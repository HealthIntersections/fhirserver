unit fhir5_xml;

{
  Copyright (c) 2011+, HL7 and Health Intersections Pty Ltd (http://www.healthintersections.com.au)
  All rights reserved.
  
  Redistribution and use in source and binary forms, with or without modification, 
  are permitted provided that the following conditions are met:
  
   * Redistributions of source code must retain the above copyright notice, this 
     list of conditions and the following disclaimer.
   * Redistributions in binary form must reproduce the above copyright notice, 
     this list of conditions and the following disclaimer in the documentation 
     and/or other materials provided with the distribution.
   * Neither the name of HL7 nor the names of its contributors may be used to 
     endorse or promote products derived from this software without specific 
     prior written permission.
  
  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND 
  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED 
  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. 
  IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, 
  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT 
  NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR 
  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, 
  WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) 
  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE 
  POSSIBILITY OF SUCH DAMAGE.
  
}

{$I fhir.inc}
{$I fhir5.inc}

interface

// Generated on Thu, Nov 10, 2022 for FHIR v5.0.0



uses
  SysUtils, Classes, 
  fsl_base, fsl_utilities, fsl_collections, fsl_xml,  
  fhir_parser, fhir_objects, 
  fhir5_parserBase, fhir5_resources, fhir5_resources_base, fhir5_constants, fhir5_base, fhir5_enums, fhir5_types;

Type

  TFHIRXmlParser = class (TFHIRXmlParserBase5)
  protected
    Procedure ParseBaseAttributes(value : TFhirBase; path : string; element : TMXmlElement); overload;
    Function ParseBaseChild(value : TFhirBase; path : string; child : TMXmlElement) : boolean;  overload;
    Procedure ParseBaseAttributes(value : TFhirResource; path : string; element : TMXmlElement);  overload;
    Function ParseBaseChild(value : TFhirResource; path : string; child : TMXmlElement) : boolean;  overload;

    Procedure ParseElementAttributes(value : TFhirElement; path : string; element : TMXmlElement);
    Function ParseElementChild(value : TFhirElement; path : string; child : TMXmlElement) : boolean;
    Procedure ParseBackboneElementAttributes(value : TFhirBackboneElement; path : string; element : TMXmlElement);
    Function ParseBackboneElementChild(value : TFhirBackboneElement; path : string; child : TMXmlElement) : boolean;
    Procedure ParseDataTypeAttributes(value : TFhirDataType; path : string; element : TMXmlElement);
    Function ParseDataTypeChild(value : TFhirDataType; path : string; child : TMXmlElement) : boolean;
    Procedure ParseBackboneTypeAttributes(value : TFhirBackboneType; path : string; element : TMXmlElement);
    Function ParseBackboneTypeChild(value : TFhirBackboneType; path : string; child : TMXmlElement) : boolean;
    Procedure ParsePrimitiveTypeAttributes(value : TFhirPrimitiveType; path : string; element : TMXmlElement);
    Function ParsePrimitiveTypeChild(value : TFhirPrimitiveType; path : string; child : TMXmlElement) : boolean;


    function ParseEnum(Const aNames, aSystems : Array Of String; element : TMXmlElement; path : String) : TFhirEnum;
    function ParseDate(element : TMXmlElement; path : string) : TFhirDate;
    function ParseDateTime(element : TMXmlElement; path : string) : TFhirDateTime;
    function ParseString(element : TMXmlElement; path : string) : TFhirString;
    function ParseInteger(element : TMXmlElement; path : string) : TFhirInteger;
    function ParseUri(element : TMXmlElement; path : string) : TFhirUri;
    function ParseInstant(element : TMXmlElement; path : string) : TFhirInstant;
    function ParseXhtml(element : TMXmlElement; path : string) : TFhirXhtml;
    function ParseBoolean(element : TMXmlElement; path : string) : TFhirBoolean;
    function ParseBase64Binary(element : TMXmlElement; path : string) : TFhirBase64Binary;
    function ParseTime(element : TMXmlElement; path : string) : TFhirTime;
    function ParseDecimal(element : TMXmlElement; path : string) : TFhirDecimal;
    function ParseCode(element : TMXmlElement; path : string) : TFhirCode;
    function ParseCanonical(element : TMXmlElement; path : string) : TFhirCanonical;
    function ParseOid(element : TMXmlElement; path : string) : TFhirOid;
    function ParseUuid(element : TMXmlElement; path : string) : TFhirUuid;
    function ParseUrl(element : TMXmlElement; path : string) : TFhirUrl;
    function ParseMarkdown(element : TMXmlElement; path : string) : TFhirMarkdown;
    function ParseUnsignedInt(element : TMXmlElement; path : string) : TFhirUnsignedInt;
    function ParseId(element : TMXmlElement; path : string) : TFhirId;
    function ParsePositiveInt(element : TMXmlElement; path : string) : TFhirPositiveInt;
    function ParseInteger64(element : TMXmlElement; path : string) : TFhirInteger64;

    function ParseAddress(element : TMXmlElement; path : string) : TFhirAddress;
    function ParseAddressChild(value : TFhirAddress; path : string; child : TMXmlElement) : boolean;
    function ParseAnnotation(element : TMXmlElement; path : string) : TFhirAnnotation;
    function ParseAnnotationChild(value : TFhirAnnotation; path : string; child : TMXmlElement) : boolean;
    function ParseAttachment(element : TMXmlElement; path : string) : TFhirAttachment;
    function ParseAttachmentChild(value : TFhirAttachment; path : string; child : TMXmlElement) : boolean;
    function ParseAvailabilityAvailableTime(element : TMXmlElement; path : string) : TFhirAvailabilityAvailableTime;
    function ParseAvailabilityAvailableTimeChild(value : TFhirAvailabilityAvailableTime; path : string; child : TMXmlElement) : boolean;
    function ParseAvailabilityNotAvailableTime(element : TMXmlElement; path : string) : TFhirAvailabilityNotAvailableTime;
    function ParseAvailabilityNotAvailableTimeChild(value : TFhirAvailabilityNotAvailableTime; path : string; child : TMXmlElement) : boolean;
    function ParseAvailability(element : TMXmlElement; path : string) : TFhirAvailability;
    function ParseAvailabilityChild(value : TFhirAvailability; path : string; child : TMXmlElement) : boolean;
    function ParseCodeableConcept(element : TMXmlElement; path : string) : TFhirCodeableConcept;
    function ParseCodeableConceptChild(value : TFhirCodeableConcept; path : string; child : TMXmlElement) : boolean;
    function ParseCodeableReference(element : TMXmlElement; path : string) : TFhirCodeableReference;
    function ParseCodeableReferenceChild(value : TFhirCodeableReference; path : string; child : TMXmlElement) : boolean;
    function ParseCoding(element : TMXmlElement; path : string) : TFhirCoding;
    function ParseCodingChild(value : TFhirCoding; path : string; child : TMXmlElement) : boolean;
    function ParseContactDetail(element : TMXmlElement; path : string) : TFhirContactDetail;
    function ParseContactDetailChild(value : TFhirContactDetail; path : string; child : TMXmlElement) : boolean;
    function ParseContactPoint(element : TMXmlElement; path : string) : TFhirContactPoint;
    function ParseContactPointChild(value : TFhirContactPoint; path : string; child : TMXmlElement) : boolean;
    function ParseContributor(element : TMXmlElement; path : string) : TFhirContributor;
    function ParseContributorChild(value : TFhirContributor; path : string; child : TMXmlElement) : boolean;
    function ParseDataRequirementCodeFilter(element : TMXmlElement; path : string) : TFhirDataRequirementCodeFilter;
    function ParseDataRequirementCodeFilterChild(value : TFhirDataRequirementCodeFilter; path : string; child : TMXmlElement) : boolean;
    function ParseDataRequirementDateFilter(element : TMXmlElement; path : string) : TFhirDataRequirementDateFilter;
    function ParseDataRequirementDateFilterChild(value : TFhirDataRequirementDateFilter; path : string; child : TMXmlElement) : boolean;
    function ParseDataRequirementValueFilter(element : TMXmlElement; path : string) : TFhirDataRequirementValueFilter;
    function ParseDataRequirementValueFilterChild(value : TFhirDataRequirementValueFilter; path : string; child : TMXmlElement) : boolean;
    function ParseDataRequirementSort(element : TMXmlElement; path : string) : TFhirDataRequirementSort;
    function ParseDataRequirementSortChild(value : TFhirDataRequirementSort; path : string; child : TMXmlElement) : boolean;
    function ParseDataRequirement(element : TMXmlElement; path : string) : TFhirDataRequirement;
    function ParseDataRequirementChild(value : TFhirDataRequirement; path : string; child : TMXmlElement) : boolean;
    function ParseExpression(element : TMXmlElement; path : string) : TFhirExpression;
    function ParseExpressionChild(value : TFhirExpression; path : string; child : TMXmlElement) : boolean;
    function ParseExtendedContactDetail(element : TMXmlElement; path : string) : TFhirExtendedContactDetail;
    function ParseExtendedContactDetailChild(value : TFhirExtendedContactDetail; path : string; child : TMXmlElement) : boolean;
    function ParseExtension(element : TMXmlElement; path : string) : TFhirExtension;
    function ParseExtensionChild(value : TFhirExtension; path : string; child : TMXmlElement) : boolean;
    function ParseHumanName(element : TMXmlElement; path : string) : TFhirHumanName;
    function ParseHumanNameChild(value : TFhirHumanName; path : string; child : TMXmlElement) : boolean;
    function ParseIdentifier(element : TMXmlElement; path : string) : TFhirIdentifier;
    function ParseIdentifierChild(value : TFhirIdentifier; path : string; child : TMXmlElement) : boolean;
    function ParseMeta(element : TMXmlElement; path : string) : TFhirMeta;
    function ParseMetaChild(value : TFhirMeta; path : string; child : TMXmlElement) : boolean;
    function ParseMonetaryComponent(element : TMXmlElement; path : string) : TFhirMonetaryComponent;
    function ParseMonetaryComponentChild(value : TFhirMonetaryComponent; path : string; child : TMXmlElement) : boolean;
    function ParseMoney(element : TMXmlElement; path : string) : TFhirMoney;
    function ParseMoneyChild(value : TFhirMoney; path : string; child : TMXmlElement) : boolean;
    function ParseNarrative(element : TMXmlElement; path : string) : TFhirNarrative;
    function ParseNarrativeChild(value : TFhirNarrative; path : string; child : TMXmlElement) : boolean;
    function ParseParameterDefinition(element : TMXmlElement; path : string) : TFhirParameterDefinition;
    function ParseParameterDefinitionChild(value : TFhirParameterDefinition; path : string; child : TMXmlElement) : boolean;
    function ParsePeriod(element : TMXmlElement; path : string) : TFhirPeriod;
    function ParsePeriodChild(value : TFhirPeriod; path : string; child : TMXmlElement) : boolean;
    function ParseQuantity(element : TMXmlElement; path : string) : TFhirQuantity;
    function ParseQuantityChild(value : TFhirQuantity; path : string; child : TMXmlElement) : boolean;
    function ParseRange(element : TMXmlElement; path : string) : TFhirRange;
    function ParseRangeChild(value : TFhirRange; path : string; child : TMXmlElement) : boolean;
    function ParseRatio(element : TMXmlElement; path : string) : TFhirRatio;
    function ParseRatioChild(value : TFhirRatio; path : string; child : TMXmlElement) : boolean;
    function ParseRatioRange(element : TMXmlElement; path : string) : TFhirRatioRange;
    function ParseRatioRangeChild(value : TFhirRatioRange; path : string; child : TMXmlElement) : boolean;
    function ParseReference(element : TMXmlElement; path : string) : TFhirReference;
    function ParseReferenceChild(value : TFhirReference; path : string; child : TMXmlElement) : boolean;
    function ParseRelatedArtifact(element : TMXmlElement; path : string) : TFhirRelatedArtifact;
    function ParseRelatedArtifactChild(value : TFhirRelatedArtifact; path : string; child : TMXmlElement) : boolean;
    function ParseSampledData(element : TMXmlElement; path : string) : TFhirSampledData;
    function ParseSampledDataChild(value : TFhirSampledData; path : string; child : TMXmlElement) : boolean;
    function ParseSignature(element : TMXmlElement; path : string) : TFhirSignature;
    function ParseSignatureChild(value : TFhirSignature; path : string; child : TMXmlElement) : boolean;
    function ParseTriggerDefinition(element : TMXmlElement; path : string) : TFhirTriggerDefinition;
    function ParseTriggerDefinitionChild(value : TFhirTriggerDefinition; path : string; child : TMXmlElement) : boolean;
    function ParseUsageContext(element : TMXmlElement; path : string) : TFhirUsageContext;
    function ParseUsageContextChild(value : TFhirUsageContext; path : string; child : TMXmlElement) : boolean;
    function ParseVirtualServiceDetail(element : TMXmlElement; path : string) : TFhirVirtualServiceDetail;
    function ParseVirtualServiceDetailChild(value : TFhirVirtualServiceDetail; path : string; child : TMXmlElement) : boolean;
    function ParseAge(element : TMXmlElement; path : string) : TFhirAge;
    function ParseAgeChild(value : TFhirAge; path : string; child : TMXmlElement) : boolean;
    function ParseCount(element : TMXmlElement; path : string) : TFhirCount;
    function ParseCountChild(value : TFhirCount; path : string; child : TMXmlElement) : boolean;
    function ParseDistance(element : TMXmlElement; path : string) : TFhirDistance;
    function ParseDistanceChild(value : TFhirDistance; path : string; child : TMXmlElement) : boolean;
    function ParseDosageDoseAndRate(element : TMXmlElement; path : string) : TFhirDosageDoseAndRate;
    function ParseDosageDoseAndRateChild(value : TFhirDosageDoseAndRate; path : string; child : TMXmlElement) : boolean;
    function ParseDosage(element : TMXmlElement; path : string) : TFhirDosage;
    function ParseDosageChild(value : TFhirDosage; path : string; child : TMXmlElement) : boolean;
    function ParseDuration(element : TMXmlElement; path : string) : TFhirDuration;
    function ParseDurationChild(value : TFhirDuration; path : string; child : TMXmlElement) : boolean;
    function ParseElementDefinitionSlicing(element : TMXmlElement; path : string) : TFhirElementDefinitionSlicing;
    function ParseElementDefinitionSlicingChild(value : TFhirElementDefinitionSlicing; path : string; child : TMXmlElement) : boolean;
    function ParseElementDefinitionSlicingDiscriminator(element : TMXmlElement; path : string) : TFhirElementDefinitionSlicingDiscriminator;
    function ParseElementDefinitionSlicingDiscriminatorChild(value : TFhirElementDefinitionSlicingDiscriminator; path : string; child : TMXmlElement) : boolean;
    function ParseElementDefinitionBase(element : TMXmlElement; path : string) : TFhirElementDefinitionBase;
    function ParseElementDefinitionBaseChild(value : TFhirElementDefinitionBase; path : string; child : TMXmlElement) : boolean;
    function ParseElementDefinitionType(element : TMXmlElement; path : string) : TFhirElementDefinitionType;
    function ParseElementDefinitionTypeChild(value : TFhirElementDefinitionType; path : string; child : TMXmlElement) : boolean;
    function ParseElementDefinitionExample(element : TMXmlElement; path : string) : TFhirElementDefinitionExample;
    function ParseElementDefinitionExampleChild(value : TFhirElementDefinitionExample; path : string; child : TMXmlElement) : boolean;
    function ParseElementDefinitionConstraint(element : TMXmlElement; path : string) : TFhirElementDefinitionConstraint;
    function ParseElementDefinitionConstraintChild(value : TFhirElementDefinitionConstraint; path : string; child : TMXmlElement) : boolean;
    function ParseElementDefinitionBinding(element : TMXmlElement; path : string) : TFhirElementDefinitionBinding;
    function ParseElementDefinitionBindingChild(value : TFhirElementDefinitionBinding; path : string; child : TMXmlElement) : boolean;
    function ParseElementDefinitionMapping(element : TMXmlElement; path : string) : TFhirElementDefinitionMapping;
    function ParseElementDefinitionMappingChild(value : TFhirElementDefinitionMapping; path : string; child : TMXmlElement) : boolean;
    function ParseElementDefinition(element : TMXmlElement; path : string) : TFhirElementDefinition;
    function ParseElementDefinitionChild(value : TFhirElementDefinition; path : string; child : TMXmlElement) : boolean;
    function ParseMarketingStatus(element : TMXmlElement; path : string) : TFhirMarketingStatus;
    function ParseMarketingStatusChild(value : TFhirMarketingStatus; path : string; child : TMXmlElement) : boolean;
    function ParsePopulation(element : TMXmlElement; path : string) : TFhirPopulation;
    function ParsePopulationChild(value : TFhirPopulation; path : string; child : TMXmlElement) : boolean;
    function ParseProductShelfLife(element : TMXmlElement; path : string) : TFhirProductShelfLife;
    function ParseProductShelfLifeChild(value : TFhirProductShelfLife; path : string; child : TMXmlElement) : boolean;
    function ParseTimingRepeat(element : TMXmlElement; path : string) : TFhirTimingRepeat;
    function ParseTimingRepeatChild(value : TFhirTimingRepeat; path : string; child : TMXmlElement) : boolean;
    function ParseTiming(element : TMXmlElement; path : string) : TFhirTiming;
    function ParseTimingChild(value : TFhirTiming; path : string; child : TMXmlElement) : boolean;


    Procedure ParseResourceAttributes(value : TFhirResource; path : string; element : TMXmlElement);
    Function ParseResourceChild(value : TFhirResource; path : string; child : TMXmlElement) : boolean;
    Procedure ParseDomainResourceAttributes(value : TFhirDomainResource; path : string; element : TMXmlElement);
    Function ParseDomainResourceChild(value : TFhirDomainResource; path : string; child : TMXmlElement) : boolean;
    Procedure ParseCanonicalResourceAttributes(value : TFhirCanonicalResource; path : string; element : TMXmlElement);
    Function ParseCanonicalResourceChild(value : TFhirCanonicalResource; path : string; child : TMXmlElement) : boolean;
    Procedure ParseMetadataResourceAttributes(value : TFhirMetadataResource; path : string; element : TMXmlElement);
    Function ParseMetadataResourceChild(value : TFhirMetadataResource; path : string; child : TMXmlElement) : boolean;


{$IFDEF FHIR_ACCOUNT}
    function ParseAccountCoverage(element : TMXmlElement; path : string) : TFhirAccountCoverage;
    function ParseAccountCoverageChild(value : TFhirAccountCoverage; path : string; child : TMXmlElement) : boolean;
    function ParseAccountGuarantor(element : TMXmlElement; path : string) : TFhirAccountGuarantor;
    function ParseAccountGuarantorChild(value : TFhirAccountGuarantor; path : string; child : TMXmlElement) : boolean;
    function ParseAccountRelatedAccount(element : TMXmlElement; path : string) : TFhirAccountRelatedAccount;
    function ParseAccountRelatedAccountChild(value : TFhirAccountRelatedAccount; path : string; child : TMXmlElement) : boolean;
    function ParseAccountBalance(element : TMXmlElement; path : string) : TFhirAccountBalance;
    function ParseAccountBalanceChild(value : TFhirAccountBalance; path : string; child : TMXmlElement) : boolean;
    function ParseAccount(element : TMXmlElement; path : string) : TFhirAccount;
    function ParseAccountChild(value : TFhirAccount; path : string; child : TMXmlElement) : boolean;
{$ENDIF FHIR_ACCOUNT}
{$IFDEF FHIR_ACTIVITYDEFINITION}
    function ParseActivityDefinitionParticipant(element : TMXmlElement; path : string) : TFhirActivityDefinitionParticipant;
    function ParseActivityDefinitionParticipantChild(value : TFhirActivityDefinitionParticipant; path : string; child : TMXmlElement) : boolean;
    function ParseActivityDefinitionDynamicValue(element : TMXmlElement; path : string) : TFhirActivityDefinitionDynamicValue;
    function ParseActivityDefinitionDynamicValueChild(value : TFhirActivityDefinitionDynamicValue; path : string; child : TMXmlElement) : boolean;
    function ParseActivityDefinition(element : TMXmlElement; path : string) : TFhirActivityDefinition;
    function ParseActivityDefinitionChild(value : TFhirActivityDefinition; path : string; child : TMXmlElement) : boolean;
{$ENDIF FHIR_ACTIVITYDEFINITION}
{$IFDEF FHIR_ACTORDEFINITION}
    function ParseActorDefinition(element : TMXmlElement; path : string) : TFhirActorDefinition;
    function ParseActorDefinitionChild(value : TFhirActorDefinition; path : string; child : TMXmlElement) : boolean;
{$ENDIF FHIR_ACTORDEFINITION}
{$IFDEF FHIR_ADMINISTRABLEPRODUCTDEFINITION}
    function ParseAdministrableProductDefinitionProperty(element : TMXmlElement; path : string) : TFhirAdministrableProductDefinitionProperty;
    function ParseAdministrableProductDefinitionPropertyChild(value : TFhirAdministrableProductDefinitionProperty; path : string; child : TMXmlElement) : boolean;
    function ParseAdministrableProductDefinitionRouteOfAdministration(element : TMXmlElement; path : string) : TFhirAdministrableProductDefinitionRouteOfAdministration;
    function ParseAdministrableProductDefinitionRouteOfAdministrationChild(value : TFhirAdministrableProductDefinitionRouteOfAdministration; path : string; child : TMXmlElement) : boolean;
    function ParseAdministrableProductDefinitionRouteOfAdministrationTargetSpecies(element : TMXmlElement; path : string) : TFhirAdministrableProductDefinitionRouteOfAdministrationTargetSpecies;
    function ParseAdministrableProductDefinitionRouteOfAdministrationTargetSpeciesChild(value : TFhirAdministrableProductDefinitionRouteOfAdministrationTargetSpecies; path : string; child : TMXmlElement) : boolean;
    function ParseAdministrableProductDefinitionRouteOfAdministrationTargetSpeciesWithdrawalPeriod(element : TMXmlElement; path : string) : TFhirAdministrableProductDefinitionRouteOfAdministrationTargetSpeciesWithdrawalPeriod;
    function ParseAdministrableProductDefinitionRouteOfAdministrationTargetSpeciesWithdrawalPeriodChild(value : TFhirAdministrableProductDefinitionRouteOfAdministrationTargetSpeciesWithdrawalPeriod; path : string; child : TMXmlElement) : boolean;
    function ParseAdministrableProductDefinition(element : TMXmlElement; path : string) : TFhirAdministrableProductDefinition;
    function ParseAdministrableProductDefinitionChild(value : TFhirAdministrableProductDefinition; path : string; child : TMXmlElement) : boolean;
{$ENDIF FHIR_ADMINISTRABLEPRODUCTDEFINITION}
{$IFDEF FHIR_ADVERSEEVENT}
    function ParseAdverseEventParticipant(element : TMXmlElement; path : string) : TFhirAdverseEventParticipant;
    function ParseAdverseEventParticipantChild(value : TFhirAdverseEventParticipant; path : string; child : TMXmlElement) : boolean;
    function ParseAdverseEventSuspectEntity(element : TMXmlElement; path : string) : TFhirAdverseEventSuspectEntity;
    function ParseAdverseEventSuspectEntityChild(value : TFhirAdverseEventSuspectEntity; path : string; child : TMXmlElement) : boolean;
    function ParseAdverseEventSuspectEntityCausality(element : TMXmlElement; path : string) : TFhirAdverseEventSuspectEntityCausality;
    function ParseAdverseEventSuspectEntityCausalityChild(value : TFhirAdverseEventSuspectEntityCausality; path : string; child : TMXmlElement) : boolean;
    function ParseAdverseEventContributingFactor(element : TMXmlElement; path : string) : TFhirAdverseEventContributingFactor;
    function ParseAdverseEventContributingFactorChild(value : TFhirAdverseEventContributingFactor; path : string; child : TMXmlElement) : boolean;
    function ParseAdverseEventPreventiveAction(element : TMXmlElement; path : string) : TFhirAdverseEventPreventiveAction;
    function ParseAdverseEventPreventiveActionChild(value : TFhirAdverseEventPreventiveAction; path : string; child : TMXmlElement) : boolean;
    function ParseAdverseEventMitigatingAction(element : TMXmlElement; path : string) : TFhirAdverseEventMitigatingAction;
    function ParseAdverseEventMitigatingActionChild(value : TFhirAdverseEventMitigatingAction; path : string; child : TMXmlElement) : boolean;
    function ParseAdverseEventSupportingInfo(element : TMXmlElement; path : string) : TFhirAdverseEventSupportingInfo;
    function ParseAdverseEventSupportingInfoChild(value : TFhirAdverseEventSupportingInfo; path : string; child : TMXmlElement) : boolean;
    function ParseAdverseEvent(element : TMXmlElement; path : string) : TFhirAdverseEvent;
    function ParseAdverseEventChild(value : TFhirAdverseEvent; path : string; child : TMXmlElement) : boolean;
{$ENDIF FHIR_ADVERSEEVENT}
{$IFDEF FHIR_ALLERGYINTOLERANCE}
    function ParseAllergyIntoleranceParticipant(element : TMXmlElement; path : string) : TFhirAllergyIntoleranceParticipant;
    function ParseAllergyIntoleranceParticipantChild(value : TFhirAllergyIntoleranceParticipant; path : string; child : TMXmlElement) : boolean;
    function ParseAllergyIntoleranceReaction(element : TMXmlElement; path : string) : TFhirAllergyIntoleranceReaction;
    function ParseAllergyIntoleranceReactionChild(value : TFhirAllergyIntoleranceReaction; path : string; child : TMXmlElement) : boolean;
    function ParseAllergyIntolerance(element : TMXmlElement; path : string) : TFhirAllergyIntolerance;
    function ParseAllergyIntoleranceChild(value : TFhirAllergyIntolerance; path : string; child : TMXmlElement) : boolean;
{$ENDIF FHIR_ALLERGYINTOLERANCE}
{$IFDEF FHIR_APPOINTMENT}
    function ParseAppointmentParticipant(element : TMXmlElement; path : string) : TFhirAppointmentParticipant;
    function ParseAppointmentParticipantChild(value : TFhirAppointmentParticipant; path : string; child : TMXmlElement) : boolean;
    function ParseAppointmentRecurrenceTemplate(element : TMXmlElement; path : string) : TFhirAppointmentRecurrenceTemplate;
    function ParseAppointmentRecurrenceTemplateChild(value : TFhirAppointmentRecurrenceTemplate; path : string; child : TMXmlElement) : boolean;
    function ParseAppointmentRecurrenceTemplateWeeklyTemplate(element : TMXmlElement; path : string) : TFhirAppointmentRecurrenceTemplateWeeklyTemplate;
    function ParseAppointmentRecurrenceTemplateWeeklyTemplateChild(value : TFhirAppointmentRecurrenceTemplateWeeklyTemplate; path : string; child : TMXmlElement) : boolean;
    function ParseAppointmentRecurrenceTemplateMonthlyTemplate(element : TMXmlElement; path : string) : TFhirAppointmentRecurrenceTemplateMonthlyTemplate;
    function ParseAppointmentRecurrenceTemplateMonthlyTemplateChild(value : TFhirAppointmentRecurrenceTemplateMonthlyTemplate; path : string; child : TMXmlElement) : boolean;
    function ParseAppointmentRecurrenceTemplateYearlyTemplate(element : TMXmlElement; path : string) : TFhirAppointmentRecurrenceTemplateYearlyTemplate;
    function ParseAppointmentRecurrenceTemplateYearlyTemplateChild(value : TFhirAppointmentRecurrenceTemplateYearlyTemplate; path : string; child : TMXmlElement) : boolean;
    function ParseAppointment(element : TMXmlElement; path : string) : TFhirAppointment;
    function ParseAppointmentChild(value : TFhirAppointment; path : string; child : TMXmlElement) : boolean;
{$ENDIF FHIR_APPOINTMENT}
{$IFDEF FHIR_APPOINTMENTRESPONSE}
    function ParseAppointmentResponse(element : TMXmlElement; path : string) : TFhirAppointmentResponse;
    function ParseAppointmentResponseChild(value : TFhirAppointmentResponse; path : string; child : TMXmlElement) : boolean;
{$ENDIF FHIR_APPOINTMENTRESPONSE}
{$IFDEF FHIR_ARTIFACTASSESSMENT}
    function ParseArtifactAssessmentContent(element : TMXmlElement; path : string) : TFhirArtifactAssessmentContent;
    function ParseArtifactAssessmentContentChild(value : TFhirArtifactAssessmentContent; path : string; child : TMXmlElement) : boolean;
    function ParseArtifactAssessment(element : TMXmlElement; path : string) : TFhirArtifactAssessment;
    function ParseArtifactAssessmentChild(value : TFhirArtifactAssessment; path : string; child : TMXmlElement) : boolean;
{$ENDIF FHIR_ARTIFACTASSESSMENT}
{$IFDEF FHIR_AUDITEVENT}
    function ParseAuditEventOutcome(element : TMXmlElement; path : string) : TFhirAuditEventOutcome;
    function ParseAuditEventOutcomeChild(value : TFhirAuditEventOutcome; path : string; child : TMXmlElement) : boolean;
    function ParseAuditEventAgent(element : TMXmlElement; path : string) : TFhirAuditEventAgent;
    function ParseAuditEventAgentChild(value : TFhirAuditEventAgent; path : string; child : TMXmlElement) : boolean;
    function ParseAuditEventSource(element : TMXmlElement; path : string) : TFhirAuditEventSource;
    function ParseAuditEventSourceChild(value : TFhirAuditEventSource; path : string; child : TMXmlElement) : boolean;
    function ParseAuditEventEntity(element : TMXmlElement; path : string) : TFhirAuditEventEntity;
    function ParseAuditEventEntityChild(value : TFhirAuditEventEntity; path : string; child : TMXmlElement) : boolean;
    function ParseAuditEventEntityDetail(element : TMXmlElement; path : string) : TFhirAuditEventEntityDetail;
    function ParseAuditEventEntityDetailChild(value : TFhirAuditEventEntityDetail; path : string; child : TMXmlElement) : boolean;
    function ParseAuditEvent(element : TMXmlElement; path : string) : TFhirAuditEvent;
    function ParseAuditEventChild(value : TFhirAuditEvent; path : string; child : TMXmlElement) : boolean;
{$ENDIF FHIR_AUDITEVENT}
{$IFDEF FHIR_BASIC}
    function ParseBasic(element : TMXmlElement; path : string) : TFhirBasic;
    function ParseBasicChild(value : TFhirBasic; path : string; child : TMXmlElement) : boolean;
{$ENDIF FHIR_BASIC}
{$IFDEF FHIR_BINARY}
    function ParseBinary(element : TMXmlElement; path : string) : TFhirBinary;
    function ParseBinaryChild(value : TFhirBinary; path : string; child : TMXmlElement) : boolean;
{$ENDIF FHIR_BINARY}
{$IFDEF FHIR_BIOLOGICALLYDERIVEDPRODUCT}
    function ParseBiologicallyDerivedProductCollection(element : TMXmlElement; path : string) : TFhirBiologicallyDerivedProductCollection;
    function ParseBiologicallyDerivedProductCollectionChild(value : TFhirBiologicallyDerivedProductCollection; path : string; child : TMXmlElement) : boolean;
    function ParseBiologicallyDerivedProductProperty(element : TMXmlElement; path : string) : TFhirBiologicallyDerivedProductProperty;
    function ParseBiologicallyDerivedProductPropertyChild(value : TFhirBiologicallyDerivedProductProperty; path : string; child : TMXmlElement) : boolean;
    function ParseBiologicallyDerivedProduct(element : TMXmlElement; path : string) : TFhirBiologicallyDerivedProduct;
    function ParseBiologicallyDerivedProductChild(value : TFhirBiologicallyDerivedProduct; path : string; child : TMXmlElement) : boolean;
{$ENDIF FHIR_BIOLOGICALLYDERIVEDPRODUCT}
{$IFDEF FHIR_BODYSTRUCTURE}
    function ParseBodyStructureIncludedStructure(element : TMXmlElement; path : string) : TFhirBodyStructureIncludedStructure;
    function ParseBodyStructureIncludedStructureChild(value : TFhirBodyStructureIncludedStructure; path : string; child : TMXmlElement) : boolean;
    function ParseBodyStructureExcludedStructure(element : TMXmlElement; path : string) : TFhirBodyStructureExcludedStructure;
    function ParseBodyStructureExcludedStructureChild(value : TFhirBodyStructureExcludedStructure; path : string; child : TMXmlElement) : boolean;
    function ParseBodyStructure(element : TMXmlElement; path : string) : TFhirBodyStructure;
    function ParseBodyStructureChild(value : TFhirBodyStructure; path : string; child : TMXmlElement) : boolean;
{$ENDIF FHIR_BODYSTRUCTURE}
{$IFDEF FHIR_BUNDLE}
    function ParseBundleLink(element : TMXmlElement; path : string) : TFhirBundleLink;
    function ParseBundleLinkChild(value : TFhirBundleLink; path : string; child : TMXmlElement) : boolean;
    function ParseBundleEntry(element : TMXmlElement; path : string) : TFhirBundleEntry;
    function ParseBundleEntryChild(value : TFhirBundleEntry; path : string; child : TMXmlElement) : boolean;
    function ParseBundleEntrySearch(element : TMXmlElement; path : string) : TFhirBundleEntrySearch;
    function ParseBundleEntrySearchChild(value : TFhirBundleEntrySearch; path : string; child : TMXmlElement) : boolean;
    function ParseBundleEntryRequest(element : TMXmlElement; path : string) : TFhirBundleEntryRequest;
    function ParseBundleEntryRequestChild(value : TFhirBundleEntryRequest; path : string; child : TMXmlElement) : boolean;
    function ParseBundleEntryResponse(element : TMXmlElement; path : string) : TFhirBundleEntryResponse;
    function ParseBundleEntryResponseChild(value : TFhirBundleEntryResponse; path : string; child : TMXmlElement) : boolean;
    function ParseBundle(element : TMXmlElement; path : string) : TFhirBundle;
    function ParseBundleChild(value : TFhirBundle; path : string; child : TMXmlElement) : boolean;
{$ENDIF FHIR_BUNDLE}
{$IFDEF FHIR_CAPABILITYSTATEMENT}
    function ParseCapabilityStatementSoftware(element : TMXmlElement; path : string) : TFhirCapabilityStatementSoftware;
    function ParseCapabilityStatementSoftwareChild(value : TFhirCapabilityStatementSoftware; path : string; child : TMXmlElement) : boolean;
    function ParseCapabilityStatementImplementation(element : TMXmlElement; path : string) : TFhirCapabilityStatementImplementation;
    function ParseCapabilityStatementImplementationChild(value : TFhirCapabilityStatementImplementation; path : string; child : TMXmlElement) : boolean;
    function ParseCapabilityStatementRest(element : TMXmlElement; path : string) : TFhirCapabilityStatementRest;
    function ParseCapabilityStatementRestChild(value : TFhirCapabilityStatementRest; path : string; child : TMXmlElement) : boolean;
    function ParseCapabilityStatementRestSecurity(element : TMXmlElement; path : string) : TFhirCapabilityStatementRestSecurity;
    function ParseCapabilityStatementRestSecurityChild(value : TFhirCapabilityStatementRestSecurity; path : string; child : TMXmlElement) : boolean;
    function ParseCapabilityStatementRestResource(element : TMXmlElement; path : string) : TFhirCapabilityStatementRestResource;
    function ParseCapabilityStatementRestResourceChild(value : TFhirCapabilityStatementRestResource; path : string; child : TMXmlElement) : boolean;
    function ParseCapabilityStatementRestResourceInteraction(element : TMXmlElement; path : string) : TFhirCapabilityStatementRestResourceInteraction;
    function ParseCapabilityStatementRestResourceInteractionChild(value : TFhirCapabilityStatementRestResourceInteraction; path : string; child : TMXmlElement) : boolean;
    function ParseCapabilityStatementRestResourceSearchParam(element : TMXmlElement; path : string) : TFhirCapabilityStatementRestResourceSearchParam;
    function ParseCapabilityStatementRestResourceSearchParamChild(value : TFhirCapabilityStatementRestResourceSearchParam; path : string; child : TMXmlElement) : boolean;
    function ParseCapabilityStatementRestResourceOperation(element : TMXmlElement; path : string) : TFhirCapabilityStatementRestResourceOperation;
    function ParseCapabilityStatementRestResourceOperationChild(value : TFhirCapabilityStatementRestResourceOperation; path : string; child : TMXmlElement) : boolean;
    function ParseCapabilityStatementRestInteraction(element : TMXmlElement; path : string) : TFhirCapabilityStatementRestInteraction;
    function ParseCapabilityStatementRestInteractionChild(value : TFhirCapabilityStatementRestInteraction; path : string; child : TMXmlElement) : boolean;
    function ParseCapabilityStatementMessaging(element : TMXmlElement; path : string) : TFhirCapabilityStatementMessaging;
    function ParseCapabilityStatementMessagingChild(value : TFhirCapabilityStatementMessaging; path : string; child : TMXmlElement) : boolean;
    function ParseCapabilityStatementMessagingEndpoint(element : TMXmlElement; path : string) : TFhirCapabilityStatementMessagingEndpoint;
    function ParseCapabilityStatementMessagingEndpointChild(value : TFhirCapabilityStatementMessagingEndpoint; path : string; child : TMXmlElement) : boolean;
    function ParseCapabilityStatementMessagingSupportedMessage(element : TMXmlElement; path : string) : TFhirCapabilityStatementMessagingSupportedMessage;
    function ParseCapabilityStatementMessagingSupportedMessageChild(value : TFhirCapabilityStatementMessagingSupportedMessage; path : string; child : TMXmlElement) : boolean;
    function ParseCapabilityStatementDocument(element : TMXmlElement; path : string) : TFhirCapabilityStatementDocument;
    function ParseCapabilityStatementDocumentChild(value : TFhirCapabilityStatementDocument; path : string; child : TMXmlElement) : boolean;
    function ParseCapabilityStatement(element : TMXmlElement; path : string) : TFhirCapabilityStatement;
    function ParseCapabilityStatementChild(value : TFhirCapabilityStatement; path : string; child : TMXmlElement) : boolean;
{$ENDIF FHIR_CAPABILITYSTATEMENT}
{$IFDEF FHIR_CAREPLAN}
    function ParseCarePlanActivity(element : TMXmlElement; path : string) : TFhirCarePlanActivity;
    function ParseCarePlanActivityChild(value : TFhirCarePlanActivity; path : string; child : TMXmlElement) : boolean;
    function ParseCarePlanActivityPlannedActivityDetail(element : TMXmlElement; path : string) : TFhirCarePlanActivityPlannedActivityDetail;
    function ParseCarePlanActivityPlannedActivityDetailChild(value : TFhirCarePlanActivityPlannedActivityDetail; path : string; child : TMXmlElement) : boolean;
    function ParseCarePlan(element : TMXmlElement; path : string) : TFhirCarePlan;
    function ParseCarePlanChild(value : TFhirCarePlan; path : string; child : TMXmlElement) : boolean;
{$ENDIF FHIR_CAREPLAN}
{$IFDEF FHIR_CARETEAM}
    function ParseCareTeamParticipant(element : TMXmlElement; path : string) : TFhirCareTeamParticipant;
    function ParseCareTeamParticipantChild(value : TFhirCareTeamParticipant; path : string; child : TMXmlElement) : boolean;
    function ParseCareTeam(element : TMXmlElement; path : string) : TFhirCareTeam;
    function ParseCareTeamChild(value : TFhirCareTeam; path : string; child : TMXmlElement) : boolean;
{$ENDIF FHIR_CARETEAM}
{$IFDEF FHIR_CHARGEITEM}
    function ParseChargeItemPerformer(element : TMXmlElement; path : string) : TFhirChargeItemPerformer;
    function ParseChargeItemPerformerChild(value : TFhirChargeItemPerformer; path : string; child : TMXmlElement) : boolean;
    function ParseChargeItem(element : TMXmlElement; path : string) : TFhirChargeItem;
    function ParseChargeItemChild(value : TFhirChargeItem; path : string; child : TMXmlElement) : boolean;
{$ENDIF FHIR_CHARGEITEM}
{$IFDEF FHIR_CHARGEITEMDEFINITION}
    function ParseChargeItemDefinitionApplicability(element : TMXmlElement; path : string) : TFhirChargeItemDefinitionApplicability;
    function ParseChargeItemDefinitionApplicabilityChild(value : TFhirChargeItemDefinitionApplicability; path : string; child : TMXmlElement) : boolean;
    function ParseChargeItemDefinitionPropertyGroup(element : TMXmlElement; path : string) : TFhirChargeItemDefinitionPropertyGroup;
    function ParseChargeItemDefinitionPropertyGroupChild(value : TFhirChargeItemDefinitionPropertyGroup; path : string; child : TMXmlElement) : boolean;
    function ParseChargeItemDefinition(element : TMXmlElement; path : string) : TFhirChargeItemDefinition;
    function ParseChargeItemDefinitionChild(value : TFhirChargeItemDefinition; path : string; child : TMXmlElement) : boolean;
{$ENDIF FHIR_CHARGEITEMDEFINITION}
{$IFDEF FHIR_CITATION}
    function ParseCitationSummary(element : TMXmlElement; path : string) : TFhirCitationSummary;
    function ParseCitationSummaryChild(value : TFhirCitationSummary; path : string; child : TMXmlElement) : boolean;
    function ParseCitationClassification(element : TMXmlElement; path : string) : TFhirCitationClassification;
    function ParseCitationClassificationChild(value : TFhirCitationClassification; path : string; child : TMXmlElement) : boolean;
    function ParseCitationStatusDate(element : TMXmlElement; path : string) : TFhirCitationStatusDate;
    function ParseCitationStatusDateChild(value : TFhirCitationStatusDate; path : string; child : TMXmlElement) : boolean;
    function ParseCitationCitedArtifact(element : TMXmlElement; path : string) : TFhirCitationCitedArtifact;
    function ParseCitationCitedArtifactChild(value : TFhirCitationCitedArtifact; path : string; child : TMXmlElement) : boolean;
    function ParseCitationCitedArtifactVersion(element : TMXmlElement; path : string) : TFhirCitationCitedArtifactVersion;
    function ParseCitationCitedArtifactVersionChild(value : TFhirCitationCitedArtifactVersion; path : string; child : TMXmlElement) : boolean;
    function ParseCitationCitedArtifactStatusDate(element : TMXmlElement; path : string) : TFhirCitationCitedArtifactStatusDate;
    function ParseCitationCitedArtifactStatusDateChild(value : TFhirCitationCitedArtifactStatusDate; path : string; child : TMXmlElement) : boolean;
    function ParseCitationCitedArtifactTitle(element : TMXmlElement; path : string) : TFhirCitationCitedArtifactTitle;
    function ParseCitationCitedArtifactTitleChild(value : TFhirCitationCitedArtifactTitle; path : string; child : TMXmlElement) : boolean;
    function ParseCitationCitedArtifactAbstract(element : TMXmlElement; path : string) : TFhirCitationCitedArtifactAbstract;
    function ParseCitationCitedArtifactAbstractChild(value : TFhirCitationCitedArtifactAbstract; path : string; child : TMXmlElement) : boolean;
    function ParseCitationCitedArtifactPart(element : TMXmlElement; path : string) : TFhirCitationCitedArtifactPart;
    function ParseCitationCitedArtifactPartChild(value : TFhirCitationCitedArtifactPart; path : string; child : TMXmlElement) : boolean;
    function ParseCitationCitedArtifactRelatesTo(element : TMXmlElement; path : string) : TFhirCitationCitedArtifactRelatesTo;
    function ParseCitationCitedArtifactRelatesToChild(value : TFhirCitationCitedArtifactRelatesTo; path : string; child : TMXmlElement) : boolean;
    function ParseCitationCitedArtifactPublicationForm(element : TMXmlElement; path : string) : TFhirCitationCitedArtifactPublicationForm;
    function ParseCitationCitedArtifactPublicationFormChild(value : TFhirCitationCitedArtifactPublicationForm; path : string; child : TMXmlElement) : boolean;
    function ParseCitationCitedArtifactPublicationFormPublishedIn(element : TMXmlElement; path : string) : TFhirCitationCitedArtifactPublicationFormPublishedIn;
    function ParseCitationCitedArtifactPublicationFormPublishedInChild(value : TFhirCitationCitedArtifactPublicationFormPublishedIn; path : string; child : TMXmlElement) : boolean;
    function ParseCitationCitedArtifactWebLocation(element : TMXmlElement; path : string) : TFhirCitationCitedArtifactWebLocation;
    function ParseCitationCitedArtifactWebLocationChild(value : TFhirCitationCitedArtifactWebLocation; path : string; child : TMXmlElement) : boolean;
    function ParseCitationCitedArtifactClassification(element : TMXmlElement; path : string) : TFhirCitationCitedArtifactClassification;
    function ParseCitationCitedArtifactClassificationChild(value : TFhirCitationCitedArtifactClassification; path : string; child : TMXmlElement) : boolean;
    function ParseCitationCitedArtifactContributorship(element : TMXmlElement; path : string) : TFhirCitationCitedArtifactContributorship;
    function ParseCitationCitedArtifactContributorshipChild(value : TFhirCitationCitedArtifactContributorship; path : string; child : TMXmlElement) : boolean;
    function ParseCitationCitedArtifactContributorshipEntry(element : TMXmlElement; path : string) : TFhirCitationCitedArtifactContributorshipEntry;
    function ParseCitationCitedArtifactContributorshipEntryChild(value : TFhirCitationCitedArtifactContributorshipEntry; path : string; child : TMXmlElement) : boolean;
    function ParseCitationCitedArtifactContributorshipEntryContributionInstance(element : TMXmlElement; path : string) : TFhirCitationCitedArtifactContributorshipEntryContributionInstance;
    function ParseCitationCitedArtifactContributorshipEntryContributionInstanceChild(value : TFhirCitationCitedArtifactContributorshipEntryContributionInstance; path : string; child : TMXmlElement) : boolean;
    function ParseCitationCitedArtifactContributorshipSummary(element : TMXmlElement; path : string) : TFhirCitationCitedArtifactContributorshipSummary;
    function ParseCitationCitedArtifactContributorshipSummaryChild(value : TFhirCitationCitedArtifactContributorshipSummary; path : string; child : TMXmlElement) : boolean;
    function ParseCitation(element : TMXmlElement; path : string) : TFhirCitation;
    function ParseCitationChild(value : TFhirCitation; path : string; child : TMXmlElement) : boolean;
{$ENDIF FHIR_CITATION}
{$IFDEF FHIR_CLAIM}
    function ParseClaimRelated(element : TMXmlElement; path : string) : TFhirClaimRelated;
    function ParseClaimRelatedChild(value : TFhirClaimRelated; path : string; child : TMXmlElement) : boolean;
    function ParseClaimPayee(element : TMXmlElement; path : string) : TFhirClaimPayee;
    function ParseClaimPayeeChild(value : TFhirClaimPayee; path : string; child : TMXmlElement) : boolean;
    function ParseClaimCareTeam(element : TMXmlElement; path : string) : TFhirClaimCareTeam;
    function ParseClaimCareTeamChild(value : TFhirClaimCareTeam; path : string; child : TMXmlElement) : boolean;
    function ParseClaimSupportingInfo(element : TMXmlElement; path : string) : TFhirClaimSupportingInfo;
    function ParseClaimSupportingInfoChild(value : TFhirClaimSupportingInfo; path : string; child : TMXmlElement) : boolean;
    function ParseClaimDiagnosis(element : TMXmlElement; path : string) : TFhirClaimDiagnosis;
    function ParseClaimDiagnosisChild(value : TFhirClaimDiagnosis; path : string; child : TMXmlElement) : boolean;
    function ParseClaimProcedure(element : TMXmlElement; path : string) : TFhirClaimProcedure;
    function ParseClaimProcedureChild(value : TFhirClaimProcedure; path : string; child : TMXmlElement) : boolean;
    function ParseClaimInsurance(element : TMXmlElement; path : string) : TFhirClaimInsurance;
    function ParseClaimInsuranceChild(value : TFhirClaimInsurance; path : string; child : TMXmlElement) : boolean;
    function ParseClaimAccident(element : TMXmlElement; path : string) : TFhirClaimAccident;
    function ParseClaimAccidentChild(value : TFhirClaimAccident; path : string; child : TMXmlElement) : boolean;
    function ParseClaimItem(element : TMXmlElement; path : string) : TFhirClaimItem;
    function ParseClaimItemChild(value : TFhirClaimItem; path : string; child : TMXmlElement) : boolean;
    function ParseClaimItemBodySite(element : TMXmlElement; path : string) : TFhirClaimItemBodySite;
    function ParseClaimItemBodySiteChild(value : TFhirClaimItemBodySite; path : string; child : TMXmlElement) : boolean;
    function ParseClaimItemDetail(element : TMXmlElement; path : string) : TFhirClaimItemDetail;
    function ParseClaimItemDetailChild(value : TFhirClaimItemDetail; path : string; child : TMXmlElement) : boolean;
    function ParseClaimItemDetailSubDetail(element : TMXmlElement; path : string) : TFhirClaimItemDetailSubDetail;
    function ParseClaimItemDetailSubDetailChild(value : TFhirClaimItemDetailSubDetail; path : string; child : TMXmlElement) : boolean;
    function ParseClaim(element : TMXmlElement; path : string) : TFhirClaim;
    function ParseClaimChild(value : TFhirClaim; path : string; child : TMXmlElement) : boolean;
{$ENDIF FHIR_CLAIM}
{$IFDEF FHIR_CLAIMRESPONSE}
    function ParseClaimResponseItem(element : TMXmlElement; path : string) : TFhirClaimResponseItem;
    function ParseClaimResponseItemChild(value : TFhirClaimResponseItem; path : string; child : TMXmlElement) : boolean;
    function ParseClaimResponseItemAdjudication(element : TMXmlElement; path : string) : TFhirClaimResponseItemAdjudication;
    function ParseClaimResponseItemAdjudicationChild(value : TFhirClaimResponseItemAdjudication; path : string; child : TMXmlElement) : boolean;
    function ParseClaimResponseItemDetail(element : TMXmlElement; path : string) : TFhirClaimResponseItemDetail;
    function ParseClaimResponseItemDetailChild(value : TFhirClaimResponseItemDetail; path : string; child : TMXmlElement) : boolean;
    function ParseClaimResponseItemDetailSubDetail(element : TMXmlElement; path : string) : TFhirClaimResponseItemDetailSubDetail;
    function ParseClaimResponseItemDetailSubDetailChild(value : TFhirClaimResponseItemDetailSubDetail; path : string; child : TMXmlElement) : boolean;
    function ParseClaimResponseAddItem(element : TMXmlElement; path : string) : TFhirClaimResponseAddItem;
    function ParseClaimResponseAddItemChild(value : TFhirClaimResponseAddItem; path : string; child : TMXmlElement) : boolean;
    function ParseClaimResponseAddItemBodySite(element : TMXmlElement; path : string) : TFhirClaimResponseAddItemBodySite;
    function ParseClaimResponseAddItemBodySiteChild(value : TFhirClaimResponseAddItemBodySite; path : string; child : TMXmlElement) : boolean;
    function ParseClaimResponseAddItemDetail(element : TMXmlElement; path : string) : TFhirClaimResponseAddItemDetail;
    function ParseClaimResponseAddItemDetailChild(value : TFhirClaimResponseAddItemDetail; path : string; child : TMXmlElement) : boolean;
    function ParseClaimResponseAddItemDetailSubDetail(element : TMXmlElement; path : string) : TFhirClaimResponseAddItemDetailSubDetail;
    function ParseClaimResponseAddItemDetailSubDetailChild(value : TFhirClaimResponseAddItemDetailSubDetail; path : string; child : TMXmlElement) : boolean;
    function ParseClaimResponseTotal(element : TMXmlElement; path : string) : TFhirClaimResponseTotal;
    function ParseClaimResponseTotalChild(value : TFhirClaimResponseTotal; path : string; child : TMXmlElement) : boolean;
    function ParseClaimResponsePayment(element : TMXmlElement; path : string) : TFhirClaimResponsePayment;
    function ParseClaimResponsePaymentChild(value : TFhirClaimResponsePayment; path : string; child : TMXmlElement) : boolean;
    function ParseClaimResponseProcessNote(element : TMXmlElement; path : string) : TFhirClaimResponseProcessNote;
    function ParseClaimResponseProcessNoteChild(value : TFhirClaimResponseProcessNote; path : string; child : TMXmlElement) : boolean;
    function ParseClaimResponseInsurance(element : TMXmlElement; path : string) : TFhirClaimResponseInsurance;
    function ParseClaimResponseInsuranceChild(value : TFhirClaimResponseInsurance; path : string; child : TMXmlElement) : boolean;
    function ParseClaimResponseError(element : TMXmlElement; path : string) : TFhirClaimResponseError;
    function ParseClaimResponseErrorChild(value : TFhirClaimResponseError; path : string; child : TMXmlElement) : boolean;
    function ParseClaimResponse(element : TMXmlElement; path : string) : TFhirClaimResponse;
    function ParseClaimResponseChild(value : TFhirClaimResponse; path : string; child : TMXmlElement) : boolean;
{$ENDIF FHIR_CLAIMRESPONSE}
{$IFDEF FHIR_CLINICALIMPRESSION}
    function ParseClinicalImpressionFinding(element : TMXmlElement; path : string) : TFhirClinicalImpressionFinding;
    function ParseClinicalImpressionFindingChild(value : TFhirClinicalImpressionFinding; path : string; child : TMXmlElement) : boolean;
    function ParseClinicalImpression(element : TMXmlElement; path : string) : TFhirClinicalImpression;
    function ParseClinicalImpressionChild(value : TFhirClinicalImpression; path : string; child : TMXmlElement) : boolean;
{$ENDIF FHIR_CLINICALIMPRESSION}
{$IFDEF FHIR_CLINICALUSEDEFINITION}
    function ParseClinicalUseDefinitionContraindication(element : TMXmlElement; path : string) : TFhirClinicalUseDefinitionContraindication;
    function ParseClinicalUseDefinitionContraindicationChild(value : TFhirClinicalUseDefinitionContraindication; path : string; child : TMXmlElement) : boolean;
    function ParseClinicalUseDefinitionContraindicationOtherTherapy(element : TMXmlElement; path : string) : TFhirClinicalUseDefinitionContraindicationOtherTherapy;
    function ParseClinicalUseDefinitionContraindicationOtherTherapyChild(value : TFhirClinicalUseDefinitionContraindicationOtherTherapy; path : string; child : TMXmlElement) : boolean;
    function ParseClinicalUseDefinitionIndication(element : TMXmlElement; path : string) : TFhirClinicalUseDefinitionIndication;
    function ParseClinicalUseDefinitionIndicationChild(value : TFhirClinicalUseDefinitionIndication; path : string; child : TMXmlElement) : boolean;
    function ParseClinicalUseDefinitionInteraction(element : TMXmlElement; path : string) : TFhirClinicalUseDefinitionInteraction;
    function ParseClinicalUseDefinitionInteractionChild(value : TFhirClinicalUseDefinitionInteraction; path : string; child : TMXmlElement) : boolean;
    function ParseClinicalUseDefinitionInteractionInteractant(element : TMXmlElement; path : string) : TFhirClinicalUseDefinitionInteractionInteractant;
    function ParseClinicalUseDefinitionInteractionInteractantChild(value : TFhirClinicalUseDefinitionInteractionInteractant; path : string; child : TMXmlElement) : boolean;
    function ParseClinicalUseDefinitionUndesirableEffect(element : TMXmlElement; path : string) : TFhirClinicalUseDefinitionUndesirableEffect;
    function ParseClinicalUseDefinitionUndesirableEffectChild(value : TFhirClinicalUseDefinitionUndesirableEffect; path : string; child : TMXmlElement) : boolean;
    function ParseClinicalUseDefinitionWarning(element : TMXmlElement; path : string) : TFhirClinicalUseDefinitionWarning;
    function ParseClinicalUseDefinitionWarningChild(value : TFhirClinicalUseDefinitionWarning; path : string; child : TMXmlElement) : boolean;
    function ParseClinicalUseDefinition(element : TMXmlElement; path : string) : TFhirClinicalUseDefinition;
    function ParseClinicalUseDefinitionChild(value : TFhirClinicalUseDefinition; path : string; child : TMXmlElement) : boolean;
{$ENDIF FHIR_CLINICALUSEDEFINITION}
{$IFDEF FHIR_CODESYSTEM}
    function ParseCodeSystemFilter(element : TMXmlElement; path : string) : TFhirCodeSystemFilter;
    function ParseCodeSystemFilterChild(value : TFhirCodeSystemFilter; path : string; child : TMXmlElement) : boolean;
    function ParseCodeSystemProperty(element : TMXmlElement; path : string) : TFhirCodeSystemProperty;
    function ParseCodeSystemPropertyChild(value : TFhirCodeSystemProperty; path : string; child : TMXmlElement) : boolean;
    function ParseCodeSystemConcept(element : TMXmlElement; path : string) : TFhirCodeSystemConcept;
    function ParseCodeSystemConceptChild(value : TFhirCodeSystemConcept; path : string; child : TMXmlElement) : boolean;
    function ParseCodeSystemConceptDesignation(element : TMXmlElement; path : string) : TFhirCodeSystemConceptDesignation;
    function ParseCodeSystemConceptDesignationChild(value : TFhirCodeSystemConceptDesignation; path : string; child : TMXmlElement) : boolean;
    function ParseCodeSystemConceptProperty(element : TMXmlElement; path : string) : TFhirCodeSystemConceptProperty;
    function ParseCodeSystemConceptPropertyChild(value : TFhirCodeSystemConceptProperty; path : string; child : TMXmlElement) : boolean;
    function ParseCodeSystem(element : TMXmlElement; path : string) : TFhirCodeSystem;
    function ParseCodeSystemChild(value : TFhirCodeSystem; path : string; child : TMXmlElement) : boolean;
{$ENDIF FHIR_CODESYSTEM}
{$IFDEF FHIR_COMMUNICATION}
    function ParseCommunicationPayload(element : TMXmlElement; path : string) : TFhirCommunicationPayload;
    function ParseCommunicationPayloadChild(value : TFhirCommunicationPayload; path : string; child : TMXmlElement) : boolean;
    function ParseCommunication(element : TMXmlElement; path : string) : TFhirCommunication;
    function ParseCommunicationChild(value : TFhirCommunication; path : string; child : TMXmlElement) : boolean;
{$ENDIF FHIR_COMMUNICATION}
{$IFDEF FHIR_COMMUNICATIONREQUEST}
    function ParseCommunicationRequestPayload(element : TMXmlElement; path : string) : TFhirCommunicationRequestPayload;
    function ParseCommunicationRequestPayloadChild(value : TFhirCommunicationRequestPayload; path : string; child : TMXmlElement) : boolean;
    function ParseCommunicationRequest(element : TMXmlElement; path : string) : TFhirCommunicationRequest;
    function ParseCommunicationRequestChild(value : TFhirCommunicationRequest; path : string; child : TMXmlElement) : boolean;
{$ENDIF FHIR_COMMUNICATIONREQUEST}
{$IFDEF FHIR_COMPARTMENTDEFINITION}
    function ParseCompartmentDefinitionResource(element : TMXmlElement; path : string) : TFhirCompartmentDefinitionResource;
    function ParseCompartmentDefinitionResourceChild(value : TFhirCompartmentDefinitionResource; path : string; child : TMXmlElement) : boolean;
    function ParseCompartmentDefinition(element : TMXmlElement; path : string) : TFhirCompartmentDefinition;
    function ParseCompartmentDefinitionChild(value : TFhirCompartmentDefinition; path : string; child : TMXmlElement) : boolean;
{$ENDIF FHIR_COMPARTMENTDEFINITION}
{$IFDEF FHIR_COMPOSITION}
    function ParseCompositionAttester(element : TMXmlElement; path : string) : TFhirCompositionAttester;
    function ParseCompositionAttesterChild(value : TFhirCompositionAttester; path : string; child : TMXmlElement) : boolean;
    function ParseCompositionEvent(element : TMXmlElement; path : string) : TFhirCompositionEvent;
    function ParseCompositionEventChild(value : TFhirCompositionEvent; path : string; child : TMXmlElement) : boolean;
    function ParseCompositionSection(element : TMXmlElement; path : string) : TFhirCompositionSection;
    function ParseCompositionSectionChild(value : TFhirCompositionSection; path : string; child : TMXmlElement) : boolean;
    function ParseComposition(element : TMXmlElement; path : string) : TFhirComposition;
    function ParseCompositionChild(value : TFhirComposition; path : string; child : TMXmlElement) : boolean;
{$ENDIF FHIR_COMPOSITION}
{$IFDEF FHIR_CONCEPTMAP}
    function ParseConceptMapGroup(element : TMXmlElement; path : string) : TFhirConceptMapGroup;
    function ParseConceptMapGroupChild(value : TFhirConceptMapGroup; path : string; child : TMXmlElement) : boolean;
    function ParseConceptMapGroupElement(element : TMXmlElement; path : string) : TFhirConceptMapGroupElement;
    function ParseConceptMapGroupElementChild(value : TFhirConceptMapGroupElement; path : string; child : TMXmlElement) : boolean;
    function ParseConceptMapGroupElementTarget(element : TMXmlElement; path : string) : TFhirConceptMapGroupElementTarget;
    function ParseConceptMapGroupElementTargetChild(value : TFhirConceptMapGroupElementTarget; path : string; child : TMXmlElement) : boolean;
    function ParseConceptMapGroupElementTargetDependsOn(element : TMXmlElement; path : string) : TFhirConceptMapGroupElementTargetDependsOn;
    function ParseConceptMapGroupElementTargetDependsOnChild(value : TFhirConceptMapGroupElementTargetDependsOn; path : string; child : TMXmlElement) : boolean;
    function ParseConceptMapGroupUnmapped(element : TMXmlElement; path : string) : TFhirConceptMapGroupUnmapped;
    function ParseConceptMapGroupUnmappedChild(value : TFhirConceptMapGroupUnmapped; path : string; child : TMXmlElement) : boolean;
    function ParseConceptMap(element : TMXmlElement; path : string) : TFhirConceptMap;
    function ParseConceptMapChild(value : TFhirConceptMap; path : string; child : TMXmlElement) : boolean;
{$ENDIF FHIR_CONCEPTMAP}
{$IFDEF FHIR_CONDITION}
    function ParseConditionParticipant(element : TMXmlElement; path : string) : TFhirConditionParticipant;
    function ParseConditionParticipantChild(value : TFhirConditionParticipant; path : string; child : TMXmlElement) : boolean;
    function ParseConditionStage(element : TMXmlElement; path : string) : TFhirConditionStage;
    function ParseConditionStageChild(value : TFhirConditionStage; path : string; child : TMXmlElement) : boolean;
    function ParseCondition(element : TMXmlElement; path : string) : TFhirCondition;
    function ParseConditionChild(value : TFhirCondition; path : string; child : TMXmlElement) : boolean;
{$ENDIF FHIR_CONDITION}
{$IFDEF FHIR_CONDITIONDEFINITION}
    function ParseConditionDefinitionObservation(element : TMXmlElement; path : string) : TFhirConditionDefinitionObservation;
    function ParseConditionDefinitionObservationChild(value : TFhirConditionDefinitionObservation; path : string; child : TMXmlElement) : boolean;
    function ParseConditionDefinitionMedication(element : TMXmlElement; path : string) : TFhirConditionDefinitionMedication;
    function ParseConditionDefinitionMedicationChild(value : TFhirConditionDefinitionMedication; path : string; child : TMXmlElement) : boolean;
    function ParseConditionDefinitionPrecondition(element : TMXmlElement; path : string) : TFhirConditionDefinitionPrecondition;
    function ParseConditionDefinitionPreconditionChild(value : TFhirConditionDefinitionPrecondition; path : string; child : TMXmlElement) : boolean;
    function ParseConditionDefinitionQuestionnaire(element : TMXmlElement; path : string) : TFhirConditionDefinitionQuestionnaire;
    function ParseConditionDefinitionQuestionnaireChild(value : TFhirConditionDefinitionQuestionnaire; path : string; child : TMXmlElement) : boolean;
    function ParseConditionDefinitionPlan(element : TMXmlElement; path : string) : TFhirConditionDefinitionPlan;
    function ParseConditionDefinitionPlanChild(value : TFhirConditionDefinitionPlan; path : string; child : TMXmlElement) : boolean;
    function ParseConditionDefinition(element : TMXmlElement; path : string) : TFhirConditionDefinition;
    function ParseConditionDefinitionChild(value : TFhirConditionDefinition; path : string; child : TMXmlElement) : boolean;
{$ENDIF FHIR_CONDITIONDEFINITION}
{$IFDEF FHIR_CONSENT}
    function ParseConsentPolicyBasis(element : TMXmlElement; path : string) : TFhirConsentPolicyBasis;
    function ParseConsentPolicyBasisChild(value : TFhirConsentPolicyBasis; path : string; child : TMXmlElement) : boolean;
    function ParseConsentVerification(element : TMXmlElement; path : string) : TFhirConsentVerification;
    function ParseConsentVerificationChild(value : TFhirConsentVerification; path : string; child : TMXmlElement) : boolean;
    function ParseConsentProvision(element : TMXmlElement; path : string) : TFhirConsentProvision;
    function ParseConsentProvisionChild(value : TFhirConsentProvision; path : string; child : TMXmlElement) : boolean;
    function ParseConsentProvisionActor(element : TMXmlElement; path : string) : TFhirConsentProvisionActor;
    function ParseConsentProvisionActorChild(value : TFhirConsentProvisionActor; path : string; child : TMXmlElement) : boolean;
    function ParseConsentProvisionData(element : TMXmlElement; path : string) : TFhirConsentProvisionData;
    function ParseConsentProvisionDataChild(value : TFhirConsentProvisionData; path : string; child : TMXmlElement) : boolean;
    function ParseConsent(element : TMXmlElement; path : string) : TFhirConsent;
    function ParseConsentChild(value : TFhirConsent; path : string; child : TMXmlElement) : boolean;
{$ENDIF FHIR_CONSENT}
{$IFDEF FHIR_CONTRACT}
    function ParseContractContentDefinition(element : TMXmlElement; path : string) : TFhirContractContentDefinition;
    function ParseContractContentDefinitionChild(value : TFhirContractContentDefinition; path : string; child : TMXmlElement) : boolean;
    function ParseContractTerm(element : TMXmlElement; path : string) : TFhirContractTerm;
    function ParseContractTermChild(value : TFhirContractTerm; path : string; child : TMXmlElement) : boolean;
    function ParseContractTermSecurityLabel(element : TMXmlElement; path : string) : TFhirContractTermSecurityLabel;
    function ParseContractTermSecurityLabelChild(value : TFhirContractTermSecurityLabel; path : string; child : TMXmlElement) : boolean;
    function ParseContractTermOffer(element : TMXmlElement; path : string) : TFhirContractTermOffer;
    function ParseContractTermOfferChild(value : TFhirContractTermOffer; path : string; child : TMXmlElement) : boolean;
    function ParseContractTermOfferParty(element : TMXmlElement; path : string) : TFhirContractTermOfferParty;
    function ParseContractTermOfferPartyChild(value : TFhirContractTermOfferParty; path : string; child : TMXmlElement) : boolean;
    function ParseContractTermOfferAnswer(element : TMXmlElement; path : string) : TFhirContractTermOfferAnswer;
    function ParseContractTermOfferAnswerChild(value : TFhirContractTermOfferAnswer; path : string; child : TMXmlElement) : boolean;
    function ParseContractTermAsset(element : TMXmlElement; path : string) : TFhirContractTermAsset;
    function ParseContractTermAssetChild(value : TFhirContractTermAsset; path : string; child : TMXmlElement) : boolean;
    function ParseContractTermAssetContext(element : TMXmlElement; path : string) : TFhirContractTermAssetContext;
    function ParseContractTermAssetContextChild(value : TFhirContractTermAssetContext; path : string; child : TMXmlElement) : boolean;
    function ParseContractTermAssetValuedItem(element : TMXmlElement; path : string) : TFhirContractTermAssetValuedItem;
    function ParseContractTermAssetValuedItemChild(value : TFhirContractTermAssetValuedItem; path : string; child : TMXmlElement) : boolean;
    function ParseContractTermAction(element : TMXmlElement; path : string) : TFhirContractTermAction;
    function ParseContractTermActionChild(value : TFhirContractTermAction; path : string; child : TMXmlElement) : boolean;
    function ParseContractTermActionSubject(element : TMXmlElement; path : string) : TFhirContractTermActionSubject;
    function ParseContractTermActionSubjectChild(value : TFhirContractTermActionSubject; path : string; child : TMXmlElement) : boolean;
    function ParseContractSigner(element : TMXmlElement; path : string) : TFhirContractSigner;
    function ParseContractSignerChild(value : TFhirContractSigner; path : string; child : TMXmlElement) : boolean;
    function ParseContractFriendly(element : TMXmlElement; path : string) : TFhirContractFriendly;
    function ParseContractFriendlyChild(value : TFhirContractFriendly; path : string; child : TMXmlElement) : boolean;
    function ParseContractLegal(element : TMXmlElement; path : string) : TFhirContractLegal;
    function ParseContractLegalChild(value : TFhirContractLegal; path : string; child : TMXmlElement) : boolean;
    function ParseContractRule(element : TMXmlElement; path : string) : TFhirContractRule;
    function ParseContractRuleChild(value : TFhirContractRule; path : string; child : TMXmlElement) : boolean;
    function ParseContract(element : TMXmlElement; path : string) : TFhirContract;
    function ParseContractChild(value : TFhirContract; path : string; child : TMXmlElement) : boolean;
{$ENDIF FHIR_CONTRACT}
{$IFDEF FHIR_COVERAGE}
    function ParseCoveragePaymentBy(element : TMXmlElement; path : string) : TFhirCoveragePaymentBy;
    function ParseCoveragePaymentByChild(value : TFhirCoveragePaymentBy; path : string; child : TMXmlElement) : boolean;
    function ParseCoverageClass(element : TMXmlElement; path : string) : TFhirCoverageClass;
    function ParseCoverageClassChild(value : TFhirCoverageClass; path : string; child : TMXmlElement) : boolean;
    function ParseCoverageCostToBeneficiary(element : TMXmlElement; path : string) : TFhirCoverageCostToBeneficiary;
    function ParseCoverageCostToBeneficiaryChild(value : TFhirCoverageCostToBeneficiary; path : string; child : TMXmlElement) : boolean;
    function ParseCoverageCostToBeneficiaryException(element : TMXmlElement; path : string) : TFhirCoverageCostToBeneficiaryException;
    function ParseCoverageCostToBeneficiaryExceptionChild(value : TFhirCoverageCostToBeneficiaryException; path : string; child : TMXmlElement) : boolean;
    function ParseCoverage(element : TMXmlElement; path : string) : TFhirCoverage;
    function ParseCoverageChild(value : TFhirCoverage; path : string; child : TMXmlElement) : boolean;
{$ENDIF FHIR_COVERAGE}
{$IFDEF FHIR_COVERAGEELIGIBILITYREQUEST}
    function ParseCoverageEligibilityRequestSupportingInfo(element : TMXmlElement; path : string) : TFhirCoverageEligibilityRequestSupportingInfo;
    function ParseCoverageEligibilityRequestSupportingInfoChild(value : TFhirCoverageEligibilityRequestSupportingInfo; path : string; child : TMXmlElement) : boolean;
    function ParseCoverageEligibilityRequestInsurance(element : TMXmlElement; path : string) : TFhirCoverageEligibilityRequestInsurance;
    function ParseCoverageEligibilityRequestInsuranceChild(value : TFhirCoverageEligibilityRequestInsurance; path : string; child : TMXmlElement) : boolean;
    function ParseCoverageEligibilityRequestItem(element : TMXmlElement; path : string) : TFhirCoverageEligibilityRequestItem;
    function ParseCoverageEligibilityRequestItemChild(value : TFhirCoverageEligibilityRequestItem; path : string; child : TMXmlElement) : boolean;
    function ParseCoverageEligibilityRequestItemDiagnosis(element : TMXmlElement; path : string) : TFhirCoverageEligibilityRequestItemDiagnosis;
    function ParseCoverageEligibilityRequestItemDiagnosisChild(value : TFhirCoverageEligibilityRequestItemDiagnosis; path : string; child : TMXmlElement) : boolean;
    function ParseCoverageEligibilityRequest(element : TMXmlElement; path : string) : TFhirCoverageEligibilityRequest;
    function ParseCoverageEligibilityRequestChild(value : TFhirCoverageEligibilityRequest; path : string; child : TMXmlElement) : boolean;
{$ENDIF FHIR_COVERAGEELIGIBILITYREQUEST}
{$IFDEF FHIR_COVERAGEELIGIBILITYRESPONSE}
    function ParseCoverageEligibilityResponseInsurance(element : TMXmlElement; path : string) : TFhirCoverageEligibilityResponseInsurance;
    function ParseCoverageEligibilityResponseInsuranceChild(value : TFhirCoverageEligibilityResponseInsurance; path : string; child : TMXmlElement) : boolean;
    function ParseCoverageEligibilityResponseInsuranceItem(element : TMXmlElement; path : string) : TFhirCoverageEligibilityResponseInsuranceItem;
    function ParseCoverageEligibilityResponseInsuranceItemChild(value : TFhirCoverageEligibilityResponseInsuranceItem; path : string; child : TMXmlElement) : boolean;
    function ParseCoverageEligibilityResponseInsuranceItemBenefit(element : TMXmlElement; path : string) : TFhirCoverageEligibilityResponseInsuranceItemBenefit;
    function ParseCoverageEligibilityResponseInsuranceItemBenefitChild(value : TFhirCoverageEligibilityResponseInsuranceItemBenefit; path : string; child : TMXmlElement) : boolean;
    function ParseCoverageEligibilityResponseError(element : TMXmlElement; path : string) : TFhirCoverageEligibilityResponseError;
    function ParseCoverageEligibilityResponseErrorChild(value : TFhirCoverageEligibilityResponseError; path : string; child : TMXmlElement) : boolean;
    function ParseCoverageEligibilityResponse(element : TMXmlElement; path : string) : TFhirCoverageEligibilityResponse;
    function ParseCoverageEligibilityResponseChild(value : TFhirCoverageEligibilityResponse; path : string; child : TMXmlElement) : boolean;
{$ENDIF FHIR_COVERAGEELIGIBILITYRESPONSE}
{$IFDEF FHIR_DETECTEDISSUE}
    function ParseDetectedIssueEvidence(element : TMXmlElement; path : string) : TFhirDetectedIssueEvidence;
    function ParseDetectedIssueEvidenceChild(value : TFhirDetectedIssueEvidence; path : string; child : TMXmlElement) : boolean;
    function ParseDetectedIssueMitigation(element : TMXmlElement; path : string) : TFhirDetectedIssueMitigation;
    function ParseDetectedIssueMitigationChild(value : TFhirDetectedIssueMitigation; path : string; child : TMXmlElement) : boolean;
    function ParseDetectedIssue(element : TMXmlElement; path : string) : TFhirDetectedIssue;
    function ParseDetectedIssueChild(value : TFhirDetectedIssue; path : string; child : TMXmlElement) : boolean;
{$ENDIF FHIR_DETECTEDISSUE}
{$IFDEF FHIR_DEVICE}
    function ParseDeviceUdiCarrier(element : TMXmlElement; path : string) : TFhirDeviceUdiCarrier;
    function ParseDeviceUdiCarrierChild(value : TFhirDeviceUdiCarrier; path : string; child : TMXmlElement) : boolean;
    function ParseDeviceDeviceName(element : TMXmlElement; path : string) : TFhirDeviceDeviceName;
    function ParseDeviceDeviceNameChild(value : TFhirDeviceDeviceName; path : string; child : TMXmlElement) : boolean;
    function ParseDeviceVersion(element : TMXmlElement; path : string) : TFhirDeviceVersion;
    function ParseDeviceVersionChild(value : TFhirDeviceVersion; path : string; child : TMXmlElement) : boolean;
    function ParseDeviceSpecialization(element : TMXmlElement; path : string) : TFhirDeviceSpecialization;
    function ParseDeviceSpecializationChild(value : TFhirDeviceSpecialization; path : string; child : TMXmlElement) : boolean;
    function ParseDeviceProperty(element : TMXmlElement; path : string) : TFhirDeviceProperty;
    function ParseDevicePropertyChild(value : TFhirDeviceProperty; path : string; child : TMXmlElement) : boolean;
    function ParseDeviceOperation(element : TMXmlElement; path : string) : TFhirDeviceOperation;
    function ParseDeviceOperationChild(value : TFhirDeviceOperation; path : string; child : TMXmlElement) : boolean;
    function ParseDeviceAssociation(element : TMXmlElement; path : string) : TFhirDeviceAssociation;
    function ParseDeviceAssociationChild(value : TFhirDeviceAssociation; path : string; child : TMXmlElement) : boolean;
    function ParseDevice(element : TMXmlElement; path : string) : TFhirDevice;
    function ParseDeviceChild(value : TFhirDevice; path : string; child : TMXmlElement) : boolean;
{$ENDIF FHIR_DEVICE}
{$IFDEF FHIR_DEVICEDEFINITION}
    function ParseDeviceDefinitionUdiDeviceIdentifier(element : TMXmlElement; path : string) : TFhirDeviceDefinitionUdiDeviceIdentifier;
    function ParseDeviceDefinitionUdiDeviceIdentifierChild(value : TFhirDeviceDefinitionUdiDeviceIdentifier; path : string; child : TMXmlElement) : boolean;
    function ParseDeviceDefinitionUdiDeviceIdentifierMarketDistribution(element : TMXmlElement; path : string) : TFhirDeviceDefinitionUdiDeviceIdentifierMarketDistribution;
    function ParseDeviceDefinitionUdiDeviceIdentifierMarketDistributionChild(value : TFhirDeviceDefinitionUdiDeviceIdentifierMarketDistribution; path : string; child : TMXmlElement) : boolean;
    function ParseDeviceDefinitionRegulatoryIdentifier(element : TMXmlElement; path : string) : TFhirDeviceDefinitionRegulatoryIdentifier;
    function ParseDeviceDefinitionRegulatoryIdentifierChild(value : TFhirDeviceDefinitionRegulatoryIdentifier; path : string; child : TMXmlElement) : boolean;
    function ParseDeviceDefinitionDeviceName(element : TMXmlElement; path : string) : TFhirDeviceDefinitionDeviceName;
    function ParseDeviceDefinitionDeviceNameChild(value : TFhirDeviceDefinitionDeviceName; path : string; child : TMXmlElement) : boolean;
    function ParseDeviceDefinitionClassification(element : TMXmlElement; path : string) : TFhirDeviceDefinitionClassification;
    function ParseDeviceDefinitionClassificationChild(value : TFhirDeviceDefinitionClassification; path : string; child : TMXmlElement) : boolean;
    function ParseDeviceDefinitionHasPart(element : TMXmlElement; path : string) : TFhirDeviceDefinitionHasPart;
    function ParseDeviceDefinitionHasPartChild(value : TFhirDeviceDefinitionHasPart; path : string; child : TMXmlElement) : boolean;
    function ParseDeviceDefinitionPackaging(element : TMXmlElement; path : string) : TFhirDeviceDefinitionPackaging;
    function ParseDeviceDefinitionPackagingChild(value : TFhirDeviceDefinitionPackaging; path : string; child : TMXmlElement) : boolean;
    function ParseDeviceDefinitionPackagingDistributor(element : TMXmlElement; path : string) : TFhirDeviceDefinitionPackagingDistributor;
    function ParseDeviceDefinitionPackagingDistributorChild(value : TFhirDeviceDefinitionPackagingDistributor; path : string; child : TMXmlElement) : boolean;
    function ParseDeviceDefinitionVersion(element : TMXmlElement; path : string) : TFhirDeviceDefinitionVersion;
    function ParseDeviceDefinitionVersionChild(value : TFhirDeviceDefinitionVersion; path : string; child : TMXmlElement) : boolean;
    function ParseDeviceDefinitionProperty(element : TMXmlElement; path : string) : TFhirDeviceDefinitionProperty;
    function ParseDeviceDefinitionPropertyChild(value : TFhirDeviceDefinitionProperty; path : string; child : TMXmlElement) : boolean;
    function ParseDeviceDefinitionLink(element : TMXmlElement; path : string) : TFhirDeviceDefinitionLink;
    function ParseDeviceDefinitionLinkChild(value : TFhirDeviceDefinitionLink; path : string; child : TMXmlElement) : boolean;
    function ParseDeviceDefinitionMaterial(element : TMXmlElement; path : string) : TFhirDeviceDefinitionMaterial;
    function ParseDeviceDefinitionMaterialChild(value : TFhirDeviceDefinitionMaterial; path : string; child : TMXmlElement) : boolean;
    function ParseDeviceDefinitionGuideline(element : TMXmlElement; path : string) : TFhirDeviceDefinitionGuideline;
    function ParseDeviceDefinitionGuidelineChild(value : TFhirDeviceDefinitionGuideline; path : string; child : TMXmlElement) : boolean;
    function ParseDeviceDefinitionCorrectiveAction(element : TMXmlElement; path : string) : TFhirDeviceDefinitionCorrectiveAction;
    function ParseDeviceDefinitionCorrectiveActionChild(value : TFhirDeviceDefinitionCorrectiveAction; path : string; child : TMXmlElement) : boolean;
    function ParseDeviceDefinitionChargeItem(element : TMXmlElement; path : string) : TFhirDeviceDefinitionChargeItem;
    function ParseDeviceDefinitionChargeItemChild(value : TFhirDeviceDefinitionChargeItem; path : string; child : TMXmlElement) : boolean;
    function ParseDeviceDefinition(element : TMXmlElement; path : string) : TFhirDeviceDefinition;
    function ParseDeviceDefinitionChild(value : TFhirDeviceDefinition; path : string; child : TMXmlElement) : boolean;
{$ENDIF FHIR_DEVICEDEFINITION}
{$IFDEF FHIR_DEVICEDISPENSE}
    function ParseDeviceDispensePerformer(element : TMXmlElement; path : string) : TFhirDeviceDispensePerformer;
    function ParseDeviceDispensePerformerChild(value : TFhirDeviceDispensePerformer; path : string; child : TMXmlElement) : boolean;
    function ParseDeviceDispense(element : TMXmlElement; path : string) : TFhirDeviceDispense;
    function ParseDeviceDispenseChild(value : TFhirDeviceDispense; path : string; child : TMXmlElement) : boolean;
{$ENDIF FHIR_DEVICEDISPENSE}
{$IFDEF FHIR_DEVICEMETRIC}
    function ParseDeviceMetricCalibration(element : TMXmlElement; path : string) : TFhirDeviceMetricCalibration;
    function ParseDeviceMetricCalibrationChild(value : TFhirDeviceMetricCalibration; path : string; child : TMXmlElement) : boolean;
    function ParseDeviceMetric(element : TMXmlElement; path : string) : TFhirDeviceMetric;
    function ParseDeviceMetricChild(value : TFhirDeviceMetric; path : string; child : TMXmlElement) : boolean;
{$ENDIF FHIR_DEVICEMETRIC}
{$IFDEF FHIR_DEVICEREQUEST}
    function ParseDeviceRequestParameter(element : TMXmlElement; path : string) : TFhirDeviceRequestParameter;
    function ParseDeviceRequestParameterChild(value : TFhirDeviceRequestParameter; path : string; child : TMXmlElement) : boolean;
    function ParseDeviceRequest(element : TMXmlElement; path : string) : TFhirDeviceRequest;
    function ParseDeviceRequestChild(value : TFhirDeviceRequest; path : string; child : TMXmlElement) : boolean;
{$ENDIF FHIR_DEVICEREQUEST}
{$IFDEF FHIR_DEVICEUSAGE}
    function ParseDeviceUsageAdherence(element : TMXmlElement; path : string) : TFhirDeviceUsageAdherence;
    function ParseDeviceUsageAdherenceChild(value : TFhirDeviceUsageAdherence; path : string; child : TMXmlElement) : boolean;
    function ParseDeviceUsage(element : TMXmlElement; path : string) : TFhirDeviceUsage;
    function ParseDeviceUsageChild(value : TFhirDeviceUsage; path : string; child : TMXmlElement) : boolean;
{$ENDIF FHIR_DEVICEUSAGE}
{$IFDEF FHIR_DIAGNOSTICREPORT}
    function ParseDiagnosticReportSupportingInfo(element : TMXmlElement; path : string) : TFhirDiagnosticReportSupportingInfo;
    function ParseDiagnosticReportSupportingInfoChild(value : TFhirDiagnosticReportSupportingInfo; path : string; child : TMXmlElement) : boolean;
    function ParseDiagnosticReportMedia(element : TMXmlElement; path : string) : TFhirDiagnosticReportMedia;
    function ParseDiagnosticReportMediaChild(value : TFhirDiagnosticReportMedia; path : string; child : TMXmlElement) : boolean;
    function ParseDiagnosticReport(element : TMXmlElement; path : string) : TFhirDiagnosticReport;
    function ParseDiagnosticReportChild(value : TFhirDiagnosticReport; path : string; child : TMXmlElement) : boolean;
{$ENDIF FHIR_DIAGNOSTICREPORT}
{$IFDEF FHIR_DOCUMENTMANIFEST}
    function ParseDocumentManifestRelated(element : TMXmlElement; path : string) : TFhirDocumentManifestRelated;
    function ParseDocumentManifestRelatedChild(value : TFhirDocumentManifestRelated; path : string; child : TMXmlElement) : boolean;
    function ParseDocumentManifest(element : TMXmlElement; path : string) : TFhirDocumentManifest;
    function ParseDocumentManifestChild(value : TFhirDocumentManifest; path : string; child : TMXmlElement) : boolean;
{$ENDIF FHIR_DOCUMENTMANIFEST}
{$IFDEF FHIR_DOCUMENTREFERENCE}
    function ParseDocumentReferenceAttester(element : TMXmlElement; path : string) : TFhirDocumentReferenceAttester;
    function ParseDocumentReferenceAttesterChild(value : TFhirDocumentReferenceAttester; path : string; child : TMXmlElement) : boolean;
    function ParseDocumentReferenceRelatesTo(element : TMXmlElement; path : string) : TFhirDocumentReferenceRelatesTo;
    function ParseDocumentReferenceRelatesToChild(value : TFhirDocumentReferenceRelatesTo; path : string; child : TMXmlElement) : boolean;
    function ParseDocumentReferenceContent(element : TMXmlElement; path : string) : TFhirDocumentReferenceContent;
    function ParseDocumentReferenceContentChild(value : TFhirDocumentReferenceContent; path : string; child : TMXmlElement) : boolean;
    function ParseDocumentReferenceContentProfile(element : TMXmlElement; path : string) : TFhirDocumentReferenceContentProfile;
    function ParseDocumentReferenceContentProfileChild(value : TFhirDocumentReferenceContentProfile; path : string; child : TMXmlElement) : boolean;
    function ParseDocumentReference(element : TMXmlElement; path : string) : TFhirDocumentReference;
    function ParseDocumentReferenceChild(value : TFhirDocumentReference; path : string; child : TMXmlElement) : boolean;
{$ENDIF FHIR_DOCUMENTREFERENCE}
{$IFDEF FHIR_ENCOUNTER}
    function ParseEncounterStatusHistory(element : TMXmlElement; path : string) : TFhirEncounterStatusHistory;
    function ParseEncounterStatusHistoryChild(value : TFhirEncounterStatusHistory; path : string; child : TMXmlElement) : boolean;
    function ParseEncounterClassHistory(element : TMXmlElement; path : string) : TFhirEncounterClassHistory;
    function ParseEncounterClassHistoryChild(value : TFhirEncounterClassHistory; path : string; child : TMXmlElement) : boolean;
    function ParseEncounterParticipant(element : TMXmlElement; path : string) : TFhirEncounterParticipant;
    function ParseEncounterParticipantChild(value : TFhirEncounterParticipant; path : string; child : TMXmlElement) : boolean;
    function ParseEncounterDiagnosis(element : TMXmlElement; path : string) : TFhirEncounterDiagnosis;
    function ParseEncounterDiagnosisChild(value : TFhirEncounterDiagnosis; path : string; child : TMXmlElement) : boolean;
    function ParseEncounterAdmission(element : TMXmlElement; path : string) : TFhirEncounterAdmission;
    function ParseEncounterAdmissionChild(value : TFhirEncounterAdmission; path : string; child : TMXmlElement) : boolean;
    function ParseEncounterLocation(element : TMXmlElement; path : string) : TFhirEncounterLocation;
    function ParseEncounterLocationChild(value : TFhirEncounterLocation; path : string; child : TMXmlElement) : boolean;
    function ParseEncounter(element : TMXmlElement; path : string) : TFhirEncounter;
    function ParseEncounterChild(value : TFhirEncounter; path : string; child : TMXmlElement) : boolean;
{$ENDIF FHIR_ENCOUNTER}
{$IFDEF FHIR_ENDPOINT}
    function ParseEndpoint(element : TMXmlElement; path : string) : TFhirEndpoint;
    function ParseEndpointChild(value : TFhirEndpoint; path : string; child : TMXmlElement) : boolean;
{$ENDIF FHIR_ENDPOINT}
{$IFDEF FHIR_ENROLLMENTREQUEST}
    function ParseEnrollmentRequest(element : TMXmlElement; path : string) : TFhirEnrollmentRequest;
    function ParseEnrollmentRequestChild(value : TFhirEnrollmentRequest; path : string; child : TMXmlElement) : boolean;
{$ENDIF FHIR_ENROLLMENTREQUEST}
{$IFDEF FHIR_ENROLLMENTRESPONSE}
    function ParseEnrollmentResponse(element : TMXmlElement; path : string) : TFhirEnrollmentResponse;
    function ParseEnrollmentResponseChild(value : TFhirEnrollmentResponse; path : string; child : TMXmlElement) : boolean;
{$ENDIF FHIR_ENROLLMENTRESPONSE}
{$IFDEF FHIR_EPISODEOFCARE}
    function ParseEpisodeOfCareStatusHistory(element : TMXmlElement; path : string) : TFhirEpisodeOfCareStatusHistory;
    function ParseEpisodeOfCareStatusHistoryChild(value : TFhirEpisodeOfCareStatusHistory; path : string; child : TMXmlElement) : boolean;
    function ParseEpisodeOfCareDiagnosis(element : TMXmlElement; path : string) : TFhirEpisodeOfCareDiagnosis;
    function ParseEpisodeOfCareDiagnosisChild(value : TFhirEpisodeOfCareDiagnosis; path : string; child : TMXmlElement) : boolean;
    function ParseEpisodeOfCare(element : TMXmlElement; path : string) : TFhirEpisodeOfCare;
    function ParseEpisodeOfCareChild(value : TFhirEpisodeOfCare; path : string; child : TMXmlElement) : boolean;
{$ENDIF FHIR_EPISODEOFCARE}
{$IFDEF FHIR_EVENTDEFINITION}
    function ParseEventDefinition(element : TMXmlElement; path : string) : TFhirEventDefinition;
    function ParseEventDefinitionChild(value : TFhirEventDefinition; path : string; child : TMXmlElement) : boolean;
{$ENDIF FHIR_EVENTDEFINITION}
{$IFDEF FHIR_EVIDENCE}
    function ParseEvidenceVariableDefinition(element : TMXmlElement; path : string) : TFhirEvidenceVariableDefinition;
    function ParseEvidenceVariableDefinitionChild(value : TFhirEvidenceVariableDefinition; path : string; child : TMXmlElement) : boolean;
    function ParseEvidenceStatistic(element : TMXmlElement; path : string) : TFhirEvidenceStatistic;
    function ParseEvidenceStatisticChild(value : TFhirEvidenceStatistic; path : string; child : TMXmlElement) : boolean;
    function ParseEvidenceStatisticSampleSize(element : TMXmlElement; path : string) : TFhirEvidenceStatisticSampleSize;
    function ParseEvidenceStatisticSampleSizeChild(value : TFhirEvidenceStatisticSampleSize; path : string; child : TMXmlElement) : boolean;
    function ParseEvidenceStatisticAttributeEstimate(element : TMXmlElement; path : string) : TFhirEvidenceStatisticAttributeEstimate;
    function ParseEvidenceStatisticAttributeEstimateChild(value : TFhirEvidenceStatisticAttributeEstimate; path : string; child : TMXmlElement) : boolean;
    function ParseEvidenceStatisticModelCharacteristic(element : TMXmlElement; path : string) : TFhirEvidenceStatisticModelCharacteristic;
    function ParseEvidenceStatisticModelCharacteristicChild(value : TFhirEvidenceStatisticModelCharacteristic; path : string; child : TMXmlElement) : boolean;
    function ParseEvidenceStatisticModelCharacteristicVariable(element : TMXmlElement; path : string) : TFhirEvidenceStatisticModelCharacteristicVariable;
    function ParseEvidenceStatisticModelCharacteristicVariableChild(value : TFhirEvidenceStatisticModelCharacteristicVariable; path : string; child : TMXmlElement) : boolean;
    function ParseEvidenceCertainty(element : TMXmlElement; path : string) : TFhirEvidenceCertainty;
    function ParseEvidenceCertaintyChild(value : TFhirEvidenceCertainty; path : string; child : TMXmlElement) : boolean;
    function ParseEvidence(element : TMXmlElement; path : string) : TFhirEvidence;
    function ParseEvidenceChild(value : TFhirEvidence; path : string; child : TMXmlElement) : boolean;
{$ENDIF FHIR_EVIDENCE}
{$IFDEF FHIR_EVIDENCEREPORT}
    function ParseEvidenceReportSubject(element : TMXmlElement; path : string) : TFhirEvidenceReportSubject;
    function ParseEvidenceReportSubjectChild(value : TFhirEvidenceReportSubject; path : string; child : TMXmlElement) : boolean;
    function ParseEvidenceReportSubjectCharacteristic(element : TMXmlElement; path : string) : TFhirEvidenceReportSubjectCharacteristic;
    function ParseEvidenceReportSubjectCharacteristicChild(value : TFhirEvidenceReportSubjectCharacteristic; path : string; child : TMXmlElement) : boolean;
    function ParseEvidenceReportRelatesTo(element : TMXmlElement; path : string) : TFhirEvidenceReportRelatesTo;
    function ParseEvidenceReportRelatesToChild(value : TFhirEvidenceReportRelatesTo; path : string; child : TMXmlElement) : boolean;
    function ParseEvidenceReportRelatesToTarget(element : TMXmlElement; path : string) : TFhirEvidenceReportRelatesToTarget;
    function ParseEvidenceReportRelatesToTargetChild(value : TFhirEvidenceReportRelatesToTarget; path : string; child : TMXmlElement) : boolean;
    function ParseEvidenceReportSection(element : TMXmlElement; path : string) : TFhirEvidenceReportSection;
    function ParseEvidenceReportSectionChild(value : TFhirEvidenceReportSection; path : string; child : TMXmlElement) : boolean;
    function ParseEvidenceReport(element : TMXmlElement; path : string) : TFhirEvidenceReport;
    function ParseEvidenceReportChild(value : TFhirEvidenceReport; path : string; child : TMXmlElement) : boolean;
{$ENDIF FHIR_EVIDENCEREPORT}
{$IFDEF FHIR_EVIDENCEVARIABLE}
    function ParseEvidenceVariableCharacteristic(element : TMXmlElement; path : string) : TFhirEvidenceVariableCharacteristic;
    function ParseEvidenceVariableCharacteristicChild(value : TFhirEvidenceVariableCharacteristic; path : string; child : TMXmlElement) : boolean;
    function ParseEvidenceVariableCharacteristicDefinitionByTypeAndValue(element : TMXmlElement; path : string) : TFhirEvidenceVariableCharacteristicDefinitionByTypeAndValue;
    function ParseEvidenceVariableCharacteristicDefinitionByTypeAndValueChild(value : TFhirEvidenceVariableCharacteristicDefinitionByTypeAndValue; path : string; child : TMXmlElement) : boolean;
    function ParseEvidenceVariableCharacteristicDefinitionByCombination(element : TMXmlElement; path : string) : TFhirEvidenceVariableCharacteristicDefinitionByCombination;
    function ParseEvidenceVariableCharacteristicDefinitionByCombinationChild(value : TFhirEvidenceVariableCharacteristicDefinitionByCombination; path : string; child : TMXmlElement) : boolean;
    function ParseEvidenceVariableCharacteristicTimeFromEvent(element : TMXmlElement; path : string) : TFhirEvidenceVariableCharacteristicTimeFromEvent;
    function ParseEvidenceVariableCharacteristicTimeFromEventChild(value : TFhirEvidenceVariableCharacteristicTimeFromEvent; path : string; child : TMXmlElement) : boolean;
    function ParseEvidenceVariableCategory(element : TMXmlElement; path : string) : TFhirEvidenceVariableCategory;
    function ParseEvidenceVariableCategoryChild(value : TFhirEvidenceVariableCategory; path : string; child : TMXmlElement) : boolean;
    function ParseEvidenceVariable(element : TMXmlElement; path : string) : TFhirEvidenceVariable;
    function ParseEvidenceVariableChild(value : TFhirEvidenceVariable; path : string; child : TMXmlElement) : boolean;
{$ENDIF FHIR_EVIDENCEVARIABLE}
{$IFDEF FHIR_EXAMPLESCENARIO}
    function ParseExampleScenarioActor(element : TMXmlElement; path : string) : TFhirExampleScenarioActor;
    function ParseExampleScenarioActorChild(value : TFhirExampleScenarioActor; path : string; child : TMXmlElement) : boolean;
    function ParseExampleScenarioInstance(element : TMXmlElement; path : string) : TFhirExampleScenarioInstance;
    function ParseExampleScenarioInstanceChild(value : TFhirExampleScenarioInstance; path : string; child : TMXmlElement) : boolean;
    function ParseExampleScenarioInstanceVersion(element : TMXmlElement; path : string) : TFhirExampleScenarioInstanceVersion;
    function ParseExampleScenarioInstanceVersionChild(value : TFhirExampleScenarioInstanceVersion; path : string; child : TMXmlElement) : boolean;
    function ParseExampleScenarioInstanceContainedInstance(element : TMXmlElement; path : string) : TFhirExampleScenarioInstanceContainedInstance;
    function ParseExampleScenarioInstanceContainedInstanceChild(value : TFhirExampleScenarioInstanceContainedInstance; path : string; child : TMXmlElement) : boolean;
    function ParseExampleScenarioProcess(element : TMXmlElement; path : string) : TFhirExampleScenarioProcess;
    function ParseExampleScenarioProcessChild(value : TFhirExampleScenarioProcess; path : string; child : TMXmlElement) : boolean;
    function ParseExampleScenarioProcessStep(element : TMXmlElement; path : string) : TFhirExampleScenarioProcessStep;
    function ParseExampleScenarioProcessStepChild(value : TFhirExampleScenarioProcessStep; path : string; child : TMXmlElement) : boolean;
    function ParseExampleScenarioProcessStepOperation(element : TMXmlElement; path : string) : TFhirExampleScenarioProcessStepOperation;
    function ParseExampleScenarioProcessStepOperationChild(value : TFhirExampleScenarioProcessStepOperation; path : string; child : TMXmlElement) : boolean;
    function ParseExampleScenarioProcessStepAlternative(element : TMXmlElement; path : string) : TFhirExampleScenarioProcessStepAlternative;
    function ParseExampleScenarioProcessStepAlternativeChild(value : TFhirExampleScenarioProcessStepAlternative; path : string; child : TMXmlElement) : boolean;
    function ParseExampleScenario(element : TMXmlElement; path : string) : TFhirExampleScenario;
    function ParseExampleScenarioChild(value : TFhirExampleScenario; path : string; child : TMXmlElement) : boolean;
{$ENDIF FHIR_EXAMPLESCENARIO}
{$IFDEF FHIR_EXPLANATIONOFBENEFIT}
    function ParseExplanationOfBenefitRelated(element : TMXmlElement; path : string) : TFhirExplanationOfBenefitRelated;
    function ParseExplanationOfBenefitRelatedChild(value : TFhirExplanationOfBenefitRelated; path : string; child : TMXmlElement) : boolean;
    function ParseExplanationOfBenefitPayee(element : TMXmlElement; path : string) : TFhirExplanationOfBenefitPayee;
    function ParseExplanationOfBenefitPayeeChild(value : TFhirExplanationOfBenefitPayee; path : string; child : TMXmlElement) : boolean;
    function ParseExplanationOfBenefitCareTeam(element : TMXmlElement; path : string) : TFhirExplanationOfBenefitCareTeam;
    function ParseExplanationOfBenefitCareTeamChild(value : TFhirExplanationOfBenefitCareTeam; path : string; child : TMXmlElement) : boolean;
    function ParseExplanationOfBenefitSupportingInfo(element : TMXmlElement; path : string) : TFhirExplanationOfBenefitSupportingInfo;
    function ParseExplanationOfBenefitSupportingInfoChild(value : TFhirExplanationOfBenefitSupportingInfo; path : string; child : TMXmlElement) : boolean;
    function ParseExplanationOfBenefitDiagnosis(element : TMXmlElement; path : string) : TFhirExplanationOfBenefitDiagnosis;
    function ParseExplanationOfBenefitDiagnosisChild(value : TFhirExplanationOfBenefitDiagnosis; path : string; child : TMXmlElement) : boolean;
    function ParseExplanationOfBenefitProcedure(element : TMXmlElement; path : string) : TFhirExplanationOfBenefitProcedure;
    function ParseExplanationOfBenefitProcedureChild(value : TFhirExplanationOfBenefitProcedure; path : string; child : TMXmlElement) : boolean;
    function ParseExplanationOfBenefitInsurance(element : TMXmlElement; path : string) : TFhirExplanationOfBenefitInsurance;
    function ParseExplanationOfBenefitInsuranceChild(value : TFhirExplanationOfBenefitInsurance; path : string; child : TMXmlElement) : boolean;
    function ParseExplanationOfBenefitAccident(element : TMXmlElement; path : string) : TFhirExplanationOfBenefitAccident;
    function ParseExplanationOfBenefitAccidentChild(value : TFhirExplanationOfBenefitAccident; path : string; child : TMXmlElement) : boolean;
    function ParseExplanationOfBenefitItem(element : TMXmlElement; path : string) : TFhirExplanationOfBenefitItem;
    function ParseExplanationOfBenefitItemChild(value : TFhirExplanationOfBenefitItem; path : string; child : TMXmlElement) : boolean;
    function ParseExplanationOfBenefitItemBodySite(element : TMXmlElement; path : string) : TFhirExplanationOfBenefitItemBodySite;
    function ParseExplanationOfBenefitItemBodySiteChild(value : TFhirExplanationOfBenefitItemBodySite; path : string; child : TMXmlElement) : boolean;
    function ParseExplanationOfBenefitItemAdjudication(element : TMXmlElement; path : string) : TFhirExplanationOfBenefitItemAdjudication;
    function ParseExplanationOfBenefitItemAdjudicationChild(value : TFhirExplanationOfBenefitItemAdjudication; path : string; child : TMXmlElement) : boolean;
    function ParseExplanationOfBenefitItemDetail(element : TMXmlElement; path : string) : TFhirExplanationOfBenefitItemDetail;
    function ParseExplanationOfBenefitItemDetailChild(value : TFhirExplanationOfBenefitItemDetail; path : string; child : TMXmlElement) : boolean;
    function ParseExplanationOfBenefitItemDetailSubDetail(element : TMXmlElement; path : string) : TFhirExplanationOfBenefitItemDetailSubDetail;
    function ParseExplanationOfBenefitItemDetailSubDetailChild(value : TFhirExplanationOfBenefitItemDetailSubDetail; path : string; child : TMXmlElement) : boolean;
    function ParseExplanationOfBenefitAddItem(element : TMXmlElement; path : string) : TFhirExplanationOfBenefitAddItem;
    function ParseExplanationOfBenefitAddItemChild(value : TFhirExplanationOfBenefitAddItem; path : string; child : TMXmlElement) : boolean;
    function ParseExplanationOfBenefitAddItemBodySite(element : TMXmlElement; path : string) : TFhirExplanationOfBenefitAddItemBodySite;
    function ParseExplanationOfBenefitAddItemBodySiteChild(value : TFhirExplanationOfBenefitAddItemBodySite; path : string; child : TMXmlElement) : boolean;
    function ParseExplanationOfBenefitAddItemDetail(element : TMXmlElement; path : string) : TFhirExplanationOfBenefitAddItemDetail;
    function ParseExplanationOfBenefitAddItemDetailChild(value : TFhirExplanationOfBenefitAddItemDetail; path : string; child : TMXmlElement) : boolean;
    function ParseExplanationOfBenefitAddItemDetailSubDetail(element : TMXmlElement; path : string) : TFhirExplanationOfBenefitAddItemDetailSubDetail;
    function ParseExplanationOfBenefitAddItemDetailSubDetailChild(value : TFhirExplanationOfBenefitAddItemDetailSubDetail; path : string; child : TMXmlElement) : boolean;
    function ParseExplanationOfBenefitTotal(element : TMXmlElement; path : string) : TFhirExplanationOfBenefitTotal;
    function ParseExplanationOfBenefitTotalChild(value : TFhirExplanationOfBenefitTotal; path : string; child : TMXmlElement) : boolean;
    function ParseExplanationOfBenefitPayment(element : TMXmlElement; path : string) : TFhirExplanationOfBenefitPayment;
    function ParseExplanationOfBenefitPaymentChild(value : TFhirExplanationOfBenefitPayment; path : string; child : TMXmlElement) : boolean;
    function ParseExplanationOfBenefitProcessNote(element : TMXmlElement; path : string) : TFhirExplanationOfBenefitProcessNote;
    function ParseExplanationOfBenefitProcessNoteChild(value : TFhirExplanationOfBenefitProcessNote; path : string; child : TMXmlElement) : boolean;
    function ParseExplanationOfBenefitBenefitBalance(element : TMXmlElement; path : string) : TFhirExplanationOfBenefitBenefitBalance;
    function ParseExplanationOfBenefitBenefitBalanceChild(value : TFhirExplanationOfBenefitBenefitBalance; path : string; child : TMXmlElement) : boolean;
    function ParseExplanationOfBenefitBenefitBalanceFinancial(element : TMXmlElement; path : string) : TFhirExplanationOfBenefitBenefitBalanceFinancial;
    function ParseExplanationOfBenefitBenefitBalanceFinancialChild(value : TFhirExplanationOfBenefitBenefitBalanceFinancial; path : string; child : TMXmlElement) : boolean;
    function ParseExplanationOfBenefit(element : TMXmlElement; path : string) : TFhirExplanationOfBenefit;
    function ParseExplanationOfBenefitChild(value : TFhirExplanationOfBenefit; path : string; child : TMXmlElement) : boolean;
{$ENDIF FHIR_EXPLANATIONOFBENEFIT}
{$IFDEF FHIR_FAMILYMEMBERHISTORY}
    function ParseFamilyMemberHistoryCondition(element : TMXmlElement; path : string) : TFhirFamilyMemberHistoryCondition;
    function ParseFamilyMemberHistoryConditionChild(value : TFhirFamilyMemberHistoryCondition; path : string; child : TMXmlElement) : boolean;
    function ParseFamilyMemberHistoryProcedure(element : TMXmlElement; path : string) : TFhirFamilyMemberHistoryProcedure;
    function ParseFamilyMemberHistoryProcedureChild(value : TFhirFamilyMemberHistoryProcedure; path : string; child : TMXmlElement) : boolean;
    function ParseFamilyMemberHistory(element : TMXmlElement; path : string) : TFhirFamilyMemberHistory;
    function ParseFamilyMemberHistoryChild(value : TFhirFamilyMemberHistory; path : string; child : TMXmlElement) : boolean;
{$ENDIF FHIR_FAMILYMEMBERHISTORY}
{$IFDEF FHIR_FLAG}
    function ParseFlag(element : TMXmlElement; path : string) : TFhirFlag;
    function ParseFlagChild(value : TFhirFlag; path : string; child : TMXmlElement) : boolean;
{$ENDIF FHIR_FLAG}
{$IFDEF FHIR_FORMULARYITEM}
    function ParseFormularyItem(element : TMXmlElement; path : string) : TFhirFormularyItem;
    function ParseFormularyItemChild(value : TFhirFormularyItem; path : string; child : TMXmlElement) : boolean;
{$ENDIF FHIR_FORMULARYITEM}
{$IFDEF FHIR_GENOMICSTUDY}
    function ParseGenomicStudyAnalysis(element : TMXmlElement; path : string) : TFhirGenomicStudyAnalysis;
    function ParseGenomicStudyAnalysisChild(value : TFhirGenomicStudyAnalysis; path : string; child : TMXmlElement) : boolean;
    function ParseGenomicStudyAnalysisInput(element : TMXmlElement; path : string) : TFhirGenomicStudyAnalysisInput;
    function ParseGenomicStudyAnalysisInputChild(value : TFhirGenomicStudyAnalysisInput; path : string; child : TMXmlElement) : boolean;
    function ParseGenomicStudyAnalysisOutput(element : TMXmlElement; path : string) : TFhirGenomicStudyAnalysisOutput;
    function ParseGenomicStudyAnalysisOutputChild(value : TFhirGenomicStudyAnalysisOutput; path : string; child : TMXmlElement) : boolean;
    function ParseGenomicStudyAnalysisPerformer(element : TMXmlElement; path : string) : TFhirGenomicStudyAnalysisPerformer;
    function ParseGenomicStudyAnalysisPerformerChild(value : TFhirGenomicStudyAnalysisPerformer; path : string; child : TMXmlElement) : boolean;
    function ParseGenomicStudyAnalysisDevice(element : TMXmlElement; path : string) : TFhirGenomicStudyAnalysisDevice;
    function ParseGenomicStudyAnalysisDeviceChild(value : TFhirGenomicStudyAnalysisDevice; path : string; child : TMXmlElement) : boolean;
    function ParseGenomicStudy(element : TMXmlElement; path : string) : TFhirGenomicStudy;
    function ParseGenomicStudyChild(value : TFhirGenomicStudy; path : string; child : TMXmlElement) : boolean;
{$ENDIF FHIR_GENOMICSTUDY}
{$IFDEF FHIR_GOAL}
    function ParseGoalTarget(element : TMXmlElement; path : string) : TFhirGoalTarget;
    function ParseGoalTargetChild(value : TFhirGoalTarget; path : string; child : TMXmlElement) : boolean;
    function ParseGoal(element : TMXmlElement; path : string) : TFhirGoal;
    function ParseGoalChild(value : TFhirGoal; path : string; child : TMXmlElement) : boolean;
{$ENDIF FHIR_GOAL}
{$IFDEF FHIR_GRAPHDEFINITION}
    function ParseGraphDefinitionLink(element : TMXmlElement; path : string) : TFhirGraphDefinitionLink;
    function ParseGraphDefinitionLinkChild(value : TFhirGraphDefinitionLink; path : string; child : TMXmlElement) : boolean;
    function ParseGraphDefinitionLinkTarget(element : TMXmlElement; path : string) : TFhirGraphDefinitionLinkTarget;
    function ParseGraphDefinitionLinkTargetChild(value : TFhirGraphDefinitionLinkTarget; path : string; child : TMXmlElement) : boolean;
    function ParseGraphDefinitionLinkTargetCompartment(element : TMXmlElement; path : string) : TFhirGraphDefinitionLinkTargetCompartment;
    function ParseGraphDefinitionLinkTargetCompartmentChild(value : TFhirGraphDefinitionLinkTargetCompartment; path : string; child : TMXmlElement) : boolean;
    function ParseGraphDefinition(element : TMXmlElement; path : string) : TFhirGraphDefinition;
    function ParseGraphDefinitionChild(value : TFhirGraphDefinition; path : string; child : TMXmlElement) : boolean;
{$ENDIF FHIR_GRAPHDEFINITION}
{$IFDEF FHIR_GROUP}
    function ParseGroupCharacteristic(element : TMXmlElement; path : string) : TFhirGroupCharacteristic;
    function ParseGroupCharacteristicChild(value : TFhirGroupCharacteristic; path : string; child : TMXmlElement) : boolean;
    function ParseGroupMember(element : TMXmlElement; path : string) : TFhirGroupMember;
    function ParseGroupMemberChild(value : TFhirGroupMember; path : string; child : TMXmlElement) : boolean;
    function ParseGroup(element : TMXmlElement; path : string) : TFhirGroup;
    function ParseGroupChild(value : TFhirGroup; path : string; child : TMXmlElement) : boolean;
{$ENDIF FHIR_GROUP}
{$IFDEF FHIR_GUIDANCERESPONSE}
    function ParseGuidanceResponse(element : TMXmlElement; path : string) : TFhirGuidanceResponse;
    function ParseGuidanceResponseChild(value : TFhirGuidanceResponse; path : string; child : TMXmlElement) : boolean;
{$ENDIF FHIR_GUIDANCERESPONSE}
{$IFDEF FHIR_HEALTHCARESERVICE}
    function ParseHealthcareServiceEligibility(element : TMXmlElement; path : string) : TFhirHealthcareServiceEligibility;
    function ParseHealthcareServiceEligibilityChild(value : TFhirHealthcareServiceEligibility; path : string; child : TMXmlElement) : boolean;
    function ParseHealthcareService(element : TMXmlElement; path : string) : TFhirHealthcareService;
    function ParseHealthcareServiceChild(value : TFhirHealthcareService; path : string; child : TMXmlElement) : boolean;
{$ENDIF FHIR_HEALTHCARESERVICE}
{$IFDEF FHIR_IMAGINGSELECTION}
    function ParseImagingSelectionPerformer(element : TMXmlElement; path : string) : TFhirImagingSelectionPerformer;
    function ParseImagingSelectionPerformerChild(value : TFhirImagingSelectionPerformer; path : string; child : TMXmlElement) : boolean;
    function ParseImagingSelectionInstance(element : TMXmlElement; path : string) : TFhirImagingSelectionInstance;
    function ParseImagingSelectionInstanceChild(value : TFhirImagingSelectionInstance; path : string; child : TMXmlElement) : boolean;
    function ParseImagingSelectionInstanceImageRegion(element : TMXmlElement; path : string) : TFhirImagingSelectionInstanceImageRegion;
    function ParseImagingSelectionInstanceImageRegionChild(value : TFhirImagingSelectionInstanceImageRegion; path : string; child : TMXmlElement) : boolean;
    function ParseImagingSelectionImageRegion(element : TMXmlElement; path : string) : TFhirImagingSelectionImageRegion;
    function ParseImagingSelectionImageRegionChild(value : TFhirImagingSelectionImageRegion; path : string; child : TMXmlElement) : boolean;
    function ParseImagingSelection(element : TMXmlElement; path : string) : TFhirImagingSelection;
    function ParseImagingSelectionChild(value : TFhirImagingSelection; path : string; child : TMXmlElement) : boolean;
{$ENDIF FHIR_IMAGINGSELECTION}
{$IFDEF FHIR_IMAGINGSTUDY}
    function ParseImagingStudySeries(element : TMXmlElement; path : string) : TFhirImagingStudySeries;
    function ParseImagingStudySeriesChild(value : TFhirImagingStudySeries; path : string; child : TMXmlElement) : boolean;
    function ParseImagingStudySeriesPerformer(element : TMXmlElement; path : string) : TFhirImagingStudySeriesPerformer;
    function ParseImagingStudySeriesPerformerChild(value : TFhirImagingStudySeriesPerformer; path : string; child : TMXmlElement) : boolean;
    function ParseImagingStudySeriesInstance(element : TMXmlElement; path : string) : TFhirImagingStudySeriesInstance;
    function ParseImagingStudySeriesInstanceChild(value : TFhirImagingStudySeriesInstance; path : string; child : TMXmlElement) : boolean;
    function ParseImagingStudy(element : TMXmlElement; path : string) : TFhirImagingStudy;
    function ParseImagingStudyChild(value : TFhirImagingStudy; path : string; child : TMXmlElement) : boolean;
{$ENDIF FHIR_IMAGINGSTUDY}
{$IFDEF FHIR_IMMUNIZATION}
    function ParseImmunizationPerformer(element : TMXmlElement; path : string) : TFhirImmunizationPerformer;
    function ParseImmunizationPerformerChild(value : TFhirImmunizationPerformer; path : string; child : TMXmlElement) : boolean;
    function ParseImmunizationProgramEligibility(element : TMXmlElement; path : string) : TFhirImmunizationProgramEligibility;
    function ParseImmunizationProgramEligibilityChild(value : TFhirImmunizationProgramEligibility; path : string; child : TMXmlElement) : boolean;
    function ParseImmunizationReaction(element : TMXmlElement; path : string) : TFhirImmunizationReaction;
    function ParseImmunizationReactionChild(value : TFhirImmunizationReaction; path : string; child : TMXmlElement) : boolean;
    function ParseImmunizationProtocolApplied(element : TMXmlElement; path : string) : TFhirImmunizationProtocolApplied;
    function ParseImmunizationProtocolAppliedChild(value : TFhirImmunizationProtocolApplied; path : string; child : TMXmlElement) : boolean;
    function ParseImmunization(element : TMXmlElement; path : string) : TFhirImmunization;
    function ParseImmunizationChild(value : TFhirImmunization; path : string; child : TMXmlElement) : boolean;
{$ENDIF FHIR_IMMUNIZATION}
{$IFDEF FHIR_IMMUNIZATIONEVALUATION}
    function ParseImmunizationEvaluation(element : TMXmlElement; path : string) : TFhirImmunizationEvaluation;
    function ParseImmunizationEvaluationChild(value : TFhirImmunizationEvaluation; path : string; child : TMXmlElement) : boolean;
{$ENDIF FHIR_IMMUNIZATIONEVALUATION}
{$IFDEF FHIR_IMMUNIZATIONRECOMMENDATION}
    function ParseImmunizationRecommendationRecommendation(element : TMXmlElement; path : string) : TFhirImmunizationRecommendationRecommendation;
    function ParseImmunizationRecommendationRecommendationChild(value : TFhirImmunizationRecommendationRecommendation; path : string; child : TMXmlElement) : boolean;
    function ParseImmunizationRecommendationRecommendationDateCriterion(element : TMXmlElement; path : string) : TFhirImmunizationRecommendationRecommendationDateCriterion;
    function ParseImmunizationRecommendationRecommendationDateCriterionChild(value : TFhirImmunizationRecommendationRecommendationDateCriterion; path : string; child : TMXmlElement) : boolean;
    function ParseImmunizationRecommendation(element : TMXmlElement; path : string) : TFhirImmunizationRecommendation;
    function ParseImmunizationRecommendationChild(value : TFhirImmunizationRecommendation; path : string; child : TMXmlElement) : boolean;
{$ENDIF FHIR_IMMUNIZATIONRECOMMENDATION}
{$IFDEF FHIR_IMPLEMENTATIONGUIDE}
    function ParseImplementationGuideDependsOn(element : TMXmlElement; path : string) : TFhirImplementationGuideDependsOn;
    function ParseImplementationGuideDependsOnChild(value : TFhirImplementationGuideDependsOn; path : string; child : TMXmlElement) : boolean;
    function ParseImplementationGuideGlobal(element : TMXmlElement; path : string) : TFhirImplementationGuideGlobal;
    function ParseImplementationGuideGlobalChild(value : TFhirImplementationGuideGlobal; path : string; child : TMXmlElement) : boolean;
    function ParseImplementationGuideDefinition(element : TMXmlElement; path : string) : TFhirImplementationGuideDefinition;
    function ParseImplementationGuideDefinitionChild(value : TFhirImplementationGuideDefinition; path : string; child : TMXmlElement) : boolean;
    function ParseImplementationGuideDefinitionGrouping(element : TMXmlElement; path : string) : TFhirImplementationGuideDefinitionGrouping;
    function ParseImplementationGuideDefinitionGroupingChild(value : TFhirImplementationGuideDefinitionGrouping; path : string; child : TMXmlElement) : boolean;
    function ParseImplementationGuideDefinitionResource(element : TMXmlElement; path : string) : TFhirImplementationGuideDefinitionResource;
    function ParseImplementationGuideDefinitionResourceChild(value : TFhirImplementationGuideDefinitionResource; path : string; child : TMXmlElement) : boolean;
    function ParseImplementationGuideDefinitionPage(element : TMXmlElement; path : string) : TFhirImplementationGuideDefinitionPage;
    function ParseImplementationGuideDefinitionPageChild(value : TFhirImplementationGuideDefinitionPage; path : string; child : TMXmlElement) : boolean;
    function ParseImplementationGuideDefinitionParameter(element : TMXmlElement; path : string) : TFhirImplementationGuideDefinitionParameter;
    function ParseImplementationGuideDefinitionParameterChild(value : TFhirImplementationGuideDefinitionParameter; path : string; child : TMXmlElement) : boolean;
    function ParseImplementationGuideDefinitionTemplate(element : TMXmlElement; path : string) : TFhirImplementationGuideDefinitionTemplate;
    function ParseImplementationGuideDefinitionTemplateChild(value : TFhirImplementationGuideDefinitionTemplate; path : string; child : TMXmlElement) : boolean;
    function ParseImplementationGuideManifest(element : TMXmlElement; path : string) : TFhirImplementationGuideManifest;
    function ParseImplementationGuideManifestChild(value : TFhirImplementationGuideManifest; path : string; child : TMXmlElement) : boolean;
    function ParseImplementationGuideManifestResource(element : TMXmlElement; path : string) : TFhirImplementationGuideManifestResource;
    function ParseImplementationGuideManifestResourceChild(value : TFhirImplementationGuideManifestResource; path : string; child : TMXmlElement) : boolean;
    function ParseImplementationGuideManifestPage(element : TMXmlElement; path : string) : TFhirImplementationGuideManifestPage;
    function ParseImplementationGuideManifestPageChild(value : TFhirImplementationGuideManifestPage; path : string; child : TMXmlElement) : boolean;
    function ParseImplementationGuide(element : TMXmlElement; path : string) : TFhirImplementationGuide;
    function ParseImplementationGuideChild(value : TFhirImplementationGuide; path : string; child : TMXmlElement) : boolean;
{$ENDIF FHIR_IMPLEMENTATIONGUIDE}
{$IFDEF FHIR_INGREDIENT}
    function ParseIngredientManufacturer(element : TMXmlElement; path : string) : TFhirIngredientManufacturer;
    function ParseIngredientManufacturerChild(value : TFhirIngredientManufacturer; path : string; child : TMXmlElement) : boolean;
    function ParseIngredientSubstance(element : TMXmlElement; path : string) : TFhirIngredientSubstance;
    function ParseIngredientSubstanceChild(value : TFhirIngredientSubstance; path : string; child : TMXmlElement) : boolean;
    function ParseIngredientSubstanceStrength(element : TMXmlElement; path : string) : TFhirIngredientSubstanceStrength;
    function ParseIngredientSubstanceStrengthChild(value : TFhirIngredientSubstanceStrength; path : string; child : TMXmlElement) : boolean;
    function ParseIngredientSubstanceStrengthReferenceStrength(element : TMXmlElement; path : string) : TFhirIngredientSubstanceStrengthReferenceStrength;
    function ParseIngredientSubstanceStrengthReferenceStrengthChild(value : TFhirIngredientSubstanceStrengthReferenceStrength; path : string; child : TMXmlElement) : boolean;
    function ParseIngredient(element : TMXmlElement; path : string) : TFhirIngredient;
    function ParseIngredientChild(value : TFhirIngredient; path : string; child : TMXmlElement) : boolean;
{$ENDIF FHIR_INGREDIENT}
{$IFDEF FHIR_INSURANCEPLAN}
    function ParseInsurancePlanCoverage(element : TMXmlElement; path : string) : TFhirInsurancePlanCoverage;
    function ParseInsurancePlanCoverageChild(value : TFhirInsurancePlanCoverage; path : string; child : TMXmlElement) : boolean;
    function ParseInsurancePlanCoverageBenefit(element : TMXmlElement; path : string) : TFhirInsurancePlanCoverageBenefit;
    function ParseInsurancePlanCoverageBenefitChild(value : TFhirInsurancePlanCoverageBenefit; path : string; child : TMXmlElement) : boolean;
    function ParseInsurancePlanCoverageBenefitLimit(element : TMXmlElement; path : string) : TFhirInsurancePlanCoverageBenefitLimit;
    function ParseInsurancePlanCoverageBenefitLimitChild(value : TFhirInsurancePlanCoverageBenefitLimit; path : string; child : TMXmlElement) : boolean;
    function ParseInsurancePlanPlan(element : TMXmlElement; path : string) : TFhirInsurancePlanPlan;
    function ParseInsurancePlanPlanChild(value : TFhirInsurancePlanPlan; path : string; child : TMXmlElement) : boolean;
    function ParseInsurancePlanPlanGeneralCost(element : TMXmlElement; path : string) : TFhirInsurancePlanPlanGeneralCost;
    function ParseInsurancePlanPlanGeneralCostChild(value : TFhirInsurancePlanPlanGeneralCost; path : string; child : TMXmlElement) : boolean;
    function ParseInsurancePlanPlanSpecificCost(element : TMXmlElement; path : string) : TFhirInsurancePlanPlanSpecificCost;
    function ParseInsurancePlanPlanSpecificCostChild(value : TFhirInsurancePlanPlanSpecificCost; path : string; child : TMXmlElement) : boolean;
    function ParseInsurancePlanPlanSpecificCostBenefit(element : TMXmlElement; path : string) : TFhirInsurancePlanPlanSpecificCostBenefit;
    function ParseInsurancePlanPlanSpecificCostBenefitChild(value : TFhirInsurancePlanPlanSpecificCostBenefit; path : string; child : TMXmlElement) : boolean;
    function ParseInsurancePlanPlanSpecificCostBenefitCost(element : TMXmlElement; path : string) : TFhirInsurancePlanPlanSpecificCostBenefitCost;
    function ParseInsurancePlanPlanSpecificCostBenefitCostChild(value : TFhirInsurancePlanPlanSpecificCostBenefitCost; path : string; child : TMXmlElement) : boolean;
    function ParseInsurancePlan(element : TMXmlElement; path : string) : TFhirInsurancePlan;
    function ParseInsurancePlanChild(value : TFhirInsurancePlan; path : string; child : TMXmlElement) : boolean;
{$ENDIF FHIR_INSURANCEPLAN}
{$IFDEF FHIR_INVENTORYREPORT}
    function ParseInventoryReportInventoryListing(element : TMXmlElement; path : string) : TFhirInventoryReportInventoryListing;
    function ParseInventoryReportInventoryListingChild(value : TFhirInventoryReportInventoryListing; path : string; child : TMXmlElement) : boolean;
    function ParseInventoryReportInventoryListingItems(element : TMXmlElement; path : string) : TFhirInventoryReportInventoryListingItems;
    function ParseInventoryReportInventoryListingItemsChild(value : TFhirInventoryReportInventoryListingItems; path : string; child : TMXmlElement) : boolean;
    function ParseInventoryReport(element : TMXmlElement; path : string) : TFhirInventoryReport;
    function ParseInventoryReportChild(value : TFhirInventoryReport; path : string; child : TMXmlElement) : boolean;
{$ENDIF FHIR_INVENTORYREPORT}
{$IFDEF FHIR_INVOICE}
    function ParseInvoiceParticipant(element : TMXmlElement; path : string) : TFhirInvoiceParticipant;
    function ParseInvoiceParticipantChild(value : TFhirInvoiceParticipant; path : string; child : TMXmlElement) : boolean;
    function ParseInvoiceLineItem(element : TMXmlElement; path : string) : TFhirInvoiceLineItem;
    function ParseInvoiceLineItemChild(value : TFhirInvoiceLineItem; path : string; child : TMXmlElement) : boolean;
    function ParseInvoice(element : TMXmlElement; path : string) : TFhirInvoice;
    function ParseInvoiceChild(value : TFhirInvoice; path : string; child : TMXmlElement) : boolean;
{$ENDIF FHIR_INVOICE}
{$IFDEF FHIR_LIBRARY}
    function ParseLibrary(element : TMXmlElement; path : string) : TFhirLibrary;
    function ParseLibraryChild(value : TFhirLibrary; path : string; child : TMXmlElement) : boolean;
{$ENDIF FHIR_LIBRARY}
{$IFDEF FHIR_LINKAGE}
    function ParseLinkageItem(element : TMXmlElement; path : string) : TFhirLinkageItem;
    function ParseLinkageItemChild(value : TFhirLinkageItem; path : string; child : TMXmlElement) : boolean;
    function ParseLinkage(element : TMXmlElement; path : string) : TFhirLinkage;
    function ParseLinkageChild(value : TFhirLinkage; path : string; child : TMXmlElement) : boolean;
{$ENDIF FHIR_LINKAGE}
{$IFDEF FHIR_LIST}
    function ParseListEntry(element : TMXmlElement; path : string) : TFhirListEntry;
    function ParseListEntryChild(value : TFhirListEntry; path : string; child : TMXmlElement) : boolean;
    function ParseList(element : TMXmlElement; path : string) : TFhirList;
    function ParseListChild(value : TFhirList; path : string; child : TMXmlElement) : boolean;
{$ENDIF FHIR_LIST}
{$IFDEF FHIR_LOCATION}
    function ParseLocationPosition(element : TMXmlElement; path : string) : TFhirLocationPosition;
    function ParseLocationPositionChild(value : TFhirLocationPosition; path : string; child : TMXmlElement) : boolean;
    function ParseLocation(element : TMXmlElement; path : string) : TFhirLocation;
    function ParseLocationChild(value : TFhirLocation; path : string; child : TMXmlElement) : boolean;
{$ENDIF FHIR_LOCATION}
{$IFDEF FHIR_MANUFACTUREDITEMDEFINITION}
    function ParseManufacturedItemDefinitionProperty(element : TMXmlElement; path : string) : TFhirManufacturedItemDefinitionProperty;
    function ParseManufacturedItemDefinitionPropertyChild(value : TFhirManufacturedItemDefinitionProperty; path : string; child : TMXmlElement) : boolean;
    function ParseManufacturedItemDefinitionComponent(element : TMXmlElement; path : string) : TFhirManufacturedItemDefinitionComponent;
    function ParseManufacturedItemDefinitionComponentChild(value : TFhirManufacturedItemDefinitionComponent; path : string; child : TMXmlElement) : boolean;
    function ParseManufacturedItemDefinitionComponentConstituent(element : TMXmlElement; path : string) : TFhirManufacturedItemDefinitionComponentConstituent;
    function ParseManufacturedItemDefinitionComponentConstituentChild(value : TFhirManufacturedItemDefinitionComponentConstituent; path : string; child : TMXmlElement) : boolean;
    function ParseManufacturedItemDefinition(element : TMXmlElement; path : string) : TFhirManufacturedItemDefinition;
    function ParseManufacturedItemDefinitionChild(value : TFhirManufacturedItemDefinition; path : string; child : TMXmlElement) : boolean;
{$ENDIF FHIR_MANUFACTUREDITEMDEFINITION}
{$IFDEF FHIR_MEASURE}
    function ParseMeasureTerm(element : TMXmlElement; path : string) : TFhirMeasureTerm;
    function ParseMeasureTermChild(value : TFhirMeasureTerm; path : string; child : TMXmlElement) : boolean;
    function ParseMeasureGroup(element : TMXmlElement; path : string) : TFhirMeasureGroup;
    function ParseMeasureGroupChild(value : TFhirMeasureGroup; path : string; child : TMXmlElement) : boolean;
    function ParseMeasureGroupPopulation(element : TMXmlElement; path : string) : TFhirMeasureGroupPopulation;
    function ParseMeasureGroupPopulationChild(value : TFhirMeasureGroupPopulation; path : string; child : TMXmlElement) : boolean;
    function ParseMeasureGroupStratifier(element : TMXmlElement; path : string) : TFhirMeasureGroupStratifier;
    function ParseMeasureGroupStratifierChild(value : TFhirMeasureGroupStratifier; path : string; child : TMXmlElement) : boolean;
    function ParseMeasureGroupStratifierComponent(element : TMXmlElement; path : string) : TFhirMeasureGroupStratifierComponent;
    function ParseMeasureGroupStratifierComponentChild(value : TFhirMeasureGroupStratifierComponent; path : string; child : TMXmlElement) : boolean;
    function ParseMeasureSupplementalData(element : TMXmlElement; path : string) : TFhirMeasureSupplementalData;
    function ParseMeasureSupplementalDataChild(value : TFhirMeasureSupplementalData; path : string; child : TMXmlElement) : boolean;
    function ParseMeasure(element : TMXmlElement; path : string) : TFhirMeasure;
    function ParseMeasureChild(value : TFhirMeasure; path : string; child : TMXmlElement) : boolean;
{$ENDIF FHIR_MEASURE}
{$IFDEF FHIR_MEASUREREPORT}
    function ParseMeasureReportGroup(element : TMXmlElement; path : string) : TFhirMeasureReportGroup;
    function ParseMeasureReportGroupChild(value : TFhirMeasureReportGroup; path : string; child : TMXmlElement) : boolean;
    function ParseMeasureReportGroupPopulation(element : TMXmlElement; path : string) : TFhirMeasureReportGroupPopulation;
    function ParseMeasureReportGroupPopulationChild(value : TFhirMeasureReportGroupPopulation; path : string; child : TMXmlElement) : boolean;
    function ParseMeasureReportGroupStratifier(element : TMXmlElement; path : string) : TFhirMeasureReportGroupStratifier;
    function ParseMeasureReportGroupStratifierChild(value : TFhirMeasureReportGroupStratifier; path : string; child : TMXmlElement) : boolean;
    function ParseMeasureReportGroupStratifierStratum(element : TMXmlElement; path : string) : TFhirMeasureReportGroupStratifierStratum;
    function ParseMeasureReportGroupStratifierStratumChild(value : TFhirMeasureReportGroupStratifierStratum; path : string; child : TMXmlElement) : boolean;
    function ParseMeasureReportGroupStratifierStratumComponent(element : TMXmlElement; path : string) : TFhirMeasureReportGroupStratifierStratumComponent;
    function ParseMeasureReportGroupStratifierStratumComponentChild(value : TFhirMeasureReportGroupStratifierStratumComponent; path : string; child : TMXmlElement) : boolean;
    function ParseMeasureReportGroupStratifierStratumPopulation(element : TMXmlElement; path : string) : TFhirMeasureReportGroupStratifierStratumPopulation;
    function ParseMeasureReportGroupStratifierStratumPopulationChild(value : TFhirMeasureReportGroupStratifierStratumPopulation; path : string; child : TMXmlElement) : boolean;
    function ParseMeasureReport(element : TMXmlElement; path : string) : TFhirMeasureReport;
    function ParseMeasureReportChild(value : TFhirMeasureReport; path : string; child : TMXmlElement) : boolean;
{$ENDIF FHIR_MEASUREREPORT}
{$IFDEF FHIR_MEDICATION}
    function ParseMedicationIngredient(element : TMXmlElement; path : string) : TFhirMedicationIngredient;
    function ParseMedicationIngredientChild(value : TFhirMedicationIngredient; path : string; child : TMXmlElement) : boolean;
    function ParseMedicationBatch(element : TMXmlElement; path : string) : TFhirMedicationBatch;
    function ParseMedicationBatchChild(value : TFhirMedicationBatch; path : string; child : TMXmlElement) : boolean;
    function ParseMedication(element : TMXmlElement; path : string) : TFhirMedication;
    function ParseMedicationChild(value : TFhirMedication; path : string; child : TMXmlElement) : boolean;
{$ENDIF FHIR_MEDICATION}
{$IFDEF FHIR_MEDICATIONADMINISTRATION}
    function ParseMedicationAdministrationPerformer(element : TMXmlElement; path : string) : TFhirMedicationAdministrationPerformer;
    function ParseMedicationAdministrationPerformerChild(value : TFhirMedicationAdministrationPerformer; path : string; child : TMXmlElement) : boolean;
    function ParseMedicationAdministrationDosage(element : TMXmlElement; path : string) : TFhirMedicationAdministrationDosage;
    function ParseMedicationAdministrationDosageChild(value : TFhirMedicationAdministrationDosage; path : string; child : TMXmlElement) : boolean;
    function ParseMedicationAdministration(element : TMXmlElement; path : string) : TFhirMedicationAdministration;
    function ParseMedicationAdministrationChild(value : TFhirMedicationAdministration; path : string; child : TMXmlElement) : boolean;
{$ENDIF FHIR_MEDICATIONADMINISTRATION}
{$IFDEF FHIR_MEDICATIONDISPENSE}
    function ParseMedicationDispensePerformer(element : TMXmlElement; path : string) : TFhirMedicationDispensePerformer;
    function ParseMedicationDispensePerformerChild(value : TFhirMedicationDispensePerformer; path : string; child : TMXmlElement) : boolean;
    function ParseMedicationDispenseSubstitution(element : TMXmlElement; path : string) : TFhirMedicationDispenseSubstitution;
    function ParseMedicationDispenseSubstitutionChild(value : TFhirMedicationDispenseSubstitution; path : string; child : TMXmlElement) : boolean;
    function ParseMedicationDispense(element : TMXmlElement; path : string) : TFhirMedicationDispense;
    function ParseMedicationDispenseChild(value : TFhirMedicationDispense; path : string; child : TMXmlElement) : boolean;
{$ENDIF FHIR_MEDICATIONDISPENSE}
{$IFDEF FHIR_MEDICATIONKNOWLEDGE}
    function ParseMedicationKnowledgeRelatedMedicationKnowledge(element : TMXmlElement; path : string) : TFhirMedicationKnowledgeRelatedMedicationKnowledge;
    function ParseMedicationKnowledgeRelatedMedicationKnowledgeChild(value : TFhirMedicationKnowledgeRelatedMedicationKnowledge; path : string; child : TMXmlElement) : boolean;
    function ParseMedicationKnowledgeMonograph(element : TMXmlElement; path : string) : TFhirMedicationKnowledgeMonograph;
    function ParseMedicationKnowledgeMonographChild(value : TFhirMedicationKnowledgeMonograph; path : string; child : TMXmlElement) : boolean;
    function ParseMedicationKnowledgeCost(element : TMXmlElement; path : string) : TFhirMedicationKnowledgeCost;
    function ParseMedicationKnowledgeCostChild(value : TFhirMedicationKnowledgeCost; path : string; child : TMXmlElement) : boolean;
    function ParseMedicationKnowledgeMonitoringProgram(element : TMXmlElement; path : string) : TFhirMedicationKnowledgeMonitoringProgram;
    function ParseMedicationKnowledgeMonitoringProgramChild(value : TFhirMedicationKnowledgeMonitoringProgram; path : string; child : TMXmlElement) : boolean;
    function ParseMedicationKnowledgeIndicationGuideline(element : TMXmlElement; path : string) : TFhirMedicationKnowledgeIndicationGuideline;
    function ParseMedicationKnowledgeIndicationGuidelineChild(value : TFhirMedicationKnowledgeIndicationGuideline; path : string; child : TMXmlElement) : boolean;
    function ParseMedicationKnowledgeIndicationGuidelineDosingGuideline(element : TMXmlElement; path : string) : TFhirMedicationKnowledgeIndicationGuidelineDosingGuideline;
    function ParseMedicationKnowledgeIndicationGuidelineDosingGuidelineChild(value : TFhirMedicationKnowledgeIndicationGuidelineDosingGuideline; path : string; child : TMXmlElement) : boolean;
    function ParseMedicationKnowledgeIndicationGuidelineDosingGuidelineDosage(element : TMXmlElement; path : string) : TFhirMedicationKnowledgeIndicationGuidelineDosingGuidelineDosage;
    function ParseMedicationKnowledgeIndicationGuidelineDosingGuidelineDosageChild(value : TFhirMedicationKnowledgeIndicationGuidelineDosingGuidelineDosage; path : string; child : TMXmlElement) : boolean;
    function ParseMedicationKnowledgeIndicationGuidelineDosingGuidelinePatientCharacteristic(element : TMXmlElement; path : string) : TFhirMedicationKnowledgeIndicationGuidelineDosingGuidelinePatientCharacteristic;
    function ParseMedicationKnowledgeIndicationGuidelineDosingGuidelinePatientCharacteristicChild(value : TFhirMedicationKnowledgeIndicationGuidelineDosingGuidelinePatientCharacteristic; path : string; child : TMXmlElement) : boolean;
    function ParseMedicationKnowledgeMedicineClassification(element : TMXmlElement; path : string) : TFhirMedicationKnowledgeMedicineClassification;
    function ParseMedicationKnowledgeMedicineClassificationChild(value : TFhirMedicationKnowledgeMedicineClassification; path : string; child : TMXmlElement) : boolean;
    function ParseMedicationKnowledgePackaging(element : TMXmlElement; path : string) : TFhirMedicationKnowledgePackaging;
    function ParseMedicationKnowledgePackagingChild(value : TFhirMedicationKnowledgePackaging; path : string; child : TMXmlElement) : boolean;
    function ParseMedicationKnowledgeStorageGuideline(element : TMXmlElement; path : string) : TFhirMedicationKnowledgeStorageGuideline;
    function ParseMedicationKnowledgeStorageGuidelineChild(value : TFhirMedicationKnowledgeStorageGuideline; path : string; child : TMXmlElement) : boolean;
    function ParseMedicationKnowledgeStorageGuidelineEnvironmentalSetting(element : TMXmlElement; path : string) : TFhirMedicationKnowledgeStorageGuidelineEnvironmentalSetting;
    function ParseMedicationKnowledgeStorageGuidelineEnvironmentalSettingChild(value : TFhirMedicationKnowledgeStorageGuidelineEnvironmentalSetting; path : string; child : TMXmlElement) : boolean;
    function ParseMedicationKnowledgeRegulatory(element : TMXmlElement; path : string) : TFhirMedicationKnowledgeRegulatory;
    function ParseMedicationKnowledgeRegulatoryChild(value : TFhirMedicationKnowledgeRegulatory; path : string; child : TMXmlElement) : boolean;
    function ParseMedicationKnowledgeRegulatorySubstitution(element : TMXmlElement; path : string) : TFhirMedicationKnowledgeRegulatorySubstitution;
    function ParseMedicationKnowledgeRegulatorySubstitutionChild(value : TFhirMedicationKnowledgeRegulatorySubstitution; path : string; child : TMXmlElement) : boolean;
    function ParseMedicationKnowledgeRegulatoryMaxDispense(element : TMXmlElement; path : string) : TFhirMedicationKnowledgeRegulatoryMaxDispense;
    function ParseMedicationKnowledgeRegulatoryMaxDispenseChild(value : TFhirMedicationKnowledgeRegulatoryMaxDispense; path : string; child : TMXmlElement) : boolean;
    function ParseMedicationKnowledgeDefinitional(element : TMXmlElement; path : string) : TFhirMedicationKnowledgeDefinitional;
    function ParseMedicationKnowledgeDefinitionalChild(value : TFhirMedicationKnowledgeDefinitional; path : string; child : TMXmlElement) : boolean;
    function ParseMedicationKnowledgeDefinitionalIngredient(element : TMXmlElement; path : string) : TFhirMedicationKnowledgeDefinitionalIngredient;
    function ParseMedicationKnowledgeDefinitionalIngredientChild(value : TFhirMedicationKnowledgeDefinitionalIngredient; path : string; child : TMXmlElement) : boolean;
    function ParseMedicationKnowledgeDefinitionalDrugCharacteristic(element : TMXmlElement; path : string) : TFhirMedicationKnowledgeDefinitionalDrugCharacteristic;
    function ParseMedicationKnowledgeDefinitionalDrugCharacteristicChild(value : TFhirMedicationKnowledgeDefinitionalDrugCharacteristic; path : string; child : TMXmlElement) : boolean;
    function ParseMedicationKnowledge(element : TMXmlElement; path : string) : TFhirMedicationKnowledge;
    function ParseMedicationKnowledgeChild(value : TFhirMedicationKnowledge; path : string; child : TMXmlElement) : boolean;
{$ENDIF FHIR_MEDICATIONKNOWLEDGE}
{$IFDEF FHIR_MEDICATIONREQUEST}
    function ParseMedicationRequestDose(element : TMXmlElement; path : string) : TFhirMedicationRequestDose;
    function ParseMedicationRequestDoseChild(value : TFhirMedicationRequestDose; path : string; child : TMXmlElement) : boolean;
    function ParseMedicationRequestDispenseRequest(element : TMXmlElement; path : string) : TFhirMedicationRequestDispenseRequest;
    function ParseMedicationRequestDispenseRequestChild(value : TFhirMedicationRequestDispenseRequest; path : string; child : TMXmlElement) : boolean;
    function ParseMedicationRequestDispenseRequestInitialFill(element : TMXmlElement; path : string) : TFhirMedicationRequestDispenseRequestInitialFill;
    function ParseMedicationRequestDispenseRequestInitialFillChild(value : TFhirMedicationRequestDispenseRequestInitialFill; path : string; child : TMXmlElement) : boolean;
    function ParseMedicationRequestSubstitution(element : TMXmlElement; path : string) : TFhirMedicationRequestSubstitution;
    function ParseMedicationRequestSubstitutionChild(value : TFhirMedicationRequestSubstitution; path : string; child : TMXmlElement) : boolean;
    function ParseMedicationRequest(element : TMXmlElement; path : string) : TFhirMedicationRequest;
    function ParseMedicationRequestChild(value : TFhirMedicationRequest; path : string; child : TMXmlElement) : boolean;
{$ENDIF FHIR_MEDICATIONREQUEST}
{$IFDEF FHIR_MEDICATIONUSAGE}
    function ParseMedicationUsageAdherence(element : TMXmlElement; path : string) : TFhirMedicationUsageAdherence;
    function ParseMedicationUsageAdherenceChild(value : TFhirMedicationUsageAdherence; path : string; child : TMXmlElement) : boolean;
    function ParseMedicationUsage(element : TMXmlElement; path : string) : TFhirMedicationUsage;
    function ParseMedicationUsageChild(value : TFhirMedicationUsage; path : string; child : TMXmlElement) : boolean;
{$ENDIF FHIR_MEDICATIONUSAGE}
{$IFDEF FHIR_MEDICINALPRODUCTDEFINITION}
    function ParseMedicinalProductDefinitionContact(element : TMXmlElement; path : string) : TFhirMedicinalProductDefinitionContact;
    function ParseMedicinalProductDefinitionContactChild(value : TFhirMedicinalProductDefinitionContact; path : string; child : TMXmlElement) : boolean;
    function ParseMedicinalProductDefinitionName(element : TMXmlElement; path : string) : TFhirMedicinalProductDefinitionName;
    function ParseMedicinalProductDefinitionNameChild(value : TFhirMedicinalProductDefinitionName; path : string; child : TMXmlElement) : boolean;
    function ParseMedicinalProductDefinitionNamePart(element : TMXmlElement; path : string) : TFhirMedicinalProductDefinitionNamePart;
    function ParseMedicinalProductDefinitionNamePartChild(value : TFhirMedicinalProductDefinitionNamePart; path : string; child : TMXmlElement) : boolean;
    function ParseMedicinalProductDefinitionNameUsage(element : TMXmlElement; path : string) : TFhirMedicinalProductDefinitionNameUsage;
    function ParseMedicinalProductDefinitionNameUsageChild(value : TFhirMedicinalProductDefinitionNameUsage; path : string; child : TMXmlElement) : boolean;
    function ParseMedicinalProductDefinitionCrossReference(element : TMXmlElement; path : string) : TFhirMedicinalProductDefinitionCrossReference;
    function ParseMedicinalProductDefinitionCrossReferenceChild(value : TFhirMedicinalProductDefinitionCrossReference; path : string; child : TMXmlElement) : boolean;
    function ParseMedicinalProductDefinitionOperation(element : TMXmlElement; path : string) : TFhirMedicinalProductDefinitionOperation;
    function ParseMedicinalProductDefinitionOperationChild(value : TFhirMedicinalProductDefinitionOperation; path : string; child : TMXmlElement) : boolean;
    function ParseMedicinalProductDefinitionCharacteristic(element : TMXmlElement; path : string) : TFhirMedicinalProductDefinitionCharacteristic;
    function ParseMedicinalProductDefinitionCharacteristicChild(value : TFhirMedicinalProductDefinitionCharacteristic; path : string; child : TMXmlElement) : boolean;
    function ParseMedicinalProductDefinition(element : TMXmlElement; path : string) : TFhirMedicinalProductDefinition;
    function ParseMedicinalProductDefinitionChild(value : TFhirMedicinalProductDefinition; path : string; child : TMXmlElement) : boolean;
{$ENDIF FHIR_MEDICINALPRODUCTDEFINITION}
{$IFDEF FHIR_MESSAGEDEFINITION}
    function ParseMessageDefinitionFocus(element : TMXmlElement; path : string) : TFhirMessageDefinitionFocus;
    function ParseMessageDefinitionFocusChild(value : TFhirMessageDefinitionFocus; path : string; child : TMXmlElement) : boolean;
    function ParseMessageDefinitionAllowedResponse(element : TMXmlElement; path : string) : TFhirMessageDefinitionAllowedResponse;
    function ParseMessageDefinitionAllowedResponseChild(value : TFhirMessageDefinitionAllowedResponse; path : string; child : TMXmlElement) : boolean;
    function ParseMessageDefinition(element : TMXmlElement; path : string) : TFhirMessageDefinition;
    function ParseMessageDefinitionChild(value : TFhirMessageDefinition; path : string; child : TMXmlElement) : boolean;
{$ENDIF FHIR_MESSAGEDEFINITION}
{$IFDEF FHIR_MESSAGEHEADER}
    function ParseMessageHeaderDestination(element : TMXmlElement; path : string) : TFhirMessageHeaderDestination;
    function ParseMessageHeaderDestinationChild(value : TFhirMessageHeaderDestination; path : string; child : TMXmlElement) : boolean;
    function ParseMessageHeaderSource(element : TMXmlElement; path : string) : TFhirMessageHeaderSource;
    function ParseMessageHeaderSourceChild(value : TFhirMessageHeaderSource; path : string; child : TMXmlElement) : boolean;
    function ParseMessageHeaderResponse(element : TMXmlElement; path : string) : TFhirMessageHeaderResponse;
    function ParseMessageHeaderResponseChild(value : TFhirMessageHeaderResponse; path : string; child : TMXmlElement) : boolean;
    function ParseMessageHeader(element : TMXmlElement; path : string) : TFhirMessageHeader;
    function ParseMessageHeaderChild(value : TFhirMessageHeader; path : string; child : TMXmlElement) : boolean;
{$ENDIF FHIR_MESSAGEHEADER}
{$IFDEF FHIR_MOLECULARSEQUENCE}
    function ParseMolecularSequenceRelative(element : TMXmlElement; path : string) : TFhirMolecularSequenceRelative;
    function ParseMolecularSequenceRelativeChild(value : TFhirMolecularSequenceRelative; path : string; child : TMXmlElement) : boolean;
    function ParseMolecularSequenceRelativeStartingSequence(element : TMXmlElement; path : string) : TFhirMolecularSequenceRelativeStartingSequence;
    function ParseMolecularSequenceRelativeStartingSequenceChild(value : TFhirMolecularSequenceRelativeStartingSequence; path : string; child : TMXmlElement) : boolean;
    function ParseMolecularSequenceRelativeEdit(element : TMXmlElement; path : string) : TFhirMolecularSequenceRelativeEdit;
    function ParseMolecularSequenceRelativeEditChild(value : TFhirMolecularSequenceRelativeEdit; path : string; child : TMXmlElement) : boolean;
    function ParseMolecularSequence(element : TMXmlElement; path : string) : TFhirMolecularSequence;
    function ParseMolecularSequenceChild(value : TFhirMolecularSequence; path : string; child : TMXmlElement) : boolean;
{$ENDIF FHIR_MOLECULARSEQUENCE}
{$IFDEF FHIR_NAMINGSYSTEM}
    function ParseNamingSystemUniqueId(element : TMXmlElement; path : string) : TFhirNamingSystemUniqueId;
    function ParseNamingSystemUniqueIdChild(value : TFhirNamingSystemUniqueId; path : string; child : TMXmlElement) : boolean;
    function ParseNamingSystem(element : TMXmlElement; path : string) : TFhirNamingSystem;
    function ParseNamingSystemChild(value : TFhirNamingSystem; path : string; child : TMXmlElement) : boolean;
{$ENDIF FHIR_NAMINGSYSTEM}
{$IFDEF FHIR_NUTRITIONINTAKE}
    function ParseNutritionIntakeConsumedItem(element : TMXmlElement; path : string) : TFhirNutritionIntakeConsumedItem;
    function ParseNutritionIntakeConsumedItemChild(value : TFhirNutritionIntakeConsumedItem; path : string; child : TMXmlElement) : boolean;
    function ParseNutritionIntakeIngredientLabel(element : TMXmlElement; path : string) : TFhirNutritionIntakeIngredientLabel;
    function ParseNutritionIntakeIngredientLabelChild(value : TFhirNutritionIntakeIngredientLabel; path : string; child : TMXmlElement) : boolean;
    function ParseNutritionIntakePerformer(element : TMXmlElement; path : string) : TFhirNutritionIntakePerformer;
    function ParseNutritionIntakePerformerChild(value : TFhirNutritionIntakePerformer; path : string; child : TMXmlElement) : boolean;
    function ParseNutritionIntake(element : TMXmlElement; path : string) : TFhirNutritionIntake;
    function ParseNutritionIntakeChild(value : TFhirNutritionIntake; path : string; child : TMXmlElement) : boolean;
{$ENDIF FHIR_NUTRITIONINTAKE}
{$IFDEF FHIR_NUTRITIONORDER}
    function ParseNutritionOrderOralDiet(element : TMXmlElement; path : string) : TFhirNutritionOrderOralDiet;
    function ParseNutritionOrderOralDietChild(value : TFhirNutritionOrderOralDiet; path : string; child : TMXmlElement) : boolean;
    function ParseNutritionOrderOralDietSchedule(element : TMXmlElement; path : string) : TFhirNutritionOrderOralDietSchedule;
    function ParseNutritionOrderOralDietScheduleChild(value : TFhirNutritionOrderOralDietSchedule; path : string; child : TMXmlElement) : boolean;
    function ParseNutritionOrderOralDietNutrient(element : TMXmlElement; path : string) : TFhirNutritionOrderOralDietNutrient;
    function ParseNutritionOrderOralDietNutrientChild(value : TFhirNutritionOrderOralDietNutrient; path : string; child : TMXmlElement) : boolean;
    function ParseNutritionOrderOralDietTexture(element : TMXmlElement; path : string) : TFhirNutritionOrderOralDietTexture;
    function ParseNutritionOrderOralDietTextureChild(value : TFhirNutritionOrderOralDietTexture; path : string; child : TMXmlElement) : boolean;
    function ParseNutritionOrderSupplement(element : TMXmlElement; path : string) : TFhirNutritionOrderSupplement;
    function ParseNutritionOrderSupplementChild(value : TFhirNutritionOrderSupplement; path : string; child : TMXmlElement) : boolean;
    function ParseNutritionOrderSupplementSchedule(element : TMXmlElement; path : string) : TFhirNutritionOrderSupplementSchedule;
    function ParseNutritionOrderSupplementScheduleChild(value : TFhirNutritionOrderSupplementSchedule; path : string; child : TMXmlElement) : boolean;
    function ParseNutritionOrderEnteralFormula(element : TMXmlElement; path : string) : TFhirNutritionOrderEnteralFormula;
    function ParseNutritionOrderEnteralFormulaChild(value : TFhirNutritionOrderEnteralFormula; path : string; child : TMXmlElement) : boolean;
    function ParseNutritionOrderEnteralFormulaAdditive(element : TMXmlElement; path : string) : TFhirNutritionOrderEnteralFormulaAdditive;
    function ParseNutritionOrderEnteralFormulaAdditiveChild(value : TFhirNutritionOrderEnteralFormulaAdditive; path : string; child : TMXmlElement) : boolean;
    function ParseNutritionOrderEnteralFormulaAdministration(element : TMXmlElement; path : string) : TFhirNutritionOrderEnteralFormulaAdministration;
    function ParseNutritionOrderEnteralFormulaAdministrationChild(value : TFhirNutritionOrderEnteralFormulaAdministration; path : string; child : TMXmlElement) : boolean;
    function ParseNutritionOrderEnteralFormulaAdministrationSchedule(element : TMXmlElement; path : string) : TFhirNutritionOrderEnteralFormulaAdministrationSchedule;
    function ParseNutritionOrderEnteralFormulaAdministrationScheduleChild(value : TFhirNutritionOrderEnteralFormulaAdministrationSchedule; path : string; child : TMXmlElement) : boolean;
    function ParseNutritionOrder(element : TMXmlElement; path : string) : TFhirNutritionOrder;
    function ParseNutritionOrderChild(value : TFhirNutritionOrder; path : string; child : TMXmlElement) : boolean;
{$ENDIF FHIR_NUTRITIONORDER}
{$IFDEF FHIR_NUTRITIONPRODUCT}
    function ParseNutritionProductNutrient(element : TMXmlElement; path : string) : TFhirNutritionProductNutrient;
    function ParseNutritionProductNutrientChild(value : TFhirNutritionProductNutrient; path : string; child : TMXmlElement) : boolean;
    function ParseNutritionProductIngredient(element : TMXmlElement; path : string) : TFhirNutritionProductIngredient;
    function ParseNutritionProductIngredientChild(value : TFhirNutritionProductIngredient; path : string; child : TMXmlElement) : boolean;
    function ParseNutritionProductCharacteristic(element : TMXmlElement; path : string) : TFhirNutritionProductCharacteristic;
    function ParseNutritionProductCharacteristicChild(value : TFhirNutritionProductCharacteristic; path : string; child : TMXmlElement) : boolean;
    function ParseNutritionProductInstance(element : TMXmlElement; path : string) : TFhirNutritionProductInstance;
    function ParseNutritionProductInstanceChild(value : TFhirNutritionProductInstance; path : string; child : TMXmlElement) : boolean;
    function ParseNutritionProduct(element : TMXmlElement; path : string) : TFhirNutritionProduct;
    function ParseNutritionProductChild(value : TFhirNutritionProduct; path : string; child : TMXmlElement) : boolean;
{$ENDIF FHIR_NUTRITIONPRODUCT}
{$IFDEF FHIR_OBSERVATION}
    function ParseObservationTriggeredBy(element : TMXmlElement; path : string) : TFhirObservationTriggeredBy;
    function ParseObservationTriggeredByChild(value : TFhirObservationTriggeredBy; path : string; child : TMXmlElement) : boolean;
    function ParseObservationReferenceRange(element : TMXmlElement; path : string) : TFhirObservationReferenceRange;
    function ParseObservationReferenceRangeChild(value : TFhirObservationReferenceRange; path : string; child : TMXmlElement) : boolean;
    function ParseObservationComponent(element : TMXmlElement; path : string) : TFhirObservationComponent;
    function ParseObservationComponentChild(value : TFhirObservationComponent; path : string; child : TMXmlElement) : boolean;
    function ParseObservation(element : TMXmlElement; path : string) : TFhirObservation;
    function ParseObservationChild(value : TFhirObservation; path : string; child : TMXmlElement) : boolean;
{$ENDIF FHIR_OBSERVATION}
{$IFDEF FHIR_OBSERVATIONDEFINITION}
    function ParseObservationDefinitionQuantitativeDetails(element : TMXmlElement; path : string) : TFhirObservationDefinitionQuantitativeDetails;
    function ParseObservationDefinitionQuantitativeDetailsChild(value : TFhirObservationDefinitionQuantitativeDetails; path : string; child : TMXmlElement) : boolean;
    function ParseObservationDefinitionQualifiedValue(element : TMXmlElement; path : string) : TFhirObservationDefinitionQualifiedValue;
    function ParseObservationDefinitionQualifiedValueChild(value : TFhirObservationDefinitionQualifiedValue; path : string; child : TMXmlElement) : boolean;
    function ParseObservationDefinitionComponent(element : TMXmlElement; path : string) : TFhirObservationDefinitionComponent;
    function ParseObservationDefinitionComponentChild(value : TFhirObservationDefinitionComponent; path : string; child : TMXmlElement) : boolean;
    function ParseObservationDefinition(element : TMXmlElement; path : string) : TFhirObservationDefinition;
    function ParseObservationDefinitionChild(value : TFhirObservationDefinition; path : string; child : TMXmlElement) : boolean;
{$ENDIF FHIR_OBSERVATIONDEFINITION}
{$IFDEF FHIR_OPERATIONDEFINITION}
    function ParseOperationDefinitionParameter(element : TMXmlElement; path : string) : TFhirOperationDefinitionParameter;
    function ParseOperationDefinitionParameterChild(value : TFhirOperationDefinitionParameter; path : string; child : TMXmlElement) : boolean;
    function ParseOperationDefinitionParameterBinding(element : TMXmlElement; path : string) : TFhirOperationDefinitionParameterBinding;
    function ParseOperationDefinitionParameterBindingChild(value : TFhirOperationDefinitionParameterBinding; path : string; child : TMXmlElement) : boolean;
    function ParseOperationDefinitionParameterReferencedFrom(element : TMXmlElement; path : string) : TFhirOperationDefinitionParameterReferencedFrom;
    function ParseOperationDefinitionParameterReferencedFromChild(value : TFhirOperationDefinitionParameterReferencedFrom; path : string; child : TMXmlElement) : boolean;
    function ParseOperationDefinitionOverload(element : TMXmlElement; path : string) : TFhirOperationDefinitionOverload;
    function ParseOperationDefinitionOverloadChild(value : TFhirOperationDefinitionOverload; path : string; child : TMXmlElement) : boolean;
    function ParseOperationDefinition(element : TMXmlElement; path : string) : TFhirOperationDefinition;
    function ParseOperationDefinitionChild(value : TFhirOperationDefinition; path : string; child : TMXmlElement) : boolean;
{$ENDIF FHIR_OPERATIONDEFINITION}
{$IFDEF FHIR_OPERATIONOUTCOME}
    function ParseOperationOutcomeIssue(element : TMXmlElement; path : string) : TFhirOperationOutcomeIssue;
    function ParseOperationOutcomeIssueChild(value : TFhirOperationOutcomeIssue; path : string; child : TMXmlElement) : boolean;
    function ParseOperationOutcome(element : TMXmlElement; path : string) : TFhirOperationOutcome;
    function ParseOperationOutcomeChild(value : TFhirOperationOutcome; path : string; child : TMXmlElement) : boolean;
{$ENDIF FHIR_OPERATIONOUTCOME}
{$IFDEF FHIR_ORGANIZATION}
    function ParseOrganizationQualification(element : TMXmlElement; path : string) : TFhirOrganizationQualification;
    function ParseOrganizationQualificationChild(value : TFhirOrganizationQualification; path : string; child : TMXmlElement) : boolean;
    function ParseOrganization(element : TMXmlElement; path : string) : TFhirOrganization;
    function ParseOrganizationChild(value : TFhirOrganization; path : string; child : TMXmlElement) : boolean;
{$ENDIF FHIR_ORGANIZATION}
{$IFDEF FHIR_ORGANIZATIONAFFILIATION}
    function ParseOrganizationAffiliation(element : TMXmlElement; path : string) : TFhirOrganizationAffiliation;
    function ParseOrganizationAffiliationChild(value : TFhirOrganizationAffiliation; path : string; child : TMXmlElement) : boolean;
{$ENDIF FHIR_ORGANIZATIONAFFILIATION}
{$IFDEF FHIR_PACKAGEDPRODUCTDEFINITION}
    function ParsePackagedProductDefinitionLegalStatusOfSupply(element : TMXmlElement; path : string) : TFhirPackagedProductDefinitionLegalStatusOfSupply;
    function ParsePackagedProductDefinitionLegalStatusOfSupplyChild(value : TFhirPackagedProductDefinitionLegalStatusOfSupply; path : string; child : TMXmlElement) : boolean;
    function ParsePackagedProductDefinitionPackaging(element : TMXmlElement; path : string) : TFhirPackagedProductDefinitionPackaging;
    function ParsePackagedProductDefinitionPackagingChild(value : TFhirPackagedProductDefinitionPackaging; path : string; child : TMXmlElement) : boolean;
    function ParsePackagedProductDefinitionPackagingProperty(element : TMXmlElement; path : string) : TFhirPackagedProductDefinitionPackagingProperty;
    function ParsePackagedProductDefinitionPackagingPropertyChild(value : TFhirPackagedProductDefinitionPackagingProperty; path : string; child : TMXmlElement) : boolean;
    function ParsePackagedProductDefinitionPackagingContainedItem(element : TMXmlElement; path : string) : TFhirPackagedProductDefinitionPackagingContainedItem;
    function ParsePackagedProductDefinitionPackagingContainedItemChild(value : TFhirPackagedProductDefinitionPackagingContainedItem; path : string; child : TMXmlElement) : boolean;
    function ParsePackagedProductDefinition(element : TMXmlElement; path : string) : TFhirPackagedProductDefinition;
    function ParsePackagedProductDefinitionChild(value : TFhirPackagedProductDefinition; path : string; child : TMXmlElement) : boolean;
{$ENDIF FHIR_PACKAGEDPRODUCTDEFINITION}
{$IFDEF FHIR_PARAMETERS}
    function ParseParametersParameter(element : TMXmlElement; path : string) : TFhirParametersParameter;
    function ParseParametersParameterChild(value : TFhirParametersParameter; path : string; child : TMXmlElement) : boolean;
    function ParseParameters(element : TMXmlElement; path : string) : TFhirParameters;
    function ParseParametersChild(value : TFhirParameters; path : string; child : TMXmlElement) : boolean;
{$ENDIF FHIR_PARAMETERS}
{$IFDEF FHIR_PATIENT}
    function ParsePatientContact(element : TMXmlElement; path : string) : TFhirPatientContact;
    function ParsePatientContactChild(value : TFhirPatientContact; path : string; child : TMXmlElement) : boolean;
    function ParsePatientCommunication(element : TMXmlElement; path : string) : TFhirPatientCommunication;
    function ParsePatientCommunicationChild(value : TFhirPatientCommunication; path : string; child : TMXmlElement) : boolean;
    function ParsePatientLink(element : TMXmlElement; path : string) : TFhirPatientLink;
    function ParsePatientLinkChild(value : TFhirPatientLink; path : string; child : TMXmlElement) : boolean;
    function ParsePatient(element : TMXmlElement; path : string) : TFhirPatient;
    function ParsePatientChild(value : TFhirPatient; path : string; child : TMXmlElement) : boolean;
{$ENDIF FHIR_PATIENT}
{$IFDEF FHIR_PAYMENTNOTICE}
    function ParsePaymentNotice(element : TMXmlElement; path : string) : TFhirPaymentNotice;
    function ParsePaymentNoticeChild(value : TFhirPaymentNotice; path : string; child : TMXmlElement) : boolean;
{$ENDIF FHIR_PAYMENTNOTICE}
{$IFDEF FHIR_PAYMENTRECONCILIATION}
    function ParsePaymentReconciliationAllocation(element : TMXmlElement; path : string) : TFhirPaymentReconciliationAllocation;
    function ParsePaymentReconciliationAllocationChild(value : TFhirPaymentReconciliationAllocation; path : string; child : TMXmlElement) : boolean;
    function ParsePaymentReconciliationProcessNote(element : TMXmlElement; path : string) : TFhirPaymentReconciliationProcessNote;
    function ParsePaymentReconciliationProcessNoteChild(value : TFhirPaymentReconciliationProcessNote; path : string; child : TMXmlElement) : boolean;
    function ParsePaymentReconciliation(element : TMXmlElement; path : string) : TFhirPaymentReconciliation;
    function ParsePaymentReconciliationChild(value : TFhirPaymentReconciliation; path : string; child : TMXmlElement) : boolean;
{$ENDIF FHIR_PAYMENTRECONCILIATION}
{$IFDEF FHIR_PERMISSION}
    function ParsePermissionJustification(element : TMXmlElement; path : string) : TFhirPermissionJustification;
    function ParsePermissionJustificationChild(value : TFhirPermissionJustification; path : string; child : TMXmlElement) : boolean;
    function ParsePermissionRule(element : TMXmlElement; path : string) : TFhirPermissionRule;
    function ParsePermissionRuleChild(value : TFhirPermissionRule; path : string; child : TMXmlElement) : boolean;
    function ParsePermissionRuleData(element : TMXmlElement; path : string) : TFhirPermissionRuleData;
    function ParsePermissionRuleDataChild(value : TFhirPermissionRuleData; path : string; child : TMXmlElement) : boolean;
    function ParsePermissionRuleDataResource(element : TMXmlElement; path : string) : TFhirPermissionRuleDataResource;
    function ParsePermissionRuleDataResourceChild(value : TFhirPermissionRuleDataResource; path : string; child : TMXmlElement) : boolean;
    function ParsePermissionRuleActivity(element : TMXmlElement; path : string) : TFhirPermissionRuleActivity;
    function ParsePermissionRuleActivityChild(value : TFhirPermissionRuleActivity; path : string; child : TMXmlElement) : boolean;
    function ParsePermission(element : TMXmlElement; path : string) : TFhirPermission;
    function ParsePermissionChild(value : TFhirPermission; path : string; child : TMXmlElement) : boolean;
{$ENDIF FHIR_PERMISSION}
{$IFDEF FHIR_PERSON}
    function ParsePersonCommunication(element : TMXmlElement; path : string) : TFhirPersonCommunication;
    function ParsePersonCommunicationChild(value : TFhirPersonCommunication; path : string; child : TMXmlElement) : boolean;
    function ParsePersonLink(element : TMXmlElement; path : string) : TFhirPersonLink;
    function ParsePersonLinkChild(value : TFhirPersonLink; path : string; child : TMXmlElement) : boolean;
    function ParsePerson(element : TMXmlElement; path : string) : TFhirPerson;
    function ParsePersonChild(value : TFhirPerson; path : string; child : TMXmlElement) : boolean;
{$ENDIF FHIR_PERSON}
{$IFDEF FHIR_PLANDEFINITION}
    function ParsePlanDefinitionGoal(element : TMXmlElement; path : string) : TFhirPlanDefinitionGoal;
    function ParsePlanDefinitionGoalChild(value : TFhirPlanDefinitionGoal; path : string; child : TMXmlElement) : boolean;
    function ParsePlanDefinitionGoalTarget(element : TMXmlElement; path : string) : TFhirPlanDefinitionGoalTarget;
    function ParsePlanDefinitionGoalTargetChild(value : TFhirPlanDefinitionGoalTarget; path : string; child : TMXmlElement) : boolean;
    function ParsePlanDefinitionActor(element : TMXmlElement; path : string) : TFhirPlanDefinitionActor;
    function ParsePlanDefinitionActorChild(value : TFhirPlanDefinitionActor; path : string; child : TMXmlElement) : boolean;
    function ParsePlanDefinitionActorOption(element : TMXmlElement; path : string) : TFhirPlanDefinitionActorOption;
    function ParsePlanDefinitionActorOptionChild(value : TFhirPlanDefinitionActorOption; path : string; child : TMXmlElement) : boolean;
    function ParsePlanDefinitionAction(element : TMXmlElement; path : string) : TFhirPlanDefinitionAction;
    function ParsePlanDefinitionActionChild(value : TFhirPlanDefinitionAction; path : string; child : TMXmlElement) : boolean;
    function ParsePlanDefinitionActionCondition(element : TMXmlElement; path : string) : TFhirPlanDefinitionActionCondition;
    function ParsePlanDefinitionActionConditionChild(value : TFhirPlanDefinitionActionCondition; path : string; child : TMXmlElement) : boolean;
    function ParsePlanDefinitionActionInput(element : TMXmlElement; path : string) : TFhirPlanDefinitionActionInput;
    function ParsePlanDefinitionActionInputChild(value : TFhirPlanDefinitionActionInput; path : string; child : TMXmlElement) : boolean;
    function ParsePlanDefinitionActionOutput(element : TMXmlElement; path : string) : TFhirPlanDefinitionActionOutput;
    function ParsePlanDefinitionActionOutputChild(value : TFhirPlanDefinitionActionOutput; path : string; child : TMXmlElement) : boolean;
    function ParsePlanDefinitionActionRelatedAction(element : TMXmlElement; path : string) : TFhirPlanDefinitionActionRelatedAction;
    function ParsePlanDefinitionActionRelatedActionChild(value : TFhirPlanDefinitionActionRelatedAction; path : string; child : TMXmlElement) : boolean;
    function ParsePlanDefinitionActionParticipant(element : TMXmlElement; path : string) : TFhirPlanDefinitionActionParticipant;
    function ParsePlanDefinitionActionParticipantChild(value : TFhirPlanDefinitionActionParticipant; path : string; child : TMXmlElement) : boolean;
    function ParsePlanDefinitionActionDynamicValue(element : TMXmlElement; path : string) : TFhirPlanDefinitionActionDynamicValue;
    function ParsePlanDefinitionActionDynamicValueChild(value : TFhirPlanDefinitionActionDynamicValue; path : string; child : TMXmlElement) : boolean;
    function ParsePlanDefinition(element : TMXmlElement; path : string) : TFhirPlanDefinition;
    function ParsePlanDefinitionChild(value : TFhirPlanDefinition; path : string; child : TMXmlElement) : boolean;
{$ENDIF FHIR_PLANDEFINITION}
{$IFDEF FHIR_PRACTITIONER}
    function ParsePractitionerQualification(element : TMXmlElement; path : string) : TFhirPractitionerQualification;
    function ParsePractitionerQualificationChild(value : TFhirPractitionerQualification; path : string; child : TMXmlElement) : boolean;
    function ParsePractitioner(element : TMXmlElement; path : string) : TFhirPractitioner;
    function ParsePractitionerChild(value : TFhirPractitioner; path : string; child : TMXmlElement) : boolean;
{$ENDIF FHIR_PRACTITIONER}
{$IFDEF FHIR_PRACTITIONERROLE}
    function ParsePractitionerRole(element : TMXmlElement; path : string) : TFhirPractitionerRole;
    function ParsePractitionerRoleChild(value : TFhirPractitionerRole; path : string; child : TMXmlElement) : boolean;
{$ENDIF FHIR_PRACTITIONERROLE}
{$IFDEF FHIR_PROCEDURE}
    function ParseProcedurePerformer(element : TMXmlElement; path : string) : TFhirProcedurePerformer;
    function ParseProcedurePerformerChild(value : TFhirProcedurePerformer; path : string; child : TMXmlElement) : boolean;
    function ParseProcedureFocalDevice(element : TMXmlElement; path : string) : TFhirProcedureFocalDevice;
    function ParseProcedureFocalDeviceChild(value : TFhirProcedureFocalDevice; path : string; child : TMXmlElement) : boolean;
    function ParseProcedure(element : TMXmlElement; path : string) : TFhirProcedure;
    function ParseProcedureChild(value : TFhirProcedure; path : string; child : TMXmlElement) : boolean;
{$ENDIF FHIR_PROCEDURE}
{$IFDEF FHIR_PROVENANCE}
    function ParseProvenanceAgent(element : TMXmlElement; path : string) : TFhirProvenanceAgent;
    function ParseProvenanceAgentChild(value : TFhirProvenanceAgent; path : string; child : TMXmlElement) : boolean;
    function ParseProvenanceEntity(element : TMXmlElement; path : string) : TFhirProvenanceEntity;
    function ParseProvenanceEntityChild(value : TFhirProvenanceEntity; path : string; child : TMXmlElement) : boolean;
    function ParseProvenance(element : TMXmlElement; path : string) : TFhirProvenance;
    function ParseProvenanceChild(value : TFhirProvenance; path : string; child : TMXmlElement) : boolean;
{$ENDIF FHIR_PROVENANCE}
{$IFDEF FHIR_QUESTIONNAIRE}
    function ParseQuestionnaireItem(element : TMXmlElement; path : string) : TFhirQuestionnaireItem;
    function ParseQuestionnaireItemChild(value : TFhirQuestionnaireItem; path : string; child : TMXmlElement) : boolean;
    function ParseQuestionnaireItemEnableWhen(element : TMXmlElement; path : string) : TFhirQuestionnaireItemEnableWhen;
    function ParseQuestionnaireItemEnableWhenChild(value : TFhirQuestionnaireItemEnableWhen; path : string; child : TMXmlElement) : boolean;
    function ParseQuestionnaireItemAnswerOption(element : TMXmlElement; path : string) : TFhirQuestionnaireItemAnswerOption;
    function ParseQuestionnaireItemAnswerOptionChild(value : TFhirQuestionnaireItemAnswerOption; path : string; child : TMXmlElement) : boolean;
    function ParseQuestionnaireItemInitial(element : TMXmlElement; path : string) : TFhirQuestionnaireItemInitial;
    function ParseQuestionnaireItemInitialChild(value : TFhirQuestionnaireItemInitial; path : string; child : TMXmlElement) : boolean;
    function ParseQuestionnaire(element : TMXmlElement; path : string) : TFhirQuestionnaire;
    function ParseQuestionnaireChild(value : TFhirQuestionnaire; path : string; child : TMXmlElement) : boolean;
{$ENDIF FHIR_QUESTIONNAIRE}
{$IFDEF FHIR_QUESTIONNAIRERESPONSE}
    function ParseQuestionnaireResponseItem(element : TMXmlElement; path : string) : TFhirQuestionnaireResponseItem;
    function ParseQuestionnaireResponseItemChild(value : TFhirQuestionnaireResponseItem; path : string; child : TMXmlElement) : boolean;
    function ParseQuestionnaireResponseItemAnswer(element : TMXmlElement; path : string) : TFhirQuestionnaireResponseItemAnswer;
    function ParseQuestionnaireResponseItemAnswerChild(value : TFhirQuestionnaireResponseItemAnswer; path : string; child : TMXmlElement) : boolean;
    function ParseQuestionnaireResponse(element : TMXmlElement; path : string) : TFhirQuestionnaireResponse;
    function ParseQuestionnaireResponseChild(value : TFhirQuestionnaireResponse; path : string; child : TMXmlElement) : boolean;
{$ENDIF FHIR_QUESTIONNAIRERESPONSE}
{$IFDEF FHIR_REGULATEDAUTHORIZATION}
    function ParseRegulatedAuthorizationCase(element : TMXmlElement; path : string) : TFhirRegulatedAuthorizationCase;
    function ParseRegulatedAuthorizationCaseChild(value : TFhirRegulatedAuthorizationCase; path : string; child : TMXmlElement) : boolean;
    function ParseRegulatedAuthorization(element : TMXmlElement; path : string) : TFhirRegulatedAuthorization;
    function ParseRegulatedAuthorizationChild(value : TFhirRegulatedAuthorization; path : string; child : TMXmlElement) : boolean;
{$ENDIF FHIR_REGULATEDAUTHORIZATION}
{$IFDEF FHIR_RELATEDPERSON}
    function ParseRelatedPersonCommunication(element : TMXmlElement; path : string) : TFhirRelatedPersonCommunication;
    function ParseRelatedPersonCommunicationChild(value : TFhirRelatedPersonCommunication; path : string; child : TMXmlElement) : boolean;
    function ParseRelatedPerson(element : TMXmlElement; path : string) : TFhirRelatedPerson;
    function ParseRelatedPersonChild(value : TFhirRelatedPerson; path : string; child : TMXmlElement) : boolean;
{$ENDIF FHIR_RELATEDPERSON}
{$IFDEF FHIR_REQUESTGROUP}
    function ParseRequestGroupAction(element : TMXmlElement; path : string) : TFhirRequestGroupAction;
    function ParseRequestGroupActionChild(value : TFhirRequestGroupAction; path : string; child : TMXmlElement) : boolean;
    function ParseRequestGroupActionCondition(element : TMXmlElement; path : string) : TFhirRequestGroupActionCondition;
    function ParseRequestGroupActionConditionChild(value : TFhirRequestGroupActionCondition; path : string; child : TMXmlElement) : boolean;
    function ParseRequestGroupActionRelatedAction(element : TMXmlElement; path : string) : TFhirRequestGroupActionRelatedAction;
    function ParseRequestGroupActionRelatedActionChild(value : TFhirRequestGroupActionRelatedAction; path : string; child : TMXmlElement) : boolean;
    function ParseRequestGroupActionParticipant(element : TMXmlElement; path : string) : TFhirRequestGroupActionParticipant;
    function ParseRequestGroupActionParticipantChild(value : TFhirRequestGroupActionParticipant; path : string; child : TMXmlElement) : boolean;
    function ParseRequestGroup(element : TMXmlElement; path : string) : TFhirRequestGroup;
    function ParseRequestGroupChild(value : TFhirRequestGroup; path : string; child : TMXmlElement) : boolean;
{$ENDIF FHIR_REQUESTGROUP}
{$IFDEF FHIR_REQUESTORCHESTRATION}
    function ParseRequestOrchestrationAction(element : TMXmlElement; path : string) : TFhirRequestOrchestrationAction;
    function ParseRequestOrchestrationActionChild(value : TFhirRequestOrchestrationAction; path : string; child : TMXmlElement) : boolean;
    function ParseRequestOrchestrationActionCondition(element : TMXmlElement; path : string) : TFhirRequestOrchestrationActionCondition;
    function ParseRequestOrchestrationActionConditionChild(value : TFhirRequestOrchestrationActionCondition; path : string; child : TMXmlElement) : boolean;
    function ParseRequestOrchestrationActionInput(element : TMXmlElement; path : string) : TFhirRequestOrchestrationActionInput;
    function ParseRequestOrchestrationActionInputChild(value : TFhirRequestOrchestrationActionInput; path : string; child : TMXmlElement) : boolean;
    function ParseRequestOrchestrationActionOutput(element : TMXmlElement; path : string) : TFhirRequestOrchestrationActionOutput;
    function ParseRequestOrchestrationActionOutputChild(value : TFhirRequestOrchestrationActionOutput; path : string; child : TMXmlElement) : boolean;
    function ParseRequestOrchestrationActionRelatedAction(element : TMXmlElement; path : string) : TFhirRequestOrchestrationActionRelatedAction;
    function ParseRequestOrchestrationActionRelatedActionChild(value : TFhirRequestOrchestrationActionRelatedAction; path : string; child : TMXmlElement) : boolean;
    function ParseRequestOrchestrationActionParticipant(element : TMXmlElement; path : string) : TFhirRequestOrchestrationActionParticipant;
    function ParseRequestOrchestrationActionParticipantChild(value : TFhirRequestOrchestrationActionParticipant; path : string; child : TMXmlElement) : boolean;
    function ParseRequestOrchestrationActionDynamicValue(element : TMXmlElement; path : string) : TFhirRequestOrchestrationActionDynamicValue;
    function ParseRequestOrchestrationActionDynamicValueChild(value : TFhirRequestOrchestrationActionDynamicValue; path : string; child : TMXmlElement) : boolean;
    function ParseRequestOrchestration(element : TMXmlElement; path : string) : TFhirRequestOrchestration;
    function ParseRequestOrchestrationChild(value : TFhirRequestOrchestration; path : string; child : TMXmlElement) : boolean;
{$ENDIF FHIR_REQUESTORCHESTRATION}
{$IFDEF FHIR_REQUIREMENTS}
    function ParseRequirementsStatement(element : TMXmlElement; path : string) : TFhirRequirementsStatement;
    function ParseRequirementsStatementChild(value : TFhirRequirementsStatement; path : string; child : TMXmlElement) : boolean;
    function ParseRequirements(element : TMXmlElement; path : string) : TFhirRequirements;
    function ParseRequirementsChild(value : TFhirRequirements; path : string; child : TMXmlElement) : boolean;
{$ENDIF FHIR_REQUIREMENTS}
{$IFDEF FHIR_RESEARCHSTUDY}
    function ParseResearchStudyLabel(element : TMXmlElement; path : string) : TFhirResearchStudyLabel;
    function ParseResearchStudyLabelChild(value : TFhirResearchStudyLabel; path : string; child : TMXmlElement) : boolean;
    function ParseResearchStudyFocus(element : TMXmlElement; path : string) : TFhirResearchStudyFocus;
    function ParseResearchStudyFocusChild(value : TFhirResearchStudyFocus; path : string; child : TMXmlElement) : boolean;
    function ParseResearchStudyAssociatedParty(element : TMXmlElement; path : string) : TFhirResearchStudyAssociatedParty;
    function ParseResearchStudyAssociatedPartyChild(value : TFhirResearchStudyAssociatedParty; path : string; child : TMXmlElement) : boolean;
    function ParseResearchStudyProgressStatus(element : TMXmlElement; path : string) : TFhirResearchStudyProgressStatus;
    function ParseResearchStudyProgressStatusChild(value : TFhirResearchStudyProgressStatus; path : string; child : TMXmlElement) : boolean;
    function ParseResearchStudyRecruitment(element : TMXmlElement; path : string) : TFhirResearchStudyRecruitment;
    function ParseResearchStudyRecruitmentChild(value : TFhirResearchStudyRecruitment; path : string; child : TMXmlElement) : boolean;
    function ParseResearchStudyComparisonGroup(element : TMXmlElement; path : string) : TFhirResearchStudyComparisonGroup;
    function ParseResearchStudyComparisonGroupChild(value : TFhirResearchStudyComparisonGroup; path : string; child : TMXmlElement) : boolean;
    function ParseResearchStudyObjective(element : TMXmlElement; path : string) : TFhirResearchStudyObjective;
    function ParseResearchStudyObjectiveChild(value : TFhirResearchStudyObjective; path : string; child : TMXmlElement) : boolean;
    function ParseResearchStudyOutcomeMeasure(element : TMXmlElement; path : string) : TFhirResearchStudyOutcomeMeasure;
    function ParseResearchStudyOutcomeMeasureChild(value : TFhirResearchStudyOutcomeMeasure; path : string; child : TMXmlElement) : boolean;
    function ParseResearchStudyWebLocation(element : TMXmlElement; path : string) : TFhirResearchStudyWebLocation;
    function ParseResearchStudyWebLocationChild(value : TFhirResearchStudyWebLocation; path : string; child : TMXmlElement) : boolean;
    function ParseResearchStudy(element : TMXmlElement; path : string) : TFhirResearchStudy;
    function ParseResearchStudyChild(value : TFhirResearchStudy; path : string; child : TMXmlElement) : boolean;
{$ENDIF FHIR_RESEARCHSTUDY}
{$IFDEF FHIR_RESEARCHSUBJECT}
    function ParseResearchSubjectProgress(element : TMXmlElement; path : string) : TFhirResearchSubjectProgress;
    function ParseResearchSubjectProgressChild(value : TFhirResearchSubjectProgress; path : string; child : TMXmlElement) : boolean;
    function ParseResearchSubject(element : TMXmlElement; path : string) : TFhirResearchSubject;
    function ParseResearchSubjectChild(value : TFhirResearchSubject; path : string; child : TMXmlElement) : boolean;
{$ENDIF FHIR_RESEARCHSUBJECT}
{$IFDEF FHIR_RISKASSESSMENT}
    function ParseRiskAssessmentPrediction(element : TMXmlElement; path : string) : TFhirRiskAssessmentPrediction;
    function ParseRiskAssessmentPredictionChild(value : TFhirRiskAssessmentPrediction; path : string; child : TMXmlElement) : boolean;
    function ParseRiskAssessment(element : TMXmlElement; path : string) : TFhirRiskAssessment;
    function ParseRiskAssessmentChild(value : TFhirRiskAssessment; path : string; child : TMXmlElement) : boolean;
{$ENDIF FHIR_RISKASSESSMENT}
{$IFDEF FHIR_SCHEDULE}
    function ParseSchedule(element : TMXmlElement; path : string) : TFhirSchedule;
    function ParseScheduleChild(value : TFhirSchedule; path : string; child : TMXmlElement) : boolean;
{$ENDIF FHIR_SCHEDULE}
{$IFDEF FHIR_SEARCHPARAMETER}
    function ParseSearchParameterComponent(element : TMXmlElement; path : string) : TFhirSearchParameterComponent;
    function ParseSearchParameterComponentChild(value : TFhirSearchParameterComponent; path : string; child : TMXmlElement) : boolean;
    function ParseSearchParameter(element : TMXmlElement; path : string) : TFhirSearchParameter;
    function ParseSearchParameterChild(value : TFhirSearchParameter; path : string; child : TMXmlElement) : boolean;
{$ENDIF FHIR_SEARCHPARAMETER}
{$IFDEF FHIR_SERVICEREQUEST}
    function ParseServiceRequest(element : TMXmlElement; path : string) : TFhirServiceRequest;
    function ParseServiceRequestChild(value : TFhirServiceRequest; path : string; child : TMXmlElement) : boolean;
{$ENDIF FHIR_SERVICEREQUEST}
{$IFDEF FHIR_SLOT}
    function ParseSlot(element : TMXmlElement; path : string) : TFhirSlot;
    function ParseSlotChild(value : TFhirSlot; path : string; child : TMXmlElement) : boolean;
{$ENDIF FHIR_SLOT}
{$IFDEF FHIR_SPECIMEN}
    function ParseSpecimenFeature(element : TMXmlElement; path : string) : TFhirSpecimenFeature;
    function ParseSpecimenFeatureChild(value : TFhirSpecimenFeature; path : string; child : TMXmlElement) : boolean;
    function ParseSpecimenCollection(element : TMXmlElement; path : string) : TFhirSpecimenCollection;
    function ParseSpecimenCollectionChild(value : TFhirSpecimenCollection; path : string; child : TMXmlElement) : boolean;
    function ParseSpecimenProcessing(element : TMXmlElement; path : string) : TFhirSpecimenProcessing;
    function ParseSpecimenProcessingChild(value : TFhirSpecimenProcessing; path : string; child : TMXmlElement) : boolean;
    function ParseSpecimenContainer(element : TMXmlElement; path : string) : TFhirSpecimenContainer;
    function ParseSpecimenContainerChild(value : TFhirSpecimenContainer; path : string; child : TMXmlElement) : boolean;
    function ParseSpecimen(element : TMXmlElement; path : string) : TFhirSpecimen;
    function ParseSpecimenChild(value : TFhirSpecimen; path : string; child : TMXmlElement) : boolean;
{$ENDIF FHIR_SPECIMEN}
{$IFDEF FHIR_SPECIMENDEFINITION}
    function ParseSpecimenDefinitionTypeTested(element : TMXmlElement; path : string) : TFhirSpecimenDefinitionTypeTested;
    function ParseSpecimenDefinitionTypeTestedChild(value : TFhirSpecimenDefinitionTypeTested; path : string; child : TMXmlElement) : boolean;
    function ParseSpecimenDefinitionTypeTestedContainer(element : TMXmlElement; path : string) : TFhirSpecimenDefinitionTypeTestedContainer;
    function ParseSpecimenDefinitionTypeTestedContainerChild(value : TFhirSpecimenDefinitionTypeTestedContainer; path : string; child : TMXmlElement) : boolean;
    function ParseSpecimenDefinitionTypeTestedContainerAdditive(element : TMXmlElement; path : string) : TFhirSpecimenDefinitionTypeTestedContainerAdditive;
    function ParseSpecimenDefinitionTypeTestedContainerAdditiveChild(value : TFhirSpecimenDefinitionTypeTestedContainerAdditive; path : string; child : TMXmlElement) : boolean;
    function ParseSpecimenDefinitionTypeTestedHandling(element : TMXmlElement; path : string) : TFhirSpecimenDefinitionTypeTestedHandling;
    function ParseSpecimenDefinitionTypeTestedHandlingChild(value : TFhirSpecimenDefinitionTypeTestedHandling; path : string; child : TMXmlElement) : boolean;
    function ParseSpecimenDefinition(element : TMXmlElement; path : string) : TFhirSpecimenDefinition;
    function ParseSpecimenDefinitionChild(value : TFhirSpecimenDefinition; path : string; child : TMXmlElement) : boolean;
{$ENDIF FHIR_SPECIMENDEFINITION}
{$IFDEF FHIR_STRUCTUREDEFINITION}
    function ParseStructureDefinitionMapping(element : TMXmlElement; path : string) : TFhirStructureDefinitionMapping;
    function ParseStructureDefinitionMappingChild(value : TFhirStructureDefinitionMapping; path : string; child : TMXmlElement) : boolean;
    function ParseStructureDefinitionContext(element : TMXmlElement; path : string) : TFhirStructureDefinitionContext;
    function ParseStructureDefinitionContextChild(value : TFhirStructureDefinitionContext; path : string; child : TMXmlElement) : boolean;
    function ParseStructureDefinitionSnapshot(element : TMXmlElement; path : string) : TFhirStructureDefinitionSnapshot;
    function ParseStructureDefinitionSnapshotChild(value : TFhirStructureDefinitionSnapshot; path : string; child : TMXmlElement) : boolean;
    function ParseStructureDefinitionDifferential(element : TMXmlElement; path : string) : TFhirStructureDefinitionDifferential;
    function ParseStructureDefinitionDifferentialChild(value : TFhirStructureDefinitionDifferential; path : string; child : TMXmlElement) : boolean;
    function ParseStructureDefinition(element : TMXmlElement; path : string) : TFhirStructureDefinition;
    function ParseStructureDefinitionChild(value : TFhirStructureDefinition; path : string; child : TMXmlElement) : boolean;
{$ENDIF FHIR_STRUCTUREDEFINITION}
{$IFDEF FHIR_STRUCTUREMAP}
    function ParseStructureMapStructure(element : TMXmlElement; path : string) : TFhirStructureMapStructure;
    function ParseStructureMapStructureChild(value : TFhirStructureMapStructure; path : string; child : TMXmlElement) : boolean;
    function ParseStructureMapGroup(element : TMXmlElement; path : string) : TFhirStructureMapGroup;
    function ParseStructureMapGroupChild(value : TFhirStructureMapGroup; path : string; child : TMXmlElement) : boolean;
    function ParseStructureMapGroupInput(element : TMXmlElement; path : string) : TFhirStructureMapGroupInput;
    function ParseStructureMapGroupInputChild(value : TFhirStructureMapGroupInput; path : string; child : TMXmlElement) : boolean;
    function ParseStructureMapGroupRule(element : TMXmlElement; path : string) : TFhirStructureMapGroupRule;
    function ParseStructureMapGroupRuleChild(value : TFhirStructureMapGroupRule; path : string; child : TMXmlElement) : boolean;
    function ParseStructureMapGroupRuleSource(element : TMXmlElement; path : string) : TFhirStructureMapGroupRuleSource;
    function ParseStructureMapGroupRuleSourceChild(value : TFhirStructureMapGroupRuleSource; path : string; child : TMXmlElement) : boolean;
    function ParseStructureMapGroupRuleTarget(element : TMXmlElement; path : string) : TFhirStructureMapGroupRuleTarget;
    function ParseStructureMapGroupRuleTargetChild(value : TFhirStructureMapGroupRuleTarget; path : string; child : TMXmlElement) : boolean;
    function ParseStructureMapGroupRuleTargetParameter(element : TMXmlElement; path : string) : TFhirStructureMapGroupRuleTargetParameter;
    function ParseStructureMapGroupRuleTargetParameterChild(value : TFhirStructureMapGroupRuleTargetParameter; path : string; child : TMXmlElement) : boolean;
    function ParseStructureMapGroupRuleDependent(element : TMXmlElement; path : string) : TFhirStructureMapGroupRuleDependent;
    function ParseStructureMapGroupRuleDependentChild(value : TFhirStructureMapGroupRuleDependent; path : string; child : TMXmlElement) : boolean;
    function ParseStructureMap(element : TMXmlElement; path : string) : TFhirStructureMap;
    function ParseStructureMapChild(value : TFhirStructureMap; path : string; child : TMXmlElement) : boolean;
{$ENDIF FHIR_STRUCTUREMAP}
{$IFDEF FHIR_SUBSCRIPTION}
    function ParseSubscriptionFilterBy(element : TMXmlElement; path : string) : TFhirSubscriptionFilterBy;
    function ParseSubscriptionFilterByChild(value : TFhirSubscriptionFilterBy; path : string; child : TMXmlElement) : boolean;
    function ParseSubscription(element : TMXmlElement; path : string) : TFhirSubscription;
    function ParseSubscriptionChild(value : TFhirSubscription; path : string; child : TMXmlElement) : boolean;
{$ENDIF FHIR_SUBSCRIPTION}
{$IFDEF FHIR_SUBSCRIPTIONSTATUS}
    function ParseSubscriptionStatusNotificationEvent(element : TMXmlElement; path : string) : TFhirSubscriptionStatusNotificationEvent;
    function ParseSubscriptionStatusNotificationEventChild(value : TFhirSubscriptionStatusNotificationEvent; path : string; child : TMXmlElement) : boolean;
    function ParseSubscriptionStatus(element : TMXmlElement; path : string) : TFhirSubscriptionStatus;
    function ParseSubscriptionStatusChild(value : TFhirSubscriptionStatus; path : string; child : TMXmlElement) : boolean;
{$ENDIF FHIR_SUBSCRIPTIONSTATUS}
{$IFDEF FHIR_SUBSCRIPTIONTOPIC}
    function ParseSubscriptionTopicResourceTrigger(element : TMXmlElement; path : string) : TFhirSubscriptionTopicResourceTrigger;
    function ParseSubscriptionTopicResourceTriggerChild(value : TFhirSubscriptionTopicResourceTrigger; path : string; child : TMXmlElement) : boolean;
    function ParseSubscriptionTopicResourceTriggerQueryCriteria(element : TMXmlElement; path : string) : TFhirSubscriptionTopicResourceTriggerQueryCriteria;
    function ParseSubscriptionTopicResourceTriggerQueryCriteriaChild(value : TFhirSubscriptionTopicResourceTriggerQueryCriteria; path : string; child : TMXmlElement) : boolean;
    function ParseSubscriptionTopicEventTrigger(element : TMXmlElement; path : string) : TFhirSubscriptionTopicEventTrigger;
    function ParseSubscriptionTopicEventTriggerChild(value : TFhirSubscriptionTopicEventTrigger; path : string; child : TMXmlElement) : boolean;
    function ParseSubscriptionTopicCanFilterBy(element : TMXmlElement; path : string) : TFhirSubscriptionTopicCanFilterBy;
    function ParseSubscriptionTopicCanFilterByChild(value : TFhirSubscriptionTopicCanFilterBy; path : string; child : TMXmlElement) : boolean;
    function ParseSubscriptionTopicNotificationShape(element : TMXmlElement; path : string) : TFhirSubscriptionTopicNotificationShape;
    function ParseSubscriptionTopicNotificationShapeChild(value : TFhirSubscriptionTopicNotificationShape; path : string; child : TMXmlElement) : boolean;
    function ParseSubscriptionTopic(element : TMXmlElement; path : string) : TFhirSubscriptionTopic;
    function ParseSubscriptionTopicChild(value : TFhirSubscriptionTopic; path : string; child : TMXmlElement) : boolean;
{$ENDIF FHIR_SUBSCRIPTIONTOPIC}
{$IFDEF FHIR_SUBSTANCE}
    function ParseSubstanceIngredient(element : TMXmlElement; path : string) : TFhirSubstanceIngredient;
    function ParseSubstanceIngredientChild(value : TFhirSubstanceIngredient; path : string; child : TMXmlElement) : boolean;
    function ParseSubstance(element : TMXmlElement; path : string) : TFhirSubstance;
    function ParseSubstanceChild(value : TFhirSubstance; path : string; child : TMXmlElement) : boolean;
{$ENDIF FHIR_SUBSTANCE}
{$IFDEF FHIR_SUBSTANCEDEFINITION}
    function ParseSubstanceDefinitionMoiety(element : TMXmlElement; path : string) : TFhirSubstanceDefinitionMoiety;
    function ParseSubstanceDefinitionMoietyChild(value : TFhirSubstanceDefinitionMoiety; path : string; child : TMXmlElement) : boolean;
    function ParseSubstanceDefinitionProperty(element : TMXmlElement; path : string) : TFhirSubstanceDefinitionProperty;
    function ParseSubstanceDefinitionPropertyChild(value : TFhirSubstanceDefinitionProperty; path : string; child : TMXmlElement) : boolean;
    function ParseSubstanceDefinitionMolecularWeight(element : TMXmlElement; path : string) : TFhirSubstanceDefinitionMolecularWeight;
    function ParseSubstanceDefinitionMolecularWeightChild(value : TFhirSubstanceDefinitionMolecularWeight; path : string; child : TMXmlElement) : boolean;
    function ParseSubstanceDefinitionStructure(element : TMXmlElement; path : string) : TFhirSubstanceDefinitionStructure;
    function ParseSubstanceDefinitionStructureChild(value : TFhirSubstanceDefinitionStructure; path : string; child : TMXmlElement) : boolean;
    function ParseSubstanceDefinitionStructureRepresentation(element : TMXmlElement; path : string) : TFhirSubstanceDefinitionStructureRepresentation;
    function ParseSubstanceDefinitionStructureRepresentationChild(value : TFhirSubstanceDefinitionStructureRepresentation; path : string; child : TMXmlElement) : boolean;
    function ParseSubstanceDefinitionCode(element : TMXmlElement; path : string) : TFhirSubstanceDefinitionCode;
    function ParseSubstanceDefinitionCodeChild(value : TFhirSubstanceDefinitionCode; path : string; child : TMXmlElement) : boolean;
    function ParseSubstanceDefinitionName(element : TMXmlElement; path : string) : TFhirSubstanceDefinitionName;
    function ParseSubstanceDefinitionNameChild(value : TFhirSubstanceDefinitionName; path : string; child : TMXmlElement) : boolean;
    function ParseSubstanceDefinitionNameOfficial(element : TMXmlElement; path : string) : TFhirSubstanceDefinitionNameOfficial;
    function ParseSubstanceDefinitionNameOfficialChild(value : TFhirSubstanceDefinitionNameOfficial; path : string; child : TMXmlElement) : boolean;
    function ParseSubstanceDefinitionRelationship(element : TMXmlElement; path : string) : TFhirSubstanceDefinitionRelationship;
    function ParseSubstanceDefinitionRelationshipChild(value : TFhirSubstanceDefinitionRelationship; path : string; child : TMXmlElement) : boolean;
    function ParseSubstanceDefinitionSourceMaterial(element : TMXmlElement; path : string) : TFhirSubstanceDefinitionSourceMaterial;
    function ParseSubstanceDefinitionSourceMaterialChild(value : TFhirSubstanceDefinitionSourceMaterial; path : string; child : TMXmlElement) : boolean;
    function ParseSubstanceDefinition(element : TMXmlElement; path : string) : TFhirSubstanceDefinition;
    function ParseSubstanceDefinitionChild(value : TFhirSubstanceDefinition; path : string; child : TMXmlElement) : boolean;
{$ENDIF FHIR_SUBSTANCEDEFINITION}
{$IFDEF FHIR_SUBSTANCENUCLEICACID}
    function ParseSubstanceNucleicAcidSubunit(element : TMXmlElement; path : string) : TFhirSubstanceNucleicAcidSubunit;
    function ParseSubstanceNucleicAcidSubunitChild(value : TFhirSubstanceNucleicAcidSubunit; path : string; child : TMXmlElement) : boolean;
    function ParseSubstanceNucleicAcidSubunitLinkage(element : TMXmlElement; path : string) : TFhirSubstanceNucleicAcidSubunitLinkage;
    function ParseSubstanceNucleicAcidSubunitLinkageChild(value : TFhirSubstanceNucleicAcidSubunitLinkage; path : string; child : TMXmlElement) : boolean;
    function ParseSubstanceNucleicAcidSubunitSugar(element : TMXmlElement; path : string) : TFhirSubstanceNucleicAcidSubunitSugar;
    function ParseSubstanceNucleicAcidSubunitSugarChild(value : TFhirSubstanceNucleicAcidSubunitSugar; path : string; child : TMXmlElement) : boolean;
    function ParseSubstanceNucleicAcid(element : TMXmlElement; path : string) : TFhirSubstanceNucleicAcid;
    function ParseSubstanceNucleicAcidChild(value : TFhirSubstanceNucleicAcid; path : string; child : TMXmlElement) : boolean;
{$ENDIF FHIR_SUBSTANCENUCLEICACID}
{$IFDEF FHIR_SUBSTANCEPOLYMER}
    function ParseSubstancePolymerMonomerSet(element : TMXmlElement; path : string) : TFhirSubstancePolymerMonomerSet;
    function ParseSubstancePolymerMonomerSetChild(value : TFhirSubstancePolymerMonomerSet; path : string; child : TMXmlElement) : boolean;
    function ParseSubstancePolymerMonomerSetStartingMaterial(element : TMXmlElement; path : string) : TFhirSubstancePolymerMonomerSetStartingMaterial;
    function ParseSubstancePolymerMonomerSetStartingMaterialChild(value : TFhirSubstancePolymerMonomerSetStartingMaterial; path : string; child : TMXmlElement) : boolean;
    function ParseSubstancePolymerRepeat(element : TMXmlElement; path : string) : TFhirSubstancePolymerRepeat;
    function ParseSubstancePolymerRepeatChild(value : TFhirSubstancePolymerRepeat; path : string; child : TMXmlElement) : boolean;
    function ParseSubstancePolymerRepeatRepeatUnit(element : TMXmlElement; path : string) : TFhirSubstancePolymerRepeatRepeatUnit;
    function ParseSubstancePolymerRepeatRepeatUnitChild(value : TFhirSubstancePolymerRepeatRepeatUnit; path : string; child : TMXmlElement) : boolean;
    function ParseSubstancePolymerRepeatRepeatUnitDegreeOfPolymerisation(element : TMXmlElement; path : string) : TFhirSubstancePolymerRepeatRepeatUnitDegreeOfPolymerisation;
    function ParseSubstancePolymerRepeatRepeatUnitDegreeOfPolymerisationChild(value : TFhirSubstancePolymerRepeatRepeatUnitDegreeOfPolymerisation; path : string; child : TMXmlElement) : boolean;
    function ParseSubstancePolymerRepeatRepeatUnitStructuralRepresentation(element : TMXmlElement; path : string) : TFhirSubstancePolymerRepeatRepeatUnitStructuralRepresentation;
    function ParseSubstancePolymerRepeatRepeatUnitStructuralRepresentationChild(value : TFhirSubstancePolymerRepeatRepeatUnitStructuralRepresentation; path : string; child : TMXmlElement) : boolean;
    function ParseSubstancePolymer(element : TMXmlElement; path : string) : TFhirSubstancePolymer;
    function ParseSubstancePolymerChild(value : TFhirSubstancePolymer; path : string; child : TMXmlElement) : boolean;
{$ENDIF FHIR_SUBSTANCEPOLYMER}
{$IFDEF FHIR_SUBSTANCEPROTEIN}
    function ParseSubstanceProteinSubunit(element : TMXmlElement; path : string) : TFhirSubstanceProteinSubunit;
    function ParseSubstanceProteinSubunitChild(value : TFhirSubstanceProteinSubunit; path : string; child : TMXmlElement) : boolean;
    function ParseSubstanceProtein(element : TMXmlElement; path : string) : TFhirSubstanceProtein;
    function ParseSubstanceProteinChild(value : TFhirSubstanceProtein; path : string; child : TMXmlElement) : boolean;
{$ENDIF FHIR_SUBSTANCEPROTEIN}
{$IFDEF FHIR_SUBSTANCEREFERENCEINFORMATION}
    function ParseSubstanceReferenceInformationGene(element : TMXmlElement; path : string) : TFhirSubstanceReferenceInformationGene;
    function ParseSubstanceReferenceInformationGeneChild(value : TFhirSubstanceReferenceInformationGene; path : string; child : TMXmlElement) : boolean;
    function ParseSubstanceReferenceInformationGeneElement(element : TMXmlElement; path : string) : TFhirSubstanceReferenceInformationGeneElement;
    function ParseSubstanceReferenceInformationGeneElementChild(value : TFhirSubstanceReferenceInformationGeneElement; path : string; child : TMXmlElement) : boolean;
    function ParseSubstanceReferenceInformationTarget(element : TMXmlElement; path : string) : TFhirSubstanceReferenceInformationTarget;
    function ParseSubstanceReferenceInformationTargetChild(value : TFhirSubstanceReferenceInformationTarget; path : string; child : TMXmlElement) : boolean;
    function ParseSubstanceReferenceInformation(element : TMXmlElement; path : string) : TFhirSubstanceReferenceInformation;
    function ParseSubstanceReferenceInformationChild(value : TFhirSubstanceReferenceInformation; path : string; child : TMXmlElement) : boolean;
{$ENDIF FHIR_SUBSTANCEREFERENCEINFORMATION}
{$IFDEF FHIR_SUBSTANCESOURCEMATERIAL}
    function ParseSubstanceSourceMaterialFractionDescription(element : TMXmlElement; path : string) : TFhirSubstanceSourceMaterialFractionDescription;
    function ParseSubstanceSourceMaterialFractionDescriptionChild(value : TFhirSubstanceSourceMaterialFractionDescription; path : string; child : TMXmlElement) : boolean;
    function ParseSubstanceSourceMaterialOrganism(element : TMXmlElement; path : string) : TFhirSubstanceSourceMaterialOrganism;
    function ParseSubstanceSourceMaterialOrganismChild(value : TFhirSubstanceSourceMaterialOrganism; path : string; child : TMXmlElement) : boolean;
    function ParseSubstanceSourceMaterialOrganismAuthor(element : TMXmlElement; path : string) : TFhirSubstanceSourceMaterialOrganismAuthor;
    function ParseSubstanceSourceMaterialOrganismAuthorChild(value : TFhirSubstanceSourceMaterialOrganismAuthor; path : string; child : TMXmlElement) : boolean;
    function ParseSubstanceSourceMaterialOrganismHybrid(element : TMXmlElement; path : string) : TFhirSubstanceSourceMaterialOrganismHybrid;
    function ParseSubstanceSourceMaterialOrganismHybridChild(value : TFhirSubstanceSourceMaterialOrganismHybrid; path : string; child : TMXmlElement) : boolean;
    function ParseSubstanceSourceMaterialOrganismOrganismGeneral(element : TMXmlElement; path : string) : TFhirSubstanceSourceMaterialOrganismOrganismGeneral;
    function ParseSubstanceSourceMaterialOrganismOrganismGeneralChild(value : TFhirSubstanceSourceMaterialOrganismOrganismGeneral; path : string; child : TMXmlElement) : boolean;
    function ParseSubstanceSourceMaterialPartDescription(element : TMXmlElement; path : string) : TFhirSubstanceSourceMaterialPartDescription;
    function ParseSubstanceSourceMaterialPartDescriptionChild(value : TFhirSubstanceSourceMaterialPartDescription; path : string; child : TMXmlElement) : boolean;
    function ParseSubstanceSourceMaterial(element : TMXmlElement; path : string) : TFhirSubstanceSourceMaterial;
    function ParseSubstanceSourceMaterialChild(value : TFhirSubstanceSourceMaterial; path : string; child : TMXmlElement) : boolean;
{$ENDIF FHIR_SUBSTANCESOURCEMATERIAL}
{$IFDEF FHIR_SUPPLYDELIVERY}
    function ParseSupplyDeliverySuppliedItem(element : TMXmlElement; path : string) : TFhirSupplyDeliverySuppliedItem;
    function ParseSupplyDeliverySuppliedItemChild(value : TFhirSupplyDeliverySuppliedItem; path : string; child : TMXmlElement) : boolean;
    function ParseSupplyDelivery(element : TMXmlElement; path : string) : TFhirSupplyDelivery;
    function ParseSupplyDeliveryChild(value : TFhirSupplyDelivery; path : string; child : TMXmlElement) : boolean;
{$ENDIF FHIR_SUPPLYDELIVERY}
{$IFDEF FHIR_SUPPLYREQUEST}
    function ParseSupplyRequestParameter(element : TMXmlElement; path : string) : TFhirSupplyRequestParameter;
    function ParseSupplyRequestParameterChild(value : TFhirSupplyRequestParameter; path : string; child : TMXmlElement) : boolean;
    function ParseSupplyRequest(element : TMXmlElement; path : string) : TFhirSupplyRequest;
    function ParseSupplyRequestChild(value : TFhirSupplyRequest; path : string; child : TMXmlElement) : boolean;
{$ENDIF FHIR_SUPPLYREQUEST}
{$IFDEF FHIR_TASK}
    function ParseTaskRestriction(element : TMXmlElement; path : string) : TFhirTaskRestriction;
    function ParseTaskRestrictionChild(value : TFhirTaskRestriction; path : string; child : TMXmlElement) : boolean;
    function ParseTaskInput(element : TMXmlElement; path : string) : TFhirTaskInput;
    function ParseTaskInputChild(value : TFhirTaskInput; path : string; child : TMXmlElement) : boolean;
    function ParseTaskOutput(element : TMXmlElement; path : string) : TFhirTaskOutput;
    function ParseTaskOutputChild(value : TFhirTaskOutput; path : string; child : TMXmlElement) : boolean;
    function ParseTask(element : TMXmlElement; path : string) : TFhirTask;
    function ParseTaskChild(value : TFhirTask; path : string; child : TMXmlElement) : boolean;
{$ENDIF FHIR_TASK}
{$IFDEF FHIR_TERMINOLOGYCAPABILITIES}
    function ParseTerminologyCapabilitiesSoftware(element : TMXmlElement; path : string) : TFhirTerminologyCapabilitiesSoftware;
    function ParseTerminologyCapabilitiesSoftwareChild(value : TFhirTerminologyCapabilitiesSoftware; path : string; child : TMXmlElement) : boolean;
    function ParseTerminologyCapabilitiesImplementation(element : TMXmlElement; path : string) : TFhirTerminologyCapabilitiesImplementation;
    function ParseTerminologyCapabilitiesImplementationChild(value : TFhirTerminologyCapabilitiesImplementation; path : string; child : TMXmlElement) : boolean;
    function ParseTerminologyCapabilitiesCodeSystem(element : TMXmlElement; path : string) : TFhirTerminologyCapabilitiesCodeSystem;
    function ParseTerminologyCapabilitiesCodeSystemChild(value : TFhirTerminologyCapabilitiesCodeSystem; path : string; child : TMXmlElement) : boolean;
    function ParseTerminologyCapabilitiesCodeSystemVersion(element : TMXmlElement; path : string) : TFhirTerminologyCapabilitiesCodeSystemVersion;
    function ParseTerminologyCapabilitiesCodeSystemVersionChild(value : TFhirTerminologyCapabilitiesCodeSystemVersion; path : string; child : TMXmlElement) : boolean;
    function ParseTerminologyCapabilitiesCodeSystemVersionFilter(element : TMXmlElement; path : string) : TFhirTerminologyCapabilitiesCodeSystemVersionFilter;
    function ParseTerminologyCapabilitiesCodeSystemVersionFilterChild(value : TFhirTerminologyCapabilitiesCodeSystemVersionFilter; path : string; child : TMXmlElement) : boolean;
    function ParseTerminologyCapabilitiesExpansion(element : TMXmlElement; path : string) : TFhirTerminologyCapabilitiesExpansion;
    function ParseTerminologyCapabilitiesExpansionChild(value : TFhirTerminologyCapabilitiesExpansion; path : string; child : TMXmlElement) : boolean;
    function ParseTerminologyCapabilitiesExpansionParameter(element : TMXmlElement; path : string) : TFhirTerminologyCapabilitiesExpansionParameter;
    function ParseTerminologyCapabilitiesExpansionParameterChild(value : TFhirTerminologyCapabilitiesExpansionParameter; path : string; child : TMXmlElement) : boolean;
    function ParseTerminologyCapabilitiesValidateCode(element : TMXmlElement; path : string) : TFhirTerminologyCapabilitiesValidateCode;
    function ParseTerminologyCapabilitiesValidateCodeChild(value : TFhirTerminologyCapabilitiesValidateCode; path : string; child : TMXmlElement) : boolean;
    function ParseTerminologyCapabilitiesTranslation(element : TMXmlElement; path : string) : TFhirTerminologyCapabilitiesTranslation;
    function ParseTerminologyCapabilitiesTranslationChild(value : TFhirTerminologyCapabilitiesTranslation; path : string; child : TMXmlElement) : boolean;
    function ParseTerminologyCapabilitiesClosure(element : TMXmlElement; path : string) : TFhirTerminologyCapabilitiesClosure;
    function ParseTerminologyCapabilitiesClosureChild(value : TFhirTerminologyCapabilitiesClosure; path : string; child : TMXmlElement) : boolean;
    function ParseTerminologyCapabilities(element : TMXmlElement; path : string) : TFhirTerminologyCapabilities;
    function ParseTerminologyCapabilitiesChild(value : TFhirTerminologyCapabilities; path : string; child : TMXmlElement) : boolean;
{$ENDIF FHIR_TERMINOLOGYCAPABILITIES}
{$IFDEF FHIR_TESTREPORT}
    function ParseTestReportParticipant(element : TMXmlElement; path : string) : TFhirTestReportParticipant;
    function ParseTestReportParticipantChild(value : TFhirTestReportParticipant; path : string; child : TMXmlElement) : boolean;
    function ParseTestReportSetup(element : TMXmlElement; path : string) : TFhirTestReportSetup;
    function ParseTestReportSetupChild(value : TFhirTestReportSetup; path : string; child : TMXmlElement) : boolean;
    function ParseTestReportSetupAction(element : TMXmlElement; path : string) : TFhirTestReportSetupAction;
    function ParseTestReportSetupActionChild(value : TFhirTestReportSetupAction; path : string; child : TMXmlElement) : boolean;
    function ParseTestReportSetupActionOperation(element : TMXmlElement; path : string) : TFhirTestReportSetupActionOperation;
    function ParseTestReportSetupActionOperationChild(value : TFhirTestReportSetupActionOperation; path : string; child : TMXmlElement) : boolean;
    function ParseTestReportSetupActionAssert(element : TMXmlElement; path : string) : TFhirTestReportSetupActionAssert;
    function ParseTestReportSetupActionAssertChild(value : TFhirTestReportSetupActionAssert; path : string; child : TMXmlElement) : boolean;
    function ParseTestReportTest(element : TMXmlElement; path : string) : TFhirTestReportTest;
    function ParseTestReportTestChild(value : TFhirTestReportTest; path : string; child : TMXmlElement) : boolean;
    function ParseTestReportTestAction(element : TMXmlElement; path : string) : TFhirTestReportTestAction;
    function ParseTestReportTestActionChild(value : TFhirTestReportTestAction; path : string; child : TMXmlElement) : boolean;
    function ParseTestReportTeardown(element : TMXmlElement; path : string) : TFhirTestReportTeardown;
    function ParseTestReportTeardownChild(value : TFhirTestReportTeardown; path : string; child : TMXmlElement) : boolean;
    function ParseTestReportTeardownAction(element : TMXmlElement; path : string) : TFhirTestReportTeardownAction;
    function ParseTestReportTeardownActionChild(value : TFhirTestReportTeardownAction; path : string; child : TMXmlElement) : boolean;
    function ParseTestReport(element : TMXmlElement; path : string) : TFhirTestReport;
    function ParseTestReportChild(value : TFhirTestReport; path : string; child : TMXmlElement) : boolean;
{$ENDIF FHIR_TESTREPORT}
{$IFDEF FHIR_TESTSCRIPT}
    function ParseTestScriptOrigin(element : TMXmlElement; path : string) : TFhirTestScriptOrigin;
    function ParseTestScriptOriginChild(value : TFhirTestScriptOrigin; path : string; child : TMXmlElement) : boolean;
    function ParseTestScriptDestination(element : TMXmlElement; path : string) : TFhirTestScriptDestination;
    function ParseTestScriptDestinationChild(value : TFhirTestScriptDestination; path : string; child : TMXmlElement) : boolean;
    function ParseTestScriptMetadata(element : TMXmlElement; path : string) : TFhirTestScriptMetadata;
    function ParseTestScriptMetadataChild(value : TFhirTestScriptMetadata; path : string; child : TMXmlElement) : boolean;
    function ParseTestScriptMetadataLink(element : TMXmlElement; path : string) : TFhirTestScriptMetadataLink;
    function ParseTestScriptMetadataLinkChild(value : TFhirTestScriptMetadataLink; path : string; child : TMXmlElement) : boolean;
    function ParseTestScriptMetadataCapability(element : TMXmlElement; path : string) : TFhirTestScriptMetadataCapability;
    function ParseTestScriptMetadataCapabilityChild(value : TFhirTestScriptMetadataCapability; path : string; child : TMXmlElement) : boolean;
    function ParseTestScriptScope(element : TMXmlElement; path : string) : TFhirTestScriptScope;
    function ParseTestScriptScopeChild(value : TFhirTestScriptScope; path : string; child : TMXmlElement) : boolean;
    function ParseTestScriptFixture(element : TMXmlElement; path : string) : TFhirTestScriptFixture;
    function ParseTestScriptFixtureChild(value : TFhirTestScriptFixture; path : string; child : TMXmlElement) : boolean;
    function ParseTestScriptVariable(element : TMXmlElement; path : string) : TFhirTestScriptVariable;
    function ParseTestScriptVariableChild(value : TFhirTestScriptVariable; path : string; child : TMXmlElement) : boolean;
    function ParseTestScriptSetup(element : TMXmlElement; path : string) : TFhirTestScriptSetup;
    function ParseTestScriptSetupChild(value : TFhirTestScriptSetup; path : string; child : TMXmlElement) : boolean;
    function ParseTestScriptSetupAction(element : TMXmlElement; path : string) : TFhirTestScriptSetupAction;
    function ParseTestScriptSetupActionChild(value : TFhirTestScriptSetupAction; path : string; child : TMXmlElement) : boolean;
    function ParseTestScriptSetupActionOperation(element : TMXmlElement; path : string) : TFhirTestScriptSetupActionOperation;
    function ParseTestScriptSetupActionOperationChild(value : TFhirTestScriptSetupActionOperation; path : string; child : TMXmlElement) : boolean;
    function ParseTestScriptSetupActionOperationRequestHeader(element : TMXmlElement; path : string) : TFhirTestScriptSetupActionOperationRequestHeader;
    function ParseTestScriptSetupActionOperationRequestHeaderChild(value : TFhirTestScriptSetupActionOperationRequestHeader; path : string; child : TMXmlElement) : boolean;
    function ParseTestScriptSetupActionAssert(element : TMXmlElement; path : string) : TFhirTestScriptSetupActionAssert;
    function ParseTestScriptSetupActionAssertChild(value : TFhirTestScriptSetupActionAssert; path : string; child : TMXmlElement) : boolean;
    function ParseTestScriptTest(element : TMXmlElement; path : string) : TFhirTestScriptTest;
    function ParseTestScriptTestChild(value : TFhirTestScriptTest; path : string; child : TMXmlElement) : boolean;
    function ParseTestScriptTestAction(element : TMXmlElement; path : string) : TFhirTestScriptTestAction;
    function ParseTestScriptTestActionChild(value : TFhirTestScriptTestAction; path : string; child : TMXmlElement) : boolean;
    function ParseTestScriptTeardown(element : TMXmlElement; path : string) : TFhirTestScriptTeardown;
    function ParseTestScriptTeardownChild(value : TFhirTestScriptTeardown; path : string; child : TMXmlElement) : boolean;
    function ParseTestScriptTeardownAction(element : TMXmlElement; path : string) : TFhirTestScriptTeardownAction;
    function ParseTestScriptTeardownActionChild(value : TFhirTestScriptTeardownAction; path : string; child : TMXmlElement) : boolean;
    function ParseTestScript(element : TMXmlElement; path : string) : TFhirTestScript;
    function ParseTestScriptChild(value : TFhirTestScript; path : string; child : TMXmlElement) : boolean;
{$ENDIF FHIR_TESTSCRIPT}
{$IFDEF FHIR_TRANSPORT}
    function ParseTransportRestriction(element : TMXmlElement; path : string) : TFhirTransportRestriction;
    function ParseTransportRestrictionChild(value : TFhirTransportRestriction; path : string; child : TMXmlElement) : boolean;
    function ParseTransportInput(element : TMXmlElement; path : string) : TFhirTransportInput;
    function ParseTransportInputChild(value : TFhirTransportInput; path : string; child : TMXmlElement) : boolean;
    function ParseTransportOutput(element : TMXmlElement; path : string) : TFhirTransportOutput;
    function ParseTransportOutputChild(value : TFhirTransportOutput; path : string; child : TMXmlElement) : boolean;
    function ParseTransport(element : TMXmlElement; path : string) : TFhirTransport;
    function ParseTransportChild(value : TFhirTransport; path : string; child : TMXmlElement) : boolean;
{$ENDIF FHIR_TRANSPORT}
{$IFDEF FHIR_VALUESET}
    function ParseValueSetCompose(element : TMXmlElement; path : string) : TFhirValueSetCompose;
    function ParseValueSetComposeChild(value : TFhirValueSetCompose; path : string; child : TMXmlElement) : boolean;
    function ParseValueSetComposeInclude(element : TMXmlElement; path : string) : TFhirValueSetComposeInclude;
    function ParseValueSetComposeIncludeChild(value : TFhirValueSetComposeInclude; path : string; child : TMXmlElement) : boolean;
    function ParseValueSetComposeIncludeConcept(element : TMXmlElement; path : string) : TFhirValueSetComposeIncludeConcept;
    function ParseValueSetComposeIncludeConceptChild(value : TFhirValueSetComposeIncludeConcept; path : string; child : TMXmlElement) : boolean;
    function ParseValueSetComposeIncludeConceptDesignation(element : TMXmlElement; path : string) : TFhirValueSetComposeIncludeConceptDesignation;
    function ParseValueSetComposeIncludeConceptDesignationChild(value : TFhirValueSetComposeIncludeConceptDesignation; path : string; child : TMXmlElement) : boolean;
    function ParseValueSetComposeIncludeFilter(element : TMXmlElement; path : string) : TFhirValueSetComposeIncludeFilter;
    function ParseValueSetComposeIncludeFilterChild(value : TFhirValueSetComposeIncludeFilter; path : string; child : TMXmlElement) : boolean;
    function ParseValueSetExpansion(element : TMXmlElement; path : string) : TFhirValueSetExpansion;
    function ParseValueSetExpansionChild(value : TFhirValueSetExpansion; path : string; child : TMXmlElement) : boolean;
    function ParseValueSetExpansionParameter(element : TMXmlElement; path : string) : TFhirValueSetExpansionParameter;
    function ParseValueSetExpansionParameterChild(value : TFhirValueSetExpansionParameter; path : string; child : TMXmlElement) : boolean;
    function ParseValueSetExpansionProperty(element : TMXmlElement; path : string) : TFhirValueSetExpansionProperty;
    function ParseValueSetExpansionPropertyChild(value : TFhirValueSetExpansionProperty; path : string; child : TMXmlElement) : boolean;
    function ParseValueSetExpansionContains(element : TMXmlElement; path : string) : TFhirValueSetExpansionContains;
    function ParseValueSetExpansionContainsChild(value : TFhirValueSetExpansionContains; path : string; child : TMXmlElement) : boolean;
    function ParseValueSetExpansionContainsProperty(element : TMXmlElement; path : string) : TFhirValueSetExpansionContainsProperty;
    function ParseValueSetExpansionContainsPropertyChild(value : TFhirValueSetExpansionContainsProperty; path : string; child : TMXmlElement) : boolean;
    function ParseValueSetExpansionContainsPropertySubProperty(element : TMXmlElement; path : string) : TFhirValueSetExpansionContainsPropertySubProperty;
    function ParseValueSetExpansionContainsPropertySubPropertyChild(value : TFhirValueSetExpansionContainsPropertySubProperty; path : string; child : TMXmlElement) : boolean;
    function ParseValueSetScope(element : TMXmlElement; path : string) : TFhirValueSetScope;
    function ParseValueSetScopeChild(value : TFhirValueSetScope; path : string; child : TMXmlElement) : boolean;
    function ParseValueSet(element : TMXmlElement; path : string) : TFhirValueSet;
    function ParseValueSetChild(value : TFhirValueSet; path : string; child : TMXmlElement) : boolean;
{$ENDIF FHIR_VALUESET}
{$IFDEF FHIR_VERIFICATIONRESULT}
    function ParseVerificationResultPrimarySource(element : TMXmlElement; path : string) : TFhirVerificationResultPrimarySource;
    function ParseVerificationResultPrimarySourceChild(value : TFhirVerificationResultPrimarySource; path : string; child : TMXmlElement) : boolean;
    function ParseVerificationResultAttestation(element : TMXmlElement; path : string) : TFhirVerificationResultAttestation;
    function ParseVerificationResultAttestationChild(value : TFhirVerificationResultAttestation; path : string; child : TMXmlElement) : boolean;
    function ParseVerificationResultValidator(element : TMXmlElement; path : string) : TFhirVerificationResultValidator;
    function ParseVerificationResultValidatorChild(value : TFhirVerificationResultValidator; path : string; child : TMXmlElement) : boolean;
    function ParseVerificationResult(element : TMXmlElement; path : string) : TFhirVerificationResult;
    function ParseVerificationResultChild(value : TFhirVerificationResult; path : string; child : TMXmlElement) : boolean;
{$ENDIF FHIR_VERIFICATIONRESULT}
{$IFDEF FHIR_VISIONPRESCRIPTION}
    function ParseVisionPrescriptionLensSpecification(element : TMXmlElement; path : string) : TFhirVisionPrescriptionLensSpecification;
    function ParseVisionPrescriptionLensSpecificationChild(value : TFhirVisionPrescriptionLensSpecification; path : string; child : TMXmlElement) : boolean;
    function ParseVisionPrescriptionLensSpecificationPrism(element : TMXmlElement; path : string) : TFhirVisionPrescriptionLensSpecificationPrism;
    function ParseVisionPrescriptionLensSpecificationPrismChild(value : TFhirVisionPrescriptionLensSpecificationPrism; path : string; child : TMXmlElement) : boolean;
    function ParseVisionPrescription(element : TMXmlElement; path : string) : TFhirVisionPrescription;
    function ParseVisionPrescriptionChild(value : TFhirVisionPrescription; path : string; child : TMXmlElement) : boolean;
{$ENDIF FHIR_VISIONPRESCRIPTION}


    function ParseResource(element : TMXmlElement; path : String) : TFhirResource; override;
    function ParseDataType(element : TMXmlElement; name : String; type_ : TFHIRDataTypeClass) : TFHIRDataType; override;
  public
    function ParseFragment(element : TMXmlElement) : TFHIRObject; overload;
  end;

  TFHIRXmlComposer = class (TFHIRXmlComposerBase5)
  protected
    Procedure ComposeBaseAttributes(xml : TXmlBuilder; res : TFhirBase); overload;
    Procedure ComposeBaseChildren(xml : TXmlBuilder; value : TFhirBase); overload;
    Procedure ComposeBaseAttributes(xml : TXmlBuilder; res : TFhirResource); overload;
    Procedure ComposeBaseChildren(xml : TXmlBuilder; value : TFhirResource); overload;

    Procedure ComposeElementAttributes(xml : TXmlBuilder; value : TFhirElement);
    Procedure ComposeElementChildren(xml : TXmlBuilder; value : TFhirElement);
    Procedure ComposeBackboneElementAttributes(xml : TXmlBuilder; value : TFhirBackboneElement);
    Procedure ComposeBackboneElementChildren(xml : TXmlBuilder; value : TFhirBackboneElement);
    Procedure ComposeDataTypeAttributes(xml : TXmlBuilder; value : TFhirDataType);
    Procedure ComposeDataTypeChildren(xml : TXmlBuilder; value : TFhirDataType);
    Procedure ComposeBackboneTypeAttributes(xml : TXmlBuilder; value : TFhirBackboneType);
    Procedure ComposeBackboneTypeChildren(xml : TXmlBuilder; value : TFhirBackboneType);
    Procedure ComposePrimitiveTypeAttributes(xml : TXmlBuilder; value : TFhirPrimitiveType);
    Procedure ComposePrimitiveTypeChildren(xml : TXmlBuilder; value : TFhirPrimitiveType);


    Procedure ComposeEnum(xml : TXmlBuilder; name : String; value : TFhirEnum; Const aNames : Array Of String);
    Procedure ComposeDate(xml : TXmlBuilder; name : String; value : TFhirDate);
    Procedure ComposeDateTime(xml : TXmlBuilder; name : String; value : TFhirDateTime);
    Procedure ComposeString(xml : TXmlBuilder; name : String; value : TFhirString);
    Procedure ComposeInteger(xml : TXmlBuilder; name : String; value : TFhirInteger);
    Procedure ComposeUri(xml : TXmlBuilder; name : String; value : TFhirUri);
    Procedure ComposeInstant(xml : TXmlBuilder; name : String; value : TFhirInstant);
    Procedure ComposeXhtml(xml : TXmlBuilder; name : String; value : TFhirXhtml);
    Procedure ComposeBoolean(xml : TXmlBuilder; name : String; value : TFhirBoolean);
    Procedure ComposeBase64Binary(xml : TXmlBuilder; name : String; value : TFhirBase64Binary);
    Procedure ComposeTime(xml : TXmlBuilder; name : String; value : TFhirTime);
    Procedure ComposeDecimal(xml : TXmlBuilder; name : String; value : TFhirDecimal);
    Procedure ComposeCode(xml : TXmlBuilder; name : String; value : TFhirCode);
    Procedure ComposeCanonical(xml : TXmlBuilder; name : String; value : TFhirCanonical);
    Procedure ComposeOid(xml : TXmlBuilder; name : String; value : TFhirOid);
    Procedure ComposeUuid(xml : TXmlBuilder; name : String; value : TFhirUuid);
    Procedure ComposeUrl(xml : TXmlBuilder; name : String; value : TFhirUrl);
    Procedure ComposeMarkdown(xml : TXmlBuilder; name : String; value : TFhirMarkdown);
    Procedure ComposeUnsignedInt(xml : TXmlBuilder; name : String; value : TFhirUnsignedInt);
    Procedure ComposeId(xml : TXmlBuilder; name : String; value : TFhirId);
    Procedure ComposePositiveInt(xml : TXmlBuilder; name : String; value : TFhirPositiveInt);
    Procedure ComposeInteger64(xml : TXmlBuilder; name : String; value : TFhirInteger64);

    procedure ComposeAddress(xml : TXmlBuilder; name : string; value : TFhirAddress);
    procedure ComposeAddressChildren(xml : TXmlBuilder; value : TFhirAddress);
    procedure ComposeAnnotation(xml : TXmlBuilder; name : string; value : TFhirAnnotation);
    procedure ComposeAnnotationChildren(xml : TXmlBuilder; value : TFhirAnnotation);
    procedure ComposeAttachment(xml : TXmlBuilder; name : string; value : TFhirAttachment);
    procedure ComposeAttachmentChildren(xml : TXmlBuilder; value : TFhirAttachment);
    procedure ComposeAvailabilityAvailableTime(xml : TXmlBuilder; name : string; value : TFhirAvailabilityAvailableTime);
    procedure ComposeAvailabilityAvailableTimeChildren(xml : TXmlBuilder; value : TFhirAvailabilityAvailableTime);
    procedure ComposeAvailabilityNotAvailableTime(xml : TXmlBuilder; name : string; value : TFhirAvailabilityNotAvailableTime);
    procedure ComposeAvailabilityNotAvailableTimeChildren(xml : TXmlBuilder; value : TFhirAvailabilityNotAvailableTime);
    procedure ComposeAvailability(xml : TXmlBuilder; name : string; value : TFhirAvailability);
    procedure ComposeAvailabilityChildren(xml : TXmlBuilder; value : TFhirAvailability);
    procedure ComposeCodeableConcept(xml : TXmlBuilder; name : string; value : TFhirCodeableConcept);
    procedure ComposeCodeableConceptChildren(xml : TXmlBuilder; value : TFhirCodeableConcept);
    procedure ComposeCodeableReference(xml : TXmlBuilder; name : string; value : TFhirCodeableReference);
    procedure ComposeCodeableReferenceChildren(xml : TXmlBuilder; value : TFhirCodeableReference);
    procedure ComposeCoding(xml : TXmlBuilder; name : string; value : TFhirCoding);
    procedure ComposeCodingChildren(xml : TXmlBuilder; value : TFhirCoding);
    procedure ComposeContactDetail(xml : TXmlBuilder; name : string; value : TFhirContactDetail);
    procedure ComposeContactDetailChildren(xml : TXmlBuilder; value : TFhirContactDetail);
    procedure ComposeContactPoint(xml : TXmlBuilder; name : string; value : TFhirContactPoint);
    procedure ComposeContactPointChildren(xml : TXmlBuilder; value : TFhirContactPoint);
    procedure ComposeContributor(xml : TXmlBuilder; name : string; value : TFhirContributor);
    procedure ComposeContributorChildren(xml : TXmlBuilder; value : TFhirContributor);
    procedure ComposeDataRequirementCodeFilter(xml : TXmlBuilder; name : string; value : TFhirDataRequirementCodeFilter);
    procedure ComposeDataRequirementCodeFilterChildren(xml : TXmlBuilder; value : TFhirDataRequirementCodeFilter);
    procedure ComposeDataRequirementDateFilter(xml : TXmlBuilder; name : string; value : TFhirDataRequirementDateFilter);
    procedure ComposeDataRequirementDateFilterChildren(xml : TXmlBuilder; value : TFhirDataRequirementDateFilter);
    procedure ComposeDataRequirementValueFilter(xml : TXmlBuilder; name : string; value : TFhirDataRequirementValueFilter);
    procedure ComposeDataRequirementValueFilterChildren(xml : TXmlBuilder; value : TFhirDataRequirementValueFilter);
    procedure ComposeDataRequirementSort(xml : TXmlBuilder; name : string; value : TFhirDataRequirementSort);
    procedure ComposeDataRequirementSortChildren(xml : TXmlBuilder; value : TFhirDataRequirementSort);
    procedure ComposeDataRequirement(xml : TXmlBuilder; name : string; value : TFhirDataRequirement);
    procedure ComposeDataRequirementChildren(xml : TXmlBuilder; value : TFhirDataRequirement);
    procedure ComposeExpression(xml : TXmlBuilder; name : string; value : TFhirExpression);
    procedure ComposeExpressionChildren(xml : TXmlBuilder; value : TFhirExpression);
    procedure ComposeExtendedContactDetail(xml : TXmlBuilder; name : string; value : TFhirExtendedContactDetail);
    procedure ComposeExtendedContactDetailChildren(xml : TXmlBuilder; value : TFhirExtendedContactDetail);
    procedure ComposeExtension(xml : TXmlBuilder; name : string; value : TFhirExtension);
    procedure ComposeExtensionChildren(xml : TXmlBuilder; value : TFhirExtension);
    procedure ComposeHumanName(xml : TXmlBuilder; name : string; value : TFhirHumanName);
    procedure ComposeHumanNameChildren(xml : TXmlBuilder; value : TFhirHumanName);
    procedure ComposeIdentifier(xml : TXmlBuilder; name : string; value : TFhirIdentifier);
    procedure ComposeIdentifierChildren(xml : TXmlBuilder; value : TFhirIdentifier);
    procedure ComposeMeta(xml : TXmlBuilder; name : string; value : TFhirMeta);
    procedure ComposeMetaChildren(xml : TXmlBuilder; value : TFhirMeta);
    procedure ComposeMonetaryComponent(xml : TXmlBuilder; name : string; value : TFhirMonetaryComponent);
    procedure ComposeMonetaryComponentChildren(xml : TXmlBuilder; value : TFhirMonetaryComponent);
    procedure ComposeMoney(xml : TXmlBuilder; name : string; value : TFhirMoney);
    procedure ComposeMoneyChildren(xml : TXmlBuilder; value : TFhirMoney);
    procedure ComposeNarrative(xml : TXmlBuilder; name : string; value : TFhirNarrative);
    procedure ComposeNarrativeChildren(xml : TXmlBuilder; value : TFhirNarrative);
    procedure ComposeParameterDefinition(xml : TXmlBuilder; name : string; value : TFhirParameterDefinition);
    procedure ComposeParameterDefinitionChildren(xml : TXmlBuilder; value : TFhirParameterDefinition);
    procedure ComposePeriod(xml : TXmlBuilder; name : string; value : TFhirPeriod);
    procedure ComposePeriodChildren(xml : TXmlBuilder; value : TFhirPeriod);
    procedure ComposeQuantity(xml : TXmlBuilder; name : string; value : TFhirQuantity);
    procedure ComposeQuantityChildren(xml : TXmlBuilder; value : TFhirQuantity);
    procedure ComposeRange(xml : TXmlBuilder; name : string; value : TFhirRange);
    procedure ComposeRangeChildren(xml : TXmlBuilder; value : TFhirRange);
    procedure ComposeRatio(xml : TXmlBuilder; name : string; value : TFhirRatio);
    procedure ComposeRatioChildren(xml : TXmlBuilder; value : TFhirRatio);
    procedure ComposeRatioRange(xml : TXmlBuilder; name : string; value : TFhirRatioRange);
    procedure ComposeRatioRangeChildren(xml : TXmlBuilder; value : TFhirRatioRange);
    procedure ComposeReference(xml : TXmlBuilder; name : string; value : TFhirReference);
    procedure ComposeReferenceChildren(xml : TXmlBuilder; value : TFhirReference);
    procedure ComposeRelatedArtifact(xml : TXmlBuilder; name : string; value : TFhirRelatedArtifact);
    procedure ComposeRelatedArtifactChildren(xml : TXmlBuilder; value : TFhirRelatedArtifact);
    procedure ComposeSampledData(xml : TXmlBuilder; name : string; value : TFhirSampledData);
    procedure ComposeSampledDataChildren(xml : TXmlBuilder; value : TFhirSampledData);
    procedure ComposeSignature(xml : TXmlBuilder; name : string; value : TFhirSignature);
    procedure ComposeSignatureChildren(xml : TXmlBuilder; value : TFhirSignature);
    procedure ComposeTriggerDefinition(xml : TXmlBuilder; name : string; value : TFhirTriggerDefinition);
    procedure ComposeTriggerDefinitionChildren(xml : TXmlBuilder; value : TFhirTriggerDefinition);
    procedure ComposeUsageContext(xml : TXmlBuilder; name : string; value : TFhirUsageContext);
    procedure ComposeUsageContextChildren(xml : TXmlBuilder; value : TFhirUsageContext);
    procedure ComposeVirtualServiceDetail(xml : TXmlBuilder; name : string; value : TFhirVirtualServiceDetail);
    procedure ComposeVirtualServiceDetailChildren(xml : TXmlBuilder; value : TFhirVirtualServiceDetail);
    procedure ComposeAge(xml : TXmlBuilder; name : string; value : TFhirAge);
    procedure ComposeAgeChildren(xml : TXmlBuilder; value : TFhirAge);
    procedure ComposeCount(xml : TXmlBuilder; name : string; value : TFhirCount);
    procedure ComposeCountChildren(xml : TXmlBuilder; value : TFhirCount);
    procedure ComposeDistance(xml : TXmlBuilder; name : string; value : TFhirDistance);
    procedure ComposeDistanceChildren(xml : TXmlBuilder; value : TFhirDistance);
    procedure ComposeDosageDoseAndRate(xml : TXmlBuilder; name : string; value : TFhirDosageDoseAndRate);
    procedure ComposeDosageDoseAndRateChildren(xml : TXmlBuilder; value : TFhirDosageDoseAndRate);
    procedure ComposeDosage(xml : TXmlBuilder; name : string; value : TFhirDosage);
    procedure ComposeDosageChildren(xml : TXmlBuilder; value : TFhirDosage);
    procedure ComposeDuration(xml : TXmlBuilder; name : string; value : TFhirDuration);
    procedure ComposeDurationChildren(xml : TXmlBuilder; value : TFhirDuration);
    procedure ComposeElementDefinitionSlicing(xml : TXmlBuilder; name : string; value : TFhirElementDefinitionSlicing);
    procedure ComposeElementDefinitionSlicingChildren(xml : TXmlBuilder; value : TFhirElementDefinitionSlicing);
    procedure ComposeElementDefinitionSlicingDiscriminator(xml : TXmlBuilder; name : string; value : TFhirElementDefinitionSlicingDiscriminator);
    procedure ComposeElementDefinitionSlicingDiscriminatorChildren(xml : TXmlBuilder; value : TFhirElementDefinitionSlicingDiscriminator);
    procedure ComposeElementDefinitionBase(xml : TXmlBuilder; name : string; value : TFhirElementDefinitionBase);
    procedure ComposeElementDefinitionBaseChildren(xml : TXmlBuilder; value : TFhirElementDefinitionBase);
    procedure ComposeElementDefinitionType(xml : TXmlBuilder; name : string; value : TFhirElementDefinitionType);
    procedure ComposeElementDefinitionTypeChildren(xml : TXmlBuilder; value : TFhirElementDefinitionType);
    procedure ComposeElementDefinitionExample(xml : TXmlBuilder; name : string; value : TFhirElementDefinitionExample);
    procedure ComposeElementDefinitionExampleChildren(xml : TXmlBuilder; value : TFhirElementDefinitionExample);
    procedure ComposeElementDefinitionConstraint(xml : TXmlBuilder; name : string; value : TFhirElementDefinitionConstraint);
    procedure ComposeElementDefinitionConstraintChildren(xml : TXmlBuilder; value : TFhirElementDefinitionConstraint);
    procedure ComposeElementDefinitionBinding(xml : TXmlBuilder; name : string; value : TFhirElementDefinitionBinding);
    procedure ComposeElementDefinitionBindingChildren(xml : TXmlBuilder; value : TFhirElementDefinitionBinding);
    procedure ComposeElementDefinitionMapping(xml : TXmlBuilder; name : string; value : TFhirElementDefinitionMapping);
    procedure ComposeElementDefinitionMappingChildren(xml : TXmlBuilder; value : TFhirElementDefinitionMapping);
    procedure ComposeElementDefinition(xml : TXmlBuilder; name : string; value : TFhirElementDefinition);
    procedure ComposeElementDefinitionChildren(xml : TXmlBuilder; value : TFhirElementDefinition);
    procedure ComposeMarketingStatus(xml : TXmlBuilder; name : string; value : TFhirMarketingStatus);
    procedure ComposeMarketingStatusChildren(xml : TXmlBuilder; value : TFhirMarketingStatus);
    procedure ComposePopulation(xml : TXmlBuilder; name : string; value : TFhirPopulation);
    procedure ComposePopulationChildren(xml : TXmlBuilder; value : TFhirPopulation);
    procedure ComposeProductShelfLife(xml : TXmlBuilder; name : string; value : TFhirProductShelfLife);
    procedure ComposeProductShelfLifeChildren(xml : TXmlBuilder; value : TFhirProductShelfLife);
    procedure ComposeTimingRepeat(xml : TXmlBuilder; name : string; value : TFhirTimingRepeat);
    procedure ComposeTimingRepeatChildren(xml : TXmlBuilder; value : TFhirTimingRepeat);
    procedure ComposeTiming(xml : TXmlBuilder; name : string; value : TFhirTiming);
    procedure ComposeTimingChildren(xml : TXmlBuilder; value : TFhirTiming);


    Procedure ComposeResourceAttributes(xml : TXmlBuilder; value : TFhirResource);
    Procedure ComposeResourceChildren(xml : TXmlBuilder; value : TFhirResource);
    Procedure ComposeDomainResourceAttributes(xml : TXmlBuilder; value : TFhirDomainResource);
    Procedure ComposeDomainResourceChildren(xml : TXmlBuilder; value : TFhirDomainResource);
    Procedure ComposeCanonicalResourceAttributes(xml : TXmlBuilder; value : TFhirCanonicalResource);
    Procedure ComposeCanonicalResourceChildren(xml : TXmlBuilder; value : TFhirCanonicalResource);
    Procedure ComposeMetadataResourceAttributes(xml : TXmlBuilder; value : TFhirMetadataResource);
    Procedure ComposeMetadataResourceChildren(xml : TXmlBuilder; value : TFhirMetadataResource);


{$IFDEF FHIR_ACCOUNT}
    procedure ComposeAccountCoverage(xml : TXmlBuilder; name : string; value : TFhirAccountCoverage);
    procedure ComposeAccountCoverageChildren(xml : TXmlBuilder; value : TFhirAccountCoverage);
    procedure ComposeAccountGuarantor(xml : TXmlBuilder; name : string; value : TFhirAccountGuarantor);
    procedure ComposeAccountGuarantorChildren(xml : TXmlBuilder; value : TFhirAccountGuarantor);
    procedure ComposeAccountRelatedAccount(xml : TXmlBuilder; name : string; value : TFhirAccountRelatedAccount);
    procedure ComposeAccountRelatedAccountChildren(xml : TXmlBuilder; value : TFhirAccountRelatedAccount);
    procedure ComposeAccountBalance(xml : TXmlBuilder; name : string; value : TFhirAccountBalance);
    procedure ComposeAccountBalanceChildren(xml : TXmlBuilder; value : TFhirAccountBalance);
    procedure ComposeAccount(xml : TXmlBuilder; name : string; value : TFhirAccount);
    procedure ComposeAccountChildren(xml : TXmlBuilder; value : TFhirAccount);
{$ENDIF FHIR_ACCOUNT}
{$IFDEF FHIR_ACTIVITYDEFINITION}
    procedure ComposeActivityDefinitionParticipant(xml : TXmlBuilder; name : string; value : TFhirActivityDefinitionParticipant);
    procedure ComposeActivityDefinitionParticipantChildren(xml : TXmlBuilder; value : TFhirActivityDefinitionParticipant);
    procedure ComposeActivityDefinitionDynamicValue(xml : TXmlBuilder; name : string; value : TFhirActivityDefinitionDynamicValue);
    procedure ComposeActivityDefinitionDynamicValueChildren(xml : TXmlBuilder; value : TFhirActivityDefinitionDynamicValue);
    procedure ComposeActivityDefinition(xml : TXmlBuilder; name : string; value : TFhirActivityDefinition);
    procedure ComposeActivityDefinitionChildren(xml : TXmlBuilder; value : TFhirActivityDefinition);
{$ENDIF FHIR_ACTIVITYDEFINITION}
{$IFDEF FHIR_ACTORDEFINITION}
    procedure ComposeActorDefinition(xml : TXmlBuilder; name : string; value : TFhirActorDefinition);
    procedure ComposeActorDefinitionChildren(xml : TXmlBuilder; value : TFhirActorDefinition);
{$ENDIF FHIR_ACTORDEFINITION}
{$IFDEF FHIR_ADMINISTRABLEPRODUCTDEFINITION}
    procedure ComposeAdministrableProductDefinitionProperty(xml : TXmlBuilder; name : string; value : TFhirAdministrableProductDefinitionProperty);
    procedure ComposeAdministrableProductDefinitionPropertyChildren(xml : TXmlBuilder; value : TFhirAdministrableProductDefinitionProperty);
    procedure ComposeAdministrableProductDefinitionRouteOfAdministration(xml : TXmlBuilder; name : string; value : TFhirAdministrableProductDefinitionRouteOfAdministration);
    procedure ComposeAdministrableProductDefinitionRouteOfAdministrationChildren(xml : TXmlBuilder; value : TFhirAdministrableProductDefinitionRouteOfAdministration);
    procedure ComposeAdministrableProductDefinitionRouteOfAdministrationTargetSpecies(xml : TXmlBuilder; name : string; value : TFhirAdministrableProductDefinitionRouteOfAdministrationTargetSpecies);
    procedure ComposeAdministrableProductDefinitionRouteOfAdministrationTargetSpeciesChildren(xml : TXmlBuilder; value : TFhirAdministrableProductDefinitionRouteOfAdministrationTargetSpecies);
    procedure ComposeAdministrableProductDefinitionRouteOfAdministrationTargetSpeciesWithdrawalPeriod(xml : TXmlBuilder; name : string; value : TFhirAdministrableProductDefinitionRouteOfAdministrationTargetSpeciesWithdrawalPeriod);
    procedure ComposeAdministrableProductDefinitionRouteOfAdministrationTargetSpeciesWithdrawalPeriodChildren(xml : TXmlBuilder; value : TFhirAdministrableProductDefinitionRouteOfAdministrationTargetSpeciesWithdrawalPeriod);
    procedure ComposeAdministrableProductDefinition(xml : TXmlBuilder; name : string; value : TFhirAdministrableProductDefinition);
    procedure ComposeAdministrableProductDefinitionChildren(xml : TXmlBuilder; value : TFhirAdministrableProductDefinition);
{$ENDIF FHIR_ADMINISTRABLEPRODUCTDEFINITION}
{$IFDEF FHIR_ADVERSEEVENT}
    procedure ComposeAdverseEventParticipant(xml : TXmlBuilder; name : string; value : TFhirAdverseEventParticipant);
    procedure ComposeAdverseEventParticipantChildren(xml : TXmlBuilder; value : TFhirAdverseEventParticipant);
    procedure ComposeAdverseEventSuspectEntity(xml : TXmlBuilder; name : string; value : TFhirAdverseEventSuspectEntity);
    procedure ComposeAdverseEventSuspectEntityChildren(xml : TXmlBuilder; value : TFhirAdverseEventSuspectEntity);
    procedure ComposeAdverseEventSuspectEntityCausality(xml : TXmlBuilder; name : string; value : TFhirAdverseEventSuspectEntityCausality);
    procedure ComposeAdverseEventSuspectEntityCausalityChildren(xml : TXmlBuilder; value : TFhirAdverseEventSuspectEntityCausality);
    procedure ComposeAdverseEventContributingFactor(xml : TXmlBuilder; name : string; value : TFhirAdverseEventContributingFactor);
    procedure ComposeAdverseEventContributingFactorChildren(xml : TXmlBuilder; value : TFhirAdverseEventContributingFactor);
    procedure ComposeAdverseEventPreventiveAction(xml : TXmlBuilder; name : string; value : TFhirAdverseEventPreventiveAction);
    procedure ComposeAdverseEventPreventiveActionChildren(xml : TXmlBuilder; value : TFhirAdverseEventPreventiveAction);
    procedure ComposeAdverseEventMitigatingAction(xml : TXmlBuilder; name : string; value : TFhirAdverseEventMitigatingAction);
    procedure ComposeAdverseEventMitigatingActionChildren(xml : TXmlBuilder; value : TFhirAdverseEventMitigatingAction);
    procedure ComposeAdverseEventSupportingInfo(xml : TXmlBuilder; name : string; value : TFhirAdverseEventSupportingInfo);
    procedure ComposeAdverseEventSupportingInfoChildren(xml : TXmlBuilder; value : TFhirAdverseEventSupportingInfo);
    procedure ComposeAdverseEvent(xml : TXmlBuilder; name : string; value : TFhirAdverseEvent);
    procedure ComposeAdverseEventChildren(xml : TXmlBuilder; value : TFhirAdverseEvent);
{$ENDIF FHIR_ADVERSEEVENT}
{$IFDEF FHIR_ALLERGYINTOLERANCE}
    procedure ComposeAllergyIntoleranceParticipant(xml : TXmlBuilder; name : string; value : TFhirAllergyIntoleranceParticipant);
    procedure ComposeAllergyIntoleranceParticipantChildren(xml : TXmlBuilder; value : TFhirAllergyIntoleranceParticipant);
    procedure ComposeAllergyIntoleranceReaction(xml : TXmlBuilder; name : string; value : TFhirAllergyIntoleranceReaction);
    procedure ComposeAllergyIntoleranceReactionChildren(xml : TXmlBuilder; value : TFhirAllergyIntoleranceReaction);
    procedure ComposeAllergyIntolerance(xml : TXmlBuilder; name : string; value : TFhirAllergyIntolerance);
    procedure ComposeAllergyIntoleranceChildren(xml : TXmlBuilder; value : TFhirAllergyIntolerance);
{$ENDIF FHIR_ALLERGYINTOLERANCE}
{$IFDEF FHIR_APPOINTMENT}
    procedure ComposeAppointmentParticipant(xml : TXmlBuilder; name : string; value : TFhirAppointmentParticipant);
    procedure ComposeAppointmentParticipantChildren(xml : TXmlBuilder; value : TFhirAppointmentParticipant);
    procedure ComposeAppointmentRecurrenceTemplate(xml : TXmlBuilder; name : string; value : TFhirAppointmentRecurrenceTemplate);
    procedure ComposeAppointmentRecurrenceTemplateChildren(xml : TXmlBuilder; value : TFhirAppointmentRecurrenceTemplate);
    procedure ComposeAppointmentRecurrenceTemplateWeeklyTemplate(xml : TXmlBuilder; name : string; value : TFhirAppointmentRecurrenceTemplateWeeklyTemplate);
    procedure ComposeAppointmentRecurrenceTemplateWeeklyTemplateChildren(xml : TXmlBuilder; value : TFhirAppointmentRecurrenceTemplateWeeklyTemplate);
    procedure ComposeAppointmentRecurrenceTemplateMonthlyTemplate(xml : TXmlBuilder; name : string; value : TFhirAppointmentRecurrenceTemplateMonthlyTemplate);
    procedure ComposeAppointmentRecurrenceTemplateMonthlyTemplateChildren(xml : TXmlBuilder; value : TFhirAppointmentRecurrenceTemplateMonthlyTemplate);
    procedure ComposeAppointmentRecurrenceTemplateYearlyTemplate(xml : TXmlBuilder; name : string; value : TFhirAppointmentRecurrenceTemplateYearlyTemplate);
    procedure ComposeAppointmentRecurrenceTemplateYearlyTemplateChildren(xml : TXmlBuilder; value : TFhirAppointmentRecurrenceTemplateYearlyTemplate);
    procedure ComposeAppointment(xml : TXmlBuilder; name : string; value : TFhirAppointment);
    procedure ComposeAppointmentChildren(xml : TXmlBuilder; value : TFhirAppointment);
{$ENDIF FHIR_APPOINTMENT}
{$IFDEF FHIR_APPOINTMENTRESPONSE}
    procedure ComposeAppointmentResponse(xml : TXmlBuilder; name : string; value : TFhirAppointmentResponse);
    procedure ComposeAppointmentResponseChildren(xml : TXmlBuilder; value : TFhirAppointmentResponse);
{$ENDIF FHIR_APPOINTMENTRESPONSE}
{$IFDEF FHIR_ARTIFACTASSESSMENT}
    procedure ComposeArtifactAssessmentContent(xml : TXmlBuilder; name : string; value : TFhirArtifactAssessmentContent);
    procedure ComposeArtifactAssessmentContentChildren(xml : TXmlBuilder; value : TFhirArtifactAssessmentContent);
    procedure ComposeArtifactAssessment(xml : TXmlBuilder; name : string; value : TFhirArtifactAssessment);
    procedure ComposeArtifactAssessmentChildren(xml : TXmlBuilder; value : TFhirArtifactAssessment);
{$ENDIF FHIR_ARTIFACTASSESSMENT}
{$IFDEF FHIR_AUDITEVENT}
    procedure ComposeAuditEventOutcome(xml : TXmlBuilder; name : string; value : TFhirAuditEventOutcome);
    procedure ComposeAuditEventOutcomeChildren(xml : TXmlBuilder; value : TFhirAuditEventOutcome);
    procedure ComposeAuditEventAgent(xml : TXmlBuilder; name : string; value : TFhirAuditEventAgent);
    procedure ComposeAuditEventAgentChildren(xml : TXmlBuilder; value : TFhirAuditEventAgent);
    procedure ComposeAuditEventSource(xml : TXmlBuilder; name : string; value : TFhirAuditEventSource);
    procedure ComposeAuditEventSourceChildren(xml : TXmlBuilder; value : TFhirAuditEventSource);
    procedure ComposeAuditEventEntity(xml : TXmlBuilder; name : string; value : TFhirAuditEventEntity);
    procedure ComposeAuditEventEntityChildren(xml : TXmlBuilder; value : TFhirAuditEventEntity);
    procedure ComposeAuditEventEntityDetail(xml : TXmlBuilder; name : string; value : TFhirAuditEventEntityDetail);
    procedure ComposeAuditEventEntityDetailChildren(xml : TXmlBuilder; value : TFhirAuditEventEntityDetail);
    procedure ComposeAuditEvent(xml : TXmlBuilder; name : string; value : TFhirAuditEvent);
    procedure ComposeAuditEventChildren(xml : TXmlBuilder; value : TFhirAuditEvent);
{$ENDIF FHIR_AUDITEVENT}
{$IFDEF FHIR_BASIC}
    procedure ComposeBasic(xml : TXmlBuilder; name : string; value : TFhirBasic);
    procedure ComposeBasicChildren(xml : TXmlBuilder; value : TFhirBasic);
{$ENDIF FHIR_BASIC}
{$IFDEF FHIR_BINARY}
    procedure ComposeBinary(xml : TXmlBuilder; name : string; value : TFhirBinary);
    procedure ComposeBinaryChildren(xml : TXmlBuilder; value : TFhirBinary);
{$ENDIF FHIR_BINARY}
{$IFDEF FHIR_BIOLOGICALLYDERIVEDPRODUCT}
    procedure ComposeBiologicallyDerivedProductCollection(xml : TXmlBuilder; name : string; value : TFhirBiologicallyDerivedProductCollection);
    procedure ComposeBiologicallyDerivedProductCollectionChildren(xml : TXmlBuilder; value : TFhirBiologicallyDerivedProductCollection);
    procedure ComposeBiologicallyDerivedProductProperty(xml : TXmlBuilder; name : string; value : TFhirBiologicallyDerivedProductProperty);
    procedure ComposeBiologicallyDerivedProductPropertyChildren(xml : TXmlBuilder; value : TFhirBiologicallyDerivedProductProperty);
    procedure ComposeBiologicallyDerivedProduct(xml : TXmlBuilder; name : string; value : TFhirBiologicallyDerivedProduct);
    procedure ComposeBiologicallyDerivedProductChildren(xml : TXmlBuilder; value : TFhirBiologicallyDerivedProduct);
{$ENDIF FHIR_BIOLOGICALLYDERIVEDPRODUCT}
{$IFDEF FHIR_BODYSTRUCTURE}
    procedure ComposeBodyStructureIncludedStructure(xml : TXmlBuilder; name : string; value : TFhirBodyStructureIncludedStructure);
    procedure ComposeBodyStructureIncludedStructureChildren(xml : TXmlBuilder; value : TFhirBodyStructureIncludedStructure);
    procedure ComposeBodyStructureExcludedStructure(xml : TXmlBuilder; name : string; value : TFhirBodyStructureExcludedStructure);
    procedure ComposeBodyStructureExcludedStructureChildren(xml : TXmlBuilder; value : TFhirBodyStructureExcludedStructure);
    procedure ComposeBodyStructure(xml : TXmlBuilder; name : string; value : TFhirBodyStructure);
    procedure ComposeBodyStructureChildren(xml : TXmlBuilder; value : TFhirBodyStructure);
{$ENDIF FHIR_BODYSTRUCTURE}
{$IFDEF FHIR_BUNDLE}
    procedure ComposeBundleLink(xml : TXmlBuilder; name : string; value : TFhirBundleLink);
    procedure ComposeBundleLinkChildren(xml : TXmlBuilder; value : TFhirBundleLink);
    procedure ComposeBundleEntry(xml : TXmlBuilder; name : string; value : TFhirBundleEntry);
    procedure ComposeBundleEntryChildren(xml : TXmlBuilder; value : TFhirBundleEntry);
    procedure ComposeBundleEntrySearch(xml : TXmlBuilder; name : string; value : TFhirBundleEntrySearch);
    procedure ComposeBundleEntrySearchChildren(xml : TXmlBuilder; value : TFhirBundleEntrySearch);
    procedure ComposeBundleEntryRequest(xml : TXmlBuilder; name : string; value : TFhirBundleEntryRequest);
    procedure ComposeBundleEntryRequestChildren(xml : TXmlBuilder; value : TFhirBundleEntryRequest);
    procedure ComposeBundleEntryResponse(xml : TXmlBuilder; name : string; value : TFhirBundleEntryResponse);
    procedure ComposeBundleEntryResponseChildren(xml : TXmlBuilder; value : TFhirBundleEntryResponse);
    procedure ComposeBundle(xml : TXmlBuilder; name : string; value : TFhirBundle);
    procedure ComposeBundleChildren(xml : TXmlBuilder; value : TFhirBundle);
{$ENDIF FHIR_BUNDLE}
{$IFDEF FHIR_CAPABILITYSTATEMENT}
    procedure ComposeCapabilityStatementSoftware(xml : TXmlBuilder; name : string; value : TFhirCapabilityStatementSoftware);
    procedure ComposeCapabilityStatementSoftwareChildren(xml : TXmlBuilder; value : TFhirCapabilityStatementSoftware);
    procedure ComposeCapabilityStatementImplementation(xml : TXmlBuilder; name : string; value : TFhirCapabilityStatementImplementation);
    procedure ComposeCapabilityStatementImplementationChildren(xml : TXmlBuilder; value : TFhirCapabilityStatementImplementation);
    procedure ComposeCapabilityStatementRest(xml : TXmlBuilder; name : string; value : TFhirCapabilityStatementRest);
    procedure ComposeCapabilityStatementRestChildren(xml : TXmlBuilder; value : TFhirCapabilityStatementRest);
    procedure ComposeCapabilityStatementRestSecurity(xml : TXmlBuilder; name : string; value : TFhirCapabilityStatementRestSecurity);
    procedure ComposeCapabilityStatementRestSecurityChildren(xml : TXmlBuilder; value : TFhirCapabilityStatementRestSecurity);
    procedure ComposeCapabilityStatementRestResource(xml : TXmlBuilder; name : string; value : TFhirCapabilityStatementRestResource);
    procedure ComposeCapabilityStatementRestResourceChildren(xml : TXmlBuilder; value : TFhirCapabilityStatementRestResource);
    procedure ComposeCapabilityStatementRestResourceInteraction(xml : TXmlBuilder; name : string; value : TFhirCapabilityStatementRestResourceInteraction);
    procedure ComposeCapabilityStatementRestResourceInteractionChildren(xml : TXmlBuilder; value : TFhirCapabilityStatementRestResourceInteraction);
    procedure ComposeCapabilityStatementRestResourceSearchParam(xml : TXmlBuilder; name : string; value : TFhirCapabilityStatementRestResourceSearchParam);
    procedure ComposeCapabilityStatementRestResourceSearchParamChildren(xml : TXmlBuilder; value : TFhirCapabilityStatementRestResourceSearchParam);
    procedure ComposeCapabilityStatementRestResourceOperation(xml : TXmlBuilder; name : string; value : TFhirCapabilityStatementRestResourceOperation);
    procedure ComposeCapabilityStatementRestResourceOperationChildren(xml : TXmlBuilder; value : TFhirCapabilityStatementRestResourceOperation);
    procedure ComposeCapabilityStatementRestInteraction(xml : TXmlBuilder; name : string; value : TFhirCapabilityStatementRestInteraction);
    procedure ComposeCapabilityStatementRestInteractionChildren(xml : TXmlBuilder; value : TFhirCapabilityStatementRestInteraction);
    procedure ComposeCapabilityStatementMessaging(xml : TXmlBuilder; name : string; value : TFhirCapabilityStatementMessaging);
    procedure ComposeCapabilityStatementMessagingChildren(xml : TXmlBuilder; value : TFhirCapabilityStatementMessaging);
    procedure ComposeCapabilityStatementMessagingEndpoint(xml : TXmlBuilder; name : string; value : TFhirCapabilityStatementMessagingEndpoint);
    procedure ComposeCapabilityStatementMessagingEndpointChildren(xml : TXmlBuilder; value : TFhirCapabilityStatementMessagingEndpoint);
    procedure ComposeCapabilityStatementMessagingSupportedMessage(xml : TXmlBuilder; name : string; value : TFhirCapabilityStatementMessagingSupportedMessage);
    procedure ComposeCapabilityStatementMessagingSupportedMessageChildren(xml : TXmlBuilder; value : TFhirCapabilityStatementMessagingSupportedMessage);
    procedure ComposeCapabilityStatementDocument(xml : TXmlBuilder; name : string; value : TFhirCapabilityStatementDocument);
    procedure ComposeCapabilityStatementDocumentChildren(xml : TXmlBuilder; value : TFhirCapabilityStatementDocument);
    procedure ComposeCapabilityStatement(xml : TXmlBuilder; name : string; value : TFhirCapabilityStatement);
    procedure ComposeCapabilityStatementChildren(xml : TXmlBuilder; value : TFhirCapabilityStatement);
{$ENDIF FHIR_CAPABILITYSTATEMENT}
{$IFDEF FHIR_CAREPLAN}
    procedure ComposeCarePlanActivity(xml : TXmlBuilder; name : string; value : TFhirCarePlanActivity);
    procedure ComposeCarePlanActivityChildren(xml : TXmlBuilder; value : TFhirCarePlanActivity);
    procedure ComposeCarePlanActivityPlannedActivityDetail(xml : TXmlBuilder; name : string; value : TFhirCarePlanActivityPlannedActivityDetail);
    procedure ComposeCarePlanActivityPlannedActivityDetailChildren(xml : TXmlBuilder; value : TFhirCarePlanActivityPlannedActivityDetail);
    procedure ComposeCarePlan(xml : TXmlBuilder; name : string; value : TFhirCarePlan);
    procedure ComposeCarePlanChildren(xml : TXmlBuilder; value : TFhirCarePlan);
{$ENDIF FHIR_CAREPLAN}
{$IFDEF FHIR_CARETEAM}
    procedure ComposeCareTeamParticipant(xml : TXmlBuilder; name : string; value : TFhirCareTeamParticipant);
    procedure ComposeCareTeamParticipantChildren(xml : TXmlBuilder; value : TFhirCareTeamParticipant);
    procedure ComposeCareTeam(xml : TXmlBuilder; name : string; value : TFhirCareTeam);
    procedure ComposeCareTeamChildren(xml : TXmlBuilder; value : TFhirCareTeam);
{$ENDIF FHIR_CARETEAM}
{$IFDEF FHIR_CHARGEITEM}
    procedure ComposeChargeItemPerformer(xml : TXmlBuilder; name : string; value : TFhirChargeItemPerformer);
    procedure ComposeChargeItemPerformerChildren(xml : TXmlBuilder; value : TFhirChargeItemPerformer);
    procedure ComposeChargeItem(xml : TXmlBuilder; name : string; value : TFhirChargeItem);
    procedure ComposeChargeItemChildren(xml : TXmlBuilder; value : TFhirChargeItem);
{$ENDIF FHIR_CHARGEITEM}
{$IFDEF FHIR_CHARGEITEMDEFINITION}
    procedure ComposeChargeItemDefinitionApplicability(xml : TXmlBuilder; name : string; value : TFhirChargeItemDefinitionApplicability);
    procedure ComposeChargeItemDefinitionApplicabilityChildren(xml : TXmlBuilder; value : TFhirChargeItemDefinitionApplicability);
    procedure ComposeChargeItemDefinitionPropertyGroup(xml : TXmlBuilder; name : string; value : TFhirChargeItemDefinitionPropertyGroup);
    procedure ComposeChargeItemDefinitionPropertyGroupChildren(xml : TXmlBuilder; value : TFhirChargeItemDefinitionPropertyGroup);
    procedure ComposeChargeItemDefinition(xml : TXmlBuilder; name : string; value : TFhirChargeItemDefinition);
    procedure ComposeChargeItemDefinitionChildren(xml : TXmlBuilder; value : TFhirChargeItemDefinition);
{$ENDIF FHIR_CHARGEITEMDEFINITION}
{$IFDEF FHIR_CITATION}
    procedure ComposeCitationSummary(xml : TXmlBuilder; name : string; value : TFhirCitationSummary);
    procedure ComposeCitationSummaryChildren(xml : TXmlBuilder; value : TFhirCitationSummary);
    procedure ComposeCitationClassification(xml : TXmlBuilder; name : string; value : TFhirCitationClassification);
    procedure ComposeCitationClassificationChildren(xml : TXmlBuilder; value : TFhirCitationClassification);
    procedure ComposeCitationStatusDate(xml : TXmlBuilder; name : string; value : TFhirCitationStatusDate);
    procedure ComposeCitationStatusDateChildren(xml : TXmlBuilder; value : TFhirCitationStatusDate);
    procedure ComposeCitationCitedArtifact(xml : TXmlBuilder; name : string; value : TFhirCitationCitedArtifact);
    procedure ComposeCitationCitedArtifactChildren(xml : TXmlBuilder; value : TFhirCitationCitedArtifact);
    procedure ComposeCitationCitedArtifactVersion(xml : TXmlBuilder; name : string; value : TFhirCitationCitedArtifactVersion);
    procedure ComposeCitationCitedArtifactVersionChildren(xml : TXmlBuilder; value : TFhirCitationCitedArtifactVersion);
    procedure ComposeCitationCitedArtifactStatusDate(xml : TXmlBuilder; name : string; value : TFhirCitationCitedArtifactStatusDate);
    procedure ComposeCitationCitedArtifactStatusDateChildren(xml : TXmlBuilder; value : TFhirCitationCitedArtifactStatusDate);
    procedure ComposeCitationCitedArtifactTitle(xml : TXmlBuilder; name : string; value : TFhirCitationCitedArtifactTitle);
    procedure ComposeCitationCitedArtifactTitleChildren(xml : TXmlBuilder; value : TFhirCitationCitedArtifactTitle);
    procedure ComposeCitationCitedArtifactAbstract(xml : TXmlBuilder; name : string; value : TFhirCitationCitedArtifactAbstract);
    procedure ComposeCitationCitedArtifactAbstractChildren(xml : TXmlBuilder; value : TFhirCitationCitedArtifactAbstract);
    procedure ComposeCitationCitedArtifactPart(xml : TXmlBuilder; name : string; value : TFhirCitationCitedArtifactPart);
    procedure ComposeCitationCitedArtifactPartChildren(xml : TXmlBuilder; value : TFhirCitationCitedArtifactPart);
    procedure ComposeCitationCitedArtifactRelatesTo(xml : TXmlBuilder; name : string; value : TFhirCitationCitedArtifactRelatesTo);
    procedure ComposeCitationCitedArtifactRelatesToChildren(xml : TXmlBuilder; value : TFhirCitationCitedArtifactRelatesTo);
    procedure ComposeCitationCitedArtifactPublicationForm(xml : TXmlBuilder; name : string; value : TFhirCitationCitedArtifactPublicationForm);
    procedure ComposeCitationCitedArtifactPublicationFormChildren(xml : TXmlBuilder; value : TFhirCitationCitedArtifactPublicationForm);
    procedure ComposeCitationCitedArtifactPublicationFormPublishedIn(xml : TXmlBuilder; name : string; value : TFhirCitationCitedArtifactPublicationFormPublishedIn);
    procedure ComposeCitationCitedArtifactPublicationFormPublishedInChildren(xml : TXmlBuilder; value : TFhirCitationCitedArtifactPublicationFormPublishedIn);
    procedure ComposeCitationCitedArtifactWebLocation(xml : TXmlBuilder; name : string; value : TFhirCitationCitedArtifactWebLocation);
    procedure ComposeCitationCitedArtifactWebLocationChildren(xml : TXmlBuilder; value : TFhirCitationCitedArtifactWebLocation);
    procedure ComposeCitationCitedArtifactClassification(xml : TXmlBuilder; name : string; value : TFhirCitationCitedArtifactClassification);
    procedure ComposeCitationCitedArtifactClassificationChildren(xml : TXmlBuilder; value : TFhirCitationCitedArtifactClassification);
    procedure ComposeCitationCitedArtifactContributorship(xml : TXmlBuilder; name : string; value : TFhirCitationCitedArtifactContributorship);
    procedure ComposeCitationCitedArtifactContributorshipChildren(xml : TXmlBuilder; value : TFhirCitationCitedArtifactContributorship);
    procedure ComposeCitationCitedArtifactContributorshipEntry(xml : TXmlBuilder; name : string; value : TFhirCitationCitedArtifactContributorshipEntry);
    procedure ComposeCitationCitedArtifactContributorshipEntryChildren(xml : TXmlBuilder; value : TFhirCitationCitedArtifactContributorshipEntry);
    procedure ComposeCitationCitedArtifactContributorshipEntryContributionInstance(xml : TXmlBuilder; name : string; value : TFhirCitationCitedArtifactContributorshipEntryContributionInstance);
    procedure ComposeCitationCitedArtifactContributorshipEntryContributionInstanceChildren(xml : TXmlBuilder; value : TFhirCitationCitedArtifactContributorshipEntryContributionInstance);
    procedure ComposeCitationCitedArtifactContributorshipSummary(xml : TXmlBuilder; name : string; value : TFhirCitationCitedArtifactContributorshipSummary);
    procedure ComposeCitationCitedArtifactContributorshipSummaryChildren(xml : TXmlBuilder; value : TFhirCitationCitedArtifactContributorshipSummary);
    procedure ComposeCitation(xml : TXmlBuilder; name : string; value : TFhirCitation);
    procedure ComposeCitationChildren(xml : TXmlBuilder; value : TFhirCitation);
{$ENDIF FHIR_CITATION}
{$IFDEF FHIR_CLAIM}
    procedure ComposeClaimRelated(xml : TXmlBuilder; name : string; value : TFhirClaimRelated);
    procedure ComposeClaimRelatedChildren(xml : TXmlBuilder; value : TFhirClaimRelated);
    procedure ComposeClaimPayee(xml : TXmlBuilder; name : string; value : TFhirClaimPayee);
    procedure ComposeClaimPayeeChildren(xml : TXmlBuilder; value : TFhirClaimPayee);
    procedure ComposeClaimCareTeam(xml : TXmlBuilder; name : string; value : TFhirClaimCareTeam);
    procedure ComposeClaimCareTeamChildren(xml : TXmlBuilder; value : TFhirClaimCareTeam);
    procedure ComposeClaimSupportingInfo(xml : TXmlBuilder; name : string; value : TFhirClaimSupportingInfo);
    procedure ComposeClaimSupportingInfoChildren(xml : TXmlBuilder; value : TFhirClaimSupportingInfo);
    procedure ComposeClaimDiagnosis(xml : TXmlBuilder; name : string; value : TFhirClaimDiagnosis);
    procedure ComposeClaimDiagnosisChildren(xml : TXmlBuilder; value : TFhirClaimDiagnosis);
    procedure ComposeClaimProcedure(xml : TXmlBuilder; name : string; value : TFhirClaimProcedure);
    procedure ComposeClaimProcedureChildren(xml : TXmlBuilder; value : TFhirClaimProcedure);
    procedure ComposeClaimInsurance(xml : TXmlBuilder; name : string; value : TFhirClaimInsurance);
    procedure ComposeClaimInsuranceChildren(xml : TXmlBuilder; value : TFhirClaimInsurance);
    procedure ComposeClaimAccident(xml : TXmlBuilder; name : string; value : TFhirClaimAccident);
    procedure ComposeClaimAccidentChildren(xml : TXmlBuilder; value : TFhirClaimAccident);
    procedure ComposeClaimItem(xml : TXmlBuilder; name : string; value : TFhirClaimItem);
    procedure ComposeClaimItemChildren(xml : TXmlBuilder; value : TFhirClaimItem);
    procedure ComposeClaimItemBodySite(xml : TXmlBuilder; name : string; value : TFhirClaimItemBodySite);
    procedure ComposeClaimItemBodySiteChildren(xml : TXmlBuilder; value : TFhirClaimItemBodySite);
    procedure ComposeClaimItemDetail(xml : TXmlBuilder; name : string; value : TFhirClaimItemDetail);
    procedure ComposeClaimItemDetailChildren(xml : TXmlBuilder; value : TFhirClaimItemDetail);
    procedure ComposeClaimItemDetailSubDetail(xml : TXmlBuilder; name : string; value : TFhirClaimItemDetailSubDetail);
    procedure ComposeClaimItemDetailSubDetailChildren(xml : TXmlBuilder; value : TFhirClaimItemDetailSubDetail);
    procedure ComposeClaim(xml : TXmlBuilder; name : string; value : TFhirClaim);
    procedure ComposeClaimChildren(xml : TXmlBuilder; value : TFhirClaim);
{$ENDIF FHIR_CLAIM}
{$IFDEF FHIR_CLAIMRESPONSE}
    procedure ComposeClaimResponseItem(xml : TXmlBuilder; name : string; value : TFhirClaimResponseItem);
    procedure ComposeClaimResponseItemChildren(xml : TXmlBuilder; value : TFhirClaimResponseItem);
    procedure ComposeClaimResponseItemAdjudication(xml : TXmlBuilder; name : string; value : TFhirClaimResponseItemAdjudication);
    procedure ComposeClaimResponseItemAdjudicationChildren(xml : TXmlBuilder; value : TFhirClaimResponseItemAdjudication);
    procedure ComposeClaimResponseItemDetail(xml : TXmlBuilder; name : string; value : TFhirClaimResponseItemDetail);
    procedure ComposeClaimResponseItemDetailChildren(xml : TXmlBuilder; value : TFhirClaimResponseItemDetail);
    procedure ComposeClaimResponseItemDetailSubDetail(xml : TXmlBuilder; name : string; value : TFhirClaimResponseItemDetailSubDetail);
    procedure ComposeClaimResponseItemDetailSubDetailChildren(xml : TXmlBuilder; value : TFhirClaimResponseItemDetailSubDetail);
    procedure ComposeClaimResponseAddItem(xml : TXmlBuilder; name : string; value : TFhirClaimResponseAddItem);
    procedure ComposeClaimResponseAddItemChildren(xml : TXmlBuilder; value : TFhirClaimResponseAddItem);
    procedure ComposeClaimResponseAddItemBodySite(xml : TXmlBuilder; name : string; value : TFhirClaimResponseAddItemBodySite);
    procedure ComposeClaimResponseAddItemBodySiteChildren(xml : TXmlBuilder; value : TFhirClaimResponseAddItemBodySite);
    procedure ComposeClaimResponseAddItemDetail(xml : TXmlBuilder; name : string; value : TFhirClaimResponseAddItemDetail);
    procedure ComposeClaimResponseAddItemDetailChildren(xml : TXmlBuilder; value : TFhirClaimResponseAddItemDetail);
    procedure ComposeClaimResponseAddItemDetailSubDetail(xml : TXmlBuilder; name : string; value : TFhirClaimResponseAddItemDetailSubDetail);
    procedure ComposeClaimResponseAddItemDetailSubDetailChildren(xml : TXmlBuilder; value : TFhirClaimResponseAddItemDetailSubDetail);
    procedure ComposeClaimResponseTotal(xml : TXmlBuilder; name : string; value : TFhirClaimResponseTotal);
    procedure ComposeClaimResponseTotalChildren(xml : TXmlBuilder; value : TFhirClaimResponseTotal);
    procedure ComposeClaimResponsePayment(xml : TXmlBuilder; name : string; value : TFhirClaimResponsePayment);
    procedure ComposeClaimResponsePaymentChildren(xml : TXmlBuilder; value : TFhirClaimResponsePayment);
    procedure ComposeClaimResponseProcessNote(xml : TXmlBuilder; name : string; value : TFhirClaimResponseProcessNote);
    procedure ComposeClaimResponseProcessNoteChildren(xml : TXmlBuilder; value : TFhirClaimResponseProcessNote);
    procedure ComposeClaimResponseInsurance(xml : TXmlBuilder; name : string; value : TFhirClaimResponseInsurance);
    procedure ComposeClaimResponseInsuranceChildren(xml : TXmlBuilder; value : TFhirClaimResponseInsurance);
    procedure ComposeClaimResponseError(xml : TXmlBuilder; name : string; value : TFhirClaimResponseError);
    procedure ComposeClaimResponseErrorChildren(xml : TXmlBuilder; value : TFhirClaimResponseError);
    procedure ComposeClaimResponse(xml : TXmlBuilder; name : string; value : TFhirClaimResponse);
    procedure ComposeClaimResponseChildren(xml : TXmlBuilder; value : TFhirClaimResponse);
{$ENDIF FHIR_CLAIMRESPONSE}
{$IFDEF FHIR_CLINICALIMPRESSION}
    procedure ComposeClinicalImpressionFinding(xml : TXmlBuilder; name : string; value : TFhirClinicalImpressionFinding);
    procedure ComposeClinicalImpressionFindingChildren(xml : TXmlBuilder; value : TFhirClinicalImpressionFinding);
    procedure ComposeClinicalImpression(xml : TXmlBuilder; name : string; value : TFhirClinicalImpression);
    procedure ComposeClinicalImpressionChildren(xml : TXmlBuilder; value : TFhirClinicalImpression);
{$ENDIF FHIR_CLINICALIMPRESSION}
{$IFDEF FHIR_CLINICALUSEDEFINITION}
    procedure ComposeClinicalUseDefinitionContraindication(xml : TXmlBuilder; name : string; value : TFhirClinicalUseDefinitionContraindication);
    procedure ComposeClinicalUseDefinitionContraindicationChildren(xml : TXmlBuilder; value : TFhirClinicalUseDefinitionContraindication);
    procedure ComposeClinicalUseDefinitionContraindicationOtherTherapy(xml : TXmlBuilder; name : string; value : TFhirClinicalUseDefinitionContraindicationOtherTherapy);
    procedure ComposeClinicalUseDefinitionContraindicationOtherTherapyChildren(xml : TXmlBuilder; value : TFhirClinicalUseDefinitionContraindicationOtherTherapy);
    procedure ComposeClinicalUseDefinitionIndication(xml : TXmlBuilder; name : string; value : TFhirClinicalUseDefinitionIndication);
    procedure ComposeClinicalUseDefinitionIndicationChildren(xml : TXmlBuilder; value : TFhirClinicalUseDefinitionIndication);
    procedure ComposeClinicalUseDefinitionInteraction(xml : TXmlBuilder; name : string; value : TFhirClinicalUseDefinitionInteraction);
    procedure ComposeClinicalUseDefinitionInteractionChildren(xml : TXmlBuilder; value : TFhirClinicalUseDefinitionInteraction);
    procedure ComposeClinicalUseDefinitionInteractionInteractant(xml : TXmlBuilder; name : string; value : TFhirClinicalUseDefinitionInteractionInteractant);
    procedure ComposeClinicalUseDefinitionInteractionInteractantChildren(xml : TXmlBuilder; value : TFhirClinicalUseDefinitionInteractionInteractant);
    procedure ComposeClinicalUseDefinitionUndesirableEffect(xml : TXmlBuilder; name : string; value : TFhirClinicalUseDefinitionUndesirableEffect);
    procedure ComposeClinicalUseDefinitionUndesirableEffectChildren(xml : TXmlBuilder; value : TFhirClinicalUseDefinitionUndesirableEffect);
    procedure ComposeClinicalUseDefinitionWarning(xml : TXmlBuilder; name : string; value : TFhirClinicalUseDefinitionWarning);
    procedure ComposeClinicalUseDefinitionWarningChildren(xml : TXmlBuilder; value : TFhirClinicalUseDefinitionWarning);
    procedure ComposeClinicalUseDefinition(xml : TXmlBuilder; name : string; value : TFhirClinicalUseDefinition);
    procedure ComposeClinicalUseDefinitionChildren(xml : TXmlBuilder; value : TFhirClinicalUseDefinition);
{$ENDIF FHIR_CLINICALUSEDEFINITION}
{$IFDEF FHIR_CODESYSTEM}
    procedure ComposeCodeSystemFilter(xml : TXmlBuilder; name : string; value : TFhirCodeSystemFilter);
    procedure ComposeCodeSystemFilterChildren(xml : TXmlBuilder; value : TFhirCodeSystemFilter);
    procedure ComposeCodeSystemProperty(xml : TXmlBuilder; name : string; value : TFhirCodeSystemProperty);
    procedure ComposeCodeSystemPropertyChildren(xml : TXmlBuilder; value : TFhirCodeSystemProperty);
    procedure ComposeCodeSystemConcept(xml : TXmlBuilder; name : string; value : TFhirCodeSystemConcept);
    procedure ComposeCodeSystemConceptChildren(xml : TXmlBuilder; value : TFhirCodeSystemConcept);
    procedure ComposeCodeSystemConceptDesignation(xml : TXmlBuilder; name : string; value : TFhirCodeSystemConceptDesignation);
    procedure ComposeCodeSystemConceptDesignationChildren(xml : TXmlBuilder; value : TFhirCodeSystemConceptDesignation);
    procedure ComposeCodeSystemConceptProperty(xml : TXmlBuilder; name : string; value : TFhirCodeSystemConceptProperty);
    procedure ComposeCodeSystemConceptPropertyChildren(xml : TXmlBuilder; value : TFhirCodeSystemConceptProperty);
    procedure ComposeCodeSystem(xml : TXmlBuilder; name : string; value : TFhirCodeSystem);
    procedure ComposeCodeSystemChildren(xml : TXmlBuilder; value : TFhirCodeSystem);
{$ENDIF FHIR_CODESYSTEM}
{$IFDEF FHIR_COMMUNICATION}
    procedure ComposeCommunicationPayload(xml : TXmlBuilder; name : string; value : TFhirCommunicationPayload);
    procedure ComposeCommunicationPayloadChildren(xml : TXmlBuilder; value : TFhirCommunicationPayload);
    procedure ComposeCommunication(xml : TXmlBuilder; name : string; value : TFhirCommunication);
    procedure ComposeCommunicationChildren(xml : TXmlBuilder; value : TFhirCommunication);
{$ENDIF FHIR_COMMUNICATION}
{$IFDEF FHIR_COMMUNICATIONREQUEST}
    procedure ComposeCommunicationRequestPayload(xml : TXmlBuilder; name : string; value : TFhirCommunicationRequestPayload);
    procedure ComposeCommunicationRequestPayloadChildren(xml : TXmlBuilder; value : TFhirCommunicationRequestPayload);
    procedure ComposeCommunicationRequest(xml : TXmlBuilder; name : string; value : TFhirCommunicationRequest);
    procedure ComposeCommunicationRequestChildren(xml : TXmlBuilder; value : TFhirCommunicationRequest);
{$ENDIF FHIR_COMMUNICATIONREQUEST}
{$IFDEF FHIR_COMPARTMENTDEFINITION}
    procedure ComposeCompartmentDefinitionResource(xml : TXmlBuilder; name : string; value : TFhirCompartmentDefinitionResource);
    procedure ComposeCompartmentDefinitionResourceChildren(xml : TXmlBuilder; value : TFhirCompartmentDefinitionResource);
    procedure ComposeCompartmentDefinition(xml : TXmlBuilder; name : string; value : TFhirCompartmentDefinition);
    procedure ComposeCompartmentDefinitionChildren(xml : TXmlBuilder; value : TFhirCompartmentDefinition);
{$ENDIF FHIR_COMPARTMENTDEFINITION}
{$IFDEF FHIR_COMPOSITION}
    procedure ComposeCompositionAttester(xml : TXmlBuilder; name : string; value : TFhirCompositionAttester);
    procedure ComposeCompositionAttesterChildren(xml : TXmlBuilder; value : TFhirCompositionAttester);
    procedure ComposeCompositionEvent(xml : TXmlBuilder; name : string; value : TFhirCompositionEvent);
    procedure ComposeCompositionEventChildren(xml : TXmlBuilder; value : TFhirCompositionEvent);
    procedure ComposeCompositionSection(xml : TXmlBuilder; name : string; value : TFhirCompositionSection);
    procedure ComposeCompositionSectionChildren(xml : TXmlBuilder; value : TFhirCompositionSection);
    procedure ComposeComposition(xml : TXmlBuilder; name : string; value : TFhirComposition);
    procedure ComposeCompositionChildren(xml : TXmlBuilder; value : TFhirComposition);
{$ENDIF FHIR_COMPOSITION}
{$IFDEF FHIR_CONCEPTMAP}
    procedure ComposeConceptMapGroup(xml : TXmlBuilder; name : string; value : TFhirConceptMapGroup);
    procedure ComposeConceptMapGroupChildren(xml : TXmlBuilder; value : TFhirConceptMapGroup);
    procedure ComposeConceptMapGroupElement(xml : TXmlBuilder; name : string; value : TFhirConceptMapGroupElement);
    procedure ComposeConceptMapGroupElementChildren(xml : TXmlBuilder; value : TFhirConceptMapGroupElement);
    procedure ComposeConceptMapGroupElementTarget(xml : TXmlBuilder; name : string; value : TFhirConceptMapGroupElementTarget);
    procedure ComposeConceptMapGroupElementTargetChildren(xml : TXmlBuilder; value : TFhirConceptMapGroupElementTarget);
    procedure ComposeConceptMapGroupElementTargetDependsOn(xml : TXmlBuilder; name : string; value : TFhirConceptMapGroupElementTargetDependsOn);
    procedure ComposeConceptMapGroupElementTargetDependsOnChildren(xml : TXmlBuilder; value : TFhirConceptMapGroupElementTargetDependsOn);
    procedure ComposeConceptMapGroupUnmapped(xml : TXmlBuilder; name : string; value : TFhirConceptMapGroupUnmapped);
    procedure ComposeConceptMapGroupUnmappedChildren(xml : TXmlBuilder; value : TFhirConceptMapGroupUnmapped);
    procedure ComposeConceptMap(xml : TXmlBuilder; name : string; value : TFhirConceptMap);
    procedure ComposeConceptMapChildren(xml : TXmlBuilder; value : TFhirConceptMap);
{$ENDIF FHIR_CONCEPTMAP}
{$IFDEF FHIR_CONDITION}
    procedure ComposeConditionParticipant(xml : TXmlBuilder; name : string; value : TFhirConditionParticipant);
    procedure ComposeConditionParticipantChildren(xml : TXmlBuilder; value : TFhirConditionParticipant);
    procedure ComposeConditionStage(xml : TXmlBuilder; name : string; value : TFhirConditionStage);
    procedure ComposeConditionStageChildren(xml : TXmlBuilder; value : TFhirConditionStage);
    procedure ComposeCondition(xml : TXmlBuilder; name : string; value : TFhirCondition);
    procedure ComposeConditionChildren(xml : TXmlBuilder; value : TFhirCondition);
{$ENDIF FHIR_CONDITION}
{$IFDEF FHIR_CONDITIONDEFINITION}
    procedure ComposeConditionDefinitionObservation(xml : TXmlBuilder; name : string; value : TFhirConditionDefinitionObservation);
    procedure ComposeConditionDefinitionObservationChildren(xml : TXmlBuilder; value : TFhirConditionDefinitionObservation);
    procedure ComposeConditionDefinitionMedication(xml : TXmlBuilder; name : string; value : TFhirConditionDefinitionMedication);
    procedure ComposeConditionDefinitionMedicationChildren(xml : TXmlBuilder; value : TFhirConditionDefinitionMedication);
    procedure ComposeConditionDefinitionPrecondition(xml : TXmlBuilder; name : string; value : TFhirConditionDefinitionPrecondition);
    procedure ComposeConditionDefinitionPreconditionChildren(xml : TXmlBuilder; value : TFhirConditionDefinitionPrecondition);
    procedure ComposeConditionDefinitionQuestionnaire(xml : TXmlBuilder; name : string; value : TFhirConditionDefinitionQuestionnaire);
    procedure ComposeConditionDefinitionQuestionnaireChildren(xml : TXmlBuilder; value : TFhirConditionDefinitionQuestionnaire);
    procedure ComposeConditionDefinitionPlan(xml : TXmlBuilder; name : string; value : TFhirConditionDefinitionPlan);
    procedure ComposeConditionDefinitionPlanChildren(xml : TXmlBuilder; value : TFhirConditionDefinitionPlan);
    procedure ComposeConditionDefinition(xml : TXmlBuilder; name : string; value : TFhirConditionDefinition);
    procedure ComposeConditionDefinitionChildren(xml : TXmlBuilder; value : TFhirConditionDefinition);
{$ENDIF FHIR_CONDITIONDEFINITION}
{$IFDEF FHIR_CONSENT}
    procedure ComposeConsentPolicyBasis(xml : TXmlBuilder; name : string; value : TFhirConsentPolicyBasis);
    procedure ComposeConsentPolicyBasisChildren(xml : TXmlBuilder; value : TFhirConsentPolicyBasis);
    procedure ComposeConsentVerification(xml : TXmlBuilder; name : string; value : TFhirConsentVerification);
    procedure ComposeConsentVerificationChildren(xml : TXmlBuilder; value : TFhirConsentVerification);
    procedure ComposeConsentProvision(xml : TXmlBuilder; name : string; value : TFhirConsentProvision);
    procedure ComposeConsentProvisionChildren(xml : TXmlBuilder; value : TFhirConsentProvision);
    procedure ComposeConsentProvisionActor(xml : TXmlBuilder; name : string; value : TFhirConsentProvisionActor);
    procedure ComposeConsentProvisionActorChildren(xml : TXmlBuilder; value : TFhirConsentProvisionActor);
    procedure ComposeConsentProvisionData(xml : TXmlBuilder; name : string; value : TFhirConsentProvisionData);
    procedure ComposeConsentProvisionDataChildren(xml : TXmlBuilder; value : TFhirConsentProvisionData);
    procedure ComposeConsent(xml : TXmlBuilder; name : string; value : TFhirConsent);
    procedure ComposeConsentChildren(xml : TXmlBuilder; value : TFhirConsent);
{$ENDIF FHIR_CONSENT}
{$IFDEF FHIR_CONTRACT}
    procedure ComposeContractContentDefinition(xml : TXmlBuilder; name : string; value : TFhirContractContentDefinition);
    procedure ComposeContractContentDefinitionChildren(xml : TXmlBuilder; value : TFhirContractContentDefinition);
    procedure ComposeContractTerm(xml : TXmlBuilder; name : string; value : TFhirContractTerm);
    procedure ComposeContractTermChildren(xml : TXmlBuilder; value : TFhirContractTerm);
    procedure ComposeContractTermSecurityLabel(xml : TXmlBuilder; name : string; value : TFhirContractTermSecurityLabel);
    procedure ComposeContractTermSecurityLabelChildren(xml : TXmlBuilder; value : TFhirContractTermSecurityLabel);
    procedure ComposeContractTermOffer(xml : TXmlBuilder; name : string; value : TFhirContractTermOffer);
    procedure ComposeContractTermOfferChildren(xml : TXmlBuilder; value : TFhirContractTermOffer);
    procedure ComposeContractTermOfferParty(xml : TXmlBuilder; name : string; value : TFhirContractTermOfferParty);
    procedure ComposeContractTermOfferPartyChildren(xml : TXmlBuilder; value : TFhirContractTermOfferParty);
    procedure ComposeContractTermOfferAnswer(xml : TXmlBuilder; name : string; value : TFhirContractTermOfferAnswer);
    procedure ComposeContractTermOfferAnswerChildren(xml : TXmlBuilder; value : TFhirContractTermOfferAnswer);
    procedure ComposeContractTermAsset(xml : TXmlBuilder; name : string; value : TFhirContractTermAsset);
    procedure ComposeContractTermAssetChildren(xml : TXmlBuilder; value : TFhirContractTermAsset);
    procedure ComposeContractTermAssetContext(xml : TXmlBuilder; name : string; value : TFhirContractTermAssetContext);
    procedure ComposeContractTermAssetContextChildren(xml : TXmlBuilder; value : TFhirContractTermAssetContext);
    procedure ComposeContractTermAssetValuedItem(xml : TXmlBuilder; name : string; value : TFhirContractTermAssetValuedItem);
    procedure ComposeContractTermAssetValuedItemChildren(xml : TXmlBuilder; value : TFhirContractTermAssetValuedItem);
    procedure ComposeContractTermAction(xml : TXmlBuilder; name : string; value : TFhirContractTermAction);
    procedure ComposeContractTermActionChildren(xml : TXmlBuilder; value : TFhirContractTermAction);
    procedure ComposeContractTermActionSubject(xml : TXmlBuilder; name : string; value : TFhirContractTermActionSubject);
    procedure ComposeContractTermActionSubjectChildren(xml : TXmlBuilder; value : TFhirContractTermActionSubject);
    procedure ComposeContractSigner(xml : TXmlBuilder; name : string; value : TFhirContractSigner);
    procedure ComposeContractSignerChildren(xml : TXmlBuilder; value : TFhirContractSigner);
    procedure ComposeContractFriendly(xml : TXmlBuilder; name : string; value : TFhirContractFriendly);
    procedure ComposeContractFriendlyChildren(xml : TXmlBuilder; value : TFhirContractFriendly);
    procedure ComposeContractLegal(xml : TXmlBuilder; name : string; value : TFhirContractLegal);
    procedure ComposeContractLegalChildren(xml : TXmlBuilder; value : TFhirContractLegal);
    procedure ComposeContractRule(xml : TXmlBuilder; name : string; value : TFhirContractRule);
    procedure ComposeContractRuleChildren(xml : TXmlBuilder; value : TFhirContractRule);
    procedure ComposeContract(xml : TXmlBuilder; name : string; value : TFhirContract);
    procedure ComposeContractChildren(xml : TXmlBuilder; value : TFhirContract);
{$ENDIF FHIR_CONTRACT}
{$IFDEF FHIR_COVERAGE}
    procedure ComposeCoveragePaymentBy(xml : TXmlBuilder; name : string; value : TFhirCoveragePaymentBy);
    procedure ComposeCoveragePaymentByChildren(xml : TXmlBuilder; value : TFhirCoveragePaymentBy);
    procedure ComposeCoverageClass(xml : TXmlBuilder; name : string; value : TFhirCoverageClass);
    procedure ComposeCoverageClassChildren(xml : TXmlBuilder; value : TFhirCoverageClass);
    procedure ComposeCoverageCostToBeneficiary(xml : TXmlBuilder; name : string; value : TFhirCoverageCostToBeneficiary);
    procedure ComposeCoverageCostToBeneficiaryChildren(xml : TXmlBuilder; value : TFhirCoverageCostToBeneficiary);
    procedure ComposeCoverageCostToBeneficiaryException(xml : TXmlBuilder; name : string; value : TFhirCoverageCostToBeneficiaryException);
    procedure ComposeCoverageCostToBeneficiaryExceptionChildren(xml : TXmlBuilder; value : TFhirCoverageCostToBeneficiaryException);
    procedure ComposeCoverage(xml : TXmlBuilder; name : string; value : TFhirCoverage);
    procedure ComposeCoverageChildren(xml : TXmlBuilder; value : TFhirCoverage);
{$ENDIF FHIR_COVERAGE}
{$IFDEF FHIR_COVERAGEELIGIBILITYREQUEST}
    procedure ComposeCoverageEligibilityRequestSupportingInfo(xml : TXmlBuilder; name : string; value : TFhirCoverageEligibilityRequestSupportingInfo);
    procedure ComposeCoverageEligibilityRequestSupportingInfoChildren(xml : TXmlBuilder; value : TFhirCoverageEligibilityRequestSupportingInfo);
    procedure ComposeCoverageEligibilityRequestInsurance(xml : TXmlBuilder; name : string; value : TFhirCoverageEligibilityRequestInsurance);
    procedure ComposeCoverageEligibilityRequestInsuranceChildren(xml : TXmlBuilder; value : TFhirCoverageEligibilityRequestInsurance);
    procedure ComposeCoverageEligibilityRequestItem(xml : TXmlBuilder; name : string; value : TFhirCoverageEligibilityRequestItem);
    procedure ComposeCoverageEligibilityRequestItemChildren(xml : TXmlBuilder; value : TFhirCoverageEligibilityRequestItem);
    procedure ComposeCoverageEligibilityRequestItemDiagnosis(xml : TXmlBuilder; name : string; value : TFhirCoverageEligibilityRequestItemDiagnosis);
    procedure ComposeCoverageEligibilityRequestItemDiagnosisChildren(xml : TXmlBuilder; value : TFhirCoverageEligibilityRequestItemDiagnosis);
    procedure ComposeCoverageEligibilityRequest(xml : TXmlBuilder; name : string; value : TFhirCoverageEligibilityRequest);
    procedure ComposeCoverageEligibilityRequestChildren(xml : TXmlBuilder; value : TFhirCoverageEligibilityRequest);
{$ENDIF FHIR_COVERAGEELIGIBILITYREQUEST}
{$IFDEF FHIR_COVERAGEELIGIBILITYRESPONSE}
    procedure ComposeCoverageEligibilityResponseInsurance(xml : TXmlBuilder; name : string; value : TFhirCoverageEligibilityResponseInsurance);
    procedure ComposeCoverageEligibilityResponseInsuranceChildren(xml : TXmlBuilder; value : TFhirCoverageEligibilityResponseInsurance);
    procedure ComposeCoverageEligibilityResponseInsuranceItem(xml : TXmlBuilder; name : string; value : TFhirCoverageEligibilityResponseInsuranceItem);
    procedure ComposeCoverageEligibilityResponseInsuranceItemChildren(xml : TXmlBuilder; value : TFhirCoverageEligibilityResponseInsuranceItem);
    procedure ComposeCoverageEligibilityResponseInsuranceItemBenefit(xml : TXmlBuilder; name : string; value : TFhirCoverageEligibilityResponseInsuranceItemBenefit);
    procedure ComposeCoverageEligibilityResponseInsuranceItemBenefitChildren(xml : TXmlBuilder; value : TFhirCoverageEligibilityResponseInsuranceItemBenefit);
    procedure ComposeCoverageEligibilityResponseError(xml : TXmlBuilder; name : string; value : TFhirCoverageEligibilityResponseError);
    procedure ComposeCoverageEligibilityResponseErrorChildren(xml : TXmlBuilder; value : TFhirCoverageEligibilityResponseError);
    procedure ComposeCoverageEligibilityResponse(xml : TXmlBuilder; name : string; value : TFhirCoverageEligibilityResponse);
    procedure ComposeCoverageEligibilityResponseChildren(xml : TXmlBuilder; value : TFhirCoverageEligibilityResponse);
{$ENDIF FHIR_COVERAGEELIGIBILITYRESPONSE}
{$IFDEF FHIR_DETECTEDISSUE}
    procedure ComposeDetectedIssueEvidence(xml : TXmlBuilder; name : string; value : TFhirDetectedIssueEvidence);
    procedure ComposeDetectedIssueEvidenceChildren(xml : TXmlBuilder; value : TFhirDetectedIssueEvidence);
    procedure ComposeDetectedIssueMitigation(xml : TXmlBuilder; name : string; value : TFhirDetectedIssueMitigation);
    procedure ComposeDetectedIssueMitigationChildren(xml : TXmlBuilder; value : TFhirDetectedIssueMitigation);
    procedure ComposeDetectedIssue(xml : TXmlBuilder; name : string; value : TFhirDetectedIssue);
    procedure ComposeDetectedIssueChildren(xml : TXmlBuilder; value : TFhirDetectedIssue);
{$ENDIF FHIR_DETECTEDISSUE}
{$IFDEF FHIR_DEVICE}
    procedure ComposeDeviceUdiCarrier(xml : TXmlBuilder; name : string; value : TFhirDeviceUdiCarrier);
    procedure ComposeDeviceUdiCarrierChildren(xml : TXmlBuilder; value : TFhirDeviceUdiCarrier);
    procedure ComposeDeviceDeviceName(xml : TXmlBuilder; name : string; value : TFhirDeviceDeviceName);
    procedure ComposeDeviceDeviceNameChildren(xml : TXmlBuilder; value : TFhirDeviceDeviceName);
    procedure ComposeDeviceVersion(xml : TXmlBuilder; name : string; value : TFhirDeviceVersion);
    procedure ComposeDeviceVersionChildren(xml : TXmlBuilder; value : TFhirDeviceVersion);
    procedure ComposeDeviceSpecialization(xml : TXmlBuilder; name : string; value : TFhirDeviceSpecialization);
    procedure ComposeDeviceSpecializationChildren(xml : TXmlBuilder; value : TFhirDeviceSpecialization);
    procedure ComposeDeviceProperty(xml : TXmlBuilder; name : string; value : TFhirDeviceProperty);
    procedure ComposeDevicePropertyChildren(xml : TXmlBuilder; value : TFhirDeviceProperty);
    procedure ComposeDeviceOperation(xml : TXmlBuilder; name : string; value : TFhirDeviceOperation);
    procedure ComposeDeviceOperationChildren(xml : TXmlBuilder; value : TFhirDeviceOperation);
    procedure ComposeDeviceAssociation(xml : TXmlBuilder; name : string; value : TFhirDeviceAssociation);
    procedure ComposeDeviceAssociationChildren(xml : TXmlBuilder; value : TFhirDeviceAssociation);
    procedure ComposeDevice(xml : TXmlBuilder; name : string; value : TFhirDevice);
    procedure ComposeDeviceChildren(xml : TXmlBuilder; value : TFhirDevice);
{$ENDIF FHIR_DEVICE}
{$IFDEF FHIR_DEVICEDEFINITION}
    procedure ComposeDeviceDefinitionUdiDeviceIdentifier(xml : TXmlBuilder; name : string; value : TFhirDeviceDefinitionUdiDeviceIdentifier);
    procedure ComposeDeviceDefinitionUdiDeviceIdentifierChildren(xml : TXmlBuilder; value : TFhirDeviceDefinitionUdiDeviceIdentifier);
    procedure ComposeDeviceDefinitionUdiDeviceIdentifierMarketDistribution(xml : TXmlBuilder; name : string; value : TFhirDeviceDefinitionUdiDeviceIdentifierMarketDistribution);
    procedure ComposeDeviceDefinitionUdiDeviceIdentifierMarketDistributionChildren(xml : TXmlBuilder; value : TFhirDeviceDefinitionUdiDeviceIdentifierMarketDistribution);
    procedure ComposeDeviceDefinitionRegulatoryIdentifier(xml : TXmlBuilder; name : string; value : TFhirDeviceDefinitionRegulatoryIdentifier);
    procedure ComposeDeviceDefinitionRegulatoryIdentifierChildren(xml : TXmlBuilder; value : TFhirDeviceDefinitionRegulatoryIdentifier);
    procedure ComposeDeviceDefinitionDeviceName(xml : TXmlBuilder; name : string; value : TFhirDeviceDefinitionDeviceName);
    procedure ComposeDeviceDefinitionDeviceNameChildren(xml : TXmlBuilder; value : TFhirDeviceDefinitionDeviceName);
    procedure ComposeDeviceDefinitionClassification(xml : TXmlBuilder; name : string; value : TFhirDeviceDefinitionClassification);
    procedure ComposeDeviceDefinitionClassificationChildren(xml : TXmlBuilder; value : TFhirDeviceDefinitionClassification);
    procedure ComposeDeviceDefinitionHasPart(xml : TXmlBuilder; name : string; value : TFhirDeviceDefinitionHasPart);
    procedure ComposeDeviceDefinitionHasPartChildren(xml : TXmlBuilder; value : TFhirDeviceDefinitionHasPart);
    procedure ComposeDeviceDefinitionPackaging(xml : TXmlBuilder; name : string; value : TFhirDeviceDefinitionPackaging);
    procedure ComposeDeviceDefinitionPackagingChildren(xml : TXmlBuilder; value : TFhirDeviceDefinitionPackaging);
    procedure ComposeDeviceDefinitionPackagingDistributor(xml : TXmlBuilder; name : string; value : TFhirDeviceDefinitionPackagingDistributor);
    procedure ComposeDeviceDefinitionPackagingDistributorChildren(xml : TXmlBuilder; value : TFhirDeviceDefinitionPackagingDistributor);
    procedure ComposeDeviceDefinitionVersion(xml : TXmlBuilder; name : string; value : TFhirDeviceDefinitionVersion);
    procedure ComposeDeviceDefinitionVersionChildren(xml : TXmlBuilder; value : TFhirDeviceDefinitionVersion);
    procedure ComposeDeviceDefinitionProperty(xml : TXmlBuilder; name : string; value : TFhirDeviceDefinitionProperty);
    procedure ComposeDeviceDefinitionPropertyChildren(xml : TXmlBuilder; value : TFhirDeviceDefinitionProperty);
    procedure ComposeDeviceDefinitionLink(xml : TXmlBuilder; name : string; value : TFhirDeviceDefinitionLink);
    procedure ComposeDeviceDefinitionLinkChildren(xml : TXmlBuilder; value : TFhirDeviceDefinitionLink);
    procedure ComposeDeviceDefinitionMaterial(xml : TXmlBuilder; name : string; value : TFhirDeviceDefinitionMaterial);
    procedure ComposeDeviceDefinitionMaterialChildren(xml : TXmlBuilder; value : TFhirDeviceDefinitionMaterial);
    procedure ComposeDeviceDefinitionGuideline(xml : TXmlBuilder; name : string; value : TFhirDeviceDefinitionGuideline);
    procedure ComposeDeviceDefinitionGuidelineChildren(xml : TXmlBuilder; value : TFhirDeviceDefinitionGuideline);
    procedure ComposeDeviceDefinitionCorrectiveAction(xml : TXmlBuilder; name : string; value : TFhirDeviceDefinitionCorrectiveAction);
    procedure ComposeDeviceDefinitionCorrectiveActionChildren(xml : TXmlBuilder; value : TFhirDeviceDefinitionCorrectiveAction);
    procedure ComposeDeviceDefinitionChargeItem(xml : TXmlBuilder; name : string; value : TFhirDeviceDefinitionChargeItem);
    procedure ComposeDeviceDefinitionChargeItemChildren(xml : TXmlBuilder; value : TFhirDeviceDefinitionChargeItem);
    procedure ComposeDeviceDefinition(xml : TXmlBuilder; name : string; value : TFhirDeviceDefinition);
    procedure ComposeDeviceDefinitionChildren(xml : TXmlBuilder; value : TFhirDeviceDefinition);
{$ENDIF FHIR_DEVICEDEFINITION}
{$IFDEF FHIR_DEVICEDISPENSE}
    procedure ComposeDeviceDispensePerformer(xml : TXmlBuilder; name : string; value : TFhirDeviceDispensePerformer);
    procedure ComposeDeviceDispensePerformerChildren(xml : TXmlBuilder; value : TFhirDeviceDispensePerformer);
    procedure ComposeDeviceDispense(xml : TXmlBuilder; name : string; value : TFhirDeviceDispense);
    procedure ComposeDeviceDispenseChildren(xml : TXmlBuilder; value : TFhirDeviceDispense);
{$ENDIF FHIR_DEVICEDISPENSE}
{$IFDEF FHIR_DEVICEMETRIC}
    procedure ComposeDeviceMetricCalibration(xml : TXmlBuilder; name : string; value : TFhirDeviceMetricCalibration);
    procedure ComposeDeviceMetricCalibrationChildren(xml : TXmlBuilder; value : TFhirDeviceMetricCalibration);
    procedure ComposeDeviceMetric(xml : TXmlBuilder; name : string; value : TFhirDeviceMetric);
    procedure ComposeDeviceMetricChildren(xml : TXmlBuilder; value : TFhirDeviceMetric);
{$ENDIF FHIR_DEVICEMETRIC}
{$IFDEF FHIR_DEVICEREQUEST}
    procedure ComposeDeviceRequestParameter(xml : TXmlBuilder; name : string; value : TFhirDeviceRequestParameter);
    procedure ComposeDeviceRequestParameterChildren(xml : TXmlBuilder; value : TFhirDeviceRequestParameter);
    procedure ComposeDeviceRequest(xml : TXmlBuilder; name : string; value : TFhirDeviceRequest);
    procedure ComposeDeviceRequestChildren(xml : TXmlBuilder; value : TFhirDeviceRequest);
{$ENDIF FHIR_DEVICEREQUEST}
{$IFDEF FHIR_DEVICEUSAGE}
    procedure ComposeDeviceUsageAdherence(xml : TXmlBuilder; name : string; value : TFhirDeviceUsageAdherence);
    procedure ComposeDeviceUsageAdherenceChildren(xml : TXmlBuilder; value : TFhirDeviceUsageAdherence);
    procedure ComposeDeviceUsage(xml : TXmlBuilder; name : string; value : TFhirDeviceUsage);
    procedure ComposeDeviceUsageChildren(xml : TXmlBuilder; value : TFhirDeviceUsage);
{$ENDIF FHIR_DEVICEUSAGE}
{$IFDEF FHIR_DIAGNOSTICREPORT}
    procedure ComposeDiagnosticReportSupportingInfo(xml : TXmlBuilder; name : string; value : TFhirDiagnosticReportSupportingInfo);
    procedure ComposeDiagnosticReportSupportingInfoChildren(xml : TXmlBuilder; value : TFhirDiagnosticReportSupportingInfo);
    procedure ComposeDiagnosticReportMedia(xml : TXmlBuilder; name : string; value : TFhirDiagnosticReportMedia);
    procedure ComposeDiagnosticReportMediaChildren(xml : TXmlBuilder; value : TFhirDiagnosticReportMedia);
    procedure ComposeDiagnosticReport(xml : TXmlBuilder; name : string; value : TFhirDiagnosticReport);
    procedure ComposeDiagnosticReportChildren(xml : TXmlBuilder; value : TFhirDiagnosticReport);
{$ENDIF FHIR_DIAGNOSTICREPORT}
{$IFDEF FHIR_DOCUMENTMANIFEST}
    procedure ComposeDocumentManifestRelated(xml : TXmlBuilder; name : string; value : TFhirDocumentManifestRelated);
    procedure ComposeDocumentManifestRelatedChildren(xml : TXmlBuilder; value : TFhirDocumentManifestRelated);
    procedure ComposeDocumentManifest(xml : TXmlBuilder; name : string; value : TFhirDocumentManifest);
    procedure ComposeDocumentManifestChildren(xml : TXmlBuilder; value : TFhirDocumentManifest);
{$ENDIF FHIR_DOCUMENTMANIFEST}
{$IFDEF FHIR_DOCUMENTREFERENCE}
    procedure ComposeDocumentReferenceAttester(xml : TXmlBuilder; name : string; value : TFhirDocumentReferenceAttester);
    procedure ComposeDocumentReferenceAttesterChildren(xml : TXmlBuilder; value : TFhirDocumentReferenceAttester);
    procedure ComposeDocumentReferenceRelatesTo(xml : TXmlBuilder; name : string; value : TFhirDocumentReferenceRelatesTo);
    procedure ComposeDocumentReferenceRelatesToChildren(xml : TXmlBuilder; value : TFhirDocumentReferenceRelatesTo);
    procedure ComposeDocumentReferenceContent(xml : TXmlBuilder; name : string; value : TFhirDocumentReferenceContent);
    procedure ComposeDocumentReferenceContentChildren(xml : TXmlBuilder; value : TFhirDocumentReferenceContent);
    procedure ComposeDocumentReferenceContentProfile(xml : TXmlBuilder; name : string; value : TFhirDocumentReferenceContentProfile);
    procedure ComposeDocumentReferenceContentProfileChildren(xml : TXmlBuilder; value : TFhirDocumentReferenceContentProfile);
    procedure ComposeDocumentReference(xml : TXmlBuilder; name : string; value : TFhirDocumentReference);
    procedure ComposeDocumentReferenceChildren(xml : TXmlBuilder; value : TFhirDocumentReference);
{$ENDIF FHIR_DOCUMENTREFERENCE}
{$IFDEF FHIR_ENCOUNTER}
    procedure ComposeEncounterStatusHistory(xml : TXmlBuilder; name : string; value : TFhirEncounterStatusHistory);
    procedure ComposeEncounterStatusHistoryChildren(xml : TXmlBuilder; value : TFhirEncounterStatusHistory);
    procedure ComposeEncounterClassHistory(xml : TXmlBuilder; name : string; value : TFhirEncounterClassHistory);
    procedure ComposeEncounterClassHistoryChildren(xml : TXmlBuilder; value : TFhirEncounterClassHistory);
    procedure ComposeEncounterParticipant(xml : TXmlBuilder; name : string; value : TFhirEncounterParticipant);
    procedure ComposeEncounterParticipantChildren(xml : TXmlBuilder; value : TFhirEncounterParticipant);
    procedure ComposeEncounterDiagnosis(xml : TXmlBuilder; name : string; value : TFhirEncounterDiagnosis);
    procedure ComposeEncounterDiagnosisChildren(xml : TXmlBuilder; value : TFhirEncounterDiagnosis);
    procedure ComposeEncounterAdmission(xml : TXmlBuilder; name : string; value : TFhirEncounterAdmission);
    procedure ComposeEncounterAdmissionChildren(xml : TXmlBuilder; value : TFhirEncounterAdmission);
    procedure ComposeEncounterLocation(xml : TXmlBuilder; name : string; value : TFhirEncounterLocation);
    procedure ComposeEncounterLocationChildren(xml : TXmlBuilder; value : TFhirEncounterLocation);
    procedure ComposeEncounter(xml : TXmlBuilder; name : string; value : TFhirEncounter);
    procedure ComposeEncounterChildren(xml : TXmlBuilder; value : TFhirEncounter);
{$ENDIF FHIR_ENCOUNTER}
{$IFDEF FHIR_ENDPOINT}
    procedure ComposeEndpoint(xml : TXmlBuilder; name : string; value : TFhirEndpoint);
    procedure ComposeEndpointChildren(xml : TXmlBuilder; value : TFhirEndpoint);
{$ENDIF FHIR_ENDPOINT}
{$IFDEF FHIR_ENROLLMENTREQUEST}
    procedure ComposeEnrollmentRequest(xml : TXmlBuilder; name : string; value : TFhirEnrollmentRequest);
    procedure ComposeEnrollmentRequestChildren(xml : TXmlBuilder; value : TFhirEnrollmentRequest);
{$ENDIF FHIR_ENROLLMENTREQUEST}
{$IFDEF FHIR_ENROLLMENTRESPONSE}
    procedure ComposeEnrollmentResponse(xml : TXmlBuilder; name : string; value : TFhirEnrollmentResponse);
    procedure ComposeEnrollmentResponseChildren(xml : TXmlBuilder; value : TFhirEnrollmentResponse);
{$ENDIF FHIR_ENROLLMENTRESPONSE}
{$IFDEF FHIR_EPISODEOFCARE}
    procedure ComposeEpisodeOfCareStatusHistory(xml : TXmlBuilder; name : string; value : TFhirEpisodeOfCareStatusHistory);
    procedure ComposeEpisodeOfCareStatusHistoryChildren(xml : TXmlBuilder; value : TFhirEpisodeOfCareStatusHistory);
    procedure ComposeEpisodeOfCareDiagnosis(xml : TXmlBuilder; name : string; value : TFhirEpisodeOfCareDiagnosis);
    procedure ComposeEpisodeOfCareDiagnosisChildren(xml : TXmlBuilder; value : TFhirEpisodeOfCareDiagnosis);
    procedure ComposeEpisodeOfCare(xml : TXmlBuilder; name : string; value : TFhirEpisodeOfCare);
    procedure ComposeEpisodeOfCareChildren(xml : TXmlBuilder; value : TFhirEpisodeOfCare);
{$ENDIF FHIR_EPISODEOFCARE}
{$IFDEF FHIR_EVENTDEFINITION}
    procedure ComposeEventDefinition(xml : TXmlBuilder; name : string; value : TFhirEventDefinition);
    procedure ComposeEventDefinitionChildren(xml : TXmlBuilder; value : TFhirEventDefinition);
{$ENDIF FHIR_EVENTDEFINITION}
{$IFDEF FHIR_EVIDENCE}
    procedure ComposeEvidenceVariableDefinition(xml : TXmlBuilder; name : string; value : TFhirEvidenceVariableDefinition);
    procedure ComposeEvidenceVariableDefinitionChildren(xml : TXmlBuilder; value : TFhirEvidenceVariableDefinition);
    procedure ComposeEvidenceStatistic(xml : TXmlBuilder; name : string; value : TFhirEvidenceStatistic);
    procedure ComposeEvidenceStatisticChildren(xml : TXmlBuilder; value : TFhirEvidenceStatistic);
    procedure ComposeEvidenceStatisticSampleSize(xml : TXmlBuilder; name : string; value : TFhirEvidenceStatisticSampleSize);
    procedure ComposeEvidenceStatisticSampleSizeChildren(xml : TXmlBuilder; value : TFhirEvidenceStatisticSampleSize);
    procedure ComposeEvidenceStatisticAttributeEstimate(xml : TXmlBuilder; name : string; value : TFhirEvidenceStatisticAttributeEstimate);
    procedure ComposeEvidenceStatisticAttributeEstimateChildren(xml : TXmlBuilder; value : TFhirEvidenceStatisticAttributeEstimate);
    procedure ComposeEvidenceStatisticModelCharacteristic(xml : TXmlBuilder; name : string; value : TFhirEvidenceStatisticModelCharacteristic);
    procedure ComposeEvidenceStatisticModelCharacteristicChildren(xml : TXmlBuilder; value : TFhirEvidenceStatisticModelCharacteristic);
    procedure ComposeEvidenceStatisticModelCharacteristicVariable(xml : TXmlBuilder; name : string; value : TFhirEvidenceStatisticModelCharacteristicVariable);
    procedure ComposeEvidenceStatisticModelCharacteristicVariableChildren(xml : TXmlBuilder; value : TFhirEvidenceStatisticModelCharacteristicVariable);
    procedure ComposeEvidenceCertainty(xml : TXmlBuilder; name : string; value : TFhirEvidenceCertainty);
    procedure ComposeEvidenceCertaintyChildren(xml : TXmlBuilder; value : TFhirEvidenceCertainty);
    procedure ComposeEvidence(xml : TXmlBuilder; name : string; value : TFhirEvidence);
    procedure ComposeEvidenceChildren(xml : TXmlBuilder; value : TFhirEvidence);
{$ENDIF FHIR_EVIDENCE}
{$IFDEF FHIR_EVIDENCEREPORT}
    procedure ComposeEvidenceReportSubject(xml : TXmlBuilder; name : string; value : TFhirEvidenceReportSubject);
    procedure ComposeEvidenceReportSubjectChildren(xml : TXmlBuilder; value : TFhirEvidenceReportSubject);
    procedure ComposeEvidenceReportSubjectCharacteristic(xml : TXmlBuilder; name : string; value : TFhirEvidenceReportSubjectCharacteristic);
    procedure ComposeEvidenceReportSubjectCharacteristicChildren(xml : TXmlBuilder; value : TFhirEvidenceReportSubjectCharacteristic);
    procedure ComposeEvidenceReportRelatesTo(xml : TXmlBuilder; name : string; value : TFhirEvidenceReportRelatesTo);
    procedure ComposeEvidenceReportRelatesToChildren(xml : TXmlBuilder; value : TFhirEvidenceReportRelatesTo);
    procedure ComposeEvidenceReportRelatesToTarget(xml : TXmlBuilder; name : string; value : TFhirEvidenceReportRelatesToTarget);
    procedure ComposeEvidenceReportRelatesToTargetChildren(xml : TXmlBuilder; value : TFhirEvidenceReportRelatesToTarget);
    procedure ComposeEvidenceReportSection(xml : TXmlBuilder; name : string; value : TFhirEvidenceReportSection);
    procedure ComposeEvidenceReportSectionChildren(xml : TXmlBuilder; value : TFhirEvidenceReportSection);
    procedure ComposeEvidenceReport(xml : TXmlBuilder; name : string; value : TFhirEvidenceReport);
    procedure ComposeEvidenceReportChildren(xml : TXmlBuilder; value : TFhirEvidenceReport);
{$ENDIF FHIR_EVIDENCEREPORT}
{$IFDEF FHIR_EVIDENCEVARIABLE}
    procedure ComposeEvidenceVariableCharacteristic(xml : TXmlBuilder; name : string; value : TFhirEvidenceVariableCharacteristic);
    procedure ComposeEvidenceVariableCharacteristicChildren(xml : TXmlBuilder; value : TFhirEvidenceVariableCharacteristic);
    procedure ComposeEvidenceVariableCharacteristicDefinitionByTypeAndValue(xml : TXmlBuilder; name : string; value : TFhirEvidenceVariableCharacteristicDefinitionByTypeAndValue);
    procedure ComposeEvidenceVariableCharacteristicDefinitionByTypeAndValueChildren(xml : TXmlBuilder; value : TFhirEvidenceVariableCharacteristicDefinitionByTypeAndValue);
    procedure ComposeEvidenceVariableCharacteristicDefinitionByCombination(xml : TXmlBuilder; name : string; value : TFhirEvidenceVariableCharacteristicDefinitionByCombination);
    procedure ComposeEvidenceVariableCharacteristicDefinitionByCombinationChildren(xml : TXmlBuilder; value : TFhirEvidenceVariableCharacteristicDefinitionByCombination);
    procedure ComposeEvidenceVariableCharacteristicTimeFromEvent(xml : TXmlBuilder; name : string; value : TFhirEvidenceVariableCharacteristicTimeFromEvent);
    procedure ComposeEvidenceVariableCharacteristicTimeFromEventChildren(xml : TXmlBuilder; value : TFhirEvidenceVariableCharacteristicTimeFromEvent);
    procedure ComposeEvidenceVariableCategory(xml : TXmlBuilder; name : string; value : TFhirEvidenceVariableCategory);
    procedure ComposeEvidenceVariableCategoryChildren(xml : TXmlBuilder; value : TFhirEvidenceVariableCategory);
    procedure ComposeEvidenceVariable(xml : TXmlBuilder; name : string; value : TFhirEvidenceVariable);
    procedure ComposeEvidenceVariableChildren(xml : TXmlBuilder; value : TFhirEvidenceVariable);
{$ENDIF FHIR_EVIDENCEVARIABLE}
{$IFDEF FHIR_EXAMPLESCENARIO}
    procedure ComposeExampleScenarioActor(xml : TXmlBuilder; name : string; value : TFhirExampleScenarioActor);
    procedure ComposeExampleScenarioActorChildren(xml : TXmlBuilder; value : TFhirExampleScenarioActor);
    procedure ComposeExampleScenarioInstance(xml : TXmlBuilder; name : string; value : TFhirExampleScenarioInstance);
    procedure ComposeExampleScenarioInstanceChildren(xml : TXmlBuilder; value : TFhirExampleScenarioInstance);
    procedure ComposeExampleScenarioInstanceVersion(xml : TXmlBuilder; name : string; value : TFhirExampleScenarioInstanceVersion);
    procedure ComposeExampleScenarioInstanceVersionChildren(xml : TXmlBuilder; value : TFhirExampleScenarioInstanceVersion);
    procedure ComposeExampleScenarioInstanceContainedInstance(xml : TXmlBuilder; name : string; value : TFhirExampleScenarioInstanceContainedInstance);
    procedure ComposeExampleScenarioInstanceContainedInstanceChildren(xml : TXmlBuilder; value : TFhirExampleScenarioInstanceContainedInstance);
    procedure ComposeExampleScenarioProcess(xml : TXmlBuilder; name : string; value : TFhirExampleScenarioProcess);
    procedure ComposeExampleScenarioProcessChildren(xml : TXmlBuilder; value : TFhirExampleScenarioProcess);
    procedure ComposeExampleScenarioProcessStep(xml : TXmlBuilder; name : string; value : TFhirExampleScenarioProcessStep);
    procedure ComposeExampleScenarioProcessStepChildren(xml : TXmlBuilder; value : TFhirExampleScenarioProcessStep);
    procedure ComposeExampleScenarioProcessStepOperation(xml : TXmlBuilder; name : string; value : TFhirExampleScenarioProcessStepOperation);
    procedure ComposeExampleScenarioProcessStepOperationChildren(xml : TXmlBuilder; value : TFhirExampleScenarioProcessStepOperation);
    procedure ComposeExampleScenarioProcessStepAlternative(xml : TXmlBuilder; name : string; value : TFhirExampleScenarioProcessStepAlternative);
    procedure ComposeExampleScenarioProcessStepAlternativeChildren(xml : TXmlBuilder; value : TFhirExampleScenarioProcessStepAlternative);
    procedure ComposeExampleScenario(xml : TXmlBuilder; name : string; value : TFhirExampleScenario);
    procedure ComposeExampleScenarioChildren(xml : TXmlBuilder; value : TFhirExampleScenario);
{$ENDIF FHIR_EXAMPLESCENARIO}
{$IFDEF FHIR_EXPLANATIONOFBENEFIT}
    procedure ComposeExplanationOfBenefitRelated(xml : TXmlBuilder; name : string; value : TFhirExplanationOfBenefitRelated);
    procedure ComposeExplanationOfBenefitRelatedChildren(xml : TXmlBuilder; value : TFhirExplanationOfBenefitRelated);
    procedure ComposeExplanationOfBenefitPayee(xml : TXmlBuilder; name : string; value : TFhirExplanationOfBenefitPayee);
    procedure ComposeExplanationOfBenefitPayeeChildren(xml : TXmlBuilder; value : TFhirExplanationOfBenefitPayee);
    procedure ComposeExplanationOfBenefitCareTeam(xml : TXmlBuilder; name : string; value : TFhirExplanationOfBenefitCareTeam);
    procedure ComposeExplanationOfBenefitCareTeamChildren(xml : TXmlBuilder; value : TFhirExplanationOfBenefitCareTeam);
    procedure ComposeExplanationOfBenefitSupportingInfo(xml : TXmlBuilder; name : string; value : TFhirExplanationOfBenefitSupportingInfo);
    procedure ComposeExplanationOfBenefitSupportingInfoChildren(xml : TXmlBuilder; value : TFhirExplanationOfBenefitSupportingInfo);
    procedure ComposeExplanationOfBenefitDiagnosis(xml : TXmlBuilder; name : string; value : TFhirExplanationOfBenefitDiagnosis);
    procedure ComposeExplanationOfBenefitDiagnosisChildren(xml : TXmlBuilder; value : TFhirExplanationOfBenefitDiagnosis);
    procedure ComposeExplanationOfBenefitProcedure(xml : TXmlBuilder; name : string; value : TFhirExplanationOfBenefitProcedure);
    procedure ComposeExplanationOfBenefitProcedureChildren(xml : TXmlBuilder; value : TFhirExplanationOfBenefitProcedure);
    procedure ComposeExplanationOfBenefitInsurance(xml : TXmlBuilder; name : string; value : TFhirExplanationOfBenefitInsurance);
    procedure ComposeExplanationOfBenefitInsuranceChildren(xml : TXmlBuilder; value : TFhirExplanationOfBenefitInsurance);
    procedure ComposeExplanationOfBenefitAccident(xml : TXmlBuilder; name : string; value : TFhirExplanationOfBenefitAccident);
    procedure ComposeExplanationOfBenefitAccidentChildren(xml : TXmlBuilder; value : TFhirExplanationOfBenefitAccident);
    procedure ComposeExplanationOfBenefitItem(xml : TXmlBuilder; name : string; value : TFhirExplanationOfBenefitItem);
    procedure ComposeExplanationOfBenefitItemChildren(xml : TXmlBuilder; value : TFhirExplanationOfBenefitItem);
    procedure ComposeExplanationOfBenefitItemBodySite(xml : TXmlBuilder; name : string; value : TFhirExplanationOfBenefitItemBodySite);
    procedure ComposeExplanationOfBenefitItemBodySiteChildren(xml : TXmlBuilder; value : TFhirExplanationOfBenefitItemBodySite);
    procedure ComposeExplanationOfBenefitItemAdjudication(xml : TXmlBuilder; name : string; value : TFhirExplanationOfBenefitItemAdjudication);
    procedure ComposeExplanationOfBenefitItemAdjudicationChildren(xml : TXmlBuilder; value : TFhirExplanationOfBenefitItemAdjudication);
    procedure ComposeExplanationOfBenefitItemDetail(xml : TXmlBuilder; name : string; value : TFhirExplanationOfBenefitItemDetail);
    procedure ComposeExplanationOfBenefitItemDetailChildren(xml : TXmlBuilder; value : TFhirExplanationOfBenefitItemDetail);
    procedure ComposeExplanationOfBenefitItemDetailSubDetail(xml : TXmlBuilder; name : string; value : TFhirExplanationOfBenefitItemDetailSubDetail);
    procedure ComposeExplanationOfBenefitItemDetailSubDetailChildren(xml : TXmlBuilder; value : TFhirExplanationOfBenefitItemDetailSubDetail);
    procedure ComposeExplanationOfBenefitAddItem(xml : TXmlBuilder; name : string; value : TFhirExplanationOfBenefitAddItem);
    procedure ComposeExplanationOfBenefitAddItemChildren(xml : TXmlBuilder; value : TFhirExplanationOfBenefitAddItem);
    procedure ComposeExplanationOfBenefitAddItemBodySite(xml : TXmlBuilder; name : string; value : TFhirExplanationOfBenefitAddItemBodySite);
    procedure ComposeExplanationOfBenefitAddItemBodySiteChildren(xml : TXmlBuilder; value : TFhirExplanationOfBenefitAddItemBodySite);
    procedure ComposeExplanationOfBenefitAddItemDetail(xml : TXmlBuilder; name : string; value : TFhirExplanationOfBenefitAddItemDetail);
    procedure ComposeExplanationOfBenefitAddItemDetailChildren(xml : TXmlBuilder; value : TFhirExplanationOfBenefitAddItemDetail);
    procedure ComposeExplanationOfBenefitAddItemDetailSubDetail(xml : TXmlBuilder; name : string; value : TFhirExplanationOfBenefitAddItemDetailSubDetail);
    procedure ComposeExplanationOfBenefitAddItemDetailSubDetailChildren(xml : TXmlBuilder; value : TFhirExplanationOfBenefitAddItemDetailSubDetail);
    procedure ComposeExplanationOfBenefitTotal(xml : TXmlBuilder; name : string; value : TFhirExplanationOfBenefitTotal);
    procedure ComposeExplanationOfBenefitTotalChildren(xml : TXmlBuilder; value : TFhirExplanationOfBenefitTotal);
    procedure ComposeExplanationOfBenefitPayment(xml : TXmlBuilder; name : string; value : TFhirExplanationOfBenefitPayment);
    procedure ComposeExplanationOfBenefitPaymentChildren(xml : TXmlBuilder; value : TFhirExplanationOfBenefitPayment);
    procedure ComposeExplanationOfBenefitProcessNote(xml : TXmlBuilder; name : string; value : TFhirExplanationOfBenefitProcessNote);
    procedure ComposeExplanationOfBenefitProcessNoteChildren(xml : TXmlBuilder; value : TFhirExplanationOfBenefitProcessNote);
    procedure ComposeExplanationOfBenefitBenefitBalance(xml : TXmlBuilder; name : string; value : TFhirExplanationOfBenefitBenefitBalance);
    procedure ComposeExplanationOfBenefitBenefitBalanceChildren(xml : TXmlBuilder; value : TFhirExplanationOfBenefitBenefitBalance);
    procedure ComposeExplanationOfBenefitBenefitBalanceFinancial(xml : TXmlBuilder; name : string; value : TFhirExplanationOfBenefitBenefitBalanceFinancial);
    procedure ComposeExplanationOfBenefitBenefitBalanceFinancialChildren(xml : TXmlBuilder; value : TFhirExplanationOfBenefitBenefitBalanceFinancial);
    procedure ComposeExplanationOfBenefit(xml : TXmlBuilder; name : string; value : TFhirExplanationOfBenefit);
    procedure ComposeExplanationOfBenefitChildren(xml : TXmlBuilder; value : TFhirExplanationOfBenefit);
{$ENDIF FHIR_EXPLANATIONOFBENEFIT}
{$IFDEF FHIR_FAMILYMEMBERHISTORY}
    procedure ComposeFamilyMemberHistoryCondition(xml : TXmlBuilder; name : string; value : TFhirFamilyMemberHistoryCondition);
    procedure ComposeFamilyMemberHistoryConditionChildren(xml : TXmlBuilder; value : TFhirFamilyMemberHistoryCondition);
    procedure ComposeFamilyMemberHistoryProcedure(xml : TXmlBuilder; name : string; value : TFhirFamilyMemberHistoryProcedure);
    procedure ComposeFamilyMemberHistoryProcedureChildren(xml : TXmlBuilder; value : TFhirFamilyMemberHistoryProcedure);
    procedure ComposeFamilyMemberHistory(xml : TXmlBuilder; name : string; value : TFhirFamilyMemberHistory);
    procedure ComposeFamilyMemberHistoryChildren(xml : TXmlBuilder; value : TFhirFamilyMemberHistory);
{$ENDIF FHIR_FAMILYMEMBERHISTORY}
{$IFDEF FHIR_FLAG}
    procedure ComposeFlag(xml : TXmlBuilder; name : string; value : TFhirFlag);
    procedure ComposeFlagChildren(xml : TXmlBuilder; value : TFhirFlag);
{$ENDIF FHIR_FLAG}
{$IFDEF FHIR_FORMULARYITEM}
    procedure ComposeFormularyItem(xml : TXmlBuilder; name : string; value : TFhirFormularyItem);
    procedure ComposeFormularyItemChildren(xml : TXmlBuilder; value : TFhirFormularyItem);
{$ENDIF FHIR_FORMULARYITEM}
{$IFDEF FHIR_GENOMICSTUDY}
    procedure ComposeGenomicStudyAnalysis(xml : TXmlBuilder; name : string; value : TFhirGenomicStudyAnalysis);
    procedure ComposeGenomicStudyAnalysisChildren(xml : TXmlBuilder; value : TFhirGenomicStudyAnalysis);
    procedure ComposeGenomicStudyAnalysisInput(xml : TXmlBuilder; name : string; value : TFhirGenomicStudyAnalysisInput);
    procedure ComposeGenomicStudyAnalysisInputChildren(xml : TXmlBuilder; value : TFhirGenomicStudyAnalysisInput);
    procedure ComposeGenomicStudyAnalysisOutput(xml : TXmlBuilder; name : string; value : TFhirGenomicStudyAnalysisOutput);
    procedure ComposeGenomicStudyAnalysisOutputChildren(xml : TXmlBuilder; value : TFhirGenomicStudyAnalysisOutput);
    procedure ComposeGenomicStudyAnalysisPerformer(xml : TXmlBuilder; name : string; value : TFhirGenomicStudyAnalysisPerformer);
    procedure ComposeGenomicStudyAnalysisPerformerChildren(xml : TXmlBuilder; value : TFhirGenomicStudyAnalysisPerformer);
    procedure ComposeGenomicStudyAnalysisDevice(xml : TXmlBuilder; name : string; value : TFhirGenomicStudyAnalysisDevice);
    procedure ComposeGenomicStudyAnalysisDeviceChildren(xml : TXmlBuilder; value : TFhirGenomicStudyAnalysisDevice);
    procedure ComposeGenomicStudy(xml : TXmlBuilder; name : string; value : TFhirGenomicStudy);
    procedure ComposeGenomicStudyChildren(xml : TXmlBuilder; value : TFhirGenomicStudy);
{$ENDIF FHIR_GENOMICSTUDY}
{$IFDEF FHIR_GOAL}
    procedure ComposeGoalTarget(xml : TXmlBuilder; name : string; value : TFhirGoalTarget);
    procedure ComposeGoalTargetChildren(xml : TXmlBuilder; value : TFhirGoalTarget);
    procedure ComposeGoal(xml : TXmlBuilder; name : string; value : TFhirGoal);
    procedure ComposeGoalChildren(xml : TXmlBuilder; value : TFhirGoal);
{$ENDIF FHIR_GOAL}
{$IFDEF FHIR_GRAPHDEFINITION}
    procedure ComposeGraphDefinitionLink(xml : TXmlBuilder; name : string; value : TFhirGraphDefinitionLink);
    procedure ComposeGraphDefinitionLinkChildren(xml : TXmlBuilder; value : TFhirGraphDefinitionLink);
    procedure ComposeGraphDefinitionLinkTarget(xml : TXmlBuilder; name : string; value : TFhirGraphDefinitionLinkTarget);
    procedure ComposeGraphDefinitionLinkTargetChildren(xml : TXmlBuilder; value : TFhirGraphDefinitionLinkTarget);
    procedure ComposeGraphDefinitionLinkTargetCompartment(xml : TXmlBuilder; name : string; value : TFhirGraphDefinitionLinkTargetCompartment);
    procedure ComposeGraphDefinitionLinkTargetCompartmentChildren(xml : TXmlBuilder; value : TFhirGraphDefinitionLinkTargetCompartment);
    procedure ComposeGraphDefinition(xml : TXmlBuilder; name : string; value : TFhirGraphDefinition);
    procedure ComposeGraphDefinitionChildren(xml : TXmlBuilder; value : TFhirGraphDefinition);
{$ENDIF FHIR_GRAPHDEFINITION}
{$IFDEF FHIR_GROUP}
    procedure ComposeGroupCharacteristic(xml : TXmlBuilder; name : string; value : TFhirGroupCharacteristic);
    procedure ComposeGroupCharacteristicChildren(xml : TXmlBuilder; value : TFhirGroupCharacteristic);
    procedure ComposeGroupMember(xml : TXmlBuilder; name : string; value : TFhirGroupMember);
    procedure ComposeGroupMemberChildren(xml : TXmlBuilder; value : TFhirGroupMember);
    procedure ComposeGroup(xml : TXmlBuilder; name : string; value : TFhirGroup);
    procedure ComposeGroupChildren(xml : TXmlBuilder; value : TFhirGroup);
{$ENDIF FHIR_GROUP}
{$IFDEF FHIR_GUIDANCERESPONSE}
    procedure ComposeGuidanceResponse(xml : TXmlBuilder; name : string; value : TFhirGuidanceResponse);
    procedure ComposeGuidanceResponseChildren(xml : TXmlBuilder; value : TFhirGuidanceResponse);
{$ENDIF FHIR_GUIDANCERESPONSE}
{$IFDEF FHIR_HEALTHCARESERVICE}
    procedure ComposeHealthcareServiceEligibility(xml : TXmlBuilder; name : string; value : TFhirHealthcareServiceEligibility);
    procedure ComposeHealthcareServiceEligibilityChildren(xml : TXmlBuilder; value : TFhirHealthcareServiceEligibility);
    procedure ComposeHealthcareService(xml : TXmlBuilder; name : string; value : TFhirHealthcareService);
    procedure ComposeHealthcareServiceChildren(xml : TXmlBuilder; value : TFhirHealthcareService);
{$ENDIF FHIR_HEALTHCARESERVICE}
{$IFDEF FHIR_IMAGINGSELECTION}
    procedure ComposeImagingSelectionPerformer(xml : TXmlBuilder; name : string; value : TFhirImagingSelectionPerformer);
    procedure ComposeImagingSelectionPerformerChildren(xml : TXmlBuilder; value : TFhirImagingSelectionPerformer);
    procedure ComposeImagingSelectionInstance(xml : TXmlBuilder; name : string; value : TFhirImagingSelectionInstance);
    procedure ComposeImagingSelectionInstanceChildren(xml : TXmlBuilder; value : TFhirImagingSelectionInstance);
    procedure ComposeImagingSelectionInstanceImageRegion(xml : TXmlBuilder; name : string; value : TFhirImagingSelectionInstanceImageRegion);
    procedure ComposeImagingSelectionInstanceImageRegionChildren(xml : TXmlBuilder; value : TFhirImagingSelectionInstanceImageRegion);
    procedure ComposeImagingSelectionImageRegion(xml : TXmlBuilder; name : string; value : TFhirImagingSelectionImageRegion);
    procedure ComposeImagingSelectionImageRegionChildren(xml : TXmlBuilder; value : TFhirImagingSelectionImageRegion);
    procedure ComposeImagingSelection(xml : TXmlBuilder; name : string; value : TFhirImagingSelection);
    procedure ComposeImagingSelectionChildren(xml : TXmlBuilder; value : TFhirImagingSelection);
{$ENDIF FHIR_IMAGINGSELECTION}
{$IFDEF FHIR_IMAGINGSTUDY}
    procedure ComposeImagingStudySeries(xml : TXmlBuilder; name : string; value : TFhirImagingStudySeries);
    procedure ComposeImagingStudySeriesChildren(xml : TXmlBuilder; value : TFhirImagingStudySeries);
    procedure ComposeImagingStudySeriesPerformer(xml : TXmlBuilder; name : string; value : TFhirImagingStudySeriesPerformer);
    procedure ComposeImagingStudySeriesPerformerChildren(xml : TXmlBuilder; value : TFhirImagingStudySeriesPerformer);
    procedure ComposeImagingStudySeriesInstance(xml : TXmlBuilder; name : string; value : TFhirImagingStudySeriesInstance);
    procedure ComposeImagingStudySeriesInstanceChildren(xml : TXmlBuilder; value : TFhirImagingStudySeriesInstance);
    procedure ComposeImagingStudy(xml : TXmlBuilder; name : string; value : TFhirImagingStudy);
    procedure ComposeImagingStudyChildren(xml : TXmlBuilder; value : TFhirImagingStudy);
{$ENDIF FHIR_IMAGINGSTUDY}
{$IFDEF FHIR_IMMUNIZATION}
    procedure ComposeImmunizationPerformer(xml : TXmlBuilder; name : string; value : TFhirImmunizationPerformer);
    procedure ComposeImmunizationPerformerChildren(xml : TXmlBuilder; value : TFhirImmunizationPerformer);
    procedure ComposeImmunizationProgramEligibility(xml : TXmlBuilder; name : string; value : TFhirImmunizationProgramEligibility);
    procedure ComposeImmunizationProgramEligibilityChildren(xml : TXmlBuilder; value : TFhirImmunizationProgramEligibility);
    procedure ComposeImmunizationReaction(xml : TXmlBuilder; name : string; value : TFhirImmunizationReaction);
    procedure ComposeImmunizationReactionChildren(xml : TXmlBuilder; value : TFhirImmunizationReaction);
    procedure ComposeImmunizationProtocolApplied(xml : TXmlBuilder; name : string; value : TFhirImmunizationProtocolApplied);
    procedure ComposeImmunizationProtocolAppliedChildren(xml : TXmlBuilder; value : TFhirImmunizationProtocolApplied);
    procedure ComposeImmunization(xml : TXmlBuilder; name : string; value : TFhirImmunization);
    procedure ComposeImmunizationChildren(xml : TXmlBuilder; value : TFhirImmunization);
{$ENDIF FHIR_IMMUNIZATION}
{$IFDEF FHIR_IMMUNIZATIONEVALUATION}
    procedure ComposeImmunizationEvaluation(xml : TXmlBuilder; name : string; value : TFhirImmunizationEvaluation);
    procedure ComposeImmunizationEvaluationChildren(xml : TXmlBuilder; value : TFhirImmunizationEvaluation);
{$ENDIF FHIR_IMMUNIZATIONEVALUATION}
{$IFDEF FHIR_IMMUNIZATIONRECOMMENDATION}
    procedure ComposeImmunizationRecommendationRecommendation(xml : TXmlBuilder; name : string; value : TFhirImmunizationRecommendationRecommendation);
    procedure ComposeImmunizationRecommendationRecommendationChildren(xml : TXmlBuilder; value : TFhirImmunizationRecommendationRecommendation);
    procedure ComposeImmunizationRecommendationRecommendationDateCriterion(xml : TXmlBuilder; name : string; value : TFhirImmunizationRecommendationRecommendationDateCriterion);
    procedure ComposeImmunizationRecommendationRecommendationDateCriterionChildren(xml : TXmlBuilder; value : TFhirImmunizationRecommendationRecommendationDateCriterion);
    procedure ComposeImmunizationRecommendation(xml : TXmlBuilder; name : string; value : TFhirImmunizationRecommendation);
    procedure ComposeImmunizationRecommendationChildren(xml : TXmlBuilder; value : TFhirImmunizationRecommendation);
{$ENDIF FHIR_IMMUNIZATIONRECOMMENDATION}
{$IFDEF FHIR_IMPLEMENTATIONGUIDE}
    procedure ComposeImplementationGuideDependsOn(xml : TXmlBuilder; name : string; value : TFhirImplementationGuideDependsOn);
    procedure ComposeImplementationGuideDependsOnChildren(xml : TXmlBuilder; value : TFhirImplementationGuideDependsOn);
    procedure ComposeImplementationGuideGlobal(xml : TXmlBuilder; name : string; value : TFhirImplementationGuideGlobal);
    procedure ComposeImplementationGuideGlobalChildren(xml : TXmlBuilder; value : TFhirImplementationGuideGlobal);
    procedure ComposeImplementationGuideDefinition(xml : TXmlBuilder; name : string; value : TFhirImplementationGuideDefinition);
    procedure ComposeImplementationGuideDefinitionChildren(xml : TXmlBuilder; value : TFhirImplementationGuideDefinition);
    procedure ComposeImplementationGuideDefinitionGrouping(xml : TXmlBuilder; name : string; value : TFhirImplementationGuideDefinitionGrouping);
    procedure ComposeImplementationGuideDefinitionGroupingChildren(xml : TXmlBuilder; value : TFhirImplementationGuideDefinitionGrouping);
    procedure ComposeImplementationGuideDefinitionResource(xml : TXmlBuilder; name : string; value : TFhirImplementationGuideDefinitionResource);
    procedure ComposeImplementationGuideDefinitionResourceChildren(xml : TXmlBuilder; value : TFhirImplementationGuideDefinitionResource);
    procedure ComposeImplementationGuideDefinitionPage(xml : TXmlBuilder; name : string; value : TFhirImplementationGuideDefinitionPage);
    procedure ComposeImplementationGuideDefinitionPageChildren(xml : TXmlBuilder; value : TFhirImplementationGuideDefinitionPage);
    procedure ComposeImplementationGuideDefinitionParameter(xml : TXmlBuilder; name : string; value : TFhirImplementationGuideDefinitionParameter);
    procedure ComposeImplementationGuideDefinitionParameterChildren(xml : TXmlBuilder; value : TFhirImplementationGuideDefinitionParameter);
    procedure ComposeImplementationGuideDefinitionTemplate(xml : TXmlBuilder; name : string; value : TFhirImplementationGuideDefinitionTemplate);
    procedure ComposeImplementationGuideDefinitionTemplateChildren(xml : TXmlBuilder; value : TFhirImplementationGuideDefinitionTemplate);
    procedure ComposeImplementationGuideManifest(xml : TXmlBuilder; name : string; value : TFhirImplementationGuideManifest);
    procedure ComposeImplementationGuideManifestChildren(xml : TXmlBuilder; value : TFhirImplementationGuideManifest);
    procedure ComposeImplementationGuideManifestResource(xml : TXmlBuilder; name : string; value : TFhirImplementationGuideManifestResource);
    procedure ComposeImplementationGuideManifestResourceChildren(xml : TXmlBuilder; value : TFhirImplementationGuideManifestResource);
    procedure ComposeImplementationGuideManifestPage(xml : TXmlBuilder; name : string; value : TFhirImplementationGuideManifestPage);
    procedure ComposeImplementationGuideManifestPageChildren(xml : TXmlBuilder; value : TFhirImplementationGuideManifestPage);
    procedure ComposeImplementationGuide(xml : TXmlBuilder; name : string; value : TFhirImplementationGuide);
    procedure ComposeImplementationGuideChildren(xml : TXmlBuilder; value : TFhirImplementationGuide);
{$ENDIF FHIR_IMPLEMENTATIONGUIDE}
{$IFDEF FHIR_INGREDIENT}
    procedure ComposeIngredientManufacturer(xml : TXmlBuilder; name : string; value : TFhirIngredientManufacturer);
    procedure ComposeIngredientManufacturerChildren(xml : TXmlBuilder; value : TFhirIngredientManufacturer);
    procedure ComposeIngredientSubstance(xml : TXmlBuilder; name : string; value : TFhirIngredientSubstance);
    procedure ComposeIngredientSubstanceChildren(xml : TXmlBuilder; value : TFhirIngredientSubstance);
    procedure ComposeIngredientSubstanceStrength(xml : TXmlBuilder; name : string; value : TFhirIngredientSubstanceStrength);
    procedure ComposeIngredientSubstanceStrengthChildren(xml : TXmlBuilder; value : TFhirIngredientSubstanceStrength);
    procedure ComposeIngredientSubstanceStrengthReferenceStrength(xml : TXmlBuilder; name : string; value : TFhirIngredientSubstanceStrengthReferenceStrength);
    procedure ComposeIngredientSubstanceStrengthReferenceStrengthChildren(xml : TXmlBuilder; value : TFhirIngredientSubstanceStrengthReferenceStrength);
    procedure ComposeIngredient(xml : TXmlBuilder; name : string; value : TFhirIngredient);
    procedure ComposeIngredientChildren(xml : TXmlBuilder; value : TFhirIngredient);
{$ENDIF FHIR_INGREDIENT}
{$IFDEF FHIR_INSURANCEPLAN}
    procedure ComposeInsurancePlanCoverage(xml : TXmlBuilder; name : string; value : TFhirInsurancePlanCoverage);
    procedure ComposeInsurancePlanCoverageChildren(xml : TXmlBuilder; value : TFhirInsurancePlanCoverage);
    procedure ComposeInsurancePlanCoverageBenefit(xml : TXmlBuilder; name : string; value : TFhirInsurancePlanCoverageBenefit);
    procedure ComposeInsurancePlanCoverageBenefitChildren(xml : TXmlBuilder; value : TFhirInsurancePlanCoverageBenefit);
    procedure ComposeInsurancePlanCoverageBenefitLimit(xml : TXmlBuilder; name : string; value : TFhirInsurancePlanCoverageBenefitLimit);
    procedure ComposeInsurancePlanCoverageBenefitLimitChildren(xml : TXmlBuilder; value : TFhirInsurancePlanCoverageBenefitLimit);
    procedure ComposeInsurancePlanPlan(xml : TXmlBuilder; name : string; value : TFhirInsurancePlanPlan);
    procedure ComposeInsurancePlanPlanChildren(xml : TXmlBuilder; value : TFhirInsurancePlanPlan);
    procedure ComposeInsurancePlanPlanGeneralCost(xml : TXmlBuilder; name : string; value : TFhirInsurancePlanPlanGeneralCost);
    procedure ComposeInsurancePlanPlanGeneralCostChildren(xml : TXmlBuilder; value : TFhirInsurancePlanPlanGeneralCost);
    procedure ComposeInsurancePlanPlanSpecificCost(xml : TXmlBuilder; name : string; value : TFhirInsurancePlanPlanSpecificCost);
    procedure ComposeInsurancePlanPlanSpecificCostChildren(xml : TXmlBuilder; value : TFhirInsurancePlanPlanSpecificCost);
    procedure ComposeInsurancePlanPlanSpecificCostBenefit(xml : TXmlBuilder; name : string; value : TFhirInsurancePlanPlanSpecificCostBenefit);
    procedure ComposeInsurancePlanPlanSpecificCostBenefitChildren(xml : TXmlBuilder; value : TFhirInsurancePlanPlanSpecificCostBenefit);
    procedure ComposeInsurancePlanPlanSpecificCostBenefitCost(xml : TXmlBuilder; name : string; value : TFhirInsurancePlanPlanSpecificCostBenefitCost);
    procedure ComposeInsurancePlanPlanSpecificCostBenefitCostChildren(xml : TXmlBuilder; value : TFhirInsurancePlanPlanSpecificCostBenefitCost);
    procedure ComposeInsurancePlan(xml : TXmlBuilder; name : string; value : TFhirInsurancePlan);
    procedure ComposeInsurancePlanChildren(xml : TXmlBuilder; value : TFhirInsurancePlan);
{$ENDIF FHIR_INSURANCEPLAN}
{$IFDEF FHIR_INVENTORYREPORT}
    procedure ComposeInventoryReportInventoryListing(xml : TXmlBuilder; name : string; value : TFhirInventoryReportInventoryListing);
    procedure ComposeInventoryReportInventoryListingChildren(xml : TXmlBuilder; value : TFhirInventoryReportInventoryListing);
    procedure ComposeInventoryReportInventoryListingItems(xml : TXmlBuilder; name : string; value : TFhirInventoryReportInventoryListingItems);
    procedure ComposeInventoryReportInventoryListingItemsChildren(xml : TXmlBuilder; value : TFhirInventoryReportInventoryListingItems);
    procedure ComposeInventoryReport(xml : TXmlBuilder; name : string; value : TFhirInventoryReport);
    procedure ComposeInventoryReportChildren(xml : TXmlBuilder; value : TFhirInventoryReport);
{$ENDIF FHIR_INVENTORYREPORT}
{$IFDEF FHIR_INVOICE}
    procedure ComposeInvoiceParticipant(xml : TXmlBuilder; name : string; value : TFhirInvoiceParticipant);
    procedure ComposeInvoiceParticipantChildren(xml : TXmlBuilder; value : TFhirInvoiceParticipant);
    procedure ComposeInvoiceLineItem(xml : TXmlBuilder; name : string; value : TFhirInvoiceLineItem);
    procedure ComposeInvoiceLineItemChildren(xml : TXmlBuilder; value : TFhirInvoiceLineItem);
    procedure ComposeInvoice(xml : TXmlBuilder; name : string; value : TFhirInvoice);
    procedure ComposeInvoiceChildren(xml : TXmlBuilder; value : TFhirInvoice);
{$ENDIF FHIR_INVOICE}
{$IFDEF FHIR_LIBRARY}
    procedure ComposeLibrary(xml : TXmlBuilder; name : string; value : TFhirLibrary);
    procedure ComposeLibraryChildren(xml : TXmlBuilder; value : TFhirLibrary);
{$ENDIF FHIR_LIBRARY}
{$IFDEF FHIR_LINKAGE}
    procedure ComposeLinkageItem(xml : TXmlBuilder; name : string; value : TFhirLinkageItem);
    procedure ComposeLinkageItemChildren(xml : TXmlBuilder; value : TFhirLinkageItem);
    procedure ComposeLinkage(xml : TXmlBuilder; name : string; value : TFhirLinkage);
    procedure ComposeLinkageChildren(xml : TXmlBuilder; value : TFhirLinkage);
{$ENDIF FHIR_LINKAGE}
{$IFDEF FHIR_LIST}
    procedure ComposeListEntry(xml : TXmlBuilder; name : string; value : TFhirListEntry);
    procedure ComposeListEntryChildren(xml : TXmlBuilder; value : TFhirListEntry);
    procedure ComposeList(xml : TXmlBuilder; name : string; value : TFhirList);
    procedure ComposeListChildren(xml : TXmlBuilder; value : TFhirList);
{$ENDIF FHIR_LIST}
{$IFDEF FHIR_LOCATION}
    procedure ComposeLocationPosition(xml : TXmlBuilder; name : string; value : TFhirLocationPosition);
    procedure ComposeLocationPositionChildren(xml : TXmlBuilder; value : TFhirLocationPosition);
    procedure ComposeLocation(xml : TXmlBuilder; name : string; value : TFhirLocation);
    procedure ComposeLocationChildren(xml : TXmlBuilder; value : TFhirLocation);
{$ENDIF FHIR_LOCATION}
{$IFDEF FHIR_MANUFACTUREDITEMDEFINITION}
    procedure ComposeManufacturedItemDefinitionProperty(xml : TXmlBuilder; name : string; value : TFhirManufacturedItemDefinitionProperty);
    procedure ComposeManufacturedItemDefinitionPropertyChildren(xml : TXmlBuilder; value : TFhirManufacturedItemDefinitionProperty);
    procedure ComposeManufacturedItemDefinitionComponent(xml : TXmlBuilder; name : string; value : TFhirManufacturedItemDefinitionComponent);
    procedure ComposeManufacturedItemDefinitionComponentChildren(xml : TXmlBuilder; value : TFhirManufacturedItemDefinitionComponent);
    procedure ComposeManufacturedItemDefinitionComponentConstituent(xml : TXmlBuilder; name : string; value : TFhirManufacturedItemDefinitionComponentConstituent);
    procedure ComposeManufacturedItemDefinitionComponentConstituentChildren(xml : TXmlBuilder; value : TFhirManufacturedItemDefinitionComponentConstituent);
    procedure ComposeManufacturedItemDefinition(xml : TXmlBuilder; name : string; value : TFhirManufacturedItemDefinition);
    procedure ComposeManufacturedItemDefinitionChildren(xml : TXmlBuilder; value : TFhirManufacturedItemDefinition);
{$ENDIF FHIR_MANUFACTUREDITEMDEFINITION}
{$IFDEF FHIR_MEASURE}
    procedure ComposeMeasureTerm(xml : TXmlBuilder; name : string; value : TFhirMeasureTerm);
    procedure ComposeMeasureTermChildren(xml : TXmlBuilder; value : TFhirMeasureTerm);
    procedure ComposeMeasureGroup(xml : TXmlBuilder; name : string; value : TFhirMeasureGroup);
    procedure ComposeMeasureGroupChildren(xml : TXmlBuilder; value : TFhirMeasureGroup);
    procedure ComposeMeasureGroupPopulation(xml : TXmlBuilder; name : string; value : TFhirMeasureGroupPopulation);
    procedure ComposeMeasureGroupPopulationChildren(xml : TXmlBuilder; value : TFhirMeasureGroupPopulation);
    procedure ComposeMeasureGroupStratifier(xml : TXmlBuilder; name : string; value : TFhirMeasureGroupStratifier);
    procedure ComposeMeasureGroupStratifierChildren(xml : TXmlBuilder; value : TFhirMeasureGroupStratifier);
    procedure ComposeMeasureGroupStratifierComponent(xml : TXmlBuilder; name : string; value : TFhirMeasureGroupStratifierComponent);
    procedure ComposeMeasureGroupStratifierComponentChildren(xml : TXmlBuilder; value : TFhirMeasureGroupStratifierComponent);
    procedure ComposeMeasureSupplementalData(xml : TXmlBuilder; name : string; value : TFhirMeasureSupplementalData);
    procedure ComposeMeasureSupplementalDataChildren(xml : TXmlBuilder; value : TFhirMeasureSupplementalData);
    procedure ComposeMeasure(xml : TXmlBuilder; name : string; value : TFhirMeasure);
    procedure ComposeMeasureChildren(xml : TXmlBuilder; value : TFhirMeasure);
{$ENDIF FHIR_MEASURE}
{$IFDEF FHIR_MEASUREREPORT}
    procedure ComposeMeasureReportGroup(xml : TXmlBuilder; name : string; value : TFhirMeasureReportGroup);
    procedure ComposeMeasureReportGroupChildren(xml : TXmlBuilder; value : TFhirMeasureReportGroup);
    procedure ComposeMeasureReportGroupPopulation(xml : TXmlBuilder; name : string; value : TFhirMeasureReportGroupPopulation);
    procedure ComposeMeasureReportGroupPopulationChildren(xml : TXmlBuilder; value : TFhirMeasureReportGroupPopulation);
    procedure ComposeMeasureReportGroupStratifier(xml : TXmlBuilder; name : string; value : TFhirMeasureReportGroupStratifier);
    procedure ComposeMeasureReportGroupStratifierChildren(xml : TXmlBuilder; value : TFhirMeasureReportGroupStratifier);
    procedure ComposeMeasureReportGroupStratifierStratum(xml : TXmlBuilder; name : string; value : TFhirMeasureReportGroupStratifierStratum);
    procedure ComposeMeasureReportGroupStratifierStratumChildren(xml : TXmlBuilder; value : TFhirMeasureReportGroupStratifierStratum);
    procedure ComposeMeasureReportGroupStratifierStratumComponent(xml : TXmlBuilder; name : string; value : TFhirMeasureReportGroupStratifierStratumComponent);
    procedure ComposeMeasureReportGroupStratifierStratumComponentChildren(xml : TXmlBuilder; value : TFhirMeasureReportGroupStratifierStratumComponent);
    procedure ComposeMeasureReportGroupStratifierStratumPopulation(xml : TXmlBuilder; name : string; value : TFhirMeasureReportGroupStratifierStratumPopulation);
    procedure ComposeMeasureReportGroupStratifierStratumPopulationChildren(xml : TXmlBuilder; value : TFhirMeasureReportGroupStratifierStratumPopulation);
    procedure ComposeMeasureReport(xml : TXmlBuilder; name : string; value : TFhirMeasureReport);
    procedure ComposeMeasureReportChildren(xml : TXmlBuilder; value : TFhirMeasureReport);
{$ENDIF FHIR_MEASUREREPORT}
{$IFDEF FHIR_MEDICATION}
    procedure ComposeMedicationIngredient(xml : TXmlBuilder; name : string; value : TFhirMedicationIngredient);
    procedure ComposeMedicationIngredientChildren(xml : TXmlBuilder; value : TFhirMedicationIngredient);
    procedure ComposeMedicationBatch(xml : TXmlBuilder; name : string; value : TFhirMedicationBatch);
    procedure ComposeMedicationBatchChildren(xml : TXmlBuilder; value : TFhirMedicationBatch);
    procedure ComposeMedication(xml : TXmlBuilder; name : string; value : TFhirMedication);
    procedure ComposeMedicationChildren(xml : TXmlBuilder; value : TFhirMedication);
{$ENDIF FHIR_MEDICATION}
{$IFDEF FHIR_MEDICATIONADMINISTRATION}
    procedure ComposeMedicationAdministrationPerformer(xml : TXmlBuilder; name : string; value : TFhirMedicationAdministrationPerformer);
    procedure ComposeMedicationAdministrationPerformerChildren(xml : TXmlBuilder; value : TFhirMedicationAdministrationPerformer);
    procedure ComposeMedicationAdministrationDosage(xml : TXmlBuilder; name : string; value : TFhirMedicationAdministrationDosage);
    procedure ComposeMedicationAdministrationDosageChildren(xml : TXmlBuilder; value : TFhirMedicationAdministrationDosage);
    procedure ComposeMedicationAdministration(xml : TXmlBuilder; name : string; value : TFhirMedicationAdministration);
    procedure ComposeMedicationAdministrationChildren(xml : TXmlBuilder; value : TFhirMedicationAdministration);
{$ENDIF FHIR_MEDICATIONADMINISTRATION}
{$IFDEF FHIR_MEDICATIONDISPENSE}
    procedure ComposeMedicationDispensePerformer(xml : TXmlBuilder; name : string; value : TFhirMedicationDispensePerformer);
    procedure ComposeMedicationDispensePerformerChildren(xml : TXmlBuilder; value : TFhirMedicationDispensePerformer);
    procedure ComposeMedicationDispenseSubstitution(xml : TXmlBuilder; name : string; value : TFhirMedicationDispenseSubstitution);
    procedure ComposeMedicationDispenseSubstitutionChildren(xml : TXmlBuilder; value : TFhirMedicationDispenseSubstitution);
    procedure ComposeMedicationDispense(xml : TXmlBuilder; name : string; value : TFhirMedicationDispense);
    procedure ComposeMedicationDispenseChildren(xml : TXmlBuilder; value : TFhirMedicationDispense);
{$ENDIF FHIR_MEDICATIONDISPENSE}
{$IFDEF FHIR_MEDICATIONKNOWLEDGE}
    procedure ComposeMedicationKnowledgeRelatedMedicationKnowledge(xml : TXmlBuilder; name : string; value : TFhirMedicationKnowledgeRelatedMedicationKnowledge);
    procedure ComposeMedicationKnowledgeRelatedMedicationKnowledgeChildren(xml : TXmlBuilder; value : TFhirMedicationKnowledgeRelatedMedicationKnowledge);
    procedure ComposeMedicationKnowledgeMonograph(xml : TXmlBuilder; name : string; value : TFhirMedicationKnowledgeMonograph);
    procedure ComposeMedicationKnowledgeMonographChildren(xml : TXmlBuilder; value : TFhirMedicationKnowledgeMonograph);
    procedure ComposeMedicationKnowledgeCost(xml : TXmlBuilder; name : string; value : TFhirMedicationKnowledgeCost);
    procedure ComposeMedicationKnowledgeCostChildren(xml : TXmlBuilder; value : TFhirMedicationKnowledgeCost);
    procedure ComposeMedicationKnowledgeMonitoringProgram(xml : TXmlBuilder; name : string; value : TFhirMedicationKnowledgeMonitoringProgram);
    procedure ComposeMedicationKnowledgeMonitoringProgramChildren(xml : TXmlBuilder; value : TFhirMedicationKnowledgeMonitoringProgram);
    procedure ComposeMedicationKnowledgeIndicationGuideline(xml : TXmlBuilder; name : string; value : TFhirMedicationKnowledgeIndicationGuideline);
    procedure ComposeMedicationKnowledgeIndicationGuidelineChildren(xml : TXmlBuilder; value : TFhirMedicationKnowledgeIndicationGuideline);
    procedure ComposeMedicationKnowledgeIndicationGuidelineDosingGuideline(xml : TXmlBuilder; name : string; value : TFhirMedicationKnowledgeIndicationGuidelineDosingGuideline);
    procedure ComposeMedicationKnowledgeIndicationGuidelineDosingGuidelineChildren(xml : TXmlBuilder; value : TFhirMedicationKnowledgeIndicationGuidelineDosingGuideline);
    procedure ComposeMedicationKnowledgeIndicationGuidelineDosingGuidelineDosage(xml : TXmlBuilder; name : string; value : TFhirMedicationKnowledgeIndicationGuidelineDosingGuidelineDosage);
    procedure ComposeMedicationKnowledgeIndicationGuidelineDosingGuidelineDosageChildren(xml : TXmlBuilder; value : TFhirMedicationKnowledgeIndicationGuidelineDosingGuidelineDosage);
    procedure ComposeMedicationKnowledgeIndicationGuidelineDosingGuidelinePatientCharacteristic(xml : TXmlBuilder; name : string; value : TFhirMedicationKnowledgeIndicationGuidelineDosingGuidelinePatientCharacteristic);
    procedure ComposeMedicationKnowledgeIndicationGuidelineDosingGuidelinePatientCharacteristicChildren(xml : TXmlBuilder; value : TFhirMedicationKnowledgeIndicationGuidelineDosingGuidelinePatientCharacteristic);
    procedure ComposeMedicationKnowledgeMedicineClassification(xml : TXmlBuilder; name : string; value : TFhirMedicationKnowledgeMedicineClassification);
    procedure ComposeMedicationKnowledgeMedicineClassificationChildren(xml : TXmlBuilder; value : TFhirMedicationKnowledgeMedicineClassification);
    procedure ComposeMedicationKnowledgePackaging(xml : TXmlBuilder; name : string; value : TFhirMedicationKnowledgePackaging);
    procedure ComposeMedicationKnowledgePackagingChildren(xml : TXmlBuilder; value : TFhirMedicationKnowledgePackaging);
    procedure ComposeMedicationKnowledgeStorageGuideline(xml : TXmlBuilder; name : string; value : TFhirMedicationKnowledgeStorageGuideline);
    procedure ComposeMedicationKnowledgeStorageGuidelineChildren(xml : TXmlBuilder; value : TFhirMedicationKnowledgeStorageGuideline);
    procedure ComposeMedicationKnowledgeStorageGuidelineEnvironmentalSetting(xml : TXmlBuilder; name : string; value : TFhirMedicationKnowledgeStorageGuidelineEnvironmentalSetting);
    procedure ComposeMedicationKnowledgeStorageGuidelineEnvironmentalSettingChildren(xml : TXmlBuilder; value : TFhirMedicationKnowledgeStorageGuidelineEnvironmentalSetting);
    procedure ComposeMedicationKnowledgeRegulatory(xml : TXmlBuilder; name : string; value : TFhirMedicationKnowledgeRegulatory);
    procedure ComposeMedicationKnowledgeRegulatoryChildren(xml : TXmlBuilder; value : TFhirMedicationKnowledgeRegulatory);
    procedure ComposeMedicationKnowledgeRegulatorySubstitution(xml : TXmlBuilder; name : string; value : TFhirMedicationKnowledgeRegulatorySubstitution);
    procedure ComposeMedicationKnowledgeRegulatorySubstitutionChildren(xml : TXmlBuilder; value : TFhirMedicationKnowledgeRegulatorySubstitution);
    procedure ComposeMedicationKnowledgeRegulatoryMaxDispense(xml : TXmlBuilder; name : string; value : TFhirMedicationKnowledgeRegulatoryMaxDispense);
    procedure ComposeMedicationKnowledgeRegulatoryMaxDispenseChildren(xml : TXmlBuilder; value : TFhirMedicationKnowledgeRegulatoryMaxDispense);
    procedure ComposeMedicationKnowledgeDefinitional(xml : TXmlBuilder; name : string; value : TFhirMedicationKnowledgeDefinitional);
    procedure ComposeMedicationKnowledgeDefinitionalChildren(xml : TXmlBuilder; value : TFhirMedicationKnowledgeDefinitional);
    procedure ComposeMedicationKnowledgeDefinitionalIngredient(xml : TXmlBuilder; name : string; value : TFhirMedicationKnowledgeDefinitionalIngredient);
    procedure ComposeMedicationKnowledgeDefinitionalIngredientChildren(xml : TXmlBuilder; value : TFhirMedicationKnowledgeDefinitionalIngredient);
    procedure ComposeMedicationKnowledgeDefinitionalDrugCharacteristic(xml : TXmlBuilder; name : string; value : TFhirMedicationKnowledgeDefinitionalDrugCharacteristic);
    procedure ComposeMedicationKnowledgeDefinitionalDrugCharacteristicChildren(xml : TXmlBuilder; value : TFhirMedicationKnowledgeDefinitionalDrugCharacteristic);
    procedure ComposeMedicationKnowledge(xml : TXmlBuilder; name : string; value : TFhirMedicationKnowledge);
    procedure ComposeMedicationKnowledgeChildren(xml : TXmlBuilder; value : TFhirMedicationKnowledge);
{$ENDIF FHIR_MEDICATIONKNOWLEDGE}
{$IFDEF FHIR_MEDICATIONREQUEST}
    procedure ComposeMedicationRequestDose(xml : TXmlBuilder; name : string; value : TFhirMedicationRequestDose);
    procedure ComposeMedicationRequestDoseChildren(xml : TXmlBuilder; value : TFhirMedicationRequestDose);
    procedure ComposeMedicationRequestDispenseRequest(xml : TXmlBuilder; name : string; value : TFhirMedicationRequestDispenseRequest);
    procedure ComposeMedicationRequestDispenseRequestChildren(xml : TXmlBuilder; value : TFhirMedicationRequestDispenseRequest);
    procedure ComposeMedicationRequestDispenseRequestInitialFill(xml : TXmlBuilder; name : string; value : TFhirMedicationRequestDispenseRequestInitialFill);
    procedure ComposeMedicationRequestDispenseRequestInitialFillChildren(xml : TXmlBuilder; value : TFhirMedicationRequestDispenseRequestInitialFill);
    procedure ComposeMedicationRequestSubstitution(xml : TXmlBuilder; name : string; value : TFhirMedicationRequestSubstitution);
    procedure ComposeMedicationRequestSubstitutionChildren(xml : TXmlBuilder; value : TFhirMedicationRequestSubstitution);
    procedure ComposeMedicationRequest(xml : TXmlBuilder; name : string; value : TFhirMedicationRequest);
    procedure ComposeMedicationRequestChildren(xml : TXmlBuilder; value : TFhirMedicationRequest);
{$ENDIF FHIR_MEDICATIONREQUEST}
{$IFDEF FHIR_MEDICATIONUSAGE}
    procedure ComposeMedicationUsageAdherence(xml : TXmlBuilder; name : string; value : TFhirMedicationUsageAdherence);
    procedure ComposeMedicationUsageAdherenceChildren(xml : TXmlBuilder; value : TFhirMedicationUsageAdherence);
    procedure ComposeMedicationUsage(xml : TXmlBuilder; name : string; value : TFhirMedicationUsage);
    procedure ComposeMedicationUsageChildren(xml : TXmlBuilder; value : TFhirMedicationUsage);
{$ENDIF FHIR_MEDICATIONUSAGE}
{$IFDEF FHIR_MEDICINALPRODUCTDEFINITION}
    procedure ComposeMedicinalProductDefinitionContact(xml : TXmlBuilder; name : string; value : TFhirMedicinalProductDefinitionContact);
    procedure ComposeMedicinalProductDefinitionContactChildren(xml : TXmlBuilder; value : TFhirMedicinalProductDefinitionContact);
    procedure ComposeMedicinalProductDefinitionName(xml : TXmlBuilder; name : string; value : TFhirMedicinalProductDefinitionName);
    procedure ComposeMedicinalProductDefinitionNameChildren(xml : TXmlBuilder; value : TFhirMedicinalProductDefinitionName);
    procedure ComposeMedicinalProductDefinitionNamePart(xml : TXmlBuilder; name : string; value : TFhirMedicinalProductDefinitionNamePart);
    procedure ComposeMedicinalProductDefinitionNamePartChildren(xml : TXmlBuilder; value : TFhirMedicinalProductDefinitionNamePart);
    procedure ComposeMedicinalProductDefinitionNameUsage(xml : TXmlBuilder; name : string; value : TFhirMedicinalProductDefinitionNameUsage);
    procedure ComposeMedicinalProductDefinitionNameUsageChildren(xml : TXmlBuilder; value : TFhirMedicinalProductDefinitionNameUsage);
    procedure ComposeMedicinalProductDefinitionCrossReference(xml : TXmlBuilder; name : string; value : TFhirMedicinalProductDefinitionCrossReference);
    procedure ComposeMedicinalProductDefinitionCrossReferenceChildren(xml : TXmlBuilder; value : TFhirMedicinalProductDefinitionCrossReference);
    procedure ComposeMedicinalProductDefinitionOperation(xml : TXmlBuilder; name : string; value : TFhirMedicinalProductDefinitionOperation);
    procedure ComposeMedicinalProductDefinitionOperationChildren(xml : TXmlBuilder; value : TFhirMedicinalProductDefinitionOperation);
    procedure ComposeMedicinalProductDefinitionCharacteristic(xml : TXmlBuilder; name : string; value : TFhirMedicinalProductDefinitionCharacteristic);
    procedure ComposeMedicinalProductDefinitionCharacteristicChildren(xml : TXmlBuilder; value : TFhirMedicinalProductDefinitionCharacteristic);
    procedure ComposeMedicinalProductDefinition(xml : TXmlBuilder; name : string; value : TFhirMedicinalProductDefinition);
    procedure ComposeMedicinalProductDefinitionChildren(xml : TXmlBuilder; value : TFhirMedicinalProductDefinition);
{$ENDIF FHIR_MEDICINALPRODUCTDEFINITION}
{$IFDEF FHIR_MESSAGEDEFINITION}
    procedure ComposeMessageDefinitionFocus(xml : TXmlBuilder; name : string; value : TFhirMessageDefinitionFocus);
    procedure ComposeMessageDefinitionFocusChildren(xml : TXmlBuilder; value : TFhirMessageDefinitionFocus);
    procedure ComposeMessageDefinitionAllowedResponse(xml : TXmlBuilder; name : string; value : TFhirMessageDefinitionAllowedResponse);
    procedure ComposeMessageDefinitionAllowedResponseChildren(xml : TXmlBuilder; value : TFhirMessageDefinitionAllowedResponse);
    procedure ComposeMessageDefinition(xml : TXmlBuilder; name : string; value : TFhirMessageDefinition);
    procedure ComposeMessageDefinitionChildren(xml : TXmlBuilder; value : TFhirMessageDefinition);
{$ENDIF FHIR_MESSAGEDEFINITION}
{$IFDEF FHIR_MESSAGEHEADER}
    procedure ComposeMessageHeaderDestination(xml : TXmlBuilder; name : string; value : TFhirMessageHeaderDestination);
    procedure ComposeMessageHeaderDestinationChildren(xml : TXmlBuilder; value : TFhirMessageHeaderDestination);
    procedure ComposeMessageHeaderSource(xml : TXmlBuilder; name : string; value : TFhirMessageHeaderSource);
    procedure ComposeMessageHeaderSourceChildren(xml : TXmlBuilder; value : TFhirMessageHeaderSource);
    procedure ComposeMessageHeaderResponse(xml : TXmlBuilder; name : string; value : TFhirMessageHeaderResponse);
    procedure ComposeMessageHeaderResponseChildren(xml : TXmlBuilder; value : TFhirMessageHeaderResponse);
    procedure ComposeMessageHeader(xml : TXmlBuilder; name : string; value : TFhirMessageHeader);
    procedure ComposeMessageHeaderChildren(xml : TXmlBuilder; value : TFhirMessageHeader);
{$ENDIF FHIR_MESSAGEHEADER}
{$IFDEF FHIR_MOLECULARSEQUENCE}
    procedure ComposeMolecularSequenceRelative(xml : TXmlBuilder; name : string; value : TFhirMolecularSequenceRelative);
    procedure ComposeMolecularSequenceRelativeChildren(xml : TXmlBuilder; value : TFhirMolecularSequenceRelative);
    procedure ComposeMolecularSequenceRelativeStartingSequence(xml : TXmlBuilder; name : string; value : TFhirMolecularSequenceRelativeStartingSequence);
    procedure ComposeMolecularSequenceRelativeStartingSequenceChildren(xml : TXmlBuilder; value : TFhirMolecularSequenceRelativeStartingSequence);
    procedure ComposeMolecularSequenceRelativeEdit(xml : TXmlBuilder; name : string; value : TFhirMolecularSequenceRelativeEdit);
    procedure ComposeMolecularSequenceRelativeEditChildren(xml : TXmlBuilder; value : TFhirMolecularSequenceRelativeEdit);
    procedure ComposeMolecularSequence(xml : TXmlBuilder; name : string; value : TFhirMolecularSequence);
    procedure ComposeMolecularSequenceChildren(xml : TXmlBuilder; value : TFhirMolecularSequence);
{$ENDIF FHIR_MOLECULARSEQUENCE}
{$IFDEF FHIR_NAMINGSYSTEM}
    procedure ComposeNamingSystemUniqueId(xml : TXmlBuilder; name : string; value : TFhirNamingSystemUniqueId);
    procedure ComposeNamingSystemUniqueIdChildren(xml : TXmlBuilder; value : TFhirNamingSystemUniqueId);
    procedure ComposeNamingSystem(xml : TXmlBuilder; name : string; value : TFhirNamingSystem);
    procedure ComposeNamingSystemChildren(xml : TXmlBuilder; value : TFhirNamingSystem);
{$ENDIF FHIR_NAMINGSYSTEM}
{$IFDEF FHIR_NUTRITIONINTAKE}
    procedure ComposeNutritionIntakeConsumedItem(xml : TXmlBuilder; name : string; value : TFhirNutritionIntakeConsumedItem);
    procedure ComposeNutritionIntakeConsumedItemChildren(xml : TXmlBuilder; value : TFhirNutritionIntakeConsumedItem);
    procedure ComposeNutritionIntakeIngredientLabel(xml : TXmlBuilder; name : string; value : TFhirNutritionIntakeIngredientLabel);
    procedure ComposeNutritionIntakeIngredientLabelChildren(xml : TXmlBuilder; value : TFhirNutritionIntakeIngredientLabel);
    procedure ComposeNutritionIntakePerformer(xml : TXmlBuilder; name : string; value : TFhirNutritionIntakePerformer);
    procedure ComposeNutritionIntakePerformerChildren(xml : TXmlBuilder; value : TFhirNutritionIntakePerformer);
    procedure ComposeNutritionIntake(xml : TXmlBuilder; name : string; value : TFhirNutritionIntake);
    procedure ComposeNutritionIntakeChildren(xml : TXmlBuilder; value : TFhirNutritionIntake);
{$ENDIF FHIR_NUTRITIONINTAKE}
{$IFDEF FHIR_NUTRITIONORDER}
    procedure ComposeNutritionOrderOralDiet(xml : TXmlBuilder; name : string; value : TFhirNutritionOrderOralDiet);
    procedure ComposeNutritionOrderOralDietChildren(xml : TXmlBuilder; value : TFhirNutritionOrderOralDiet);
    procedure ComposeNutritionOrderOralDietSchedule(xml : TXmlBuilder; name : string; value : TFhirNutritionOrderOralDietSchedule);
    procedure ComposeNutritionOrderOralDietScheduleChildren(xml : TXmlBuilder; value : TFhirNutritionOrderOralDietSchedule);
    procedure ComposeNutritionOrderOralDietNutrient(xml : TXmlBuilder; name : string; value : TFhirNutritionOrderOralDietNutrient);
    procedure ComposeNutritionOrderOralDietNutrientChildren(xml : TXmlBuilder; value : TFhirNutritionOrderOralDietNutrient);
    procedure ComposeNutritionOrderOralDietTexture(xml : TXmlBuilder; name : string; value : TFhirNutritionOrderOralDietTexture);
    procedure ComposeNutritionOrderOralDietTextureChildren(xml : TXmlBuilder; value : TFhirNutritionOrderOralDietTexture);
    procedure ComposeNutritionOrderSupplement(xml : TXmlBuilder; name : string; value : TFhirNutritionOrderSupplement);
    procedure ComposeNutritionOrderSupplementChildren(xml : TXmlBuilder; value : TFhirNutritionOrderSupplement);
    procedure ComposeNutritionOrderSupplementSchedule(xml : TXmlBuilder; name : string; value : TFhirNutritionOrderSupplementSchedule);
    procedure ComposeNutritionOrderSupplementScheduleChildren(xml : TXmlBuilder; value : TFhirNutritionOrderSupplementSchedule);
    procedure ComposeNutritionOrderEnteralFormula(xml : TXmlBuilder; name : string; value : TFhirNutritionOrderEnteralFormula);
    procedure ComposeNutritionOrderEnteralFormulaChildren(xml : TXmlBuilder; value : TFhirNutritionOrderEnteralFormula);
    procedure ComposeNutritionOrderEnteralFormulaAdditive(xml : TXmlBuilder; name : string; value : TFhirNutritionOrderEnteralFormulaAdditive);
    procedure ComposeNutritionOrderEnteralFormulaAdditiveChildren(xml : TXmlBuilder; value : TFhirNutritionOrderEnteralFormulaAdditive);
    procedure ComposeNutritionOrderEnteralFormulaAdministration(xml : TXmlBuilder; name : string; value : TFhirNutritionOrderEnteralFormulaAdministration);
    procedure ComposeNutritionOrderEnteralFormulaAdministrationChildren(xml : TXmlBuilder; value : TFhirNutritionOrderEnteralFormulaAdministration);
    procedure ComposeNutritionOrderEnteralFormulaAdministrationSchedule(xml : TXmlBuilder; name : string; value : TFhirNutritionOrderEnteralFormulaAdministrationSchedule);
    procedure ComposeNutritionOrderEnteralFormulaAdministrationScheduleChildren(xml : TXmlBuilder; value : TFhirNutritionOrderEnteralFormulaAdministrationSchedule);
    procedure ComposeNutritionOrder(xml : TXmlBuilder; name : string; value : TFhirNutritionOrder);
    procedure ComposeNutritionOrderChildren(xml : TXmlBuilder; value : TFhirNutritionOrder);
{$ENDIF FHIR_NUTRITIONORDER}
{$IFDEF FHIR_NUTRITIONPRODUCT}
    procedure ComposeNutritionProductNutrient(xml : TXmlBuilder; name : string; value : TFhirNutritionProductNutrient);
    procedure ComposeNutritionProductNutrientChildren(xml : TXmlBuilder; value : TFhirNutritionProductNutrient);
    procedure ComposeNutritionProductIngredient(xml : TXmlBuilder; name : string; value : TFhirNutritionProductIngredient);
    procedure ComposeNutritionProductIngredientChildren(xml : TXmlBuilder; value : TFhirNutritionProductIngredient);
    procedure ComposeNutritionProductCharacteristic(xml : TXmlBuilder; name : string; value : TFhirNutritionProductCharacteristic);
    procedure ComposeNutritionProductCharacteristicChildren(xml : TXmlBuilder; value : TFhirNutritionProductCharacteristic);
    procedure ComposeNutritionProductInstance(xml : TXmlBuilder; name : string; value : TFhirNutritionProductInstance);
    procedure ComposeNutritionProductInstanceChildren(xml : TXmlBuilder; value : TFhirNutritionProductInstance);
    procedure ComposeNutritionProduct(xml : TXmlBuilder; name : string; value : TFhirNutritionProduct);
    procedure ComposeNutritionProductChildren(xml : TXmlBuilder; value : TFhirNutritionProduct);
{$ENDIF FHIR_NUTRITIONPRODUCT}
{$IFDEF FHIR_OBSERVATION}
    procedure ComposeObservationTriggeredBy(xml : TXmlBuilder; name : string; value : TFhirObservationTriggeredBy);
    procedure ComposeObservationTriggeredByChildren(xml : TXmlBuilder; value : TFhirObservationTriggeredBy);
    procedure ComposeObservationReferenceRange(xml : TXmlBuilder; name : string; value : TFhirObservationReferenceRange);
    procedure ComposeObservationReferenceRangeChildren(xml : TXmlBuilder; value : TFhirObservationReferenceRange);
    procedure ComposeObservationComponent(xml : TXmlBuilder; name : string; value : TFhirObservationComponent);
    procedure ComposeObservationComponentChildren(xml : TXmlBuilder; value : TFhirObservationComponent);
    procedure ComposeObservation(xml : TXmlBuilder; name : string; value : TFhirObservation);
    procedure ComposeObservationChildren(xml : TXmlBuilder; value : TFhirObservation);
{$ENDIF FHIR_OBSERVATION}
{$IFDEF FHIR_OBSERVATIONDEFINITION}
    procedure ComposeObservationDefinitionQuantitativeDetails(xml : TXmlBuilder; name : string; value : TFhirObservationDefinitionQuantitativeDetails);
    procedure ComposeObservationDefinitionQuantitativeDetailsChildren(xml : TXmlBuilder; value : TFhirObservationDefinitionQuantitativeDetails);
    procedure ComposeObservationDefinitionQualifiedValue(xml : TXmlBuilder; name : string; value : TFhirObservationDefinitionQualifiedValue);
    procedure ComposeObservationDefinitionQualifiedValueChildren(xml : TXmlBuilder; value : TFhirObservationDefinitionQualifiedValue);
    procedure ComposeObservationDefinitionComponent(xml : TXmlBuilder; name : string; value : TFhirObservationDefinitionComponent);
    procedure ComposeObservationDefinitionComponentChildren(xml : TXmlBuilder; value : TFhirObservationDefinitionComponent);
    procedure ComposeObservationDefinition(xml : TXmlBuilder; name : string; value : TFhirObservationDefinition);
    procedure ComposeObservationDefinitionChildren(xml : TXmlBuilder; value : TFhirObservationDefinition);
{$ENDIF FHIR_OBSERVATIONDEFINITION}
{$IFDEF FHIR_OPERATIONDEFINITION}
    procedure ComposeOperationDefinitionParameter(xml : TXmlBuilder; name : string; value : TFhirOperationDefinitionParameter);
    procedure ComposeOperationDefinitionParameterChildren(xml : TXmlBuilder; value : TFhirOperationDefinitionParameter);
    procedure ComposeOperationDefinitionParameterBinding(xml : TXmlBuilder; name : string; value : TFhirOperationDefinitionParameterBinding);
    procedure ComposeOperationDefinitionParameterBindingChildren(xml : TXmlBuilder; value : TFhirOperationDefinitionParameterBinding);
    procedure ComposeOperationDefinitionParameterReferencedFrom(xml : TXmlBuilder; name : string; value : TFhirOperationDefinitionParameterReferencedFrom);
    procedure ComposeOperationDefinitionParameterReferencedFromChildren(xml : TXmlBuilder; value : TFhirOperationDefinitionParameterReferencedFrom);
    procedure ComposeOperationDefinitionOverload(xml : TXmlBuilder; name : string; value : TFhirOperationDefinitionOverload);
    procedure ComposeOperationDefinitionOverloadChildren(xml : TXmlBuilder; value : TFhirOperationDefinitionOverload);
    procedure ComposeOperationDefinition(xml : TXmlBuilder; name : string; value : TFhirOperationDefinition);
    procedure ComposeOperationDefinitionChildren(xml : TXmlBuilder; value : TFhirOperationDefinition);
{$ENDIF FHIR_OPERATIONDEFINITION}
{$IFDEF FHIR_OPERATIONOUTCOME}
    procedure ComposeOperationOutcomeIssue(xml : TXmlBuilder; name : string; value : TFhirOperationOutcomeIssue);
    procedure ComposeOperationOutcomeIssueChildren(xml : TXmlBuilder; value : TFhirOperationOutcomeIssue);
    procedure ComposeOperationOutcome(xml : TXmlBuilder; name : string; value : TFhirOperationOutcome);
    procedure ComposeOperationOutcomeChildren(xml : TXmlBuilder; value : TFhirOperationOutcome);
{$ENDIF FHIR_OPERATIONOUTCOME}
{$IFDEF FHIR_ORGANIZATION}
    procedure ComposeOrganizationQualification(xml : TXmlBuilder; name : string; value : TFhirOrganizationQualification);
    procedure ComposeOrganizationQualificationChildren(xml : TXmlBuilder; value : TFhirOrganizationQualification);
    procedure ComposeOrganization(xml : TXmlBuilder; name : string; value : TFhirOrganization);
    procedure ComposeOrganizationChildren(xml : TXmlBuilder; value : TFhirOrganization);
{$ENDIF FHIR_ORGANIZATION}
{$IFDEF FHIR_ORGANIZATIONAFFILIATION}
    procedure ComposeOrganizationAffiliation(xml : TXmlBuilder; name : string; value : TFhirOrganizationAffiliation);
    procedure ComposeOrganizationAffiliationChildren(xml : TXmlBuilder; value : TFhirOrganizationAffiliation);
{$ENDIF FHIR_ORGANIZATIONAFFILIATION}
{$IFDEF FHIR_PACKAGEDPRODUCTDEFINITION}
    procedure ComposePackagedProductDefinitionLegalStatusOfSupply(xml : TXmlBuilder; name : string; value : TFhirPackagedProductDefinitionLegalStatusOfSupply);
    procedure ComposePackagedProductDefinitionLegalStatusOfSupplyChildren(xml : TXmlBuilder; value : TFhirPackagedProductDefinitionLegalStatusOfSupply);
    procedure ComposePackagedProductDefinitionPackaging(xml : TXmlBuilder; name : string; value : TFhirPackagedProductDefinitionPackaging);
    procedure ComposePackagedProductDefinitionPackagingChildren(xml : TXmlBuilder; value : TFhirPackagedProductDefinitionPackaging);
    procedure ComposePackagedProductDefinitionPackagingProperty(xml : TXmlBuilder; name : string; value : TFhirPackagedProductDefinitionPackagingProperty);
    procedure ComposePackagedProductDefinitionPackagingPropertyChildren(xml : TXmlBuilder; value : TFhirPackagedProductDefinitionPackagingProperty);
    procedure ComposePackagedProductDefinitionPackagingContainedItem(xml : TXmlBuilder; name : string; value : TFhirPackagedProductDefinitionPackagingContainedItem);
    procedure ComposePackagedProductDefinitionPackagingContainedItemChildren(xml : TXmlBuilder; value : TFhirPackagedProductDefinitionPackagingContainedItem);
    procedure ComposePackagedProductDefinition(xml : TXmlBuilder; name : string; value : TFhirPackagedProductDefinition);
    procedure ComposePackagedProductDefinitionChildren(xml : TXmlBuilder; value : TFhirPackagedProductDefinition);
{$ENDIF FHIR_PACKAGEDPRODUCTDEFINITION}
{$IFDEF FHIR_PARAMETERS}
    procedure ComposeParametersParameter(xml : TXmlBuilder; name : string; value : TFhirParametersParameter);
    procedure ComposeParametersParameterChildren(xml : TXmlBuilder; value : TFhirParametersParameter);
    procedure ComposeParameters(xml : TXmlBuilder; name : string; value : TFhirParameters);
    procedure ComposeParametersChildren(xml : TXmlBuilder; value : TFhirParameters);
{$ENDIF FHIR_PARAMETERS}
{$IFDEF FHIR_PATIENT}
    procedure ComposePatientContact(xml : TXmlBuilder; name : string; value : TFhirPatientContact);
    procedure ComposePatientContactChildren(xml : TXmlBuilder; value : TFhirPatientContact);
    procedure ComposePatientCommunication(xml : TXmlBuilder; name : string; value : TFhirPatientCommunication);
    procedure ComposePatientCommunicationChildren(xml : TXmlBuilder; value : TFhirPatientCommunication);
    procedure ComposePatientLink(xml : TXmlBuilder; name : string; value : TFhirPatientLink);
    procedure ComposePatientLinkChildren(xml : TXmlBuilder; value : TFhirPatientLink);
    procedure ComposePatient(xml : TXmlBuilder; name : string; value : TFhirPatient);
    procedure ComposePatientChildren(xml : TXmlBuilder; value : TFhirPatient);
{$ENDIF FHIR_PATIENT}
{$IFDEF FHIR_PAYMENTNOTICE}
    procedure ComposePaymentNotice(xml : TXmlBuilder; name : string; value : TFhirPaymentNotice);
    procedure ComposePaymentNoticeChildren(xml : TXmlBuilder; value : TFhirPaymentNotice);
{$ENDIF FHIR_PAYMENTNOTICE}
{$IFDEF FHIR_PAYMENTRECONCILIATION}
    procedure ComposePaymentReconciliationAllocation(xml : TXmlBuilder; name : string; value : TFhirPaymentReconciliationAllocation);
    procedure ComposePaymentReconciliationAllocationChildren(xml : TXmlBuilder; value : TFhirPaymentReconciliationAllocation);
    procedure ComposePaymentReconciliationProcessNote(xml : TXmlBuilder; name : string; value : TFhirPaymentReconciliationProcessNote);
    procedure ComposePaymentReconciliationProcessNoteChildren(xml : TXmlBuilder; value : TFhirPaymentReconciliationProcessNote);
    procedure ComposePaymentReconciliation(xml : TXmlBuilder; name : string; value : TFhirPaymentReconciliation);
    procedure ComposePaymentReconciliationChildren(xml : TXmlBuilder; value : TFhirPaymentReconciliation);
{$ENDIF FHIR_PAYMENTRECONCILIATION}
{$IFDEF FHIR_PERMISSION}
    procedure ComposePermissionJustification(xml : TXmlBuilder; name : string; value : TFhirPermissionJustification);
    procedure ComposePermissionJustificationChildren(xml : TXmlBuilder; value : TFhirPermissionJustification);
    procedure ComposePermissionRule(xml : TXmlBuilder; name : string; value : TFhirPermissionRule);
    procedure ComposePermissionRuleChildren(xml : TXmlBuilder; value : TFhirPermissionRule);
    procedure ComposePermissionRuleData(xml : TXmlBuilder; name : string; value : TFhirPermissionRuleData);
    procedure ComposePermissionRuleDataChildren(xml : TXmlBuilder; value : TFhirPermissionRuleData);
    procedure ComposePermissionRuleDataResource(xml : TXmlBuilder; name : string; value : TFhirPermissionRuleDataResource);
    procedure ComposePermissionRuleDataResourceChildren(xml : TXmlBuilder; value : TFhirPermissionRuleDataResource);
    procedure ComposePermissionRuleActivity(xml : TXmlBuilder; name : string; value : TFhirPermissionRuleActivity);
    procedure ComposePermissionRuleActivityChildren(xml : TXmlBuilder; value : TFhirPermissionRuleActivity);
    procedure ComposePermission(xml : TXmlBuilder; name : string; value : TFhirPermission);
    procedure ComposePermissionChildren(xml : TXmlBuilder; value : TFhirPermission);
{$ENDIF FHIR_PERMISSION}
{$IFDEF FHIR_PERSON}
    procedure ComposePersonCommunication(xml : TXmlBuilder; name : string; value : TFhirPersonCommunication);
    procedure ComposePersonCommunicationChildren(xml : TXmlBuilder; value : TFhirPersonCommunication);
    procedure ComposePersonLink(xml : TXmlBuilder; name : string; value : TFhirPersonLink);
    procedure ComposePersonLinkChildren(xml : TXmlBuilder; value : TFhirPersonLink);
    procedure ComposePerson(xml : TXmlBuilder; name : string; value : TFhirPerson);
    procedure ComposePersonChildren(xml : TXmlBuilder; value : TFhirPerson);
{$ENDIF FHIR_PERSON}
{$IFDEF FHIR_PLANDEFINITION}
    procedure ComposePlanDefinitionGoal(xml : TXmlBuilder; name : string; value : TFhirPlanDefinitionGoal);
    procedure ComposePlanDefinitionGoalChildren(xml : TXmlBuilder; value : TFhirPlanDefinitionGoal);
    procedure ComposePlanDefinitionGoalTarget(xml : TXmlBuilder; name : string; value : TFhirPlanDefinitionGoalTarget);
    procedure ComposePlanDefinitionGoalTargetChildren(xml : TXmlBuilder; value : TFhirPlanDefinitionGoalTarget);
    procedure ComposePlanDefinitionActor(xml : TXmlBuilder; name : string; value : TFhirPlanDefinitionActor);
    procedure ComposePlanDefinitionActorChildren(xml : TXmlBuilder; value : TFhirPlanDefinitionActor);
    procedure ComposePlanDefinitionActorOption(xml : TXmlBuilder; name : string; value : TFhirPlanDefinitionActorOption);
    procedure ComposePlanDefinitionActorOptionChildren(xml : TXmlBuilder; value : TFhirPlanDefinitionActorOption);
    procedure ComposePlanDefinitionAction(xml : TXmlBuilder; name : string; value : TFhirPlanDefinitionAction);
    procedure ComposePlanDefinitionActionChildren(xml : TXmlBuilder; value : TFhirPlanDefinitionAction);
    procedure ComposePlanDefinitionActionCondition(xml : TXmlBuilder; name : string; value : TFhirPlanDefinitionActionCondition);
    procedure ComposePlanDefinitionActionConditionChildren(xml : TXmlBuilder; value : TFhirPlanDefinitionActionCondition);
    procedure ComposePlanDefinitionActionInput(xml : TXmlBuilder; name : string; value : TFhirPlanDefinitionActionInput);
    procedure ComposePlanDefinitionActionInputChildren(xml : TXmlBuilder; value : TFhirPlanDefinitionActionInput);
    procedure ComposePlanDefinitionActionOutput(xml : TXmlBuilder; name : string; value : TFhirPlanDefinitionActionOutput);
    procedure ComposePlanDefinitionActionOutputChildren(xml : TXmlBuilder; value : TFhirPlanDefinitionActionOutput);
    procedure ComposePlanDefinitionActionRelatedAction(xml : TXmlBuilder; name : string; value : TFhirPlanDefinitionActionRelatedAction);
    procedure ComposePlanDefinitionActionRelatedActionChildren(xml : TXmlBuilder; value : TFhirPlanDefinitionActionRelatedAction);
    procedure ComposePlanDefinitionActionParticipant(xml : TXmlBuilder; name : string; value : TFhirPlanDefinitionActionParticipant);
    procedure ComposePlanDefinitionActionParticipantChildren(xml : TXmlBuilder; value : TFhirPlanDefinitionActionParticipant);
    procedure ComposePlanDefinitionActionDynamicValue(xml : TXmlBuilder; name : string; value : TFhirPlanDefinitionActionDynamicValue);
    procedure ComposePlanDefinitionActionDynamicValueChildren(xml : TXmlBuilder; value : TFhirPlanDefinitionActionDynamicValue);
    procedure ComposePlanDefinition(xml : TXmlBuilder; name : string; value : TFhirPlanDefinition);
    procedure ComposePlanDefinitionChildren(xml : TXmlBuilder; value : TFhirPlanDefinition);
{$ENDIF FHIR_PLANDEFINITION}
{$IFDEF FHIR_PRACTITIONER}
    procedure ComposePractitionerQualification(xml : TXmlBuilder; name : string; value : TFhirPractitionerQualification);
    procedure ComposePractitionerQualificationChildren(xml : TXmlBuilder; value : TFhirPractitionerQualification);
    procedure ComposePractitioner(xml : TXmlBuilder; name : string; value : TFhirPractitioner);
    procedure ComposePractitionerChildren(xml : TXmlBuilder; value : TFhirPractitioner);
{$ENDIF FHIR_PRACTITIONER}
{$IFDEF FHIR_PRACTITIONERROLE}
    procedure ComposePractitionerRole(xml : TXmlBuilder; name : string; value : TFhirPractitionerRole);
    procedure ComposePractitionerRoleChildren(xml : TXmlBuilder; value : TFhirPractitionerRole);
{$ENDIF FHIR_PRACTITIONERROLE}
{$IFDEF FHIR_PROCEDURE}
    procedure ComposeProcedurePerformer(xml : TXmlBuilder; name : string; value : TFhirProcedurePerformer);
    procedure ComposeProcedurePerformerChildren(xml : TXmlBuilder; value : TFhirProcedurePerformer);
    procedure ComposeProcedureFocalDevice(xml : TXmlBuilder; name : string; value : TFhirProcedureFocalDevice);
    procedure ComposeProcedureFocalDeviceChildren(xml : TXmlBuilder; value : TFhirProcedureFocalDevice);
    procedure ComposeProcedure(xml : TXmlBuilder; name : string; value : TFhirProcedure);
    procedure ComposeProcedureChildren(xml : TXmlBuilder; value : TFhirProcedure);
{$ENDIF FHIR_PROCEDURE}
{$IFDEF FHIR_PROVENANCE}
    procedure ComposeProvenanceAgent(xml : TXmlBuilder; name : string; value : TFhirProvenanceAgent);
    procedure ComposeProvenanceAgentChildren(xml : TXmlBuilder; value : TFhirProvenanceAgent);
    procedure ComposeProvenanceEntity(xml : TXmlBuilder; name : string; value : TFhirProvenanceEntity);
    procedure ComposeProvenanceEntityChildren(xml : TXmlBuilder; value : TFhirProvenanceEntity);
    procedure ComposeProvenance(xml : TXmlBuilder; name : string; value : TFhirProvenance);
    procedure ComposeProvenanceChildren(xml : TXmlBuilder; value : TFhirProvenance);
{$ENDIF FHIR_PROVENANCE}
{$IFDEF FHIR_QUESTIONNAIRE}
    procedure ComposeQuestionnaireItem(xml : TXmlBuilder; name : string; value : TFhirQuestionnaireItem);
    procedure ComposeQuestionnaireItemChildren(xml : TXmlBuilder; value : TFhirQuestionnaireItem);
    procedure ComposeQuestionnaireItemEnableWhen(xml : TXmlBuilder; name : string; value : TFhirQuestionnaireItemEnableWhen);
    procedure ComposeQuestionnaireItemEnableWhenChildren(xml : TXmlBuilder; value : TFhirQuestionnaireItemEnableWhen);
    procedure ComposeQuestionnaireItemAnswerOption(xml : TXmlBuilder; name : string; value : TFhirQuestionnaireItemAnswerOption);
    procedure ComposeQuestionnaireItemAnswerOptionChildren(xml : TXmlBuilder; value : TFhirQuestionnaireItemAnswerOption);
    procedure ComposeQuestionnaireItemInitial(xml : TXmlBuilder; name : string; value : TFhirQuestionnaireItemInitial);
    procedure ComposeQuestionnaireItemInitialChildren(xml : TXmlBuilder; value : TFhirQuestionnaireItemInitial);
    procedure ComposeQuestionnaire(xml : TXmlBuilder; name : string; value : TFhirQuestionnaire);
    procedure ComposeQuestionnaireChildren(xml : TXmlBuilder; value : TFhirQuestionnaire);
{$ENDIF FHIR_QUESTIONNAIRE}
{$IFDEF FHIR_QUESTIONNAIRERESPONSE}
    procedure ComposeQuestionnaireResponseItem(xml : TXmlBuilder; name : string; value : TFhirQuestionnaireResponseItem);
    procedure ComposeQuestionnaireResponseItemChildren(xml : TXmlBuilder; value : TFhirQuestionnaireResponseItem);
    procedure ComposeQuestionnaireResponseItemAnswer(xml : TXmlBuilder; name : string; value : TFhirQuestionnaireResponseItemAnswer);
    procedure ComposeQuestionnaireResponseItemAnswerChildren(xml : TXmlBuilder; value : TFhirQuestionnaireResponseItemAnswer);
    procedure ComposeQuestionnaireResponse(xml : TXmlBuilder; name : string; value : TFhirQuestionnaireResponse);
    procedure ComposeQuestionnaireResponseChildren(xml : TXmlBuilder; value : TFhirQuestionnaireResponse);
{$ENDIF FHIR_QUESTIONNAIRERESPONSE}
{$IFDEF FHIR_REGULATEDAUTHORIZATION}
    procedure ComposeRegulatedAuthorizationCase(xml : TXmlBuilder; name : string; value : TFhirRegulatedAuthorizationCase);
    procedure ComposeRegulatedAuthorizationCaseChildren(xml : TXmlBuilder; value : TFhirRegulatedAuthorizationCase);
    procedure ComposeRegulatedAuthorization(xml : TXmlBuilder; name : string; value : TFhirRegulatedAuthorization);
    procedure ComposeRegulatedAuthorizationChildren(xml : TXmlBuilder; value : TFhirRegulatedAuthorization);
{$ENDIF FHIR_REGULATEDAUTHORIZATION}
{$IFDEF FHIR_RELATEDPERSON}
    procedure ComposeRelatedPersonCommunication(xml : TXmlBuilder; name : string; value : TFhirRelatedPersonCommunication);
    procedure ComposeRelatedPersonCommunicationChildren(xml : TXmlBuilder; value : TFhirRelatedPersonCommunication);
    procedure ComposeRelatedPerson(xml : TXmlBuilder; name : string; value : TFhirRelatedPerson);
    procedure ComposeRelatedPersonChildren(xml : TXmlBuilder; value : TFhirRelatedPerson);
{$ENDIF FHIR_RELATEDPERSON}
{$IFDEF FHIR_REQUESTGROUP}
    procedure ComposeRequestGroupAction(xml : TXmlBuilder; name : string; value : TFhirRequestGroupAction);
    procedure ComposeRequestGroupActionChildren(xml : TXmlBuilder; value : TFhirRequestGroupAction);
    procedure ComposeRequestGroupActionCondition(xml : TXmlBuilder; name : string; value : TFhirRequestGroupActionCondition);
    procedure ComposeRequestGroupActionConditionChildren(xml : TXmlBuilder; value : TFhirRequestGroupActionCondition);
    procedure ComposeRequestGroupActionRelatedAction(xml : TXmlBuilder; name : string; value : TFhirRequestGroupActionRelatedAction);
    procedure ComposeRequestGroupActionRelatedActionChildren(xml : TXmlBuilder; value : TFhirRequestGroupActionRelatedAction);
    procedure ComposeRequestGroupActionParticipant(xml : TXmlBuilder; name : string; value : TFhirRequestGroupActionParticipant);
    procedure ComposeRequestGroupActionParticipantChildren(xml : TXmlBuilder; value : TFhirRequestGroupActionParticipant);
    procedure ComposeRequestGroup(xml : TXmlBuilder; name : string; value : TFhirRequestGroup);
    procedure ComposeRequestGroupChildren(xml : TXmlBuilder; value : TFhirRequestGroup);
{$ENDIF FHIR_REQUESTGROUP}
{$IFDEF FHIR_REQUESTORCHESTRATION}
    procedure ComposeRequestOrchestrationAction(xml : TXmlBuilder; name : string; value : TFhirRequestOrchestrationAction);
    procedure ComposeRequestOrchestrationActionChildren(xml : TXmlBuilder; value : TFhirRequestOrchestrationAction);
    procedure ComposeRequestOrchestrationActionCondition(xml : TXmlBuilder; name : string; value : TFhirRequestOrchestrationActionCondition);
    procedure ComposeRequestOrchestrationActionConditionChildren(xml : TXmlBuilder; value : TFhirRequestOrchestrationActionCondition);
    procedure ComposeRequestOrchestrationActionInput(xml : TXmlBuilder; name : string; value : TFhirRequestOrchestrationActionInput);
    procedure ComposeRequestOrchestrationActionInputChildren(xml : TXmlBuilder; value : TFhirRequestOrchestrationActionInput);
    procedure ComposeRequestOrchestrationActionOutput(xml : TXmlBuilder; name : string; value : TFhirRequestOrchestrationActionOutput);
    procedure ComposeRequestOrchestrationActionOutputChildren(xml : TXmlBuilder; value : TFhirRequestOrchestrationActionOutput);
    procedure ComposeRequestOrchestrationActionRelatedAction(xml : TXmlBuilder; name : string; value : TFhirRequestOrchestrationActionRelatedAction);
    procedure ComposeRequestOrchestrationActionRelatedActionChildren(xml : TXmlBuilder; value : TFhirRequestOrchestrationActionRelatedAction);
    procedure ComposeRequestOrchestrationActionParticipant(xml : TXmlBuilder; name : string; value : TFhirRequestOrchestrationActionParticipant);
    procedure ComposeRequestOrchestrationActionParticipantChildren(xml : TXmlBuilder; value : TFhirRequestOrchestrationActionParticipant);
    procedure ComposeRequestOrchestrationActionDynamicValue(xml : TXmlBuilder; name : string; value : TFhirRequestOrchestrationActionDynamicValue);
    procedure ComposeRequestOrchestrationActionDynamicValueChildren(xml : TXmlBuilder; value : TFhirRequestOrchestrationActionDynamicValue);
    procedure ComposeRequestOrchestration(xml : TXmlBuilder; name : string; value : TFhirRequestOrchestration);
    procedure ComposeRequestOrchestrationChildren(xml : TXmlBuilder; value : TFhirRequestOrchestration);
{$ENDIF FHIR_REQUESTORCHESTRATION}
{$IFDEF FHIR_REQUIREMENTS}
    procedure ComposeRequirementsStatement(xml : TXmlBuilder; name : string; value : TFhirRequirementsStatement);
    procedure ComposeRequirementsStatementChildren(xml : TXmlBuilder; value : TFhirRequirementsStatement);
    procedure ComposeRequirements(xml : TXmlBuilder; name : string; value : TFhirRequirements);
    procedure ComposeRequirementsChildren(xml : TXmlBuilder; value : TFhirRequirements);
{$ENDIF FHIR_REQUIREMENTS}
{$IFDEF FHIR_RESEARCHSTUDY}
    procedure ComposeResearchStudyLabel(xml : TXmlBuilder; name : string; value : TFhirResearchStudyLabel);
    procedure ComposeResearchStudyLabelChildren(xml : TXmlBuilder; value : TFhirResearchStudyLabel);
    procedure ComposeResearchStudyFocus(xml : TXmlBuilder; name : string; value : TFhirResearchStudyFocus);
    procedure ComposeResearchStudyFocusChildren(xml : TXmlBuilder; value : TFhirResearchStudyFocus);
    procedure ComposeResearchStudyAssociatedParty(xml : TXmlBuilder; name : string; value : TFhirResearchStudyAssociatedParty);
    procedure ComposeResearchStudyAssociatedPartyChildren(xml : TXmlBuilder; value : TFhirResearchStudyAssociatedParty);
    procedure ComposeResearchStudyProgressStatus(xml : TXmlBuilder; name : string; value : TFhirResearchStudyProgressStatus);
    procedure ComposeResearchStudyProgressStatusChildren(xml : TXmlBuilder; value : TFhirResearchStudyProgressStatus);
    procedure ComposeResearchStudyRecruitment(xml : TXmlBuilder; name : string; value : TFhirResearchStudyRecruitment);
    procedure ComposeResearchStudyRecruitmentChildren(xml : TXmlBuilder; value : TFhirResearchStudyRecruitment);
    procedure ComposeResearchStudyComparisonGroup(xml : TXmlBuilder; name : string; value : TFhirResearchStudyComparisonGroup);
    procedure ComposeResearchStudyComparisonGroupChildren(xml : TXmlBuilder; value : TFhirResearchStudyComparisonGroup);
    procedure ComposeResearchStudyObjective(xml : TXmlBuilder; name : string; value : TFhirResearchStudyObjective);
    procedure ComposeResearchStudyObjectiveChildren(xml : TXmlBuilder; value : TFhirResearchStudyObjective);
    procedure ComposeResearchStudyOutcomeMeasure(xml : TXmlBuilder; name : string; value : TFhirResearchStudyOutcomeMeasure);
    procedure ComposeResearchStudyOutcomeMeasureChildren(xml : TXmlBuilder; value : TFhirResearchStudyOutcomeMeasure);
    procedure ComposeResearchStudyWebLocation(xml : TXmlBuilder; name : string; value : TFhirResearchStudyWebLocation);
    procedure ComposeResearchStudyWebLocationChildren(xml : TXmlBuilder; value : TFhirResearchStudyWebLocation);
    procedure ComposeResearchStudy(xml : TXmlBuilder; name : string; value : TFhirResearchStudy);
    procedure ComposeResearchStudyChildren(xml : TXmlBuilder; value : TFhirResearchStudy);
{$ENDIF FHIR_RESEARCHSTUDY}
{$IFDEF FHIR_RESEARCHSUBJECT}
    procedure ComposeResearchSubjectProgress(xml : TXmlBuilder; name : string; value : TFhirResearchSubjectProgress);
    procedure ComposeResearchSubjectProgressChildren(xml : TXmlBuilder; value : TFhirResearchSubjectProgress);
    procedure ComposeResearchSubject(xml : TXmlBuilder; name : string; value : TFhirResearchSubject);
    procedure ComposeResearchSubjectChildren(xml : TXmlBuilder; value : TFhirResearchSubject);
{$ENDIF FHIR_RESEARCHSUBJECT}
{$IFDEF FHIR_RISKASSESSMENT}
    procedure ComposeRiskAssessmentPrediction(xml : TXmlBuilder; name : string; value : TFhirRiskAssessmentPrediction);
    procedure ComposeRiskAssessmentPredictionChildren(xml : TXmlBuilder; value : TFhirRiskAssessmentPrediction);
    procedure ComposeRiskAssessment(xml : TXmlBuilder; name : string; value : TFhirRiskAssessment);
    procedure ComposeRiskAssessmentChildren(xml : TXmlBuilder; value : TFhirRiskAssessment);
{$ENDIF FHIR_RISKASSESSMENT}
{$IFDEF FHIR_SCHEDULE}
    procedure ComposeSchedule(xml : TXmlBuilder; name : string; value : TFhirSchedule);
    procedure ComposeScheduleChildren(xml : TXmlBuilder; value : TFhirSchedule);
{$ENDIF FHIR_SCHEDULE}
{$IFDEF FHIR_SEARCHPARAMETER}
    procedure ComposeSearchParameterComponent(xml : TXmlBuilder; name : string; value : TFhirSearchParameterComponent);
    procedure ComposeSearchParameterComponentChildren(xml : TXmlBuilder; value : TFhirSearchParameterComponent);
    procedure ComposeSearchParameter(xml : TXmlBuilder; name : string; value : TFhirSearchParameter);
    procedure ComposeSearchParameterChildren(xml : TXmlBuilder; value : TFhirSearchParameter);
{$ENDIF FHIR_SEARCHPARAMETER}
{$IFDEF FHIR_SERVICEREQUEST}
    procedure ComposeServiceRequest(xml : TXmlBuilder; name : string; value : TFhirServiceRequest);
    procedure ComposeServiceRequestChildren(xml : TXmlBuilder; value : TFhirServiceRequest);
{$ENDIF FHIR_SERVICEREQUEST}
{$IFDEF FHIR_SLOT}
    procedure ComposeSlot(xml : TXmlBuilder; name : string; value : TFhirSlot);
    procedure ComposeSlotChildren(xml : TXmlBuilder; value : TFhirSlot);
{$ENDIF FHIR_SLOT}
{$IFDEF FHIR_SPECIMEN}
    procedure ComposeSpecimenFeature(xml : TXmlBuilder; name : string; value : TFhirSpecimenFeature);
    procedure ComposeSpecimenFeatureChildren(xml : TXmlBuilder; value : TFhirSpecimenFeature);
    procedure ComposeSpecimenCollection(xml : TXmlBuilder; name : string; value : TFhirSpecimenCollection);
    procedure ComposeSpecimenCollectionChildren(xml : TXmlBuilder; value : TFhirSpecimenCollection);
    procedure ComposeSpecimenProcessing(xml : TXmlBuilder; name : string; value : TFhirSpecimenProcessing);
    procedure ComposeSpecimenProcessingChildren(xml : TXmlBuilder; value : TFhirSpecimenProcessing);
    procedure ComposeSpecimenContainer(xml : TXmlBuilder; name : string; value : TFhirSpecimenContainer);
    procedure ComposeSpecimenContainerChildren(xml : TXmlBuilder; value : TFhirSpecimenContainer);
    procedure ComposeSpecimen(xml : TXmlBuilder; name : string; value : TFhirSpecimen);
    procedure ComposeSpecimenChildren(xml : TXmlBuilder; value : TFhirSpecimen);
{$ENDIF FHIR_SPECIMEN}
{$IFDEF FHIR_SPECIMENDEFINITION}
    procedure ComposeSpecimenDefinitionTypeTested(xml : TXmlBuilder; name : string; value : TFhirSpecimenDefinitionTypeTested);
    procedure ComposeSpecimenDefinitionTypeTestedChildren(xml : TXmlBuilder; value : TFhirSpecimenDefinitionTypeTested);
    procedure ComposeSpecimenDefinitionTypeTestedContainer(xml : TXmlBuilder; name : string; value : TFhirSpecimenDefinitionTypeTestedContainer);
    procedure ComposeSpecimenDefinitionTypeTestedContainerChildren(xml : TXmlBuilder; value : TFhirSpecimenDefinitionTypeTestedContainer);
    procedure ComposeSpecimenDefinitionTypeTestedContainerAdditive(xml : TXmlBuilder; name : string; value : TFhirSpecimenDefinitionTypeTestedContainerAdditive);
    procedure ComposeSpecimenDefinitionTypeTestedContainerAdditiveChildren(xml : TXmlBuilder; value : TFhirSpecimenDefinitionTypeTestedContainerAdditive);
    procedure ComposeSpecimenDefinitionTypeTestedHandling(xml : TXmlBuilder; name : string; value : TFhirSpecimenDefinitionTypeTestedHandling);
    procedure ComposeSpecimenDefinitionTypeTestedHandlingChildren(xml : TXmlBuilder; value : TFhirSpecimenDefinitionTypeTestedHandling);
    procedure ComposeSpecimenDefinition(xml : TXmlBuilder; name : string; value : TFhirSpecimenDefinition);
    procedure ComposeSpecimenDefinitionChildren(xml : TXmlBuilder; value : TFhirSpecimenDefinition);
{$ENDIF FHIR_SPECIMENDEFINITION}
{$IFDEF FHIR_STRUCTUREDEFINITION}
    procedure ComposeStructureDefinitionMapping(xml : TXmlBuilder; name : string; value : TFhirStructureDefinitionMapping);
    procedure ComposeStructureDefinitionMappingChildren(xml : TXmlBuilder; value : TFhirStructureDefinitionMapping);
    procedure ComposeStructureDefinitionContext(xml : TXmlBuilder; name : string; value : TFhirStructureDefinitionContext);
    procedure ComposeStructureDefinitionContextChildren(xml : TXmlBuilder; value : TFhirStructureDefinitionContext);
    procedure ComposeStructureDefinitionSnapshot(xml : TXmlBuilder; name : string; value : TFhirStructureDefinitionSnapshot);
    procedure ComposeStructureDefinitionSnapshotChildren(xml : TXmlBuilder; value : TFhirStructureDefinitionSnapshot);
    procedure ComposeStructureDefinitionDifferential(xml : TXmlBuilder; name : string; value : TFhirStructureDefinitionDifferential);
    procedure ComposeStructureDefinitionDifferentialChildren(xml : TXmlBuilder; value : TFhirStructureDefinitionDifferential);
    procedure ComposeStructureDefinition(xml : TXmlBuilder; name : string; value : TFhirStructureDefinition);
    procedure ComposeStructureDefinitionChildren(xml : TXmlBuilder; value : TFhirStructureDefinition);
{$ENDIF FHIR_STRUCTUREDEFINITION}
{$IFDEF FHIR_STRUCTUREMAP}
    procedure ComposeStructureMapStructure(xml : TXmlBuilder; name : string; value : TFhirStructureMapStructure);
    procedure ComposeStructureMapStructureChildren(xml : TXmlBuilder; value : TFhirStructureMapStructure);
    procedure ComposeStructureMapGroup(xml : TXmlBuilder; name : string; value : TFhirStructureMapGroup);
    procedure ComposeStructureMapGroupChildren(xml : TXmlBuilder; value : TFhirStructureMapGroup);
    procedure ComposeStructureMapGroupInput(xml : TXmlBuilder; name : string; value : TFhirStructureMapGroupInput);
    procedure ComposeStructureMapGroupInputChildren(xml : TXmlBuilder; value : TFhirStructureMapGroupInput);
    procedure ComposeStructureMapGroupRule(xml : TXmlBuilder; name : string; value : TFhirStructureMapGroupRule);
    procedure ComposeStructureMapGroupRuleChildren(xml : TXmlBuilder; value : TFhirStructureMapGroupRule);
    procedure ComposeStructureMapGroupRuleSource(xml : TXmlBuilder; name : string; value : TFhirStructureMapGroupRuleSource);
    procedure ComposeStructureMapGroupRuleSourceChildren(xml : TXmlBuilder; value : TFhirStructureMapGroupRuleSource);
    procedure ComposeStructureMapGroupRuleTarget(xml : TXmlBuilder; name : string; value : TFhirStructureMapGroupRuleTarget);
    procedure ComposeStructureMapGroupRuleTargetChildren(xml : TXmlBuilder; value : TFhirStructureMapGroupRuleTarget);
    procedure ComposeStructureMapGroupRuleTargetParameter(xml : TXmlBuilder; name : string; value : TFhirStructureMapGroupRuleTargetParameter);
    procedure ComposeStructureMapGroupRuleTargetParameterChildren(xml : TXmlBuilder; value : TFhirStructureMapGroupRuleTargetParameter);
    procedure ComposeStructureMapGroupRuleDependent(xml : TXmlBuilder; name : string; value : TFhirStructureMapGroupRuleDependent);
    procedure ComposeStructureMapGroupRuleDependentChildren(xml : TXmlBuilder; value : TFhirStructureMapGroupRuleDependent);
    procedure ComposeStructureMap(xml : TXmlBuilder; name : string; value : TFhirStructureMap);
    procedure ComposeStructureMapChildren(xml : TXmlBuilder; value : TFhirStructureMap);
{$ENDIF FHIR_STRUCTUREMAP}
{$IFDEF FHIR_SUBSCRIPTION}
    procedure ComposeSubscriptionFilterBy(xml : TXmlBuilder; name : string; value : TFhirSubscriptionFilterBy);
    procedure ComposeSubscriptionFilterByChildren(xml : TXmlBuilder; value : TFhirSubscriptionFilterBy);
    procedure ComposeSubscription(xml : TXmlBuilder; name : string; value : TFhirSubscription);
    procedure ComposeSubscriptionChildren(xml : TXmlBuilder; value : TFhirSubscription);
{$ENDIF FHIR_SUBSCRIPTION}
{$IFDEF FHIR_SUBSCRIPTIONSTATUS}
    procedure ComposeSubscriptionStatusNotificationEvent(xml : TXmlBuilder; name : string; value : TFhirSubscriptionStatusNotificationEvent);
    procedure ComposeSubscriptionStatusNotificationEventChildren(xml : TXmlBuilder; value : TFhirSubscriptionStatusNotificationEvent);
    procedure ComposeSubscriptionStatus(xml : TXmlBuilder; name : string; value : TFhirSubscriptionStatus);
    procedure ComposeSubscriptionStatusChildren(xml : TXmlBuilder; value : TFhirSubscriptionStatus);
{$ENDIF FHIR_SUBSCRIPTIONSTATUS}
{$IFDEF FHIR_SUBSCRIPTIONTOPIC}
    procedure ComposeSubscriptionTopicResourceTrigger(xml : TXmlBuilder; name : string; value : TFhirSubscriptionTopicResourceTrigger);
    procedure ComposeSubscriptionTopicResourceTriggerChildren(xml : TXmlBuilder; value : TFhirSubscriptionTopicResourceTrigger);
    procedure ComposeSubscriptionTopicResourceTriggerQueryCriteria(xml : TXmlBuilder; name : string; value : TFhirSubscriptionTopicResourceTriggerQueryCriteria);
    procedure ComposeSubscriptionTopicResourceTriggerQueryCriteriaChildren(xml : TXmlBuilder; value : TFhirSubscriptionTopicResourceTriggerQueryCriteria);
    procedure ComposeSubscriptionTopicEventTrigger(xml : TXmlBuilder; name : string; value : TFhirSubscriptionTopicEventTrigger);
    procedure ComposeSubscriptionTopicEventTriggerChildren(xml : TXmlBuilder; value : TFhirSubscriptionTopicEventTrigger);
    procedure ComposeSubscriptionTopicCanFilterBy(xml : TXmlBuilder; name : string; value : TFhirSubscriptionTopicCanFilterBy);
    procedure ComposeSubscriptionTopicCanFilterByChildren(xml : TXmlBuilder; value : TFhirSubscriptionTopicCanFilterBy);
    procedure ComposeSubscriptionTopicNotificationShape(xml : TXmlBuilder; name : string; value : TFhirSubscriptionTopicNotificationShape);
    procedure ComposeSubscriptionTopicNotificationShapeChildren(xml : TXmlBuilder; value : TFhirSubscriptionTopicNotificationShape);
    procedure ComposeSubscriptionTopic(xml : TXmlBuilder; name : string; value : TFhirSubscriptionTopic);
    procedure ComposeSubscriptionTopicChildren(xml : TXmlBuilder; value : TFhirSubscriptionTopic);
{$ENDIF FHIR_SUBSCRIPTIONTOPIC}
{$IFDEF FHIR_SUBSTANCE}
    procedure ComposeSubstanceIngredient(xml : TXmlBuilder; name : string; value : TFhirSubstanceIngredient);
    procedure ComposeSubstanceIngredientChildren(xml : TXmlBuilder; value : TFhirSubstanceIngredient);
    procedure ComposeSubstance(xml : TXmlBuilder; name : string; value : TFhirSubstance);
    procedure ComposeSubstanceChildren(xml : TXmlBuilder; value : TFhirSubstance);
{$ENDIF FHIR_SUBSTANCE}
{$IFDEF FHIR_SUBSTANCEDEFINITION}
    procedure ComposeSubstanceDefinitionMoiety(xml : TXmlBuilder; name : string; value : TFhirSubstanceDefinitionMoiety);
    procedure ComposeSubstanceDefinitionMoietyChildren(xml : TXmlBuilder; value : TFhirSubstanceDefinitionMoiety);
    procedure ComposeSubstanceDefinitionProperty(xml : TXmlBuilder; name : string; value : TFhirSubstanceDefinitionProperty);
    procedure ComposeSubstanceDefinitionPropertyChildren(xml : TXmlBuilder; value : TFhirSubstanceDefinitionProperty);
    procedure ComposeSubstanceDefinitionMolecularWeight(xml : TXmlBuilder; name : string; value : TFhirSubstanceDefinitionMolecularWeight);
    procedure ComposeSubstanceDefinitionMolecularWeightChildren(xml : TXmlBuilder; value : TFhirSubstanceDefinitionMolecularWeight);
    procedure ComposeSubstanceDefinitionStructure(xml : TXmlBuilder; name : string; value : TFhirSubstanceDefinitionStructure);
    procedure ComposeSubstanceDefinitionStructureChildren(xml : TXmlBuilder; value : TFhirSubstanceDefinitionStructure);
    procedure ComposeSubstanceDefinitionStructureRepresentation(xml : TXmlBuilder; name : string; value : TFhirSubstanceDefinitionStructureRepresentation);
    procedure ComposeSubstanceDefinitionStructureRepresentationChildren(xml : TXmlBuilder; value : TFhirSubstanceDefinitionStructureRepresentation);
    procedure ComposeSubstanceDefinitionCode(xml : TXmlBuilder; name : string; value : TFhirSubstanceDefinitionCode);
    procedure ComposeSubstanceDefinitionCodeChildren(xml : TXmlBuilder; value : TFhirSubstanceDefinitionCode);
    procedure ComposeSubstanceDefinitionName(xml : TXmlBuilder; name : string; value : TFhirSubstanceDefinitionName);
    procedure ComposeSubstanceDefinitionNameChildren(xml : TXmlBuilder; value : TFhirSubstanceDefinitionName);
    procedure ComposeSubstanceDefinitionNameOfficial(xml : TXmlBuilder; name : string; value : TFhirSubstanceDefinitionNameOfficial);
    procedure ComposeSubstanceDefinitionNameOfficialChildren(xml : TXmlBuilder; value : TFhirSubstanceDefinitionNameOfficial);
    procedure ComposeSubstanceDefinitionRelationship(xml : TXmlBuilder; name : string; value : TFhirSubstanceDefinitionRelationship);
    procedure ComposeSubstanceDefinitionRelationshipChildren(xml : TXmlBuilder; value : TFhirSubstanceDefinitionRelationship);
    procedure ComposeSubstanceDefinitionSourceMaterial(xml : TXmlBuilder; name : string; value : TFhirSubstanceDefinitionSourceMaterial);
    procedure ComposeSubstanceDefinitionSourceMaterialChildren(xml : TXmlBuilder; value : TFhirSubstanceDefinitionSourceMaterial);
    procedure ComposeSubstanceDefinition(xml : TXmlBuilder; name : string; value : TFhirSubstanceDefinition);
    procedure ComposeSubstanceDefinitionChildren(xml : TXmlBuilder; value : TFhirSubstanceDefinition);
{$ENDIF FHIR_SUBSTANCEDEFINITION}
{$IFDEF FHIR_SUBSTANCENUCLEICACID}
    procedure ComposeSubstanceNucleicAcidSubunit(xml : TXmlBuilder; name : string; value : TFhirSubstanceNucleicAcidSubunit);
    procedure ComposeSubstanceNucleicAcidSubunitChildren(xml : TXmlBuilder; value : TFhirSubstanceNucleicAcidSubunit);
    procedure ComposeSubstanceNucleicAcidSubunitLinkage(xml : TXmlBuilder; name : string; value : TFhirSubstanceNucleicAcidSubunitLinkage);
    procedure ComposeSubstanceNucleicAcidSubunitLinkageChildren(xml : TXmlBuilder; value : TFhirSubstanceNucleicAcidSubunitLinkage);
    procedure ComposeSubstanceNucleicAcidSubunitSugar(xml : TXmlBuilder; name : string; value : TFhirSubstanceNucleicAcidSubunitSugar);
    procedure ComposeSubstanceNucleicAcidSubunitSugarChildren(xml : TXmlBuilder; value : TFhirSubstanceNucleicAcidSubunitSugar);
    procedure ComposeSubstanceNucleicAcid(xml : TXmlBuilder; name : string; value : TFhirSubstanceNucleicAcid);
    procedure ComposeSubstanceNucleicAcidChildren(xml : TXmlBuilder; value : TFhirSubstanceNucleicAcid);
{$ENDIF FHIR_SUBSTANCENUCLEICACID}
{$IFDEF FHIR_SUBSTANCEPOLYMER}
    procedure ComposeSubstancePolymerMonomerSet(xml : TXmlBuilder; name : string; value : TFhirSubstancePolymerMonomerSet);
    procedure ComposeSubstancePolymerMonomerSetChildren(xml : TXmlBuilder; value : TFhirSubstancePolymerMonomerSet);
    procedure ComposeSubstancePolymerMonomerSetStartingMaterial(xml : TXmlBuilder; name : string; value : TFhirSubstancePolymerMonomerSetStartingMaterial);
    procedure ComposeSubstancePolymerMonomerSetStartingMaterialChildren(xml : TXmlBuilder; value : TFhirSubstancePolymerMonomerSetStartingMaterial);
    procedure ComposeSubstancePolymerRepeat(xml : TXmlBuilder; name : string; value : TFhirSubstancePolymerRepeat);
    procedure ComposeSubstancePolymerRepeatChildren(xml : TXmlBuilder; value : TFhirSubstancePolymerRepeat);
    procedure ComposeSubstancePolymerRepeatRepeatUnit(xml : TXmlBuilder; name : string; value : TFhirSubstancePolymerRepeatRepeatUnit);
    procedure ComposeSubstancePolymerRepeatRepeatUnitChildren(xml : TXmlBuilder; value : TFhirSubstancePolymerRepeatRepeatUnit);
    procedure ComposeSubstancePolymerRepeatRepeatUnitDegreeOfPolymerisation(xml : TXmlBuilder; name : string; value : TFhirSubstancePolymerRepeatRepeatUnitDegreeOfPolymerisation);
    procedure ComposeSubstancePolymerRepeatRepeatUnitDegreeOfPolymerisationChildren(xml : TXmlBuilder; value : TFhirSubstancePolymerRepeatRepeatUnitDegreeOfPolymerisation);
    procedure ComposeSubstancePolymerRepeatRepeatUnitStructuralRepresentation(xml : TXmlBuilder; name : string; value : TFhirSubstancePolymerRepeatRepeatUnitStructuralRepresentation);
    procedure ComposeSubstancePolymerRepeatRepeatUnitStructuralRepresentationChildren(xml : TXmlBuilder; value : TFhirSubstancePolymerRepeatRepeatUnitStructuralRepresentation);
    procedure ComposeSubstancePolymer(xml : TXmlBuilder; name : string; value : TFhirSubstancePolymer);
    procedure ComposeSubstancePolymerChildren(xml : TXmlBuilder; value : TFhirSubstancePolymer);
{$ENDIF FHIR_SUBSTANCEPOLYMER}
{$IFDEF FHIR_SUBSTANCEPROTEIN}
    procedure ComposeSubstanceProteinSubunit(xml : TXmlBuilder; name : string; value : TFhirSubstanceProteinSubunit);
    procedure ComposeSubstanceProteinSubunitChildren(xml : TXmlBuilder; value : TFhirSubstanceProteinSubunit);
    procedure ComposeSubstanceProtein(xml : TXmlBuilder; name : string; value : TFhirSubstanceProtein);
    procedure ComposeSubstanceProteinChildren(xml : TXmlBuilder; value : TFhirSubstanceProtein);
{$ENDIF FHIR_SUBSTANCEPROTEIN}
{$IFDEF FHIR_SUBSTANCEREFERENCEINFORMATION}
    procedure ComposeSubstanceReferenceInformationGene(xml : TXmlBuilder; name : string; value : TFhirSubstanceReferenceInformationGene);
    procedure ComposeSubstanceReferenceInformationGeneChildren(xml : TXmlBuilder; value : TFhirSubstanceReferenceInformationGene);
    procedure ComposeSubstanceReferenceInformationGeneElement(xml : TXmlBuilder; name : string; value : TFhirSubstanceReferenceInformationGeneElement);
    procedure ComposeSubstanceReferenceInformationGeneElementChildren(xml : TXmlBuilder; value : TFhirSubstanceReferenceInformationGeneElement);
    procedure ComposeSubstanceReferenceInformationTarget(xml : TXmlBuilder; name : string; value : TFhirSubstanceReferenceInformationTarget);
    procedure ComposeSubstanceReferenceInformationTargetChildren(xml : TXmlBuilder; value : TFhirSubstanceReferenceInformationTarget);
    procedure ComposeSubstanceReferenceInformation(xml : TXmlBuilder; name : string; value : TFhirSubstanceReferenceInformation);
    procedure ComposeSubstanceReferenceInformationChildren(xml : TXmlBuilder; value : TFhirSubstanceReferenceInformation);
{$ENDIF FHIR_SUBSTANCEREFERENCEINFORMATION}
{$IFDEF FHIR_SUBSTANCESOURCEMATERIAL}
    procedure ComposeSubstanceSourceMaterialFractionDescription(xml : TXmlBuilder; name : string; value : TFhirSubstanceSourceMaterialFractionDescription);
    procedure ComposeSubstanceSourceMaterialFractionDescriptionChildren(xml : TXmlBuilder; value : TFhirSubstanceSourceMaterialFractionDescription);
    procedure ComposeSubstanceSourceMaterialOrganism(xml : TXmlBuilder; name : string; value : TFhirSubstanceSourceMaterialOrganism);
    procedure ComposeSubstanceSourceMaterialOrganismChildren(xml : TXmlBuilder; value : TFhirSubstanceSourceMaterialOrganism);
    procedure ComposeSubstanceSourceMaterialOrganismAuthor(xml : TXmlBuilder; name : string; value : TFhirSubstanceSourceMaterialOrganismAuthor);
    procedure ComposeSubstanceSourceMaterialOrganismAuthorChildren(xml : TXmlBuilder; value : TFhirSubstanceSourceMaterialOrganismAuthor);
    procedure ComposeSubstanceSourceMaterialOrganismHybrid(xml : TXmlBuilder; name : string; value : TFhirSubstanceSourceMaterialOrganismHybrid);
    procedure ComposeSubstanceSourceMaterialOrganismHybridChildren(xml : TXmlBuilder; value : TFhirSubstanceSourceMaterialOrganismHybrid);
    procedure ComposeSubstanceSourceMaterialOrganismOrganismGeneral(xml : TXmlBuilder; name : string; value : TFhirSubstanceSourceMaterialOrganismOrganismGeneral);
    procedure ComposeSubstanceSourceMaterialOrganismOrganismGeneralChildren(xml : TXmlBuilder; value : TFhirSubstanceSourceMaterialOrganismOrganismGeneral);
    procedure ComposeSubstanceSourceMaterialPartDescription(xml : TXmlBuilder; name : string; value : TFhirSubstanceSourceMaterialPartDescription);
    procedure ComposeSubstanceSourceMaterialPartDescriptionChildren(xml : TXmlBuilder; value : TFhirSubstanceSourceMaterialPartDescription);
    procedure ComposeSubstanceSourceMaterial(xml : TXmlBuilder; name : string; value : TFhirSubstanceSourceMaterial);
    procedure ComposeSubstanceSourceMaterialChildren(xml : TXmlBuilder; value : TFhirSubstanceSourceMaterial);
{$ENDIF FHIR_SUBSTANCESOURCEMATERIAL}
{$IFDEF FHIR_SUPPLYDELIVERY}
    procedure ComposeSupplyDeliverySuppliedItem(xml : TXmlBuilder; name : string; value : TFhirSupplyDeliverySuppliedItem);
    procedure ComposeSupplyDeliverySuppliedItemChildren(xml : TXmlBuilder; value : TFhirSupplyDeliverySuppliedItem);
    procedure ComposeSupplyDelivery(xml : TXmlBuilder; name : string; value : TFhirSupplyDelivery);
    procedure ComposeSupplyDeliveryChildren(xml : TXmlBuilder; value : TFhirSupplyDelivery);
{$ENDIF FHIR_SUPPLYDELIVERY}
{$IFDEF FHIR_SUPPLYREQUEST}
    procedure ComposeSupplyRequestParameter(xml : TXmlBuilder; name : string; value : TFhirSupplyRequestParameter);
    procedure ComposeSupplyRequestParameterChildren(xml : TXmlBuilder; value : TFhirSupplyRequestParameter);
    procedure ComposeSupplyRequest(xml : TXmlBuilder; name : string; value : TFhirSupplyRequest);
    procedure ComposeSupplyRequestChildren(xml : TXmlBuilder; value : TFhirSupplyRequest);
{$ENDIF FHIR_SUPPLYREQUEST}
{$IFDEF FHIR_TASK}
    procedure ComposeTaskRestriction(xml : TXmlBuilder; name : string; value : TFhirTaskRestriction);
    procedure ComposeTaskRestrictionChildren(xml : TXmlBuilder; value : TFhirTaskRestriction);
    procedure ComposeTaskInput(xml : TXmlBuilder; name : string; value : TFhirTaskInput);
    procedure ComposeTaskInputChildren(xml : TXmlBuilder; value : TFhirTaskInput);
    procedure ComposeTaskOutput(xml : TXmlBuilder; name : string; value : TFhirTaskOutput);
    procedure ComposeTaskOutputChildren(xml : TXmlBuilder; value : TFhirTaskOutput);
    procedure ComposeTask(xml : TXmlBuilder; name : string; value : TFhirTask);
    procedure ComposeTaskChildren(xml : TXmlBuilder; value : TFhirTask);
{$ENDIF FHIR_TASK}
{$IFDEF FHIR_TERMINOLOGYCAPABILITIES}
    procedure ComposeTerminologyCapabilitiesSoftware(xml : TXmlBuilder; name : string; value : TFhirTerminologyCapabilitiesSoftware);
    procedure ComposeTerminologyCapabilitiesSoftwareChildren(xml : TXmlBuilder; value : TFhirTerminologyCapabilitiesSoftware);
    procedure ComposeTerminologyCapabilitiesImplementation(xml : TXmlBuilder; name : string; value : TFhirTerminologyCapabilitiesImplementation);
    procedure ComposeTerminologyCapabilitiesImplementationChildren(xml : TXmlBuilder; value : TFhirTerminologyCapabilitiesImplementation);
    procedure ComposeTerminologyCapabilitiesCodeSystem(xml : TXmlBuilder; name : string; value : TFhirTerminologyCapabilitiesCodeSystem);
    procedure ComposeTerminologyCapabilitiesCodeSystemChildren(xml : TXmlBuilder; value : TFhirTerminologyCapabilitiesCodeSystem);
    procedure ComposeTerminologyCapabilitiesCodeSystemVersion(xml : TXmlBuilder; name : string; value : TFhirTerminologyCapabilitiesCodeSystemVersion);
    procedure ComposeTerminologyCapabilitiesCodeSystemVersionChildren(xml : TXmlBuilder; value : TFhirTerminologyCapabilitiesCodeSystemVersion);
    procedure ComposeTerminologyCapabilitiesCodeSystemVersionFilter(xml : TXmlBuilder; name : string; value : TFhirTerminologyCapabilitiesCodeSystemVersionFilter);
    procedure ComposeTerminologyCapabilitiesCodeSystemVersionFilterChildren(xml : TXmlBuilder; value : TFhirTerminologyCapabilitiesCodeSystemVersionFilter);
    procedure ComposeTerminologyCapabilitiesExpansion(xml : TXmlBuilder; name : string; value : TFhirTerminologyCapabilitiesExpansion);
    procedure ComposeTerminologyCapabilitiesExpansionChildren(xml : TXmlBuilder; value : TFhirTerminologyCapabilitiesExpansion);
    procedure ComposeTerminologyCapabilitiesExpansionParameter(xml : TXmlBuilder; name : string; value : TFhirTerminologyCapabilitiesExpansionParameter);
    procedure ComposeTerminologyCapabilitiesExpansionParameterChildren(xml : TXmlBuilder; value : TFhirTerminologyCapabilitiesExpansionParameter);
    procedure ComposeTerminologyCapabilitiesValidateCode(xml : TXmlBuilder; name : string; value : TFhirTerminologyCapabilitiesValidateCode);
    procedure ComposeTerminologyCapabilitiesValidateCodeChildren(xml : TXmlBuilder; value : TFhirTerminologyCapabilitiesValidateCode);
    procedure ComposeTerminologyCapabilitiesTranslation(xml : TXmlBuilder; name : string; value : TFhirTerminologyCapabilitiesTranslation);
    procedure ComposeTerminologyCapabilitiesTranslationChildren(xml : TXmlBuilder; value : TFhirTerminologyCapabilitiesTranslation);
    procedure ComposeTerminologyCapabilitiesClosure(xml : TXmlBuilder; name : string; value : TFhirTerminologyCapabilitiesClosure);
    procedure ComposeTerminologyCapabilitiesClosureChildren(xml : TXmlBuilder; value : TFhirTerminologyCapabilitiesClosure);
    procedure ComposeTerminologyCapabilities(xml : TXmlBuilder; name : string; value : TFhirTerminologyCapabilities);
    procedure ComposeTerminologyCapabilitiesChildren(xml : TXmlBuilder; value : TFhirTerminologyCapabilities);
{$ENDIF FHIR_TERMINOLOGYCAPABILITIES}
{$IFDEF FHIR_TESTREPORT}
    procedure ComposeTestReportParticipant(xml : TXmlBuilder; name : string; value : TFhirTestReportParticipant);
    procedure ComposeTestReportParticipantChildren(xml : TXmlBuilder; value : TFhirTestReportParticipant);
    procedure ComposeTestReportSetup(xml : TXmlBuilder; name : string; value : TFhirTestReportSetup);
    procedure ComposeTestReportSetupChildren(xml : TXmlBuilder; value : TFhirTestReportSetup);
    procedure ComposeTestReportSetupAction(xml : TXmlBuilder; name : string; value : TFhirTestReportSetupAction);
    procedure ComposeTestReportSetupActionChildren(xml : TXmlBuilder; value : TFhirTestReportSetupAction);
    procedure ComposeTestReportSetupActionOperation(xml : TXmlBuilder; name : string; value : TFhirTestReportSetupActionOperation);
    procedure ComposeTestReportSetupActionOperationChildren(xml : TXmlBuilder; value : TFhirTestReportSetupActionOperation);
    procedure ComposeTestReportSetupActionAssert(xml : TXmlBuilder; name : string; value : TFhirTestReportSetupActionAssert);
    procedure ComposeTestReportSetupActionAssertChildren(xml : TXmlBuilder; value : TFhirTestReportSetupActionAssert);
    procedure ComposeTestReportTest(xml : TXmlBuilder; name : string; value : TFhirTestReportTest);
    procedure ComposeTestReportTestChildren(xml : TXmlBuilder; value : TFhirTestReportTest);
    procedure ComposeTestReportTestAction(xml : TXmlBuilder; name : string; value : TFhirTestReportTestAction);
    procedure ComposeTestReportTestActionChildren(xml : TXmlBuilder; value : TFhirTestReportTestAction);
    procedure ComposeTestReportTeardown(xml : TXmlBuilder; name : string; value : TFhirTestReportTeardown);
    procedure ComposeTestReportTeardownChildren(xml : TXmlBuilder; value : TFhirTestReportTeardown);
    procedure ComposeTestReportTeardownAction(xml : TXmlBuilder; name : string; value : TFhirTestReportTeardownAction);
    procedure ComposeTestReportTeardownActionChildren(xml : TXmlBuilder; value : TFhirTestReportTeardownAction);
    procedure ComposeTestReport(xml : TXmlBuilder; name : string; value : TFhirTestReport);
    procedure ComposeTestReportChildren(xml : TXmlBuilder; value : TFhirTestReport);
{$ENDIF FHIR_TESTREPORT}
{$IFDEF FHIR_TESTSCRIPT}
    procedure ComposeTestScriptOrigin(xml : TXmlBuilder; name : string; value : TFhirTestScriptOrigin);
    procedure ComposeTestScriptOriginChildren(xml : TXmlBuilder; value : TFhirTestScriptOrigin);
    procedure ComposeTestScriptDestination(xml : TXmlBuilder; name : string; value : TFhirTestScriptDestination);
    procedure ComposeTestScriptDestinationChildren(xml : TXmlBuilder; value : TFhirTestScriptDestination);
    procedure ComposeTestScriptMetadata(xml : TXmlBuilder; name : string; value : TFhirTestScriptMetadata);
    procedure ComposeTestScriptMetadataChildren(xml : TXmlBuilder; value : TFhirTestScriptMetadata);
    procedure ComposeTestScriptMetadataLink(xml : TXmlBuilder; name : string; value : TFhirTestScriptMetadataLink);
    procedure ComposeTestScriptMetadataLinkChildren(xml : TXmlBuilder; value : TFhirTestScriptMetadataLink);
    procedure ComposeTestScriptMetadataCapability(xml : TXmlBuilder; name : string; value : TFhirTestScriptMetadataCapability);
    procedure ComposeTestScriptMetadataCapabilityChildren(xml : TXmlBuilder; value : TFhirTestScriptMetadataCapability);
    procedure ComposeTestScriptScope(xml : TXmlBuilder; name : string; value : TFhirTestScriptScope);
    procedure ComposeTestScriptScopeChildren(xml : TXmlBuilder; value : TFhirTestScriptScope);
    procedure ComposeTestScriptFixture(xml : TXmlBuilder; name : string; value : TFhirTestScriptFixture);
    procedure ComposeTestScriptFixtureChildren(xml : TXmlBuilder; value : TFhirTestScriptFixture);
    procedure ComposeTestScriptVariable(xml : TXmlBuilder; name : string; value : TFhirTestScriptVariable);
    procedure ComposeTestScriptVariableChildren(xml : TXmlBuilder; value : TFhirTestScriptVariable);
    procedure ComposeTestScriptSetup(xml : TXmlBuilder; name : string; value : TFhirTestScriptSetup);
    procedure ComposeTestScriptSetupChildren(xml : TXmlBuilder; value : TFhirTestScriptSetup);
    procedure ComposeTestScriptSetupAction(xml : TXmlBuilder; name : string; value : TFhirTestScriptSetupAction);
    procedure ComposeTestScriptSetupActionChildren(xml : TXmlBuilder; value : TFhirTestScriptSetupAction);
    procedure ComposeTestScriptSetupActionOperation(xml : TXmlBuilder; name : string; value : TFhirTestScriptSetupActionOperation);
    procedure ComposeTestScriptSetupActionOperationChildren(xml : TXmlBuilder; value : TFhirTestScriptSetupActionOperation);
    procedure ComposeTestScriptSetupActionOperationRequestHeader(xml : TXmlBuilder; name : string; value : TFhirTestScriptSetupActionOperationRequestHeader);
    procedure ComposeTestScriptSetupActionOperationRequestHeaderChildren(xml : TXmlBuilder; value : TFhirTestScriptSetupActionOperationRequestHeader);
    procedure ComposeTestScriptSetupActionAssert(xml : TXmlBuilder; name : string; value : TFhirTestScriptSetupActionAssert);
    procedure ComposeTestScriptSetupActionAssertChildren(xml : TXmlBuilder; value : TFhirTestScriptSetupActionAssert);
    procedure ComposeTestScriptTest(xml : TXmlBuilder; name : string; value : TFhirTestScriptTest);
    procedure ComposeTestScriptTestChildren(xml : TXmlBuilder; value : TFhirTestScriptTest);
    procedure ComposeTestScriptTestAction(xml : TXmlBuilder; name : string; value : TFhirTestScriptTestAction);
    procedure ComposeTestScriptTestActionChildren(xml : TXmlBuilder; value : TFhirTestScriptTestAction);
    procedure ComposeTestScriptTeardown(xml : TXmlBuilder; name : string; value : TFhirTestScriptTeardown);
    procedure ComposeTestScriptTeardownChildren(xml : TXmlBuilder; value : TFhirTestScriptTeardown);
    procedure ComposeTestScriptTeardownAction(xml : TXmlBuilder; name : string; value : TFhirTestScriptTeardownAction);
    procedure ComposeTestScriptTeardownActionChildren(xml : TXmlBuilder; value : TFhirTestScriptTeardownAction);
    procedure ComposeTestScript(xml : TXmlBuilder; name : string; value : TFhirTestScript);
    procedure ComposeTestScriptChildren(xml : TXmlBuilder; value : TFhirTestScript);
{$ENDIF FHIR_TESTSCRIPT}
{$IFDEF FHIR_TRANSPORT}
    procedure ComposeTransportRestriction(xml : TXmlBuilder; name : string; value : TFhirTransportRestriction);
    procedure ComposeTransportRestrictionChildren(xml : TXmlBuilder; value : TFhirTransportRestriction);
    procedure ComposeTransportInput(xml : TXmlBuilder; name : string; value : TFhirTransportInput);
    procedure ComposeTransportInputChildren(xml : TXmlBuilder; value : TFhirTransportInput);
    procedure ComposeTransportOutput(xml : TXmlBuilder; name : string; value : TFhirTransportOutput);
    procedure ComposeTransportOutputChildren(xml : TXmlBuilder; value : TFhirTransportOutput);
    procedure ComposeTransport(xml : TXmlBuilder; name : string; value : TFhirTransport);
    procedure ComposeTransportChildren(xml : TXmlBuilder; value : TFhirTransport);
{$ENDIF FHIR_TRANSPORT}
{$IFDEF FHIR_VALUESET}
    procedure ComposeValueSetCompose(xml : TXmlBuilder; name : string; value : TFhirValueSetCompose);
    procedure ComposeValueSetComposeChildren(xml : TXmlBuilder; value : TFhirValueSetCompose);
    procedure ComposeValueSetComposeInclude(xml : TXmlBuilder; name : string; value : TFhirValueSetComposeInclude);
    procedure ComposeValueSetComposeIncludeChildren(xml : TXmlBuilder; value : TFhirValueSetComposeInclude);
    procedure ComposeValueSetComposeIncludeConcept(xml : TXmlBuilder; name : string; value : TFhirValueSetComposeIncludeConcept);
    procedure ComposeValueSetComposeIncludeConceptChildren(xml : TXmlBuilder; value : TFhirValueSetComposeIncludeConcept);
    procedure ComposeValueSetComposeIncludeConceptDesignation(xml : TXmlBuilder; name : string; value : TFhirValueSetComposeIncludeConceptDesignation);
    procedure ComposeValueSetComposeIncludeConceptDesignationChildren(xml : TXmlBuilder; value : TFhirValueSetComposeIncludeConceptDesignation);
    procedure ComposeValueSetComposeIncludeFilter(xml : TXmlBuilder; name : string; value : TFhirValueSetComposeIncludeFilter);
    procedure ComposeValueSetComposeIncludeFilterChildren(xml : TXmlBuilder; value : TFhirValueSetComposeIncludeFilter);
    procedure ComposeValueSetExpansion(xml : TXmlBuilder; name : string; value : TFhirValueSetExpansion);
    procedure ComposeValueSetExpansionChildren(xml : TXmlBuilder; value : TFhirValueSetExpansion);
    procedure ComposeValueSetExpansionParameter(xml : TXmlBuilder; name : string; value : TFhirValueSetExpansionParameter);
    procedure ComposeValueSetExpansionParameterChildren(xml : TXmlBuilder; value : TFhirValueSetExpansionParameter);
    procedure ComposeValueSetExpansionProperty(xml : TXmlBuilder; name : string; value : TFhirValueSetExpansionProperty);
    procedure ComposeValueSetExpansionPropertyChildren(xml : TXmlBuilder; value : TFhirValueSetExpansionProperty);
    procedure ComposeValueSetExpansionContains(xml : TXmlBuilder; name : string; value : TFhirValueSetExpansionContains);
    procedure ComposeValueSetExpansionContainsChildren(xml : TXmlBuilder; value : TFhirValueSetExpansionContains);
    procedure ComposeValueSetExpansionContainsProperty(xml : TXmlBuilder; name : string; value : TFhirValueSetExpansionContainsProperty);
    procedure ComposeValueSetExpansionContainsPropertyChildren(xml : TXmlBuilder; value : TFhirValueSetExpansionContainsProperty);
    procedure ComposeValueSetExpansionContainsPropertySubProperty(xml : TXmlBuilder; name : string; value : TFhirValueSetExpansionContainsPropertySubProperty);
    procedure ComposeValueSetExpansionContainsPropertySubPropertyChildren(xml : TXmlBuilder; value : TFhirValueSetExpansionContainsPropertySubProperty);
    procedure ComposeValueSetScope(xml : TXmlBuilder; name : string; value : TFhirValueSetScope);
    procedure ComposeValueSetScopeChildren(xml : TXmlBuilder; value : TFhirValueSetScope);
    procedure ComposeValueSet(xml : TXmlBuilder; name : string; value : TFhirValueSet);
    procedure ComposeValueSetChildren(xml : TXmlBuilder; value : TFhirValueSet);
{$ENDIF FHIR_VALUESET}
{$IFDEF FHIR_VERIFICATIONRESULT}
    procedure ComposeVerificationResultPrimarySource(xml : TXmlBuilder; name : string; value : TFhirVerificationResultPrimarySource);
    procedure ComposeVerificationResultPrimarySourceChildren(xml : TXmlBuilder; value : TFhirVerificationResultPrimarySource);
    procedure ComposeVerificationResultAttestation(xml : TXmlBuilder; name : string; value : TFhirVerificationResultAttestation);
    procedure ComposeVerificationResultAttestationChildren(xml : TXmlBuilder; value : TFhirVerificationResultAttestation);
    procedure ComposeVerificationResultValidator(xml : TXmlBuilder; name : string; value : TFhirVerificationResultValidator);
    procedure ComposeVerificationResultValidatorChildren(xml : TXmlBuilder; value : TFhirVerificationResultValidator);
    procedure ComposeVerificationResult(xml : TXmlBuilder; name : string; value : TFhirVerificationResult);
    procedure ComposeVerificationResultChildren(xml : TXmlBuilder; value : TFhirVerificationResult);
{$ENDIF FHIR_VERIFICATIONRESULT}
{$IFDEF FHIR_VISIONPRESCRIPTION}
    procedure ComposeVisionPrescriptionLensSpecification(xml : TXmlBuilder; name : string; value : TFhirVisionPrescriptionLensSpecification);
    procedure ComposeVisionPrescriptionLensSpecificationChildren(xml : TXmlBuilder; value : TFhirVisionPrescriptionLensSpecification);
    procedure ComposeVisionPrescriptionLensSpecificationPrism(xml : TXmlBuilder; name : string; value : TFhirVisionPrescriptionLensSpecificationPrism);
    procedure ComposeVisionPrescriptionLensSpecificationPrismChildren(xml : TXmlBuilder; value : TFhirVisionPrescriptionLensSpecificationPrism);
    procedure ComposeVisionPrescription(xml : TXmlBuilder; name : string; value : TFhirVisionPrescription);
    procedure ComposeVisionPrescriptionChildren(xml : TXmlBuilder; value : TFhirVisionPrescription);
{$ENDIF FHIR_VISIONPRESCRIPTION}


  public
    procedure ComposeResource(xml : TXmlBuilder; resource : TFhirResource); override;
    procedure ComposeBase(xml : TXmlBuilder; name : String; base : TFHIRObject); override;
  end;


implementation

{ TFHIRXmlParser / TFHIRXmlComposer }

Procedure TFHIRXmlParser.ParseBaseAttributes(value : TFhirBase; path : string; element : TMXmlElement); 
begin
  TakeCommentsStart(value);
  GetObjectLocation(value, element);
end;

Procedure TFHIRXmlParser.ParseBaseAttributes(value : TFhirResource; path : string; element : TMXmlElement);  
begin
  TakeCommentsStart(value);
  GetObjectLocation(value, element);
end;

Function TFHIRXmlParser.ParseBaseChild(value : TFhirBase; path : string; child : TMXmlElement) : boolean;  
begin
  result := false;
end;

Function TFHIRXmlParser.ParseBaseChild(value : TFhirResource; path : string; child : TMXmlElement) : boolean;  
begin
  result := false;
end;

Procedure TFHIRXmlComposer.ComposeBaseAttributes(xml : TXmlBuilder; res : TFhirBase); 
begin
  CommentsStart(xml, res);
end;

Procedure TFHIRXmlComposer.ComposeBaseAttributes(xml : TXmlBuilder; res : TFhirResource); 
begin
  CommentsStart(xml, res);
end;

Procedure TFHIRXmlComposer.ComposeBaseChildren(xml : TXmlBuilder; value : TFhirBase); 
begin
  // nothing
end;

Procedure TFHIRXmlComposer.ComposeBaseChildren(xml : TXmlBuilder; value : TFhirResource); 
begin
  // nothing
end;


Procedure TFHIRXmlParser.ParseElementAttributes(value : TFhirElement; path : string; element : TMXmlElement);
begin
  ParseBaseAttributes(value, path, element);
    value.id := GetAttribute(element, 'id');
end;

Function TFHIRXmlParser.ParseElementChild(value : TFhirElement; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
  if (child.localName = 'extension') then
    value.extensionList.Add(ParseExtension(child, path+'/extension'))
  else if not parseBaseChild(value, path, child) then
    result := false;
end;

Procedure TFHIRXmlComposer.ComposeElementAttributes(xml : TXmlBuilder; value : TFhirElement);
begin
  ComposeBaseAttributes(xml, value);
  Attribute(xml, 'id', value.id  );
end;

Procedure TFHIRXmlComposer.ComposeElementChildren(xml : TXmlBuilder; value : TFhirElement);
var
  i : integer;
begin
  composeBaseChildren(xml, value);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.extensionList.Count - 1 do
      ComposeExtension(xml, 'extension', value.extensionList[i]);
end;

Procedure TFHIRXmlParser.ParseBackboneElementAttributes(value : TFhirBackboneElement; path : string; element : TMXmlElement);
begin
  ParseElementAttributes(value, path, element);
end;

Function TFHIRXmlParser.ParseBackboneElementChild(value : TFhirBackboneElement; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
  if (child.localName = 'modifierExtension') then
    value.modifierExtensionList.Add(ParseExtension(child, path+'/modifierExtension'))
  else if not parseElementChild(value, path, child) then
    result := false;
end;

Procedure TFHIRXmlComposer.ComposeBackboneElementAttributes(xml : TXmlBuilder; value : TFhirBackboneElement);
begin
  ComposeElementAttributes(xml, value);
end;

Procedure TFHIRXmlComposer.ComposeBackboneElementChildren(xml : TXmlBuilder; value : TFhirBackboneElement);
var
  i : integer;
begin
  composeElementChildren(xml, value);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.modifierExtensionList.Count - 1 do
      ComposeExtension(xml, 'modifierExtension', value.modifierExtensionList[i]);
end;

Procedure TFHIRXmlParser.ParseDataTypeAttributes(value : TFhirDataType; path : string; element : TMXmlElement);
begin
  ParseElementAttributes(value, path, element);
end;

Function TFHIRXmlParser.ParseDataTypeChild(value : TFhirDataType; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
  if not parseElementChild(value, path, child) then
    result := false;
end;

Procedure TFHIRXmlComposer.ComposeDataTypeAttributes(xml : TXmlBuilder; value : TFhirDataType);
begin
  ComposeElementAttributes(xml, value);
end;

Procedure TFHIRXmlComposer.ComposeDataTypeChildren(xml : TXmlBuilder; value : TFhirDataType);
begin
  composeElementChildren(xml, value);
end;

Procedure TFHIRXmlParser.ParseBackboneTypeAttributes(value : TFhirBackboneType; path : string; element : TMXmlElement);
begin
  ParseDataTypeAttributes(value, path, element);
end;

Function TFHIRXmlParser.ParseBackboneTypeChild(value : TFhirBackboneType; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
  if (child.localName = 'modifierExtension') then
    value.modifierExtensionList.Add(ParseExtension(child, path+'/modifierExtension'))
  else if not parseDataTypeChild(value, path, child) then
    result := false;
end;

Procedure TFHIRXmlComposer.ComposeBackboneTypeAttributes(xml : TXmlBuilder; value : TFhirBackboneType);
begin
  ComposeDataTypeAttributes(xml, value);
end;

Procedure TFHIRXmlComposer.ComposeBackboneTypeChildren(xml : TXmlBuilder; value : TFhirBackboneType);
var
  i : integer;
begin
  composeDataTypeChildren(xml, value);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.modifierExtensionList.Count - 1 do
      ComposeExtension(xml, 'modifierExtension', value.modifierExtensionList[i]);
end;

Procedure TFHIRXmlParser.ParsePrimitiveTypeAttributes(value : TFhirPrimitiveType; path : string; element : TMXmlElement);
begin
  ParseDataTypeAttributes(value, path, element);
end;

Function TFHIRXmlParser.ParsePrimitiveTypeChild(value : TFhirPrimitiveType; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
  if not parseDataTypeChild(value, path, child) then
    result := false;
end;

Procedure TFHIRXmlComposer.ComposePrimitiveTypeAttributes(xml : TXmlBuilder; value : TFhirPrimitiveType);
begin
  ComposeDataTypeAttributes(xml, value);
end;

Procedure TFHIRXmlComposer.ComposePrimitiveTypeChildren(xml : TXmlBuilder; value : TFhirPrimitiveType);
begin
  composeDataTypeChildren(xml, value);
end;



function TFHIRXmlParser.ParseEnum(Const aNames, aSystems : Array Of String; element : TMXmlElement; path : String) : TFhirEnum;
var
  child : TMXmlElement;
  i : integer;
begin
  result := TFhirEnum.Create;
  try
    ParseElementAttributes(result, path, element);
    result.value := GetAttribute(element, 'value');
    i := StringArrayIndexOfSensitive(aNames, result.value);
    if i < 0 then
      raise EXmlException.Create('unknown code: '+result.value+' from a set of choices of '+StringArrayToCommaString(aNames)+' for "'+path+'"');
    result.system := aSystems[i];
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if Not ParseElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

Procedure TFHIRXmlComposer.ComposeEnum(xml : TXmlBuilder; name : String; value : TFhirEnum; Const aNames : Array Of String);
begin
  if (value = nil) then
    exit;
  composeElementAttributes(xml, value);
  attribute(xml, 'value', value.value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeElementChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

function TFHIRXmlParser.ParseDate(element : TMXmlElement; path : string) : TFhirDate;
var
  child : TMXmlElement;
begin
  result := TFhirDate.Create;
  try
    ParseElementAttributes(result, path, element);
    result.value := toTFslDateTime(GetAttribute(element, 'value'));
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if Not ParseElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

Procedure TFHIRXmlComposer.ComposeDate(xml : TXmlBuilder; name : String; value : TFhirDate);
begin
  if (value = nil) or ((value.value.null) and (value.extensionList.count = 0)) then
    exit;
  composeElementAttributes(xml, value);
  if (value.value.notNull) then
    attribute(xml, 'value', asString(value.value));
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeElementChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

function TFHIRXmlParser.ParseDateTime(element : TMXmlElement; path : string) : TFhirDateTime;
var
  child : TMXmlElement;
begin
  result := TFhirDateTime.Create;
  try
    ParseElementAttributes(result, path, element);
    result.value := toTFslDateTime(GetAttribute(element, 'value'));
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if Not ParseElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

Procedure TFHIRXmlComposer.ComposeDateTime(xml : TXmlBuilder; name : String; value : TFhirDateTime);
begin
  if (value = nil) or ((value.value.null) and (value.extensionList.count = 0)) then
    exit;
  composeElementAttributes(xml, value);
  if (value.value.notNull) then
    attribute(xml, 'value', asString(value.value));
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeElementChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

function TFHIRXmlParser.ParseString(element : TMXmlElement; path : string) : TFhirString;
var
  child : TMXmlElement;
begin
  result := TFhirString.Create;
  try
    ParseElementAttributes(result, path, element);
    result.value := GetAttribute(element, 'value');
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if Not ParseElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

Procedure TFHIRXmlComposer.ComposeString(xml : TXmlBuilder; name : String; value : TFhirString);
begin
  if (value = nil) or ((value.value = '') and (value.extensionList.count = 0)) then
    exit;
  composeElementAttributes(xml, value);
  attribute(xml, 'value', value.value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeElementChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

function TFHIRXmlParser.ParseInteger(element : TMXmlElement; path : string) : TFhirInteger;
var
  child : TMXmlElement;
begin
  result := TFhirInteger.Create;
  try
    ParseElementAttributes(result, path, element);
    result.value := GetAttribute(element, 'value');
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if Not ParseElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

Procedure TFHIRXmlComposer.ComposeInteger(xml : TXmlBuilder; name : String; value : TFhirInteger);
begin
  if (value = nil) or ((value.value = '') and (value.extensionList.count = 0)) then
    exit;
  composeElementAttributes(xml, value);
  attribute(xml, 'value', value.value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeElementChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

function TFHIRXmlParser.ParseUri(element : TMXmlElement; path : string) : TFhirUri;
var
  child : TMXmlElement;
begin
  result := TFhirUri.Create;
  try
    ParseElementAttributes(result, path, element);
    result.value := GetAttribute(element, 'value');
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if Not ParseElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

Procedure TFHIRXmlComposer.ComposeUri(xml : TXmlBuilder; name : String; value : TFhirUri);
begin
  if (value = nil) or ((value.value = '') and (value.extensionList.count = 0)) then
    exit;
  composeElementAttributes(xml, value);
  attribute(xml, 'value', value.value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeElementChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

function TFHIRXmlParser.ParseInstant(element : TMXmlElement; path : string) : TFhirInstant;
var
  child : TMXmlElement;
begin
  result := TFhirInstant.Create;
  try
    ParseElementAttributes(result, path, element);
    result.value := toTFslDateTime(GetAttribute(element, 'value'));
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if Not ParseElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

Procedure TFHIRXmlComposer.ComposeInstant(xml : TXmlBuilder; name : String; value : TFhirInstant);
begin
  if (value = nil) or ((value.value.null) and (value.extensionList.count = 0)) then
    exit;
  composeElementAttributes(xml, value);
  if (value.value.notNull) then
    attribute(xml, 'value', asString(value.value));
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeElementChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

function TFHIRXmlParser.ParseXhtml(element : TMXmlElement; path : string) : TFhirXhtml;
var
  child : TMXmlElement;
begin
  result := TFhirXhtml.Create;
  try
    ParseElementAttributes(result, path, element);
    result.value := GetAttribute(element, 'value');
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if Not ParseElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

Procedure TFHIRXmlComposer.ComposeXhtml(xml : TXmlBuilder; name : String; value : TFhirXhtml);
begin
  if (value = nil) or ((value.value = '') and (value.extensionList.count = 0)) then
    exit;
  composeElementAttributes(xml, value);
  attribute(xml, 'value', value.value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeElementChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

function TFHIRXmlParser.ParseBoolean(element : TMXmlElement; path : string) : TFhirBoolean;
var
  child : TMXmlElement;
begin
  result := TFhirBoolean.Create;
  try
    ParseElementAttributes(result, path, element);
    result.value := StringToBoolean(GetAttribute(element, 'value'));
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if Not ParseElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

Procedure TFHIRXmlComposer.ComposeBoolean(xml : TXmlBuilder; name : String; value : TFhirBoolean);
begin
  if (value = nil) then
    exit;
  composeElementAttributes(xml, value);
  attribute(xml, 'value', LCBooleanToString(value.value));
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeElementChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

function TFHIRXmlParser.ParseBase64Binary(element : TMXmlElement; path : string) : TFhirBase64Binary;
var
  child : TMXmlElement;
begin
  result := TFhirBase64Binary.Create;
  try
    ParseElementAttributes(result, path, element);
    result.value := toTBytes(GetAttribute(element, 'value'));
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if Not ParseElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

Procedure TFHIRXmlComposer.ComposeBase64Binary(xml : TXmlBuilder; name : String; value : TFhirBase64Binary);
begin
  if (value = nil) or ((value.value = nil) and (value.extensionList.count = 0)) then
    exit;
  composeElementAttributes(xml, value);
  if (value.value <> nil) then
    attribute(xml, 'value', asString(value.value));
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeElementChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

function TFHIRXmlParser.ParseTime(element : TMXmlElement; path : string) : TFhirTime;
var
  child : TMXmlElement;
begin
  result := TFhirTime.Create;
  try
    ParseElementAttributes(result, path, element);
    result.value := GetAttribute(element, 'value');
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if Not ParseElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

Procedure TFHIRXmlComposer.ComposeTime(xml : TXmlBuilder; name : String; value : TFhirTime);
begin
  if (value = nil) or ((value.value = '') and (value.extensionList.count = 0)) then
    exit;
  composeElementAttributes(xml, value);
  attribute(xml, 'value', value.value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeElementChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

function TFHIRXmlParser.ParseDecimal(element : TMXmlElement; path : string) : TFhirDecimal;
var
  child : TMXmlElement;
begin
  result := TFhirDecimal.Create;
  try
    ParseElementAttributes(result, path, element);
    result.value := GetAttribute(element, 'value');
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if Not ParseElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

Procedure TFHIRXmlComposer.ComposeDecimal(xml : TXmlBuilder; name : String; value : TFhirDecimal);
begin
  if (value = nil) or ((value.value = '') and (value.extensionList.count = 0)) then
    exit;
  composeElementAttributes(xml, value);
  attribute(xml, 'value', value.value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeElementChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

function TFHIRXmlParser.ParseCode(element : TMXmlElement; path : string) : TFhirCode;
var
  child : TMXmlElement;
begin
  result := TFhirCode.Create;
  try
    ParseElementAttributes(result, path, element);
    result.value := GetAttribute(element, 'value');
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if Not ParseElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

Procedure TFHIRXmlComposer.ComposeCode(xml : TXmlBuilder; name : String; value : TFhirCode);
begin
  if (value = nil) or ((value.value = '') and (value.extensionList.count = 0)) then
    exit;
  composeElementAttributes(xml, value);
  attribute(xml, 'value', value.value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeElementChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

function TFHIRXmlParser.ParseCanonical(element : TMXmlElement; path : string) : TFhirCanonical;
var
  child : TMXmlElement;
begin
  result := TFhirCanonical.Create;
  try
    ParseElementAttributes(result, path, element);
    result.value := GetAttribute(element, 'value');
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if Not ParseElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

Procedure TFHIRXmlComposer.ComposeCanonical(xml : TXmlBuilder; name : String; value : TFhirCanonical);
begin
  if (value = nil) or ((value.value = '') and (value.extensionList.count = 0)) then
    exit;
  composeElementAttributes(xml, value);
  attribute(xml, 'value', value.value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeElementChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

function TFHIRXmlParser.ParseOid(element : TMXmlElement; path : string) : TFhirOid;
var
  child : TMXmlElement;
begin
  result := TFhirOid.Create;
  try
    ParseElementAttributes(result, path, element);
    result.value := GetAttribute(element, 'value');
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if Not ParseElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

Procedure TFHIRXmlComposer.ComposeOid(xml : TXmlBuilder; name : String; value : TFhirOid);
begin
  if (value = nil) or ((value.value = '') and (value.extensionList.count = 0)) then
    exit;
  composeElementAttributes(xml, value);
  attribute(xml, 'value', value.value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeElementChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

function TFHIRXmlParser.ParseUuid(element : TMXmlElement; path : string) : TFhirUuid;
var
  child : TMXmlElement;
begin
  result := TFhirUuid.Create;
  try
    ParseElementAttributes(result, path, element);
    result.value := GetAttribute(element, 'value');
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if Not ParseElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

Procedure TFHIRXmlComposer.ComposeUuid(xml : TXmlBuilder; name : String; value : TFhirUuid);
begin
  if (value = nil) or ((value.value = '') and (value.extensionList.count = 0)) then
    exit;
  composeElementAttributes(xml, value);
  attribute(xml, 'value', value.value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeElementChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

function TFHIRXmlParser.ParseUrl(element : TMXmlElement; path : string) : TFhirUrl;
var
  child : TMXmlElement;
begin
  result := TFhirUrl.Create;
  try
    ParseElementAttributes(result, path, element);
    result.value := GetAttribute(element, 'value');
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if Not ParseElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

Procedure TFHIRXmlComposer.ComposeUrl(xml : TXmlBuilder; name : String; value : TFhirUrl);
begin
  if (value = nil) or ((value.value = '') and (value.extensionList.count = 0)) then
    exit;
  composeElementAttributes(xml, value);
  attribute(xml, 'value', value.value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeElementChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

function TFHIRXmlParser.ParseMarkdown(element : TMXmlElement; path : string) : TFhirMarkdown;
var
  child : TMXmlElement;
begin
  result := TFhirMarkdown.Create;
  try
    ParseElementAttributes(result, path, element);
    result.value := GetAttribute(element, 'value');
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if Not ParseElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

Procedure TFHIRXmlComposer.ComposeMarkdown(xml : TXmlBuilder; name : String; value : TFhirMarkdown);
begin
  if (value = nil) or ((value.value = '') and (value.extensionList.count = 0)) then
    exit;
  composeElementAttributes(xml, value);
  attribute(xml, 'value', value.value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeElementChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

function TFHIRXmlParser.ParseUnsignedInt(element : TMXmlElement; path : string) : TFhirUnsignedInt;
var
  child : TMXmlElement;
begin
  result := TFhirUnsignedInt.Create;
  try
    ParseElementAttributes(result, path, element);
    result.value := GetAttribute(element, 'value');
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if Not ParseElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

Procedure TFHIRXmlComposer.ComposeUnsignedInt(xml : TXmlBuilder; name : String; value : TFhirUnsignedInt);
begin
  if (value = nil) or ((value.value = '') and (value.extensionList.count = 0)) then
    exit;
  composeElementAttributes(xml, value);
  attribute(xml, 'value', value.value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeElementChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

function TFHIRXmlParser.ParseId(element : TMXmlElement; path : string) : TFhirId;
var
  child : TMXmlElement;
begin
  result := TFhirId.Create;
  try
    ParseElementAttributes(result, path, element);
    result.value := GetAttribute(element, 'value');
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if Not ParseElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

Procedure TFHIRXmlComposer.ComposeId(xml : TXmlBuilder; name : String; value : TFhirId);
begin
  if (value = nil) or ((value.value = '') and (value.extensionList.count = 0)) then
    exit;
  composeElementAttributes(xml, value);
  attribute(xml, 'value', value.value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeElementChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

function TFHIRXmlParser.ParsePositiveInt(element : TMXmlElement; path : string) : TFhirPositiveInt;
var
  child : TMXmlElement;
begin
  result := TFhirPositiveInt.Create;
  try
    ParseElementAttributes(result, path, element);
    result.value := GetAttribute(element, 'value');
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if Not ParseElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

Procedure TFHIRXmlComposer.ComposePositiveInt(xml : TXmlBuilder; name : String; value : TFhirPositiveInt);
begin
  if (value = nil) or ((value.value = '') and (value.extensionList.count = 0)) then
    exit;
  composeElementAttributes(xml, value);
  attribute(xml, 'value', value.value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeElementChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

function TFHIRXmlParser.ParseInteger64(element : TMXmlElement; path : string) : TFhirInteger64;
var
  child : TMXmlElement;
begin
  result := TFhirInteger64.Create;
  try
    ParseElementAttributes(result, path, element);
    result.value := GetAttribute(element, 'value');
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if Not ParseElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

Procedure TFHIRXmlComposer.ComposeInteger64(xml : TXmlBuilder; name : String; value : TFhirInteger64);
begin
  if (value = nil) or ((value.value = '') and (value.extensionList.count = 0)) then
    exit;
  composeElementAttributes(xml, value);
  attribute(xml, 'value', value.value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeElementChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

function TFHIRXmlParser.ParseAddress(element : TMXmlElement; path : string) : TFhirAddress;
var
  child : TMXmlElement;
begin
  result := TFhirAddress.Create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseAddressChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseAddressChild(value : TFhirAddress; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'use') then
        value.useElement := ParseEnum(CODES_TFhirAddressUseEnum, SYSTEMS_TFhirAddressUseEnum, child, path+'/use')
      else if (child.localName = 'type') then
        value.type_Element := ParseEnum(CODES_TFhirAddressTypeEnum, SYSTEMS_TFhirAddressTypeEnum, child, path+'/type')
      else if (child.localName = 'text') then
        value.textElement := ParseString(child, path+'/text')
      else if (child.localName = 'line') then
        value.lineList.Add(ParseString(child, path+'/line'))
      else if (child.localName = 'city') then
        value.cityElement := ParseString(child, path+'/city')
      else if (child.localName = 'district') then
        value.districtElement := ParseString(child, path+'/district')
      else if (child.localName = 'state') then
        value.stateElement := ParseString(child, path+'/state')
      else if (child.localName = 'postalCode') then
        value.postalCodeElement := ParseString(child, path+'/postalCode')
      else if (child.localName = 'country') then
        value.countryElement := ParseString(child, path+'/country')
      else if (child.localName = 'period') then
        value.period := ParsePeriod(child, path+'/period')
      else if Not ParseElementChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeAddress(xml : TXmlBuilder; name : String; value : TFhirAddress);
begin
  if (value = nil) then
    exit;
  composeElementAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeAddressChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeAddressChildren(xml : TXmlBuilder; value : TFhirAddress);
var
  i : integer;
begin
  composeDataTypeChildren(xml, value);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeEnum(xml, 'use', value.useElement, CODES_TFhirAddressUseEnum);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeEnum(xml, 'type', value.type_Element, CODES_TFhirAddressTypeEnum);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(xml, 'text', value.textElement);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.lineList.Count - 1 do
      ComposeString(xml, 'line', value.lineList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(xml, 'city', value.cityElement);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(xml, 'district', value.districtElement);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(xml, 'state', value.stateElement);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(xml, 'postalCode', value.postalCodeElement);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(xml, 'country', value.countryElement);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposePeriod(xml, 'period', value.period);
end;

function TFHIRXmlParser.ParseAnnotation(element : TMXmlElement; path : string) : TFhirAnnotation;
var
  child : TMXmlElement;
begin
  result := TFhirAnnotation.Create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseAnnotationChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseAnnotationChild(value : TFhirAnnotation; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'authorReference') then
        value.author := ParseReference(child, path+'/authorReference')
      else if (child.localName = 'authorString') then
        value.author := ParseString(child, path+'/authorString')
      else if (child.localName = 'time') then
        value.timeElement := ParseDateTime(child, path+'/time')
      else if (child.localName = 'text') then
        value.textElement := ParseMarkdown(child, path+'/text')
      else if Not ParseElementChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeAnnotation(xml : TXmlBuilder; name : String; value : TFhirAnnotation);
begin
  if (value = nil) then
    exit;
  composeElementAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeAnnotationChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeAnnotationChildren(xml : TXmlBuilder; value : TFhirAnnotation);
begin
  composeDataTypeChildren(xml, value);
  if (SummaryOption in [soFull, soSummary, soData]) and (value.author is TFhirReference) {2} then
    ComposeReference(xml, 'authorReference', TFhirReference(value.author))
  else if (SummaryOption in [soFull, soSummary, soData]) and (value.author is TFhirString) {6} then
    ComposeString(xml, 'authorString', TFhirString(value.author));
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDateTime(xml, 'time', value.timeElement);
  ComposeMarkdown(xml, 'text', value.textElement);
end;

function TFHIRXmlParser.ParseAttachment(element : TMXmlElement; path : string) : TFhirAttachment;
var
  child : TMXmlElement;
begin
  result := TFhirAttachment.Create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseAttachmentChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseAttachmentChild(value : TFhirAttachment; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'contentType') then
        value.contentTypeElement := ParseCode(child, path+'/contentType')
      else if (child.localName = 'language') then
        value.languageElement := ParseCode(child, path+'/language')
      else if (child.localName = 'data') then
        value.dataElement := ParseBase64Binary(child, path+'/data')
      else if (child.localName = 'url') then
        value.urlElement := ParseUrl(child, path+'/url')
      else if (child.localName = 'size') then
        value.sizeElement := ParseInteger64(child, path+'/size')
      else if (child.localName = 'hash') then
        value.hashElement := ParseBase64Binary(child, path+'/hash')
      else if (child.localName = 'title') then
        value.titleElement := ParseString(child, path+'/title')
      else if (child.localName = 'creation') then
        value.creationElement := ParseDateTime(child, path+'/creation')
      else if (child.localName = 'height') then
        value.heightElement := ParsePositiveInt(child, path+'/height')
      else if (child.localName = 'width') then
        value.widthElement := ParsePositiveInt(child, path+'/width')
      else if (child.localName = 'frames') then
        value.framesElement := ParsePositiveInt(child, path+'/frames')
      else if (child.localName = 'duration') then
        value.durationElement := ParseDecimal(child, path+'/duration')
      else if (child.localName = 'pages') then
        value.pagesElement := ParsePositiveInt(child, path+'/pages')
      else if Not ParseElementChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeAttachment(xml : TXmlBuilder; name : String; value : TFhirAttachment);
begin
  if (value = nil) then
    exit;
  composeElementAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeAttachmentChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeAttachmentChildren(xml : TXmlBuilder; value : TFhirAttachment);
begin
  composeDataTypeChildren(xml, value);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCode(xml, 'contentType', value.contentTypeElement);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCode(xml, 'language', value.languageElement);
  if (SummaryOption in [soFull, soData]) then
    ComposeBase64Binary(xml, 'data', value.dataElement);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeUrl(xml, 'url', value.urlElement);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeInteger64(xml, 'size', value.sizeElement);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeBase64Binary(xml, 'hash', value.hashElement);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(xml, 'title', value.titleElement);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDateTime(xml, 'creation', value.creationElement);
  if (SummaryOption in [soFull, soData]) then
    ComposePositiveInt(xml, 'height', value.heightElement);
  if (SummaryOption in [soFull, soData]) then
    ComposePositiveInt(xml, 'width', value.widthElement);
  if (SummaryOption in [soFull, soData]) then
    ComposePositiveInt(xml, 'frames', value.framesElement);
  if (SummaryOption in [soFull, soData]) then
    ComposeDecimal(xml, 'duration', value.durationElement);
  if (SummaryOption in [soFull, soData]) then
    ComposePositiveInt(xml, 'pages', value.pagesElement);
end;

function TFHIRXmlParser.ParseAvailabilityAvailableTime(element : TMXmlElement; path : string) : TFhirAvailabilityAvailableTime;
var
  child : TMXmlElement;
begin
  result := TFhirAvailabilityAvailableTime.Create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseAvailabilityAvailableTimeChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseAvailabilityAvailableTimeChild(value : TFhirAvailabilityAvailableTime; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'daysOfWeek') then
        value.daysOfWeekList.Add(ParseEnum(CODES_TFhirDaysOfWeekEnum, SYSTEMS_TFhirDaysOfWeekEnum, child, path+'/daysOfWeek')){y.1}
      else if (child.localName = 'allDay') then
        value.allDayElement := ParseBoolean(child, path+'/allDay')
      else if (child.localName = 'availableStartTime') then
        value.availableStartTimeElement := ParseTime(child, path+'/availableStartTime')
      else if (child.localName = 'availableEndTime') then
        value.availableEndTimeElement := ParseTime(child, path+'/availableEndTime')
      else if Not ParseElementChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeAvailabilityAvailableTime(xml : TXmlBuilder; name : String; value : TFhirAvailabilityAvailableTime);
begin
  if (value = nil) then
    exit;
  composeElementAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeAvailabilityAvailableTimeChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeAvailabilityAvailableTimeChildren(xml : TXmlBuilder; value : TFhirAvailabilityAvailableTime);
var
  i : integer;
begin
  composeElementChildren(xml, value);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.daysOfWeekList.Count - 1 do
      ComposeEnum(xml, 'daysOfWeek', value.daysOfWeekList[i], CODES_TFhirDaysOfWeekEnum);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeBoolean(xml, 'allDay', value.allDayElement);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeTime(xml, 'availableStartTime', value.availableStartTimeElement);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeTime(xml, 'availableEndTime', value.availableEndTimeElement);
end;

function TFHIRXmlParser.ParseAvailabilityNotAvailableTime(element : TMXmlElement; path : string) : TFhirAvailabilityNotAvailableTime;
var
  child : TMXmlElement;
begin
  result := TFhirAvailabilityNotAvailableTime.Create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseAvailabilityNotAvailableTimeChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseAvailabilityNotAvailableTimeChild(value : TFhirAvailabilityNotAvailableTime; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'description') then
        value.descriptionElement := ParseString(child, path+'/description')
      else if (child.localName = 'during') then
        value.during := ParsePeriod(child, path+'/during')
      else if Not ParseElementChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeAvailabilityNotAvailableTime(xml : TXmlBuilder; name : String; value : TFhirAvailabilityNotAvailableTime);
begin
  if (value = nil) then
    exit;
  composeElementAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeAvailabilityNotAvailableTimeChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeAvailabilityNotAvailableTimeChildren(xml : TXmlBuilder; value : TFhirAvailabilityNotAvailableTime);
begin
  composeElementChildren(xml, value);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(xml, 'description', value.descriptionElement);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposePeriod(xml, 'during', value.during);
end;

function TFHIRXmlParser.ParseAvailability(element : TMXmlElement; path : string) : TFhirAvailability;
var
  child : TMXmlElement;
begin
  result := TFhirAvailability.Create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseAvailabilityChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseAvailabilityChild(value : TFhirAvailability; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'availableTime') then
        value.availableTimeList.Add(ParseAvailabilityAvailableTime(child, path+'/availableTime'))
      else if (child.localName = 'notAvailableTime') then
        value.notAvailableTimeList.Add(ParseAvailabilityNotAvailableTime(child, path+'/notAvailableTime'))
      else if Not ParseElementChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeAvailability(xml : TXmlBuilder; name : String; value : TFhirAvailability);
begin
  if (value = nil) then
    exit;
  composeElementAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeAvailabilityChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeAvailabilityChildren(xml : TXmlBuilder; value : TFhirAvailability);
var
  i : integer;
begin
  composeDataTypeChildren(xml, value);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.availableTimeList.Count - 1 do
      ComposeAvailabilityAvailableTime(xml, 'availableTime', value.availableTimeList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.notAvailableTimeList.Count - 1 do
      ComposeAvailabilityNotAvailableTime(xml, 'notAvailableTime', value.notAvailableTimeList[i]);
end;

function TFHIRXmlParser.ParseCodeableConcept(element : TMXmlElement; path : string) : TFhirCodeableConcept;
var
  child : TMXmlElement;
begin
  result := TFhirCodeableConcept.Create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseCodeableConceptChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseCodeableConceptChild(value : TFhirCodeableConcept; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'coding') then
        value.codingList.Add(ParseCoding(child, path+'/coding'))
      else if (child.localName = 'text') then
        value.textElement := ParseString(child, path+'/text')
      else if Not ParseElementChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeCodeableConcept(xml : TXmlBuilder; name : String; value : TFhirCodeableConcept);
begin
  if (value = nil) then
    exit;
  composeElementAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeCodeableConceptChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeCodeableConceptChildren(xml : TXmlBuilder; value : TFhirCodeableConcept);
var
  i : integer;
begin
  composeDataTypeChildren(xml, value);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.codingList.Count - 1 do
      ComposeCoding(xml, 'coding', value.codingList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(xml, 'text', value.textElement);
end;

function TFHIRXmlParser.ParseCodeableReference(element : TMXmlElement; path : string) : TFhirCodeableReference;
var
  child : TMXmlElement;
begin
  result := TFhirCodeableReference.Create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseCodeableReferenceChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseCodeableReferenceChild(value : TFhirCodeableReference; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'concept') then
        value.concept := ParseCodeableConcept(child, path+'/concept')
      else if (child.localName = 'reference') then
        value.reference := ParseReference(child, path+'/reference')
      else if Not ParseElementChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeCodeableReference(xml : TXmlBuilder; name : String; value : TFhirCodeableReference);
begin
  if (value = nil) then
    exit;
  composeElementAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeCodeableReferenceChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeCodeableReferenceChildren(xml : TXmlBuilder; value : TFhirCodeableReference);
begin
  composeDataTypeChildren(xml, value);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(xml, 'concept', value.concept);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference(xml, 'reference', value.reference);
end;

function TFHIRXmlParser.ParseCoding(element : TMXmlElement; path : string) : TFhirCoding;
var
  child : TMXmlElement;
begin
  result := TFhirCoding.Create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseCodingChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseCodingChild(value : TFhirCoding; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'system') then
        value.systemElement := ParseUri(child, path+'/system')
      else if (child.localName = 'version') then
        value.versionElement := ParseString(child, path+'/version')
      else if (child.localName = 'code') then
        value.codeElement := ParseCode(child, path+'/code')
      else if (child.localName = 'display') then
        value.displayElement := ParseString(child, path+'/display')
      else if (child.localName = 'userSelected') then
        value.userSelectedElement := ParseBoolean(child, path+'/userSelected')
      else if Not ParseElementChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeCoding(xml : TXmlBuilder; name : String; value : TFhirCoding);
begin
  if (value = nil) then
    exit;
  composeElementAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeCodingChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeCodingChildren(xml : TXmlBuilder; value : TFhirCoding);
begin
  composeDataTypeChildren(xml, value);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeUri(xml, 'system', value.systemElement);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(xml, 'version', value.versionElement);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCode(xml, 'code', value.codeElement);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(xml, 'display', value.displayElement);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeBoolean(xml, 'userSelected', value.userSelectedElement);
end;

function TFHIRXmlParser.ParseContactDetail(element : TMXmlElement; path : string) : TFhirContactDetail;
var
  child : TMXmlElement;
begin
  result := TFhirContactDetail.Create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseContactDetailChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseContactDetailChild(value : TFhirContactDetail; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'name') then
        value.nameElement := ParseString(child, path+'/name')
      else if (child.localName = 'telecom') then
        value.telecomList.Add(ParseContactPoint(child, path+'/telecom'))
      else if Not ParseElementChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeContactDetail(xml : TXmlBuilder; name : String; value : TFhirContactDetail);
begin
  if (value = nil) then
    exit;
  composeElementAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeContactDetailChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeContactDetailChildren(xml : TXmlBuilder; value : TFhirContactDetail);
var
  i : integer;
begin
  composeDataTypeChildren(xml, value);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(xml, 'name', value.nameElement);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.telecomList.Count - 1 do
      ComposeContactPoint(xml, 'telecom', value.telecomList[i]);
end;

function TFHIRXmlParser.ParseContactPoint(element : TMXmlElement; path : string) : TFhirContactPoint;
var
  child : TMXmlElement;
begin
  result := TFhirContactPoint.Create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseContactPointChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseContactPointChild(value : TFhirContactPoint; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'system') then
        value.systemElement := ParseEnum(CODES_TFhirContactPointSystemEnum, SYSTEMS_TFhirContactPointSystemEnum, child, path+'/system')
      else if (child.localName = 'value') then
        value.valueElement := ParseString(child, path+'/value')
      else if (child.localName = 'use') then
        value.useElement := ParseEnum(CODES_TFhirContactPointUseEnum, SYSTEMS_TFhirContactPointUseEnum, child, path+'/use')
      else if (child.localName = 'rank') then
        value.rankElement := ParsePositiveInt(child, path+'/rank')
      else if (child.localName = 'period') then
        value.period := ParsePeriod(child, path+'/period')
      else if Not ParseElementChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeContactPoint(xml : TXmlBuilder; name : String; value : TFhirContactPoint);
begin
  if (value = nil) then
    exit;
  composeElementAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeContactPointChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeContactPointChildren(xml : TXmlBuilder; value : TFhirContactPoint);
begin
  composeDataTypeChildren(xml, value);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeEnum(xml, 'system', value.systemElement, CODES_TFhirContactPointSystemEnum);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(xml, 'value', value.valueElement);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeEnum(xml, 'use', value.useElement, CODES_TFhirContactPointUseEnum);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposePositiveInt(xml, 'rank', value.rankElement);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposePeriod(xml, 'period', value.period);
end;

function TFHIRXmlParser.ParseContributor(element : TMXmlElement; path : string) : TFhirContributor;
var
  child : TMXmlElement;
begin
  result := TFhirContributor.Create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseContributorChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseContributorChild(value : TFhirContributor; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'type') then
        value.type_Element := ParseEnum(CODES_TFhirContributorTypeEnum, SYSTEMS_TFhirContributorTypeEnum, child, path+'/type')
      else if (child.localName = 'name') then
        value.nameElement := ParseString(child, path+'/name')
      else if (child.localName = 'contact') then
        value.contactList.Add(ParseContactDetail(child, path+'/contact'))
      else if Not ParseElementChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeContributor(xml : TXmlBuilder; name : String; value : TFhirContributor);
begin
  if (value = nil) then
    exit;
  composeElementAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeContributorChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeContributorChildren(xml : TXmlBuilder; value : TFhirContributor);
var
  i : integer;
begin
  composeDataTypeChildren(xml, value);
  ComposeEnum(xml, 'type', value.type_Element, CODES_TFhirContributorTypeEnum);
  ComposeString(xml, 'name', value.nameElement);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.contactList.Count - 1 do
      ComposeContactDetail(xml, 'contact', value.contactList[i]);
end;

function TFHIRXmlParser.ParseDataRequirementCodeFilter(element : TMXmlElement; path : string) : TFhirDataRequirementCodeFilter;
var
  child : TMXmlElement;
begin
  result := TFhirDataRequirementCodeFilter.Create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseDataRequirementCodeFilterChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseDataRequirementCodeFilterChild(value : TFhirDataRequirementCodeFilter; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'path') then
        value.pathElement := ParseString(child, path+'/path')
      else if (child.localName = 'searchParam') then
        value.searchParamElement := ParseString(child, path+'/searchParam')
      else if (child.localName = 'valueSet') then
        value.valueSetElement := ParseCanonical(child, path+'/valueSet')
      else if (child.localName = 'code') then
        value.codeList.Add(ParseCoding(child, path+'/code'))
      else if Not ParseElementChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeDataRequirementCodeFilter(xml : TXmlBuilder; name : String; value : TFhirDataRequirementCodeFilter);
begin
  if (value = nil) then
    exit;
  composeElementAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeDataRequirementCodeFilterChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeDataRequirementCodeFilterChildren(xml : TXmlBuilder; value : TFhirDataRequirementCodeFilter);
var
  i : integer;
begin
  composeElementChildren(xml, value);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(xml, 'path', value.pathElement);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(xml, 'searchParam', value.searchParamElement);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCanonical(xml, 'valueSet', value.valueSetElement);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.codeList.Count - 1 do
      ComposeCoding(xml, 'code', value.codeList[i]);
end;

function TFHIRXmlParser.ParseDataRequirementDateFilter(element : TMXmlElement; path : string) : TFhirDataRequirementDateFilter;
var
  child : TMXmlElement;
begin
  result := TFhirDataRequirementDateFilter.Create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseDataRequirementDateFilterChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseDataRequirementDateFilterChild(value : TFhirDataRequirementDateFilter; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'path') then
        value.pathElement := ParseString(child, path+'/path')
      else if (child.localName = 'searchParam') then
        value.searchParamElement := ParseString(child, path+'/searchParam')
      else if (child.localName = 'valuePeriod') then
        value.value := ParsePeriod(child, path+'/valuePeriod')
      else if (child.localName = 'valueDuration') then
        value.value := ParseDuration(child, path+'/valueDuration')
      else if (child.localName = 'valueDateTime') then
        value.value := ParseDateTime(child, path+'/valueDateTime')
      else if Not ParseElementChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeDataRequirementDateFilter(xml : TXmlBuilder; name : String; value : TFhirDataRequirementDateFilter);
begin
  if (value = nil) then
    exit;
  composeElementAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeDataRequirementDateFilterChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeDataRequirementDateFilterChildren(xml : TXmlBuilder; value : TFhirDataRequirementDateFilter);
begin
  composeElementChildren(xml, value);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(xml, 'path', value.pathElement);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(xml, 'searchParam', value.searchParamElement);
  if (SummaryOption in [soFull, soSummary, soData]) and (value.value is TFhirPeriod) {6} then
    ComposePeriod(xml, 'valuePeriod', TFhirPeriod(value.value))
  else if (SummaryOption in [soFull, soSummary, soData]) and (value.value is TFhirDuration) {6} then
    ComposeDuration(xml, 'valueDuration', TFhirDuration(value.value))
  else if (SummaryOption in [soFull, soSummary, soData]) and (value.value is TFhirDateTime) {6} then
    ComposeDateTime(xml, 'valueDateTime', TFhirDateTime(value.value));
end;

function TFHIRXmlParser.ParseDataRequirementValueFilter(element : TMXmlElement; path : string) : TFhirDataRequirementValueFilter;
var
  child : TMXmlElement;
begin
  result := TFhirDataRequirementValueFilter.Create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseDataRequirementValueFilterChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseDataRequirementValueFilterChild(value : TFhirDataRequirementValueFilter; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'path') then
        value.pathElement := ParseString(child, path+'/path')
      else if (child.localName = 'searchParam') then
        value.searchParamElement := ParseString(child, path+'/searchParam')
      else if (child.localName = 'comparator') then
        value.comparatorElement := ParseEnum(CODES_TFhirValueFilterComparatorEnum, SYSTEMS_TFhirValueFilterComparatorEnum, child, path+'/comparator')
      else if (child.localName = 'valuePeriod') then
        value.value := ParsePeriod(child, path+'/valuePeriod')
      else if (child.localName = 'valueDuration') then
        value.value := ParseDuration(child, path+'/valueDuration')
      else if (child.localName = 'valueDateTime') then
        value.value := ParseDateTime(child, path+'/valueDateTime')
      else if Not ParseElementChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeDataRequirementValueFilter(xml : TXmlBuilder; name : String; value : TFhirDataRequirementValueFilter);
begin
  if (value = nil) then
    exit;
  composeElementAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeDataRequirementValueFilterChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeDataRequirementValueFilterChildren(xml : TXmlBuilder; value : TFhirDataRequirementValueFilter);
begin
  composeElementChildren(xml, value);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(xml, 'path', value.pathElement);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(xml, 'searchParam', value.searchParamElement);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeEnum(xml, 'comparator', value.comparatorElement, CODES_TFhirValueFilterComparatorEnum);
  if (SummaryOption in [soFull, soSummary, soData]) and (value.value is TFhirPeriod) {6} then
    ComposePeriod(xml, 'valuePeriod', TFhirPeriod(value.value))
  else if (SummaryOption in [soFull, soSummary, soData]) and (value.value is TFhirDuration) {6} then
    ComposeDuration(xml, 'valueDuration', TFhirDuration(value.value))
  else if (SummaryOption in [soFull, soSummary, soData]) and (value.value is TFhirDateTime) {6} then
    ComposeDateTime(xml, 'valueDateTime', TFhirDateTime(value.value));
end;

function TFHIRXmlParser.ParseDataRequirementSort(element : TMXmlElement; path : string) : TFhirDataRequirementSort;
var
  child : TMXmlElement;
begin
  result := TFhirDataRequirementSort.Create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseDataRequirementSortChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseDataRequirementSortChild(value : TFhirDataRequirementSort; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'path') then
        value.pathElement := ParseString(child, path+'/path')
      else if (child.localName = 'direction') then
        value.directionElement := ParseEnum(CODES_TFhirSortDirectionEnum, SYSTEMS_TFhirSortDirectionEnum, child, path+'/direction')
      else if Not ParseElementChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeDataRequirementSort(xml : TXmlBuilder; name : String; value : TFhirDataRequirementSort);
begin
  if (value = nil) then
    exit;
  composeElementAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeDataRequirementSortChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeDataRequirementSortChildren(xml : TXmlBuilder; value : TFhirDataRequirementSort);
begin
  composeElementChildren(xml, value);
  ComposeString(xml, 'path', value.pathElement);
  ComposeEnum(xml, 'direction', value.directionElement, CODES_TFhirSortDirectionEnum);
end;

function TFHIRXmlParser.ParseDataRequirement(element : TMXmlElement; path : string) : TFhirDataRequirement;
var
  child : TMXmlElement;
begin
  result := TFhirDataRequirement.Create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseDataRequirementChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseDataRequirementChild(value : TFhirDataRequirement; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'type') then
        value.type_Element := ParseEnum(CODES_TFhirFHIRTypesEnum, SYSTEMS_TFhirFHIRTypesEnum, child, path+'/type')
      else if (child.localName = 'profile') then
        value.profileList.Add(ParseCanonical(child, path+'/profile'))
      else if (child.localName = 'subjectCodeableConcept') then
        value.subject := ParseCodeableConcept(child, path+'/subjectCodeableConcept')
      else if (child.localName = 'subjectReference') then
        value.subject := ParseReference(child, path+'/subjectReference')
      else if (child.localName = 'mustSupport') then
        value.mustSupportList.Add(ParseString(child, path+'/mustSupport'))
      else if (child.localName = 'codeFilter') then
        value.codeFilterList.Add(ParseDataRequirementCodeFilter(child, path+'/codeFilter'))
      else if (child.localName = 'dateFilter') then
        value.dateFilterList.Add(ParseDataRequirementDateFilter(child, path+'/dateFilter'))
      else if (child.localName = 'valueFilter') then
        value.valueFilterList.Add(ParseDataRequirementValueFilter(child, path+'/valueFilter'))
      else if (child.localName = 'limit') then
        value.limitElement := ParsePositiveInt(child, path+'/limit')
      else if (child.localName = 'sort') then
        value.sortList.Add(ParseDataRequirementSort(child, path+'/sort'))
      else if Not ParseElementChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeDataRequirement(xml : TXmlBuilder; name : String; value : TFhirDataRequirement);
begin
  if (value = nil) then
    exit;
  composeElementAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeDataRequirementChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeDataRequirementChildren(xml : TXmlBuilder; value : TFhirDataRequirement);
var
  i : integer;
begin
  composeDataTypeChildren(xml, value);
  ComposeEnum(xml, 'type', value.type_Element, CODES_TFhirFHIRTypesEnum);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.profileList.Count - 1 do
      ComposeCanonical(xml, 'profile', value.profileList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) and (value.subject is TFhirCodeableConcept) {6} then
    ComposeCodeableConcept(xml, 'subjectCodeableConcept', TFhirCodeableConcept(value.subject))
  else if (SummaryOption in [soFull, soSummary, soData]) and (value.subject is TFhirReference) {2} then
    ComposeReference(xml, 'subjectReference', TFhirReference(value.subject));
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.mustSupportList.Count - 1 do
      ComposeString(xml, 'mustSupport', value.mustSupportList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.codeFilterList.Count - 1 do
      ComposeDataRequirementCodeFilter(xml, 'codeFilter', value.codeFilterList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.dateFilterList.Count - 1 do
      ComposeDataRequirementDateFilter(xml, 'dateFilter', value.dateFilterList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.valueFilterList.Count - 1 do
      ComposeDataRequirementValueFilter(xml, 'valueFilter', value.valueFilterList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposePositiveInt(xml, 'limit', value.limitElement);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.sortList.Count - 1 do
      ComposeDataRequirementSort(xml, 'sort', value.sortList[i]);
end;

function TFHIRXmlParser.ParseExpression(element : TMXmlElement; path : string) : TFhirExpression;
var
  child : TMXmlElement;
begin
  result := TFhirExpression.Create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseExpressionChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseExpressionChild(value : TFhirExpression; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'description') then
        value.descriptionElement := ParseString(child, path+'/description')
      else if (child.localName = 'name') then
        value.nameElement := ParseId(child, path+'/name')
      else if (child.localName = 'language') then
        value.languageElement := ParseCode(child, path+'/language')
      else if (child.localName = 'expression') then
        value.expressionElement := ParseString(child, path+'/expression')
      else if (child.localName = 'reference') then
        value.referenceElement := ParseUri(child, path+'/reference')
      else if Not ParseElementChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeExpression(xml : TXmlBuilder; name : String; value : TFhirExpression);
begin
  if (value = nil) then
    exit;
  composeElementAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeExpressionChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeExpressionChildren(xml : TXmlBuilder; value : TFhirExpression);
begin
  composeDataTypeChildren(xml, value);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(xml, 'description', value.descriptionElement);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeId(xml, 'name', value.nameElement);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCode(xml, 'language', value.languageElement);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(xml, 'expression', value.expressionElement);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeUri(xml, 'reference', value.referenceElement);
end;

function TFHIRXmlParser.ParseExtendedContactDetail(element : TMXmlElement; path : string) : TFhirExtendedContactDetail;
var
  child : TMXmlElement;
begin
  result := TFhirExtendedContactDetail.Create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseExtendedContactDetailChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseExtendedContactDetailChild(value : TFhirExtendedContactDetail; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'purpose') then
        value.purpose := ParseCodeableConcept(child, path+'/purpose')
      else if (child.localName = 'name') then
        value.nameList.Add(ParseHumanName(child, path+'/name'))
      else if (child.localName = 'telecom') then
        value.telecomList.Add(ParseContactPoint(child, path+'/telecom'))
      else if (child.localName = 'address') then
        value.address := ParseAddress(child, path+'/address')
      else if (child.localName = 'organization') then
        value.organization := ParseReference(child, path+'/organization')
      else if (child.localName = 'period') then
        value.period := ParsePeriod(child, path+'/period')
      else if Not ParseElementChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeExtendedContactDetail(xml : TXmlBuilder; name : String; value : TFhirExtendedContactDetail);
begin
  if (value = nil) then
    exit;
  composeElementAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeExtendedContactDetailChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeExtendedContactDetailChildren(xml : TXmlBuilder; value : TFhirExtendedContactDetail);
var
  i : integer;
begin
  composeDataTypeChildren(xml, value);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(xml, 'purpose', value.purpose);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.nameList.Count - 1 do
      ComposeHumanName(xml, 'name', value.nameList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.telecomList.Count - 1 do
      ComposeContactPoint(xml, 'telecom', value.telecomList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeAddress(xml, 'address', value.address);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference(xml, 'organization', value.organization);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposePeriod(xml, 'period', value.period);
end;

function TFHIRXmlParser.ParseExtension(element : TMXmlElement; path : string) : TFhirExtension;
var
  child : TMXmlElement;
begin
  result := TFhirExtension.Create;
  try
    parseElementAttributes(result, path, element);
    result.url := GetAttribute(element, 'url');
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseExtensionChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseExtensionChild(value : TFhirExtension; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'valueCanonical') then
        value.value := ParseCanonical(child, path+'/valueCanonical')
      else if (child.localName = 'valueCode') then
        value.value := ParseCode(child, path+'/valueCode')
      else if (child.localName = 'valueId') then
        value.value := ParseId(child, path+'/valueId')
      else if (child.localName = 'valueMarkdown') then
        value.value := ParseMarkdown(child, path+'/valueMarkdown')
      else if (child.localName = 'valueOid') then
        value.value := ParseOid(child, path+'/valueOid')
      else if (child.localName = 'valuePositiveInt') then
        value.value := ParsePositiveInt(child, path+'/valuePositiveInt')
      else if (child.localName = 'valueUnsignedInt') then
        value.value := ParseUnsignedInt(child, path+'/valueUnsignedInt')
      else if (child.localName = 'valueUrl') then
        value.value := ParseUrl(child, path+'/valueUrl')
      else if (child.localName = 'valueUuid') then
        value.value := ParseUuid(child, path+'/valueUuid')
      else if (child.localName = 'valueAddress') then
        value.value := ParseAddress(child, path+'/valueAddress')
      else if (child.localName = 'valueAge') then
        value.value := ParseAge(child, path+'/valueAge')
      else if (child.localName = 'valueAnnotation') then
        value.value := ParseAnnotation(child, path+'/valueAnnotation')
      else if (child.localName = 'valueAttachment') then
        value.value := ParseAttachment(child, path+'/valueAttachment')
      else if (child.localName = 'valueCodeableConcept') then
        value.value := ParseCodeableConcept(child, path+'/valueCodeableConcept')
      else if (child.localName = 'valueCodeableReference') then
        value.value := ParseCodeableReference(child, path+'/valueCodeableReference')
      else if (child.localName = 'valueCoding') then
        value.value := ParseCoding(child, path+'/valueCoding')
      else if (child.localName = 'valueContactPoint') then
        value.value := ParseContactPoint(child, path+'/valueContactPoint')
      else if (child.localName = 'valueCount') then
        value.value := ParseCount(child, path+'/valueCount')
      else if (child.localName = 'valueDistance') then
        value.value := ParseDistance(child, path+'/valueDistance')
      else if (child.localName = 'valueDuration') then
        value.value := ParseDuration(child, path+'/valueDuration')
      else if (child.localName = 'valueHumanName') then
        value.value := ParseHumanName(child, path+'/valueHumanName')
      else if (child.localName = 'valueIdentifier') then
        value.value := ParseIdentifier(child, path+'/valueIdentifier')
      else if (child.localName = 'valueMoney') then
        value.value := ParseMoney(child, path+'/valueMoney')
      else if (child.localName = 'valuePeriod') then
        value.value := ParsePeriod(child, path+'/valuePeriod')
      else if (child.localName = 'valueQuantity') then
        value.value := ParseQuantity(child, path+'/valueQuantity')
      else if (child.localName = 'valueRange') then
        value.value := ParseRange(child, path+'/valueRange')
      else if (child.localName = 'valueRatio') then
        value.value := ParseRatio(child, path+'/valueRatio')
      else if (child.localName = 'valueRatioRange') then
        value.value := ParseRatioRange(child, path+'/valueRatioRange')
      else if (child.localName = 'valueReference') then
        value.value := ParseReference(child, path+'/valueReference')
      else if (child.localName = 'valueSampledData') then
        value.value := ParseSampledData(child, path+'/valueSampledData')
      else if (child.localName = 'valueSignature') then
        value.value := ParseSignature(child, path+'/valueSignature')
      else if (child.localName = 'valueTiming') then
        value.value := ParseTiming(child, path+'/valueTiming')
      else if (child.localName = 'valueContactDetail') then
        value.value := ParseContactDetail(child, path+'/valueContactDetail')
      else if (child.localName = 'valueDataRequirement') then
        value.value := ParseDataRequirement(child, path+'/valueDataRequirement')
      else if (child.localName = 'valueExpression') then
        value.value := ParseExpression(child, path+'/valueExpression')
      else if (child.localName = 'valueParameterDefinition') then
        value.value := ParseParameterDefinition(child, path+'/valueParameterDefinition')
      else if (child.localName = 'valueRelatedArtifact') then
        value.value := ParseRelatedArtifact(child, path+'/valueRelatedArtifact')
      else if (child.localName = 'valueTriggerDefinition') then
        value.value := ParseTriggerDefinition(child, path+'/valueTriggerDefinition')
      else if (child.localName = 'valueUsageContext') then
        value.value := ParseUsageContext(child, path+'/valueUsageContext')
      else if (child.localName = 'valueAvailability') then
        value.value := ParseAvailability(child, path+'/valueAvailability')
      else if (child.localName = 'valueExtendedContactDetail') then
        value.value := ParseExtendedContactDetail(child, path+'/valueExtendedContactDetail')
      else if (child.localName = 'valueDosage') then
        value.value := ParseDosage(child, path+'/valueDosage')
      else if (child.localName = 'valueMeta') then
        value.value := ParseMeta(child, path+'/valueMeta')
      else if (child.localName = 'valueBase64Binary') then
        value.value := ParseBase64Binary(child, path+'/valueBase64Binary')
      else if (child.localName = 'valueBoolean') then
        value.value := ParseBoolean(child, path+'/valueBoolean')
      else if (child.localName = 'valueDate') then
        value.value := ParseDate(child, path+'/valueDate')
      else if (child.localName = 'valueDateTime') then
        value.value := ParseDateTime(child, path+'/valueDateTime')
      else if (child.localName = 'valueDecimal') then
        value.value := ParseDecimal(child, path+'/valueDecimal')
      else if (child.localName = 'valueInstant') then
        value.value := ParseInstant(child, path+'/valueInstant')
      else if (child.localName = 'valueInteger') then
        value.value := ParseInteger(child, path+'/valueInteger')
      else if (child.localName = 'valueInteger64') then
        value.value := ParseInteger64(child, path+'/valueInteger64')
      else if (child.localName = 'valueString') then
        value.value := ParseString(child, path+'/valueString')
      else if (child.localName = 'valueTime') then
        value.value := ParseTime(child, path+'/valueTime')
      else if (child.localName = 'valueUri') then
        value.value := ParseUri(child, path+'/valueUri')
      else if Not ParseElementChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeExtension(xml : TXmlBuilder; name : String; value : TFhirExtension);
begin
  if (value = nil) then
    exit;
  composeElementAttributes(xml, value);
  Attribute(xml, 'url', value.url  );
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeExtensionChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeExtensionChildren(xml : TXmlBuilder; value : TFhirExtension);
begin
  composeDataTypeChildren(xml, value);
  if (SummaryOption in [soFull, soData]) and (value.value is TFhirCanonical) {6} then
    ComposeCanonical(xml, 'valueCanonical', TFhirCanonical(value.value))
  else if (SummaryOption in [soFull, soData]) and (value.value is TFhirCode) {6} then
    ComposeCode(xml, 'valueCode', TFhirCode(value.value))
  else if (SummaryOption in [soFull, soData]) and (value.value is TFhirId) {6} then
    ComposeId(xml, 'valueId', TFhirId(value.value))
  else if (SummaryOption in [soFull, soData]) and (value.value is TFhirMarkdown) {6} then
    ComposeMarkdown(xml, 'valueMarkdown', TFhirMarkdown(value.value))
  else if (SummaryOption in [soFull, soData]) and (value.value is TFhirOid) {6} then
    ComposeOid(xml, 'valueOid', TFhirOid(value.value))
  else if (SummaryOption in [soFull, soData]) and (value.value is TFhirPositiveInt) {6} then
    ComposePositiveInt(xml, 'valuePositiveInt', TFhirPositiveInt(value.value))
  else if (SummaryOption in [soFull, soData]) and (value.value is TFhirUnsignedInt) {6} then
    ComposeUnsignedInt(xml, 'valueUnsignedInt', TFhirUnsignedInt(value.value))
  else if (SummaryOption in [soFull, soData]) and (value.value is TFhirUrl) {6} then
    ComposeUrl(xml, 'valueUrl', TFhirUrl(value.value))
  else if (SummaryOption in [soFull, soData]) and (value.value is TFhirUuid) {6} then
    ComposeUuid(xml, 'valueUuid', TFhirUuid(value.value))
  else if (SummaryOption in [soFull, soData]) and (value.value is TFhirAddress) {6} then
    ComposeAddress(xml, 'valueAddress', TFhirAddress(value.value))
  else if (SummaryOption in [soFull, soData]) and (value.value is TFhirAge) {6} then
    ComposeAge(xml, 'valueAge', TFhirAge(value.value))
  else if (SummaryOption in [soFull, soData]) and (value.value is TFhirAnnotation) {6} then
    ComposeAnnotation(xml, 'valueAnnotation', TFhirAnnotation(value.value))
  else if (SummaryOption in [soFull, soData]) and (value.value is TFhirAttachment) {6} then
    ComposeAttachment(xml, 'valueAttachment', TFhirAttachment(value.value))
  else if (SummaryOption in [soFull, soData]) and (value.value is TFhirCodeableConcept) {6} then
    ComposeCodeableConcept(xml, 'valueCodeableConcept', TFhirCodeableConcept(value.value))
  else if (SummaryOption in [soFull, soData]) and (value.value is TFhirCodeableReference) {6} then
    ComposeCodeableReference(xml, 'valueCodeableReference', TFhirCodeableReference(value.value))
  else if (SummaryOption in [soFull, soData]) and (value.value is TFhirCoding) {6} then
    ComposeCoding(xml, 'valueCoding', TFhirCoding(value.value))
  else if (SummaryOption in [soFull, soData]) and (value.value is TFhirContactPoint) {6} then
    ComposeContactPoint(xml, 'valueContactPoint', TFhirContactPoint(value.value))
  else if (SummaryOption in [soFull, soData]) and (value.value is TFhirCount) {6} then
    ComposeCount(xml, 'valueCount', TFhirCount(value.value))
  else if (SummaryOption in [soFull, soData]) and (value.value is TFhirDistance) {6} then
    ComposeDistance(xml, 'valueDistance', TFhirDistance(value.value))
  else if (SummaryOption in [soFull, soData]) and (value.value is TFhirDuration) {6} then
    ComposeDuration(xml, 'valueDuration', TFhirDuration(value.value))
  else if (SummaryOption in [soFull, soData]) and (value.value is TFhirHumanName) {6} then
    ComposeHumanName(xml, 'valueHumanName', TFhirHumanName(value.value))
  else if (SummaryOption in [soFull, soData]) and (value.value is TFhirIdentifier) {6} then
    ComposeIdentifier(xml, 'valueIdentifier', TFhirIdentifier(value.value))
  else if (SummaryOption in [soFull, soData]) and (value.value is TFhirMoney) {6} then
    ComposeMoney(xml, 'valueMoney', TFhirMoney(value.value))
  else if (SummaryOption in [soFull, soData]) and (value.value is TFhirPeriod) {6} then
    ComposePeriod(xml, 'valuePeriod', TFhirPeriod(value.value))
  else if (SummaryOption in [soFull, soData]) and (value.value is TFhirQuantity) {6} then
    ComposeQuantity(xml, 'valueQuantity', TFhirQuantity(value.value))
  else if (SummaryOption in [soFull, soData]) and (value.value is TFhirRange) {6} then
    ComposeRange(xml, 'valueRange', TFhirRange(value.value))
  else if (SummaryOption in [soFull, soData]) and (value.value is TFhirRatio) {6} then
    ComposeRatio(xml, 'valueRatio', TFhirRatio(value.value))
  else if (SummaryOption in [soFull, soData]) and (value.value is TFhirRatioRange) {6} then
    ComposeRatioRange(xml, 'valueRatioRange', TFhirRatioRange(value.value))
  else if (SummaryOption in [soFull, soData]) and (value.value is TFhirReference) {6} then
    ComposeReference(xml, 'valueReference', TFhirReference(value.value))
  else if (SummaryOption in [soFull, soData]) and (value.value is TFhirSampledData) {6} then
    ComposeSampledData(xml, 'valueSampledData', TFhirSampledData(value.value))
  else if (SummaryOption in [soFull, soData]) and (value.value is TFhirSignature) {6} then
    ComposeSignature(xml, 'valueSignature', TFhirSignature(value.value))
  else if (SummaryOption in [soFull, soData]) and (value.value is TFhirTiming) {6} then
    ComposeTiming(xml, 'valueTiming', TFhirTiming(value.value))
  else if (SummaryOption in [soFull, soData]) and (value.value is TFhirContactDetail) {6} then
    ComposeContactDetail(xml, 'valueContactDetail', TFhirContactDetail(value.value))
  else if (SummaryOption in [soFull, soData]) and (value.value is TFhirDataRequirement) {6} then
    ComposeDataRequirement(xml, 'valueDataRequirement', TFhirDataRequirement(value.value))
  else if (SummaryOption in [soFull, soData]) and (value.value is TFhirExpression) {6} then
    ComposeExpression(xml, 'valueExpression', TFhirExpression(value.value))
  else if (SummaryOption in [soFull, soData]) and (value.value is TFhirParameterDefinition) {6} then
    ComposeParameterDefinition(xml, 'valueParameterDefinition', TFhirParameterDefinition(value.value))
  else if (SummaryOption in [soFull, soData]) and (value.value is TFhirRelatedArtifact) {6} then
    ComposeRelatedArtifact(xml, 'valueRelatedArtifact', TFhirRelatedArtifact(value.value))
  else if (SummaryOption in [soFull, soData]) and (value.value is TFhirTriggerDefinition) {6} then
    ComposeTriggerDefinition(xml, 'valueTriggerDefinition', TFhirTriggerDefinition(value.value))
  else if (SummaryOption in [soFull, soData]) and (value.value is TFhirUsageContext) {6} then
    ComposeUsageContext(xml, 'valueUsageContext', TFhirUsageContext(value.value))
  else if (SummaryOption in [soFull, soData]) and (value.value is TFhirAvailability) {6} then
    ComposeAvailability(xml, 'valueAvailability', TFhirAvailability(value.value))
  else if (SummaryOption in [soFull, soData]) and (value.value is TFhirExtendedContactDetail) {6} then
    ComposeExtendedContactDetail(xml, 'valueExtendedContactDetail', TFhirExtendedContactDetail(value.value))
  else if (SummaryOption in [soFull, soData]) and (value.value is TFhirDosage) {6} then
    ComposeDosage(xml, 'valueDosage', TFhirDosage(value.value))
  else if (SummaryOption in [soFull, soData]) and (value.value is TFhirMeta) {6} then
    ComposeMeta(xml, 'valueMeta', TFhirMeta(value.value))
  else if (SummaryOption in [soFull, soData]) and (value.value is TFhirBase64Binary) {6} then
    ComposeBase64Binary(xml, 'valueBase64Binary', TFhirBase64Binary(value.value))
  else if (SummaryOption in [soFull, soData]) and (value.value is TFhirBoolean) {6} then
    ComposeBoolean(xml, 'valueBoolean', TFhirBoolean(value.value))
  else if (SummaryOption in [soFull, soData]) and (value.value is TFhirDate) {6} then
    ComposeDate(xml, 'valueDate', TFhirDate(value.value))
  else if (SummaryOption in [soFull, soData]) and (value.value is TFhirDateTime) {6} then
    ComposeDateTime(xml, 'valueDateTime', TFhirDateTime(value.value))
  else if (SummaryOption in [soFull, soData]) and (value.value is TFhirDecimal) {6} then
    ComposeDecimal(xml, 'valueDecimal', TFhirDecimal(value.value))
  else if (SummaryOption in [soFull, soData]) and (value.value is TFhirInstant) {6} then
    ComposeInstant(xml, 'valueInstant', TFhirInstant(value.value))
  else if (SummaryOption in [soFull, soData]) and (value.value is TFhirInteger) {6} then
    ComposeInteger(xml, 'valueInteger', TFhirInteger(value.value))
  else if (SummaryOption in [soFull, soData]) and (value.value is TFhirInteger64) {6} then
    ComposeInteger64(xml, 'valueInteger64', TFhirInteger64(value.value))
  else if (SummaryOption in [soFull, soData]) and (value.value is TFhirString) {6} then
    ComposeString(xml, 'valueString', TFhirString(value.value))
  else if (SummaryOption in [soFull, soData]) and (value.value is TFhirTime) {6} then
    ComposeTime(xml, 'valueTime', TFhirTime(value.value))
  else if (SummaryOption in [soFull, soData]) and (value.value is TFhirUri) {6} then
    ComposeUri(xml, 'valueUri', TFhirUri(value.value));
end;

function TFHIRXmlParser.ParseHumanName(element : TMXmlElement; path : string) : TFhirHumanName;
var
  child : TMXmlElement;
begin
  result := TFhirHumanName.Create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseHumanNameChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseHumanNameChild(value : TFhirHumanName; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'use') then
        value.useElement := ParseEnum(CODES_TFhirNameUseEnum, SYSTEMS_TFhirNameUseEnum, child, path+'/use')
      else if (child.localName = 'text') then
        value.textElement := ParseString(child, path+'/text')
      else if (child.localName = 'family') then
        value.familyElement := ParseString(child, path+'/family')
      else if (child.localName = 'given') then
        value.givenList.Add(ParseString(child, path+'/given'))
      else if (child.localName = 'prefix') then
        value.prefixList.Add(ParseString(child, path+'/prefix'))
      else if (child.localName = 'suffix') then
        value.suffixList.Add(ParseString(child, path+'/suffix'))
      else if (child.localName = 'period') then
        value.period := ParsePeriod(child, path+'/period')
      else if Not ParseElementChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeHumanName(xml : TXmlBuilder; name : String; value : TFhirHumanName);
begin
  if (value = nil) then
    exit;
  composeElementAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeHumanNameChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeHumanNameChildren(xml : TXmlBuilder; value : TFhirHumanName);
var
  i : integer;
begin
  composeDataTypeChildren(xml, value);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeEnum(xml, 'use', value.useElement, CODES_TFhirNameUseEnum);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(xml, 'text', value.textElement);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(xml, 'family', value.familyElement);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.givenList.Count - 1 do
      ComposeString(xml, 'given', value.givenList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.prefixList.Count - 1 do
      ComposeString(xml, 'prefix', value.prefixList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.suffixList.Count - 1 do
      ComposeString(xml, 'suffix', value.suffixList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposePeriod(xml, 'period', value.period);
end;

function TFHIRXmlParser.ParseIdentifier(element : TMXmlElement; path : string) : TFhirIdentifier;
var
  child : TMXmlElement;
begin
  result := TFhirIdentifier.Create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseIdentifierChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseIdentifierChild(value : TFhirIdentifier; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'use') then
        value.useElement := ParseEnum(CODES_TFhirIdentifierUseEnum, SYSTEMS_TFhirIdentifierUseEnum, child, path+'/use')
      else if (child.localName = 'type') then
        value.type_ := ParseCodeableConcept(child, path+'/type')
      else if (child.localName = 'system') then
        value.systemElement := ParseUri(child, path+'/system')
      else if (child.localName = 'value') then
        value.valueElement := ParseString(child, path+'/value')
      else if (child.localName = 'period') then
        value.period := ParsePeriod(child, path+'/period')
      else if (child.localName = 'assigner') then
        value.assigner := ParseReference(child, path+'/assigner')
      else if Not ParseElementChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeIdentifier(xml : TXmlBuilder; name : String; value : TFhirIdentifier);
begin
  if (value = nil) then
    exit;
  composeElementAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeIdentifierChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeIdentifierChildren(xml : TXmlBuilder; value : TFhirIdentifier);
begin
  composeDataTypeChildren(xml, value);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeEnum(xml, 'use', value.useElement, CODES_TFhirIdentifierUseEnum);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(xml, 'type', value.type_);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeUri(xml, 'system', value.systemElement);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(xml, 'value', value.valueElement);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposePeriod(xml, 'period', value.period);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference(xml, 'assigner', value.assigner);
end;

function TFHIRXmlParser.ParseMeta(element : TMXmlElement; path : string) : TFhirMeta;
var
  child : TMXmlElement;
begin
  result := TFhirMeta.Create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseMetaChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseMetaChild(value : TFhirMeta; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'versionId') then
        value.versionIdElement := ParseId(child, path+'/versionId')
      else if (child.localName = 'lastUpdated') then
        value.lastUpdatedElement := ParseInstant(child, path+'/lastUpdated')
      else if (child.localName = 'source') then
        value.sourceElement := ParseUri(child, path+'/source')
      else if (child.localName = 'profile') then
        value.profileList.Add(ParseCanonical(child, path+'/profile'))
      else if (child.localName = 'security') then
        value.securityList.Add(ParseCoding(child, path+'/security'))
      else if (child.localName = 'tag') then
        value.tagList.Add(ParseCoding(child, path+'/tag'))
      else if Not ParseElementChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeMeta(xml : TXmlBuilder; name : String; value : TFhirMeta);
begin
  if (value = nil) then
    exit;
  composeElementAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeMetaChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeMetaChildren(xml : TXmlBuilder; value : TFhirMeta);
var
  i : integer;
begin
  composeDataTypeChildren(xml, value);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeId(xml, 'versionId', value.versionIdElement);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeInstant(xml, 'lastUpdated', value.lastUpdatedElement);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeUri(xml, 'source', value.sourceElement);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.profileList.Count - 1 do
      ComposeCanonical(xml, 'profile', value.profileList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.securityList.Count - 1 do
      ComposeCoding(xml, 'security', value.securityList[i]);
  for i := 0 to value.tagList.Count - 1 do
    if (SummaryOption in [soFull, soSummary, soData]) or isSubsettedTag(value.tagList[i]) then
      ComposeCoding(xml, 'tag', value.tagList[i]);
end;

function TFHIRXmlParser.ParseMonetaryComponent(element : TMXmlElement; path : string) : TFhirMonetaryComponent;
var
  child : TMXmlElement;
begin
  result := TFhirMonetaryComponent.Create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseMonetaryComponentChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseMonetaryComponentChild(value : TFhirMonetaryComponent; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'type') then
        value.type_Element := ParseEnum(CODES_TFhirPriceComponentTypeEnum, SYSTEMS_TFhirPriceComponentTypeEnum, child, path+'/type')
      else if (child.localName = 'code') then
        value.code := ParseCodeableConcept(child, path+'/code')
      else if (child.localName = 'factor') then
        value.factorElement := ParseDecimal(child, path+'/factor')
      else if (child.localName = 'amount') then
        value.amount := ParseMoney(child, path+'/amount')
      else if Not ParseElementChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeMonetaryComponent(xml : TXmlBuilder; name : String; value : TFhirMonetaryComponent);
begin
  if (value = nil) then
    exit;
  composeElementAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeMonetaryComponentChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeMonetaryComponentChildren(xml : TXmlBuilder; value : TFhirMonetaryComponent);
begin
  composeDataTypeChildren(xml, value);
  ComposeEnum(xml, 'type', value.type_Element, CODES_TFhirPriceComponentTypeEnum);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(xml, 'code', value.code);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDecimal(xml, 'factor', value.factorElement);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeMoney(xml, 'amount', value.amount);
end;

function TFHIRXmlParser.ParseMoney(element : TMXmlElement; path : string) : TFhirMoney;
var
  child : TMXmlElement;
begin
  result := TFhirMoney.Create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseMoneyChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseMoneyChild(value : TFhirMoney; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'value') then
        value.valueElement := ParseDecimal(child, path+'/value')
      else if (child.localName = 'currency') then
        value.currencyElement := ParseCode(child, path+'/currency')
      else if Not ParseElementChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeMoney(xml : TXmlBuilder; name : String; value : TFhirMoney);
begin
  if (value = nil) then
    exit;
  composeElementAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeMoneyChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeMoneyChildren(xml : TXmlBuilder; value : TFhirMoney);
begin
  composeDataTypeChildren(xml, value);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDecimal(xml, 'value', value.valueElement);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCode(xml, 'currency', value.currencyElement);
end;

function TFHIRXmlParser.ParseNarrative(element : TMXmlElement; path : string) : TFhirNarrative;
var
  child : TMXmlElement;
begin
  result := TFhirNarrative.Create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseNarrativeChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseNarrativeChild(value : TFhirNarrative; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'status') then
        value.statusElement := ParseEnum(CODES_TFhirNarrativeStatusEnum, SYSTEMS_TFhirNarrativeStatusEnum, child, path+'/status')
      else if (child.localName = 'div') then
        value.div_ := ParseXHtmlNode(child, path+'/div')
      else if Not ParseElementChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeNarrative(xml : TXmlBuilder; name : String; value : TFhirNarrative);
begin
  if (value = nil) then
    exit;
  composeElementAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeNarrativeChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeNarrativeChildren(xml : TXmlBuilder; value : TFhirNarrative);
begin
  composeDataTypeChildren(xml, value);
  ComposeEnum(xml, 'status', value.statusElement, CODES_TFhirNarrativeStatusEnum);
  ComposeXHtmlNode(xml, 'div', value.div_);
end;

function TFHIRXmlParser.ParseParameterDefinition(element : TMXmlElement; path : string) : TFhirParameterDefinition;
var
  child : TMXmlElement;
begin
  result := TFhirParameterDefinition.Create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseParameterDefinitionChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseParameterDefinitionChild(value : TFhirParameterDefinition; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'name') then
        value.nameElement := ParseCode(child, path+'/name')
      else if (child.localName = 'use') then
        value.useElement := ParseEnum(CODES_TFhirOperationParameterUseEnum, SYSTEMS_TFhirOperationParameterUseEnum, child, path+'/use')
      else if (child.localName = 'min') then
        value.minElement := ParseInteger(child, path+'/min')
      else if (child.localName = 'max') then
        value.maxElement := ParseString(child, path+'/max')
      else if (child.localName = 'documentation') then
        value.documentationElement := ParseString(child, path+'/documentation')
      else if (child.localName = 'type') then
        value.type_Element := ParseEnum(CODES_TFhirFHIRTypesEnum, SYSTEMS_TFhirFHIRTypesEnum, child, path+'/type')
      else if (child.localName = 'profile') then
        value.profileElement := ParseCanonical(child, path+'/profile')
      else if Not ParseElementChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeParameterDefinition(xml : TXmlBuilder; name : String; value : TFhirParameterDefinition);
begin
  if (value = nil) then
    exit;
  composeElementAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeParameterDefinitionChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeParameterDefinitionChildren(xml : TXmlBuilder; value : TFhirParameterDefinition);
begin
  composeDataTypeChildren(xml, value);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCode(xml, 'name', value.nameElement);
  ComposeEnum(xml, 'use', value.useElement, CODES_TFhirOperationParameterUseEnum);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeInteger(xml, 'min', value.minElement);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(xml, 'max', value.maxElement);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(xml, 'documentation', value.documentationElement);
  ComposeEnum(xml, 'type', value.type_Element, CODES_TFhirFHIRTypesEnum);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCanonical(xml, 'profile', value.profileElement);
end;

function TFHIRXmlParser.ParsePeriod(element : TMXmlElement; path : string) : TFhirPeriod;
var
  child : TMXmlElement;
begin
  result := TFhirPeriod.Create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParsePeriodChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParsePeriodChild(value : TFhirPeriod; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'start') then
        value.startElement := ParseDateTime(child, path+'/start')
      else if (child.localName = 'end') then
        value.end_Element := ParseDateTime(child, path+'/end')
      else if Not ParseElementChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposePeriod(xml : TXmlBuilder; name : String; value : TFhirPeriod);
begin
  if (value = nil) then
    exit;
  composeElementAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composePeriodChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposePeriodChildren(xml : TXmlBuilder; value : TFhirPeriod);
begin
  composeDataTypeChildren(xml, value);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDateTime(xml, 'start', value.startElement);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDateTime(xml, 'end', value.end_Element);
end;

function TFHIRXmlParser.ParseQuantity(element : TMXmlElement; path : string) : TFhirQuantity;
var
  child : TMXmlElement;
begin
  result := TFhirQuantity.Create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseQuantityChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseQuantityChild(value : TFhirQuantity; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'value') then
        value.valueElement := ParseDecimal(child, path+'/value')
      else if (child.localName = 'comparator') then
        value.comparatorElement := ParseEnum(CODES_TFhirQuantityComparatorEnum, SYSTEMS_TFhirQuantityComparatorEnum, child, path+'/comparator')
      else if (child.localName = 'unit') then
        value.unit_Element := ParseString(child, path+'/unit')
      else if (child.localName = 'system') then
        value.systemElement := ParseUri(child, path+'/system')
      else if (child.localName = 'code') then
        value.codeElement := ParseCode(child, path+'/code')
      else if Not ParseElementChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeQuantity(xml : TXmlBuilder; name : String; value : TFhirQuantity);
begin
  if (value = nil) then
    exit;
  composeElementAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeQuantityChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeQuantityChildren(xml : TXmlBuilder; value : TFhirQuantity);
begin
  composeDataTypeChildren(xml, value);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDecimal(xml, 'value', value.valueElement);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeEnum(xml, 'comparator', value.comparatorElement, CODES_TFhirQuantityComparatorEnum);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(xml, 'unit', value.unit_Element);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeUri(xml, 'system', value.systemElement);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCode(xml, 'code', value.codeElement);
end;

function TFHIRXmlParser.ParseRange(element : TMXmlElement; path : string) : TFhirRange;
var
  child : TMXmlElement;
begin
  result := TFhirRange.Create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseRangeChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseRangeChild(value : TFhirRange; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'low') then
        value.low := ParseQuantity(child, path+'/low')
      else if (child.localName = 'high') then
        value.high := ParseQuantity(child, path+'/high')
      else if Not ParseElementChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeRange(xml : TXmlBuilder; name : String; value : TFhirRange);
begin
  if (value = nil) then
    exit;
  composeElementAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeRangeChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeRangeChildren(xml : TXmlBuilder; value : TFhirRange);
begin
  composeDataTypeChildren(xml, value);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeQuantity(xml, 'low', value.low);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeQuantity(xml, 'high', value.high);
end;

function TFHIRXmlParser.ParseRatio(element : TMXmlElement; path : string) : TFhirRatio;
var
  child : TMXmlElement;
begin
  result := TFhirRatio.Create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseRatioChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseRatioChild(value : TFhirRatio; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'numerator') then
        value.numerator := ParseQuantity(child, path+'/numerator')
      else if (child.localName = 'denominator') then
        value.denominator := ParseQuantity(child, path+'/denominator')
      else if Not ParseElementChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeRatio(xml : TXmlBuilder; name : String; value : TFhirRatio);
begin
  if (value = nil) then
    exit;
  composeElementAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeRatioChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeRatioChildren(xml : TXmlBuilder; value : TFhirRatio);
begin
  composeDataTypeChildren(xml, value);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeQuantity(xml, 'numerator', value.numerator);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeQuantity(xml, 'denominator', value.denominator);
end;

function TFHIRXmlParser.ParseRatioRange(element : TMXmlElement; path : string) : TFhirRatioRange;
var
  child : TMXmlElement;
begin
  result := TFhirRatioRange.Create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseRatioRangeChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseRatioRangeChild(value : TFhirRatioRange; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'lowNumerator') then
        value.lowNumerator := ParseQuantity(child, path+'/lowNumerator')
      else if (child.localName = 'highNumerator') then
        value.highNumerator := ParseQuantity(child, path+'/highNumerator')
      else if (child.localName = 'denominator') then
        value.denominator := ParseQuantity(child, path+'/denominator')
      else if Not ParseElementChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeRatioRange(xml : TXmlBuilder; name : String; value : TFhirRatioRange);
begin
  if (value = nil) then
    exit;
  composeElementAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeRatioRangeChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeRatioRangeChildren(xml : TXmlBuilder; value : TFhirRatioRange);
begin
  composeDataTypeChildren(xml, value);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeQuantity(xml, 'lowNumerator', value.lowNumerator);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeQuantity(xml, 'highNumerator', value.highNumerator);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeQuantity(xml, 'denominator', value.denominator);
end;

function TFHIRXmlParser.ParseReference(element : TMXmlElement; path : string) : TFhirReference;
var
  child : TMXmlElement;
begin
  result := TFhirReference.Create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseReferenceChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseReferenceChild(value : TFhirReference; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'reference') then
        value.referenceElement := ParseString(child, path+'/reference')
      else if (child.localName = 'type') then
        value.type_Element := ParseUri(child, path+'/type')
      else if (child.localName = 'identifier') then
        value.identifier := ParseIdentifier(child, path+'/identifier')
      else if (child.localName = 'display') then
        value.displayElement := ParseString(child, path+'/display')
      else if Not ParseElementChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeReference(xml : TXmlBuilder; name : String; value : TFhirReference);
begin
  if (value = nil) then
    exit;
  composeElementAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeReferenceChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeReferenceChildren(xml : TXmlBuilder; value : TFhirReference);
begin
  composeDataTypeChildren(xml, value);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(xml, 'reference', value.referenceElement);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeUri(xml, 'type', value.type_Element);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeIdentifier(xml, 'identifier', value.identifier);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(xml, 'display', value.displayElement);
end;

function TFHIRXmlParser.ParseRelatedArtifact(element : TMXmlElement; path : string) : TFhirRelatedArtifact;
var
  child : TMXmlElement;
begin
  result := TFhirRelatedArtifact.Create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseRelatedArtifactChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseRelatedArtifactChild(value : TFhirRelatedArtifact; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'type') then
        value.type_Element := ParseEnum(CODES_TFhirRelatedArtifactTypeEnum, SYSTEMS_TFhirRelatedArtifactTypeEnum, child, path+'/type')
      else if (child.localName = 'classifier') then
        value.classifierList.Add(ParseCodeableConcept(child, path+'/classifier'))
      else if (child.localName = 'label') then
        value.label_Element := ParseString(child, path+'/label')
      else if (child.localName = 'display') then
        value.displayElement := ParseString(child, path+'/display')
      else if (child.localName = 'citation') then
        value.citationElement := ParseMarkdown(child, path+'/citation')
      else if (child.localName = 'document') then
        value.document := ParseAttachment(child, path+'/document')
      else if (child.localName = 'resource') then
        value.resourceElement := ParseCanonical(child, path+'/resource')
      else if (child.localName = 'resourceReference') then
        value.resourceReference := ParseReference(child, path+'/resourceReference')
      else if (child.localName = 'publicationStatus') then
        value.publicationStatusElement := ParseEnum(CODES_TFhirPublicationStatusEnum, SYSTEMS_TFhirPublicationStatusEnum, child, path+'/publicationStatus')
      else if (child.localName = 'publicationDate') then
        value.publicationDateElement := ParseDate(child, path+'/publicationDate')
      else if Not ParseElementChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeRelatedArtifact(xml : TXmlBuilder; name : String; value : TFhirRelatedArtifact);
begin
  if (value = nil) then
    exit;
  composeElementAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeRelatedArtifactChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeRelatedArtifactChildren(xml : TXmlBuilder; value : TFhirRelatedArtifact);
var
  i : integer;
begin
  composeDataTypeChildren(xml, value);
  ComposeEnum(xml, 'type', value.type_Element, CODES_TFhirRelatedArtifactTypeEnum);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.classifierList.Count - 1 do
      ComposeCodeableConcept(xml, 'classifier', value.classifierList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(xml, 'label', value.label_Element);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(xml, 'display', value.displayElement);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeMarkdown(xml, 'citation', value.citationElement);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeAttachment(xml, 'document', value.document);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCanonical(xml, 'resource', value.resourceElement);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference(xml, 'resourceReference', value.resourceReference);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeEnum(xml, 'publicationStatus', value.publicationStatusElement, CODES_TFhirPublicationStatusEnum);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDate(xml, 'publicationDate', value.publicationDateElement);
end;

function TFHIRXmlParser.ParseSampledData(element : TMXmlElement; path : string) : TFhirSampledData;
var
  child : TMXmlElement;
begin
  result := TFhirSampledData.Create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseSampledDataChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseSampledDataChild(value : TFhirSampledData; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'origin') then
        value.origin := ParseQuantity(child, path+'/origin')
      else if (child.localName = 'interval') then
        value.intervalElement := ParseDecimal(child, path+'/interval')
      else if (child.localName = 'intervalUnit') then
        value.intervalUnitElement := ParseCode(child, path+'/intervalUnit')
      else if (child.localName = 'factor') then
        value.factorElement := ParseDecimal(child, path+'/factor')
      else if (child.localName = 'lowerLimit') then
        value.lowerLimitElement := ParseDecimal(child, path+'/lowerLimit')
      else if (child.localName = 'upperLimit') then
        value.upperLimitElement := ParseDecimal(child, path+'/upperLimit')
      else if (child.localName = 'dimensions') then
        value.dimensionsElement := ParsePositiveInt(child, path+'/dimensions')
      else if (child.localName = 'data') then
        value.dataElement := ParseString(child, path+'/data')
      else if Not ParseElementChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeSampledData(xml : TXmlBuilder; name : String; value : TFhirSampledData);
begin
  if (value = nil) then
    exit;
  composeElementAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeSampledDataChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeSampledDataChildren(xml : TXmlBuilder; value : TFhirSampledData);
begin
  composeDataTypeChildren(xml, value);
  ComposeQuantity(xml, 'origin', value.origin);
  ComposeDecimal(xml, 'interval', value.intervalElement);
  ComposeCode(xml, 'intervalUnit', value.intervalUnitElement);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDecimal(xml, 'factor', value.factorElement);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDecimal(xml, 'lowerLimit', value.lowerLimitElement);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDecimal(xml, 'upperLimit', value.upperLimitElement);
  ComposePositiveInt(xml, 'dimensions', value.dimensionsElement);
  if (SummaryOption in [soFull, soData]) then
    ComposeString(xml, 'data', value.dataElement);
end;

function TFHIRXmlParser.ParseSignature(element : TMXmlElement; path : string) : TFhirSignature;
var
  child : TMXmlElement;
begin
  result := TFhirSignature.Create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseSignatureChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseSignatureChild(value : TFhirSignature; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'type') then
        value.type_List.Add(ParseCoding(child, path+'/type'))
      else if (child.localName = 'when') then
        value.whenElement := ParseInstant(child, path+'/when')
      else if (child.localName = 'who') then
        value.who := ParseReference(child, path+'/who')
      else if (child.localName = 'onBehalfOf') then
        value.onBehalfOf := ParseReference(child, path+'/onBehalfOf')
      else if (child.localName = 'targetFormat') then
        value.targetFormatElement := ParseCode(child, path+'/targetFormat')
      else if (child.localName = 'sigFormat') then
        value.sigFormatElement := ParseCode(child, path+'/sigFormat')
      else if (child.localName = 'data') then
        value.dataElement := ParseBase64Binary(child, path+'/data')
      else if Not ParseElementChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeSignature(xml : TXmlBuilder; name : String; value : TFhirSignature);
begin
  if (value = nil) then
    exit;
  composeElementAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeSignatureChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeSignatureChildren(xml : TXmlBuilder; value : TFhirSignature);
var
  i : integer;
begin
  composeDataTypeChildren(xml, value);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.type_List.Count - 1 do
      ComposeCoding(xml, 'type', value.type_List[i]);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeInstant(xml, 'when', value.whenElement);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference(xml, 'who', value.who);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference(xml, 'onBehalfOf', value.onBehalfOf);
  if (SummaryOption in [soFull, soData]) then
    ComposeCode(xml, 'targetFormat', value.targetFormatElement);
  if (SummaryOption in [soFull, soData]) then
    ComposeCode(xml, 'sigFormat', value.sigFormatElement);
  if (SummaryOption in [soFull, soData]) then
    ComposeBase64Binary(xml, 'data', value.dataElement);
end;

function TFHIRXmlParser.ParseTriggerDefinition(element : TMXmlElement; path : string) : TFhirTriggerDefinition;
var
  child : TMXmlElement;
begin
  result := TFhirTriggerDefinition.Create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseTriggerDefinitionChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseTriggerDefinitionChild(value : TFhirTriggerDefinition; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'type') then
        value.type_Element := ParseEnum(CODES_TFhirTriggerTypeEnum, SYSTEMS_TFhirTriggerTypeEnum, child, path+'/type')
      else if (child.localName = 'name') then
        value.nameElement := ParseString(child, path+'/name')
      else if (child.localName = 'code') then
        value.code := ParseCodeableConcept(child, path+'/code')
      else if (child.localName = 'subscriptionTopic') then
        value.subscriptionTopicElement := ParseCanonical(child, path+'/subscriptionTopic')
      else if (child.localName = 'timingTiming') then
        value.timing := ParseTiming(child, path+'/timingTiming')
      else if (child.localName = 'timingReference') then
        value.timing := ParseReference(child, path+'/timingReference')
      else if (child.localName = 'timingDate') then
        value.timing := ParseDate(child, path+'/timingDate')
      else if (child.localName = 'timingDateTime') then
        value.timing := ParseDateTime(child, path+'/timingDateTime')
      else if (child.localName = 'data') then
        value.dataList.Add(ParseDataRequirement(child, path+'/data'))
      else if (child.localName = 'condition') then
        value.condition := ParseExpression(child, path+'/condition')
      else if Not ParseElementChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeTriggerDefinition(xml : TXmlBuilder; name : String; value : TFhirTriggerDefinition);
begin
  if (value = nil) then
    exit;
  composeElementAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeTriggerDefinitionChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeTriggerDefinitionChildren(xml : TXmlBuilder; value : TFhirTriggerDefinition);
var
  i : integer;
begin
  composeDataTypeChildren(xml, value);
  ComposeEnum(xml, 'type', value.type_Element, CODES_TFhirTriggerTypeEnum);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(xml, 'name', value.nameElement);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(xml, 'code', value.code);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCanonical(xml, 'subscriptionTopic', value.subscriptionTopicElement);
  if (SummaryOption in [soFull, soSummary, soData]) and (value.timing is TFhirTiming) {6} then
    ComposeTiming(xml, 'timingTiming', TFhirTiming(value.timing))
  else if (SummaryOption in [soFull, soSummary, soData]) and (value.timing is TFhirReference) {2} then
    ComposeReference(xml, 'timingReference', TFhirReference(value.timing))
  else if (SummaryOption in [soFull, soSummary, soData]) and (value.timing is TFhirDate) {6} then
    ComposeDate(xml, 'timingDate', TFhirDate(value.timing))
  else if (SummaryOption in [soFull, soSummary, soData]) and (value.timing is TFhirDateTime) {6} then
    ComposeDateTime(xml, 'timingDateTime', TFhirDateTime(value.timing));
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.dataList.Count - 1 do
      ComposeDataRequirement(xml, 'data', value.dataList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeExpression(xml, 'condition', value.condition);
end;

function TFHIRXmlParser.ParseUsageContext(element : TMXmlElement; path : string) : TFhirUsageContext;
var
  child : TMXmlElement;
begin
  result := TFhirUsageContext.Create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseUsageContextChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseUsageContextChild(value : TFhirUsageContext; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'code') then
        value.code := ParseCoding(child, path+'/code')
      else if (child.localName = 'valueCodeableConcept') then
        value.value := ParseCodeableConcept(child, path+'/valueCodeableConcept')
      else if (child.localName = 'valueQuantity') then
        value.value := ParseQuantity(child, path+'/valueQuantity')
      else if (child.localName = 'valueRange') then
        value.value := ParseRange(child, path+'/valueRange')
      else if (child.localName = 'valueReference') then
        value.value := ParseReference(child, path+'/valueReference')
      else if Not ParseElementChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeUsageContext(xml : TXmlBuilder; name : String; value : TFhirUsageContext);
begin
  if (value = nil) then
    exit;
  composeElementAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeUsageContextChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeUsageContextChildren(xml : TXmlBuilder; value : TFhirUsageContext);
begin
  composeDataTypeChildren(xml, value);
  ComposeCoding(xml, 'code', value.code);
  if (value.value is TFhirCodeableConcept) {6} then
    ComposeCodeableConcept(xml, 'valueCodeableConcept', TFhirCodeableConcept(value.value))
  else if (value.value is TFhirQuantity) {6} then
    ComposeQuantity(xml, 'valueQuantity', TFhirQuantity(value.value))
  else if (value.value is TFhirRange) {6} then
    ComposeRange(xml, 'valueRange', TFhirRange(value.value))
  else if (value.value is TFhirReference) {2} then
    ComposeReference(xml, 'valueReference', TFhirReference(value.value));
end;

function TFHIRXmlParser.ParseVirtualServiceDetail(element : TMXmlElement; path : string) : TFhirVirtualServiceDetail;
var
  child : TMXmlElement;
begin
  result := TFhirVirtualServiceDetail.Create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseVirtualServiceDetailChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseVirtualServiceDetailChild(value : TFhirVirtualServiceDetail; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'channelType') then
        value.channelType := ParseCoding(child, path+'/channelType')
      else if (child.localName = 'addressUrl') then
        value.address := ParseUrl(child, path+'/addressUrl')
      else if (child.localName = 'addressContactPoint') then
        value.address := ParseContactPoint(child, path+'/addressContactPoint')
      else if (child.localName = 'addressExtendedContactDetail') then
        value.address := ParseExtendedContactDetail(child, path+'/addressExtendedContactDetail')
      else if (child.localName = 'addressString') then
        value.address := ParseString(child, path+'/addressString')
      else if (child.localName = 'additionalInfo') then
        value.additionalInfoList.Add(ParseUrl(child, path+'/additionalInfo'))
      else if (child.localName = 'maxParticipants') then
        value.maxParticipantsElement := ParsePositiveInt(child, path+'/maxParticipants')
      else if (child.localName = 'sessionKey') then
        value.sessionKeyElement := ParseString(child, path+'/sessionKey')
      else if Not ParseElementChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeVirtualServiceDetail(xml : TXmlBuilder; name : String; value : TFhirVirtualServiceDetail);
begin
  if (value = nil) then
    exit;
  composeElementAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeVirtualServiceDetailChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeVirtualServiceDetailChildren(xml : TXmlBuilder; value : TFhirVirtualServiceDetail);
var
  i : integer;
begin
  composeDataTypeChildren(xml, value);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCoding(xml, 'channelType', value.channelType);
  if (SummaryOption in [soFull, soSummary, soData]) and (value.address is TFhirUrl) {6} then
    ComposeUrl(xml, 'addressUrl', TFhirUrl(value.address))
  else if (SummaryOption in [soFull, soSummary, soData]) and (value.address is TFhirContactPoint) {6} then
    ComposeContactPoint(xml, 'addressContactPoint', TFhirContactPoint(value.address))
  else if (SummaryOption in [soFull, soSummary, soData]) and (value.address is TFhirExtendedContactDetail) {6} then
    ComposeExtendedContactDetail(xml, 'addressExtendedContactDetail', TFhirExtendedContactDetail(value.address))
  else if (SummaryOption in [soFull, soSummary, soData]) and (value.address is TFhirString) {6} then
    ComposeString(xml, 'addressString', TFhirString(value.address));
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.additionalInfoList.Count - 1 do
      ComposeUrl(xml, 'additionalInfo', value.additionalInfoList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposePositiveInt(xml, 'maxParticipants', value.maxParticipantsElement);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(xml, 'sessionKey', value.sessionKeyElement);
end;

function TFHIRXmlParser.ParseAge(element : TMXmlElement; path : string) : TFhirAge;
var
  child : TMXmlElement;
begin
  result := TFhirAge.Create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseAgeChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseAgeChild(value : TFhirAge; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
  if Not ParseQuantityChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeAge(xml : TXmlBuilder; name : String; value : TFhirAge);
begin
  if (value = nil) then
    exit;
  composeElementAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeAgeChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeAgeChildren(xml : TXmlBuilder; value : TFhirAge);
begin
  composeQuantityChildren(xml, value);
end;

function TFHIRXmlParser.ParseCount(element : TMXmlElement; path : string) : TFhirCount;
var
  child : TMXmlElement;
begin
  result := TFhirCount.Create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseCountChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseCountChild(value : TFhirCount; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if Not ParseQuantityChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeCount(xml : TXmlBuilder; name : String; value : TFhirCount);
begin
  if (value = nil) then
    exit;
  composeElementAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeCountChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeCountChildren(xml : TXmlBuilder; value : TFhirCount);
begin
  composeQuantityChildren(xml, value);
end;

function TFHIRXmlParser.ParseDistance(element : TMXmlElement; path : string) : TFhirDistance;
var
  child : TMXmlElement;
begin
  result := TFhirDistance.Create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseDistanceChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseDistanceChild(value : TFhirDistance; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if Not ParseQuantityChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeDistance(xml : TXmlBuilder; name : String; value : TFhirDistance);
begin
  if (value = nil) then
    exit;
  composeElementAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeDistanceChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeDistanceChildren(xml : TXmlBuilder; value : TFhirDistance);
begin
  composeQuantityChildren(xml, value);
end;

function TFHIRXmlParser.ParseDosageDoseAndRate(element : TMXmlElement; path : string) : TFhirDosageDoseAndRate;
var
  child : TMXmlElement;
begin
  result := TFhirDosageDoseAndRate.Create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseDosageDoseAndRateChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseDosageDoseAndRateChild(value : TFhirDosageDoseAndRate; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'type') then
        value.type_ := ParseCodeableConcept(child, path+'/type')
      else if (child.localName = 'doseRange') then
        value.dose := ParseRange(child, path+'/doseRange')
      else if (child.localName = 'doseQuantity') then
        value.dose := ParseQuantity(child, path+'/doseQuantity')
      else if (child.localName = 'rateRatio') then
        value.rate := ParseRatio(child, path+'/rateRatio')
      else if (child.localName = 'rateRange') then
        value.rate := ParseRange(child, path+'/rateRange')
      else if (child.localName = 'rateQuantity') then
        value.rate := ParseQuantity(child, path+'/rateQuantity')
      else if Not ParseElementChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeDosageDoseAndRate(xml : TXmlBuilder; name : String; value : TFhirDosageDoseAndRate);
begin
  if (value = nil) then
    exit;
  composeElementAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeDosageDoseAndRateChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeDosageDoseAndRateChildren(xml : TXmlBuilder; value : TFhirDosageDoseAndRate);
begin
  composeElementChildren(xml, value);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(xml, 'type', value.type_);
  if (SummaryOption in [soFull, soSummary, soData]) and (value.dose is TFhirRange) {6} then
    ComposeRange(xml, 'doseRange', TFhirRange(value.dose))
  else if (SummaryOption in [soFull, soSummary, soData]) and (value.dose is TFhirQuantity) {6} then
    ComposeQuantity(xml, 'doseQuantity', TFhirQuantity(value.dose));
  if (SummaryOption in [soFull, soSummary, soData]) and (value.rate is TFhirRatio) {6} then
    ComposeRatio(xml, 'rateRatio', TFhirRatio(value.rate))
  else if (SummaryOption in [soFull, soSummary, soData]) and (value.rate is TFhirRange) {6} then
    ComposeRange(xml, 'rateRange', TFhirRange(value.rate))
  else if (SummaryOption in [soFull, soSummary, soData]) and (value.rate is TFhirQuantity) {6} then
    ComposeQuantity(xml, 'rateQuantity', TFhirQuantity(value.rate));
end;

function TFHIRXmlParser.ParseDosage(element : TMXmlElement; path : string) : TFhirDosage;
var
  child : TMXmlElement;
begin
  result := TFhirDosage.Create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseDosageChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseDosageChild(value : TFhirDosage; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'sequence') then
        value.sequenceElement := ParseInteger(child, path+'/sequence')
      else if (child.localName = 'text') then
        value.textElement := ParseString(child, path+'/text')
      else if (child.localName = 'additionalInstruction') then
        value.additionalInstructionList.Add(ParseCodeableConcept(child, path+'/additionalInstruction'))
      else if (child.localName = 'patientInstruction') then
        value.patientInstructionElement := ParseString(child, path+'/patientInstruction')
      else if (child.localName = 'timing') then
        value.timing := ParseTiming(child, path+'/timing')
      else if (child.localName = 'asNeeded') then
        value.asNeededElement := ParseBoolean(child, path+'/asNeeded')
      else if (child.localName = 'asNeededFor') then
        value.asNeededForList.Add(ParseCodeableConcept(child, path+'/asNeededFor'))
      else if (child.localName = 'site') then
        value.site := ParseCodeableConcept(child, path+'/site')
      else if (child.localName = 'route') then
        value.route := ParseCodeableConcept(child, path+'/route')
      else if (child.localName = 'method') then
        value.method := ParseCodeableConcept(child, path+'/method')
      else if (child.localName = 'doseAndRate') then
        value.doseAndRateList.Add(ParseDosageDoseAndRate(child, path+'/doseAndRate'))
      else if (child.localName = 'maxDosePerPeriod') then
        value.maxDosePerPeriodList.Add(ParseRatio(child, path+'/maxDosePerPeriod'))
      else if (child.localName = 'maxDosePerAdministration') then
        value.maxDosePerAdministration := ParseQuantity(child, path+'/maxDosePerAdministration')
      else if (child.localName = 'maxDosePerLifetime') then
        value.maxDosePerLifetime := ParseQuantity(child, path+'/maxDosePerLifetime')
      else if Not ParseElementChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeDosage(xml : TXmlBuilder; name : String; value : TFhirDosage);
begin
  if (value = nil) then
    exit;
  composeElementAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeDosageChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeDosageChildren(xml : TXmlBuilder; value : TFhirDosage);
var
  i : integer;
begin
  composeBackboneTypeChildren(xml, value);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeInteger(xml, 'sequence', value.sequenceElement);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(xml, 'text', value.textElement);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.additionalInstructionList.Count - 1 do
      ComposeCodeableConcept(xml, 'additionalInstruction', value.additionalInstructionList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(xml, 'patientInstruction', value.patientInstructionElement);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeTiming(xml, 'timing', value.timing);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeBoolean(xml, 'asNeeded', value.asNeededElement);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.asNeededForList.Count - 1 do
      ComposeCodeableConcept(xml, 'asNeededFor', value.asNeededForList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(xml, 'site', value.site);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(xml, 'route', value.route);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(xml, 'method', value.method);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.doseAndRateList.Count - 1 do
      ComposeDosageDoseAndRate(xml, 'doseAndRate', value.doseAndRateList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.maxDosePerPeriodList.Count - 1 do
      ComposeRatio(xml, 'maxDosePerPeriod', value.maxDosePerPeriodList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeQuantity(xml, 'maxDosePerAdministration', value.maxDosePerAdministration);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeQuantity(xml, 'maxDosePerLifetime', value.maxDosePerLifetime);
end;

function TFHIRXmlParser.ParseDuration(element : TMXmlElement; path : string) : TFhirDuration;
var
  child : TMXmlElement;
begin
  result := TFhirDuration.Create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseDurationChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseDurationChild(value : TFhirDuration; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if Not ParseQuantityChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeDuration(xml : TXmlBuilder; name : String; value : TFhirDuration);
begin
  if (value = nil) then
    exit;
  composeElementAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeDurationChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeDurationChildren(xml : TXmlBuilder; value : TFhirDuration);
begin
  composeQuantityChildren(xml, value);
end;

function TFHIRXmlParser.ParseElementDefinitionSlicing(element : TMXmlElement; path : string) : TFhirElementDefinitionSlicing;
var
  child : TMXmlElement;
begin
  result := TFhirElementDefinitionSlicing.Create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseElementDefinitionSlicingChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseElementDefinitionSlicingChild(value : TFhirElementDefinitionSlicing; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'discriminator') then
        value.discriminatorList.Add(ParseElementDefinitionSlicingDiscriminator(child, path+'/discriminator'))
      else if (child.localName = 'description') then
        value.descriptionElement := ParseString(child, path+'/description')
      else if (child.localName = 'ordered') then
        value.orderedElement := ParseBoolean(child, path+'/ordered')
      else if (child.localName = 'rules') then
        value.rulesElement := ParseEnum(CODES_TFhirSlicingRulesEnum, SYSTEMS_TFhirSlicingRulesEnum, child, path+'/rules')
      else if Not ParseElementChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeElementDefinitionSlicing(xml : TXmlBuilder; name : String; value : TFhirElementDefinitionSlicing);
begin
  if (value = nil) then
    exit;
  composeElementAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeElementDefinitionSlicingChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeElementDefinitionSlicingChildren(xml : TXmlBuilder; value : TFhirElementDefinitionSlicing);
var
  i : integer;
begin
  composeElementChildren(xml, value);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.discriminatorList.Count - 1 do
      ComposeElementDefinitionSlicingDiscriminator(xml, 'discriminator', value.discriminatorList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(xml, 'description', value.descriptionElement);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeBoolean(xml, 'ordered', value.orderedElement);
  ComposeEnum(xml, 'rules', value.rulesElement, CODES_TFhirSlicingRulesEnum);
end;

function TFHIRXmlParser.ParseElementDefinitionSlicingDiscriminator(element : TMXmlElement; path : string) : TFhirElementDefinitionSlicingDiscriminator;
var
  child : TMXmlElement;
begin
  result := TFhirElementDefinitionSlicingDiscriminator.Create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseElementDefinitionSlicingDiscriminatorChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseElementDefinitionSlicingDiscriminatorChild(value : TFhirElementDefinitionSlicingDiscriminator; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'type') then
        value.type_Element := ParseEnum(CODES_TFhirDiscriminatorTypeEnum, SYSTEMS_TFhirDiscriminatorTypeEnum, child, path+'/type')
      else if (child.localName = 'path') then
        value.pathElement := ParseString(child, path+'/path')
      else if Not ParseElementChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeElementDefinitionSlicingDiscriminator(xml : TXmlBuilder; name : String; value : TFhirElementDefinitionSlicingDiscriminator);
begin
  if (value = nil) then
    exit;
  composeElementAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeElementDefinitionSlicingDiscriminatorChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeElementDefinitionSlicingDiscriminatorChildren(xml : TXmlBuilder; value : TFhirElementDefinitionSlicingDiscriminator);
begin
  composeElementChildren(xml, value);
  ComposeEnum(xml, 'type', value.type_Element, CODES_TFhirDiscriminatorTypeEnum);
  ComposeString(xml, 'path', value.pathElement);
end;

function TFHIRXmlParser.ParseElementDefinitionBase(element : TMXmlElement; path : string) : TFhirElementDefinitionBase;
var
  child : TMXmlElement;
begin
  result := TFhirElementDefinitionBase.Create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseElementDefinitionBaseChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseElementDefinitionBaseChild(value : TFhirElementDefinitionBase; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'path') then
        value.pathElement := ParseString(child, path+'/path')
      else if (child.localName = 'min') then
        value.minElement := ParseUnsignedInt(child, path+'/min')
      else if (child.localName = 'max') then
        value.maxElement := ParseString(child, path+'/max')
      else if Not ParseElementChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeElementDefinitionBase(xml : TXmlBuilder; name : String; value : TFhirElementDefinitionBase);
begin
  if (value = nil) then
    exit;
  composeElementAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeElementDefinitionBaseChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeElementDefinitionBaseChildren(xml : TXmlBuilder; value : TFhirElementDefinitionBase);
begin
  composeElementChildren(xml, value);
  ComposeString(xml, 'path', value.pathElement);
  ComposeUnsignedInt(xml, 'min', value.minElement);
  ComposeString(xml, 'max', value.maxElement);
end;

function TFHIRXmlParser.ParseElementDefinitionType(element : TMXmlElement; path : string) : TFhirElementDefinitionType;
var
  child : TMXmlElement;
begin
  result := TFhirElementDefinitionType.Create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseElementDefinitionTypeChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseElementDefinitionTypeChild(value : TFhirElementDefinitionType; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'code') then
        value.codeElement := ParseUri(child, path+'/code')
      else if (child.localName = 'profile') then
        value.profileList.Add(ParseCanonical(child, path+'/profile'))
      else if (child.localName = 'targetProfile') then
        value.targetProfileList.Add(ParseCanonical(child, path+'/targetProfile'))
      else if (child.localName = 'aggregation') then
        value.aggregationList.Add(ParseEnum(CODES_TFhirAggregationModeEnum, SYSTEMS_TFhirAggregationModeEnum, child, path+'/aggregation')){y.1}
      else if (child.localName = 'versioning') then
        value.versioningElement := ParseEnum(CODES_TFhirReferenceVersionRulesEnum, SYSTEMS_TFhirReferenceVersionRulesEnum, child, path+'/versioning')
      else if Not ParseElementChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeElementDefinitionType(xml : TXmlBuilder; name : String; value : TFhirElementDefinitionType);
begin
  if (value = nil) then
    exit;
  composeElementAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeElementDefinitionTypeChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeElementDefinitionTypeChildren(xml : TXmlBuilder; value : TFhirElementDefinitionType);
var
  i : integer;
begin
  composeElementChildren(xml, value);
  ComposeUri(xml, 'code', value.codeElement);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.profileList.Count - 1 do
      ComposeCanonical(xml, 'profile', value.profileList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.targetProfileList.Count - 1 do
      ComposeCanonical(xml, 'targetProfile', value.targetProfileList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.aggregationList.Count - 1 do
      ComposeEnum(xml, 'aggregation', value.aggregationList[i], CODES_TFhirAggregationModeEnum);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeEnum(xml, 'versioning', value.versioningElement, CODES_TFhirReferenceVersionRulesEnum);
end;

function TFHIRXmlParser.ParseElementDefinitionExample(element : TMXmlElement; path : string) : TFhirElementDefinitionExample;
var
  child : TMXmlElement;
begin
  result := TFhirElementDefinitionExample.Create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseElementDefinitionExampleChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseElementDefinitionExampleChild(value : TFhirElementDefinitionExample; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'label') then
        value.label_Element := ParseString(child, path+'/label')
      else if (child.localName = 'valueCanonical') then
        value.value := ParseCanonical(child, path+'/valueCanonical')
      else if (child.localName = 'valueCode') then
        value.value := ParseCode(child, path+'/valueCode')
      else if (child.localName = 'valueId') then
        value.value := ParseId(child, path+'/valueId')
      else if (child.localName = 'valueMarkdown') then
        value.value := ParseMarkdown(child, path+'/valueMarkdown')
      else if (child.localName = 'valueOid') then
        value.value := ParseOid(child, path+'/valueOid')
      else if (child.localName = 'valuePositiveInt') then
        value.value := ParsePositiveInt(child, path+'/valuePositiveInt')
      else if (child.localName = 'valueUnsignedInt') then
        value.value := ParseUnsignedInt(child, path+'/valueUnsignedInt')
      else if (child.localName = 'valueUrl') then
        value.value := ParseUrl(child, path+'/valueUrl')
      else if (child.localName = 'valueUuid') then
        value.value := ParseUuid(child, path+'/valueUuid')
      else if (child.localName = 'valueAddress') then
        value.value := ParseAddress(child, path+'/valueAddress')
      else if (child.localName = 'valueAge') then
        value.value := ParseAge(child, path+'/valueAge')
      else if (child.localName = 'valueAnnotation') then
        value.value := ParseAnnotation(child, path+'/valueAnnotation')
      else if (child.localName = 'valueAttachment') then
        value.value := ParseAttachment(child, path+'/valueAttachment')
      else if (child.localName = 'valueCodeableConcept') then
        value.value := ParseCodeableConcept(child, path+'/valueCodeableConcept')
      else if (child.localName = 'valueCodeableReference') then
        value.value := ParseCodeableReference(child, path+'/valueCodeableReference')
      else if (child.localName = 'valueCoding') then
        value.value := ParseCoding(child, path+'/valueCoding')
      else if (child.localName = 'valueContactPoint') then
        value.value := ParseContactPoint(child, path+'/valueContactPoint')
      else if (child.localName = 'valueCount') then
        value.value := ParseCount(child, path+'/valueCount')
      else if (child.localName = 'valueDistance') then
        value.value := ParseDistance(child, path+'/valueDistance')
      else if (child.localName = 'valueDuration') then
        value.value := ParseDuration(child, path+'/valueDuration')
      else if (child.localName = 'valueHumanName') then
        value.value := ParseHumanName(child, path+'/valueHumanName')
      else if (child.localName = 'valueIdentifier') then
        value.value := ParseIdentifier(child, path+'/valueIdentifier')
      else if (child.localName = 'valueMoney') then
        value.value := ParseMoney(child, path+'/valueMoney')
      else if (child.localName = 'valuePeriod') then
        value.value := ParsePeriod(child, path+'/valuePeriod')
      else if (child.localName = 'valueQuantity') then
        value.value := ParseQuantity(child, path+'/valueQuantity')
      else if (child.localName = 'valueRange') then
        value.value := ParseRange(child, path+'/valueRange')
      else if (child.localName = 'valueRatio') then
        value.value := ParseRatio(child, path+'/valueRatio')
      else if (child.localName = 'valueRatioRange') then
        value.value := ParseRatioRange(child, path+'/valueRatioRange')
      else if (child.localName = 'valueReference') then
        value.value := ParseReference(child, path+'/valueReference')
      else if (child.localName = 'valueSampledData') then
        value.value := ParseSampledData(child, path+'/valueSampledData')
      else if (child.localName = 'valueSignature') then
        value.value := ParseSignature(child, path+'/valueSignature')
      else if (child.localName = 'valueTiming') then
        value.value := ParseTiming(child, path+'/valueTiming')
      else if (child.localName = 'valueContactDetail') then
        value.value := ParseContactDetail(child, path+'/valueContactDetail')
      else if (child.localName = 'valueDataRequirement') then
        value.value := ParseDataRequirement(child, path+'/valueDataRequirement')
      else if (child.localName = 'valueExpression') then
        value.value := ParseExpression(child, path+'/valueExpression')
      else if (child.localName = 'valueParameterDefinition') then
        value.value := ParseParameterDefinition(child, path+'/valueParameterDefinition')
      else if (child.localName = 'valueRelatedArtifact') then
        value.value := ParseRelatedArtifact(child, path+'/valueRelatedArtifact')
      else if (child.localName = 'valueTriggerDefinition') then
        value.value := ParseTriggerDefinition(child, path+'/valueTriggerDefinition')
      else if (child.localName = 'valueUsageContext') then
        value.value := ParseUsageContext(child, path+'/valueUsageContext')
      else if (child.localName = 'valueAvailability') then
        value.value := ParseAvailability(child, path+'/valueAvailability')
      else if (child.localName = 'valueExtendedContactDetail') then
        value.value := ParseExtendedContactDetail(child, path+'/valueExtendedContactDetail')
      else if (child.localName = 'valueDosage') then
        value.value := ParseDosage(child, path+'/valueDosage')
      else if (child.localName = 'valueMeta') then
        value.value := ParseMeta(child, path+'/valueMeta')
      else if (child.localName = 'valueBase64Binary') then
        value.value := ParseBase64Binary(child, path+'/valueBase64Binary')
      else if (child.localName = 'valueBoolean') then
        value.value := ParseBoolean(child, path+'/valueBoolean')
      else if (child.localName = 'valueDate') then
        value.value := ParseDate(child, path+'/valueDate')
      else if (child.localName = 'valueDateTime') then
        value.value := ParseDateTime(child, path+'/valueDateTime')
      else if (child.localName = 'valueDecimal') then
        value.value := ParseDecimal(child, path+'/valueDecimal')
      else if (child.localName = 'valueInstant') then
        value.value := ParseInstant(child, path+'/valueInstant')
      else if (child.localName = 'valueInteger') then
        value.value := ParseInteger(child, path+'/valueInteger')
      else if (child.localName = 'valueInteger64') then
        value.value := ParseInteger64(child, path+'/valueInteger64')
      else if (child.localName = 'valueString') then
        value.value := ParseString(child, path+'/valueString')
      else if (child.localName = 'valueTime') then
        value.value := ParseTime(child, path+'/valueTime')
      else if (child.localName = 'valueUri') then
        value.value := ParseUri(child, path+'/valueUri')
      else if Not ParseElementChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeElementDefinitionExample(xml : TXmlBuilder; name : String; value : TFhirElementDefinitionExample);
begin
  if (value = nil) then
    exit;
  composeElementAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeElementDefinitionExampleChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeElementDefinitionExampleChildren(xml : TXmlBuilder; value : TFhirElementDefinitionExample);
begin
  composeElementChildren(xml, value);
  ComposeString(xml, 'label', value.label_Element);
  if (value.value is TFhirCanonical) {6} then
    ComposeCanonical(xml, 'valueCanonical', TFhirCanonical(value.value))
  else if (value.value is TFhirCode) {6} then
    ComposeCode(xml, 'valueCode', TFhirCode(value.value))
  else if (value.value is TFhirId) {6} then
    ComposeId(xml, 'valueId', TFhirId(value.value))
  else if (value.value is TFhirMarkdown) {6} then
    ComposeMarkdown(xml, 'valueMarkdown', TFhirMarkdown(value.value))
  else if (value.value is TFhirOid) {6} then
    ComposeOid(xml, 'valueOid', TFhirOid(value.value))
  else if (value.value is TFhirPositiveInt) {6} then
    ComposePositiveInt(xml, 'valuePositiveInt', TFhirPositiveInt(value.value))
  else if (value.value is TFhirUnsignedInt) {6} then
    ComposeUnsignedInt(xml, 'valueUnsignedInt', TFhirUnsignedInt(value.value))
  else if (value.value is TFhirUrl) {6} then
    ComposeUrl(xml, 'valueUrl', TFhirUrl(value.value))
  else if (value.value is TFhirUuid) {6} then
    ComposeUuid(xml, 'valueUuid', TFhirUuid(value.value))
  else if (value.value is TFhirAddress) {6} then
    ComposeAddress(xml, 'valueAddress', TFhirAddress(value.value))
  else if (value.value is TFhirAge) {6} then
    ComposeAge(xml, 'valueAge', TFhirAge(value.value))
  else if (value.value is TFhirAnnotation) {6} then
    ComposeAnnotation(xml, 'valueAnnotation', TFhirAnnotation(value.value))
  else if (value.value is TFhirAttachment) {6} then
    ComposeAttachment(xml, 'valueAttachment', TFhirAttachment(value.value))
  else if (value.value is TFhirCodeableConcept) {6} then
    ComposeCodeableConcept(xml, 'valueCodeableConcept', TFhirCodeableConcept(value.value))
  else if (value.value is TFhirCodeableReference) {6} then
    ComposeCodeableReference(xml, 'valueCodeableReference', TFhirCodeableReference(value.value))
  else if (value.value is TFhirCoding) {6} then
    ComposeCoding(xml, 'valueCoding', TFhirCoding(value.value))
  else if (value.value is TFhirContactPoint) {6} then
    ComposeContactPoint(xml, 'valueContactPoint', TFhirContactPoint(value.value))
  else if (value.value is TFhirCount) {6} then
    ComposeCount(xml, 'valueCount', TFhirCount(value.value))
  else if (value.value is TFhirDistance) {6} then
    ComposeDistance(xml, 'valueDistance', TFhirDistance(value.value))
  else if (value.value is TFhirDuration) {6} then
    ComposeDuration(xml, 'valueDuration', TFhirDuration(value.value))
  else if (value.value is TFhirHumanName) {6} then
    ComposeHumanName(xml, 'valueHumanName', TFhirHumanName(value.value))
  else if (value.value is TFhirIdentifier) {6} then
    ComposeIdentifier(xml, 'valueIdentifier', TFhirIdentifier(value.value))
  else if (value.value is TFhirMoney) {6} then
    ComposeMoney(xml, 'valueMoney', TFhirMoney(value.value))
  else if (value.value is TFhirPeriod) {6} then
    ComposePeriod(xml, 'valuePeriod', TFhirPeriod(value.value))
  else if (value.value is TFhirQuantity) {6} then
    ComposeQuantity(xml, 'valueQuantity', TFhirQuantity(value.value))
  else if (value.value is TFhirRange) {6} then
    ComposeRange(xml, 'valueRange', TFhirRange(value.value))
  else if (value.value is TFhirRatio) {6} then
    ComposeRatio(xml, 'valueRatio', TFhirRatio(value.value))
  else if (value.value is TFhirRatioRange) {6} then
    ComposeRatioRange(xml, 'valueRatioRange', TFhirRatioRange(value.value))
  else if (value.value is TFhirReference) {6} then
    ComposeReference(xml, 'valueReference', TFhirReference(value.value))
  else if (value.value is TFhirSampledData) {6} then
    ComposeSampledData(xml, 'valueSampledData', TFhirSampledData(value.value))
  else if (value.value is TFhirSignature) {6} then
    ComposeSignature(xml, 'valueSignature', TFhirSignature(value.value))
  else if (value.value is TFhirTiming) {6} then
    ComposeTiming(xml, 'valueTiming', TFhirTiming(value.value))
  else if (value.value is TFhirContactDetail) {6} then
    ComposeContactDetail(xml, 'valueContactDetail', TFhirContactDetail(value.value))
  else if (value.value is TFhirDataRequirement) {6} then
    ComposeDataRequirement(xml, 'valueDataRequirement', TFhirDataRequirement(value.value))
  else if (value.value is TFhirExpression) {6} then
    ComposeExpression(xml, 'valueExpression', TFhirExpression(value.value))
  else if (value.value is TFhirParameterDefinition) {6} then
    ComposeParameterDefinition(xml, 'valueParameterDefinition', TFhirParameterDefinition(value.value))
  else if (value.value is TFhirRelatedArtifact) {6} then
    ComposeRelatedArtifact(xml, 'valueRelatedArtifact', TFhirRelatedArtifact(value.value))
  else if (value.value is TFhirTriggerDefinition) {6} then
    ComposeTriggerDefinition(xml, 'valueTriggerDefinition', TFhirTriggerDefinition(value.value))
  else if (value.value is TFhirUsageContext) {6} then
    ComposeUsageContext(xml, 'valueUsageContext', TFhirUsageContext(value.value))
  else if (value.value is TFhirAvailability) {6} then
    ComposeAvailability(xml, 'valueAvailability', TFhirAvailability(value.value))
  else if (value.value is TFhirExtendedContactDetail) {6} then
    ComposeExtendedContactDetail(xml, 'valueExtendedContactDetail', TFhirExtendedContactDetail(value.value))
  else if (value.value is TFhirDosage) {6} then
    ComposeDosage(xml, 'valueDosage', TFhirDosage(value.value))
  else if (value.value is TFhirMeta) {6} then
    ComposeMeta(xml, 'valueMeta', TFhirMeta(value.value))
  else if (value.value is TFhirBase64Binary) {6} then
    ComposeBase64Binary(xml, 'valueBase64Binary', TFhirBase64Binary(value.value))
  else if (value.value is TFhirBoolean) {6} then
    ComposeBoolean(xml, 'valueBoolean', TFhirBoolean(value.value))
  else if (value.value is TFhirDate) {6} then
    ComposeDate(xml, 'valueDate', TFhirDate(value.value))
  else if (value.value is TFhirDateTime) {6} then
    ComposeDateTime(xml, 'valueDateTime', TFhirDateTime(value.value))
  else if (value.value is TFhirDecimal) {6} then
    ComposeDecimal(xml, 'valueDecimal', TFhirDecimal(value.value))
  else if (value.value is TFhirInstant) {6} then
    ComposeInstant(xml, 'valueInstant', TFhirInstant(value.value))
  else if (value.value is TFhirInteger) {6} then
    ComposeInteger(xml, 'valueInteger', TFhirInteger(value.value))
  else if (value.value is TFhirInteger64) {6} then
    ComposeInteger64(xml, 'valueInteger64', TFhirInteger64(value.value))
  else if (value.value is TFhirString) {6} then
    ComposeString(xml, 'valueString', TFhirString(value.value))
  else if (value.value is TFhirTime) {6} then
    ComposeTime(xml, 'valueTime', TFhirTime(value.value))
  else if (value.value is TFhirUri) {6} then
    ComposeUri(xml, 'valueUri', TFhirUri(value.value));
end;

function TFHIRXmlParser.ParseElementDefinitionConstraint(element : TMXmlElement; path : string) : TFhirElementDefinitionConstraint;
var
  child : TMXmlElement;
begin
  result := TFhirElementDefinitionConstraint.Create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseElementDefinitionConstraintChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseElementDefinitionConstraintChild(value : TFhirElementDefinitionConstraint; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'key') then
        value.keyElement := ParseId(child, path+'/key')
      else if (child.localName = 'requirements') then
        value.requirementsElement := ParseMarkdown(child, path+'/requirements')
      else if (child.localName = 'severity') then
        value.severityElement := ParseEnum(CODES_TFhirConstraintSeverityEnum, SYSTEMS_TFhirConstraintSeverityEnum, child, path+'/severity')
      else if (child.localName = 'suppress') then
        value.suppressElement := ParseBoolean(child, path+'/suppress')
      else if (child.localName = 'human') then
        value.humanElement := ParseString(child, path+'/human')
      else if (child.localName = 'expression') then
        value.expressionElement := ParseString(child, path+'/expression')
      else if (child.localName = 'xpath') then
        value.xpathElement := ParseString(child, path+'/xpath')
      else if (child.localName = 'source') then
        value.sourceElement := ParseCanonical(child, path+'/source')
      else if Not ParseElementChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeElementDefinitionConstraint(xml : TXmlBuilder; name : String; value : TFhirElementDefinitionConstraint);
begin
  if (value = nil) then
    exit;
  composeElementAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeElementDefinitionConstraintChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeElementDefinitionConstraintChildren(xml : TXmlBuilder; value : TFhirElementDefinitionConstraint);
begin
  composeElementChildren(xml, value);
  ComposeId(xml, 'key', value.keyElement);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeMarkdown(xml, 'requirements', value.requirementsElement);
  ComposeEnum(xml, 'severity', value.severityElement, CODES_TFhirConstraintSeverityEnum);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeBoolean(xml, 'suppress', value.suppressElement);
  ComposeString(xml, 'human', value.humanElement);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(xml, 'expression', value.expressionElement);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(xml, 'xpath', value.xpathElement);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCanonical(xml, 'source', value.sourceElement);
end;

function TFHIRXmlParser.ParseElementDefinitionBinding(element : TMXmlElement; path : string) : TFhirElementDefinitionBinding;
var
  child : TMXmlElement;
begin
  result := TFhirElementDefinitionBinding.Create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseElementDefinitionBindingChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseElementDefinitionBindingChild(value : TFhirElementDefinitionBinding; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'strength') then
        value.strengthElement := ParseEnum(CODES_TFhirBindingStrengthEnum, SYSTEMS_TFhirBindingStrengthEnum, child, path+'/strength')
      else if (child.localName = 'description') then
        value.descriptionElement := ParseMarkdown(child, path+'/description')
      else if (child.localName = 'valueSet') then
        value.valueSetElement := ParseCanonical(child, path+'/valueSet')
      else if Not ParseElementChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeElementDefinitionBinding(xml : TXmlBuilder; name : String; value : TFhirElementDefinitionBinding);
begin
  if (value = nil) then
    exit;
  composeElementAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeElementDefinitionBindingChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeElementDefinitionBindingChildren(xml : TXmlBuilder; value : TFhirElementDefinitionBinding);
begin
  composeElementChildren(xml, value);
  ComposeEnum(xml, 'strength', value.strengthElement, CODES_TFhirBindingStrengthEnum);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeMarkdown(xml, 'description', value.descriptionElement);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCanonical(xml, 'valueSet', value.valueSetElement);
end;

function TFHIRXmlParser.ParseElementDefinitionMapping(element : TMXmlElement; path : string) : TFhirElementDefinitionMapping;
var
  child : TMXmlElement;
begin
  result := TFhirElementDefinitionMapping.Create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseElementDefinitionMappingChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseElementDefinitionMappingChild(value : TFhirElementDefinitionMapping; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'identity') then
        value.identityElement := ParseId(child, path+'/identity')
      else if (child.localName = 'language') then
        value.languageElement := ParseCode(child, path+'/language')
      else if (child.localName = 'map') then
        value.mapElement := ParseString(child, path+'/map')
      else if (child.localName = 'comment') then
        value.commentElement := ParseMarkdown(child, path+'/comment')
      else if Not ParseElementChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeElementDefinitionMapping(xml : TXmlBuilder; name : String; value : TFhirElementDefinitionMapping);
begin
  if (value = nil) then
    exit;
  composeElementAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeElementDefinitionMappingChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeElementDefinitionMappingChildren(xml : TXmlBuilder; value : TFhirElementDefinitionMapping);
begin
  composeElementChildren(xml, value);
  ComposeId(xml, 'identity', value.identityElement);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCode(xml, 'language', value.languageElement);
  ComposeString(xml, 'map', value.mapElement);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeMarkdown(xml, 'comment', value.commentElement);
end;

function TFHIRXmlParser.ParseElementDefinition(element : TMXmlElement; path : string) : TFhirElementDefinition;
var
  child : TMXmlElement;
begin
  result := TFhirElementDefinition.Create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseElementDefinitionChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseElementDefinitionChild(value : TFhirElementDefinition; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'path') then
        value.pathElement := ParseString(child, path+'/path')
      else if (child.localName = 'representation') then
        value.representationList.Add(ParseEnum(CODES_TFhirPropertyRepresentationEnum, SYSTEMS_TFhirPropertyRepresentationEnum, child, path+'/representation')){y.1}
      else if (child.localName = 'sliceName') then
        value.sliceNameElement := ParseString(child, path+'/sliceName')
      else if (child.localName = 'sliceIsConstraining') then
        value.sliceIsConstrainingElement := ParseBoolean(child, path+'/sliceIsConstraining')
      else if (child.localName = 'label') then
        value.label_Element := ParseString(child, path+'/label')
      else if (child.localName = 'code') then
        value.codeList.Add(ParseCoding(child, path+'/code'))
      else if (child.localName = 'slicing') then
        value.slicing := ParseElementDefinitionSlicing(child, path+'/slicing')
      else if (child.localName = 'short') then
        value.shortElement := ParseString(child, path+'/short')
      else if (child.localName = 'definition') then
        value.definitionElement := ParseMarkdown(child, path+'/definition')
      else if (child.localName = 'comment') then
        value.commentElement := ParseMarkdown(child, path+'/comment')
      else if (child.localName = 'requirements') then
        value.requirementsElement := ParseMarkdown(child, path+'/requirements')
      else if (child.localName = 'alias') then
        value.aliasList.Add(ParseString(child, path+'/alias'))
      else if (child.localName = 'min') then
        value.minElement := ParseUnsignedInt(child, path+'/min')
      else if (child.localName = 'max') then
        value.maxElement := ParseString(child, path+'/max')
      else if (child.localName = 'base') then
        value.base := ParseElementDefinitionBase(child, path+'/base')
      else if (child.localName = 'contentReference') then
        value.contentReferenceElement := ParseUri(child, path+'/contentReference')
      else if (child.localName = 'type') then
        value.type_List.Add(ParseElementDefinitionType(child, path+'/type'))
      else if (child.localName = 'defaultValueCanonical') then
        value.defaultValue := ParseCanonical(child, path+'/defaultValueCanonical')
      else if (child.localName = 'defaultValueCode') then
        value.defaultValue := ParseCode(child, path+'/defaultValueCode')
      else if (child.localName = 'defaultValueId') then
        value.defaultValue := ParseId(child, path+'/defaultValueId')
      else if (child.localName = 'defaultValueMarkdown') then
        value.defaultValue := ParseMarkdown(child, path+'/defaultValueMarkdown')
      else if (child.localName = 'defaultValueOid') then
        value.defaultValue := ParseOid(child, path+'/defaultValueOid')
      else if (child.localName = 'defaultValuePositiveInt') then
        value.defaultValue := ParsePositiveInt(child, path+'/defaultValuePositiveInt')
      else if (child.localName = 'defaultValueUnsignedInt') then
        value.defaultValue := ParseUnsignedInt(child, path+'/defaultValueUnsignedInt')
      else if (child.localName = 'defaultValueUrl') then
        value.defaultValue := ParseUrl(child, path+'/defaultValueUrl')
      else if (child.localName = 'defaultValueUuid') then
        value.defaultValue := ParseUuid(child, path+'/defaultValueUuid')
      else if (child.localName = 'defaultValueAddress') then
        value.defaultValue := ParseAddress(child, path+'/defaultValueAddress')
      else if (child.localName = 'defaultValueAge') then
        value.defaultValue := ParseAge(child, path+'/defaultValueAge')
      else if (child.localName = 'defaultValueAnnotation') then
        value.defaultValue := ParseAnnotation(child, path+'/defaultValueAnnotation')
      else if (child.localName = 'defaultValueAttachment') then
        value.defaultValue := ParseAttachment(child, path+'/defaultValueAttachment')
      else if (child.localName = 'defaultValueCodeableConcept') then
        value.defaultValue := ParseCodeableConcept(child, path+'/defaultValueCodeableConcept')
      else if (child.localName = 'defaultValueCodeableReference') then
        value.defaultValue := ParseCodeableReference(child, path+'/defaultValueCodeableReference')
      else if (child.localName = 'defaultValueCoding') then
        value.defaultValue := ParseCoding(child, path+'/defaultValueCoding')
      else if (child.localName = 'defaultValueContactPoint') then
        value.defaultValue := ParseContactPoint(child, path+'/defaultValueContactPoint')
      else if (child.localName = 'defaultValueCount') then
        value.defaultValue := ParseCount(child, path+'/defaultValueCount')
      else if (child.localName = 'defaultValueDistance') then
        value.defaultValue := ParseDistance(child, path+'/defaultValueDistance')
      else if (child.localName = 'defaultValueDuration') then
        value.defaultValue := ParseDuration(child, path+'/defaultValueDuration')
      else if (child.localName = 'defaultValueHumanName') then
        value.defaultValue := ParseHumanName(child, path+'/defaultValueHumanName')
      else if (child.localName = 'defaultValueIdentifier') then
        value.defaultValue := ParseIdentifier(child, path+'/defaultValueIdentifier')
      else if (child.localName = 'defaultValueMoney') then
        value.defaultValue := ParseMoney(child, path+'/defaultValueMoney')
      else if (child.localName = 'defaultValuePeriod') then
        value.defaultValue := ParsePeriod(child, path+'/defaultValuePeriod')
      else if (child.localName = 'defaultValueQuantity') then
        value.defaultValue := ParseQuantity(child, path+'/defaultValueQuantity')
      else if (child.localName = 'defaultValueRange') then
        value.defaultValue := ParseRange(child, path+'/defaultValueRange')
      else if (child.localName = 'defaultValueRatio') then
        value.defaultValue := ParseRatio(child, path+'/defaultValueRatio')
      else if (child.localName = 'defaultValueRatioRange') then
        value.defaultValue := ParseRatioRange(child, path+'/defaultValueRatioRange')
      else if (child.localName = 'defaultValueReference') then
        value.defaultValue := ParseReference(child, path+'/defaultValueReference')
      else if (child.localName = 'defaultValueSampledData') then
        value.defaultValue := ParseSampledData(child, path+'/defaultValueSampledData')
      else if (child.localName = 'defaultValueSignature') then
        value.defaultValue := ParseSignature(child, path+'/defaultValueSignature')
      else if (child.localName = 'defaultValueTiming') then
        value.defaultValue := ParseTiming(child, path+'/defaultValueTiming')
      else if (child.localName = 'defaultValueContactDetail') then
        value.defaultValue := ParseContactDetail(child, path+'/defaultValueContactDetail')
      else if (child.localName = 'defaultValueDataRequirement') then
        value.defaultValue := ParseDataRequirement(child, path+'/defaultValueDataRequirement')
      else if (child.localName = 'defaultValueExpression') then
        value.defaultValue := ParseExpression(child, path+'/defaultValueExpression')
      else if (child.localName = 'defaultValueParameterDefinition') then
        value.defaultValue := ParseParameterDefinition(child, path+'/defaultValueParameterDefinition')
      else if (child.localName = 'defaultValueRelatedArtifact') then
        value.defaultValue := ParseRelatedArtifact(child, path+'/defaultValueRelatedArtifact')
      else if (child.localName = 'defaultValueTriggerDefinition') then
        value.defaultValue := ParseTriggerDefinition(child, path+'/defaultValueTriggerDefinition')
      else if (child.localName = 'defaultValueUsageContext') then
        value.defaultValue := ParseUsageContext(child, path+'/defaultValueUsageContext')
      else if (child.localName = 'defaultValueAvailability') then
        value.defaultValue := ParseAvailability(child, path+'/defaultValueAvailability')
      else if (child.localName = 'defaultValueExtendedContactDetail') then
        value.defaultValue := ParseExtendedContactDetail(child, path+'/defaultValueExtendedContactDetail')
      else if (child.localName = 'defaultValueDosage') then
        value.defaultValue := ParseDosage(child, path+'/defaultValueDosage')
      else if (child.localName = 'defaultValueMeta') then
        value.defaultValue := ParseMeta(child, path+'/defaultValueMeta')
      else if (child.localName = 'defaultValueBase64Binary') then
        value.defaultValue := ParseBase64Binary(child, path+'/defaultValueBase64Binary')
      else if (child.localName = 'defaultValueBoolean') then
        value.defaultValue := ParseBoolean(child, path+'/defaultValueBoolean')
      else if (child.localName = 'defaultValueDate') then
        value.defaultValue := ParseDate(child, path+'/defaultValueDate')
      else if (child.localName = 'defaultValueDateTime') then
        value.defaultValue := ParseDateTime(child, path+'/defaultValueDateTime')
      else if (child.localName = 'defaultValueDecimal') then
        value.defaultValue := ParseDecimal(child, path+'/defaultValueDecimal')
      else if (child.localName = 'defaultValueInstant') then
        value.defaultValue := ParseInstant(child, path+'/defaultValueInstant')
      else if (child.localName = 'defaultValueInteger') then
        value.defaultValue := ParseInteger(child, path+'/defaultValueInteger')
      else if (child.localName = 'defaultValueInteger64') then
        value.defaultValue := ParseInteger64(child, path+'/defaultValueInteger64')
      else if (child.localName = 'defaultValueString') then
        value.defaultValue := ParseString(child, path+'/defaultValueString')
      else if (child.localName = 'defaultValueTime') then
        value.defaultValue := ParseTime(child, path+'/defaultValueTime')
      else if (child.localName = 'defaultValueUri') then
        value.defaultValue := ParseUri(child, path+'/defaultValueUri')
      else if (child.localName = 'meaningWhenMissing') then
        value.meaningWhenMissingElement := ParseMarkdown(child, path+'/meaningWhenMissing')
      else if (child.localName = 'orderMeaning') then
        value.orderMeaningElement := ParseString(child, path+'/orderMeaning')
      else if (child.localName = 'fixedCanonical') then
        value.fixed := ParseCanonical(child, path+'/fixedCanonical')
      else if (child.localName = 'fixedCode') then
        value.fixed := ParseCode(child, path+'/fixedCode')
      else if (child.localName = 'fixedId') then
        value.fixed := ParseId(child, path+'/fixedId')
      else if (child.localName = 'fixedMarkdown') then
        value.fixed := ParseMarkdown(child, path+'/fixedMarkdown')
      else if (child.localName = 'fixedOid') then
        value.fixed := ParseOid(child, path+'/fixedOid')
      else if (child.localName = 'fixedPositiveInt') then
        value.fixed := ParsePositiveInt(child, path+'/fixedPositiveInt')
      else if (child.localName = 'fixedUnsignedInt') then
        value.fixed := ParseUnsignedInt(child, path+'/fixedUnsignedInt')
      else if (child.localName = 'fixedUrl') then
        value.fixed := ParseUrl(child, path+'/fixedUrl')
      else if (child.localName = 'fixedUuid') then
        value.fixed := ParseUuid(child, path+'/fixedUuid')
      else if (child.localName = 'fixedAddress') then
        value.fixed := ParseAddress(child, path+'/fixedAddress')
      else if (child.localName = 'fixedAge') then
        value.fixed := ParseAge(child, path+'/fixedAge')
      else if (child.localName = 'fixedAnnotation') then
        value.fixed := ParseAnnotation(child, path+'/fixedAnnotation')
      else if (child.localName = 'fixedAttachment') then
        value.fixed := ParseAttachment(child, path+'/fixedAttachment')
      else if (child.localName = 'fixedCodeableConcept') then
        value.fixed := ParseCodeableConcept(child, path+'/fixedCodeableConcept')
      else if (child.localName = 'fixedCodeableReference') then
        value.fixed := ParseCodeableReference(child, path+'/fixedCodeableReference')
      else if (child.localName = 'fixedCoding') then
        value.fixed := ParseCoding(child, path+'/fixedCoding')
      else if (child.localName = 'fixedContactPoint') then
        value.fixed := ParseContactPoint(child, path+'/fixedContactPoint')
      else if (child.localName = 'fixedCount') then
        value.fixed := ParseCount(child, path+'/fixedCount')
      else if (child.localName = 'fixedDistance') then
        value.fixed := ParseDistance(child, path+'/fixedDistance')
      else if (child.localName = 'fixedDuration') then
        value.fixed := ParseDuration(child, path+'/fixedDuration')
      else if (child.localName = 'fixedHumanName') then
        value.fixed := ParseHumanName(child, path+'/fixedHumanName')
      else if (child.localName = 'fixedIdentifier') then
        value.fixed := ParseIdentifier(child, path+'/fixedIdentifier')
      else if (child.localName = 'fixedMoney') then
        value.fixed := ParseMoney(child, path+'/fixedMoney')
      else if (child.localName = 'fixedPeriod') then
        value.fixed := ParsePeriod(child, path+'/fixedPeriod')
      else if (child.localName = 'fixedQuantity') then
        value.fixed := ParseQuantity(child, path+'/fixedQuantity')
      else if (child.localName = 'fixedRange') then
        value.fixed := ParseRange(child, path+'/fixedRange')
      else if (child.localName = 'fixedRatio') then
        value.fixed := ParseRatio(child, path+'/fixedRatio')
      else if (child.localName = 'fixedRatioRange') then
        value.fixed := ParseRatioRange(child, path+'/fixedRatioRange')
      else if (child.localName = 'fixedReference') then
        value.fixed := ParseReference(child, path+'/fixedReference')
      else if (child.localName = 'fixedSampledData') then
        value.fixed := ParseSampledData(child, path+'/fixedSampledData')
      else if (child.localName = 'fixedSignature') then
        value.fixed := ParseSignature(child, path+'/fixedSignature')
      else if (child.localName = 'fixedTiming') then
        value.fixed := ParseTiming(child, path+'/fixedTiming')
      else if (child.localName = 'fixedContactDetail') then
        value.fixed := ParseContactDetail(child, path+'/fixedContactDetail')
      else if (child.localName = 'fixedDataRequirement') then
        value.fixed := ParseDataRequirement(child, path+'/fixedDataRequirement')
      else if (child.localName = 'fixedExpression') then
        value.fixed := ParseExpression(child, path+'/fixedExpression')
      else if (child.localName = 'fixedParameterDefinition') then
        value.fixed := ParseParameterDefinition(child, path+'/fixedParameterDefinition')
      else if (child.localName = 'fixedRelatedArtifact') then
        value.fixed := ParseRelatedArtifact(child, path+'/fixedRelatedArtifact')
      else if (child.localName = 'fixedTriggerDefinition') then
        value.fixed := ParseTriggerDefinition(child, path+'/fixedTriggerDefinition')
      else if (child.localName = 'fixedUsageContext') then
        value.fixed := ParseUsageContext(child, path+'/fixedUsageContext')
      else if (child.localName = 'fixedAvailability') then
        value.fixed := ParseAvailability(child, path+'/fixedAvailability')
      else if (child.localName = 'fixedExtendedContactDetail') then
        value.fixed := ParseExtendedContactDetail(child, path+'/fixedExtendedContactDetail')
      else if (child.localName = 'fixedDosage') then
        value.fixed := ParseDosage(child, path+'/fixedDosage')
      else if (child.localName = 'fixedMeta') then
        value.fixed := ParseMeta(child, path+'/fixedMeta')
      else if (child.localName = 'fixedBase64Binary') then
        value.fixed := ParseBase64Binary(child, path+'/fixedBase64Binary')
      else if (child.localName = 'fixedBoolean') then
        value.fixed := ParseBoolean(child, path+'/fixedBoolean')
      else if (child.localName = 'fixedDate') then
        value.fixed := ParseDate(child, path+'/fixedDate')
      else if (child.localName = 'fixedDateTime') then
        value.fixed := ParseDateTime(child, path+'/fixedDateTime')
      else if (child.localName = 'fixedDecimal') then
        value.fixed := ParseDecimal(child, path+'/fixedDecimal')
      else if (child.localName = 'fixedInstant') then
        value.fixed := ParseInstant(child, path+'/fixedInstant')
      else if (child.localName = 'fixedInteger') then
        value.fixed := ParseInteger(child, path+'/fixedInteger')
      else if (child.localName = 'fixedInteger64') then
        value.fixed := ParseInteger64(child, path+'/fixedInteger64')
      else if (child.localName = 'fixedString') then
        value.fixed := ParseString(child, path+'/fixedString')
      else if (child.localName = 'fixedTime') then
        value.fixed := ParseTime(child, path+'/fixedTime')
      else if (child.localName = 'fixedUri') then
        value.fixed := ParseUri(child, path+'/fixedUri')
      else if (child.localName = 'patternCanonical') then
        value.pattern := ParseCanonical(child, path+'/patternCanonical')
      else if (child.localName = 'patternCode') then
        value.pattern := ParseCode(child, path+'/patternCode')
      else if (child.localName = 'patternId') then
        value.pattern := ParseId(child, path+'/patternId')
      else if (child.localName = 'patternMarkdown') then
        value.pattern := ParseMarkdown(child, path+'/patternMarkdown')
      else if (child.localName = 'patternOid') then
        value.pattern := ParseOid(child, path+'/patternOid')
      else if (child.localName = 'patternPositiveInt') then
        value.pattern := ParsePositiveInt(child, path+'/patternPositiveInt')
      else if (child.localName = 'patternUnsignedInt') then
        value.pattern := ParseUnsignedInt(child, path+'/patternUnsignedInt')
      else if (child.localName = 'patternUrl') then
        value.pattern := ParseUrl(child, path+'/patternUrl')
      else if (child.localName = 'patternUuid') then
        value.pattern := ParseUuid(child, path+'/patternUuid')
      else if (child.localName = 'patternAddress') then
        value.pattern := ParseAddress(child, path+'/patternAddress')
      else if (child.localName = 'patternAge') then
        value.pattern := ParseAge(child, path+'/patternAge')
      else if (child.localName = 'patternAnnotation') then
        value.pattern := ParseAnnotation(child, path+'/patternAnnotation')
      else if (child.localName = 'patternAttachment') then
        value.pattern := ParseAttachment(child, path+'/patternAttachment')
      else if (child.localName = 'patternCodeableConcept') then
        value.pattern := ParseCodeableConcept(child, path+'/patternCodeableConcept')
      else if (child.localName = 'patternCodeableReference') then
        value.pattern := ParseCodeableReference(child, path+'/patternCodeableReference')
      else if (child.localName = 'patternCoding') then
        value.pattern := ParseCoding(child, path+'/patternCoding')
      else if (child.localName = 'patternContactPoint') then
        value.pattern := ParseContactPoint(child, path+'/patternContactPoint')
      else if (child.localName = 'patternCount') then
        value.pattern := ParseCount(child, path+'/patternCount')
      else if (child.localName = 'patternDistance') then
        value.pattern := ParseDistance(child, path+'/patternDistance')
      else if (child.localName = 'patternDuration') then
        value.pattern := ParseDuration(child, path+'/patternDuration')
      else if (child.localName = 'patternHumanName') then
        value.pattern := ParseHumanName(child, path+'/patternHumanName')
      else if (child.localName = 'patternIdentifier') then
        value.pattern := ParseIdentifier(child, path+'/patternIdentifier')
      else if (child.localName = 'patternMoney') then
        value.pattern := ParseMoney(child, path+'/patternMoney')
      else if (child.localName = 'patternPeriod') then
        value.pattern := ParsePeriod(child, path+'/patternPeriod')
      else if (child.localName = 'patternQuantity') then
        value.pattern := ParseQuantity(child, path+'/patternQuantity')
      else if (child.localName = 'patternRange') then
        value.pattern := ParseRange(child, path+'/patternRange')
      else if (child.localName = 'patternRatio') then
        value.pattern := ParseRatio(child, path+'/patternRatio')
      else if (child.localName = 'patternRatioRange') then
        value.pattern := ParseRatioRange(child, path+'/patternRatioRange')
      else if (child.localName = 'patternReference') then
        value.pattern := ParseReference(child, path+'/patternReference')
      else if (child.localName = 'patternSampledData') then
        value.pattern := ParseSampledData(child, path+'/patternSampledData')
      else if (child.localName = 'patternSignature') then
        value.pattern := ParseSignature(child, path+'/patternSignature')
      else if (child.localName = 'patternTiming') then
        value.pattern := ParseTiming(child, path+'/patternTiming')
      else if (child.localName = 'patternContactDetail') then
        value.pattern := ParseContactDetail(child, path+'/patternContactDetail')
      else if (child.localName = 'patternDataRequirement') then
        value.pattern := ParseDataRequirement(child, path+'/patternDataRequirement')
      else if (child.localName = 'patternExpression') then
        value.pattern := ParseExpression(child, path+'/patternExpression')
      else if (child.localName = 'patternParameterDefinition') then
        value.pattern := ParseParameterDefinition(child, path+'/patternParameterDefinition')
      else if (child.localName = 'patternRelatedArtifact') then
        value.pattern := ParseRelatedArtifact(child, path+'/patternRelatedArtifact')
      else if (child.localName = 'patternTriggerDefinition') then
        value.pattern := ParseTriggerDefinition(child, path+'/patternTriggerDefinition')
      else if (child.localName = 'patternUsageContext') then
        value.pattern := ParseUsageContext(child, path+'/patternUsageContext')
      else if (child.localName = 'patternAvailability') then
        value.pattern := ParseAvailability(child, path+'/patternAvailability')
      else if (child.localName = 'patternExtendedContactDetail') then
        value.pattern := ParseExtendedContactDetail(child, path+'/patternExtendedContactDetail')
      else if (child.localName = 'patternDosage') then
        value.pattern := ParseDosage(child, path+'/patternDosage')
      else if (child.localName = 'patternMeta') then
        value.pattern := ParseMeta(child, path+'/patternMeta')
      else if (child.localName = 'patternBase64Binary') then
        value.pattern := ParseBase64Binary(child, path+'/patternBase64Binary')
      else if (child.localName = 'patternBoolean') then
        value.pattern := ParseBoolean(child, path+'/patternBoolean')
      else if (child.localName = 'patternDate') then
        value.pattern := ParseDate(child, path+'/patternDate')
      else if (child.localName = 'patternDateTime') then
        value.pattern := ParseDateTime(child, path+'/patternDateTime')
      else if (child.localName = 'patternDecimal') then
        value.pattern := ParseDecimal(child, path+'/patternDecimal')
      else if (child.localName = 'patternInstant') then
        value.pattern := ParseInstant(child, path+'/patternInstant')
      else if (child.localName = 'patternInteger') then
        value.pattern := ParseInteger(child, path+'/patternInteger')
      else if (child.localName = 'patternInteger64') then
        value.pattern := ParseInteger64(child, path+'/patternInteger64')
      else if (child.localName = 'patternString') then
        value.pattern := ParseString(child, path+'/patternString')
      else if (child.localName = 'patternTime') then
        value.pattern := ParseTime(child, path+'/patternTime')
      else if (child.localName = 'patternUri') then
        value.pattern := ParseUri(child, path+'/patternUri')
      else if (child.localName = 'example') then
        value.exampleList.Add(ParseElementDefinitionExample(child, path+'/example'))
      else if (child.localName = 'minValuePositiveInt') then
        value.minValue := ParsePositiveInt(child, path+'/minValuePositiveInt')
      else if (child.localName = 'minValueUnsignedInt') then
        value.minValue := ParseUnsignedInt(child, path+'/minValueUnsignedInt')
      else if (child.localName = 'minValueQuantity') then
        value.minValue := ParseQuantity(child, path+'/minValueQuantity')
      else if (child.localName = 'minValueDate') then
        value.minValue := ParseDate(child, path+'/minValueDate')
      else if (child.localName = 'minValueDateTime') then
        value.minValue := ParseDateTime(child, path+'/minValueDateTime')
      else if (child.localName = 'minValueInstant') then
        value.minValue := ParseInstant(child, path+'/minValueInstant')
      else if (child.localName = 'minValueTime') then
        value.minValue := ParseTime(child, path+'/minValueTime')
      else if (child.localName = 'minValueDecimal') then
        value.minValue := ParseDecimal(child, path+'/minValueDecimal')
      else if (child.localName = 'minValueInteger') then
        value.minValue := ParseInteger(child, path+'/minValueInteger')
      else if (child.localName = 'minValueInteger64') then
        value.minValue := ParseInteger64(child, path+'/minValueInteger64')
      else if (child.localName = 'maxValuePositiveInt') then
        value.maxValue := ParsePositiveInt(child, path+'/maxValuePositiveInt')
      else if (child.localName = 'maxValueUnsignedInt') then
        value.maxValue := ParseUnsignedInt(child, path+'/maxValueUnsignedInt')
      else if (child.localName = 'maxValueQuantity') then
        value.maxValue := ParseQuantity(child, path+'/maxValueQuantity')
      else if (child.localName = 'maxValueDate') then
        value.maxValue := ParseDate(child, path+'/maxValueDate')
      else if (child.localName = 'maxValueDateTime') then
        value.maxValue := ParseDateTime(child, path+'/maxValueDateTime')
      else if (child.localName = 'maxValueInstant') then
        value.maxValue := ParseInstant(child, path+'/maxValueInstant')
      else if (child.localName = 'maxValueTime') then
        value.maxValue := ParseTime(child, path+'/maxValueTime')
      else if (child.localName = 'maxValueDecimal') then
        value.maxValue := ParseDecimal(child, path+'/maxValueDecimal')
      else if (child.localName = 'maxValueInteger') then
        value.maxValue := ParseInteger(child, path+'/maxValueInteger')
      else if (child.localName = 'maxValueInteger64') then
        value.maxValue := ParseInteger64(child, path+'/maxValueInteger64')
      else if (child.localName = 'maxLength') then
        value.maxLengthElement := ParseInteger(child, path+'/maxLength')
      else if (child.localName = 'condition') then
        value.conditionList.Add(ParseId(child, path+'/condition'))
      else if (child.localName = 'constraint') then
        value.constraintList.Add(ParseElementDefinitionConstraint(child, path+'/constraint'))
      else if (child.localName = 'mustSupport') then
        value.mustSupportElement := ParseBoolean(child, path+'/mustSupport')
      else if (child.localName = 'isModifier') then
        value.isModifierElement := ParseBoolean(child, path+'/isModifier')
      else if (child.localName = 'isModifierReason') then
        value.isModifierReasonElement := ParseString(child, path+'/isModifierReason')
      else if (child.localName = 'isSummary') then
        value.isSummaryElement := ParseBoolean(child, path+'/isSummary')
      else if (child.localName = 'binding') then
        value.binding := ParseElementDefinitionBinding(child, path+'/binding')
      else if (child.localName = 'mapping') then
        value.mappingList.Add(ParseElementDefinitionMapping(child, path+'/mapping'))
      else if Not ParseElementChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeElementDefinition(xml : TXmlBuilder; name : String; value : TFhirElementDefinition);
begin
  if (value = nil) then
    exit;
  composeElementAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeElementDefinitionChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeElementDefinitionChildren(xml : TXmlBuilder; value : TFhirElementDefinition);
var
  i : integer;
begin
  composeBackboneTypeChildren(xml, value);
  ComposeString(xml, 'path', value.pathElement);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.representationList.Count - 1 do
      ComposeEnum(xml, 'representation', value.representationList[i], CODES_TFhirPropertyRepresentationEnum);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(xml, 'sliceName', value.sliceNameElement);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeBoolean(xml, 'sliceIsConstraining', value.sliceIsConstrainingElement);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(xml, 'label', value.label_Element);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.codeList.Count - 1 do
      ComposeCoding(xml, 'code', value.codeList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeElementDefinitionSlicing(xml, 'slicing', value.slicing);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(xml, 'short', value.shortElement);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeMarkdown(xml, 'definition', value.definitionElement);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeMarkdown(xml, 'comment', value.commentElement);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeMarkdown(xml, 'requirements', value.requirementsElement);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.aliasList.Count - 1 do
      ComposeString(xml, 'alias', value.aliasList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeUnsignedInt(xml, 'min', value.minElement);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(xml, 'max', value.maxElement);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeElementDefinitionBase(xml, 'base', value.base);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeUri(xml, 'contentReference', value.contentReferenceElement);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.type_List.Count - 1 do
      ComposeElementDefinitionType(xml, 'type', value.type_List[i]);
  if (SummaryOption in [soFull, soSummary, soData]) and (value.defaultValue is TFhirCanonical) {6} then
    ComposeCanonical(xml, 'defaultValueCanonical', TFhirCanonical(value.defaultValue))
  else if (SummaryOption in [soFull, soSummary, soData]) and (value.defaultValue is TFhirCode) {6} then
    ComposeCode(xml, 'defaultValueCode', TFhirCode(value.defaultValue))
  else if (SummaryOption in [soFull, soSummary, soData]) and (value.defaultValue is TFhirId) {6} then
    ComposeId(xml, 'defaultValueId', TFhirId(value.defaultValue))
  else if (SummaryOption in [soFull, soSummary, soData]) and (value.defaultValue is TFhirMarkdown) {6} then
    ComposeMarkdown(xml, 'defaultValueMarkdown', TFhirMarkdown(value.defaultValue))
  else if (SummaryOption in [soFull, soSummary, soData]) and (value.defaultValue is TFhirOid) {6} then
    ComposeOid(xml, 'defaultValueOid', TFhirOid(value.defaultValue))
  else if (SummaryOption in [soFull, soSummary, soData]) and (value.defaultValue is TFhirPositiveInt) {6} then
    ComposePositiveInt(xml, 'defaultValuePositiveInt', TFhirPositiveInt(value.defaultValue))
  else if (SummaryOption in [soFull, soSummary, soData]) and (value.defaultValue is TFhirUnsignedInt) {6} then
    ComposeUnsignedInt(xml, 'defaultValueUnsignedInt', TFhirUnsignedInt(value.defaultValue))
  else if (SummaryOption in [soFull, soSummary, soData]) and (value.defaultValue is TFhirUrl) {6} then
    ComposeUrl(xml, 'defaultValueUrl', TFhirUrl(value.defaultValue))
  else if (SummaryOption in [soFull, soSummary, soData]) and (value.defaultValue is TFhirUuid) {6} then
    ComposeUuid(xml, 'defaultValueUuid', TFhirUuid(value.defaultValue))
  else if (SummaryOption in [soFull, soSummary, soData]) and (value.defaultValue is TFhirAddress) {6} then
    ComposeAddress(xml, 'defaultValueAddress', TFhirAddress(value.defaultValue))
  else if (SummaryOption in [soFull, soSummary, soData]) and (value.defaultValue is TFhirAge) {6} then
    ComposeAge(xml, 'defaultValueAge', TFhirAge(value.defaultValue))
  else if (SummaryOption in [soFull, soSummary, soData]) and (value.defaultValue is TFhirAnnotation) {6} then
    ComposeAnnotation(xml, 'defaultValueAnnotation', TFhirAnnotation(value.defaultValue))
  else if (SummaryOption in [soFull, soSummary, soData]) and (value.defaultValue is TFhirAttachment) {6} then
    ComposeAttachment(xml, 'defaultValueAttachment', TFhirAttachment(value.defaultValue))
  else if (SummaryOption in [soFull, soSummary, soData]) and (value.defaultValue is TFhirCodeableConcept) {6} then
    ComposeCodeableConcept(xml, 'defaultValueCodeableConcept', TFhirCodeableConcept(value.defaultValue))
  else if (SummaryOption in [soFull, soSummary, soData]) and (value.defaultValue is TFhirCodeableReference) {6} then
    ComposeCodeableReference(xml, 'defaultValueCodeableReference', TFhirCodeableReference(value.defaultValue))
  else if (SummaryOption in [soFull, soSummary, soData]) and (value.defaultValue is TFhirCoding) {6} then
    ComposeCoding(xml, 'defaultValueCoding', TFhirCoding(value.defaultValue))
  else if (SummaryOption in [soFull, soSummary, soData]) and (value.defaultValue is TFhirContactPoint) {6} then
    ComposeContactPoint(xml, 'defaultValueContactPoint', TFhirContactPoint(value.defaultValue))
  else if (SummaryOption in [soFull, soSummary, soData]) and (value.defaultValue is TFhirCount) {6} then
    ComposeCount(xml, 'defaultValueCount', TFhirCount(value.defaultValue))
  else if (SummaryOption in [soFull, soSummary, soData]) and (value.defaultValue is TFhirDistance) {6} then
    ComposeDistance(xml, 'defaultValueDistance', TFhirDistance(value.defaultValue))
  else if (SummaryOption in [soFull, soSummary, soData]) and (value.defaultValue is TFhirDuration) {6} then
    ComposeDuration(xml, 'defaultValueDuration', TFhirDuration(value.defaultValue))
  else if (SummaryOption in [soFull, soSummary, soData]) and (value.defaultValue is TFhirHumanName) {6} then
    ComposeHumanName(xml, 'defaultValueHumanName', TFhirHumanName(value.defaultValue))
  else if (SummaryOption in [soFull, soSummary, soData]) and (value.defaultValue is TFhirIdentifier) {6} then
    ComposeIdentifier(xml, 'defaultValueIdentifier', TFhirIdentifier(value.defaultValue))
  else if (SummaryOption in [soFull, soSummary, soData]) and (value.defaultValue is TFhirMoney) {6} then
    ComposeMoney(xml, 'defaultValueMoney', TFhirMoney(value.defaultValue))
  else if (SummaryOption in [soFull, soSummary, soData]) and (value.defaultValue is TFhirPeriod) {6} then
    ComposePeriod(xml, 'defaultValuePeriod', TFhirPeriod(value.defaultValue))
  else if (SummaryOption in [soFull, soSummary, soData]) and (value.defaultValue is TFhirQuantity) {6} then
    ComposeQuantity(xml, 'defaultValueQuantity', TFhirQuantity(value.defaultValue))
  else if (SummaryOption in [soFull, soSummary, soData]) and (value.defaultValue is TFhirRange) {6} then
    ComposeRange(xml, 'defaultValueRange', TFhirRange(value.defaultValue))
  else if (SummaryOption in [soFull, soSummary, soData]) and (value.defaultValue is TFhirRatio) {6} then
    ComposeRatio(xml, 'defaultValueRatio', TFhirRatio(value.defaultValue))
  else if (SummaryOption in [soFull, soSummary, soData]) and (value.defaultValue is TFhirRatioRange) {6} then
    ComposeRatioRange(xml, 'defaultValueRatioRange', TFhirRatioRange(value.defaultValue))
  else if (SummaryOption in [soFull, soSummary, soData]) and (value.defaultValue is TFhirReference) {6} then
    ComposeReference(xml, 'defaultValueReference', TFhirReference(value.defaultValue))
  else if (SummaryOption in [soFull, soSummary, soData]) and (value.defaultValue is TFhirSampledData) {6} then
    ComposeSampledData(xml, 'defaultValueSampledData', TFhirSampledData(value.defaultValue))
  else if (SummaryOption in [soFull, soSummary, soData]) and (value.defaultValue is TFhirSignature) {6} then
    ComposeSignature(xml, 'defaultValueSignature', TFhirSignature(value.defaultValue))
  else if (SummaryOption in [soFull, soSummary, soData]) and (value.defaultValue is TFhirTiming) {6} then
    ComposeTiming(xml, 'defaultValueTiming', TFhirTiming(value.defaultValue))
  else if (SummaryOption in [soFull, soSummary, soData]) and (value.defaultValue is TFhirContactDetail) {6} then
    ComposeContactDetail(xml, 'defaultValueContactDetail', TFhirContactDetail(value.defaultValue))
  else if (SummaryOption in [soFull, soSummary, soData]) and (value.defaultValue is TFhirDataRequirement) {6} then
    ComposeDataRequirement(xml, 'defaultValueDataRequirement', TFhirDataRequirement(value.defaultValue))
  else if (SummaryOption in [soFull, soSummary, soData]) and (value.defaultValue is TFhirExpression) {6} then
    ComposeExpression(xml, 'defaultValueExpression', TFhirExpression(value.defaultValue))
  else if (SummaryOption in [soFull, soSummary, soData]) and (value.defaultValue is TFhirParameterDefinition) {6} then
    ComposeParameterDefinition(xml, 'defaultValueParameterDefinition', TFhirParameterDefinition(value.defaultValue))
  else if (SummaryOption in [soFull, soSummary, soData]) and (value.defaultValue is TFhirRelatedArtifact) {6} then
    ComposeRelatedArtifact(xml, 'defaultValueRelatedArtifact', TFhirRelatedArtifact(value.defaultValue))
  else if (SummaryOption in [soFull, soSummary, soData]) and (value.defaultValue is TFhirTriggerDefinition) {6} then
    ComposeTriggerDefinition(xml, 'defaultValueTriggerDefinition', TFhirTriggerDefinition(value.defaultValue))
  else if (SummaryOption in [soFull, soSummary, soData]) and (value.defaultValue is TFhirUsageContext) {6} then
    ComposeUsageContext(xml, 'defaultValueUsageContext', TFhirUsageContext(value.defaultValue))
  else if (SummaryOption in [soFull, soSummary, soData]) and (value.defaultValue is TFhirAvailability) {6} then
    ComposeAvailability(xml, 'defaultValueAvailability', TFhirAvailability(value.defaultValue))
  else if (SummaryOption in [soFull, soSummary, soData]) and (value.defaultValue is TFhirExtendedContactDetail) {6} then
    ComposeExtendedContactDetail(xml, 'defaultValueExtendedContactDetail', TFhirExtendedContactDetail(value.defaultValue))
  else if (SummaryOption in [soFull, soSummary, soData]) and (value.defaultValue is TFhirDosage) {6} then
    ComposeDosage(xml, 'defaultValueDosage', TFhirDosage(value.defaultValue))
  else if (SummaryOption in [soFull, soSummary, soData]) and (value.defaultValue is TFhirMeta) {6} then
    ComposeMeta(xml, 'defaultValueMeta', TFhirMeta(value.defaultValue))
  else if (SummaryOption in [soFull, soSummary, soData]) and (value.defaultValue is TFhirBase64Binary) {6} then
    ComposeBase64Binary(xml, 'defaultValueBase64Binary', TFhirBase64Binary(value.defaultValue))
  else if (SummaryOption in [soFull, soSummary, soData]) and (value.defaultValue is TFhirBoolean) {6} then
    ComposeBoolean(xml, 'defaultValueBoolean', TFhirBoolean(value.defaultValue))
  else if (SummaryOption in [soFull, soSummary, soData]) and (value.defaultValue is TFhirDate) {6} then
    ComposeDate(xml, 'defaultValueDate', TFhirDate(value.defaultValue))
  else if (SummaryOption in [soFull, soSummary, soData]) and (value.defaultValue is TFhirDateTime) {6} then
    ComposeDateTime(xml, 'defaultValueDateTime', TFhirDateTime(value.defaultValue))
  else if (SummaryOption in [soFull, soSummary, soData]) and (value.defaultValue is TFhirDecimal) {6} then
    ComposeDecimal(xml, 'defaultValueDecimal', TFhirDecimal(value.defaultValue))
  else if (SummaryOption in [soFull, soSummary, soData]) and (value.defaultValue is TFhirInstant) {6} then
    ComposeInstant(xml, 'defaultValueInstant', TFhirInstant(value.defaultValue))
  else if (SummaryOption in [soFull, soSummary, soData]) and (value.defaultValue is TFhirInteger) {6} then
    ComposeInteger(xml, 'defaultValueInteger', TFhirInteger(value.defaultValue))
  else if (SummaryOption in [soFull, soSummary, soData]) and (value.defaultValue is TFhirInteger64) {6} then
    ComposeInteger64(xml, 'defaultValueInteger64', TFhirInteger64(value.defaultValue))
  else if (SummaryOption in [soFull, soSummary, soData]) and (value.defaultValue is TFhirString) {6} then
    ComposeString(xml, 'defaultValueString', TFhirString(value.defaultValue))
  else if (SummaryOption in [soFull, soSummary, soData]) and (value.defaultValue is TFhirTime) {6} then
    ComposeTime(xml, 'defaultValueTime', TFhirTime(value.defaultValue))
  else if (SummaryOption in [soFull, soSummary, soData]) and (value.defaultValue is TFhirUri) {6} then
    ComposeUri(xml, 'defaultValueUri', TFhirUri(value.defaultValue));
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeMarkdown(xml, 'meaningWhenMissing', value.meaningWhenMissingElement);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(xml, 'orderMeaning', value.orderMeaningElement);
  if (SummaryOption in [soFull, soSummary, soData]) and (value.fixed is TFhirCanonical) {6} then
    ComposeCanonical(xml, 'fixedCanonical', TFhirCanonical(value.fixed))
  else if (SummaryOption in [soFull, soSummary, soData]) and (value.fixed is TFhirCode) {6} then
    ComposeCode(xml, 'fixedCode', TFhirCode(value.fixed))
  else if (SummaryOption in [soFull, soSummary, soData]) and (value.fixed is TFhirId) {6} then
    ComposeId(xml, 'fixedId', TFhirId(value.fixed))
  else if (SummaryOption in [soFull, soSummary, soData]) and (value.fixed is TFhirMarkdown) {6} then
    ComposeMarkdown(xml, 'fixedMarkdown', TFhirMarkdown(value.fixed))
  else if (SummaryOption in [soFull, soSummary, soData]) and (value.fixed is TFhirOid) {6} then
    ComposeOid(xml, 'fixedOid', TFhirOid(value.fixed))
  else if (SummaryOption in [soFull, soSummary, soData]) and (value.fixed is TFhirPositiveInt) {6} then
    ComposePositiveInt(xml, 'fixedPositiveInt', TFhirPositiveInt(value.fixed))
  else if (SummaryOption in [soFull, soSummary, soData]) and (value.fixed is TFhirUnsignedInt) {6} then
    ComposeUnsignedInt(xml, 'fixedUnsignedInt', TFhirUnsignedInt(value.fixed))
  else if (SummaryOption in [soFull, soSummary, soData]) and (value.fixed is TFhirUrl) {6} then
    ComposeUrl(xml, 'fixedUrl', TFhirUrl(value.fixed))
  else if (SummaryOption in [soFull, soSummary, soData]) and (value.fixed is TFhirUuid) {6} then
    ComposeUuid(xml, 'fixedUuid', TFhirUuid(value.fixed))
  else if (SummaryOption in [soFull, soSummary, soData]) and (value.fixed is TFhirAddress) {6} then
    ComposeAddress(xml, 'fixedAddress', TFhirAddress(value.fixed))
  else if (SummaryOption in [soFull, soSummary, soData]) and (value.fixed is TFhirAge) {6} then
    ComposeAge(xml, 'fixedAge', TFhirAge(value.fixed))
  else if (SummaryOption in [soFull, soSummary, soData]) and (value.fixed is TFhirAnnotation) {6} then
    ComposeAnnotation(xml, 'fixedAnnotation', TFhirAnnotation(value.fixed))
  else if (SummaryOption in [soFull, soSummary, soData]) and (value.fixed is TFhirAttachment) {6} then
    ComposeAttachment(xml, 'fixedAttachment', TFhirAttachment(value.fixed))
  else if (SummaryOption in [soFull, soSummary, soData]) and (value.fixed is TFhirCodeableConcept) {6} then
    ComposeCodeableConcept(xml, 'fixedCodeableConcept', TFhirCodeableConcept(value.fixed))
  else if (SummaryOption in [soFull, soSummary, soData]) and (value.fixed is TFhirCodeableReference) {6} then
    ComposeCodeableReference(xml, 'fixedCodeableReference', TFhirCodeableReference(value.fixed))
  else if (SummaryOption in [soFull, soSummary, soData]) and (value.fixed is TFhirCoding) {6} then
    ComposeCoding(xml, 'fixedCoding', TFhirCoding(value.fixed))
  else if (SummaryOption in [soFull, soSummary, soData]) and (value.fixed is TFhirContactPoint) {6} then
    ComposeContactPoint(xml, 'fixedContactPoint', TFhirContactPoint(value.fixed))
  else if (SummaryOption in [soFull, soSummary, soData]) and (value.fixed is TFhirCount) {6} then
    ComposeCount(xml, 'fixedCount', TFhirCount(value.fixed))
  else if (SummaryOption in [soFull, soSummary, soData]) and (value.fixed is TFhirDistance) {6} then
    ComposeDistance(xml, 'fixedDistance', TFhirDistance(value.fixed))
  else if (SummaryOption in [soFull, soSummary, soData]) and (value.fixed is TFhirDuration) {6} then
    ComposeDuration(xml, 'fixedDuration', TFhirDuration(value.fixed))
  else if (SummaryOption in [soFull, soSummary, soData]) and (value.fixed is TFhirHumanName) {6} then
    ComposeHumanName(xml, 'fixedHumanName', TFhirHumanName(value.fixed))
  else if (SummaryOption in [soFull, soSummary, soData]) and (value.fixed is TFhirIdentifier) {6} then
    ComposeIdentifier(xml, 'fixedIdentifier', TFhirIdentifier(value.fixed))
  else if (SummaryOption in [soFull, soSummary, soData]) and (value.fixed is TFhirMoney) {6} then
    ComposeMoney(xml, 'fixedMoney', TFhirMoney(value.fixed))
  else if (SummaryOption in [soFull, soSummary, soData]) and (value.fixed is TFhirPeriod) {6} then
    ComposePeriod(xml, 'fixedPeriod', TFhirPeriod(value.fixed))
  else if (SummaryOption in [soFull, soSummary, soData]) and (value.fixed is TFhirQuantity) {6} then
    ComposeQuantity(xml, 'fixedQuantity', TFhirQuantity(value.fixed))
  else if (SummaryOption in [soFull, soSummary, soData]) and (value.fixed is TFhirRange) {6} then
    ComposeRange(xml, 'fixedRange', TFhirRange(value.fixed))
  else if (SummaryOption in [soFull, soSummary, soData]) and (value.fixed is TFhirRatio) {6} then
    ComposeRatio(xml, 'fixedRatio', TFhirRatio(value.fixed))
  else if (SummaryOption in [soFull, soSummary, soData]) and (value.fixed is TFhirRatioRange) {6} then
    ComposeRatioRange(xml, 'fixedRatioRange', TFhirRatioRange(value.fixed))
  else if (SummaryOption in [soFull, soSummary, soData]) and (value.fixed is TFhirReference) {6} then
    ComposeReference(xml, 'fixedReference', TFhirReference(value.fixed))
  else if (SummaryOption in [soFull, soSummary, soData]) and (value.fixed is TFhirSampledData) {6} then
    ComposeSampledData(xml, 'fixedSampledData', TFhirSampledData(value.fixed))
  else if (SummaryOption in [soFull, soSummary, soData]) and (value.fixed is TFhirSignature) {6} then
    ComposeSignature(xml, 'fixedSignature', TFhirSignature(value.fixed))
  else if (SummaryOption in [soFull, soSummary, soData]) and (value.fixed is TFhirTiming) {6} then
    ComposeTiming(xml, 'fixedTiming', TFhirTiming(value.fixed))
  else if (SummaryOption in [soFull, soSummary, soData]) and (value.fixed is TFhirContactDetail) {6} then
    ComposeContactDetail(xml, 'fixedContactDetail', TFhirContactDetail(value.fixed))
  else if (SummaryOption in [soFull, soSummary, soData]) and (value.fixed is TFhirDataRequirement) {6} then
    ComposeDataRequirement(xml, 'fixedDataRequirement', TFhirDataRequirement(value.fixed))
  else if (SummaryOption in [soFull, soSummary, soData]) and (value.fixed is TFhirExpression) {6} then
    ComposeExpression(xml, 'fixedExpression', TFhirExpression(value.fixed))
  else if (SummaryOption in [soFull, soSummary, soData]) and (value.fixed is TFhirParameterDefinition) {6} then
    ComposeParameterDefinition(xml, 'fixedParameterDefinition', TFhirParameterDefinition(value.fixed))
  else if (SummaryOption in [soFull, soSummary, soData]) and (value.fixed is TFhirRelatedArtifact) {6} then
    ComposeRelatedArtifact(xml, 'fixedRelatedArtifact', TFhirRelatedArtifact(value.fixed))
  else if (SummaryOption in [soFull, soSummary, soData]) and (value.fixed is TFhirTriggerDefinition) {6} then
    ComposeTriggerDefinition(xml, 'fixedTriggerDefinition', TFhirTriggerDefinition(value.fixed))
  else if (SummaryOption in [soFull, soSummary, soData]) and (value.fixed is TFhirUsageContext) {6} then
    ComposeUsageContext(xml, 'fixedUsageContext', TFhirUsageContext(value.fixed))
  else if (SummaryOption in [soFull, soSummary, soData]) and (value.fixed is TFhirAvailability) {6} then
    ComposeAvailability(xml, 'fixedAvailability', TFhirAvailability(value.fixed))
  else if (SummaryOption in [soFull, soSummary, soData]) and (value.fixed is TFhirExtendedContactDetail) {6} then
    ComposeExtendedContactDetail(xml, 'fixedExtendedContactDetail', TFhirExtendedContactDetail(value.fixed))
  else if (SummaryOption in [soFull, soSummary, soData]) and (value.fixed is TFhirDosage) {6} then
    ComposeDosage(xml, 'fixedDosage', TFhirDosage(value.fixed))
  else if (SummaryOption in [soFull, soSummary, soData]) and (value.fixed is TFhirMeta) {6} then
    ComposeMeta(xml, 'fixedMeta', TFhirMeta(value.fixed))
  else if (SummaryOption in [soFull, soSummary, soData]) and (value.fixed is TFhirBase64Binary) {6} then
    ComposeBase64Binary(xml, 'fixedBase64Binary', TFhirBase64Binary(value.fixed))
  else if (SummaryOption in [soFull, soSummary, soData]) and (value.fixed is TFhirBoolean) {6} then
    ComposeBoolean(xml, 'fixedBoolean', TFhirBoolean(value.fixed))
  else if (SummaryOption in [soFull, soSummary, soData]) and (value.fixed is TFhirDate) {6} then
    ComposeDate(xml, 'fixedDate', TFhirDate(value.fixed))
  else if (SummaryOption in [soFull, soSummary, soData]) and (value.fixed is TFhirDateTime) {6} then
    ComposeDateTime(xml, 'fixedDateTime', TFhirDateTime(value.fixed))
  else if (SummaryOption in [soFull, soSummary, soData]) and (value.fixed is TFhirDecimal) {6} then
    ComposeDecimal(xml, 'fixedDecimal', TFhirDecimal(value.fixed))
  else if (SummaryOption in [soFull, soSummary, soData]) and (value.fixed is TFhirInstant) {6} then
    ComposeInstant(xml, 'fixedInstant', TFhirInstant(value.fixed))
  else if (SummaryOption in [soFull, soSummary, soData]) and (value.fixed is TFhirInteger) {6} then
    ComposeInteger(xml, 'fixedInteger', TFhirInteger(value.fixed))
  else if (SummaryOption in [soFull, soSummary, soData]) and (value.fixed is TFhirInteger64) {6} then
    ComposeInteger64(xml, 'fixedInteger64', TFhirInteger64(value.fixed))
  else if (SummaryOption in [soFull, soSummary, soData]) and (value.fixed is TFhirString) {6} then
    ComposeString(xml, 'fixedString', TFhirString(value.fixed))
  else if (SummaryOption in [soFull, soSummary, soData]) and (value.fixed is TFhirTime) {6} then
    ComposeTime(xml, 'fixedTime', TFhirTime(value.fixed))
  else if (SummaryOption in [soFull, soSummary, soData]) and (value.fixed is TFhirUri) {6} then
    ComposeUri(xml, 'fixedUri', TFhirUri(value.fixed));
  if (SummaryOption in [soFull, soSummary, soData]) and (value.pattern is TFhirCanonical) {6} then
    ComposeCanonical(xml, 'patternCanonical', TFhirCanonical(value.pattern))
  else if (SummaryOption in [soFull, soSummary, soData]) and (value.pattern is TFhirCode) {6} then
    ComposeCode(xml, 'patternCode', TFhirCode(value.pattern))
  else if (SummaryOption in [soFull, soSummary, soData]) and (value.pattern is TFhirId) {6} then
    ComposeId(xml, 'patternId', TFhirId(value.pattern))
  else if (SummaryOption in [soFull, soSummary, soData]) and (value.pattern is TFhirMarkdown) {6} then
    ComposeMarkdown(xml, 'patternMarkdown', TFhirMarkdown(value.pattern))
  else if (SummaryOption in [soFull, soSummary, soData]) and (value.pattern is TFhirOid) {6} then
    ComposeOid(xml, 'patternOid', TFhirOid(value.pattern))
  else if (SummaryOption in [soFull, soSummary, soData]) and (value.pattern is TFhirPositiveInt) {6} then
    ComposePositiveInt(xml, 'patternPositiveInt', TFhirPositiveInt(value.pattern))
  else if (SummaryOption in [soFull, soSummary, soData]) and (value.pattern is TFhirUnsignedInt) {6} then
    ComposeUnsignedInt(xml, 'patternUnsignedInt', TFhirUnsignedInt(value.pattern))
  else if (SummaryOption in [soFull, soSummary, soData]) and (value.pattern is TFhirUrl) {6} then
    ComposeUrl(xml, 'patternUrl', TFhirUrl(value.pattern))
  else if (SummaryOption in [soFull, soSummary, soData]) and (value.pattern is TFhirUuid) {6} then
    ComposeUuid(xml, 'patternUuid', TFhirUuid(value.pattern))
  else if (SummaryOption in [soFull, soSummary, soData]) and (value.pattern is TFhirAddress) {6} then
    ComposeAddress(xml, 'patternAddress', TFhirAddress(value.pattern))
  else if (SummaryOption in [soFull, soSummary, soData]) and (value.pattern is TFhirAge) {6} then
    ComposeAge(xml, 'patternAge', TFhirAge(value.pattern))
  else if (SummaryOption in [soFull, soSummary, soData]) and (value.pattern is TFhirAnnotation) {6} then
    ComposeAnnotation(xml, 'patternAnnotation', TFhirAnnotation(value.pattern))
  else if (SummaryOption in [soFull, soSummary, soData]) and (value.pattern is TFhirAttachment) {6} then
    ComposeAttachment(xml, 'patternAttachment', TFhirAttachment(value.pattern))
  else if (SummaryOption in [soFull, soSummary, soData]) and (value.pattern is TFhirCodeableConcept) {6} then
    ComposeCodeableConcept(xml, 'patternCodeableConcept', TFhirCodeableConcept(value.pattern))
  else if (SummaryOption in [soFull, soSummary, soData]) and (value.pattern is TFhirCodeableReference) {6} then
    ComposeCodeableReference(xml, 'patternCodeableReference', TFhirCodeableReference(value.pattern))
  else if (SummaryOption in [soFull, soSummary, soData]) and (value.pattern is TFhirCoding) {6} then
    ComposeCoding(xml, 'patternCoding', TFhirCoding(value.pattern))
  else if (SummaryOption in [soFull, soSummary, soData]) and (value.pattern is TFhirContactPoint) {6} then
    ComposeContactPoint(xml, 'patternContactPoint', TFhirContactPoint(value.pattern))
  else if (SummaryOption in [soFull, soSummary, soData]) and (value.pattern is TFhirCount) {6} then
    ComposeCount(xml, 'patternCount', TFhirCount(value.pattern))
  else if (SummaryOption in [soFull, soSummary, soData]) and (value.pattern is TFhirDistance) {6} then
    ComposeDistance(xml, 'patternDistance', TFhirDistance(value.pattern))
  else if (SummaryOption in [soFull, soSummary, soData]) and (value.pattern is TFhirDuration) {6} then
    ComposeDuration(xml, 'patternDuration', TFhirDuration(value.pattern))
  else if (SummaryOption in [soFull, soSummary, soData]) and (value.pattern is TFhirHumanName) {6} then
    ComposeHumanName(xml, 'patternHumanName', TFhirHumanName(value.pattern))
  else if (SummaryOption in [soFull, soSummary, soData]) and (value.pattern is TFhirIdentifier) {6} then
    ComposeIdentifier(xml, 'patternIdentifier', TFhirIdentifier(value.pattern))
  else if (SummaryOption in [soFull, soSummary, soData]) and (value.pattern is TFhirMoney) {6} then
    ComposeMoney(xml, 'patternMoney', TFhirMoney(value.pattern))
  else if (SummaryOption in [soFull, soSummary, soData]) and (value.pattern is TFhirPeriod) {6} then
    ComposePeriod(xml, 'patternPeriod', TFhirPeriod(value.pattern))
  else if (SummaryOption in [soFull, soSummary, soData]) and (value.pattern is TFhirQuantity) {6} then
    ComposeQuantity(xml, 'patternQuantity', TFhirQuantity(value.pattern))
  else if (SummaryOption in [soFull, soSummary, soData]) and (value.pattern is TFhirRange) {6} then
    ComposeRange(xml, 'patternRange', TFhirRange(value.pattern))
  else if (SummaryOption in [soFull, soSummary, soData]) and (value.pattern is TFhirRatio) {6} then
    ComposeRatio(xml, 'patternRatio', TFhirRatio(value.pattern))
  else if (SummaryOption in [soFull, soSummary, soData]) and (value.pattern is TFhirRatioRange) {6} then
    ComposeRatioRange(xml, 'patternRatioRange', TFhirRatioRange(value.pattern))
  else if (SummaryOption in [soFull, soSummary, soData]) and (value.pattern is TFhirReference) {6} then
    ComposeReference(xml, 'patternReference', TFhirReference(value.pattern))
  else if (SummaryOption in [soFull, soSummary, soData]) and (value.pattern is TFhirSampledData) {6} then
    ComposeSampledData(xml, 'patternSampledData', TFhirSampledData(value.pattern))
  else if (SummaryOption in [soFull, soSummary, soData]) and (value.pattern is TFhirSignature) {6} then
    ComposeSignature(xml, 'patternSignature', TFhirSignature(value.pattern))
  else if (SummaryOption in [soFull, soSummary, soData]) and (value.pattern is TFhirTiming) {6} then
    ComposeTiming(xml, 'patternTiming', TFhirTiming(value.pattern))
  else if (SummaryOption in [soFull, soSummary, soData]) and (value.pattern is TFhirContactDetail) {6} then
    ComposeContactDetail(xml, 'patternContactDetail', TFhirContactDetail(value.pattern))
  else if (SummaryOption in [soFull, soSummary, soData]) and (value.pattern is TFhirDataRequirement) {6} then
    ComposeDataRequirement(xml, 'patternDataRequirement', TFhirDataRequirement(value.pattern))
  else if (SummaryOption in [soFull, soSummary, soData]) and (value.pattern is TFhirExpression) {6} then
    ComposeExpression(xml, 'patternExpression', TFhirExpression(value.pattern))
  else if (SummaryOption in [soFull, soSummary, soData]) and (value.pattern is TFhirParameterDefinition) {6} then
    ComposeParameterDefinition(xml, 'patternParameterDefinition', TFhirParameterDefinition(value.pattern))
  else if (SummaryOption in [soFull, soSummary, soData]) and (value.pattern is TFhirRelatedArtifact) {6} then
    ComposeRelatedArtifact(xml, 'patternRelatedArtifact', TFhirRelatedArtifact(value.pattern))
  else if (SummaryOption in [soFull, soSummary, soData]) and (value.pattern is TFhirTriggerDefinition) {6} then
    ComposeTriggerDefinition(xml, 'patternTriggerDefinition', TFhirTriggerDefinition(value.pattern))
  else if (SummaryOption in [soFull, soSummary, soData]) and (value.pattern is TFhirUsageContext) {6} then
    ComposeUsageContext(xml, 'patternUsageContext', TFhirUsageContext(value.pattern))
  else if (SummaryOption in [soFull, soSummary, soData]) and (value.pattern is TFhirAvailability) {6} then
    ComposeAvailability(xml, 'patternAvailability', TFhirAvailability(value.pattern))
  else if (SummaryOption in [soFull, soSummary, soData]) and (value.pattern is TFhirExtendedContactDetail) {6} then
    ComposeExtendedContactDetail(xml, 'patternExtendedContactDetail', TFhirExtendedContactDetail(value.pattern))
  else if (SummaryOption in [soFull, soSummary, soData]) and (value.pattern is TFhirDosage) {6} then
    ComposeDosage(xml, 'patternDosage', TFhirDosage(value.pattern))
  else if (SummaryOption in [soFull, soSummary, soData]) and (value.pattern is TFhirMeta) {6} then
    ComposeMeta(xml, 'patternMeta', TFhirMeta(value.pattern))
  else if (SummaryOption in [soFull, soSummary, soData]) and (value.pattern is TFhirBase64Binary) {6} then
    ComposeBase64Binary(xml, 'patternBase64Binary', TFhirBase64Binary(value.pattern))
  else if (SummaryOption in [soFull, soSummary, soData]) and (value.pattern is TFhirBoolean) {6} then
    ComposeBoolean(xml, 'patternBoolean', TFhirBoolean(value.pattern))
  else if (SummaryOption in [soFull, soSummary, soData]) and (value.pattern is TFhirDate) {6} then
    ComposeDate(xml, 'patternDate', TFhirDate(value.pattern))
  else if (SummaryOption in [soFull, soSummary, soData]) and (value.pattern is TFhirDateTime) {6} then
    ComposeDateTime(xml, 'patternDateTime', TFhirDateTime(value.pattern))
  else if (SummaryOption in [soFull, soSummary, soData]) and (value.pattern is TFhirDecimal) {6} then
    ComposeDecimal(xml, 'patternDecimal', TFhirDecimal(value.pattern))
  else if (SummaryOption in [soFull, soSummary, soData]) and (value.pattern is TFhirInstant) {6} then
    ComposeInstant(xml, 'patternInstant', TFhirInstant(value.pattern))
  else if (SummaryOption in [soFull, soSummary, soData]) and (value.pattern is TFhirInteger) {6} then
    ComposeInteger(xml, 'patternInteger', TFhirInteger(value.pattern))
  else if (SummaryOption in [soFull, soSummary, soData]) and (value.pattern is TFhirInteger64) {6} then
    ComposeInteger64(xml, 'patternInteger64', TFhirInteger64(value.pattern))
  else if (SummaryOption in [soFull, soSummary, soData]) and (value.pattern is TFhirString) {6} then
    ComposeString(xml, 'patternString', TFhirString(value.pattern))
  else if (SummaryOption in [soFull, soSummary, soData]) and (value.pattern is TFhirTime) {6} then
    ComposeTime(xml, 'patternTime', TFhirTime(value.pattern))
  else if (SummaryOption in [soFull, soSummary, soData]) and (value.pattern is TFhirUri) {6} then
    ComposeUri(xml, 'patternUri', TFhirUri(value.pattern));
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.exampleList.Count - 1 do
      ComposeElementDefinitionExample(xml, 'example', value.exampleList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) and (value.minValue is TFhirPositiveInt) {6} then
    ComposePositiveInt(xml, 'minValuePositiveInt', TFhirPositiveInt(value.minValue))
  else if (SummaryOption in [soFull, soSummary, soData]) and (value.minValue is TFhirUnsignedInt) {6} then
    ComposeUnsignedInt(xml, 'minValueUnsignedInt', TFhirUnsignedInt(value.minValue))
  else if (SummaryOption in [soFull, soSummary, soData]) and (value.minValue is TFhirQuantity) {6} then
    ComposeQuantity(xml, 'minValueQuantity', TFhirQuantity(value.minValue))
  else if (SummaryOption in [soFull, soSummary, soData]) and (value.minValue is TFhirDate) {6} then
    ComposeDate(xml, 'minValueDate', TFhirDate(value.minValue))
  else if (SummaryOption in [soFull, soSummary, soData]) and (value.minValue is TFhirDateTime) {6} then
    ComposeDateTime(xml, 'minValueDateTime', TFhirDateTime(value.minValue))
  else if (SummaryOption in [soFull, soSummary, soData]) and (value.minValue is TFhirInstant) {6} then
    ComposeInstant(xml, 'minValueInstant', TFhirInstant(value.minValue))
  else if (SummaryOption in [soFull, soSummary, soData]) and (value.minValue is TFhirTime) {6} then
    ComposeTime(xml, 'minValueTime', TFhirTime(value.minValue))
  else if (SummaryOption in [soFull, soSummary, soData]) and (value.minValue is TFhirDecimal) {6} then
    ComposeDecimal(xml, 'minValueDecimal', TFhirDecimal(value.minValue))
  else if (SummaryOption in [soFull, soSummary, soData]) and (value.minValue is TFhirInteger) {6} then
    ComposeInteger(xml, 'minValueInteger', TFhirInteger(value.minValue))
  else if (SummaryOption in [soFull, soSummary, soData]) and (value.minValue is TFhirInteger64) {6} then
    ComposeInteger64(xml, 'minValueInteger64', TFhirInteger64(value.minValue));
  if (SummaryOption in [soFull, soSummary, soData]) and (value.maxValue is TFhirPositiveInt) {6} then
    ComposePositiveInt(xml, 'maxValuePositiveInt', TFhirPositiveInt(value.maxValue))
  else if (SummaryOption in [soFull, soSummary, soData]) and (value.maxValue is TFhirUnsignedInt) {6} then
    ComposeUnsignedInt(xml, 'maxValueUnsignedInt', TFhirUnsignedInt(value.maxValue))
  else if (SummaryOption in [soFull, soSummary, soData]) and (value.maxValue is TFhirQuantity) {6} then
    ComposeQuantity(xml, 'maxValueQuantity', TFhirQuantity(value.maxValue))
  else if (SummaryOption in [soFull, soSummary, soData]) and (value.maxValue is TFhirDate) {6} then
    ComposeDate(xml, 'maxValueDate', TFhirDate(value.maxValue))
  else if (SummaryOption in [soFull, soSummary, soData]) and (value.maxValue is TFhirDateTime) {6} then
    ComposeDateTime(xml, 'maxValueDateTime', TFhirDateTime(value.maxValue))
  else if (SummaryOption in [soFull, soSummary, soData]) and (value.maxValue is TFhirInstant) {6} then
    ComposeInstant(xml, 'maxValueInstant', TFhirInstant(value.maxValue))
  else if (SummaryOption in [soFull, soSummary, soData]) and (value.maxValue is TFhirTime) {6} then
    ComposeTime(xml, 'maxValueTime', TFhirTime(value.maxValue))
  else if (SummaryOption in [soFull, soSummary, soData]) and (value.maxValue is TFhirDecimal) {6} then
    ComposeDecimal(xml, 'maxValueDecimal', TFhirDecimal(value.maxValue))
  else if (SummaryOption in [soFull, soSummary, soData]) and (value.maxValue is TFhirInteger) {6} then
    ComposeInteger(xml, 'maxValueInteger', TFhirInteger(value.maxValue))
  else if (SummaryOption in [soFull, soSummary, soData]) and (value.maxValue is TFhirInteger64) {6} then
    ComposeInteger64(xml, 'maxValueInteger64', TFhirInteger64(value.maxValue));
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeInteger(xml, 'maxLength', value.maxLengthElement);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.conditionList.Count - 1 do
      ComposeId(xml, 'condition', value.conditionList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.constraintList.Count - 1 do
      ComposeElementDefinitionConstraint(xml, 'constraint', value.constraintList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeBoolean(xml, 'mustSupport', value.mustSupportElement);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeBoolean(xml, 'isModifier', value.isModifierElement);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(xml, 'isModifierReason', value.isModifierReasonElement);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeBoolean(xml, 'isSummary', value.isSummaryElement);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeElementDefinitionBinding(xml, 'binding', value.binding);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.mappingList.Count - 1 do
      ComposeElementDefinitionMapping(xml, 'mapping', value.mappingList[i]);
end;

function TFHIRXmlParser.ParseMarketingStatus(element : TMXmlElement; path : string) : TFhirMarketingStatus;
var
  child : TMXmlElement;
begin
  result := TFhirMarketingStatus.Create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseMarketingStatusChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseMarketingStatusChild(value : TFhirMarketingStatus; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'country') then
        value.country := ParseCodeableConcept(child, path+'/country')
      else if (child.localName = 'jurisdiction') then
        value.jurisdiction := ParseCodeableConcept(child, path+'/jurisdiction')
      else if (child.localName = 'status') then
        value.status := ParseCodeableConcept(child, path+'/status')
      else if (child.localName = 'dateRange') then
        value.dateRange := ParsePeriod(child, path+'/dateRange')
      else if (child.localName = 'restoreDate') then
        value.restoreDateElement := ParseDateTime(child, path+'/restoreDate')
      else if Not ParseElementChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeMarketingStatus(xml : TXmlBuilder; name : String; value : TFhirMarketingStatus);
begin
  if (value = nil) then
    exit;
  composeElementAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeMarketingStatusChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeMarketingStatusChildren(xml : TXmlBuilder; value : TFhirMarketingStatus);
begin
  composeBackboneTypeChildren(xml, value);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(xml, 'country', value.country);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(xml, 'jurisdiction', value.jurisdiction);
  ComposeCodeableConcept(xml, 'status', value.status);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposePeriod(xml, 'dateRange', value.dateRange);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDateTime(xml, 'restoreDate', value.restoreDateElement);
end;

function TFHIRXmlParser.ParsePopulation(element : TMXmlElement; path : string) : TFhirPopulation;
var
  child : TMXmlElement;
begin
  result := TFhirPopulation.Create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParsePopulationChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParsePopulationChild(value : TFhirPopulation; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'ageRange') then
        value.age := ParseRange(child, path+'/ageRange')
      else if (child.localName = 'ageCodeableConcept') then
        value.age := ParseCodeableConcept(child, path+'/ageCodeableConcept')
      else if (child.localName = 'gender') then
        value.gender := ParseCodeableConcept(child, path+'/gender')
      else if (child.localName = 'race') then
        value.race := ParseCodeableConcept(child, path+'/race')
      else if (child.localName = 'physiologicalCondition') then
        value.physiologicalCondition := ParseCodeableConcept(child, path+'/physiologicalCondition')
      else if Not ParseElementChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposePopulation(xml : TXmlBuilder; name : String; value : TFhirPopulation);
begin
  if (value = nil) then
    exit;
  composeElementAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composePopulationChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposePopulationChildren(xml : TXmlBuilder; value : TFhirPopulation);
begin
  composeBackboneTypeChildren(xml, value);
  if (SummaryOption in [soFull, soSummary, soData]) and (value.age is TFhirRange) {6} then
    ComposeRange(xml, 'ageRange', TFhirRange(value.age))
  else if (SummaryOption in [soFull, soSummary, soData]) and (value.age is TFhirCodeableConcept) {6} then
    ComposeCodeableConcept(xml, 'ageCodeableConcept', TFhirCodeableConcept(value.age));
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(xml, 'gender', value.gender);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(xml, 'race', value.race);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(xml, 'physiologicalCondition', value.physiologicalCondition);
end;

function TFHIRXmlParser.ParseProductShelfLife(element : TMXmlElement; path : string) : TFhirProductShelfLife;
var
  child : TMXmlElement;
begin
  result := TFhirProductShelfLife.Create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseProductShelfLifeChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseProductShelfLifeChild(value : TFhirProductShelfLife; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'type') then
        value.type_ := ParseCodeableConcept(child, path+'/type')
      else if (child.localName = 'periodDuration') then
        value.period := ParseDuration(child, path+'/periodDuration')
      else if (child.localName = 'periodString') then
        value.period := ParseString(child, path+'/periodString')
      else if (child.localName = 'specialPrecautionsForStorage') then
        value.specialPrecautionsForStorageList.Add(ParseCodeableConcept(child, path+'/specialPrecautionsForStorage'))
      else if Not ParseElementChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeProductShelfLife(xml : TXmlBuilder; name : String; value : TFhirProductShelfLife);
begin
  if (value = nil) then
    exit;
  composeElementAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeProductShelfLifeChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeProductShelfLifeChildren(xml : TXmlBuilder; value : TFhirProductShelfLife);
var
  i : integer;
begin
  composeBackboneTypeChildren(xml, value);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(xml, 'type', value.type_);
  if (SummaryOption in [soFull, soSummary, soData]) and (value.period is TFhirDuration) {6} then
    ComposeDuration(xml, 'periodDuration', TFhirDuration(value.period))
  else if (SummaryOption in [soFull, soSummary, soData]) and (value.period is TFhirString) {6} then
    ComposeString(xml, 'periodString', TFhirString(value.period));
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.specialPrecautionsForStorageList.Count - 1 do
      ComposeCodeableConcept(xml, 'specialPrecautionsForStorage', value.specialPrecautionsForStorageList[i]);
end;

function TFHIRXmlParser.ParseTimingRepeat(element : TMXmlElement; path : string) : TFhirTimingRepeat;
var
  child : TMXmlElement;
begin
  result := TFhirTimingRepeat.Create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseTimingRepeatChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseTimingRepeatChild(value : TFhirTimingRepeat; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'boundsDuration') then
        value.bounds := ParseDuration(child, path+'/boundsDuration')
      else if (child.localName = 'boundsRange') then
        value.bounds := ParseRange(child, path+'/boundsRange')
      else if (child.localName = 'boundsPeriod') then
        value.bounds := ParsePeriod(child, path+'/boundsPeriod')
      else if (child.localName = 'count') then
        value.countElement := ParsePositiveInt(child, path+'/count')
      else if (child.localName = 'countMax') then
        value.countMaxElement := ParsePositiveInt(child, path+'/countMax')
      else if (child.localName = 'duration') then
        value.durationElement := ParseDecimal(child, path+'/duration')
      else if (child.localName = 'durationMax') then
        value.durationMaxElement := ParseDecimal(child, path+'/durationMax')
      else if (child.localName = 'durationUnit') then
        value.durationUnitElement := ParseEnum(CODES_TFhirUnitsOfTimeEnum, SYSTEMS_TFhirUnitsOfTimeEnum, child, path+'/durationUnit')
      else if (child.localName = 'frequency') then
        value.frequencyElement := ParsePositiveInt(child, path+'/frequency')
      else if (child.localName = 'frequencyMax') then
        value.frequencyMaxElement := ParsePositiveInt(child, path+'/frequencyMax')
      else if (child.localName = 'period') then
        value.periodElement := ParseDecimal(child, path+'/period')
      else if (child.localName = 'periodMax') then
        value.periodMaxElement := ParseDecimal(child, path+'/periodMax')
      else if (child.localName = 'periodUnit') then
        value.periodUnitElement := ParseEnum(CODES_TFhirUnitsOfTimeEnum, SYSTEMS_TFhirUnitsOfTimeEnum, child, path+'/periodUnit')
      else if (child.localName = 'dayOfWeek') then
        value.dayOfWeekList.Add(ParseEnum(CODES_TFhirDaysOfWeekEnum, SYSTEMS_TFhirDaysOfWeekEnum, child, path+'/dayOfWeek')){y.1}
      else if (child.localName = 'timeOfDay') then
        value.timeOfDayList.Add(ParseTime(child, path+'/timeOfDay'))
      else if (child.localName = 'when') then
        value.whenList.Add(ParseEnum(CODES_TFhirEventTimingEnum, SYSTEMS_TFhirEventTimingEnum, child, path+'/when')){y.1}
      else if (child.localName = 'offset') then
        value.offsetElement := ParseUnsignedInt(child, path+'/offset')
      else if Not ParseElementChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeTimingRepeat(xml : TXmlBuilder; name : String; value : TFhirTimingRepeat);
begin
  if (value = nil) then
    exit;
  composeElementAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeTimingRepeatChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeTimingRepeatChildren(xml : TXmlBuilder; value : TFhirTimingRepeat);
var
  i : integer;
begin
  composeElementChildren(xml, value);
  if (SummaryOption in [soFull, soSummary, soData]) and (value.bounds is TFhirDuration) {6} then
    ComposeDuration(xml, 'boundsDuration', TFhirDuration(value.bounds))
  else if (SummaryOption in [soFull, soSummary, soData]) and (value.bounds is TFhirRange) {6} then
    ComposeRange(xml, 'boundsRange', TFhirRange(value.bounds))
  else if (SummaryOption in [soFull, soSummary, soData]) and (value.bounds is TFhirPeriod) {6} then
    ComposePeriod(xml, 'boundsPeriod', TFhirPeriod(value.bounds));
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposePositiveInt(xml, 'count', value.countElement);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposePositiveInt(xml, 'countMax', value.countMaxElement);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDecimal(xml, 'duration', value.durationElement);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDecimal(xml, 'durationMax', value.durationMaxElement);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeEnum(xml, 'durationUnit', value.durationUnitElement, CODES_TFhirUnitsOfTimeEnum);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposePositiveInt(xml, 'frequency', value.frequencyElement);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposePositiveInt(xml, 'frequencyMax', value.frequencyMaxElement);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDecimal(xml, 'period', value.periodElement);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDecimal(xml, 'periodMax', value.periodMaxElement);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeEnum(xml, 'periodUnit', value.periodUnitElement, CODES_TFhirUnitsOfTimeEnum);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.dayOfWeekList.Count - 1 do
      ComposeEnum(xml, 'dayOfWeek', value.dayOfWeekList[i], CODES_TFhirDaysOfWeekEnum);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.timeOfDayList.Count - 1 do
      ComposeTime(xml, 'timeOfDay', value.timeOfDayList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.whenList.Count - 1 do
      ComposeEnum(xml, 'when', value.whenList[i], CODES_TFhirEventTimingEnum);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeUnsignedInt(xml, 'offset', value.offsetElement);
end;

function TFHIRXmlParser.ParseTiming(element : TMXmlElement; path : string) : TFhirTiming;
var
  child : TMXmlElement;
begin
  result := TFhirTiming.Create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseTimingChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseTimingChild(value : TFhirTiming; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'event') then
        value.eventList.Add(ParseDateTime(child, path+'/event'))
      else if (child.localName = 'repeat') then
        value.repeat_ := ParseTimingRepeat(child, path+'/repeat')
      else if (child.localName = 'code') then
        value.code := ParseCodeableConcept(child, path+'/code')
      else if Not ParseElementChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeTiming(xml : TXmlBuilder; name : String; value : TFhirTiming);
begin
  if (value = nil) then
    exit;
  composeElementAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeTimingChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeTimingChildren(xml : TXmlBuilder; value : TFhirTiming);
var
  i : integer;
begin
  composeBackboneTypeChildren(xml, value);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.eventList.Count - 1 do
      ComposeDateTime(xml, 'event', value.eventList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeTimingRepeat(xml, 'repeat', value.repeat_);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(xml, 'code', value.code);
end;



Procedure TFHIRXmlParser.ParseResourceAttributes(value : TFhirResource; path : string; element : TMXmlElement);
begin
  ParseBaseAttributes(value, path, element);
end;

Function TFHIRXmlParser.ParseResourceChild(value : TFhirResource; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
  if (child.localName = 'id') then
    value.idElement := ParseId(child, path+'/id')
  else if (child.localName = 'meta') then
    value.meta := ParseMeta(child, path+'/meta')
  else if (child.localName = 'implicitRules') then
    value.implicitRulesElement := ParseUri(child, path+'/implicitRules')
  else if (child.localName = 'language') then
    value.languageElement := ParseCode(child, path+'/language')
  else if not parseBaseChild(value, path, child) then
    result := false;
end;

Procedure TFHIRXmlComposer.ComposeResourceAttributes(xml : TXmlBuilder; value : TFhirResource);
begin
  ComposeBaseAttributes(xml, value);
end;

Procedure TFHIRXmlComposer.ComposeResourceChildren(xml : TXmlBuilder; value : TFhirResource);
begin
  composeBaseChildren(xml, value);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeId(xml, 'id', value.idElement);
  ComposeMeta(xml, 'meta', value.meta);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeUri(xml, 'implicitRules', value.implicitRulesElement);
  if (SummaryOption in [soFull, soData]) then
    ComposeCode(xml, 'language', value.languageElement);
end;

Procedure TFHIRXmlParser.ParseDomainResourceAttributes(value : TFhirDomainResource; path : string; element : TMXmlElement);
begin
  ParseResourceAttributes(value, path, element);
end;

Function TFHIRXmlParser.ParseDomainResourceChild(value : TFhirDomainResource; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
  if (child.localName = 'text') then
    value.text := ParseNarrative(child, path+'/text')
  else if (child.localName = 'contained') then
    value.containedList.Add(ParseInnerResource(child, path+'/contained'))
  else if (child.localName = 'extension') then
    value.extensionList.Add(ParseExtension(child, path+'/extension'))
  else if (child.localName = 'modifierExtension') then
    value.modifierExtensionList.Add(ParseExtension(child, path+'/modifierExtension'))
  else if not parseResourceChild(value, path, child) then
    result := false;
end;

Procedure TFHIRXmlComposer.ComposeDomainResourceAttributes(xml : TXmlBuilder; value : TFhirDomainResource);
begin
  ComposeResourceAttributes(xml, value);
end;

Procedure TFHIRXmlComposer.ComposeDomainResourceChildren(xml : TXmlBuilder; value : TFhirDomainResource);
var
  i : integer;
begin
  composeResourceChildren(xml, value);
  if (SummaryOption in [soFull, soData]) then
    ComposeNarrative(xml, 'text', value.text);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.containedList.Count - 1 do
      ComposeInnerResource(xml, 'contained', value, value.containedList[i]);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.extensionList.Count - 1 do
      ComposeExtension(xml, 'extension', value.extensionList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.modifierExtensionList.Count - 1 do
      ComposeExtension(xml, 'modifierExtension', value.modifierExtensionList[i]);
end;

Procedure TFHIRXmlParser.ParseCanonicalResourceAttributes(value : TFhirCanonicalResource; path : string; element : TMXmlElement);
begin
  ParseDomainResourceAttributes(value, path, element);
end;

Function TFHIRXmlParser.ParseCanonicalResourceChild(value : TFhirCanonicalResource; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
  if not parseDomainResourceChild(value, path, child) then
    result := false;
end;

Procedure TFHIRXmlComposer.ComposeCanonicalResourceAttributes(xml : TXmlBuilder; value : TFhirCanonicalResource);
begin
  ComposeDomainResourceAttributes(xml, value);
end;

Procedure TFHIRXmlComposer.ComposeCanonicalResourceChildren(xml : TXmlBuilder; value : TFhirCanonicalResource);
begin
  composeDomainResourceChildren(xml, value);
end;

Procedure TFHIRXmlParser.ParseMetadataResourceAttributes(value : TFhirMetadataResource; path : string; element : TMXmlElement);
begin
  ParseCanonicalResourceAttributes(value, path, element);
end;

Function TFHIRXmlParser.ParseMetadataResourceChild(value : TFhirMetadataResource; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
  if not parseCanonicalResourceChild(value, path, child) then
    result := false;
end;

Procedure TFHIRXmlComposer.ComposeMetadataResourceAttributes(xml : TXmlBuilder; value : TFhirMetadataResource);
begin
  ComposeCanonicalResourceAttributes(xml, value);
end;

Procedure TFHIRXmlComposer.ComposeMetadataResourceChildren(xml : TXmlBuilder; value : TFhirMetadataResource);
begin
  composeCanonicalResourceChildren(xml, value);
end;



{$IFDEF FHIR_ACCOUNT}
function TFHIRXmlParser.ParseAccountCoverage(element : TMXmlElement; path : string) : TFhirAccountCoverage;
var
  child : TMXmlElement;
begin
  result := TFhirAccountCoverage.Create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseAccountCoverageChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseAccountCoverageChild(value : TFhirAccountCoverage; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'coverage') then
        value.coverage := ParseReference(child, path+'/coverage')
      else if (child.localName = 'priority') then
        value.priorityElement := ParsePositiveInt(child, path+'/priority')
      else if Not ParseBackboneElementChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeAccountCoverage(xml : TXmlBuilder; name : String; value : TFhirAccountCoverage);
begin
  if (value = nil) then
    exit;
  composeElementAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeAccountCoverageChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeAccountCoverageChildren(xml : TXmlBuilder; value : TFhirAccountCoverage);
begin
  composeBackboneElementChildren(xml, value);
  ComposeReference(xml, 'coverage', value.coverage);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposePositiveInt(xml, 'priority', value.priorityElement);
end;

function TFHIRXmlParser.ParseAccountGuarantor(element : TMXmlElement; path : string) : TFhirAccountGuarantor;
var
  child : TMXmlElement;
begin
  result := TFhirAccountGuarantor.Create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseAccountGuarantorChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseAccountGuarantorChild(value : TFhirAccountGuarantor; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'party') then
        value.party := ParseReference(child, path+'/party')
      else if (child.localName = 'onHold') then
        value.onHoldElement := ParseBoolean(child, path+'/onHold')
      else if (child.localName = 'period') then
        value.period := ParsePeriod(child, path+'/period')
      else if Not ParseBackboneElementChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeAccountGuarantor(xml : TXmlBuilder; name : String; value : TFhirAccountGuarantor);
begin
  if (value = nil) then
    exit;
  composeElementAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeAccountGuarantorChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeAccountGuarantorChildren(xml : TXmlBuilder; value : TFhirAccountGuarantor);
begin
  composeBackboneElementChildren(xml, value);
  ComposeReference(xml, 'party', value.party);
  if (SummaryOption in [soFull, soData]) then
    ComposeBoolean(xml, 'onHold', value.onHoldElement);
  if (SummaryOption in [soFull, soData]) then
    ComposePeriod(xml, 'period', value.period);
end;

function TFHIRXmlParser.ParseAccountRelatedAccount(element : TMXmlElement; path : string) : TFhirAccountRelatedAccount;
var
  child : TMXmlElement;
begin
  result := TFhirAccountRelatedAccount.Create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseAccountRelatedAccountChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseAccountRelatedAccountChild(value : TFhirAccountRelatedAccount; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'relationship') then
        value.relationship := ParseCodeableConcept(child, path+'/relationship')
      else if (child.localName = 'account') then
        value.account := ParseReference(child, path+'/account')
      else if Not ParseBackboneElementChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeAccountRelatedAccount(xml : TXmlBuilder; name : String; value : TFhirAccountRelatedAccount);
begin
  if (value = nil) then
    exit;
  composeElementAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeAccountRelatedAccountChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeAccountRelatedAccountChildren(xml : TXmlBuilder; value : TFhirAccountRelatedAccount);
begin
  composeBackboneElementChildren(xml, value);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(xml, 'relationship', value.relationship);
  ComposeReference(xml, 'account', value.account);
end;

function TFHIRXmlParser.ParseAccountBalance(element : TMXmlElement; path : string) : TFhirAccountBalance;
var
  child : TMXmlElement;
begin
  result := TFhirAccountBalance.Create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseAccountBalanceChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseAccountBalanceChild(value : TFhirAccountBalance; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'aggregate') then
        value.aggregate := ParseCodeableConcept(child, path+'/aggregate')
      else if (child.localName = 'term') then
        value.term := ParseCodeableConcept(child, path+'/term')
      else if (child.localName = 'estimate') then
        value.estimateElement := ParseBoolean(child, path+'/estimate')
      else if (child.localName = 'amount') then
        value.amount := ParseMoney(child, path+'/amount')
      else if Not ParseBackboneElementChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeAccountBalance(xml : TXmlBuilder; name : String; value : TFhirAccountBalance);
begin
  if (value = nil) then
    exit;
  composeElementAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeAccountBalanceChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeAccountBalanceChildren(xml : TXmlBuilder; value : TFhirAccountBalance);
begin
  composeBackboneElementChildren(xml, value);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(xml, 'aggregate', value.aggregate);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(xml, 'term', value.term);
  if (SummaryOption in [soFull, soData]) then
    ComposeBoolean(xml, 'estimate', value.estimateElement);
  ComposeMoney(xml, 'amount', value.amount);
end;

function TFHIRXmlParser.ParseAccount(element : TMXmlElement; path : string) : TFhirAccount;
var
  child : TMXmlElement;
begin
  result := TFhirAccount.Create;
  try
    parseDomainResourceAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseAccountChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseAccountChild(value : TFhirAccount; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'identifier') then
        value.identifierList.Add(ParseIdentifier(child, path+'/identifier'))
      else if (child.localName = 'status') then
        value.statusElement := ParseEnum(CODES_TFhirAccountStatusEnum, SYSTEMS_TFhirAccountStatusEnum, child, path+'/status')
      else if (child.localName = 'billingStatus') then
        value.billingStatus := ParseCodeableConcept(child, path+'/billingStatus')
      else if (child.localName = 'type') then
        value.type_ := ParseCodeableConcept(child, path+'/type')
      else if (child.localName = 'name') then
        value.nameElement := ParseString(child, path+'/name')
      else if (child.localName = 'subject') then
        value.subjectList.Add(ParseReference(child, path+'/subject'))
      else if (child.localName = 'servicePeriod') then
        value.servicePeriod := ParsePeriod(child, path+'/servicePeriod')
      else if (child.localName = 'coverage') then
        value.coverageList.Add(ParseAccountCoverage(child, path+'/coverage'))
      else if (child.localName = 'owner') then
        value.owner := ParseReference(child, path+'/owner')
      else if (child.localName = 'description') then
        value.descriptionElement := ParseString(child, path+'/description')
      else if (child.localName = 'guarantor') then
        value.guarantorList.Add(ParseAccountGuarantor(child, path+'/guarantor'))
      else if (child.localName = 'relatedAccount') then
        value.relatedAccountList.Add(ParseAccountRelatedAccount(child, path+'/relatedAccount'))
      else if (child.localName = 'currency') then
        value.currency := ParseCodeableConcept(child, path+'/currency')
      else if (child.localName = 'balance') then
        value.balanceList.Add(ParseAccountBalance(child, path+'/balance'))
      else if (child.localName = 'calculatedAt') then
        value.calculatedAtElement := ParseInstant(child, path+'/calculatedAt')
      else if Not ParseDomainResourceChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeAccount(xml : TXmlBuilder; name : String; value : TFhirAccount);
begin
  if (value = nil) then
    exit;
  composeDomainResourceAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeAccountChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeAccountChildren(xml : TXmlBuilder; value : TFhirAccount);
var
  i : integer;
begin
  composeDomainResourceChildren(xml, value);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.identifierList.Count - 1 do
      ComposeIdentifier(xml, 'identifier', value.identifierList[i]);
  ComposeEnum(xml, 'status', value.statusElement, CODES_TFhirAccountStatusEnum);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(xml, 'billingStatus', value.billingStatus);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(xml, 'type', value.type_);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(xml, 'name', value.nameElement);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.subjectList.Count - 1 do
      ComposeReference(xml, 'subject', value.subjectList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposePeriod(xml, 'servicePeriod', value.servicePeriod);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.coverageList.Count - 1 do
      ComposeAccountCoverage(xml, 'coverage', value.coverageList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference(xml, 'owner', value.owner);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(xml, 'description', value.descriptionElement);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.guarantorList.Count - 1 do
      ComposeAccountGuarantor(xml, 'guarantor', value.guarantorList[i]);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.relatedAccountList.Count - 1 do
      ComposeAccountRelatedAccount(xml, 'relatedAccount', value.relatedAccountList[i]);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(xml, 'currency', value.currency);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.balanceList.Count - 1 do
      ComposeAccountBalance(xml, 'balance', value.balanceList[i]);
  if (SummaryOption in [soFull, soData]) then
    ComposeInstant(xml, 'calculatedAt', value.calculatedAtElement);
end;

{$ENDIF FHIR_ACCOUNT}
{$IFDEF FHIR_ACTIVITYDEFINITION}
function TFHIRXmlParser.ParseActivityDefinitionParticipant(element : TMXmlElement; path : string) : TFhirActivityDefinitionParticipant;
var
  child : TMXmlElement;
begin
  result := TFhirActivityDefinitionParticipant.Create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseActivityDefinitionParticipantChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseActivityDefinitionParticipantChild(value : TFhirActivityDefinitionParticipant; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'type') then
        value.type_Element := ParseEnum(CODES_TFhirActionParticipantTypeEnum, SYSTEMS_TFhirActionParticipantTypeEnum, child, path+'/type')
      else if (child.localName = 'typeCanonical') then
        value.typeCanonicalElement := ParseCanonical(child, path+'/typeCanonical')
      else if (child.localName = 'typeReference') then
        value.typeReference := ParseReference(child, path+'/typeReference')
      else if (child.localName = 'role') then
        value.role := ParseCodeableConcept(child, path+'/role')
      else if (child.localName = 'function') then
        value.function_ := ParseCodeableConcept(child, path+'/function')
      else if Not ParseBackboneElementChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeActivityDefinitionParticipant(xml : TXmlBuilder; name : String; value : TFhirActivityDefinitionParticipant);
begin
  if (value = nil) then
    exit;
  composeElementAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeActivityDefinitionParticipantChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeActivityDefinitionParticipantChildren(xml : TXmlBuilder; value : TFhirActivityDefinitionParticipant);
begin
  composeBackboneElementChildren(xml, value);
  if (SummaryOption in [soFull, soData]) then
    ComposeEnum(xml, 'type', value.type_Element, CODES_TFhirActionParticipantTypeEnum);
  if (SummaryOption in [soFull, soData]) then
    ComposeCanonical(xml, 'typeCanonical', value.typeCanonicalElement);
  if (SummaryOption in [soFull, soData]) then
    ComposeReference(xml, 'typeReference', value.typeReference);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(xml, 'role', value.role);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(xml, 'function', value.function_);
end;

function TFHIRXmlParser.ParseActivityDefinitionDynamicValue(element : TMXmlElement; path : string) : TFhirActivityDefinitionDynamicValue;
var
  child : TMXmlElement;
begin
  result := TFhirActivityDefinitionDynamicValue.Create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseActivityDefinitionDynamicValueChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseActivityDefinitionDynamicValueChild(value : TFhirActivityDefinitionDynamicValue; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'path') then
        value.pathElement := ParseString(child, path+'/path')
      else if (child.localName = 'expression') then
        value.expression := ParseExpression(child, path+'/expression')
      else if Not ParseBackboneElementChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeActivityDefinitionDynamicValue(xml : TXmlBuilder; name : String; value : TFhirActivityDefinitionDynamicValue);
begin
  if (value = nil) then
    exit;
  composeElementAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeActivityDefinitionDynamicValueChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeActivityDefinitionDynamicValueChildren(xml : TXmlBuilder; value : TFhirActivityDefinitionDynamicValue);
begin
  composeBackboneElementChildren(xml, value);
  ComposeString(xml, 'path', value.pathElement);
  ComposeExpression(xml, 'expression', value.expression);
end;

function TFHIRXmlParser.ParseActivityDefinition(element : TMXmlElement; path : string) : TFhirActivityDefinition;
var
  child : TMXmlElement;
begin
  result := TFhirActivityDefinition.Create;
  try
    parseMetadataResourceAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseActivityDefinitionChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseActivityDefinitionChild(value : TFhirActivityDefinition; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'url') then
        value.urlElement := ParseUri(child, path+'/url')
      else if (child.localName = 'identifier') then
        value.identifierList.Add(ParseIdentifier(child, path+'/identifier'))
      else if (child.localName = 'version') then
        value.versionElement := ParseString(child, path+'/version')
      else if (child.localName = 'name') then
        value.nameElement := ParseString(child, path+'/name')
      else if (child.localName = 'title') then
        value.titleElement := ParseString(child, path+'/title')
      else if (child.localName = 'subtitle') then
        value.subtitleElement := ParseString(child, path+'/subtitle')
      else if (child.localName = 'status') then
        value.statusElement := ParseEnum(CODES_TFhirPublicationStatusEnum, SYSTEMS_TFhirPublicationStatusEnum, child, path+'/status')
      else if (child.localName = 'experimental') then
        value.experimentalElement := ParseBoolean(child, path+'/experimental')
      else if (child.localName = 'subjectCodeableConcept') then
        value.subject := ParseCodeableConcept(child, path+'/subjectCodeableConcept')
      else if (child.localName = 'subjectReference') then
        value.subject := ParseReference(child, path+'/subjectReference')
      else if (child.localName = 'subjectCanonical') then
        value.subject := ParseCanonical(child, path+'/subjectCanonical')
      else if (child.localName = 'date') then
        value.dateElement := ParseDateTime(child, path+'/date')
      else if (child.localName = 'publisher') then
        value.publisherElement := ParseString(child, path+'/publisher')
      else if (child.localName = 'contact') then
        value.contactList.Add(ParseContactDetail(child, path+'/contact'))
      else if (child.localName = 'description') then
        value.descriptionElement := ParseMarkdown(child, path+'/description')
      else if (child.localName = 'useContext') then
        value.useContextList.Add(ParseUsageContext(child, path+'/useContext'))
      else if (child.localName = 'jurisdiction') then
        value.jurisdictionList.Add(ParseCodeableConcept(child, path+'/jurisdiction'))
      else if (child.localName = 'purpose') then
        value.purposeElement := ParseMarkdown(child, path+'/purpose')
      else if (child.localName = 'usage') then
        value.usageElement := ParseString(child, path+'/usage')
      else if (child.localName = 'copyright') then
        value.copyrightElement := ParseMarkdown(child, path+'/copyright')
      else if (child.localName = 'approvalDate') then
        value.approvalDateElement := ParseDate(child, path+'/approvalDate')
      else if (child.localName = 'lastReviewDate') then
        value.lastReviewDateElement := ParseDate(child, path+'/lastReviewDate')
      else if (child.localName = 'effectivePeriod') then
        value.effectivePeriod := ParsePeriod(child, path+'/effectivePeriod')
      else if (child.localName = 'topic') then
        value.topicList.Add(ParseCodeableConcept(child, path+'/topic'))
      else if (child.localName = 'author') then
        value.authorList.Add(ParseContactDetail(child, path+'/author'))
      else if (child.localName = 'editor') then
        value.editorList.Add(ParseContactDetail(child, path+'/editor'))
      else if (child.localName = 'reviewer') then
        value.reviewerList.Add(ParseContactDetail(child, path+'/reviewer'))
      else if (child.localName = 'endorser') then
        value.endorserList.Add(ParseContactDetail(child, path+'/endorser'))
      else if (child.localName = 'relatedArtifact') then
        value.relatedArtifactList.Add(ParseRelatedArtifact(child, path+'/relatedArtifact'))
      else if (child.localName = 'library') then
        value.library_List.Add(ParseCanonical(child, path+'/library'))
      else if (child.localName = 'kind') then
        value.kindElement := ParseEnum(CODES_TFhirRequestResourceTypesEnum, SYSTEMS_TFhirRequestResourceTypesEnum, child, path+'/kind')
      else if (child.localName = 'profile') then
        value.profileElement := ParseCanonical(child, path+'/profile')
      else if (child.localName = 'code') then
        value.code := ParseCodeableConcept(child, path+'/code')
      else if (child.localName = 'intent') then
        value.intentElement := ParseEnum(CODES_TFhirRequestIntentEnum, SYSTEMS_TFhirRequestIntentEnum, child, path+'/intent')
      else if (child.localName = 'priority') then
        value.priorityElement := ParseEnum(CODES_TFhirRequestPriorityEnum, SYSTEMS_TFhirRequestPriorityEnum, child, path+'/priority')
      else if (child.localName = 'doNotPerform') then
        value.doNotPerformElement := ParseBoolean(child, path+'/doNotPerform')
      else if (child.localName = 'timingTiming') then
        value.timing := ParseTiming(child, path+'/timingTiming')
      else if (child.localName = 'timingAge') then
        value.timing := ParseAge(child, path+'/timingAge')
      else if (child.localName = 'timingRange') then
        value.timing := ParseRange(child, path+'/timingRange')
      else if (child.localName = 'timingDuration') then
        value.timing := ParseDuration(child, path+'/timingDuration')
      else if (child.localName = 'asNeededCodeableConcept') then
        value.asNeeded := ParseCodeableConcept(child, path+'/asNeededCodeableConcept')
      else if (child.localName = 'asNeededBoolean') then
        value.asNeeded := ParseBoolean(child, path+'/asNeededBoolean')
      else if (child.localName = 'location') then
        value.location := ParseCodeableReference(child, path+'/location')
      else if (child.localName = 'participant') then
        value.participantList.Add(ParseActivityDefinitionParticipant(child, path+'/participant'))
      else if (child.localName = 'productReference') then
        value.product := ParseReference(child, path+'/productReference')
      else if (child.localName = 'productCodeableConcept') then
        value.product := ParseCodeableConcept(child, path+'/productCodeableConcept')
      else if (child.localName = 'quantity') then
        value.quantity := ParseQuantity(child, path+'/quantity')
      else if (child.localName = 'dosage') then
        value.dosageList.Add(ParseDosage(child, path+'/dosage'))
      else if (child.localName = 'bodySite') then
        value.bodySiteList.Add(ParseCodeableConcept(child, path+'/bodySite'))
      else if (child.localName = 'specimenRequirement') then
        value.specimenRequirementList.Add(ParseCanonical(child, path+'/specimenRequirement'))
      else if (child.localName = 'observationRequirement') then
        value.observationRequirementList.Add(ParseCanonical(child, path+'/observationRequirement'))
      else if (child.localName = 'observationResultRequirement') then
        value.observationResultRequirementList.Add(ParseCanonical(child, path+'/observationResultRequirement'))
      else if (child.localName = 'transform') then
        value.transformElement := ParseCanonical(child, path+'/transform')
      else if (child.localName = 'dynamicValue') then
        value.dynamicValueList.Add(ParseActivityDefinitionDynamicValue(child, path+'/dynamicValue'))
      else if Not ParseMetadataResourceChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeActivityDefinition(xml : TXmlBuilder; name : String; value : TFhirActivityDefinition);
begin
  if (value = nil) then
    exit;
  composeMetadataResourceAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeActivityDefinitionChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeActivityDefinitionChildren(xml : TXmlBuilder; value : TFhirActivityDefinition);
var
  i : integer;
begin
  composeMetadataResourceChildren(xml, value);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeUri(xml, 'url', value.urlElement);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.identifierList.Count - 1 do
      ComposeIdentifier(xml, 'identifier', value.identifierList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(xml, 'version', value.versionElement);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(xml, 'name', value.nameElement);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(xml, 'title', value.titleElement);
  if (SummaryOption in [soFull, soData]) then
    ComposeString(xml, 'subtitle', value.subtitleElement);
  ComposeEnum(xml, 'status', value.statusElement, CODES_TFhirPublicationStatusEnum);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeBoolean(xml, 'experimental', value.experimentalElement);
  if (SummaryOption in [soFull, soData]) and (value.subject is TFhirCodeableConcept) {6} then
    ComposeCodeableConcept(xml, 'subjectCodeableConcept', TFhirCodeableConcept(value.subject))
  else if (SummaryOption in [soFull, soData]) and (value.subject is TFhirReference) {2} then
    ComposeReference(xml, 'subjectReference', TFhirReference(value.subject))
  else if (SummaryOption in [soFull, soData]) and (value.subject is TFhirCanonical) {6} then
    ComposeCanonical(xml, 'subjectCanonical', TFhirCanonical(value.subject));
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDateTime(xml, 'date', value.dateElement);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(xml, 'publisher', value.publisherElement);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.contactList.Count - 1 do
      ComposeContactDetail(xml, 'contact', value.contactList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeMarkdown(xml, 'description', value.descriptionElement);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.useContextList.Count - 1 do
      ComposeUsageContext(xml, 'useContext', value.useContextList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.jurisdictionList.Count - 1 do
      ComposeCodeableConcept(xml, 'jurisdiction', value.jurisdictionList[i]);
  if (SummaryOption in [soFull, soData]) then
    ComposeMarkdown(xml, 'purpose', value.purposeElement);
  if (SummaryOption in [soFull, soData]) then
    ComposeString(xml, 'usage', value.usageElement);
  if (SummaryOption in [soFull, soData]) then
    ComposeMarkdown(xml, 'copyright', value.copyrightElement);
  if (SummaryOption in [soFull, soData]) then
    ComposeDate(xml, 'approvalDate', value.approvalDateElement);
  if (SummaryOption in [soFull, soData]) then
    ComposeDate(xml, 'lastReviewDate', value.lastReviewDateElement);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposePeriod(xml, 'effectivePeriod', value.effectivePeriod);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.topicList.Count - 1 do
      ComposeCodeableConcept(xml, 'topic', value.topicList[i]);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.authorList.Count - 1 do
      ComposeContactDetail(xml, 'author', value.authorList[i]);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.editorList.Count - 1 do
      ComposeContactDetail(xml, 'editor', value.editorList[i]);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.reviewerList.Count - 1 do
      ComposeContactDetail(xml, 'reviewer', value.reviewerList[i]);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.endorserList.Count - 1 do
      ComposeContactDetail(xml, 'endorser', value.endorserList[i]);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.relatedArtifactList.Count - 1 do
      ComposeRelatedArtifact(xml, 'relatedArtifact', value.relatedArtifactList[i]);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.library_List.Count - 1 do
      ComposeCanonical(xml, 'library', value.library_List[i]);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeEnum(xml, 'kind', value.kindElement, CODES_TFhirRequestResourceTypesEnum);
  if (SummaryOption in [soFull, soData]) then
    ComposeCanonical(xml, 'profile', value.profileElement);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(xml, 'code', value.code);
  if (SummaryOption in [soFull, soData]) then
    ComposeEnum(xml, 'intent', value.intentElement, CODES_TFhirRequestIntentEnum);
  if (SummaryOption in [soFull, soData]) then
    ComposeEnum(xml, 'priority', value.priorityElement, CODES_TFhirRequestPriorityEnum);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeBoolean(xml, 'doNotPerform', value.doNotPerformElement);
  if (SummaryOption in [soFull, soData]) and (value.timing is TFhirTiming) {6} then
    ComposeTiming(xml, 'timingTiming', TFhirTiming(value.timing))
  else if (SummaryOption in [soFull, soData]) and (value.timing is TFhirAge) {6} then
    ComposeAge(xml, 'timingAge', TFhirAge(value.timing))
  else if (SummaryOption in [soFull, soData]) and (value.timing is TFhirRange) {6} then
    ComposeRange(xml, 'timingRange', TFhirRange(value.timing))
  else if (SummaryOption in [soFull, soData]) and (value.timing is TFhirDuration) {6} then
    ComposeDuration(xml, 'timingDuration', TFhirDuration(value.timing));
  if (SummaryOption in [soFull, soSummary, soData]) and (value.asNeeded is TFhirCodeableConcept) {6} then
    ComposeCodeableConcept(xml, 'asNeededCodeableConcept', TFhirCodeableConcept(value.asNeeded))
  else if (SummaryOption in [soFull, soSummary, soData]) and (value.asNeeded is TFhirBoolean) {6} then
    ComposeBoolean(xml, 'asNeededBoolean', TFhirBoolean(value.asNeeded));
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableReference(xml, 'location', value.location);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.participantList.Count - 1 do
      ComposeActivityDefinitionParticipant(xml, 'participant', value.participantList[i]);
  if (SummaryOption in [soFull, soData]) and (value.product is TFhirReference) {2} then
    ComposeReference(xml, 'productReference', TFhirReference(value.product))
  else if (SummaryOption in [soFull, soData]) and (value.product is TFhirCodeableConcept) {6} then
    ComposeCodeableConcept(xml, 'productCodeableConcept', TFhirCodeableConcept(value.product));
  if (SummaryOption in [soFull, soData]) then
    ComposeQuantity(xml, 'quantity', value.quantity);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.dosageList.Count - 1 do
      ComposeDosage(xml, 'dosage', value.dosageList[i]);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.bodySiteList.Count - 1 do
      ComposeCodeableConcept(xml, 'bodySite', value.bodySiteList[i]);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.specimenRequirementList.Count - 1 do
      ComposeCanonical(xml, 'specimenRequirement', value.specimenRequirementList[i]);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.observationRequirementList.Count - 1 do
      ComposeCanonical(xml, 'observationRequirement', value.observationRequirementList[i]);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.observationResultRequirementList.Count - 1 do
      ComposeCanonical(xml, 'observationResultRequirement', value.observationResultRequirementList[i]);
  if (SummaryOption in [soFull, soData]) then
    ComposeCanonical(xml, 'transform', value.transformElement);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.dynamicValueList.Count - 1 do
      ComposeActivityDefinitionDynamicValue(xml, 'dynamicValue', value.dynamicValueList[i]);
end;

{$ENDIF FHIR_ACTIVITYDEFINITION}
{$IFDEF FHIR_ACTORDEFINITION}
function TFHIRXmlParser.ParseActorDefinition(element : TMXmlElement; path : string) : TFhirActorDefinition;
var
  child : TMXmlElement;
begin
  result := TFhirActorDefinition.Create;
  try
    parseCanonicalResourceAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseActorDefinitionChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseActorDefinitionChild(value : TFhirActorDefinition; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'url') then
        value.urlElement := ParseUri(child, path+'/url')
      else if (child.localName = 'identifier') then
        value.identifierList.Add(ParseIdentifier(child, path+'/identifier'))
      else if (child.localName = 'version') then
        value.versionElement := ParseString(child, path+'/version')
      else if (child.localName = 'name') then
        value.nameElement := ParseString(child, path+'/name')
      else if (child.localName = 'title') then
        value.titleElement := ParseString(child, path+'/title')
      else if (child.localName = 'status') then
        value.statusElement := ParseEnum(CODES_TFhirPublicationStatusEnum, SYSTEMS_TFhirPublicationStatusEnum, child, path+'/status')
      else if (child.localName = 'experimental') then
        value.experimentalElement := ParseBoolean(child, path+'/experimental')
      else if (child.localName = 'date') then
        value.dateElement := ParseDateTime(child, path+'/date')
      else if (child.localName = 'publisher') then
        value.publisherElement := ParseString(child, path+'/publisher')
      else if (child.localName = 'contact') then
        value.contactList.Add(ParseContactDetail(child, path+'/contact'))
      else if (child.localName = 'description') then
        value.descriptionElement := ParseMarkdown(child, path+'/description')
      else if (child.localName = 'useContext') then
        value.useContextList.Add(ParseUsageContext(child, path+'/useContext'))
      else if (child.localName = 'jurisdiction') then
        value.jurisdictionList.Add(ParseCodeableConcept(child, path+'/jurisdiction'))
      else if (child.localName = 'purpose') then
        value.purposeElement := ParseMarkdown(child, path+'/purpose')
      else if (child.localName = 'copyright') then
        value.copyrightElement := ParseMarkdown(child, path+'/copyright')
      else if (child.localName = 'copyrightLabel') then
        value.copyrightLabelElement := ParseString(child, path+'/copyrightLabel')
      else if (child.localName = 'type') then
        value.type_Element := ParseEnum(CODES_TFhirExampleScenarioActorTypeEnum, SYSTEMS_TFhirExampleScenarioActorTypeEnum, child, path+'/type')
      else if (child.localName = 'documentation') then
        value.documentationElement := ParseMarkdown(child, path+'/documentation')
      else if (child.localName = 'reference') then
        value.referenceList.Add(ParseUrl(child, path+'/reference'))
      else if (child.localName = 'capabilities') then
        value.capabilitiesElement := ParseCanonical(child, path+'/capabilities')
      else if (child.localName = 'derivedFrom') then
        value.derivedFromList.Add(ParseCanonical(child, path+'/derivedFrom'))
      else if Not ParseCanonicalResourceChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeActorDefinition(xml : TXmlBuilder; name : String; value : TFhirActorDefinition);
begin
  if (value = nil) then
    exit;
  composeCanonicalResourceAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeActorDefinitionChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeActorDefinitionChildren(xml : TXmlBuilder; value : TFhirActorDefinition);
var
  i : integer;
begin
  composeCanonicalResourceChildren(xml, value);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeUri(xml, 'url', value.urlElement);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.identifierList.Count - 1 do
      ComposeIdentifier(xml, 'identifier', value.identifierList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(xml, 'version', value.versionElement);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(xml, 'name', value.nameElement);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(xml, 'title', value.titleElement);
  ComposeEnum(xml, 'status', value.statusElement, CODES_TFhirPublicationStatusEnum);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeBoolean(xml, 'experimental', value.experimentalElement);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDateTime(xml, 'date', value.dateElement);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(xml, 'publisher', value.publisherElement);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.contactList.Count - 1 do
      ComposeContactDetail(xml, 'contact', value.contactList[i]);
  if (SummaryOption in [soFull, soData]) then
    ComposeMarkdown(xml, 'description', value.descriptionElement);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.useContextList.Count - 1 do
      ComposeUsageContext(xml, 'useContext', value.useContextList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.jurisdictionList.Count - 1 do
      ComposeCodeableConcept(xml, 'jurisdiction', value.jurisdictionList[i]);
  if (SummaryOption in [soFull, soData]) then
    ComposeMarkdown(xml, 'purpose', value.purposeElement);
  if (SummaryOption in [soFull, soData]) then
    ComposeMarkdown(xml, 'copyright', value.copyrightElement);
  if (SummaryOption in [soFull, soData]) then
    ComposeString(xml, 'copyrightLabel', value.copyrightLabelElement);
  ComposeEnum(xml, 'type', value.type_Element, CODES_TFhirExampleScenarioActorTypeEnum);
  if (SummaryOption in [soFull, soData]) then
    ComposeMarkdown(xml, 'documentation', value.documentationElement);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.referenceList.Count - 1 do
      ComposeUrl(xml, 'reference', value.referenceList[i]);
  if (SummaryOption in [soFull, soData]) then
    ComposeCanonical(xml, 'capabilities', value.capabilitiesElement);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.derivedFromList.Count - 1 do
      ComposeCanonical(xml, 'derivedFrom', value.derivedFromList[i]);
end;

{$ENDIF FHIR_ACTORDEFINITION}
{$IFDEF FHIR_ADMINISTRABLEPRODUCTDEFINITION}
function TFHIRXmlParser.ParseAdministrableProductDefinitionProperty(element : TMXmlElement; path : string) : TFhirAdministrableProductDefinitionProperty;
var
  child : TMXmlElement;
begin
  result := TFhirAdministrableProductDefinitionProperty.Create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseAdministrableProductDefinitionPropertyChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseAdministrableProductDefinitionPropertyChild(value : TFhirAdministrableProductDefinitionProperty; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'type') then
        value.type_ := ParseCodeableConcept(child, path+'/type')
      else if (child.localName = 'valueCodeableConcept') then
        value.value := ParseCodeableConcept(child, path+'/valueCodeableConcept')
      else if (child.localName = 'valueQuantity') then
        value.value := ParseQuantity(child, path+'/valueQuantity')
      else if (child.localName = 'valueAttachment') then
        value.value := ParseAttachment(child, path+'/valueAttachment')
      else if (child.localName = 'valueDate') then
        value.value := ParseDate(child, path+'/valueDate')
      else if (child.localName = 'valueBoolean') then
        value.value := ParseBoolean(child, path+'/valueBoolean')
      else if (child.localName = 'status') then
        value.status := ParseCodeableConcept(child, path+'/status')
      else if Not ParseBackboneElementChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeAdministrableProductDefinitionProperty(xml : TXmlBuilder; name : String; value : TFhirAdministrableProductDefinitionProperty);
begin
  if (value = nil) then
    exit;
  composeElementAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeAdministrableProductDefinitionPropertyChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeAdministrableProductDefinitionPropertyChildren(xml : TXmlBuilder; value : TFhirAdministrableProductDefinitionProperty);
begin
  composeBackboneElementChildren(xml, value);
  ComposeCodeableConcept(xml, 'type', value.type_);
  if (SummaryOption in [soFull, soSummary, soData]) and (value.value is TFhirCodeableConcept) {6} then
    ComposeCodeableConcept(xml, 'valueCodeableConcept', TFhirCodeableConcept(value.value))
  else if (SummaryOption in [soFull, soSummary, soData]) and (value.value is TFhirQuantity) {6} then
    ComposeQuantity(xml, 'valueQuantity', TFhirQuantity(value.value))
  else if (SummaryOption in [soFull, soSummary, soData]) and (value.value is TFhirAttachment) {6} then
    ComposeAttachment(xml, 'valueAttachment', TFhirAttachment(value.value))
  else if (SummaryOption in [soFull, soSummary, soData]) and (value.value is TFhirDate) {6} then
    ComposeDate(xml, 'valueDate', TFhirDate(value.value))
  else if (SummaryOption in [soFull, soSummary, soData]) and (value.value is TFhirBoolean) {6} then
    ComposeBoolean(xml, 'valueBoolean', TFhirBoolean(value.value));
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(xml, 'status', value.status);
end;

function TFHIRXmlParser.ParseAdministrableProductDefinitionRouteOfAdministration(element : TMXmlElement; path : string) : TFhirAdministrableProductDefinitionRouteOfAdministration;
var
  child : TMXmlElement;
begin
  result := TFhirAdministrableProductDefinitionRouteOfAdministration.Create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseAdministrableProductDefinitionRouteOfAdministrationChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseAdministrableProductDefinitionRouteOfAdministrationChild(value : TFhirAdministrableProductDefinitionRouteOfAdministration; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'code') then
        value.code := ParseCodeableConcept(child, path+'/code')
      else if (child.localName = 'firstDose') then
        value.firstDose := ParseQuantity(child, path+'/firstDose')
      else if (child.localName = 'maxSingleDose') then
        value.maxSingleDose := ParseQuantity(child, path+'/maxSingleDose')
      else if (child.localName = 'maxDosePerDay') then
        value.maxDosePerDay := ParseQuantity(child, path+'/maxDosePerDay')
      else if (child.localName = 'maxDosePerTreatmentPeriod') then
        value.maxDosePerTreatmentPeriod := ParseRatio(child, path+'/maxDosePerTreatmentPeriod')
      else if (child.localName = 'maxTreatmentPeriod') then
        value.maxTreatmentPeriod := ParseDuration(child, path+'/maxTreatmentPeriod')
      else if (child.localName = 'targetSpecies') then
        value.targetSpeciesList.Add(ParseAdministrableProductDefinitionRouteOfAdministrationTargetSpecies(child, path+'/targetSpecies'))
      else if Not ParseBackboneElementChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeAdministrableProductDefinitionRouteOfAdministration(xml : TXmlBuilder; name : String; value : TFhirAdministrableProductDefinitionRouteOfAdministration);
begin
  if (value = nil) then
    exit;
  composeElementAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeAdministrableProductDefinitionRouteOfAdministrationChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeAdministrableProductDefinitionRouteOfAdministrationChildren(xml : TXmlBuilder; value : TFhirAdministrableProductDefinitionRouteOfAdministration);
var
  i : integer;
begin
  composeBackboneElementChildren(xml, value);
  ComposeCodeableConcept(xml, 'code', value.code);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeQuantity(xml, 'firstDose', value.firstDose);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeQuantity(xml, 'maxSingleDose', value.maxSingleDose);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeQuantity(xml, 'maxDosePerDay', value.maxDosePerDay);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeRatio(xml, 'maxDosePerTreatmentPeriod', value.maxDosePerTreatmentPeriod);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDuration(xml, 'maxTreatmentPeriod', value.maxTreatmentPeriod);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.targetSpeciesList.Count - 1 do
      ComposeAdministrableProductDefinitionRouteOfAdministrationTargetSpecies(xml, 'targetSpecies', value.targetSpeciesList[i]);
end;

function TFHIRXmlParser.ParseAdministrableProductDefinitionRouteOfAdministrationTargetSpecies(element : TMXmlElement; path : string) : TFhirAdministrableProductDefinitionRouteOfAdministrationTargetSpecies;
var
  child : TMXmlElement;
begin
  result := TFhirAdministrableProductDefinitionRouteOfAdministrationTargetSpecies.Create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseAdministrableProductDefinitionRouteOfAdministrationTargetSpeciesChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseAdministrableProductDefinitionRouteOfAdministrationTargetSpeciesChild(value : TFhirAdministrableProductDefinitionRouteOfAdministrationTargetSpecies; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'code') then
        value.code := ParseCodeableConcept(child, path+'/code')
      else if (child.localName = 'withdrawalPeriod') then
        value.withdrawalPeriodList.Add(ParseAdministrableProductDefinitionRouteOfAdministrationTargetSpeciesWithdrawalPeriod(child, path+'/withdrawalPeriod'))
      else if Not ParseBackboneElementChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeAdministrableProductDefinitionRouteOfAdministrationTargetSpecies(xml : TXmlBuilder; name : String; value : TFhirAdministrableProductDefinitionRouteOfAdministrationTargetSpecies);
begin
  if (value = nil) then
    exit;
  composeElementAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeAdministrableProductDefinitionRouteOfAdministrationTargetSpeciesChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeAdministrableProductDefinitionRouteOfAdministrationTargetSpeciesChildren(xml : TXmlBuilder; value : TFhirAdministrableProductDefinitionRouteOfAdministrationTargetSpecies);
var
  i : integer;
begin
  composeBackboneElementChildren(xml, value);
  ComposeCodeableConcept(xml, 'code', value.code);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.withdrawalPeriodList.Count - 1 do
      ComposeAdministrableProductDefinitionRouteOfAdministrationTargetSpeciesWithdrawalPeriod(xml, 'withdrawalPeriod', value.withdrawalPeriodList[i]);
end;

function TFHIRXmlParser.ParseAdministrableProductDefinitionRouteOfAdministrationTargetSpeciesWithdrawalPeriod(element : TMXmlElement; path : string) : TFhirAdministrableProductDefinitionRouteOfAdministrationTargetSpeciesWithdrawalPeriod;
var
  child : TMXmlElement;
begin
  result := TFhirAdministrableProductDefinitionRouteOfAdministrationTargetSpeciesWithdrawalPeriod.Create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseAdministrableProductDefinitionRouteOfAdministrationTargetSpeciesWithdrawalPeriodChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseAdministrableProductDefinitionRouteOfAdministrationTargetSpeciesWithdrawalPeriodChild(value : TFhirAdministrableProductDefinitionRouteOfAdministrationTargetSpeciesWithdrawalPeriod; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'tissue') then
        value.tissue := ParseCodeableConcept(child, path+'/tissue')
      else if (child.localName = 'value') then
        value.value := ParseQuantity(child, path+'/value')
      else if (child.localName = 'supportingInformation') then
        value.supportingInformationElement := ParseString(child, path+'/supportingInformation')
      else if Not ParseBackboneElementChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeAdministrableProductDefinitionRouteOfAdministrationTargetSpeciesWithdrawalPeriod(xml : TXmlBuilder; name : String; value : TFhirAdministrableProductDefinitionRouteOfAdministrationTargetSpeciesWithdrawalPeriod);
begin
  if (value = nil) then
    exit;
  composeElementAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeAdministrableProductDefinitionRouteOfAdministrationTargetSpeciesWithdrawalPeriodChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeAdministrableProductDefinitionRouteOfAdministrationTargetSpeciesWithdrawalPeriodChildren(xml : TXmlBuilder; value : TFhirAdministrableProductDefinitionRouteOfAdministrationTargetSpeciesWithdrawalPeriod);
begin
  composeBackboneElementChildren(xml, value);
  ComposeCodeableConcept(xml, 'tissue', value.tissue);
  ComposeQuantity(xml, 'value', value.value);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(xml, 'supportingInformation', value.supportingInformationElement);
end;

function TFHIRXmlParser.ParseAdministrableProductDefinition(element : TMXmlElement; path : string) : TFhirAdministrableProductDefinition;
var
  child : TMXmlElement;
begin
  result := TFhirAdministrableProductDefinition.Create;
  try
    parseDomainResourceAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseAdministrableProductDefinitionChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseAdministrableProductDefinitionChild(value : TFhirAdministrableProductDefinition; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'identifier') then
        value.identifierList.Add(ParseIdentifier(child, path+'/identifier'))
      else if (child.localName = 'status') then
        value.statusElement := ParseEnum(CODES_TFhirPublicationStatusEnum, SYSTEMS_TFhirPublicationStatusEnum, child, path+'/status')
      else if (child.localName = 'formOf') then
        value.formOfList.Add(ParseReference(child, path+'/formOf'))
      else if (child.localName = 'administrableDoseForm') then
        value.administrableDoseForm := ParseCodeableConcept(child, path+'/administrableDoseForm')
      else if (child.localName = 'unitOfPresentation') then
        value.unitOfPresentation := ParseCodeableConcept(child, path+'/unitOfPresentation')
      else if (child.localName = 'producedFrom') then
        value.producedFromList.Add(ParseReference(child, path+'/producedFrom'))
      else if (child.localName = 'ingredient') then
        value.ingredientList.Add(ParseCodeableConcept(child, path+'/ingredient'))
      else if (child.localName = 'device') then
        value.device := ParseReference(child, path+'/device')
      else if (child.localName = 'property') then
        value.property_List.Add(ParseAdministrableProductDefinitionProperty(child, path+'/property'))
      else if (child.localName = 'routeOfAdministration') then
        value.routeOfAdministrationList.Add(ParseAdministrableProductDefinitionRouteOfAdministration(child, path+'/routeOfAdministration'))
      else if Not ParseDomainResourceChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeAdministrableProductDefinition(xml : TXmlBuilder; name : String; value : TFhirAdministrableProductDefinition);
begin
  if (value = nil) then
    exit;
  composeDomainResourceAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeAdministrableProductDefinitionChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeAdministrableProductDefinitionChildren(xml : TXmlBuilder; value : TFhirAdministrableProductDefinition);
var
  i : integer;
begin
  composeDomainResourceChildren(xml, value);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.identifierList.Count - 1 do
      ComposeIdentifier(xml, 'identifier', value.identifierList[i]);
  ComposeEnum(xml, 'status', value.statusElement, CODES_TFhirPublicationStatusEnum);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.formOfList.Count - 1 do
      ComposeReference(xml, 'formOf', value.formOfList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(xml, 'administrableDoseForm', value.administrableDoseForm);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(xml, 'unitOfPresentation', value.unitOfPresentation);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.producedFromList.Count - 1 do
      ComposeReference(xml, 'producedFrom', value.producedFromList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.ingredientList.Count - 1 do
      ComposeCodeableConcept(xml, 'ingredient', value.ingredientList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference(xml, 'device', value.device);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.property_List.Count - 1 do
      ComposeAdministrableProductDefinitionProperty(xml, 'property', value.property_List[i]);
  for i := 0 to value.routeOfAdministrationList.Count - 1 do
      ComposeAdministrableProductDefinitionRouteOfAdministration(xml, 'routeOfAdministration', value.routeOfAdministrationList[i]);
end;

{$ENDIF FHIR_ADMINISTRABLEPRODUCTDEFINITION}
{$IFDEF FHIR_ADVERSEEVENT}
function TFHIRXmlParser.ParseAdverseEventParticipant(element : TMXmlElement; path : string) : TFhirAdverseEventParticipant;
var
  child : TMXmlElement;
begin
  result := TFhirAdverseEventParticipant.Create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseAdverseEventParticipantChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseAdverseEventParticipantChild(value : TFhirAdverseEventParticipant; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'function') then
        value.function_ := ParseCodeableConcept(child, path+'/function')
      else if (child.localName = 'actor') then
        value.actor := ParseReference(child, path+'/actor')
      else if Not ParseBackboneElementChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeAdverseEventParticipant(xml : TXmlBuilder; name : String; value : TFhirAdverseEventParticipant);
begin
  if (value = nil) then
    exit;
  composeElementAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeAdverseEventParticipantChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeAdverseEventParticipantChildren(xml : TXmlBuilder; value : TFhirAdverseEventParticipant);
begin
  composeBackboneElementChildren(xml, value);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(xml, 'function', value.function_);
  ComposeReference(xml, 'actor', value.actor);
end;

function TFHIRXmlParser.ParseAdverseEventSuspectEntity(element : TMXmlElement; path : string) : TFhirAdverseEventSuspectEntity;
var
  child : TMXmlElement;
begin
  result := TFhirAdverseEventSuspectEntity.Create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseAdverseEventSuspectEntityChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseAdverseEventSuspectEntityChild(value : TFhirAdverseEventSuspectEntity; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'instanceCodeableConcept') then
        value.instance := ParseCodeableConcept(child, path+'/instanceCodeableConcept')
      else if (child.localName = 'instanceReference') then
        value.instance := ParseReference(child, path+'/instanceReference')
      else if (child.localName = 'causality') then
        value.causality := ParseAdverseEventSuspectEntityCausality(child, path+'/causality')
      else if Not ParseBackboneElementChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeAdverseEventSuspectEntity(xml : TXmlBuilder; name : String; value : TFhirAdverseEventSuspectEntity);
begin
  if (value = nil) then
    exit;
  composeElementAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeAdverseEventSuspectEntityChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeAdverseEventSuspectEntityChildren(xml : TXmlBuilder; value : TFhirAdverseEventSuspectEntity);
begin
  composeBackboneElementChildren(xml, value);
  if (value.instance is TFhirCodeableConcept) {6} then
    ComposeCodeableConcept(xml, 'instanceCodeableConcept', TFhirCodeableConcept(value.instance))
  else if (value.instance is TFhirReference) {2} then
    ComposeReference(xml, 'instanceReference', TFhirReference(value.instance));
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeAdverseEventSuspectEntityCausality(xml, 'causality', value.causality);
end;

function TFHIRXmlParser.ParseAdverseEventSuspectEntityCausality(element : TMXmlElement; path : string) : TFhirAdverseEventSuspectEntityCausality;
var
  child : TMXmlElement;
begin
  result := TFhirAdverseEventSuspectEntityCausality.Create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseAdverseEventSuspectEntityCausalityChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseAdverseEventSuspectEntityCausalityChild(value : TFhirAdverseEventSuspectEntityCausality; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'assessmentMethod') then
        value.assessmentMethod := ParseCodeableConcept(child, path+'/assessmentMethod')
      else if (child.localName = 'entityRelatedness') then
        value.entityRelatedness := ParseCodeableConcept(child, path+'/entityRelatedness')
      else if (child.localName = 'author') then
        value.author := ParseReference(child, path+'/author')
      else if Not ParseBackboneElementChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeAdverseEventSuspectEntityCausality(xml : TXmlBuilder; name : String; value : TFhirAdverseEventSuspectEntityCausality);
begin
  if (value = nil) then
    exit;
  composeElementAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeAdverseEventSuspectEntityCausalityChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeAdverseEventSuspectEntityCausalityChildren(xml : TXmlBuilder; value : TFhirAdverseEventSuspectEntityCausality);
begin
  composeBackboneElementChildren(xml, value);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(xml, 'assessmentMethod', value.assessmentMethod);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(xml, 'entityRelatedness', value.entityRelatedness);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference(xml, 'author', value.author);
end;

function TFHIRXmlParser.ParseAdverseEventContributingFactor(element : TMXmlElement; path : string) : TFhirAdverseEventContributingFactor;
var
  child : TMXmlElement;
begin
  result := TFhirAdverseEventContributingFactor.Create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseAdverseEventContributingFactorChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseAdverseEventContributingFactorChild(value : TFhirAdverseEventContributingFactor; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'itemReference') then
        value.item := ParseReference(child, path+'/itemReference')
      else if (child.localName = 'itemCodeableConcept') then
        value.item := ParseCodeableConcept(child, path+'/itemCodeableConcept')
      else if Not ParseBackboneElementChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeAdverseEventContributingFactor(xml : TXmlBuilder; name : String; value : TFhirAdverseEventContributingFactor);
begin
  if (value = nil) then
    exit;
  composeElementAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeAdverseEventContributingFactorChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeAdverseEventContributingFactorChildren(xml : TXmlBuilder; value : TFhirAdverseEventContributingFactor);
begin
  composeBackboneElementChildren(xml, value);
  if (value.item is TFhirReference) {2} then
    ComposeReference(xml, 'itemReference', TFhirReference(value.item))
  else if (value.item is TFhirCodeableConcept) {6} then
    ComposeCodeableConcept(xml, 'itemCodeableConcept', TFhirCodeableConcept(value.item));
end;

function TFHIRXmlParser.ParseAdverseEventPreventiveAction(element : TMXmlElement; path : string) : TFhirAdverseEventPreventiveAction;
var
  child : TMXmlElement;
begin
  result := TFhirAdverseEventPreventiveAction.Create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseAdverseEventPreventiveActionChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseAdverseEventPreventiveActionChild(value : TFhirAdverseEventPreventiveAction; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'itemReference') then
        value.item := ParseReference(child, path+'/itemReference')
      else if (child.localName = 'itemCodeableConcept') then
        value.item := ParseCodeableConcept(child, path+'/itemCodeableConcept')
      else if Not ParseBackboneElementChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeAdverseEventPreventiveAction(xml : TXmlBuilder; name : String; value : TFhirAdverseEventPreventiveAction);
begin
  if (value = nil) then
    exit;
  composeElementAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeAdverseEventPreventiveActionChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeAdverseEventPreventiveActionChildren(xml : TXmlBuilder; value : TFhirAdverseEventPreventiveAction);
begin
  composeBackboneElementChildren(xml, value);
  if (value.item is TFhirReference) {2} then
    ComposeReference(xml, 'itemReference', TFhirReference(value.item))
  else if (value.item is TFhirCodeableConcept) {6} then
    ComposeCodeableConcept(xml, 'itemCodeableConcept', TFhirCodeableConcept(value.item));
end;

function TFHIRXmlParser.ParseAdverseEventMitigatingAction(element : TMXmlElement; path : string) : TFhirAdverseEventMitigatingAction;
var
  child : TMXmlElement;
begin
  result := TFhirAdverseEventMitigatingAction.Create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseAdverseEventMitigatingActionChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseAdverseEventMitigatingActionChild(value : TFhirAdverseEventMitigatingAction; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'itemReference') then
        value.item := ParseReference(child, path+'/itemReference')
      else if (child.localName = 'itemCodeableConcept') then
        value.item := ParseCodeableConcept(child, path+'/itemCodeableConcept')
      else if Not ParseBackboneElementChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeAdverseEventMitigatingAction(xml : TXmlBuilder; name : String; value : TFhirAdverseEventMitigatingAction);
begin
  if (value = nil) then
    exit;
  composeElementAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeAdverseEventMitigatingActionChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeAdverseEventMitigatingActionChildren(xml : TXmlBuilder; value : TFhirAdverseEventMitigatingAction);
begin
  composeBackboneElementChildren(xml, value);
  if (value.item is TFhirReference) {2} then
    ComposeReference(xml, 'itemReference', TFhirReference(value.item))
  else if (value.item is TFhirCodeableConcept) {6} then
    ComposeCodeableConcept(xml, 'itemCodeableConcept', TFhirCodeableConcept(value.item));
end;

function TFHIRXmlParser.ParseAdverseEventSupportingInfo(element : TMXmlElement; path : string) : TFhirAdverseEventSupportingInfo;
var
  child : TMXmlElement;
begin
  result := TFhirAdverseEventSupportingInfo.Create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseAdverseEventSupportingInfoChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseAdverseEventSupportingInfoChild(value : TFhirAdverseEventSupportingInfo; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'itemReference') then
        value.item := ParseReference(child, path+'/itemReference')
      else if (child.localName = 'itemCodeableConcept') then
        value.item := ParseCodeableConcept(child, path+'/itemCodeableConcept')
      else if Not ParseBackboneElementChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeAdverseEventSupportingInfo(xml : TXmlBuilder; name : String; value : TFhirAdverseEventSupportingInfo);
begin
  if (value = nil) then
    exit;
  composeElementAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeAdverseEventSupportingInfoChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeAdverseEventSupportingInfoChildren(xml : TXmlBuilder; value : TFhirAdverseEventSupportingInfo);
begin
  composeBackboneElementChildren(xml, value);
  if (value.item is TFhirReference) {2} then
    ComposeReference(xml, 'itemReference', TFhirReference(value.item))
  else if (value.item is TFhirCodeableConcept) {6} then
    ComposeCodeableConcept(xml, 'itemCodeableConcept', TFhirCodeableConcept(value.item));
end;

function TFHIRXmlParser.ParseAdverseEvent(element : TMXmlElement; path : string) : TFhirAdverseEvent;
var
  child : TMXmlElement;
begin
  result := TFhirAdverseEvent.Create;
  try
    parseDomainResourceAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseAdverseEventChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseAdverseEventChild(value : TFhirAdverseEvent; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'identifier') then
        value.identifierList.Add(ParseIdentifier(child, path+'/identifier'))
      else if (child.localName = 'status') then
        value.statusElement := ParseEnum(CODES_TFhirAdverseEventStatusEnum, SYSTEMS_TFhirAdverseEventStatusEnum, child, path+'/status')
      else if (child.localName = 'actuality') then
        value.actualityElement := ParseEnum(CODES_TFhirAdverseEventActualityEnum, SYSTEMS_TFhirAdverseEventActualityEnum, child, path+'/actuality')
      else if (child.localName = 'category') then
        value.categoryList.Add(ParseCodeableConcept(child, path+'/category'))
      else if (child.localName = 'code') then
        value.code := ParseCodeableConcept(child, path+'/code')
      else if (child.localName = 'subject') then
        value.subject := ParseReference(child, path+'/subject')
      else if (child.localName = 'encounter') then
        value.encounter := ParseReference(child, path+'/encounter')
      else if (child.localName = 'occurrencePeriod') then
        value.occurrence := ParsePeriod(child, path+'/occurrencePeriod')
      else if (child.localName = 'occurrenceTiming') then
        value.occurrence := ParseTiming(child, path+'/occurrenceTiming')
      else if (child.localName = 'occurrenceDateTime') then
        value.occurrence := ParseDateTime(child, path+'/occurrenceDateTime')
      else if (child.localName = 'detected') then
        value.detectedElement := ParseDateTime(child, path+'/detected')
      else if (child.localName = 'recordedDate') then
        value.recordedDateElement := ParseDateTime(child, path+'/recordedDate')
      else if (child.localName = 'resultingCondition') then
        value.resultingConditionList.Add(ParseReference(child, path+'/resultingCondition'))
      else if (child.localName = 'location') then
        value.location := ParseReference(child, path+'/location')
      else if (child.localName = 'seriousness') then
        value.seriousness := ParseCodeableConcept(child, path+'/seriousness')
      else if (child.localName = 'outcome') then
        value.outcomeList.Add(ParseCodeableConcept(child, path+'/outcome'))
      else if (child.localName = 'recorder') then
        value.recorder := ParseReference(child, path+'/recorder')
      else if (child.localName = 'participant') then
        value.participantList.Add(ParseAdverseEventParticipant(child, path+'/participant'))
      else if (child.localName = 'study') then
        value.studyList.Add(ParseReference(child, path+'/study'))
      else if (child.localName = 'expectedInResearchStudy') then
        value.expectedInResearchStudyElement := ParseBoolean(child, path+'/expectedInResearchStudy')
      else if (child.localName = 'suspectEntity') then
        value.suspectEntityList.Add(ParseAdverseEventSuspectEntity(child, path+'/suspectEntity'))
      else if (child.localName = 'contributingFactor') then
        value.contributingFactorList.Add(ParseAdverseEventContributingFactor(child, path+'/contributingFactor'))
      else if (child.localName = 'preventiveAction') then
        value.preventiveActionList.Add(ParseAdverseEventPreventiveAction(child, path+'/preventiveAction'))
      else if (child.localName = 'mitigatingAction') then
        value.mitigatingActionList.Add(ParseAdverseEventMitigatingAction(child, path+'/mitigatingAction'))
      else if (child.localName = 'supportingInfo') then
        value.supportingInfoList.Add(ParseAdverseEventSupportingInfo(child, path+'/supportingInfo'))
      else if (child.localName = 'note') then
        value.noteList.Add(ParseAnnotation(child, path+'/note'))
      else if Not ParseDomainResourceChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeAdverseEvent(xml : TXmlBuilder; name : String; value : TFhirAdverseEvent);
begin
  if (value = nil) then
    exit;
  composeDomainResourceAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeAdverseEventChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeAdverseEventChildren(xml : TXmlBuilder; value : TFhirAdverseEvent);
var
  i : integer;
begin
  composeDomainResourceChildren(xml, value);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.identifierList.Count - 1 do
      ComposeIdentifier(xml, 'identifier', value.identifierList[i]);
  ComposeEnum(xml, 'status', value.statusElement, CODES_TFhirAdverseEventStatusEnum);
  ComposeEnum(xml, 'actuality', value.actualityElement, CODES_TFhirAdverseEventActualityEnum);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.categoryList.Count - 1 do
      ComposeCodeableConcept(xml, 'category', value.categoryList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(xml, 'code', value.code);
  ComposeReference(xml, 'subject', value.subject);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference(xml, 'encounter', value.encounter);
  if (SummaryOption in [soFull, soSummary, soData]) and (value.occurrence is TFhirPeriod) {6} then
    ComposePeriod(xml, 'occurrencePeriod', TFhirPeriod(value.occurrence))
  else if (SummaryOption in [soFull, soSummary, soData]) and (value.occurrence is TFhirTiming) {6} then
    ComposeTiming(xml, 'occurrenceTiming', TFhirTiming(value.occurrence))
  else if (SummaryOption in [soFull, soSummary, soData]) and (value.occurrence is TFhirDateTime) {6} then
    ComposeDateTime(xml, 'occurrenceDateTime', TFhirDateTime(value.occurrence));
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDateTime(xml, 'detected', value.detectedElement);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDateTime(xml, 'recordedDate', value.recordedDateElement);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.resultingConditionList.Count - 1 do
      ComposeReference(xml, 'resultingCondition', value.resultingConditionList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference(xml, 'location', value.location);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(xml, 'seriousness', value.seriousness);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.outcomeList.Count - 1 do
      ComposeCodeableConcept(xml, 'outcome', value.outcomeList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference(xml, 'recorder', value.recorder);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.participantList.Count - 1 do
      ComposeAdverseEventParticipant(xml, 'participant', value.participantList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.studyList.Count - 1 do
      ComposeReference(xml, 'study', value.studyList[i]);
  if (SummaryOption in [soFull, soData]) then
    ComposeBoolean(xml, 'expectedInResearchStudy', value.expectedInResearchStudyElement);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.suspectEntityList.Count - 1 do
      ComposeAdverseEventSuspectEntity(xml, 'suspectEntity', value.suspectEntityList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.contributingFactorList.Count - 1 do
      ComposeAdverseEventContributingFactor(xml, 'contributingFactor', value.contributingFactorList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.preventiveActionList.Count - 1 do
      ComposeAdverseEventPreventiveAction(xml, 'preventiveAction', value.preventiveActionList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.mitigatingActionList.Count - 1 do
      ComposeAdverseEventMitigatingAction(xml, 'mitigatingAction', value.mitigatingActionList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.supportingInfoList.Count - 1 do
      ComposeAdverseEventSupportingInfo(xml, 'supportingInfo', value.supportingInfoList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.noteList.Count - 1 do
      ComposeAnnotation(xml, 'note', value.noteList[i]);
end;

{$ENDIF FHIR_ADVERSEEVENT}
{$IFDEF FHIR_ALLERGYINTOLERANCE}
function TFHIRXmlParser.ParseAllergyIntoleranceParticipant(element : TMXmlElement; path : string) : TFhirAllergyIntoleranceParticipant;
var
  child : TMXmlElement;
begin
  result := TFhirAllergyIntoleranceParticipant.Create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseAllergyIntoleranceParticipantChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseAllergyIntoleranceParticipantChild(value : TFhirAllergyIntoleranceParticipant; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'function') then
        value.function_ := ParseCodeableConcept(child, path+'/function')
      else if (child.localName = 'actor') then
        value.actor := ParseReference(child, path+'/actor')
      else if Not ParseBackboneElementChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeAllergyIntoleranceParticipant(xml : TXmlBuilder; name : String; value : TFhirAllergyIntoleranceParticipant);
begin
  if (value = nil) then
    exit;
  composeElementAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeAllergyIntoleranceParticipantChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeAllergyIntoleranceParticipantChildren(xml : TXmlBuilder; value : TFhirAllergyIntoleranceParticipant);
begin
  composeBackboneElementChildren(xml, value);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(xml, 'function', value.function_);
  ComposeReference(xml, 'actor', value.actor);
end;

function TFHIRXmlParser.ParseAllergyIntoleranceReaction(element : TMXmlElement; path : string) : TFhirAllergyIntoleranceReaction;
var
  child : TMXmlElement;
begin
  result := TFhirAllergyIntoleranceReaction.Create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseAllergyIntoleranceReactionChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseAllergyIntoleranceReactionChild(value : TFhirAllergyIntoleranceReaction; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'substance') then
        value.substance := ParseCodeableConcept(child, path+'/substance')
      else if (child.localName = 'manifestation') then
        value.manifestationList.Add(ParseCodeableReference(child, path+'/manifestation'))
      else if (child.localName = 'description') then
        value.descriptionElement := ParseString(child, path+'/description')
      else if (child.localName = 'onset') then
        value.onsetElement := ParseDateTime(child, path+'/onset')
      else if (child.localName = 'severity') then
        value.severityElement := ParseEnum(CODES_TFhirAllergyIntoleranceSeverityEnum, SYSTEMS_TFhirAllergyIntoleranceSeverityEnum, child, path+'/severity')
      else if (child.localName = 'exposureRoute') then
        value.exposureRoute := ParseCodeableConcept(child, path+'/exposureRoute')
      else if (child.localName = 'note') then
        value.noteList.Add(ParseAnnotation(child, path+'/note'))
      else if Not ParseBackboneElementChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeAllergyIntoleranceReaction(xml : TXmlBuilder; name : String; value : TFhirAllergyIntoleranceReaction);
begin
  if (value = nil) then
    exit;
  composeElementAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeAllergyIntoleranceReactionChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeAllergyIntoleranceReactionChildren(xml : TXmlBuilder; value : TFhirAllergyIntoleranceReaction);
var
  i : integer;
begin
  composeBackboneElementChildren(xml, value);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(xml, 'substance', value.substance);
  for i := 0 to value.manifestationList.Count - 1 do
      ComposeCodeableReference(xml, 'manifestation', value.manifestationList[i]);
  if (SummaryOption in [soFull, soData]) then
    ComposeString(xml, 'description', value.descriptionElement);
  if (SummaryOption in [soFull, soData]) then
    ComposeDateTime(xml, 'onset', value.onsetElement);
  if (SummaryOption in [soFull, soData]) then
    ComposeEnum(xml, 'severity', value.severityElement, CODES_TFhirAllergyIntoleranceSeverityEnum);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(xml, 'exposureRoute', value.exposureRoute);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.noteList.Count - 1 do
      ComposeAnnotation(xml, 'note', value.noteList[i]);
end;

function TFHIRXmlParser.ParseAllergyIntolerance(element : TMXmlElement; path : string) : TFhirAllergyIntolerance;
var
  child : TMXmlElement;
begin
  result := TFhirAllergyIntolerance.Create;
  try
    parseDomainResourceAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseAllergyIntoleranceChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseAllergyIntoleranceChild(value : TFhirAllergyIntolerance; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'identifier') then
        value.identifierList.Add(ParseIdentifier(child, path+'/identifier'))
      else if (child.localName = 'clinicalStatus') then
        value.clinicalStatus := ParseCodeableConcept(child, path+'/clinicalStatus')
      else if (child.localName = 'verificationStatus') then
        value.verificationStatus := ParseCodeableConcept(child, path+'/verificationStatus')
      else if (child.localName = 'type') then
        value.type_Element := ParseEnum(CODES_TFhirAllergyIntoleranceTypeEnum, SYSTEMS_TFhirAllergyIntoleranceTypeEnum, child, path+'/type')
      else if (child.localName = 'category') then
        value.categoryList.Add(ParseEnum(CODES_TFhirAllergyIntoleranceCategoryEnum, SYSTEMS_TFhirAllergyIntoleranceCategoryEnum, child, path+'/category')){y.1}
      else if (child.localName = 'criticality') then
        value.criticalityElement := ParseEnum(CODES_TFhirAllergyIntoleranceCriticalityEnum, SYSTEMS_TFhirAllergyIntoleranceCriticalityEnum, child, path+'/criticality')
      else if (child.localName = 'code') then
        value.code := ParseCodeableConcept(child, path+'/code')
      else if (child.localName = 'patient') then
        value.patient := ParseReference(child, path+'/patient')
      else if (child.localName = 'encounter') then
        value.encounter := ParseReference(child, path+'/encounter')
      else if (child.localName = 'onsetAge') then
        value.onset := ParseAge(child, path+'/onsetAge')
      else if (child.localName = 'onsetPeriod') then
        value.onset := ParsePeriod(child, path+'/onsetPeriod')
      else if (child.localName = 'onsetRange') then
        value.onset := ParseRange(child, path+'/onsetRange')
      else if (child.localName = 'onsetDateTime') then
        value.onset := ParseDateTime(child, path+'/onsetDateTime')
      else if (child.localName = 'onsetString') then
        value.onset := ParseString(child, path+'/onsetString')
      else if (child.localName = 'recordedDate') then
        value.recordedDateElement := ParseDateTime(child, path+'/recordedDate')
      else if (child.localName = 'participant') then
        value.participantList.Add(ParseAllergyIntoleranceParticipant(child, path+'/participant'))
      else if (child.localName = 'lastOccurrence') then
        value.lastOccurrenceElement := ParseDateTime(child, path+'/lastOccurrence')
      else if (child.localName = 'note') then
        value.noteList.Add(ParseAnnotation(child, path+'/note'))
      else if (child.localName = 'reaction') then
        value.reactionList.Add(ParseAllergyIntoleranceReaction(child, path+'/reaction'))
      else if Not ParseDomainResourceChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeAllergyIntolerance(xml : TXmlBuilder; name : String; value : TFhirAllergyIntolerance);
begin
  if (value = nil) then
    exit;
  composeDomainResourceAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeAllergyIntoleranceChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeAllergyIntoleranceChildren(xml : TXmlBuilder; value : TFhirAllergyIntolerance);
var
  i : integer;
begin
  composeDomainResourceChildren(xml, value);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.identifierList.Count - 1 do
      ComposeIdentifier(xml, 'identifier', value.identifierList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(xml, 'clinicalStatus', value.clinicalStatus);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(xml, 'verificationStatus', value.verificationStatus);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeEnum(xml, 'type', value.type_Element, CODES_TFhirAllergyIntoleranceTypeEnum);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.categoryList.Count - 1 do
      ComposeEnum(xml, 'category', value.categoryList[i], CODES_TFhirAllergyIntoleranceCategoryEnum);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeEnum(xml, 'criticality', value.criticalityElement, CODES_TFhirAllergyIntoleranceCriticalityEnum);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(xml, 'code', value.code);
  ComposeReference(xml, 'patient', value.patient);
  if (SummaryOption in [soFull, soData]) then
    ComposeReference(xml, 'encounter', value.encounter);
  if (SummaryOption in [soFull, soData]) and (value.onset is TFhirAge) {6} then
    ComposeAge(xml, 'onsetAge', TFhirAge(value.onset))
  else if (SummaryOption in [soFull, soData]) and (value.onset is TFhirPeriod) {6} then
    ComposePeriod(xml, 'onsetPeriod', TFhirPeriod(value.onset))
  else if (SummaryOption in [soFull, soData]) and (value.onset is TFhirRange) {6} then
    ComposeRange(xml, 'onsetRange', TFhirRange(value.onset))
  else if (SummaryOption in [soFull, soData]) and (value.onset is TFhirDateTime) {6} then
    ComposeDateTime(xml, 'onsetDateTime', TFhirDateTime(value.onset))
  else if (SummaryOption in [soFull, soData]) and (value.onset is TFhirString) {6} then
    ComposeString(xml, 'onsetString', TFhirString(value.onset));
  if (SummaryOption in [soFull, soData]) then
    ComposeDateTime(xml, 'recordedDate', value.recordedDateElement);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.participantList.Count - 1 do
      ComposeAllergyIntoleranceParticipant(xml, 'participant', value.participantList[i]);
  if (SummaryOption in [soFull, soData]) then
    ComposeDateTime(xml, 'lastOccurrence', value.lastOccurrenceElement);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.noteList.Count - 1 do
      ComposeAnnotation(xml, 'note', value.noteList[i]);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.reactionList.Count - 1 do
      ComposeAllergyIntoleranceReaction(xml, 'reaction', value.reactionList[i]);
end;

{$ENDIF FHIR_ALLERGYINTOLERANCE}
{$IFDEF FHIR_APPOINTMENT}
function TFHIRXmlParser.ParseAppointmentParticipant(element : TMXmlElement; path : string) : TFhirAppointmentParticipant;
var
  child : TMXmlElement;
begin
  result := TFhirAppointmentParticipant.Create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseAppointmentParticipantChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseAppointmentParticipantChild(value : TFhirAppointmentParticipant; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'type') then
        value.type_List.Add(ParseCodeableConcept(child, path+'/type'))
      else if (child.localName = 'period') then
        value.period := ParsePeriod(child, path+'/period')
      else if (child.localName = 'actor') then
        value.actor := ParseReference(child, path+'/actor')
      else if (child.localName = 'required') then
        value.requiredElement := ParseBoolean(child, path+'/required')
      else if (child.localName = 'status') then
        value.statusElement := ParseEnum(CODES_TFhirParticipationStatusEnum, SYSTEMS_TFhirParticipationStatusEnum, child, path+'/status')
      else if Not ParseBackboneElementChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeAppointmentParticipant(xml : TXmlBuilder; name : String; value : TFhirAppointmentParticipant);
begin
  if (value = nil) then
    exit;
  composeElementAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeAppointmentParticipantChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeAppointmentParticipantChildren(xml : TXmlBuilder; value : TFhirAppointmentParticipant);
var
  i : integer;
begin
  composeBackboneElementChildren(xml, value);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.type_List.Count - 1 do
      ComposeCodeableConcept(xml, 'type', value.type_List[i]);
  if (SummaryOption in [soFull, soData]) then
    ComposePeriod(xml, 'period', value.period);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference(xml, 'actor', value.actor);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeBoolean(xml, 'required', value.requiredElement);
  ComposeEnum(xml, 'status', value.statusElement, CODES_TFhirParticipationStatusEnum);
end;

function TFHIRXmlParser.ParseAppointmentRecurrenceTemplate(element : TMXmlElement; path : string) : TFhirAppointmentRecurrenceTemplate;
var
  child : TMXmlElement;
begin
  result := TFhirAppointmentRecurrenceTemplate.Create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseAppointmentRecurrenceTemplateChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseAppointmentRecurrenceTemplateChild(value : TFhirAppointmentRecurrenceTemplate; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'timezone') then
        value.timezone := ParseCodeableConcept(child, path+'/timezone')
      else if (child.localName = 'recurrenceType') then
        value.recurrenceType := ParseCodeableConcept(child, path+'/recurrenceType')
      else if (child.localName = 'lastOccurrenceDate') then
        value.lastOccurrenceDateElement := ParseDate(child, path+'/lastOccurrenceDate')
      else if (child.localName = 'occurrenceCount') then
        value.occurrenceCountElement := ParsePositiveInt(child, path+'/occurrenceCount')
      else if (child.localName = 'occurrenceDate') then
        value.occurrenceDateList.Add(ParseDate(child, path+'/occurrenceDate'))
      else if (child.localName = 'weeklyTemplate') then
        value.weeklyTemplate := ParseAppointmentRecurrenceTemplateWeeklyTemplate(child, path+'/weeklyTemplate')
      else if (child.localName = 'monthlyTemplate') then
        value.monthlyTemplate := ParseAppointmentRecurrenceTemplateMonthlyTemplate(child, path+'/monthlyTemplate')
      else if (child.localName = 'yearlyTemplate') then
        value.yearlyTemplate := ParseAppointmentRecurrenceTemplateYearlyTemplate(child, path+'/yearlyTemplate')
      else if (child.localName = 'excludingDate') then
        value.excludingDateList.Add(ParseDate(child, path+'/excludingDate'))
      else if (child.localName = 'excludingRecurrenceId') then
        value.excludingRecurrenceIdList.Add(ParsePositiveInt(child, path+'/excludingRecurrenceId'))
      else if Not ParseBackboneElementChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeAppointmentRecurrenceTemplate(xml : TXmlBuilder; name : String; value : TFhirAppointmentRecurrenceTemplate);
begin
  if (value = nil) then
    exit;
  composeElementAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeAppointmentRecurrenceTemplateChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeAppointmentRecurrenceTemplateChildren(xml : TXmlBuilder; value : TFhirAppointmentRecurrenceTemplate);
var
  i : integer;
begin
  composeBackboneElementChildren(xml, value);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(xml, 'timezone', value.timezone);
  ComposeCodeableConcept(xml, 'recurrenceType', value.recurrenceType);
  if (SummaryOption in [soFull, soData]) then
    ComposeDate(xml, 'lastOccurrenceDate', value.lastOccurrenceDateElement);
  if (SummaryOption in [soFull, soData]) then
    ComposePositiveInt(xml, 'occurrenceCount', value.occurrenceCountElement);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.occurrenceDateList.Count - 1 do
      ComposeDate(xml, 'occurrenceDate', value.occurrenceDateList[i]);
  if (SummaryOption in [soFull, soData]) then
    ComposeAppointmentRecurrenceTemplateWeeklyTemplate(xml, 'weeklyTemplate', value.weeklyTemplate);
  if (SummaryOption in [soFull, soData]) then
    ComposeAppointmentRecurrenceTemplateMonthlyTemplate(xml, 'monthlyTemplate', value.monthlyTemplate);
  if (SummaryOption in [soFull, soData]) then
    ComposeAppointmentRecurrenceTemplateYearlyTemplate(xml, 'yearlyTemplate', value.yearlyTemplate);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.excludingDateList.Count - 1 do
      ComposeDate(xml, 'excludingDate', value.excludingDateList[i]);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.excludingRecurrenceIdList.Count - 1 do
      ComposePositiveInt(xml, 'excludingRecurrenceId', value.excludingRecurrenceIdList[i]);
end;

function TFHIRXmlParser.ParseAppointmentRecurrenceTemplateWeeklyTemplate(element : TMXmlElement; path : string) : TFhirAppointmentRecurrenceTemplateWeeklyTemplate;
var
  child : TMXmlElement;
begin
  result := TFhirAppointmentRecurrenceTemplateWeeklyTemplate.Create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseAppointmentRecurrenceTemplateWeeklyTemplateChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseAppointmentRecurrenceTemplateWeeklyTemplateChild(value : TFhirAppointmentRecurrenceTemplateWeeklyTemplate; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'monday') then
        value.mondayElement := ParseBoolean(child, path+'/monday')
      else if (child.localName = 'tuesday') then
        value.tuesdayElement := ParseBoolean(child, path+'/tuesday')
      else if (child.localName = 'wednesday') then
        value.wednesdayElement := ParseBoolean(child, path+'/wednesday')
      else if (child.localName = 'thursday') then
        value.thursdayElement := ParseBoolean(child, path+'/thursday')
      else if (child.localName = 'friday') then
        value.fridayElement := ParseBoolean(child, path+'/friday')
      else if (child.localName = 'saturday') then
        value.saturdayElement := ParseBoolean(child, path+'/saturday')
      else if (child.localName = 'sunday') then
        value.sundayElement := ParseBoolean(child, path+'/sunday')
      else if (child.localName = 'weekInterval') then
        value.weekIntervalElement := ParsePositiveInt(child, path+'/weekInterval')
      else if Not ParseBackboneElementChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeAppointmentRecurrenceTemplateWeeklyTemplate(xml : TXmlBuilder; name : String; value : TFhirAppointmentRecurrenceTemplateWeeklyTemplate);
begin
  if (value = nil) then
    exit;
  composeElementAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeAppointmentRecurrenceTemplateWeeklyTemplateChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeAppointmentRecurrenceTemplateWeeklyTemplateChildren(xml : TXmlBuilder; value : TFhirAppointmentRecurrenceTemplateWeeklyTemplate);
begin
  composeBackboneElementChildren(xml, value);
  if (SummaryOption in [soFull, soData]) then
    ComposeBoolean(xml, 'monday', value.mondayElement);
  if (SummaryOption in [soFull, soData]) then
    ComposeBoolean(xml, 'tuesday', value.tuesdayElement);
  if (SummaryOption in [soFull, soData]) then
    ComposeBoolean(xml, 'wednesday', value.wednesdayElement);
  if (SummaryOption in [soFull, soData]) then
    ComposeBoolean(xml, 'thursday', value.thursdayElement);
  if (SummaryOption in [soFull, soData]) then
    ComposeBoolean(xml, 'friday', value.fridayElement);
  if (SummaryOption in [soFull, soData]) then
    ComposeBoolean(xml, 'saturday', value.saturdayElement);
  if (SummaryOption in [soFull, soData]) then
    ComposeBoolean(xml, 'sunday', value.sundayElement);
  if (SummaryOption in [soFull, soData]) then
    ComposePositiveInt(xml, 'weekInterval', value.weekIntervalElement);
end;

function TFHIRXmlParser.ParseAppointmentRecurrenceTemplateMonthlyTemplate(element : TMXmlElement; path : string) : TFhirAppointmentRecurrenceTemplateMonthlyTemplate;
var
  child : TMXmlElement;
begin
  result := TFhirAppointmentRecurrenceTemplateMonthlyTemplate.Create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseAppointmentRecurrenceTemplateMonthlyTemplateChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseAppointmentRecurrenceTemplateMonthlyTemplateChild(value : TFhirAppointmentRecurrenceTemplateMonthlyTemplate; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'dayOfMonth') then
        value.dayOfMonthElement := ParsePositiveInt(child, path+'/dayOfMonth')
      else if (child.localName = 'nthWeekOfMonth') then
        value.nthWeekOfMonth := ParseCoding(child, path+'/nthWeekOfMonth')
      else if (child.localName = 'dayOfWeek') then
        value.dayOfWeek := ParseCoding(child, path+'/dayOfWeek')
      else if (child.localName = 'monthInterval') then
        value.monthIntervalElement := ParsePositiveInt(child, path+'/monthInterval')
      else if Not ParseBackboneElementChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeAppointmentRecurrenceTemplateMonthlyTemplate(xml : TXmlBuilder; name : String; value : TFhirAppointmentRecurrenceTemplateMonthlyTemplate);
begin
  if (value = nil) then
    exit;
  composeElementAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeAppointmentRecurrenceTemplateMonthlyTemplateChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeAppointmentRecurrenceTemplateMonthlyTemplateChildren(xml : TXmlBuilder; value : TFhirAppointmentRecurrenceTemplateMonthlyTemplate);
begin
  composeBackboneElementChildren(xml, value);
  if (SummaryOption in [soFull, soData]) then
    ComposePositiveInt(xml, 'dayOfMonth', value.dayOfMonthElement);
  if (SummaryOption in [soFull, soData]) then
    ComposeCoding(xml, 'nthWeekOfMonth', value.nthWeekOfMonth);
  if (SummaryOption in [soFull, soData]) then
    ComposeCoding(xml, 'dayOfWeek', value.dayOfWeek);
  ComposePositiveInt(xml, 'monthInterval', value.monthIntervalElement);
end;

function TFHIRXmlParser.ParseAppointmentRecurrenceTemplateYearlyTemplate(element : TMXmlElement; path : string) : TFhirAppointmentRecurrenceTemplateYearlyTemplate;
var
  child : TMXmlElement;
begin
  result := TFhirAppointmentRecurrenceTemplateYearlyTemplate.Create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseAppointmentRecurrenceTemplateYearlyTemplateChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseAppointmentRecurrenceTemplateYearlyTemplateChild(value : TFhirAppointmentRecurrenceTemplateYearlyTemplate; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'yearInterval') then
        value.yearIntervalElement := ParsePositiveInt(child, path+'/yearInterval')
      else if Not ParseBackboneElementChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeAppointmentRecurrenceTemplateYearlyTemplate(xml : TXmlBuilder; name : String; value : TFhirAppointmentRecurrenceTemplateYearlyTemplate);
begin
  if (value = nil) then
    exit;
  composeElementAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeAppointmentRecurrenceTemplateYearlyTemplateChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeAppointmentRecurrenceTemplateYearlyTemplateChildren(xml : TXmlBuilder; value : TFhirAppointmentRecurrenceTemplateYearlyTemplate);
begin
  composeBackboneElementChildren(xml, value);
  ComposePositiveInt(xml, 'yearInterval', value.yearIntervalElement);
end;

function TFHIRXmlParser.ParseAppointment(element : TMXmlElement; path : string) : TFhirAppointment;
var
  child : TMXmlElement;
begin
  result := TFhirAppointment.Create;
  try
    parseDomainResourceAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseAppointmentChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseAppointmentChild(value : TFhirAppointment; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'identifier') then
        value.identifierList.Add(ParseIdentifier(child, path+'/identifier'))
      else if (child.localName = 'status') then
        value.statusElement := ParseEnum(CODES_TFhirAppointmentStatusEnum, SYSTEMS_TFhirAppointmentStatusEnum, child, path+'/status')
      else if (child.localName = 'cancellationReason') then
        value.cancellationReason := ParseCodeableConcept(child, path+'/cancellationReason')
      else if (child.localName = 'class') then
        value.class_List.Add(ParseCodeableConcept(child, path+'/class'))
      else if (child.localName = 'serviceCategory') then
        value.serviceCategoryList.Add(ParseCodeableConcept(child, path+'/serviceCategory'))
      else if (child.localName = 'serviceType') then
        value.serviceTypeList.Add(ParseCodeableReference(child, path+'/serviceType'))
      else if (child.localName = 'specialty') then
        value.specialtyList.Add(ParseCodeableConcept(child, path+'/specialty'))
      else if (child.localName = 'appointmentType') then
        value.appointmentType := ParseCodeableConcept(child, path+'/appointmentType')
      else if (child.localName = 'reason') then
        value.reasonList.Add(ParseCodeableReference(child, path+'/reason'))
      else if (child.localName = 'priority') then
        value.priority := ParseCodeableConcept(child, path+'/priority')
      else if (child.localName = 'description') then
        value.descriptionElement := ParseString(child, path+'/description')
      else if (child.localName = 'replaces') then
        value.replacesList.Add(ParseReference(child, path+'/replaces'))
      else if (child.localName = 'virtualService') then
        value.virtualServiceList.Add(ParseVirtualServiceDetail(child, path+'/virtualService'))
      else if (child.localName = 'supportingInformation') then
        value.supportingInformationList.Add(ParseReference(child, path+'/supportingInformation'))
      else if (child.localName = 'previousAppointment') then
        value.previousAppointment := ParseReference(child, path+'/previousAppointment')
      else if (child.localName = 'originatingAppointment') then
        value.originatingAppointment := ParseReference(child, path+'/originatingAppointment')
      else if (child.localName = 'start') then
        value.startElement := ParseInstant(child, path+'/start')
      else if (child.localName = 'end') then
        value.end_Element := ParseInstant(child, path+'/end')
      else if (child.localName = 'minutesDuration') then
        value.minutesDurationElement := ParsePositiveInt(child, path+'/minutesDuration')
      else if (child.localName = 'slot') then
        value.slotList.Add(ParseReference(child, path+'/slot'))
      else if (child.localName = 'account') then
        value.accountList.Add(ParseReference(child, path+'/account'))
      else if (child.localName = 'created') then
        value.createdElement := ParseDateTime(child, path+'/created')
      else if (child.localName = 'note') then
        value.noteList.Add(ParseAnnotation(child, path+'/note'))
      else if (child.localName = 'patientInstruction') then
        value.patientInstructionList.Add(ParseCodeableReference(child, path+'/patientInstruction'))
      else if (child.localName = 'basedOn') then
        value.basedOnList.Add(ParseReference(child, path+'/basedOn'))
      else if (child.localName = 'subject') then
        value.subject := ParseReference(child, path+'/subject')
      else if (child.localName = 'participant') then
        value.participantList.Add(ParseAppointmentParticipant(child, path+'/participant'))
      else if (child.localName = 'requestedPeriod') then
        value.requestedPeriodList.Add(ParsePeriod(child, path+'/requestedPeriod'))
      else if (child.localName = 'recurrenceId') then
        value.recurrenceIdElement := ParsePositiveInt(child, path+'/recurrenceId')
      else if (child.localName = 'occurrenceChanged') then
        value.occurrenceChangedElement := ParseBoolean(child, path+'/occurrenceChanged')
      else if (child.localName = 'recurrenceTemplate') then
        value.recurrenceTemplateList.Add(ParseAppointmentRecurrenceTemplate(child, path+'/recurrenceTemplate'))
      else if Not ParseDomainResourceChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeAppointment(xml : TXmlBuilder; name : String; value : TFhirAppointment);
begin
  if (value = nil) then
    exit;
  composeDomainResourceAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeAppointmentChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeAppointmentChildren(xml : TXmlBuilder; value : TFhirAppointment);
var
  i : integer;
begin
  composeDomainResourceChildren(xml, value);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.identifierList.Count - 1 do
      ComposeIdentifier(xml, 'identifier', value.identifierList[i]);
  ComposeEnum(xml, 'status', value.statusElement, CODES_TFhirAppointmentStatusEnum);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(xml, 'cancellationReason', value.cancellationReason);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.class_List.Count - 1 do
      ComposeCodeableConcept(xml, 'class', value.class_List[i]);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.serviceCategoryList.Count - 1 do
      ComposeCodeableConcept(xml, 'serviceCategory', value.serviceCategoryList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.serviceTypeList.Count - 1 do
      ComposeCodeableReference(xml, 'serviceType', value.serviceTypeList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.specialtyList.Count - 1 do
      ComposeCodeableConcept(xml, 'specialty', value.specialtyList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(xml, 'appointmentType', value.appointmentType);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.reasonList.Count - 1 do
      ComposeCodeableReference(xml, 'reason', value.reasonList[i]);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(xml, 'priority', value.priority);
  if (SummaryOption in [soFull, soData]) then
    ComposeString(xml, 'description', value.descriptionElement);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.replacesList.Count - 1 do
      ComposeReference(xml, 'replaces', value.replacesList[i]);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.virtualServiceList.Count - 1 do
      ComposeVirtualServiceDetail(xml, 'virtualService', value.virtualServiceList[i]);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.supportingInformationList.Count - 1 do
      ComposeReference(xml, 'supportingInformation', value.supportingInformationList[i]);
  if (SummaryOption in [soFull, soData]) then
    ComposeReference(xml, 'previousAppointment', value.previousAppointment);
  if (SummaryOption in [soFull, soData]) then
    ComposeReference(xml, 'originatingAppointment', value.originatingAppointment);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeInstant(xml, 'start', value.startElement);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeInstant(xml, 'end', value.end_Element);
  if (SummaryOption in [soFull, soData]) then
    ComposePositiveInt(xml, 'minutesDuration', value.minutesDurationElement);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.slotList.Count - 1 do
      ComposeReference(xml, 'slot', value.slotList[i]);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.accountList.Count - 1 do
      ComposeReference(xml, 'account', value.accountList[i]);
  if (SummaryOption in [soFull, soData]) then
    ComposeDateTime(xml, 'created', value.createdElement);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.noteList.Count - 1 do
      ComposeAnnotation(xml, 'note', value.noteList[i]);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.patientInstructionList.Count - 1 do
      ComposeCodeableReference(xml, 'patientInstruction', value.patientInstructionList[i]);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.basedOnList.Count - 1 do
      ComposeReference(xml, 'basedOn', value.basedOnList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference(xml, 'subject', value.subject);
  for i := 0 to value.participantList.Count - 1 do
      ComposeAppointmentParticipant(xml, 'participant', value.participantList[i]);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.requestedPeriodList.Count - 1 do
      ComposePeriod(xml, 'requestedPeriod', value.requestedPeriodList[i]);
  if (SummaryOption in [soFull, soData]) then
    ComposePositiveInt(xml, 'recurrenceId', value.recurrenceIdElement);
  if (SummaryOption in [soFull, soData]) then
    ComposeBoolean(xml, 'occurrenceChanged', value.occurrenceChangedElement);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.recurrenceTemplateList.Count - 1 do
      ComposeAppointmentRecurrenceTemplate(xml, 'recurrenceTemplate', value.recurrenceTemplateList[i]);
end;

{$ENDIF FHIR_APPOINTMENT}
{$IFDEF FHIR_APPOINTMENTRESPONSE}
function TFHIRXmlParser.ParseAppointmentResponse(element : TMXmlElement; path : string) : TFhirAppointmentResponse;
var
  child : TMXmlElement;
begin
  result := TFhirAppointmentResponse.Create;
  try
    parseDomainResourceAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseAppointmentResponseChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseAppointmentResponseChild(value : TFhirAppointmentResponse; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'identifier') then
        value.identifierList.Add(ParseIdentifier(child, path+'/identifier'))
      else if (child.localName = 'appointment') then
        value.appointment := ParseReference(child, path+'/appointment')
      else if (child.localName = 'proposedNewTime') then
        value.proposedNewTimeElement := ParseBoolean(child, path+'/proposedNewTime')
      else if (child.localName = 'start') then
        value.startElement := ParseInstant(child, path+'/start')
      else if (child.localName = 'end') then
        value.end_Element := ParseInstant(child, path+'/end')
      else if (child.localName = 'participantType') then
        value.participantTypeList.Add(ParseCodeableConcept(child, path+'/participantType'))
      else if (child.localName = 'actor') then
        value.actor := ParseReference(child, path+'/actor')
      else if (child.localName = 'participantStatus') then
        value.participantStatusElement := ParseEnum(CODES_TFhirParticipationStatusEnum, SYSTEMS_TFhirParticipationStatusEnum, child, path+'/participantStatus')
      else if (child.localName = 'comment') then
        value.commentElement := ParseString(child, path+'/comment')
      else if (child.localName = 'recurring') then
        value.recurringElement := ParseBoolean(child, path+'/recurring')
      else if (child.localName = 'occurrenceDate') then
        value.occurrenceDateElement := ParseDate(child, path+'/occurrenceDate')
      else if (child.localName = 'recurrenceId') then
        value.recurrenceIdElement := ParsePositiveInt(child, path+'/recurrenceId')
      else if Not ParseDomainResourceChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeAppointmentResponse(xml : TXmlBuilder; name : String; value : TFhirAppointmentResponse);
begin
  if (value = nil) then
    exit;
  composeDomainResourceAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeAppointmentResponseChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeAppointmentResponseChildren(xml : TXmlBuilder; value : TFhirAppointmentResponse);
var
  i : integer;
begin
  composeDomainResourceChildren(xml, value);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.identifierList.Count - 1 do
      ComposeIdentifier(xml, 'identifier', value.identifierList[i]);
  ComposeReference(xml, 'appointment', value.appointment);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeBoolean(xml, 'proposedNewTime', value.proposedNewTimeElement);
  if (SummaryOption in [soFull, soData]) then
    ComposeInstant(xml, 'start', value.startElement);
  if (SummaryOption in [soFull, soData]) then
    ComposeInstant(xml, 'end', value.end_Element);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.participantTypeList.Count - 1 do
      ComposeCodeableConcept(xml, 'participantType', value.participantTypeList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference(xml, 'actor', value.actor);
  ComposeEnum(xml, 'participantStatus', value.participantStatusElement, CODES_TFhirParticipationStatusEnum);
  if (SummaryOption in [soFull, soData]) then
    ComposeString(xml, 'comment', value.commentElement);
  if (SummaryOption in [soFull, soData]) then
    ComposeBoolean(xml, 'recurring', value.recurringElement);
  if (SummaryOption in [soFull, soData]) then
    ComposeDate(xml, 'occurrenceDate', value.occurrenceDateElement);
  if (SummaryOption in [soFull, soData]) then
    ComposePositiveInt(xml, 'recurrenceId', value.recurrenceIdElement);
end;

{$ENDIF FHIR_APPOINTMENTRESPONSE}
{$IFDEF FHIR_ARTIFACTASSESSMENT}
function TFHIRXmlParser.ParseArtifactAssessmentContent(element : TMXmlElement; path : string) : TFhirArtifactAssessmentContent;
var
  child : TMXmlElement;
begin
  result := TFhirArtifactAssessmentContent.Create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseArtifactAssessmentContentChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseArtifactAssessmentContentChild(value : TFhirArtifactAssessmentContent; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'informationType') then
        value.informationTypeElement := ParseEnum(CODES_TFhirArtifactAssessmentInformationTypeEnum, SYSTEMS_TFhirArtifactAssessmentInformationTypeEnum, child, path+'/informationType')
      else if (child.localName = 'summary') then
        value.summaryElement := ParseMarkdown(child, path+'/summary')
      else if (child.localName = 'type') then
        value.type_ := ParseCodeableConcept(child, path+'/type')
      else if (child.localName = 'classifier') then
        value.classifierList.Add(ParseCodeableConcept(child, path+'/classifier'))
      else if (child.localName = 'author') then
        value.author := ParseReference(child, path+'/author')
      else if (child.localName = 'path') then
        value.pathList.Add(ParseUri(child, path+'/path'))
      else if (child.localName = 'relatedArtifact') then
        value.relatedArtifactList.Add(ParseRelatedArtifact(child, path+'/relatedArtifact'))
      else if (child.localName = 'freeToShare') then
        value.freeToShareElement := ParseBoolean(child, path+'/freeToShare')
      else if (child.localName = 'component') then
        value.componentList.Add(ParseArtifactAssessmentContent(child, path+'/component'))
      else if Not ParseBackboneElementChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeArtifactAssessmentContent(xml : TXmlBuilder; name : String; value : TFhirArtifactAssessmentContent);
begin
  if (value = nil) then
    exit;
  composeElementAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeArtifactAssessmentContentChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeArtifactAssessmentContentChildren(xml : TXmlBuilder; value : TFhirArtifactAssessmentContent);
var
  i : integer;
begin
  composeBackboneElementChildren(xml, value);
  if (SummaryOption in [soFull, soData]) then
    ComposeEnum(xml, 'informationType', value.informationTypeElement, CODES_TFhirArtifactAssessmentInformationTypeEnum);
  if (SummaryOption in [soFull, soData]) then
    ComposeMarkdown(xml, 'summary', value.summaryElement);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(xml, 'type', value.type_);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.classifierList.Count - 1 do
      ComposeCodeableConcept(xml, 'classifier', value.classifierList[i]);
  if (SummaryOption in [soFull, soData]) then
    ComposeReference(xml, 'author', value.author);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.pathList.Count - 1 do
      ComposeUri(xml, 'path', value.pathList[i]);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.relatedArtifactList.Count - 1 do
      ComposeRelatedArtifact(xml, 'relatedArtifact', value.relatedArtifactList[i]);
  if (SummaryOption in [soFull, soData]) then
    ComposeBoolean(xml, 'freeToShare', value.freeToShareElement);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.componentList.Count - 1 do
      ComposeArtifactAssessmentContent(xml, 'component', value.componentList[i]);
end;

function TFHIRXmlParser.ParseArtifactAssessment(element : TMXmlElement; path : string) : TFhirArtifactAssessment;
var
  child : TMXmlElement;
begin
  result := TFhirArtifactAssessment.Create;
  try
    parseDomainResourceAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseArtifactAssessmentChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseArtifactAssessmentChild(value : TFhirArtifactAssessment; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'identifier') then
        value.identifierList.Add(ParseIdentifier(child, path+'/identifier'))
      else if (child.localName = 'citeAsReference') then
        value.citeAs := ParseReference(child, path+'/citeAsReference')
      else if (child.localName = 'citeAsMarkdown') then
        value.citeAs := ParseMarkdown(child, path+'/citeAsMarkdown')
      else if (child.localName = 'date') then
        value.dateElement := ParseDateTime(child, path+'/date')
      else if (child.localName = 'copyright') then
        value.copyrightElement := ParseMarkdown(child, path+'/copyright')
      else if (child.localName = 'approvalDate') then
        value.approvalDateElement := ParseDate(child, path+'/approvalDate')
      else if (child.localName = 'lastReviewDate') then
        value.lastReviewDateElement := ParseDate(child, path+'/lastReviewDate')
      else if (child.localName = 'artifactReference') then
        value.artifact := ParseReference(child, path+'/artifactReference')
      else if (child.localName = 'artifactCanonical') then
        value.artifact := ParseCanonical(child, path+'/artifactCanonical')
      else if (child.localName = 'artifactUri') then
        value.artifact := ParseUri(child, path+'/artifactUri')
      else if (child.localName = 'content') then
        value.contentList.Add(ParseArtifactAssessmentContent(child, path+'/content'))
      else if (child.localName = 'workflowStatus') then
        value.workflowStatusElement := ParseEnum(CODES_TFhirArtifactAssessmentWorkflowStatusEnum, SYSTEMS_TFhirArtifactAssessmentWorkflowStatusEnum, child, path+'/workflowStatus')
      else if (child.localName = 'disposition') then
        value.dispositionElement := ParseEnum(CODES_TFhirArtifactAssessmentDispositionEnum, SYSTEMS_TFhirArtifactAssessmentDispositionEnum, child, path+'/disposition')
      else if Not ParseDomainResourceChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeArtifactAssessment(xml : TXmlBuilder; name : String; value : TFhirArtifactAssessment);
begin
  if (value = nil) then
    exit;
  composeDomainResourceAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeArtifactAssessmentChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeArtifactAssessmentChildren(xml : TXmlBuilder; value : TFhirArtifactAssessment);
var
  i : integer;
begin
  composeDomainResourceChildren(xml, value);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.identifierList.Count - 1 do
      ComposeIdentifier(xml, 'identifier', value.identifierList[i]);
  if (SummaryOption in [soFull, soData]) and (value.citeAs is TFhirReference) {2} then
    ComposeReference(xml, 'citeAsReference', TFhirReference(value.citeAs))
  else if (SummaryOption in [soFull, soData]) and (value.citeAs is TFhirMarkdown) {6} then
    ComposeMarkdown(xml, 'citeAsMarkdown', TFhirMarkdown(value.citeAs));
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDateTime(xml, 'date', value.dateElement);
  if (SummaryOption in [soFull, soData]) then
    ComposeMarkdown(xml, 'copyright', value.copyrightElement);
  if (SummaryOption in [soFull, soData]) then
    ComposeDate(xml, 'approvalDate', value.approvalDateElement);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDate(xml, 'lastReviewDate', value.lastReviewDateElement);
  if (value.artifact is TFhirReference) {2} then
    ComposeReference(xml, 'artifactReference', TFhirReference(value.artifact))
  else if (value.artifact is TFhirCanonical) {6} then
    ComposeCanonical(xml, 'artifactCanonical', TFhirCanonical(value.artifact))
  else if (value.artifact is TFhirUri) {6} then
    ComposeUri(xml, 'artifactUri', TFhirUri(value.artifact));
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.contentList.Count - 1 do
      ComposeArtifactAssessmentContent(xml, 'content', value.contentList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeEnum(xml, 'workflowStatus', value.workflowStatusElement, CODES_TFhirArtifactAssessmentWorkflowStatusEnum);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeEnum(xml, 'disposition', value.dispositionElement, CODES_TFhirArtifactAssessmentDispositionEnum);
end;

{$ENDIF FHIR_ARTIFACTASSESSMENT}
{$IFDEF FHIR_AUDITEVENT}
function TFHIRXmlParser.ParseAuditEventOutcome(element : TMXmlElement; path : string) : TFhirAuditEventOutcome;
var
  child : TMXmlElement;
begin
  result := TFhirAuditEventOutcome.Create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseAuditEventOutcomeChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseAuditEventOutcomeChild(value : TFhirAuditEventOutcome; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'code') then
        value.code := ParseCoding(child, path+'/code')
      else if (child.localName = 'detail') then
        value.detailList.Add(ParseCodeableConcept(child, path+'/detail'))
      else if Not ParseBackboneElementChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeAuditEventOutcome(xml : TXmlBuilder; name : String; value : TFhirAuditEventOutcome);
begin
  if (value = nil) then
    exit;
  composeElementAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeAuditEventOutcomeChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeAuditEventOutcomeChildren(xml : TXmlBuilder; value : TFhirAuditEventOutcome);
var
  i : integer;
begin
  composeBackboneElementChildren(xml, value);
  ComposeCoding(xml, 'code', value.code);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.detailList.Count - 1 do
      ComposeCodeableConcept(xml, 'detail', value.detailList[i]);
end;

function TFHIRXmlParser.ParseAuditEventAgent(element : TMXmlElement; path : string) : TFhirAuditEventAgent;
var
  child : TMXmlElement;
begin
  result := TFhirAuditEventAgent.Create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseAuditEventAgentChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseAuditEventAgentChild(value : TFhirAuditEventAgent; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'type') then
        value.type_ := ParseCodeableConcept(child, path+'/type')
      else if (child.localName = 'role') then
        value.roleList.Add(ParseCodeableConcept(child, path+'/role'))
      else if (child.localName = 'who') then
        value.who := ParseReference(child, path+'/who')
      else if (child.localName = 'requestor') then
        value.requestorElement := ParseBoolean(child, path+'/requestor')
      else if (child.localName = 'location') then
        value.location := ParseReference(child, path+'/location')
      else if (child.localName = 'policy') then
        value.policyList.Add(ParseUri(child, path+'/policy'))
      else if (child.localName = 'networkReference') then
        value.network := ParseReference(child, path+'/networkReference')
      else if (child.localName = 'networkUri') then
        value.network := ParseUri(child, path+'/networkUri')
      else if (child.localName = 'networkString') then
        value.network := ParseString(child, path+'/networkString')
      else if (child.localName = 'authorization') then
        value.authorizationList.Add(ParseCodeableConcept(child, path+'/authorization'))
      else if Not ParseBackboneElementChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeAuditEventAgent(xml : TXmlBuilder; name : String; value : TFhirAuditEventAgent);
begin
  if (value = nil) then
    exit;
  composeElementAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeAuditEventAgentChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeAuditEventAgentChildren(xml : TXmlBuilder; value : TFhirAuditEventAgent);
var
  i : integer;
begin
  composeBackboneElementChildren(xml, value);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(xml, 'type', value.type_);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.roleList.Count - 1 do
      ComposeCodeableConcept(xml, 'role', value.roleList[i]);
  ComposeReference(xml, 'who', value.who);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeBoolean(xml, 'requestor', value.requestorElement);
  if (SummaryOption in [soFull, soData]) then
    ComposeReference(xml, 'location', value.location);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.policyList.Count - 1 do
      ComposeUri(xml, 'policy', value.policyList[i]);
  if (SummaryOption in [soFull, soData]) and (value.network is TFhirReference) {2} then
    ComposeReference(xml, 'networkReference', TFhirReference(value.network))
  else if (SummaryOption in [soFull, soData]) and (value.network is TFhirUri) {6} then
    ComposeUri(xml, 'networkUri', TFhirUri(value.network))
  else if (SummaryOption in [soFull, soData]) and (value.network is TFhirString) {6} then
    ComposeString(xml, 'networkString', TFhirString(value.network));
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.authorizationList.Count - 1 do
      ComposeCodeableConcept(xml, 'authorization', value.authorizationList[i]);
end;

function TFHIRXmlParser.ParseAuditEventSource(element : TMXmlElement; path : string) : TFhirAuditEventSource;
var
  child : TMXmlElement;
begin
  result := TFhirAuditEventSource.Create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseAuditEventSourceChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseAuditEventSourceChild(value : TFhirAuditEventSource; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'site') then
        value.site := ParseReference(child, path+'/site')
      else if (child.localName = 'observer') then
        value.observer := ParseReference(child, path+'/observer')
      else if (child.localName = 'type') then
        value.type_List.Add(ParseCodeableConcept(child, path+'/type'))
      else if Not ParseBackboneElementChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeAuditEventSource(xml : TXmlBuilder; name : String; value : TFhirAuditEventSource);
begin
  if (value = nil) then
    exit;
  composeElementAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeAuditEventSourceChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeAuditEventSourceChildren(xml : TXmlBuilder; value : TFhirAuditEventSource);
var
  i : integer;
begin
  composeBackboneElementChildren(xml, value);
  if (SummaryOption in [soFull, soData]) then
    ComposeReference(xml, 'site', value.site);
  ComposeReference(xml, 'observer', value.observer);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.type_List.Count - 1 do
      ComposeCodeableConcept(xml, 'type', value.type_List[i]);
end;

function TFHIRXmlParser.ParseAuditEventEntity(element : TMXmlElement; path : string) : TFhirAuditEventEntity;
var
  child : TMXmlElement;
begin
  result := TFhirAuditEventEntity.Create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseAuditEventEntityChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseAuditEventEntityChild(value : TFhirAuditEventEntity; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'what') then
        value.what := ParseReference(child, path+'/what')
      else if (child.localName = 'role') then
        value.role := ParseCodeableConcept(child, path+'/role')
      else if (child.localName = 'securityLabel') then
        value.securityLabelList.Add(ParseCodeableConcept(child, path+'/securityLabel'))
      else if (child.localName = 'query') then
        value.queryElement := ParseBase64Binary(child, path+'/query')
      else if (child.localName = 'detail') then
        value.detailList.Add(ParseAuditEventEntityDetail(child, path+'/detail'))
      else if (child.localName = 'agent') then
        value.agentList.Add(ParseAuditEventAgent(child, path+'/agent'))
      else if Not ParseBackboneElementChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeAuditEventEntity(xml : TXmlBuilder; name : String; value : TFhirAuditEventEntity);
begin
  if (value = nil) then
    exit;
  composeElementAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeAuditEventEntityChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeAuditEventEntityChildren(xml : TXmlBuilder; value : TFhirAuditEventEntity);
var
  i : integer;
begin
  composeBackboneElementChildren(xml, value);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference(xml, 'what', value.what);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(xml, 'role', value.role);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.securityLabelList.Count - 1 do
      ComposeCodeableConcept(xml, 'securityLabel', value.securityLabelList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeBase64Binary(xml, 'query', value.queryElement);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.detailList.Count - 1 do
      ComposeAuditEventEntityDetail(xml, 'detail', value.detailList[i]);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.agentList.Count - 1 do
      ComposeAuditEventAgent(xml, 'agent', value.agentList[i]);
end;

function TFHIRXmlParser.ParseAuditEventEntityDetail(element : TMXmlElement; path : string) : TFhirAuditEventEntityDetail;
var
  child : TMXmlElement;
begin
  result := TFhirAuditEventEntityDetail.Create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseAuditEventEntityDetailChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseAuditEventEntityDetailChild(value : TFhirAuditEventEntityDetail; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'type') then
        value.type_ := ParseCodeableConcept(child, path+'/type')
      else if (child.localName = 'valueQuantity') then
        value.value := ParseQuantity(child, path+'/valueQuantity')
      else if (child.localName = 'valueCodeableConcept') then
        value.value := ParseCodeableConcept(child, path+'/valueCodeableConcept')
      else if (child.localName = 'valueRange') then
        value.value := ParseRange(child, path+'/valueRange')
      else if (child.localName = 'valueRatio') then
        value.value := ParseRatio(child, path+'/valueRatio')
      else if (child.localName = 'valuePeriod') then
        value.value := ParsePeriod(child, path+'/valuePeriod')
      else if (child.localName = 'valueString') then
        value.value := ParseString(child, path+'/valueString')
      else if (child.localName = 'valueBoolean') then
        value.value := ParseBoolean(child, path+'/valueBoolean')
      else if (child.localName = 'valueInteger') then
        value.value := ParseInteger(child, path+'/valueInteger')
      else if (child.localName = 'valueTime') then
        value.value := ParseTime(child, path+'/valueTime')
      else if (child.localName = 'valueDateTime') then
        value.value := ParseDateTime(child, path+'/valueDateTime')
      else if (child.localName = 'valueBase64Binary') then
        value.value := ParseBase64Binary(child, path+'/valueBase64Binary')
      else if Not ParseBackboneElementChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeAuditEventEntityDetail(xml : TXmlBuilder; name : String; value : TFhirAuditEventEntityDetail);
begin
  if (value = nil) then
    exit;
  composeElementAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeAuditEventEntityDetailChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeAuditEventEntityDetailChildren(xml : TXmlBuilder; value : TFhirAuditEventEntityDetail);
begin
  composeBackboneElementChildren(xml, value);
  ComposeCodeableConcept(xml, 'type', value.type_);
  if (value.value is TFhirQuantity) {6} then
    ComposeQuantity(xml, 'valueQuantity', TFhirQuantity(value.value))
  else if (value.value is TFhirCodeableConcept) {6} then
    ComposeCodeableConcept(xml, 'valueCodeableConcept', TFhirCodeableConcept(value.value))
  else if (value.value is TFhirRange) {6} then
    ComposeRange(xml, 'valueRange', TFhirRange(value.value))
  else if (value.value is TFhirRatio) {6} then
    ComposeRatio(xml, 'valueRatio', TFhirRatio(value.value))
  else if (value.value is TFhirPeriod) {6} then
    ComposePeriod(xml, 'valuePeriod', TFhirPeriod(value.value))
  else if (value.value is TFhirString) {6} then
    ComposeString(xml, 'valueString', TFhirString(value.value))
  else if (value.value is TFhirBoolean) {6} then
    ComposeBoolean(xml, 'valueBoolean', TFhirBoolean(value.value))
  else if (value.value is TFhirInteger) {6} then
    ComposeInteger(xml, 'valueInteger', TFhirInteger(value.value))
  else if (value.value is TFhirTime) {6} then
    ComposeTime(xml, 'valueTime', TFhirTime(value.value))
  else if (value.value is TFhirDateTime) {6} then
    ComposeDateTime(xml, 'valueDateTime', TFhirDateTime(value.value))
  else if (value.value is TFhirBase64Binary) {6} then
    ComposeBase64Binary(xml, 'valueBase64Binary', TFhirBase64Binary(value.value));
end;

function TFHIRXmlParser.ParseAuditEvent(element : TMXmlElement; path : string) : TFhirAuditEvent;
var
  child : TMXmlElement;
begin
  result := TFhirAuditEvent.Create;
  try
    parseDomainResourceAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseAuditEventChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseAuditEventChild(value : TFhirAuditEvent; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'category') then
        value.categoryList.Add(ParseCodeableConcept(child, path+'/category'))
      else if (child.localName = 'code') then
        value.code := ParseCodeableConcept(child, path+'/code')
      else if (child.localName = 'action') then
        value.actionElement := ParseEnum(CODES_TFhirAuditEventActionEnum, SYSTEMS_TFhirAuditEventActionEnum, child, path+'/action')
      else if (child.localName = 'severity') then
        value.severityElement := ParseEnum(CODES_TFhirAuditEventSeverityEnum, SYSTEMS_TFhirAuditEventSeverityEnum, child, path+'/severity')
      else if (child.localName = 'occurredPeriod') then
        value.occurred := ParsePeriod(child, path+'/occurredPeriod')
      else if (child.localName = 'occurredDateTime') then
        value.occurred := ParseDateTime(child, path+'/occurredDateTime')
      else if (child.localName = 'recorded') then
        value.recordedElement := ParseInstant(child, path+'/recorded')
      else if (child.localName = 'outcome') then
        value.outcome := ParseAuditEventOutcome(child, path+'/outcome')
      else if (child.localName = 'authorization') then
        value.authorizationList.Add(ParseCodeableConcept(child, path+'/authorization'))
      else if (child.localName = 'basedOn') then
        value.basedOnList.Add(ParseReference(child, path+'/basedOn'))
      else if (child.localName = 'patient') then
        value.patient := ParseReference(child, path+'/patient')
      else if (child.localName = 'encounter') then
        value.encounter := ParseReference(child, path+'/encounter')
      else if (child.localName = 'agent') then
        value.agentList.Add(ParseAuditEventAgent(child, path+'/agent'))
      else if (child.localName = 'source') then
        value.source := ParseAuditEventSource(child, path+'/source')
      else if (child.localName = 'entity') then
        value.entityList.Add(ParseAuditEventEntity(child, path+'/entity'))
      else if Not ParseDomainResourceChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeAuditEvent(xml : TXmlBuilder; name : String; value : TFhirAuditEvent);
begin
  if (value = nil) then
    exit;
  composeDomainResourceAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeAuditEventChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeAuditEventChildren(xml : TXmlBuilder; value : TFhirAuditEvent);
var
  i : integer;
begin
  composeDomainResourceChildren(xml, value);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.categoryList.Count - 1 do
      ComposeCodeableConcept(xml, 'category', value.categoryList[i]);
  ComposeCodeableConcept(xml, 'code', value.code);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeEnum(xml, 'action', value.actionElement, CODES_TFhirAuditEventActionEnum);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeEnum(xml, 'severity', value.severityElement, CODES_TFhirAuditEventSeverityEnum);
  if (SummaryOption in [soFull, soData]) and (value.occurred is TFhirPeriod) {6} then
    ComposePeriod(xml, 'occurredPeriod', TFhirPeriod(value.occurred))
  else if (SummaryOption in [soFull, soData]) and (value.occurred is TFhirDateTime) {6} then
    ComposeDateTime(xml, 'occurredDateTime', TFhirDateTime(value.occurred));
  ComposeInstant(xml, 'recorded', value.recordedElement);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeAuditEventOutcome(xml, 'outcome', value.outcome);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.authorizationList.Count - 1 do
      ComposeCodeableConcept(xml, 'authorization', value.authorizationList[i]);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.basedOnList.Count - 1 do
      ComposeReference(xml, 'basedOn', value.basedOnList[i]);
  if (SummaryOption in [soFull, soData]) then
    ComposeReference(xml, 'patient', value.patient);
  if (SummaryOption in [soFull, soData]) then
    ComposeReference(xml, 'encounter', value.encounter);
  for i := 0 to value.agentList.Count - 1 do
      ComposeAuditEventAgent(xml, 'agent', value.agentList[i]);
  ComposeAuditEventSource(xml, 'source', value.source);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.entityList.Count - 1 do
      ComposeAuditEventEntity(xml, 'entity', value.entityList[i]);
end;

{$ENDIF FHIR_AUDITEVENT}
{$IFDEF FHIR_BASIC}
function TFHIRXmlParser.ParseBasic(element : TMXmlElement; path : string) : TFhirBasic;
var
  child : TMXmlElement;
begin
  result := TFhirBasic.Create;
  try
    parseDomainResourceAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseBasicChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseBasicChild(value : TFhirBasic; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'identifier') then
        value.identifierList.Add(ParseIdentifier(child, path+'/identifier'))
      else if (child.localName = 'code') then
        value.code := ParseCodeableConcept(child, path+'/code')
      else if (child.localName = 'subject') then
        value.subject := ParseReference(child, path+'/subject')
      else if (child.localName = 'created') then
        value.createdElement := ParseDateTime(child, path+'/created')
      else if (child.localName = 'author') then
        value.author := ParseReference(child, path+'/author')
      else if Not ParseDomainResourceChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeBasic(xml : TXmlBuilder; name : String; value : TFhirBasic);
begin
  if (value = nil) then
    exit;
  composeDomainResourceAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeBasicChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeBasicChildren(xml : TXmlBuilder; value : TFhirBasic);
var
  i : integer;
begin
  composeDomainResourceChildren(xml, value);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.identifierList.Count - 1 do
      ComposeIdentifier(xml, 'identifier', value.identifierList[i]);
  ComposeCodeableConcept(xml, 'code', value.code);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference(xml, 'subject', value.subject);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDateTime(xml, 'created', value.createdElement);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference(xml, 'author', value.author);
end;

{$ENDIF FHIR_BASIC}
{$IFDEF FHIR_BINARY}
function TFHIRXmlParser.ParseBinary(element : TMXmlElement; path : string) : TFhirBinary;
var
  child : TMXmlElement;
begin
  result := TFhirBinary.Create;
  try
    parseResourceAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseBinaryChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseBinaryChild(value : TFhirBinary; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'contentType') then
        value.contentTypeElement := ParseCode(child, path+'/contentType')
      else if (child.localName = 'securityContext') then
        value.securityContext := ParseReference(child, path+'/securityContext')
      else if (child.localName = 'data') then
        value.dataElement := ParseBase64Binary(child, path+'/data')
      else if Not ParseResourceChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeBinary(xml : TXmlBuilder; name : String; value : TFhirBinary);
begin
  if (value = nil) then
    exit;
  composeResourceAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeBinaryChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeBinaryChildren(xml : TXmlBuilder; value : TFhirBinary);
begin
  composeResourceChildren(xml, value);
  ComposeCode(xml, 'contentType', value.contentTypeElement);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference(xml, 'securityContext', value.securityContext);
  if (SummaryOption in [soFull, soData]) then
    ComposeBase64Binary(xml, 'data', value.dataElement);
end;

{$ENDIF FHIR_BINARY}
{$IFDEF FHIR_BIOLOGICALLYDERIVEDPRODUCT}
function TFHIRXmlParser.ParseBiologicallyDerivedProductCollection(element : TMXmlElement; path : string) : TFhirBiologicallyDerivedProductCollection;
var
  child : TMXmlElement;
begin
  result := TFhirBiologicallyDerivedProductCollection.Create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseBiologicallyDerivedProductCollectionChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseBiologicallyDerivedProductCollectionChild(value : TFhirBiologicallyDerivedProductCollection; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'collector') then
        value.collector := ParseReference(child, path+'/collector')
      else if (child.localName = 'source') then
        value.source := ParseReference(child, path+'/source')
      else if (child.localName = 'collectedPeriod') then
        value.collected := ParsePeriod(child, path+'/collectedPeriod')
      else if (child.localName = 'collectedDateTime') then
        value.collected := ParseDateTime(child, path+'/collectedDateTime')
      else if Not ParseBackboneElementChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeBiologicallyDerivedProductCollection(xml : TXmlBuilder; name : String; value : TFhirBiologicallyDerivedProductCollection);
begin
  if (value = nil) then
    exit;
  composeElementAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeBiologicallyDerivedProductCollectionChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeBiologicallyDerivedProductCollectionChildren(xml : TXmlBuilder; value : TFhirBiologicallyDerivedProductCollection);
begin
  composeBackboneElementChildren(xml, value);
  if (SummaryOption in [soFull, soData]) then
    ComposeReference(xml, 'collector', value.collector);
  if (SummaryOption in [soFull, soData]) then
    ComposeReference(xml, 'source', value.source);
  if (SummaryOption in [soFull, soData]) and (value.collected is TFhirPeriod) {6} then
    ComposePeriod(xml, 'collectedPeriod', TFhirPeriod(value.collected))
  else if (SummaryOption in [soFull, soData]) and (value.collected is TFhirDateTime) {6} then
    ComposeDateTime(xml, 'collectedDateTime', TFhirDateTime(value.collected));
end;

function TFHIRXmlParser.ParseBiologicallyDerivedProductProperty(element : TMXmlElement; path : string) : TFhirBiologicallyDerivedProductProperty;
var
  child : TMXmlElement;
begin
  result := TFhirBiologicallyDerivedProductProperty.Create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseBiologicallyDerivedProductPropertyChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseBiologicallyDerivedProductPropertyChild(value : TFhirBiologicallyDerivedProductProperty; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'type') then
        value.type_ := ParseCoding(child, path+'/type')
      else if (child.localName = 'valueCodeableConcept') then
        value.value := ParseCodeableConcept(child, path+'/valueCodeableConcept')
      else if (child.localName = 'valuePeriod') then
        value.value := ParsePeriod(child, path+'/valuePeriod')
      else if (child.localName = 'valueQuantity') then
        value.value := ParseQuantity(child, path+'/valueQuantity')
      else if (child.localName = 'valueRange') then
        value.value := ParseRange(child, path+'/valueRange')
      else if (child.localName = 'valueRatio') then
        value.value := ParseRatio(child, path+'/valueRatio')
      else if (child.localName = 'valueAttachment') then
        value.value := ParseAttachment(child, path+'/valueAttachment')
      else if (child.localName = 'valueBoolean') then
        value.value := ParseBoolean(child, path+'/valueBoolean')
      else if (child.localName = 'valueInteger') then
        value.value := ParseInteger(child, path+'/valueInteger')
      else if (child.localName = 'valueString') then
        value.value := ParseString(child, path+'/valueString')
      else if Not ParseBackboneElementChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeBiologicallyDerivedProductProperty(xml : TXmlBuilder; name : String; value : TFhirBiologicallyDerivedProductProperty);
begin
  if (value = nil) then
    exit;
  composeElementAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeBiologicallyDerivedProductPropertyChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeBiologicallyDerivedProductPropertyChildren(xml : TXmlBuilder; value : TFhirBiologicallyDerivedProductProperty);
begin
  composeBackboneElementChildren(xml, value);
  ComposeCoding(xml, 'type', value.type_);
  if (value.value is TFhirCodeableConcept) {6} then
    ComposeCodeableConcept(xml, 'valueCodeableConcept', TFhirCodeableConcept(value.value))
  else if (value.value is TFhirPeriod) {6} then
    ComposePeriod(xml, 'valuePeriod', TFhirPeriod(value.value))
  else if (value.value is TFhirQuantity) {6} then
    ComposeQuantity(xml, 'valueQuantity', TFhirQuantity(value.value))
  else if (value.value is TFhirRange) {6} then
    ComposeRange(xml, 'valueRange', TFhirRange(value.value))
  else if (value.value is TFhirRatio) {6} then
    ComposeRatio(xml, 'valueRatio', TFhirRatio(value.value))
  else if (value.value is TFhirAttachment) {6} then
    ComposeAttachment(xml, 'valueAttachment', TFhirAttachment(value.value))
  else if (value.value is TFhirBoolean) {6} then
    ComposeBoolean(xml, 'valueBoolean', TFhirBoolean(value.value))
  else if (value.value is TFhirInteger) {6} then
    ComposeInteger(xml, 'valueInteger', TFhirInteger(value.value))
  else if (value.value is TFhirString) {6} then
    ComposeString(xml, 'valueString', TFhirString(value.value));
end;

function TFHIRXmlParser.ParseBiologicallyDerivedProduct(element : TMXmlElement; path : string) : TFhirBiologicallyDerivedProduct;
var
  child : TMXmlElement;
begin
  result := TFhirBiologicallyDerivedProduct.Create;
  try
    parseDomainResourceAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseBiologicallyDerivedProductChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseBiologicallyDerivedProductChild(value : TFhirBiologicallyDerivedProduct; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'productCategory') then
        value.productCategory := ParseCoding(child, path+'/productCategory')
      else if (child.localName = 'productCode') then
        value.productCode := ParseCodeableConcept(child, path+'/productCode')
      else if (child.localName = 'parent') then
        value.parentList.Add(ParseReference(child, path+'/parent'))
      else if (child.localName = 'request') then
        value.requestList.Add(ParseReference(child, path+'/request'))
      else if (child.localName = 'identifier') then
        value.identifierList.Add(ParseIdentifier(child, path+'/identifier'))
      else if (child.localName = 'biologicalSourceEvent') then
        value.biologicalSourceEvent := ParseIdentifier(child, path+'/biologicalSourceEvent')
      else if (child.localName = 'processingFacility') then
        value.processingFacilityList.Add(ParseReference(child, path+'/processingFacility'))
      else if (child.localName = 'division') then
        value.divisionElement := ParseString(child, path+'/division')
      else if (child.localName = 'productStatus') then
        value.productStatus := ParseCoding(child, path+'/productStatus')
      else if (child.localName = 'expirationDate') then
        value.expirationDateElement := ParseDateTime(child, path+'/expirationDate')
      else if (child.localName = 'collection') then
        value.collection := ParseBiologicallyDerivedProductCollection(child, path+'/collection')
      else if (child.localName = 'storageTempRequirements') then
        value.storageTempRequirements := ParseRange(child, path+'/storageTempRequirements')
      else if (child.localName = 'property') then
        value.property_List.Add(ParseBiologicallyDerivedProductProperty(child, path+'/property'))
      else if Not ParseDomainResourceChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeBiologicallyDerivedProduct(xml : TXmlBuilder; name : String; value : TFhirBiologicallyDerivedProduct);
begin
  if (value = nil) then
    exit;
  composeDomainResourceAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeBiologicallyDerivedProductChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeBiologicallyDerivedProductChildren(xml : TXmlBuilder; value : TFhirBiologicallyDerivedProduct);
var
  i : integer;
begin
  composeDomainResourceChildren(xml, value);
  if (SummaryOption in [soFull, soData]) then
    ComposeCoding(xml, 'productCategory', value.productCategory);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(xml, 'productCode', value.productCode);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.parentList.Count - 1 do
      ComposeReference(xml, 'parent', value.parentList[i]);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.requestList.Count - 1 do
      ComposeReference(xml, 'request', value.requestList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.identifierList.Count - 1 do
      ComposeIdentifier(xml, 'identifier', value.identifierList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeIdentifier(xml, 'biologicalSourceEvent', value.biologicalSourceEvent);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.processingFacilityList.Count - 1 do
      ComposeReference(xml, 'processingFacility', value.processingFacilityList[i]);
  if (SummaryOption in [soFull, soData]) then
    ComposeString(xml, 'division', value.divisionElement);
  if (SummaryOption in [soFull, soData]) then
    ComposeCoding(xml, 'productStatus', value.productStatus);
  if (SummaryOption in [soFull, soData]) then
    ComposeDateTime(xml, 'expirationDate', value.expirationDateElement);
  if (SummaryOption in [soFull, soData]) then
    ComposeBiologicallyDerivedProductCollection(xml, 'collection', value.collection);
  if (SummaryOption in [soFull, soData]) then
    ComposeRange(xml, 'storageTempRequirements', value.storageTempRequirements);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.property_List.Count - 1 do
      ComposeBiologicallyDerivedProductProperty(xml, 'property', value.property_List[i]);
end;

{$ENDIF FHIR_BIOLOGICALLYDERIVEDPRODUCT}
{$IFDEF FHIR_BODYSTRUCTURE}
function TFHIRXmlParser.ParseBodyStructureIncludedStructure(element : TMXmlElement; path : string) : TFhirBodyStructureIncludedStructure;
var
  child : TMXmlElement;
begin
  result := TFhirBodyStructureIncludedStructure.Create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseBodyStructureIncludedStructureChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseBodyStructureIncludedStructureChild(value : TFhirBodyStructureIncludedStructure; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'structure') then
        value.structure := ParseCodeableConcept(child, path+'/structure')
      else if (child.localName = 'laterality') then
        value.laterality := ParseCodeableConcept(child, path+'/laterality')
      else if (child.localName = 'qualifier') then
        value.qualifierList.Add(ParseCodeableConcept(child, path+'/qualifier'))
      else if Not ParseBackboneElementChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeBodyStructureIncludedStructure(xml : TXmlBuilder; name : String; value : TFhirBodyStructureIncludedStructure);
begin
  if (value = nil) then
    exit;
  composeElementAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeBodyStructureIncludedStructureChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeBodyStructureIncludedStructureChildren(xml : TXmlBuilder; value : TFhirBodyStructureIncludedStructure);
var
  i : integer;
begin
  composeBackboneElementChildren(xml, value);
  ComposeCodeableConcept(xml, 'structure', value.structure);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(xml, 'laterality', value.laterality);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.qualifierList.Count - 1 do
      ComposeCodeableConcept(xml, 'qualifier', value.qualifierList[i]);
end;

function TFHIRXmlParser.ParseBodyStructureExcludedStructure(element : TMXmlElement; path : string) : TFhirBodyStructureExcludedStructure;
var
  child : TMXmlElement;
begin
  result := TFhirBodyStructureExcludedStructure.Create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseBodyStructureExcludedStructureChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseBodyStructureExcludedStructureChild(value : TFhirBodyStructureExcludedStructure; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'structure') then
        value.structure := ParseCodeableConcept(child, path+'/structure')
      else if (child.localName = 'laterality') then
        value.laterality := ParseCodeableConcept(child, path+'/laterality')
      else if (child.localName = 'qualifier') then
        value.qualifierList.Add(ParseCodeableConcept(child, path+'/qualifier'))
      else if Not ParseBackboneElementChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeBodyStructureExcludedStructure(xml : TXmlBuilder; name : String; value : TFhirBodyStructureExcludedStructure);
begin
  if (value = nil) then
    exit;
  composeElementAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeBodyStructureExcludedStructureChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeBodyStructureExcludedStructureChildren(xml : TXmlBuilder; value : TFhirBodyStructureExcludedStructure);
var
  i : integer;
begin
  composeBackboneElementChildren(xml, value);
  ComposeCodeableConcept(xml, 'structure', value.structure);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(xml, 'laterality', value.laterality);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.qualifierList.Count - 1 do
      ComposeCodeableConcept(xml, 'qualifier', value.qualifierList[i]);
end;

function TFHIRXmlParser.ParseBodyStructure(element : TMXmlElement; path : string) : TFhirBodyStructure;
var
  child : TMXmlElement;
begin
  result := TFhirBodyStructure.Create;
  try
    parseDomainResourceAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseBodyStructureChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseBodyStructureChild(value : TFhirBodyStructure; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'identifier') then
        value.identifierList.Add(ParseIdentifier(child, path+'/identifier'))
      else if (child.localName = 'active') then
        value.activeElement := ParseBoolean(child, path+'/active')
      else if (child.localName = 'morphology') then
        value.morphology := ParseCodeableConcept(child, path+'/morphology')
      else if (child.localName = 'includedStructure') then
        value.includedStructureList.Add(ParseBodyStructureIncludedStructure(child, path+'/includedStructure'))
      else if (child.localName = 'excludedStructure') then
        value.excludedStructureList.Add(ParseBodyStructureExcludedStructure(child, path+'/excludedStructure'))
      else if (child.localName = 'description') then
        value.descriptionElement := ParseString(child, path+'/description')
      else if (child.localName = 'image') then
        value.imageList.Add(ParseAttachment(child, path+'/image'))
      else if (child.localName = 'patient') then
        value.patient := ParseReference(child, path+'/patient')
      else if Not ParseDomainResourceChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeBodyStructure(xml : TXmlBuilder; name : String; value : TFhirBodyStructure);
begin
  if (value = nil) then
    exit;
  composeDomainResourceAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeBodyStructureChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeBodyStructureChildren(xml : TXmlBuilder; value : TFhirBodyStructure);
var
  i : integer;
begin
  composeDomainResourceChildren(xml, value);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.identifierList.Count - 1 do
      ComposeIdentifier(xml, 'identifier', value.identifierList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeBoolean(xml, 'active', value.activeElement);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(xml, 'morphology', value.morphology);
  for i := 0 to value.includedStructureList.Count - 1 do
      ComposeBodyStructureIncludedStructure(xml, 'includedStructure', value.includedStructureList[i]);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.excludedStructureList.Count - 1 do
      ComposeBodyStructureExcludedStructure(xml, 'excludedStructure', value.excludedStructureList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(xml, 'description', value.descriptionElement);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.imageList.Count - 1 do
      ComposeAttachment(xml, 'image', value.imageList[i]);
  ComposeReference(xml, 'patient', value.patient);
end;

{$ENDIF FHIR_BODYSTRUCTURE}
{$IFDEF FHIR_BUNDLE}
function TFHIRXmlParser.ParseBundleLink(element : TMXmlElement; path : string) : TFhirBundleLink;
var
  child : TMXmlElement;
begin
  result := TFhirBundleLink.Create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseBundleLinkChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseBundleLinkChild(value : TFhirBundleLink; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'relation') then
        value.relationElement := ParseEnum(CODES_TFhirLinkRelationTypesEnum, SYSTEMS_TFhirLinkRelationTypesEnum, child, path+'/relation')
      else if (child.localName = 'url') then
        value.urlElement := ParseUri(child, path+'/url')
      else if Not ParseBackboneElementChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeBundleLink(xml : TXmlBuilder; name : String; value : TFhirBundleLink);
begin
  if (value = nil) then
    exit;
  composeElementAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeBundleLinkChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeBundleLinkChildren(xml : TXmlBuilder; value : TFhirBundleLink);
begin
  composeBackboneElementChildren(xml, value);
  ComposeEnum(xml, 'relation', value.relationElement, CODES_TFhirLinkRelationTypesEnum);
  ComposeUri(xml, 'url', value.urlElement);
end;

function TFHIRXmlParser.ParseBundleEntry(element : TMXmlElement; path : string) : TFhirBundleEntry;
var
  child : TMXmlElement;
begin
  result := TFhirBundleEntry.Create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseBundleEntryChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseBundleEntryChild(value : TFhirBundleEntry; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'link') then
        value.link_List.Add(ParseBundleLink(child, path+'/link'))
      else if (child.localName = 'fullUrl') then
        value.fullUrlElement := ParseUri(child, path+'/fullUrl')
      else if (child.localName = 'resource') then
        value.resource := ParseInnerResource(child, path+'/resource')
      else if (child.localName = 'search') then
        value.search := ParseBundleEntrySearch(child, path+'/search')
      else if (child.localName = 'request') then
        value.request := ParseBundleEntryRequest(child, path+'/request')
      else if (child.localName = 'response') then
        value.response := ParseBundleEntryResponse(child, path+'/response')
      else if Not ParseBackboneElementChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeBundleEntry(xml : TXmlBuilder; name : String; value : TFhirBundleEntry);
begin
  if (value = nil) then
    exit;
  composeElementAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeBundleEntryChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeBundleEntryChildren(xml : TXmlBuilder; value : TFhirBundleEntry);
var
  i : integer;
begin
  composeBackboneElementChildren(xml, value);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    for i := 0 to value.link_List.Count - 1 do
      ComposeBundleLink(xml, 'link', value.link_List[i]);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeUri(xml, 'fullUrl', value.fullUrlElement);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeInnerResource(xml, 'resource', value, value.resource);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeBundleEntrySearch(xml, 'search', value.search);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeBundleEntryRequest(xml, 'request', value.request);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeBundleEntryResponse(xml, 'response', value.response);
end;

function TFHIRXmlParser.ParseBundleEntrySearch(element : TMXmlElement; path : string) : TFhirBundleEntrySearch;
var
  child : TMXmlElement;
begin
  result := TFhirBundleEntrySearch.Create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseBundleEntrySearchChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseBundleEntrySearchChild(value : TFhirBundleEntrySearch; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'mode') then
        value.modeElement := ParseEnum(CODES_TFhirSearchEntryModeEnum, SYSTEMS_TFhirSearchEntryModeEnum, child, path+'/mode')
      else if (child.localName = 'score') then
        value.scoreElement := ParseDecimal(child, path+'/score')
      else if Not ParseBackboneElementChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeBundleEntrySearch(xml : TXmlBuilder; name : String; value : TFhirBundleEntrySearch);
begin
  if (value = nil) then
    exit;
  composeElementAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeBundleEntrySearchChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeBundleEntrySearchChildren(xml : TXmlBuilder; value : TFhirBundleEntrySearch);
begin
  composeBackboneElementChildren(xml, value);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeEnum(xml, 'mode', value.modeElement, CODES_TFhirSearchEntryModeEnum);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeDecimal(xml, 'score', value.scoreElement);
end;

function TFHIRXmlParser.ParseBundleEntryRequest(element : TMXmlElement; path : string) : TFhirBundleEntryRequest;
var
  child : TMXmlElement;
begin
  result := TFhirBundleEntryRequest.Create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseBundleEntryRequestChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseBundleEntryRequestChild(value : TFhirBundleEntryRequest; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'method') then
        value.methodElement := ParseEnum(CODES_TFhirHTTPVerbEnum, SYSTEMS_TFhirHTTPVerbEnum, child, path+'/method')
      else if (child.localName = 'url') then
        value.urlElement := ParseUri(child, path+'/url')
      else if (child.localName = 'ifNoneMatch') then
        value.ifNoneMatchElement := ParseString(child, path+'/ifNoneMatch')
      else if (child.localName = 'ifModifiedSince') then
        value.ifModifiedSinceElement := ParseInstant(child, path+'/ifModifiedSince')
      else if (child.localName = 'ifMatch') then
        value.ifMatchElement := ParseString(child, path+'/ifMatch')
      else if (child.localName = 'ifNoneExist') then
        value.ifNoneExistElement := ParseString(child, path+'/ifNoneExist')
      else if Not ParseBackboneElementChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeBundleEntryRequest(xml : TXmlBuilder; name : String; value : TFhirBundleEntryRequest);
begin
  if (value = nil) then
    exit;
  composeElementAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeBundleEntryRequestChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeBundleEntryRequestChildren(xml : TXmlBuilder; value : TFhirBundleEntryRequest);
begin
  composeBackboneElementChildren(xml, value);
  ComposeEnum(xml, 'method', value.methodElement, CODES_TFhirHTTPVerbEnum);
  ComposeUri(xml, 'url', value.urlElement);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeString(xml, 'ifNoneMatch', value.ifNoneMatchElement);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeInstant(xml, 'ifModifiedSince', value.ifModifiedSinceElement);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeString(xml, 'ifMatch', value.ifMatchElement);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeString(xml, 'ifNoneExist', value.ifNoneExistElement);
end;

function TFHIRXmlParser.ParseBundleEntryResponse(element : TMXmlElement; path : string) : TFhirBundleEntryResponse;
var
  child : TMXmlElement;
begin
  result := TFhirBundleEntryResponse.Create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseBundleEntryResponseChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseBundleEntryResponseChild(value : TFhirBundleEntryResponse; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'status') then
        value.statusElement := ParseString(child, path+'/status')
      else if (child.localName = 'location') then
        value.locationElement := ParseUri(child, path+'/location')
      else if (child.localName = 'etag') then
        value.etagElement := ParseString(child, path+'/etag')
      else if (child.localName = 'lastModified') then
        value.lastModifiedElement := ParseInstant(child, path+'/lastModified')
      else if (child.localName = 'outcome') then
        value.outcome := ParseInnerResource(child, path+'/outcome')
      else if Not ParseBackboneElementChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeBundleEntryResponse(xml : TXmlBuilder; name : String; value : TFhirBundleEntryResponse);
begin
  if (value = nil) then
    exit;
  composeElementAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeBundleEntryResponseChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeBundleEntryResponseChildren(xml : TXmlBuilder; value : TFhirBundleEntryResponse);
begin
  composeBackboneElementChildren(xml, value);
  ComposeString(xml, 'status', value.statusElement);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeUri(xml, 'location', value.locationElement);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeString(xml, 'etag', value.etagElement);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeInstant(xml, 'lastModified', value.lastModifiedElement);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeInnerResource(xml, 'outcome', value, value.outcome);
end;

function TFHIRXmlParser.ParseBundle(element : TMXmlElement; path : string) : TFhirBundle;
var
  child : TMXmlElement;
begin
  result := TFhirBundle.Create;
  try
    parseResourceAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseBundleChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseBundleChild(value : TFhirBundle; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'identifier') then
        value.identifier := ParseIdentifier(child, path+'/identifier')
      else if (child.localName = 'type') then
        value.type_Element := ParseEnum(CODES_TFhirBundleTypeEnum, SYSTEMS_TFhirBundleTypeEnum, child, path+'/type')
      else if (child.localName = 'timestamp') then
        value.timestampElement := ParseInstant(child, path+'/timestamp')
      else if (child.localName = 'total') then
        value.totalElement := ParseUnsignedInt(child, path+'/total')
      else if (child.localName = 'link') then
        value.link_List.Add(ParseBundleLink(child, path+'/link'))
      else if (child.localName = 'entry') then
        value.entryList.Add(ParseBundleEntry(child, path+'/entry'))
      else if (child.localName = 'signature') then
        value.signature := ParseSignature(child, path+'/signature')
      else if (child.localName = 'issues') then
        value.issues := ParseInnerResource(child, path+'/issues')
      else if Not ParseResourceChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeBundle(xml : TXmlBuilder; name : String; value : TFhirBundle);
begin
  if (value = nil) then
    exit;
  composeResourceAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeBundleChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeBundleChildren(xml : TXmlBuilder; value : TFhirBundle);
var
  i : integer;
begin
  composeResourceChildren(xml, value);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeIdentifier(xml, 'identifier', value.identifier);
  ComposeEnum(xml, 'type', value.type_Element, CODES_TFhirBundleTypeEnum);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeInstant(xml, 'timestamp', value.timestampElement);
  if (SummaryOption in [soFull, soSummary, soText, soData, soCount]) then
    ComposeUnsignedInt(xml, 'total', value.totalElement);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    for i := 0 to value.link_List.Count - 1 do
      ComposeBundleLink(xml, 'link', value.link_List[i]);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    for i := 0 to value.entryList.Count - 1 do
      ComposeBundleEntry(xml, 'entry', value.entryList[i]);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeSignature(xml, 'signature', value.signature);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeInnerResource(xml, 'issues', value, value.issues);
end;

{$ENDIF FHIR_BUNDLE}
{$IFDEF FHIR_CAPABILITYSTATEMENT}
function TFHIRXmlParser.ParseCapabilityStatementSoftware(element : TMXmlElement; path : string) : TFhirCapabilityStatementSoftware;
var
  child : TMXmlElement;
begin
  result := TFhirCapabilityStatementSoftware.Create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseCapabilityStatementSoftwareChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseCapabilityStatementSoftwareChild(value : TFhirCapabilityStatementSoftware; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'name') then
        value.nameElement := ParseString(child, path+'/name')
      else if (child.localName = 'version') then
        value.versionElement := ParseString(child, path+'/version')
      else if (child.localName = 'releaseDate') then
        value.releaseDateElement := ParseDateTime(child, path+'/releaseDate')
      else if Not ParseBackboneElementChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeCapabilityStatementSoftware(xml : TXmlBuilder; name : String; value : TFhirCapabilityStatementSoftware);
begin
  if (value = nil) then
    exit;
  composeElementAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeCapabilityStatementSoftwareChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeCapabilityStatementSoftwareChildren(xml : TXmlBuilder; value : TFhirCapabilityStatementSoftware);
begin
  composeBackboneElementChildren(xml, value);
  ComposeString(xml, 'name', value.nameElement);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(xml, 'version', value.versionElement);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDateTime(xml, 'releaseDate', value.releaseDateElement);
end;

function TFHIRXmlParser.ParseCapabilityStatementImplementation(element : TMXmlElement; path : string) : TFhirCapabilityStatementImplementation;
var
  child : TMXmlElement;
begin
  result := TFhirCapabilityStatementImplementation.Create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseCapabilityStatementImplementationChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseCapabilityStatementImplementationChild(value : TFhirCapabilityStatementImplementation; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'description') then
        value.descriptionElement := ParseString(child, path+'/description')
      else if (child.localName = 'url') then
        value.urlElement := ParseUrl(child, path+'/url')
      else if (child.localName = 'custodian') then
        value.custodian := ParseReference(child, path+'/custodian')
      else if Not ParseBackboneElementChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeCapabilityStatementImplementation(xml : TXmlBuilder; name : String; value : TFhirCapabilityStatementImplementation);
begin
  if (value = nil) then
    exit;
  composeElementAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeCapabilityStatementImplementationChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeCapabilityStatementImplementationChildren(xml : TXmlBuilder; value : TFhirCapabilityStatementImplementation);
begin
  composeBackboneElementChildren(xml, value);
  ComposeString(xml, 'description', value.descriptionElement);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeUrl(xml, 'url', value.urlElement);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference(xml, 'custodian', value.custodian);
end;

function TFHIRXmlParser.ParseCapabilityStatementRest(element : TMXmlElement; path : string) : TFhirCapabilityStatementRest;
var
  child : TMXmlElement;
begin
  result := TFhirCapabilityStatementRest.Create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseCapabilityStatementRestChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseCapabilityStatementRestChild(value : TFhirCapabilityStatementRest; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'mode') then
        value.modeElement := ParseEnum(CODES_TFhirRestfulCapabilityModeEnum, SYSTEMS_TFhirRestfulCapabilityModeEnum, child, path+'/mode')
      else if (child.localName = 'documentation') then
        value.documentationElement := ParseMarkdown(child, path+'/documentation')
      else if (child.localName = 'security') then
        value.security := ParseCapabilityStatementRestSecurity(child, path+'/security')
      else if (child.localName = 'resource') then
        value.resourceList.Add(ParseCapabilityStatementRestResource(child, path+'/resource'))
      else if (child.localName = 'interaction') then
        value.interactionList.Add(ParseCapabilityStatementRestInteraction(child, path+'/interaction'))
      else if (child.localName = 'searchParam') then
        value.searchParamList.Add(ParseCapabilityStatementRestResourceSearchParam(child, path+'/searchParam'))
      else if (child.localName = 'operation') then
        value.operationList.Add(ParseCapabilityStatementRestResourceOperation(child, path+'/operation'))
      else if (child.localName = 'compartment') then
        value.compartmentList.Add(ParseCanonical(child, path+'/compartment'))
      else if Not ParseBackboneElementChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeCapabilityStatementRest(xml : TXmlBuilder; name : String; value : TFhirCapabilityStatementRest);
begin
  if (value = nil) then
    exit;
  composeElementAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeCapabilityStatementRestChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeCapabilityStatementRestChildren(xml : TXmlBuilder; value : TFhirCapabilityStatementRest);
var
  i : integer;
begin
  composeBackboneElementChildren(xml, value);
  ComposeEnum(xml, 'mode', value.modeElement, CODES_TFhirRestfulCapabilityModeEnum);
  if (SummaryOption in [soFull, soData]) then
    ComposeMarkdown(xml, 'documentation', value.documentationElement);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCapabilityStatementRestSecurity(xml, 'security', value.security);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.resourceList.Count - 1 do
      ComposeCapabilityStatementRestResource(xml, 'resource', value.resourceList[i]);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.interactionList.Count - 1 do
      ComposeCapabilityStatementRestInteraction(xml, 'interaction', value.interactionList[i]);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.searchParamList.Count - 1 do
      ComposeCapabilityStatementRestResourceSearchParam(xml, 'searchParam', value.searchParamList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.operationList.Count - 1 do
      ComposeCapabilityStatementRestResourceOperation(xml, 'operation', value.operationList[i]);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.compartmentList.Count - 1 do
      ComposeCanonical(xml, 'compartment', value.compartmentList[i]);
end;

function TFHIRXmlParser.ParseCapabilityStatementRestSecurity(element : TMXmlElement; path : string) : TFhirCapabilityStatementRestSecurity;
var
  child : TMXmlElement;
begin
  result := TFhirCapabilityStatementRestSecurity.Create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseCapabilityStatementRestSecurityChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseCapabilityStatementRestSecurityChild(value : TFhirCapabilityStatementRestSecurity; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'cors') then
        value.corsElement := ParseBoolean(child, path+'/cors')
      else if (child.localName = 'service') then
        value.serviceList.Add(ParseCodeableConcept(child, path+'/service'))
      else if (child.localName = 'description') then
        value.descriptionElement := ParseMarkdown(child, path+'/description')
      else if Not ParseBackboneElementChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeCapabilityStatementRestSecurity(xml : TXmlBuilder; name : String; value : TFhirCapabilityStatementRestSecurity);
begin
  if (value = nil) then
    exit;
  composeElementAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeCapabilityStatementRestSecurityChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeCapabilityStatementRestSecurityChildren(xml : TXmlBuilder; value : TFhirCapabilityStatementRestSecurity);
var
  i : integer;
begin
  composeBackboneElementChildren(xml, value);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeBoolean(xml, 'cors', value.corsElement);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.serviceList.Count - 1 do
      ComposeCodeableConcept(xml, 'service', value.serviceList[i]);
  if (SummaryOption in [soFull, soData]) then
    ComposeMarkdown(xml, 'description', value.descriptionElement);
end;

function TFHIRXmlParser.ParseCapabilityStatementRestResource(element : TMXmlElement; path : string) : TFhirCapabilityStatementRestResource;
var
  child : TMXmlElement;
begin
  result := TFhirCapabilityStatementRestResource.Create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseCapabilityStatementRestResourceChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseCapabilityStatementRestResourceChild(value : TFhirCapabilityStatementRestResource; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'type') then
        value.type_Element := ParseEnum(CODES_TFhirResourceTypesEnum, SYSTEMS_TFhirResourceTypesEnum, child, path+'/type')
      else if (child.localName = 'profile') then
        value.profileElement := ParseCanonical(child, path+'/profile')
      else if (child.localName = 'supportedProfile') then
        value.supportedProfileList.Add(ParseCanonical(child, path+'/supportedProfile'))
      else if (child.localName = 'documentation') then
        value.documentationElement := ParseMarkdown(child, path+'/documentation')
      else if (child.localName = 'interaction') then
        value.interactionList.Add(ParseCapabilityStatementRestResourceInteraction(child, path+'/interaction'))
      else if (child.localName = 'versioning') then
        value.versioningElement := ParseEnum(CODES_TFhirResourceVersionPolicyEnum, SYSTEMS_TFhirResourceVersionPolicyEnum, child, path+'/versioning')
      else if (child.localName = 'readHistory') then
        value.readHistoryElement := ParseBoolean(child, path+'/readHistory')
      else if (child.localName = 'updateCreate') then
        value.updateCreateElement := ParseBoolean(child, path+'/updateCreate')
      else if (child.localName = 'conditionalCreate') then
        value.conditionalCreateElement := ParseBoolean(child, path+'/conditionalCreate')
      else if (child.localName = 'conditionalRead') then
        value.conditionalReadElement := ParseEnum(CODES_TFhirConditionalReadStatusEnum, SYSTEMS_TFhirConditionalReadStatusEnum, child, path+'/conditionalRead')
      else if (child.localName = 'conditionalUpdate') then
        value.conditionalUpdateElement := ParseBoolean(child, path+'/conditionalUpdate')
      else if (child.localName = 'conditionalPatch') then
        value.conditionalPatchElement := ParseBoolean(child, path+'/conditionalPatch')
      else if (child.localName = 'conditionalDelete') then
        value.conditionalDeleteElement := ParseEnum(CODES_TFhirConditionalDeleteStatusEnum, SYSTEMS_TFhirConditionalDeleteStatusEnum, child, path+'/conditionalDelete')
      else if (child.localName = 'referencePolicy') then
        value.referencePolicyList.Add(ParseEnum(CODES_TFhirReferenceHandlingPolicyEnum, SYSTEMS_TFhirReferenceHandlingPolicyEnum, child, path+'/referencePolicy')){y.1}
      else if (child.localName = 'searchInclude') then
        value.searchIncludeList.Add(ParseString(child, path+'/searchInclude'))
      else if (child.localName = 'searchRevInclude') then
        value.searchRevIncludeList.Add(ParseString(child, path+'/searchRevInclude'))
      else if (child.localName = 'searchParam') then
        value.searchParamList.Add(ParseCapabilityStatementRestResourceSearchParam(child, path+'/searchParam'))
      else if (child.localName = 'operation') then
        value.operationList.Add(ParseCapabilityStatementRestResourceOperation(child, path+'/operation'))
      else if Not ParseBackboneElementChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeCapabilityStatementRestResource(xml : TXmlBuilder; name : String; value : TFhirCapabilityStatementRestResource);
begin
  if (value = nil) then
    exit;
  composeElementAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeCapabilityStatementRestResourceChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeCapabilityStatementRestResourceChildren(xml : TXmlBuilder; value : TFhirCapabilityStatementRestResource);
var
  i : integer;
begin
  composeBackboneElementChildren(xml, value);
  ComposeEnum(xml, 'type', value.type_Element, CODES_TFhirResourceTypesEnum);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCanonical(xml, 'profile', value.profileElement);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.supportedProfileList.Count - 1 do
      ComposeCanonical(xml, 'supportedProfile', value.supportedProfileList[i]);
  if (SummaryOption in [soFull, soData]) then
    ComposeMarkdown(xml, 'documentation', value.documentationElement);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.interactionList.Count - 1 do
      ComposeCapabilityStatementRestResourceInteraction(xml, 'interaction', value.interactionList[i]);
  if (SummaryOption in [soFull, soData]) then
    ComposeEnum(xml, 'versioning', value.versioningElement, CODES_TFhirResourceVersionPolicyEnum);
  if (SummaryOption in [soFull, soData]) then
    ComposeBoolean(xml, 'readHistory', value.readHistoryElement);
  if (SummaryOption in [soFull, soData]) then
    ComposeBoolean(xml, 'updateCreate', value.updateCreateElement);
  if (SummaryOption in [soFull, soData]) then
    ComposeBoolean(xml, 'conditionalCreate', value.conditionalCreateElement);
  if (SummaryOption in [soFull, soData]) then
    ComposeEnum(xml, 'conditionalRead', value.conditionalReadElement, CODES_TFhirConditionalReadStatusEnum);
  if (SummaryOption in [soFull, soData]) then
    ComposeBoolean(xml, 'conditionalUpdate', value.conditionalUpdateElement);
  if (SummaryOption in [soFull, soData]) then
    ComposeBoolean(xml, 'conditionalPatch', value.conditionalPatchElement);
  if (SummaryOption in [soFull, soData]) then
    ComposeEnum(xml, 'conditionalDelete', value.conditionalDeleteElement, CODES_TFhirConditionalDeleteStatusEnum);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.referencePolicyList.Count - 1 do
      ComposeEnum(xml, 'referencePolicy', value.referencePolicyList[i], CODES_TFhirReferenceHandlingPolicyEnum);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.searchIncludeList.Count - 1 do
      ComposeString(xml, 'searchInclude', value.searchIncludeList[i]);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.searchRevIncludeList.Count - 1 do
      ComposeString(xml, 'searchRevInclude', value.searchRevIncludeList[i]);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.searchParamList.Count - 1 do
      ComposeCapabilityStatementRestResourceSearchParam(xml, 'searchParam', value.searchParamList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.operationList.Count - 1 do
      ComposeCapabilityStatementRestResourceOperation(xml, 'operation', value.operationList[i]);
end;

function TFHIRXmlParser.ParseCapabilityStatementRestResourceInteraction(element : TMXmlElement; path : string) : TFhirCapabilityStatementRestResourceInteraction;
var
  child : TMXmlElement;
begin
  result := TFhirCapabilityStatementRestResourceInteraction.Create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseCapabilityStatementRestResourceInteractionChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseCapabilityStatementRestResourceInteractionChild(value : TFhirCapabilityStatementRestResourceInteraction; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'code') then
        value.codeElement := ParseEnum(CODES_TFhirTypeRestfulInteractionEnum, SYSTEMS_TFhirTypeRestfulInteractionEnum, child, path+'/code')
      else if (child.localName = 'documentation') then
        value.documentationElement := ParseMarkdown(child, path+'/documentation')
      else if Not ParseBackboneElementChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeCapabilityStatementRestResourceInteraction(xml : TXmlBuilder; name : String; value : TFhirCapabilityStatementRestResourceInteraction);
begin
  if (value = nil) then
    exit;
  composeElementAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeCapabilityStatementRestResourceInteractionChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeCapabilityStatementRestResourceInteractionChildren(xml : TXmlBuilder; value : TFhirCapabilityStatementRestResourceInteraction);
begin
  composeBackboneElementChildren(xml, value);
  ComposeEnum(xml, 'code', value.codeElement, CODES_TFhirTypeRestfulInteractionEnum);
  if (SummaryOption in [soFull, soData]) then
    ComposeMarkdown(xml, 'documentation', value.documentationElement);
end;

function TFHIRXmlParser.ParseCapabilityStatementRestResourceSearchParam(element : TMXmlElement; path : string) : TFhirCapabilityStatementRestResourceSearchParam;
var
  child : TMXmlElement;
begin
  result := TFhirCapabilityStatementRestResourceSearchParam.Create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseCapabilityStatementRestResourceSearchParamChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseCapabilityStatementRestResourceSearchParamChild(value : TFhirCapabilityStatementRestResourceSearchParam; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'name') then
        value.nameElement := ParseString(child, path+'/name')
      else if (child.localName = 'definition') then
        value.definitionElement := ParseCanonical(child, path+'/definition')
      else if (child.localName = 'type') then
        value.type_Element := ParseEnum(CODES_TFhirSearchParamTypeEnum, SYSTEMS_TFhirSearchParamTypeEnum, child, path+'/type')
      else if (child.localName = 'documentation') then
        value.documentationElement := ParseMarkdown(child, path+'/documentation')
      else if Not ParseBackboneElementChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeCapabilityStatementRestResourceSearchParam(xml : TXmlBuilder; name : String; value : TFhirCapabilityStatementRestResourceSearchParam);
begin
  if (value = nil) then
    exit;
  composeElementAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeCapabilityStatementRestResourceSearchParamChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeCapabilityStatementRestResourceSearchParamChildren(xml : TXmlBuilder; value : TFhirCapabilityStatementRestResourceSearchParam);
begin
  composeBackboneElementChildren(xml, value);
  ComposeString(xml, 'name', value.nameElement);
  if (SummaryOption in [soFull, soData]) then
    ComposeCanonical(xml, 'definition', value.definitionElement);
  ComposeEnum(xml, 'type', value.type_Element, CODES_TFhirSearchParamTypeEnum);
  if (SummaryOption in [soFull, soData]) then
    ComposeMarkdown(xml, 'documentation', value.documentationElement);
end;

function TFHIRXmlParser.ParseCapabilityStatementRestResourceOperation(element : TMXmlElement; path : string) : TFhirCapabilityStatementRestResourceOperation;
var
  child : TMXmlElement;
begin
  result := TFhirCapabilityStatementRestResourceOperation.Create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseCapabilityStatementRestResourceOperationChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseCapabilityStatementRestResourceOperationChild(value : TFhirCapabilityStatementRestResourceOperation; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'name') then
        value.nameElement := ParseString(child, path+'/name')
      else if (child.localName = 'definition') then
        value.definitionElement := ParseCanonical(child, path+'/definition')
      else if (child.localName = 'documentation') then
        value.documentationElement := ParseMarkdown(child, path+'/documentation')
      else if Not ParseBackboneElementChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeCapabilityStatementRestResourceOperation(xml : TXmlBuilder; name : String; value : TFhirCapabilityStatementRestResourceOperation);
begin
  if (value = nil) then
    exit;
  composeElementAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeCapabilityStatementRestResourceOperationChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeCapabilityStatementRestResourceOperationChildren(xml : TXmlBuilder; value : TFhirCapabilityStatementRestResourceOperation);
begin
  composeBackboneElementChildren(xml, value);
  ComposeString(xml, 'name', value.nameElement);
  ComposeCanonical(xml, 'definition', value.definitionElement);
  if (SummaryOption in [soFull, soData]) then
    ComposeMarkdown(xml, 'documentation', value.documentationElement);
end;

function TFHIRXmlParser.ParseCapabilityStatementRestInteraction(element : TMXmlElement; path : string) : TFhirCapabilityStatementRestInteraction;
var
  child : TMXmlElement;
begin
  result := TFhirCapabilityStatementRestInteraction.Create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseCapabilityStatementRestInteractionChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseCapabilityStatementRestInteractionChild(value : TFhirCapabilityStatementRestInteraction; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'code') then
        value.codeElement := ParseEnum(CODES_TFhirSystemRestfulInteractionEnum, SYSTEMS_TFhirSystemRestfulInteractionEnum, child, path+'/code')
      else if (child.localName = 'documentation') then
        value.documentationElement := ParseMarkdown(child, path+'/documentation')
      else if Not ParseBackboneElementChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeCapabilityStatementRestInteraction(xml : TXmlBuilder; name : String; value : TFhirCapabilityStatementRestInteraction);
begin
  if (value = nil) then
    exit;
  composeElementAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeCapabilityStatementRestInteractionChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeCapabilityStatementRestInteractionChildren(xml : TXmlBuilder; value : TFhirCapabilityStatementRestInteraction);
begin
  composeBackboneElementChildren(xml, value);
  ComposeEnum(xml, 'code', value.codeElement, CODES_TFhirSystemRestfulInteractionEnum);
  if (SummaryOption in [soFull, soData]) then
    ComposeMarkdown(xml, 'documentation', value.documentationElement);
end;

function TFHIRXmlParser.ParseCapabilityStatementMessaging(element : TMXmlElement; path : string) : TFhirCapabilityStatementMessaging;
var
  child : TMXmlElement;
begin
  result := TFhirCapabilityStatementMessaging.Create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseCapabilityStatementMessagingChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseCapabilityStatementMessagingChild(value : TFhirCapabilityStatementMessaging; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'endpoint') then
        value.endpointList.Add(ParseCapabilityStatementMessagingEndpoint(child, path+'/endpoint'))
      else if (child.localName = 'reliableCache') then
        value.reliableCacheElement := ParseUnsignedInt(child, path+'/reliableCache')
      else if (child.localName = 'documentation') then
        value.documentationElement := ParseMarkdown(child, path+'/documentation')
      else if (child.localName = 'supportedMessage') then
        value.supportedMessageList.Add(ParseCapabilityStatementMessagingSupportedMessage(child, path+'/supportedMessage'))
      else if Not ParseBackboneElementChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeCapabilityStatementMessaging(xml : TXmlBuilder; name : String; value : TFhirCapabilityStatementMessaging);
begin
  if (value = nil) then
    exit;
  composeElementAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeCapabilityStatementMessagingChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeCapabilityStatementMessagingChildren(xml : TXmlBuilder; value : TFhirCapabilityStatementMessaging);
var
  i : integer;
begin
  composeBackboneElementChildren(xml, value);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.endpointList.Count - 1 do
      ComposeCapabilityStatementMessagingEndpoint(xml, 'endpoint', value.endpointList[i]);
  if (SummaryOption in [soFull, soData]) then
    ComposeUnsignedInt(xml, 'reliableCache', value.reliableCacheElement);
  if (SummaryOption in [soFull, soData]) then
    ComposeMarkdown(xml, 'documentation', value.documentationElement);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.supportedMessageList.Count - 1 do
      ComposeCapabilityStatementMessagingSupportedMessage(xml, 'supportedMessage', value.supportedMessageList[i]);
end;

function TFHIRXmlParser.ParseCapabilityStatementMessagingEndpoint(element : TMXmlElement; path : string) : TFhirCapabilityStatementMessagingEndpoint;
var
  child : TMXmlElement;
begin
  result := TFhirCapabilityStatementMessagingEndpoint.Create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseCapabilityStatementMessagingEndpointChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseCapabilityStatementMessagingEndpointChild(value : TFhirCapabilityStatementMessagingEndpoint; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'protocol') then
        value.protocol := ParseCoding(child, path+'/protocol')
      else if (child.localName = 'address') then
        value.addressElement := ParseUrl(child, path+'/address')
      else if Not ParseBackboneElementChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeCapabilityStatementMessagingEndpoint(xml : TXmlBuilder; name : String; value : TFhirCapabilityStatementMessagingEndpoint);
begin
  if (value = nil) then
    exit;
  composeElementAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeCapabilityStatementMessagingEndpointChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeCapabilityStatementMessagingEndpointChildren(xml : TXmlBuilder; value : TFhirCapabilityStatementMessagingEndpoint);
begin
  composeBackboneElementChildren(xml, value);
  ComposeCoding(xml, 'protocol', value.protocol);
  ComposeUrl(xml, 'address', value.addressElement);
end;

function TFHIRXmlParser.ParseCapabilityStatementMessagingSupportedMessage(element : TMXmlElement; path : string) : TFhirCapabilityStatementMessagingSupportedMessage;
var
  child : TMXmlElement;
begin
  result := TFhirCapabilityStatementMessagingSupportedMessage.Create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseCapabilityStatementMessagingSupportedMessageChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseCapabilityStatementMessagingSupportedMessageChild(value : TFhirCapabilityStatementMessagingSupportedMessage; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'mode') then
        value.modeElement := ParseEnum(CODES_TFhirEventCapabilityModeEnum, SYSTEMS_TFhirEventCapabilityModeEnum, child, path+'/mode')
      else if (child.localName = 'definition') then
        value.definitionElement := ParseCanonical(child, path+'/definition')
      else if Not ParseBackboneElementChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeCapabilityStatementMessagingSupportedMessage(xml : TXmlBuilder; name : String; value : TFhirCapabilityStatementMessagingSupportedMessage);
begin
  if (value = nil) then
    exit;
  composeElementAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeCapabilityStatementMessagingSupportedMessageChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeCapabilityStatementMessagingSupportedMessageChildren(xml : TXmlBuilder; value : TFhirCapabilityStatementMessagingSupportedMessage);
begin
  composeBackboneElementChildren(xml, value);
  ComposeEnum(xml, 'mode', value.modeElement, CODES_TFhirEventCapabilityModeEnum);
  ComposeCanonical(xml, 'definition', value.definitionElement);
end;

function TFHIRXmlParser.ParseCapabilityStatementDocument(element : TMXmlElement; path : string) : TFhirCapabilityStatementDocument;
var
  child : TMXmlElement;
begin
  result := TFhirCapabilityStatementDocument.Create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseCapabilityStatementDocumentChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseCapabilityStatementDocumentChild(value : TFhirCapabilityStatementDocument; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'mode') then
        value.modeElement := ParseEnum(CODES_TFhirDocumentModeEnum, SYSTEMS_TFhirDocumentModeEnum, child, path+'/mode')
      else if (child.localName = 'documentation') then
        value.documentationElement := ParseMarkdown(child, path+'/documentation')
      else if (child.localName = 'profile') then
        value.profileElement := ParseCanonical(child, path+'/profile')
      else if Not ParseBackboneElementChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeCapabilityStatementDocument(xml : TXmlBuilder; name : String; value : TFhirCapabilityStatementDocument);
begin
  if (value = nil) then
    exit;
  composeElementAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeCapabilityStatementDocumentChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeCapabilityStatementDocumentChildren(xml : TXmlBuilder; value : TFhirCapabilityStatementDocument);
begin
  composeBackboneElementChildren(xml, value);
  ComposeEnum(xml, 'mode', value.modeElement, CODES_TFhirDocumentModeEnum);
  if (SummaryOption in [soFull, soData]) then
    ComposeMarkdown(xml, 'documentation', value.documentationElement);
  ComposeCanonical(xml, 'profile', value.profileElement);
end;

function TFHIRXmlParser.ParseCapabilityStatement(element : TMXmlElement; path : string) : TFhirCapabilityStatement;
var
  child : TMXmlElement;
begin
  result := TFhirCapabilityStatement.Create;
  try
    parseCanonicalResourceAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseCapabilityStatementChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseCapabilityStatementChild(value : TFhirCapabilityStatement; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'url') then
        value.urlElement := ParseUri(child, path+'/url')
      else if (child.localName = 'version') then
        value.versionElement := ParseString(child, path+'/version')
      else if (child.localName = 'versionAlgorithmCoding') then
        value.versionAlgorithm := ParseCoding(child, path+'/versionAlgorithmCoding')
      else if (child.localName = 'versionAlgorithmString') then
        value.versionAlgorithm := ParseString(child, path+'/versionAlgorithmString')
      else if (child.localName = 'name') then
        value.nameElement := ParseString(child, path+'/name')
      else if (child.localName = 'title') then
        value.titleElement := ParseString(child, path+'/title')
      else if (child.localName = 'status') then
        value.statusElement := ParseEnum(CODES_TFhirPublicationStatusEnum, SYSTEMS_TFhirPublicationStatusEnum, child, path+'/status')
      else if (child.localName = 'experimental') then
        value.experimentalElement := ParseBoolean(child, path+'/experimental')
      else if (child.localName = 'date') then
        value.dateElement := ParseDateTime(child, path+'/date')
      else if (child.localName = 'publisher') then
        value.publisherElement := ParseString(child, path+'/publisher')
      else if (child.localName = 'contact') then
        value.contactList.Add(ParseContactDetail(child, path+'/contact'))
      else if (child.localName = 'description') then
        value.descriptionElement := ParseMarkdown(child, path+'/description')
      else if (child.localName = 'useContext') then
        value.useContextList.Add(ParseUsageContext(child, path+'/useContext'))
      else if (child.localName = 'jurisdiction') then
        value.jurisdictionList.Add(ParseCodeableConcept(child, path+'/jurisdiction'))
      else if (child.localName = 'purpose') then
        value.purposeElement := ParseMarkdown(child, path+'/purpose')
      else if (child.localName = 'copyright') then
        value.copyrightElement := ParseMarkdown(child, path+'/copyright')
      else if (child.localName = 'copyrightLabel') then
        value.copyrightLabelElement := ParseString(child, path+'/copyrightLabel')
      else if (child.localName = 'kind') then
        value.kindElement := ParseEnum(CODES_TFhirCapabilityStatementKindEnum, SYSTEMS_TFhirCapabilityStatementKindEnum, child, path+'/kind')
      else if (child.localName = 'instantiates') then
        value.instantiatesList.Add(ParseCanonical(child, path+'/instantiates'))
      else if (child.localName = 'imports') then
        value.importsList.Add(ParseCanonical(child, path+'/imports'))
      else if (child.localName = 'software') then
        value.software := ParseCapabilityStatementSoftware(child, path+'/software')
      else if (child.localName = 'implementation') then
        value.implementation_ := ParseCapabilityStatementImplementation(child, path+'/implementation')
      else if (child.localName = 'fhirVersion') then
        value.fhirVersionElement := ParseEnum(CODES_TFhirFHIRVersionEnum, SYSTEMS_TFhirFHIRVersionEnum, child, path+'/fhirVersion')
      else if (child.localName = 'format') then
        value.formatList.Add(ParseCode(child, path+'/format'))
      else if (child.localName = 'patchFormat') then
        value.patchFormatList.Add(ParseCode(child, path+'/patchFormat'))
      else if (child.localName = 'acceptLanguage') then
        value.acceptLanguageList.Add(ParseCode(child, path+'/acceptLanguage'))
      else if (child.localName = 'implementationGuide') then
        value.implementationGuideList.Add(ParseCanonical(child, path+'/implementationGuide'))
      else if (child.localName = 'rest') then
        value.restList.Add(ParseCapabilityStatementRest(child, path+'/rest'))
      else if (child.localName = 'messaging') then
        value.messagingList.Add(ParseCapabilityStatementMessaging(child, path+'/messaging'))
      else if (child.localName = 'document') then
        value.documentList.Add(ParseCapabilityStatementDocument(child, path+'/document'))
      else if Not ParseCanonicalResourceChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeCapabilityStatement(xml : TXmlBuilder; name : String; value : TFhirCapabilityStatement);
begin
  if (value = nil) then
    exit;
  composeCanonicalResourceAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeCapabilityStatementChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeCapabilityStatementChildren(xml : TXmlBuilder; value : TFhirCapabilityStatement);
var
  i : integer;
begin
  composeCanonicalResourceChildren(xml, value);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeUri(xml, 'url', value.urlElement);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(xml, 'version', value.versionElement);
  if (SummaryOption in [soFull, soSummary, soData]) and (value.versionAlgorithm is TFhirCoding) {6} then
    ComposeCoding(xml, 'versionAlgorithmCoding', TFhirCoding(value.versionAlgorithm))
  else if (SummaryOption in [soFull, soSummary, soData]) and (value.versionAlgorithm is TFhirString) {6} then
    ComposeString(xml, 'versionAlgorithmString', TFhirString(value.versionAlgorithm));
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(xml, 'name', value.nameElement);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(xml, 'title', value.titleElement);
  ComposeEnum(xml, 'status', value.statusElement, CODES_TFhirPublicationStatusEnum);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeBoolean(xml, 'experimental', value.experimentalElement);
  ComposeDateTime(xml, 'date', value.dateElement);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(xml, 'publisher', value.publisherElement);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.contactList.Count - 1 do
      ComposeContactDetail(xml, 'contact', value.contactList[i]);
  if (SummaryOption in [soFull, soData]) then
    ComposeMarkdown(xml, 'description', value.descriptionElement);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.useContextList.Count - 1 do
      ComposeUsageContext(xml, 'useContext', value.useContextList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.jurisdictionList.Count - 1 do
      ComposeCodeableConcept(xml, 'jurisdiction', value.jurisdictionList[i]);
  if (SummaryOption in [soFull, soData]) then
    ComposeMarkdown(xml, 'purpose', value.purposeElement);
  if (SummaryOption in [soFull, soData]) then
    ComposeMarkdown(xml, 'copyright', value.copyrightElement);
  if (SummaryOption in [soFull, soData]) then
    ComposeString(xml, 'copyrightLabel', value.copyrightLabelElement);
  ComposeEnum(xml, 'kind', value.kindElement, CODES_TFhirCapabilityStatementKindEnum);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.instantiatesList.Count - 1 do
      ComposeCanonical(xml, 'instantiates', value.instantiatesList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.importsList.Count - 1 do
      ComposeCanonical(xml, 'imports', value.importsList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCapabilityStatementSoftware(xml, 'software', value.software);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCapabilityStatementImplementation(xml, 'implementation', value.implementation_);
  ComposeEnum(xml, 'fhirVersion', value.fhirVersionElement, CODES_TFhirFHIRVersionEnum);
  for i := 0 to value.formatList.Count - 1 do
      ComposeCode(xml, 'format', value.formatList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.patchFormatList.Count - 1 do
      ComposeCode(xml, 'patchFormat', value.patchFormatList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.acceptLanguageList.Count - 1 do
      ComposeCode(xml, 'acceptLanguage', value.acceptLanguageList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.implementationGuideList.Count - 1 do
      ComposeCanonical(xml, 'implementationGuide', value.implementationGuideList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.restList.Count - 1 do
      ComposeCapabilityStatementRest(xml, 'rest', value.restList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.messagingList.Count - 1 do
      ComposeCapabilityStatementMessaging(xml, 'messaging', value.messagingList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.documentList.Count - 1 do
      ComposeCapabilityStatementDocument(xml, 'document', value.documentList[i]);
end;

{$ENDIF FHIR_CAPABILITYSTATEMENT}
{$IFDEF FHIR_CAREPLAN}
function TFHIRXmlParser.ParseCarePlanActivity(element : TMXmlElement; path : string) : TFhirCarePlanActivity;
var
  child : TMXmlElement;
begin
  result := TFhirCarePlanActivity.Create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseCarePlanActivityChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseCarePlanActivityChild(value : TFhirCarePlanActivity; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'performedActivity') then
        value.performedActivityList.Add(ParseCodeableReference(child, path+'/performedActivity'))
      else if (child.localName = 'progress') then
        value.progressList.Add(ParseAnnotation(child, path+'/progress'))
      else if (child.localName = 'plannedActivityReference') then
        value.plannedActivityReference := ParseReference(child, path+'/plannedActivityReference')
      else if (child.localName = 'plannedActivityDetail') then
        value.plannedActivityDetail := ParseCarePlanActivityPlannedActivityDetail(child, path+'/plannedActivityDetail')
      else if Not ParseBackboneElementChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeCarePlanActivity(xml : TXmlBuilder; name : String; value : TFhirCarePlanActivity);
begin
  if (value = nil) then
    exit;
  composeElementAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeCarePlanActivityChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeCarePlanActivityChildren(xml : TXmlBuilder; value : TFhirCarePlanActivity);
var
  i : integer;
begin
  composeBackboneElementChildren(xml, value);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.performedActivityList.Count - 1 do
      ComposeCodeableReference(xml, 'performedActivity', value.performedActivityList[i]);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.progressList.Count - 1 do
      ComposeAnnotation(xml, 'progress', value.progressList[i]);
  if (SummaryOption in [soFull, soData]) then
    ComposeReference(xml, 'plannedActivityReference', value.plannedActivityReference);
  if (SummaryOption in [soFull, soData]) then
    ComposeCarePlanActivityPlannedActivityDetail(xml, 'plannedActivityDetail', value.plannedActivityDetail);
end;

function TFHIRXmlParser.ParseCarePlanActivityPlannedActivityDetail(element : TMXmlElement; path : string) : TFhirCarePlanActivityPlannedActivityDetail;
var
  child : TMXmlElement;
begin
  result := TFhirCarePlanActivityPlannedActivityDetail.Create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseCarePlanActivityPlannedActivityDetailChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseCarePlanActivityPlannedActivityDetailChild(value : TFhirCarePlanActivityPlannedActivityDetail; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'kind') then
        value.kindElement := ParseEnum(CODES_TFhirCarePlanActivityKindEnum, SYSTEMS_TFhirCarePlanActivityKindEnum, child, path+'/kind')
      else if (child.localName = 'instantiatesCanonical') then
        value.instantiatesCanonicalList.Add(ParseCanonical(child, path+'/instantiatesCanonical'))
      else if (child.localName = 'instantiatesUri') then
        value.instantiatesUriList.Add(ParseUri(child, path+'/instantiatesUri'))
      else if (child.localName = 'code') then
        value.code := ParseCodeableConcept(child, path+'/code')
      else if (child.localName = 'reason') then
        value.reasonList.Add(ParseCodeableReference(child, path+'/reason'))
      else if (child.localName = 'goal') then
        value.goalList.Add(ParseReference(child, path+'/goal'))
      else if (child.localName = 'status') then
        value.statusElement := ParseEnum(CODES_TFhirCarePlanActivityStatusEnum, SYSTEMS_TFhirCarePlanActivityStatusEnum, child, path+'/status')
      else if (child.localName = 'statusReason') then
        value.statusReason := ParseCodeableConcept(child, path+'/statusReason')
      else if (child.localName = 'doNotPerform') then
        value.doNotPerformElement := ParseBoolean(child, path+'/doNotPerform')
      else if (child.localName = 'scheduledTiming') then
        value.scheduled := ParseTiming(child, path+'/scheduledTiming')
      else if (child.localName = 'scheduledPeriod') then
        value.scheduled := ParsePeriod(child, path+'/scheduledPeriod')
      else if (child.localName = 'scheduledString') then
        value.scheduled := ParseString(child, path+'/scheduledString')
      else if (child.localName = 'location') then
        value.location := ParseCodeableReference(child, path+'/location')
      else if (child.localName = 'reportedReference') then
        value.reported := ParseReference(child, path+'/reportedReference')
      else if (child.localName = 'reportedBoolean') then
        value.reported := ParseBoolean(child, path+'/reportedBoolean')
      else if (child.localName = 'performer') then
        value.performerList.Add(ParseReference(child, path+'/performer'))
      else if (child.localName = 'productCodeableConcept') then
        value.product := ParseCodeableConcept(child, path+'/productCodeableConcept')
      else if (child.localName = 'productReference') then
        value.product := ParseReference(child, path+'/productReference')
      else if (child.localName = 'dailyAmount') then
        value.dailyAmount := ParseQuantity(child, path+'/dailyAmount')
      else if (child.localName = 'quantity') then
        value.quantity := ParseQuantity(child, path+'/quantity')
      else if (child.localName = 'description') then
        value.descriptionElement := ParseString(child, path+'/description')
      else if Not ParseBackboneElementChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeCarePlanActivityPlannedActivityDetail(xml : TXmlBuilder; name : String; value : TFhirCarePlanActivityPlannedActivityDetail);
begin
  if (value = nil) then
    exit;
  composeElementAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeCarePlanActivityPlannedActivityDetailChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeCarePlanActivityPlannedActivityDetailChildren(xml : TXmlBuilder; value : TFhirCarePlanActivityPlannedActivityDetail);
var
  i : integer;
begin
  composeBackboneElementChildren(xml, value);
  if (SummaryOption in [soFull, soData]) then
    ComposeEnum(xml, 'kind', value.kindElement, CODES_TFhirCarePlanActivityKindEnum);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.instantiatesCanonicalList.Count - 1 do
      ComposeCanonical(xml, 'instantiatesCanonical', value.instantiatesCanonicalList[i]);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.instantiatesUriList.Count - 1 do
      ComposeUri(xml, 'instantiatesUri', value.instantiatesUriList[i]);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(xml, 'code', value.code);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.reasonList.Count - 1 do
      ComposeCodeableReference(xml, 'reason', value.reasonList[i]);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.goalList.Count - 1 do
      ComposeReference(xml, 'goal', value.goalList[i]);
  ComposeEnum(xml, 'status', value.statusElement, CODES_TFhirCarePlanActivityStatusEnum);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(xml, 'statusReason', value.statusReason);
  if (SummaryOption in [soFull, soData]) then
    ComposeBoolean(xml, 'doNotPerform', value.doNotPerformElement);
  if (SummaryOption in [soFull, soData]) and (value.scheduled is TFhirTiming) {6} then
    ComposeTiming(xml, 'scheduledTiming', TFhirTiming(value.scheduled))
  else if (SummaryOption in [soFull, soData]) and (value.scheduled is TFhirPeriod) {6} then
    ComposePeriod(xml, 'scheduledPeriod', TFhirPeriod(value.scheduled))
  else if (SummaryOption in [soFull, soData]) and (value.scheduled is TFhirString) {6} then
    ComposeString(xml, 'scheduledString', TFhirString(value.scheduled));
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableReference(xml, 'location', value.location);
  if (SummaryOption in [soFull, soData]) and (value.reported is TFhirReference) {2} then
    ComposeReference(xml, 'reportedReference', TFhirReference(value.reported))
  else if (SummaryOption in [soFull, soData]) and (value.reported is TFhirBoolean) {6} then
    ComposeBoolean(xml, 'reportedBoolean', TFhirBoolean(value.reported));
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.performerList.Count - 1 do
      ComposeReference(xml, 'performer', value.performerList[i]);
  if (SummaryOption in [soFull, soData]) and (value.product is TFhirCodeableConcept) {6} then
    ComposeCodeableConcept(xml, 'productCodeableConcept', TFhirCodeableConcept(value.product))
  else if (SummaryOption in [soFull, soData]) and (value.product is TFhirReference) {2} then
    ComposeReference(xml, 'productReference', TFhirReference(value.product));
  if (SummaryOption in [soFull, soData]) then
    ComposeQuantity(xml, 'dailyAmount', value.dailyAmount);
  if (SummaryOption in [soFull, soData]) then
    ComposeQuantity(xml, 'quantity', value.quantity);
  if (SummaryOption in [soFull, soData]) then
    ComposeString(xml, 'description', value.descriptionElement);
end;

function TFHIRXmlParser.ParseCarePlan(element : TMXmlElement; path : string) : TFhirCarePlan;
var
  child : TMXmlElement;
begin
  result := TFhirCarePlan.Create;
  try
    parseDomainResourceAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseCarePlanChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseCarePlanChild(value : TFhirCarePlan; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'identifier') then
        value.identifierList.Add(ParseIdentifier(child, path+'/identifier'))
      else if (child.localName = 'instantiatesCanonical') then
        value.instantiatesCanonicalList.Add(ParseCanonical(child, path+'/instantiatesCanonical'))
      else if (child.localName = 'instantiatesUri') then
        value.instantiatesUriList.Add(ParseUri(child, path+'/instantiatesUri'))
      else if (child.localName = 'basedOn') then
        value.basedOnList.Add(ParseReference(child, path+'/basedOn'))
      else if (child.localName = 'replaces') then
        value.replacesList.Add(ParseReference(child, path+'/replaces'))
      else if (child.localName = 'partOf') then
        value.partOfList.Add(ParseReference(child, path+'/partOf'))
      else if (child.localName = 'status') then
        value.statusElement := ParseEnum(CODES_TFhirRequestStatusEnum, SYSTEMS_TFhirRequestStatusEnum, child, path+'/status')
      else if (child.localName = 'intent') then
        value.intentElement := ParseEnum(CODES_TFhirCarePlanIntentEnum, SYSTEMS_TFhirCarePlanIntentEnum, child, path+'/intent')
      else if (child.localName = 'category') then
        value.categoryList.Add(ParseCodeableConcept(child, path+'/category'))
      else if (child.localName = 'title') then
        value.titleElement := ParseString(child, path+'/title')
      else if (child.localName = 'description') then
        value.descriptionElement := ParseString(child, path+'/description')
      else if (child.localName = 'subject') then
        value.subject := ParseReference(child, path+'/subject')
      else if (child.localName = 'encounter') then
        value.encounter := ParseReference(child, path+'/encounter')
      else if (child.localName = 'period') then
        value.period := ParsePeriod(child, path+'/period')
      else if (child.localName = 'created') then
        value.createdElement := ParseDateTime(child, path+'/created')
      else if (child.localName = 'custodian') then
        value.custodian := ParseReference(child, path+'/custodian')
      else if (child.localName = 'contributor') then
        value.contributorList.Add(ParseReference(child, path+'/contributor'))
      else if (child.localName = 'careTeam') then
        value.careTeamList.Add(ParseReference(child, path+'/careTeam'))
      else if (child.localName = 'addresses') then
        value.addressesList.Add(ParseCodeableReference(child, path+'/addresses'))
      else if (child.localName = 'supportingInfo') then
        value.supportingInfoList.Add(ParseReference(child, path+'/supportingInfo'))
      else if (child.localName = 'goal') then
        value.goalList.Add(ParseReference(child, path+'/goal'))
      else if (child.localName = 'activity') then
        value.activityList.Add(ParseCarePlanActivity(child, path+'/activity'))
      else if (child.localName = 'note') then
        value.noteList.Add(ParseAnnotation(child, path+'/note'))
      else if Not ParseDomainResourceChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeCarePlan(xml : TXmlBuilder; name : String; value : TFhirCarePlan);
begin
  if (value = nil) then
    exit;
  composeDomainResourceAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeCarePlanChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeCarePlanChildren(xml : TXmlBuilder; value : TFhirCarePlan);
var
  i : integer;
begin
  composeDomainResourceChildren(xml, value);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.identifierList.Count - 1 do
      ComposeIdentifier(xml, 'identifier', value.identifierList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.instantiatesCanonicalList.Count - 1 do
      ComposeCanonical(xml, 'instantiatesCanonical', value.instantiatesCanonicalList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.instantiatesUriList.Count - 1 do
      ComposeUri(xml, 'instantiatesUri', value.instantiatesUriList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.basedOnList.Count - 1 do
      ComposeReference(xml, 'basedOn', value.basedOnList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.replacesList.Count - 1 do
      ComposeReference(xml, 'replaces', value.replacesList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.partOfList.Count - 1 do
      ComposeReference(xml, 'partOf', value.partOfList[i]);
  ComposeEnum(xml, 'status', value.statusElement, CODES_TFhirRequestStatusEnum);
  ComposeEnum(xml, 'intent', value.intentElement, CODES_TFhirCarePlanIntentEnum);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.categoryList.Count - 1 do
      ComposeCodeableConcept(xml, 'category', value.categoryList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(xml, 'title', value.titleElement);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(xml, 'description', value.descriptionElement);
  ComposeReference(xml, 'subject', value.subject);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference(xml, 'encounter', value.encounter);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposePeriod(xml, 'period', value.period);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDateTime(xml, 'created', value.createdElement);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference(xml, 'custodian', value.custodian);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.contributorList.Count - 1 do
      ComposeReference(xml, 'contributor', value.contributorList[i]);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.careTeamList.Count - 1 do
      ComposeReference(xml, 'careTeam', value.careTeamList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.addressesList.Count - 1 do
      ComposeCodeableReference(xml, 'addresses', value.addressesList[i]);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.supportingInfoList.Count - 1 do
      ComposeReference(xml, 'supportingInfo', value.supportingInfoList[i]);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.goalList.Count - 1 do
      ComposeReference(xml, 'goal', value.goalList[i]);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.activityList.Count - 1 do
      ComposeCarePlanActivity(xml, 'activity', value.activityList[i]);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.noteList.Count - 1 do
      ComposeAnnotation(xml, 'note', value.noteList[i]);
end;

{$ENDIF FHIR_CAREPLAN}
{$IFDEF FHIR_CARETEAM}
function TFHIRXmlParser.ParseCareTeamParticipant(element : TMXmlElement; path : string) : TFhirCareTeamParticipant;
var
  child : TMXmlElement;
begin
  result := TFhirCareTeamParticipant.Create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseCareTeamParticipantChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseCareTeamParticipantChild(value : TFhirCareTeamParticipant; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'role') then
        value.role := ParseCodeableConcept(child, path+'/role')
      else if (child.localName = 'member') then
        value.member := ParseReference(child, path+'/member')
      else if (child.localName = 'onBehalfOf') then
        value.onBehalfOf := ParseReference(child, path+'/onBehalfOf')
      else if (child.localName = 'coveragePeriod') then
        value.coverage := ParsePeriod(child, path+'/coveragePeriod')
      else if (child.localName = 'coverageTiming') then
        value.coverage := ParseTiming(child, path+'/coverageTiming')
      else if Not ParseBackboneElementChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeCareTeamParticipant(xml : TXmlBuilder; name : String; value : TFhirCareTeamParticipant);
begin
  if (value = nil) then
    exit;
  composeElementAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeCareTeamParticipantChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeCareTeamParticipantChildren(xml : TXmlBuilder; value : TFhirCareTeamParticipant);
begin
  composeBackboneElementChildren(xml, value);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(xml, 'role', value.role);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference(xml, 'member', value.member);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference(xml, 'onBehalfOf', value.onBehalfOf);
  if (SummaryOption in [soFull, soData]) and (value.coverage is TFhirPeriod) {6} then
    ComposePeriod(xml, 'coveragePeriod', TFhirPeriod(value.coverage))
  else if (SummaryOption in [soFull, soData]) and (value.coverage is TFhirTiming) {6} then
    ComposeTiming(xml, 'coverageTiming', TFhirTiming(value.coverage));
end;

function TFHIRXmlParser.ParseCareTeam(element : TMXmlElement; path : string) : TFhirCareTeam;
var
  child : TMXmlElement;
begin
  result := TFhirCareTeam.Create;
  try
    parseDomainResourceAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseCareTeamChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseCareTeamChild(value : TFhirCareTeam; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'identifier') then
        value.identifierList.Add(ParseIdentifier(child, path+'/identifier'))
      else if (child.localName = 'status') then
        value.statusElement := ParseEnum(CODES_TFhirCareTeamStatusEnum, SYSTEMS_TFhirCareTeamStatusEnum, child, path+'/status')
      else if (child.localName = 'category') then
        value.categoryList.Add(ParseCodeableConcept(child, path+'/category'))
      else if (child.localName = 'name') then
        value.nameElement := ParseString(child, path+'/name')
      else if (child.localName = 'subject') then
        value.subject := ParseReference(child, path+'/subject')
      else if (child.localName = 'period') then
        value.period := ParsePeriod(child, path+'/period')
      else if (child.localName = 'participant') then
        value.participantList.Add(ParseCareTeamParticipant(child, path+'/participant'))
      else if (child.localName = 'reason') then
        value.reasonList.Add(ParseCodeableReference(child, path+'/reason'))
      else if (child.localName = 'managingOrganization') then
        value.managingOrganizationList.Add(ParseReference(child, path+'/managingOrganization'))
      else if (child.localName = 'telecom') then
        value.telecomList.Add(ParseContactPoint(child, path+'/telecom'))
      else if (child.localName = 'note') then
        value.noteList.Add(ParseAnnotation(child, path+'/note'))
      else if Not ParseDomainResourceChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeCareTeam(xml : TXmlBuilder; name : String; value : TFhirCareTeam);
begin
  if (value = nil) then
    exit;
  composeDomainResourceAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeCareTeamChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeCareTeamChildren(xml : TXmlBuilder; value : TFhirCareTeam);
var
  i : integer;
begin
  composeDomainResourceChildren(xml, value);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.identifierList.Count - 1 do
      ComposeIdentifier(xml, 'identifier', value.identifierList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeEnum(xml, 'status', value.statusElement, CODES_TFhirCareTeamStatusEnum);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.categoryList.Count - 1 do
      ComposeCodeableConcept(xml, 'category', value.categoryList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(xml, 'name', value.nameElement);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference(xml, 'subject', value.subject);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposePeriod(xml, 'period', value.period);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.participantList.Count - 1 do
      ComposeCareTeamParticipant(xml, 'participant', value.participantList[i]);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.reasonList.Count - 1 do
      ComposeCodeableReference(xml, 'reason', value.reasonList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.managingOrganizationList.Count - 1 do
      ComposeReference(xml, 'managingOrganization', value.managingOrganizationList[i]);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.telecomList.Count - 1 do
      ComposeContactPoint(xml, 'telecom', value.telecomList[i]);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.noteList.Count - 1 do
      ComposeAnnotation(xml, 'note', value.noteList[i]);
end;

{$ENDIF FHIR_CARETEAM}
{$IFDEF FHIR_CHARGEITEM}
function TFHIRXmlParser.ParseChargeItemPerformer(element : TMXmlElement; path : string) : TFhirChargeItemPerformer;
var
  child : TMXmlElement;
begin
  result := TFhirChargeItemPerformer.Create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseChargeItemPerformerChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseChargeItemPerformerChild(value : TFhirChargeItemPerformer; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'function') then
        value.function_ := ParseCodeableConcept(child, path+'/function')
      else if (child.localName = 'actor') then
        value.actor := ParseReference(child, path+'/actor')
      else if Not ParseBackboneElementChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeChargeItemPerformer(xml : TXmlBuilder; name : String; value : TFhirChargeItemPerformer);
begin
  if (value = nil) then
    exit;
  composeElementAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeChargeItemPerformerChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeChargeItemPerformerChildren(xml : TXmlBuilder; value : TFhirChargeItemPerformer);
begin
  composeBackboneElementChildren(xml, value);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(xml, 'function', value.function_);
  ComposeReference(xml, 'actor', value.actor);
end;

function TFHIRXmlParser.ParseChargeItem(element : TMXmlElement; path : string) : TFhirChargeItem;
var
  child : TMXmlElement;
begin
  result := TFhirChargeItem.Create;
  try
    parseDomainResourceAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseChargeItemChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseChargeItemChild(value : TFhirChargeItem; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'identifier') then
        value.identifierList.Add(ParseIdentifier(child, path+'/identifier'))
      else if (child.localName = 'definitionUri') then
        value.definitionUriList.Add(ParseUri(child, path+'/definitionUri'))
      else if (child.localName = 'definitionCanonical') then
        value.definitionCanonicalList.Add(ParseCanonical(child, path+'/definitionCanonical'))
      else if (child.localName = 'status') then
        value.statusElement := ParseEnum(CODES_TFhirChargeItemStatusEnum, SYSTEMS_TFhirChargeItemStatusEnum, child, path+'/status')
      else if (child.localName = 'partOf') then
        value.partOfList.Add(ParseReference(child, path+'/partOf'))
      else if (child.localName = 'code') then
        value.code := ParseCodeableConcept(child, path+'/code')
      else if (child.localName = 'subject') then
        value.subject := ParseReference(child, path+'/subject')
      else if (child.localName = 'encounter') then
        value.encounter := ParseReference(child, path+'/encounter')
      else if (child.localName = 'occurrencePeriod') then
        value.occurrence := ParsePeriod(child, path+'/occurrencePeriod')
      else if (child.localName = 'occurrenceTiming') then
        value.occurrence := ParseTiming(child, path+'/occurrenceTiming')
      else if (child.localName = 'occurrenceDateTime') then
        value.occurrence := ParseDateTime(child, path+'/occurrenceDateTime')
      else if (child.localName = 'performer') then
        value.performerList.Add(ParseChargeItemPerformer(child, path+'/performer'))
      else if (child.localName = 'performingOrganization') then
        value.performingOrganization := ParseReference(child, path+'/performingOrganization')
      else if (child.localName = 'requestingOrganization') then
        value.requestingOrganization := ParseReference(child, path+'/requestingOrganization')
      else if (child.localName = 'costCenter') then
        value.costCenter := ParseReference(child, path+'/costCenter')
      else if (child.localName = 'quantity') then
        value.quantity := ParseQuantity(child, path+'/quantity')
      else if (child.localName = 'bodysite') then
        value.bodysiteList.Add(ParseCodeableConcept(child, path+'/bodysite'))
      else if (child.localName = 'unitPriceComponent') then
        value.unitPriceComponent := ParseMonetaryComponent(child, path+'/unitPriceComponent')
      else if (child.localName = 'totalPriceComponent') then
        value.totalPriceComponent := ParseMonetaryComponent(child, path+'/totalPriceComponent')
      else if (child.localName = 'overrideReason') then
        value.overrideReason := ParseCodeableConcept(child, path+'/overrideReason')
      else if (child.localName = 'enterer') then
        value.enterer := ParseReference(child, path+'/enterer')
      else if (child.localName = 'enteredDate') then
        value.enteredDateElement := ParseDateTime(child, path+'/enteredDate')
      else if (child.localName = 'reason') then
        value.reasonList.Add(ParseCodeableConcept(child, path+'/reason'))
      else if (child.localName = 'service') then
        value.serviceList.Add(ParseCodeableReference(child, path+'/service'))
      else if (child.localName = 'product') then
        value.productList.Add(ParseCodeableReference(child, path+'/product'))
      else if (child.localName = 'account') then
        value.accountList.Add(ParseReference(child, path+'/account'))
      else if (child.localName = 'note') then
        value.noteList.Add(ParseAnnotation(child, path+'/note'))
      else if (child.localName = 'supportingInformation') then
        value.supportingInformationList.Add(ParseReference(child, path+'/supportingInformation'))
      else if Not ParseDomainResourceChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeChargeItem(xml : TXmlBuilder; name : String; value : TFhirChargeItem);
begin
  if (value = nil) then
    exit;
  composeDomainResourceAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeChargeItemChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeChargeItemChildren(xml : TXmlBuilder; value : TFhirChargeItem);
var
  i : integer;
begin
  composeDomainResourceChildren(xml, value);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.identifierList.Count - 1 do
      ComposeIdentifier(xml, 'identifier', value.identifierList[i]);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.definitionUriList.Count - 1 do
      ComposeUri(xml, 'definitionUri', value.definitionUriList[i]);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.definitionCanonicalList.Count - 1 do
      ComposeCanonical(xml, 'definitionCanonical', value.definitionCanonicalList[i]);
  ComposeEnum(xml, 'status', value.statusElement, CODES_TFhirChargeItemStatusEnum);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.partOfList.Count - 1 do
      ComposeReference(xml, 'partOf', value.partOfList[i]);
  ComposeCodeableConcept(xml, 'code', value.code);
  ComposeReference(xml, 'subject', value.subject);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference(xml, 'encounter', value.encounter);
  if (SummaryOption in [soFull, soSummary, soData]) and (value.occurrence is TFhirPeriod) {6} then
    ComposePeriod(xml, 'occurrencePeriod', TFhirPeriod(value.occurrence))
  else if (SummaryOption in [soFull, soSummary, soData]) and (value.occurrence is TFhirTiming) {6} then
    ComposeTiming(xml, 'occurrenceTiming', TFhirTiming(value.occurrence))
  else if (SummaryOption in [soFull, soSummary, soData]) and (value.occurrence is TFhirDateTime) {6} then
    ComposeDateTime(xml, 'occurrenceDateTime', TFhirDateTime(value.occurrence));
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.performerList.Count - 1 do
      ComposeChargeItemPerformer(xml, 'performer', value.performerList[i]);
  if (SummaryOption in [soFull, soData]) then
    ComposeReference(xml, 'performingOrganization', value.performingOrganization);
  if (SummaryOption in [soFull, soData]) then
    ComposeReference(xml, 'requestingOrganization', value.requestingOrganization);
  if (SummaryOption in [soFull, soData]) then
    ComposeReference(xml, 'costCenter', value.costCenter);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeQuantity(xml, 'quantity', value.quantity);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.bodysiteList.Count - 1 do
      ComposeCodeableConcept(xml, 'bodysite', value.bodysiteList[i]);
  if (SummaryOption in [soFull, soData]) then
    ComposeMonetaryComponent(xml, 'unitPriceComponent', value.unitPriceComponent);
  if (SummaryOption in [soFull, soData]) then
    ComposeMonetaryComponent(xml, 'totalPriceComponent', value.totalPriceComponent);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(xml, 'overrideReason', value.overrideReason);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference(xml, 'enterer', value.enterer);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDateTime(xml, 'enteredDate', value.enteredDateElement);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.reasonList.Count - 1 do
      ComposeCodeableConcept(xml, 'reason', value.reasonList[i]);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.serviceList.Count - 1 do
      ComposeCodeableReference(xml, 'service', value.serviceList[i]);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.productList.Count - 1 do
      ComposeCodeableReference(xml, 'product', value.productList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.accountList.Count - 1 do
      ComposeReference(xml, 'account', value.accountList[i]);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.noteList.Count - 1 do
      ComposeAnnotation(xml, 'note', value.noteList[i]);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.supportingInformationList.Count - 1 do
      ComposeReference(xml, 'supportingInformation', value.supportingInformationList[i]);
end;

{$ENDIF FHIR_CHARGEITEM}
{$IFDEF FHIR_CHARGEITEMDEFINITION}
function TFHIRXmlParser.ParseChargeItemDefinitionApplicability(element : TMXmlElement; path : string) : TFhirChargeItemDefinitionApplicability;
var
  child : TMXmlElement;
begin
  result := TFhirChargeItemDefinitionApplicability.Create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseChargeItemDefinitionApplicabilityChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseChargeItemDefinitionApplicabilityChild(value : TFhirChargeItemDefinitionApplicability; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'condition') then
        value.condition := ParseExpression(child, path+'/condition')
      else if (child.localName = 'effectivePeriod') then
        value.effectivePeriod := ParsePeriod(child, path+'/effectivePeriod')
      else if (child.localName = 'relatedArtifact') then
        value.relatedArtifact := ParseRelatedArtifact(child, path+'/relatedArtifact')
      else if Not ParseBackboneElementChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeChargeItemDefinitionApplicability(xml : TXmlBuilder; name : String; value : TFhirChargeItemDefinitionApplicability);
begin
  if (value = nil) then
    exit;
  composeElementAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeChargeItemDefinitionApplicabilityChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeChargeItemDefinitionApplicabilityChildren(xml : TXmlBuilder; value : TFhirChargeItemDefinitionApplicability);
begin
  composeBackboneElementChildren(xml, value);
  if (SummaryOption in [soFull, soData]) then
    ComposeExpression(xml, 'condition', value.condition);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposePeriod(xml, 'effectivePeriod', value.effectivePeriod);
  if (SummaryOption in [soFull, soData]) then
    ComposeRelatedArtifact(xml, 'relatedArtifact', value.relatedArtifact);
end;

function TFHIRXmlParser.ParseChargeItemDefinitionPropertyGroup(element : TMXmlElement; path : string) : TFhirChargeItemDefinitionPropertyGroup;
var
  child : TMXmlElement;
begin
  result := TFhirChargeItemDefinitionPropertyGroup.Create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseChargeItemDefinitionPropertyGroupChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseChargeItemDefinitionPropertyGroupChild(value : TFhirChargeItemDefinitionPropertyGroup; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'applicability') then
        value.applicabilityList.Add(ParseChargeItemDefinitionApplicability(child, path+'/applicability'))
      else if (child.localName = 'priceComponent') then
        value.priceComponentList.Add(ParseMonetaryComponent(child, path+'/priceComponent'))
      else if Not ParseBackboneElementChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeChargeItemDefinitionPropertyGroup(xml : TXmlBuilder; name : String; value : TFhirChargeItemDefinitionPropertyGroup);
begin
  if (value = nil) then
    exit;
  composeElementAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeChargeItemDefinitionPropertyGroupChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeChargeItemDefinitionPropertyGroupChildren(xml : TXmlBuilder; value : TFhirChargeItemDefinitionPropertyGroup);
var
  i : integer;
begin
  composeBackboneElementChildren(xml, value);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.applicabilityList.Count - 1 do
      ComposeChargeItemDefinitionApplicability(xml, 'applicability', value.applicabilityList[i]);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.priceComponentList.Count - 1 do
      ComposeMonetaryComponent(xml, 'priceComponent', value.priceComponentList[i]);
end;

function TFHIRXmlParser.ParseChargeItemDefinition(element : TMXmlElement; path : string) : TFhirChargeItemDefinition;
var
  child : TMXmlElement;
begin
  result := TFhirChargeItemDefinition.Create;
  try
    parseMetadataResourceAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseChargeItemDefinitionChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseChargeItemDefinitionChild(value : TFhirChargeItemDefinition; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'url') then
        value.urlElement := ParseUri(child, path+'/url')
      else if (child.localName = 'identifier') then
        value.identifierList.Add(ParseIdentifier(child, path+'/identifier'))
      else if (child.localName = 'version') then
        value.versionElement := ParseString(child, path+'/version')
      else if (child.localName = 'name') then
        value.nameElement := ParseString(child, path+'/name')
      else if (child.localName = 'title') then
        value.titleElement := ParseString(child, path+'/title')
      else if (child.localName = 'derivedFromUri') then
        value.derivedFromUriList.Add(ParseUri(child, path+'/derivedFromUri'))
      else if (child.localName = 'partOf') then
        value.partOfList.Add(ParseCanonical(child, path+'/partOf'))
      else if (child.localName = 'replaces') then
        value.replacesList.Add(ParseCanonical(child, path+'/replaces'))
      else if (child.localName = 'status') then
        value.statusElement := ParseEnum(CODES_TFhirPublicationStatusEnum, SYSTEMS_TFhirPublicationStatusEnum, child, path+'/status')
      else if (child.localName = 'experimental') then
        value.experimentalElement := ParseBoolean(child, path+'/experimental')
      else if (child.localName = 'date') then
        value.dateElement := ParseDateTime(child, path+'/date')
      else if (child.localName = 'publisher') then
        value.publisherElement := ParseString(child, path+'/publisher')
      else if (child.localName = 'contact') then
        value.contactList.Add(ParseContactDetail(child, path+'/contact'))
      else if (child.localName = 'description') then
        value.descriptionElement := ParseMarkdown(child, path+'/description')
      else if (child.localName = 'useContext') then
        value.useContextList.Add(ParseUsageContext(child, path+'/useContext'))
      else if (child.localName = 'jurisdiction') then
        value.jurisdictionList.Add(ParseCodeableConcept(child, path+'/jurisdiction'))
      else if (child.localName = 'purpose') then
        value.purposeElement := ParseMarkdown(child, path+'/purpose')
      else if (child.localName = 'copyright') then
        value.copyrightElement := ParseMarkdown(child, path+'/copyright')
      else if (child.localName = 'approvalDate') then
        value.approvalDateElement := ParseDate(child, path+'/approvalDate')
      else if (child.localName = 'lastReviewDate') then
        value.lastReviewDateElement := ParseDate(child, path+'/lastReviewDate')
      else if (child.localName = 'code') then
        value.code := ParseCodeableConcept(child, path+'/code')
      else if (child.localName = 'instance') then
        value.instanceList.Add(ParseReference(child, path+'/instance'))
      else if (child.localName = 'applicability') then
        value.applicabilityList.Add(ParseChargeItemDefinitionApplicability(child, path+'/applicability'))
      else if (child.localName = 'propertyGroup') then
        value.propertyGroupList.Add(ParseChargeItemDefinitionPropertyGroup(child, path+'/propertyGroup'))
      else if Not ParseMetadataResourceChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeChargeItemDefinition(xml : TXmlBuilder; name : String; value : TFhirChargeItemDefinition);
begin
  if (value = nil) then
    exit;
  composeMetadataResourceAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeChargeItemDefinitionChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeChargeItemDefinitionChildren(xml : TXmlBuilder; value : TFhirChargeItemDefinition);
var
  i : integer;
begin
  composeMetadataResourceChildren(xml, value);
  ComposeUri(xml, 'url', value.urlElement);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.identifierList.Count - 1 do
      ComposeIdentifier(xml, 'identifier', value.identifierList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(xml, 'version', value.versionElement);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(xml, 'name', value.nameElement);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(xml, 'title', value.titleElement);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.derivedFromUriList.Count - 1 do
      ComposeUri(xml, 'derivedFromUri', value.derivedFromUriList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.partOfList.Count - 1 do
      ComposeCanonical(xml, 'partOf', value.partOfList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.replacesList.Count - 1 do
      ComposeCanonical(xml, 'replaces', value.replacesList[i]);
  ComposeEnum(xml, 'status', value.statusElement, CODES_TFhirPublicationStatusEnum);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeBoolean(xml, 'experimental', value.experimentalElement);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDateTime(xml, 'date', value.dateElement);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(xml, 'publisher', value.publisherElement);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.contactList.Count - 1 do
      ComposeContactDetail(xml, 'contact', value.contactList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeMarkdown(xml, 'description', value.descriptionElement);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.useContextList.Count - 1 do
      ComposeUsageContext(xml, 'useContext', value.useContextList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.jurisdictionList.Count - 1 do
      ComposeCodeableConcept(xml, 'jurisdiction', value.jurisdictionList[i]);
  if (SummaryOption in [soFull, soData]) then
    ComposeMarkdown(xml, 'purpose', value.purposeElement);
  if (SummaryOption in [soFull, soData]) then
    ComposeMarkdown(xml, 'copyright', value.copyrightElement);
  if (SummaryOption in [soFull, soData]) then
    ComposeDate(xml, 'approvalDate', value.approvalDateElement);
  if (SummaryOption in [soFull, soData]) then
    ComposeDate(xml, 'lastReviewDate', value.lastReviewDateElement);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(xml, 'code', value.code);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.instanceList.Count - 1 do
      ComposeReference(xml, 'instance', value.instanceList[i]);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.applicabilityList.Count - 1 do
      ComposeChargeItemDefinitionApplicability(xml, 'applicability', value.applicabilityList[i]);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.propertyGroupList.Count - 1 do
      ComposeChargeItemDefinitionPropertyGroup(xml, 'propertyGroup', value.propertyGroupList[i]);
end;

{$ENDIF FHIR_CHARGEITEMDEFINITION}
{$IFDEF FHIR_CITATION}
function TFHIRXmlParser.ParseCitationSummary(element : TMXmlElement; path : string) : TFhirCitationSummary;
var
  child : TMXmlElement;
begin
  result := TFhirCitationSummary.Create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseCitationSummaryChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseCitationSummaryChild(value : TFhirCitationSummary; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'style') then
        value.style := ParseCodeableConcept(child, path+'/style')
      else if (child.localName = 'text') then
        value.textElement := ParseMarkdown(child, path+'/text')
      else if Not ParseBackboneElementChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeCitationSummary(xml : TXmlBuilder; name : String; value : TFhirCitationSummary);
begin
  if (value = nil) then
    exit;
  composeElementAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeCitationSummaryChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeCitationSummaryChildren(xml : TXmlBuilder; value : TFhirCitationSummary);
begin
  composeBackboneElementChildren(xml, value);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(xml, 'style', value.style);
  ComposeMarkdown(xml, 'text', value.textElement);
end;

function TFHIRXmlParser.ParseCitationClassification(element : TMXmlElement; path : string) : TFhirCitationClassification;
var
  child : TMXmlElement;
begin
  result := TFhirCitationClassification.Create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseCitationClassificationChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseCitationClassificationChild(value : TFhirCitationClassification; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'type') then
        value.type_ := ParseCodeableConcept(child, path+'/type')
      else if (child.localName = 'classifier') then
        value.classifierList.Add(ParseCodeableConcept(child, path+'/classifier'))
      else if Not ParseBackboneElementChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeCitationClassification(xml : TXmlBuilder; name : String; value : TFhirCitationClassification);
begin
  if (value = nil) then
    exit;
  composeElementAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeCitationClassificationChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeCitationClassificationChildren(xml : TXmlBuilder; value : TFhirCitationClassification);
var
  i : integer;
begin
  composeBackboneElementChildren(xml, value);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(xml, 'type', value.type_);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.classifierList.Count - 1 do
      ComposeCodeableConcept(xml, 'classifier', value.classifierList[i]);
end;

function TFHIRXmlParser.ParseCitationStatusDate(element : TMXmlElement; path : string) : TFhirCitationStatusDate;
var
  child : TMXmlElement;
begin
  result := TFhirCitationStatusDate.Create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseCitationStatusDateChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseCitationStatusDateChild(value : TFhirCitationStatusDate; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'activity') then
        value.activity := ParseCodeableConcept(child, path+'/activity')
      else if (child.localName = 'actual') then
        value.actualElement := ParseBoolean(child, path+'/actual')
      else if (child.localName = 'period') then
        value.period := ParsePeriod(child, path+'/period')
      else if Not ParseBackboneElementChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeCitationStatusDate(xml : TXmlBuilder; name : String; value : TFhirCitationStatusDate);
begin
  if (value = nil) then
    exit;
  composeElementAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeCitationStatusDateChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeCitationStatusDateChildren(xml : TXmlBuilder; value : TFhirCitationStatusDate);
begin
  composeBackboneElementChildren(xml, value);
  ComposeCodeableConcept(xml, 'activity', value.activity);
  if (SummaryOption in [soFull, soData]) then
    ComposeBoolean(xml, 'actual', value.actualElement);
  ComposePeriod(xml, 'period', value.period);
end;

function TFHIRXmlParser.ParseCitationCitedArtifact(element : TMXmlElement; path : string) : TFhirCitationCitedArtifact;
var
  child : TMXmlElement;
begin
  result := TFhirCitationCitedArtifact.Create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseCitationCitedArtifactChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseCitationCitedArtifactChild(value : TFhirCitationCitedArtifact; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'identifier') then
        value.identifierList.Add(ParseIdentifier(child, path+'/identifier'))
      else if (child.localName = 'relatedIdentifier') then
        value.relatedIdentifierList.Add(ParseIdentifier(child, path+'/relatedIdentifier'))
      else if (child.localName = 'dateAccessed') then
        value.dateAccessedElement := ParseDateTime(child, path+'/dateAccessed')
      else if (child.localName = 'version') then
        value.version := ParseCitationCitedArtifactVersion(child, path+'/version')
      else if (child.localName = 'currentState') then
        value.currentStateList.Add(ParseCodeableConcept(child, path+'/currentState'))
      else if (child.localName = 'statusDate') then
        value.statusDateList.Add(ParseCitationCitedArtifactStatusDate(child, path+'/statusDate'))
      else if (child.localName = 'title') then
        value.titleList.Add(ParseCitationCitedArtifactTitle(child, path+'/title'))
      else if (child.localName = 'abstract') then
        value.abstractList.Add(ParseCitationCitedArtifactAbstract(child, path+'/abstract'))
      else if (child.localName = 'part') then
        value.part := ParseCitationCitedArtifactPart(child, path+'/part')
      else if (child.localName = 'relatesTo') then
        value.relatesToList.Add(ParseCitationCitedArtifactRelatesTo(child, path+'/relatesTo'))
      else if (child.localName = 'publicationForm') then
        value.publicationFormList.Add(ParseCitationCitedArtifactPublicationForm(child, path+'/publicationForm'))
      else if (child.localName = 'webLocation') then
        value.webLocationList.Add(ParseCitationCitedArtifactWebLocation(child, path+'/webLocation'))
      else if (child.localName = 'classification') then
        value.classificationList.Add(ParseCitationCitedArtifactClassification(child, path+'/classification'))
      else if (child.localName = 'contributorship') then
        value.contributorship := ParseCitationCitedArtifactContributorship(child, path+'/contributorship')
      else if (child.localName = 'note') then
        value.noteList.Add(ParseAnnotation(child, path+'/note'))
      else if Not ParseBackboneElementChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeCitationCitedArtifact(xml : TXmlBuilder; name : String; value : TFhirCitationCitedArtifact);
begin
  if (value = nil) then
    exit;
  composeElementAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeCitationCitedArtifactChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeCitationCitedArtifactChildren(xml : TXmlBuilder; value : TFhirCitationCitedArtifact);
var
  i : integer;
begin
  composeBackboneElementChildren(xml, value);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.identifierList.Count - 1 do
      ComposeIdentifier(xml, 'identifier', value.identifierList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.relatedIdentifierList.Count - 1 do
      ComposeIdentifier(xml, 'relatedIdentifier', value.relatedIdentifierList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDateTime(xml, 'dateAccessed', value.dateAccessedElement);
  if (SummaryOption in [soFull, soData]) then
    ComposeCitationCitedArtifactVersion(xml, 'version', value.version);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.currentStateList.Count - 1 do
      ComposeCodeableConcept(xml, 'currentState', value.currentStateList[i]);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.statusDateList.Count - 1 do
      ComposeCitationCitedArtifactStatusDate(xml, 'statusDate', value.statusDateList[i]);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.titleList.Count - 1 do
      ComposeCitationCitedArtifactTitle(xml, 'title', value.titleList[i]);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.abstractList.Count - 1 do
      ComposeCitationCitedArtifactAbstract(xml, 'abstract', value.abstractList[i]);
  if (SummaryOption in [soFull, soData]) then
    ComposeCitationCitedArtifactPart(xml, 'part', value.part);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.relatesToList.Count - 1 do
      ComposeCitationCitedArtifactRelatesTo(xml, 'relatesTo', value.relatesToList[i]);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.publicationFormList.Count - 1 do
      ComposeCitationCitedArtifactPublicationForm(xml, 'publicationForm', value.publicationFormList[i]);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.webLocationList.Count - 1 do
      ComposeCitationCitedArtifactWebLocation(xml, 'webLocation', value.webLocationList[i]);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.classificationList.Count - 1 do
      ComposeCitationCitedArtifactClassification(xml, 'classification', value.classificationList[i]);
  if (SummaryOption in [soFull, soData]) then
    ComposeCitationCitedArtifactContributorship(xml, 'contributorship', value.contributorship);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.noteList.Count - 1 do
      ComposeAnnotation(xml, 'note', value.noteList[i]);
end;

function TFHIRXmlParser.ParseCitationCitedArtifactVersion(element : TMXmlElement; path : string) : TFhirCitationCitedArtifactVersion;
var
  child : TMXmlElement;
begin
  result := TFhirCitationCitedArtifactVersion.Create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseCitationCitedArtifactVersionChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseCitationCitedArtifactVersionChild(value : TFhirCitationCitedArtifactVersion; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'value') then
        value.valueElement := ParseString(child, path+'/value')
      else if (child.localName = 'baseCitation') then
        value.baseCitation := ParseReference(child, path+'/baseCitation')
      else if Not ParseBackboneElementChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeCitationCitedArtifactVersion(xml : TXmlBuilder; name : String; value : TFhirCitationCitedArtifactVersion);
begin
  if (value = nil) then
    exit;
  composeElementAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeCitationCitedArtifactVersionChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeCitationCitedArtifactVersionChildren(xml : TXmlBuilder; value : TFhirCitationCitedArtifactVersion);
begin
  composeBackboneElementChildren(xml, value);
  ComposeString(xml, 'value', value.valueElement);
  if (SummaryOption in [soFull, soData]) then
    ComposeReference(xml, 'baseCitation', value.baseCitation);
end;

function TFHIRXmlParser.ParseCitationCitedArtifactStatusDate(element : TMXmlElement; path : string) : TFhirCitationCitedArtifactStatusDate;
var
  child : TMXmlElement;
begin
  result := TFhirCitationCitedArtifactStatusDate.Create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseCitationCitedArtifactStatusDateChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseCitationCitedArtifactStatusDateChild(value : TFhirCitationCitedArtifactStatusDate; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'activity') then
        value.activity := ParseCodeableConcept(child, path+'/activity')
      else if (child.localName = 'actual') then
        value.actualElement := ParseBoolean(child, path+'/actual')
      else if (child.localName = 'period') then
        value.period := ParsePeriod(child, path+'/period')
      else if Not ParseBackboneElementChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeCitationCitedArtifactStatusDate(xml : TXmlBuilder; name : String; value : TFhirCitationCitedArtifactStatusDate);
begin
  if (value = nil) then
    exit;
  composeElementAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeCitationCitedArtifactStatusDateChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeCitationCitedArtifactStatusDateChildren(xml : TXmlBuilder; value : TFhirCitationCitedArtifactStatusDate);
begin
  composeBackboneElementChildren(xml, value);
  ComposeCodeableConcept(xml, 'activity', value.activity);
  if (SummaryOption in [soFull, soData]) then
    ComposeBoolean(xml, 'actual', value.actualElement);
  ComposePeriod(xml, 'period', value.period);
end;

function TFHIRXmlParser.ParseCitationCitedArtifactTitle(element : TMXmlElement; path : string) : TFhirCitationCitedArtifactTitle;
var
  child : TMXmlElement;
begin
  result := TFhirCitationCitedArtifactTitle.Create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseCitationCitedArtifactTitleChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseCitationCitedArtifactTitleChild(value : TFhirCitationCitedArtifactTitle; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'type') then
        value.type_List.Add(ParseCodeableConcept(child, path+'/type'))
      else if (child.localName = 'language') then
        value.language := ParseCodeableConcept(child, path+'/language')
      else if (child.localName = 'text') then
        value.textElement := ParseMarkdown(child, path+'/text')
      else if Not ParseBackboneElementChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeCitationCitedArtifactTitle(xml : TXmlBuilder; name : String; value : TFhirCitationCitedArtifactTitle);
begin
  if (value = nil) then
    exit;
  composeElementAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeCitationCitedArtifactTitleChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeCitationCitedArtifactTitleChildren(xml : TXmlBuilder; value : TFhirCitationCitedArtifactTitle);
var
  i : integer;
begin
  composeBackboneElementChildren(xml, value);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.type_List.Count - 1 do
      ComposeCodeableConcept(xml, 'type', value.type_List[i]);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(xml, 'language', value.language);
  ComposeMarkdown(xml, 'text', value.textElement);
end;

function TFHIRXmlParser.ParseCitationCitedArtifactAbstract(element : TMXmlElement; path : string) : TFhirCitationCitedArtifactAbstract;
var
  child : TMXmlElement;
begin
  result := TFhirCitationCitedArtifactAbstract.Create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseCitationCitedArtifactAbstractChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseCitationCitedArtifactAbstractChild(value : TFhirCitationCitedArtifactAbstract; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'type') then
        value.type_ := ParseCodeableConcept(child, path+'/type')
      else if (child.localName = 'language') then
        value.language := ParseCodeableConcept(child, path+'/language')
      else if (child.localName = 'text') then
        value.textElement := ParseMarkdown(child, path+'/text')
      else if (child.localName = 'copyright') then
        value.copyrightElement := ParseMarkdown(child, path+'/copyright')
      else if Not ParseBackboneElementChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeCitationCitedArtifactAbstract(xml : TXmlBuilder; name : String; value : TFhirCitationCitedArtifactAbstract);
begin
  if (value = nil) then
    exit;
  composeElementAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeCitationCitedArtifactAbstractChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeCitationCitedArtifactAbstractChildren(xml : TXmlBuilder; value : TFhirCitationCitedArtifactAbstract);
begin
  composeBackboneElementChildren(xml, value);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(xml, 'type', value.type_);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(xml, 'language', value.language);
  ComposeMarkdown(xml, 'text', value.textElement);
  if (SummaryOption in [soFull, soData]) then
    ComposeMarkdown(xml, 'copyright', value.copyrightElement);
end;

function TFHIRXmlParser.ParseCitationCitedArtifactPart(element : TMXmlElement; path : string) : TFhirCitationCitedArtifactPart;
var
  child : TMXmlElement;
begin
  result := TFhirCitationCitedArtifactPart.Create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseCitationCitedArtifactPartChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseCitationCitedArtifactPartChild(value : TFhirCitationCitedArtifactPart; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'type') then
        value.type_ := ParseCodeableConcept(child, path+'/type')
      else if (child.localName = 'value') then
        value.valueElement := ParseString(child, path+'/value')
      else if (child.localName = 'baseCitation') then
        value.baseCitation := ParseReference(child, path+'/baseCitation')
      else if Not ParseBackboneElementChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeCitationCitedArtifactPart(xml : TXmlBuilder; name : String; value : TFhirCitationCitedArtifactPart);
begin
  if (value = nil) then
    exit;
  composeElementAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeCitationCitedArtifactPartChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeCitationCitedArtifactPartChildren(xml : TXmlBuilder; value : TFhirCitationCitedArtifactPart);
begin
  composeBackboneElementChildren(xml, value);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(xml, 'type', value.type_);
  if (SummaryOption in [soFull, soData]) then
    ComposeString(xml, 'value', value.valueElement);
  if (SummaryOption in [soFull, soData]) then
    ComposeReference(xml, 'baseCitation', value.baseCitation);
end;

function TFHIRXmlParser.ParseCitationCitedArtifactRelatesTo(element : TMXmlElement; path : string) : TFhirCitationCitedArtifactRelatesTo;
var
  child : TMXmlElement;
begin
  result := TFhirCitationCitedArtifactRelatesTo.Create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseCitationCitedArtifactRelatesToChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseCitationCitedArtifactRelatesToChild(value : TFhirCitationCitedArtifactRelatesTo; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'type') then
        value.type_Element := ParseEnum(CODES_TFhirRelatedArtifactTypeExpandedEnum, SYSTEMS_TFhirRelatedArtifactTypeExpandedEnum, child, path+'/type')
      else if (child.localName = 'classifier') then
        value.classifierList.Add(ParseCodeableConcept(child, path+'/classifier'))
      else if (child.localName = 'label') then
        value.label_Element := ParseString(child, path+'/label')
      else if (child.localName = 'display') then
        value.displayElement := ParseString(child, path+'/display')
      else if (child.localName = 'citation') then
        value.citationElement := ParseMarkdown(child, path+'/citation')
      else if (child.localName = 'document') then
        value.document := ParseAttachment(child, path+'/document')
      else if (child.localName = 'resource') then
        value.resourceElement := ParseCanonical(child, path+'/resource')
      else if (child.localName = 'resourceReference') then
        value.resourceReference := ParseReference(child, path+'/resourceReference')
      else if Not ParseBackboneElementChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeCitationCitedArtifactRelatesTo(xml : TXmlBuilder; name : String; value : TFhirCitationCitedArtifactRelatesTo);
begin
  if (value = nil) then
    exit;
  composeElementAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeCitationCitedArtifactRelatesToChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeCitationCitedArtifactRelatesToChildren(xml : TXmlBuilder; value : TFhirCitationCitedArtifactRelatesTo);
var
  i : integer;
begin
  composeBackboneElementChildren(xml, value);
  ComposeEnum(xml, 'type', value.type_Element, CODES_TFhirRelatedArtifactTypeExpandedEnum);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.classifierList.Count - 1 do
      ComposeCodeableConcept(xml, 'classifier', value.classifierList[i]);
  if (SummaryOption in [soFull, soData]) then
    ComposeString(xml, 'label', value.label_Element);
  if (SummaryOption in [soFull, soData]) then
    ComposeString(xml, 'display', value.displayElement);
  if (SummaryOption in [soFull, soData]) then
    ComposeMarkdown(xml, 'citation', value.citationElement);
  if (SummaryOption in [soFull, soData]) then
    ComposeAttachment(xml, 'document', value.document);
  if (SummaryOption in [soFull, soData]) then
    ComposeCanonical(xml, 'resource', value.resourceElement);
  if (SummaryOption in [soFull, soData]) then
    ComposeReference(xml, 'resourceReference', value.resourceReference);
end;

function TFHIRXmlParser.ParseCitationCitedArtifactPublicationForm(element : TMXmlElement; path : string) : TFhirCitationCitedArtifactPublicationForm;
var
  child : TMXmlElement;
begin
  result := TFhirCitationCitedArtifactPublicationForm.Create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseCitationCitedArtifactPublicationFormChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseCitationCitedArtifactPublicationFormChild(value : TFhirCitationCitedArtifactPublicationForm; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'publishedIn') then
        value.publishedIn := ParseCitationCitedArtifactPublicationFormPublishedIn(child, path+'/publishedIn')
      else if (child.localName = 'citedMedium') then
        value.citedMedium := ParseCodeableConcept(child, path+'/citedMedium')
      else if (child.localName = 'volume') then
        value.volumeElement := ParseString(child, path+'/volume')
      else if (child.localName = 'issue') then
        value.issueElement := ParseString(child, path+'/issue')
      else if (child.localName = 'publicationDateYear') then
        value.publicationDateYearElement := ParseString(child, path+'/publicationDateYear')
      else if (child.localName = 'publicationDateMonth') then
        value.publicationDateMonthElement := ParseString(child, path+'/publicationDateMonth')
      else if (child.localName = 'publicationDateDay') then
        value.publicationDateDayElement := ParseString(child, path+'/publicationDateDay')
      else if (child.localName = 'publicationDateSeason') then
        value.publicationDateSeasonElement := ParseString(child, path+'/publicationDateSeason')
      else if (child.localName = 'publicationDateText') then
        value.publicationDateTextElement := ParseString(child, path+'/publicationDateText')
      else if (child.localName = 'articleDate') then
        value.articleDateElement := ParseDateTime(child, path+'/articleDate')
      else if (child.localName = 'lastRevisionDate') then
        value.lastRevisionDateElement := ParseDateTime(child, path+'/lastRevisionDate')
      else if (child.localName = 'language') then
        value.languageList.Add(ParseCodeableConcept(child, path+'/language'))
      else if (child.localName = 'accessionNumber') then
        value.accessionNumberElement := ParseString(child, path+'/accessionNumber')
      else if (child.localName = 'pageString') then
        value.pageStringElement := ParseString(child, path+'/pageString')
      else if (child.localName = 'firstPage') then
        value.firstPageElement := ParseString(child, path+'/firstPage')
      else if (child.localName = 'lastPage') then
        value.lastPageElement := ParseString(child, path+'/lastPage')
      else if (child.localName = 'pageCount') then
        value.pageCountElement := ParseString(child, path+'/pageCount')
      else if (child.localName = 'copyright') then
        value.copyrightElement := ParseMarkdown(child, path+'/copyright')
      else if Not ParseBackboneElementChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeCitationCitedArtifactPublicationForm(xml : TXmlBuilder; name : String; value : TFhirCitationCitedArtifactPublicationForm);
begin
  if (value = nil) then
    exit;
  composeElementAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeCitationCitedArtifactPublicationFormChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeCitationCitedArtifactPublicationFormChildren(xml : TXmlBuilder; value : TFhirCitationCitedArtifactPublicationForm);
var
  i : integer;
begin
  composeBackboneElementChildren(xml, value);
  if (SummaryOption in [soFull, soData]) then
    ComposeCitationCitedArtifactPublicationFormPublishedIn(xml, 'publishedIn', value.publishedIn);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(xml, 'citedMedium', value.citedMedium);
  if (SummaryOption in [soFull, soData]) then
    ComposeString(xml, 'volume', value.volumeElement);
  if (SummaryOption in [soFull, soData]) then
    ComposeString(xml, 'issue', value.issueElement);
  if (SummaryOption in [soFull, soData]) then
    ComposeString(xml, 'publicationDateYear', value.publicationDateYearElement);
  if (SummaryOption in [soFull, soData]) then
    ComposeString(xml, 'publicationDateMonth', value.publicationDateMonthElement);
  if (SummaryOption in [soFull, soData]) then
    ComposeString(xml, 'publicationDateDay', value.publicationDateDayElement);
  if (SummaryOption in [soFull, soData]) then
    ComposeString(xml, 'publicationDateSeason', value.publicationDateSeasonElement);
  if (SummaryOption in [soFull, soData]) then
    ComposeString(xml, 'publicationDateText', value.publicationDateTextElement);
  if (SummaryOption in [soFull, soData]) then
    ComposeDateTime(xml, 'articleDate', value.articleDateElement);
  if (SummaryOption in [soFull, soData]) then
    ComposeDateTime(xml, 'lastRevisionDate', value.lastRevisionDateElement);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.languageList.Count - 1 do
      ComposeCodeableConcept(xml, 'language', value.languageList[i]);
  if (SummaryOption in [soFull, soData]) then
    ComposeString(xml, 'accessionNumber', value.accessionNumberElement);
  if (SummaryOption in [soFull, soData]) then
    ComposeString(xml, 'pageString', value.pageStringElement);
  if (SummaryOption in [soFull, soData]) then
    ComposeString(xml, 'firstPage', value.firstPageElement);
  if (SummaryOption in [soFull, soData]) then
    ComposeString(xml, 'lastPage', value.lastPageElement);
  if (SummaryOption in [soFull, soData]) then
    ComposeString(xml, 'pageCount', value.pageCountElement);
  if (SummaryOption in [soFull, soData]) then
    ComposeMarkdown(xml, 'copyright', value.copyrightElement);
end;

function TFHIRXmlParser.ParseCitationCitedArtifactPublicationFormPublishedIn(element : TMXmlElement; path : string) : TFhirCitationCitedArtifactPublicationFormPublishedIn;
var
  child : TMXmlElement;
begin
  result := TFhirCitationCitedArtifactPublicationFormPublishedIn.Create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseCitationCitedArtifactPublicationFormPublishedInChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseCitationCitedArtifactPublicationFormPublishedInChild(value : TFhirCitationCitedArtifactPublicationFormPublishedIn; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'type') then
        value.type_ := ParseCodeableConcept(child, path+'/type')
      else if (child.localName = 'identifier') then
        value.identifierList.Add(ParseIdentifier(child, path+'/identifier'))
      else if (child.localName = 'title') then
        value.titleElement := ParseString(child, path+'/title')
      else if (child.localName = 'publisher') then
        value.publisher := ParseReference(child, path+'/publisher')
      else if (child.localName = 'publisherLocation') then
        value.publisherLocationElement := ParseString(child, path+'/publisherLocation')
      else if Not ParseBackboneElementChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeCitationCitedArtifactPublicationFormPublishedIn(xml : TXmlBuilder; name : String; value : TFhirCitationCitedArtifactPublicationFormPublishedIn);
begin
  if (value = nil) then
    exit;
  composeElementAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeCitationCitedArtifactPublicationFormPublishedInChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeCitationCitedArtifactPublicationFormPublishedInChildren(xml : TXmlBuilder; value : TFhirCitationCitedArtifactPublicationFormPublishedIn);
var
  i : integer;
begin
  composeBackboneElementChildren(xml, value);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(xml, 'type', value.type_);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.identifierList.Count - 1 do
      ComposeIdentifier(xml, 'identifier', value.identifierList[i]);
  if (SummaryOption in [soFull, soData]) then
    ComposeString(xml, 'title', value.titleElement);
  if (SummaryOption in [soFull, soData]) then
    ComposeReference(xml, 'publisher', value.publisher);
  if (SummaryOption in [soFull, soData]) then
    ComposeString(xml, 'publisherLocation', value.publisherLocationElement);
end;

function TFHIRXmlParser.ParseCitationCitedArtifactWebLocation(element : TMXmlElement; path : string) : TFhirCitationCitedArtifactWebLocation;
var
  child : TMXmlElement;
begin
  result := TFhirCitationCitedArtifactWebLocation.Create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseCitationCitedArtifactWebLocationChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseCitationCitedArtifactWebLocationChild(value : TFhirCitationCitedArtifactWebLocation; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'classifier') then
        value.classifierList.Add(ParseCodeableConcept(child, path+'/classifier'))
      else if (child.localName = 'url') then
        value.urlElement := ParseUri(child, path+'/url')
      else if Not ParseBackboneElementChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeCitationCitedArtifactWebLocation(xml : TXmlBuilder; name : String; value : TFhirCitationCitedArtifactWebLocation);
begin
  if (value = nil) then
    exit;
  composeElementAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeCitationCitedArtifactWebLocationChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeCitationCitedArtifactWebLocationChildren(xml : TXmlBuilder; value : TFhirCitationCitedArtifactWebLocation);
var
  i : integer;
begin
  composeBackboneElementChildren(xml, value);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.classifierList.Count - 1 do
      ComposeCodeableConcept(xml, 'classifier', value.classifierList[i]);
  if (SummaryOption in [soFull, soData]) then
    ComposeUri(xml, 'url', value.urlElement);
end;

function TFHIRXmlParser.ParseCitationCitedArtifactClassification(element : TMXmlElement; path : string) : TFhirCitationCitedArtifactClassification;
var
  child : TMXmlElement;
begin
  result := TFhirCitationCitedArtifactClassification.Create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseCitationCitedArtifactClassificationChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseCitationCitedArtifactClassificationChild(value : TFhirCitationCitedArtifactClassification; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'type') then
        value.type_ := ParseCodeableConcept(child, path+'/type')
      else if (child.localName = 'classifier') then
        value.classifierList.Add(ParseCodeableConcept(child, path+'/classifier'))
      else if (child.localName = 'artifactAssessment') then
        value.artifactAssessmentList.Add(ParseReference(child, path+'/artifactAssessment'))
      else if Not ParseBackboneElementChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeCitationCitedArtifactClassification(xml : TXmlBuilder; name : String; value : TFhirCitationCitedArtifactClassification);
begin
  if (value = nil) then
    exit;
  composeElementAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeCitationCitedArtifactClassificationChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeCitationCitedArtifactClassificationChildren(xml : TXmlBuilder; value : TFhirCitationCitedArtifactClassification);
var
  i : integer;
begin
  composeBackboneElementChildren(xml, value);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(xml, 'type', value.type_);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.classifierList.Count - 1 do
      ComposeCodeableConcept(xml, 'classifier', value.classifierList[i]);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.artifactAssessmentList.Count - 1 do
      ComposeReference(xml, 'artifactAssessment', value.artifactAssessmentList[i]);
end;

function TFHIRXmlParser.ParseCitationCitedArtifactContributorship(element : TMXmlElement; path : string) : TFhirCitationCitedArtifactContributorship;
var
  child : TMXmlElement;
begin
  result := TFhirCitationCitedArtifactContributorship.Create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseCitationCitedArtifactContributorshipChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseCitationCitedArtifactContributorshipChild(value : TFhirCitationCitedArtifactContributorship; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'complete') then
        value.completeElement := ParseBoolean(child, path+'/complete')
      else if (child.localName = 'entry') then
        value.entryList.Add(ParseCitationCitedArtifactContributorshipEntry(child, path+'/entry'))
      else if (child.localName = 'summary') then
        value.summaryList.Add(ParseCitationCitedArtifactContributorshipSummary(child, path+'/summary'))
      else if Not ParseBackboneElementChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeCitationCitedArtifactContributorship(xml : TXmlBuilder; name : String; value : TFhirCitationCitedArtifactContributorship);
begin
  if (value = nil) then
    exit;
  composeElementAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeCitationCitedArtifactContributorshipChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeCitationCitedArtifactContributorshipChildren(xml : TXmlBuilder; value : TFhirCitationCitedArtifactContributorship);
var
  i : integer;
begin
  composeBackboneElementChildren(xml, value);
  if (SummaryOption in [soFull, soData]) then
    ComposeBoolean(xml, 'complete', value.completeElement);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.entryList.Count - 1 do
      ComposeCitationCitedArtifactContributorshipEntry(xml, 'entry', value.entryList[i]);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.summaryList.Count - 1 do
      ComposeCitationCitedArtifactContributorshipSummary(xml, 'summary', value.summaryList[i]);
end;

function TFHIRXmlParser.ParseCitationCitedArtifactContributorshipEntry(element : TMXmlElement; path : string) : TFhirCitationCitedArtifactContributorshipEntry;
var
  child : TMXmlElement;
begin
  result := TFhirCitationCitedArtifactContributorshipEntry.Create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseCitationCitedArtifactContributorshipEntryChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseCitationCitedArtifactContributorshipEntryChild(value : TFhirCitationCitedArtifactContributorshipEntry; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'contributor') then
        value.contributor := ParseReference(child, path+'/contributor')
      else if (child.localName = 'forenameInitials') then
        value.forenameInitialsElement := ParseString(child, path+'/forenameInitials')
      else if (child.localName = 'affiliation') then
        value.affiliationList.Add(ParseReference(child, path+'/affiliation'))
      else if (child.localName = 'contributionType') then
        value.contributionTypeList.Add(ParseCodeableConcept(child, path+'/contributionType'))
      else if (child.localName = 'role') then
        value.role := ParseCodeableConcept(child, path+'/role')
      else if (child.localName = 'contributionInstance') then
        value.contributionInstanceList.Add(ParseCitationCitedArtifactContributorshipEntryContributionInstance(child, path+'/contributionInstance'))
      else if (child.localName = 'correspondingContact') then
        value.correspondingContactElement := ParseBoolean(child, path+'/correspondingContact')
      else if (child.localName = 'rankingOrder') then
        value.rankingOrderElement := ParsePositiveInt(child, path+'/rankingOrder')
      else if Not ParseBackboneElementChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeCitationCitedArtifactContributorshipEntry(xml : TXmlBuilder; name : String; value : TFhirCitationCitedArtifactContributorshipEntry);
begin
  if (value = nil) then
    exit;
  composeElementAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeCitationCitedArtifactContributorshipEntryChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeCitationCitedArtifactContributorshipEntryChildren(xml : TXmlBuilder; value : TFhirCitationCitedArtifactContributorshipEntry);
var
  i : integer;
begin
  composeBackboneElementChildren(xml, value);
  ComposeReference(xml, 'contributor', value.contributor);
  if (SummaryOption in [soFull, soData]) then
    ComposeString(xml, 'forenameInitials', value.forenameInitialsElement);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.affiliationList.Count - 1 do
      ComposeReference(xml, 'affiliation', value.affiliationList[i]);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.contributionTypeList.Count - 1 do
      ComposeCodeableConcept(xml, 'contributionType', value.contributionTypeList[i]);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(xml, 'role', value.role);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.contributionInstanceList.Count - 1 do
      ComposeCitationCitedArtifactContributorshipEntryContributionInstance(xml, 'contributionInstance', value.contributionInstanceList[i]);
  if (SummaryOption in [soFull, soData]) then
    ComposeBoolean(xml, 'correspondingContact', value.correspondingContactElement);
  if (SummaryOption in [soFull, soData]) then
    ComposePositiveInt(xml, 'rankingOrder', value.rankingOrderElement);
end;

function TFHIRXmlParser.ParseCitationCitedArtifactContributorshipEntryContributionInstance(element : TMXmlElement; path : string) : TFhirCitationCitedArtifactContributorshipEntryContributionInstance;
var
  child : TMXmlElement;
begin
  result := TFhirCitationCitedArtifactContributorshipEntryContributionInstance.Create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseCitationCitedArtifactContributorshipEntryContributionInstanceChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseCitationCitedArtifactContributorshipEntryContributionInstanceChild(value : TFhirCitationCitedArtifactContributorshipEntryContributionInstance; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'type') then
        value.type_ := ParseCodeableConcept(child, path+'/type')
      else if (child.localName = 'time') then
        value.timeElement := ParseDateTime(child, path+'/time')
      else if Not ParseBackboneElementChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeCitationCitedArtifactContributorshipEntryContributionInstance(xml : TXmlBuilder; name : String; value : TFhirCitationCitedArtifactContributorshipEntryContributionInstance);
begin
  if (value = nil) then
    exit;
  composeElementAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeCitationCitedArtifactContributorshipEntryContributionInstanceChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeCitationCitedArtifactContributorshipEntryContributionInstanceChildren(xml : TXmlBuilder; value : TFhirCitationCitedArtifactContributorshipEntryContributionInstance);
begin
  composeBackboneElementChildren(xml, value);
  ComposeCodeableConcept(xml, 'type', value.type_);
  if (SummaryOption in [soFull, soData]) then
    ComposeDateTime(xml, 'time', value.timeElement);
end;

function TFHIRXmlParser.ParseCitationCitedArtifactContributorshipSummary(element : TMXmlElement; path : string) : TFhirCitationCitedArtifactContributorshipSummary;
var
  child : TMXmlElement;
begin
  result := TFhirCitationCitedArtifactContributorshipSummary.Create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseCitationCitedArtifactContributorshipSummaryChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseCitationCitedArtifactContributorshipSummaryChild(value : TFhirCitationCitedArtifactContributorshipSummary; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'type') then
        value.type_ := ParseCodeableConcept(child, path+'/type')
      else if (child.localName = 'style') then
        value.style := ParseCodeableConcept(child, path+'/style')
      else if (child.localName = 'source') then
        value.source := ParseCodeableConcept(child, path+'/source')
      else if (child.localName = 'value') then
        value.valueElement := ParseMarkdown(child, path+'/value')
      else if Not ParseBackboneElementChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeCitationCitedArtifactContributorshipSummary(xml : TXmlBuilder; name : String; value : TFhirCitationCitedArtifactContributorshipSummary);
begin
  if (value = nil) then
    exit;
  composeElementAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeCitationCitedArtifactContributorshipSummaryChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeCitationCitedArtifactContributorshipSummaryChildren(xml : TXmlBuilder; value : TFhirCitationCitedArtifactContributorshipSummary);
begin
  composeBackboneElementChildren(xml, value);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(xml, 'type', value.type_);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(xml, 'style', value.style);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(xml, 'source', value.source);
  ComposeMarkdown(xml, 'value', value.valueElement);
end;

function TFHIRXmlParser.ParseCitation(element : TMXmlElement; path : string) : TFhirCitation;
var
  child : TMXmlElement;
begin
  result := TFhirCitation.Create;
  try
    parseMetadataResourceAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseCitationChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseCitationChild(value : TFhirCitation; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'url') then
        value.urlElement := ParseUri(child, path+'/url')
      else if (child.localName = 'identifier') then
        value.identifierList.Add(ParseIdentifier(child, path+'/identifier'))
      else if (child.localName = 'version') then
        value.versionElement := ParseString(child, path+'/version')
      else if (child.localName = 'name') then
        value.nameElement := ParseString(child, path+'/name')
      else if (child.localName = 'title') then
        value.titleElement := ParseString(child, path+'/title')
      else if (child.localName = 'status') then
        value.statusElement := ParseEnum(CODES_TFhirPublicationStatusEnum, SYSTEMS_TFhirPublicationStatusEnum, child, path+'/status')
      else if (child.localName = 'experimental') then
        value.experimentalElement := ParseBoolean(child, path+'/experimental')
      else if (child.localName = 'date') then
        value.dateElement := ParseDateTime(child, path+'/date')
      else if (child.localName = 'publisher') then
        value.publisherElement := ParseString(child, path+'/publisher')
      else if (child.localName = 'contact') then
        value.contactList.Add(ParseContactDetail(child, path+'/contact'))
      else if (child.localName = 'description') then
        value.descriptionElement := ParseMarkdown(child, path+'/description')
      else if (child.localName = 'useContext') then
        value.useContextList.Add(ParseUsageContext(child, path+'/useContext'))
      else if (child.localName = 'jurisdiction') then
        value.jurisdictionList.Add(ParseCodeableConcept(child, path+'/jurisdiction'))
      else if (child.localName = 'purpose') then
        value.purposeElement := ParseMarkdown(child, path+'/purpose')
      else if (child.localName = 'copyright') then
        value.copyrightElement := ParseMarkdown(child, path+'/copyright')
      else if (child.localName = 'approvalDate') then
        value.approvalDateElement := ParseDate(child, path+'/approvalDate')
      else if (child.localName = 'lastReviewDate') then
        value.lastReviewDateElement := ParseDate(child, path+'/lastReviewDate')
      else if (child.localName = 'effectivePeriod') then
        value.effectivePeriod := ParsePeriod(child, path+'/effectivePeriod')
      else if (child.localName = 'author') then
        value.authorList.Add(ParseContactDetail(child, path+'/author'))
      else if (child.localName = 'editor') then
        value.editorList.Add(ParseContactDetail(child, path+'/editor'))
      else if (child.localName = 'reviewer') then
        value.reviewerList.Add(ParseContactDetail(child, path+'/reviewer'))
      else if (child.localName = 'endorser') then
        value.endorserList.Add(ParseContactDetail(child, path+'/endorser'))
      else if (child.localName = 'summary') then
        value.summaryList.Add(ParseCitationSummary(child, path+'/summary'))
      else if (child.localName = 'classification') then
        value.classificationList.Add(ParseCitationClassification(child, path+'/classification'))
      else if (child.localName = 'note') then
        value.noteList.Add(ParseAnnotation(child, path+'/note'))
      else if (child.localName = 'currentState') then
        value.currentStateList.Add(ParseCodeableConcept(child, path+'/currentState'))
      else if (child.localName = 'statusDate') then
        value.statusDateList.Add(ParseCitationStatusDate(child, path+'/statusDate'))
      else if (child.localName = 'relatedArtifact') then
        value.relatedArtifactList.Add(ParseRelatedArtifact(child, path+'/relatedArtifact'))
      else if (child.localName = 'citedArtifact') then
        value.citedArtifact := ParseCitationCitedArtifact(child, path+'/citedArtifact')
      else if Not ParseMetadataResourceChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeCitation(xml : TXmlBuilder; name : String; value : TFhirCitation);
begin
  if (value = nil) then
    exit;
  composeMetadataResourceAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeCitationChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeCitationChildren(xml : TXmlBuilder; value : TFhirCitation);
var
  i : integer;
begin
  composeMetadataResourceChildren(xml, value);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeUri(xml, 'url', value.urlElement);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.identifierList.Count - 1 do
      ComposeIdentifier(xml, 'identifier', value.identifierList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(xml, 'version', value.versionElement);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(xml, 'name', value.nameElement);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(xml, 'title', value.titleElement);
  ComposeEnum(xml, 'status', value.statusElement, CODES_TFhirPublicationStatusEnum);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeBoolean(xml, 'experimental', value.experimentalElement);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDateTime(xml, 'date', value.dateElement);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(xml, 'publisher', value.publisherElement);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.contactList.Count - 1 do
      ComposeContactDetail(xml, 'contact', value.contactList[i]);
  if (SummaryOption in [soFull, soData]) then
    ComposeMarkdown(xml, 'description', value.descriptionElement);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.useContextList.Count - 1 do
      ComposeUsageContext(xml, 'useContext', value.useContextList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.jurisdictionList.Count - 1 do
      ComposeCodeableConcept(xml, 'jurisdiction', value.jurisdictionList[i]);
  if (SummaryOption in [soFull, soData]) then
    ComposeMarkdown(xml, 'purpose', value.purposeElement);
  if (SummaryOption in [soFull, soData]) then
    ComposeMarkdown(xml, 'copyright', value.copyrightElement);
  if (SummaryOption in [soFull, soData]) then
    ComposeDate(xml, 'approvalDate', value.approvalDateElement);
  if (SummaryOption in [soFull, soData]) then
    ComposeDate(xml, 'lastReviewDate', value.lastReviewDateElement);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposePeriod(xml, 'effectivePeriod', value.effectivePeriod);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.authorList.Count - 1 do
      ComposeContactDetail(xml, 'author', value.authorList[i]);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.editorList.Count - 1 do
      ComposeContactDetail(xml, 'editor', value.editorList[i]);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.reviewerList.Count - 1 do
      ComposeContactDetail(xml, 'reviewer', value.reviewerList[i]);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.endorserList.Count - 1 do
      ComposeContactDetail(xml, 'endorser', value.endorserList[i]);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.summaryList.Count - 1 do
      ComposeCitationSummary(xml, 'summary', value.summaryList[i]);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.classificationList.Count - 1 do
      ComposeCitationClassification(xml, 'classification', value.classificationList[i]);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.noteList.Count - 1 do
      ComposeAnnotation(xml, 'note', value.noteList[i]);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.currentStateList.Count - 1 do
      ComposeCodeableConcept(xml, 'currentState', value.currentStateList[i]);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.statusDateList.Count - 1 do
      ComposeCitationStatusDate(xml, 'statusDate', value.statusDateList[i]);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.relatedArtifactList.Count - 1 do
      ComposeRelatedArtifact(xml, 'relatedArtifact', value.relatedArtifactList[i]);
  if (SummaryOption in [soFull, soData]) then
    ComposeCitationCitedArtifact(xml, 'citedArtifact', value.citedArtifact);
end;

{$ENDIF FHIR_CITATION}
{$IFDEF FHIR_CLAIM}
function TFHIRXmlParser.ParseClaimRelated(element : TMXmlElement; path : string) : TFhirClaimRelated;
var
  child : TMXmlElement;
begin
  result := TFhirClaimRelated.Create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseClaimRelatedChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseClaimRelatedChild(value : TFhirClaimRelated; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'claim') then
        value.claim := ParseReference(child, path+'/claim')
      else if (child.localName = 'relationship') then
        value.relationship := ParseCodeableConcept(child, path+'/relationship')
      else if (child.localName = 'reference') then
        value.reference := ParseIdentifier(child, path+'/reference')
      else if Not ParseBackboneElementChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeClaimRelated(xml : TXmlBuilder; name : String; value : TFhirClaimRelated);
begin
  if (value = nil) then
    exit;
  composeElementAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeClaimRelatedChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeClaimRelatedChildren(xml : TXmlBuilder; value : TFhirClaimRelated);
begin
  composeBackboneElementChildren(xml, value);
  if (SummaryOption in [soFull, soData]) then
    ComposeReference(xml, 'claim', value.claim);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(xml, 'relationship', value.relationship);
  if (SummaryOption in [soFull, soData]) then
    ComposeIdentifier(xml, 'reference', value.reference);
end;

function TFHIRXmlParser.ParseClaimPayee(element : TMXmlElement; path : string) : TFhirClaimPayee;
var
  child : TMXmlElement;
begin
  result := TFhirClaimPayee.Create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseClaimPayeeChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseClaimPayeeChild(value : TFhirClaimPayee; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'type') then
        value.type_ := ParseCodeableConcept(child, path+'/type')
      else if (child.localName = 'party') then
        value.party := ParseReference(child, path+'/party')
      else if Not ParseBackboneElementChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeClaimPayee(xml : TXmlBuilder; name : String; value : TFhirClaimPayee);
begin
  if (value = nil) then
    exit;
  composeElementAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeClaimPayeeChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeClaimPayeeChildren(xml : TXmlBuilder; value : TFhirClaimPayee);
begin
  composeBackboneElementChildren(xml, value);
  ComposeCodeableConcept(xml, 'type', value.type_);
  if (SummaryOption in [soFull, soData]) then
    ComposeReference(xml, 'party', value.party);
end;

function TFHIRXmlParser.ParseClaimCareTeam(element : TMXmlElement; path : string) : TFhirClaimCareTeam;
var
  child : TMXmlElement;
begin
  result := TFhirClaimCareTeam.Create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseClaimCareTeamChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseClaimCareTeamChild(value : TFhirClaimCareTeam; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'sequence') then
        value.sequenceElement := ParsePositiveInt(child, path+'/sequence')
      else if (child.localName = 'provider') then
        value.provider := ParseReference(child, path+'/provider')
      else if (child.localName = 'responsible') then
        value.responsibleElement := ParseBoolean(child, path+'/responsible')
      else if (child.localName = 'role') then
        value.role := ParseCodeableConcept(child, path+'/role')
      else if (child.localName = 'specialty') then
        value.specialty := ParseCodeableConcept(child, path+'/specialty')
      else if Not ParseBackboneElementChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeClaimCareTeam(xml : TXmlBuilder; name : String; value : TFhirClaimCareTeam);
begin
  if (value = nil) then
    exit;
  composeElementAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeClaimCareTeamChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeClaimCareTeamChildren(xml : TXmlBuilder; value : TFhirClaimCareTeam);
begin
  composeBackboneElementChildren(xml, value);
  ComposePositiveInt(xml, 'sequence', value.sequenceElement);
  ComposeReference(xml, 'provider', value.provider);
  if (SummaryOption in [soFull, soData]) then
    ComposeBoolean(xml, 'responsible', value.responsibleElement);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(xml, 'role', value.role);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(xml, 'specialty', value.specialty);
end;

function TFHIRXmlParser.ParseClaimSupportingInfo(element : TMXmlElement; path : string) : TFhirClaimSupportingInfo;
var
  child : TMXmlElement;
begin
  result := TFhirClaimSupportingInfo.Create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseClaimSupportingInfoChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseClaimSupportingInfoChild(value : TFhirClaimSupportingInfo; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'sequence') then
        value.sequenceElement := ParsePositiveInt(child, path+'/sequence')
      else if (child.localName = 'category') then
        value.category := ParseCodeableConcept(child, path+'/category')
      else if (child.localName = 'code') then
        value.code := ParseCodeableConcept(child, path+'/code')
      else if (child.localName = 'timingPeriod') then
        value.timing := ParsePeriod(child, path+'/timingPeriod')
      else if (child.localName = 'timingDate') then
        value.timing := ParseDate(child, path+'/timingDate')
      else if (child.localName = 'valueQuantity') then
        value.value := ParseQuantity(child, path+'/valueQuantity')
      else if (child.localName = 'valueAttachment') then
        value.value := ParseAttachment(child, path+'/valueAttachment')
      else if (child.localName = 'valueReference') then
        value.value := ParseReference(child, path+'/valueReference')
      else if (child.localName = 'valueIdentifier') then
        value.value := ParseIdentifier(child, path+'/valueIdentifier')
      else if (child.localName = 'valueBoolean') then
        value.value := ParseBoolean(child, path+'/valueBoolean')
      else if (child.localName = 'valueString') then
        value.value := ParseString(child, path+'/valueString')
      else if (child.localName = 'reason') then
        value.reason := ParseCodeableConcept(child, path+'/reason')
      else if Not ParseBackboneElementChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeClaimSupportingInfo(xml : TXmlBuilder; name : String; value : TFhirClaimSupportingInfo);
begin
  if (value = nil) then
    exit;
  composeElementAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeClaimSupportingInfoChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeClaimSupportingInfoChildren(xml : TXmlBuilder; value : TFhirClaimSupportingInfo);
begin
  composeBackboneElementChildren(xml, value);
  ComposePositiveInt(xml, 'sequence', value.sequenceElement);
  ComposeCodeableConcept(xml, 'category', value.category);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(xml, 'code', value.code);
  if (SummaryOption in [soFull, soData]) and (value.timing is TFhirPeriod) {6} then
    ComposePeriod(xml, 'timingPeriod', TFhirPeriod(value.timing))
  else if (SummaryOption in [soFull, soData]) and (value.timing is TFhirDate) {6} then
    ComposeDate(xml, 'timingDate', TFhirDate(value.timing));
  if (SummaryOption in [soFull, soData]) and (value.value is TFhirQuantity) {6} then
    ComposeQuantity(xml, 'valueQuantity', TFhirQuantity(value.value))
  else if (SummaryOption in [soFull, soData]) and (value.value is TFhirAttachment) {6} then
    ComposeAttachment(xml, 'valueAttachment', TFhirAttachment(value.value))
  else if (SummaryOption in [soFull, soData]) and (value.value is TFhirReference) {2} then
    ComposeReference(xml, 'valueReference', TFhirReference(value.value))
  else if (SummaryOption in [soFull, soData]) and (value.value is TFhirIdentifier) {6} then
    ComposeIdentifier(xml, 'valueIdentifier', TFhirIdentifier(value.value))
  else if (SummaryOption in [soFull, soData]) and (value.value is TFhirBoolean) {6} then
    ComposeBoolean(xml, 'valueBoolean', TFhirBoolean(value.value))
  else if (SummaryOption in [soFull, soData]) and (value.value is TFhirString) {6} then
    ComposeString(xml, 'valueString', TFhirString(value.value));
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(xml, 'reason', value.reason);
end;

function TFHIRXmlParser.ParseClaimDiagnosis(element : TMXmlElement; path : string) : TFhirClaimDiagnosis;
var
  child : TMXmlElement;
begin
  result := TFhirClaimDiagnosis.Create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseClaimDiagnosisChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseClaimDiagnosisChild(value : TFhirClaimDiagnosis; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'sequence') then
        value.sequenceElement := ParsePositiveInt(child, path+'/sequence')
      else if (child.localName = 'diagnosisCodeableConcept') then
        value.diagnosis := ParseCodeableConcept(child, path+'/diagnosisCodeableConcept')
      else if (child.localName = 'diagnosisReference') then
        value.diagnosis := ParseReference(child, path+'/diagnosisReference')
      else if (child.localName = 'type') then
        value.type_List.Add(ParseCodeableConcept(child, path+'/type'))
      else if (child.localName = 'onAdmission') then
        value.onAdmission := ParseCodeableConcept(child, path+'/onAdmission')
      else if Not ParseBackboneElementChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeClaimDiagnosis(xml : TXmlBuilder; name : String; value : TFhirClaimDiagnosis);
begin
  if (value = nil) then
    exit;
  composeElementAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeClaimDiagnosisChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeClaimDiagnosisChildren(xml : TXmlBuilder; value : TFhirClaimDiagnosis);
var
  i : integer;
begin
  composeBackboneElementChildren(xml, value);
  ComposePositiveInt(xml, 'sequence', value.sequenceElement);
  if (value.diagnosis is TFhirCodeableConcept) {6} then
    ComposeCodeableConcept(xml, 'diagnosisCodeableConcept', TFhirCodeableConcept(value.diagnosis))
  else if (value.diagnosis is TFhirReference) {2} then
    ComposeReference(xml, 'diagnosisReference', TFhirReference(value.diagnosis));
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.type_List.Count - 1 do
      ComposeCodeableConcept(xml, 'type', value.type_List[i]);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(xml, 'onAdmission', value.onAdmission);
end;

function TFHIRXmlParser.ParseClaimProcedure(element : TMXmlElement; path : string) : TFhirClaimProcedure;
var
  child : TMXmlElement;
begin
  result := TFhirClaimProcedure.Create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseClaimProcedureChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseClaimProcedureChild(value : TFhirClaimProcedure; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'sequence') then
        value.sequenceElement := ParsePositiveInt(child, path+'/sequence')
      else if (child.localName = 'type') then
        value.type_List.Add(ParseCodeableConcept(child, path+'/type'))
      else if (child.localName = 'date') then
        value.dateElement := ParseDateTime(child, path+'/date')
      else if (child.localName = 'procedureCodeableConcept') then
        value.procedure_ := ParseCodeableConcept(child, path+'/procedureCodeableConcept')
      else if (child.localName = 'procedureReference') then
        value.procedure_ := ParseReference(child, path+'/procedureReference')
      else if (child.localName = 'udi') then
        value.udiList.Add(ParseReference(child, path+'/udi'))
      else if Not ParseBackboneElementChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeClaimProcedure(xml : TXmlBuilder; name : String; value : TFhirClaimProcedure);
begin
  if (value = nil) then
    exit;
  composeElementAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeClaimProcedureChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeClaimProcedureChildren(xml : TXmlBuilder; value : TFhirClaimProcedure);
var
  i : integer;
begin
  composeBackboneElementChildren(xml, value);
  ComposePositiveInt(xml, 'sequence', value.sequenceElement);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.type_List.Count - 1 do
      ComposeCodeableConcept(xml, 'type', value.type_List[i]);
  if (SummaryOption in [soFull, soData]) then
    ComposeDateTime(xml, 'date', value.dateElement);
  if (value.procedure_ is TFhirCodeableConcept) {6} then
    ComposeCodeableConcept(xml, 'procedureCodeableConcept', TFhirCodeableConcept(value.procedure_))
  else if (value.procedure_ is TFhirReference) {2} then
    ComposeReference(xml, 'procedureReference', TFhirReference(value.procedure_));
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.udiList.Count - 1 do
      ComposeReference(xml, 'udi', value.udiList[i]);
end;

function TFHIRXmlParser.ParseClaimInsurance(element : TMXmlElement; path : string) : TFhirClaimInsurance;
var
  child : TMXmlElement;
begin
  result := TFhirClaimInsurance.Create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseClaimInsuranceChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseClaimInsuranceChild(value : TFhirClaimInsurance; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'sequence') then
        value.sequenceElement := ParsePositiveInt(child, path+'/sequence')
      else if (child.localName = 'focal') then
        value.focalElement := ParseBoolean(child, path+'/focal')
      else if (child.localName = 'identifier') then
        value.identifier := ParseIdentifier(child, path+'/identifier')
      else if (child.localName = 'coverage') then
        value.coverage := ParseReference(child, path+'/coverage')
      else if (child.localName = 'businessArrangement') then
        value.businessArrangementElement := ParseString(child, path+'/businessArrangement')
      else if (child.localName = 'preAuthRef') then
        value.preAuthRefList.Add(ParseString(child, path+'/preAuthRef'))
      else if (child.localName = 'claimResponse') then
        value.claimResponse := ParseReference(child, path+'/claimResponse')
      else if Not ParseBackboneElementChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeClaimInsurance(xml : TXmlBuilder; name : String; value : TFhirClaimInsurance);
begin
  if (value = nil) then
    exit;
  composeElementAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeClaimInsuranceChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeClaimInsuranceChildren(xml : TXmlBuilder; value : TFhirClaimInsurance);
var
  i : integer;
begin
  composeBackboneElementChildren(xml, value);
  ComposePositiveInt(xml, 'sequence', value.sequenceElement);
  ComposeBoolean(xml, 'focal', value.focalElement);
  if (SummaryOption in [soFull, soData]) then
    ComposeIdentifier(xml, 'identifier', value.identifier);
  ComposeReference(xml, 'coverage', value.coverage);
  if (SummaryOption in [soFull, soData]) then
    ComposeString(xml, 'businessArrangement', value.businessArrangementElement);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.preAuthRefList.Count - 1 do
      ComposeString(xml, 'preAuthRef', value.preAuthRefList[i]);
  if (SummaryOption in [soFull, soData]) then
    ComposeReference(xml, 'claimResponse', value.claimResponse);
end;

function TFHIRXmlParser.ParseClaimAccident(element : TMXmlElement; path : string) : TFhirClaimAccident;
var
  child : TMXmlElement;
begin
  result := TFhirClaimAccident.Create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseClaimAccidentChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseClaimAccidentChild(value : TFhirClaimAccident; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'date') then
        value.dateElement := ParseDate(child, path+'/date')
      else if (child.localName = 'type') then
        value.type_ := ParseCodeableConcept(child, path+'/type')
      else if (child.localName = 'locationAddress') then
        value.location := ParseAddress(child, path+'/locationAddress')
      else if (child.localName = 'locationReference') then
        value.location := ParseReference(child, path+'/locationReference')
      else if Not ParseBackboneElementChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeClaimAccident(xml : TXmlBuilder; name : String; value : TFhirClaimAccident);
begin
  if (value = nil) then
    exit;
  composeElementAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeClaimAccidentChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeClaimAccidentChildren(xml : TXmlBuilder; value : TFhirClaimAccident);
begin
  composeBackboneElementChildren(xml, value);
  ComposeDate(xml, 'date', value.dateElement);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(xml, 'type', value.type_);
  if (SummaryOption in [soFull, soData]) and (value.location is TFhirAddress) {6} then
    ComposeAddress(xml, 'locationAddress', TFhirAddress(value.location))
  else if (SummaryOption in [soFull, soData]) and (value.location is TFhirReference) {2} then
    ComposeReference(xml, 'locationReference', TFhirReference(value.location));
end;

function TFHIRXmlParser.ParseClaimItem(element : TMXmlElement; path : string) : TFhirClaimItem;
var
  child : TMXmlElement;
begin
  result := TFhirClaimItem.Create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseClaimItemChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseClaimItemChild(value : TFhirClaimItem; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'sequence') then
        value.sequenceElement := ParsePositiveInt(child, path+'/sequence')
      else if (child.localName = 'careTeamSequence') then
        value.careTeamSequenceList.Add(ParsePositiveInt(child, path+'/careTeamSequence'))
      else if (child.localName = 'diagnosisSequence') then
        value.diagnosisSequenceList.Add(ParsePositiveInt(child, path+'/diagnosisSequence'))
      else if (child.localName = 'procedureSequence') then
        value.procedureSequenceList.Add(ParsePositiveInt(child, path+'/procedureSequence'))
      else if (child.localName = 'informationSequence') then
        value.informationSequenceList.Add(ParsePositiveInt(child, path+'/informationSequence'))
      else if (child.localName = 'revenue') then
        value.revenue := ParseCodeableConcept(child, path+'/revenue')
      else if (child.localName = 'category') then
        value.category := ParseCodeableConcept(child, path+'/category')
      else if (child.localName = 'productOrService') then
        value.productOrService := ParseCodeableConcept(child, path+'/productOrService')
      else if (child.localName = 'productOrServiceEnd') then
        value.productOrServiceEnd := ParseCodeableConcept(child, path+'/productOrServiceEnd')
      else if (child.localName = 'modifier') then
        value.modifierList.Add(ParseCodeableConcept(child, path+'/modifier'))
      else if (child.localName = 'programCode') then
        value.programCodeList.Add(ParseCodeableConcept(child, path+'/programCode'))
      else if (child.localName = 'servicedPeriod') then
        value.serviced := ParsePeriod(child, path+'/servicedPeriod')
      else if (child.localName = 'servicedDate') then
        value.serviced := ParseDate(child, path+'/servicedDate')
      else if (child.localName = 'locationCodeableConcept') then
        value.location := ParseCodeableConcept(child, path+'/locationCodeableConcept')
      else if (child.localName = 'locationAddress') then
        value.location := ParseAddress(child, path+'/locationAddress')
      else if (child.localName = 'locationReference') then
        value.location := ParseReference(child, path+'/locationReference')
      else if (child.localName = 'patientPaid') then
        value.patientPaid := ParseMoney(child, path+'/patientPaid')
      else if (child.localName = 'quantity') then
        value.quantity := ParseQuantity(child, path+'/quantity')
      else if (child.localName = 'unitPrice') then
        value.unitPrice := ParseMoney(child, path+'/unitPrice')
      else if (child.localName = 'factor') then
        value.factorElement := ParseDecimal(child, path+'/factor')
      else if (child.localName = 'tax') then
        value.tax := ParseMoney(child, path+'/tax')
      else if (child.localName = 'net') then
        value.net := ParseMoney(child, path+'/net')
      else if (child.localName = 'udi') then
        value.udiList.Add(ParseReference(child, path+'/udi'))
      else if (child.localName = 'bodySite') then
        value.bodySiteList.Add(ParseClaimItemBodySite(child, path+'/bodySite'))
      else if (child.localName = 'encounter') then
        value.encounterList.Add(ParseReference(child, path+'/encounter'))
      else if (child.localName = 'detail') then
        value.detailList.Add(ParseClaimItemDetail(child, path+'/detail'))
      else if Not ParseBackboneElementChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeClaimItem(xml : TXmlBuilder; name : String; value : TFhirClaimItem);
begin
  if (value = nil) then
    exit;
  composeElementAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeClaimItemChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeClaimItemChildren(xml : TXmlBuilder; value : TFhirClaimItem);
var
  i : integer;
begin
  composeBackboneElementChildren(xml, value);
  ComposePositiveInt(xml, 'sequence', value.sequenceElement);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.careTeamSequenceList.Count - 1 do
      ComposePositiveInt(xml, 'careTeamSequence', value.careTeamSequenceList[i]);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.diagnosisSequenceList.Count - 1 do
      ComposePositiveInt(xml, 'diagnosisSequence', value.diagnosisSequenceList[i]);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.procedureSequenceList.Count - 1 do
      ComposePositiveInt(xml, 'procedureSequence', value.procedureSequenceList[i]);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.informationSequenceList.Count - 1 do
      ComposePositiveInt(xml, 'informationSequence', value.informationSequenceList[i]);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(xml, 'revenue', value.revenue);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(xml, 'category', value.category);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(xml, 'productOrService', value.productOrService);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(xml, 'productOrServiceEnd', value.productOrServiceEnd);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.modifierList.Count - 1 do
      ComposeCodeableConcept(xml, 'modifier', value.modifierList[i]);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.programCodeList.Count - 1 do
      ComposeCodeableConcept(xml, 'programCode', value.programCodeList[i]);
  if (SummaryOption in [soFull, soData]) and (value.serviced is TFhirPeriod) {6} then
    ComposePeriod(xml, 'servicedPeriod', TFhirPeriod(value.serviced))
  else if (SummaryOption in [soFull, soData]) and (value.serviced is TFhirDate) {6} then
    ComposeDate(xml, 'servicedDate', TFhirDate(value.serviced));
  if (SummaryOption in [soFull, soData]) and (value.location is TFhirCodeableConcept) {6} then
    ComposeCodeableConcept(xml, 'locationCodeableConcept', TFhirCodeableConcept(value.location))
  else if (SummaryOption in [soFull, soData]) and (value.location is TFhirAddress) {6} then
    ComposeAddress(xml, 'locationAddress', TFhirAddress(value.location))
  else if (SummaryOption in [soFull, soData]) and (value.location is TFhirReference) {2} then
    ComposeReference(xml, 'locationReference', TFhirReference(value.location));
  if (SummaryOption in [soFull, soData]) then
    ComposeMoney(xml, 'patientPaid', value.patientPaid);
  if (SummaryOption in [soFull, soData]) then
    ComposeQuantity(xml, 'quantity', value.quantity);
  if (SummaryOption in [soFull, soData]) then
    ComposeMoney(xml, 'unitPrice', value.unitPrice);
  if (SummaryOption in [soFull, soData]) then
    ComposeDecimal(xml, 'factor', value.factorElement);
  if (SummaryOption in [soFull, soData]) then
    ComposeMoney(xml, 'tax', value.tax);
  if (SummaryOption in [soFull, soData]) then
    ComposeMoney(xml, 'net', value.net);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.udiList.Count - 1 do
      ComposeReference(xml, 'udi', value.udiList[i]);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.bodySiteList.Count - 1 do
      ComposeClaimItemBodySite(xml, 'bodySite', value.bodySiteList[i]);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.encounterList.Count - 1 do
      ComposeReference(xml, 'encounter', value.encounterList[i]);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.detailList.Count - 1 do
      ComposeClaimItemDetail(xml, 'detail', value.detailList[i]);
end;

function TFHIRXmlParser.ParseClaimItemBodySite(element : TMXmlElement; path : string) : TFhirClaimItemBodySite;
var
  child : TMXmlElement;
begin
  result := TFhirClaimItemBodySite.Create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseClaimItemBodySiteChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseClaimItemBodySiteChild(value : TFhirClaimItemBodySite; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'site') then
        value.siteList.Add(ParseCodeableReference(child, path+'/site'))
      else if (child.localName = 'subSite') then
        value.subSiteList.Add(ParseCodeableConcept(child, path+'/subSite'))
      else if Not ParseBackboneElementChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeClaimItemBodySite(xml : TXmlBuilder; name : String; value : TFhirClaimItemBodySite);
begin
  if (value = nil) then
    exit;
  composeElementAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeClaimItemBodySiteChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeClaimItemBodySiteChildren(xml : TXmlBuilder; value : TFhirClaimItemBodySite);
var
  i : integer;
begin
  composeBackboneElementChildren(xml, value);
  for i := 0 to value.siteList.Count - 1 do
      ComposeCodeableReference(xml, 'site', value.siteList[i]);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.subSiteList.Count - 1 do
      ComposeCodeableConcept(xml, 'subSite', value.subSiteList[i]);
end;

function TFHIRXmlParser.ParseClaimItemDetail(element : TMXmlElement; path : string) : TFhirClaimItemDetail;
var
  child : TMXmlElement;
begin
  result := TFhirClaimItemDetail.Create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseClaimItemDetailChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseClaimItemDetailChild(value : TFhirClaimItemDetail; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'sequence') then
        value.sequenceElement := ParsePositiveInt(child, path+'/sequence')
      else if (child.localName = 'revenue') then
        value.revenue := ParseCodeableConcept(child, path+'/revenue')
      else if (child.localName = 'category') then
        value.category := ParseCodeableConcept(child, path+'/category')
      else if (child.localName = 'productOrService') then
        value.productOrService := ParseCodeableConcept(child, path+'/productOrService')
      else if (child.localName = 'productOrServiceEnd') then
        value.productOrServiceEnd := ParseCodeableConcept(child, path+'/productOrServiceEnd')
      else if (child.localName = 'modifier') then
        value.modifierList.Add(ParseCodeableConcept(child, path+'/modifier'))
      else if (child.localName = 'programCode') then
        value.programCodeList.Add(ParseCodeableConcept(child, path+'/programCode'))
      else if (child.localName = 'patientPaid') then
        value.patientPaid := ParseMoney(child, path+'/patientPaid')
      else if (child.localName = 'quantity') then
        value.quantity := ParseQuantity(child, path+'/quantity')
      else if (child.localName = 'unitPrice') then
        value.unitPrice := ParseMoney(child, path+'/unitPrice')
      else if (child.localName = 'factor') then
        value.factorElement := ParseDecimal(child, path+'/factor')
      else if (child.localName = 'tax') then
        value.tax := ParseMoney(child, path+'/tax')
      else if (child.localName = 'net') then
        value.net := ParseMoney(child, path+'/net')
      else if (child.localName = 'udi') then
        value.udiList.Add(ParseReference(child, path+'/udi'))
      else if (child.localName = 'subDetail') then
        value.subDetailList.Add(ParseClaimItemDetailSubDetail(child, path+'/subDetail'))
      else if Not ParseBackboneElementChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeClaimItemDetail(xml : TXmlBuilder; name : String; value : TFhirClaimItemDetail);
begin
  if (value = nil) then
    exit;
  composeElementAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeClaimItemDetailChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeClaimItemDetailChildren(xml : TXmlBuilder; value : TFhirClaimItemDetail);
var
  i : integer;
begin
  composeBackboneElementChildren(xml, value);
  ComposePositiveInt(xml, 'sequence', value.sequenceElement);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(xml, 'revenue', value.revenue);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(xml, 'category', value.category);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(xml, 'productOrService', value.productOrService);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(xml, 'productOrServiceEnd', value.productOrServiceEnd);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.modifierList.Count - 1 do
      ComposeCodeableConcept(xml, 'modifier', value.modifierList[i]);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.programCodeList.Count - 1 do
      ComposeCodeableConcept(xml, 'programCode', value.programCodeList[i]);
  if (SummaryOption in [soFull, soData]) then
    ComposeMoney(xml, 'patientPaid', value.patientPaid);
  if (SummaryOption in [soFull, soData]) then
    ComposeQuantity(xml, 'quantity', value.quantity);
  if (SummaryOption in [soFull, soData]) then
    ComposeMoney(xml, 'unitPrice', value.unitPrice);
  if (SummaryOption in [soFull, soData]) then
    ComposeDecimal(xml, 'factor', value.factorElement);
  if (SummaryOption in [soFull, soData]) then
    ComposeMoney(xml, 'tax', value.tax);
  if (SummaryOption in [soFull, soData]) then
    ComposeMoney(xml, 'net', value.net);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.udiList.Count - 1 do
      ComposeReference(xml, 'udi', value.udiList[i]);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.subDetailList.Count - 1 do
      ComposeClaimItemDetailSubDetail(xml, 'subDetail', value.subDetailList[i]);
end;

function TFHIRXmlParser.ParseClaimItemDetailSubDetail(element : TMXmlElement; path : string) : TFhirClaimItemDetailSubDetail;
var
  child : TMXmlElement;
begin
  result := TFhirClaimItemDetailSubDetail.Create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseClaimItemDetailSubDetailChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseClaimItemDetailSubDetailChild(value : TFhirClaimItemDetailSubDetail; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'sequence') then
        value.sequenceElement := ParsePositiveInt(child, path+'/sequence')
      else if (child.localName = 'revenue') then
        value.revenue := ParseCodeableConcept(child, path+'/revenue')
      else if (child.localName = 'category') then
        value.category := ParseCodeableConcept(child, path+'/category')
      else if (child.localName = 'productOrService') then
        value.productOrService := ParseCodeableConcept(child, path+'/productOrService')
      else if (child.localName = 'productOrServiceEnd') then
        value.productOrServiceEnd := ParseCodeableConcept(child, path+'/productOrServiceEnd')
      else if (child.localName = 'modifier') then
        value.modifierList.Add(ParseCodeableConcept(child, path+'/modifier'))
      else if (child.localName = 'programCode') then
        value.programCodeList.Add(ParseCodeableConcept(child, path+'/programCode'))
      else if (child.localName = 'patientPaid') then
        value.patientPaid := ParseMoney(child, path+'/patientPaid')
      else if (child.localName = 'quantity') then
        value.quantity := ParseQuantity(child, path+'/quantity')
      else if (child.localName = 'unitPrice') then
        value.unitPrice := ParseMoney(child, path+'/unitPrice')
      else if (child.localName = 'factor') then
        value.factorElement := ParseDecimal(child, path+'/factor')
      else if (child.localName = 'tax') then
        value.tax := ParseMoney(child, path+'/tax')
      else if (child.localName = 'net') then
        value.net := ParseMoney(child, path+'/net')
      else if (child.localName = 'udi') then
        value.udiList.Add(ParseReference(child, path+'/udi'))
      else if Not ParseBackboneElementChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeClaimItemDetailSubDetail(xml : TXmlBuilder; name : String; value : TFhirClaimItemDetailSubDetail);
begin
  if (value = nil) then
    exit;
  composeElementAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeClaimItemDetailSubDetailChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeClaimItemDetailSubDetailChildren(xml : TXmlBuilder; value : TFhirClaimItemDetailSubDetail);
var
  i : integer;
begin
  composeBackboneElementChildren(xml, value);
  ComposePositiveInt(xml, 'sequence', value.sequenceElement);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(xml, 'revenue', value.revenue);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(xml, 'category', value.category);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(xml, 'productOrService', value.productOrService);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(xml, 'productOrServiceEnd', value.productOrServiceEnd);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.modifierList.Count - 1 do
      ComposeCodeableConcept(xml, 'modifier', value.modifierList[i]);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.programCodeList.Count - 1 do
      ComposeCodeableConcept(xml, 'programCode', value.programCodeList[i]);
  if (SummaryOption in [soFull, soData]) then
    ComposeMoney(xml, 'patientPaid', value.patientPaid);
  if (SummaryOption in [soFull, soData]) then
    ComposeQuantity(xml, 'quantity', value.quantity);
  if (SummaryOption in [soFull, soData]) then
    ComposeMoney(xml, 'unitPrice', value.unitPrice);
  if (SummaryOption in [soFull, soData]) then
    ComposeDecimal(xml, 'factor', value.factorElement);
  if (SummaryOption in [soFull, soData]) then
    ComposeMoney(xml, 'tax', value.tax);
  if (SummaryOption in [soFull, soData]) then
    ComposeMoney(xml, 'net', value.net);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.udiList.Count - 1 do
      ComposeReference(xml, 'udi', value.udiList[i]);
end;

function TFHIRXmlParser.ParseClaim(element : TMXmlElement; path : string) : TFhirClaim;
var
  child : TMXmlElement;
begin
  result := TFhirClaim.Create;
  try
    parseDomainResourceAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseClaimChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseClaimChild(value : TFhirClaim; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'identifier') then
        value.identifierList.Add(ParseIdentifier(child, path+'/identifier'))
      else if (child.localName = 'status') then
        value.statusElement := ParseEnum(CODES_TFhirFinancialResourceStatusCodesEnum, SYSTEMS_TFhirFinancialResourceStatusCodesEnum, child, path+'/status')
      else if (child.localName = 'type') then
        value.type_ := ParseCodeableConcept(child, path+'/type')
      else if (child.localName = 'subType') then
        value.subType := ParseCodeableConcept(child, path+'/subType')
      else if (child.localName = 'use') then
        value.useElement := ParseEnum(CODES_TFhirUseEnum, SYSTEMS_TFhirUseEnum, child, path+'/use')
      else if (child.localName = 'patient') then
        value.patient := ParseReference(child, path+'/patient')
      else if (child.localName = 'billablePeriod') then
        value.billablePeriod := ParsePeriod(child, path+'/billablePeriod')
      else if (child.localName = 'created') then
        value.createdElement := ParseDateTime(child, path+'/created')
      else if (child.localName = 'enterer') then
        value.enterer := ParseReference(child, path+'/enterer')
      else if (child.localName = 'insurer') then
        value.insurer := ParseReference(child, path+'/insurer')
      else if (child.localName = 'provider') then
        value.provider := ParseReference(child, path+'/provider')
      else if (child.localName = 'priority') then
        value.priority := ParseCodeableConcept(child, path+'/priority')
      else if (child.localName = 'fundsReserve') then
        value.fundsReserve := ParseCodeableConcept(child, path+'/fundsReserve')
      else if (child.localName = 'related') then
        value.relatedList.Add(ParseClaimRelated(child, path+'/related'))
      else if (child.localName = 'prescription') then
        value.prescription := ParseReference(child, path+'/prescription')
      else if (child.localName = 'originalPrescription') then
        value.originalPrescription := ParseReference(child, path+'/originalPrescription')
      else if (child.localName = 'payee') then
        value.payee := ParseClaimPayee(child, path+'/payee')
      else if (child.localName = 'referral') then
        value.referral := ParseReference(child, path+'/referral')
      else if (child.localName = 'encounter') then
        value.encounterList.Add(ParseReference(child, path+'/encounter'))
      else if (child.localName = 'facility') then
        value.facility := ParseReference(child, path+'/facility')
      else if (child.localName = 'diagnosisRelatedGroup') then
        value.diagnosisRelatedGroup := ParseCodeableConcept(child, path+'/diagnosisRelatedGroup')
      else if (child.localName = 'careTeam') then
        value.careTeamList.Add(ParseClaimCareTeam(child, path+'/careTeam'))
      else if (child.localName = 'supportingInfo') then
        value.supportingInfoList.Add(ParseClaimSupportingInfo(child, path+'/supportingInfo'))
      else if (child.localName = 'diagnosis') then
        value.diagnosisList.Add(ParseClaimDiagnosis(child, path+'/diagnosis'))
      else if (child.localName = 'procedure') then
        value.procedure_List.Add(ParseClaimProcedure(child, path+'/procedure'))
      else if (child.localName = 'insurance') then
        value.insuranceList.Add(ParseClaimInsurance(child, path+'/insurance'))
      else if (child.localName = 'accident') then
        value.accident := ParseClaimAccident(child, path+'/accident')
      else if (child.localName = 'patientPaid') then
        value.patientPaid := ParseMoney(child, path+'/patientPaid')
      else if (child.localName = 'item') then
        value.itemList.Add(ParseClaimItem(child, path+'/item'))
      else if (child.localName = 'total') then
        value.total := ParseMoney(child, path+'/total')
      else if Not ParseDomainResourceChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeClaim(xml : TXmlBuilder; name : String; value : TFhirClaim);
begin
  if (value = nil) then
    exit;
  composeDomainResourceAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeClaimChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeClaimChildren(xml : TXmlBuilder; value : TFhirClaim);
var
  i : integer;
begin
  composeDomainResourceChildren(xml, value);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.identifierList.Count - 1 do
      ComposeIdentifier(xml, 'identifier', value.identifierList[i]);
  ComposeEnum(xml, 'status', value.statusElement, CODES_TFhirFinancialResourceStatusCodesEnum);
  ComposeCodeableConcept(xml, 'type', value.type_);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(xml, 'subType', value.subType);
  ComposeEnum(xml, 'use', value.useElement, CODES_TFhirUseEnum);
  ComposeReference(xml, 'patient', value.patient);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposePeriod(xml, 'billablePeriod', value.billablePeriod);
  ComposeDateTime(xml, 'created', value.createdElement);
  if (SummaryOption in [soFull, soData]) then
    ComposeReference(xml, 'enterer', value.enterer);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference(xml, 'insurer', value.insurer);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference(xml, 'provider', value.provider);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(xml, 'priority', value.priority);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(xml, 'fundsReserve', value.fundsReserve);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.relatedList.Count - 1 do
      ComposeClaimRelated(xml, 'related', value.relatedList[i]);
  if (SummaryOption in [soFull, soData]) then
    ComposeReference(xml, 'prescription', value.prescription);
  if (SummaryOption in [soFull, soData]) then
    ComposeReference(xml, 'originalPrescription', value.originalPrescription);
  if (SummaryOption in [soFull, soData]) then
    ComposeClaimPayee(xml, 'payee', value.payee);
  if (SummaryOption in [soFull, soData]) then
    ComposeReference(xml, 'referral', value.referral);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.encounterList.Count - 1 do
      ComposeReference(xml, 'encounter', value.encounterList[i]);
  if (SummaryOption in [soFull, soData]) then
    ComposeReference(xml, 'facility', value.facility);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(xml, 'diagnosisRelatedGroup', value.diagnosisRelatedGroup);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.careTeamList.Count - 1 do
      ComposeClaimCareTeam(xml, 'careTeam', value.careTeamList[i]);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.supportingInfoList.Count - 1 do
      ComposeClaimSupportingInfo(xml, 'supportingInfo', value.supportingInfoList[i]);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.diagnosisList.Count - 1 do
      ComposeClaimDiagnosis(xml, 'diagnosis', value.diagnosisList[i]);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.procedure_List.Count - 1 do
      ComposeClaimProcedure(xml, 'procedure', value.procedure_List[i]);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.insuranceList.Count - 1 do
      ComposeClaimInsurance(xml, 'insurance', value.insuranceList[i]);
  if (SummaryOption in [soFull, soData]) then
    ComposeClaimAccident(xml, 'accident', value.accident);
  if (SummaryOption in [soFull, soData]) then
    ComposeMoney(xml, 'patientPaid', value.patientPaid);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.itemList.Count - 1 do
      ComposeClaimItem(xml, 'item', value.itemList[i]);
  if (SummaryOption in [soFull, soData]) then
    ComposeMoney(xml, 'total', value.total);
end;

{$ENDIF FHIR_CLAIM}
{$IFDEF FHIR_CLAIMRESPONSE}
function TFHIRXmlParser.ParseClaimResponseItem(element : TMXmlElement; path : string) : TFhirClaimResponseItem;
var
  child : TMXmlElement;
begin
  result := TFhirClaimResponseItem.Create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseClaimResponseItemChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseClaimResponseItemChild(value : TFhirClaimResponseItem; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'itemSequence') then
        value.itemSequenceElement := ParsePositiveInt(child, path+'/itemSequence')
      else if (child.localName = 'noteNumber') then
        value.noteNumberList.Add(ParsePositiveInt(child, path+'/noteNumber'))
      else if (child.localName = 'decision') then
        value.decision := ParseCodeableConcept(child, path+'/decision')
      else if (child.localName = 'adjudication') then
        value.adjudicationList.Add(ParseClaimResponseItemAdjudication(child, path+'/adjudication'))
      else if (child.localName = 'detail') then
        value.detailList.Add(ParseClaimResponseItemDetail(child, path+'/detail'))
      else if Not ParseBackboneElementChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeClaimResponseItem(xml : TXmlBuilder; name : String; value : TFhirClaimResponseItem);
begin
  if (value = nil) then
    exit;
  composeElementAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeClaimResponseItemChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeClaimResponseItemChildren(xml : TXmlBuilder; value : TFhirClaimResponseItem);
var
  i : integer;
begin
  composeBackboneElementChildren(xml, value);
  ComposePositiveInt(xml, 'itemSequence', value.itemSequenceElement);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.noteNumberList.Count - 1 do
      ComposePositiveInt(xml, 'noteNumber', value.noteNumberList[i]);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(xml, 'decision', value.decision);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.adjudicationList.Count - 1 do
      ComposeClaimResponseItemAdjudication(xml, 'adjudication', value.adjudicationList[i]);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.detailList.Count - 1 do
      ComposeClaimResponseItemDetail(xml, 'detail', value.detailList[i]);
end;

function TFHIRXmlParser.ParseClaimResponseItemAdjudication(element : TMXmlElement; path : string) : TFhirClaimResponseItemAdjudication;
var
  child : TMXmlElement;
begin
  result := TFhirClaimResponseItemAdjudication.Create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseClaimResponseItemAdjudicationChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseClaimResponseItemAdjudicationChild(value : TFhirClaimResponseItemAdjudication; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'category') then
        value.category := ParseCodeableConcept(child, path+'/category')
      else if (child.localName = 'reason') then
        value.reason := ParseCodeableConcept(child, path+'/reason')
      else if (child.localName = 'amount') then
        value.amount := ParseMoney(child, path+'/amount')
      else if (child.localName = 'value') then
        value.valueElement := ParseDecimal(child, path+'/value')
      else if Not ParseBackboneElementChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeClaimResponseItemAdjudication(xml : TXmlBuilder; name : String; value : TFhirClaimResponseItemAdjudication);
begin
  if (value = nil) then
    exit;
  composeElementAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeClaimResponseItemAdjudicationChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeClaimResponseItemAdjudicationChildren(xml : TXmlBuilder; value : TFhirClaimResponseItemAdjudication);
begin
  composeBackboneElementChildren(xml, value);
  ComposeCodeableConcept(xml, 'category', value.category);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(xml, 'reason', value.reason);
  if (SummaryOption in [soFull, soData]) then
    ComposeMoney(xml, 'amount', value.amount);
  if (SummaryOption in [soFull, soData]) then
    ComposeDecimal(xml, 'value', value.valueElement);
end;

function TFHIRXmlParser.ParseClaimResponseItemDetail(element : TMXmlElement; path : string) : TFhirClaimResponseItemDetail;
var
  child : TMXmlElement;
begin
  result := TFhirClaimResponseItemDetail.Create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseClaimResponseItemDetailChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseClaimResponseItemDetailChild(value : TFhirClaimResponseItemDetail; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'detailSequence') then
        value.detailSequenceElement := ParsePositiveInt(child, path+'/detailSequence')
      else if (child.localName = 'noteNumber') then
        value.noteNumberList.Add(ParsePositiveInt(child, path+'/noteNumber'))
      else if (child.localName = 'decision') then
        value.decision := ParseCodeableConcept(child, path+'/decision')
      else if (child.localName = 'adjudication') then
        value.adjudicationList.Add(ParseClaimResponseItemAdjudication(child, path+'/adjudication'))
      else if (child.localName = 'subDetail') then
        value.subDetailList.Add(ParseClaimResponseItemDetailSubDetail(child, path+'/subDetail'))
      else if Not ParseBackboneElementChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeClaimResponseItemDetail(xml : TXmlBuilder; name : String; value : TFhirClaimResponseItemDetail);
begin
  if (value = nil) then
    exit;
  composeElementAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeClaimResponseItemDetailChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeClaimResponseItemDetailChildren(xml : TXmlBuilder; value : TFhirClaimResponseItemDetail);
var
  i : integer;
begin
  composeBackboneElementChildren(xml, value);
  ComposePositiveInt(xml, 'detailSequence', value.detailSequenceElement);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.noteNumberList.Count - 1 do
      ComposePositiveInt(xml, 'noteNumber', value.noteNumberList[i]);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(xml, 'decision', value.decision);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.adjudicationList.Count - 1 do
      ComposeClaimResponseItemAdjudication(xml, 'adjudication', value.adjudicationList[i]);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.subDetailList.Count - 1 do
      ComposeClaimResponseItemDetailSubDetail(xml, 'subDetail', value.subDetailList[i]);
end;

function TFHIRXmlParser.ParseClaimResponseItemDetailSubDetail(element : TMXmlElement; path : string) : TFhirClaimResponseItemDetailSubDetail;
var
  child : TMXmlElement;
begin
  result := TFhirClaimResponseItemDetailSubDetail.Create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseClaimResponseItemDetailSubDetailChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseClaimResponseItemDetailSubDetailChild(value : TFhirClaimResponseItemDetailSubDetail; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'subDetailSequence') then
        value.subDetailSequenceElement := ParsePositiveInt(child, path+'/subDetailSequence')
      else if (child.localName = 'noteNumber') then
        value.noteNumberList.Add(ParsePositiveInt(child, path+'/noteNumber'))
      else if (child.localName = 'decision') then
        value.decision := ParseCodeableConcept(child, path+'/decision')
      else if (child.localName = 'adjudication') then
        value.adjudicationList.Add(ParseClaimResponseItemAdjudication(child, path+'/adjudication'))
      else if Not ParseBackboneElementChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeClaimResponseItemDetailSubDetail(xml : TXmlBuilder; name : String; value : TFhirClaimResponseItemDetailSubDetail);
begin
  if (value = nil) then
    exit;
  composeElementAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeClaimResponseItemDetailSubDetailChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeClaimResponseItemDetailSubDetailChildren(xml : TXmlBuilder; value : TFhirClaimResponseItemDetailSubDetail);
var
  i : integer;
begin
  composeBackboneElementChildren(xml, value);
  ComposePositiveInt(xml, 'subDetailSequence', value.subDetailSequenceElement);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.noteNumberList.Count - 1 do
      ComposePositiveInt(xml, 'noteNumber', value.noteNumberList[i]);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(xml, 'decision', value.decision);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.adjudicationList.Count - 1 do
      ComposeClaimResponseItemAdjudication(xml, 'adjudication', value.adjudicationList[i]);
end;

function TFHIRXmlParser.ParseClaimResponseAddItem(element : TMXmlElement; path : string) : TFhirClaimResponseAddItem;
var
  child : TMXmlElement;
begin
  result := TFhirClaimResponseAddItem.Create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseClaimResponseAddItemChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseClaimResponseAddItemChild(value : TFhirClaimResponseAddItem; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'itemSequence') then
        value.itemSequenceList.Add(ParsePositiveInt(child, path+'/itemSequence'))
      else if (child.localName = 'detailSequence') then
        value.detailSequenceList.Add(ParsePositiveInt(child, path+'/detailSequence'))
      else if (child.localName = 'subdetailSequence') then
        value.subdetailSequenceList.Add(ParsePositiveInt(child, path+'/subdetailSequence'))
      else if (child.localName = 'provider') then
        value.providerList.Add(ParseReference(child, path+'/provider'))
      else if (child.localName = 'revenue') then
        value.revenue := ParseCodeableConcept(child, path+'/revenue')
      else if (child.localName = 'productOrService') then
        value.productOrService := ParseCodeableConcept(child, path+'/productOrService')
      else if (child.localName = 'productOrServiceEnd') then
        value.productOrServiceEnd := ParseCodeableConcept(child, path+'/productOrServiceEnd')
      else if (child.localName = 'modifier') then
        value.modifierList.Add(ParseCodeableConcept(child, path+'/modifier'))
      else if (child.localName = 'programCode') then
        value.programCodeList.Add(ParseCodeableConcept(child, path+'/programCode'))
      else if (child.localName = 'servicedPeriod') then
        value.serviced := ParsePeriod(child, path+'/servicedPeriod')
      else if (child.localName = 'servicedDate') then
        value.serviced := ParseDate(child, path+'/servicedDate')
      else if (child.localName = 'locationCodeableConcept') then
        value.location := ParseCodeableConcept(child, path+'/locationCodeableConcept')
      else if (child.localName = 'locationAddress') then
        value.location := ParseAddress(child, path+'/locationAddress')
      else if (child.localName = 'locationReference') then
        value.location := ParseReference(child, path+'/locationReference')
      else if (child.localName = 'quantity') then
        value.quantity := ParseQuantity(child, path+'/quantity')
      else if (child.localName = 'unitPrice') then
        value.unitPrice := ParseMoney(child, path+'/unitPrice')
      else if (child.localName = 'factor') then
        value.factorElement := ParseDecimal(child, path+'/factor')
      else if (child.localName = 'tax') then
        value.tax := ParseMoney(child, path+'/tax')
      else if (child.localName = 'net') then
        value.net := ParseMoney(child, path+'/net')
      else if (child.localName = 'bodySite') then
        value.bodySiteList.Add(ParseClaimResponseAddItemBodySite(child, path+'/bodySite'))
      else if (child.localName = 'noteNumber') then
        value.noteNumberList.Add(ParsePositiveInt(child, path+'/noteNumber'))
      else if (child.localName = 'decision') then
        value.decision := ParseCodeableConcept(child, path+'/decision')
      else if (child.localName = 'adjudication') then
        value.adjudicationList.Add(ParseClaimResponseItemAdjudication(child, path+'/adjudication'))
      else if (child.localName = 'detail') then
        value.detailList.Add(ParseClaimResponseAddItemDetail(child, path+'/detail'))
      else if Not ParseBackboneElementChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeClaimResponseAddItem(xml : TXmlBuilder; name : String; value : TFhirClaimResponseAddItem);
begin
  if (value = nil) then
    exit;
  composeElementAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeClaimResponseAddItemChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeClaimResponseAddItemChildren(xml : TXmlBuilder; value : TFhirClaimResponseAddItem);
var
  i : integer;
begin
  composeBackboneElementChildren(xml, value);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.itemSequenceList.Count - 1 do
      ComposePositiveInt(xml, 'itemSequence', value.itemSequenceList[i]);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.detailSequenceList.Count - 1 do
      ComposePositiveInt(xml, 'detailSequence', value.detailSequenceList[i]);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.subdetailSequenceList.Count - 1 do
      ComposePositiveInt(xml, 'subdetailSequence', value.subdetailSequenceList[i]);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.providerList.Count - 1 do
      ComposeReference(xml, 'provider', value.providerList[i]);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(xml, 'revenue', value.revenue);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(xml, 'productOrService', value.productOrService);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(xml, 'productOrServiceEnd', value.productOrServiceEnd);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.modifierList.Count - 1 do
      ComposeCodeableConcept(xml, 'modifier', value.modifierList[i]);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.programCodeList.Count - 1 do
      ComposeCodeableConcept(xml, 'programCode', value.programCodeList[i]);
  if (SummaryOption in [soFull, soData]) and (value.serviced is TFhirPeriod) {6} then
    ComposePeriod(xml, 'servicedPeriod', TFhirPeriod(value.serviced))
  else if (SummaryOption in [soFull, soData]) and (value.serviced is TFhirDate) {6} then
    ComposeDate(xml, 'servicedDate', TFhirDate(value.serviced));
  if (SummaryOption in [soFull, soData]) and (value.location is TFhirCodeableConcept) {6} then
    ComposeCodeableConcept(xml, 'locationCodeableConcept', TFhirCodeableConcept(value.location))
  else if (SummaryOption in [soFull, soData]) and (value.location is TFhirAddress) {6} then
    ComposeAddress(xml, 'locationAddress', TFhirAddress(value.location))
  else if (SummaryOption in [soFull, soData]) and (value.location is TFhirReference) {2} then
    ComposeReference(xml, 'locationReference', TFhirReference(value.location));
  if (SummaryOption in [soFull, soData]) then
    ComposeQuantity(xml, 'quantity', value.quantity);
  if (SummaryOption in [soFull, soData]) then
    ComposeMoney(xml, 'unitPrice', value.unitPrice);
  if (SummaryOption in [soFull, soData]) then
    ComposeDecimal(xml, 'factor', value.factorElement);
  if (SummaryOption in [soFull, soData]) then
    ComposeMoney(xml, 'tax', value.tax);
  if (SummaryOption in [soFull, soData]) then
    ComposeMoney(xml, 'net', value.net);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.bodySiteList.Count - 1 do
      ComposeClaimResponseAddItemBodySite(xml, 'bodySite', value.bodySiteList[i]);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.noteNumberList.Count - 1 do
      ComposePositiveInt(xml, 'noteNumber', value.noteNumberList[i]);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(xml, 'decision', value.decision);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.adjudicationList.Count - 1 do
      ComposeClaimResponseItemAdjudication(xml, 'adjudication', value.adjudicationList[i]);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.detailList.Count - 1 do
      ComposeClaimResponseAddItemDetail(xml, 'detail', value.detailList[i]);
end;

function TFHIRXmlParser.ParseClaimResponseAddItemBodySite(element : TMXmlElement; path : string) : TFhirClaimResponseAddItemBodySite;
var
  child : TMXmlElement;
begin
  result := TFhirClaimResponseAddItemBodySite.Create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseClaimResponseAddItemBodySiteChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseClaimResponseAddItemBodySiteChild(value : TFhirClaimResponseAddItemBodySite; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'site') then
        value.siteList.Add(ParseCodeableReference(child, path+'/site'))
      else if (child.localName = 'subSite') then
        value.subSiteList.Add(ParseCodeableConcept(child, path+'/subSite'))
      else if Not ParseBackboneElementChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeClaimResponseAddItemBodySite(xml : TXmlBuilder; name : String; value : TFhirClaimResponseAddItemBodySite);
begin
  if (value = nil) then
    exit;
  composeElementAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeClaimResponseAddItemBodySiteChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeClaimResponseAddItemBodySiteChildren(xml : TXmlBuilder; value : TFhirClaimResponseAddItemBodySite);
var
  i : integer;
begin
  composeBackboneElementChildren(xml, value);
  for i := 0 to value.siteList.Count - 1 do
      ComposeCodeableReference(xml, 'site', value.siteList[i]);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.subSiteList.Count - 1 do
      ComposeCodeableConcept(xml, 'subSite', value.subSiteList[i]);
end;

function TFHIRXmlParser.ParseClaimResponseAddItemDetail(element : TMXmlElement; path : string) : TFhirClaimResponseAddItemDetail;
var
  child : TMXmlElement;
begin
  result := TFhirClaimResponseAddItemDetail.Create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseClaimResponseAddItemDetailChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseClaimResponseAddItemDetailChild(value : TFhirClaimResponseAddItemDetail; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'revenue') then
        value.revenue := ParseCodeableConcept(child, path+'/revenue')
      else if (child.localName = 'productOrService') then
        value.productOrService := ParseCodeableConcept(child, path+'/productOrService')
      else if (child.localName = 'productOrServiceEnd') then
        value.productOrServiceEnd := ParseCodeableConcept(child, path+'/productOrServiceEnd')
      else if (child.localName = 'modifier') then
        value.modifierList.Add(ParseCodeableConcept(child, path+'/modifier'))
      else if (child.localName = 'quantity') then
        value.quantity := ParseQuantity(child, path+'/quantity')
      else if (child.localName = 'unitPrice') then
        value.unitPrice := ParseMoney(child, path+'/unitPrice')
      else if (child.localName = 'factor') then
        value.factorElement := ParseDecimal(child, path+'/factor')
      else if (child.localName = 'tax') then
        value.tax := ParseMoney(child, path+'/tax')
      else if (child.localName = 'net') then
        value.net := ParseMoney(child, path+'/net')
      else if (child.localName = 'noteNumber') then
        value.noteNumberList.Add(ParsePositiveInt(child, path+'/noteNumber'))
      else if (child.localName = 'decision') then
        value.decision := ParseCodeableConcept(child, path+'/decision')
      else if (child.localName = 'adjudication') then
        value.adjudicationList.Add(ParseClaimResponseItemAdjudication(child, path+'/adjudication'))
      else if (child.localName = 'subDetail') then
        value.subDetailList.Add(ParseClaimResponseAddItemDetailSubDetail(child, path+'/subDetail'))
      else if Not ParseBackboneElementChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeClaimResponseAddItemDetail(xml : TXmlBuilder; name : String; value : TFhirClaimResponseAddItemDetail);
begin
  if (value = nil) then
    exit;
  composeElementAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeClaimResponseAddItemDetailChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeClaimResponseAddItemDetailChildren(xml : TXmlBuilder; value : TFhirClaimResponseAddItemDetail);
var
  i : integer;
begin
  composeBackboneElementChildren(xml, value);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(xml, 'revenue', value.revenue);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(xml, 'productOrService', value.productOrService);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(xml, 'productOrServiceEnd', value.productOrServiceEnd);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.modifierList.Count - 1 do
      ComposeCodeableConcept(xml, 'modifier', value.modifierList[i]);
  if (SummaryOption in [soFull, soData]) then
    ComposeQuantity(xml, 'quantity', value.quantity);
  if (SummaryOption in [soFull, soData]) then
    ComposeMoney(xml, 'unitPrice', value.unitPrice);
  if (SummaryOption in [soFull, soData]) then
    ComposeDecimal(xml, 'factor', value.factorElement);
  if (SummaryOption in [soFull, soData]) then
    ComposeMoney(xml, 'tax', value.tax);
  if (SummaryOption in [soFull, soData]) then
    ComposeMoney(xml, 'net', value.net);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.noteNumberList.Count - 1 do
      ComposePositiveInt(xml, 'noteNumber', value.noteNumberList[i]);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(xml, 'decision', value.decision);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.adjudicationList.Count - 1 do
      ComposeClaimResponseItemAdjudication(xml, 'adjudication', value.adjudicationList[i]);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.subDetailList.Count - 1 do
      ComposeClaimResponseAddItemDetailSubDetail(xml, 'subDetail', value.subDetailList[i]);
end;

function TFHIRXmlParser.ParseClaimResponseAddItemDetailSubDetail(element : TMXmlElement; path : string) : TFhirClaimResponseAddItemDetailSubDetail;
var
  child : TMXmlElement;
begin
  result := TFhirClaimResponseAddItemDetailSubDetail.Create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseClaimResponseAddItemDetailSubDetailChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseClaimResponseAddItemDetailSubDetailChild(value : TFhirClaimResponseAddItemDetailSubDetail; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'revenue') then
        value.revenue := ParseCodeableConcept(child, path+'/revenue')
      else if (child.localName = 'productOrService') then
        value.productOrService := ParseCodeableConcept(child, path+'/productOrService')
      else if (child.localName = 'productOrServiceEnd') then
        value.productOrServiceEnd := ParseCodeableConcept(child, path+'/productOrServiceEnd')
      else if (child.localName = 'modifier') then
        value.modifierList.Add(ParseCodeableConcept(child, path+'/modifier'))
      else if (child.localName = 'quantity') then
        value.quantity := ParseQuantity(child, path+'/quantity')
      else if (child.localName = 'unitPrice') then
        value.unitPrice := ParseMoney(child, path+'/unitPrice')
      else if (child.localName = 'factor') then
        value.factorElement := ParseDecimal(child, path+'/factor')
      else if (child.localName = 'tax') then
        value.tax := ParseMoney(child, path+'/tax')
      else if (child.localName = 'net') then
        value.net := ParseMoney(child, path+'/net')
      else if (child.localName = 'noteNumber') then
        value.noteNumberList.Add(ParsePositiveInt(child, path+'/noteNumber'))
      else if (child.localName = 'decision') then
        value.decision := ParseCodeableConcept(child, path+'/decision')
      else if (child.localName = 'adjudication') then
        value.adjudicationList.Add(ParseClaimResponseItemAdjudication(child, path+'/adjudication'))
      else if Not ParseBackboneElementChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeClaimResponseAddItemDetailSubDetail(xml : TXmlBuilder; name : String; value : TFhirClaimResponseAddItemDetailSubDetail);
begin
  if (value = nil) then
    exit;
  composeElementAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeClaimResponseAddItemDetailSubDetailChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeClaimResponseAddItemDetailSubDetailChildren(xml : TXmlBuilder; value : TFhirClaimResponseAddItemDetailSubDetail);
var
  i : integer;
begin
  composeBackboneElementChildren(xml, value);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(xml, 'revenue', value.revenue);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(xml, 'productOrService', value.productOrService);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(xml, 'productOrServiceEnd', value.productOrServiceEnd);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.modifierList.Count - 1 do
      ComposeCodeableConcept(xml, 'modifier', value.modifierList[i]);
  if (SummaryOption in [soFull, soData]) then
    ComposeQuantity(xml, 'quantity', value.quantity);
  if (SummaryOption in [soFull, soData]) then
    ComposeMoney(xml, 'unitPrice', value.unitPrice);
  if (SummaryOption in [soFull, soData]) then
    ComposeDecimal(xml, 'factor', value.factorElement);
  if (SummaryOption in [soFull, soData]) then
    ComposeMoney(xml, 'tax', value.tax);
  if (SummaryOption in [soFull, soData]) then
    ComposeMoney(xml, 'net', value.net);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.noteNumberList.Count - 1 do
      ComposePositiveInt(xml, 'noteNumber', value.noteNumberList[i]);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(xml, 'decision', value.decision);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.adjudicationList.Count - 1 do
      ComposeClaimResponseItemAdjudication(xml, 'adjudication', value.adjudicationList[i]);
end;

function TFHIRXmlParser.ParseClaimResponseTotal(element : TMXmlElement; path : string) : TFhirClaimResponseTotal;
var
  child : TMXmlElement;
begin
  result := TFhirClaimResponseTotal.Create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseClaimResponseTotalChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseClaimResponseTotalChild(value : TFhirClaimResponseTotal; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'category') then
        value.category := ParseCodeableConcept(child, path+'/category')
      else if (child.localName = 'amount') then
        value.amount := ParseMoney(child, path+'/amount')
      else if Not ParseBackboneElementChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeClaimResponseTotal(xml : TXmlBuilder; name : String; value : TFhirClaimResponseTotal);
begin
  if (value = nil) then
    exit;
  composeElementAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeClaimResponseTotalChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeClaimResponseTotalChildren(xml : TXmlBuilder; value : TFhirClaimResponseTotal);
begin
  composeBackboneElementChildren(xml, value);
  ComposeCodeableConcept(xml, 'category', value.category);
  ComposeMoney(xml, 'amount', value.amount);
end;

function TFHIRXmlParser.ParseClaimResponsePayment(element : TMXmlElement; path : string) : TFhirClaimResponsePayment;
var
  child : TMXmlElement;
begin
  result := TFhirClaimResponsePayment.Create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseClaimResponsePaymentChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseClaimResponsePaymentChild(value : TFhirClaimResponsePayment; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'type') then
        value.type_ := ParseCodeableConcept(child, path+'/type')
      else if (child.localName = 'adjustment') then
        value.adjustment := ParseMoney(child, path+'/adjustment')
      else if (child.localName = 'adjustmentReason') then
        value.adjustmentReason := ParseCodeableConcept(child, path+'/adjustmentReason')
      else if (child.localName = 'date') then
        value.dateElement := ParseDate(child, path+'/date')
      else if (child.localName = 'amount') then
        value.amount := ParseMoney(child, path+'/amount')
      else if (child.localName = 'identifier') then
        value.identifier := ParseIdentifier(child, path+'/identifier')
      else if Not ParseBackboneElementChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeClaimResponsePayment(xml : TXmlBuilder; name : String; value : TFhirClaimResponsePayment);
begin
  if (value = nil) then
    exit;
  composeElementAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeClaimResponsePaymentChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeClaimResponsePaymentChildren(xml : TXmlBuilder; value : TFhirClaimResponsePayment);
begin
  composeBackboneElementChildren(xml, value);
  ComposeCodeableConcept(xml, 'type', value.type_);
  if (SummaryOption in [soFull, soData]) then
    ComposeMoney(xml, 'adjustment', value.adjustment);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(xml, 'adjustmentReason', value.adjustmentReason);
  if (SummaryOption in [soFull, soData]) then
    ComposeDate(xml, 'date', value.dateElement);
  ComposeMoney(xml, 'amount', value.amount);
  if (SummaryOption in [soFull, soData]) then
    ComposeIdentifier(xml, 'identifier', value.identifier);
end;

function TFHIRXmlParser.ParseClaimResponseProcessNote(element : TMXmlElement; path : string) : TFhirClaimResponseProcessNote;
var
  child : TMXmlElement;
begin
  result := TFhirClaimResponseProcessNote.Create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseClaimResponseProcessNoteChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseClaimResponseProcessNoteChild(value : TFhirClaimResponseProcessNote; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'number') then
        value.numberElement := ParsePositiveInt(child, path+'/number')
      else if (child.localName = 'type') then
        value.type_Element := ParseEnum(CODES_TFhirNoteTypeEnum, SYSTEMS_TFhirNoteTypeEnum, child, path+'/type')
      else if (child.localName = 'text') then
        value.textElement := ParseString(child, path+'/text')
      else if (child.localName = 'language') then
        value.language := ParseCodeableConcept(child, path+'/language')
      else if Not ParseBackboneElementChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeClaimResponseProcessNote(xml : TXmlBuilder; name : String; value : TFhirClaimResponseProcessNote);
begin
  if (value = nil) then
    exit;
  composeElementAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeClaimResponseProcessNoteChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeClaimResponseProcessNoteChildren(xml : TXmlBuilder; value : TFhirClaimResponseProcessNote);
begin
  composeBackboneElementChildren(xml, value);
  if (SummaryOption in [soFull, soData]) then
    ComposePositiveInt(xml, 'number', value.numberElement);
  if (SummaryOption in [soFull, soData]) then
    ComposeEnum(xml, 'type', value.type_Element, CODES_TFhirNoteTypeEnum);
  ComposeString(xml, 'text', value.textElement);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(xml, 'language', value.language);
end;

function TFHIRXmlParser.ParseClaimResponseInsurance(element : TMXmlElement; path : string) : TFhirClaimResponseInsurance;
var
  child : TMXmlElement;
begin
  result := TFhirClaimResponseInsurance.Create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseClaimResponseInsuranceChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseClaimResponseInsuranceChild(value : TFhirClaimResponseInsurance; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'sequence') then
        value.sequenceElement := ParsePositiveInt(child, path+'/sequence')
      else if (child.localName = 'focal') then
        value.focalElement := ParseBoolean(child, path+'/focal')
      else if (child.localName = 'coverage') then
        value.coverage := ParseReference(child, path+'/coverage')
      else if (child.localName = 'businessArrangement') then
        value.businessArrangementElement := ParseString(child, path+'/businessArrangement')
      else if (child.localName = 'claimResponse') then
        value.claimResponse := ParseReference(child, path+'/claimResponse')
      else if Not ParseBackboneElementChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeClaimResponseInsurance(xml : TXmlBuilder; name : String; value : TFhirClaimResponseInsurance);
begin
  if (value = nil) then
    exit;
  composeElementAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeClaimResponseInsuranceChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeClaimResponseInsuranceChildren(xml : TXmlBuilder; value : TFhirClaimResponseInsurance);
begin
  composeBackboneElementChildren(xml, value);
  ComposePositiveInt(xml, 'sequence', value.sequenceElement);
  ComposeBoolean(xml, 'focal', value.focalElement);
  ComposeReference(xml, 'coverage', value.coverage);
  if (SummaryOption in [soFull, soData]) then
    ComposeString(xml, 'businessArrangement', value.businessArrangementElement);
  if (SummaryOption in [soFull, soData]) then
    ComposeReference(xml, 'claimResponse', value.claimResponse);
end;

function TFHIRXmlParser.ParseClaimResponseError(element : TMXmlElement; path : string) : TFhirClaimResponseError;
var
  child : TMXmlElement;
begin
  result := TFhirClaimResponseError.Create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseClaimResponseErrorChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseClaimResponseErrorChild(value : TFhirClaimResponseError; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'itemSequence') then
        value.itemSequenceElement := ParsePositiveInt(child, path+'/itemSequence')
      else if (child.localName = 'detailSequence') then
        value.detailSequenceElement := ParsePositiveInt(child, path+'/detailSequence')
      else if (child.localName = 'subDetailSequence') then
        value.subDetailSequenceElement := ParsePositiveInt(child, path+'/subDetailSequence')
      else if (child.localName = 'code') then
        value.code := ParseCodeableConcept(child, path+'/code')
      else if Not ParseBackboneElementChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeClaimResponseError(xml : TXmlBuilder; name : String; value : TFhirClaimResponseError);
begin
  if (value = nil) then
    exit;
  composeElementAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeClaimResponseErrorChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeClaimResponseErrorChildren(xml : TXmlBuilder; value : TFhirClaimResponseError);
begin
  composeBackboneElementChildren(xml, value);
  if (SummaryOption in [soFull, soData]) then
    ComposePositiveInt(xml, 'itemSequence', value.itemSequenceElement);
  if (SummaryOption in [soFull, soData]) then
    ComposePositiveInt(xml, 'detailSequence', value.detailSequenceElement);
  if (SummaryOption in [soFull, soData]) then
    ComposePositiveInt(xml, 'subDetailSequence', value.subDetailSequenceElement);
  ComposeCodeableConcept(xml, 'code', value.code);
end;

function TFHIRXmlParser.ParseClaimResponse(element : TMXmlElement; path : string) : TFhirClaimResponse;
var
  child : TMXmlElement;
begin
  result := TFhirClaimResponse.Create;
  try
    parseDomainResourceAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseClaimResponseChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseClaimResponseChild(value : TFhirClaimResponse; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'identifier') then
        value.identifierList.Add(ParseIdentifier(child, path+'/identifier'))
      else if (child.localName = 'status') then
        value.statusElement := ParseEnum(CODES_TFhirFinancialResourceStatusCodesEnum, SYSTEMS_TFhirFinancialResourceStatusCodesEnum, child, path+'/status')
      else if (child.localName = 'type') then
        value.type_ := ParseCodeableConcept(child, path+'/type')
      else if (child.localName = 'subType') then
        value.subType := ParseCodeableConcept(child, path+'/subType')
      else if (child.localName = 'use') then
        value.useElement := ParseEnum(CODES_TFhirUseEnum, SYSTEMS_TFhirUseEnum, child, path+'/use')
      else if (child.localName = 'patient') then
        value.patient := ParseReference(child, path+'/patient')
      else if (child.localName = 'created') then
        value.createdElement := ParseDateTime(child, path+'/created')
      else if (child.localName = 'insurer') then
        value.insurer := ParseReference(child, path+'/insurer')
      else if (child.localName = 'requestor') then
        value.requestor := ParseReference(child, path+'/requestor')
      else if (child.localName = 'request') then
        value.request := ParseReference(child, path+'/request')
      else if (child.localName = 'outcome') then
        value.outcomeElement := ParseEnum(CODES_TFhirClaimProcessingCodesEnum, SYSTEMS_TFhirClaimProcessingCodesEnum, child, path+'/outcome')
      else if (child.localName = 'decision') then
        value.decision := ParseCodeableConcept(child, path+'/decision')
      else if (child.localName = 'disposition') then
        value.dispositionElement := ParseString(child, path+'/disposition')
      else if (child.localName = 'preAuthRef') then
        value.preAuthRefElement := ParseString(child, path+'/preAuthRef')
      else if (child.localName = 'preAuthPeriod') then
        value.preAuthPeriod := ParsePeriod(child, path+'/preAuthPeriod')
      else if (child.localName = 'payeeType') then
        value.payeeType := ParseCodeableConcept(child, path+'/payeeType')
      else if (child.localName = 'encounter') then
        value.encounterList.Add(ParseReference(child, path+'/encounter'))
      else if (child.localName = 'diagnosisRelatedGroup') then
        value.diagnosisRelatedGroup := ParseCodeableConcept(child, path+'/diagnosisRelatedGroup')
      else if (child.localName = 'item') then
        value.itemList.Add(ParseClaimResponseItem(child, path+'/item'))
      else if (child.localName = 'addItem') then
        value.addItemList.Add(ParseClaimResponseAddItem(child, path+'/addItem'))
      else if (child.localName = 'adjudication') then
        value.adjudicationList.Add(ParseClaimResponseItemAdjudication(child, path+'/adjudication'))
      else if (child.localName = 'total') then
        value.totalList.Add(ParseClaimResponseTotal(child, path+'/total'))
      else if (child.localName = 'payment') then
        value.payment := ParseClaimResponsePayment(child, path+'/payment')
      else if (child.localName = 'fundsReserve') then
        value.fundsReserve := ParseCodeableConcept(child, path+'/fundsReserve')
      else if (child.localName = 'formCode') then
        value.formCode := ParseCodeableConcept(child, path+'/formCode')
      else if (child.localName = 'form') then
        value.form := ParseAttachment(child, path+'/form')
      else if (child.localName = 'processNote') then
        value.processNoteList.Add(ParseClaimResponseProcessNote(child, path+'/processNote'))
      else if (child.localName = 'communicationRequest') then
        value.communicationRequestList.Add(ParseReference(child, path+'/communicationRequest'))
      else if (child.localName = 'insurance') then
        value.insuranceList.Add(ParseClaimResponseInsurance(child, path+'/insurance'))
      else if (child.localName = 'error') then
        value.errorList.Add(ParseClaimResponseError(child, path+'/error'))
      else if Not ParseDomainResourceChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeClaimResponse(xml : TXmlBuilder; name : String; value : TFhirClaimResponse);
begin
  if (value = nil) then
    exit;
  composeDomainResourceAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeClaimResponseChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeClaimResponseChildren(xml : TXmlBuilder; value : TFhirClaimResponse);
var
  i : integer;
begin
  composeDomainResourceChildren(xml, value);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.identifierList.Count - 1 do
      ComposeIdentifier(xml, 'identifier', value.identifierList[i]);
  ComposeEnum(xml, 'status', value.statusElement, CODES_TFhirFinancialResourceStatusCodesEnum);
  ComposeCodeableConcept(xml, 'type', value.type_);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(xml, 'subType', value.subType);
  ComposeEnum(xml, 'use', value.useElement, CODES_TFhirUseEnum);
  ComposeReference(xml, 'patient', value.patient);
  ComposeDateTime(xml, 'created', value.createdElement);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference(xml, 'insurer', value.insurer);
  if (SummaryOption in [soFull, soData]) then
    ComposeReference(xml, 'requestor', value.requestor);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference(xml, 'request', value.request);
  ComposeEnum(xml, 'outcome', value.outcomeElement, CODES_TFhirClaimProcessingCodesEnum);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(xml, 'decision', value.decision);
  if (SummaryOption in [soFull, soData]) then
    ComposeString(xml, 'disposition', value.dispositionElement);
  if (SummaryOption in [soFull, soData]) then
    ComposeString(xml, 'preAuthRef', value.preAuthRefElement);
  if (SummaryOption in [soFull, soData]) then
    ComposePeriod(xml, 'preAuthPeriod', value.preAuthPeriod);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(xml, 'payeeType', value.payeeType);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.encounterList.Count - 1 do
      ComposeReference(xml, 'encounter', value.encounterList[i]);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(xml, 'diagnosisRelatedGroup', value.diagnosisRelatedGroup);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.itemList.Count - 1 do
      ComposeClaimResponseItem(xml, 'item', value.itemList[i]);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.addItemList.Count - 1 do
      ComposeClaimResponseAddItem(xml, 'addItem', value.addItemList[i]);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.adjudicationList.Count - 1 do
      ComposeClaimResponseItemAdjudication(xml, 'adjudication', value.adjudicationList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.totalList.Count - 1 do
      ComposeClaimResponseTotal(xml, 'total', value.totalList[i]);
  if (SummaryOption in [soFull, soData]) then
    ComposeClaimResponsePayment(xml, 'payment', value.payment);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(xml, 'fundsReserve', value.fundsReserve);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(xml, 'formCode', value.formCode);
  if (SummaryOption in [soFull, soData]) then
    ComposeAttachment(xml, 'form', value.form);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.processNoteList.Count - 1 do
      ComposeClaimResponseProcessNote(xml, 'processNote', value.processNoteList[i]);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.communicationRequestList.Count - 1 do
      ComposeReference(xml, 'communicationRequest', value.communicationRequestList[i]);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.insuranceList.Count - 1 do
      ComposeClaimResponseInsurance(xml, 'insurance', value.insuranceList[i]);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.errorList.Count - 1 do
      ComposeClaimResponseError(xml, 'error', value.errorList[i]);
end;

{$ENDIF FHIR_CLAIMRESPONSE}
{$IFDEF FHIR_CLINICALIMPRESSION}
function TFHIRXmlParser.ParseClinicalImpressionFinding(element : TMXmlElement; path : string) : TFhirClinicalImpressionFinding;
var
  child : TMXmlElement;
begin
  result := TFhirClinicalImpressionFinding.Create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseClinicalImpressionFindingChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseClinicalImpressionFindingChild(value : TFhirClinicalImpressionFinding; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'item') then
        value.item := ParseCodeableReference(child, path+'/item')
      else if (child.localName = 'basis') then
        value.basisElement := ParseString(child, path+'/basis')
      else if Not ParseBackboneElementChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeClinicalImpressionFinding(xml : TXmlBuilder; name : String; value : TFhirClinicalImpressionFinding);
begin
  if (value = nil) then
    exit;
  composeElementAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeClinicalImpressionFindingChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeClinicalImpressionFindingChildren(xml : TXmlBuilder; value : TFhirClinicalImpressionFinding);
begin
  composeBackboneElementChildren(xml, value);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableReference(xml, 'item', value.item);
  if (SummaryOption in [soFull, soData]) then
    ComposeString(xml, 'basis', value.basisElement);
end;

function TFHIRXmlParser.ParseClinicalImpression(element : TMXmlElement; path : string) : TFhirClinicalImpression;
var
  child : TMXmlElement;
begin
  result := TFhirClinicalImpression.Create;
  try
    parseDomainResourceAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseClinicalImpressionChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseClinicalImpressionChild(value : TFhirClinicalImpression; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'identifier') then
        value.identifierList.Add(ParseIdentifier(child, path+'/identifier'))
      else if (child.localName = 'status') then
        value.statusElement := ParseEnum(CODES_TFhirEventStatusEnum, SYSTEMS_TFhirEventStatusEnum, child, path+'/status')
      else if (child.localName = 'statusReason') then
        value.statusReason := ParseCodeableConcept(child, path+'/statusReason')
      else if (child.localName = 'description') then
        value.descriptionElement := ParseString(child, path+'/description')
      else if (child.localName = 'subject') then
        value.subject := ParseReference(child, path+'/subject')
      else if (child.localName = 'encounter') then
        value.encounter := ParseReference(child, path+'/encounter')
      else if (child.localName = 'effectivePeriod') then
        value.effective := ParsePeriod(child, path+'/effectivePeriod')
      else if (child.localName = 'effectiveDateTime') then
        value.effective := ParseDateTime(child, path+'/effectiveDateTime')
      else if (child.localName = 'date') then
        value.dateElement := ParseDateTime(child, path+'/date')
      else if (child.localName = 'performer') then
        value.performer := ParseReference(child, path+'/performer')
      else if (child.localName = 'previous') then
        value.previous := ParseReference(child, path+'/previous')
      else if (child.localName = 'problem') then
        value.problemList.Add(ParseReference(child, path+'/problem'))
      else if (child.localName = 'changePattern') then
        value.changePattern := ParseCodeableConcept(child, path+'/changePattern')
      else if (child.localName = 'protocol') then
        value.protocolList.Add(ParseUri(child, path+'/protocol'))
      else if (child.localName = 'summary') then
        value.summaryElement := ParseString(child, path+'/summary')
      else if (child.localName = 'finding') then
        value.findingList.Add(ParseClinicalImpressionFinding(child, path+'/finding'))
      else if (child.localName = 'prognosisCodeableConcept') then
        value.prognosisCodeableConceptList.Add(ParseCodeableConcept(child, path+'/prognosisCodeableConcept'))
      else if (child.localName = 'prognosisReference') then
        value.prognosisReferenceList.Add(ParseReference(child, path+'/prognosisReference'))
      else if (child.localName = 'supportingInfo') then
        value.supportingInfoList.Add(ParseReference(child, path+'/supportingInfo'))
      else if (child.localName = 'note') then
        value.noteList.Add(ParseAnnotation(child, path+'/note'))
      else if Not ParseDomainResourceChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeClinicalImpression(xml : TXmlBuilder; name : String; value : TFhirClinicalImpression);
begin
  if (value = nil) then
    exit;
  composeDomainResourceAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeClinicalImpressionChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeClinicalImpressionChildren(xml : TXmlBuilder; value : TFhirClinicalImpression);
var
  i : integer;
begin
  composeDomainResourceChildren(xml, value);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.identifierList.Count - 1 do
      ComposeIdentifier(xml, 'identifier', value.identifierList[i]);
  ComposeEnum(xml, 'status', value.statusElement, CODES_TFhirEventStatusEnum);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(xml, 'statusReason', value.statusReason);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(xml, 'description', value.descriptionElement);
  ComposeReference(xml, 'subject', value.subject);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference(xml, 'encounter', value.encounter);
  if (SummaryOption in [soFull, soSummary, soData]) and (value.effective is TFhirPeriod) {6} then
    ComposePeriod(xml, 'effectivePeriod', TFhirPeriod(value.effective))
  else if (SummaryOption in [soFull, soSummary, soData]) and (value.effective is TFhirDateTime) {6} then
    ComposeDateTime(xml, 'effectiveDateTime', TFhirDateTime(value.effective));
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDateTime(xml, 'date', value.dateElement);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference(xml, 'performer', value.performer);
  if (SummaryOption in [soFull, soData]) then
    ComposeReference(xml, 'previous', value.previous);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.problemList.Count - 1 do
      ComposeReference(xml, 'problem', value.problemList[i]);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(xml, 'changePattern', value.changePattern);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.protocolList.Count - 1 do
      ComposeUri(xml, 'protocol', value.protocolList[i]);
  if (SummaryOption in [soFull, soData]) then
    ComposeString(xml, 'summary', value.summaryElement);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.findingList.Count - 1 do
      ComposeClinicalImpressionFinding(xml, 'finding', value.findingList[i]);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.prognosisCodeableConceptList.Count - 1 do
      ComposeCodeableConcept(xml, 'prognosisCodeableConcept', value.prognosisCodeableConceptList[i]);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.prognosisReferenceList.Count - 1 do
      ComposeReference(xml, 'prognosisReference', value.prognosisReferenceList[i]);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.supportingInfoList.Count - 1 do
      ComposeReference(xml, 'supportingInfo', value.supportingInfoList[i]);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.noteList.Count - 1 do
      ComposeAnnotation(xml, 'note', value.noteList[i]);
end;

{$ENDIF FHIR_CLINICALIMPRESSION}
{$IFDEF FHIR_CLINICALUSEDEFINITION}
function TFHIRXmlParser.ParseClinicalUseDefinitionContraindication(element : TMXmlElement; path : string) : TFhirClinicalUseDefinitionContraindication;
var
  child : TMXmlElement;
begin
  result := TFhirClinicalUseDefinitionContraindication.Create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseClinicalUseDefinitionContraindicationChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseClinicalUseDefinitionContraindicationChild(value : TFhirClinicalUseDefinitionContraindication; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'diseaseSymptomProcedure') then
        value.diseaseSymptomProcedure := ParseCodeableReference(child, path+'/diseaseSymptomProcedure')
      else if (child.localName = 'diseaseStatus') then
        value.diseaseStatus := ParseCodeableReference(child, path+'/diseaseStatus')
      else if (child.localName = 'comorbidity') then
        value.comorbidityList.Add(ParseCodeableReference(child, path+'/comorbidity'))
      else if (child.localName = 'indication') then
        value.indicationList.Add(ParseReference(child, path+'/indication'))
      else if (child.localName = 'otherTherapy') then
        value.otherTherapyList.Add(ParseClinicalUseDefinitionContraindicationOtherTherapy(child, path+'/otherTherapy'))
      else if Not ParseBackboneElementChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeClinicalUseDefinitionContraindication(xml : TXmlBuilder; name : String; value : TFhirClinicalUseDefinitionContraindication);
begin
  if (value = nil) then
    exit;
  composeElementAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeClinicalUseDefinitionContraindicationChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeClinicalUseDefinitionContraindicationChildren(xml : TXmlBuilder; value : TFhirClinicalUseDefinitionContraindication);
var
  i : integer;
begin
  composeBackboneElementChildren(xml, value);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableReference(xml, 'diseaseSymptomProcedure', value.diseaseSymptomProcedure);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableReference(xml, 'diseaseStatus', value.diseaseStatus);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.comorbidityList.Count - 1 do
      ComposeCodeableReference(xml, 'comorbidity', value.comorbidityList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.indicationList.Count - 1 do
      ComposeReference(xml, 'indication', value.indicationList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.otherTherapyList.Count - 1 do
      ComposeClinicalUseDefinitionContraindicationOtherTherapy(xml, 'otherTherapy', value.otherTherapyList[i]);
end;

function TFHIRXmlParser.ParseClinicalUseDefinitionContraindicationOtherTherapy(element : TMXmlElement; path : string) : TFhirClinicalUseDefinitionContraindicationOtherTherapy;
var
  child : TMXmlElement;
begin
  result := TFhirClinicalUseDefinitionContraindicationOtherTherapy.Create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseClinicalUseDefinitionContraindicationOtherTherapyChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseClinicalUseDefinitionContraindicationOtherTherapyChild(value : TFhirClinicalUseDefinitionContraindicationOtherTherapy; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'relationshipType') then
        value.relationshipType := ParseCodeableConcept(child, path+'/relationshipType')
      else if (child.localName = 'treatment') then
        value.treatment := ParseCodeableReference(child, path+'/treatment')
      else if Not ParseBackboneElementChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeClinicalUseDefinitionContraindicationOtherTherapy(xml : TXmlBuilder; name : String; value : TFhirClinicalUseDefinitionContraindicationOtherTherapy);
begin
  if (value = nil) then
    exit;
  composeElementAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeClinicalUseDefinitionContraindicationOtherTherapyChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeClinicalUseDefinitionContraindicationOtherTherapyChildren(xml : TXmlBuilder; value : TFhirClinicalUseDefinitionContraindicationOtherTherapy);
begin
  composeBackboneElementChildren(xml, value);
  ComposeCodeableConcept(xml, 'relationshipType', value.relationshipType);
  ComposeCodeableReference(xml, 'treatment', value.treatment);
end;

function TFHIRXmlParser.ParseClinicalUseDefinitionIndication(element : TMXmlElement; path : string) : TFhirClinicalUseDefinitionIndication;
var
  child : TMXmlElement;
begin
  result := TFhirClinicalUseDefinitionIndication.Create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseClinicalUseDefinitionIndicationChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseClinicalUseDefinitionIndicationChild(value : TFhirClinicalUseDefinitionIndication; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'diseaseSymptomProcedure') then
        value.diseaseSymptomProcedure := ParseCodeableReference(child, path+'/diseaseSymptomProcedure')
      else if (child.localName = 'diseaseStatus') then
        value.diseaseStatus := ParseCodeableReference(child, path+'/diseaseStatus')
      else if (child.localName = 'comorbidity') then
        value.comorbidityList.Add(ParseCodeableReference(child, path+'/comorbidity'))
      else if (child.localName = 'intendedEffect') then
        value.intendedEffect := ParseCodeableReference(child, path+'/intendedEffect')
      else if (child.localName = 'durationRange') then
        value.duration := ParseRange(child, path+'/durationRange')
      else if (child.localName = 'durationString') then
        value.duration := ParseString(child, path+'/durationString')
      else if (child.localName = 'undesirableEffect') then
        value.undesirableEffectList.Add(ParseReference(child, path+'/undesirableEffect'))
      else if (child.localName = 'otherTherapy') then
        value.otherTherapyList.Add(ParseClinicalUseDefinitionContraindicationOtherTherapy(child, path+'/otherTherapy'))
      else if Not ParseBackboneElementChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeClinicalUseDefinitionIndication(xml : TXmlBuilder; name : String; value : TFhirClinicalUseDefinitionIndication);
begin
  if (value = nil) then
    exit;
  composeElementAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeClinicalUseDefinitionIndicationChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeClinicalUseDefinitionIndicationChildren(xml : TXmlBuilder; value : TFhirClinicalUseDefinitionIndication);
var
  i : integer;
begin
  composeBackboneElementChildren(xml, value);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableReference(xml, 'diseaseSymptomProcedure', value.diseaseSymptomProcedure);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableReference(xml, 'diseaseStatus', value.diseaseStatus);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.comorbidityList.Count - 1 do
      ComposeCodeableReference(xml, 'comorbidity', value.comorbidityList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableReference(xml, 'intendedEffect', value.intendedEffect);
  if (SummaryOption in [soFull, soSummary, soData]) and (value.duration is TFhirRange) {6} then
    ComposeRange(xml, 'durationRange', TFhirRange(value.duration))
  else if (SummaryOption in [soFull, soSummary, soData]) and (value.duration is TFhirString) {6} then
    ComposeString(xml, 'durationString', TFhirString(value.duration));
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.undesirableEffectList.Count - 1 do
      ComposeReference(xml, 'undesirableEffect', value.undesirableEffectList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.otherTherapyList.Count - 1 do
      ComposeClinicalUseDefinitionContraindicationOtherTherapy(xml, 'otherTherapy', value.otherTherapyList[i]);
end;

function TFHIRXmlParser.ParseClinicalUseDefinitionInteraction(element : TMXmlElement; path : string) : TFhirClinicalUseDefinitionInteraction;
var
  child : TMXmlElement;
begin
  result := TFhirClinicalUseDefinitionInteraction.Create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseClinicalUseDefinitionInteractionChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseClinicalUseDefinitionInteractionChild(value : TFhirClinicalUseDefinitionInteraction; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'interactant') then
        value.interactantList.Add(ParseClinicalUseDefinitionInteractionInteractant(child, path+'/interactant'))
      else if (child.localName = 'type') then
        value.type_ := ParseCodeableConcept(child, path+'/type')
      else if (child.localName = 'effect') then
        value.effect := ParseCodeableReference(child, path+'/effect')
      else if (child.localName = 'incidence') then
        value.incidence := ParseCodeableConcept(child, path+'/incidence')
      else if (child.localName = 'management') then
        value.managementList.Add(ParseCodeableConcept(child, path+'/management'))
      else if Not ParseBackboneElementChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeClinicalUseDefinitionInteraction(xml : TXmlBuilder; name : String; value : TFhirClinicalUseDefinitionInteraction);
begin
  if (value = nil) then
    exit;
  composeElementAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeClinicalUseDefinitionInteractionChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeClinicalUseDefinitionInteractionChildren(xml : TXmlBuilder; value : TFhirClinicalUseDefinitionInteraction);
var
  i : integer;
begin
  composeBackboneElementChildren(xml, value);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.interactantList.Count - 1 do
      ComposeClinicalUseDefinitionInteractionInteractant(xml, 'interactant', value.interactantList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(xml, 'type', value.type_);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableReference(xml, 'effect', value.effect);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(xml, 'incidence', value.incidence);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.managementList.Count - 1 do
      ComposeCodeableConcept(xml, 'management', value.managementList[i]);
end;

function TFHIRXmlParser.ParseClinicalUseDefinitionInteractionInteractant(element : TMXmlElement; path : string) : TFhirClinicalUseDefinitionInteractionInteractant;
var
  child : TMXmlElement;
begin
  result := TFhirClinicalUseDefinitionInteractionInteractant.Create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseClinicalUseDefinitionInteractionInteractantChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseClinicalUseDefinitionInteractionInteractantChild(value : TFhirClinicalUseDefinitionInteractionInteractant; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'itemReference') then
        value.item := ParseReference(child, path+'/itemReference')
      else if (child.localName = 'itemCodeableConcept') then
        value.item := ParseCodeableConcept(child, path+'/itemCodeableConcept')
      else if Not ParseBackboneElementChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeClinicalUseDefinitionInteractionInteractant(xml : TXmlBuilder; name : String; value : TFhirClinicalUseDefinitionInteractionInteractant);
begin
  if (value = nil) then
    exit;
  composeElementAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeClinicalUseDefinitionInteractionInteractantChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeClinicalUseDefinitionInteractionInteractantChildren(xml : TXmlBuilder; value : TFhirClinicalUseDefinitionInteractionInteractant);
begin
  composeBackboneElementChildren(xml, value);
  if (value.item is TFhirReference) {2} then
    ComposeReference(xml, 'itemReference', TFhirReference(value.item))
  else if (value.item is TFhirCodeableConcept) {6} then
    ComposeCodeableConcept(xml, 'itemCodeableConcept', TFhirCodeableConcept(value.item));
end;

function TFHIRXmlParser.ParseClinicalUseDefinitionUndesirableEffect(element : TMXmlElement; path : string) : TFhirClinicalUseDefinitionUndesirableEffect;
var
  child : TMXmlElement;
begin
  result := TFhirClinicalUseDefinitionUndesirableEffect.Create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseClinicalUseDefinitionUndesirableEffectChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseClinicalUseDefinitionUndesirableEffectChild(value : TFhirClinicalUseDefinitionUndesirableEffect; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'symptomConditionEffect') then
        value.symptomConditionEffect := ParseCodeableReference(child, path+'/symptomConditionEffect')
      else if (child.localName = 'classification') then
        value.classification := ParseCodeableConcept(child, path+'/classification')
      else if (child.localName = 'frequencyOfOccurrence') then
        value.frequencyOfOccurrence := ParseCodeableConcept(child, path+'/frequencyOfOccurrence')
      else if Not ParseBackboneElementChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeClinicalUseDefinitionUndesirableEffect(xml : TXmlBuilder; name : String; value : TFhirClinicalUseDefinitionUndesirableEffect);
begin
  if (value = nil) then
    exit;
  composeElementAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeClinicalUseDefinitionUndesirableEffectChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeClinicalUseDefinitionUndesirableEffectChildren(xml : TXmlBuilder; value : TFhirClinicalUseDefinitionUndesirableEffect);
begin
  composeBackboneElementChildren(xml, value);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableReference(xml, 'symptomConditionEffect', value.symptomConditionEffect);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(xml, 'classification', value.classification);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(xml, 'frequencyOfOccurrence', value.frequencyOfOccurrence);
end;

function TFHIRXmlParser.ParseClinicalUseDefinitionWarning(element : TMXmlElement; path : string) : TFhirClinicalUseDefinitionWarning;
var
  child : TMXmlElement;
begin
  result := TFhirClinicalUseDefinitionWarning.Create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseClinicalUseDefinitionWarningChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseClinicalUseDefinitionWarningChild(value : TFhirClinicalUseDefinitionWarning; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'description') then
        value.descriptionElement := ParseMarkdown(child, path+'/description')
      else if (child.localName = 'code') then
        value.code := ParseCodeableConcept(child, path+'/code')
      else if Not ParseBackboneElementChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeClinicalUseDefinitionWarning(xml : TXmlBuilder; name : String; value : TFhirClinicalUseDefinitionWarning);
begin
  if (value = nil) then
    exit;
  composeElementAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeClinicalUseDefinitionWarningChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeClinicalUseDefinitionWarningChildren(xml : TXmlBuilder; value : TFhirClinicalUseDefinitionWarning);
begin
  composeBackboneElementChildren(xml, value);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeMarkdown(xml, 'description', value.descriptionElement);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(xml, 'code', value.code);
end;

function TFHIRXmlParser.ParseClinicalUseDefinition(element : TMXmlElement; path : string) : TFhirClinicalUseDefinition;
var
  child : TMXmlElement;
begin
  result := TFhirClinicalUseDefinition.Create;
  try
    parseDomainResourceAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseClinicalUseDefinitionChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseClinicalUseDefinitionChild(value : TFhirClinicalUseDefinition; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'identifier') then
        value.identifierList.Add(ParseIdentifier(child, path+'/identifier'))
      else if (child.localName = 'type') then
        value.type_Element := ParseEnum(CODES_TFhirClinicalUseDefinitionTypeEnum, SYSTEMS_TFhirClinicalUseDefinitionTypeEnum, child, path+'/type')
      else if (child.localName = 'category') then
        value.categoryList.Add(ParseCodeableConcept(child, path+'/category'))
      else if (child.localName = 'subject') then
        value.subjectList.Add(ParseReference(child, path+'/subject'))
      else if (child.localName = 'status') then
        value.status := ParseCodeableConcept(child, path+'/status')
      else if (child.localName = 'contraindication') then
        value.contraindication := ParseClinicalUseDefinitionContraindication(child, path+'/contraindication')
      else if (child.localName = 'indication') then
        value.indication := ParseClinicalUseDefinitionIndication(child, path+'/indication')
      else if (child.localName = 'interaction') then
        value.interaction := ParseClinicalUseDefinitionInteraction(child, path+'/interaction')
      else if (child.localName = 'population') then
        value.populationList.Add(ParseReference(child, path+'/population'))
      else if (child.localName = 'undesirableEffect') then
        value.undesirableEffect := ParseClinicalUseDefinitionUndesirableEffect(child, path+'/undesirableEffect')
      else if (child.localName = 'warning') then
        value.warning := ParseClinicalUseDefinitionWarning(child, path+'/warning')
      else if Not ParseDomainResourceChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeClinicalUseDefinition(xml : TXmlBuilder; name : String; value : TFhirClinicalUseDefinition);
begin
  if (value = nil) then
    exit;
  composeDomainResourceAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeClinicalUseDefinitionChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeClinicalUseDefinitionChildren(xml : TXmlBuilder; value : TFhirClinicalUseDefinition);
var
  i : integer;
begin
  composeDomainResourceChildren(xml, value);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.identifierList.Count - 1 do
      ComposeIdentifier(xml, 'identifier', value.identifierList[i]);
  ComposeEnum(xml, 'type', value.type_Element, CODES_TFhirClinicalUseDefinitionTypeEnum);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.categoryList.Count - 1 do
      ComposeCodeableConcept(xml, 'category', value.categoryList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.subjectList.Count - 1 do
      ComposeReference(xml, 'subject', value.subjectList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(xml, 'status', value.status);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeClinicalUseDefinitionContraindication(xml, 'contraindication', value.contraindication);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeClinicalUseDefinitionIndication(xml, 'indication', value.indication);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeClinicalUseDefinitionInteraction(xml, 'interaction', value.interaction);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.populationList.Count - 1 do
      ComposeReference(xml, 'population', value.populationList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeClinicalUseDefinitionUndesirableEffect(xml, 'undesirableEffect', value.undesirableEffect);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeClinicalUseDefinitionWarning(xml, 'warning', value.warning);
end;

{$ENDIF FHIR_CLINICALUSEDEFINITION}
{$IFDEF FHIR_CODESYSTEM}
function TFHIRXmlParser.ParseCodeSystemFilter(element : TMXmlElement; path : string) : TFhirCodeSystemFilter;
var
  child : TMXmlElement;
begin
  result := TFhirCodeSystemFilter.Create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseCodeSystemFilterChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseCodeSystemFilterChild(value : TFhirCodeSystemFilter; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'code') then
        value.codeElement := ParseCode(child, path+'/code')
      else if (child.localName = 'description') then
        value.descriptionElement := ParseString(child, path+'/description')
      else if (child.localName = 'operator') then
        value.operatorList.Add(ParseEnum(CODES_TFhirFilterOperatorEnum, SYSTEMS_TFhirFilterOperatorEnum, child, path+'/operator')){y.1}
      else if (child.localName = 'value') then
        value.valueElement := ParseString(child, path+'/value')
      else if Not ParseBackboneElementChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeCodeSystemFilter(xml : TXmlBuilder; name : String; value : TFhirCodeSystemFilter);
begin
  if (value = nil) then
    exit;
  composeElementAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeCodeSystemFilterChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeCodeSystemFilterChildren(xml : TXmlBuilder; value : TFhirCodeSystemFilter);
var
  i : integer;
begin
  composeBackboneElementChildren(xml, value);
  ComposeCode(xml, 'code', value.codeElement);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(xml, 'description', value.descriptionElement);
  for i := 0 to value.operatorList.Count - 1 do
      ComposeEnum(xml, 'operator', value.operatorList[i], CODES_TFhirFilterOperatorEnum);
  ComposeString(xml, 'value', value.valueElement);
end;

function TFHIRXmlParser.ParseCodeSystemProperty(element : TMXmlElement; path : string) : TFhirCodeSystemProperty;
var
  child : TMXmlElement;
begin
  result := TFhirCodeSystemProperty.Create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseCodeSystemPropertyChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseCodeSystemPropertyChild(value : TFhirCodeSystemProperty; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'code') then
        value.codeElement := ParseCode(child, path+'/code')
      else if (child.localName = 'uri') then
        value.uriElement := ParseUri(child, path+'/uri')
      else if (child.localName = 'description') then
        value.descriptionElement := ParseString(child, path+'/description')
      else if (child.localName = 'type') then
        value.type_Element := ParseEnum(CODES_TFhirConceptPropertyTypeEnum, SYSTEMS_TFhirConceptPropertyTypeEnum, child, path+'/type')
      else if Not ParseBackboneElementChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeCodeSystemProperty(xml : TXmlBuilder; name : String; value : TFhirCodeSystemProperty);
begin
  if (value = nil) then
    exit;
  composeElementAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeCodeSystemPropertyChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeCodeSystemPropertyChildren(xml : TXmlBuilder; value : TFhirCodeSystemProperty);
begin
  composeBackboneElementChildren(xml, value);
  ComposeCode(xml, 'code', value.codeElement);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeUri(xml, 'uri', value.uriElement);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(xml, 'description', value.descriptionElement);
  ComposeEnum(xml, 'type', value.type_Element, CODES_TFhirConceptPropertyTypeEnum);
end;

function TFHIRXmlParser.ParseCodeSystemConcept(element : TMXmlElement; path : string) : TFhirCodeSystemConcept;
var
  child : TMXmlElement;
begin
  result := TFhirCodeSystemConcept.Create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseCodeSystemConceptChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseCodeSystemConceptChild(value : TFhirCodeSystemConcept; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'code') then
        value.codeElement := ParseCode(child, path+'/code')
      else if (child.localName = 'display') then
        value.displayElement := ParseString(child, path+'/display')
      else if (child.localName = 'definition') then
        value.definitionElement := ParseString(child, path+'/definition')
      else if (child.localName = 'designation') then
        value.designationList.Add(ParseCodeSystemConceptDesignation(child, path+'/designation'))
      else if (child.localName = 'property') then
        value.property_List.Add(ParseCodeSystemConceptProperty(child, path+'/property'))
      else if (child.localName = 'concept') then
        value.conceptList.Add(ParseCodeSystemConcept(child, path+'/concept'))
      else if Not ParseBackboneElementChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeCodeSystemConcept(xml : TXmlBuilder; name : String; value : TFhirCodeSystemConcept);
begin
  if (value = nil) then
    exit;
  composeElementAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeCodeSystemConceptChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeCodeSystemConceptChildren(xml : TXmlBuilder; value : TFhirCodeSystemConcept);
var
  i : integer;
begin
  composeBackboneElementChildren(xml, value);
  ComposeCode(xml, 'code', value.codeElement);
  if (SummaryOption in [soFull, soData]) then
    ComposeString(xml, 'display', value.displayElement);
  if (SummaryOption in [soFull, soData]) then
    ComposeString(xml, 'definition', value.definitionElement);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.designationList.Count - 1 do
      ComposeCodeSystemConceptDesignation(xml, 'designation', value.designationList[i]);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.property_List.Count - 1 do
      ComposeCodeSystemConceptProperty(xml, 'property', value.property_List[i]);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.conceptList.Count - 1 do
      ComposeCodeSystemConcept(xml, 'concept', value.conceptList[i]);
end;

function TFHIRXmlParser.ParseCodeSystemConceptDesignation(element : TMXmlElement; path : string) : TFhirCodeSystemConceptDesignation;
var
  child : TMXmlElement;
begin
  result := TFhirCodeSystemConceptDesignation.Create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseCodeSystemConceptDesignationChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseCodeSystemConceptDesignationChild(value : TFhirCodeSystemConceptDesignation; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'language') then
        value.languageElement := ParseCode(child, path+'/language')
      else if (child.localName = 'use') then
        value.use := ParseCoding(child, path+'/use')
      else if (child.localName = 'additionalUse') then
        value.additionalUseList.Add(ParseCoding(child, path+'/additionalUse'))
      else if (child.localName = 'value') then
        value.valueElement := ParseString(child, path+'/value')
      else if Not ParseBackboneElementChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeCodeSystemConceptDesignation(xml : TXmlBuilder; name : String; value : TFhirCodeSystemConceptDesignation);
begin
  if (value = nil) then
    exit;
  composeElementAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeCodeSystemConceptDesignationChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeCodeSystemConceptDesignationChildren(xml : TXmlBuilder; value : TFhirCodeSystemConceptDesignation);
var
  i : integer;
begin
  composeBackboneElementChildren(xml, value);
  if (SummaryOption in [soFull, soData]) then
    ComposeCode(xml, 'language', value.languageElement);
  if (SummaryOption in [soFull, soData]) then
    ComposeCoding(xml, 'use', value.use);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.additionalUseList.Count - 1 do
      ComposeCoding(xml, 'additionalUse', value.additionalUseList[i]);
  ComposeString(xml, 'value', value.valueElement);
end;

function TFHIRXmlParser.ParseCodeSystemConceptProperty(element : TMXmlElement; path : string) : TFhirCodeSystemConceptProperty;
var
  child : TMXmlElement;
begin
  result := TFhirCodeSystemConceptProperty.Create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseCodeSystemConceptPropertyChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseCodeSystemConceptPropertyChild(value : TFhirCodeSystemConceptProperty; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'code') then
        value.codeElement := ParseCode(child, path+'/code')
      else if (child.localName = 'valueCode') then
        value.value := ParseCode(child, path+'/valueCode')
      else if (child.localName = 'valueCoding') then
        value.value := ParseCoding(child, path+'/valueCoding')
      else if (child.localName = 'valueString') then
        value.value := ParseString(child, path+'/valueString')
      else if (child.localName = 'valueInteger') then
        value.value := ParseInteger(child, path+'/valueInteger')
      else if (child.localName = 'valueBoolean') then
        value.value := ParseBoolean(child, path+'/valueBoolean')
      else if (child.localName = 'valueDateTime') then
        value.value := ParseDateTime(child, path+'/valueDateTime')
      else if (child.localName = 'valueDecimal') then
        value.value := ParseDecimal(child, path+'/valueDecimal')
      else if Not ParseBackboneElementChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeCodeSystemConceptProperty(xml : TXmlBuilder; name : String; value : TFhirCodeSystemConceptProperty);
begin
  if (value = nil) then
    exit;
  composeElementAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeCodeSystemConceptPropertyChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeCodeSystemConceptPropertyChildren(xml : TXmlBuilder; value : TFhirCodeSystemConceptProperty);
begin
  composeBackboneElementChildren(xml, value);
  ComposeCode(xml, 'code', value.codeElement);
  if (value.value is TFhirCode) {6} then
    ComposeCode(xml, 'valueCode', TFhirCode(value.value))
  else if (value.value is TFhirCoding) {6} then
    ComposeCoding(xml, 'valueCoding', TFhirCoding(value.value))
  else if (value.value is TFhirString) {6} then
    ComposeString(xml, 'valueString', TFhirString(value.value))
  else if (value.value is TFhirInteger) {6} then
    ComposeInteger(xml, 'valueInteger', TFhirInteger(value.value))
  else if (value.value is TFhirBoolean) {6} then
    ComposeBoolean(xml, 'valueBoolean', TFhirBoolean(value.value))
  else if (value.value is TFhirDateTime) {6} then
    ComposeDateTime(xml, 'valueDateTime', TFhirDateTime(value.value))
  else if (value.value is TFhirDecimal) {6} then
    ComposeDecimal(xml, 'valueDecimal', TFhirDecimal(value.value));
end;

function TFHIRXmlParser.ParseCodeSystem(element : TMXmlElement; path : string) : TFhirCodeSystem;
var
  child : TMXmlElement;
begin
  result := TFhirCodeSystem.Create;
  try
    parseMetadataResourceAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseCodeSystemChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseCodeSystemChild(value : TFhirCodeSystem; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'url') then
        value.urlElement := ParseUri(child, path+'/url')
      else if (child.localName = 'identifier') then
        value.identifierList.Add(ParseIdentifier(child, path+'/identifier'))
      else if (child.localName = 'version') then
        value.versionElement := ParseString(child, path+'/version')
      else if (child.localName = 'name') then
        value.nameElement := ParseString(child, path+'/name')
      else if (child.localName = 'title') then
        value.titleElement := ParseString(child, path+'/title')
      else if (child.localName = 'status') then
        value.statusElement := ParseEnum(CODES_TFhirPublicationStatusEnum, SYSTEMS_TFhirPublicationStatusEnum, child, path+'/status')
      else if (child.localName = 'experimental') then
        value.experimentalElement := ParseBoolean(child, path+'/experimental')
      else if (child.localName = 'date') then
        value.dateElement := ParseDateTime(child, path+'/date')
      else if (child.localName = 'publisher') then
        value.publisherElement := ParseString(child, path+'/publisher')
      else if (child.localName = 'contact') then
        value.contactList.Add(ParseContactDetail(child, path+'/contact'))
      else if (child.localName = 'description') then
        value.descriptionElement := ParseMarkdown(child, path+'/description')
      else if (child.localName = 'useContext') then
        value.useContextList.Add(ParseUsageContext(child, path+'/useContext'))
      else if (child.localName = 'jurisdiction') then
        value.jurisdictionList.Add(ParseCodeableConcept(child, path+'/jurisdiction'))
      else if (child.localName = 'purpose') then
        value.purposeElement := ParseMarkdown(child, path+'/purpose')
      else if (child.localName = 'copyright') then
        value.copyrightElement := ParseMarkdown(child, path+'/copyright')
      else if (child.localName = 'approvalDate') then
        value.approvalDateElement := ParseDate(child, path+'/approvalDate')
      else if (child.localName = 'lastReviewDate') then
        value.lastReviewDateElement := ParseDate(child, path+'/lastReviewDate')
      else if (child.localName = 'effectivePeriod') then
        value.effectivePeriod := ParsePeriod(child, path+'/effectivePeriod')
      else if (child.localName = 'topic') then
        value.topicList.Add(ParseCodeableConcept(child, path+'/topic'))
      else if (child.localName = 'author') then
        value.authorList.Add(ParseContactDetail(child, path+'/author'))
      else if (child.localName = 'editor') then
        value.editorList.Add(ParseContactDetail(child, path+'/editor'))
      else if (child.localName = 'reviewer') then
        value.reviewerList.Add(ParseContactDetail(child, path+'/reviewer'))
      else if (child.localName = 'endorser') then
        value.endorserList.Add(ParseContactDetail(child, path+'/endorser'))
      else if (child.localName = 'relatedArtifact') then
        value.relatedArtifactList.Add(ParseRelatedArtifact(child, path+'/relatedArtifact'))
      else if (child.localName = 'caseSensitive') then
        value.caseSensitiveElement := ParseBoolean(child, path+'/caseSensitive')
      else if (child.localName = 'valueSet') then
        value.valueSetElement := ParseCanonical(child, path+'/valueSet')
      else if (child.localName = 'hierarchyMeaning') then
        value.hierarchyMeaningElement := ParseEnum(CODES_TFhirCodeSystemHierarchyMeaningEnum, SYSTEMS_TFhirCodeSystemHierarchyMeaningEnum, child, path+'/hierarchyMeaning')
      else if (child.localName = 'compositional') then
        value.compositionalElement := ParseBoolean(child, path+'/compositional')
      else if (child.localName = 'versionNeeded') then
        value.versionNeededElement := ParseBoolean(child, path+'/versionNeeded')
      else if (child.localName = 'content') then
        value.contentElement := ParseEnum(CODES_TFhirCodeSystemContentModeEnum, SYSTEMS_TFhirCodeSystemContentModeEnum, child, path+'/content')
      else if (child.localName = 'supplements') then
        value.supplementsElement := ParseCanonical(child, path+'/supplements')
      else if (child.localName = 'count') then
        value.countElement := ParseUnsignedInt(child, path+'/count')
      else if (child.localName = 'filter') then
        value.filterList.Add(ParseCodeSystemFilter(child, path+'/filter'))
      else if (child.localName = 'property') then
        value.property_List.Add(ParseCodeSystemProperty(child, path+'/property'))
      else if (child.localName = 'concept') then
        value.conceptList.Add(ParseCodeSystemConcept(child, path+'/concept'))
      else if Not ParseMetadataResourceChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeCodeSystem(xml : TXmlBuilder; name : String; value : TFhirCodeSystem);
begin
  if (value = nil) then
    exit;
  composeMetadataResourceAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeCodeSystemChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeCodeSystemChildren(xml : TXmlBuilder; value : TFhirCodeSystem);
var
  i : integer;
begin
  composeMetadataResourceChildren(xml, value);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeUri(xml, 'url', value.urlElement);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.identifierList.Count - 1 do
      ComposeIdentifier(xml, 'identifier', value.identifierList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(xml, 'version', value.versionElement);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(xml, 'name', value.nameElement);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(xml, 'title', value.titleElement);
  ComposeEnum(xml, 'status', value.statusElement, CODES_TFhirPublicationStatusEnum);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeBoolean(xml, 'experimental', value.experimentalElement);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDateTime(xml, 'date', value.dateElement);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(xml, 'publisher', value.publisherElement);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.contactList.Count - 1 do
      ComposeContactDetail(xml, 'contact', value.contactList[i]);
  if (SummaryOption in [soFull, soData]) then
    ComposeMarkdown(xml, 'description', value.descriptionElement);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.useContextList.Count - 1 do
      ComposeUsageContext(xml, 'useContext', value.useContextList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.jurisdictionList.Count - 1 do
      ComposeCodeableConcept(xml, 'jurisdiction', value.jurisdictionList[i]);
  if (SummaryOption in [soFull, soData]) then
    ComposeMarkdown(xml, 'purpose', value.purposeElement);
  if (SummaryOption in [soFull, soData]) then
    ComposeMarkdown(xml, 'copyright', value.copyrightElement);
  if (SummaryOption in [soFull, soData]) then
    ComposeDate(xml, 'approvalDate', value.approvalDateElement);
  if (SummaryOption in [soFull, soData]) then
    ComposeDate(xml, 'lastReviewDate', value.lastReviewDateElement);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposePeriod(xml, 'effectivePeriod', value.effectivePeriod);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.topicList.Count - 1 do
      ComposeCodeableConcept(xml, 'topic', value.topicList[i]);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.authorList.Count - 1 do
      ComposeContactDetail(xml, 'author', value.authorList[i]);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.editorList.Count - 1 do
      ComposeContactDetail(xml, 'editor', value.editorList[i]);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.reviewerList.Count - 1 do
      ComposeContactDetail(xml, 'reviewer', value.reviewerList[i]);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.endorserList.Count - 1 do
      ComposeContactDetail(xml, 'endorser', value.endorserList[i]);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.relatedArtifactList.Count - 1 do
      ComposeRelatedArtifact(xml, 'relatedArtifact', value.relatedArtifactList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeBoolean(xml, 'caseSensitive', value.caseSensitiveElement);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCanonical(xml, 'valueSet', value.valueSetElement);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeEnum(xml, 'hierarchyMeaning', value.hierarchyMeaningElement, CODES_TFhirCodeSystemHierarchyMeaningEnum);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeBoolean(xml, 'compositional', value.compositionalElement);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeBoolean(xml, 'versionNeeded', value.versionNeededElement);
  ComposeEnum(xml, 'content', value.contentElement, CODES_TFhirCodeSystemContentModeEnum);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCanonical(xml, 'supplements', value.supplementsElement);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeUnsignedInt(xml, 'count', value.countElement);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.filterList.Count - 1 do
      ComposeCodeSystemFilter(xml, 'filter', value.filterList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.property_List.Count - 1 do
      ComposeCodeSystemProperty(xml, 'property', value.property_List[i]);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.conceptList.Count - 1 do
      ComposeCodeSystemConcept(xml, 'concept', value.conceptList[i]);
end;

{$ENDIF FHIR_CODESYSTEM}
{$IFDEF FHIR_COMMUNICATION}
function TFHIRXmlParser.ParseCommunicationPayload(element : TMXmlElement; path : string) : TFhirCommunicationPayload;
var
  child : TMXmlElement;
begin
  result := TFhirCommunicationPayload.Create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseCommunicationPayloadChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseCommunicationPayloadChild(value : TFhirCommunicationPayload; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'contentAttachment') then
        value.content := ParseAttachment(child, path+'/contentAttachment')
      else if (child.localName = 'contentReference') then
        value.content := ParseReference(child, path+'/contentReference')
      else if (child.localName = 'contentCodeableConcept') then
        value.content := ParseCodeableConcept(child, path+'/contentCodeableConcept')
      else if Not ParseBackboneElementChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeCommunicationPayload(xml : TXmlBuilder; name : String; value : TFhirCommunicationPayload);
begin
  if (value = nil) then
    exit;
  composeElementAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeCommunicationPayloadChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeCommunicationPayloadChildren(xml : TXmlBuilder; value : TFhirCommunicationPayload);
begin
  composeBackboneElementChildren(xml, value);
  if (value.content is TFhirAttachment) {6} then
    ComposeAttachment(xml, 'contentAttachment', TFhirAttachment(value.content))
  else if (value.content is TFhirReference) {2} then
    ComposeReference(xml, 'contentReference', TFhirReference(value.content))
  else if (value.content is TFhirCodeableConcept) {6} then
    ComposeCodeableConcept(xml, 'contentCodeableConcept', TFhirCodeableConcept(value.content));
end;

function TFHIRXmlParser.ParseCommunication(element : TMXmlElement; path : string) : TFhirCommunication;
var
  child : TMXmlElement;
begin
  result := TFhirCommunication.Create;
  try
    parseDomainResourceAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseCommunicationChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseCommunicationChild(value : TFhirCommunication; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'identifier') then
        value.identifierList.Add(ParseIdentifier(child, path+'/identifier'))
      else if (child.localName = 'instantiatesCanonical') then
        value.instantiatesCanonicalList.Add(ParseCanonical(child, path+'/instantiatesCanonical'))
      else if (child.localName = 'instantiatesUri') then
        value.instantiatesUriList.Add(ParseUri(child, path+'/instantiatesUri'))
      else if (child.localName = 'basedOn') then
        value.basedOnList.Add(ParseReference(child, path+'/basedOn'))
      else if (child.localName = 'partOf') then
        value.partOfList.Add(ParseReference(child, path+'/partOf'))
      else if (child.localName = 'inResponseTo') then
        value.inResponseToList.Add(ParseReference(child, path+'/inResponseTo'))
      else if (child.localName = 'status') then
        value.statusElement := ParseEnum(CODES_TFhirEventStatusEnum, SYSTEMS_TFhirEventStatusEnum, child, path+'/status')
      else if (child.localName = 'statusReason') then
        value.statusReason := ParseCodeableConcept(child, path+'/statusReason')
      else if (child.localName = 'category') then
        value.categoryList.Add(ParseCodeableConcept(child, path+'/category'))
      else if (child.localName = 'priority') then
        value.priorityElement := ParseEnum(CODES_TFhirRequestPriorityEnum, SYSTEMS_TFhirRequestPriorityEnum, child, path+'/priority')
      else if (child.localName = 'medium') then
        value.mediumList.Add(ParseCodeableConcept(child, path+'/medium'))
      else if (child.localName = 'subject') then
        value.subject := ParseReference(child, path+'/subject')
      else if (child.localName = 'topic') then
        value.topic := ParseCodeableConcept(child, path+'/topic')
      else if (child.localName = 'about') then
        value.aboutList.Add(ParseReference(child, path+'/about'))
      else if (child.localName = 'encounter') then
        value.encounter := ParseReference(child, path+'/encounter')
      else if (child.localName = 'sent') then
        value.sentElement := ParseDateTime(child, path+'/sent')
      else if (child.localName = 'received') then
        value.receivedElement := ParseDateTime(child, path+'/received')
      else if (child.localName = 'recipient') then
        value.recipientList.Add(ParseReference(child, path+'/recipient'))
      else if (child.localName = 'sender') then
        value.sender := ParseReference(child, path+'/sender')
      else if (child.localName = 'reason') then
        value.reasonList.Add(ParseCodeableReference(child, path+'/reason'))
      else if (child.localName = 'payload') then
        value.payloadList.Add(ParseCommunicationPayload(child, path+'/payload'))
      else if (child.localName = 'note') then
        value.noteList.Add(ParseAnnotation(child, path+'/note'))
      else if Not ParseDomainResourceChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeCommunication(xml : TXmlBuilder; name : String; value : TFhirCommunication);
begin
  if (value = nil) then
    exit;
  composeDomainResourceAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeCommunicationChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeCommunicationChildren(xml : TXmlBuilder; value : TFhirCommunication);
var
  i : integer;
begin
  composeDomainResourceChildren(xml, value);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.identifierList.Count - 1 do
      ComposeIdentifier(xml, 'identifier', value.identifierList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.instantiatesCanonicalList.Count - 1 do
      ComposeCanonical(xml, 'instantiatesCanonical', value.instantiatesCanonicalList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.instantiatesUriList.Count - 1 do
      ComposeUri(xml, 'instantiatesUri', value.instantiatesUriList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.basedOnList.Count - 1 do
      ComposeReference(xml, 'basedOn', value.basedOnList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.partOfList.Count - 1 do
      ComposeReference(xml, 'partOf', value.partOfList[i]);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.inResponseToList.Count - 1 do
      ComposeReference(xml, 'inResponseTo', value.inResponseToList[i]);
  ComposeEnum(xml, 'status', value.statusElement, CODES_TFhirEventStatusEnum);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(xml, 'statusReason', value.statusReason);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.categoryList.Count - 1 do
      ComposeCodeableConcept(xml, 'category', value.categoryList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeEnum(xml, 'priority', value.priorityElement, CODES_TFhirRequestPriorityEnum);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.mediumList.Count - 1 do
      ComposeCodeableConcept(xml, 'medium', value.mediumList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference(xml, 'subject', value.subject);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(xml, 'topic', value.topic);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.aboutList.Count - 1 do
      ComposeReference(xml, 'about', value.aboutList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference(xml, 'encounter', value.encounter);
  if (SummaryOption in [soFull, soData]) then
    ComposeDateTime(xml, 'sent', value.sentElement);
  if (SummaryOption in [soFull, soData]) then
    ComposeDateTime(xml, 'received', value.receivedElement);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.recipientList.Count - 1 do
      ComposeReference(xml, 'recipient', value.recipientList[i]);
  if (SummaryOption in [soFull, soData]) then
    ComposeReference(xml, 'sender', value.sender);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.reasonList.Count - 1 do
      ComposeCodeableReference(xml, 'reason', value.reasonList[i]);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.payloadList.Count - 1 do
      ComposeCommunicationPayload(xml, 'payload', value.payloadList[i]);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.noteList.Count - 1 do
      ComposeAnnotation(xml, 'note', value.noteList[i]);
end;

{$ENDIF FHIR_COMMUNICATION}
{$IFDEF FHIR_COMMUNICATIONREQUEST}
function TFHIRXmlParser.ParseCommunicationRequestPayload(element : TMXmlElement; path : string) : TFhirCommunicationRequestPayload;
var
  child : TMXmlElement;
begin
  result := TFhirCommunicationRequestPayload.Create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseCommunicationRequestPayloadChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseCommunicationRequestPayloadChild(value : TFhirCommunicationRequestPayload; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'contentAttachment') then
        value.content := ParseAttachment(child, path+'/contentAttachment')
      else if (child.localName = 'contentReference') then
        value.content := ParseReference(child, path+'/contentReference')
      else if (child.localName = 'contentCodeableConcept') then
        value.content := ParseCodeableConcept(child, path+'/contentCodeableConcept')
      else if Not ParseBackboneElementChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeCommunicationRequestPayload(xml : TXmlBuilder; name : String; value : TFhirCommunicationRequestPayload);
begin
  if (value = nil) then
    exit;
  composeElementAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeCommunicationRequestPayloadChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeCommunicationRequestPayloadChildren(xml : TXmlBuilder; value : TFhirCommunicationRequestPayload);
begin
  composeBackboneElementChildren(xml, value);
  if (value.content is TFhirAttachment) {6} then
    ComposeAttachment(xml, 'contentAttachment', TFhirAttachment(value.content))
  else if (value.content is TFhirReference) {2} then
    ComposeReference(xml, 'contentReference', TFhirReference(value.content))
  else if (value.content is TFhirCodeableConcept) {6} then
    ComposeCodeableConcept(xml, 'contentCodeableConcept', TFhirCodeableConcept(value.content));
end;

function TFHIRXmlParser.ParseCommunicationRequest(element : TMXmlElement; path : string) : TFhirCommunicationRequest;
var
  child : TMXmlElement;
begin
  result := TFhirCommunicationRequest.Create;
  try
    parseDomainResourceAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseCommunicationRequestChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseCommunicationRequestChild(value : TFhirCommunicationRequest; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'identifier') then
        value.identifierList.Add(ParseIdentifier(child, path+'/identifier'))
      else if (child.localName = 'basedOn') then
        value.basedOnList.Add(ParseReference(child, path+'/basedOn'))
      else if (child.localName = 'replaces') then
        value.replacesList.Add(ParseReference(child, path+'/replaces'))
      else if (child.localName = 'groupIdentifier') then
        value.groupIdentifier := ParseIdentifier(child, path+'/groupIdentifier')
      else if (child.localName = 'status') then
        value.statusElement := ParseEnum(CODES_TFhirRequestStatusEnum, SYSTEMS_TFhirRequestStatusEnum, child, path+'/status')
      else if (child.localName = 'statusReason') then
        value.statusReason := ParseCodeableConcept(child, path+'/statusReason')
      else if (child.localName = 'intent') then
        value.intentElement := ParseEnum(CODES_TFhirRequestIntentEnum, SYSTEMS_TFhirRequestIntentEnum, child, path+'/intent')
      else if (child.localName = 'category') then
        value.categoryList.Add(ParseCodeableConcept(child, path+'/category'))
      else if (child.localName = 'priority') then
        value.priorityElement := ParseEnum(CODES_TFhirRequestPriorityEnum, SYSTEMS_TFhirRequestPriorityEnum, child, path+'/priority')
      else if (child.localName = 'doNotPerform') then
        value.doNotPerformElement := ParseBoolean(child, path+'/doNotPerform')
      else if (child.localName = 'medium') then
        value.mediumList.Add(ParseCodeableConcept(child, path+'/medium'))
      else if (child.localName = 'subject') then
        value.subject := ParseReference(child, path+'/subject')
      else if (child.localName = 'about') then
        value.aboutList.Add(ParseReference(child, path+'/about'))
      else if (child.localName = 'encounter') then
        value.encounter := ParseReference(child, path+'/encounter')
      else if (child.localName = 'payload') then
        value.payloadList.Add(ParseCommunicationRequestPayload(child, path+'/payload'))
      else if (child.localName = 'occurrencePeriod') then
        value.occurrence := ParsePeriod(child, path+'/occurrencePeriod')
      else if (child.localName = 'occurrenceDateTime') then
        value.occurrence := ParseDateTime(child, path+'/occurrenceDateTime')
      else if (child.localName = 'authoredOn') then
        value.authoredOnElement := ParseDateTime(child, path+'/authoredOn')
      else if (child.localName = 'requester') then
        value.requester := ParseReference(child, path+'/requester')
      else if (child.localName = 'recipient') then
        value.recipientList.Add(ParseReference(child, path+'/recipient'))
      else if (child.localName = 'informationProvider') then
        value.informationProviderList.Add(ParseReference(child, path+'/informationProvider'))
      else if (child.localName = 'reason') then
        value.reasonList.Add(ParseCodeableReference(child, path+'/reason'))
      else if (child.localName = 'note') then
        value.noteList.Add(ParseAnnotation(child, path+'/note'))
      else if Not ParseDomainResourceChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeCommunicationRequest(xml : TXmlBuilder; name : String; value : TFhirCommunicationRequest);
begin
  if (value = nil) then
    exit;
  composeDomainResourceAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeCommunicationRequestChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeCommunicationRequestChildren(xml : TXmlBuilder; value : TFhirCommunicationRequest);
var
  i : integer;
begin
  composeDomainResourceChildren(xml, value);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.identifierList.Count - 1 do
      ComposeIdentifier(xml, 'identifier', value.identifierList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.basedOnList.Count - 1 do
      ComposeReference(xml, 'basedOn', value.basedOnList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.replacesList.Count - 1 do
      ComposeReference(xml, 'replaces', value.replacesList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeIdentifier(xml, 'groupIdentifier', value.groupIdentifier);
  ComposeEnum(xml, 'status', value.statusElement, CODES_TFhirRequestStatusEnum);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(xml, 'statusReason', value.statusReason);
  ComposeEnum(xml, 'intent', value.intentElement, CODES_TFhirRequestIntentEnum);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.categoryList.Count - 1 do
      ComposeCodeableConcept(xml, 'category', value.categoryList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeEnum(xml, 'priority', value.priorityElement, CODES_TFhirRequestPriorityEnum);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeBoolean(xml, 'doNotPerform', value.doNotPerformElement);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.mediumList.Count - 1 do
      ComposeCodeableConcept(xml, 'medium', value.mediumList[i]);
  if (SummaryOption in [soFull, soData]) then
    ComposeReference(xml, 'subject', value.subject);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.aboutList.Count - 1 do
      ComposeReference(xml, 'about', value.aboutList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference(xml, 'encounter', value.encounter);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.payloadList.Count - 1 do
      ComposeCommunicationRequestPayload(xml, 'payload', value.payloadList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) and (value.occurrence is TFhirPeriod) {6} then
    ComposePeriod(xml, 'occurrencePeriod', TFhirPeriod(value.occurrence))
  else if (SummaryOption in [soFull, soSummary, soData]) and (value.occurrence is TFhirDateTime) {6} then
    ComposeDateTime(xml, 'occurrenceDateTime', TFhirDateTime(value.occurrence));
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDateTime(xml, 'authoredOn', value.authoredOnElement);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference(xml, 'requester', value.requester);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.recipientList.Count - 1 do
      ComposeReference(xml, 'recipient', value.recipientList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.informationProviderList.Count - 1 do
      ComposeReference(xml, 'informationProvider', value.informationProviderList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.reasonList.Count - 1 do
      ComposeCodeableReference(xml, 'reason', value.reasonList[i]);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.noteList.Count - 1 do
      ComposeAnnotation(xml, 'note', value.noteList[i]);
end;

{$ENDIF FHIR_COMMUNICATIONREQUEST}
{$IFDEF FHIR_COMPARTMENTDEFINITION}
function TFHIRXmlParser.ParseCompartmentDefinitionResource(element : TMXmlElement; path : string) : TFhirCompartmentDefinitionResource;
var
  child : TMXmlElement;
begin
  result := TFhirCompartmentDefinitionResource.Create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseCompartmentDefinitionResourceChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseCompartmentDefinitionResourceChild(value : TFhirCompartmentDefinitionResource; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'code') then
        value.codeElement := ParseEnum(CODES_TFhirResourceTypesEnum, SYSTEMS_TFhirResourceTypesEnum, child, path+'/code')
      else if (child.localName = 'param') then
        value.paramList.Add(ParseString(child, path+'/param'))
      else if (child.localName = 'documentation') then
        value.documentationElement := ParseString(child, path+'/documentation')
      else if (child.localName = 'startParam') then
        value.startParamElement := ParseUri(child, path+'/startParam')
      else if (child.localName = 'endParam') then
        value.endParamElement := ParseUri(child, path+'/endParam')
      else if Not ParseBackboneElementChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeCompartmentDefinitionResource(xml : TXmlBuilder; name : String; value : TFhirCompartmentDefinitionResource);
begin
  if (value = nil) then
    exit;
  composeElementAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeCompartmentDefinitionResourceChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeCompartmentDefinitionResourceChildren(xml : TXmlBuilder; value : TFhirCompartmentDefinitionResource);
var
  i : integer;
begin
  composeBackboneElementChildren(xml, value);
  ComposeEnum(xml, 'code', value.codeElement, CODES_TFhirResourceTypesEnum);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.paramList.Count - 1 do
      ComposeString(xml, 'param', value.paramList[i]);
  if (SummaryOption in [soFull, soData]) then
    ComposeString(xml, 'documentation', value.documentationElement);
  if (SummaryOption in [soFull, soData]) then
    ComposeUri(xml, 'startParam', value.startParamElement);
  if (SummaryOption in [soFull, soData]) then
    ComposeUri(xml, 'endParam', value.endParamElement);
end;

function TFHIRXmlParser.ParseCompartmentDefinition(element : TMXmlElement; path : string) : TFhirCompartmentDefinition;
var
  child : TMXmlElement;
begin
  result := TFhirCompartmentDefinition.Create;
  try
    parseCanonicalResourceAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseCompartmentDefinitionChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseCompartmentDefinitionChild(value : TFhirCompartmentDefinition; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'url') then
        value.urlElement := ParseUri(child, path+'/url')
      else if (child.localName = 'version') then
        value.versionElement := ParseString(child, path+'/version')
      else if (child.localName = 'versionAlgorithmCoding') then
        value.versionAlgorithm := ParseCoding(child, path+'/versionAlgorithmCoding')
      else if (child.localName = 'versionAlgorithmString') then
        value.versionAlgorithm := ParseString(child, path+'/versionAlgorithmString')
      else if (child.localName = 'name') then
        value.nameElement := ParseString(child, path+'/name')
      else if (child.localName = 'title') then
        value.titleElement := ParseString(child, path+'/title')
      else if (child.localName = 'status') then
        value.statusElement := ParseEnum(CODES_TFhirPublicationStatusEnum, SYSTEMS_TFhirPublicationStatusEnum, child, path+'/status')
      else if (child.localName = 'experimental') then
        value.experimentalElement := ParseBoolean(child, path+'/experimental')
      else if (child.localName = 'date') then
        value.dateElement := ParseDateTime(child, path+'/date')
      else if (child.localName = 'publisher') then
        value.publisherElement := ParseString(child, path+'/publisher')
      else if (child.localName = 'contact') then
        value.contactList.Add(ParseContactDetail(child, path+'/contact'))
      else if (child.localName = 'description') then
        value.descriptionElement := ParseMarkdown(child, path+'/description')
      else if (child.localName = 'useContext') then
        value.useContextList.Add(ParseUsageContext(child, path+'/useContext'))
      else if (child.localName = 'purpose') then
        value.purposeElement := ParseMarkdown(child, path+'/purpose')
      else if (child.localName = 'code') then
        value.codeElement := ParseEnum(CODES_TFhirCompartmentTypeEnum, SYSTEMS_TFhirCompartmentTypeEnum, child, path+'/code')
      else if (child.localName = 'search') then
        value.searchElement := ParseBoolean(child, path+'/search')
      else if (child.localName = 'resource') then
        value.resourceList.Add(ParseCompartmentDefinitionResource(child, path+'/resource'))
      else if Not ParseCanonicalResourceChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeCompartmentDefinition(xml : TXmlBuilder; name : String; value : TFhirCompartmentDefinition);
begin
  if (value = nil) then
    exit;
  composeCanonicalResourceAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeCompartmentDefinitionChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeCompartmentDefinitionChildren(xml : TXmlBuilder; value : TFhirCompartmentDefinition);
var
  i : integer;
begin
  composeCanonicalResourceChildren(xml, value);
  ComposeUri(xml, 'url', value.urlElement);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(xml, 'version', value.versionElement);
  if (SummaryOption in [soFull, soSummary, soData]) and (value.versionAlgorithm is TFhirCoding) {6} then
    ComposeCoding(xml, 'versionAlgorithmCoding', TFhirCoding(value.versionAlgorithm))
  else if (SummaryOption in [soFull, soSummary, soData]) and (value.versionAlgorithm is TFhirString) {6} then
    ComposeString(xml, 'versionAlgorithmString', TFhirString(value.versionAlgorithm));
  ComposeString(xml, 'name', value.nameElement);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(xml, 'title', value.titleElement);
  ComposeEnum(xml, 'status', value.statusElement, CODES_TFhirPublicationStatusEnum);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeBoolean(xml, 'experimental', value.experimentalElement);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDateTime(xml, 'date', value.dateElement);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(xml, 'publisher', value.publisherElement);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.contactList.Count - 1 do
      ComposeContactDetail(xml, 'contact', value.contactList[i]);
  if (SummaryOption in [soFull, soData]) then
    ComposeMarkdown(xml, 'description', value.descriptionElement);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.useContextList.Count - 1 do
      ComposeUsageContext(xml, 'useContext', value.useContextList[i]);
  if (SummaryOption in [soFull, soData]) then
    ComposeMarkdown(xml, 'purpose', value.purposeElement);
  ComposeEnum(xml, 'code', value.codeElement, CODES_TFhirCompartmentTypeEnum);
  ComposeBoolean(xml, 'search', value.searchElement);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.resourceList.Count - 1 do
      ComposeCompartmentDefinitionResource(xml, 'resource', value.resourceList[i]);
end;

{$ENDIF FHIR_COMPARTMENTDEFINITION}
{$IFDEF FHIR_COMPOSITION}
function TFHIRXmlParser.ParseCompositionAttester(element : TMXmlElement; path : string) : TFhirCompositionAttester;
var
  child : TMXmlElement;
begin
  result := TFhirCompositionAttester.Create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseCompositionAttesterChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseCompositionAttesterChild(value : TFhirCompositionAttester; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'mode') then
        value.mode := ParseCodeableConcept(child, path+'/mode')
      else if (child.localName = 'time') then
        value.timeElement := ParseDateTime(child, path+'/time')
      else if (child.localName = 'party') then
        value.party := ParseReference(child, path+'/party')
      else if Not ParseBackboneElementChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeCompositionAttester(xml : TXmlBuilder; name : String; value : TFhirCompositionAttester);
begin
  if (value = nil) then
    exit;
  composeElementAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeCompositionAttesterChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeCompositionAttesterChildren(xml : TXmlBuilder; value : TFhirCompositionAttester);
begin
  composeBackboneElementChildren(xml, value);
  ComposeCodeableConcept(xml, 'mode', value.mode);
  if (SummaryOption in [soFull, soData]) then
    ComposeDateTime(xml, 'time', value.timeElement);
  if (SummaryOption in [soFull, soData]) then
    ComposeReference(xml, 'party', value.party);
end;

function TFHIRXmlParser.ParseCompositionEvent(element : TMXmlElement; path : string) : TFhirCompositionEvent;
var
  child : TMXmlElement;
begin
  result := TFhirCompositionEvent.Create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseCompositionEventChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseCompositionEventChild(value : TFhirCompositionEvent; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'code') then
        value.codeList.Add(ParseCodeableConcept(child, path+'/code'))
      else if (child.localName = 'period') then
        value.period := ParsePeriod(child, path+'/period')
      else if (child.localName = 'detail') then
        value.detailList.Add(ParseReference(child, path+'/detail'))
      else if Not ParseBackboneElementChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeCompositionEvent(xml : TXmlBuilder; name : String; value : TFhirCompositionEvent);
begin
  if (value = nil) then
    exit;
  composeElementAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeCompositionEventChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeCompositionEventChildren(xml : TXmlBuilder; value : TFhirCompositionEvent);
var
  i : integer;
begin
  composeBackboneElementChildren(xml, value);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.codeList.Count - 1 do
      ComposeCodeableConcept(xml, 'code', value.codeList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposePeriod(xml, 'period', value.period);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.detailList.Count - 1 do
      ComposeReference(xml, 'detail', value.detailList[i]);
end;

function TFHIRXmlParser.ParseCompositionSection(element : TMXmlElement; path : string) : TFhirCompositionSection;
var
  child : TMXmlElement;
begin
  result := TFhirCompositionSection.Create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseCompositionSectionChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseCompositionSectionChild(value : TFhirCompositionSection; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'title') then
        value.titleElement := ParseString(child, path+'/title')
      else if (child.localName = 'code') then
        value.code := ParseCodeableConcept(child, path+'/code')
      else if (child.localName = 'author') then
        value.authorList.Add(ParseReference(child, path+'/author'))
      else if (child.localName = 'focus') then
        value.focus := ParseReference(child, path+'/focus')
      else if (child.localName = 'text') then
        value.text := ParseNarrative(child, path+'/text')
      else if (child.localName = 'mode') then
        value.modeElement := ParseEnum(CODES_TFhirListModeEnum, SYSTEMS_TFhirListModeEnum, child, path+'/mode')
      else if (child.localName = 'orderedBy') then
        value.orderedBy := ParseCodeableConcept(child, path+'/orderedBy')
      else if (child.localName = 'entry') then
        value.entryList.Add(ParseReference(child, path+'/entry'))
      else if (child.localName = 'emptyReason') then
        value.emptyReason := ParseCodeableConcept(child, path+'/emptyReason')
      else if (child.localName = 'section') then
        value.sectionList.Add(ParseCompositionSection(child, path+'/section'))
      else if Not ParseBackboneElementChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeCompositionSection(xml : TXmlBuilder; name : String; value : TFhirCompositionSection);
begin
  if (value = nil) then
    exit;
  composeElementAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeCompositionSectionChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeCompositionSectionChildren(xml : TXmlBuilder; value : TFhirCompositionSection);
var
  i : integer;
begin
  composeBackboneElementChildren(xml, value);
  if (SummaryOption in [soFull, soData]) then
    ComposeString(xml, 'title', value.titleElement);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(xml, 'code', value.code);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.authorList.Count - 1 do
      ComposeReference(xml, 'author', value.authorList[i]);
  if (SummaryOption in [soFull, soData]) then
    ComposeReference(xml, 'focus', value.focus);
  if (SummaryOption in [soFull, soData]) then
    ComposeNarrative(xml, 'text', value.text);
  if (SummaryOption in [soFull, soData]) then
    ComposeEnum(xml, 'mode', value.modeElement, CODES_TFhirListModeEnum);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(xml, 'orderedBy', value.orderedBy);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.entryList.Count - 1 do
      ComposeReference(xml, 'entry', value.entryList[i]);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(xml, 'emptyReason', value.emptyReason);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.sectionList.Count - 1 do
      ComposeCompositionSection(xml, 'section', value.sectionList[i]);
end;

function TFHIRXmlParser.ParseComposition(element : TMXmlElement; path : string) : TFhirComposition;
var
  child : TMXmlElement;
begin
  result := TFhirComposition.Create;
  try
    parseDomainResourceAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseCompositionChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseCompositionChild(value : TFhirComposition; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'url') then
        value.urlElement := ParseUri(child, path+'/url')
      else if (child.localName = 'identifier') then
        value.identifierList.Add(ParseIdentifier(child, path+'/identifier'))
      else if (child.localName = 'version') then
        value.versionElement := ParseString(child, path+'/version')
      else if (child.localName = 'status') then
        value.statusElement := ParseEnum(CODES_TFhirCompositionStatusEnum, SYSTEMS_TFhirCompositionStatusEnum, child, path+'/status')
      else if (child.localName = 'type') then
        value.type_ := ParseCodeableConcept(child, path+'/type')
      else if (child.localName = 'category') then
        value.categoryList.Add(ParseCodeableConcept(child, path+'/category'))
      else if (child.localName = 'subject') then
        value.subjectList.Add(ParseReference(child, path+'/subject'))
      else if (child.localName = 'encounter') then
        value.encounter := ParseReference(child, path+'/encounter')
      else if (child.localName = 'date') then
        value.dateElement := ParseDateTime(child, path+'/date')
      else if (child.localName = 'useContext') then
        value.useContextList.Add(ParseUsageContext(child, path+'/useContext'))
      else if (child.localName = 'author') then
        value.authorList.Add(ParseReference(child, path+'/author'))
      else if (child.localName = 'name') then
        value.nameElement := ParseString(child, path+'/name')
      else if (child.localName = 'title') then
        value.titleElement := ParseString(child, path+'/title')
      else if (child.localName = 'note') then
        value.noteList.Add(ParseAnnotation(child, path+'/note'))
      else if (child.localName = 'attester') then
        value.attesterList.Add(ParseCompositionAttester(child, path+'/attester'))
      else if (child.localName = 'custodian') then
        value.custodian := ParseReference(child, path+'/custodian')
      else if (child.localName = 'relatesTo') then
        value.relatesToList.Add(ParseRelatedArtifact(child, path+'/relatesTo'))
      else if (child.localName = 'event') then
        value.eventList.Add(ParseCompositionEvent(child, path+'/event'))
      else if (child.localName = 'section') then
        value.sectionList.Add(ParseCompositionSection(child, path+'/section'))
      else if Not ParseDomainResourceChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeComposition(xml : TXmlBuilder; name : String; value : TFhirComposition);
begin
  if (value = nil) then
    exit;
  composeDomainResourceAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeCompositionChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeCompositionChildren(xml : TXmlBuilder; value : TFhirComposition);
var
  i : integer;
begin
  composeDomainResourceChildren(xml, value);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeUri(xml, 'url', value.urlElement);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.identifierList.Count - 1 do
      ComposeIdentifier(xml, 'identifier', value.identifierList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(xml, 'version', value.versionElement);
  ComposeEnum(xml, 'status', value.statusElement, CODES_TFhirCompositionStatusEnum);
  ComposeCodeableConcept(xml, 'type', value.type_);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.categoryList.Count - 1 do
      ComposeCodeableConcept(xml, 'category', value.categoryList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.subjectList.Count - 1 do
      ComposeReference(xml, 'subject', value.subjectList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference(xml, 'encounter', value.encounter);
  ComposeDateTime(xml, 'date', value.dateElement);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.useContextList.Count - 1 do
      ComposeUsageContext(xml, 'useContext', value.useContextList[i]);
  for i := 0 to value.authorList.Count - 1 do
      ComposeReference(xml, 'author', value.authorList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(xml, 'name', value.nameElement);
  ComposeString(xml, 'title', value.titleElement);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.noteList.Count - 1 do
      ComposeAnnotation(xml, 'note', value.noteList[i]);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.attesterList.Count - 1 do
      ComposeCompositionAttester(xml, 'attester', value.attesterList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference(xml, 'custodian', value.custodian);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.relatesToList.Count - 1 do
      ComposeRelatedArtifact(xml, 'relatesTo', value.relatesToList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.eventList.Count - 1 do
      ComposeCompositionEvent(xml, 'event', value.eventList[i]);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.sectionList.Count - 1 do
      ComposeCompositionSection(xml, 'section', value.sectionList[i]);
end;

{$ENDIF FHIR_COMPOSITION}
{$IFDEF FHIR_CONCEPTMAP}
function TFHIRXmlParser.ParseConceptMapGroup(element : TMXmlElement; path : string) : TFhirConceptMapGroup;
var
  child : TMXmlElement;
begin
  result := TFhirConceptMapGroup.Create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseConceptMapGroupChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseConceptMapGroupChild(value : TFhirConceptMapGroup; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'source') then
        value.sourceElement := ParseCanonical(child, path+'/source')
      else if (child.localName = 'target') then
        value.targetElement := ParseCanonical(child, path+'/target')
      else if (child.localName = 'element') then
        value.elementList.Add(ParseConceptMapGroupElement(child, path+'/element'))
      else if (child.localName = 'unmapped') then
        value.unmapped := ParseConceptMapGroupUnmapped(child, path+'/unmapped')
      else if Not ParseBackboneElementChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeConceptMapGroup(xml : TXmlBuilder; name : String; value : TFhirConceptMapGroup);
begin
  if (value = nil) then
    exit;
  composeElementAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeConceptMapGroupChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeConceptMapGroupChildren(xml : TXmlBuilder; value : TFhirConceptMapGroup);
var
  i : integer;
begin
  composeBackboneElementChildren(xml, value);
  if (SummaryOption in [soFull, soData]) then
    ComposeCanonical(xml, 'source', value.sourceElement);
  if (SummaryOption in [soFull, soData]) then
    ComposeCanonical(xml, 'target', value.targetElement);
  for i := 0 to value.elementList.Count - 1 do
      ComposeConceptMapGroupElement(xml, 'element', value.elementList[i]);
  if (SummaryOption in [soFull, soData]) then
    ComposeConceptMapGroupUnmapped(xml, 'unmapped', value.unmapped);
end;

function TFHIRXmlParser.ParseConceptMapGroupElement(element : TMXmlElement; path : string) : TFhirConceptMapGroupElement;
var
  child : TMXmlElement;
begin
  result := TFhirConceptMapGroupElement.Create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseConceptMapGroupElementChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseConceptMapGroupElementChild(value : TFhirConceptMapGroupElement; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'code') then
        value.codeElement := ParseCode(child, path+'/code')
      else if (child.localName = 'display') then
        value.displayElement := ParseString(child, path+'/display')
      else if (child.localName = 'valueSet') then
        value.valueSetElement := ParseCanonical(child, path+'/valueSet')
      else if (child.localName = 'noMap') then
        value.noMapElement := ParseBoolean(child, path+'/noMap')
      else if (child.localName = 'target') then
        value.targetList.Add(ParseConceptMapGroupElementTarget(child, path+'/target'))
      else if Not ParseBackboneElementChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeConceptMapGroupElement(xml : TXmlBuilder; name : String; value : TFhirConceptMapGroupElement);
begin
  if (value = nil) then
    exit;
  composeElementAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeConceptMapGroupElementChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeConceptMapGroupElementChildren(xml : TXmlBuilder; value : TFhirConceptMapGroupElement);
var
  i : integer;
begin
  composeBackboneElementChildren(xml, value);
  if (SummaryOption in [soFull, soData]) then
    ComposeCode(xml, 'code', value.codeElement);
  if (SummaryOption in [soFull, soData]) then
    ComposeString(xml, 'display', value.displayElement);
  if (SummaryOption in [soFull, soData]) then
    ComposeCanonical(xml, 'valueSet', value.valueSetElement);
  if (SummaryOption in [soFull, soData]) then
    ComposeBoolean(xml, 'noMap', value.noMapElement);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.targetList.Count - 1 do
      ComposeConceptMapGroupElementTarget(xml, 'target', value.targetList[i]);
end;

function TFHIRXmlParser.ParseConceptMapGroupElementTarget(element : TMXmlElement; path : string) : TFhirConceptMapGroupElementTarget;
var
  child : TMXmlElement;
begin
  result := TFhirConceptMapGroupElementTarget.Create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseConceptMapGroupElementTargetChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseConceptMapGroupElementTargetChild(value : TFhirConceptMapGroupElementTarget; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'code') then
        value.codeElement := ParseCode(child, path+'/code')
      else if (child.localName = 'display') then
        value.displayElement := ParseString(child, path+'/display')
      else if (child.localName = 'valueSet') then
        value.valueSetElement := ParseCanonical(child, path+'/valueSet')
      else if (child.localName = 'relationship') then
        value.relationshipElement := ParseEnum(CODES_TFhirConceptMapRelationshipEnum, SYSTEMS_TFhirConceptMapRelationshipEnum, child, path+'/relationship')
      else if (child.localName = 'comment') then
        value.commentElement := ParseString(child, path+'/comment')
      else if (child.localName = 'dependsOn') then
        value.dependsOnList.Add(ParseConceptMapGroupElementTargetDependsOn(child, path+'/dependsOn'))
      else if (child.localName = 'product') then
        value.productList.Add(ParseConceptMapGroupElementTargetDependsOn(child, path+'/product'))
      else if Not ParseBackboneElementChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeConceptMapGroupElementTarget(xml : TXmlBuilder; name : String; value : TFhirConceptMapGroupElementTarget);
begin
  if (value = nil) then
    exit;
  composeElementAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeConceptMapGroupElementTargetChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeConceptMapGroupElementTargetChildren(xml : TXmlBuilder; value : TFhirConceptMapGroupElementTarget);
var
  i : integer;
begin
  composeBackboneElementChildren(xml, value);
  if (SummaryOption in [soFull, soData]) then
    ComposeCode(xml, 'code', value.codeElement);
  if (SummaryOption in [soFull, soData]) then
    ComposeString(xml, 'display', value.displayElement);
  if (SummaryOption in [soFull, soData]) then
    ComposeCanonical(xml, 'valueSet', value.valueSetElement);
  ComposeEnum(xml, 'relationship', value.relationshipElement, CODES_TFhirConceptMapRelationshipEnum);
  if (SummaryOption in [soFull, soData]) then
    ComposeString(xml, 'comment', value.commentElement);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.dependsOnList.Count - 1 do
      ComposeConceptMapGroupElementTargetDependsOn(xml, 'dependsOn', value.dependsOnList[i]);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.productList.Count - 1 do
      ComposeConceptMapGroupElementTargetDependsOn(xml, 'product', value.productList[i]);
end;

function TFHIRXmlParser.ParseConceptMapGroupElementTargetDependsOn(element : TMXmlElement; path : string) : TFhirConceptMapGroupElementTargetDependsOn;
var
  child : TMXmlElement;
begin
  result := TFhirConceptMapGroupElementTargetDependsOn.Create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseConceptMapGroupElementTargetDependsOnChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseConceptMapGroupElementTargetDependsOnChild(value : TFhirConceptMapGroupElementTargetDependsOn; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'property') then
        value.property_Element := ParseUri(child, path+'/property')
      else if (child.localName = 'valueCode') then
        value.value := ParseCode(child, path+'/valueCode')
      else if (child.localName = 'valueCoding') then
        value.value := ParseCoding(child, path+'/valueCoding')
      else if (child.localName = 'valueId') then
        value.value := ParseId(child, path+'/valueId')
      else if (child.localName = 'valueString') then
        value.value := ParseString(child, path+'/valueString')
      else if (child.localName = 'valueInteger') then
        value.value := ParseInteger(child, path+'/valueInteger')
      else if (child.localName = 'valueBoolean') then
        value.value := ParseBoolean(child, path+'/valueBoolean')
      else if (child.localName = 'valueDateTime') then
        value.value := ParseDateTime(child, path+'/valueDateTime')
      else if (child.localName = 'valueDecimal') then
        value.value := ParseDecimal(child, path+'/valueDecimal')
      else if (child.localName = 'valueUri') then
        value.value := ParseUri(child, path+'/valueUri')
      else if (child.localName = 'valueSet') then
        value.valueSetElement := ParseCanonical(child, path+'/valueSet')
      else if Not ParseBackboneElementChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeConceptMapGroupElementTargetDependsOn(xml : TXmlBuilder; name : String; value : TFhirConceptMapGroupElementTargetDependsOn);
begin
  if (value = nil) then
    exit;
  composeElementAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeConceptMapGroupElementTargetDependsOnChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeConceptMapGroupElementTargetDependsOnChildren(xml : TXmlBuilder; value : TFhirConceptMapGroupElementTargetDependsOn);
begin
  composeBackboneElementChildren(xml, value);
  ComposeUri(xml, 'property', value.property_Element);
  if (SummaryOption in [soFull, soData]) and (value.value is TFhirCode) {6} then
    ComposeCode(xml, 'valueCode', TFhirCode(value.value))
  else if (SummaryOption in [soFull, soData]) and (value.value is TFhirCoding) {6} then
    ComposeCoding(xml, 'valueCoding', TFhirCoding(value.value))
  else if (SummaryOption in [soFull, soData]) and (value.value is TFhirId) {6} then
    ComposeId(xml, 'valueId', TFhirId(value.value))
  else if (SummaryOption in [soFull, soData]) and (value.value is TFhirString) {6} then
    ComposeString(xml, 'valueString', TFhirString(value.value))
  else if (SummaryOption in [soFull, soData]) and (value.value is TFhirInteger) {6} then
    ComposeInteger(xml, 'valueInteger', TFhirInteger(value.value))
  else if (SummaryOption in [soFull, soData]) and (value.value is TFhirBoolean) {6} then
    ComposeBoolean(xml, 'valueBoolean', TFhirBoolean(value.value))
  else if (SummaryOption in [soFull, soData]) and (value.value is TFhirDateTime) {6} then
    ComposeDateTime(xml, 'valueDateTime', TFhirDateTime(value.value))
  else if (SummaryOption in [soFull, soData]) and (value.value is TFhirDecimal) {6} then
    ComposeDecimal(xml, 'valueDecimal', TFhirDecimal(value.value))
  else if (SummaryOption in [soFull, soData]) and (value.value is TFhirUri) {6} then
    ComposeUri(xml, 'valueUri', TFhirUri(value.value));
  if (SummaryOption in [soFull, soData]) then
    ComposeCanonical(xml, 'valueSet', value.valueSetElement);
end;

function TFHIRXmlParser.ParseConceptMapGroupUnmapped(element : TMXmlElement; path : string) : TFhirConceptMapGroupUnmapped;
var
  child : TMXmlElement;
begin
  result := TFhirConceptMapGroupUnmapped.Create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseConceptMapGroupUnmappedChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseConceptMapGroupUnmappedChild(value : TFhirConceptMapGroupUnmapped; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'mode') then
        value.modeElement := ParseEnum(CODES_TFhirConceptMapGroupUnmappedModeEnum, SYSTEMS_TFhirConceptMapGroupUnmappedModeEnum, child, path+'/mode')
      else if (child.localName = 'code') then
        value.codeElement := ParseCode(child, path+'/code')
      else if (child.localName = 'display') then
        value.displayElement := ParseString(child, path+'/display')
      else if (child.localName = 'valueSet') then
        value.valueSetElement := ParseCanonical(child, path+'/valueSet')
      else if (child.localName = 'relationship') then
        value.relationshipElement := ParseEnum(CODES_TFhirConceptMapRelationshipEnum, SYSTEMS_TFhirConceptMapRelationshipEnum, child, path+'/relationship')
      else if (child.localName = 'otherMap') then
        value.otherMapElement := ParseCanonical(child, path+'/otherMap')
      else if Not ParseBackboneElementChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeConceptMapGroupUnmapped(xml : TXmlBuilder; name : String; value : TFhirConceptMapGroupUnmapped);
begin
  if (value = nil) then
    exit;
  composeElementAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeConceptMapGroupUnmappedChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeConceptMapGroupUnmappedChildren(xml : TXmlBuilder; value : TFhirConceptMapGroupUnmapped);
begin
  composeBackboneElementChildren(xml, value);
  ComposeEnum(xml, 'mode', value.modeElement, CODES_TFhirConceptMapGroupUnmappedModeEnum);
  if (SummaryOption in [soFull, soData]) then
    ComposeCode(xml, 'code', value.codeElement);
  if (SummaryOption in [soFull, soData]) then
    ComposeString(xml, 'display', value.displayElement);
  if (SummaryOption in [soFull, soData]) then
    ComposeCanonical(xml, 'valueSet', value.valueSetElement);
  if (SummaryOption in [soFull, soData]) then
    ComposeEnum(xml, 'relationship', value.relationshipElement, CODES_TFhirConceptMapRelationshipEnum);
  if (SummaryOption in [soFull, soData]) then
    ComposeCanonical(xml, 'otherMap', value.otherMapElement);
end;

function TFHIRXmlParser.ParseConceptMap(element : TMXmlElement; path : string) : TFhirConceptMap;
var
  child : TMXmlElement;
begin
  result := TFhirConceptMap.Create;
  try
    parseMetadataResourceAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseConceptMapChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseConceptMapChild(value : TFhirConceptMap; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'url') then
        value.urlElement := ParseUri(child, path+'/url')
      else if (child.localName = 'identifier') then
        value.identifierList.Add(ParseIdentifier(child, path+'/identifier'))
      else if (child.localName = 'version') then
        value.versionElement := ParseString(child, path+'/version')
      else if (child.localName = 'name') then
        value.nameElement := ParseString(child, path+'/name')
      else if (child.localName = 'title') then
        value.titleElement := ParseString(child, path+'/title')
      else if (child.localName = 'status') then
        value.statusElement := ParseEnum(CODES_TFhirPublicationStatusEnum, SYSTEMS_TFhirPublicationStatusEnum, child, path+'/status')
      else if (child.localName = 'experimental') then
        value.experimentalElement := ParseBoolean(child, path+'/experimental')
      else if (child.localName = 'date') then
        value.dateElement := ParseDateTime(child, path+'/date')
      else if (child.localName = 'publisher') then
        value.publisherElement := ParseString(child, path+'/publisher')
      else if (child.localName = 'contact') then
        value.contactList.Add(ParseContactDetail(child, path+'/contact'))
      else if (child.localName = 'description') then
        value.descriptionElement := ParseMarkdown(child, path+'/description')
      else if (child.localName = 'useContext') then
        value.useContextList.Add(ParseUsageContext(child, path+'/useContext'))
      else if (child.localName = 'jurisdiction') then
        value.jurisdictionList.Add(ParseCodeableConcept(child, path+'/jurisdiction'))
      else if (child.localName = 'purpose') then
        value.purposeElement := ParseMarkdown(child, path+'/purpose')
      else if (child.localName = 'copyright') then
        value.copyrightElement := ParseMarkdown(child, path+'/copyright')
      else if (child.localName = 'approvalDate') then
        value.approvalDateElement := ParseDate(child, path+'/approvalDate')
      else if (child.localName = 'lastReviewDate') then
        value.lastReviewDateElement := ParseDate(child, path+'/lastReviewDate')
      else if (child.localName = 'effectivePeriod') then
        value.effectivePeriod := ParsePeriod(child, path+'/effectivePeriod')
      else if (child.localName = 'topic') then
        value.topicList.Add(ParseCodeableConcept(child, path+'/topic'))
      else if (child.localName = 'author') then
        value.authorList.Add(ParseContactDetail(child, path+'/author'))
      else if (child.localName = 'editor') then
        value.editorList.Add(ParseContactDetail(child, path+'/editor'))
      else if (child.localName = 'reviewer') then
        value.reviewerList.Add(ParseContactDetail(child, path+'/reviewer'))
      else if (child.localName = 'endorser') then
        value.endorserList.Add(ParseContactDetail(child, path+'/endorser'))
      else if (child.localName = 'relatedArtifact') then
        value.relatedArtifactList.Add(ParseRelatedArtifact(child, path+'/relatedArtifact'))
      else if (child.localName = 'sourceScopeCanonical') then
        value.sourceScope := ParseCanonical(child, path+'/sourceScopeCanonical')
      else if (child.localName = 'sourceScopeUri') then
        value.sourceScope := ParseUri(child, path+'/sourceScopeUri')
      else if (child.localName = 'targetScopeCanonical') then
        value.targetScope := ParseCanonical(child, path+'/targetScopeCanonical')
      else if (child.localName = 'targetScopeUri') then
        value.targetScope := ParseUri(child, path+'/targetScopeUri')
      else if (child.localName = 'group') then
        value.groupList.Add(ParseConceptMapGroup(child, path+'/group'))
      else if Not ParseMetadataResourceChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeConceptMap(xml : TXmlBuilder; name : String; value : TFhirConceptMap);
begin
  if (value = nil) then
    exit;
  composeMetadataResourceAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeConceptMapChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeConceptMapChildren(xml : TXmlBuilder; value : TFhirConceptMap);
var
  i : integer;
begin
  composeMetadataResourceChildren(xml, value);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeUri(xml, 'url', value.urlElement);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.identifierList.Count - 1 do
      ComposeIdentifier(xml, 'identifier', value.identifierList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(xml, 'version', value.versionElement);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(xml, 'name', value.nameElement);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(xml, 'title', value.titleElement);
  ComposeEnum(xml, 'status', value.statusElement, CODES_TFhirPublicationStatusEnum);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeBoolean(xml, 'experimental', value.experimentalElement);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDateTime(xml, 'date', value.dateElement);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(xml, 'publisher', value.publisherElement);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.contactList.Count - 1 do
      ComposeContactDetail(xml, 'contact', value.contactList[i]);
  if (SummaryOption in [soFull, soData]) then
    ComposeMarkdown(xml, 'description', value.descriptionElement);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.useContextList.Count - 1 do
      ComposeUsageContext(xml, 'useContext', value.useContextList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.jurisdictionList.Count - 1 do
      ComposeCodeableConcept(xml, 'jurisdiction', value.jurisdictionList[i]);
  if (SummaryOption in [soFull, soData]) then
    ComposeMarkdown(xml, 'purpose', value.purposeElement);
  if (SummaryOption in [soFull, soData]) then
    ComposeMarkdown(xml, 'copyright', value.copyrightElement);
  if (SummaryOption in [soFull, soData]) then
    ComposeDate(xml, 'approvalDate', value.approvalDateElement);
  if (SummaryOption in [soFull, soData]) then
    ComposeDate(xml, 'lastReviewDate', value.lastReviewDateElement);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposePeriod(xml, 'effectivePeriod', value.effectivePeriod);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.topicList.Count - 1 do
      ComposeCodeableConcept(xml, 'topic', value.topicList[i]);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.authorList.Count - 1 do
      ComposeContactDetail(xml, 'author', value.authorList[i]);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.editorList.Count - 1 do
      ComposeContactDetail(xml, 'editor', value.editorList[i]);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.reviewerList.Count - 1 do
      ComposeContactDetail(xml, 'reviewer', value.reviewerList[i]);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.endorserList.Count - 1 do
      ComposeContactDetail(xml, 'endorser', value.endorserList[i]);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.relatedArtifactList.Count - 1 do
      ComposeRelatedArtifact(xml, 'relatedArtifact', value.relatedArtifactList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) and (value.sourceScope is TFhirCanonical) {6} then
    ComposeCanonical(xml, 'sourceScopeCanonical', TFhirCanonical(value.sourceScope))
  else if (SummaryOption in [soFull, soSummary, soData]) and (value.sourceScope is TFhirUri) {6} then
    ComposeUri(xml, 'sourceScopeUri', TFhirUri(value.sourceScope));
  if (SummaryOption in [soFull, soSummary, soData]) and (value.targetScope is TFhirCanonical) {6} then
    ComposeCanonical(xml, 'targetScopeCanonical', TFhirCanonical(value.targetScope))
  else if (SummaryOption in [soFull, soSummary, soData]) and (value.targetScope is TFhirUri) {6} then
    ComposeUri(xml, 'targetScopeUri', TFhirUri(value.targetScope));
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.groupList.Count - 1 do
      ComposeConceptMapGroup(xml, 'group', value.groupList[i]);
end;

{$ENDIF FHIR_CONCEPTMAP}
{$IFDEF FHIR_CONDITION}
function TFHIRXmlParser.ParseConditionParticipant(element : TMXmlElement; path : string) : TFhirConditionParticipant;
var
  child : TMXmlElement;
begin
  result := TFhirConditionParticipant.Create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseConditionParticipantChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseConditionParticipantChild(value : TFhirConditionParticipant; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'function') then
        value.function_ := ParseCodeableConcept(child, path+'/function')
      else if (child.localName = 'actor') then
        value.actor := ParseReference(child, path+'/actor')
      else if Not ParseBackboneElementChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeConditionParticipant(xml : TXmlBuilder; name : String; value : TFhirConditionParticipant);
begin
  if (value = nil) then
    exit;
  composeElementAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeConditionParticipantChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeConditionParticipantChildren(xml : TXmlBuilder; value : TFhirConditionParticipant);
begin
  composeBackboneElementChildren(xml, value);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(xml, 'function', value.function_);
  ComposeReference(xml, 'actor', value.actor);
end;

function TFHIRXmlParser.ParseConditionStage(element : TMXmlElement; path : string) : TFhirConditionStage;
var
  child : TMXmlElement;
begin
  result := TFhirConditionStage.Create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseConditionStageChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseConditionStageChild(value : TFhirConditionStage; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'summary') then
        value.summary := ParseCodeableConcept(child, path+'/summary')
      else if (child.localName = 'assessment') then
        value.assessmentList.Add(ParseReference(child, path+'/assessment'))
      else if (child.localName = 'type') then
        value.type_ := ParseCodeableConcept(child, path+'/type')
      else if Not ParseBackboneElementChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeConditionStage(xml : TXmlBuilder; name : String; value : TFhirConditionStage);
begin
  if (value = nil) then
    exit;
  composeElementAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeConditionStageChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeConditionStageChildren(xml : TXmlBuilder; value : TFhirConditionStage);
var
  i : integer;
begin
  composeBackboneElementChildren(xml, value);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(xml, 'summary', value.summary);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.assessmentList.Count - 1 do
      ComposeReference(xml, 'assessment', value.assessmentList[i]);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(xml, 'type', value.type_);
end;

function TFHIRXmlParser.ParseCondition(element : TMXmlElement; path : string) : TFhirCondition;
var
  child : TMXmlElement;
begin
  result := TFhirCondition.Create;
  try
    parseDomainResourceAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseConditionChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseConditionChild(value : TFhirCondition; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'identifier') then
        value.identifierList.Add(ParseIdentifier(child, path+'/identifier'))
      else if (child.localName = 'clinicalStatus') then
        value.clinicalStatus := ParseCodeableConcept(child, path+'/clinicalStatus')
      else if (child.localName = 'verificationStatus') then
        value.verificationStatus := ParseCodeableConcept(child, path+'/verificationStatus')
      else if (child.localName = 'category') then
        value.categoryList.Add(ParseCodeableConcept(child, path+'/category'))
      else if (child.localName = 'severity') then
        value.severity := ParseCodeableConcept(child, path+'/severity')
      else if (child.localName = 'code') then
        value.code := ParseCodeableConcept(child, path+'/code')
      else if (child.localName = 'bodySite') then
        value.bodySiteList.Add(ParseCodeableConcept(child, path+'/bodySite'))
      else if (child.localName = 'subject') then
        value.subject := ParseReference(child, path+'/subject')
      else if (child.localName = 'encounter') then
        value.encounter := ParseReference(child, path+'/encounter')
      else if (child.localName = 'onsetAge') then
        value.onset := ParseAge(child, path+'/onsetAge')
      else if (child.localName = 'onsetPeriod') then
        value.onset := ParsePeriod(child, path+'/onsetPeriod')
      else if (child.localName = 'onsetRange') then
        value.onset := ParseRange(child, path+'/onsetRange')
      else if (child.localName = 'onsetDateTime') then
        value.onset := ParseDateTime(child, path+'/onsetDateTime')
      else if (child.localName = 'onsetString') then
        value.onset := ParseString(child, path+'/onsetString')
      else if (child.localName = 'abatementAge') then
        value.abatement := ParseAge(child, path+'/abatementAge')
      else if (child.localName = 'abatementPeriod') then
        value.abatement := ParsePeriod(child, path+'/abatementPeriod')
      else if (child.localName = 'abatementRange') then
        value.abatement := ParseRange(child, path+'/abatementRange')
      else if (child.localName = 'abatementDateTime') then
        value.abatement := ParseDateTime(child, path+'/abatementDateTime')
      else if (child.localName = 'abatementString') then
        value.abatement := ParseString(child, path+'/abatementString')
      else if (child.localName = 'recordedDate') then
        value.recordedDateElement := ParseDateTime(child, path+'/recordedDate')
      else if (child.localName = 'participant') then
        value.participantList.Add(ParseConditionParticipant(child, path+'/participant'))
      else if (child.localName = 'stage') then
        value.stageList.Add(ParseConditionStage(child, path+'/stage'))
      else if (child.localName = 'evidence') then
        value.evidenceList.Add(ParseCodeableReference(child, path+'/evidence'))
      else if (child.localName = 'note') then
        value.noteList.Add(ParseAnnotation(child, path+'/note'))
      else if Not ParseDomainResourceChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeCondition(xml : TXmlBuilder; name : String; value : TFhirCondition);
begin
  if (value = nil) then
    exit;
  composeDomainResourceAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeConditionChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeConditionChildren(xml : TXmlBuilder; value : TFhirCondition);
var
  i : integer;
begin
  composeDomainResourceChildren(xml, value);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.identifierList.Count - 1 do
      ComposeIdentifier(xml, 'identifier', value.identifierList[i]);
  ComposeCodeableConcept(xml, 'clinicalStatus', value.clinicalStatus);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(xml, 'verificationStatus', value.verificationStatus);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.categoryList.Count - 1 do
      ComposeCodeableConcept(xml, 'category', value.categoryList[i]);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(xml, 'severity', value.severity);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(xml, 'code', value.code);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.bodySiteList.Count - 1 do
      ComposeCodeableConcept(xml, 'bodySite', value.bodySiteList[i]);
  ComposeReference(xml, 'subject', value.subject);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference(xml, 'encounter', value.encounter);
  if (SummaryOption in [soFull, soSummary, soData]) and (value.onset is TFhirAge) {6} then
    ComposeAge(xml, 'onsetAge', TFhirAge(value.onset))
  else if (SummaryOption in [soFull, soSummary, soData]) and (value.onset is TFhirPeriod) {6} then
    ComposePeriod(xml, 'onsetPeriod', TFhirPeriod(value.onset))
  else if (SummaryOption in [soFull, soSummary, soData]) and (value.onset is TFhirRange) {6} then
    ComposeRange(xml, 'onsetRange', TFhirRange(value.onset))
  else if (SummaryOption in [soFull, soSummary, soData]) and (value.onset is TFhirDateTime) {6} then
    ComposeDateTime(xml, 'onsetDateTime', TFhirDateTime(value.onset))
  else if (SummaryOption in [soFull, soSummary, soData]) and (value.onset is TFhirString) {6} then
    ComposeString(xml, 'onsetString', TFhirString(value.onset));
  if (SummaryOption in [soFull, soData]) and (value.abatement is TFhirAge) {6} then
    ComposeAge(xml, 'abatementAge', TFhirAge(value.abatement))
  else if (SummaryOption in [soFull, soData]) and (value.abatement is TFhirPeriod) {6} then
    ComposePeriod(xml, 'abatementPeriod', TFhirPeriod(value.abatement))
  else if (SummaryOption in [soFull, soData]) and (value.abatement is TFhirRange) {6} then
    ComposeRange(xml, 'abatementRange', TFhirRange(value.abatement))
  else if (SummaryOption in [soFull, soData]) and (value.abatement is TFhirDateTime) {6} then
    ComposeDateTime(xml, 'abatementDateTime', TFhirDateTime(value.abatement))
  else if (SummaryOption in [soFull, soData]) and (value.abatement is TFhirString) {6} then
    ComposeString(xml, 'abatementString', TFhirString(value.abatement));
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDateTime(xml, 'recordedDate', value.recordedDateElement);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.participantList.Count - 1 do
      ComposeConditionParticipant(xml, 'participant', value.participantList[i]);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.stageList.Count - 1 do
      ComposeConditionStage(xml, 'stage', value.stageList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.evidenceList.Count - 1 do
      ComposeCodeableReference(xml, 'evidence', value.evidenceList[i]);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.noteList.Count - 1 do
      ComposeAnnotation(xml, 'note', value.noteList[i]);
end;

{$ENDIF FHIR_CONDITION}
{$IFDEF FHIR_CONDITIONDEFINITION}
function TFHIRXmlParser.ParseConditionDefinitionObservation(element : TMXmlElement; path : string) : TFhirConditionDefinitionObservation;
var
  child : TMXmlElement;
begin
  result := TFhirConditionDefinitionObservation.Create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseConditionDefinitionObservationChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseConditionDefinitionObservationChild(value : TFhirConditionDefinitionObservation; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'category') then
        value.category := ParseCodeableConcept(child, path+'/category')
      else if (child.localName = 'code') then
        value.code := ParseCodeableConcept(child, path+'/code')
      else if Not ParseBackboneElementChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeConditionDefinitionObservation(xml : TXmlBuilder; name : String; value : TFhirConditionDefinitionObservation);
begin
  if (value = nil) then
    exit;
  composeElementAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeConditionDefinitionObservationChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeConditionDefinitionObservationChildren(xml : TXmlBuilder; value : TFhirConditionDefinitionObservation);
begin
  composeBackboneElementChildren(xml, value);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(xml, 'category', value.category);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(xml, 'code', value.code);
end;

function TFHIRXmlParser.ParseConditionDefinitionMedication(element : TMXmlElement; path : string) : TFhirConditionDefinitionMedication;
var
  child : TMXmlElement;
begin
  result := TFhirConditionDefinitionMedication.Create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseConditionDefinitionMedicationChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseConditionDefinitionMedicationChild(value : TFhirConditionDefinitionMedication; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'category') then
        value.category := ParseCodeableConcept(child, path+'/category')
      else if (child.localName = 'code') then
        value.code := ParseCodeableConcept(child, path+'/code')
      else if Not ParseBackboneElementChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeConditionDefinitionMedication(xml : TXmlBuilder; name : String; value : TFhirConditionDefinitionMedication);
begin
  if (value = nil) then
    exit;
  composeElementAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeConditionDefinitionMedicationChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeConditionDefinitionMedicationChildren(xml : TXmlBuilder; value : TFhirConditionDefinitionMedication);
begin
  composeBackboneElementChildren(xml, value);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(xml, 'category', value.category);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(xml, 'code', value.code);
end;

function TFHIRXmlParser.ParseConditionDefinitionPrecondition(element : TMXmlElement; path : string) : TFhirConditionDefinitionPrecondition;
var
  child : TMXmlElement;
begin
  result := TFhirConditionDefinitionPrecondition.Create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseConditionDefinitionPreconditionChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseConditionDefinitionPreconditionChild(value : TFhirConditionDefinitionPrecondition; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'type') then
        value.type_Element := ParseEnum(CODES_TFhirConditionPreconditionTypeEnum, SYSTEMS_TFhirConditionPreconditionTypeEnum, child, path+'/type')
      else if (child.localName = 'code') then
        value.code := ParseCodeableConcept(child, path+'/code')
      else if (child.localName = 'valueCodeableConcept') then
        value.value := ParseCodeableConcept(child, path+'/valueCodeableConcept')
      else if (child.localName = 'valueQuantity') then
        value.value := ParseQuantity(child, path+'/valueQuantity')
      else if Not ParseBackboneElementChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeConditionDefinitionPrecondition(xml : TXmlBuilder; name : String; value : TFhirConditionDefinitionPrecondition);
begin
  if (value = nil) then
    exit;
  composeElementAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeConditionDefinitionPreconditionChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeConditionDefinitionPreconditionChildren(xml : TXmlBuilder; value : TFhirConditionDefinitionPrecondition);
begin
  composeBackboneElementChildren(xml, value);
  ComposeEnum(xml, 'type', value.type_Element, CODES_TFhirConditionPreconditionTypeEnum);
  ComposeCodeableConcept(xml, 'code', value.code);
  if (SummaryOption in [soFull, soData]) and (value.value is TFhirCodeableConcept) {6} then
    ComposeCodeableConcept(xml, 'valueCodeableConcept', TFhirCodeableConcept(value.value))
  else if (SummaryOption in [soFull, soData]) and (value.value is TFhirQuantity) {6} then
    ComposeQuantity(xml, 'valueQuantity', TFhirQuantity(value.value));
end;

function TFHIRXmlParser.ParseConditionDefinitionQuestionnaire(element : TMXmlElement; path : string) : TFhirConditionDefinitionQuestionnaire;
var
  child : TMXmlElement;
begin
  result := TFhirConditionDefinitionQuestionnaire.Create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseConditionDefinitionQuestionnaireChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseConditionDefinitionQuestionnaireChild(value : TFhirConditionDefinitionQuestionnaire; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'purpose') then
        value.purposeElement := ParseEnum(CODES_TFhirConditionQuestionnairePurposeEnum, SYSTEMS_TFhirConditionQuestionnairePurposeEnum, child, path+'/purpose')
      else if (child.localName = 'reference') then
        value.reference := ParseReference(child, path+'/reference')
      else if Not ParseBackboneElementChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeConditionDefinitionQuestionnaire(xml : TXmlBuilder; name : String; value : TFhirConditionDefinitionQuestionnaire);
begin
  if (value = nil) then
    exit;
  composeElementAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeConditionDefinitionQuestionnaireChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeConditionDefinitionQuestionnaireChildren(xml : TXmlBuilder; value : TFhirConditionDefinitionQuestionnaire);
begin
  composeBackboneElementChildren(xml, value);
  ComposeEnum(xml, 'purpose', value.purposeElement, CODES_TFhirConditionQuestionnairePurposeEnum);
  ComposeReference(xml, 'reference', value.reference);
end;

function TFHIRXmlParser.ParseConditionDefinitionPlan(element : TMXmlElement; path : string) : TFhirConditionDefinitionPlan;
var
  child : TMXmlElement;
begin
  result := TFhirConditionDefinitionPlan.Create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseConditionDefinitionPlanChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseConditionDefinitionPlanChild(value : TFhirConditionDefinitionPlan; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'role') then
        value.role := ParseCodeableConcept(child, path+'/role')
      else if (child.localName = 'reference') then
        value.reference := ParseReference(child, path+'/reference')
      else if Not ParseBackboneElementChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeConditionDefinitionPlan(xml : TXmlBuilder; name : String; value : TFhirConditionDefinitionPlan);
begin
  if (value = nil) then
    exit;
  composeElementAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeConditionDefinitionPlanChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeConditionDefinitionPlanChildren(xml : TXmlBuilder; value : TFhirConditionDefinitionPlan);
begin
  composeBackboneElementChildren(xml, value);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(xml, 'role', value.role);
  ComposeReference(xml, 'reference', value.reference);
end;

function TFHIRXmlParser.ParseConditionDefinition(element : TMXmlElement; path : string) : TFhirConditionDefinition;
var
  child : TMXmlElement;
begin
  result := TFhirConditionDefinition.Create;
  try
    parseMetadataResourceAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseConditionDefinitionChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseConditionDefinitionChild(value : TFhirConditionDefinition; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'url') then
        value.urlElement := ParseUri(child, path+'/url')
      else if (child.localName = 'identifier') then
        value.identifierList.Add(ParseIdentifier(child, path+'/identifier'))
      else if (child.localName = 'version') then
        value.versionElement := ParseString(child, path+'/version')
      else if (child.localName = 'name') then
        value.nameElement := ParseString(child, path+'/name')
      else if (child.localName = 'title') then
        value.titleElement := ParseString(child, path+'/title')
      else if (child.localName = 'subtitle') then
        value.subtitleElement := ParseString(child, path+'/subtitle')
      else if (child.localName = 'status') then
        value.statusElement := ParseEnum(CODES_TFhirPublicationStatusEnum, SYSTEMS_TFhirPublicationStatusEnum, child, path+'/status')
      else if (child.localName = 'experimental') then
        value.experimentalElement := ParseBoolean(child, path+'/experimental')
      else if (child.localName = 'date') then
        value.dateElement := ParseDateTime(child, path+'/date')
      else if (child.localName = 'publisher') then
        value.publisherElement := ParseString(child, path+'/publisher')
      else if (child.localName = 'contact') then
        value.contactList.Add(ParseContactDetail(child, path+'/contact'))
      else if (child.localName = 'description') then
        value.descriptionElement := ParseMarkdown(child, path+'/description')
      else if (child.localName = 'useContext') then
        value.useContextList.Add(ParseUsageContext(child, path+'/useContext'))
      else if (child.localName = 'jurisdiction') then
        value.jurisdictionList.Add(ParseCodeableConcept(child, path+'/jurisdiction'))
      else if (child.localName = 'code') then
        value.code := ParseCodeableConcept(child, path+'/code')
      else if (child.localName = 'severity') then
        value.severity := ParseCodeableConcept(child, path+'/severity')
      else if (child.localName = 'bodySite') then
        value.bodySite := ParseCodeableConcept(child, path+'/bodySite')
      else if (child.localName = 'stage') then
        value.stage := ParseCodeableConcept(child, path+'/stage')
      else if (child.localName = 'hasSeverity') then
        value.hasSeverityElement := ParseBoolean(child, path+'/hasSeverity')
      else if (child.localName = 'hasBodySite') then
        value.hasBodySiteElement := ParseBoolean(child, path+'/hasBodySite')
      else if (child.localName = 'hasStage') then
        value.hasStageElement := ParseBoolean(child, path+'/hasStage')
      else if (child.localName = 'definition') then
        value.definitionList.Add(ParseUri(child, path+'/definition'))
      else if (child.localName = 'observation') then
        value.observationList.Add(ParseConditionDefinitionObservation(child, path+'/observation'))
      else if (child.localName = 'medication') then
        value.medicationList.Add(ParseConditionDefinitionMedication(child, path+'/medication'))
      else if (child.localName = 'precondition') then
        value.preconditionList.Add(ParseConditionDefinitionPrecondition(child, path+'/precondition'))
      else if (child.localName = 'team') then
        value.teamList.Add(ParseReference(child, path+'/team'))
      else if (child.localName = 'questionnaire') then
        value.questionnaireList.Add(ParseConditionDefinitionQuestionnaire(child, path+'/questionnaire'))
      else if (child.localName = 'plan') then
        value.planList.Add(ParseConditionDefinitionPlan(child, path+'/plan'))
      else if Not ParseMetadataResourceChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeConditionDefinition(xml : TXmlBuilder; name : String; value : TFhirConditionDefinition);
begin
  if (value = nil) then
    exit;
  composeMetadataResourceAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeConditionDefinitionChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeConditionDefinitionChildren(xml : TXmlBuilder; value : TFhirConditionDefinition);
var
  i : integer;
begin
  composeMetadataResourceChildren(xml, value);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeUri(xml, 'url', value.urlElement);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.identifierList.Count - 1 do
      ComposeIdentifier(xml, 'identifier', value.identifierList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(xml, 'version', value.versionElement);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(xml, 'name', value.nameElement);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(xml, 'title', value.titleElement);
  if (SummaryOption in [soFull, soData]) then
    ComposeString(xml, 'subtitle', value.subtitleElement);
  ComposeEnum(xml, 'status', value.statusElement, CODES_TFhirPublicationStatusEnum);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeBoolean(xml, 'experimental', value.experimentalElement);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDateTime(xml, 'date', value.dateElement);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(xml, 'publisher', value.publisherElement);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.contactList.Count - 1 do
      ComposeContactDetail(xml, 'contact', value.contactList[i]);
  if (SummaryOption in [soFull, soData]) then
    ComposeMarkdown(xml, 'description', value.descriptionElement);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.useContextList.Count - 1 do
      ComposeUsageContext(xml, 'useContext', value.useContextList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.jurisdictionList.Count - 1 do
      ComposeCodeableConcept(xml, 'jurisdiction', value.jurisdictionList[i]);
  ComposeCodeableConcept(xml, 'code', value.code);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(xml, 'severity', value.severity);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(xml, 'bodySite', value.bodySite);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(xml, 'stage', value.stage);
  if (SummaryOption in [soFull, soData]) then
    ComposeBoolean(xml, 'hasSeverity', value.hasSeverityElement);
  if (SummaryOption in [soFull, soData]) then
    ComposeBoolean(xml, 'hasBodySite', value.hasBodySiteElement);
  if (SummaryOption in [soFull, soData]) then
    ComposeBoolean(xml, 'hasStage', value.hasStageElement);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.definitionList.Count - 1 do
      ComposeUri(xml, 'definition', value.definitionList[i]);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.observationList.Count - 1 do
      ComposeConditionDefinitionObservation(xml, 'observation', value.observationList[i]);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.medicationList.Count - 1 do
      ComposeConditionDefinitionMedication(xml, 'medication', value.medicationList[i]);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.preconditionList.Count - 1 do
      ComposeConditionDefinitionPrecondition(xml, 'precondition', value.preconditionList[i]);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.teamList.Count - 1 do
      ComposeReference(xml, 'team', value.teamList[i]);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.questionnaireList.Count - 1 do
      ComposeConditionDefinitionQuestionnaire(xml, 'questionnaire', value.questionnaireList[i]);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.planList.Count - 1 do
      ComposeConditionDefinitionPlan(xml, 'plan', value.planList[i]);
end;

{$ENDIF FHIR_CONDITIONDEFINITION}
{$IFDEF FHIR_CONSENT}
function TFHIRXmlParser.ParseConsentPolicyBasis(element : TMXmlElement; path : string) : TFhirConsentPolicyBasis;
var
  child : TMXmlElement;
begin
  result := TFhirConsentPolicyBasis.Create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseConsentPolicyBasisChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseConsentPolicyBasisChild(value : TFhirConsentPolicyBasis; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'reference') then
        value.reference := ParseReference(child, path+'/reference')
      else if (child.localName = 'url') then
        value.urlElement := ParseUrl(child, path+'/url')
      else if Not ParseBackboneElementChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeConsentPolicyBasis(xml : TXmlBuilder; name : String; value : TFhirConsentPolicyBasis);
begin
  if (value = nil) then
    exit;
  composeElementAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeConsentPolicyBasisChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeConsentPolicyBasisChildren(xml : TXmlBuilder; value : TFhirConsentPolicyBasis);
begin
  composeBackboneElementChildren(xml, value);
  if (SummaryOption in [soFull, soData]) then
    ComposeReference(xml, 'reference', value.reference);
  if (SummaryOption in [soFull, soData]) then
    ComposeUrl(xml, 'url', value.urlElement);
end;

function TFHIRXmlParser.ParseConsentVerification(element : TMXmlElement; path : string) : TFhirConsentVerification;
var
  child : TMXmlElement;
begin
  result := TFhirConsentVerification.Create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseConsentVerificationChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseConsentVerificationChild(value : TFhirConsentVerification; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'verified') then
        value.verifiedElement := ParseBoolean(child, path+'/verified')
      else if (child.localName = 'verificationType') then
        value.verificationType := ParseCodeableConcept(child, path+'/verificationType')
      else if (child.localName = 'verifiedBy') then
        value.verifiedBy := ParseReference(child, path+'/verifiedBy')
      else if (child.localName = 'verifiedWith') then
        value.verifiedWith := ParseReference(child, path+'/verifiedWith')
      else if (child.localName = 'verificationDate') then
        value.verificationDateList.Add(ParseDateTime(child, path+'/verificationDate'))
      else if Not ParseBackboneElementChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeConsentVerification(xml : TXmlBuilder; name : String; value : TFhirConsentVerification);
begin
  if (value = nil) then
    exit;
  composeElementAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeConsentVerificationChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeConsentVerificationChildren(xml : TXmlBuilder; value : TFhirConsentVerification);
var
  i : integer;
begin
  composeBackboneElementChildren(xml, value);
  ComposeBoolean(xml, 'verified', value.verifiedElement);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(xml, 'verificationType', value.verificationType);
  if (SummaryOption in [soFull, soData]) then
    ComposeReference(xml, 'verifiedBy', value.verifiedBy);
  if (SummaryOption in [soFull, soData]) then
    ComposeReference(xml, 'verifiedWith', value.verifiedWith);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.verificationDateList.Count - 1 do
      ComposeDateTime(xml, 'verificationDate', value.verificationDateList[i]);
end;

function TFHIRXmlParser.ParseConsentProvision(element : TMXmlElement; path : string) : TFhirConsentProvision;
var
  child : TMXmlElement;
begin
  result := TFhirConsentProvision.Create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseConsentProvisionChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseConsentProvisionChild(value : TFhirConsentProvision; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'type') then
        value.type_Element := ParseEnum(CODES_TFhirConsentProvisionTypeEnum, SYSTEMS_TFhirConsentProvisionTypeEnum, child, path+'/type')
      else if (child.localName = 'period') then
        value.period := ParsePeriod(child, path+'/period')
      else if (child.localName = 'actor') then
        value.actorList.Add(ParseConsentProvisionActor(child, path+'/actor'))
      else if (child.localName = 'action') then
        value.actionList.Add(ParseCodeableConcept(child, path+'/action'))
      else if (child.localName = 'securityLabel') then
        value.securityLabelList.Add(ParseCoding(child, path+'/securityLabel'))
      else if (child.localName = 'purpose') then
        value.purposeList.Add(ParseCoding(child, path+'/purpose'))
      else if (child.localName = 'class') then
        value.class_List.Add(ParseCoding(child, path+'/class'))
      else if (child.localName = 'code') then
        value.codeList.Add(ParseCodeableConcept(child, path+'/code'))
      else if (child.localName = 'dataPeriod') then
        value.dataPeriod := ParsePeriod(child, path+'/dataPeriod')
      else if (child.localName = 'data') then
        value.dataList.Add(ParseConsentProvisionData(child, path+'/data'))
      else if (child.localName = 'expression') then
        value.expression := ParseExpression(child, path+'/expression')
      else if (child.localName = 'provision') then
        value.provisionList.Add(ParseConsentProvision(child, path+'/provision'))
      else if Not ParseBackboneElementChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeConsentProvision(xml : TXmlBuilder; name : String; value : TFhirConsentProvision);
begin
  if (value = nil) then
    exit;
  composeElementAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeConsentProvisionChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeConsentProvisionChildren(xml : TXmlBuilder; value : TFhirConsentProvision);
var
  i : integer;
begin
  composeBackboneElementChildren(xml, value);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeEnum(xml, 'type', value.type_Element, CODES_TFhirConsentProvisionTypeEnum);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposePeriod(xml, 'period', value.period);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.actorList.Count - 1 do
      ComposeConsentProvisionActor(xml, 'actor', value.actorList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.actionList.Count - 1 do
      ComposeCodeableConcept(xml, 'action', value.actionList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.securityLabelList.Count - 1 do
      ComposeCoding(xml, 'securityLabel', value.securityLabelList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.purposeList.Count - 1 do
      ComposeCoding(xml, 'purpose', value.purposeList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.class_List.Count - 1 do
      ComposeCoding(xml, 'class', value.class_List[i]);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.codeList.Count - 1 do
      ComposeCodeableConcept(xml, 'code', value.codeList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposePeriod(xml, 'dataPeriod', value.dataPeriod);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.dataList.Count - 1 do
      ComposeConsentProvisionData(xml, 'data', value.dataList[i]);
  if (SummaryOption in [soFull, soData]) then
    ComposeExpression(xml, 'expression', value.expression);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.provisionList.Count - 1 do
      ComposeConsentProvision(xml, 'provision', value.provisionList[i]);
end;

function TFHIRXmlParser.ParseConsentProvisionActor(element : TMXmlElement; path : string) : TFhirConsentProvisionActor;
var
  child : TMXmlElement;
begin
  result := TFhirConsentProvisionActor.Create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseConsentProvisionActorChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseConsentProvisionActorChild(value : TFhirConsentProvisionActor; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'role') then
        value.role := ParseCodeableConcept(child, path+'/role')
      else if (child.localName = 'reference') then
        value.reference := ParseReference(child, path+'/reference')
      else if Not ParseBackboneElementChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeConsentProvisionActor(xml : TXmlBuilder; name : String; value : TFhirConsentProvisionActor);
begin
  if (value = nil) then
    exit;
  composeElementAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeConsentProvisionActorChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeConsentProvisionActorChildren(xml : TXmlBuilder; value : TFhirConsentProvisionActor);
begin
  composeBackboneElementChildren(xml, value);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(xml, 'role', value.role);
  if (SummaryOption in [soFull, soData]) then
    ComposeReference(xml, 'reference', value.reference);
end;

function TFHIRXmlParser.ParseConsentProvisionData(element : TMXmlElement; path : string) : TFhirConsentProvisionData;
var
  child : TMXmlElement;
begin
  result := TFhirConsentProvisionData.Create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseConsentProvisionDataChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseConsentProvisionDataChild(value : TFhirConsentProvisionData; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'meaning') then
        value.meaningElement := ParseEnum(CODES_TFhirConsentDataMeaningEnum, SYSTEMS_TFhirConsentDataMeaningEnum, child, path+'/meaning')
      else if (child.localName = 'reference') then
        value.reference := ParseReference(child, path+'/reference')
      else if Not ParseBackboneElementChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeConsentProvisionData(xml : TXmlBuilder; name : String; value : TFhirConsentProvisionData);
begin
  if (value = nil) then
    exit;
  composeElementAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeConsentProvisionDataChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeConsentProvisionDataChildren(xml : TXmlBuilder; value : TFhirConsentProvisionData);
begin
  composeBackboneElementChildren(xml, value);
  ComposeEnum(xml, 'meaning', value.meaningElement, CODES_TFhirConsentDataMeaningEnum);
  ComposeReference(xml, 'reference', value.reference);
end;

function TFHIRXmlParser.ParseConsent(element : TMXmlElement; path : string) : TFhirConsent;
var
  child : TMXmlElement;
begin
  result := TFhirConsent.Create;
  try
    parseDomainResourceAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseConsentChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseConsentChild(value : TFhirConsent; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'identifier') then
        value.identifierList.Add(ParseIdentifier(child, path+'/identifier'))
      else if (child.localName = 'status') then
        value.statusElement := ParseEnum(CODES_TFhirConsentStateEnum, SYSTEMS_TFhirConsentStateEnum, child, path+'/status')
      else if (child.localName = 'category') then
        value.categoryList.Add(ParseCodeableConcept(child, path+'/category'))
      else if (child.localName = 'subject') then
        value.subject := ParseReference(child, path+'/subject')
      else if (child.localName = 'dateTime') then
        value.dateTimeElement := ParseDateTime(child, path+'/dateTime')
      else if (child.localName = 'grantor') then
        value.grantorList.Add(ParseReference(child, path+'/grantor'))
      else if (child.localName = 'grantee') then
        value.granteeList.Add(ParseReference(child, path+'/grantee'))
      else if (child.localName = 'manager') then
        value.managerList.Add(ParseReference(child, path+'/manager'))
      else if (child.localName = 'controller') then
        value.controllerList.Add(ParseReference(child, path+'/controller'))
      else if (child.localName = 'sourceAttachment') then
        value.sourceAttachmentList.Add(ParseAttachment(child, path+'/sourceAttachment'))
      else if (child.localName = 'sourceReference') then
        value.sourceReferenceList.Add(ParseReference(child, path+'/sourceReference'))
      else if (child.localName = 'regulatoryBasis') then
        value.regulatoryBasisList.Add(ParseCodeableConcept(child, path+'/regulatoryBasis'))
      else if (child.localName = 'policyBasis') then
        value.policyBasis := ParseConsentPolicyBasis(child, path+'/policyBasis')
      else if (child.localName = 'policyText') then
        value.policyTextList.Add(ParseReference(child, path+'/policyText'))
      else if (child.localName = 'verification') then
        value.verificationList.Add(ParseConsentVerification(child, path+'/verification'))
      else if (child.localName = 'provision') then
        value.provision := ParseConsentProvision(child, path+'/provision')
      else if Not ParseDomainResourceChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeConsent(xml : TXmlBuilder; name : String; value : TFhirConsent);
begin
  if (value = nil) then
    exit;
  composeDomainResourceAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeConsentChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeConsentChildren(xml : TXmlBuilder; value : TFhirConsent);
var
  i : integer;
begin
  composeDomainResourceChildren(xml, value);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.identifierList.Count - 1 do
      ComposeIdentifier(xml, 'identifier', value.identifierList[i]);
  ComposeEnum(xml, 'status', value.statusElement, CODES_TFhirConsentStateEnum);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.categoryList.Count - 1 do
      ComposeCodeableConcept(xml, 'category', value.categoryList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference(xml, 'subject', value.subject);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDateTime(xml, 'dateTime', value.dateTimeElement);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.grantorList.Count - 1 do
      ComposeReference(xml, 'grantor', value.grantorList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.granteeList.Count - 1 do
      ComposeReference(xml, 'grantee', value.granteeList[i]);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.managerList.Count - 1 do
      ComposeReference(xml, 'manager', value.managerList[i]);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.controllerList.Count - 1 do
      ComposeReference(xml, 'controller', value.controllerList[i]);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.sourceAttachmentList.Count - 1 do
      ComposeAttachment(xml, 'sourceAttachment', value.sourceAttachmentList[i]);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.sourceReferenceList.Count - 1 do
      ComposeReference(xml, 'sourceReference', value.sourceReferenceList[i]);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.regulatoryBasisList.Count - 1 do
      ComposeCodeableConcept(xml, 'regulatoryBasis', value.regulatoryBasisList[i]);
  if (SummaryOption in [soFull, soData]) then
    ComposeConsentPolicyBasis(xml, 'policyBasis', value.policyBasis);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.policyTextList.Count - 1 do
      ComposeReference(xml, 'policyText', value.policyTextList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.verificationList.Count - 1 do
      ComposeConsentVerification(xml, 'verification', value.verificationList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeConsentProvision(xml, 'provision', value.provision);
end;

{$ENDIF FHIR_CONSENT}
{$IFDEF FHIR_CONTRACT}
function TFHIRXmlParser.ParseContractContentDefinition(element : TMXmlElement; path : string) : TFhirContractContentDefinition;
var
  child : TMXmlElement;
begin
  result := TFhirContractContentDefinition.Create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseContractContentDefinitionChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseContractContentDefinitionChild(value : TFhirContractContentDefinition; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'type') then
        value.type_ := ParseCodeableConcept(child, path+'/type')
      else if (child.localName = 'subType') then
        value.subType := ParseCodeableConcept(child, path+'/subType')
      else if (child.localName = 'publisher') then
        value.publisher := ParseReference(child, path+'/publisher')
      else if (child.localName = 'publicationDate') then
        value.publicationDateElement := ParseDateTime(child, path+'/publicationDate')
      else if (child.localName = 'publicationStatus') then
        value.publicationStatusElement := ParseEnum(CODES_TFhirContractResourcePublicationStatusCodesEnum, SYSTEMS_TFhirContractResourcePublicationStatusCodesEnum, child, path+'/publicationStatus')
      else if (child.localName = 'copyright') then
        value.copyrightElement := ParseMarkdown(child, path+'/copyright')
      else if Not ParseBackboneElementChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeContractContentDefinition(xml : TXmlBuilder; name : String; value : TFhirContractContentDefinition);
begin
  if (value = nil) then
    exit;
  composeElementAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeContractContentDefinitionChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeContractContentDefinitionChildren(xml : TXmlBuilder; value : TFhirContractContentDefinition);
begin
  composeBackboneElementChildren(xml, value);
  ComposeCodeableConcept(xml, 'type', value.type_);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(xml, 'subType', value.subType);
  if (SummaryOption in [soFull, soData]) then
    ComposeReference(xml, 'publisher', value.publisher);
  if (SummaryOption in [soFull, soData]) then
    ComposeDateTime(xml, 'publicationDate', value.publicationDateElement);
  ComposeEnum(xml, 'publicationStatus', value.publicationStatusElement, CODES_TFhirContractResourcePublicationStatusCodesEnum);
  if (SummaryOption in [soFull, soData]) then
    ComposeMarkdown(xml, 'copyright', value.copyrightElement);
end;

function TFHIRXmlParser.ParseContractTerm(element : TMXmlElement; path : string) : TFhirContractTerm;
var
  child : TMXmlElement;
begin
  result := TFhirContractTerm.Create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseContractTermChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseContractTermChild(value : TFhirContractTerm; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'identifier') then
        value.identifier := ParseIdentifier(child, path+'/identifier')
      else if (child.localName = 'issued') then
        value.issuedElement := ParseDateTime(child, path+'/issued')
      else if (child.localName = 'applies') then
        value.applies := ParsePeriod(child, path+'/applies')
      else if (child.localName = 'topicCodeableConcept') then
        value.topic := ParseCodeableConcept(child, path+'/topicCodeableConcept')
      else if (child.localName = 'topicReference') then
        value.topic := ParseReference(child, path+'/topicReference')
      else if (child.localName = 'type') then
        value.type_ := ParseCodeableConcept(child, path+'/type')
      else if (child.localName = 'subType') then
        value.subType := ParseCodeableConcept(child, path+'/subType')
      else if (child.localName = 'text') then
        value.textElement := ParseString(child, path+'/text')
      else if (child.localName = 'securityLabel') then
        value.securityLabelList.Add(ParseContractTermSecurityLabel(child, path+'/securityLabel'))
      else if (child.localName = 'offer') then
        value.offer := ParseContractTermOffer(child, path+'/offer')
      else if (child.localName = 'asset') then
        value.assetList.Add(ParseContractTermAsset(child, path+'/asset'))
      else if (child.localName = 'action') then
        value.actionList.Add(ParseContractTermAction(child, path+'/action'))
      else if (child.localName = 'group') then
        value.groupList.Add(ParseContractTerm(child, path+'/group'))
      else if Not ParseBackboneElementChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeContractTerm(xml : TXmlBuilder; name : String; value : TFhirContractTerm);
begin
  if (value = nil) then
    exit;
  composeElementAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeContractTermChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeContractTermChildren(xml : TXmlBuilder; value : TFhirContractTerm);
var
  i : integer;
begin
  composeBackboneElementChildren(xml, value);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeIdentifier(xml, 'identifier', value.identifier);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDateTime(xml, 'issued', value.issuedElement);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposePeriod(xml, 'applies', value.applies);
  if (SummaryOption in [soFull, soData]) and (value.topic is TFhirCodeableConcept) {6} then
    ComposeCodeableConcept(xml, 'topicCodeableConcept', TFhirCodeableConcept(value.topic))
  else if (SummaryOption in [soFull, soData]) and (value.topic is TFhirReference) {2} then
    ComposeReference(xml, 'topicReference', TFhirReference(value.topic));
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(xml, 'type', value.type_);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(xml, 'subType', value.subType);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(xml, 'text', value.textElement);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.securityLabelList.Count - 1 do
      ComposeContractTermSecurityLabel(xml, 'securityLabel', value.securityLabelList[i]);
  ComposeContractTermOffer(xml, 'offer', value.offer);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.assetList.Count - 1 do
      ComposeContractTermAsset(xml, 'asset', value.assetList[i]);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.actionList.Count - 1 do
      ComposeContractTermAction(xml, 'action', value.actionList[i]);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.groupList.Count - 1 do
      ComposeContractTerm(xml, 'group', value.groupList[i]);
end;

function TFHIRXmlParser.ParseContractTermSecurityLabel(element : TMXmlElement; path : string) : TFhirContractTermSecurityLabel;
var
  child : TMXmlElement;
begin
  result := TFhirContractTermSecurityLabel.Create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseContractTermSecurityLabelChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseContractTermSecurityLabelChild(value : TFhirContractTermSecurityLabel; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'number') then
        value.numberList.Add(ParseUnsignedInt(child, path+'/number'))
      else if (child.localName = 'classification') then
        value.classification := ParseCoding(child, path+'/classification')
      else if (child.localName = 'category') then
        value.categoryList.Add(ParseCoding(child, path+'/category'))
      else if (child.localName = 'control') then
        value.controlList.Add(ParseCoding(child, path+'/control'))
      else if Not ParseBackboneElementChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeContractTermSecurityLabel(xml : TXmlBuilder; name : String; value : TFhirContractTermSecurityLabel);
begin
  if (value = nil) then
    exit;
  composeElementAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeContractTermSecurityLabelChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeContractTermSecurityLabelChildren(xml : TXmlBuilder; value : TFhirContractTermSecurityLabel);
var
  i : integer;
begin
  composeBackboneElementChildren(xml, value);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.numberList.Count - 1 do
      ComposeUnsignedInt(xml, 'number', value.numberList[i]);
  ComposeCoding(xml, 'classification', value.classification);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.categoryList.Count - 1 do
      ComposeCoding(xml, 'category', value.categoryList[i]);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.controlList.Count - 1 do
      ComposeCoding(xml, 'control', value.controlList[i]);
end;

function TFHIRXmlParser.ParseContractTermOffer(element : TMXmlElement; path : string) : TFhirContractTermOffer;
var
  child : TMXmlElement;
begin
  result := TFhirContractTermOffer.Create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseContractTermOfferChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseContractTermOfferChild(value : TFhirContractTermOffer; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'identifier') then
        value.identifierList.Add(ParseIdentifier(child, path+'/identifier'))
      else if (child.localName = 'party') then
        value.partyList.Add(ParseContractTermOfferParty(child, path+'/party'))
      else if (child.localName = 'topic') then
        value.topic := ParseReference(child, path+'/topic')
      else if (child.localName = 'type') then
        value.type_ := ParseCodeableConcept(child, path+'/type')
      else if (child.localName = 'decision') then
        value.decision := ParseCodeableConcept(child, path+'/decision')
      else if (child.localName = 'decisionMode') then
        value.decisionModeList.Add(ParseCodeableConcept(child, path+'/decisionMode'))
      else if (child.localName = 'answer') then
        value.answerList.Add(ParseContractTermOfferAnswer(child, path+'/answer'))
      else if (child.localName = 'text') then
        value.textElement := ParseString(child, path+'/text')
      else if (child.localName = 'linkId') then
        value.linkIdList.Add(ParseString(child, path+'/linkId'))
      else if (child.localName = 'securityLabelNumber') then
        value.securityLabelNumberList.Add(ParseUnsignedInt(child, path+'/securityLabelNumber'))
      else if Not ParseBackboneElementChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeContractTermOffer(xml : TXmlBuilder; name : String; value : TFhirContractTermOffer);
begin
  if (value = nil) then
    exit;
  composeElementAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeContractTermOfferChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeContractTermOfferChildren(xml : TXmlBuilder; value : TFhirContractTermOffer);
var
  i : integer;
begin
  composeBackboneElementChildren(xml, value);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.identifierList.Count - 1 do
      ComposeIdentifier(xml, 'identifier', value.identifierList[i]);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.partyList.Count - 1 do
      ComposeContractTermOfferParty(xml, 'party', value.partyList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference(xml, 'topic', value.topic);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(xml, 'type', value.type_);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(xml, 'decision', value.decision);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.decisionModeList.Count - 1 do
      ComposeCodeableConcept(xml, 'decisionMode', value.decisionModeList[i]);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.answerList.Count - 1 do
      ComposeContractTermOfferAnswer(xml, 'answer', value.answerList[i]);
  if (SummaryOption in [soFull, soData]) then
    ComposeString(xml, 'text', value.textElement);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.linkIdList.Count - 1 do
      ComposeString(xml, 'linkId', value.linkIdList[i]);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.securityLabelNumberList.Count - 1 do
      ComposeUnsignedInt(xml, 'securityLabelNumber', value.securityLabelNumberList[i]);
end;

function TFHIRXmlParser.ParseContractTermOfferParty(element : TMXmlElement; path : string) : TFhirContractTermOfferParty;
var
  child : TMXmlElement;
begin
  result := TFhirContractTermOfferParty.Create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseContractTermOfferPartyChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseContractTermOfferPartyChild(value : TFhirContractTermOfferParty; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'reference') then
        value.referenceList.Add(ParseReference(child, path+'/reference'))
      else if (child.localName = 'role') then
        value.role := ParseCodeableConcept(child, path+'/role')
      else if Not ParseBackboneElementChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeContractTermOfferParty(xml : TXmlBuilder; name : String; value : TFhirContractTermOfferParty);
begin
  if (value = nil) then
    exit;
  composeElementAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeContractTermOfferPartyChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeContractTermOfferPartyChildren(xml : TXmlBuilder; value : TFhirContractTermOfferParty);
var
  i : integer;
begin
  composeBackboneElementChildren(xml, value);
  for i := 0 to value.referenceList.Count - 1 do
      ComposeReference(xml, 'reference', value.referenceList[i]);
  ComposeCodeableConcept(xml, 'role', value.role);
end;

function TFHIRXmlParser.ParseContractTermOfferAnswer(element : TMXmlElement; path : string) : TFhirContractTermOfferAnswer;
var
  child : TMXmlElement;
begin
  result := TFhirContractTermOfferAnswer.Create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseContractTermOfferAnswerChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseContractTermOfferAnswerChild(value : TFhirContractTermOfferAnswer; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'valueAttachment') then
        value.value := ParseAttachment(child, path+'/valueAttachment')
      else if (child.localName = 'valueCoding') then
        value.value := ParseCoding(child, path+'/valueCoding')
      else if (child.localName = 'valueQuantity') then
        value.value := ParseQuantity(child, path+'/valueQuantity')
      else if (child.localName = 'valueReference') then
        value.value := ParseReference(child, path+'/valueReference')
      else if (child.localName = 'valueBoolean') then
        value.value := ParseBoolean(child, path+'/valueBoolean')
      else if (child.localName = 'valueDecimal') then
        value.value := ParseDecimal(child, path+'/valueDecimal')
      else if (child.localName = 'valueInteger') then
        value.value := ParseInteger(child, path+'/valueInteger')
      else if (child.localName = 'valueDate') then
        value.value := ParseDate(child, path+'/valueDate')
      else if (child.localName = 'valueDateTime') then
        value.value := ParseDateTime(child, path+'/valueDateTime')
      else if (child.localName = 'valueTime') then
        value.value := ParseTime(child, path+'/valueTime')
      else if (child.localName = 'valueString') then
        value.value := ParseString(child, path+'/valueString')
      else if (child.localName = 'valueUri') then
        value.value := ParseUri(child, path+'/valueUri')
      else if Not ParseBackboneElementChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeContractTermOfferAnswer(xml : TXmlBuilder; name : String; value : TFhirContractTermOfferAnswer);
begin
  if (value = nil) then
    exit;
  composeElementAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeContractTermOfferAnswerChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeContractTermOfferAnswerChildren(xml : TXmlBuilder; value : TFhirContractTermOfferAnswer);
begin
  composeBackboneElementChildren(xml, value);
  if (value.value is TFhirAttachment) {6} then
    ComposeAttachment(xml, 'valueAttachment', TFhirAttachment(value.value))
  else if (value.value is TFhirCoding) {6} then
    ComposeCoding(xml, 'valueCoding', TFhirCoding(value.value))
  else if (value.value is TFhirQuantity) {6} then
    ComposeQuantity(xml, 'valueQuantity', TFhirQuantity(value.value))
  else if (value.value is TFhirReference) {2} then
    ComposeReference(xml, 'valueReference', TFhirReference(value.value))
  else if (value.value is TFhirBoolean) {6} then
    ComposeBoolean(xml, 'valueBoolean', TFhirBoolean(value.value))
  else if (value.value is TFhirDecimal) {6} then
    ComposeDecimal(xml, 'valueDecimal', TFhirDecimal(value.value))
  else if (value.value is TFhirInteger) {6} then
    ComposeInteger(xml, 'valueInteger', TFhirInteger(value.value))
  else if (value.value is TFhirDate) {6} then
    ComposeDate(xml, 'valueDate', TFhirDate(value.value))
  else if (value.value is TFhirDateTime) {6} then
    ComposeDateTime(xml, 'valueDateTime', TFhirDateTime(value.value))
  else if (value.value is TFhirTime) {6} then
    ComposeTime(xml, 'valueTime', TFhirTime(value.value))
  else if (value.value is TFhirString) {6} then
    ComposeString(xml, 'valueString', TFhirString(value.value))
  else if (value.value is TFhirUri) {6} then
    ComposeUri(xml, 'valueUri', TFhirUri(value.value));
end;

function TFHIRXmlParser.ParseContractTermAsset(element : TMXmlElement; path : string) : TFhirContractTermAsset;
var
  child : TMXmlElement;
begin
  result := TFhirContractTermAsset.Create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseContractTermAssetChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseContractTermAssetChild(value : TFhirContractTermAsset; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'scope') then
        value.scope := ParseCodeableConcept(child, path+'/scope')
      else if (child.localName = 'type') then
        value.type_List.Add(ParseCodeableConcept(child, path+'/type'))
      else if (child.localName = 'typeReference') then
        value.typeReferenceList.Add(ParseReference(child, path+'/typeReference'))
      else if (child.localName = 'subtype') then
        value.subtypeList.Add(ParseCodeableConcept(child, path+'/subtype'))
      else if (child.localName = 'relationship') then
        value.relationship := ParseCoding(child, path+'/relationship')
      else if (child.localName = 'context') then
        value.contextList.Add(ParseContractTermAssetContext(child, path+'/context'))
      else if (child.localName = 'condition') then
        value.conditionElement := ParseString(child, path+'/condition')
      else if (child.localName = 'periodType') then
        value.periodTypeList.Add(ParseCodeableConcept(child, path+'/periodType'))
      else if (child.localName = 'period') then
        value.periodList.Add(ParsePeriod(child, path+'/period'))
      else if (child.localName = 'usePeriod') then
        value.usePeriodList.Add(ParsePeriod(child, path+'/usePeriod'))
      else if (child.localName = 'text') then
        value.textElement := ParseString(child, path+'/text')
      else if (child.localName = 'linkId') then
        value.linkIdList.Add(ParseString(child, path+'/linkId'))
      else if (child.localName = 'answer') then
        value.answerList.Add(ParseContractTermOfferAnswer(child, path+'/answer'))
      else if (child.localName = 'securityLabelNumber') then
        value.securityLabelNumberList.Add(ParseUnsignedInt(child, path+'/securityLabelNumber'))
      else if (child.localName = 'valuedItem') then
        value.valuedItemList.Add(ParseContractTermAssetValuedItem(child, path+'/valuedItem'))
      else if Not ParseBackboneElementChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeContractTermAsset(xml : TXmlBuilder; name : String; value : TFhirContractTermAsset);
begin
  if (value = nil) then
    exit;
  composeElementAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeContractTermAssetChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeContractTermAssetChildren(xml : TXmlBuilder; value : TFhirContractTermAsset);
var
  i : integer;
begin
  composeBackboneElementChildren(xml, value);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(xml, 'scope', value.scope);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.type_List.Count - 1 do
      ComposeCodeableConcept(xml, 'type', value.type_List[i]);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.typeReferenceList.Count - 1 do
      ComposeReference(xml, 'typeReference', value.typeReferenceList[i]);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.subtypeList.Count - 1 do
      ComposeCodeableConcept(xml, 'subtype', value.subtypeList[i]);
  if (SummaryOption in [soFull, soData]) then
    ComposeCoding(xml, 'relationship', value.relationship);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.contextList.Count - 1 do
      ComposeContractTermAssetContext(xml, 'context', value.contextList[i]);
  if (SummaryOption in [soFull, soData]) then
    ComposeString(xml, 'condition', value.conditionElement);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.periodTypeList.Count - 1 do
      ComposeCodeableConcept(xml, 'periodType', value.periodTypeList[i]);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.periodList.Count - 1 do
      ComposePeriod(xml, 'period', value.periodList[i]);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.usePeriodList.Count - 1 do
      ComposePeriod(xml, 'usePeriod', value.usePeriodList[i]);
  if (SummaryOption in [soFull, soData]) then
    ComposeString(xml, 'text', value.textElement);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.linkIdList.Count - 1 do
      ComposeString(xml, 'linkId', value.linkIdList[i]);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.answerList.Count - 1 do
      ComposeContractTermOfferAnswer(xml, 'answer', value.answerList[i]);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.securityLabelNumberList.Count - 1 do
      ComposeUnsignedInt(xml, 'securityLabelNumber', value.securityLabelNumberList[i]);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.valuedItemList.Count - 1 do
      ComposeContractTermAssetValuedItem(xml, 'valuedItem', value.valuedItemList[i]);
end;

function TFHIRXmlParser.ParseContractTermAssetContext(element : TMXmlElement; path : string) : TFhirContractTermAssetContext;
var
  child : TMXmlElement;
begin
  result := TFhirContractTermAssetContext.Create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseContractTermAssetContextChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseContractTermAssetContextChild(value : TFhirContractTermAssetContext; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'reference') then
        value.reference := ParseReference(child, path+'/reference')
      else if (child.localName = 'code') then
        value.codeList.Add(ParseCodeableConcept(child, path+'/code'))
      else if (child.localName = 'text') then
        value.textElement := ParseString(child, path+'/text')
      else if Not ParseBackboneElementChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeContractTermAssetContext(xml : TXmlBuilder; name : String; value : TFhirContractTermAssetContext);
begin
  if (value = nil) then
    exit;
  composeElementAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeContractTermAssetContextChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeContractTermAssetContextChildren(xml : TXmlBuilder; value : TFhirContractTermAssetContext);
var
  i : integer;
begin
  composeBackboneElementChildren(xml, value);
  if (SummaryOption in [soFull, soData]) then
    ComposeReference(xml, 'reference', value.reference);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.codeList.Count - 1 do
      ComposeCodeableConcept(xml, 'code', value.codeList[i]);
  if (SummaryOption in [soFull, soData]) then
    ComposeString(xml, 'text', value.textElement);
end;

function TFHIRXmlParser.ParseContractTermAssetValuedItem(element : TMXmlElement; path : string) : TFhirContractTermAssetValuedItem;
var
  child : TMXmlElement;
begin
  result := TFhirContractTermAssetValuedItem.Create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseContractTermAssetValuedItemChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseContractTermAssetValuedItemChild(value : TFhirContractTermAssetValuedItem; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'entityCodeableConcept') then
        value.entity := ParseCodeableConcept(child, path+'/entityCodeableConcept')
      else if (child.localName = 'entityReference') then
        value.entity := ParseReference(child, path+'/entityReference')
      else if (child.localName = 'identifier') then
        value.identifier := ParseIdentifier(child, path+'/identifier')
      else if (child.localName = 'effectiveTime') then
        value.effectiveTimeElement := ParseDateTime(child, path+'/effectiveTime')
      else if (child.localName = 'quantity') then
        value.quantity := ParseQuantity(child, path+'/quantity')
      else if (child.localName = 'unitPrice') then
        value.unitPrice := ParseMoney(child, path+'/unitPrice')
      else if (child.localName = 'factor') then
        value.factorElement := ParseDecimal(child, path+'/factor')
      else if (child.localName = 'points') then
        value.pointsElement := ParseDecimal(child, path+'/points')
      else if (child.localName = 'net') then
        value.net := ParseMoney(child, path+'/net')
      else if (child.localName = 'payment') then
        value.paymentElement := ParseString(child, path+'/payment')
      else if (child.localName = 'paymentDate') then
        value.paymentDateElement := ParseDateTime(child, path+'/paymentDate')
      else if (child.localName = 'responsible') then
        value.responsible := ParseReference(child, path+'/responsible')
      else if (child.localName = 'recipient') then
        value.recipient := ParseReference(child, path+'/recipient')
      else if (child.localName = 'linkId') then
        value.linkIdList.Add(ParseString(child, path+'/linkId'))
      else if (child.localName = 'securityLabelNumber') then
        value.securityLabelNumberList.Add(ParseUnsignedInt(child, path+'/securityLabelNumber'))
      else if Not ParseBackboneElementChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeContractTermAssetValuedItem(xml : TXmlBuilder; name : String; value : TFhirContractTermAssetValuedItem);
begin
  if (value = nil) then
    exit;
  composeElementAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeContractTermAssetValuedItemChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeContractTermAssetValuedItemChildren(xml : TXmlBuilder; value : TFhirContractTermAssetValuedItem);
var
  i : integer;
begin
  composeBackboneElementChildren(xml, value);
  if (SummaryOption in [soFull, soData]) and (value.entity is TFhirCodeableConcept) {6} then
    ComposeCodeableConcept(xml, 'entityCodeableConcept', TFhirCodeableConcept(value.entity))
  else if (SummaryOption in [soFull, soData]) and (value.entity is TFhirReference) {2} then
    ComposeReference(xml, 'entityReference', TFhirReference(value.entity));
  if (SummaryOption in [soFull, soData]) then
    ComposeIdentifier(xml, 'identifier', value.identifier);
  if (SummaryOption in [soFull, soData]) then
    ComposeDateTime(xml, 'effectiveTime', value.effectiveTimeElement);
  if (SummaryOption in [soFull, soData]) then
    ComposeQuantity(xml, 'quantity', value.quantity);
  if (SummaryOption in [soFull, soData]) then
    ComposeMoney(xml, 'unitPrice', value.unitPrice);
  if (SummaryOption in [soFull, soData]) then
    ComposeDecimal(xml, 'factor', value.factorElement);
  if (SummaryOption in [soFull, soData]) then
    ComposeDecimal(xml, 'points', value.pointsElement);
  if (SummaryOption in [soFull, soData]) then
    ComposeMoney(xml, 'net', value.net);
  if (SummaryOption in [soFull, soData]) then
    ComposeString(xml, 'payment', value.paymentElement);
  if (SummaryOption in [soFull, soData]) then
    ComposeDateTime(xml, 'paymentDate', value.paymentDateElement);
  if (SummaryOption in [soFull, soData]) then
    ComposeReference(xml, 'responsible', value.responsible);
  if (SummaryOption in [soFull, soData]) then
    ComposeReference(xml, 'recipient', value.recipient);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.linkIdList.Count - 1 do
      ComposeString(xml, 'linkId', value.linkIdList[i]);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.securityLabelNumberList.Count - 1 do
      ComposeUnsignedInt(xml, 'securityLabelNumber', value.securityLabelNumberList[i]);
end;

function TFHIRXmlParser.ParseContractTermAction(element : TMXmlElement; path : string) : TFhirContractTermAction;
var
  child : TMXmlElement;
begin
  result := TFhirContractTermAction.Create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseContractTermActionChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseContractTermActionChild(value : TFhirContractTermAction; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'doNotPerform') then
        value.doNotPerformElement := ParseBoolean(child, path+'/doNotPerform')
      else if (child.localName = 'type') then
        value.type_ := ParseCodeableConcept(child, path+'/type')
      else if (child.localName = 'subject') then
        value.subjectList.Add(ParseContractTermActionSubject(child, path+'/subject'))
      else if (child.localName = 'intent') then
        value.intent := ParseCodeableConcept(child, path+'/intent')
      else if (child.localName = 'linkId') then
        value.linkIdList.Add(ParseString(child, path+'/linkId'))
      else if (child.localName = 'status') then
        value.status := ParseCodeableConcept(child, path+'/status')
      else if (child.localName = 'context') then
        value.context := ParseReference(child, path+'/context')
      else if (child.localName = 'contextLinkId') then
        value.contextLinkIdList.Add(ParseString(child, path+'/contextLinkId'))
      else if (child.localName = 'occurrencePeriod') then
        value.occurrence := ParsePeriod(child, path+'/occurrencePeriod')
      else if (child.localName = 'occurrenceTiming') then
        value.occurrence := ParseTiming(child, path+'/occurrenceTiming')
      else if (child.localName = 'occurrenceDateTime') then
        value.occurrence := ParseDateTime(child, path+'/occurrenceDateTime')
      else if (child.localName = 'requester') then
        value.requesterList.Add(ParseReference(child, path+'/requester'))
      else if (child.localName = 'requesterLinkId') then
        value.requesterLinkIdList.Add(ParseString(child, path+'/requesterLinkId'))
      else if (child.localName = 'performerType') then
        value.performerTypeList.Add(ParseCodeableConcept(child, path+'/performerType'))
      else if (child.localName = 'performerRole') then
        value.performerRole := ParseCodeableConcept(child, path+'/performerRole')
      else if (child.localName = 'performer') then
        value.performer := ParseReference(child, path+'/performer')
      else if (child.localName = 'performerLinkId') then
        value.performerLinkIdList.Add(ParseString(child, path+'/performerLinkId'))
      else if (child.localName = 'reason') then
        value.reasonList.Add(ParseCodeableReference(child, path+'/reason'))
      else if (child.localName = 'reasonLinkId') then
        value.reasonLinkIdList.Add(ParseString(child, path+'/reasonLinkId'))
      else if (child.localName = 'note') then
        value.noteList.Add(ParseAnnotation(child, path+'/note'))
      else if (child.localName = 'securityLabelNumber') then
        value.securityLabelNumberList.Add(ParseUnsignedInt(child, path+'/securityLabelNumber'))
      else if Not ParseBackboneElementChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeContractTermAction(xml : TXmlBuilder; name : String; value : TFhirContractTermAction);
begin
  if (value = nil) then
    exit;
  composeElementAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeContractTermActionChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeContractTermActionChildren(xml : TXmlBuilder; value : TFhirContractTermAction);
var
  i : integer;
begin
  composeBackboneElementChildren(xml, value);
  if (SummaryOption in [soFull, soData]) then
    ComposeBoolean(xml, 'doNotPerform', value.doNotPerformElement);
  ComposeCodeableConcept(xml, 'type', value.type_);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.subjectList.Count - 1 do
      ComposeContractTermActionSubject(xml, 'subject', value.subjectList[i]);
  ComposeCodeableConcept(xml, 'intent', value.intent);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.linkIdList.Count - 1 do
      ComposeString(xml, 'linkId', value.linkIdList[i]);
  ComposeCodeableConcept(xml, 'status', value.status);
  if (SummaryOption in [soFull, soData]) then
    ComposeReference(xml, 'context', value.context);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.contextLinkIdList.Count - 1 do
      ComposeString(xml, 'contextLinkId', value.contextLinkIdList[i]);
  if (SummaryOption in [soFull, soData]) and (value.occurrence is TFhirPeriod) {6} then
    ComposePeriod(xml, 'occurrencePeriod', TFhirPeriod(value.occurrence))
  else if (SummaryOption in [soFull, soData]) and (value.occurrence is TFhirTiming) {6} then
    ComposeTiming(xml, 'occurrenceTiming', TFhirTiming(value.occurrence))
  else if (SummaryOption in [soFull, soData]) and (value.occurrence is TFhirDateTime) {6} then
    ComposeDateTime(xml, 'occurrenceDateTime', TFhirDateTime(value.occurrence));
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.requesterList.Count - 1 do
      ComposeReference(xml, 'requester', value.requesterList[i]);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.requesterLinkIdList.Count - 1 do
      ComposeString(xml, 'requesterLinkId', value.requesterLinkIdList[i]);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.performerTypeList.Count - 1 do
      ComposeCodeableConcept(xml, 'performerType', value.performerTypeList[i]);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(xml, 'performerRole', value.performerRole);
  if (SummaryOption in [soFull, soData]) then
    ComposeReference(xml, 'performer', value.performer);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.performerLinkIdList.Count - 1 do
      ComposeString(xml, 'performerLinkId', value.performerLinkIdList[i]);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.reasonList.Count - 1 do
      ComposeCodeableReference(xml, 'reason', value.reasonList[i]);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.reasonLinkIdList.Count - 1 do
      ComposeString(xml, 'reasonLinkId', value.reasonLinkIdList[i]);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.noteList.Count - 1 do
      ComposeAnnotation(xml, 'note', value.noteList[i]);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.securityLabelNumberList.Count - 1 do
      ComposeUnsignedInt(xml, 'securityLabelNumber', value.securityLabelNumberList[i]);
end;

function TFHIRXmlParser.ParseContractTermActionSubject(element : TMXmlElement; path : string) : TFhirContractTermActionSubject;
var
  child : TMXmlElement;
begin
  result := TFhirContractTermActionSubject.Create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseContractTermActionSubjectChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseContractTermActionSubjectChild(value : TFhirContractTermActionSubject; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'reference') then
        value.referenceList.Add(ParseReference(child, path+'/reference'))
      else if (child.localName = 'role') then
        value.role := ParseCodeableConcept(child, path+'/role')
      else if Not ParseBackboneElementChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeContractTermActionSubject(xml : TXmlBuilder; name : String; value : TFhirContractTermActionSubject);
begin
  if (value = nil) then
    exit;
  composeElementAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeContractTermActionSubjectChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeContractTermActionSubjectChildren(xml : TXmlBuilder; value : TFhirContractTermActionSubject);
var
  i : integer;
begin
  composeBackboneElementChildren(xml, value);
  for i := 0 to value.referenceList.Count - 1 do
      ComposeReference(xml, 'reference', value.referenceList[i]);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(xml, 'role', value.role);
end;

function TFHIRXmlParser.ParseContractSigner(element : TMXmlElement; path : string) : TFhirContractSigner;
var
  child : TMXmlElement;
begin
  result := TFhirContractSigner.Create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseContractSignerChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseContractSignerChild(value : TFhirContractSigner; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'type') then
        value.type_ := ParseCoding(child, path+'/type')
      else if (child.localName = 'party') then
        value.party := ParseReference(child, path+'/party')
      else if (child.localName = 'signature') then
        value.signatureList.Add(ParseSignature(child, path+'/signature'))
      else if Not ParseBackboneElementChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeContractSigner(xml : TXmlBuilder; name : String; value : TFhirContractSigner);
begin
  if (value = nil) then
    exit;
  composeElementAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeContractSignerChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeContractSignerChildren(xml : TXmlBuilder; value : TFhirContractSigner);
var
  i : integer;
begin
  composeBackboneElementChildren(xml, value);
  ComposeCoding(xml, 'type', value.type_);
  ComposeReference(xml, 'party', value.party);
  for i := 0 to value.signatureList.Count - 1 do
      ComposeSignature(xml, 'signature', value.signatureList[i]);
end;

function TFHIRXmlParser.ParseContractFriendly(element : TMXmlElement; path : string) : TFhirContractFriendly;
var
  child : TMXmlElement;
begin
  result := TFhirContractFriendly.Create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseContractFriendlyChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseContractFriendlyChild(value : TFhirContractFriendly; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'contentAttachment') then
        value.content := ParseAttachment(child, path+'/contentAttachment')
      else if (child.localName = 'contentReference') then
        value.content := ParseReference(child, path+'/contentReference')
      else if Not ParseBackboneElementChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeContractFriendly(xml : TXmlBuilder; name : String; value : TFhirContractFriendly);
begin
  if (value = nil) then
    exit;
  composeElementAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeContractFriendlyChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeContractFriendlyChildren(xml : TXmlBuilder; value : TFhirContractFriendly);
begin
  composeBackboneElementChildren(xml, value);
  if (value.content is TFhirAttachment) {6} then
    ComposeAttachment(xml, 'contentAttachment', TFhirAttachment(value.content))
  else if (value.content is TFhirReference) {2} then
    ComposeReference(xml, 'contentReference', TFhirReference(value.content));
end;

function TFHIRXmlParser.ParseContractLegal(element : TMXmlElement; path : string) : TFhirContractLegal;
var
  child : TMXmlElement;
begin
  result := TFhirContractLegal.Create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseContractLegalChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseContractLegalChild(value : TFhirContractLegal; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'contentAttachment') then
        value.content := ParseAttachment(child, path+'/contentAttachment')
      else if (child.localName = 'contentReference') then
        value.content := ParseReference(child, path+'/contentReference')
      else if Not ParseBackboneElementChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeContractLegal(xml : TXmlBuilder; name : String; value : TFhirContractLegal);
begin
  if (value = nil) then
    exit;
  composeElementAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeContractLegalChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeContractLegalChildren(xml : TXmlBuilder; value : TFhirContractLegal);
begin
  composeBackboneElementChildren(xml, value);
  if (value.content is TFhirAttachment) {6} then
    ComposeAttachment(xml, 'contentAttachment', TFhirAttachment(value.content))
  else if (value.content is TFhirReference) {2} then
    ComposeReference(xml, 'contentReference', TFhirReference(value.content));
end;

function TFHIRXmlParser.ParseContractRule(element : TMXmlElement; path : string) : TFhirContractRule;
var
  child : TMXmlElement;
begin
  result := TFhirContractRule.Create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseContractRuleChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseContractRuleChild(value : TFhirContractRule; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'contentAttachment') then
        value.content := ParseAttachment(child, path+'/contentAttachment')
      else if (child.localName = 'contentReference') then
        value.content := ParseReference(child, path+'/contentReference')
      else if Not ParseBackboneElementChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeContractRule(xml : TXmlBuilder; name : String; value : TFhirContractRule);
begin
  if (value = nil) then
    exit;
  composeElementAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeContractRuleChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeContractRuleChildren(xml : TXmlBuilder; value : TFhirContractRule);
begin
  composeBackboneElementChildren(xml, value);
  if (value.content is TFhirAttachment) {6} then
    ComposeAttachment(xml, 'contentAttachment', TFhirAttachment(value.content))
  else if (value.content is TFhirReference) {2} then
    ComposeReference(xml, 'contentReference', TFhirReference(value.content));
end;

function TFHIRXmlParser.ParseContract(element : TMXmlElement; path : string) : TFhirContract;
var
  child : TMXmlElement;
begin
  result := TFhirContract.Create;
  try
    parseDomainResourceAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseContractChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseContractChild(value : TFhirContract; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'identifier') then
        value.identifierList.Add(ParseIdentifier(child, path+'/identifier'))
      else if (child.localName = 'url') then
        value.urlElement := ParseUri(child, path+'/url')
      else if (child.localName = 'version') then
        value.versionElement := ParseString(child, path+'/version')
      else if (child.localName = 'status') then
        value.statusElement := ParseEnum(CODES_TFhirContractResourceStatusCodesEnum, SYSTEMS_TFhirContractResourceStatusCodesEnum, child, path+'/status')
      else if (child.localName = 'legalState') then
        value.legalState := ParseCodeableConcept(child, path+'/legalState')
      else if (child.localName = 'instantiatesCanonical') then
        value.instantiatesCanonical := ParseReference(child, path+'/instantiatesCanonical')
      else if (child.localName = 'instantiatesUri') then
        value.instantiatesUriElement := ParseUri(child, path+'/instantiatesUri')
      else if (child.localName = 'contentDerivative') then
        value.contentDerivative := ParseCodeableConcept(child, path+'/contentDerivative')
      else if (child.localName = 'issued') then
        value.issuedElement := ParseDateTime(child, path+'/issued')
      else if (child.localName = 'applies') then
        value.applies := ParsePeriod(child, path+'/applies')
      else if (child.localName = 'expirationType') then
        value.expirationType := ParseCodeableConcept(child, path+'/expirationType')
      else if (child.localName = 'subject') then
        value.subjectList.Add(ParseReference(child, path+'/subject'))
      else if (child.localName = 'authority') then
        value.authorityList.Add(ParseReference(child, path+'/authority'))
      else if (child.localName = 'domain') then
        value.domainList.Add(ParseReference(child, path+'/domain'))
      else if (child.localName = 'site') then
        value.siteList.Add(ParseReference(child, path+'/site'))
      else if (child.localName = 'name') then
        value.nameElement := ParseString(child, path+'/name')
      else if (child.localName = 'title') then
        value.titleElement := ParseString(child, path+'/title')
      else if (child.localName = 'subtitle') then
        value.subtitleElement := ParseString(child, path+'/subtitle')
      else if (child.localName = 'alias') then
        value.aliasList.Add(ParseString(child, path+'/alias'))
      else if (child.localName = 'author') then
        value.author := ParseReference(child, path+'/author')
      else if (child.localName = 'scope') then
        value.scope := ParseCodeableConcept(child, path+'/scope')
      else if (child.localName = 'topicCodeableConcept') then
        value.topic := ParseCodeableConcept(child, path+'/topicCodeableConcept')
      else if (child.localName = 'topicReference') then
        value.topic := ParseReference(child, path+'/topicReference')
      else if (child.localName = 'type') then
        value.type_ := ParseCodeableConcept(child, path+'/type')
      else if (child.localName = 'subType') then
        value.subTypeList.Add(ParseCodeableConcept(child, path+'/subType'))
      else if (child.localName = 'contentDefinition') then
        value.contentDefinition := ParseContractContentDefinition(child, path+'/contentDefinition')
      else if (child.localName = 'term') then
        value.termList.Add(ParseContractTerm(child, path+'/term'))
      else if (child.localName = 'supportingInfo') then
        value.supportingInfoList.Add(ParseReference(child, path+'/supportingInfo'))
      else if (child.localName = 'relevantHistory') then
        value.relevantHistoryList.Add(ParseReference(child, path+'/relevantHistory'))
      else if (child.localName = 'signer') then
        value.signerList.Add(ParseContractSigner(child, path+'/signer'))
      else if (child.localName = 'friendly') then
        value.friendlyList.Add(ParseContractFriendly(child, path+'/friendly'))
      else if (child.localName = 'legal') then
        value.legalList.Add(ParseContractLegal(child, path+'/legal'))
      else if (child.localName = 'rule') then
        value.ruleList.Add(ParseContractRule(child, path+'/rule'))
      else if (child.localName = 'legallyBindingAttachment') then
        value.legallyBinding := ParseAttachment(child, path+'/legallyBindingAttachment')
      else if (child.localName = 'legallyBindingReference') then
        value.legallyBinding := ParseReference(child, path+'/legallyBindingReference')
      else if Not ParseDomainResourceChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeContract(xml : TXmlBuilder; name : String; value : TFhirContract);
begin
  if (value = nil) then
    exit;
  composeDomainResourceAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeContractChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeContractChildren(xml : TXmlBuilder; value : TFhirContract);
var
  i : integer;
begin
  composeDomainResourceChildren(xml, value);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.identifierList.Count - 1 do
      ComposeIdentifier(xml, 'identifier', value.identifierList[i]);
  if (SummaryOption in [soFull, soData]) then
    ComposeUri(xml, 'url', value.urlElement);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(xml, 'version', value.versionElement);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeEnum(xml, 'status', value.statusElement, CODES_TFhirContractResourceStatusCodesEnum);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(xml, 'legalState', value.legalState);
  if (SummaryOption in [soFull, soData]) then
    ComposeReference(xml, 'instantiatesCanonical', value.instantiatesCanonical);
  if (SummaryOption in [soFull, soData]) then
    ComposeUri(xml, 'instantiatesUri', value.instantiatesUriElement);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(xml, 'contentDerivative', value.contentDerivative);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDateTime(xml, 'issued', value.issuedElement);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposePeriod(xml, 'applies', value.applies);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(xml, 'expirationType', value.expirationType);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.subjectList.Count - 1 do
      ComposeReference(xml, 'subject', value.subjectList[i]);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.authorityList.Count - 1 do
      ComposeReference(xml, 'authority', value.authorityList[i]);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.domainList.Count - 1 do
      ComposeReference(xml, 'domain', value.domainList[i]);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.siteList.Count - 1 do
      ComposeReference(xml, 'site', value.siteList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(xml, 'name', value.nameElement);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(xml, 'title', value.titleElement);
  if (SummaryOption in [soFull, soData]) then
    ComposeString(xml, 'subtitle', value.subtitleElement);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.aliasList.Count - 1 do
      ComposeString(xml, 'alias', value.aliasList[i]);
  if (SummaryOption in [soFull, soData]) then
    ComposeReference(xml, 'author', value.author);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(xml, 'scope', value.scope);
  if (SummaryOption in [soFull, soData]) and (value.topic is TFhirCodeableConcept) {6} then
    ComposeCodeableConcept(xml, 'topicCodeableConcept', TFhirCodeableConcept(value.topic))
  else if (SummaryOption in [soFull, soData]) and (value.topic is TFhirReference) {2} then
    ComposeReference(xml, 'topicReference', TFhirReference(value.topic));
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(xml, 'type', value.type_);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.subTypeList.Count - 1 do
      ComposeCodeableConcept(xml, 'subType', value.subTypeList[i]);
  if (SummaryOption in [soFull, soData]) then
    ComposeContractContentDefinition(xml, 'contentDefinition', value.contentDefinition);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.termList.Count - 1 do
      ComposeContractTerm(xml, 'term', value.termList[i]);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.supportingInfoList.Count - 1 do
      ComposeReference(xml, 'supportingInfo', value.supportingInfoList[i]);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.relevantHistoryList.Count - 1 do
      ComposeReference(xml, 'relevantHistory', value.relevantHistoryList[i]);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.signerList.Count - 1 do
      ComposeContractSigner(xml, 'signer', value.signerList[i]);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.friendlyList.Count - 1 do
      ComposeContractFriendly(xml, 'friendly', value.friendlyList[i]);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.legalList.Count - 1 do
      ComposeContractLegal(xml, 'legal', value.legalList[i]);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.ruleList.Count - 1 do
      ComposeContractRule(xml, 'rule', value.ruleList[i]);
  if (SummaryOption in [soFull, soData]) and (value.legallyBinding is TFhirAttachment) {6} then
    ComposeAttachment(xml, 'legallyBindingAttachment', TFhirAttachment(value.legallyBinding))
  else if (SummaryOption in [soFull, soData]) and (value.legallyBinding is TFhirReference) {2} then
    ComposeReference(xml, 'legallyBindingReference', TFhirReference(value.legallyBinding));
end;

{$ENDIF FHIR_CONTRACT}
{$IFDEF FHIR_COVERAGE}
function TFHIRXmlParser.ParseCoveragePaymentBy(element : TMXmlElement; path : string) : TFhirCoveragePaymentBy;
var
  child : TMXmlElement;
begin
  result := TFhirCoveragePaymentBy.Create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseCoveragePaymentByChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseCoveragePaymentByChild(value : TFhirCoveragePaymentBy; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'party') then
        value.party := ParseReference(child, path+'/party')
      else if (child.localName = 'responsibility') then
        value.responsibilityElement := ParseString(child, path+'/responsibility')
      else if Not ParseBackboneElementChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeCoveragePaymentBy(xml : TXmlBuilder; name : String; value : TFhirCoveragePaymentBy);
begin
  if (value = nil) then
    exit;
  composeElementAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeCoveragePaymentByChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeCoveragePaymentByChildren(xml : TXmlBuilder; value : TFhirCoveragePaymentBy);
begin
  composeBackboneElementChildren(xml, value);
  ComposeReference(xml, 'party', value.party);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(xml, 'responsibility', value.responsibilityElement);
end;

function TFHIRXmlParser.ParseCoverageClass(element : TMXmlElement; path : string) : TFhirCoverageClass;
var
  child : TMXmlElement;
begin
  result := TFhirCoverageClass.Create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseCoverageClassChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseCoverageClassChild(value : TFhirCoverageClass; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'type') then
        value.type_ := ParseCodeableConcept(child, path+'/type')
      else if (child.localName = 'value') then
        value.value := ParseIdentifier(child, path+'/value')
      else if (child.localName = 'name') then
        value.nameElement := ParseString(child, path+'/name')
      else if Not ParseBackboneElementChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeCoverageClass(xml : TXmlBuilder; name : String; value : TFhirCoverageClass);
begin
  if (value = nil) then
    exit;
  composeElementAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeCoverageClassChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeCoverageClassChildren(xml : TXmlBuilder; value : TFhirCoverageClass);
begin
  composeBackboneElementChildren(xml, value);
  ComposeCodeableConcept(xml, 'type', value.type_);
  ComposeIdentifier(xml, 'value', value.value);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(xml, 'name', value.nameElement);
end;

function TFHIRXmlParser.ParseCoverageCostToBeneficiary(element : TMXmlElement; path : string) : TFhirCoverageCostToBeneficiary;
var
  child : TMXmlElement;
begin
  result := TFhirCoverageCostToBeneficiary.Create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseCoverageCostToBeneficiaryChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseCoverageCostToBeneficiaryChild(value : TFhirCoverageCostToBeneficiary; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'type') then
        value.type_ := ParseCodeableConcept(child, path+'/type')
      else if (child.localName = 'category') then
        value.category := ParseCodeableConcept(child, path+'/category')
      else if (child.localName = 'network') then
        value.network := ParseCodeableConcept(child, path+'/network')
      else if (child.localName = 'unit') then
        value.unit_ := ParseCodeableConcept(child, path+'/unit')
      else if (child.localName = 'term') then
        value.term := ParseCodeableConcept(child, path+'/term')
      else if (child.localName = 'valueQuantity') then
        value.value := ParseQuantity(child, path+'/valueQuantity')
      else if (child.localName = 'valueMoney') then
        value.value := ParseMoney(child, path+'/valueMoney')
      else if (child.localName = 'exception') then
        value.exceptionList.Add(ParseCoverageCostToBeneficiaryException(child, path+'/exception'))
      else if Not ParseBackboneElementChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeCoverageCostToBeneficiary(xml : TXmlBuilder; name : String; value : TFhirCoverageCostToBeneficiary);
begin
  if (value = nil) then
    exit;
  composeElementAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeCoverageCostToBeneficiaryChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeCoverageCostToBeneficiaryChildren(xml : TXmlBuilder; value : TFhirCoverageCostToBeneficiary);
var
  i : integer;
begin
  composeBackboneElementChildren(xml, value);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(xml, 'type', value.type_);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(xml, 'category', value.category);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(xml, 'network', value.network);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(xml, 'unit', value.unit_);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(xml, 'term', value.term);
  if (SummaryOption in [soFull, soSummary, soData]) and (value.value is TFhirQuantity) {6} then
    ComposeQuantity(xml, 'valueQuantity', TFhirQuantity(value.value))
  else if (SummaryOption in [soFull, soSummary, soData]) and (value.value is TFhirMoney) {6} then
    ComposeMoney(xml, 'valueMoney', TFhirMoney(value.value));
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.exceptionList.Count - 1 do
      ComposeCoverageCostToBeneficiaryException(xml, 'exception', value.exceptionList[i]);
end;

function TFHIRXmlParser.ParseCoverageCostToBeneficiaryException(element : TMXmlElement; path : string) : TFhirCoverageCostToBeneficiaryException;
var
  child : TMXmlElement;
begin
  result := TFhirCoverageCostToBeneficiaryException.Create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseCoverageCostToBeneficiaryExceptionChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseCoverageCostToBeneficiaryExceptionChild(value : TFhirCoverageCostToBeneficiaryException; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'type') then
        value.type_ := ParseCodeableConcept(child, path+'/type')
      else if (child.localName = 'period') then
        value.period := ParsePeriod(child, path+'/period')
      else if Not ParseBackboneElementChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeCoverageCostToBeneficiaryException(xml : TXmlBuilder; name : String; value : TFhirCoverageCostToBeneficiaryException);
begin
  if (value = nil) then
    exit;
  composeElementAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeCoverageCostToBeneficiaryExceptionChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeCoverageCostToBeneficiaryExceptionChildren(xml : TXmlBuilder; value : TFhirCoverageCostToBeneficiaryException);
begin
  composeBackboneElementChildren(xml, value);
  ComposeCodeableConcept(xml, 'type', value.type_);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposePeriod(xml, 'period', value.period);
end;

function TFHIRXmlParser.ParseCoverage(element : TMXmlElement; path : string) : TFhirCoverage;
var
  child : TMXmlElement;
begin
  result := TFhirCoverage.Create;
  try
    parseDomainResourceAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseCoverageChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseCoverageChild(value : TFhirCoverage; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'identifier') then
        value.identifierList.Add(ParseIdentifier(child, path+'/identifier'))
      else if (child.localName = 'status') then
        value.statusElement := ParseEnum(CODES_TFhirFinancialResourceStatusCodesEnum, SYSTEMS_TFhirFinancialResourceStatusCodesEnum, child, path+'/status')
      else if (child.localName = 'kind') then
        value.kindElement := ParseEnum(CODES_TFhirKindEnum, SYSTEMS_TFhirKindEnum, child, path+'/kind')
      else if (child.localName = 'paymentBy') then
        value.paymentByList.Add(ParseCoveragePaymentBy(child, path+'/paymentBy'))
      else if (child.localName = 'type') then
        value.type_ := ParseCodeableConcept(child, path+'/type')
      else if (child.localName = 'policyHolder') then
        value.policyHolder := ParseReference(child, path+'/policyHolder')
      else if (child.localName = 'subscriber') then
        value.subscriber := ParseReference(child, path+'/subscriber')
      else if (child.localName = 'subscriberId') then
        value.subscriberIdList.Add(ParseIdentifier(child, path+'/subscriberId'))
      else if (child.localName = 'beneficiary') then
        value.beneficiary := ParseReference(child, path+'/beneficiary')
      else if (child.localName = 'dependent') then
        value.dependentElement := ParseString(child, path+'/dependent')
      else if (child.localName = 'relationship') then
        value.relationship := ParseCodeableConcept(child, path+'/relationship')
      else if (child.localName = 'period') then
        value.period := ParsePeriod(child, path+'/period')
      else if (child.localName = 'insurer') then
        value.insurer := ParseReference(child, path+'/insurer')
      else if (child.localName = 'class') then
        value.class_List.Add(ParseCoverageClass(child, path+'/class'))
      else if (child.localName = 'order') then
        value.orderElement := ParsePositiveInt(child, path+'/order')
      else if (child.localName = 'network') then
        value.networkElement := ParseString(child, path+'/network')
      else if (child.localName = 'costToBeneficiary') then
        value.costToBeneficiaryList.Add(ParseCoverageCostToBeneficiary(child, path+'/costToBeneficiary'))
      else if (child.localName = 'subrogation') then
        value.subrogationElement := ParseBoolean(child, path+'/subrogation')
      else if (child.localName = 'contract') then
        value.contractList.Add(ParseReference(child, path+'/contract'))
      else if (child.localName = 'insurancePlan') then
        value.insurancePlan := ParseReference(child, path+'/insurancePlan')
      else if Not ParseDomainResourceChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeCoverage(xml : TXmlBuilder; name : String; value : TFhirCoverage);
begin
  if (value = nil) then
    exit;
  composeDomainResourceAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeCoverageChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeCoverageChildren(xml : TXmlBuilder; value : TFhirCoverage);
var
  i : integer;
begin
  composeDomainResourceChildren(xml, value);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.identifierList.Count - 1 do
      ComposeIdentifier(xml, 'identifier', value.identifierList[i]);
  ComposeEnum(xml, 'status', value.statusElement, CODES_TFhirFinancialResourceStatusCodesEnum);
  ComposeEnum(xml, 'kind', value.kindElement, CODES_TFhirKindEnum);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.paymentByList.Count - 1 do
      ComposeCoveragePaymentBy(xml, 'paymentBy', value.paymentByList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(xml, 'type', value.type_);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference(xml, 'policyHolder', value.policyHolder);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference(xml, 'subscriber', value.subscriber);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.subscriberIdList.Count - 1 do
      ComposeIdentifier(xml, 'subscriberId', value.subscriberIdList[i]);
  ComposeReference(xml, 'beneficiary', value.beneficiary);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(xml, 'dependent', value.dependentElement);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(xml, 'relationship', value.relationship);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposePeriod(xml, 'period', value.period);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference(xml, 'insurer', value.insurer);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.class_List.Count - 1 do
      ComposeCoverageClass(xml, 'class', value.class_List[i]);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposePositiveInt(xml, 'order', value.orderElement);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(xml, 'network', value.networkElement);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.costToBeneficiaryList.Count - 1 do
      ComposeCoverageCostToBeneficiary(xml, 'costToBeneficiary', value.costToBeneficiaryList[i]);
  if (SummaryOption in [soFull, soData]) then
    ComposeBoolean(xml, 'subrogation', value.subrogationElement);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.contractList.Count - 1 do
      ComposeReference(xml, 'contract', value.contractList[i]);
  if (SummaryOption in [soFull, soData]) then
    ComposeReference(xml, 'insurancePlan', value.insurancePlan);
end;

{$ENDIF FHIR_COVERAGE}
{$IFDEF FHIR_COVERAGEELIGIBILITYREQUEST}
function TFHIRXmlParser.ParseCoverageEligibilityRequestSupportingInfo(element : TMXmlElement; path : string) : TFhirCoverageEligibilityRequestSupportingInfo;
var
  child : TMXmlElement;
begin
  result := TFhirCoverageEligibilityRequestSupportingInfo.Create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseCoverageEligibilityRequestSupportingInfoChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseCoverageEligibilityRequestSupportingInfoChild(value : TFhirCoverageEligibilityRequestSupportingInfo; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'sequence') then
        value.sequenceElement := ParsePositiveInt(child, path+'/sequence')
      else if (child.localName = 'information') then
        value.information := ParseReference(child, path+'/information')
      else if (child.localName = 'appliesToAll') then
        value.appliesToAllElement := ParseBoolean(child, path+'/appliesToAll')
      else if Not ParseBackboneElementChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeCoverageEligibilityRequestSupportingInfo(xml : TXmlBuilder; name : String; value : TFhirCoverageEligibilityRequestSupportingInfo);
begin
  if (value = nil) then
    exit;
  composeElementAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeCoverageEligibilityRequestSupportingInfoChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeCoverageEligibilityRequestSupportingInfoChildren(xml : TXmlBuilder; value : TFhirCoverageEligibilityRequestSupportingInfo);
begin
  composeBackboneElementChildren(xml, value);
  ComposePositiveInt(xml, 'sequence', value.sequenceElement);
  ComposeReference(xml, 'information', value.information);
  if (SummaryOption in [soFull, soData]) then
    ComposeBoolean(xml, 'appliesToAll', value.appliesToAllElement);
end;

function TFHIRXmlParser.ParseCoverageEligibilityRequestInsurance(element : TMXmlElement; path : string) : TFhirCoverageEligibilityRequestInsurance;
var
  child : TMXmlElement;
begin
  result := TFhirCoverageEligibilityRequestInsurance.Create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseCoverageEligibilityRequestInsuranceChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseCoverageEligibilityRequestInsuranceChild(value : TFhirCoverageEligibilityRequestInsurance; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'focal') then
        value.focalElement := ParseBoolean(child, path+'/focal')
      else if (child.localName = 'coverage') then
        value.coverage := ParseReference(child, path+'/coverage')
      else if (child.localName = 'businessArrangement') then
        value.businessArrangementElement := ParseString(child, path+'/businessArrangement')
      else if Not ParseBackboneElementChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeCoverageEligibilityRequestInsurance(xml : TXmlBuilder; name : String; value : TFhirCoverageEligibilityRequestInsurance);
begin
  if (value = nil) then
    exit;
  composeElementAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeCoverageEligibilityRequestInsuranceChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeCoverageEligibilityRequestInsuranceChildren(xml : TXmlBuilder; value : TFhirCoverageEligibilityRequestInsurance);
begin
  composeBackboneElementChildren(xml, value);
  if (SummaryOption in [soFull, soData]) then
    ComposeBoolean(xml, 'focal', value.focalElement);
  ComposeReference(xml, 'coverage', value.coverage);
  if (SummaryOption in [soFull, soData]) then
    ComposeString(xml, 'businessArrangement', value.businessArrangementElement);
end;

function TFHIRXmlParser.ParseCoverageEligibilityRequestItem(element : TMXmlElement; path : string) : TFhirCoverageEligibilityRequestItem;
var
  child : TMXmlElement;
begin
  result := TFhirCoverageEligibilityRequestItem.Create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseCoverageEligibilityRequestItemChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseCoverageEligibilityRequestItemChild(value : TFhirCoverageEligibilityRequestItem; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'supportingInfoSequence') then
        value.supportingInfoSequenceList.Add(ParsePositiveInt(child, path+'/supportingInfoSequence'))
      else if (child.localName = 'category') then
        value.category := ParseCodeableConcept(child, path+'/category')
      else if (child.localName = 'productOrService') then
        value.productOrService := ParseCodeableConcept(child, path+'/productOrService')
      else if (child.localName = 'modifier') then
        value.modifierList.Add(ParseCodeableConcept(child, path+'/modifier'))
      else if (child.localName = 'provider') then
        value.provider := ParseReference(child, path+'/provider')
      else if (child.localName = 'quantity') then
        value.quantity := ParseQuantity(child, path+'/quantity')
      else if (child.localName = 'unitPrice') then
        value.unitPrice := ParseMoney(child, path+'/unitPrice')
      else if (child.localName = 'facility') then
        value.facility := ParseReference(child, path+'/facility')
      else if (child.localName = 'diagnosis') then
        value.diagnosisList.Add(ParseCoverageEligibilityRequestItemDiagnosis(child, path+'/diagnosis'))
      else if (child.localName = 'detail') then
        value.detailList.Add(ParseReference(child, path+'/detail'))
      else if Not ParseBackboneElementChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeCoverageEligibilityRequestItem(xml : TXmlBuilder; name : String; value : TFhirCoverageEligibilityRequestItem);
begin
  if (value = nil) then
    exit;
  composeElementAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeCoverageEligibilityRequestItemChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeCoverageEligibilityRequestItemChildren(xml : TXmlBuilder; value : TFhirCoverageEligibilityRequestItem);
var
  i : integer;
begin
  composeBackboneElementChildren(xml, value);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.supportingInfoSequenceList.Count - 1 do
      ComposePositiveInt(xml, 'supportingInfoSequence', value.supportingInfoSequenceList[i]);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(xml, 'category', value.category);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(xml, 'productOrService', value.productOrService);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.modifierList.Count - 1 do
      ComposeCodeableConcept(xml, 'modifier', value.modifierList[i]);
  if (SummaryOption in [soFull, soData]) then
    ComposeReference(xml, 'provider', value.provider);
  if (SummaryOption in [soFull, soData]) then
    ComposeQuantity(xml, 'quantity', value.quantity);
  if (SummaryOption in [soFull, soData]) then
    ComposeMoney(xml, 'unitPrice', value.unitPrice);
  if (SummaryOption in [soFull, soData]) then
    ComposeReference(xml, 'facility', value.facility);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.diagnosisList.Count - 1 do
      ComposeCoverageEligibilityRequestItemDiagnosis(xml, 'diagnosis', value.diagnosisList[i]);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.detailList.Count - 1 do
      ComposeReference(xml, 'detail', value.detailList[i]);
end;

function TFHIRXmlParser.ParseCoverageEligibilityRequestItemDiagnosis(element : TMXmlElement; path : string) : TFhirCoverageEligibilityRequestItemDiagnosis;
var
  child : TMXmlElement;
begin
  result := TFhirCoverageEligibilityRequestItemDiagnosis.Create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseCoverageEligibilityRequestItemDiagnosisChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseCoverageEligibilityRequestItemDiagnosisChild(value : TFhirCoverageEligibilityRequestItemDiagnosis; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'diagnosisCodeableConcept') then
        value.diagnosis := ParseCodeableConcept(child, path+'/diagnosisCodeableConcept')
      else if (child.localName = 'diagnosisReference') then
        value.diagnosis := ParseReference(child, path+'/diagnosisReference')
      else if Not ParseBackboneElementChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeCoverageEligibilityRequestItemDiagnosis(xml : TXmlBuilder; name : String; value : TFhirCoverageEligibilityRequestItemDiagnosis);
begin
  if (value = nil) then
    exit;
  composeElementAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeCoverageEligibilityRequestItemDiagnosisChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeCoverageEligibilityRequestItemDiagnosisChildren(xml : TXmlBuilder; value : TFhirCoverageEligibilityRequestItemDiagnosis);
begin
  composeBackboneElementChildren(xml, value);
  if (SummaryOption in [soFull, soData]) and (value.diagnosis is TFhirCodeableConcept) {6} then
    ComposeCodeableConcept(xml, 'diagnosisCodeableConcept', TFhirCodeableConcept(value.diagnosis))
  else if (SummaryOption in [soFull, soData]) and (value.diagnosis is TFhirReference) {2} then
    ComposeReference(xml, 'diagnosisReference', TFhirReference(value.diagnosis));
end;

function TFHIRXmlParser.ParseCoverageEligibilityRequest(element : TMXmlElement; path : string) : TFhirCoverageEligibilityRequest;
var
  child : TMXmlElement;
begin
  result := TFhirCoverageEligibilityRequest.Create;
  try
    parseDomainResourceAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseCoverageEligibilityRequestChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseCoverageEligibilityRequestChild(value : TFhirCoverageEligibilityRequest; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'identifier') then
        value.identifierList.Add(ParseIdentifier(child, path+'/identifier'))
      else if (child.localName = 'status') then
        value.statusElement := ParseEnum(CODES_TFhirFinancialResourceStatusCodesEnum, SYSTEMS_TFhirFinancialResourceStatusCodesEnum, child, path+'/status')
      else if (child.localName = 'priority') then
        value.priority := ParseCodeableConcept(child, path+'/priority')
      else if (child.localName = 'purpose') then
        value.purposeList.Add(ParseEnum(CODES_TFhirEligibilityRequestPurposeEnum, SYSTEMS_TFhirEligibilityRequestPurposeEnum, child, path+'/purpose')){y.1}
      else if (child.localName = 'patient') then
        value.patient := ParseReference(child, path+'/patient')
      else if (child.localName = 'servicedPeriod') then
        value.serviced := ParsePeriod(child, path+'/servicedPeriod')
      else if (child.localName = 'servicedDate') then
        value.serviced := ParseDate(child, path+'/servicedDate')
      else if (child.localName = 'created') then
        value.createdElement := ParseDateTime(child, path+'/created')
      else if (child.localName = 'enterer') then
        value.enterer := ParseReference(child, path+'/enterer')
      else if (child.localName = 'provider') then
        value.provider := ParseReference(child, path+'/provider')
      else if (child.localName = 'insurer') then
        value.insurer := ParseReference(child, path+'/insurer')
      else if (child.localName = 'facility') then
        value.facility := ParseReference(child, path+'/facility')
      else if (child.localName = 'supportingInfo') then
        value.supportingInfoList.Add(ParseCoverageEligibilityRequestSupportingInfo(child, path+'/supportingInfo'))
      else if (child.localName = 'insurance') then
        value.insuranceList.Add(ParseCoverageEligibilityRequestInsurance(child, path+'/insurance'))
      else if (child.localName = 'item') then
        value.itemList.Add(ParseCoverageEligibilityRequestItem(child, path+'/item'))
      else if Not ParseDomainResourceChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeCoverageEligibilityRequest(xml : TXmlBuilder; name : String; value : TFhirCoverageEligibilityRequest);
begin
  if (value = nil) then
    exit;
  composeDomainResourceAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeCoverageEligibilityRequestChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeCoverageEligibilityRequestChildren(xml : TXmlBuilder; value : TFhirCoverageEligibilityRequest);
var
  i : integer;
begin
  composeDomainResourceChildren(xml, value);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.identifierList.Count - 1 do
      ComposeIdentifier(xml, 'identifier', value.identifierList[i]);
  ComposeEnum(xml, 'status', value.statusElement, CODES_TFhirFinancialResourceStatusCodesEnum);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(xml, 'priority', value.priority);
  for i := 0 to value.purposeList.Count - 1 do
      ComposeEnum(xml, 'purpose', value.purposeList[i], CODES_TFhirEligibilityRequestPurposeEnum);
  ComposeReference(xml, 'patient', value.patient);
  if (SummaryOption in [soFull, soData]) and (value.serviced is TFhirPeriod) {6} then
    ComposePeriod(xml, 'servicedPeriod', TFhirPeriod(value.serviced))
  else if (SummaryOption in [soFull, soData]) and (value.serviced is TFhirDate) {6} then
    ComposeDate(xml, 'servicedDate', TFhirDate(value.serviced));
  ComposeDateTime(xml, 'created', value.createdElement);
  if (SummaryOption in [soFull, soData]) then
    ComposeReference(xml, 'enterer', value.enterer);
  if (SummaryOption in [soFull, soData]) then
    ComposeReference(xml, 'provider', value.provider);
  ComposeReference(xml, 'insurer', value.insurer);
  if (SummaryOption in [soFull, soData]) then
    ComposeReference(xml, 'facility', value.facility);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.supportingInfoList.Count - 1 do
      ComposeCoverageEligibilityRequestSupportingInfo(xml, 'supportingInfo', value.supportingInfoList[i]);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.insuranceList.Count - 1 do
      ComposeCoverageEligibilityRequestInsurance(xml, 'insurance', value.insuranceList[i]);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.itemList.Count - 1 do
      ComposeCoverageEligibilityRequestItem(xml, 'item', value.itemList[i]);
end;

{$ENDIF FHIR_COVERAGEELIGIBILITYREQUEST}
{$IFDEF FHIR_COVERAGEELIGIBILITYRESPONSE}
function TFHIRXmlParser.ParseCoverageEligibilityResponseInsurance(element : TMXmlElement; path : string) : TFhirCoverageEligibilityResponseInsurance;
var
  child : TMXmlElement;
begin
  result := TFhirCoverageEligibilityResponseInsurance.Create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseCoverageEligibilityResponseInsuranceChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseCoverageEligibilityResponseInsuranceChild(value : TFhirCoverageEligibilityResponseInsurance; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'coverage') then
        value.coverage := ParseReference(child, path+'/coverage')
      else if (child.localName = 'inforce') then
        value.inforceElement := ParseBoolean(child, path+'/inforce')
      else if (child.localName = 'benefitPeriod') then
        value.benefitPeriod := ParsePeriod(child, path+'/benefitPeriod')
      else if (child.localName = 'item') then
        value.itemList.Add(ParseCoverageEligibilityResponseInsuranceItem(child, path+'/item'))
      else if Not ParseBackboneElementChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeCoverageEligibilityResponseInsurance(xml : TXmlBuilder; name : String; value : TFhirCoverageEligibilityResponseInsurance);
begin
  if (value = nil) then
    exit;
  composeElementAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeCoverageEligibilityResponseInsuranceChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeCoverageEligibilityResponseInsuranceChildren(xml : TXmlBuilder; value : TFhirCoverageEligibilityResponseInsurance);
var
  i : integer;
begin
  composeBackboneElementChildren(xml, value);
  ComposeReference(xml, 'coverage', value.coverage);
  if (SummaryOption in [soFull, soData]) then
    ComposeBoolean(xml, 'inforce', value.inforceElement);
  if (SummaryOption in [soFull, soData]) then
    ComposePeriod(xml, 'benefitPeriod', value.benefitPeriod);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.itemList.Count - 1 do
      ComposeCoverageEligibilityResponseInsuranceItem(xml, 'item', value.itemList[i]);
end;

function TFHIRXmlParser.ParseCoverageEligibilityResponseInsuranceItem(element : TMXmlElement; path : string) : TFhirCoverageEligibilityResponseInsuranceItem;
var
  child : TMXmlElement;
begin
  result := TFhirCoverageEligibilityResponseInsuranceItem.Create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseCoverageEligibilityResponseInsuranceItemChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseCoverageEligibilityResponseInsuranceItemChild(value : TFhirCoverageEligibilityResponseInsuranceItem; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'category') then
        value.category := ParseCodeableConcept(child, path+'/category')
      else if (child.localName = 'productOrService') then
        value.productOrService := ParseCodeableConcept(child, path+'/productOrService')
      else if (child.localName = 'modifier') then
        value.modifierList.Add(ParseCodeableConcept(child, path+'/modifier'))
      else if (child.localName = 'provider') then
        value.provider := ParseReference(child, path+'/provider')
      else if (child.localName = 'excluded') then
        value.excludedElement := ParseBoolean(child, path+'/excluded')
      else if (child.localName = 'name') then
        value.nameElement := ParseString(child, path+'/name')
      else if (child.localName = 'description') then
        value.descriptionElement := ParseString(child, path+'/description')
      else if (child.localName = 'network') then
        value.network := ParseCodeableConcept(child, path+'/network')
      else if (child.localName = 'unit') then
        value.unit_ := ParseCodeableConcept(child, path+'/unit')
      else if (child.localName = 'term') then
        value.term := ParseCodeableConcept(child, path+'/term')
      else if (child.localName = 'benefit') then
        value.benefitList.Add(ParseCoverageEligibilityResponseInsuranceItemBenefit(child, path+'/benefit'))
      else if (child.localName = 'authorizationRequired') then
        value.authorizationRequiredElement := ParseBoolean(child, path+'/authorizationRequired')
      else if (child.localName = 'authorizationSupporting') then
        value.authorizationSupportingList.Add(ParseCodeableConcept(child, path+'/authorizationSupporting'))
      else if (child.localName = 'authorizationUrl') then
        value.authorizationUrlElement := ParseUri(child, path+'/authorizationUrl')
      else if Not ParseBackboneElementChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeCoverageEligibilityResponseInsuranceItem(xml : TXmlBuilder; name : String; value : TFhirCoverageEligibilityResponseInsuranceItem);
begin
  if (value = nil) then
    exit;
  composeElementAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeCoverageEligibilityResponseInsuranceItemChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeCoverageEligibilityResponseInsuranceItemChildren(xml : TXmlBuilder; value : TFhirCoverageEligibilityResponseInsuranceItem);
var
  i : integer;
begin
  composeBackboneElementChildren(xml, value);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(xml, 'category', value.category);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(xml, 'productOrService', value.productOrService);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.modifierList.Count - 1 do
      ComposeCodeableConcept(xml, 'modifier', value.modifierList[i]);
  if (SummaryOption in [soFull, soData]) then
    ComposeReference(xml, 'provider', value.provider);
  if (SummaryOption in [soFull, soData]) then
    ComposeBoolean(xml, 'excluded', value.excludedElement);
  if (SummaryOption in [soFull, soData]) then
    ComposeString(xml, 'name', value.nameElement);
  if (SummaryOption in [soFull, soData]) then
    ComposeString(xml, 'description', value.descriptionElement);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(xml, 'network', value.network);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(xml, 'unit', value.unit_);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(xml, 'term', value.term);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.benefitList.Count - 1 do
      ComposeCoverageEligibilityResponseInsuranceItemBenefit(xml, 'benefit', value.benefitList[i]);
  if (SummaryOption in [soFull, soData]) then
    ComposeBoolean(xml, 'authorizationRequired', value.authorizationRequiredElement);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.authorizationSupportingList.Count - 1 do
      ComposeCodeableConcept(xml, 'authorizationSupporting', value.authorizationSupportingList[i]);
  if (SummaryOption in [soFull, soData]) then
    ComposeUri(xml, 'authorizationUrl', value.authorizationUrlElement);
end;

function TFHIRXmlParser.ParseCoverageEligibilityResponseInsuranceItemBenefit(element : TMXmlElement; path : string) : TFhirCoverageEligibilityResponseInsuranceItemBenefit;
var
  child : TMXmlElement;
begin
  result := TFhirCoverageEligibilityResponseInsuranceItemBenefit.Create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseCoverageEligibilityResponseInsuranceItemBenefitChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseCoverageEligibilityResponseInsuranceItemBenefitChild(value : TFhirCoverageEligibilityResponseInsuranceItemBenefit; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'type') then
        value.type_ := ParseCodeableConcept(child, path+'/type')
      else if (child.localName = 'allowedUnsignedInt') then
        value.allowed := ParseUnsignedInt(child, path+'/allowedUnsignedInt')
      else if (child.localName = 'allowedMoney') then
        value.allowed := ParseMoney(child, path+'/allowedMoney')
      else if (child.localName = 'allowedString') then
        value.allowed := ParseString(child, path+'/allowedString')
      else if (child.localName = 'usedUnsignedInt') then
        value.used := ParseUnsignedInt(child, path+'/usedUnsignedInt')
      else if (child.localName = 'usedMoney') then
        value.used := ParseMoney(child, path+'/usedMoney')
      else if (child.localName = 'usedString') then
        value.used := ParseString(child, path+'/usedString')
      else if Not ParseBackboneElementChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeCoverageEligibilityResponseInsuranceItemBenefit(xml : TXmlBuilder; name : String; value : TFhirCoverageEligibilityResponseInsuranceItemBenefit);
begin
  if (value = nil) then
    exit;
  composeElementAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeCoverageEligibilityResponseInsuranceItemBenefitChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeCoverageEligibilityResponseInsuranceItemBenefitChildren(xml : TXmlBuilder; value : TFhirCoverageEligibilityResponseInsuranceItemBenefit);
begin
  composeBackboneElementChildren(xml, value);
  ComposeCodeableConcept(xml, 'type', value.type_);
  if (SummaryOption in [soFull, soData]) and (value.allowed is TFhirUnsignedInt) {6} then
    ComposeUnsignedInt(xml, 'allowedUnsignedInt', TFhirUnsignedInt(value.allowed))
  else if (SummaryOption in [soFull, soData]) and (value.allowed is TFhirMoney) {6} then
    ComposeMoney(xml, 'allowedMoney', TFhirMoney(value.allowed))
  else if (SummaryOption in [soFull, soData]) and (value.allowed is TFhirString) {6} then
    ComposeString(xml, 'allowedString', TFhirString(value.allowed));
  if (SummaryOption in [soFull, soData]) and (value.used is TFhirUnsignedInt) {6} then
    ComposeUnsignedInt(xml, 'usedUnsignedInt', TFhirUnsignedInt(value.used))
  else if (SummaryOption in [soFull, soData]) and (value.used is TFhirMoney) {6} then
    ComposeMoney(xml, 'usedMoney', TFhirMoney(value.used))
  else if (SummaryOption in [soFull, soData]) and (value.used is TFhirString) {6} then
    ComposeString(xml, 'usedString', TFhirString(value.used));
end;

function TFHIRXmlParser.ParseCoverageEligibilityResponseError(element : TMXmlElement; path : string) : TFhirCoverageEligibilityResponseError;
var
  child : TMXmlElement;
begin
  result := TFhirCoverageEligibilityResponseError.Create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseCoverageEligibilityResponseErrorChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseCoverageEligibilityResponseErrorChild(value : TFhirCoverageEligibilityResponseError; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'code') then
        value.code := ParseCodeableConcept(child, path+'/code')
      else if Not ParseBackboneElementChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeCoverageEligibilityResponseError(xml : TXmlBuilder; name : String; value : TFhirCoverageEligibilityResponseError);
begin
  if (value = nil) then
    exit;
  composeElementAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeCoverageEligibilityResponseErrorChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeCoverageEligibilityResponseErrorChildren(xml : TXmlBuilder; value : TFhirCoverageEligibilityResponseError);
begin
  composeBackboneElementChildren(xml, value);
  ComposeCodeableConcept(xml, 'code', value.code);
end;

function TFHIRXmlParser.ParseCoverageEligibilityResponse(element : TMXmlElement; path : string) : TFhirCoverageEligibilityResponse;
var
  child : TMXmlElement;
begin
  result := TFhirCoverageEligibilityResponse.Create;
  try
    parseDomainResourceAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseCoverageEligibilityResponseChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseCoverageEligibilityResponseChild(value : TFhirCoverageEligibilityResponse; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'identifier') then
        value.identifierList.Add(ParseIdentifier(child, path+'/identifier'))
      else if (child.localName = 'status') then
        value.statusElement := ParseEnum(CODES_TFhirFinancialResourceStatusCodesEnum, SYSTEMS_TFhirFinancialResourceStatusCodesEnum, child, path+'/status')
      else if (child.localName = 'purpose') then
        value.purposeList.Add(ParseEnum(CODES_TFhirEligibilityResponsePurposeEnum, SYSTEMS_TFhirEligibilityResponsePurposeEnum, child, path+'/purpose')){y.1}
      else if (child.localName = 'patient') then
        value.patient := ParseReference(child, path+'/patient')
      else if (child.localName = 'servicedPeriod') then
        value.serviced := ParsePeriod(child, path+'/servicedPeriod')
      else if (child.localName = 'servicedDate') then
        value.serviced := ParseDate(child, path+'/servicedDate')
      else if (child.localName = 'created') then
        value.createdElement := ParseDateTime(child, path+'/created')
      else if (child.localName = 'requestor') then
        value.requestor := ParseReference(child, path+'/requestor')
      else if (child.localName = 'request') then
        value.request := ParseReference(child, path+'/request')
      else if (child.localName = 'outcome') then
        value.outcomeElement := ParseEnum(CODES_TFhirEligibilityOutcomeEnum, SYSTEMS_TFhirEligibilityOutcomeEnum, child, path+'/outcome')
      else if (child.localName = 'disposition') then
        value.dispositionElement := ParseString(child, path+'/disposition')
      else if (child.localName = 'insurer') then
        value.insurer := ParseReference(child, path+'/insurer')
      else if (child.localName = 'insurance') then
        value.insuranceList.Add(ParseCoverageEligibilityResponseInsurance(child, path+'/insurance'))
      else if (child.localName = 'preAuthRef') then
        value.preAuthRefElement := ParseString(child, path+'/preAuthRef')
      else if (child.localName = 'form') then
        value.form := ParseCodeableConcept(child, path+'/form')
      else if (child.localName = 'error') then
        value.errorList.Add(ParseCoverageEligibilityResponseError(child, path+'/error'))
      else if Not ParseDomainResourceChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeCoverageEligibilityResponse(xml : TXmlBuilder; name : String; value : TFhirCoverageEligibilityResponse);
begin
  if (value = nil) then
    exit;
  composeDomainResourceAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeCoverageEligibilityResponseChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeCoverageEligibilityResponseChildren(xml : TXmlBuilder; value : TFhirCoverageEligibilityResponse);
var
  i : integer;
begin
  composeDomainResourceChildren(xml, value);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.identifierList.Count - 1 do
      ComposeIdentifier(xml, 'identifier', value.identifierList[i]);
  ComposeEnum(xml, 'status', value.statusElement, CODES_TFhirFinancialResourceStatusCodesEnum);
  for i := 0 to value.purposeList.Count - 1 do
      ComposeEnum(xml, 'purpose', value.purposeList[i], CODES_TFhirEligibilityResponsePurposeEnum);
  ComposeReference(xml, 'patient', value.patient);
  if (SummaryOption in [soFull, soData]) and (value.serviced is TFhirPeriod) {6} then
    ComposePeriod(xml, 'servicedPeriod', TFhirPeriod(value.serviced))
  else if (SummaryOption in [soFull, soData]) and (value.serviced is TFhirDate) {6} then
    ComposeDate(xml, 'servicedDate', TFhirDate(value.serviced));
  ComposeDateTime(xml, 'created', value.createdElement);
  if (SummaryOption in [soFull, soData]) then
    ComposeReference(xml, 'requestor', value.requestor);
  ComposeReference(xml, 'request', value.request);
  ComposeEnum(xml, 'outcome', value.outcomeElement, CODES_TFhirEligibilityOutcomeEnum);
  if (SummaryOption in [soFull, soData]) then
    ComposeString(xml, 'disposition', value.dispositionElement);
  ComposeReference(xml, 'insurer', value.insurer);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.insuranceList.Count - 1 do
      ComposeCoverageEligibilityResponseInsurance(xml, 'insurance', value.insuranceList[i]);
  if (SummaryOption in [soFull, soData]) then
    ComposeString(xml, 'preAuthRef', value.preAuthRefElement);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(xml, 'form', value.form);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.errorList.Count - 1 do
      ComposeCoverageEligibilityResponseError(xml, 'error', value.errorList[i]);
end;

{$ENDIF FHIR_COVERAGEELIGIBILITYRESPONSE}
{$IFDEF FHIR_DETECTEDISSUE}
function TFHIRXmlParser.ParseDetectedIssueEvidence(element : TMXmlElement; path : string) : TFhirDetectedIssueEvidence;
var
  child : TMXmlElement;
begin
  result := TFhirDetectedIssueEvidence.Create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseDetectedIssueEvidenceChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseDetectedIssueEvidenceChild(value : TFhirDetectedIssueEvidence; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'code') then
        value.codeList.Add(ParseCodeableConcept(child, path+'/code'))
      else if (child.localName = 'detail') then
        value.detailList.Add(ParseReference(child, path+'/detail'))
      else if Not ParseBackboneElementChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeDetectedIssueEvidence(xml : TXmlBuilder; name : String; value : TFhirDetectedIssueEvidence);
begin
  if (value = nil) then
    exit;
  composeElementAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeDetectedIssueEvidenceChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeDetectedIssueEvidenceChildren(xml : TXmlBuilder; value : TFhirDetectedIssueEvidence);
var
  i : integer;
begin
  composeBackboneElementChildren(xml, value);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.codeList.Count - 1 do
      ComposeCodeableConcept(xml, 'code', value.codeList[i]);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.detailList.Count - 1 do
      ComposeReference(xml, 'detail', value.detailList[i]);
end;

function TFHIRXmlParser.ParseDetectedIssueMitigation(element : TMXmlElement; path : string) : TFhirDetectedIssueMitigation;
var
  child : TMXmlElement;
begin
  result := TFhirDetectedIssueMitigation.Create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseDetectedIssueMitigationChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseDetectedIssueMitigationChild(value : TFhirDetectedIssueMitigation; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'action') then
        value.action := ParseCodeableConcept(child, path+'/action')
      else if (child.localName = 'date') then
        value.dateElement := ParseDateTime(child, path+'/date')
      else if (child.localName = 'author') then
        value.author := ParseReference(child, path+'/author')
      else if Not ParseBackboneElementChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeDetectedIssueMitigation(xml : TXmlBuilder; name : String; value : TFhirDetectedIssueMitigation);
begin
  if (value = nil) then
    exit;
  composeElementAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeDetectedIssueMitigationChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeDetectedIssueMitigationChildren(xml : TXmlBuilder; value : TFhirDetectedIssueMitigation);
begin
  composeBackboneElementChildren(xml, value);
  ComposeCodeableConcept(xml, 'action', value.action);
  if (SummaryOption in [soFull, soData]) then
    ComposeDateTime(xml, 'date', value.dateElement);
  if (SummaryOption in [soFull, soData]) then
    ComposeReference(xml, 'author', value.author);
end;

function TFHIRXmlParser.ParseDetectedIssue(element : TMXmlElement; path : string) : TFhirDetectedIssue;
var
  child : TMXmlElement;
begin
  result := TFhirDetectedIssue.Create;
  try
    parseDomainResourceAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseDetectedIssueChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseDetectedIssueChild(value : TFhirDetectedIssue; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'identifier') then
        value.identifierList.Add(ParseIdentifier(child, path+'/identifier'))
      else if (child.localName = 'status') then
        value.statusElement := ParseEnum(CODES_TFhirDetectedIssueStatusEnum, SYSTEMS_TFhirDetectedIssueStatusEnum, child, path+'/status')
      else if (child.localName = 'category') then
        value.categoryList.Add(ParseCodeableConcept(child, path+'/category'))
      else if (child.localName = 'code') then
        value.code := ParseCodeableConcept(child, path+'/code')
      else if (child.localName = 'severity') then
        value.severityElement := ParseEnum(CODES_TFhirDetectedIssueSeverityEnum, SYSTEMS_TFhirDetectedIssueSeverityEnum, child, path+'/severity')
      else if (child.localName = 'subject') then
        value.subject := ParseReference(child, path+'/subject')
      else if (child.localName = 'identifiedPeriod') then
        value.identified := ParsePeriod(child, path+'/identifiedPeriod')
      else if (child.localName = 'identifiedDateTime') then
        value.identified := ParseDateTime(child, path+'/identifiedDateTime')
      else if (child.localName = 'author') then
        value.author := ParseReference(child, path+'/author')
      else if (child.localName = 'implicated') then
        value.implicatedList.Add(ParseReference(child, path+'/implicated'))
      else if (child.localName = 'evidence') then
        value.evidenceList.Add(ParseDetectedIssueEvidence(child, path+'/evidence'))
      else if (child.localName = 'detail') then
        value.detailElement := ParseString(child, path+'/detail')
      else if (child.localName = 'reference') then
        value.referenceElement := ParseUri(child, path+'/reference')
      else if (child.localName = 'mitigation') then
        value.mitigationList.Add(ParseDetectedIssueMitigation(child, path+'/mitigation'))
      else if Not ParseDomainResourceChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeDetectedIssue(xml : TXmlBuilder; name : String; value : TFhirDetectedIssue);
begin
  if (value = nil) then
    exit;
  composeDomainResourceAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeDetectedIssueChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeDetectedIssueChildren(xml : TXmlBuilder; value : TFhirDetectedIssue);
var
  i : integer;
begin
  composeDomainResourceChildren(xml, value);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.identifierList.Count - 1 do
      ComposeIdentifier(xml, 'identifier', value.identifierList[i]);
  ComposeEnum(xml, 'status', value.statusElement, CODES_TFhirDetectedIssueStatusEnum);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.categoryList.Count - 1 do
      ComposeCodeableConcept(xml, 'category', value.categoryList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(xml, 'code', value.code);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeEnum(xml, 'severity', value.severityElement, CODES_TFhirDetectedIssueSeverityEnum);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference(xml, 'subject', value.subject);
  if (SummaryOption in [soFull, soSummary, soData]) and (value.identified is TFhirPeriod) {6} then
    ComposePeriod(xml, 'identifiedPeriod', TFhirPeriod(value.identified))
  else if (SummaryOption in [soFull, soSummary, soData]) and (value.identified is TFhirDateTime) {6} then
    ComposeDateTime(xml, 'identifiedDateTime', TFhirDateTime(value.identified));
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference(xml, 'author', value.author);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.implicatedList.Count - 1 do
      ComposeReference(xml, 'implicated', value.implicatedList[i]);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.evidenceList.Count - 1 do
      ComposeDetectedIssueEvidence(xml, 'evidence', value.evidenceList[i]);
  if (SummaryOption in [soFull, soData]) then
    ComposeString(xml, 'detail', value.detailElement);
  if (SummaryOption in [soFull, soData]) then
    ComposeUri(xml, 'reference', value.referenceElement);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.mitigationList.Count - 1 do
      ComposeDetectedIssueMitigation(xml, 'mitigation', value.mitigationList[i]);
end;

{$ENDIF FHIR_DETECTEDISSUE}
{$IFDEF FHIR_DEVICE}
function TFHIRXmlParser.ParseDeviceUdiCarrier(element : TMXmlElement; path : string) : TFhirDeviceUdiCarrier;
var
  child : TMXmlElement;
begin
  result := TFhirDeviceUdiCarrier.Create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseDeviceUdiCarrierChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseDeviceUdiCarrierChild(value : TFhirDeviceUdiCarrier; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'deviceIdentifier') then
        value.deviceIdentifierElement := ParseString(child, path+'/deviceIdentifier')
      else if (child.localName = 'issuer') then
        value.issuerElement := ParseUri(child, path+'/issuer')
      else if (child.localName = 'jurisdiction') then
        value.jurisdictionElement := ParseUri(child, path+'/jurisdiction')
      else if (child.localName = 'carrierAIDC') then
        value.carrierAIDCElement := ParseBase64Binary(child, path+'/carrierAIDC')
      else if (child.localName = 'carrierHRF') then
        value.carrierHRFElement := ParseString(child, path+'/carrierHRF')
      else if (child.localName = 'entryType') then
        value.entryTypeElement := ParseEnum(CODES_TFhirUDIEntryTypeEnum, SYSTEMS_TFhirUDIEntryTypeEnum, child, path+'/entryType')
      else if Not ParseBackboneElementChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeDeviceUdiCarrier(xml : TXmlBuilder; name : String; value : TFhirDeviceUdiCarrier);
begin
  if (value = nil) then
    exit;
  composeElementAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeDeviceUdiCarrierChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeDeviceUdiCarrierChildren(xml : TXmlBuilder; value : TFhirDeviceUdiCarrier);
begin
  composeBackboneElementChildren(xml, value);
  ComposeString(xml, 'deviceIdentifier', value.deviceIdentifierElement);
  ComposeUri(xml, 'issuer', value.issuerElement);
  if (SummaryOption in [soFull, soData]) then
    ComposeUri(xml, 'jurisdiction', value.jurisdictionElement);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeBase64Binary(xml, 'carrierAIDC', value.carrierAIDCElement);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(xml, 'carrierHRF', value.carrierHRFElement);
  if (SummaryOption in [soFull, soData]) then
    ComposeEnum(xml, 'entryType', value.entryTypeElement, CODES_TFhirUDIEntryTypeEnum);
end;

function TFHIRXmlParser.ParseDeviceDeviceName(element : TMXmlElement; path : string) : TFhirDeviceDeviceName;
var
  child : TMXmlElement;
begin
  result := TFhirDeviceDeviceName.Create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseDeviceDeviceNameChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseDeviceDeviceNameChild(value : TFhirDeviceDeviceName; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'name') then
        value.nameElement := ParseString(child, path+'/name')
      else if (child.localName = 'type') then
        value.type_Element := ParseEnum(CODES_TFhirDeviceNameTypeEnum, SYSTEMS_TFhirDeviceNameTypeEnum, child, path+'/type')
      else if Not ParseBackboneElementChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeDeviceDeviceName(xml : TXmlBuilder; name : String; value : TFhirDeviceDeviceName);
begin
  if (value = nil) then
    exit;
  composeElementAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeDeviceDeviceNameChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeDeviceDeviceNameChildren(xml : TXmlBuilder; value : TFhirDeviceDeviceName);
begin
  composeBackboneElementChildren(xml, value);
  ComposeString(xml, 'name', value.nameElement);
  ComposeEnum(xml, 'type', value.type_Element, CODES_TFhirDeviceNameTypeEnum);
end;

function TFHIRXmlParser.ParseDeviceVersion(element : TMXmlElement; path : string) : TFhirDeviceVersion;
var
  child : TMXmlElement;
begin
  result := TFhirDeviceVersion.Create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseDeviceVersionChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseDeviceVersionChild(value : TFhirDeviceVersion; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'type') then
        value.type_ := ParseCodeableConcept(child, path+'/type')
      else if (child.localName = 'component') then
        value.component := ParseIdentifier(child, path+'/component')
      else if (child.localName = 'installDate') then
        value.installDateElement := ParseDateTime(child, path+'/installDate')
      else if (child.localName = 'value') then
        value.valueElement := ParseString(child, path+'/value')
      else if Not ParseBackboneElementChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeDeviceVersion(xml : TXmlBuilder; name : String; value : TFhirDeviceVersion);
begin
  if (value = nil) then
    exit;
  composeElementAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeDeviceVersionChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeDeviceVersionChildren(xml : TXmlBuilder; value : TFhirDeviceVersion);
begin
  composeBackboneElementChildren(xml, value);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(xml, 'type', value.type_);
  if (SummaryOption in [soFull, soData]) then
    ComposeIdentifier(xml, 'component', value.component);
  if (SummaryOption in [soFull, soData]) then
    ComposeDateTime(xml, 'installDate', value.installDateElement);
  ComposeString(xml, 'value', value.valueElement);
end;

function TFHIRXmlParser.ParseDeviceSpecialization(element : TMXmlElement; path : string) : TFhirDeviceSpecialization;
var
  child : TMXmlElement;
begin
  result := TFhirDeviceSpecialization.Create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseDeviceSpecializationChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseDeviceSpecializationChild(value : TFhirDeviceSpecialization; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'systemType') then
        value.systemType := ParseCodeableConcept(child, path+'/systemType')
      else if (child.localName = 'version') then
        value.versionElement := ParseString(child, path+'/version')
      else if (child.localName = 'category') then
        value.category := ParseCoding(child, path+'/category')
      else if Not ParseBackboneElementChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeDeviceSpecialization(xml : TXmlBuilder; name : String; value : TFhirDeviceSpecialization);
begin
  if (value = nil) then
    exit;
  composeElementAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeDeviceSpecializationChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeDeviceSpecializationChildren(xml : TXmlBuilder; value : TFhirDeviceSpecialization);
begin
  composeBackboneElementChildren(xml, value);
  ComposeCodeableConcept(xml, 'systemType', value.systemType);
  if (SummaryOption in [soFull, soData]) then
    ComposeString(xml, 'version', value.versionElement);
  if (SummaryOption in [soFull, soData]) then
    ComposeCoding(xml, 'category', value.category);
end;

function TFHIRXmlParser.ParseDeviceProperty(element : TMXmlElement; path : string) : TFhirDeviceProperty;
var
  child : TMXmlElement;
begin
  result := TFhirDeviceProperty.Create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseDevicePropertyChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseDevicePropertyChild(value : TFhirDeviceProperty; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'type') then
        value.type_ := ParseCodeableConcept(child, path+'/type')
      else if (child.localName = 'valueQuantity') then
        value.value := ParseQuantity(child, path+'/valueQuantity')
      else if (child.localName = 'valueCodeableConcept') then
        value.value := ParseCodeableConcept(child, path+'/valueCodeableConcept')
      else if (child.localName = 'valueRange') then
        value.value := ParseRange(child, path+'/valueRange')
      else if (child.localName = 'valueAttachment') then
        value.value := ParseAttachment(child, path+'/valueAttachment')
      else if (child.localName = 'valueString') then
        value.value := ParseString(child, path+'/valueString')
      else if (child.localName = 'valueBoolean') then
        value.value := ParseBoolean(child, path+'/valueBoolean')
      else if (child.localName = 'valueInteger') then
        value.value := ParseInteger(child, path+'/valueInteger')
      else if Not ParseBackboneElementChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeDeviceProperty(xml : TXmlBuilder; name : String; value : TFhirDeviceProperty);
begin
  if (value = nil) then
    exit;
  composeElementAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeDevicePropertyChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeDevicePropertyChildren(xml : TXmlBuilder; value : TFhirDeviceProperty);
begin
  composeBackboneElementChildren(xml, value);
  ComposeCodeableConcept(xml, 'type', value.type_);
  if (value.value is TFhirQuantity) {6} then
    ComposeQuantity(xml, 'valueQuantity', TFhirQuantity(value.value))
  else if (value.value is TFhirCodeableConcept) {6} then
    ComposeCodeableConcept(xml, 'valueCodeableConcept', TFhirCodeableConcept(value.value))
  else if (value.value is TFhirRange) {6} then
    ComposeRange(xml, 'valueRange', TFhirRange(value.value))
  else if (value.value is TFhirAttachment) {6} then
    ComposeAttachment(xml, 'valueAttachment', TFhirAttachment(value.value))
  else if (value.value is TFhirString) {6} then
    ComposeString(xml, 'valueString', TFhirString(value.value))
  else if (value.value is TFhirBoolean) {6} then
    ComposeBoolean(xml, 'valueBoolean', TFhirBoolean(value.value))
  else if (value.value is TFhirInteger) {6} then
    ComposeInteger(xml, 'valueInteger', TFhirInteger(value.value));
end;

function TFHIRXmlParser.ParseDeviceOperation(element : TMXmlElement; path : string) : TFhirDeviceOperation;
var
  child : TMXmlElement;
begin
  result := TFhirDeviceOperation.Create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseDeviceOperationChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseDeviceOperationChild(value : TFhirDeviceOperation; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'status') then
        value.status := ParseCodeableConcept(child, path+'/status')
      else if (child.localName = 'statusReason') then
        value.statusReasonList.Add(ParseCodeableConcept(child, path+'/statusReason'))
      else if (child.localName = 'operator') then
        value.operatorList.Add(ParseReference(child, path+'/operator'))
      else if (child.localName = 'mode') then
        value.mode := ParseCodeableConcept(child, path+'/mode')
      else if (child.localName = 'cycle') then
        value.cycle := ParseCount(child, path+'/cycle')
      else if (child.localName = 'duration') then
        value.duration := ParseDuration(child, path+'/duration')
      else if Not ParseBackboneElementChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeDeviceOperation(xml : TXmlBuilder; name : String; value : TFhirDeviceOperation);
begin
  if (value = nil) then
    exit;
  composeElementAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeDeviceOperationChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeDeviceOperationChildren(xml : TXmlBuilder; value : TFhirDeviceOperation);
var
  i : integer;
begin
  composeBackboneElementChildren(xml, value);
  ComposeCodeableConcept(xml, 'status', value.status);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.statusReasonList.Count - 1 do
      ComposeCodeableConcept(xml, 'statusReason', value.statusReasonList[i]);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.operatorList.Count - 1 do
      ComposeReference(xml, 'operator', value.operatorList[i]);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(xml, 'mode', value.mode);
  if (SummaryOption in [soFull, soData]) then
    ComposeCount(xml, 'cycle', value.cycle);
  if (SummaryOption in [soFull, soData]) then
    ComposeDuration(xml, 'duration', value.duration);
end;

function TFHIRXmlParser.ParseDeviceAssociation(element : TMXmlElement; path : string) : TFhirDeviceAssociation;
var
  child : TMXmlElement;
begin
  result := TFhirDeviceAssociation.Create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseDeviceAssociationChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseDeviceAssociationChild(value : TFhirDeviceAssociation; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'status') then
        value.status := ParseCodeableConcept(child, path+'/status')
      else if (child.localName = 'statusReason') then
        value.statusReasonList.Add(ParseCodeableConcept(child, path+'/statusReason'))
      else if (child.localName = 'humanSubject') then
        value.humanSubject := ParseReference(child, path+'/humanSubject')
      else if (child.localName = 'bodyStructure') then
        value.bodyStructure := ParseCodeableReference(child, path+'/bodyStructure')
      else if Not ParseBackboneElementChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeDeviceAssociation(xml : TXmlBuilder; name : String; value : TFhirDeviceAssociation);
begin
  if (value = nil) then
    exit;
  composeElementAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeDeviceAssociationChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeDeviceAssociationChildren(xml : TXmlBuilder; value : TFhirDeviceAssociation);
var
  i : integer;
begin
  composeBackboneElementChildren(xml, value);
  ComposeCodeableConcept(xml, 'status', value.status);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.statusReasonList.Count - 1 do
      ComposeCodeableConcept(xml, 'statusReason', value.statusReasonList[i]);
  if (SummaryOption in [soFull, soData]) then
    ComposeReference(xml, 'humanSubject', value.humanSubject);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableReference(xml, 'bodyStructure', value.bodyStructure);
end;

function TFHIRXmlParser.ParseDevice(element : TMXmlElement; path : string) : TFhirDevice;
var
  child : TMXmlElement;
begin
  result := TFhirDevice.Create;
  try
    parseDomainResourceAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseDeviceChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseDeviceChild(value : TFhirDevice; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'identifier') then
        value.identifierList.Add(ParseIdentifier(child, path+'/identifier'))
      else if (child.localName = 'displayName') then
        value.displayNameElement := ParseString(child, path+'/displayName')
      else if (child.localName = 'definition') then
        value.definition := ParseCodeableReference(child, path+'/definition')
      else if (child.localName = 'udiCarrier') then
        value.udiCarrierList.Add(ParseDeviceUdiCarrier(child, path+'/udiCarrier'))
      else if (child.localName = 'status') then
        value.statusElement := ParseEnum(CODES_TFhirFHIRDeviceStatusEnum, SYSTEMS_TFhirFHIRDeviceStatusEnum, child, path+'/status')
      else if (child.localName = 'availabilityStatus') then
        value.availabilityStatus := ParseCodeableConcept(child, path+'/availabilityStatus')
      else if (child.localName = 'biologicalSourceEvent') then
        value.biologicalSourceEvent := ParseIdentifier(child, path+'/biologicalSourceEvent')
      else if (child.localName = 'manufacturer') then
        value.manufacturerElement := ParseString(child, path+'/manufacturer')
      else if (child.localName = 'manufactureDate') then
        value.manufactureDateElement := ParseDateTime(child, path+'/manufactureDate')
      else if (child.localName = 'expirationDate') then
        value.expirationDateElement := ParseDateTime(child, path+'/expirationDate')
      else if (child.localName = 'lotNumber') then
        value.lotNumberElement := ParseString(child, path+'/lotNumber')
      else if (child.localName = 'serialNumber') then
        value.serialNumberElement := ParseString(child, path+'/serialNumber')
      else if (child.localName = 'deviceName') then
        value.deviceNameList.Add(ParseDeviceDeviceName(child, path+'/deviceName'))
      else if (child.localName = 'modelNumber') then
        value.modelNumberElement := ParseString(child, path+'/modelNumber')
      else if (child.localName = 'partNumber') then
        value.partNumberElement := ParseString(child, path+'/partNumber')
      else if (child.localName = 'category') then
        value.categoryList.Add(ParseCodeableConcept(child, path+'/category'))
      else if (child.localName = 'type') then
        value.type_List.Add(ParseCodeableConcept(child, path+'/type'))
      else if (child.localName = 'version') then
        value.versionList.Add(ParseDeviceVersion(child, path+'/version'))
      else if (child.localName = 'specialization') then
        value.specializationList.Add(ParseDeviceSpecialization(child, path+'/specialization'))
      else if (child.localName = 'property') then
        value.property_List.Add(ParseDeviceProperty(child, path+'/property'))
      else if (child.localName = 'operation') then
        value.operationList.Add(ParseDeviceOperation(child, path+'/operation'))
      else if (child.localName = 'association') then
        value.associationList.Add(ParseDeviceAssociation(child, path+'/association'))
      else if (child.localName = 'owner') then
        value.owner := ParseReference(child, path+'/owner')
      else if (child.localName = 'contact') then
        value.contactList.Add(ParseContactPoint(child, path+'/contact'))
      else if (child.localName = 'location') then
        value.location := ParseReference(child, path+'/location')
      else if (child.localName = 'url') then
        value.urlElement := ParseUri(child, path+'/url')
      else if (child.localName = 'endpoint') then
        value.endpointList.Add(ParseReference(child, path+'/endpoint'))
      else if (child.localName = 'gateway') then
        value.gatewayList.Add(ParseCodeableReference(child, path+'/gateway'))
      else if (child.localName = 'note') then
        value.noteList.Add(ParseAnnotation(child, path+'/note'))
      else if (child.localName = 'safety') then
        value.safetyList.Add(ParseCodeableConcept(child, path+'/safety'))
      else if (child.localName = 'parent') then
        value.parent := ParseReference(child, path+'/parent')
      else if Not ParseDomainResourceChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeDevice(xml : TXmlBuilder; name : String; value : TFhirDevice);
begin
  if (value = nil) then
    exit;
  composeDomainResourceAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeDeviceChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeDeviceChildren(xml : TXmlBuilder; value : TFhirDevice);
var
  i : integer;
begin
  composeDomainResourceChildren(xml, value);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.identifierList.Count - 1 do
      ComposeIdentifier(xml, 'identifier', value.identifierList[i]);
  if (SummaryOption in [soFull, soData]) then
    ComposeString(xml, 'displayName', value.displayNameElement);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableReference(xml, 'definition', value.definition);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.udiCarrierList.Count - 1 do
      ComposeDeviceUdiCarrier(xml, 'udiCarrier', value.udiCarrierList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeEnum(xml, 'status', value.statusElement, CODES_TFhirFHIRDeviceStatusEnum);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(xml, 'availabilityStatus', value.availabilityStatus);
  if (SummaryOption in [soFull, soData]) then
    ComposeIdentifier(xml, 'biologicalSourceEvent', value.biologicalSourceEvent);
  if (SummaryOption in [soFull, soData]) then
    ComposeString(xml, 'manufacturer', value.manufacturerElement);
  if (SummaryOption in [soFull, soData]) then
    ComposeDateTime(xml, 'manufactureDate', value.manufactureDateElement);
  if (SummaryOption in [soFull, soData]) then
    ComposeDateTime(xml, 'expirationDate', value.expirationDateElement);
  if (SummaryOption in [soFull, soData]) then
    ComposeString(xml, 'lotNumber', value.lotNumberElement);
  if (SummaryOption in [soFull, soData]) then
    ComposeString(xml, 'serialNumber', value.serialNumberElement);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.deviceNameList.Count - 1 do
      ComposeDeviceDeviceName(xml, 'deviceName', value.deviceNameList[i]);
  if (SummaryOption in [soFull, soData]) then
    ComposeString(xml, 'modelNumber', value.modelNumberElement);
  if (SummaryOption in [soFull, soData]) then
    ComposeString(xml, 'partNumber', value.partNumberElement);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.categoryList.Count - 1 do
      ComposeCodeableConcept(xml, 'category', value.categoryList[i]);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.type_List.Count - 1 do
      ComposeCodeableConcept(xml, 'type', value.type_List[i]);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.versionList.Count - 1 do
      ComposeDeviceVersion(xml, 'version', value.versionList[i]);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.specializationList.Count - 1 do
      ComposeDeviceSpecialization(xml, 'specialization', value.specializationList[i]);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.property_List.Count - 1 do
      ComposeDeviceProperty(xml, 'property', value.property_List[i]);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.operationList.Count - 1 do
      ComposeDeviceOperation(xml, 'operation', value.operationList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.associationList.Count - 1 do
      ComposeDeviceAssociation(xml, 'association', value.associationList[i]);
  if (SummaryOption in [soFull, soData]) then
    ComposeReference(xml, 'owner', value.owner);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.contactList.Count - 1 do
      ComposeContactPoint(xml, 'contact', value.contactList[i]);
  if (SummaryOption in [soFull, soData]) then
    ComposeReference(xml, 'location', value.location);
  if (SummaryOption in [soFull, soData]) then
    ComposeUri(xml, 'url', value.urlElement);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.endpointList.Count - 1 do
      ComposeReference(xml, 'endpoint', value.endpointList[i]);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.gatewayList.Count - 1 do
      ComposeCodeableReference(xml, 'gateway', value.gatewayList[i]);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.noteList.Count - 1 do
      ComposeAnnotation(xml, 'note', value.noteList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.safetyList.Count - 1 do
      ComposeCodeableConcept(xml, 'safety', value.safetyList[i]);
  if (SummaryOption in [soFull, soData]) then
    ComposeReference(xml, 'parent', value.parent);
end;

{$ENDIF FHIR_DEVICE}
{$IFDEF FHIR_DEVICEDEFINITION}
function TFHIRXmlParser.ParseDeviceDefinitionUdiDeviceIdentifier(element : TMXmlElement; path : string) : TFhirDeviceDefinitionUdiDeviceIdentifier;
var
  child : TMXmlElement;
begin
  result := TFhirDeviceDefinitionUdiDeviceIdentifier.Create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseDeviceDefinitionUdiDeviceIdentifierChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseDeviceDefinitionUdiDeviceIdentifierChild(value : TFhirDeviceDefinitionUdiDeviceIdentifier; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'deviceIdentifier') then
        value.deviceIdentifierElement := ParseString(child, path+'/deviceIdentifier')
      else if (child.localName = 'issuer') then
        value.issuerElement := ParseUri(child, path+'/issuer')
      else if (child.localName = 'jurisdiction') then
        value.jurisdictionElement := ParseUri(child, path+'/jurisdiction')
      else if (child.localName = 'marketDistribution') then
        value.marketDistributionList.Add(ParseDeviceDefinitionUdiDeviceIdentifierMarketDistribution(child, path+'/marketDistribution'))
      else if Not ParseBackboneElementChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeDeviceDefinitionUdiDeviceIdentifier(xml : TXmlBuilder; name : String; value : TFhirDeviceDefinitionUdiDeviceIdentifier);
begin
  if (value = nil) then
    exit;
  composeElementAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeDeviceDefinitionUdiDeviceIdentifierChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeDeviceDefinitionUdiDeviceIdentifierChildren(xml : TXmlBuilder; value : TFhirDeviceDefinitionUdiDeviceIdentifier);
var
  i : integer;
begin
  composeBackboneElementChildren(xml, value);
  ComposeString(xml, 'deviceIdentifier', value.deviceIdentifierElement);
  ComposeUri(xml, 'issuer', value.issuerElement);
  ComposeUri(xml, 'jurisdiction', value.jurisdictionElement);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.marketDistributionList.Count - 1 do
      ComposeDeviceDefinitionUdiDeviceIdentifierMarketDistribution(xml, 'marketDistribution', value.marketDistributionList[i]);
end;

function TFHIRXmlParser.ParseDeviceDefinitionUdiDeviceIdentifierMarketDistribution(element : TMXmlElement; path : string) : TFhirDeviceDefinitionUdiDeviceIdentifierMarketDistribution;
var
  child : TMXmlElement;
begin
  result := TFhirDeviceDefinitionUdiDeviceIdentifierMarketDistribution.Create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseDeviceDefinitionUdiDeviceIdentifierMarketDistributionChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseDeviceDefinitionUdiDeviceIdentifierMarketDistributionChild(value : TFhirDeviceDefinitionUdiDeviceIdentifierMarketDistribution; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'marketPeriod') then
        value.marketPeriod := ParsePeriod(child, path+'/marketPeriod')
      else if (child.localName = 'subJurisdiction') then
        value.subJurisdictionElement := ParseUri(child, path+'/subJurisdiction')
      else if Not ParseBackboneElementChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeDeviceDefinitionUdiDeviceIdentifierMarketDistribution(xml : TXmlBuilder; name : String; value : TFhirDeviceDefinitionUdiDeviceIdentifierMarketDistribution);
begin
  if (value = nil) then
    exit;
  composeElementAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeDeviceDefinitionUdiDeviceIdentifierMarketDistributionChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeDeviceDefinitionUdiDeviceIdentifierMarketDistributionChildren(xml : TXmlBuilder; value : TFhirDeviceDefinitionUdiDeviceIdentifierMarketDistribution);
begin
  composeBackboneElementChildren(xml, value);
  ComposePeriod(xml, 'marketPeriod', value.marketPeriod);
  ComposeUri(xml, 'subJurisdiction', value.subJurisdictionElement);
end;

function TFHIRXmlParser.ParseDeviceDefinitionRegulatoryIdentifier(element : TMXmlElement; path : string) : TFhirDeviceDefinitionRegulatoryIdentifier;
var
  child : TMXmlElement;
begin
  result := TFhirDeviceDefinitionRegulatoryIdentifier.Create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseDeviceDefinitionRegulatoryIdentifierChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseDeviceDefinitionRegulatoryIdentifierChild(value : TFhirDeviceDefinitionRegulatoryIdentifier; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'type') then
        value.type_Element := ParseEnum(CODES_TFhirDeviceDefinitionRegulatoryIdentifierTypeEnum, SYSTEMS_TFhirDeviceDefinitionRegulatoryIdentifierTypeEnum, child, path+'/type')
      else if (child.localName = 'deviceIdentifier') then
        value.deviceIdentifierElement := ParseString(child, path+'/deviceIdentifier')
      else if (child.localName = 'issuer') then
        value.issuerElement := ParseUri(child, path+'/issuer')
      else if (child.localName = 'jurisdiction') then
        value.jurisdictionElement := ParseUri(child, path+'/jurisdiction')
      else if Not ParseBackboneElementChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeDeviceDefinitionRegulatoryIdentifier(xml : TXmlBuilder; name : String; value : TFhirDeviceDefinitionRegulatoryIdentifier);
begin
  if (value = nil) then
    exit;
  composeElementAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeDeviceDefinitionRegulatoryIdentifierChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeDeviceDefinitionRegulatoryIdentifierChildren(xml : TXmlBuilder; value : TFhirDeviceDefinitionRegulatoryIdentifier);
begin
  composeBackboneElementChildren(xml, value);
  ComposeEnum(xml, 'type', value.type_Element, CODES_TFhirDeviceDefinitionRegulatoryIdentifierTypeEnum);
  ComposeString(xml, 'deviceIdentifier', value.deviceIdentifierElement);
  ComposeUri(xml, 'issuer', value.issuerElement);
  ComposeUri(xml, 'jurisdiction', value.jurisdictionElement);
end;

function TFHIRXmlParser.ParseDeviceDefinitionDeviceName(element : TMXmlElement; path : string) : TFhirDeviceDefinitionDeviceName;
var
  child : TMXmlElement;
begin
  result := TFhirDeviceDefinitionDeviceName.Create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseDeviceDefinitionDeviceNameChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseDeviceDefinitionDeviceNameChild(value : TFhirDeviceDefinitionDeviceName; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'name') then
        value.nameElement := ParseString(child, path+'/name')
      else if (child.localName = 'type') then
        value.type_Element := ParseEnum(CODES_TFhirDeviceNameTypeEnum, SYSTEMS_TFhirDeviceNameTypeEnum, child, path+'/type')
      else if Not ParseBackboneElementChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeDeviceDefinitionDeviceName(xml : TXmlBuilder; name : String; value : TFhirDeviceDefinitionDeviceName);
begin
  if (value = nil) then
    exit;
  composeElementAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeDeviceDefinitionDeviceNameChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeDeviceDefinitionDeviceNameChildren(xml : TXmlBuilder; value : TFhirDeviceDefinitionDeviceName);
begin
  composeBackboneElementChildren(xml, value);
  ComposeString(xml, 'name', value.nameElement);
  ComposeEnum(xml, 'type', value.type_Element, CODES_TFhirDeviceNameTypeEnum);
end;

function TFHIRXmlParser.ParseDeviceDefinitionClassification(element : TMXmlElement; path : string) : TFhirDeviceDefinitionClassification;
var
  child : TMXmlElement;
begin
  result := TFhirDeviceDefinitionClassification.Create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseDeviceDefinitionClassificationChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseDeviceDefinitionClassificationChild(value : TFhirDeviceDefinitionClassification; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'type') then
        value.type_ := ParseCodeableConcept(child, path+'/type')
      else if (child.localName = 'justification') then
        value.justificationList.Add(ParseRelatedArtifact(child, path+'/justification'))
      else if Not ParseBackboneElementChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeDeviceDefinitionClassification(xml : TXmlBuilder; name : String; value : TFhirDeviceDefinitionClassification);
begin
  if (value = nil) then
    exit;
  composeElementAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeDeviceDefinitionClassificationChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeDeviceDefinitionClassificationChildren(xml : TXmlBuilder; value : TFhirDeviceDefinitionClassification);
var
  i : integer;
begin
  composeBackboneElementChildren(xml, value);
  ComposeCodeableConcept(xml, 'type', value.type_);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.justificationList.Count - 1 do
      ComposeRelatedArtifact(xml, 'justification', value.justificationList[i]);
end;

function TFHIRXmlParser.ParseDeviceDefinitionHasPart(element : TMXmlElement; path : string) : TFhirDeviceDefinitionHasPart;
var
  child : TMXmlElement;
begin
  result := TFhirDeviceDefinitionHasPart.Create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseDeviceDefinitionHasPartChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseDeviceDefinitionHasPartChild(value : TFhirDeviceDefinitionHasPart; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'reference') then
        value.reference := ParseReference(child, path+'/reference')
      else if (child.localName = 'count') then
        value.countElement := ParseInteger(child, path+'/count')
      else if Not ParseBackboneElementChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeDeviceDefinitionHasPart(xml : TXmlBuilder; name : String; value : TFhirDeviceDefinitionHasPart);
begin
  if (value = nil) then
    exit;
  composeElementAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeDeviceDefinitionHasPartChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeDeviceDefinitionHasPartChildren(xml : TXmlBuilder; value : TFhirDeviceDefinitionHasPart);
begin
  composeBackboneElementChildren(xml, value);
  ComposeReference(xml, 'reference', value.reference);
  if (SummaryOption in [soFull, soData]) then
    ComposeInteger(xml, 'count', value.countElement);
end;

function TFHIRXmlParser.ParseDeviceDefinitionPackaging(element : TMXmlElement; path : string) : TFhirDeviceDefinitionPackaging;
var
  child : TMXmlElement;
begin
  result := TFhirDeviceDefinitionPackaging.Create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseDeviceDefinitionPackagingChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseDeviceDefinitionPackagingChild(value : TFhirDeviceDefinitionPackaging; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'identifier') then
        value.identifier := ParseIdentifier(child, path+'/identifier')
      else if (child.localName = 'type') then
        value.type_ := ParseCodeableConcept(child, path+'/type')
      else if (child.localName = 'count') then
        value.countElement := ParseInteger(child, path+'/count')
      else if (child.localName = 'distributor') then
        value.distributorList.Add(ParseDeviceDefinitionPackagingDistributor(child, path+'/distributor'))
      else if (child.localName = 'udiDeviceIdentifier') then
        value.udiDeviceIdentifierList.Add(ParseDeviceDefinitionUdiDeviceIdentifier(child, path+'/udiDeviceIdentifier'))
      else if (child.localName = 'packaging') then
        value.packagingList.Add(ParseDeviceDefinitionPackaging(child, path+'/packaging'))
      else if Not ParseBackboneElementChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeDeviceDefinitionPackaging(xml : TXmlBuilder; name : String; value : TFhirDeviceDefinitionPackaging);
begin
  if (value = nil) then
    exit;
  composeElementAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeDeviceDefinitionPackagingChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeDeviceDefinitionPackagingChildren(xml : TXmlBuilder; value : TFhirDeviceDefinitionPackaging);
var
  i : integer;
begin
  composeBackboneElementChildren(xml, value);
  if (SummaryOption in [soFull, soData]) then
    ComposeIdentifier(xml, 'identifier', value.identifier);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(xml, 'type', value.type_);
  if (SummaryOption in [soFull, soData]) then
    ComposeInteger(xml, 'count', value.countElement);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.distributorList.Count - 1 do
      ComposeDeviceDefinitionPackagingDistributor(xml, 'distributor', value.distributorList[i]);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.udiDeviceIdentifierList.Count - 1 do
      ComposeDeviceDefinitionUdiDeviceIdentifier(xml, 'udiDeviceIdentifier', value.udiDeviceIdentifierList[i]);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.packagingList.Count - 1 do
      ComposeDeviceDefinitionPackaging(xml, 'packaging', value.packagingList[i]);
end;

function TFHIRXmlParser.ParseDeviceDefinitionPackagingDistributor(element : TMXmlElement; path : string) : TFhirDeviceDefinitionPackagingDistributor;
var
  child : TMXmlElement;
begin
  result := TFhirDeviceDefinitionPackagingDistributor.Create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseDeviceDefinitionPackagingDistributorChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseDeviceDefinitionPackagingDistributorChild(value : TFhirDeviceDefinitionPackagingDistributor; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'name') then
        value.nameElement := ParseString(child, path+'/name')
      else if (child.localName = 'organizationReference') then
        value.organizationReferenceList.Add(ParseReference(child, path+'/organizationReference'))
      else if Not ParseBackboneElementChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeDeviceDefinitionPackagingDistributor(xml : TXmlBuilder; name : String; value : TFhirDeviceDefinitionPackagingDistributor);
begin
  if (value = nil) then
    exit;
  composeElementAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeDeviceDefinitionPackagingDistributorChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeDeviceDefinitionPackagingDistributorChildren(xml : TXmlBuilder; value : TFhirDeviceDefinitionPackagingDistributor);
var
  i : integer;
begin
  composeBackboneElementChildren(xml, value);
  if (SummaryOption in [soFull, soData]) then
    ComposeString(xml, 'name', value.nameElement);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.organizationReferenceList.Count - 1 do
      ComposeReference(xml, 'organizationReference', value.organizationReferenceList[i]);
end;

function TFHIRXmlParser.ParseDeviceDefinitionVersion(element : TMXmlElement; path : string) : TFhirDeviceDefinitionVersion;
var
  child : TMXmlElement;
begin
  result := TFhirDeviceDefinitionVersion.Create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseDeviceDefinitionVersionChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseDeviceDefinitionVersionChild(value : TFhirDeviceDefinitionVersion; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'type') then
        value.type_ := ParseCodeableConcept(child, path+'/type')
      else if (child.localName = 'component') then
        value.component := ParseIdentifier(child, path+'/component')
      else if (child.localName = 'value') then
        value.valueElement := ParseString(child, path+'/value')
      else if Not ParseBackboneElementChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeDeviceDefinitionVersion(xml : TXmlBuilder; name : String; value : TFhirDeviceDefinitionVersion);
begin
  if (value = nil) then
    exit;
  composeElementAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeDeviceDefinitionVersionChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeDeviceDefinitionVersionChildren(xml : TXmlBuilder; value : TFhirDeviceDefinitionVersion);
begin
  composeBackboneElementChildren(xml, value);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(xml, 'type', value.type_);
  if (SummaryOption in [soFull, soData]) then
    ComposeIdentifier(xml, 'component', value.component);
  ComposeString(xml, 'value', value.valueElement);
end;

function TFHIRXmlParser.ParseDeviceDefinitionProperty(element : TMXmlElement; path : string) : TFhirDeviceDefinitionProperty;
var
  child : TMXmlElement;
begin
  result := TFhirDeviceDefinitionProperty.Create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseDeviceDefinitionPropertyChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseDeviceDefinitionPropertyChild(value : TFhirDeviceDefinitionProperty; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'type') then
        value.type_ := ParseCodeableConcept(child, path+'/type')
      else if (child.localName = 'valueQuantity') then
        value.value := ParseQuantity(child, path+'/valueQuantity')
      else if (child.localName = 'valueCodeableConcept') then
        value.value := ParseCodeableConcept(child, path+'/valueCodeableConcept')
      else if (child.localName = 'valueRange') then
        value.value := ParseRange(child, path+'/valueRange')
      else if (child.localName = 'valueAttachment') then
        value.value := ParseAttachment(child, path+'/valueAttachment')
      else if (child.localName = 'valueString') then
        value.value := ParseString(child, path+'/valueString')
      else if (child.localName = 'valueBoolean') then
        value.value := ParseBoolean(child, path+'/valueBoolean')
      else if (child.localName = 'valueInteger') then
        value.value := ParseInteger(child, path+'/valueInteger')
      else if Not ParseBackboneElementChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeDeviceDefinitionProperty(xml : TXmlBuilder; name : String; value : TFhirDeviceDefinitionProperty);
begin
  if (value = nil) then
    exit;
  composeElementAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeDeviceDefinitionPropertyChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeDeviceDefinitionPropertyChildren(xml : TXmlBuilder; value : TFhirDeviceDefinitionProperty);
begin
  composeBackboneElementChildren(xml, value);
  ComposeCodeableConcept(xml, 'type', value.type_);
  if (value.value is TFhirQuantity) {6} then
    ComposeQuantity(xml, 'valueQuantity', TFhirQuantity(value.value))
  else if (value.value is TFhirCodeableConcept) {6} then
    ComposeCodeableConcept(xml, 'valueCodeableConcept', TFhirCodeableConcept(value.value))
  else if (value.value is TFhirRange) {6} then
    ComposeRange(xml, 'valueRange', TFhirRange(value.value))
  else if (value.value is TFhirAttachment) {6} then
    ComposeAttachment(xml, 'valueAttachment', TFhirAttachment(value.value))
  else if (value.value is TFhirString) {6} then
    ComposeString(xml, 'valueString', TFhirString(value.value))
  else if (value.value is TFhirBoolean) {6} then
    ComposeBoolean(xml, 'valueBoolean', TFhirBoolean(value.value))
  else if (value.value is TFhirInteger) {6} then
    ComposeInteger(xml, 'valueInteger', TFhirInteger(value.value));
end;

function TFHIRXmlParser.ParseDeviceDefinitionLink(element : TMXmlElement; path : string) : TFhirDeviceDefinitionLink;
var
  child : TMXmlElement;
begin
  result := TFhirDeviceDefinitionLink.Create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseDeviceDefinitionLinkChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseDeviceDefinitionLinkChild(value : TFhirDeviceDefinitionLink; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'relation') then
        value.relation := ParseCoding(child, path+'/relation')
      else if (child.localName = 'relatedDevice') then
        value.relatedDevice := ParseCodeableReference(child, path+'/relatedDevice')
      else if Not ParseBackboneElementChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeDeviceDefinitionLink(xml : TXmlBuilder; name : String; value : TFhirDeviceDefinitionLink);
begin
  if (value = nil) then
    exit;
  composeElementAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeDeviceDefinitionLinkChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeDeviceDefinitionLinkChildren(xml : TXmlBuilder; value : TFhirDeviceDefinitionLink);
begin
  composeBackboneElementChildren(xml, value);
  ComposeCoding(xml, 'relation', value.relation);
  ComposeCodeableReference(xml, 'relatedDevice', value.relatedDevice);
end;

function TFHIRXmlParser.ParseDeviceDefinitionMaterial(element : TMXmlElement; path : string) : TFhirDeviceDefinitionMaterial;
var
  child : TMXmlElement;
begin
  result := TFhirDeviceDefinitionMaterial.Create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseDeviceDefinitionMaterialChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseDeviceDefinitionMaterialChild(value : TFhirDeviceDefinitionMaterial; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'substance') then
        value.substance := ParseCodeableConcept(child, path+'/substance')
      else if (child.localName = 'alternate') then
        value.alternateElement := ParseBoolean(child, path+'/alternate')
      else if (child.localName = 'allergenicIndicator') then
        value.allergenicIndicatorElement := ParseBoolean(child, path+'/allergenicIndicator')
      else if Not ParseBackboneElementChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeDeviceDefinitionMaterial(xml : TXmlBuilder; name : String; value : TFhirDeviceDefinitionMaterial);
begin
  if (value = nil) then
    exit;
  composeElementAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeDeviceDefinitionMaterialChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeDeviceDefinitionMaterialChildren(xml : TXmlBuilder; value : TFhirDeviceDefinitionMaterial);
begin
  composeBackboneElementChildren(xml, value);
  ComposeCodeableConcept(xml, 'substance', value.substance);
  if (SummaryOption in [soFull, soData]) then
    ComposeBoolean(xml, 'alternate', value.alternateElement);
  if (SummaryOption in [soFull, soData]) then
    ComposeBoolean(xml, 'allergenicIndicator', value.allergenicIndicatorElement);
end;

function TFHIRXmlParser.ParseDeviceDefinitionGuideline(element : TMXmlElement; path : string) : TFhirDeviceDefinitionGuideline;
var
  child : TMXmlElement;
begin
  result := TFhirDeviceDefinitionGuideline.Create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseDeviceDefinitionGuidelineChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseDeviceDefinitionGuidelineChild(value : TFhirDeviceDefinitionGuideline; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'useContext') then
        value.useContextList.Add(ParseUsageContext(child, path+'/useContext'))
      else if (child.localName = 'usageInstruction') then
        value.usageInstructionElement := ParseMarkdown(child, path+'/usageInstruction')
      else if (child.localName = 'relatedArtifact') then
        value.relatedArtifactList.Add(ParseRelatedArtifact(child, path+'/relatedArtifact'))
      else if (child.localName = 'indication') then
        value.indicationList.Add(ParseCodeableReference(child, path+'/indication'))
      else if (child.localName = 'contraindication') then
        value.contraindicationList.Add(ParseCodeableReference(child, path+'/contraindication'))
      else if (child.localName = 'warning') then
        value.warningList.Add(ParseCodeableReference(child, path+'/warning'))
      else if (child.localName = 'intendedUse') then
        value.intendedUseElement := ParseString(child, path+'/intendedUse')
      else if Not ParseBackboneElementChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeDeviceDefinitionGuideline(xml : TXmlBuilder; name : String; value : TFhirDeviceDefinitionGuideline);
begin
  if (value = nil) then
    exit;
  composeElementAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeDeviceDefinitionGuidelineChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeDeviceDefinitionGuidelineChildren(xml : TXmlBuilder; value : TFhirDeviceDefinitionGuideline);
var
  i : integer;
begin
  composeBackboneElementChildren(xml, value);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.useContextList.Count - 1 do
      ComposeUsageContext(xml, 'useContext', value.useContextList[i]);
  if (SummaryOption in [soFull, soData]) then
    ComposeMarkdown(xml, 'usageInstruction', value.usageInstructionElement);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.relatedArtifactList.Count - 1 do
      ComposeRelatedArtifact(xml, 'relatedArtifact', value.relatedArtifactList[i]);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.indicationList.Count - 1 do
      ComposeCodeableReference(xml, 'indication', value.indicationList[i]);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.contraindicationList.Count - 1 do
      ComposeCodeableReference(xml, 'contraindication', value.contraindicationList[i]);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.warningList.Count - 1 do
      ComposeCodeableReference(xml, 'warning', value.warningList[i]);
  if (SummaryOption in [soFull, soData]) then
    ComposeString(xml, 'intendedUse', value.intendedUseElement);
end;

function TFHIRXmlParser.ParseDeviceDefinitionCorrectiveAction(element : TMXmlElement; path : string) : TFhirDeviceDefinitionCorrectiveAction;
var
  child : TMXmlElement;
begin
  result := TFhirDeviceDefinitionCorrectiveAction.Create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseDeviceDefinitionCorrectiveActionChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseDeviceDefinitionCorrectiveActionChild(value : TFhirDeviceDefinitionCorrectiveAction; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'recall') then
        value.recallElement := ParseBoolean(child, path+'/recall')
      else if (child.localName = 'scope') then
        value.scopeElement := ParseEnum(CODES_TFhirDeviceCorrectiveActionScopeEnum, SYSTEMS_TFhirDeviceCorrectiveActionScopeEnum, child, path+'/scope')
      else if (child.localName = 'period') then
        value.period := ParsePeriod(child, path+'/period')
      else if Not ParseBackboneElementChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeDeviceDefinitionCorrectiveAction(xml : TXmlBuilder; name : String; value : TFhirDeviceDefinitionCorrectiveAction);
begin
  if (value = nil) then
    exit;
  composeElementAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeDeviceDefinitionCorrectiveActionChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeDeviceDefinitionCorrectiveActionChildren(xml : TXmlBuilder; value : TFhirDeviceDefinitionCorrectiveAction);
begin
  composeBackboneElementChildren(xml, value);
  ComposeBoolean(xml, 'recall', value.recallElement);
  if (SummaryOption in [soFull, soData]) then
    ComposeEnum(xml, 'scope', value.scopeElement, CODES_TFhirDeviceCorrectiveActionScopeEnum);
  ComposePeriod(xml, 'period', value.period);
end;

function TFHIRXmlParser.ParseDeviceDefinitionChargeItem(element : TMXmlElement; path : string) : TFhirDeviceDefinitionChargeItem;
var
  child : TMXmlElement;
begin
  result := TFhirDeviceDefinitionChargeItem.Create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseDeviceDefinitionChargeItemChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseDeviceDefinitionChargeItemChild(value : TFhirDeviceDefinitionChargeItem; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'chargeItemCode') then
        value.chargeItemCode := ParseCodeableReference(child, path+'/chargeItemCode')
      else if (child.localName = 'count') then
        value.count := ParseQuantity(child, path+'/count')
      else if (child.localName = 'effectivePeriod') then
        value.effectivePeriod := ParsePeriod(child, path+'/effectivePeriod')
      else if (child.localName = 'useContext') then
        value.useContextList.Add(ParseUsageContext(child, path+'/useContext'))
      else if Not ParseBackboneElementChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeDeviceDefinitionChargeItem(xml : TXmlBuilder; name : String; value : TFhirDeviceDefinitionChargeItem);
begin
  if (value = nil) then
    exit;
  composeElementAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeDeviceDefinitionChargeItemChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeDeviceDefinitionChargeItemChildren(xml : TXmlBuilder; value : TFhirDeviceDefinitionChargeItem);
var
  i : integer;
begin
  composeBackboneElementChildren(xml, value);
  ComposeCodeableReference(xml, 'chargeItemCode', value.chargeItemCode);
  ComposeQuantity(xml, 'count', value.count);
  if (SummaryOption in [soFull, soData]) then
    ComposePeriod(xml, 'effectivePeriod', value.effectivePeriod);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.useContextList.Count - 1 do
      ComposeUsageContext(xml, 'useContext', value.useContextList[i]);
end;

function TFHIRXmlParser.ParseDeviceDefinition(element : TMXmlElement; path : string) : TFhirDeviceDefinition;
var
  child : TMXmlElement;
begin
  result := TFhirDeviceDefinition.Create;
  try
    parseDomainResourceAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseDeviceDefinitionChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseDeviceDefinitionChild(value : TFhirDeviceDefinition; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'description') then
        value.descriptionElement := ParseMarkdown(child, path+'/description')
      else if (child.localName = 'identifier') then
        value.identifierList.Add(ParseIdentifier(child, path+'/identifier'))
      else if (child.localName = 'udiDeviceIdentifier') then
        value.udiDeviceIdentifierList.Add(ParseDeviceDefinitionUdiDeviceIdentifier(child, path+'/udiDeviceIdentifier'))
      else if (child.localName = 'regulatoryIdentifier') then
        value.regulatoryIdentifierList.Add(ParseDeviceDefinitionRegulatoryIdentifier(child, path+'/regulatoryIdentifier'))
      else if (child.localName = 'partNumber') then
        value.partNumberElement := ParseString(child, path+'/partNumber')
      else if (child.localName = 'manufacturer') then
        value.manufacturer := ParseReference(child, path+'/manufacturer')
      else if (child.localName = 'deviceName') then
        value.deviceNameList.Add(ParseDeviceDefinitionDeviceName(child, path+'/deviceName'))
      else if (child.localName = 'modelNumber') then
        value.modelNumberElement := ParseString(child, path+'/modelNumber')
      else if (child.localName = 'classification') then
        value.classificationList.Add(ParseDeviceDefinitionClassification(child, path+'/classification'))
      else if (child.localName = 'specialization') then
        value.specializationList.Add(ParseRelatedArtifact(child, path+'/specialization'))
      else if (child.localName = 'hasPart') then
        value.hasPartList.Add(ParseDeviceDefinitionHasPart(child, path+'/hasPart'))
      else if (child.localName = 'packaging') then
        value.packagingList.Add(ParseDeviceDefinitionPackaging(child, path+'/packaging'))
      else if (child.localName = 'version') then
        value.versionList.Add(ParseDeviceDefinitionVersion(child, path+'/version'))
      else if (child.localName = 'safety') then
        value.safetyList.Add(ParseCodeableConcept(child, path+'/safety'))
      else if (child.localName = 'shelfLifeStorage') then
        value.shelfLifeStorageList.Add(ParseProductShelfLife(child, path+'/shelfLifeStorage'))
      else if (child.localName = 'languageCode') then
        value.languageCodeList.Add(ParseCodeableConcept(child, path+'/languageCode'))
      else if (child.localName = 'property') then
        value.property_List.Add(ParseDeviceDefinitionProperty(child, path+'/property'))
      else if (child.localName = 'owner') then
        value.owner := ParseReference(child, path+'/owner')
      else if (child.localName = 'contact') then
        value.contactList.Add(ParseContactPoint(child, path+'/contact'))
      else if (child.localName = 'link') then
        value.link_List.Add(ParseDeviceDefinitionLink(child, path+'/link'))
      else if (child.localName = 'note') then
        value.noteList.Add(ParseAnnotation(child, path+'/note'))
      else if (child.localName = 'parentDevice') then
        value.parentDevice := ParseReference(child, path+'/parentDevice')
      else if (child.localName = 'material') then
        value.materialList.Add(ParseDeviceDefinitionMaterial(child, path+'/material'))
      else if (child.localName = 'productionIdentifierInUDI') then
        value.productionIdentifierInUDIList.Add(ParseEnum(CODES_TFhirDeviceProductionIdentifierInUDIEnum, SYSTEMS_TFhirDeviceProductionIdentifierInUDIEnum, child, path+'/productionIdentifierInUDI')){y.1}
      else if (child.localName = 'guideline') then
        value.guideline := ParseDeviceDefinitionGuideline(child, path+'/guideline')
      else if (child.localName = 'correctiveAction') then
        value.correctiveAction := ParseDeviceDefinitionCorrectiveAction(child, path+'/correctiveAction')
      else if (child.localName = 'chargeItem') then
        value.chargeItemList.Add(ParseDeviceDefinitionChargeItem(child, path+'/chargeItem'))
      else if Not ParseDomainResourceChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeDeviceDefinition(xml : TXmlBuilder; name : String; value : TFhirDeviceDefinition);
begin
  if (value = nil) then
    exit;
  composeDomainResourceAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeDeviceDefinitionChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeDeviceDefinitionChildren(xml : TXmlBuilder; value : TFhirDeviceDefinition);
var
  i : integer;
begin
  composeDomainResourceChildren(xml, value);
  if (SummaryOption in [soFull, soData]) then
    ComposeMarkdown(xml, 'description', value.descriptionElement);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.identifierList.Count - 1 do
      ComposeIdentifier(xml, 'identifier', value.identifierList[i]);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.udiDeviceIdentifierList.Count - 1 do
      ComposeDeviceDefinitionUdiDeviceIdentifier(xml, 'udiDeviceIdentifier', value.udiDeviceIdentifierList[i]);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.regulatoryIdentifierList.Count - 1 do
      ComposeDeviceDefinitionRegulatoryIdentifier(xml, 'regulatoryIdentifier', value.regulatoryIdentifierList[i]);
  if (SummaryOption in [soFull, soData]) then
    ComposeString(xml, 'partNumber', value.partNumberElement);
  if (SummaryOption in [soFull, soData]) then
    ComposeReference(xml, 'manufacturer', value.manufacturer);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.deviceNameList.Count - 1 do
      ComposeDeviceDefinitionDeviceName(xml, 'deviceName', value.deviceNameList[i]);
  if (SummaryOption in [soFull, soData]) then
    ComposeString(xml, 'modelNumber', value.modelNumberElement);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.classificationList.Count - 1 do
      ComposeDeviceDefinitionClassification(xml, 'classification', value.classificationList[i]);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.specializationList.Count - 1 do
      ComposeRelatedArtifact(xml, 'specialization', value.specializationList[i]);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.hasPartList.Count - 1 do
      ComposeDeviceDefinitionHasPart(xml, 'hasPart', value.hasPartList[i]);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.packagingList.Count - 1 do
      ComposeDeviceDefinitionPackaging(xml, 'packaging', value.packagingList[i]);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.versionList.Count - 1 do
      ComposeDeviceDefinitionVersion(xml, 'version', value.versionList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.safetyList.Count - 1 do
      ComposeCodeableConcept(xml, 'safety', value.safetyList[i]);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.shelfLifeStorageList.Count - 1 do
      ComposeProductShelfLife(xml, 'shelfLifeStorage', value.shelfLifeStorageList[i]);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.languageCodeList.Count - 1 do
      ComposeCodeableConcept(xml, 'languageCode', value.languageCodeList[i]);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.property_List.Count - 1 do
      ComposeDeviceDefinitionProperty(xml, 'property', value.property_List[i]);
  if (SummaryOption in [soFull, soData]) then
    ComposeReference(xml, 'owner', value.owner);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.contactList.Count - 1 do
      ComposeContactPoint(xml, 'contact', value.contactList[i]);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.link_List.Count - 1 do
      ComposeDeviceDefinitionLink(xml, 'link', value.link_List[i]);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.noteList.Count - 1 do
      ComposeAnnotation(xml, 'note', value.noteList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference(xml, 'parentDevice', value.parentDevice);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.materialList.Count - 1 do
      ComposeDeviceDefinitionMaterial(xml, 'material', value.materialList[i]);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.productionIdentifierInUDIList.Count - 1 do
      ComposeEnum(xml, 'productionIdentifierInUDI', value.productionIdentifierInUDIList[i], CODES_TFhirDeviceProductionIdentifierInUDIEnum);
  if (SummaryOption in [soFull, soData]) then
    ComposeDeviceDefinitionGuideline(xml, 'guideline', value.guideline);
  if (SummaryOption in [soFull, soData]) then
    ComposeDeviceDefinitionCorrectiveAction(xml, 'correctiveAction', value.correctiveAction);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.chargeItemList.Count - 1 do
      ComposeDeviceDefinitionChargeItem(xml, 'chargeItem', value.chargeItemList[i]);
end;

{$ENDIF FHIR_DEVICEDEFINITION}
{$IFDEF FHIR_DEVICEDISPENSE}
function TFHIRXmlParser.ParseDeviceDispensePerformer(element : TMXmlElement; path : string) : TFhirDeviceDispensePerformer;
var
  child : TMXmlElement;
begin
  result := TFhirDeviceDispensePerformer.Create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseDeviceDispensePerformerChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseDeviceDispensePerformerChild(value : TFhirDeviceDispensePerformer; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'function') then
        value.function_ := ParseCodeableConcept(child, path+'/function')
      else if (child.localName = 'actor') then
        value.actor := ParseReference(child, path+'/actor')
      else if Not ParseBackboneElementChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeDeviceDispensePerformer(xml : TXmlBuilder; name : String; value : TFhirDeviceDispensePerformer);
begin
  if (value = nil) then
    exit;
  composeElementAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeDeviceDispensePerformerChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeDeviceDispensePerformerChildren(xml : TXmlBuilder; value : TFhirDeviceDispensePerformer);
begin
  composeBackboneElementChildren(xml, value);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(xml, 'function', value.function_);
  ComposeReference(xml, 'actor', value.actor);
end;

function TFHIRXmlParser.ParseDeviceDispense(element : TMXmlElement; path : string) : TFhirDeviceDispense;
var
  child : TMXmlElement;
begin
  result := TFhirDeviceDispense.Create;
  try
    parseDomainResourceAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseDeviceDispenseChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseDeviceDispenseChild(value : TFhirDeviceDispense; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'identifier') then
        value.identifierList.Add(ParseIdentifier(child, path+'/identifier'))
      else if (child.localName = 'basedOn') then
        value.basedOnList.Add(ParseReference(child, path+'/basedOn'))
      else if (child.localName = 'partOf') then
        value.partOfList.Add(ParseReference(child, path+'/partOf'))
      else if (child.localName = 'status') then
        value.statusElement := ParseEnum(CODES_TFhirDeviceDispenseStatusCodesEnum, SYSTEMS_TFhirDeviceDispenseStatusCodesEnum, child, path+'/status')
      else if (child.localName = 'statusReason') then
        value.statusReason := ParseCodeableReference(child, path+'/statusReason')
      else if (child.localName = 'category') then
        value.categoryList.Add(ParseCodeableConcept(child, path+'/category'))
      else if (child.localName = 'device') then
        value.device := ParseCodeableReference(child, path+'/device')
      else if (child.localName = 'subject') then
        value.subject := ParseReference(child, path+'/subject')
      else if (child.localName = 'encounter') then
        value.encounter := ParseReference(child, path+'/encounter')
      else if (child.localName = 'supportingInformation') then
        value.supportingInformationList.Add(ParseReference(child, path+'/supportingInformation'))
      else if (child.localName = 'performer') then
        value.performerList.Add(ParseDeviceDispensePerformer(child, path+'/performer'))
      else if (child.localName = 'location') then
        value.location := ParseReference(child, path+'/location')
      else if (child.localName = 'type') then
        value.type_ := ParseCodeableConcept(child, path+'/type')
      else if (child.localName = 'quantity') then
        value.quantity := ParseQuantity(child, path+'/quantity')
      else if (child.localName = 'preparedDate') then
        value.preparedDateElement := ParseDateTime(child, path+'/preparedDate')
      else if (child.localName = 'whenHandedOver') then
        value.whenHandedOverElement := ParseDateTime(child, path+'/whenHandedOver')
      else if (child.localName = 'destination') then
        value.destination := ParseReference(child, path+'/destination')
      else if (child.localName = 'note') then
        value.noteList.Add(ParseAnnotation(child, path+'/note'))
      else if (child.localName = 'usageInstruction') then
        value.usageInstructionElement := ParseString(child, path+'/usageInstruction')
      else if (child.localName = 'eventHistory') then
        value.eventHistoryList.Add(ParseReference(child, path+'/eventHistory'))
      else if Not ParseDomainResourceChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeDeviceDispense(xml : TXmlBuilder; name : String; value : TFhirDeviceDispense);
begin
  if (value = nil) then
    exit;
  composeDomainResourceAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeDeviceDispenseChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeDeviceDispenseChildren(xml : TXmlBuilder; value : TFhirDeviceDispense);
var
  i : integer;
begin
  composeDomainResourceChildren(xml, value);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.identifierList.Count - 1 do
      ComposeIdentifier(xml, 'identifier', value.identifierList[i]);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.basedOnList.Count - 1 do
      ComposeReference(xml, 'basedOn', value.basedOnList[i]);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.partOfList.Count - 1 do
      ComposeReference(xml, 'partOf', value.partOfList[i]);
  ComposeEnum(xml, 'status', value.statusElement, CODES_TFhirDeviceDispenseStatusCodesEnum);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableReference(xml, 'statusReason', value.statusReason);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.categoryList.Count - 1 do
      ComposeCodeableConcept(xml, 'category', value.categoryList[i]);
  ComposeCodeableReference(xml, 'device', value.device);
  ComposeReference(xml, 'subject', value.subject);
  if (SummaryOption in [soFull, soData]) then
    ComposeReference(xml, 'encounter', value.encounter);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.supportingInformationList.Count - 1 do
      ComposeReference(xml, 'supportingInformation', value.supportingInformationList[i]);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.performerList.Count - 1 do
      ComposeDeviceDispensePerformer(xml, 'performer', value.performerList[i]);
  if (SummaryOption in [soFull, soData]) then
    ComposeReference(xml, 'location', value.location);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(xml, 'type', value.type_);
  if (SummaryOption in [soFull, soData]) then
    ComposeQuantity(xml, 'quantity', value.quantity);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDateTime(xml, 'preparedDate', value.preparedDateElement);
  if (SummaryOption in [soFull, soData]) then
    ComposeDateTime(xml, 'whenHandedOver', value.whenHandedOverElement);
  if (SummaryOption in [soFull, soData]) then
    ComposeReference(xml, 'destination', value.destination);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.noteList.Count - 1 do
      ComposeAnnotation(xml, 'note', value.noteList[i]);
  if (SummaryOption in [soFull, soData]) then
    ComposeString(xml, 'usageInstruction', value.usageInstructionElement);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.eventHistoryList.Count - 1 do
      ComposeReference(xml, 'eventHistory', value.eventHistoryList[i]);
end;

{$ENDIF FHIR_DEVICEDISPENSE}
{$IFDEF FHIR_DEVICEMETRIC}
function TFHIRXmlParser.ParseDeviceMetricCalibration(element : TMXmlElement; path : string) : TFhirDeviceMetricCalibration;
var
  child : TMXmlElement;
begin
  result := TFhirDeviceMetricCalibration.Create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseDeviceMetricCalibrationChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseDeviceMetricCalibrationChild(value : TFhirDeviceMetricCalibration; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'type') then
        value.type_Element := ParseEnum(CODES_TFhirDeviceMetricCalibrationTypeEnum, SYSTEMS_TFhirDeviceMetricCalibrationTypeEnum, child, path+'/type')
      else if (child.localName = 'state') then
        value.stateElement := ParseEnum(CODES_TFhirDeviceMetricCalibrationStateEnum, SYSTEMS_TFhirDeviceMetricCalibrationStateEnum, child, path+'/state')
      else if (child.localName = 'time') then
        value.timeElement := ParseInstant(child, path+'/time')
      else if Not ParseBackboneElementChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeDeviceMetricCalibration(xml : TXmlBuilder; name : String; value : TFhirDeviceMetricCalibration);
begin
  if (value = nil) then
    exit;
  composeElementAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeDeviceMetricCalibrationChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeDeviceMetricCalibrationChildren(xml : TXmlBuilder; value : TFhirDeviceMetricCalibration);
begin
  composeBackboneElementChildren(xml, value);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeEnum(xml, 'type', value.type_Element, CODES_TFhirDeviceMetricCalibrationTypeEnum);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeEnum(xml, 'state', value.stateElement, CODES_TFhirDeviceMetricCalibrationStateEnum);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeInstant(xml, 'time', value.timeElement);
end;

function TFHIRXmlParser.ParseDeviceMetric(element : TMXmlElement; path : string) : TFhirDeviceMetric;
var
  child : TMXmlElement;
begin
  result := TFhirDeviceMetric.Create;
  try
    parseDomainResourceAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseDeviceMetricChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseDeviceMetricChild(value : TFhirDeviceMetric; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'identifier') then
        value.identifierList.Add(ParseIdentifier(child, path+'/identifier'))
      else if (child.localName = 'type') then
        value.type_ := ParseCodeableConcept(child, path+'/type')
      else if (child.localName = 'unit') then
        value.unit_ := ParseCodeableConcept(child, path+'/unit')
      else if (child.localName = 'source') then
        value.source := ParseReference(child, path+'/source')
      else if (child.localName = 'parent') then
        value.parent := ParseReference(child, path+'/parent')
      else if (child.localName = 'operationalStatus') then
        value.operationalStatusElement := ParseEnum(CODES_TFhirDeviceMetricOperationalStatusEnum, SYSTEMS_TFhirDeviceMetricOperationalStatusEnum, child, path+'/operationalStatus')
      else if (child.localName = 'color') then
        value.colorElement := ParseEnum(CODES_TFhirDeviceMetricColorEnum, SYSTEMS_TFhirDeviceMetricColorEnum, child, path+'/color')
      else if (child.localName = 'category') then
        value.categoryElement := ParseEnum(CODES_TFhirDeviceMetricCategoryEnum, SYSTEMS_TFhirDeviceMetricCategoryEnum, child, path+'/category')
      else if (child.localName = 'measurementPeriod') then
        value.measurementPeriod := ParseTiming(child, path+'/measurementPeriod')
      else if (child.localName = 'calibration') then
        value.calibrationList.Add(ParseDeviceMetricCalibration(child, path+'/calibration'))
      else if Not ParseDomainResourceChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeDeviceMetric(xml : TXmlBuilder; name : String; value : TFhirDeviceMetric);
begin
  if (value = nil) then
    exit;
  composeDomainResourceAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeDeviceMetricChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeDeviceMetricChildren(xml : TXmlBuilder; value : TFhirDeviceMetric);
var
  i : integer;
begin
  composeDomainResourceChildren(xml, value);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.identifierList.Count - 1 do
      ComposeIdentifier(xml, 'identifier', value.identifierList[i]);
  ComposeCodeableConcept(xml, 'type', value.type_);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(xml, 'unit', value.unit_);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference(xml, 'source', value.source);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference(xml, 'parent', value.parent);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeEnum(xml, 'operationalStatus', value.operationalStatusElement, CODES_TFhirDeviceMetricOperationalStatusEnum);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeEnum(xml, 'color', value.colorElement, CODES_TFhirDeviceMetricColorEnum);
  ComposeEnum(xml, 'category', value.categoryElement, CODES_TFhirDeviceMetricCategoryEnum);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeTiming(xml, 'measurementPeriod', value.measurementPeriod);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.calibrationList.Count - 1 do
      ComposeDeviceMetricCalibration(xml, 'calibration', value.calibrationList[i]);
end;

{$ENDIF FHIR_DEVICEMETRIC}
{$IFDEF FHIR_DEVICEREQUEST}
function TFHIRXmlParser.ParseDeviceRequestParameter(element : TMXmlElement; path : string) : TFhirDeviceRequestParameter;
var
  child : TMXmlElement;
begin
  result := TFhirDeviceRequestParameter.Create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseDeviceRequestParameterChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseDeviceRequestParameterChild(value : TFhirDeviceRequestParameter; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'code') then
        value.code := ParseCodeableConcept(child, path+'/code')
      else if (child.localName = 'valueCodeableConcept') then
        value.value := ParseCodeableConcept(child, path+'/valueCodeableConcept')
      else if (child.localName = 'valueQuantity') then
        value.value := ParseQuantity(child, path+'/valueQuantity')
      else if (child.localName = 'valueRange') then
        value.value := ParseRange(child, path+'/valueRange')
      else if (child.localName = 'valueBoolean') then
        value.value := ParseBoolean(child, path+'/valueBoolean')
      else if Not ParseBackboneElementChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeDeviceRequestParameter(xml : TXmlBuilder; name : String; value : TFhirDeviceRequestParameter);
begin
  if (value = nil) then
    exit;
  composeElementAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeDeviceRequestParameterChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeDeviceRequestParameterChildren(xml : TXmlBuilder; value : TFhirDeviceRequestParameter);
begin
  composeBackboneElementChildren(xml, value);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(xml, 'code', value.code);
  if (SummaryOption in [soFull, soData]) and (value.value is TFhirCodeableConcept) {6} then
    ComposeCodeableConcept(xml, 'valueCodeableConcept', TFhirCodeableConcept(value.value))
  else if (SummaryOption in [soFull, soData]) and (value.value is TFhirQuantity) {6} then
    ComposeQuantity(xml, 'valueQuantity', TFhirQuantity(value.value))
  else if (SummaryOption in [soFull, soData]) and (value.value is TFhirRange) {6} then
    ComposeRange(xml, 'valueRange', TFhirRange(value.value))
  else if (SummaryOption in [soFull, soData]) and (value.value is TFhirBoolean) {6} then
    ComposeBoolean(xml, 'valueBoolean', TFhirBoolean(value.value));
end;

function TFHIRXmlParser.ParseDeviceRequest(element : TMXmlElement; path : string) : TFhirDeviceRequest;
var
  child : TMXmlElement;
begin
  result := TFhirDeviceRequest.Create;
  try
    parseDomainResourceAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseDeviceRequestChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseDeviceRequestChild(value : TFhirDeviceRequest; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'identifier') then
        value.identifierList.Add(ParseIdentifier(child, path+'/identifier'))
      else if (child.localName = 'instantiatesCanonical') then
        value.instantiatesCanonicalList.Add(ParseCanonical(child, path+'/instantiatesCanonical'))
      else if (child.localName = 'instantiatesUri') then
        value.instantiatesUriList.Add(ParseUri(child, path+'/instantiatesUri'))
      else if (child.localName = 'basedOn') then
        value.basedOnList.Add(ParseReference(child, path+'/basedOn'))
      else if (child.localName = 'replaces') then
        value.replacesList.Add(ParseReference(child, path+'/replaces'))
      else if (child.localName = 'groupIdentifier') then
        value.groupIdentifier := ParseIdentifier(child, path+'/groupIdentifier')
      else if (child.localName = 'status') then
        value.statusElement := ParseEnum(CODES_TFhirRequestStatusEnum, SYSTEMS_TFhirRequestStatusEnum, child, path+'/status')
      else if (child.localName = 'intent') then
        value.intentElement := ParseEnum(CODES_TFhirRequestIntentEnum, SYSTEMS_TFhirRequestIntentEnum, child, path+'/intent')
      else if (child.localName = 'priority') then
        value.priorityElement := ParseEnum(CODES_TFhirRequestPriorityEnum, SYSTEMS_TFhirRequestPriorityEnum, child, path+'/priority')
      else if (child.localName = 'doNotPerform') then
        value.doNotPerformElement := ParseBoolean(child, path+'/doNotPerform')
      else if (child.localName = 'code') then
        value.code := ParseCodeableReference(child, path+'/code')
      else if (child.localName = 'quantity') then
        value.quantityElement := ParseInteger(child, path+'/quantity')
      else if (child.localName = 'parameter') then
        value.parameterList.Add(ParseDeviceRequestParameter(child, path+'/parameter'))
      else if (child.localName = 'subject') then
        value.subject := ParseReference(child, path+'/subject')
      else if (child.localName = 'encounter') then
        value.encounter := ParseReference(child, path+'/encounter')
      else if (child.localName = 'occurrencePeriod') then
        value.occurrence := ParsePeriod(child, path+'/occurrencePeriod')
      else if (child.localName = 'occurrenceTiming') then
        value.occurrence := ParseTiming(child, path+'/occurrenceTiming')
      else if (child.localName = 'occurrenceDateTime') then
        value.occurrence := ParseDateTime(child, path+'/occurrenceDateTime')
      else if (child.localName = 'authoredOn') then
        value.authoredOnElement := ParseDateTime(child, path+'/authoredOn')
      else if (child.localName = 'requester') then
        value.requester := ParseReference(child, path+'/requester')
      else if (child.localName = 'performerType') then
        value.performerType := ParseCodeableConcept(child, path+'/performerType')
      else if (child.localName = 'performer') then
        value.performer := ParseReference(child, path+'/performer')
      else if (child.localName = 'reason') then
        value.reasonList.Add(ParseCodeableReference(child, path+'/reason'))
      else if (child.localName = 'asNeeded') then
        value.asNeededElement := ParseBoolean(child, path+'/asNeeded')
      else if (child.localName = 'asNeededFor') then
        value.asNeededFor := ParseCodeableConcept(child, path+'/asNeededFor')
      else if (child.localName = 'insurance') then
        value.insuranceList.Add(ParseReference(child, path+'/insurance'))
      else if (child.localName = 'supportingInfo') then
        value.supportingInfoList.Add(ParseReference(child, path+'/supportingInfo'))
      else if (child.localName = 'note') then
        value.noteList.Add(ParseAnnotation(child, path+'/note'))
      else if (child.localName = 'relevantHistory') then
        value.relevantHistoryList.Add(ParseReference(child, path+'/relevantHistory'))
      else if Not ParseDomainResourceChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeDeviceRequest(xml : TXmlBuilder; name : String; value : TFhirDeviceRequest);
begin
  if (value = nil) then
    exit;
  composeDomainResourceAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeDeviceRequestChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeDeviceRequestChildren(xml : TXmlBuilder; value : TFhirDeviceRequest);
var
  i : integer;
begin
  composeDomainResourceChildren(xml, value);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.identifierList.Count - 1 do
      ComposeIdentifier(xml, 'identifier', value.identifierList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.instantiatesCanonicalList.Count - 1 do
      ComposeCanonical(xml, 'instantiatesCanonical', value.instantiatesCanonicalList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.instantiatesUriList.Count - 1 do
      ComposeUri(xml, 'instantiatesUri', value.instantiatesUriList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.basedOnList.Count - 1 do
      ComposeReference(xml, 'basedOn', value.basedOnList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.replacesList.Count - 1 do
      ComposeReference(xml, 'replaces', value.replacesList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeIdentifier(xml, 'groupIdentifier', value.groupIdentifier);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeEnum(xml, 'status', value.statusElement, CODES_TFhirRequestStatusEnum);
  ComposeEnum(xml, 'intent', value.intentElement, CODES_TFhirRequestIntentEnum);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeEnum(xml, 'priority', value.priorityElement, CODES_TFhirRequestPriorityEnum);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeBoolean(xml, 'doNotPerform', value.doNotPerformElement);
  ComposeCodeableReference(xml, 'code', value.code);
  if (SummaryOption in [soFull, soData]) then
    ComposeInteger(xml, 'quantity', value.quantityElement);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.parameterList.Count - 1 do
      ComposeDeviceRequestParameter(xml, 'parameter', value.parameterList[i]);
  ComposeReference(xml, 'subject', value.subject);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference(xml, 'encounter', value.encounter);
  if (SummaryOption in [soFull, soSummary, soData]) and (value.occurrence is TFhirPeriod) {6} then
    ComposePeriod(xml, 'occurrencePeriod', TFhirPeriod(value.occurrence))
  else if (SummaryOption in [soFull, soSummary, soData]) and (value.occurrence is TFhirTiming) {6} then
    ComposeTiming(xml, 'occurrenceTiming', TFhirTiming(value.occurrence))
  else if (SummaryOption in [soFull, soSummary, soData]) and (value.occurrence is TFhirDateTime) {6} then
    ComposeDateTime(xml, 'occurrenceDateTime', TFhirDateTime(value.occurrence));
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDateTime(xml, 'authoredOn', value.authoredOnElement);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference(xml, 'requester', value.requester);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(xml, 'performerType', value.performerType);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference(xml, 'performer', value.performer);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.reasonList.Count - 1 do
      ComposeCodeableReference(xml, 'reason', value.reasonList[i]);
  if (SummaryOption in [soFull, soData]) then
    ComposeBoolean(xml, 'asNeeded', value.asNeededElement);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(xml, 'asNeededFor', value.asNeededFor);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.insuranceList.Count - 1 do
      ComposeReference(xml, 'insurance', value.insuranceList[i]);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.supportingInfoList.Count - 1 do
      ComposeReference(xml, 'supportingInfo', value.supportingInfoList[i]);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.noteList.Count - 1 do
      ComposeAnnotation(xml, 'note', value.noteList[i]);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.relevantHistoryList.Count - 1 do
      ComposeReference(xml, 'relevantHistory', value.relevantHistoryList[i]);
end;

{$ENDIF FHIR_DEVICEREQUEST}
{$IFDEF FHIR_DEVICEUSAGE}
function TFHIRXmlParser.ParseDeviceUsageAdherence(element : TMXmlElement; path : string) : TFhirDeviceUsageAdherence;
var
  child : TMXmlElement;
begin
  result := TFhirDeviceUsageAdherence.Create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseDeviceUsageAdherenceChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseDeviceUsageAdherenceChild(value : TFhirDeviceUsageAdherence; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'code') then
        value.code := ParseCodeableConcept(child, path+'/code')
      else if (child.localName = 'reason') then
        value.reasonList.Add(ParseCodeableConcept(child, path+'/reason'))
      else if Not ParseBackboneElementChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeDeviceUsageAdherence(xml : TXmlBuilder; name : String; value : TFhirDeviceUsageAdherence);
begin
  if (value = nil) then
    exit;
  composeElementAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeDeviceUsageAdherenceChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeDeviceUsageAdherenceChildren(xml : TXmlBuilder; value : TFhirDeviceUsageAdherence);
var
  i : integer;
begin
  composeBackboneElementChildren(xml, value);
  ComposeCodeableConcept(xml, 'code', value.code);
  for i := 0 to value.reasonList.Count - 1 do
      ComposeCodeableConcept(xml, 'reason', value.reasonList[i]);
end;

function TFHIRXmlParser.ParseDeviceUsage(element : TMXmlElement; path : string) : TFhirDeviceUsage;
var
  child : TMXmlElement;
begin
  result := TFhirDeviceUsage.Create;
  try
    parseDomainResourceAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseDeviceUsageChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseDeviceUsageChild(value : TFhirDeviceUsage; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'identifier') then
        value.identifierList.Add(ParseIdentifier(child, path+'/identifier'))
      else if (child.localName = 'basedOn') then
        value.basedOnList.Add(ParseReference(child, path+'/basedOn'))
      else if (child.localName = 'status') then
        value.statusElement := ParseEnum(CODES_TFhirDeviceUsageStatusEnum, SYSTEMS_TFhirDeviceUsageStatusEnum, child, path+'/status')
      else if (child.localName = 'category') then
        value.categoryList.Add(ParseCodeableConcept(child, path+'/category'))
      else if (child.localName = 'patient') then
        value.patient := ParseReference(child, path+'/patient')
      else if (child.localName = 'derivedFrom') then
        value.derivedFromList.Add(ParseReference(child, path+'/derivedFrom'))
      else if (child.localName = 'context') then
        value.context := ParseReference(child, path+'/context')
      else if (child.localName = 'timingTiming') then
        value.timing := ParseTiming(child, path+'/timingTiming')
      else if (child.localName = 'timingPeriod') then
        value.timing := ParsePeriod(child, path+'/timingPeriod')
      else if (child.localName = 'timingDateTime') then
        value.timing := ParseDateTime(child, path+'/timingDateTime')
      else if (child.localName = 'dateAsserted') then
        value.dateAssertedElement := ParseDateTime(child, path+'/dateAsserted')
      else if (child.localName = 'usageStatus') then
        value.usageStatus := ParseCodeableConcept(child, path+'/usageStatus')
      else if (child.localName = 'usageReason') then
        value.usageReasonList.Add(ParseCodeableConcept(child, path+'/usageReason'))
      else if (child.localName = 'adherence') then
        value.adherence := ParseDeviceUsageAdherence(child, path+'/adherence')
      else if (child.localName = 'informationSource') then
        value.informationSource := ParseReference(child, path+'/informationSource')
      else if (child.localName = 'device') then
        value.device := ParseCodeableReference(child, path+'/device')
      else if (child.localName = 'reason') then
        value.reasonList.Add(ParseCodeableReference(child, path+'/reason'))
      else if (child.localName = 'bodySite') then
        value.bodySite := ParseCodeableReference(child, path+'/bodySite')
      else if (child.localName = 'note') then
        value.noteList.Add(ParseAnnotation(child, path+'/note'))
      else if Not ParseDomainResourceChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeDeviceUsage(xml : TXmlBuilder; name : String; value : TFhirDeviceUsage);
begin
  if (value = nil) then
    exit;
  composeDomainResourceAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeDeviceUsageChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeDeviceUsageChildren(xml : TXmlBuilder; value : TFhirDeviceUsage);
var
  i : integer;
begin
  composeDomainResourceChildren(xml, value);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.identifierList.Count - 1 do
      ComposeIdentifier(xml, 'identifier', value.identifierList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.basedOnList.Count - 1 do
      ComposeReference(xml, 'basedOn', value.basedOnList[i]);
  ComposeEnum(xml, 'status', value.statusElement, CODES_TFhirDeviceUsageStatusEnum);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.categoryList.Count - 1 do
      ComposeCodeableConcept(xml, 'category', value.categoryList[i]);
  ComposeReference(xml, 'patient', value.patient);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.derivedFromList.Count - 1 do
      ComposeReference(xml, 'derivedFrom', value.derivedFromList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference(xml, 'context', value.context);
  if (SummaryOption in [soFull, soSummary, soData]) and (value.timing is TFhirTiming) {6} then
    ComposeTiming(xml, 'timingTiming', TFhirTiming(value.timing))
  else if (SummaryOption in [soFull, soSummary, soData]) and (value.timing is TFhirPeriod) {6} then
    ComposePeriod(xml, 'timingPeriod', TFhirPeriod(value.timing))
  else if (SummaryOption in [soFull, soSummary, soData]) and (value.timing is TFhirDateTime) {6} then
    ComposeDateTime(xml, 'timingDateTime', TFhirDateTime(value.timing));
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDateTime(xml, 'dateAsserted', value.dateAssertedElement);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(xml, 'usageStatus', value.usageStatus);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.usageReasonList.Count - 1 do
      ComposeCodeableConcept(xml, 'usageReason', value.usageReasonList[i]);
  if (SummaryOption in [soFull, soData]) then
    ComposeDeviceUsageAdherence(xml, 'adherence', value.adherence);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference(xml, 'informationSource', value.informationSource);
  ComposeCodeableReference(xml, 'device', value.device);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.reasonList.Count - 1 do
      ComposeCodeableReference(xml, 'reason', value.reasonList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableReference(xml, 'bodySite', value.bodySite);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.noteList.Count - 1 do
      ComposeAnnotation(xml, 'note', value.noteList[i]);
end;

{$ENDIF FHIR_DEVICEUSAGE}
{$IFDEF FHIR_DIAGNOSTICREPORT}
function TFHIRXmlParser.ParseDiagnosticReportSupportingInfo(element : TMXmlElement; path : string) : TFhirDiagnosticReportSupportingInfo;
var
  child : TMXmlElement;
begin
  result := TFhirDiagnosticReportSupportingInfo.Create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseDiagnosticReportSupportingInfoChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseDiagnosticReportSupportingInfoChild(value : TFhirDiagnosticReportSupportingInfo; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'type') then
        value.type_ := ParseCodeableConcept(child, path+'/type')
      else if (child.localName = 'reference') then
        value.reference := ParseReference(child, path+'/reference')
      else if Not ParseBackboneElementChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeDiagnosticReportSupportingInfo(xml : TXmlBuilder; name : String; value : TFhirDiagnosticReportSupportingInfo);
begin
  if (value = nil) then
    exit;
  composeElementAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeDiagnosticReportSupportingInfoChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeDiagnosticReportSupportingInfoChildren(xml : TXmlBuilder; value : TFhirDiagnosticReportSupportingInfo);
begin
  composeBackboneElementChildren(xml, value);
  ComposeCodeableConcept(xml, 'type', value.type_);
  ComposeReference(xml, 'reference', value.reference);
end;

function TFHIRXmlParser.ParseDiagnosticReportMedia(element : TMXmlElement; path : string) : TFhirDiagnosticReportMedia;
var
  child : TMXmlElement;
begin
  result := TFhirDiagnosticReportMedia.Create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseDiagnosticReportMediaChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseDiagnosticReportMediaChild(value : TFhirDiagnosticReportMedia; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'comment') then
        value.commentElement := ParseString(child, path+'/comment')
      else if (child.localName = 'link') then
        value.link_ := ParseReference(child, path+'/link')
      else if Not ParseBackboneElementChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeDiagnosticReportMedia(xml : TXmlBuilder; name : String; value : TFhirDiagnosticReportMedia);
begin
  if (value = nil) then
    exit;
  composeElementAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeDiagnosticReportMediaChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeDiagnosticReportMediaChildren(xml : TXmlBuilder; value : TFhirDiagnosticReportMedia);
begin
  composeBackboneElementChildren(xml, value);
  if (SummaryOption in [soFull, soData]) then
    ComposeString(xml, 'comment', value.commentElement);
  ComposeReference(xml, 'link', value.link_);
end;

function TFHIRXmlParser.ParseDiagnosticReport(element : TMXmlElement; path : string) : TFhirDiagnosticReport;
var
  child : TMXmlElement;
begin
  result := TFhirDiagnosticReport.Create;
  try
    parseDomainResourceAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseDiagnosticReportChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseDiagnosticReportChild(value : TFhirDiagnosticReport; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'identifier') then
        value.identifierList.Add(ParseIdentifier(child, path+'/identifier'))
      else if (child.localName = 'basedOn') then
        value.basedOnList.Add(ParseReference(child, path+'/basedOn'))
      else if (child.localName = 'status') then
        value.statusElement := ParseEnum(CODES_TFhirDiagnosticReportStatusEnum, SYSTEMS_TFhirDiagnosticReportStatusEnum, child, path+'/status')
      else if (child.localName = 'category') then
        value.categoryList.Add(ParseCodeableConcept(child, path+'/category'))
      else if (child.localName = 'code') then
        value.code := ParseCodeableConcept(child, path+'/code')
      else if (child.localName = 'subject') then
        value.subject := ParseReference(child, path+'/subject')
      else if (child.localName = 'encounter') then
        value.encounter := ParseReference(child, path+'/encounter')
      else if (child.localName = 'effectivePeriod') then
        value.effective := ParsePeriod(child, path+'/effectivePeriod')
      else if (child.localName = 'effectiveDateTime') then
        value.effective := ParseDateTime(child, path+'/effectiveDateTime')
      else if (child.localName = 'issued') then
        value.issuedElement := ParseInstant(child, path+'/issued')
      else if (child.localName = 'performer') then
        value.performerList.Add(ParseReference(child, path+'/performer'))
      else if (child.localName = 'resultsInterpreter') then
        value.resultsInterpreterList.Add(ParseReference(child, path+'/resultsInterpreter'))
      else if (child.localName = 'specimen') then
        value.specimenList.Add(ParseReference(child, path+'/specimen'))
      else if (child.localName = 'result') then
        value.resultList.Add(ParseReference(child, path+'/result'))
      else if (child.localName = 'note') then
        value.noteList.Add(ParseAnnotation(child, path+'/note'))
      else if (child.localName = 'study') then
        value.studyList.Add(ParseReference(child, path+'/study'))
      else if (child.localName = 'supportingInfo') then
        value.supportingInfoList.Add(ParseDiagnosticReportSupportingInfo(child, path+'/supportingInfo'))
      else if (child.localName = 'media') then
        value.mediaList.Add(ParseDiagnosticReportMedia(child, path+'/media'))
      else if (child.localName = 'composition') then
        value.composition := ParseReference(child, path+'/composition')
      else if (child.localName = 'conclusion') then
        value.conclusionElement := ParseString(child, path+'/conclusion')
      else if (child.localName = 'conclusionCode') then
        value.conclusionCodeList.Add(ParseCodeableConcept(child, path+'/conclusionCode'))
      else if (child.localName = 'presentedForm') then
        value.presentedFormList.Add(ParseAttachment(child, path+'/presentedForm'))
      else if Not ParseDomainResourceChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeDiagnosticReport(xml : TXmlBuilder; name : String; value : TFhirDiagnosticReport);
begin
  if (value = nil) then
    exit;
  composeDomainResourceAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeDiagnosticReportChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeDiagnosticReportChildren(xml : TXmlBuilder; value : TFhirDiagnosticReport);
var
  i : integer;
begin
  composeDomainResourceChildren(xml, value);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.identifierList.Count - 1 do
      ComposeIdentifier(xml, 'identifier', value.identifierList[i]);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.basedOnList.Count - 1 do
      ComposeReference(xml, 'basedOn', value.basedOnList[i]);
  ComposeEnum(xml, 'status', value.statusElement, CODES_TFhirDiagnosticReportStatusEnum);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.categoryList.Count - 1 do
      ComposeCodeableConcept(xml, 'category', value.categoryList[i]);
  ComposeCodeableConcept(xml, 'code', value.code);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference(xml, 'subject', value.subject);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference(xml, 'encounter', value.encounter);
  if (SummaryOption in [soFull, soSummary, soData]) and (value.effective is TFhirPeriod) {6} then
    ComposePeriod(xml, 'effectivePeriod', TFhirPeriod(value.effective))
  else if (SummaryOption in [soFull, soSummary, soData]) and (value.effective is TFhirDateTime) {6} then
    ComposeDateTime(xml, 'effectiveDateTime', TFhirDateTime(value.effective));
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeInstant(xml, 'issued', value.issuedElement);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.performerList.Count - 1 do
      ComposeReference(xml, 'performer', value.performerList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.resultsInterpreterList.Count - 1 do
      ComposeReference(xml, 'resultsInterpreter', value.resultsInterpreterList[i]);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.specimenList.Count - 1 do
      ComposeReference(xml, 'specimen', value.specimenList[i]);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.resultList.Count - 1 do
      ComposeReference(xml, 'result', value.resultList[i]);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.noteList.Count - 1 do
      ComposeAnnotation(xml, 'note', value.noteList[i]);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.studyList.Count - 1 do
      ComposeReference(xml, 'study', value.studyList[i]);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.supportingInfoList.Count - 1 do
      ComposeDiagnosticReportSupportingInfo(xml, 'supportingInfo', value.supportingInfoList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.mediaList.Count - 1 do
      ComposeDiagnosticReportMedia(xml, 'media', value.mediaList[i]);
  if (SummaryOption in [soFull, soData]) then
    ComposeReference(xml, 'composition', value.composition);
  if (SummaryOption in [soFull, soData]) then
    ComposeString(xml, 'conclusion', value.conclusionElement);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.conclusionCodeList.Count - 1 do
      ComposeCodeableConcept(xml, 'conclusionCode', value.conclusionCodeList[i]);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.presentedFormList.Count - 1 do
      ComposeAttachment(xml, 'presentedForm', value.presentedFormList[i]);
end;

{$ENDIF FHIR_DIAGNOSTICREPORT}
{$IFDEF FHIR_DOCUMENTMANIFEST}
function TFHIRXmlParser.ParseDocumentManifestRelated(element : TMXmlElement; path : string) : TFhirDocumentManifestRelated;
var
  child : TMXmlElement;
begin
  result := TFhirDocumentManifestRelated.Create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseDocumentManifestRelatedChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseDocumentManifestRelatedChild(value : TFhirDocumentManifestRelated; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'identifier') then
        value.identifier := ParseIdentifier(child, path+'/identifier')
      else if (child.localName = 'ref') then
        value.ref := ParseReference(child, path+'/ref')
      else if Not ParseBackboneElementChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeDocumentManifestRelated(xml : TXmlBuilder; name : String; value : TFhirDocumentManifestRelated);
begin
  if (value = nil) then
    exit;
  composeElementAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeDocumentManifestRelatedChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeDocumentManifestRelatedChildren(xml : TXmlBuilder; value : TFhirDocumentManifestRelated);
begin
  composeBackboneElementChildren(xml, value);
  if (SummaryOption in [soFull, soData]) then
    ComposeIdentifier(xml, 'identifier', value.identifier);
  if (SummaryOption in [soFull, soData]) then
    ComposeReference(xml, 'ref', value.ref);
end;

function TFHIRXmlParser.ParseDocumentManifest(element : TMXmlElement; path : string) : TFhirDocumentManifest;
var
  child : TMXmlElement;
begin
  result := TFhirDocumentManifest.Create;
  try
    parseDomainResourceAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseDocumentManifestChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseDocumentManifestChild(value : TFhirDocumentManifest; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'masterIdentifier') then
        value.masterIdentifier := ParseIdentifier(child, path+'/masterIdentifier')
      else if (child.localName = 'identifier') then
        value.identifierList.Add(ParseIdentifier(child, path+'/identifier'))
      else if (child.localName = 'status') then
        value.statusElement := ParseEnum(CODES_TFhirDocumentReferenceStatusEnum, SYSTEMS_TFhirDocumentReferenceStatusEnum, child, path+'/status')
      else if (child.localName = 'type') then
        value.type_ := ParseCodeableConcept(child, path+'/type')
      else if (child.localName = 'subject') then
        value.subject := ParseReference(child, path+'/subject')
      else if (child.localName = 'created') then
        value.createdElement := ParseDateTime(child, path+'/created')
      else if (child.localName = 'author') then
        value.authorList.Add(ParseReference(child, path+'/author'))
      else if (child.localName = 'recipient') then
        value.recipientList.Add(ParseReference(child, path+'/recipient'))
      else if (child.localName = 'source') then
        value.sourceElement := ParseUri(child, path+'/source')
      else if (child.localName = 'description') then
        value.descriptionElement := ParseString(child, path+'/description')
      else if (child.localName = 'content') then
        value.contentList.Add(ParseReference(child, path+'/content'))
      else if (child.localName = 'related') then
        value.relatedList.Add(ParseDocumentManifestRelated(child, path+'/related'))
      else if Not ParseDomainResourceChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeDocumentManifest(xml : TXmlBuilder; name : String; value : TFhirDocumentManifest);
begin
  if (value = nil) then
    exit;
  composeDomainResourceAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeDocumentManifestChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeDocumentManifestChildren(xml : TXmlBuilder; value : TFhirDocumentManifest);
var
  i : integer;
begin
  composeDomainResourceChildren(xml, value);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeIdentifier(xml, 'masterIdentifier', value.masterIdentifier);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.identifierList.Count - 1 do
      ComposeIdentifier(xml, 'identifier', value.identifierList[i]);
  ComposeEnum(xml, 'status', value.statusElement, CODES_TFhirDocumentReferenceStatusEnum);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(xml, 'type', value.type_);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference(xml, 'subject', value.subject);
  if (SummaryOption in [soFull, soData]) then
    ComposeDateTime(xml, 'created', value.createdElement);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.authorList.Count - 1 do
      ComposeReference(xml, 'author', value.authorList[i]);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.recipientList.Count - 1 do
      ComposeReference(xml, 'recipient', value.recipientList[i]);
  if (SummaryOption in [soFull, soData]) then
    ComposeUri(xml, 'source', value.sourceElement);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(xml, 'description', value.descriptionElement);
  for i := 0 to value.contentList.Count - 1 do
      ComposeReference(xml, 'content', value.contentList[i]);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.relatedList.Count - 1 do
      ComposeDocumentManifestRelated(xml, 'related', value.relatedList[i]);
end;

{$ENDIF FHIR_DOCUMENTMANIFEST}
{$IFDEF FHIR_DOCUMENTREFERENCE}
function TFHIRXmlParser.ParseDocumentReferenceAttester(element : TMXmlElement; path : string) : TFhirDocumentReferenceAttester;
var
  child : TMXmlElement;
begin
  result := TFhirDocumentReferenceAttester.Create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseDocumentReferenceAttesterChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseDocumentReferenceAttesterChild(value : TFhirDocumentReferenceAttester; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'mode') then
        value.mode := ParseCodeableConcept(child, path+'/mode')
      else if (child.localName = 'time') then
        value.timeElement := ParseDateTime(child, path+'/time')
      else if (child.localName = 'party') then
        value.party := ParseReference(child, path+'/party')
      else if Not ParseBackboneElementChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeDocumentReferenceAttester(xml : TXmlBuilder; name : String; value : TFhirDocumentReferenceAttester);
begin
  if (value = nil) then
    exit;
  composeElementAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeDocumentReferenceAttesterChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeDocumentReferenceAttesterChildren(xml : TXmlBuilder; value : TFhirDocumentReferenceAttester);
begin
  composeBackboneElementChildren(xml, value);
  ComposeCodeableConcept(xml, 'mode', value.mode);
  if (SummaryOption in [soFull, soData]) then
    ComposeDateTime(xml, 'time', value.timeElement);
  if (SummaryOption in [soFull, soData]) then
    ComposeReference(xml, 'party', value.party);
end;

function TFHIRXmlParser.ParseDocumentReferenceRelatesTo(element : TMXmlElement; path : string) : TFhirDocumentReferenceRelatesTo;
var
  child : TMXmlElement;
begin
  result := TFhirDocumentReferenceRelatesTo.Create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseDocumentReferenceRelatesToChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseDocumentReferenceRelatesToChild(value : TFhirDocumentReferenceRelatesTo; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'code') then
        value.code := ParseCodeableConcept(child, path+'/code')
      else if (child.localName = 'target') then
        value.target := ParseReference(child, path+'/target')
      else if Not ParseBackboneElementChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeDocumentReferenceRelatesTo(xml : TXmlBuilder; name : String; value : TFhirDocumentReferenceRelatesTo);
begin
  if (value = nil) then
    exit;
  composeElementAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeDocumentReferenceRelatesToChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeDocumentReferenceRelatesToChildren(xml : TXmlBuilder; value : TFhirDocumentReferenceRelatesTo);
begin
  composeBackboneElementChildren(xml, value);
  ComposeCodeableConcept(xml, 'code', value.code);
  ComposeReference(xml, 'target', value.target);
end;

function TFHIRXmlParser.ParseDocumentReferenceContent(element : TMXmlElement; path : string) : TFhirDocumentReferenceContent;
var
  child : TMXmlElement;
begin
  result := TFhirDocumentReferenceContent.Create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseDocumentReferenceContentChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseDocumentReferenceContentChild(value : TFhirDocumentReferenceContent; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'attachment') then
        value.attachment := ParseAttachment(child, path+'/attachment')
      else if (child.localName = 'profile') then
        value.profileList.Add(ParseDocumentReferenceContentProfile(child, path+'/profile'))
      else if Not ParseBackboneElementChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeDocumentReferenceContent(xml : TXmlBuilder; name : String; value : TFhirDocumentReferenceContent);
begin
  if (value = nil) then
    exit;
  composeElementAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeDocumentReferenceContentChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeDocumentReferenceContentChildren(xml : TXmlBuilder; value : TFhirDocumentReferenceContent);
var
  i : integer;
begin
  composeBackboneElementChildren(xml, value);
  ComposeAttachment(xml, 'attachment', value.attachment);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.profileList.Count - 1 do
      ComposeDocumentReferenceContentProfile(xml, 'profile', value.profileList[i]);
end;

function TFHIRXmlParser.ParseDocumentReferenceContentProfile(element : TMXmlElement; path : string) : TFhirDocumentReferenceContentProfile;
var
  child : TMXmlElement;
begin
  result := TFhirDocumentReferenceContentProfile.Create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseDocumentReferenceContentProfileChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseDocumentReferenceContentProfileChild(value : TFhirDocumentReferenceContentProfile; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'valueCoding') then
        value.value := ParseCoding(child, path+'/valueCoding')
      else if (child.localName = 'valueCanonical') then
        value.value := ParseCanonical(child, path+'/valueCanonical')
      else if (child.localName = 'valueUri') then
        value.value := ParseUri(child, path+'/valueUri')
      else if Not ParseBackboneElementChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeDocumentReferenceContentProfile(xml : TXmlBuilder; name : String; value : TFhirDocumentReferenceContentProfile);
begin
  if (value = nil) then
    exit;
  composeElementAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeDocumentReferenceContentProfileChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeDocumentReferenceContentProfileChildren(xml : TXmlBuilder; value : TFhirDocumentReferenceContentProfile);
begin
  composeBackboneElementChildren(xml, value);
  if (value.value is TFhirCoding) {6} then
    ComposeCoding(xml, 'valueCoding', TFhirCoding(value.value))
  else if (value.value is TFhirCanonical) {6} then
    ComposeCanonical(xml, 'valueCanonical', TFhirCanonical(value.value))
  else if (value.value is TFhirUri) {6} then
    ComposeUri(xml, 'valueUri', TFhirUri(value.value));
end;

function TFHIRXmlParser.ParseDocumentReference(element : TMXmlElement; path : string) : TFhirDocumentReference;
var
  child : TMXmlElement;
begin
  result := TFhirDocumentReference.Create;
  try
    parseDomainResourceAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseDocumentReferenceChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseDocumentReferenceChild(value : TFhirDocumentReference; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'identifier') then
        value.identifierList.Add(ParseIdentifier(child, path+'/identifier'))
      else if (child.localName = 'basedOn') then
        value.basedOnList.Add(ParseReference(child, path+'/basedOn'))
      else if (child.localName = 'status') then
        value.statusElement := ParseEnum(CODES_TFhirDocumentReferenceStatusEnum, SYSTEMS_TFhirDocumentReferenceStatusEnum, child, path+'/status')
      else if (child.localName = 'docStatus') then
        value.docStatusElement := ParseEnum(CODES_TFhirCompositionStatusEnum, SYSTEMS_TFhirCompositionStatusEnum, child, path+'/docStatus')
      else if (child.localName = 'type') then
        value.type_ := ParseCodeableConcept(child, path+'/type')
      else if (child.localName = 'category') then
        value.categoryList.Add(ParseCodeableConcept(child, path+'/category'))
      else if (child.localName = 'subject') then
        value.subject := ParseReference(child, path+'/subject')
      else if (child.localName = 'context') then
        value.contextList.Add(ParseReference(child, path+'/context'))
      else if (child.localName = 'event') then
        value.eventList.Add(ParseCodeableReference(child, path+'/event'))
      else if (child.localName = 'facilityType') then
        value.facilityType := ParseCodeableConcept(child, path+'/facilityType')
      else if (child.localName = 'practiceSetting') then
        value.practiceSetting := ParseCodeableConcept(child, path+'/practiceSetting')
      else if (child.localName = 'period') then
        value.period := ParsePeriod(child, path+'/period')
      else if (child.localName = 'date') then
        value.dateElement := ParseInstant(child, path+'/date')
      else if (child.localName = 'author') then
        value.authorList.Add(ParseReference(child, path+'/author'))
      else if (child.localName = 'attester') then
        value.attesterList.Add(ParseDocumentReferenceAttester(child, path+'/attester'))
      else if (child.localName = 'custodian') then
        value.custodian := ParseReference(child, path+'/custodian')
      else if (child.localName = 'relatesTo') then
        value.relatesToList.Add(ParseDocumentReferenceRelatesTo(child, path+'/relatesTo'))
      else if (child.localName = 'description') then
        value.descriptionElement := ParseMarkdown(child, path+'/description')
      else if (child.localName = 'securityLabel') then
        value.securityLabelList.Add(ParseCodeableConcept(child, path+'/securityLabel'))
      else if (child.localName = 'content') then
        value.contentList.Add(ParseDocumentReferenceContent(child, path+'/content'))
      else if Not ParseDomainResourceChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeDocumentReference(xml : TXmlBuilder; name : String; value : TFhirDocumentReference);
begin
  if (value = nil) then
    exit;
  composeDomainResourceAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeDocumentReferenceChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeDocumentReferenceChildren(xml : TXmlBuilder; value : TFhirDocumentReference);
var
  i : integer;
begin
  composeDomainResourceChildren(xml, value);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.identifierList.Count - 1 do
      ComposeIdentifier(xml, 'identifier', value.identifierList[i]);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.basedOnList.Count - 1 do
      ComposeReference(xml, 'basedOn', value.basedOnList[i]);
  ComposeEnum(xml, 'status', value.statusElement, CODES_TFhirDocumentReferenceStatusEnum);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeEnum(xml, 'docStatus', value.docStatusElement, CODES_TFhirCompositionStatusEnum);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(xml, 'type', value.type_);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.categoryList.Count - 1 do
      ComposeCodeableConcept(xml, 'category', value.categoryList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference(xml, 'subject', value.subject);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.contextList.Count - 1 do
      ComposeReference(xml, 'context', value.contextList[i]);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.eventList.Count - 1 do
      ComposeCodeableReference(xml, 'event', value.eventList[i]);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(xml, 'facilityType', value.facilityType);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(xml, 'practiceSetting', value.practiceSetting);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposePeriod(xml, 'period', value.period);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeInstant(xml, 'date', value.dateElement);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.authorList.Count - 1 do
      ComposeReference(xml, 'author', value.authorList[i]);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.attesterList.Count - 1 do
      ComposeDocumentReferenceAttester(xml, 'attester', value.attesterList[i]);
  if (SummaryOption in [soFull, soData]) then
    ComposeReference(xml, 'custodian', value.custodian);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.relatesToList.Count - 1 do
      ComposeDocumentReferenceRelatesTo(xml, 'relatesTo', value.relatesToList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeMarkdown(xml, 'description', value.descriptionElement);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.securityLabelList.Count - 1 do
      ComposeCodeableConcept(xml, 'securityLabel', value.securityLabelList[i]);
  for i := 0 to value.contentList.Count - 1 do
      ComposeDocumentReferenceContent(xml, 'content', value.contentList[i]);
end;

{$ENDIF FHIR_DOCUMENTREFERENCE}
{$IFDEF FHIR_ENCOUNTER}
function TFHIRXmlParser.ParseEncounterStatusHistory(element : TMXmlElement; path : string) : TFhirEncounterStatusHistory;
var
  child : TMXmlElement;
begin
  result := TFhirEncounterStatusHistory.Create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseEncounterStatusHistoryChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseEncounterStatusHistoryChild(value : TFhirEncounterStatusHistory; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'status') then
        value.statusElement := ParseEnum(CODES_TFhirEncounterStatusEnum, SYSTEMS_TFhirEncounterStatusEnum, child, path+'/status')
      else if (child.localName = 'period') then
        value.period := ParsePeriod(child, path+'/period')
      else if Not ParseBackboneElementChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeEncounterStatusHistory(xml : TXmlBuilder; name : String; value : TFhirEncounterStatusHistory);
begin
  if (value = nil) then
    exit;
  composeElementAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeEncounterStatusHistoryChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeEncounterStatusHistoryChildren(xml : TXmlBuilder; value : TFhirEncounterStatusHistory);
begin
  composeBackboneElementChildren(xml, value);
  ComposeEnum(xml, 'status', value.statusElement, CODES_TFhirEncounterStatusEnum);
  ComposePeriod(xml, 'period', value.period);
end;

function TFHIRXmlParser.ParseEncounterClassHistory(element : TMXmlElement; path : string) : TFhirEncounterClassHistory;
var
  child : TMXmlElement;
begin
  result := TFhirEncounterClassHistory.Create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseEncounterClassHistoryChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseEncounterClassHistoryChild(value : TFhirEncounterClassHistory; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'class') then
        value.class_ := ParseCoding(child, path+'/class')
      else if (child.localName = 'period') then
        value.period := ParsePeriod(child, path+'/period')
      else if Not ParseBackboneElementChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeEncounterClassHistory(xml : TXmlBuilder; name : String; value : TFhirEncounterClassHistory);
begin
  if (value = nil) then
    exit;
  composeElementAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeEncounterClassHistoryChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeEncounterClassHistoryChildren(xml : TXmlBuilder; value : TFhirEncounterClassHistory);
begin
  composeBackboneElementChildren(xml, value);
  ComposeCoding(xml, 'class', value.class_);
  ComposePeriod(xml, 'period', value.period);
end;

function TFHIRXmlParser.ParseEncounterParticipant(element : TMXmlElement; path : string) : TFhirEncounterParticipant;
var
  child : TMXmlElement;
begin
  result := TFhirEncounterParticipant.Create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseEncounterParticipantChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseEncounterParticipantChild(value : TFhirEncounterParticipant; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'type') then
        value.type_List.Add(ParseCodeableConcept(child, path+'/type'))
      else if (child.localName = 'period') then
        value.period := ParsePeriod(child, path+'/period')
      else if (child.localName = 'actor') then
        value.actor := ParseReference(child, path+'/actor')
      else if Not ParseBackboneElementChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeEncounterParticipant(xml : TXmlBuilder; name : String; value : TFhirEncounterParticipant);
begin
  if (value = nil) then
    exit;
  composeElementAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeEncounterParticipantChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeEncounterParticipantChildren(xml : TXmlBuilder; value : TFhirEncounterParticipant);
var
  i : integer;
begin
  composeBackboneElementChildren(xml, value);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.type_List.Count - 1 do
      ComposeCodeableConcept(xml, 'type', value.type_List[i]);
  if (SummaryOption in [soFull, soData]) then
    ComposePeriod(xml, 'period', value.period);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference(xml, 'actor', value.actor);
end;

function TFHIRXmlParser.ParseEncounterDiagnosis(element : TMXmlElement; path : string) : TFhirEncounterDiagnosis;
var
  child : TMXmlElement;
begin
  result := TFhirEncounterDiagnosis.Create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseEncounterDiagnosisChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseEncounterDiagnosisChild(value : TFhirEncounterDiagnosis; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'condition') then
        value.condition := ParseReference(child, path+'/condition')
      else if (child.localName = 'use') then
        value.use := ParseCodeableConcept(child, path+'/use')
      else if (child.localName = 'rank') then
        value.rankElement := ParsePositiveInt(child, path+'/rank')
      else if Not ParseBackboneElementChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeEncounterDiagnosis(xml : TXmlBuilder; name : String; value : TFhirEncounterDiagnosis);
begin
  if (value = nil) then
    exit;
  composeElementAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeEncounterDiagnosisChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeEncounterDiagnosisChildren(xml : TXmlBuilder; value : TFhirEncounterDiagnosis);
begin
  composeBackboneElementChildren(xml, value);
  ComposeReference(xml, 'condition', value.condition);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(xml, 'use', value.use);
  if (SummaryOption in [soFull, soData]) then
    ComposePositiveInt(xml, 'rank', value.rankElement);
end;

function TFHIRXmlParser.ParseEncounterAdmission(element : TMXmlElement; path : string) : TFhirEncounterAdmission;
var
  child : TMXmlElement;
begin
  result := TFhirEncounterAdmission.Create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseEncounterAdmissionChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseEncounterAdmissionChild(value : TFhirEncounterAdmission; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'preAdmissionIdentifier') then
        value.preAdmissionIdentifier := ParseIdentifier(child, path+'/preAdmissionIdentifier')
      else if (child.localName = 'origin') then
        value.origin := ParseReference(child, path+'/origin')
      else if (child.localName = 'admitSource') then
        value.admitSource := ParseCodeableConcept(child, path+'/admitSource')
      else if (child.localName = 'reAdmission') then
        value.reAdmission := ParseCodeableConcept(child, path+'/reAdmission')
      else if (child.localName = 'dietPreference') then
        value.dietPreferenceList.Add(ParseCodeableConcept(child, path+'/dietPreference'))
      else if (child.localName = 'specialCourtesy') then
        value.specialCourtesyList.Add(ParseCodeableConcept(child, path+'/specialCourtesy'))
      else if (child.localName = 'specialArrangement') then
        value.specialArrangementList.Add(ParseCodeableConcept(child, path+'/specialArrangement'))
      else if (child.localName = 'destination') then
        value.destination := ParseReference(child, path+'/destination')
      else if (child.localName = 'dischargeDisposition') then
        value.dischargeDisposition := ParseCodeableConcept(child, path+'/dischargeDisposition')
      else if Not ParseBackboneElementChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeEncounterAdmission(xml : TXmlBuilder; name : String; value : TFhirEncounterAdmission);
begin
  if (value = nil) then
    exit;
  composeElementAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeEncounterAdmissionChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeEncounterAdmissionChildren(xml : TXmlBuilder; value : TFhirEncounterAdmission);
var
  i : integer;
begin
  composeBackboneElementChildren(xml, value);
  if (SummaryOption in [soFull, soData]) then
    ComposeIdentifier(xml, 'preAdmissionIdentifier', value.preAdmissionIdentifier);
  if (SummaryOption in [soFull, soData]) then
    ComposeReference(xml, 'origin', value.origin);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(xml, 'admitSource', value.admitSource);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(xml, 'reAdmission', value.reAdmission);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.dietPreferenceList.Count - 1 do
      ComposeCodeableConcept(xml, 'dietPreference', value.dietPreferenceList[i]);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.specialCourtesyList.Count - 1 do
      ComposeCodeableConcept(xml, 'specialCourtesy', value.specialCourtesyList[i]);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.specialArrangementList.Count - 1 do
      ComposeCodeableConcept(xml, 'specialArrangement', value.specialArrangementList[i]);
  if (SummaryOption in [soFull, soData]) then
    ComposeReference(xml, 'destination', value.destination);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(xml, 'dischargeDisposition', value.dischargeDisposition);
end;

function TFHIRXmlParser.ParseEncounterLocation(element : TMXmlElement; path : string) : TFhirEncounterLocation;
var
  child : TMXmlElement;
begin
  result := TFhirEncounterLocation.Create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseEncounterLocationChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseEncounterLocationChild(value : TFhirEncounterLocation; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'location') then
        value.location := ParseReference(child, path+'/location')
      else if (child.localName = 'status') then
        value.statusElement := ParseEnum(CODES_TFhirEncounterLocationStatusEnum, SYSTEMS_TFhirEncounterLocationStatusEnum, child, path+'/status')
      else if (child.localName = 'form') then
        value.form := ParseCodeableConcept(child, path+'/form')
      else if (child.localName = 'period') then
        value.period := ParsePeriod(child, path+'/period')
      else if Not ParseBackboneElementChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeEncounterLocation(xml : TXmlBuilder; name : String; value : TFhirEncounterLocation);
begin
  if (value = nil) then
    exit;
  composeElementAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeEncounterLocationChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeEncounterLocationChildren(xml : TXmlBuilder; value : TFhirEncounterLocation);
begin
  composeBackboneElementChildren(xml, value);
  ComposeReference(xml, 'location', value.location);
  if (SummaryOption in [soFull, soData]) then
    ComposeEnum(xml, 'status', value.statusElement, CODES_TFhirEncounterLocationStatusEnum);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(xml, 'form', value.form);
  if (SummaryOption in [soFull, soData]) then
    ComposePeriod(xml, 'period', value.period);
end;

function TFHIRXmlParser.ParseEncounter(element : TMXmlElement; path : string) : TFhirEncounter;
var
  child : TMXmlElement;
begin
  result := TFhirEncounter.Create;
  try
    parseDomainResourceAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseEncounterChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseEncounterChild(value : TFhirEncounter; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'identifier') then
        value.identifierList.Add(ParseIdentifier(child, path+'/identifier'))
      else if (child.localName = 'status') then
        value.statusElement := ParseEnum(CODES_TFhirEncounterStatusEnum, SYSTEMS_TFhirEncounterStatusEnum, child, path+'/status')
      else if (child.localName = 'statusHistory') then
        value.statusHistoryList.Add(ParseEncounterStatusHistory(child, path+'/statusHistory'))
      else if (child.localName = 'class') then
        value.class_List.Add(ParseCodeableConcept(child, path+'/class'))
      else if (child.localName = 'classHistory') then
        value.classHistoryList.Add(ParseEncounterClassHistory(child, path+'/classHistory'))
      else if (child.localName = 'priority') then
        value.priority := ParseCodeableConcept(child, path+'/priority')
      else if (child.localName = 'type') then
        value.type_List.Add(ParseCodeableConcept(child, path+'/type'))
      else if (child.localName = 'serviceType') then
        value.serviceTypeList.Add(ParseCodeableReference(child, path+'/serviceType'))
      else if (child.localName = 'subject') then
        value.subject := ParseReference(child, path+'/subject')
      else if (child.localName = 'subjectStatus') then
        value.subjectStatus := ParseCodeableConcept(child, path+'/subjectStatus')
      else if (child.localName = 'episodeOfCare') then
        value.episodeOfCareList.Add(ParseReference(child, path+'/episodeOfCare'))
      else if (child.localName = 'basedOn') then
        value.basedOnList.Add(ParseReference(child, path+'/basedOn'))
      else if (child.localName = 'careTeam') then
        value.careTeamList.Add(ParseReference(child, path+'/careTeam'))
      else if (child.localName = 'partOf') then
        value.partOf := ParseReference(child, path+'/partOf')
      else if (child.localName = 'serviceProvider') then
        value.serviceProvider := ParseReference(child, path+'/serviceProvider')
      else if (child.localName = 'participant') then
        value.participantList.Add(ParseEncounterParticipant(child, path+'/participant'))
      else if (child.localName = 'appointment') then
        value.appointmentList.Add(ParseReference(child, path+'/appointment'))
      else if (child.localName = 'virtualService') then
        value.virtualServiceList.Add(ParseVirtualServiceDetail(child, path+'/virtualService'))
      else if (child.localName = 'actualPeriod') then
        value.actualPeriod := ParsePeriod(child, path+'/actualPeriod')
      else if (child.localName = 'plannedStartDate') then
        value.plannedStartDateElement := ParseDateTime(child, path+'/plannedStartDate')
      else if (child.localName = 'plannedEndDate') then
        value.plannedEndDateElement := ParseDateTime(child, path+'/plannedEndDate')
      else if (child.localName = 'length') then
        value.length := ParseDuration(child, path+'/length')
      else if (child.localName = 'reason') then
        value.reasonList.Add(ParseCodeableReference(child, path+'/reason'))
      else if (child.localName = 'diagnosis') then
        value.diagnosisList.Add(ParseEncounterDiagnosis(child, path+'/diagnosis'))
      else if (child.localName = 'account') then
        value.accountList.Add(ParseReference(child, path+'/account'))
      else if (child.localName = 'admission') then
        value.admission := ParseEncounterAdmission(child, path+'/admission')
      else if (child.localName = 'location') then
        value.locationList.Add(ParseEncounterLocation(child, path+'/location'))
      else if Not ParseDomainResourceChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeEncounter(xml : TXmlBuilder; name : String; value : TFhirEncounter);
begin
  if (value = nil) then
    exit;
  composeDomainResourceAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeEncounterChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeEncounterChildren(xml : TXmlBuilder; value : TFhirEncounter);
var
  i : integer;
begin
  composeDomainResourceChildren(xml, value);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.identifierList.Count - 1 do
      ComposeIdentifier(xml, 'identifier', value.identifierList[i]);
  ComposeEnum(xml, 'status', value.statusElement, CODES_TFhirEncounterStatusEnum);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.statusHistoryList.Count - 1 do
      ComposeEncounterStatusHistory(xml, 'statusHistory', value.statusHistoryList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.class_List.Count - 1 do
      ComposeCodeableConcept(xml, 'class', value.class_List[i]);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.classHistoryList.Count - 1 do
      ComposeEncounterClassHistory(xml, 'classHistory', value.classHistoryList[i]);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(xml, 'priority', value.priority);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.type_List.Count - 1 do
      ComposeCodeableConcept(xml, 'type', value.type_List[i]);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.serviceTypeList.Count - 1 do
      ComposeCodeableReference(xml, 'serviceType', value.serviceTypeList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference(xml, 'subject', value.subject);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(xml, 'subjectStatus', value.subjectStatus);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.episodeOfCareList.Count - 1 do
      ComposeReference(xml, 'episodeOfCare', value.episodeOfCareList[i]);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.basedOnList.Count - 1 do
      ComposeReference(xml, 'basedOn', value.basedOnList[i]);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.careTeamList.Count - 1 do
      ComposeReference(xml, 'careTeam', value.careTeamList[i]);
  if (SummaryOption in [soFull, soData]) then
    ComposeReference(xml, 'partOf', value.partOf);
  if (SummaryOption in [soFull, soData]) then
    ComposeReference(xml, 'serviceProvider', value.serviceProvider);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.participantList.Count - 1 do
      ComposeEncounterParticipant(xml, 'participant', value.participantList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.appointmentList.Count - 1 do
      ComposeReference(xml, 'appointment', value.appointmentList[i]);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.virtualServiceList.Count - 1 do
      ComposeVirtualServiceDetail(xml, 'virtualService', value.virtualServiceList[i]);
  if (SummaryOption in [soFull, soData]) then
    ComposePeriod(xml, 'actualPeriod', value.actualPeriod);
  if (SummaryOption in [soFull, soData]) then
    ComposeDateTime(xml, 'plannedStartDate', value.plannedStartDateElement);
  if (SummaryOption in [soFull, soData]) then
    ComposeDateTime(xml, 'plannedEndDate', value.plannedEndDateElement);
  if (SummaryOption in [soFull, soData]) then
    ComposeDuration(xml, 'length', value.length);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.reasonList.Count - 1 do
      ComposeCodeableReference(xml, 'reason', value.reasonList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.diagnosisList.Count - 1 do
      ComposeEncounterDiagnosis(xml, 'diagnosis', value.diagnosisList[i]);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.accountList.Count - 1 do
      ComposeReference(xml, 'account', value.accountList[i]);
  if (SummaryOption in [soFull, soData]) then
    ComposeEncounterAdmission(xml, 'admission', value.admission);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.locationList.Count - 1 do
      ComposeEncounterLocation(xml, 'location', value.locationList[i]);
end;

{$ENDIF FHIR_ENCOUNTER}
{$IFDEF FHIR_ENDPOINT}
function TFHIRXmlParser.ParseEndpoint(element : TMXmlElement; path : string) : TFhirEndpoint;
var
  child : TMXmlElement;
begin
  result := TFhirEndpoint.Create;
  try
    parseDomainResourceAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseEndpointChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseEndpointChild(value : TFhirEndpoint; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'identifier') then
        value.identifierList.Add(ParseIdentifier(child, path+'/identifier'))
      else if (child.localName = 'status') then
        value.statusElement := ParseEnum(CODES_TFhirEndpointStatusEnum, SYSTEMS_TFhirEndpointStatusEnum, child, path+'/status')
      else if (child.localName = 'connectionType') then
        value.connectionTypeList.Add(ParseCodeableConcept(child, path+'/connectionType'))
      else if (child.localName = 'name') then
        value.nameElement := ParseString(child, path+'/name')
      else if (child.localName = 'description') then
        value.descriptionElement := ParseString(child, path+'/description')
      else if (child.localName = 'environmentType') then
        value.environmentTypeList.Add(ParseCodeableConcept(child, path+'/environmentType'))
      else if (child.localName = 'managingOrganization') then
        value.managingOrganization := ParseReference(child, path+'/managingOrganization')
      else if (child.localName = 'contact') then
        value.contactList.Add(ParseContactPoint(child, path+'/contact'))
      else if (child.localName = 'period') then
        value.period := ParsePeriod(child, path+'/period')
      else if (child.localName = 'payloadType') then
        value.payloadTypeList.Add(ParseCodeableConcept(child, path+'/payloadType'))
      else if (child.localName = 'payloadMimeType') then
        value.payloadMimeTypeList.Add(ParseCode(child, path+'/payloadMimeType'))
      else if (child.localName = 'address') then
        value.addressElement := ParseUrl(child, path+'/address')
      else if (child.localName = 'header') then
        value.headerList.Add(ParseString(child, path+'/header'))
      else if Not ParseDomainResourceChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeEndpoint(xml : TXmlBuilder; name : String; value : TFhirEndpoint);
begin
  if (value = nil) then
    exit;
  composeDomainResourceAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeEndpointChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeEndpointChildren(xml : TXmlBuilder; value : TFhirEndpoint);
var
  i : integer;
begin
  composeDomainResourceChildren(xml, value);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.identifierList.Count - 1 do
      ComposeIdentifier(xml, 'identifier', value.identifierList[i]);
  ComposeEnum(xml, 'status', value.statusElement, CODES_TFhirEndpointStatusEnum);
  for i := 0 to value.connectionTypeList.Count - 1 do
      ComposeCodeableConcept(xml, 'connectionType', value.connectionTypeList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(xml, 'name', value.nameElement);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(xml, 'description', value.descriptionElement);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.environmentTypeList.Count - 1 do
      ComposeCodeableConcept(xml, 'environmentType', value.environmentTypeList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference(xml, 'managingOrganization', value.managingOrganization);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.contactList.Count - 1 do
      ComposeContactPoint(xml, 'contact', value.contactList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposePeriod(xml, 'period', value.period);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.payloadTypeList.Count - 1 do
      ComposeCodeableConcept(xml, 'payloadType', value.payloadTypeList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.payloadMimeTypeList.Count - 1 do
      ComposeCode(xml, 'payloadMimeType', value.payloadMimeTypeList[i]);
  ComposeUrl(xml, 'address', value.addressElement);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.headerList.Count - 1 do
      ComposeString(xml, 'header', value.headerList[i]);
end;

{$ENDIF FHIR_ENDPOINT}
{$IFDEF FHIR_ENROLLMENTREQUEST}
function TFHIRXmlParser.ParseEnrollmentRequest(element : TMXmlElement; path : string) : TFhirEnrollmentRequest;
var
  child : TMXmlElement;
begin
  result := TFhirEnrollmentRequest.Create;
  try
    parseDomainResourceAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseEnrollmentRequestChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseEnrollmentRequestChild(value : TFhirEnrollmentRequest; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'identifier') then
        value.identifierList.Add(ParseIdentifier(child, path+'/identifier'))
      else if (child.localName = 'status') then
        value.statusElement := ParseEnum(CODES_TFhirFinancialResourceStatusCodesEnum, SYSTEMS_TFhirFinancialResourceStatusCodesEnum, child, path+'/status')
      else if (child.localName = 'created') then
        value.createdElement := ParseDateTime(child, path+'/created')
      else if (child.localName = 'insurer') then
        value.insurer := ParseReference(child, path+'/insurer')
      else if (child.localName = 'provider') then
        value.provider := ParseReference(child, path+'/provider')
      else if (child.localName = 'candidate') then
        value.candidate := ParseReference(child, path+'/candidate')
      else if (child.localName = 'coverage') then
        value.coverage := ParseReference(child, path+'/coverage')
      else if Not ParseDomainResourceChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeEnrollmentRequest(xml : TXmlBuilder; name : String; value : TFhirEnrollmentRequest);
begin
  if (value = nil) then
    exit;
  composeDomainResourceAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeEnrollmentRequestChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeEnrollmentRequestChildren(xml : TXmlBuilder; value : TFhirEnrollmentRequest);
var
  i : integer;
begin
  composeDomainResourceChildren(xml, value);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.identifierList.Count - 1 do
      ComposeIdentifier(xml, 'identifier', value.identifierList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeEnum(xml, 'status', value.statusElement, CODES_TFhirFinancialResourceStatusCodesEnum);
  if (SummaryOption in [soFull, soData]) then
    ComposeDateTime(xml, 'created', value.createdElement);
  if (SummaryOption in [soFull, soData]) then
    ComposeReference(xml, 'insurer', value.insurer);
  if (SummaryOption in [soFull, soData]) then
    ComposeReference(xml, 'provider', value.provider);
  if (SummaryOption in [soFull, soData]) then
    ComposeReference(xml, 'candidate', value.candidate);
  if (SummaryOption in [soFull, soData]) then
    ComposeReference(xml, 'coverage', value.coverage);
end;

{$ENDIF FHIR_ENROLLMENTREQUEST}
{$IFDEF FHIR_ENROLLMENTRESPONSE}
function TFHIRXmlParser.ParseEnrollmentResponse(element : TMXmlElement; path : string) : TFhirEnrollmentResponse;
var
  child : TMXmlElement;
begin
  result := TFhirEnrollmentResponse.Create;
  try
    parseDomainResourceAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseEnrollmentResponseChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseEnrollmentResponseChild(value : TFhirEnrollmentResponse; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'identifier') then
        value.identifierList.Add(ParseIdentifier(child, path+'/identifier'))
      else if (child.localName = 'status') then
        value.statusElement := ParseEnum(CODES_TFhirFinancialResourceStatusCodesEnum, SYSTEMS_TFhirFinancialResourceStatusCodesEnum, child, path+'/status')
      else if (child.localName = 'request') then
        value.request := ParseReference(child, path+'/request')
      else if (child.localName = 'outcome') then
        value.outcomeElement := ParseEnum(CODES_TFhirEnrollmentOutcomeEnum, SYSTEMS_TFhirEnrollmentOutcomeEnum, child, path+'/outcome')
      else if (child.localName = 'disposition') then
        value.dispositionElement := ParseString(child, path+'/disposition')
      else if (child.localName = 'created') then
        value.createdElement := ParseDateTime(child, path+'/created')
      else if (child.localName = 'organization') then
        value.organization := ParseReference(child, path+'/organization')
      else if (child.localName = 'requestProvider') then
        value.requestProvider := ParseReference(child, path+'/requestProvider')
      else if Not ParseDomainResourceChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeEnrollmentResponse(xml : TXmlBuilder; name : String; value : TFhirEnrollmentResponse);
begin
  if (value = nil) then
    exit;
  composeDomainResourceAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeEnrollmentResponseChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeEnrollmentResponseChildren(xml : TXmlBuilder; value : TFhirEnrollmentResponse);
var
  i : integer;
begin
  composeDomainResourceChildren(xml, value);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.identifierList.Count - 1 do
      ComposeIdentifier(xml, 'identifier', value.identifierList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeEnum(xml, 'status', value.statusElement, CODES_TFhirFinancialResourceStatusCodesEnum);
  if (SummaryOption in [soFull, soData]) then
    ComposeReference(xml, 'request', value.request);
  if (SummaryOption in [soFull, soData]) then
    ComposeEnum(xml, 'outcome', value.outcomeElement, CODES_TFhirEnrollmentOutcomeEnum);
  if (SummaryOption in [soFull, soData]) then
    ComposeString(xml, 'disposition', value.dispositionElement);
  if (SummaryOption in [soFull, soData]) then
    ComposeDateTime(xml, 'created', value.createdElement);
  if (SummaryOption in [soFull, soData]) then
    ComposeReference(xml, 'organization', value.organization);
  if (SummaryOption in [soFull, soData]) then
    ComposeReference(xml, 'requestProvider', value.requestProvider);
end;

{$ENDIF FHIR_ENROLLMENTRESPONSE}
{$IFDEF FHIR_EPISODEOFCARE}
function TFHIRXmlParser.ParseEpisodeOfCareStatusHistory(element : TMXmlElement; path : string) : TFhirEpisodeOfCareStatusHistory;
var
  child : TMXmlElement;
begin
  result := TFhirEpisodeOfCareStatusHistory.Create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseEpisodeOfCareStatusHistoryChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseEpisodeOfCareStatusHistoryChild(value : TFhirEpisodeOfCareStatusHistory; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'status') then
        value.statusElement := ParseEnum(CODES_TFhirEpisodeOfCareStatusEnum, SYSTEMS_TFhirEpisodeOfCareStatusEnum, child, path+'/status')
      else if (child.localName = 'period') then
        value.period := ParsePeriod(child, path+'/period')
      else if Not ParseBackboneElementChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeEpisodeOfCareStatusHistory(xml : TXmlBuilder; name : String; value : TFhirEpisodeOfCareStatusHistory);
begin
  if (value = nil) then
    exit;
  composeElementAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeEpisodeOfCareStatusHistoryChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeEpisodeOfCareStatusHistoryChildren(xml : TXmlBuilder; value : TFhirEpisodeOfCareStatusHistory);
begin
  composeBackboneElementChildren(xml, value);
  ComposeEnum(xml, 'status', value.statusElement, CODES_TFhirEpisodeOfCareStatusEnum);
  ComposePeriod(xml, 'period', value.period);
end;

function TFHIRXmlParser.ParseEpisodeOfCareDiagnosis(element : TMXmlElement; path : string) : TFhirEpisodeOfCareDiagnosis;
var
  child : TMXmlElement;
begin
  result := TFhirEpisodeOfCareDiagnosis.Create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseEpisodeOfCareDiagnosisChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseEpisodeOfCareDiagnosisChild(value : TFhirEpisodeOfCareDiagnosis; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'condition') then
        value.condition := ParseCodeableReference(child, path+'/condition')
      else if (child.localName = 'role') then
        value.role := ParseCodeableConcept(child, path+'/role')
      else if (child.localName = 'rank') then
        value.rankElement := ParsePositiveInt(child, path+'/rank')
      else if Not ParseBackboneElementChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeEpisodeOfCareDiagnosis(xml : TXmlBuilder; name : String; value : TFhirEpisodeOfCareDiagnosis);
begin
  if (value = nil) then
    exit;
  composeElementAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeEpisodeOfCareDiagnosisChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeEpisodeOfCareDiagnosisChildren(xml : TXmlBuilder; value : TFhirEpisodeOfCareDiagnosis);
begin
  composeBackboneElementChildren(xml, value);
  ComposeCodeableReference(xml, 'condition', value.condition);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(xml, 'role', value.role);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposePositiveInt(xml, 'rank', value.rankElement);
end;

function TFHIRXmlParser.ParseEpisodeOfCare(element : TMXmlElement; path : string) : TFhirEpisodeOfCare;
var
  child : TMXmlElement;
begin
  result := TFhirEpisodeOfCare.Create;
  try
    parseDomainResourceAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseEpisodeOfCareChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseEpisodeOfCareChild(value : TFhirEpisodeOfCare; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'identifier') then
        value.identifierList.Add(ParseIdentifier(child, path+'/identifier'))
      else if (child.localName = 'status') then
        value.statusElement := ParseEnum(CODES_TFhirEpisodeOfCareStatusEnum, SYSTEMS_TFhirEpisodeOfCareStatusEnum, child, path+'/status')
      else if (child.localName = 'statusHistory') then
        value.statusHistoryList.Add(ParseEpisodeOfCareStatusHistory(child, path+'/statusHistory'))
      else if (child.localName = 'type') then
        value.type_List.Add(ParseCodeableConcept(child, path+'/type'))
      else if (child.localName = 'diagnosis') then
        value.diagnosisList.Add(ParseEpisodeOfCareDiagnosis(child, path+'/diagnosis'))
      else if (child.localName = 'patient') then
        value.patient := ParseReference(child, path+'/patient')
      else if (child.localName = 'managingOrganization') then
        value.managingOrganization := ParseReference(child, path+'/managingOrganization')
      else if (child.localName = 'period') then
        value.period := ParsePeriod(child, path+'/period')
      else if (child.localName = 'referralRequest') then
        value.referralRequestList.Add(ParseReference(child, path+'/referralRequest'))
      else if (child.localName = 'careManager') then
        value.careManager := ParseReference(child, path+'/careManager')
      else if (child.localName = 'careTeam') then
        value.careTeamList.Add(ParseReference(child, path+'/careTeam'))
      else if (child.localName = 'account') then
        value.accountList.Add(ParseReference(child, path+'/account'))
      else if Not ParseDomainResourceChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeEpisodeOfCare(xml : TXmlBuilder; name : String; value : TFhirEpisodeOfCare);
begin
  if (value = nil) then
    exit;
  composeDomainResourceAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeEpisodeOfCareChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeEpisodeOfCareChildren(xml : TXmlBuilder; value : TFhirEpisodeOfCare);
var
  i : integer;
begin
  composeDomainResourceChildren(xml, value);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.identifierList.Count - 1 do
      ComposeIdentifier(xml, 'identifier', value.identifierList[i]);
  ComposeEnum(xml, 'status', value.statusElement, CODES_TFhirEpisodeOfCareStatusEnum);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.statusHistoryList.Count - 1 do
      ComposeEpisodeOfCareStatusHistory(xml, 'statusHistory', value.statusHistoryList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.type_List.Count - 1 do
      ComposeCodeableConcept(xml, 'type', value.type_List[i]);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.diagnosisList.Count - 1 do
      ComposeEpisodeOfCareDiagnosis(xml, 'diagnosis', value.diagnosisList[i]);
  ComposeReference(xml, 'patient', value.patient);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference(xml, 'managingOrganization', value.managingOrganization);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposePeriod(xml, 'period', value.period);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.referralRequestList.Count - 1 do
      ComposeReference(xml, 'referralRequest', value.referralRequestList[i]);
  if (SummaryOption in [soFull, soData]) then
    ComposeReference(xml, 'careManager', value.careManager);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.careTeamList.Count - 1 do
      ComposeReference(xml, 'careTeam', value.careTeamList[i]);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.accountList.Count - 1 do
      ComposeReference(xml, 'account', value.accountList[i]);
end;

{$ENDIF FHIR_EPISODEOFCARE}
{$IFDEF FHIR_EVENTDEFINITION}
function TFHIRXmlParser.ParseEventDefinition(element : TMXmlElement; path : string) : TFhirEventDefinition;
var
  child : TMXmlElement;
begin
  result := TFhirEventDefinition.Create;
  try
    parseMetadataResourceAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseEventDefinitionChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseEventDefinitionChild(value : TFhirEventDefinition; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'url') then
        value.urlElement := ParseUri(child, path+'/url')
      else if (child.localName = 'identifier') then
        value.identifierList.Add(ParseIdentifier(child, path+'/identifier'))
      else if (child.localName = 'version') then
        value.versionElement := ParseString(child, path+'/version')
      else if (child.localName = 'name') then
        value.nameElement := ParseString(child, path+'/name')
      else if (child.localName = 'title') then
        value.titleElement := ParseString(child, path+'/title')
      else if (child.localName = 'subtitle') then
        value.subtitleElement := ParseString(child, path+'/subtitle')
      else if (child.localName = 'status') then
        value.statusElement := ParseEnum(CODES_TFhirPublicationStatusEnum, SYSTEMS_TFhirPublicationStatusEnum, child, path+'/status')
      else if (child.localName = 'experimental') then
        value.experimentalElement := ParseBoolean(child, path+'/experimental')
      else if (child.localName = 'subjectCodeableConcept') then
        value.subject := ParseCodeableConcept(child, path+'/subjectCodeableConcept')
      else if (child.localName = 'subjectReference') then
        value.subject := ParseReference(child, path+'/subjectReference')
      else if (child.localName = 'date') then
        value.dateElement := ParseDateTime(child, path+'/date')
      else if (child.localName = 'publisher') then
        value.publisherElement := ParseString(child, path+'/publisher')
      else if (child.localName = 'contact') then
        value.contactList.Add(ParseContactDetail(child, path+'/contact'))
      else if (child.localName = 'description') then
        value.descriptionElement := ParseMarkdown(child, path+'/description')
      else if (child.localName = 'useContext') then
        value.useContextList.Add(ParseUsageContext(child, path+'/useContext'))
      else if (child.localName = 'jurisdiction') then
        value.jurisdictionList.Add(ParseCodeableConcept(child, path+'/jurisdiction'))
      else if (child.localName = 'purpose') then
        value.purposeElement := ParseMarkdown(child, path+'/purpose')
      else if (child.localName = 'usage') then
        value.usageElement := ParseString(child, path+'/usage')
      else if (child.localName = 'copyright') then
        value.copyrightElement := ParseMarkdown(child, path+'/copyright')
      else if (child.localName = 'approvalDate') then
        value.approvalDateElement := ParseDate(child, path+'/approvalDate')
      else if (child.localName = 'lastReviewDate') then
        value.lastReviewDateElement := ParseDate(child, path+'/lastReviewDate')
      else if (child.localName = 'effectivePeriod') then
        value.effectivePeriod := ParsePeriod(child, path+'/effectivePeriod')
      else if (child.localName = 'topic') then
        value.topicList.Add(ParseCodeableConcept(child, path+'/topic'))
      else if (child.localName = 'author') then
        value.authorList.Add(ParseContactDetail(child, path+'/author'))
      else if (child.localName = 'editor') then
        value.editorList.Add(ParseContactDetail(child, path+'/editor'))
      else if (child.localName = 'reviewer') then
        value.reviewerList.Add(ParseContactDetail(child, path+'/reviewer'))
      else if (child.localName = 'endorser') then
        value.endorserList.Add(ParseContactDetail(child, path+'/endorser'))
      else if (child.localName = 'relatedArtifact') then
        value.relatedArtifactList.Add(ParseRelatedArtifact(child, path+'/relatedArtifact'))
      else if (child.localName = 'trigger') then
        value.triggerList.Add(ParseTriggerDefinition(child, path+'/trigger'))
      else if Not ParseMetadataResourceChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeEventDefinition(xml : TXmlBuilder; name : String; value : TFhirEventDefinition);
begin
  if (value = nil) then
    exit;
  composeMetadataResourceAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeEventDefinitionChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeEventDefinitionChildren(xml : TXmlBuilder; value : TFhirEventDefinition);
var
  i : integer;
begin
  composeMetadataResourceChildren(xml, value);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeUri(xml, 'url', value.urlElement);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.identifierList.Count - 1 do
      ComposeIdentifier(xml, 'identifier', value.identifierList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(xml, 'version', value.versionElement);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(xml, 'name', value.nameElement);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(xml, 'title', value.titleElement);
  if (SummaryOption in [soFull, soData]) then
    ComposeString(xml, 'subtitle', value.subtitleElement);
  ComposeEnum(xml, 'status', value.statusElement, CODES_TFhirPublicationStatusEnum);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeBoolean(xml, 'experimental', value.experimentalElement);
  if (SummaryOption in [soFull, soData]) and (value.subject is TFhirCodeableConcept) {6} then
    ComposeCodeableConcept(xml, 'subjectCodeableConcept', TFhirCodeableConcept(value.subject))
  else if (SummaryOption in [soFull, soData]) and (value.subject is TFhirReference) {2} then
    ComposeReference(xml, 'subjectReference', TFhirReference(value.subject));
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDateTime(xml, 'date', value.dateElement);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(xml, 'publisher', value.publisherElement);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.contactList.Count - 1 do
      ComposeContactDetail(xml, 'contact', value.contactList[i]);
  if (SummaryOption in [soFull, soData]) then
    ComposeMarkdown(xml, 'description', value.descriptionElement);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.useContextList.Count - 1 do
      ComposeUsageContext(xml, 'useContext', value.useContextList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.jurisdictionList.Count - 1 do
      ComposeCodeableConcept(xml, 'jurisdiction', value.jurisdictionList[i]);
  if (SummaryOption in [soFull, soData]) then
    ComposeMarkdown(xml, 'purpose', value.purposeElement);
  if (SummaryOption in [soFull, soData]) then
    ComposeString(xml, 'usage', value.usageElement);
  if (SummaryOption in [soFull, soData]) then
    ComposeMarkdown(xml, 'copyright', value.copyrightElement);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDate(xml, 'approvalDate', value.approvalDateElement);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDate(xml, 'lastReviewDate', value.lastReviewDateElement);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposePeriod(xml, 'effectivePeriod', value.effectivePeriod);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.topicList.Count - 1 do
      ComposeCodeableConcept(xml, 'topic', value.topicList[i]);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.authorList.Count - 1 do
      ComposeContactDetail(xml, 'author', value.authorList[i]);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.editorList.Count - 1 do
      ComposeContactDetail(xml, 'editor', value.editorList[i]);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.reviewerList.Count - 1 do
      ComposeContactDetail(xml, 'reviewer', value.reviewerList[i]);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.endorserList.Count - 1 do
      ComposeContactDetail(xml, 'endorser', value.endorserList[i]);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.relatedArtifactList.Count - 1 do
      ComposeRelatedArtifact(xml, 'relatedArtifact', value.relatedArtifactList[i]);
  for i := 0 to value.triggerList.Count - 1 do
      ComposeTriggerDefinition(xml, 'trigger', value.triggerList[i]);
end;

{$ENDIF FHIR_EVENTDEFINITION}
{$IFDEF FHIR_EVIDENCE}
function TFHIRXmlParser.ParseEvidenceVariableDefinition(element : TMXmlElement; path : string) : TFhirEvidenceVariableDefinition;
var
  child : TMXmlElement;
begin
  result := TFhirEvidenceVariableDefinition.Create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseEvidenceVariableDefinitionChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseEvidenceVariableDefinitionChild(value : TFhirEvidenceVariableDefinition; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'description') then
        value.descriptionElement := ParseMarkdown(child, path+'/description')
      else if (child.localName = 'note') then
        value.noteList.Add(ParseAnnotation(child, path+'/note'))
      else if (child.localName = 'variableRole') then
        value.variableRole := ParseCodeableConcept(child, path+'/variableRole')
      else if (child.localName = 'observed') then
        value.observed := ParseReference(child, path+'/observed')
      else if (child.localName = 'intended') then
        value.intended := ParseReference(child, path+'/intended')
      else if (child.localName = 'directnessMatch') then
        value.directnessMatch := ParseCodeableConcept(child, path+'/directnessMatch')
      else if Not ParseBackboneElementChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeEvidenceVariableDefinition(xml : TXmlBuilder; name : String; value : TFhirEvidenceVariableDefinition);
begin
  if (value = nil) then
    exit;
  composeElementAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeEvidenceVariableDefinitionChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeEvidenceVariableDefinitionChildren(xml : TXmlBuilder; value : TFhirEvidenceVariableDefinition);
var
  i : integer;
begin
  composeBackboneElementChildren(xml, value);
  if (SummaryOption in [soFull, soData]) then
    ComposeMarkdown(xml, 'description', value.descriptionElement);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.noteList.Count - 1 do
      ComposeAnnotation(xml, 'note', value.noteList[i]);
  ComposeCodeableConcept(xml, 'variableRole', value.variableRole);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference(xml, 'observed', value.observed);
  if (SummaryOption in [soFull, soData]) then
    ComposeReference(xml, 'intended', value.intended);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(xml, 'directnessMatch', value.directnessMatch);
end;

function TFHIRXmlParser.ParseEvidenceStatistic(element : TMXmlElement; path : string) : TFhirEvidenceStatistic;
var
  child : TMXmlElement;
begin
  result := TFhirEvidenceStatistic.Create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseEvidenceStatisticChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseEvidenceStatisticChild(value : TFhirEvidenceStatistic; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'description') then
        value.descriptionElement := ParseString(child, path+'/description')
      else if (child.localName = 'note') then
        value.noteList.Add(ParseAnnotation(child, path+'/note'))
      else if (child.localName = 'statisticType') then
        value.statisticType := ParseCodeableConcept(child, path+'/statisticType')
      else if (child.localName = 'category') then
        value.category := ParseCodeableConcept(child, path+'/category')
      else if (child.localName = 'quantity') then
        value.quantity := ParseQuantity(child, path+'/quantity')
      else if (child.localName = 'numberOfEvents') then
        value.numberOfEventsElement := ParseUnsignedInt(child, path+'/numberOfEvents')
      else if (child.localName = 'numberAffected') then
        value.numberAffectedElement := ParseUnsignedInt(child, path+'/numberAffected')
      else if (child.localName = 'sampleSize') then
        value.sampleSize := ParseEvidenceStatisticSampleSize(child, path+'/sampleSize')
      else if (child.localName = 'attributeEstimate') then
        value.attributeEstimateList.Add(ParseEvidenceStatisticAttributeEstimate(child, path+'/attributeEstimate'))
      else if (child.localName = 'modelCharacteristic') then
        value.modelCharacteristicList.Add(ParseEvidenceStatisticModelCharacteristic(child, path+'/modelCharacteristic'))
      else if Not ParseBackboneElementChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeEvidenceStatistic(xml : TXmlBuilder; name : String; value : TFhirEvidenceStatistic);
begin
  if (value = nil) then
    exit;
  composeElementAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeEvidenceStatisticChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeEvidenceStatisticChildren(xml : TXmlBuilder; value : TFhirEvidenceStatistic);
var
  i : integer;
begin
  composeBackboneElementChildren(xml, value);
  if (SummaryOption in [soFull, soData]) then
    ComposeString(xml, 'description', value.descriptionElement);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.noteList.Count - 1 do
      ComposeAnnotation(xml, 'note', value.noteList[i]);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(xml, 'statisticType', value.statisticType);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(xml, 'category', value.category);
  if (SummaryOption in [soFull, soData]) then
    ComposeQuantity(xml, 'quantity', value.quantity);
  if (SummaryOption in [soFull, soData]) then
    ComposeUnsignedInt(xml, 'numberOfEvents', value.numberOfEventsElement);
  if (SummaryOption in [soFull, soData]) then
    ComposeUnsignedInt(xml, 'numberAffected', value.numberAffectedElement);
  if (SummaryOption in [soFull, soData]) then
    ComposeEvidenceStatisticSampleSize(xml, 'sampleSize', value.sampleSize);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.attributeEstimateList.Count - 1 do
      ComposeEvidenceStatisticAttributeEstimate(xml, 'attributeEstimate', value.attributeEstimateList[i]);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.modelCharacteristicList.Count - 1 do
      ComposeEvidenceStatisticModelCharacteristic(xml, 'modelCharacteristic', value.modelCharacteristicList[i]);
end;

function TFHIRXmlParser.ParseEvidenceStatisticSampleSize(element : TMXmlElement; path : string) : TFhirEvidenceStatisticSampleSize;
var
  child : TMXmlElement;
begin
  result := TFhirEvidenceStatisticSampleSize.Create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseEvidenceStatisticSampleSizeChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseEvidenceStatisticSampleSizeChild(value : TFhirEvidenceStatisticSampleSize; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'description') then
        value.descriptionElement := ParseString(child, path+'/description')
      else if (child.localName = 'note') then
        value.noteList.Add(ParseAnnotation(child, path+'/note'))
      else if (child.localName = 'numberOfStudies') then
        value.numberOfStudiesElement := ParseUnsignedInt(child, path+'/numberOfStudies')
      else if (child.localName = 'numberOfParticipants') then
        value.numberOfParticipantsElement := ParseUnsignedInt(child, path+'/numberOfParticipants')
      else if (child.localName = 'knownDataCount') then
        value.knownDataCountElement := ParseUnsignedInt(child, path+'/knownDataCount')
      else if Not ParseBackboneElementChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeEvidenceStatisticSampleSize(xml : TXmlBuilder; name : String; value : TFhirEvidenceStatisticSampleSize);
begin
  if (value = nil) then
    exit;
  composeElementAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeEvidenceStatisticSampleSizeChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeEvidenceStatisticSampleSizeChildren(xml : TXmlBuilder; value : TFhirEvidenceStatisticSampleSize);
var
  i : integer;
begin
  composeBackboneElementChildren(xml, value);
  if (SummaryOption in [soFull, soData]) then
    ComposeString(xml, 'description', value.descriptionElement);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.noteList.Count - 1 do
      ComposeAnnotation(xml, 'note', value.noteList[i]);
  if (SummaryOption in [soFull, soData]) then
    ComposeUnsignedInt(xml, 'numberOfStudies', value.numberOfStudiesElement);
  if (SummaryOption in [soFull, soData]) then
    ComposeUnsignedInt(xml, 'numberOfParticipants', value.numberOfParticipantsElement);
  if (SummaryOption in [soFull, soData]) then
    ComposeUnsignedInt(xml, 'knownDataCount', value.knownDataCountElement);
end;

function TFHIRXmlParser.ParseEvidenceStatisticAttributeEstimate(element : TMXmlElement; path : string) : TFhirEvidenceStatisticAttributeEstimate;
var
  child : TMXmlElement;
begin
  result := TFhirEvidenceStatisticAttributeEstimate.Create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseEvidenceStatisticAttributeEstimateChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseEvidenceStatisticAttributeEstimateChild(value : TFhirEvidenceStatisticAttributeEstimate; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'description') then
        value.descriptionElement := ParseString(child, path+'/description')
      else if (child.localName = 'note') then
        value.noteList.Add(ParseAnnotation(child, path+'/note'))
      else if (child.localName = 'type') then
        value.type_ := ParseCodeableConcept(child, path+'/type')
      else if (child.localName = 'quantity') then
        value.quantity := ParseQuantity(child, path+'/quantity')
      else if (child.localName = 'level') then
        value.levelElement := ParseDecimal(child, path+'/level')
      else if (child.localName = 'range') then
        value.range := ParseRange(child, path+'/range')
      else if (child.localName = 'attributeEstimate') then
        value.attributeEstimateList.Add(ParseEvidenceStatisticAttributeEstimate(child, path+'/attributeEstimate'))
      else if Not ParseBackboneElementChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeEvidenceStatisticAttributeEstimate(xml : TXmlBuilder; name : String; value : TFhirEvidenceStatisticAttributeEstimate);
begin
  if (value = nil) then
    exit;
  composeElementAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeEvidenceStatisticAttributeEstimateChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeEvidenceStatisticAttributeEstimateChildren(xml : TXmlBuilder; value : TFhirEvidenceStatisticAttributeEstimate);
var
  i : integer;
begin
  composeBackboneElementChildren(xml, value);
  if (SummaryOption in [soFull, soData]) then
    ComposeString(xml, 'description', value.descriptionElement);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.noteList.Count - 1 do
      ComposeAnnotation(xml, 'note', value.noteList[i]);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(xml, 'type', value.type_);
  if (SummaryOption in [soFull, soData]) then
    ComposeQuantity(xml, 'quantity', value.quantity);
  if (SummaryOption in [soFull, soData]) then
    ComposeDecimal(xml, 'level', value.levelElement);
  if (SummaryOption in [soFull, soData]) then
    ComposeRange(xml, 'range', value.range);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.attributeEstimateList.Count - 1 do
      ComposeEvidenceStatisticAttributeEstimate(xml, 'attributeEstimate', value.attributeEstimateList[i]);
end;

function TFHIRXmlParser.ParseEvidenceStatisticModelCharacteristic(element : TMXmlElement; path : string) : TFhirEvidenceStatisticModelCharacteristic;
var
  child : TMXmlElement;
begin
  result := TFhirEvidenceStatisticModelCharacteristic.Create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseEvidenceStatisticModelCharacteristicChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseEvidenceStatisticModelCharacteristicChild(value : TFhirEvidenceStatisticModelCharacteristic; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'code') then
        value.code := ParseCodeableConcept(child, path+'/code')
      else if (child.localName = 'value') then
        value.value := ParseQuantity(child, path+'/value')
      else if (child.localName = 'variable') then
        value.variableList.Add(ParseEvidenceStatisticModelCharacteristicVariable(child, path+'/variable'))
      else if (child.localName = 'attributeEstimate') then
        value.attributeEstimateList.Add(ParseEvidenceStatisticAttributeEstimate(child, path+'/attributeEstimate'))
      else if Not ParseBackboneElementChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeEvidenceStatisticModelCharacteristic(xml : TXmlBuilder; name : String; value : TFhirEvidenceStatisticModelCharacteristic);
begin
  if (value = nil) then
    exit;
  composeElementAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeEvidenceStatisticModelCharacteristicChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeEvidenceStatisticModelCharacteristicChildren(xml : TXmlBuilder; value : TFhirEvidenceStatisticModelCharacteristic);
var
  i : integer;
begin
  composeBackboneElementChildren(xml, value);
  ComposeCodeableConcept(xml, 'code', value.code);
  if (SummaryOption in [soFull, soData]) then
    ComposeQuantity(xml, 'value', value.value);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.variableList.Count - 1 do
      ComposeEvidenceStatisticModelCharacteristicVariable(xml, 'variable', value.variableList[i]);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.attributeEstimateList.Count - 1 do
      ComposeEvidenceStatisticAttributeEstimate(xml, 'attributeEstimate', value.attributeEstimateList[i]);
end;

function TFHIRXmlParser.ParseEvidenceStatisticModelCharacteristicVariable(element : TMXmlElement; path : string) : TFhirEvidenceStatisticModelCharacteristicVariable;
var
  child : TMXmlElement;
begin
  result := TFhirEvidenceStatisticModelCharacteristicVariable.Create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseEvidenceStatisticModelCharacteristicVariableChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseEvidenceStatisticModelCharacteristicVariableChild(value : TFhirEvidenceStatisticModelCharacteristicVariable; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'variableDefinition') then
        value.variableDefinition := ParseReference(child, path+'/variableDefinition')
      else if (child.localName = 'handling') then
        value.handlingElement := ParseEnum(CODES_TFhirEvidenceVariableHandlingEnum, SYSTEMS_TFhirEvidenceVariableHandlingEnum, child, path+'/handling')
      else if (child.localName = 'valueCategory') then
        value.valueCategoryList.Add(ParseCodeableConcept(child, path+'/valueCategory'))
      else if (child.localName = 'valueQuantity') then
        value.valueQuantityList.Add(ParseQuantity(child, path+'/valueQuantity'))
      else if (child.localName = 'valueRange') then
        value.valueRangeList.Add(ParseRange(child, path+'/valueRange'))
      else if Not ParseBackboneElementChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeEvidenceStatisticModelCharacteristicVariable(xml : TXmlBuilder; name : String; value : TFhirEvidenceStatisticModelCharacteristicVariable);
begin
  if (value = nil) then
    exit;
  composeElementAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeEvidenceStatisticModelCharacteristicVariableChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeEvidenceStatisticModelCharacteristicVariableChildren(xml : TXmlBuilder; value : TFhirEvidenceStatisticModelCharacteristicVariable);
var
  i : integer;
begin
  composeBackboneElementChildren(xml, value);
  ComposeReference(xml, 'variableDefinition', value.variableDefinition);
  if (SummaryOption in [soFull, soData]) then
    ComposeEnum(xml, 'handling', value.handlingElement, CODES_TFhirEvidenceVariableHandlingEnum);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.valueCategoryList.Count - 1 do
      ComposeCodeableConcept(xml, 'valueCategory', value.valueCategoryList[i]);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.valueQuantityList.Count - 1 do
      ComposeQuantity(xml, 'valueQuantity', value.valueQuantityList[i]);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.valueRangeList.Count - 1 do
      ComposeRange(xml, 'valueRange', value.valueRangeList[i]);
end;

function TFHIRXmlParser.ParseEvidenceCertainty(element : TMXmlElement; path : string) : TFhirEvidenceCertainty;
var
  child : TMXmlElement;
begin
  result := TFhirEvidenceCertainty.Create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseEvidenceCertaintyChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseEvidenceCertaintyChild(value : TFhirEvidenceCertainty; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'description') then
        value.descriptionElement := ParseString(child, path+'/description')
      else if (child.localName = 'note') then
        value.noteList.Add(ParseAnnotation(child, path+'/note'))
      else if (child.localName = 'type') then
        value.type_ := ParseCodeableConcept(child, path+'/type')
      else if (child.localName = 'rating') then
        value.rating := ParseCodeableConcept(child, path+'/rating')
      else if (child.localName = 'rater') then
        value.raterElement := ParseString(child, path+'/rater')
      else if (child.localName = 'subcomponent') then
        value.subcomponentList.Add(ParseEvidenceCertainty(child, path+'/subcomponent'))
      else if Not ParseBackboneElementChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeEvidenceCertainty(xml : TXmlBuilder; name : String; value : TFhirEvidenceCertainty);
begin
  if (value = nil) then
    exit;
  composeElementAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeEvidenceCertaintyChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeEvidenceCertaintyChildren(xml : TXmlBuilder; value : TFhirEvidenceCertainty);
var
  i : integer;
begin
  composeBackboneElementChildren(xml, value);
  if (SummaryOption in [soFull, soData]) then
    ComposeString(xml, 'description', value.descriptionElement);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.noteList.Count - 1 do
      ComposeAnnotation(xml, 'note', value.noteList[i]);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(xml, 'type', value.type_);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(xml, 'rating', value.rating);
  if (SummaryOption in [soFull, soData]) then
    ComposeString(xml, 'rater', value.raterElement);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.subcomponentList.Count - 1 do
      ComposeEvidenceCertainty(xml, 'subcomponent', value.subcomponentList[i]);
end;

function TFHIRXmlParser.ParseEvidence(element : TMXmlElement; path : string) : TFhirEvidence;
var
  child : TMXmlElement;
begin
  result := TFhirEvidence.Create;
  try
    parseMetadataResourceAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseEvidenceChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseEvidenceChild(value : TFhirEvidence; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'url') then
        value.urlElement := ParseUri(child, path+'/url')
      else if (child.localName = 'identifier') then
        value.identifierList.Add(ParseIdentifier(child, path+'/identifier'))
      else if (child.localName = 'version') then
        value.versionElement := ParseString(child, path+'/version')
      else if (child.localName = 'name') then
        value.nameElement := ParseString(child, path+'/name')
      else if (child.localName = 'title') then
        value.titleElement := ParseString(child, path+'/title')
      else if (child.localName = 'citeAsReference') then
        value.citeAs := ParseReference(child, path+'/citeAsReference')
      else if (child.localName = 'citeAsMarkdown') then
        value.citeAs := ParseMarkdown(child, path+'/citeAsMarkdown')
      else if (child.localName = 'status') then
        value.statusElement := ParseEnum(CODES_TFhirPublicationStatusEnum, SYSTEMS_TFhirPublicationStatusEnum, child, path+'/status')
      else if (child.localName = 'experimental') then
        value.experimentalElement := ParseBoolean(child, path+'/experimental')
      else if (child.localName = 'date') then
        value.dateElement := ParseDateTime(child, path+'/date')
      else if (child.localName = 'useContext') then
        value.useContextList.Add(ParseUsageContext(child, path+'/useContext'))
      else if (child.localName = 'approvalDate') then
        value.approvalDateElement := ParseDate(child, path+'/approvalDate')
      else if (child.localName = 'lastReviewDate') then
        value.lastReviewDateElement := ParseDate(child, path+'/lastReviewDate')
      else if (child.localName = 'publisher') then
        value.publisherElement := ParseString(child, path+'/publisher')
      else if (child.localName = 'contact') then
        value.contactList.Add(ParseContactDetail(child, path+'/contact'))
      else if (child.localName = 'author') then
        value.authorList.Add(ParseContactDetail(child, path+'/author'))
      else if (child.localName = 'editor') then
        value.editorList.Add(ParseContactDetail(child, path+'/editor'))
      else if (child.localName = 'reviewer') then
        value.reviewerList.Add(ParseContactDetail(child, path+'/reviewer'))
      else if (child.localName = 'endorser') then
        value.endorserList.Add(ParseContactDetail(child, path+'/endorser'))
      else if (child.localName = 'relatedArtifact') then
        value.relatedArtifactList.Add(ParseRelatedArtifact(child, path+'/relatedArtifact'))
      else if (child.localName = 'description') then
        value.descriptionElement := ParseMarkdown(child, path+'/description')
      else if (child.localName = 'assertion') then
        value.assertionElement := ParseMarkdown(child, path+'/assertion')
      else if (child.localName = 'note') then
        value.noteList.Add(ParseAnnotation(child, path+'/note'))
      else if (child.localName = 'variableDefinition') then
        value.variableDefinitionList.Add(ParseEvidenceVariableDefinition(child, path+'/variableDefinition'))
      else if (child.localName = 'synthesisType') then
        value.synthesisType := ParseCodeableConcept(child, path+'/synthesisType')
      else if (child.localName = 'studyDesign') then
        value.studyDesignList.Add(ParseCodeableConcept(child, path+'/studyDesign'))
      else if (child.localName = 'statistic') then
        value.statisticList.Add(ParseEvidenceStatistic(child, path+'/statistic'))
      else if (child.localName = 'certainty') then
        value.certaintyList.Add(ParseEvidenceCertainty(child, path+'/certainty'))
      else if Not ParseMetadataResourceChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeEvidence(xml : TXmlBuilder; name : String; value : TFhirEvidence);
begin
  if (value = nil) then
    exit;
  composeMetadataResourceAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeEvidenceChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeEvidenceChildren(xml : TXmlBuilder; value : TFhirEvidence);
var
  i : integer;
begin
  composeMetadataResourceChildren(xml, value);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeUri(xml, 'url', value.urlElement);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.identifierList.Count - 1 do
      ComposeIdentifier(xml, 'identifier', value.identifierList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(xml, 'version', value.versionElement);
  if (SummaryOption in [soFull, soData]) then
    ComposeString(xml, 'name', value.nameElement);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(xml, 'title', value.titleElement);
  if (SummaryOption in [soFull, soData]) and (value.citeAs is TFhirReference) {2} then
    ComposeReference(xml, 'citeAsReference', TFhirReference(value.citeAs))
  else if (SummaryOption in [soFull, soData]) and (value.citeAs is TFhirMarkdown) {6} then
    ComposeMarkdown(xml, 'citeAsMarkdown', TFhirMarkdown(value.citeAs));
  ComposeEnum(xml, 'status', value.statusElement, CODES_TFhirPublicationStatusEnum);
  if (SummaryOption in [soFull, soData]) then
    ComposeBoolean(xml, 'experimental', value.experimentalElement);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDateTime(xml, 'date', value.dateElement);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.useContextList.Count - 1 do
      ComposeUsageContext(xml, 'useContext', value.useContextList[i]);
  if (SummaryOption in [soFull, soData]) then
    ComposeDate(xml, 'approvalDate', value.approvalDateElement);
  if (SummaryOption in [soFull, soData]) then
    ComposeDate(xml, 'lastReviewDate', value.lastReviewDateElement);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(xml, 'publisher', value.publisherElement);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.contactList.Count - 1 do
      ComposeContactDetail(xml, 'contact', value.contactList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.authorList.Count - 1 do
      ComposeContactDetail(xml, 'author', value.authorList[i]);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.editorList.Count - 1 do
      ComposeContactDetail(xml, 'editor', value.editorList[i]);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.reviewerList.Count - 1 do
      ComposeContactDetail(xml, 'reviewer', value.reviewerList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.endorserList.Count - 1 do
      ComposeContactDetail(xml, 'endorser', value.endorserList[i]);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.relatedArtifactList.Count - 1 do
      ComposeRelatedArtifact(xml, 'relatedArtifact', value.relatedArtifactList[i]);
  if (SummaryOption in [soFull, soData]) then
    ComposeMarkdown(xml, 'description', value.descriptionElement);
  if (SummaryOption in [soFull, soData]) then
    ComposeMarkdown(xml, 'assertion', value.assertionElement);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.noteList.Count - 1 do
      ComposeAnnotation(xml, 'note', value.noteList[i]);
  for i := 0 to value.variableDefinitionList.Count - 1 do
      ComposeEvidenceVariableDefinition(xml, 'variableDefinition', value.variableDefinitionList[i]);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(xml, 'synthesisType', value.synthesisType);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.studyDesignList.Count - 1 do
      ComposeCodeableConcept(xml, 'studyDesign', value.studyDesignList[i]);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.statisticList.Count - 1 do
      ComposeEvidenceStatistic(xml, 'statistic', value.statisticList[i]);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.certaintyList.Count - 1 do
      ComposeEvidenceCertainty(xml, 'certainty', value.certaintyList[i]);
end;

{$ENDIF FHIR_EVIDENCE}
{$IFDEF FHIR_EVIDENCEREPORT}
function TFHIRXmlParser.ParseEvidenceReportSubject(element : TMXmlElement; path : string) : TFhirEvidenceReportSubject;
var
  child : TMXmlElement;
begin
  result := TFhirEvidenceReportSubject.Create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseEvidenceReportSubjectChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseEvidenceReportSubjectChild(value : TFhirEvidenceReportSubject; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'characteristic') then
        value.characteristicList.Add(ParseEvidenceReportSubjectCharacteristic(child, path+'/characteristic'))
      else if (child.localName = 'note') then
        value.noteList.Add(ParseAnnotation(child, path+'/note'))
      else if Not ParseBackboneElementChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeEvidenceReportSubject(xml : TXmlBuilder; name : String; value : TFhirEvidenceReportSubject);
begin
  if (value = nil) then
    exit;
  composeElementAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeEvidenceReportSubjectChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeEvidenceReportSubjectChildren(xml : TXmlBuilder; value : TFhirEvidenceReportSubject);
var
  i : integer;
begin
  composeBackboneElementChildren(xml, value);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.characteristicList.Count - 1 do
      ComposeEvidenceReportSubjectCharacteristic(xml, 'characteristic', value.characteristicList[i]);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.noteList.Count - 1 do
      ComposeAnnotation(xml, 'note', value.noteList[i]);
end;

function TFHIRXmlParser.ParseEvidenceReportSubjectCharacteristic(element : TMXmlElement; path : string) : TFhirEvidenceReportSubjectCharacteristic;
var
  child : TMXmlElement;
begin
  result := TFhirEvidenceReportSubjectCharacteristic.Create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseEvidenceReportSubjectCharacteristicChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseEvidenceReportSubjectCharacteristicChild(value : TFhirEvidenceReportSubjectCharacteristic; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'code') then
        value.code := ParseCodeableConcept(child, path+'/code')
      else if (child.localName = 'valueReference') then
        value.value := ParseReference(child, path+'/valueReference')
      else if (child.localName = 'valueCodeableConcept') then
        value.value := ParseCodeableConcept(child, path+'/valueCodeableConcept')
      else if (child.localName = 'valueQuantity') then
        value.value := ParseQuantity(child, path+'/valueQuantity')
      else if (child.localName = 'valueRange') then
        value.value := ParseRange(child, path+'/valueRange')
      else if (child.localName = 'valueBoolean') then
        value.value := ParseBoolean(child, path+'/valueBoolean')
      else if (child.localName = 'exclude') then
        value.excludeElement := ParseBoolean(child, path+'/exclude')
      else if (child.localName = 'period') then
        value.period := ParsePeriod(child, path+'/period')
      else if Not ParseBackboneElementChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeEvidenceReportSubjectCharacteristic(xml : TXmlBuilder; name : String; value : TFhirEvidenceReportSubjectCharacteristic);
begin
  if (value = nil) then
    exit;
  composeElementAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeEvidenceReportSubjectCharacteristicChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeEvidenceReportSubjectCharacteristicChildren(xml : TXmlBuilder; value : TFhirEvidenceReportSubjectCharacteristic);
begin
  composeBackboneElementChildren(xml, value);
  ComposeCodeableConcept(xml, 'code', value.code);
  if (value.value is TFhirReference) {2} then
    ComposeReference(xml, 'valueReference', TFhirReference(value.value))
  else if (value.value is TFhirCodeableConcept) {6} then
    ComposeCodeableConcept(xml, 'valueCodeableConcept', TFhirCodeableConcept(value.value))
  else if (value.value is TFhirQuantity) {6} then
    ComposeQuantity(xml, 'valueQuantity', TFhirQuantity(value.value))
  else if (value.value is TFhirRange) {6} then
    ComposeRange(xml, 'valueRange', TFhirRange(value.value))
  else if (value.value is TFhirBoolean) {6} then
    ComposeBoolean(xml, 'valueBoolean', TFhirBoolean(value.value));
  if (SummaryOption in [soFull, soData]) then
    ComposeBoolean(xml, 'exclude', value.excludeElement);
  if (SummaryOption in [soFull, soData]) then
    ComposePeriod(xml, 'period', value.period);
end;

function TFHIRXmlParser.ParseEvidenceReportRelatesTo(element : TMXmlElement; path : string) : TFhirEvidenceReportRelatesTo;
var
  child : TMXmlElement;
begin
  result := TFhirEvidenceReportRelatesTo.Create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseEvidenceReportRelatesToChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseEvidenceReportRelatesToChild(value : TFhirEvidenceReportRelatesTo; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'code') then
        value.codeElement := ParseEnum(CODES_TFhirReportRelationshipTypeEnum, SYSTEMS_TFhirReportRelationshipTypeEnum, child, path+'/code')
      else if (child.localName = 'target') then
        value.target := ParseEvidenceReportRelatesToTarget(child, path+'/target')
      else if Not ParseBackboneElementChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeEvidenceReportRelatesTo(xml : TXmlBuilder; name : String; value : TFhirEvidenceReportRelatesTo);
begin
  if (value = nil) then
    exit;
  composeElementAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeEvidenceReportRelatesToChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeEvidenceReportRelatesToChildren(xml : TXmlBuilder; value : TFhirEvidenceReportRelatesTo);
begin
  composeBackboneElementChildren(xml, value);
  ComposeEnum(xml, 'code', value.codeElement, CODES_TFhirReportRelationshipTypeEnum);
  ComposeEvidenceReportRelatesToTarget(xml, 'target', value.target);
end;

function TFHIRXmlParser.ParseEvidenceReportRelatesToTarget(element : TMXmlElement; path : string) : TFhirEvidenceReportRelatesToTarget;
var
  child : TMXmlElement;
begin
  result := TFhirEvidenceReportRelatesToTarget.Create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseEvidenceReportRelatesToTargetChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseEvidenceReportRelatesToTargetChild(value : TFhirEvidenceReportRelatesToTarget; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'url') then
        value.urlElement := ParseUri(child, path+'/url')
      else if (child.localName = 'identifier') then
        value.identifier := ParseIdentifier(child, path+'/identifier')
      else if (child.localName = 'display') then
        value.displayElement := ParseMarkdown(child, path+'/display')
      else if (child.localName = 'resource') then
        value.resource := ParseReference(child, path+'/resource')
      else if Not ParseBackboneElementChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeEvidenceReportRelatesToTarget(xml : TXmlBuilder; name : String; value : TFhirEvidenceReportRelatesToTarget);
begin
  if (value = nil) then
    exit;
  composeElementAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeEvidenceReportRelatesToTargetChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeEvidenceReportRelatesToTargetChildren(xml : TXmlBuilder; value : TFhirEvidenceReportRelatesToTarget);
begin
  composeBackboneElementChildren(xml, value);
  if (SummaryOption in [soFull, soData]) then
    ComposeUri(xml, 'url', value.urlElement);
  if (SummaryOption in [soFull, soData]) then
    ComposeIdentifier(xml, 'identifier', value.identifier);
  if (SummaryOption in [soFull, soData]) then
    ComposeMarkdown(xml, 'display', value.displayElement);
  if (SummaryOption in [soFull, soData]) then
    ComposeReference(xml, 'resource', value.resource);
end;

function TFHIRXmlParser.ParseEvidenceReportSection(element : TMXmlElement; path : string) : TFhirEvidenceReportSection;
var
  child : TMXmlElement;
begin
  result := TFhirEvidenceReportSection.Create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseEvidenceReportSectionChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseEvidenceReportSectionChild(value : TFhirEvidenceReportSection; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'title') then
        value.titleElement := ParseString(child, path+'/title')
      else if (child.localName = 'focus') then
        value.focus := ParseCodeableConcept(child, path+'/focus')
      else if (child.localName = 'focusReference') then
        value.focusReference := ParseReference(child, path+'/focusReference')
      else if (child.localName = 'author') then
        value.authorList.Add(ParseReference(child, path+'/author'))
      else if (child.localName = 'text') then
        value.text := ParseNarrative(child, path+'/text')
      else if (child.localName = 'mode') then
        value.modeElement := ParseEnum(CODES_TFhirListModeEnum, SYSTEMS_TFhirListModeEnum, child, path+'/mode')
      else if (child.localName = 'orderedBy') then
        value.orderedBy := ParseCodeableConcept(child, path+'/orderedBy')
      else if (child.localName = 'entryClassifier') then
        value.entryClassifierList.Add(ParseCodeableConcept(child, path+'/entryClassifier'))
      else if (child.localName = 'entryReference') then
        value.entryReferenceList.Add(ParseReference(child, path+'/entryReference'))
      else if (child.localName = 'entryQuantity') then
        value.entryQuantityList.Add(ParseQuantity(child, path+'/entryQuantity'))
      else if (child.localName = 'emptyReason') then
        value.emptyReason := ParseCodeableConcept(child, path+'/emptyReason')
      else if (child.localName = 'section') then
        value.sectionList.Add(ParseEvidenceReportSection(child, path+'/section'))
      else if Not ParseBackboneElementChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeEvidenceReportSection(xml : TXmlBuilder; name : String; value : TFhirEvidenceReportSection);
begin
  if (value = nil) then
    exit;
  composeElementAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeEvidenceReportSectionChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeEvidenceReportSectionChildren(xml : TXmlBuilder; value : TFhirEvidenceReportSection);
var
  i : integer;
begin
  composeBackboneElementChildren(xml, value);
  if (SummaryOption in [soFull, soData]) then
    ComposeString(xml, 'title', value.titleElement);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(xml, 'focus', value.focus);
  if (SummaryOption in [soFull, soData]) then
    ComposeReference(xml, 'focusReference', value.focusReference);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.authorList.Count - 1 do
      ComposeReference(xml, 'author', value.authorList[i]);
  if (SummaryOption in [soFull, soData]) then
    ComposeNarrative(xml, 'text', value.text);
  if (SummaryOption in [soFull, soData]) then
    ComposeEnum(xml, 'mode', value.modeElement, CODES_TFhirListModeEnum);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(xml, 'orderedBy', value.orderedBy);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.entryClassifierList.Count - 1 do
      ComposeCodeableConcept(xml, 'entryClassifier', value.entryClassifierList[i]);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.entryReferenceList.Count - 1 do
      ComposeReference(xml, 'entryReference', value.entryReferenceList[i]);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.entryQuantityList.Count - 1 do
      ComposeQuantity(xml, 'entryQuantity', value.entryQuantityList[i]);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(xml, 'emptyReason', value.emptyReason);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.sectionList.Count - 1 do
      ComposeEvidenceReportSection(xml, 'section', value.sectionList[i]);
end;

function TFHIRXmlParser.ParseEvidenceReport(element : TMXmlElement; path : string) : TFhirEvidenceReport;
var
  child : TMXmlElement;
begin
  result := TFhirEvidenceReport.Create;
  try
    parseMetadataResourceAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseEvidenceReportChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseEvidenceReportChild(value : TFhirEvidenceReport; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'url') then
        value.urlElement := ParseUri(child, path+'/url')
      else if (child.localName = 'status') then
        value.statusElement := ParseEnum(CODES_TFhirPublicationStatusEnum, SYSTEMS_TFhirPublicationStatusEnum, child, path+'/status')
      else if (child.localName = 'useContext') then
        value.useContextList.Add(ParseUsageContext(child, path+'/useContext'))
      else if (child.localName = 'identifier') then
        value.identifierList.Add(ParseIdentifier(child, path+'/identifier'))
      else if (child.localName = 'relatedIdentifier') then
        value.relatedIdentifierList.Add(ParseIdentifier(child, path+'/relatedIdentifier'))
      else if (child.localName = 'citeAsReference') then
        value.citeAs := ParseReference(child, path+'/citeAsReference')
      else if (child.localName = 'citeAsMarkdown') then
        value.citeAs := ParseMarkdown(child, path+'/citeAsMarkdown')
      else if (child.localName = 'type') then
        value.type_ := ParseCodeableConcept(child, path+'/type')
      else if (child.localName = 'note') then
        value.noteList.Add(ParseAnnotation(child, path+'/note'))
      else if (child.localName = 'relatedArtifact') then
        value.relatedArtifactList.Add(ParseRelatedArtifact(child, path+'/relatedArtifact'))
      else if (child.localName = 'subject') then
        value.subject := ParseEvidenceReportSubject(child, path+'/subject')
      else if (child.localName = 'publisher') then
        value.publisherElement := ParseString(child, path+'/publisher')
      else if (child.localName = 'contact') then
        value.contactList.Add(ParseContactDetail(child, path+'/contact'))
      else if (child.localName = 'author') then
        value.authorList.Add(ParseContactDetail(child, path+'/author'))
      else if (child.localName = 'editor') then
        value.editorList.Add(ParseContactDetail(child, path+'/editor'))
      else if (child.localName = 'reviewer') then
        value.reviewerList.Add(ParseContactDetail(child, path+'/reviewer'))
      else if (child.localName = 'endorser') then
        value.endorserList.Add(ParseContactDetail(child, path+'/endorser'))
      else if (child.localName = 'relatesTo') then
        value.relatesToList.Add(ParseEvidenceReportRelatesTo(child, path+'/relatesTo'))
      else if (child.localName = 'section') then
        value.sectionList.Add(ParseEvidenceReportSection(child, path+'/section'))
      else if Not ParseMetadataResourceChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeEvidenceReport(xml : TXmlBuilder; name : String; value : TFhirEvidenceReport);
begin
  if (value = nil) then
    exit;
  composeMetadataResourceAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeEvidenceReportChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeEvidenceReportChildren(xml : TXmlBuilder; value : TFhirEvidenceReport);
var
  i : integer;
begin
  composeMetadataResourceChildren(xml, value);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeUri(xml, 'url', value.urlElement);
  ComposeEnum(xml, 'status', value.statusElement, CODES_TFhirPublicationStatusEnum);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.useContextList.Count - 1 do
      ComposeUsageContext(xml, 'useContext', value.useContextList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.identifierList.Count - 1 do
      ComposeIdentifier(xml, 'identifier', value.identifierList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.relatedIdentifierList.Count - 1 do
      ComposeIdentifier(xml, 'relatedIdentifier', value.relatedIdentifierList[i]);
  if (SummaryOption in [soFull, soData]) and (value.citeAs is TFhirReference) {2} then
    ComposeReference(xml, 'citeAsReference', TFhirReference(value.citeAs))
  else if (SummaryOption in [soFull, soData]) and (value.citeAs is TFhirMarkdown) {6} then
    ComposeMarkdown(xml, 'citeAsMarkdown', TFhirMarkdown(value.citeAs));
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(xml, 'type', value.type_);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.noteList.Count - 1 do
      ComposeAnnotation(xml, 'note', value.noteList[i]);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.relatedArtifactList.Count - 1 do
      ComposeRelatedArtifact(xml, 'relatedArtifact', value.relatedArtifactList[i]);
  ComposeEvidenceReportSubject(xml, 'subject', value.subject);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(xml, 'publisher', value.publisherElement);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.contactList.Count - 1 do
      ComposeContactDetail(xml, 'contact', value.contactList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.authorList.Count - 1 do
      ComposeContactDetail(xml, 'author', value.authorList[i]);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.editorList.Count - 1 do
      ComposeContactDetail(xml, 'editor', value.editorList[i]);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.reviewerList.Count - 1 do
      ComposeContactDetail(xml, 'reviewer', value.reviewerList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.endorserList.Count - 1 do
      ComposeContactDetail(xml, 'endorser', value.endorserList[i]);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.relatesToList.Count - 1 do
      ComposeEvidenceReportRelatesTo(xml, 'relatesTo', value.relatesToList[i]);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.sectionList.Count - 1 do
      ComposeEvidenceReportSection(xml, 'section', value.sectionList[i]);
end;

{$ENDIF FHIR_EVIDENCEREPORT}
{$IFDEF FHIR_EVIDENCEVARIABLE}
function TFHIRXmlParser.ParseEvidenceVariableCharacteristic(element : TMXmlElement; path : string) : TFhirEvidenceVariableCharacteristic;
var
  child : TMXmlElement;
begin
  result := TFhirEvidenceVariableCharacteristic.Create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseEvidenceVariableCharacteristicChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseEvidenceVariableCharacteristicChild(value : TFhirEvidenceVariableCharacteristic; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'linkId') then
        value.linkIdElement := ParseId(child, path+'/linkId')
      else if (child.localName = 'description') then
        value.descriptionElement := ParseString(child, path+'/description')
      else if (child.localName = 'note') then
        value.noteList.Add(ParseAnnotation(child, path+'/note'))
      else if (child.localName = 'exclude') then
        value.excludeElement := ParseBoolean(child, path+'/exclude')
      else if (child.localName = 'definitionReference') then
        value.definitionReference := ParseReference(child, path+'/definitionReference')
      else if (child.localName = 'definitionCanonical') then
        value.definitionCanonicalElement := ParseCanonical(child, path+'/definitionCanonical')
      else if (child.localName = 'definitionCodeableConcept') then
        value.definitionCodeableConcept := ParseCodeableConcept(child, path+'/definitionCodeableConcept')
      else if (child.localName = 'definitionExpression') then
        value.definitionExpression := ParseExpression(child, path+'/definitionExpression')
      else if (child.localName = 'definitionId') then
        value.definitionIdElement := ParseId(child, path+'/definitionId')
      else if (child.localName = 'definitionByTypeAndValue') then
        value.definitionByTypeAndValue := ParseEvidenceVariableCharacteristicDefinitionByTypeAndValue(child, path+'/definitionByTypeAndValue')
      else if (child.localName = 'definitionByCombination') then
        value.definitionByCombination := ParseEvidenceVariableCharacteristicDefinitionByCombination(child, path+'/definitionByCombination')
      else if (child.localName = 'timeFromEvent') then
        value.timeFromEventList.Add(ParseEvidenceVariableCharacteristicTimeFromEvent(child, path+'/timeFromEvent'))
      else if Not ParseBackboneElementChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeEvidenceVariableCharacteristic(xml : TXmlBuilder; name : String; value : TFhirEvidenceVariableCharacteristic);
begin
  if (value = nil) then
    exit;
  composeElementAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeEvidenceVariableCharacteristicChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeEvidenceVariableCharacteristicChildren(xml : TXmlBuilder; value : TFhirEvidenceVariableCharacteristic);
var
  i : integer;
begin
  composeBackboneElementChildren(xml, value);
  if (SummaryOption in [soFull, soData]) then
    ComposeId(xml, 'linkId', value.linkIdElement);
  if (SummaryOption in [soFull, soData]) then
    ComposeString(xml, 'description', value.descriptionElement);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.noteList.Count - 1 do
      ComposeAnnotation(xml, 'note', value.noteList[i]);
  if (SummaryOption in [soFull, soData]) then
    ComposeBoolean(xml, 'exclude', value.excludeElement);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference(xml, 'definitionReference', value.definitionReference);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCanonical(xml, 'definitionCanonical', value.definitionCanonicalElement);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(xml, 'definitionCodeableConcept', value.definitionCodeableConcept);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeExpression(xml, 'definitionExpression', value.definitionExpression);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeId(xml, 'definitionId', value.definitionIdElement);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeEvidenceVariableCharacteristicDefinitionByTypeAndValue(xml, 'definitionByTypeAndValue', value.definitionByTypeAndValue);
  if (SummaryOption in [soFull, soData]) then
    ComposeEvidenceVariableCharacteristicDefinitionByCombination(xml, 'definitionByCombination', value.definitionByCombination);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.timeFromEventList.Count - 1 do
      ComposeEvidenceVariableCharacteristicTimeFromEvent(xml, 'timeFromEvent', value.timeFromEventList[i]);
end;

function TFHIRXmlParser.ParseEvidenceVariableCharacteristicDefinitionByTypeAndValue(element : TMXmlElement; path : string) : TFhirEvidenceVariableCharacteristicDefinitionByTypeAndValue;
var
  child : TMXmlElement;
begin
  result := TFhirEvidenceVariableCharacteristicDefinitionByTypeAndValue.Create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseEvidenceVariableCharacteristicDefinitionByTypeAndValueChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseEvidenceVariableCharacteristicDefinitionByTypeAndValueChild(value : TFhirEvidenceVariableCharacteristicDefinitionByTypeAndValue; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'type') then
        value.type_ := ParseCodeableConcept(child, path+'/type')
      else if (child.localName = 'method') then
        value.methodList.Add(ParseCodeableConcept(child, path+'/method'))
      else if (child.localName = 'device') then
        value.device := ParseReference(child, path+'/device')
      else if (child.localName = 'valueCodeableConcept') then
        value.value := ParseCodeableConcept(child, path+'/valueCodeableConcept')
      else if (child.localName = 'valueQuantity') then
        value.value := ParseQuantity(child, path+'/valueQuantity')
      else if (child.localName = 'valueRange') then
        value.value := ParseRange(child, path+'/valueRange')
      else if (child.localName = 'valueReference') then
        value.value := ParseReference(child, path+'/valueReference')
      else if (child.localName = 'valueId') then
        value.value := ParseId(child, path+'/valueId')
      else if (child.localName = 'valueBoolean') then
        value.value := ParseBoolean(child, path+'/valueBoolean')
      else if (child.localName = 'offset') then
        value.offset := ParseCodeableConcept(child, path+'/offset')
      else if Not ParseBackboneElementChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeEvidenceVariableCharacteristicDefinitionByTypeAndValue(xml : TXmlBuilder; name : String; value : TFhirEvidenceVariableCharacteristicDefinitionByTypeAndValue);
begin
  if (value = nil) then
    exit;
  composeElementAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeEvidenceVariableCharacteristicDefinitionByTypeAndValueChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeEvidenceVariableCharacteristicDefinitionByTypeAndValueChildren(xml : TXmlBuilder; value : TFhirEvidenceVariableCharacteristicDefinitionByTypeAndValue);
var
  i : integer;
begin
  composeBackboneElementChildren(xml, value);
  ComposeCodeableConcept(xml, 'type', value.type_);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.methodList.Count - 1 do
      ComposeCodeableConcept(xml, 'method', value.methodList[i]);
  if (SummaryOption in [soFull, soData]) then
    ComposeReference(xml, 'device', value.device);
  if (value.value is TFhirCodeableConcept) {6} then
    ComposeCodeableConcept(xml, 'valueCodeableConcept', TFhirCodeableConcept(value.value))
  else if (value.value is TFhirQuantity) {6} then
    ComposeQuantity(xml, 'valueQuantity', TFhirQuantity(value.value))
  else if (value.value is TFhirRange) {6} then
    ComposeRange(xml, 'valueRange', TFhirRange(value.value))
  else if (value.value is TFhirReference) {6} then
    ComposeReference(xml, 'valueReference', TFhirReference(value.value))
  else if (value.value is TFhirId) {6} then
    ComposeId(xml, 'valueId', TFhirId(value.value))
  else if (value.value is TFhirBoolean) {6} then
    ComposeBoolean(xml, 'valueBoolean', TFhirBoolean(value.value));
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(xml, 'offset', value.offset);
end;

function TFHIRXmlParser.ParseEvidenceVariableCharacteristicDefinitionByCombination(element : TMXmlElement; path : string) : TFhirEvidenceVariableCharacteristicDefinitionByCombination;
var
  child : TMXmlElement;
begin
  result := TFhirEvidenceVariableCharacteristicDefinitionByCombination.Create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseEvidenceVariableCharacteristicDefinitionByCombinationChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseEvidenceVariableCharacteristicDefinitionByCombinationChild(value : TFhirEvidenceVariableCharacteristicDefinitionByCombination; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'code') then
        value.codeElement := ParseEnum(CODES_TFhirCharacteristicCombinationEnum, SYSTEMS_TFhirCharacteristicCombinationEnum, child, path+'/code')
      else if (child.localName = 'threshold') then
        value.thresholdElement := ParsePositiveInt(child, path+'/threshold')
      else if (child.localName = 'characteristic') then
        value.characteristicList.Add(ParseEvidenceVariableCharacteristic(child, path+'/characteristic'))
      else if Not ParseBackboneElementChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeEvidenceVariableCharacteristicDefinitionByCombination(xml : TXmlBuilder; name : String; value : TFhirEvidenceVariableCharacteristicDefinitionByCombination);
begin
  if (value = nil) then
    exit;
  composeElementAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeEvidenceVariableCharacteristicDefinitionByCombinationChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeEvidenceVariableCharacteristicDefinitionByCombinationChildren(xml : TXmlBuilder; value : TFhirEvidenceVariableCharacteristicDefinitionByCombination);
var
  i : integer;
begin
  composeBackboneElementChildren(xml, value);
  ComposeEnum(xml, 'code', value.codeElement, CODES_TFhirCharacteristicCombinationEnum);
  if (SummaryOption in [soFull, soData]) then
    ComposePositiveInt(xml, 'threshold', value.thresholdElement);
  for i := 0 to value.characteristicList.Count - 1 do
      ComposeEvidenceVariableCharacteristic(xml, 'characteristic', value.characteristicList[i]);
end;

function TFHIRXmlParser.ParseEvidenceVariableCharacteristicTimeFromEvent(element : TMXmlElement; path : string) : TFhirEvidenceVariableCharacteristicTimeFromEvent;
var
  child : TMXmlElement;
begin
  result := TFhirEvidenceVariableCharacteristicTimeFromEvent.Create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseEvidenceVariableCharacteristicTimeFromEventChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseEvidenceVariableCharacteristicTimeFromEventChild(value : TFhirEvidenceVariableCharacteristicTimeFromEvent; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'description') then
        value.descriptionElement := ParseString(child, path+'/description')
      else if (child.localName = 'note') then
        value.noteList.Add(ParseAnnotation(child, path+'/note'))
      else if (child.localName = 'eventCodeableConcept') then
        value.event := ParseCodeableConcept(child, path+'/eventCodeableConcept')
      else if (child.localName = 'eventReference') then
        value.event := ParseReference(child, path+'/eventReference')
      else if (child.localName = 'eventId') then
        value.event := ParseId(child, path+'/eventId')
      else if (child.localName = 'eventDateTime') then
        value.event := ParseDateTime(child, path+'/eventDateTime')
      else if (child.localName = 'quantity') then
        value.quantity := ParseQuantity(child, path+'/quantity')
      else if (child.localName = 'range') then
        value.range := ParseRange(child, path+'/range')
      else if Not ParseBackboneElementChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeEvidenceVariableCharacteristicTimeFromEvent(xml : TXmlBuilder; name : String; value : TFhirEvidenceVariableCharacteristicTimeFromEvent);
begin
  if (value = nil) then
    exit;
  composeElementAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeEvidenceVariableCharacteristicTimeFromEventChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeEvidenceVariableCharacteristicTimeFromEventChildren(xml : TXmlBuilder; value : TFhirEvidenceVariableCharacteristicTimeFromEvent);
var
  i : integer;
begin
  composeBackboneElementChildren(xml, value);
  if (SummaryOption in [soFull, soData]) then
    ComposeString(xml, 'description', value.descriptionElement);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.noteList.Count - 1 do
      ComposeAnnotation(xml, 'note', value.noteList[i]);
  if (SummaryOption in [soFull, soData]) and (value.event is TFhirCodeableConcept) {6} then
    ComposeCodeableConcept(xml, 'eventCodeableConcept', TFhirCodeableConcept(value.event))
  else if (SummaryOption in [soFull, soData]) and (value.event is TFhirReference) {6} then
    ComposeReference(xml, 'eventReference', TFhirReference(value.event))
  else if (SummaryOption in [soFull, soData]) and (value.event is TFhirId) {6} then
    ComposeId(xml, 'eventId', TFhirId(value.event))
  else if (SummaryOption in [soFull, soData]) and (value.event is TFhirDateTime) {6} then
    ComposeDateTime(xml, 'eventDateTime', TFhirDateTime(value.event));
  if (SummaryOption in [soFull, soData]) then
    ComposeQuantity(xml, 'quantity', value.quantity);
  if (SummaryOption in [soFull, soData]) then
    ComposeRange(xml, 'range', value.range);
end;

function TFHIRXmlParser.ParseEvidenceVariableCategory(element : TMXmlElement; path : string) : TFhirEvidenceVariableCategory;
var
  child : TMXmlElement;
begin
  result := TFhirEvidenceVariableCategory.Create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseEvidenceVariableCategoryChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseEvidenceVariableCategoryChild(value : TFhirEvidenceVariableCategory; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'name') then
        value.nameElement := ParseString(child, path+'/name')
      else if (child.localName = 'valueCodeableConcept') then
        value.value := ParseCodeableConcept(child, path+'/valueCodeableConcept')
      else if (child.localName = 'valueQuantity') then
        value.value := ParseQuantity(child, path+'/valueQuantity')
      else if (child.localName = 'valueRange') then
        value.value := ParseRange(child, path+'/valueRange')
      else if Not ParseBackboneElementChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeEvidenceVariableCategory(xml : TXmlBuilder; name : String; value : TFhirEvidenceVariableCategory);
begin
  if (value = nil) then
    exit;
  composeElementAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeEvidenceVariableCategoryChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeEvidenceVariableCategoryChildren(xml : TXmlBuilder; value : TFhirEvidenceVariableCategory);
begin
  composeBackboneElementChildren(xml, value);
  if (SummaryOption in [soFull, soData]) then
    ComposeString(xml, 'name', value.nameElement);
  if (SummaryOption in [soFull, soData]) and (value.value is TFhirCodeableConcept) {6} then
    ComposeCodeableConcept(xml, 'valueCodeableConcept', TFhirCodeableConcept(value.value))
  else if (SummaryOption in [soFull, soData]) and (value.value is TFhirQuantity) {6} then
    ComposeQuantity(xml, 'valueQuantity', TFhirQuantity(value.value))
  else if (SummaryOption in [soFull, soData]) and (value.value is TFhirRange) {6} then
    ComposeRange(xml, 'valueRange', TFhirRange(value.value));
end;

function TFHIRXmlParser.ParseEvidenceVariable(element : TMXmlElement; path : string) : TFhirEvidenceVariable;
var
  child : TMXmlElement;
begin
  result := TFhirEvidenceVariable.Create;
  try
    parseMetadataResourceAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseEvidenceVariableChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseEvidenceVariableChild(value : TFhirEvidenceVariable; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'url') then
        value.urlElement := ParseUri(child, path+'/url')
      else if (child.localName = 'identifier') then
        value.identifierList.Add(ParseIdentifier(child, path+'/identifier'))
      else if (child.localName = 'version') then
        value.versionElement := ParseString(child, path+'/version')
      else if (child.localName = 'name') then
        value.nameElement := ParseString(child, path+'/name')
      else if (child.localName = 'title') then
        value.titleElement := ParseString(child, path+'/title')
      else if (child.localName = 'shortTitle') then
        value.shortTitleElement := ParseString(child, path+'/shortTitle')
      else if (child.localName = 'subtitle') then
        value.subtitleElement := ParseString(child, path+'/subtitle')
      else if (child.localName = 'status') then
        value.statusElement := ParseEnum(CODES_TFhirPublicationStatusEnum, SYSTEMS_TFhirPublicationStatusEnum, child, path+'/status')
      else if (child.localName = 'experimental') then
        value.experimentalElement := ParseBoolean(child, path+'/experimental')
      else if (child.localName = 'date') then
        value.dateElement := ParseDateTime(child, path+'/date')
      else if (child.localName = 'publisher') then
        value.publisherElement := ParseString(child, path+'/publisher')
      else if (child.localName = 'contact') then
        value.contactList.Add(ParseContactDetail(child, path+'/contact'))
      else if (child.localName = 'description') then
        value.descriptionElement := ParseMarkdown(child, path+'/description')
      else if (child.localName = 'note') then
        value.noteList.Add(ParseAnnotation(child, path+'/note'))
      else if (child.localName = 'useContext') then
        value.useContextList.Add(ParseUsageContext(child, path+'/useContext'))
      else if (child.localName = 'copyright') then
        value.copyrightElement := ParseMarkdown(child, path+'/copyright')
      else if (child.localName = 'approvalDate') then
        value.approvalDateElement := ParseDate(child, path+'/approvalDate')
      else if (child.localName = 'lastReviewDate') then
        value.lastReviewDateElement := ParseDate(child, path+'/lastReviewDate')
      else if (child.localName = 'effectivePeriod') then
        value.effectivePeriod := ParsePeriod(child, path+'/effectivePeriod')
      else if (child.localName = 'author') then
        value.authorList.Add(ParseContactDetail(child, path+'/author'))
      else if (child.localName = 'editor') then
        value.editorList.Add(ParseContactDetail(child, path+'/editor'))
      else if (child.localName = 'reviewer') then
        value.reviewerList.Add(ParseContactDetail(child, path+'/reviewer'))
      else if (child.localName = 'endorser') then
        value.endorserList.Add(ParseContactDetail(child, path+'/endorser'))
      else if (child.localName = 'relatedArtifact') then
        value.relatedArtifactList.Add(ParseRelatedArtifact(child, path+'/relatedArtifact'))
      else if (child.localName = 'actual') then
        value.actualElement := ParseBoolean(child, path+'/actual')
      else if (child.localName = 'characteristic') then
        value.characteristicList.Add(ParseEvidenceVariableCharacteristic(child, path+'/characteristic'))
      else if (child.localName = 'handling') then
        value.handlingElement := ParseEnum(CODES_TFhirEvidenceVariableHandlingEnum, SYSTEMS_TFhirEvidenceVariableHandlingEnum, child, path+'/handling')
      else if (child.localName = 'category') then
        value.categoryList.Add(ParseEvidenceVariableCategory(child, path+'/category'))
      else if Not ParseMetadataResourceChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeEvidenceVariable(xml : TXmlBuilder; name : String; value : TFhirEvidenceVariable);
begin
  if (value = nil) then
    exit;
  composeMetadataResourceAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeEvidenceVariableChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeEvidenceVariableChildren(xml : TXmlBuilder; value : TFhirEvidenceVariable);
var
  i : integer;
begin
  composeMetadataResourceChildren(xml, value);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeUri(xml, 'url', value.urlElement);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.identifierList.Count - 1 do
      ComposeIdentifier(xml, 'identifier', value.identifierList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(xml, 'version', value.versionElement);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(xml, 'name', value.nameElement);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(xml, 'title', value.titleElement);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(xml, 'shortTitle', value.shortTitleElement);
  if (SummaryOption in [soFull, soData]) then
    ComposeString(xml, 'subtitle', value.subtitleElement);
  ComposeEnum(xml, 'status', value.statusElement, CODES_TFhirPublicationStatusEnum);
  if (SummaryOption in [soFull, soData]) then
    ComposeBoolean(xml, 'experimental', value.experimentalElement);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDateTime(xml, 'date', value.dateElement);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(xml, 'publisher', value.publisherElement);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.contactList.Count - 1 do
      ComposeContactDetail(xml, 'contact', value.contactList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeMarkdown(xml, 'description', value.descriptionElement);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.noteList.Count - 1 do
      ComposeAnnotation(xml, 'note', value.noteList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.useContextList.Count - 1 do
      ComposeUsageContext(xml, 'useContext', value.useContextList[i]);
  if (SummaryOption in [soFull, soData]) then
    ComposeMarkdown(xml, 'copyright', value.copyrightElement);
  if (SummaryOption in [soFull, soData]) then
    ComposeDate(xml, 'approvalDate', value.approvalDateElement);
  if (SummaryOption in [soFull, soData]) then
    ComposeDate(xml, 'lastReviewDate', value.lastReviewDateElement);
  if (SummaryOption in [soFull, soData]) then
    ComposePeriod(xml, 'effectivePeriod', value.effectivePeriod);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.authorList.Count - 1 do
      ComposeContactDetail(xml, 'author', value.authorList[i]);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.editorList.Count - 1 do
      ComposeContactDetail(xml, 'editor', value.editorList[i]);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.reviewerList.Count - 1 do
      ComposeContactDetail(xml, 'reviewer', value.reviewerList[i]);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.endorserList.Count - 1 do
      ComposeContactDetail(xml, 'endorser', value.endorserList[i]);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.relatedArtifactList.Count - 1 do
      ComposeRelatedArtifact(xml, 'relatedArtifact', value.relatedArtifactList[i]);
  if (SummaryOption in [soFull, soData]) then
    ComposeBoolean(xml, 'actual', value.actualElement);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.characteristicList.Count - 1 do
      ComposeEvidenceVariableCharacteristic(xml, 'characteristic', value.characteristicList[i]);
  if (SummaryOption in [soFull, soData]) then
    ComposeEnum(xml, 'handling', value.handlingElement, CODES_TFhirEvidenceVariableHandlingEnum);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.categoryList.Count - 1 do
      ComposeEvidenceVariableCategory(xml, 'category', value.categoryList[i]);
end;

{$ENDIF FHIR_EVIDENCEVARIABLE}
{$IFDEF FHIR_EXAMPLESCENARIO}
function TFHIRXmlParser.ParseExampleScenarioActor(element : TMXmlElement; path : string) : TFhirExampleScenarioActor;
var
  child : TMXmlElement;
begin
  result := TFhirExampleScenarioActor.Create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseExampleScenarioActorChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseExampleScenarioActorChild(value : TFhirExampleScenarioActor; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'key') then
        value.keyElement := ParseString(child, path+'/key')
      else if (child.localName = 'type') then
        value.type_Element := ParseEnum(CODES_TFhirExampleScenarioActorTypeEnum, SYSTEMS_TFhirExampleScenarioActorTypeEnum, child, path+'/type')
      else if (child.localName = 'title') then
        value.titleElement := ParseString(child, path+'/title')
      else if (child.localName = 'description') then
        value.descriptionElement := ParseMarkdown(child, path+'/description')
      else if Not ParseBackboneElementChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeExampleScenarioActor(xml : TXmlBuilder; name : String; value : TFhirExampleScenarioActor);
begin
  if (value = nil) then
    exit;
  composeElementAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeExampleScenarioActorChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeExampleScenarioActorChildren(xml : TXmlBuilder; value : TFhirExampleScenarioActor);
begin
  composeBackboneElementChildren(xml, value);
  ComposeString(xml, 'key', value.keyElement);
  ComposeEnum(xml, 'type', value.type_Element, CODES_TFhirExampleScenarioActorTypeEnum);
  ComposeString(xml, 'title', value.titleElement);
  if (SummaryOption in [soFull, soData]) then
    ComposeMarkdown(xml, 'description', value.descriptionElement);
end;

function TFHIRXmlParser.ParseExampleScenarioInstance(element : TMXmlElement; path : string) : TFhirExampleScenarioInstance;
var
  child : TMXmlElement;
begin
  result := TFhirExampleScenarioInstance.Create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseExampleScenarioInstanceChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseExampleScenarioInstanceChild(value : TFhirExampleScenarioInstance; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'key') then
        value.keyElement := ParseString(child, path+'/key')
      else if (child.localName = 'structureType') then
        value.structureType := ParseCoding(child, path+'/structureType')
      else if (child.localName = 'structureVersion') then
        value.structureVersionElement := ParseString(child, path+'/structureVersion')
      else if (child.localName = 'structureProfileCanonical') then
        value.structureProfile := ParseCanonical(child, path+'/structureProfileCanonical')
      else if (child.localName = 'structureProfileUri') then
        value.structureProfile := ParseUri(child, path+'/structureProfileUri')
      else if (child.localName = 'title') then
        value.titleElement := ParseString(child, path+'/title')
      else if (child.localName = 'description') then
        value.descriptionElement := ParseMarkdown(child, path+'/description')
      else if (child.localName = 'content') then
        value.content := ParseReference(child, path+'/content')
      else if (child.localName = 'version') then
        value.versionList.Add(ParseExampleScenarioInstanceVersion(child, path+'/version'))
      else if (child.localName = 'containedInstance') then
        value.containedInstanceList.Add(ParseExampleScenarioInstanceContainedInstance(child, path+'/containedInstance'))
      else if Not ParseBackboneElementChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeExampleScenarioInstance(xml : TXmlBuilder; name : String; value : TFhirExampleScenarioInstance);
begin
  if (value = nil) then
    exit;
  composeElementAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeExampleScenarioInstanceChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeExampleScenarioInstanceChildren(xml : TXmlBuilder; value : TFhirExampleScenarioInstance);
var
  i : integer;
begin
  composeBackboneElementChildren(xml, value);
  ComposeString(xml, 'key', value.keyElement);
  ComposeCoding(xml, 'structureType', value.structureType);
  if (SummaryOption in [soFull, soData]) then
    ComposeString(xml, 'structureVersion', value.structureVersionElement);
  if (SummaryOption in [soFull, soData]) and (value.structureProfile is TFhirCanonical) {6} then
    ComposeCanonical(xml, 'structureProfileCanonical', TFhirCanonical(value.structureProfile))
  else if (SummaryOption in [soFull, soData]) and (value.structureProfile is TFhirUri) {6} then
    ComposeUri(xml, 'structureProfileUri', TFhirUri(value.structureProfile));
  ComposeString(xml, 'title', value.titleElement);
  if (SummaryOption in [soFull, soData]) then
    ComposeMarkdown(xml, 'description', value.descriptionElement);
  if (SummaryOption in [soFull, soData]) then
    ComposeReference(xml, 'content', value.content);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.versionList.Count - 1 do
      ComposeExampleScenarioInstanceVersion(xml, 'version', value.versionList[i]);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.containedInstanceList.Count - 1 do
      ComposeExampleScenarioInstanceContainedInstance(xml, 'containedInstance', value.containedInstanceList[i]);
end;

function TFHIRXmlParser.ParseExampleScenarioInstanceVersion(element : TMXmlElement; path : string) : TFhirExampleScenarioInstanceVersion;
var
  child : TMXmlElement;
begin
  result := TFhirExampleScenarioInstanceVersion.Create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseExampleScenarioInstanceVersionChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseExampleScenarioInstanceVersionChild(value : TFhirExampleScenarioInstanceVersion; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'key') then
        value.keyElement := ParseString(child, path+'/key')
      else if (child.localName = 'description') then
        value.descriptionElement := ParseMarkdown(child, path+'/description')
      else if (child.localName = 'content') then
        value.content := ParseReference(child, path+'/content')
      else if Not ParseBackboneElementChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeExampleScenarioInstanceVersion(xml : TXmlBuilder; name : String; value : TFhirExampleScenarioInstanceVersion);
begin
  if (value = nil) then
    exit;
  composeElementAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeExampleScenarioInstanceVersionChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeExampleScenarioInstanceVersionChildren(xml : TXmlBuilder; value : TFhirExampleScenarioInstanceVersion);
begin
  composeBackboneElementChildren(xml, value);
  ComposeString(xml, 'key', value.keyElement);
  if (SummaryOption in [soFull, soData]) then
    ComposeMarkdown(xml, 'description', value.descriptionElement);
  if (SummaryOption in [soFull, soData]) then
    ComposeReference(xml, 'content', value.content);
end;

function TFHIRXmlParser.ParseExampleScenarioInstanceContainedInstance(element : TMXmlElement; path : string) : TFhirExampleScenarioInstanceContainedInstance;
var
  child : TMXmlElement;
begin
  result := TFhirExampleScenarioInstanceContainedInstance.Create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseExampleScenarioInstanceContainedInstanceChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseExampleScenarioInstanceContainedInstanceChild(value : TFhirExampleScenarioInstanceContainedInstance; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'instanceReference') then
        value.instanceReferenceElement := ParseString(child, path+'/instanceReference')
      else if (child.localName = 'versionReference') then
        value.versionReferenceElement := ParseString(child, path+'/versionReference')
      else if Not ParseBackboneElementChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeExampleScenarioInstanceContainedInstance(xml : TXmlBuilder; name : String; value : TFhirExampleScenarioInstanceContainedInstance);
begin
  if (value = nil) then
    exit;
  composeElementAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeExampleScenarioInstanceContainedInstanceChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeExampleScenarioInstanceContainedInstanceChildren(xml : TXmlBuilder; value : TFhirExampleScenarioInstanceContainedInstance);
begin
  composeBackboneElementChildren(xml, value);
  ComposeString(xml, 'instanceReference', value.instanceReferenceElement);
  if (SummaryOption in [soFull, soData]) then
    ComposeString(xml, 'versionReference', value.versionReferenceElement);
end;

function TFHIRXmlParser.ParseExampleScenarioProcess(element : TMXmlElement; path : string) : TFhirExampleScenarioProcess;
var
  child : TMXmlElement;
begin
  result := TFhirExampleScenarioProcess.Create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseExampleScenarioProcessChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseExampleScenarioProcessChild(value : TFhirExampleScenarioProcess; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'title') then
        value.titleElement := ParseString(child, path+'/title')
      else if (child.localName = 'description') then
        value.descriptionElement := ParseMarkdown(child, path+'/description')
      else if (child.localName = 'preConditions') then
        value.preConditionsElement := ParseMarkdown(child, path+'/preConditions')
      else if (child.localName = 'postConditions') then
        value.postConditionsElement := ParseMarkdown(child, path+'/postConditions')
      else if (child.localName = 'step') then
        value.stepList.Add(ParseExampleScenarioProcessStep(child, path+'/step'))
      else if Not ParseBackboneElementChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeExampleScenarioProcess(xml : TXmlBuilder; name : String; value : TFhirExampleScenarioProcess);
begin
  if (value = nil) then
    exit;
  composeElementAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeExampleScenarioProcessChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeExampleScenarioProcessChildren(xml : TXmlBuilder; value : TFhirExampleScenarioProcess);
var
  i : integer;
begin
  composeBackboneElementChildren(xml, value);
  ComposeString(xml, 'title', value.titleElement);
  if (SummaryOption in [soFull, soData]) then
    ComposeMarkdown(xml, 'description', value.descriptionElement);
  if (SummaryOption in [soFull, soData]) then
    ComposeMarkdown(xml, 'preConditions', value.preConditionsElement);
  if (SummaryOption in [soFull, soData]) then
    ComposeMarkdown(xml, 'postConditions', value.postConditionsElement);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.stepList.Count - 1 do
      ComposeExampleScenarioProcessStep(xml, 'step', value.stepList[i]);
end;

function TFHIRXmlParser.ParseExampleScenarioProcessStep(element : TMXmlElement; path : string) : TFhirExampleScenarioProcessStep;
var
  child : TMXmlElement;
begin
  result := TFhirExampleScenarioProcessStep.Create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseExampleScenarioProcessStepChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseExampleScenarioProcessStepChild(value : TFhirExampleScenarioProcessStep; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'number') then
        value.numberElement := ParseString(child, path+'/number')
      else if (child.localName = 'process') then
        value.process := ParseExampleScenarioProcess(child, path+'/process')
      else if (child.localName = 'workflow') then
        value.workflowElement := ParseCanonical(child, path+'/workflow')
      else if (child.localName = 'operation') then
        value.operation := ParseExampleScenarioProcessStepOperation(child, path+'/operation')
      else if (child.localName = 'alternative') then
        value.alternativeList.Add(ParseExampleScenarioProcessStepAlternative(child, path+'/alternative'))
      else if (child.localName = 'pause') then
        value.pauseElement := ParseBoolean(child, path+'/pause')
      else if Not ParseBackboneElementChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeExampleScenarioProcessStep(xml : TXmlBuilder; name : String; value : TFhirExampleScenarioProcessStep);
begin
  if (value = nil) then
    exit;
  composeElementAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeExampleScenarioProcessStepChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeExampleScenarioProcessStepChildren(xml : TXmlBuilder; value : TFhirExampleScenarioProcessStep);
var
  i : integer;
begin
  composeBackboneElementChildren(xml, value);
  if (SummaryOption in [soFull, soData]) then
    ComposeString(xml, 'number', value.numberElement);
  if (SummaryOption in [soFull, soData]) then
    ComposeExampleScenarioProcess(xml, 'process', value.process);
  if (SummaryOption in [soFull, soData]) then
    ComposeCanonical(xml, 'workflow', value.workflowElement);
  if (SummaryOption in [soFull, soData]) then
    ComposeExampleScenarioProcessStepOperation(xml, 'operation', value.operation);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.alternativeList.Count - 1 do
      ComposeExampleScenarioProcessStepAlternative(xml, 'alternative', value.alternativeList[i]);
  if (SummaryOption in [soFull, soData]) then
    ComposeBoolean(xml, 'pause', value.pauseElement);
end;

function TFHIRXmlParser.ParseExampleScenarioProcessStepOperation(element : TMXmlElement; path : string) : TFhirExampleScenarioProcessStepOperation;
var
  child : TMXmlElement;
begin
  result := TFhirExampleScenarioProcessStepOperation.Create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseExampleScenarioProcessStepOperationChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseExampleScenarioProcessStepOperationChild(value : TFhirExampleScenarioProcessStepOperation; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'type') then
        value.type_ := ParseCoding(child, path+'/type')
      else if (child.localName = 'title') then
        value.titleElement := ParseString(child, path+'/title')
      else if (child.localName = 'initiator') then
        value.initiatorElement := ParseString(child, path+'/initiator')
      else if (child.localName = 'receiver') then
        value.receiverElement := ParseString(child, path+'/receiver')
      else if (child.localName = 'description') then
        value.descriptionElement := ParseMarkdown(child, path+'/description')
      else if (child.localName = 'initiatorActive') then
        value.initiatorActiveElement := ParseBoolean(child, path+'/initiatorActive')
      else if (child.localName = 'receiverActive') then
        value.receiverActiveElement := ParseBoolean(child, path+'/receiverActive')
      else if (child.localName = 'request') then
        value.request := ParseExampleScenarioInstanceContainedInstance(child, path+'/request')
      else if (child.localName = 'response') then
        value.response := ParseExampleScenarioInstanceContainedInstance(child, path+'/response')
      else if Not ParseBackboneElementChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeExampleScenarioProcessStepOperation(xml : TXmlBuilder; name : String; value : TFhirExampleScenarioProcessStepOperation);
begin
  if (value = nil) then
    exit;
  composeElementAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeExampleScenarioProcessStepOperationChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeExampleScenarioProcessStepOperationChildren(xml : TXmlBuilder; value : TFhirExampleScenarioProcessStepOperation);
begin
  composeBackboneElementChildren(xml, value);
  if (SummaryOption in [soFull, soData]) then
    ComposeCoding(xml, 'type', value.type_);
  ComposeString(xml, 'title', value.titleElement);
  if (SummaryOption in [soFull, soData]) then
    ComposeString(xml, 'initiator', value.initiatorElement);
  if (SummaryOption in [soFull, soData]) then
    ComposeString(xml, 'receiver', value.receiverElement);
  if (SummaryOption in [soFull, soData]) then
    ComposeMarkdown(xml, 'description', value.descriptionElement);
  if (SummaryOption in [soFull, soData]) then
    ComposeBoolean(xml, 'initiatorActive', value.initiatorActiveElement);
  if (SummaryOption in [soFull, soData]) then
    ComposeBoolean(xml, 'receiverActive', value.receiverActiveElement);
  if (SummaryOption in [soFull, soData]) then
    ComposeExampleScenarioInstanceContainedInstance(xml, 'request', value.request);
  if (SummaryOption in [soFull, soData]) then
    ComposeExampleScenarioInstanceContainedInstance(xml, 'response', value.response);
end;

function TFHIRXmlParser.ParseExampleScenarioProcessStepAlternative(element : TMXmlElement; path : string) : TFhirExampleScenarioProcessStepAlternative;
var
  child : TMXmlElement;
begin
  result := TFhirExampleScenarioProcessStepAlternative.Create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseExampleScenarioProcessStepAlternativeChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseExampleScenarioProcessStepAlternativeChild(value : TFhirExampleScenarioProcessStepAlternative; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'title') then
        value.titleElement := ParseString(child, path+'/title')
      else if (child.localName = 'description') then
        value.descriptionElement := ParseMarkdown(child, path+'/description')
      else if (child.localName = 'step') then
        value.stepList.Add(ParseExampleScenarioProcessStep(child, path+'/step'))
      else if Not ParseBackboneElementChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeExampleScenarioProcessStepAlternative(xml : TXmlBuilder; name : String; value : TFhirExampleScenarioProcessStepAlternative);
begin
  if (value = nil) then
    exit;
  composeElementAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeExampleScenarioProcessStepAlternativeChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeExampleScenarioProcessStepAlternativeChildren(xml : TXmlBuilder; value : TFhirExampleScenarioProcessStepAlternative);
var
  i : integer;
begin
  composeBackboneElementChildren(xml, value);
  ComposeString(xml, 'title', value.titleElement);
  if (SummaryOption in [soFull, soData]) then
    ComposeMarkdown(xml, 'description', value.descriptionElement);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.stepList.Count - 1 do
      ComposeExampleScenarioProcessStep(xml, 'step', value.stepList[i]);
end;

function TFHIRXmlParser.ParseExampleScenario(element : TMXmlElement; path : string) : TFhirExampleScenario;
var
  child : TMXmlElement;
begin
  result := TFhirExampleScenario.Create;
  try
    parseCanonicalResourceAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseExampleScenarioChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseExampleScenarioChild(value : TFhirExampleScenario; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'url') then
        value.urlElement := ParseUri(child, path+'/url')
      else if (child.localName = 'identifier') then
        value.identifierList.Add(ParseIdentifier(child, path+'/identifier'))
      else if (child.localName = 'version') then
        value.versionElement := ParseString(child, path+'/version')
      else if (child.localName = 'versionAlgorithmCoding') then
        value.versionAlgorithm := ParseCoding(child, path+'/versionAlgorithmCoding')
      else if (child.localName = 'versionAlgorithmString') then
        value.versionAlgorithm := ParseString(child, path+'/versionAlgorithmString')
      else if (child.localName = 'name') then
        value.nameElement := ParseString(child, path+'/name')
      else if (child.localName = 'title') then
        value.titleElement := ParseString(child, path+'/title')
      else if (child.localName = 'status') then
        value.statusElement := ParseEnum(CODES_TFhirPublicationStatusEnum, SYSTEMS_TFhirPublicationStatusEnum, child, path+'/status')
      else if (child.localName = 'experimental') then
        value.experimentalElement := ParseBoolean(child, path+'/experimental')
      else if (child.localName = 'date') then
        value.dateElement := ParseDateTime(child, path+'/date')
      else if (child.localName = 'publisher') then
        value.publisherElement := ParseString(child, path+'/publisher')
      else if (child.localName = 'contact') then
        value.contactList.Add(ParseContactDetail(child, path+'/contact'))
      else if (child.localName = 'description') then
        value.descriptionElement := ParseMarkdown(child, path+'/description')
      else if (child.localName = 'useContext') then
        value.useContextList.Add(ParseUsageContext(child, path+'/useContext'))
      else if (child.localName = 'jurisdiction') then
        value.jurisdictionList.Add(ParseCodeableConcept(child, path+'/jurisdiction'))
      else if (child.localName = 'purpose') then
        value.purposeElement := ParseMarkdown(child, path+'/purpose')
      else if (child.localName = 'copyright') then
        value.copyrightElement := ParseMarkdown(child, path+'/copyright')
      else if (child.localName = 'copyrightLabel') then
        value.copyrightLabelElement := ParseString(child, path+'/copyrightLabel')
      else if (child.localName = 'actor') then
        value.actorList.Add(ParseExampleScenarioActor(child, path+'/actor'))
      else if (child.localName = 'instance') then
        value.instanceList.Add(ParseExampleScenarioInstance(child, path+'/instance'))
      else if (child.localName = 'process') then
        value.processList.Add(ParseExampleScenarioProcess(child, path+'/process'))
      else if Not ParseCanonicalResourceChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeExampleScenario(xml : TXmlBuilder; name : String; value : TFhirExampleScenario);
begin
  if (value = nil) then
    exit;
  composeCanonicalResourceAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeExampleScenarioChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeExampleScenarioChildren(xml : TXmlBuilder; value : TFhirExampleScenario);
var
  i : integer;
begin
  composeCanonicalResourceChildren(xml, value);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeUri(xml, 'url', value.urlElement);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.identifierList.Count - 1 do
      ComposeIdentifier(xml, 'identifier', value.identifierList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(xml, 'version', value.versionElement);
  if (SummaryOption in [soFull, soSummary, soData]) and (value.versionAlgorithm is TFhirCoding) {6} then
    ComposeCoding(xml, 'versionAlgorithmCoding', TFhirCoding(value.versionAlgorithm))
  else if (SummaryOption in [soFull, soSummary, soData]) and (value.versionAlgorithm is TFhirString) {6} then
    ComposeString(xml, 'versionAlgorithmString', TFhirString(value.versionAlgorithm));
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(xml, 'name', value.nameElement);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(xml, 'title', value.titleElement);
  ComposeEnum(xml, 'status', value.statusElement, CODES_TFhirPublicationStatusEnum);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeBoolean(xml, 'experimental', value.experimentalElement);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDateTime(xml, 'date', value.dateElement);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(xml, 'publisher', value.publisherElement);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.contactList.Count - 1 do
      ComposeContactDetail(xml, 'contact', value.contactList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeMarkdown(xml, 'description', value.descriptionElement);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.useContextList.Count - 1 do
      ComposeUsageContext(xml, 'useContext', value.useContextList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.jurisdictionList.Count - 1 do
      ComposeCodeableConcept(xml, 'jurisdiction', value.jurisdictionList[i]);
  if (SummaryOption in [soFull, soData]) then
    ComposeMarkdown(xml, 'purpose', value.purposeElement);
  if (SummaryOption in [soFull, soData]) then
    ComposeMarkdown(xml, 'copyright', value.copyrightElement);
  if (SummaryOption in [soFull, soData]) then
    ComposeString(xml, 'copyrightLabel', value.copyrightLabelElement);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.actorList.Count - 1 do
      ComposeExampleScenarioActor(xml, 'actor', value.actorList[i]);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.instanceList.Count - 1 do
      ComposeExampleScenarioInstance(xml, 'instance', value.instanceList[i]);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.processList.Count - 1 do
      ComposeExampleScenarioProcess(xml, 'process', value.processList[i]);
end;

{$ENDIF FHIR_EXAMPLESCENARIO}
{$IFDEF FHIR_EXPLANATIONOFBENEFIT}
function TFHIRXmlParser.ParseExplanationOfBenefitRelated(element : TMXmlElement; path : string) : TFhirExplanationOfBenefitRelated;
var
  child : TMXmlElement;
begin
  result := TFhirExplanationOfBenefitRelated.Create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseExplanationOfBenefitRelatedChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseExplanationOfBenefitRelatedChild(value : TFhirExplanationOfBenefitRelated; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'claim') then
        value.claim := ParseReference(child, path+'/claim')
      else if (child.localName = 'relationship') then
        value.relationship := ParseCodeableConcept(child, path+'/relationship')
      else if (child.localName = 'reference') then
        value.reference := ParseIdentifier(child, path+'/reference')
      else if Not ParseBackboneElementChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeExplanationOfBenefitRelated(xml : TXmlBuilder; name : String; value : TFhirExplanationOfBenefitRelated);
begin
  if (value = nil) then
    exit;
  composeElementAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeExplanationOfBenefitRelatedChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeExplanationOfBenefitRelatedChildren(xml : TXmlBuilder; value : TFhirExplanationOfBenefitRelated);
begin
  composeBackboneElementChildren(xml, value);
  if (SummaryOption in [soFull, soData]) then
    ComposeReference(xml, 'claim', value.claim);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(xml, 'relationship', value.relationship);
  if (SummaryOption in [soFull, soData]) then
    ComposeIdentifier(xml, 'reference', value.reference);
end;

function TFHIRXmlParser.ParseExplanationOfBenefitPayee(element : TMXmlElement; path : string) : TFhirExplanationOfBenefitPayee;
var
  child : TMXmlElement;
begin
  result := TFhirExplanationOfBenefitPayee.Create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseExplanationOfBenefitPayeeChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseExplanationOfBenefitPayeeChild(value : TFhirExplanationOfBenefitPayee; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'type') then
        value.type_ := ParseCodeableConcept(child, path+'/type')
      else if (child.localName = 'party') then
        value.party := ParseReference(child, path+'/party')
      else if Not ParseBackboneElementChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeExplanationOfBenefitPayee(xml : TXmlBuilder; name : String; value : TFhirExplanationOfBenefitPayee);
begin
  if (value = nil) then
    exit;
  composeElementAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeExplanationOfBenefitPayeeChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeExplanationOfBenefitPayeeChildren(xml : TXmlBuilder; value : TFhirExplanationOfBenefitPayee);
begin
  composeBackboneElementChildren(xml, value);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(xml, 'type', value.type_);
  if (SummaryOption in [soFull, soData]) then
    ComposeReference(xml, 'party', value.party);
end;

function TFHIRXmlParser.ParseExplanationOfBenefitCareTeam(element : TMXmlElement; path : string) : TFhirExplanationOfBenefitCareTeam;
var
  child : TMXmlElement;
begin
  result := TFhirExplanationOfBenefitCareTeam.Create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseExplanationOfBenefitCareTeamChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseExplanationOfBenefitCareTeamChild(value : TFhirExplanationOfBenefitCareTeam; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'sequence') then
        value.sequenceElement := ParsePositiveInt(child, path+'/sequence')
      else if (child.localName = 'provider') then
        value.provider := ParseReference(child, path+'/provider')
      else if (child.localName = 'responsible') then
        value.responsibleElement := ParseBoolean(child, path+'/responsible')
      else if (child.localName = 'role') then
        value.role := ParseCodeableConcept(child, path+'/role')
      else if (child.localName = 'specialty') then
        value.specialty := ParseCodeableConcept(child, path+'/specialty')
      else if Not ParseBackboneElementChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeExplanationOfBenefitCareTeam(xml : TXmlBuilder; name : String; value : TFhirExplanationOfBenefitCareTeam);
begin
  if (value = nil) then
    exit;
  composeElementAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeExplanationOfBenefitCareTeamChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeExplanationOfBenefitCareTeamChildren(xml : TXmlBuilder; value : TFhirExplanationOfBenefitCareTeam);
begin
  composeBackboneElementChildren(xml, value);
  ComposePositiveInt(xml, 'sequence', value.sequenceElement);
  ComposeReference(xml, 'provider', value.provider);
  if (SummaryOption in [soFull, soData]) then
    ComposeBoolean(xml, 'responsible', value.responsibleElement);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(xml, 'role', value.role);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(xml, 'specialty', value.specialty);
end;

function TFHIRXmlParser.ParseExplanationOfBenefitSupportingInfo(element : TMXmlElement; path : string) : TFhirExplanationOfBenefitSupportingInfo;
var
  child : TMXmlElement;
begin
  result := TFhirExplanationOfBenefitSupportingInfo.Create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseExplanationOfBenefitSupportingInfoChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseExplanationOfBenefitSupportingInfoChild(value : TFhirExplanationOfBenefitSupportingInfo; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'sequence') then
        value.sequenceElement := ParsePositiveInt(child, path+'/sequence')
      else if (child.localName = 'category') then
        value.category := ParseCodeableConcept(child, path+'/category')
      else if (child.localName = 'code') then
        value.code := ParseCodeableConcept(child, path+'/code')
      else if (child.localName = 'timingPeriod') then
        value.timing := ParsePeriod(child, path+'/timingPeriod')
      else if (child.localName = 'timingDate') then
        value.timing := ParseDate(child, path+'/timingDate')
      else if (child.localName = 'valueQuantity') then
        value.value := ParseQuantity(child, path+'/valueQuantity')
      else if (child.localName = 'valueAttachment') then
        value.value := ParseAttachment(child, path+'/valueAttachment')
      else if (child.localName = 'valueReference') then
        value.value := ParseReference(child, path+'/valueReference')
      else if (child.localName = 'valueIdentifier') then
        value.value := ParseIdentifier(child, path+'/valueIdentifier')
      else if (child.localName = 'valueBoolean') then
        value.value := ParseBoolean(child, path+'/valueBoolean')
      else if (child.localName = 'valueString') then
        value.value := ParseString(child, path+'/valueString')
      else if (child.localName = 'reason') then
        value.reason := ParseCoding(child, path+'/reason')
      else if Not ParseBackboneElementChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeExplanationOfBenefitSupportingInfo(xml : TXmlBuilder; name : String; value : TFhirExplanationOfBenefitSupportingInfo);
begin
  if (value = nil) then
    exit;
  composeElementAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeExplanationOfBenefitSupportingInfoChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeExplanationOfBenefitSupportingInfoChildren(xml : TXmlBuilder; value : TFhirExplanationOfBenefitSupportingInfo);
begin
  composeBackboneElementChildren(xml, value);
  ComposePositiveInt(xml, 'sequence', value.sequenceElement);
  ComposeCodeableConcept(xml, 'category', value.category);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(xml, 'code', value.code);
  if (SummaryOption in [soFull, soData]) and (value.timing is TFhirPeriod) {6} then
    ComposePeriod(xml, 'timingPeriod', TFhirPeriod(value.timing))
  else if (SummaryOption in [soFull, soData]) and (value.timing is TFhirDate) {6} then
    ComposeDate(xml, 'timingDate', TFhirDate(value.timing));
  if (SummaryOption in [soFull, soData]) and (value.value is TFhirQuantity) {6} then
    ComposeQuantity(xml, 'valueQuantity', TFhirQuantity(value.value))
  else if (SummaryOption in [soFull, soData]) and (value.value is TFhirAttachment) {6} then
    ComposeAttachment(xml, 'valueAttachment', TFhirAttachment(value.value))
  else if (SummaryOption in [soFull, soData]) and (value.value is TFhirReference) {2} then
    ComposeReference(xml, 'valueReference', TFhirReference(value.value))
  else if (SummaryOption in [soFull, soData]) and (value.value is TFhirIdentifier) {6} then
    ComposeIdentifier(xml, 'valueIdentifier', TFhirIdentifier(value.value))
  else if (SummaryOption in [soFull, soData]) and (value.value is TFhirBoolean) {6} then
    ComposeBoolean(xml, 'valueBoolean', TFhirBoolean(value.value))
  else if (SummaryOption in [soFull, soData]) and (value.value is TFhirString) {6} then
    ComposeString(xml, 'valueString', TFhirString(value.value));
  if (SummaryOption in [soFull, soData]) then
    ComposeCoding(xml, 'reason', value.reason);
end;

function TFHIRXmlParser.ParseExplanationOfBenefitDiagnosis(element : TMXmlElement; path : string) : TFhirExplanationOfBenefitDiagnosis;
var
  child : TMXmlElement;
begin
  result := TFhirExplanationOfBenefitDiagnosis.Create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseExplanationOfBenefitDiagnosisChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseExplanationOfBenefitDiagnosisChild(value : TFhirExplanationOfBenefitDiagnosis; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'sequence') then
        value.sequenceElement := ParsePositiveInt(child, path+'/sequence')
      else if (child.localName = 'diagnosisCodeableConcept') then
        value.diagnosis := ParseCodeableConcept(child, path+'/diagnosisCodeableConcept')
      else if (child.localName = 'diagnosisReference') then
        value.diagnosis := ParseReference(child, path+'/diagnosisReference')
      else if (child.localName = 'type') then
        value.type_List.Add(ParseCodeableConcept(child, path+'/type'))
      else if (child.localName = 'onAdmission') then
        value.onAdmission := ParseCodeableConcept(child, path+'/onAdmission')
      else if Not ParseBackboneElementChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeExplanationOfBenefitDiagnosis(xml : TXmlBuilder; name : String; value : TFhirExplanationOfBenefitDiagnosis);
begin
  if (value = nil) then
    exit;
  composeElementAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeExplanationOfBenefitDiagnosisChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeExplanationOfBenefitDiagnosisChildren(xml : TXmlBuilder; value : TFhirExplanationOfBenefitDiagnosis);
var
  i : integer;
begin
  composeBackboneElementChildren(xml, value);
  ComposePositiveInt(xml, 'sequence', value.sequenceElement);
  if (value.diagnosis is TFhirCodeableConcept) {6} then
    ComposeCodeableConcept(xml, 'diagnosisCodeableConcept', TFhirCodeableConcept(value.diagnosis))
  else if (value.diagnosis is TFhirReference) {2} then
    ComposeReference(xml, 'diagnosisReference', TFhirReference(value.diagnosis));
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.type_List.Count - 1 do
      ComposeCodeableConcept(xml, 'type', value.type_List[i]);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(xml, 'onAdmission', value.onAdmission);
end;

function TFHIRXmlParser.ParseExplanationOfBenefitProcedure(element : TMXmlElement; path : string) : TFhirExplanationOfBenefitProcedure;
var
  child : TMXmlElement;
begin
  result := TFhirExplanationOfBenefitProcedure.Create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseExplanationOfBenefitProcedureChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseExplanationOfBenefitProcedureChild(value : TFhirExplanationOfBenefitProcedure; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'sequence') then
        value.sequenceElement := ParsePositiveInt(child, path+'/sequence')
      else if (child.localName = 'type') then
        value.type_List.Add(ParseCodeableConcept(child, path+'/type'))
      else if (child.localName = 'date') then
        value.dateElement := ParseDateTime(child, path+'/date')
      else if (child.localName = 'procedureCodeableConcept') then
        value.procedure_ := ParseCodeableConcept(child, path+'/procedureCodeableConcept')
      else if (child.localName = 'procedureReference') then
        value.procedure_ := ParseReference(child, path+'/procedureReference')
      else if (child.localName = 'udi') then
        value.udiList.Add(ParseReference(child, path+'/udi'))
      else if Not ParseBackboneElementChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeExplanationOfBenefitProcedure(xml : TXmlBuilder; name : String; value : TFhirExplanationOfBenefitProcedure);
begin
  if (value = nil) then
    exit;
  composeElementAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeExplanationOfBenefitProcedureChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeExplanationOfBenefitProcedureChildren(xml : TXmlBuilder; value : TFhirExplanationOfBenefitProcedure);
var
  i : integer;
begin
  composeBackboneElementChildren(xml, value);
  ComposePositiveInt(xml, 'sequence', value.sequenceElement);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.type_List.Count - 1 do
      ComposeCodeableConcept(xml, 'type', value.type_List[i]);
  if (SummaryOption in [soFull, soData]) then
    ComposeDateTime(xml, 'date', value.dateElement);
  if (value.procedure_ is TFhirCodeableConcept) {6} then
    ComposeCodeableConcept(xml, 'procedureCodeableConcept', TFhirCodeableConcept(value.procedure_))
  else if (value.procedure_ is TFhirReference) {2} then
    ComposeReference(xml, 'procedureReference', TFhirReference(value.procedure_));
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.udiList.Count - 1 do
      ComposeReference(xml, 'udi', value.udiList[i]);
end;

function TFHIRXmlParser.ParseExplanationOfBenefitInsurance(element : TMXmlElement; path : string) : TFhirExplanationOfBenefitInsurance;
var
  child : TMXmlElement;
begin
  result := TFhirExplanationOfBenefitInsurance.Create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseExplanationOfBenefitInsuranceChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseExplanationOfBenefitInsuranceChild(value : TFhirExplanationOfBenefitInsurance; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'focal') then
        value.focalElement := ParseBoolean(child, path+'/focal')
      else if (child.localName = 'coverage') then
        value.coverage := ParseReference(child, path+'/coverage')
      else if (child.localName = 'preAuthRef') then
        value.preAuthRefList.Add(ParseString(child, path+'/preAuthRef'))
      else if Not ParseBackboneElementChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeExplanationOfBenefitInsurance(xml : TXmlBuilder; name : String; value : TFhirExplanationOfBenefitInsurance);
begin
  if (value = nil) then
    exit;
  composeElementAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeExplanationOfBenefitInsuranceChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeExplanationOfBenefitInsuranceChildren(xml : TXmlBuilder; value : TFhirExplanationOfBenefitInsurance);
var
  i : integer;
begin
  composeBackboneElementChildren(xml, value);
  ComposeBoolean(xml, 'focal', value.focalElement);
  ComposeReference(xml, 'coverage', value.coverage);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.preAuthRefList.Count - 1 do
      ComposeString(xml, 'preAuthRef', value.preAuthRefList[i]);
end;

function TFHIRXmlParser.ParseExplanationOfBenefitAccident(element : TMXmlElement; path : string) : TFhirExplanationOfBenefitAccident;
var
  child : TMXmlElement;
begin
  result := TFhirExplanationOfBenefitAccident.Create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseExplanationOfBenefitAccidentChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseExplanationOfBenefitAccidentChild(value : TFhirExplanationOfBenefitAccident; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'date') then
        value.dateElement := ParseDate(child, path+'/date')
      else if (child.localName = 'type') then
        value.type_ := ParseCodeableConcept(child, path+'/type')
      else if (child.localName = 'locationAddress') then
        value.location := ParseAddress(child, path+'/locationAddress')
      else if (child.localName = 'locationReference') then
        value.location := ParseReference(child, path+'/locationReference')
      else if Not ParseBackboneElementChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeExplanationOfBenefitAccident(xml : TXmlBuilder; name : String; value : TFhirExplanationOfBenefitAccident);
begin
  if (value = nil) then
    exit;
  composeElementAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeExplanationOfBenefitAccidentChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeExplanationOfBenefitAccidentChildren(xml : TXmlBuilder; value : TFhirExplanationOfBenefitAccident);
begin
  composeBackboneElementChildren(xml, value);
  if (SummaryOption in [soFull, soData]) then
    ComposeDate(xml, 'date', value.dateElement);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(xml, 'type', value.type_);
  if (SummaryOption in [soFull, soData]) and (value.location is TFhirAddress) {6} then
    ComposeAddress(xml, 'locationAddress', TFhirAddress(value.location))
  else if (SummaryOption in [soFull, soData]) and (value.location is TFhirReference) {2} then
    ComposeReference(xml, 'locationReference', TFhirReference(value.location));
end;

function TFHIRXmlParser.ParseExplanationOfBenefitItem(element : TMXmlElement; path : string) : TFhirExplanationOfBenefitItem;
var
  child : TMXmlElement;
begin
  result := TFhirExplanationOfBenefitItem.Create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseExplanationOfBenefitItemChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseExplanationOfBenefitItemChild(value : TFhirExplanationOfBenefitItem; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'sequence') then
        value.sequenceElement := ParsePositiveInt(child, path+'/sequence')
      else if (child.localName = 'careTeamSequence') then
        value.careTeamSequenceList.Add(ParsePositiveInt(child, path+'/careTeamSequence'))
      else if (child.localName = 'diagnosisSequence') then
        value.diagnosisSequenceList.Add(ParsePositiveInt(child, path+'/diagnosisSequence'))
      else if (child.localName = 'procedureSequence') then
        value.procedureSequenceList.Add(ParsePositiveInt(child, path+'/procedureSequence'))
      else if (child.localName = 'informationSequence') then
        value.informationSequenceList.Add(ParsePositiveInt(child, path+'/informationSequence'))
      else if (child.localName = 'revenue') then
        value.revenue := ParseCodeableConcept(child, path+'/revenue')
      else if (child.localName = 'category') then
        value.category := ParseCodeableConcept(child, path+'/category')
      else if (child.localName = 'productOrService') then
        value.productOrService := ParseCodeableConcept(child, path+'/productOrService')
      else if (child.localName = 'productOrServiceEnd') then
        value.productOrServiceEnd := ParseCodeableConcept(child, path+'/productOrServiceEnd')
      else if (child.localName = 'modifier') then
        value.modifierList.Add(ParseCodeableConcept(child, path+'/modifier'))
      else if (child.localName = 'programCode') then
        value.programCodeList.Add(ParseCodeableConcept(child, path+'/programCode'))
      else if (child.localName = 'servicedPeriod') then
        value.serviced := ParsePeriod(child, path+'/servicedPeriod')
      else if (child.localName = 'servicedDate') then
        value.serviced := ParseDate(child, path+'/servicedDate')
      else if (child.localName = 'locationCodeableConcept') then
        value.location := ParseCodeableConcept(child, path+'/locationCodeableConcept')
      else if (child.localName = 'locationAddress') then
        value.location := ParseAddress(child, path+'/locationAddress')
      else if (child.localName = 'locationReference') then
        value.location := ParseReference(child, path+'/locationReference')
      else if (child.localName = 'patientPaid') then
        value.patientPaid := ParseMoney(child, path+'/patientPaid')
      else if (child.localName = 'quantity') then
        value.quantity := ParseQuantity(child, path+'/quantity')
      else if (child.localName = 'unitPrice') then
        value.unitPrice := ParseMoney(child, path+'/unitPrice')
      else if (child.localName = 'factor') then
        value.factorElement := ParseDecimal(child, path+'/factor')
      else if (child.localName = 'tax') then
        value.tax := ParseMoney(child, path+'/tax')
      else if (child.localName = 'net') then
        value.net := ParseMoney(child, path+'/net')
      else if (child.localName = 'udi') then
        value.udiList.Add(ParseReference(child, path+'/udi'))
      else if (child.localName = 'bodySite') then
        value.bodySiteList.Add(ParseExplanationOfBenefitItemBodySite(child, path+'/bodySite'))
      else if (child.localName = 'encounter') then
        value.encounterList.Add(ParseReference(child, path+'/encounter'))
      else if (child.localName = 'noteNumber') then
        value.noteNumberList.Add(ParsePositiveInt(child, path+'/noteNumber'))
      else if (child.localName = 'decision') then
        value.decision := ParseCodeableConcept(child, path+'/decision')
      else if (child.localName = 'adjudication') then
        value.adjudicationList.Add(ParseExplanationOfBenefitItemAdjudication(child, path+'/adjudication'))
      else if (child.localName = 'detail') then
        value.detailList.Add(ParseExplanationOfBenefitItemDetail(child, path+'/detail'))
      else if Not ParseBackboneElementChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeExplanationOfBenefitItem(xml : TXmlBuilder; name : String; value : TFhirExplanationOfBenefitItem);
begin
  if (value = nil) then
    exit;
  composeElementAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeExplanationOfBenefitItemChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeExplanationOfBenefitItemChildren(xml : TXmlBuilder; value : TFhirExplanationOfBenefitItem);
var
  i : integer;
begin
  composeBackboneElementChildren(xml, value);
  ComposePositiveInt(xml, 'sequence', value.sequenceElement);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.careTeamSequenceList.Count - 1 do
      ComposePositiveInt(xml, 'careTeamSequence', value.careTeamSequenceList[i]);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.diagnosisSequenceList.Count - 1 do
      ComposePositiveInt(xml, 'diagnosisSequence', value.diagnosisSequenceList[i]);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.procedureSequenceList.Count - 1 do
      ComposePositiveInt(xml, 'procedureSequence', value.procedureSequenceList[i]);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.informationSequenceList.Count - 1 do
      ComposePositiveInt(xml, 'informationSequence', value.informationSequenceList[i]);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(xml, 'revenue', value.revenue);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(xml, 'category', value.category);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(xml, 'productOrService', value.productOrService);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(xml, 'productOrServiceEnd', value.productOrServiceEnd);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.modifierList.Count - 1 do
      ComposeCodeableConcept(xml, 'modifier', value.modifierList[i]);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.programCodeList.Count - 1 do
      ComposeCodeableConcept(xml, 'programCode', value.programCodeList[i]);
  if (SummaryOption in [soFull, soData]) and (value.serviced is TFhirPeriod) {6} then
    ComposePeriod(xml, 'servicedPeriod', TFhirPeriod(value.serviced))
  else if (SummaryOption in [soFull, soData]) and (value.serviced is TFhirDate) {6} then
    ComposeDate(xml, 'servicedDate', TFhirDate(value.serviced));
  if (SummaryOption in [soFull, soData]) and (value.location is TFhirCodeableConcept) {6} then
    ComposeCodeableConcept(xml, 'locationCodeableConcept', TFhirCodeableConcept(value.location))
  else if (SummaryOption in [soFull, soData]) and (value.location is TFhirAddress) {6} then
    ComposeAddress(xml, 'locationAddress', TFhirAddress(value.location))
  else if (SummaryOption in [soFull, soData]) and (value.location is TFhirReference) {2} then
    ComposeReference(xml, 'locationReference', TFhirReference(value.location));
  if (SummaryOption in [soFull, soData]) then
    ComposeMoney(xml, 'patientPaid', value.patientPaid);
  if (SummaryOption in [soFull, soData]) then
    ComposeQuantity(xml, 'quantity', value.quantity);
  if (SummaryOption in [soFull, soData]) then
    ComposeMoney(xml, 'unitPrice', value.unitPrice);
  if (SummaryOption in [soFull, soData]) then
    ComposeDecimal(xml, 'factor', value.factorElement);
  if (SummaryOption in [soFull, soData]) then
    ComposeMoney(xml, 'tax', value.tax);
  if (SummaryOption in [soFull, soData]) then
    ComposeMoney(xml, 'net', value.net);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.udiList.Count - 1 do
      ComposeReference(xml, 'udi', value.udiList[i]);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.bodySiteList.Count - 1 do
      ComposeExplanationOfBenefitItemBodySite(xml, 'bodySite', value.bodySiteList[i]);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.encounterList.Count - 1 do
      ComposeReference(xml, 'encounter', value.encounterList[i]);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.noteNumberList.Count - 1 do
      ComposePositiveInt(xml, 'noteNumber', value.noteNumberList[i]);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(xml, 'decision', value.decision);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.adjudicationList.Count - 1 do
      ComposeExplanationOfBenefitItemAdjudication(xml, 'adjudication', value.adjudicationList[i]);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.detailList.Count - 1 do
      ComposeExplanationOfBenefitItemDetail(xml, 'detail', value.detailList[i]);
end;

function TFHIRXmlParser.ParseExplanationOfBenefitItemBodySite(element : TMXmlElement; path : string) : TFhirExplanationOfBenefitItemBodySite;
var
  child : TMXmlElement;
begin
  result := TFhirExplanationOfBenefitItemBodySite.Create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseExplanationOfBenefitItemBodySiteChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseExplanationOfBenefitItemBodySiteChild(value : TFhirExplanationOfBenefitItemBodySite; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'site') then
        value.siteList.Add(ParseCodeableReference(child, path+'/site'))
      else if (child.localName = 'subSite') then
        value.subSiteList.Add(ParseCodeableConcept(child, path+'/subSite'))
      else if Not ParseBackboneElementChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeExplanationOfBenefitItemBodySite(xml : TXmlBuilder; name : String; value : TFhirExplanationOfBenefitItemBodySite);
begin
  if (value = nil) then
    exit;
  composeElementAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeExplanationOfBenefitItemBodySiteChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeExplanationOfBenefitItemBodySiteChildren(xml : TXmlBuilder; value : TFhirExplanationOfBenefitItemBodySite);
var
  i : integer;
begin
  composeBackboneElementChildren(xml, value);
  for i := 0 to value.siteList.Count - 1 do
      ComposeCodeableReference(xml, 'site', value.siteList[i]);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.subSiteList.Count - 1 do
      ComposeCodeableConcept(xml, 'subSite', value.subSiteList[i]);
end;

function TFHIRXmlParser.ParseExplanationOfBenefitItemAdjudication(element : TMXmlElement; path : string) : TFhirExplanationOfBenefitItemAdjudication;
var
  child : TMXmlElement;
begin
  result := TFhirExplanationOfBenefitItemAdjudication.Create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseExplanationOfBenefitItemAdjudicationChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseExplanationOfBenefitItemAdjudicationChild(value : TFhirExplanationOfBenefitItemAdjudication; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'category') then
        value.category := ParseCodeableConcept(child, path+'/category')
      else if (child.localName = 'reason') then
        value.reason := ParseCodeableConcept(child, path+'/reason')
      else if (child.localName = 'amount') then
        value.amount := ParseMoney(child, path+'/amount')
      else if (child.localName = 'value') then
        value.valueElement := ParseDecimal(child, path+'/value')
      else if Not ParseBackboneElementChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeExplanationOfBenefitItemAdjudication(xml : TXmlBuilder; name : String; value : TFhirExplanationOfBenefitItemAdjudication);
begin
  if (value = nil) then
    exit;
  composeElementAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeExplanationOfBenefitItemAdjudicationChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeExplanationOfBenefitItemAdjudicationChildren(xml : TXmlBuilder; value : TFhirExplanationOfBenefitItemAdjudication);
begin
  composeBackboneElementChildren(xml, value);
  ComposeCodeableConcept(xml, 'category', value.category);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(xml, 'reason', value.reason);
  if (SummaryOption in [soFull, soData]) then
    ComposeMoney(xml, 'amount', value.amount);
  if (SummaryOption in [soFull, soData]) then
    ComposeDecimal(xml, 'value', value.valueElement);
end;

function TFHIRXmlParser.ParseExplanationOfBenefitItemDetail(element : TMXmlElement; path : string) : TFhirExplanationOfBenefitItemDetail;
var
  child : TMXmlElement;
begin
  result := TFhirExplanationOfBenefitItemDetail.Create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseExplanationOfBenefitItemDetailChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseExplanationOfBenefitItemDetailChild(value : TFhirExplanationOfBenefitItemDetail; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'sequence') then
        value.sequenceElement := ParsePositiveInt(child, path+'/sequence')
      else if (child.localName = 'revenue') then
        value.revenue := ParseCodeableConcept(child, path+'/revenue')
      else if (child.localName = 'category') then
        value.category := ParseCodeableConcept(child, path+'/category')
      else if (child.localName = 'productOrService') then
        value.productOrService := ParseCodeableConcept(child, path+'/productOrService')
      else if (child.localName = 'productOrServiceEnd') then
        value.productOrServiceEnd := ParseCodeableConcept(child, path+'/productOrServiceEnd')
      else if (child.localName = 'modifier') then
        value.modifierList.Add(ParseCodeableConcept(child, path+'/modifier'))
      else if (child.localName = 'programCode') then
        value.programCodeList.Add(ParseCodeableConcept(child, path+'/programCode'))
      else if (child.localName = 'patientPaid') then
        value.patientPaid := ParseMoney(child, path+'/patientPaid')
      else if (child.localName = 'quantity') then
        value.quantity := ParseQuantity(child, path+'/quantity')
      else if (child.localName = 'unitPrice') then
        value.unitPrice := ParseMoney(child, path+'/unitPrice')
      else if (child.localName = 'factor') then
        value.factorElement := ParseDecimal(child, path+'/factor')
      else if (child.localName = 'tax') then
        value.tax := ParseMoney(child, path+'/tax')
      else if (child.localName = 'net') then
        value.net := ParseMoney(child, path+'/net')
      else if (child.localName = 'udi') then
        value.udiList.Add(ParseReference(child, path+'/udi'))
      else if (child.localName = 'noteNumber') then
        value.noteNumberList.Add(ParsePositiveInt(child, path+'/noteNumber'))
      else if (child.localName = 'decision') then
        value.decision := ParseCodeableConcept(child, path+'/decision')
      else if (child.localName = 'adjudication') then
        value.adjudicationList.Add(ParseExplanationOfBenefitItemAdjudication(child, path+'/adjudication'))
      else if (child.localName = 'subDetail') then
        value.subDetailList.Add(ParseExplanationOfBenefitItemDetailSubDetail(child, path+'/subDetail'))
      else if Not ParseBackboneElementChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeExplanationOfBenefitItemDetail(xml : TXmlBuilder; name : String; value : TFhirExplanationOfBenefitItemDetail);
begin
  if (value = nil) then
    exit;
  composeElementAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeExplanationOfBenefitItemDetailChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeExplanationOfBenefitItemDetailChildren(xml : TXmlBuilder; value : TFhirExplanationOfBenefitItemDetail);
var
  i : integer;
begin
  composeBackboneElementChildren(xml, value);
  ComposePositiveInt(xml, 'sequence', value.sequenceElement);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(xml, 'revenue', value.revenue);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(xml, 'category', value.category);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(xml, 'productOrService', value.productOrService);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(xml, 'productOrServiceEnd', value.productOrServiceEnd);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.modifierList.Count - 1 do
      ComposeCodeableConcept(xml, 'modifier', value.modifierList[i]);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.programCodeList.Count - 1 do
      ComposeCodeableConcept(xml, 'programCode', value.programCodeList[i]);
  if (SummaryOption in [soFull, soData]) then
    ComposeMoney(xml, 'patientPaid', value.patientPaid);
  if (SummaryOption in [soFull, soData]) then
    ComposeQuantity(xml, 'quantity', value.quantity);
  if (SummaryOption in [soFull, soData]) then
    ComposeMoney(xml, 'unitPrice', value.unitPrice);
  if (SummaryOption in [soFull, soData]) then
    ComposeDecimal(xml, 'factor', value.factorElement);
  if (SummaryOption in [soFull, soData]) then
    ComposeMoney(xml, 'tax', value.tax);
  if (SummaryOption in [soFull, soData]) then
    ComposeMoney(xml, 'net', value.net);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.udiList.Count - 1 do
      ComposeReference(xml, 'udi', value.udiList[i]);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.noteNumberList.Count - 1 do
      ComposePositiveInt(xml, 'noteNumber', value.noteNumberList[i]);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(xml, 'decision', value.decision);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.adjudicationList.Count - 1 do
      ComposeExplanationOfBenefitItemAdjudication(xml, 'adjudication', value.adjudicationList[i]);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.subDetailList.Count - 1 do
      ComposeExplanationOfBenefitItemDetailSubDetail(xml, 'subDetail', value.subDetailList[i]);
end;

function TFHIRXmlParser.ParseExplanationOfBenefitItemDetailSubDetail(element : TMXmlElement; path : string) : TFhirExplanationOfBenefitItemDetailSubDetail;
var
  child : TMXmlElement;
begin
  result := TFhirExplanationOfBenefitItemDetailSubDetail.Create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseExplanationOfBenefitItemDetailSubDetailChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseExplanationOfBenefitItemDetailSubDetailChild(value : TFhirExplanationOfBenefitItemDetailSubDetail; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'sequence') then
        value.sequenceElement := ParsePositiveInt(child, path+'/sequence')
      else if (child.localName = 'revenue') then
        value.revenue := ParseCodeableConcept(child, path+'/revenue')
      else if (child.localName = 'category') then
        value.category := ParseCodeableConcept(child, path+'/category')
      else if (child.localName = 'productOrService') then
        value.productOrService := ParseCodeableConcept(child, path+'/productOrService')
      else if (child.localName = 'productOrServiceEnd') then
        value.productOrServiceEnd := ParseCodeableConcept(child, path+'/productOrServiceEnd')
      else if (child.localName = 'modifier') then
        value.modifierList.Add(ParseCodeableConcept(child, path+'/modifier'))
      else if (child.localName = 'programCode') then
        value.programCodeList.Add(ParseCodeableConcept(child, path+'/programCode'))
      else if (child.localName = 'patientPaid') then
        value.patientPaid := ParseMoney(child, path+'/patientPaid')
      else if (child.localName = 'quantity') then
        value.quantity := ParseQuantity(child, path+'/quantity')
      else if (child.localName = 'unitPrice') then
        value.unitPrice := ParseMoney(child, path+'/unitPrice')
      else if (child.localName = 'factor') then
        value.factorElement := ParseDecimal(child, path+'/factor')
      else if (child.localName = 'tax') then
        value.tax := ParseMoney(child, path+'/tax')
      else if (child.localName = 'net') then
        value.net := ParseMoney(child, path+'/net')
      else if (child.localName = 'udi') then
        value.udiList.Add(ParseReference(child, path+'/udi'))
      else if (child.localName = 'noteNumber') then
        value.noteNumberList.Add(ParsePositiveInt(child, path+'/noteNumber'))
      else if (child.localName = 'decision') then
        value.decision := ParseCodeableConcept(child, path+'/decision')
      else if (child.localName = 'adjudication') then
        value.adjudicationList.Add(ParseExplanationOfBenefitItemAdjudication(child, path+'/adjudication'))
      else if Not ParseBackboneElementChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeExplanationOfBenefitItemDetailSubDetail(xml : TXmlBuilder; name : String; value : TFhirExplanationOfBenefitItemDetailSubDetail);
begin
  if (value = nil) then
    exit;
  composeElementAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeExplanationOfBenefitItemDetailSubDetailChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeExplanationOfBenefitItemDetailSubDetailChildren(xml : TXmlBuilder; value : TFhirExplanationOfBenefitItemDetailSubDetail);
var
  i : integer;
begin
  composeBackboneElementChildren(xml, value);
  ComposePositiveInt(xml, 'sequence', value.sequenceElement);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(xml, 'revenue', value.revenue);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(xml, 'category', value.category);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(xml, 'productOrService', value.productOrService);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(xml, 'productOrServiceEnd', value.productOrServiceEnd);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.modifierList.Count - 1 do
      ComposeCodeableConcept(xml, 'modifier', value.modifierList[i]);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.programCodeList.Count - 1 do
      ComposeCodeableConcept(xml, 'programCode', value.programCodeList[i]);
  if (SummaryOption in [soFull, soData]) then
    ComposeMoney(xml, 'patientPaid', value.patientPaid);
  if (SummaryOption in [soFull, soData]) then
    ComposeQuantity(xml, 'quantity', value.quantity);
  if (SummaryOption in [soFull, soData]) then
    ComposeMoney(xml, 'unitPrice', value.unitPrice);
  if (SummaryOption in [soFull, soData]) then
    ComposeDecimal(xml, 'factor', value.factorElement);
  if (SummaryOption in [soFull, soData]) then
    ComposeMoney(xml, 'tax', value.tax);
  if (SummaryOption in [soFull, soData]) then
    ComposeMoney(xml, 'net', value.net);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.udiList.Count - 1 do
      ComposeReference(xml, 'udi', value.udiList[i]);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.noteNumberList.Count - 1 do
      ComposePositiveInt(xml, 'noteNumber', value.noteNumberList[i]);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(xml, 'decision', value.decision);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.adjudicationList.Count - 1 do
      ComposeExplanationOfBenefitItemAdjudication(xml, 'adjudication', value.adjudicationList[i]);
end;

function TFHIRXmlParser.ParseExplanationOfBenefitAddItem(element : TMXmlElement; path : string) : TFhirExplanationOfBenefitAddItem;
var
  child : TMXmlElement;
begin
  result := TFhirExplanationOfBenefitAddItem.Create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseExplanationOfBenefitAddItemChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseExplanationOfBenefitAddItemChild(value : TFhirExplanationOfBenefitAddItem; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'itemSequence') then
        value.itemSequenceList.Add(ParsePositiveInt(child, path+'/itemSequence'))
      else if (child.localName = 'detailSequence') then
        value.detailSequenceList.Add(ParsePositiveInt(child, path+'/detailSequence'))
      else if (child.localName = 'subDetailSequence') then
        value.subDetailSequenceList.Add(ParsePositiveInt(child, path+'/subDetailSequence'))
      else if (child.localName = 'provider') then
        value.providerList.Add(ParseReference(child, path+'/provider'))
      else if (child.localName = 'revenue') then
        value.revenue := ParseCodeableConcept(child, path+'/revenue')
      else if (child.localName = 'productOrService') then
        value.productOrService := ParseCodeableConcept(child, path+'/productOrService')
      else if (child.localName = 'productOrServiceEnd') then
        value.productOrServiceEnd := ParseCodeableConcept(child, path+'/productOrServiceEnd')
      else if (child.localName = 'modifier') then
        value.modifierList.Add(ParseCodeableConcept(child, path+'/modifier'))
      else if (child.localName = 'programCode') then
        value.programCodeList.Add(ParseCodeableConcept(child, path+'/programCode'))
      else if (child.localName = 'servicedPeriod') then
        value.serviced := ParsePeriod(child, path+'/servicedPeriod')
      else if (child.localName = 'servicedDate') then
        value.serviced := ParseDate(child, path+'/servicedDate')
      else if (child.localName = 'locationCodeableConcept') then
        value.location := ParseCodeableConcept(child, path+'/locationCodeableConcept')
      else if (child.localName = 'locationAddress') then
        value.location := ParseAddress(child, path+'/locationAddress')
      else if (child.localName = 'locationReference') then
        value.location := ParseReference(child, path+'/locationReference')
      else if (child.localName = 'patientPaid') then
        value.patientPaid := ParseMoney(child, path+'/patientPaid')
      else if (child.localName = 'quantity') then
        value.quantity := ParseQuantity(child, path+'/quantity')
      else if (child.localName = 'unitPrice') then
        value.unitPrice := ParseMoney(child, path+'/unitPrice')
      else if (child.localName = 'factor') then
        value.factorElement := ParseDecimal(child, path+'/factor')
      else if (child.localName = 'tax') then
        value.tax := ParseMoney(child, path+'/tax')
      else if (child.localName = 'net') then
        value.net := ParseMoney(child, path+'/net')
      else if (child.localName = 'bodySite') then
        value.bodySiteList.Add(ParseExplanationOfBenefitAddItemBodySite(child, path+'/bodySite'))
      else if (child.localName = 'noteNumber') then
        value.noteNumberList.Add(ParsePositiveInt(child, path+'/noteNumber'))
      else if (child.localName = 'decision') then
        value.decision := ParseCodeableConcept(child, path+'/decision')
      else if (child.localName = 'adjudication') then
        value.adjudicationList.Add(ParseExplanationOfBenefitItemAdjudication(child, path+'/adjudication'))
      else if (child.localName = 'detail') then
        value.detailList.Add(ParseExplanationOfBenefitAddItemDetail(child, path+'/detail'))
      else if Not ParseBackboneElementChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeExplanationOfBenefitAddItem(xml : TXmlBuilder; name : String; value : TFhirExplanationOfBenefitAddItem);
begin
  if (value = nil) then
    exit;
  composeElementAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeExplanationOfBenefitAddItemChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeExplanationOfBenefitAddItemChildren(xml : TXmlBuilder; value : TFhirExplanationOfBenefitAddItem);
var
  i : integer;
begin
  composeBackboneElementChildren(xml, value);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.itemSequenceList.Count - 1 do
      ComposePositiveInt(xml, 'itemSequence', value.itemSequenceList[i]);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.detailSequenceList.Count - 1 do
      ComposePositiveInt(xml, 'detailSequence', value.detailSequenceList[i]);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.subDetailSequenceList.Count - 1 do
      ComposePositiveInt(xml, 'subDetailSequence', value.subDetailSequenceList[i]);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.providerList.Count - 1 do
      ComposeReference(xml, 'provider', value.providerList[i]);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(xml, 'revenue', value.revenue);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(xml, 'productOrService', value.productOrService);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(xml, 'productOrServiceEnd', value.productOrServiceEnd);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.modifierList.Count - 1 do
      ComposeCodeableConcept(xml, 'modifier', value.modifierList[i]);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.programCodeList.Count - 1 do
      ComposeCodeableConcept(xml, 'programCode', value.programCodeList[i]);
  if (SummaryOption in [soFull, soData]) and (value.serviced is TFhirPeriod) {6} then
    ComposePeriod(xml, 'servicedPeriod', TFhirPeriod(value.serviced))
  else if (SummaryOption in [soFull, soData]) and (value.serviced is TFhirDate) {6} then
    ComposeDate(xml, 'servicedDate', TFhirDate(value.serviced));
  if (SummaryOption in [soFull, soData]) and (value.location is TFhirCodeableConcept) {6} then
    ComposeCodeableConcept(xml, 'locationCodeableConcept', TFhirCodeableConcept(value.location))
  else if (SummaryOption in [soFull, soData]) and (value.location is TFhirAddress) {6} then
    ComposeAddress(xml, 'locationAddress', TFhirAddress(value.location))
  else if (SummaryOption in [soFull, soData]) and (value.location is TFhirReference) {2} then
    ComposeReference(xml, 'locationReference', TFhirReference(value.location));
  if (SummaryOption in [soFull, soData]) then
    ComposeMoney(xml, 'patientPaid', value.patientPaid);
  if (SummaryOption in [soFull, soData]) then
    ComposeQuantity(xml, 'quantity', value.quantity);
  if (SummaryOption in [soFull, soData]) then
    ComposeMoney(xml, 'unitPrice', value.unitPrice);
  if (SummaryOption in [soFull, soData]) then
    ComposeDecimal(xml, 'factor', value.factorElement);
  if (SummaryOption in [soFull, soData]) then
    ComposeMoney(xml, 'tax', value.tax);
  if (SummaryOption in [soFull, soData]) then
    ComposeMoney(xml, 'net', value.net);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.bodySiteList.Count - 1 do
      ComposeExplanationOfBenefitAddItemBodySite(xml, 'bodySite', value.bodySiteList[i]);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.noteNumberList.Count - 1 do
      ComposePositiveInt(xml, 'noteNumber', value.noteNumberList[i]);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(xml, 'decision', value.decision);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.adjudicationList.Count - 1 do
      ComposeExplanationOfBenefitItemAdjudication(xml, 'adjudication', value.adjudicationList[i]);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.detailList.Count - 1 do
      ComposeExplanationOfBenefitAddItemDetail(xml, 'detail', value.detailList[i]);
end;

function TFHIRXmlParser.ParseExplanationOfBenefitAddItemBodySite(element : TMXmlElement; path : string) : TFhirExplanationOfBenefitAddItemBodySite;
var
  child : TMXmlElement;
begin
  result := TFhirExplanationOfBenefitAddItemBodySite.Create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseExplanationOfBenefitAddItemBodySiteChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseExplanationOfBenefitAddItemBodySiteChild(value : TFhirExplanationOfBenefitAddItemBodySite; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'site') then
        value.siteList.Add(ParseCodeableReference(child, path+'/site'))
      else if (child.localName = 'subSite') then
        value.subSiteList.Add(ParseCodeableConcept(child, path+'/subSite'))
      else if Not ParseBackboneElementChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeExplanationOfBenefitAddItemBodySite(xml : TXmlBuilder; name : String; value : TFhirExplanationOfBenefitAddItemBodySite);
begin
  if (value = nil) then
    exit;
  composeElementAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeExplanationOfBenefitAddItemBodySiteChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeExplanationOfBenefitAddItemBodySiteChildren(xml : TXmlBuilder; value : TFhirExplanationOfBenefitAddItemBodySite);
var
  i : integer;
begin
  composeBackboneElementChildren(xml, value);
  for i := 0 to value.siteList.Count - 1 do
      ComposeCodeableReference(xml, 'site', value.siteList[i]);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.subSiteList.Count - 1 do
      ComposeCodeableConcept(xml, 'subSite', value.subSiteList[i]);
end;

function TFHIRXmlParser.ParseExplanationOfBenefitAddItemDetail(element : TMXmlElement; path : string) : TFhirExplanationOfBenefitAddItemDetail;
var
  child : TMXmlElement;
begin
  result := TFhirExplanationOfBenefitAddItemDetail.Create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseExplanationOfBenefitAddItemDetailChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseExplanationOfBenefitAddItemDetailChild(value : TFhirExplanationOfBenefitAddItemDetail; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'revenue') then
        value.revenue := ParseCodeableConcept(child, path+'/revenue')
      else if (child.localName = 'productOrService') then
        value.productOrService := ParseCodeableConcept(child, path+'/productOrService')
      else if (child.localName = 'productOrServiceEnd') then
        value.productOrServiceEnd := ParseCodeableConcept(child, path+'/productOrServiceEnd')
      else if (child.localName = 'modifier') then
        value.modifierList.Add(ParseCodeableConcept(child, path+'/modifier'))
      else if (child.localName = 'patientPaid') then
        value.patientPaid := ParseMoney(child, path+'/patientPaid')
      else if (child.localName = 'quantity') then
        value.quantity := ParseQuantity(child, path+'/quantity')
      else if (child.localName = 'unitPrice') then
        value.unitPrice := ParseMoney(child, path+'/unitPrice')
      else if (child.localName = 'factor') then
        value.factorElement := ParseDecimal(child, path+'/factor')
      else if (child.localName = 'tax') then
        value.tax := ParseMoney(child, path+'/tax')
      else if (child.localName = 'net') then
        value.net := ParseMoney(child, path+'/net')
      else if (child.localName = 'noteNumber') then
        value.noteNumberList.Add(ParsePositiveInt(child, path+'/noteNumber'))
      else if (child.localName = 'decision') then
        value.decision := ParseCodeableConcept(child, path+'/decision')
      else if (child.localName = 'adjudication') then
        value.adjudicationList.Add(ParseExplanationOfBenefitItemAdjudication(child, path+'/adjudication'))
      else if (child.localName = 'subDetail') then
        value.subDetailList.Add(ParseExplanationOfBenefitAddItemDetailSubDetail(child, path+'/subDetail'))
      else if Not ParseBackboneElementChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeExplanationOfBenefitAddItemDetail(xml : TXmlBuilder; name : String; value : TFhirExplanationOfBenefitAddItemDetail);
begin
  if (value = nil) then
    exit;
  composeElementAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeExplanationOfBenefitAddItemDetailChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeExplanationOfBenefitAddItemDetailChildren(xml : TXmlBuilder; value : TFhirExplanationOfBenefitAddItemDetail);
var
  i : integer;
begin
  composeBackboneElementChildren(xml, value);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(xml, 'revenue', value.revenue);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(xml, 'productOrService', value.productOrService);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(xml, 'productOrServiceEnd', value.productOrServiceEnd);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.modifierList.Count - 1 do
      ComposeCodeableConcept(xml, 'modifier', value.modifierList[i]);
  if (SummaryOption in [soFull, soData]) then
    ComposeMoney(xml, 'patientPaid', value.patientPaid);
  if (SummaryOption in [soFull, soData]) then
    ComposeQuantity(xml, 'quantity', value.quantity);
  if (SummaryOption in [soFull, soData]) then
    ComposeMoney(xml, 'unitPrice', value.unitPrice);
  if (SummaryOption in [soFull, soData]) then
    ComposeDecimal(xml, 'factor', value.factorElement);
  if (SummaryOption in [soFull, soData]) then
    ComposeMoney(xml, 'tax', value.tax);
  if (SummaryOption in [soFull, soData]) then
    ComposeMoney(xml, 'net', value.net);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.noteNumberList.Count - 1 do
      ComposePositiveInt(xml, 'noteNumber', value.noteNumberList[i]);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(xml, 'decision', value.decision);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.adjudicationList.Count - 1 do
      ComposeExplanationOfBenefitItemAdjudication(xml, 'adjudication', value.adjudicationList[i]);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.subDetailList.Count - 1 do
      ComposeExplanationOfBenefitAddItemDetailSubDetail(xml, 'subDetail', value.subDetailList[i]);
end;

function TFHIRXmlParser.ParseExplanationOfBenefitAddItemDetailSubDetail(element : TMXmlElement; path : string) : TFhirExplanationOfBenefitAddItemDetailSubDetail;
var
  child : TMXmlElement;
begin
  result := TFhirExplanationOfBenefitAddItemDetailSubDetail.Create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseExplanationOfBenefitAddItemDetailSubDetailChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseExplanationOfBenefitAddItemDetailSubDetailChild(value : TFhirExplanationOfBenefitAddItemDetailSubDetail; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'revenue') then
        value.revenue := ParseCodeableConcept(child, path+'/revenue')
      else if (child.localName = 'productOrService') then
        value.productOrService := ParseCodeableConcept(child, path+'/productOrService')
      else if (child.localName = 'productOrServiceEnd') then
        value.productOrServiceEnd := ParseCodeableConcept(child, path+'/productOrServiceEnd')
      else if (child.localName = 'modifier') then
        value.modifierList.Add(ParseCodeableConcept(child, path+'/modifier'))
      else if (child.localName = 'patientPaid') then
        value.patientPaid := ParseMoney(child, path+'/patientPaid')
      else if (child.localName = 'quantity') then
        value.quantity := ParseQuantity(child, path+'/quantity')
      else if (child.localName = 'unitPrice') then
        value.unitPrice := ParseMoney(child, path+'/unitPrice')
      else if (child.localName = 'factor') then
        value.factorElement := ParseDecimal(child, path+'/factor')
      else if (child.localName = 'tax') then
        value.tax := ParseMoney(child, path+'/tax')
      else if (child.localName = 'net') then
        value.net := ParseMoney(child, path+'/net')
      else if (child.localName = 'noteNumber') then
        value.noteNumberList.Add(ParsePositiveInt(child, path+'/noteNumber'))
      else if (child.localName = 'decision') then
        value.decision := ParseCodeableConcept(child, path+'/decision')
      else if (child.localName = 'adjudication') then
        value.adjudicationList.Add(ParseExplanationOfBenefitItemAdjudication(child, path+'/adjudication'))
      else if Not ParseBackboneElementChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeExplanationOfBenefitAddItemDetailSubDetail(xml : TXmlBuilder; name : String; value : TFhirExplanationOfBenefitAddItemDetailSubDetail);
begin
  if (value = nil) then
    exit;
  composeElementAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeExplanationOfBenefitAddItemDetailSubDetailChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeExplanationOfBenefitAddItemDetailSubDetailChildren(xml : TXmlBuilder; value : TFhirExplanationOfBenefitAddItemDetailSubDetail);
var
  i : integer;
begin
  composeBackboneElementChildren(xml, value);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(xml, 'revenue', value.revenue);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(xml, 'productOrService', value.productOrService);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(xml, 'productOrServiceEnd', value.productOrServiceEnd);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.modifierList.Count - 1 do
      ComposeCodeableConcept(xml, 'modifier', value.modifierList[i]);
  if (SummaryOption in [soFull, soData]) then
    ComposeMoney(xml, 'patientPaid', value.patientPaid);
  if (SummaryOption in [soFull, soData]) then
    ComposeQuantity(xml, 'quantity', value.quantity);
  if (SummaryOption in [soFull, soData]) then
    ComposeMoney(xml, 'unitPrice', value.unitPrice);
  if (SummaryOption in [soFull, soData]) then
    ComposeDecimal(xml, 'factor', value.factorElement);
  if (SummaryOption in [soFull, soData]) then
    ComposeMoney(xml, 'tax', value.tax);
  if (SummaryOption in [soFull, soData]) then
    ComposeMoney(xml, 'net', value.net);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.noteNumberList.Count - 1 do
      ComposePositiveInt(xml, 'noteNumber', value.noteNumberList[i]);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(xml, 'decision', value.decision);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.adjudicationList.Count - 1 do
      ComposeExplanationOfBenefitItemAdjudication(xml, 'adjudication', value.adjudicationList[i]);
end;

function TFHIRXmlParser.ParseExplanationOfBenefitTotal(element : TMXmlElement; path : string) : TFhirExplanationOfBenefitTotal;
var
  child : TMXmlElement;
begin
  result := TFhirExplanationOfBenefitTotal.Create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseExplanationOfBenefitTotalChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseExplanationOfBenefitTotalChild(value : TFhirExplanationOfBenefitTotal; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'category') then
        value.category := ParseCodeableConcept(child, path+'/category')
      else if (child.localName = 'amount') then
        value.amount := ParseMoney(child, path+'/amount')
      else if Not ParseBackboneElementChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeExplanationOfBenefitTotal(xml : TXmlBuilder; name : String; value : TFhirExplanationOfBenefitTotal);
begin
  if (value = nil) then
    exit;
  composeElementAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeExplanationOfBenefitTotalChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeExplanationOfBenefitTotalChildren(xml : TXmlBuilder; value : TFhirExplanationOfBenefitTotal);
begin
  composeBackboneElementChildren(xml, value);
  ComposeCodeableConcept(xml, 'category', value.category);
  ComposeMoney(xml, 'amount', value.amount);
end;

function TFHIRXmlParser.ParseExplanationOfBenefitPayment(element : TMXmlElement; path : string) : TFhirExplanationOfBenefitPayment;
var
  child : TMXmlElement;
begin
  result := TFhirExplanationOfBenefitPayment.Create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseExplanationOfBenefitPaymentChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseExplanationOfBenefitPaymentChild(value : TFhirExplanationOfBenefitPayment; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'type') then
        value.type_ := ParseCodeableConcept(child, path+'/type')
      else if (child.localName = 'adjustment') then
        value.adjustment := ParseMoney(child, path+'/adjustment')
      else if (child.localName = 'adjustmentReason') then
        value.adjustmentReason := ParseCodeableConcept(child, path+'/adjustmentReason')
      else if (child.localName = 'date') then
        value.dateElement := ParseDate(child, path+'/date')
      else if (child.localName = 'amount') then
        value.amount := ParseMoney(child, path+'/amount')
      else if (child.localName = 'identifier') then
        value.identifier := ParseIdentifier(child, path+'/identifier')
      else if Not ParseBackboneElementChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeExplanationOfBenefitPayment(xml : TXmlBuilder; name : String; value : TFhirExplanationOfBenefitPayment);
begin
  if (value = nil) then
    exit;
  composeElementAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeExplanationOfBenefitPaymentChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeExplanationOfBenefitPaymentChildren(xml : TXmlBuilder; value : TFhirExplanationOfBenefitPayment);
begin
  composeBackboneElementChildren(xml, value);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(xml, 'type', value.type_);
  if (SummaryOption in [soFull, soData]) then
    ComposeMoney(xml, 'adjustment', value.adjustment);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(xml, 'adjustmentReason', value.adjustmentReason);
  if (SummaryOption in [soFull, soData]) then
    ComposeDate(xml, 'date', value.dateElement);
  if (SummaryOption in [soFull, soData]) then
    ComposeMoney(xml, 'amount', value.amount);
  if (SummaryOption in [soFull, soData]) then
    ComposeIdentifier(xml, 'identifier', value.identifier);
end;

function TFHIRXmlParser.ParseExplanationOfBenefitProcessNote(element : TMXmlElement; path : string) : TFhirExplanationOfBenefitProcessNote;
var
  child : TMXmlElement;
begin
  result := TFhirExplanationOfBenefitProcessNote.Create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseExplanationOfBenefitProcessNoteChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseExplanationOfBenefitProcessNoteChild(value : TFhirExplanationOfBenefitProcessNote; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'number') then
        value.numberElement := ParsePositiveInt(child, path+'/number')
      else if (child.localName = 'type') then
        value.type_Element := ParseEnum(CODES_TFhirNoteTypeEnum, SYSTEMS_TFhirNoteTypeEnum, child, path+'/type')
      else if (child.localName = 'text') then
        value.textElement := ParseString(child, path+'/text')
      else if (child.localName = 'language') then
        value.language := ParseCodeableConcept(child, path+'/language')
      else if Not ParseBackboneElementChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeExplanationOfBenefitProcessNote(xml : TXmlBuilder; name : String; value : TFhirExplanationOfBenefitProcessNote);
begin
  if (value = nil) then
    exit;
  composeElementAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeExplanationOfBenefitProcessNoteChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeExplanationOfBenefitProcessNoteChildren(xml : TXmlBuilder; value : TFhirExplanationOfBenefitProcessNote);
begin
  composeBackboneElementChildren(xml, value);
  if (SummaryOption in [soFull, soData]) then
    ComposePositiveInt(xml, 'number', value.numberElement);
  if (SummaryOption in [soFull, soData]) then
    ComposeEnum(xml, 'type', value.type_Element, CODES_TFhirNoteTypeEnum);
  if (SummaryOption in [soFull, soData]) then
    ComposeString(xml, 'text', value.textElement);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(xml, 'language', value.language);
end;

function TFHIRXmlParser.ParseExplanationOfBenefitBenefitBalance(element : TMXmlElement; path : string) : TFhirExplanationOfBenefitBenefitBalance;
var
  child : TMXmlElement;
begin
  result := TFhirExplanationOfBenefitBenefitBalance.Create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseExplanationOfBenefitBenefitBalanceChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseExplanationOfBenefitBenefitBalanceChild(value : TFhirExplanationOfBenefitBenefitBalance; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'category') then
        value.category := ParseCodeableConcept(child, path+'/category')
      else if (child.localName = 'excluded') then
        value.excludedElement := ParseBoolean(child, path+'/excluded')
      else if (child.localName = 'name') then
        value.nameElement := ParseString(child, path+'/name')
      else if (child.localName = 'description') then
        value.descriptionElement := ParseString(child, path+'/description')
      else if (child.localName = 'network') then
        value.network := ParseCodeableConcept(child, path+'/network')
      else if (child.localName = 'unit') then
        value.unit_ := ParseCodeableConcept(child, path+'/unit')
      else if (child.localName = 'term') then
        value.term := ParseCodeableConcept(child, path+'/term')
      else if (child.localName = 'financial') then
        value.financialList.Add(ParseExplanationOfBenefitBenefitBalanceFinancial(child, path+'/financial'))
      else if Not ParseBackboneElementChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeExplanationOfBenefitBenefitBalance(xml : TXmlBuilder; name : String; value : TFhirExplanationOfBenefitBenefitBalance);
begin
  if (value = nil) then
    exit;
  composeElementAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeExplanationOfBenefitBenefitBalanceChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeExplanationOfBenefitBenefitBalanceChildren(xml : TXmlBuilder; value : TFhirExplanationOfBenefitBenefitBalance);
var
  i : integer;
begin
  composeBackboneElementChildren(xml, value);
  ComposeCodeableConcept(xml, 'category', value.category);
  if (SummaryOption in [soFull, soData]) then
    ComposeBoolean(xml, 'excluded', value.excludedElement);
  if (SummaryOption in [soFull, soData]) then
    ComposeString(xml, 'name', value.nameElement);
  if (SummaryOption in [soFull, soData]) then
    ComposeString(xml, 'description', value.descriptionElement);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(xml, 'network', value.network);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(xml, 'unit', value.unit_);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(xml, 'term', value.term);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.financialList.Count - 1 do
      ComposeExplanationOfBenefitBenefitBalanceFinancial(xml, 'financial', value.financialList[i]);
end;

function TFHIRXmlParser.ParseExplanationOfBenefitBenefitBalanceFinancial(element : TMXmlElement; path : string) : TFhirExplanationOfBenefitBenefitBalanceFinancial;
var
  child : TMXmlElement;
begin
  result := TFhirExplanationOfBenefitBenefitBalanceFinancial.Create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseExplanationOfBenefitBenefitBalanceFinancialChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseExplanationOfBenefitBenefitBalanceFinancialChild(value : TFhirExplanationOfBenefitBenefitBalanceFinancial; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'type') then
        value.type_ := ParseCodeableConcept(child, path+'/type')
      else if (child.localName = 'allowedUnsignedInt') then
        value.allowed := ParseUnsignedInt(child, path+'/allowedUnsignedInt')
      else if (child.localName = 'allowedMoney') then
        value.allowed := ParseMoney(child, path+'/allowedMoney')
      else if (child.localName = 'allowedString') then
        value.allowed := ParseString(child, path+'/allowedString')
      else if (child.localName = 'usedUnsignedInt') then
        value.used := ParseUnsignedInt(child, path+'/usedUnsignedInt')
      else if (child.localName = 'usedMoney') then
        value.used := ParseMoney(child, path+'/usedMoney')
      else if Not ParseBackboneElementChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeExplanationOfBenefitBenefitBalanceFinancial(xml : TXmlBuilder; name : String; value : TFhirExplanationOfBenefitBenefitBalanceFinancial);
begin
  if (value = nil) then
    exit;
  composeElementAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeExplanationOfBenefitBenefitBalanceFinancialChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeExplanationOfBenefitBenefitBalanceFinancialChildren(xml : TXmlBuilder; value : TFhirExplanationOfBenefitBenefitBalanceFinancial);
begin
  composeBackboneElementChildren(xml, value);
  ComposeCodeableConcept(xml, 'type', value.type_);
  if (SummaryOption in [soFull, soData]) and (value.allowed is TFhirUnsignedInt) {6} then
    ComposeUnsignedInt(xml, 'allowedUnsignedInt', TFhirUnsignedInt(value.allowed))
  else if (SummaryOption in [soFull, soData]) and (value.allowed is TFhirMoney) {6} then
    ComposeMoney(xml, 'allowedMoney', TFhirMoney(value.allowed))
  else if (SummaryOption in [soFull, soData]) and (value.allowed is TFhirString) {6} then
    ComposeString(xml, 'allowedString', TFhirString(value.allowed));
  if (SummaryOption in [soFull, soData]) and (value.used is TFhirUnsignedInt) {6} then
    ComposeUnsignedInt(xml, 'usedUnsignedInt', TFhirUnsignedInt(value.used))
  else if (SummaryOption in [soFull, soData]) and (value.used is TFhirMoney) {6} then
    ComposeMoney(xml, 'usedMoney', TFhirMoney(value.used));
end;

function TFHIRXmlParser.ParseExplanationOfBenefit(element : TMXmlElement; path : string) : TFhirExplanationOfBenefit;
var
  child : TMXmlElement;
begin
  result := TFhirExplanationOfBenefit.Create;
  try
    parseDomainResourceAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseExplanationOfBenefitChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseExplanationOfBenefitChild(value : TFhirExplanationOfBenefit; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'identifier') then
        value.identifierList.Add(ParseIdentifier(child, path+'/identifier'))
      else if (child.localName = 'status') then
        value.statusElement := ParseEnum(CODES_TFhirExplanationOfBenefitStatusEnum, SYSTEMS_TFhirExplanationOfBenefitStatusEnum, child, path+'/status')
      else if (child.localName = 'type') then
        value.type_ := ParseCodeableConcept(child, path+'/type')
      else if (child.localName = 'subType') then
        value.subType := ParseCodeableConcept(child, path+'/subType')
      else if (child.localName = 'use') then
        value.useElement := ParseEnum(CODES_TFhirUseEnum, SYSTEMS_TFhirUseEnum, child, path+'/use')
      else if (child.localName = 'patient') then
        value.patient := ParseReference(child, path+'/patient')
      else if (child.localName = 'billablePeriod') then
        value.billablePeriod := ParsePeriod(child, path+'/billablePeriod')
      else if (child.localName = 'created') then
        value.createdElement := ParseDateTime(child, path+'/created')
      else if (child.localName = 'enterer') then
        value.enterer := ParseReference(child, path+'/enterer')
      else if (child.localName = 'insurer') then
        value.insurer := ParseReference(child, path+'/insurer')
      else if (child.localName = 'provider') then
        value.provider := ParseReference(child, path+'/provider')
      else if (child.localName = 'priority') then
        value.priority := ParseCodeableConcept(child, path+'/priority')
      else if (child.localName = 'fundsReserveRequested') then
        value.fundsReserveRequested := ParseCodeableConcept(child, path+'/fundsReserveRequested')
      else if (child.localName = 'fundsReserve') then
        value.fundsReserve := ParseCodeableConcept(child, path+'/fundsReserve')
      else if (child.localName = 'related') then
        value.relatedList.Add(ParseExplanationOfBenefitRelated(child, path+'/related'))
      else if (child.localName = 'prescription') then
        value.prescription := ParseReference(child, path+'/prescription')
      else if (child.localName = 'originalPrescription') then
        value.originalPrescription := ParseReference(child, path+'/originalPrescription')
      else if (child.localName = 'payee') then
        value.payee := ParseExplanationOfBenefitPayee(child, path+'/payee')
      else if (child.localName = 'referral') then
        value.referral := ParseReference(child, path+'/referral')
      else if (child.localName = 'encounter') then
        value.encounterList.Add(ParseReference(child, path+'/encounter'))
      else if (child.localName = 'facility') then
        value.facility := ParseReference(child, path+'/facility')
      else if (child.localName = 'claim') then
        value.claim := ParseReference(child, path+'/claim')
      else if (child.localName = 'claimResponse') then
        value.claimResponse := ParseReference(child, path+'/claimResponse')
      else if (child.localName = 'outcome') then
        value.outcomeElement := ParseEnum(CODES_TFhirClaimProcessingCodesEnum, SYSTEMS_TFhirClaimProcessingCodesEnum, child, path+'/outcome')
      else if (child.localName = 'decision') then
        value.decision := ParseCodeableConcept(child, path+'/decision')
      else if (child.localName = 'disposition') then
        value.dispositionElement := ParseString(child, path+'/disposition')
      else if (child.localName = 'preAuthRef') then
        value.preAuthRefList.Add(ParseString(child, path+'/preAuthRef'))
      else if (child.localName = 'preAuthRefPeriod') then
        value.preAuthRefPeriodList.Add(ParsePeriod(child, path+'/preAuthRefPeriod'))
      else if (child.localName = 'diagnosisRelatedGroup') then
        value.diagnosisRelatedGroup := ParseCodeableConcept(child, path+'/diagnosisRelatedGroup')
      else if (child.localName = 'careTeam') then
        value.careTeamList.Add(ParseExplanationOfBenefitCareTeam(child, path+'/careTeam'))
      else if (child.localName = 'supportingInfo') then
        value.supportingInfoList.Add(ParseExplanationOfBenefitSupportingInfo(child, path+'/supportingInfo'))
      else if (child.localName = 'diagnosis') then
        value.diagnosisList.Add(ParseExplanationOfBenefitDiagnosis(child, path+'/diagnosis'))
      else if (child.localName = 'procedure') then
        value.procedure_List.Add(ParseExplanationOfBenefitProcedure(child, path+'/procedure'))
      else if (child.localName = 'precedence') then
        value.precedenceElement := ParsePositiveInt(child, path+'/precedence')
      else if (child.localName = 'insurance') then
        value.insuranceList.Add(ParseExplanationOfBenefitInsurance(child, path+'/insurance'))
      else if (child.localName = 'accident') then
        value.accident := ParseExplanationOfBenefitAccident(child, path+'/accident')
      else if (child.localName = 'patientPaid') then
        value.patientPaid := ParseMoney(child, path+'/patientPaid')
      else if (child.localName = 'item') then
        value.itemList.Add(ParseExplanationOfBenefitItem(child, path+'/item'))
      else if (child.localName = 'addItem') then
        value.addItemList.Add(ParseExplanationOfBenefitAddItem(child, path+'/addItem'))
      else if (child.localName = 'adjudication') then
        value.adjudicationList.Add(ParseExplanationOfBenefitItemAdjudication(child, path+'/adjudication'))
      else if (child.localName = 'total') then
        value.totalList.Add(ParseExplanationOfBenefitTotal(child, path+'/total'))
      else if (child.localName = 'payment') then
        value.payment := ParseExplanationOfBenefitPayment(child, path+'/payment')
      else if (child.localName = 'formCode') then
        value.formCode := ParseCodeableConcept(child, path+'/formCode')
      else if (child.localName = 'form') then
        value.form := ParseAttachment(child, path+'/form')
      else if (child.localName = 'processNote') then
        value.processNoteList.Add(ParseExplanationOfBenefitProcessNote(child, path+'/processNote'))
      else if (child.localName = 'benefitPeriod') then
        value.benefitPeriod := ParsePeriod(child, path+'/benefitPeriod')
      else if (child.localName = 'benefitBalance') then
        value.benefitBalanceList.Add(ParseExplanationOfBenefitBenefitBalance(child, path+'/benefitBalance'))
      else if Not ParseDomainResourceChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeExplanationOfBenefit(xml : TXmlBuilder; name : String; value : TFhirExplanationOfBenefit);
begin
  if (value = nil) then
    exit;
  composeDomainResourceAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeExplanationOfBenefitChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeExplanationOfBenefitChildren(xml : TXmlBuilder; value : TFhirExplanationOfBenefit);
var
  i : integer;
begin
  composeDomainResourceChildren(xml, value);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.identifierList.Count - 1 do
      ComposeIdentifier(xml, 'identifier', value.identifierList[i]);
  ComposeEnum(xml, 'status', value.statusElement, CODES_TFhirExplanationOfBenefitStatusEnum);
  ComposeCodeableConcept(xml, 'type', value.type_);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(xml, 'subType', value.subType);
  ComposeEnum(xml, 'use', value.useElement, CODES_TFhirUseEnum);
  ComposeReference(xml, 'patient', value.patient);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposePeriod(xml, 'billablePeriod', value.billablePeriod);
  ComposeDateTime(xml, 'created', value.createdElement);
  if (SummaryOption in [soFull, soData]) then
    ComposeReference(xml, 'enterer', value.enterer);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference(xml, 'insurer', value.insurer);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference(xml, 'provider', value.provider);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(xml, 'priority', value.priority);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(xml, 'fundsReserveRequested', value.fundsReserveRequested);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(xml, 'fundsReserve', value.fundsReserve);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.relatedList.Count - 1 do
      ComposeExplanationOfBenefitRelated(xml, 'related', value.relatedList[i]);
  if (SummaryOption in [soFull, soData]) then
    ComposeReference(xml, 'prescription', value.prescription);
  if (SummaryOption in [soFull, soData]) then
    ComposeReference(xml, 'originalPrescription', value.originalPrescription);
  if (SummaryOption in [soFull, soData]) then
    ComposeExplanationOfBenefitPayee(xml, 'payee', value.payee);
  if (SummaryOption in [soFull, soData]) then
    ComposeReference(xml, 'referral', value.referral);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.encounterList.Count - 1 do
      ComposeReference(xml, 'encounter', value.encounterList[i]);
  if (SummaryOption in [soFull, soData]) then
    ComposeReference(xml, 'facility', value.facility);
  if (SummaryOption in [soFull, soData]) then
    ComposeReference(xml, 'claim', value.claim);
  if (SummaryOption in [soFull, soData]) then
    ComposeReference(xml, 'claimResponse', value.claimResponse);
  ComposeEnum(xml, 'outcome', value.outcomeElement, CODES_TFhirClaimProcessingCodesEnum);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(xml, 'decision', value.decision);
  if (SummaryOption in [soFull, soData]) then
    ComposeString(xml, 'disposition', value.dispositionElement);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.preAuthRefList.Count - 1 do
      ComposeString(xml, 'preAuthRef', value.preAuthRefList[i]);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.preAuthRefPeriodList.Count - 1 do
      ComposePeriod(xml, 'preAuthRefPeriod', value.preAuthRefPeriodList[i]);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(xml, 'diagnosisRelatedGroup', value.diagnosisRelatedGroup);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.careTeamList.Count - 1 do
      ComposeExplanationOfBenefitCareTeam(xml, 'careTeam', value.careTeamList[i]);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.supportingInfoList.Count - 1 do
      ComposeExplanationOfBenefitSupportingInfo(xml, 'supportingInfo', value.supportingInfoList[i]);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.diagnosisList.Count - 1 do
      ComposeExplanationOfBenefitDiagnosis(xml, 'diagnosis', value.diagnosisList[i]);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.procedure_List.Count - 1 do
      ComposeExplanationOfBenefitProcedure(xml, 'procedure', value.procedure_List[i]);
  if (SummaryOption in [soFull, soData]) then
    ComposePositiveInt(xml, 'precedence', value.precedenceElement);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.insuranceList.Count - 1 do
      ComposeExplanationOfBenefitInsurance(xml, 'insurance', value.insuranceList[i]);
  if (SummaryOption in [soFull, soData]) then
    ComposeExplanationOfBenefitAccident(xml, 'accident', value.accident);
  if (SummaryOption in [soFull, soData]) then
    ComposeMoney(xml, 'patientPaid', value.patientPaid);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.itemList.Count - 1 do
      ComposeExplanationOfBenefitItem(xml, 'item', value.itemList[i]);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.addItemList.Count - 1 do
      ComposeExplanationOfBenefitAddItem(xml, 'addItem', value.addItemList[i]);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.adjudicationList.Count - 1 do
      ComposeExplanationOfBenefitItemAdjudication(xml, 'adjudication', value.adjudicationList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.totalList.Count - 1 do
      ComposeExplanationOfBenefitTotal(xml, 'total', value.totalList[i]);
  if (SummaryOption in [soFull, soData]) then
    ComposeExplanationOfBenefitPayment(xml, 'payment', value.payment);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(xml, 'formCode', value.formCode);
  if (SummaryOption in [soFull, soData]) then
    ComposeAttachment(xml, 'form', value.form);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.processNoteList.Count - 1 do
      ComposeExplanationOfBenefitProcessNote(xml, 'processNote', value.processNoteList[i]);
  if (SummaryOption in [soFull, soData]) then
    ComposePeriod(xml, 'benefitPeriod', value.benefitPeriod);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.benefitBalanceList.Count - 1 do
      ComposeExplanationOfBenefitBenefitBalance(xml, 'benefitBalance', value.benefitBalanceList[i]);
end;

{$ENDIF FHIR_EXPLANATIONOFBENEFIT}
{$IFDEF FHIR_FAMILYMEMBERHISTORY}
function TFHIRXmlParser.ParseFamilyMemberHistoryCondition(element : TMXmlElement; path : string) : TFhirFamilyMemberHistoryCondition;
var
  child : TMXmlElement;
begin
  result := TFhirFamilyMemberHistoryCondition.Create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseFamilyMemberHistoryConditionChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseFamilyMemberHistoryConditionChild(value : TFhirFamilyMemberHistoryCondition; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'code') then
        value.code := ParseCodeableConcept(child, path+'/code')
      else if (child.localName = 'outcome') then
        value.outcome := ParseCodeableConcept(child, path+'/outcome')
      else if (child.localName = 'contributedToDeath') then
        value.contributedToDeathElement := ParseBoolean(child, path+'/contributedToDeath')
      else if (child.localName = 'onsetAge') then
        value.onset := ParseAge(child, path+'/onsetAge')
      else if (child.localName = 'onsetRange') then
        value.onset := ParseRange(child, path+'/onsetRange')
      else if (child.localName = 'onsetPeriod') then
        value.onset := ParsePeriod(child, path+'/onsetPeriod')
      else if (child.localName = 'onsetString') then
        value.onset := ParseString(child, path+'/onsetString')
      else if (child.localName = 'note') then
        value.noteList.Add(ParseAnnotation(child, path+'/note'))
      else if Not ParseBackboneElementChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeFamilyMemberHistoryCondition(xml : TXmlBuilder; name : String; value : TFhirFamilyMemberHistoryCondition);
begin
  if (value = nil) then
    exit;
  composeElementAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeFamilyMemberHistoryConditionChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeFamilyMemberHistoryConditionChildren(xml : TXmlBuilder; value : TFhirFamilyMemberHistoryCondition);
var
  i : integer;
begin
  composeBackboneElementChildren(xml, value);
  ComposeCodeableConcept(xml, 'code', value.code);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(xml, 'outcome', value.outcome);
  if (SummaryOption in [soFull, soData]) then
    ComposeBoolean(xml, 'contributedToDeath', value.contributedToDeathElement);
  if (SummaryOption in [soFull, soData]) and (value.onset is TFhirAge) {6} then
    ComposeAge(xml, 'onsetAge', TFhirAge(value.onset))
  else if (SummaryOption in [soFull, soData]) and (value.onset is TFhirRange) {6} then
    ComposeRange(xml, 'onsetRange', TFhirRange(value.onset))
  else if (SummaryOption in [soFull, soData]) and (value.onset is TFhirPeriod) {6} then
    ComposePeriod(xml, 'onsetPeriod', TFhirPeriod(value.onset))
  else if (SummaryOption in [soFull, soData]) and (value.onset is TFhirString) {6} then
    ComposeString(xml, 'onsetString', TFhirString(value.onset));
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.noteList.Count - 1 do
      ComposeAnnotation(xml, 'note', value.noteList[i]);
end;

function TFHIRXmlParser.ParseFamilyMemberHistoryProcedure(element : TMXmlElement; path : string) : TFhirFamilyMemberHistoryProcedure;
var
  child : TMXmlElement;
begin
  result := TFhirFamilyMemberHistoryProcedure.Create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseFamilyMemberHistoryProcedureChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseFamilyMemberHistoryProcedureChild(value : TFhirFamilyMemberHistoryProcedure; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'code') then
        value.code := ParseCodeableConcept(child, path+'/code')
      else if (child.localName = 'outcome') then
        value.outcome := ParseCodeableConcept(child, path+'/outcome')
      else if (child.localName = 'contributedToDeath') then
        value.contributedToDeathElement := ParseBoolean(child, path+'/contributedToDeath')
      else if (child.localName = 'performedAge') then
        value.performed := ParseAge(child, path+'/performedAge')
      else if (child.localName = 'performedRange') then
        value.performed := ParseRange(child, path+'/performedRange')
      else if (child.localName = 'performedPeriod') then
        value.performed := ParsePeriod(child, path+'/performedPeriod')
      else if (child.localName = 'performedString') then
        value.performed := ParseString(child, path+'/performedString')
      else if (child.localName = 'performedDateTime') then
        value.performed := ParseDateTime(child, path+'/performedDateTime')
      else if (child.localName = 'note') then
        value.noteList.Add(ParseAnnotation(child, path+'/note'))
      else if Not ParseBackboneElementChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeFamilyMemberHistoryProcedure(xml : TXmlBuilder; name : String; value : TFhirFamilyMemberHistoryProcedure);
begin
  if (value = nil) then
    exit;
  composeElementAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeFamilyMemberHistoryProcedureChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeFamilyMemberHistoryProcedureChildren(xml : TXmlBuilder; value : TFhirFamilyMemberHistoryProcedure);
var
  i : integer;
begin
  composeBackboneElementChildren(xml, value);
  ComposeCodeableConcept(xml, 'code', value.code);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(xml, 'outcome', value.outcome);
  if (SummaryOption in [soFull, soData]) then
    ComposeBoolean(xml, 'contributedToDeath', value.contributedToDeathElement);
  if (SummaryOption in [soFull, soData]) and (value.performed is TFhirAge) {6} then
    ComposeAge(xml, 'performedAge', TFhirAge(value.performed))
  else if (SummaryOption in [soFull, soData]) and (value.performed is TFhirRange) {6} then
    ComposeRange(xml, 'performedRange', TFhirRange(value.performed))
  else if (SummaryOption in [soFull, soData]) and (value.performed is TFhirPeriod) {6} then
    ComposePeriod(xml, 'performedPeriod', TFhirPeriod(value.performed))
  else if (SummaryOption in [soFull, soData]) and (value.performed is TFhirString) {6} then
    ComposeString(xml, 'performedString', TFhirString(value.performed))
  else if (SummaryOption in [soFull, soData]) and (value.performed is TFhirDateTime) {6} then
    ComposeDateTime(xml, 'performedDateTime', TFhirDateTime(value.performed));
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.noteList.Count - 1 do
      ComposeAnnotation(xml, 'note', value.noteList[i]);
end;

function TFHIRXmlParser.ParseFamilyMemberHistory(element : TMXmlElement; path : string) : TFhirFamilyMemberHistory;
var
  child : TMXmlElement;
begin
  result := TFhirFamilyMemberHistory.Create;
  try
    parseDomainResourceAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseFamilyMemberHistoryChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseFamilyMemberHistoryChild(value : TFhirFamilyMemberHistory; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'identifier') then
        value.identifierList.Add(ParseIdentifier(child, path+'/identifier'))
      else if (child.localName = 'instantiatesCanonical') then
        value.instantiatesCanonicalList.Add(ParseCanonical(child, path+'/instantiatesCanonical'))
      else if (child.localName = 'instantiatesUri') then
        value.instantiatesUriList.Add(ParseUri(child, path+'/instantiatesUri'))
      else if (child.localName = 'status') then
        value.statusElement := ParseEnum(CODES_TFhirFamilyHistoryStatusEnum, SYSTEMS_TFhirFamilyHistoryStatusEnum, child, path+'/status')
      else if (child.localName = 'dataAbsentReason') then
        value.dataAbsentReason := ParseCodeableConcept(child, path+'/dataAbsentReason')
      else if (child.localName = 'patient') then
        value.patient := ParseReference(child, path+'/patient')
      else if (child.localName = 'date') then
        value.dateElement := ParseDateTime(child, path+'/date')
      else if (child.localName = 'name') then
        value.nameElement := ParseString(child, path+'/name')
      else if (child.localName = 'relationship') then
        value.relationship := ParseCodeableConcept(child, path+'/relationship')
      else if (child.localName = 'sex') then
        value.sex := ParseCodeableConcept(child, path+'/sex')
      else if (child.localName = 'bornPeriod') then
        value.born := ParsePeriod(child, path+'/bornPeriod')
      else if (child.localName = 'bornDate') then
        value.born := ParseDate(child, path+'/bornDate')
      else if (child.localName = 'bornString') then
        value.born := ParseString(child, path+'/bornString')
      else if (child.localName = 'ageAge') then
        value.age := ParseAge(child, path+'/ageAge')
      else if (child.localName = 'ageRange') then
        value.age := ParseRange(child, path+'/ageRange')
      else if (child.localName = 'ageString') then
        value.age := ParseString(child, path+'/ageString')
      else if (child.localName = 'estimatedAge') then
        value.estimatedAgeElement := ParseBoolean(child, path+'/estimatedAge')
      else if (child.localName = 'deceasedAge') then
        value.deceased := ParseAge(child, path+'/deceasedAge')
      else if (child.localName = 'deceasedRange') then
        value.deceased := ParseRange(child, path+'/deceasedRange')
      else if (child.localName = 'deceasedBoolean') then
        value.deceased := ParseBoolean(child, path+'/deceasedBoolean')
      else if (child.localName = 'deceasedDate') then
        value.deceased := ParseDate(child, path+'/deceasedDate')
      else if (child.localName = 'deceasedString') then
        value.deceased := ParseString(child, path+'/deceasedString')
      else if (child.localName = 'reason') then
        value.reasonList.Add(ParseCodeableReference(child, path+'/reason'))
      else if (child.localName = 'note') then
        value.noteList.Add(ParseAnnotation(child, path+'/note'))
      else if (child.localName = 'condition') then
        value.conditionList.Add(ParseFamilyMemberHistoryCondition(child, path+'/condition'))
      else if (child.localName = 'procedure') then
        value.procedure_List.Add(ParseFamilyMemberHistoryProcedure(child, path+'/procedure'))
      else if Not ParseDomainResourceChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeFamilyMemberHistory(xml : TXmlBuilder; name : String; value : TFhirFamilyMemberHistory);
begin
  if (value = nil) then
    exit;
  composeDomainResourceAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeFamilyMemberHistoryChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeFamilyMemberHistoryChildren(xml : TXmlBuilder; value : TFhirFamilyMemberHistory);
var
  i : integer;
begin
  composeDomainResourceChildren(xml, value);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.identifierList.Count - 1 do
      ComposeIdentifier(xml, 'identifier', value.identifierList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.instantiatesCanonicalList.Count - 1 do
      ComposeCanonical(xml, 'instantiatesCanonical', value.instantiatesCanonicalList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.instantiatesUriList.Count - 1 do
      ComposeUri(xml, 'instantiatesUri', value.instantiatesUriList[i]);
  ComposeEnum(xml, 'status', value.statusElement, CODES_TFhirFamilyHistoryStatusEnum);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(xml, 'dataAbsentReason', value.dataAbsentReason);
  ComposeReference(xml, 'patient', value.patient);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDateTime(xml, 'date', value.dateElement);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(xml, 'name', value.nameElement);
  ComposeCodeableConcept(xml, 'relationship', value.relationship);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(xml, 'sex', value.sex);
  if (SummaryOption in [soFull, soData]) and (value.born is TFhirPeriod) {6} then
    ComposePeriod(xml, 'bornPeriod', TFhirPeriod(value.born))
  else if (SummaryOption in [soFull, soData]) and (value.born is TFhirDate) {6} then
    ComposeDate(xml, 'bornDate', TFhirDate(value.born))
  else if (SummaryOption in [soFull, soData]) and (value.born is TFhirString) {6} then
    ComposeString(xml, 'bornString', TFhirString(value.born));
  if (SummaryOption in [soFull, soSummary, soData]) and (value.age is TFhirAge) {6} then
    ComposeAge(xml, 'ageAge', TFhirAge(value.age))
  else if (SummaryOption in [soFull, soSummary, soData]) and (value.age is TFhirRange) {6} then
    ComposeRange(xml, 'ageRange', TFhirRange(value.age))
  else if (SummaryOption in [soFull, soSummary, soData]) and (value.age is TFhirString) {6} then
    ComposeString(xml, 'ageString', TFhirString(value.age));
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeBoolean(xml, 'estimatedAge', value.estimatedAgeElement);
  if (SummaryOption in [soFull, soSummary, soData]) and (value.deceased is TFhirAge) {6} then
    ComposeAge(xml, 'deceasedAge', TFhirAge(value.deceased))
  else if (SummaryOption in [soFull, soSummary, soData]) and (value.deceased is TFhirRange) {6} then
    ComposeRange(xml, 'deceasedRange', TFhirRange(value.deceased))
  else if (SummaryOption in [soFull, soSummary, soData]) and (value.deceased is TFhirBoolean) {6} then
    ComposeBoolean(xml, 'deceasedBoolean', TFhirBoolean(value.deceased))
  else if (SummaryOption in [soFull, soSummary, soData]) and (value.deceased is TFhirDate) {6} then
    ComposeDate(xml, 'deceasedDate', TFhirDate(value.deceased))
  else if (SummaryOption in [soFull, soSummary, soData]) and (value.deceased is TFhirString) {6} then
    ComposeString(xml, 'deceasedString', TFhirString(value.deceased));
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.reasonList.Count - 1 do
      ComposeCodeableReference(xml, 'reason', value.reasonList[i]);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.noteList.Count - 1 do
      ComposeAnnotation(xml, 'note', value.noteList[i]);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.conditionList.Count - 1 do
      ComposeFamilyMemberHistoryCondition(xml, 'condition', value.conditionList[i]);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.procedure_List.Count - 1 do
      ComposeFamilyMemberHistoryProcedure(xml, 'procedure', value.procedure_List[i]);
end;

{$ENDIF FHIR_FAMILYMEMBERHISTORY}
{$IFDEF FHIR_FLAG}
function TFHIRXmlParser.ParseFlag(element : TMXmlElement; path : string) : TFhirFlag;
var
  child : TMXmlElement;
begin
  result := TFhirFlag.Create;
  try
    parseDomainResourceAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseFlagChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseFlagChild(value : TFhirFlag; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'identifier') then
        value.identifierList.Add(ParseIdentifier(child, path+'/identifier'))
      else if (child.localName = 'status') then
        value.statusElement := ParseEnum(CODES_TFhirFlagStatusEnum, SYSTEMS_TFhirFlagStatusEnum, child, path+'/status')
      else if (child.localName = 'category') then
        value.categoryList.Add(ParseCodeableConcept(child, path+'/category'))
      else if (child.localName = 'code') then
        value.code := ParseCodeableConcept(child, path+'/code')
      else if (child.localName = 'subject') then
        value.subject := ParseReference(child, path+'/subject')
      else if (child.localName = 'period') then
        value.period := ParsePeriod(child, path+'/period')
      else if (child.localName = 'encounter') then
        value.encounter := ParseReference(child, path+'/encounter')
      else if (child.localName = 'author') then
        value.author := ParseReference(child, path+'/author')
      else if Not ParseDomainResourceChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeFlag(xml : TXmlBuilder; name : String; value : TFhirFlag);
begin
  if (value = nil) then
    exit;
  composeDomainResourceAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeFlagChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeFlagChildren(xml : TXmlBuilder; value : TFhirFlag);
var
  i : integer;
begin
  composeDomainResourceChildren(xml, value);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.identifierList.Count - 1 do
      ComposeIdentifier(xml, 'identifier', value.identifierList[i]);
  ComposeEnum(xml, 'status', value.statusElement, CODES_TFhirFlagStatusEnum);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.categoryList.Count - 1 do
      ComposeCodeableConcept(xml, 'category', value.categoryList[i]);
  ComposeCodeableConcept(xml, 'code', value.code);
  ComposeReference(xml, 'subject', value.subject);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposePeriod(xml, 'period', value.period);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference(xml, 'encounter', value.encounter);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference(xml, 'author', value.author);
end;

{$ENDIF FHIR_FLAG}
{$IFDEF FHIR_FORMULARYITEM}
function TFHIRXmlParser.ParseFormularyItem(element : TMXmlElement; path : string) : TFhirFormularyItem;
var
  child : TMXmlElement;
begin
  result := TFhirFormularyItem.Create;
  try
    parseDomainResourceAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseFormularyItemChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseFormularyItemChild(value : TFhirFormularyItem; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'identifier') then
        value.identifierList.Add(ParseIdentifier(child, path+'/identifier'))
      else if (child.localName = 'code') then
        value.code := ParseCodeableConcept(child, path+'/code')
      else if (child.localName = 'status') then
        value.statusElement := ParseEnum(CODES_TFhirFormularyItemStatusCodesEnum, SYSTEMS_TFhirFormularyItemStatusCodesEnum, child, path+'/status')
      else if Not ParseDomainResourceChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeFormularyItem(xml : TXmlBuilder; name : String; value : TFhirFormularyItem);
begin
  if (value = nil) then
    exit;
  composeDomainResourceAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeFormularyItemChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeFormularyItemChildren(xml : TXmlBuilder; value : TFhirFormularyItem);
var
  i : integer;
begin
  composeDomainResourceChildren(xml, value);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.identifierList.Count - 1 do
      ComposeIdentifier(xml, 'identifier', value.identifierList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(xml, 'code', value.code);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeEnum(xml, 'status', value.statusElement, CODES_TFhirFormularyItemStatusCodesEnum);
end;

{$ENDIF FHIR_FORMULARYITEM}
{$IFDEF FHIR_GENOMICSTUDY}
function TFHIRXmlParser.ParseGenomicStudyAnalysis(element : TMXmlElement; path : string) : TFhirGenomicStudyAnalysis;
var
  child : TMXmlElement;
begin
  result := TFhirGenomicStudyAnalysis.Create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseGenomicStudyAnalysisChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseGenomicStudyAnalysisChild(value : TFhirGenomicStudyAnalysis; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'identifier') then
        value.identifierList.Add(ParseIdentifier(child, path+'/identifier'))
      else if (child.localName = 'methodType') then
        value.methodTypeList.Add(ParseCodeableConcept(child, path+'/methodType'))
      else if (child.localName = 'changeType') then
        value.changeTypeList.Add(ParseCodeableConcept(child, path+'/changeType'))
      else if (child.localName = 'genomeBuild') then
        value.genomeBuild := ParseCodeableConcept(child, path+'/genomeBuild')
      else if (child.localName = 'instantiatesCanonical') then
        value.instantiatesCanonicalElement := ParseCanonical(child, path+'/instantiatesCanonical')
      else if (child.localName = 'instantiatesUri') then
        value.instantiatesUriElement := ParseUri(child, path+'/instantiatesUri')
      else if (child.localName = 'title') then
        value.titleElement := ParseString(child, path+'/title')
      else if (child.localName = 'subject') then
        value.subject := ParseReference(child, path+'/subject')
      else if (child.localName = 'specimen') then
        value.specimenList.Add(ParseReference(child, path+'/specimen'))
      else if (child.localName = 'date') then
        value.dateElement := ParseDateTime(child, path+'/date')
      else if (child.localName = 'note') then
        value.noteList.Add(ParseAnnotation(child, path+'/note'))
      else if (child.localName = 'protocolPerformed') then
        value.protocolPerformed := ParseReference(child, path+'/protocolPerformed')
      else if (child.localName = 'regionsStudied') then
        value.regionsStudiedList.Add(ParseReference(child, path+'/regionsStudied'))
      else if (child.localName = 'regionsCalled') then
        value.regionsCalledList.Add(ParseReference(child, path+'/regionsCalled'))
      else if (child.localName = 'input') then
        value.inputList.Add(ParseGenomicStudyAnalysisInput(child, path+'/input'))
      else if (child.localName = 'output') then
        value.outputList.Add(ParseGenomicStudyAnalysisOutput(child, path+'/output'))
      else if (child.localName = 'performer') then
        value.performerList.Add(ParseGenomicStudyAnalysisPerformer(child, path+'/performer'))
      else if (child.localName = 'device') then
        value.deviceList.Add(ParseGenomicStudyAnalysisDevice(child, path+'/device'))
      else if Not ParseBackboneElementChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeGenomicStudyAnalysis(xml : TXmlBuilder; name : String; value : TFhirGenomicStudyAnalysis);
begin
  if (value = nil) then
    exit;
  composeElementAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeGenomicStudyAnalysisChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeGenomicStudyAnalysisChildren(xml : TXmlBuilder; value : TFhirGenomicStudyAnalysis);
var
  i : integer;
begin
  composeBackboneElementChildren(xml, value);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.identifierList.Count - 1 do
      ComposeIdentifier(xml, 'identifier', value.identifierList[i]);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.methodTypeList.Count - 1 do
      ComposeCodeableConcept(xml, 'methodType', value.methodTypeList[i]);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.changeTypeList.Count - 1 do
      ComposeCodeableConcept(xml, 'changeType', value.changeTypeList[i]);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(xml, 'genomeBuild', value.genomeBuild);
  if (SummaryOption in [soFull, soData]) then
    ComposeCanonical(xml, 'instantiatesCanonical', value.instantiatesCanonicalElement);
  if (SummaryOption in [soFull, soData]) then
    ComposeUri(xml, 'instantiatesUri', value.instantiatesUriElement);
  if (SummaryOption in [soFull, soData]) then
    ComposeString(xml, 'title', value.titleElement);
  if (SummaryOption in [soFull, soData]) then
    ComposeReference(xml, 'subject', value.subject);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.specimenList.Count - 1 do
      ComposeReference(xml, 'specimen', value.specimenList[i]);
  if (SummaryOption in [soFull, soData]) then
    ComposeDateTime(xml, 'date', value.dateElement);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.noteList.Count - 1 do
      ComposeAnnotation(xml, 'note', value.noteList[i]);
  if (SummaryOption in [soFull, soData]) then
    ComposeReference(xml, 'protocolPerformed', value.protocolPerformed);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.regionsStudiedList.Count - 1 do
      ComposeReference(xml, 'regionsStudied', value.regionsStudiedList[i]);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.regionsCalledList.Count - 1 do
      ComposeReference(xml, 'regionsCalled', value.regionsCalledList[i]);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.inputList.Count - 1 do
      ComposeGenomicStudyAnalysisInput(xml, 'input', value.inputList[i]);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.outputList.Count - 1 do
      ComposeGenomicStudyAnalysisOutput(xml, 'output', value.outputList[i]);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.performerList.Count - 1 do
      ComposeGenomicStudyAnalysisPerformer(xml, 'performer', value.performerList[i]);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.deviceList.Count - 1 do
      ComposeGenomicStudyAnalysisDevice(xml, 'device', value.deviceList[i]);
end;

function TFHIRXmlParser.ParseGenomicStudyAnalysisInput(element : TMXmlElement; path : string) : TFhirGenomicStudyAnalysisInput;
var
  child : TMXmlElement;
begin
  result := TFhirGenomicStudyAnalysisInput.Create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseGenomicStudyAnalysisInputChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseGenomicStudyAnalysisInputChild(value : TFhirGenomicStudyAnalysisInput; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'file') then
        value.file_ := ParseReference(child, path+'/file')
      else if (child.localName = 'type') then
        value.type_ := ParseCodeableConcept(child, path+'/type')
      else if (child.localName = 'generatedByIdentifier') then
        value.generatedBy := ParseIdentifier(child, path+'/generatedByIdentifier')
      else if (child.localName = 'generatedByReference') then
        value.generatedBy := ParseReference(child, path+'/generatedByReference')
      else if Not ParseBackboneElementChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeGenomicStudyAnalysisInput(xml : TXmlBuilder; name : String; value : TFhirGenomicStudyAnalysisInput);
begin
  if (value = nil) then
    exit;
  composeElementAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeGenomicStudyAnalysisInputChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeGenomicStudyAnalysisInputChildren(xml : TXmlBuilder; value : TFhirGenomicStudyAnalysisInput);
begin
  composeBackboneElementChildren(xml, value);
  if (SummaryOption in [soFull, soData]) then
    ComposeReference(xml, 'file', value.file_);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(xml, 'type', value.type_);
  if (SummaryOption in [soFull, soData]) and (value.generatedBy is TFhirIdentifier) {6} then
    ComposeIdentifier(xml, 'generatedByIdentifier', TFhirIdentifier(value.generatedBy))
  else if (SummaryOption in [soFull, soData]) and (value.generatedBy is TFhirReference) {2} then
    ComposeReference(xml, 'generatedByReference', TFhirReference(value.generatedBy));
end;

function TFHIRXmlParser.ParseGenomicStudyAnalysisOutput(element : TMXmlElement; path : string) : TFhirGenomicStudyAnalysisOutput;
var
  child : TMXmlElement;
begin
  result := TFhirGenomicStudyAnalysisOutput.Create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseGenomicStudyAnalysisOutputChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseGenomicStudyAnalysisOutputChild(value : TFhirGenomicStudyAnalysisOutput; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'file') then
        value.file_ := ParseReference(child, path+'/file')
      else if (child.localName = 'type') then
        value.type_ := ParseCodeableConcept(child, path+'/type')
      else if Not ParseBackboneElementChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeGenomicStudyAnalysisOutput(xml : TXmlBuilder; name : String; value : TFhirGenomicStudyAnalysisOutput);
begin
  if (value = nil) then
    exit;
  composeElementAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeGenomicStudyAnalysisOutputChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeGenomicStudyAnalysisOutputChildren(xml : TXmlBuilder; value : TFhirGenomicStudyAnalysisOutput);
begin
  composeBackboneElementChildren(xml, value);
  if (SummaryOption in [soFull, soData]) then
    ComposeReference(xml, 'file', value.file_);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(xml, 'type', value.type_);
end;

function TFHIRXmlParser.ParseGenomicStudyAnalysisPerformer(element : TMXmlElement; path : string) : TFhirGenomicStudyAnalysisPerformer;
var
  child : TMXmlElement;
begin
  result := TFhirGenomicStudyAnalysisPerformer.Create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseGenomicStudyAnalysisPerformerChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseGenomicStudyAnalysisPerformerChild(value : TFhirGenomicStudyAnalysisPerformer; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'actor') then
        value.actor := ParseReference(child, path+'/actor')
      else if (child.localName = 'role') then
        value.role := ParseCodeableConcept(child, path+'/role')
      else if Not ParseBackboneElementChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeGenomicStudyAnalysisPerformer(xml : TXmlBuilder; name : String; value : TFhirGenomicStudyAnalysisPerformer);
begin
  if (value = nil) then
    exit;
  composeElementAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeGenomicStudyAnalysisPerformerChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeGenomicStudyAnalysisPerformerChildren(xml : TXmlBuilder; value : TFhirGenomicStudyAnalysisPerformer);
begin
  composeBackboneElementChildren(xml, value);
  if (SummaryOption in [soFull, soData]) then
    ComposeReference(xml, 'actor', value.actor);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(xml, 'role', value.role);
end;

function TFHIRXmlParser.ParseGenomicStudyAnalysisDevice(element : TMXmlElement; path : string) : TFhirGenomicStudyAnalysisDevice;
var
  child : TMXmlElement;
begin
  result := TFhirGenomicStudyAnalysisDevice.Create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseGenomicStudyAnalysisDeviceChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseGenomicStudyAnalysisDeviceChild(value : TFhirGenomicStudyAnalysisDevice; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'device') then
        value.device := ParseReference(child, path+'/device')
      else if (child.localName = 'function') then
        value.function_ := ParseCodeableConcept(child, path+'/function')
      else if Not ParseBackboneElementChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeGenomicStudyAnalysisDevice(xml : TXmlBuilder; name : String; value : TFhirGenomicStudyAnalysisDevice);
begin
  if (value = nil) then
    exit;
  composeElementAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeGenomicStudyAnalysisDeviceChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeGenomicStudyAnalysisDeviceChildren(xml : TXmlBuilder; value : TFhirGenomicStudyAnalysisDevice);
begin
  composeBackboneElementChildren(xml, value);
  if (SummaryOption in [soFull, soData]) then
    ComposeReference(xml, 'device', value.device);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(xml, 'function', value.function_);
end;

function TFHIRXmlParser.ParseGenomicStudy(element : TMXmlElement; path : string) : TFhirGenomicStudy;
var
  child : TMXmlElement;
begin
  result := TFhirGenomicStudy.Create;
  try
    parseDomainResourceAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseGenomicStudyChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseGenomicStudyChild(value : TFhirGenomicStudy; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'identifier') then
        value.identifierList.Add(ParseIdentifier(child, path+'/identifier'))
      else if (child.localName = 'status') then
        value.status := ParseCodeableConcept(child, path+'/status')
      else if (child.localName = 'type') then
        value.type_List.Add(ParseCodeableConcept(child, path+'/type'))
      else if (child.localName = 'subject') then
        value.subject := ParseReference(child, path+'/subject')
      else if (child.localName = 'encounter') then
        value.encounter := ParseReference(child, path+'/encounter')
      else if (child.localName = 'startDate') then
        value.startDateElement := ParseDateTime(child, path+'/startDate')
      else if (child.localName = 'basedOn') then
        value.basedOnList.Add(ParseReference(child, path+'/basedOn'))
      else if (child.localName = 'referrer') then
        value.referrer := ParseReference(child, path+'/referrer')
      else if (child.localName = 'interpreter') then
        value.interpreterList.Add(ParseReference(child, path+'/interpreter'))
      else if (child.localName = 'reason') then
        value.reasonList.Add(ParseCodeableReference(child, path+'/reason'))
      else if (child.localName = 'instantiatesCanonical') then
        value.instantiatesCanonicalElement := ParseCanonical(child, path+'/instantiatesCanonical')
      else if (child.localName = 'instantiatesUri') then
        value.instantiatesUriElement := ParseUri(child, path+'/instantiatesUri')
      else if (child.localName = 'note') then
        value.noteList.Add(ParseAnnotation(child, path+'/note'))
      else if (child.localName = 'description') then
        value.descriptionElement := ParseString(child, path+'/description')
      else if (child.localName = 'analysis') then
        value.analysisList.Add(ParseGenomicStudyAnalysis(child, path+'/analysis'))
      else if Not ParseDomainResourceChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeGenomicStudy(xml : TXmlBuilder; name : String; value : TFhirGenomicStudy);
begin
  if (value = nil) then
    exit;
  composeDomainResourceAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeGenomicStudyChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeGenomicStudyChildren(xml : TXmlBuilder; value : TFhirGenomicStudy);
var
  i : integer;
begin
  composeDomainResourceChildren(xml, value);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.identifierList.Count - 1 do
      ComposeIdentifier(xml, 'identifier', value.identifierList[i]);
  ComposeCodeableConcept(xml, 'status', value.status);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.type_List.Count - 1 do
      ComposeCodeableConcept(xml, 'type', value.type_List[i]);
  ComposeReference(xml, 'subject', value.subject);
  if (SummaryOption in [soFull, soData]) then
    ComposeReference(xml, 'encounter', value.encounter);
  if (SummaryOption in [soFull, soData]) then
    ComposeDateTime(xml, 'startDate', value.startDateElement);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.basedOnList.Count - 1 do
      ComposeReference(xml, 'basedOn', value.basedOnList[i]);
  if (SummaryOption in [soFull, soData]) then
    ComposeReference(xml, 'referrer', value.referrer);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.interpreterList.Count - 1 do
      ComposeReference(xml, 'interpreter', value.interpreterList[i]);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.reasonList.Count - 1 do
      ComposeCodeableReference(xml, 'reason', value.reasonList[i]);
  if (SummaryOption in [soFull, soData]) then
    ComposeCanonical(xml, 'instantiatesCanonical', value.instantiatesCanonicalElement);
  if (SummaryOption in [soFull, soData]) then
    ComposeUri(xml, 'instantiatesUri', value.instantiatesUriElement);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.noteList.Count - 1 do
      ComposeAnnotation(xml, 'note', value.noteList[i]);
  if (SummaryOption in [soFull, soData]) then
    ComposeString(xml, 'description', value.descriptionElement);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.analysisList.Count - 1 do
      ComposeGenomicStudyAnalysis(xml, 'analysis', value.analysisList[i]);
end;

{$ENDIF FHIR_GENOMICSTUDY}
{$IFDEF FHIR_GOAL}
function TFHIRXmlParser.ParseGoalTarget(element : TMXmlElement; path : string) : TFhirGoalTarget;
var
  child : TMXmlElement;
begin
  result := TFhirGoalTarget.Create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseGoalTargetChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseGoalTargetChild(value : TFhirGoalTarget; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'measure') then
        value.measure := ParseCodeableConcept(child, path+'/measure')
      else if (child.localName = 'detailQuantity') then
        value.detail := ParseQuantity(child, path+'/detailQuantity')
      else if (child.localName = 'detailRange') then
        value.detail := ParseRange(child, path+'/detailRange')
      else if (child.localName = 'detailCodeableConcept') then
        value.detail := ParseCodeableConcept(child, path+'/detailCodeableConcept')
      else if (child.localName = 'detailRatio') then
        value.detail := ParseRatio(child, path+'/detailRatio')
      else if (child.localName = 'detailString') then
        value.detail := ParseString(child, path+'/detailString')
      else if (child.localName = 'detailBoolean') then
        value.detail := ParseBoolean(child, path+'/detailBoolean')
      else if (child.localName = 'detailInteger') then
        value.detail := ParseInteger(child, path+'/detailInteger')
      else if (child.localName = 'dueDuration') then
        value.due := ParseDuration(child, path+'/dueDuration')
      else if (child.localName = 'dueDate') then
        value.due := ParseDate(child, path+'/dueDate')
      else if Not ParseBackboneElementChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeGoalTarget(xml : TXmlBuilder; name : String; value : TFhirGoalTarget);
begin
  if (value = nil) then
    exit;
  composeElementAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeGoalTargetChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeGoalTargetChildren(xml : TXmlBuilder; value : TFhirGoalTarget);
begin
  composeBackboneElementChildren(xml, value);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(xml, 'measure', value.measure);
  if (SummaryOption in [soFull, soSummary, soData]) and (value.detail is TFhirQuantity) {6} then
    ComposeQuantity(xml, 'detailQuantity', TFhirQuantity(value.detail))
  else if (SummaryOption in [soFull, soSummary, soData]) and (value.detail is TFhirRange) {6} then
    ComposeRange(xml, 'detailRange', TFhirRange(value.detail))
  else if (SummaryOption in [soFull, soSummary, soData]) and (value.detail is TFhirCodeableConcept) {6} then
    ComposeCodeableConcept(xml, 'detailCodeableConcept', TFhirCodeableConcept(value.detail))
  else if (SummaryOption in [soFull, soSummary, soData]) and (value.detail is TFhirRatio) {6} then
    ComposeRatio(xml, 'detailRatio', TFhirRatio(value.detail))
  else if (SummaryOption in [soFull, soSummary, soData]) and (value.detail is TFhirString) {6} then
    ComposeString(xml, 'detailString', TFhirString(value.detail))
  else if (SummaryOption in [soFull, soSummary, soData]) and (value.detail is TFhirBoolean) {6} then
    ComposeBoolean(xml, 'detailBoolean', TFhirBoolean(value.detail))
  else if (SummaryOption in [soFull, soSummary, soData]) and (value.detail is TFhirInteger) {6} then
    ComposeInteger(xml, 'detailInteger', TFhirInteger(value.detail));
  if (SummaryOption in [soFull, soSummary, soData]) and (value.due is TFhirDuration) {6} then
    ComposeDuration(xml, 'dueDuration', TFhirDuration(value.due))
  else if (SummaryOption in [soFull, soSummary, soData]) and (value.due is TFhirDate) {6} then
    ComposeDate(xml, 'dueDate', TFhirDate(value.due));
end;

function TFHIRXmlParser.ParseGoal(element : TMXmlElement; path : string) : TFhirGoal;
var
  child : TMXmlElement;
begin
  result := TFhirGoal.Create;
  try
    parseDomainResourceAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseGoalChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseGoalChild(value : TFhirGoal; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'identifier') then
        value.identifierList.Add(ParseIdentifier(child, path+'/identifier'))
      else if (child.localName = 'lifecycleStatus') then
        value.lifecycleStatusElement := ParseEnum(CODES_TFhirGoalLifecycleStatusEnum, SYSTEMS_TFhirGoalLifecycleStatusEnum, child, path+'/lifecycleStatus')
      else if (child.localName = 'achievementStatus') then
        value.achievementStatus := ParseCodeableConcept(child, path+'/achievementStatus')
      else if (child.localName = 'category') then
        value.categoryList.Add(ParseCodeableConcept(child, path+'/category'))
      else if (child.localName = 'continuous') then
        value.continuousElement := ParseBoolean(child, path+'/continuous')
      else if (child.localName = 'priority') then
        value.priority := ParseCodeableConcept(child, path+'/priority')
      else if (child.localName = 'description') then
        value.description := ParseCodeableConcept(child, path+'/description')
      else if (child.localName = 'subject') then
        value.subject := ParseReference(child, path+'/subject')
      else if (child.localName = 'startCodeableConcept') then
        value.start := ParseCodeableConcept(child, path+'/startCodeableConcept')
      else if (child.localName = 'startDate') then
        value.start := ParseDate(child, path+'/startDate')
      else if (child.localName = 'target') then
        value.targetList.Add(ParseGoalTarget(child, path+'/target'))
      else if (child.localName = 'statusDate') then
        value.statusDateElement := ParseDate(child, path+'/statusDate')
      else if (child.localName = 'statusReason') then
        value.statusReasonElement := ParseString(child, path+'/statusReason')
      else if (child.localName = 'source') then
        value.source := ParseReference(child, path+'/source')
      else if (child.localName = 'addresses') then
        value.addressesList.Add(ParseReference(child, path+'/addresses'))
      else if (child.localName = 'note') then
        value.noteList.Add(ParseAnnotation(child, path+'/note'))
      else if (child.localName = 'outcome') then
        value.outcomeList.Add(ParseCodeableReference(child, path+'/outcome'))
      else if Not ParseDomainResourceChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeGoal(xml : TXmlBuilder; name : String; value : TFhirGoal);
begin
  if (value = nil) then
    exit;
  composeDomainResourceAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeGoalChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeGoalChildren(xml : TXmlBuilder; value : TFhirGoal);
var
  i : integer;
begin
  composeDomainResourceChildren(xml, value);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.identifierList.Count - 1 do
      ComposeIdentifier(xml, 'identifier', value.identifierList[i]);
  ComposeEnum(xml, 'lifecycleStatus', value.lifecycleStatusElement, CODES_TFhirGoalLifecycleStatusEnum);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(xml, 'achievementStatus', value.achievementStatus);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.categoryList.Count - 1 do
      ComposeCodeableConcept(xml, 'category', value.categoryList[i]);
  if (SummaryOption in [soFull, soData]) then
    ComposeBoolean(xml, 'continuous', value.continuousElement);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(xml, 'priority', value.priority);
  ComposeCodeableConcept(xml, 'description', value.description);
  ComposeReference(xml, 'subject', value.subject);
  if (SummaryOption in [soFull, soSummary, soData]) and (value.start is TFhirCodeableConcept) {6} then
    ComposeCodeableConcept(xml, 'startCodeableConcept', TFhirCodeableConcept(value.start))
  else if (SummaryOption in [soFull, soSummary, soData]) and (value.start is TFhirDate) {6} then
    ComposeDate(xml, 'startDate', TFhirDate(value.start));
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.targetList.Count - 1 do
      ComposeGoalTarget(xml, 'target', value.targetList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDate(xml, 'statusDate', value.statusDateElement);
  if (SummaryOption in [soFull, soData]) then
    ComposeString(xml, 'statusReason', value.statusReasonElement);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference(xml, 'source', value.source);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.addressesList.Count - 1 do
      ComposeReference(xml, 'addresses', value.addressesList[i]);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.noteList.Count - 1 do
      ComposeAnnotation(xml, 'note', value.noteList[i]);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.outcomeList.Count - 1 do
      ComposeCodeableReference(xml, 'outcome', value.outcomeList[i]);
end;

{$ENDIF FHIR_GOAL}
{$IFDEF FHIR_GRAPHDEFINITION}
function TFHIRXmlParser.ParseGraphDefinitionLink(element : TMXmlElement; path : string) : TFhirGraphDefinitionLink;
var
  child : TMXmlElement;
begin
  result := TFhirGraphDefinitionLink.Create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseGraphDefinitionLinkChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseGraphDefinitionLinkChild(value : TFhirGraphDefinitionLink; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'path') then
        value.pathElement := ParseString(child, path+'/path')
      else if (child.localName = 'sliceName') then
        value.sliceNameElement := ParseString(child, path+'/sliceName')
      else if (child.localName = 'min') then
        value.minElement := ParseInteger(child, path+'/min')
      else if (child.localName = 'max') then
        value.maxElement := ParseString(child, path+'/max')
      else if (child.localName = 'description') then
        value.descriptionElement := ParseString(child, path+'/description')
      else if (child.localName = 'target') then
        value.targetList.Add(ParseGraphDefinitionLinkTarget(child, path+'/target'))
      else if Not ParseBackboneElementChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeGraphDefinitionLink(xml : TXmlBuilder; name : String; value : TFhirGraphDefinitionLink);
begin
  if (value = nil) then
    exit;
  composeElementAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeGraphDefinitionLinkChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeGraphDefinitionLinkChildren(xml : TXmlBuilder; value : TFhirGraphDefinitionLink);
var
  i : integer;
begin
  composeBackboneElementChildren(xml, value);
  if (SummaryOption in [soFull, soData]) then
    ComposeString(xml, 'path', value.pathElement);
  if (SummaryOption in [soFull, soData]) then
    ComposeString(xml, 'sliceName', value.sliceNameElement);
  if (SummaryOption in [soFull, soData]) then
    ComposeInteger(xml, 'min', value.minElement);
  if (SummaryOption in [soFull, soData]) then
    ComposeString(xml, 'max', value.maxElement);
  if (SummaryOption in [soFull, soData]) then
    ComposeString(xml, 'description', value.descriptionElement);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.targetList.Count - 1 do
      ComposeGraphDefinitionLinkTarget(xml, 'target', value.targetList[i]);
end;

function TFHIRXmlParser.ParseGraphDefinitionLinkTarget(element : TMXmlElement; path : string) : TFhirGraphDefinitionLinkTarget;
var
  child : TMXmlElement;
begin
  result := TFhirGraphDefinitionLinkTarget.Create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseGraphDefinitionLinkTargetChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseGraphDefinitionLinkTargetChild(value : TFhirGraphDefinitionLinkTarget; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'type') then
        value.type_Element := ParseEnum(CODES_TFhirAllResourceTypesEnum, SYSTEMS_TFhirAllResourceTypesEnum, child, path+'/type')
      else if (child.localName = 'params') then
        value.paramsElement := ParseString(child, path+'/params')
      else if (child.localName = 'profile') then
        value.profileElement := ParseCanonical(child, path+'/profile')
      else if (child.localName = 'compartment') then
        value.compartmentList.Add(ParseGraphDefinitionLinkTargetCompartment(child, path+'/compartment'))
      else if (child.localName = 'link') then
        value.link_List.Add(ParseGraphDefinitionLink(child, path+'/link'))
      else if Not ParseBackboneElementChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeGraphDefinitionLinkTarget(xml : TXmlBuilder; name : String; value : TFhirGraphDefinitionLinkTarget);
begin
  if (value = nil) then
    exit;
  composeElementAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeGraphDefinitionLinkTargetChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeGraphDefinitionLinkTargetChildren(xml : TXmlBuilder; value : TFhirGraphDefinitionLinkTarget);
var
  i : integer;
begin
  composeBackboneElementChildren(xml, value);
  ComposeEnum(xml, 'type', value.type_Element, CODES_TFhirAllResourceTypesEnum);
  if (SummaryOption in [soFull, soData]) then
    ComposeString(xml, 'params', value.paramsElement);
  if (SummaryOption in [soFull, soData]) then
    ComposeCanonical(xml, 'profile', value.profileElement);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.compartmentList.Count - 1 do
      ComposeGraphDefinitionLinkTargetCompartment(xml, 'compartment', value.compartmentList[i]);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.link_List.Count - 1 do
      ComposeGraphDefinitionLink(xml, 'link', value.link_List[i]);
end;

function TFHIRXmlParser.ParseGraphDefinitionLinkTargetCompartment(element : TMXmlElement; path : string) : TFhirGraphDefinitionLinkTargetCompartment;
var
  child : TMXmlElement;
begin
  result := TFhirGraphDefinitionLinkTargetCompartment.Create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseGraphDefinitionLinkTargetCompartmentChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseGraphDefinitionLinkTargetCompartmentChild(value : TFhirGraphDefinitionLinkTargetCompartment; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'use') then
        value.useElement := ParseEnum(CODES_TFhirGraphCompartmentUseEnum, SYSTEMS_TFhirGraphCompartmentUseEnum, child, path+'/use')
      else if (child.localName = 'code') then
        value.codeElement := ParseEnum(CODES_TFhirCompartmentTypeEnum, SYSTEMS_TFhirCompartmentTypeEnum, child, path+'/code')
      else if (child.localName = 'rule') then
        value.ruleElement := ParseEnum(CODES_TFhirGraphCompartmentRuleEnum, SYSTEMS_TFhirGraphCompartmentRuleEnum, child, path+'/rule')
      else if (child.localName = 'expression') then
        value.expressionElement := ParseString(child, path+'/expression')
      else if (child.localName = 'description') then
        value.descriptionElement := ParseString(child, path+'/description')
      else if Not ParseBackboneElementChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeGraphDefinitionLinkTargetCompartment(xml : TXmlBuilder; name : String; value : TFhirGraphDefinitionLinkTargetCompartment);
begin
  if (value = nil) then
    exit;
  composeElementAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeGraphDefinitionLinkTargetCompartmentChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeGraphDefinitionLinkTargetCompartmentChildren(xml : TXmlBuilder; value : TFhirGraphDefinitionLinkTargetCompartment);
begin
  composeBackboneElementChildren(xml, value);
  ComposeEnum(xml, 'use', value.useElement, CODES_TFhirGraphCompartmentUseEnum);
  ComposeEnum(xml, 'code', value.codeElement, CODES_TFhirCompartmentTypeEnum);
  ComposeEnum(xml, 'rule', value.ruleElement, CODES_TFhirGraphCompartmentRuleEnum);
  if (SummaryOption in [soFull, soData]) then
    ComposeString(xml, 'expression', value.expressionElement);
  if (SummaryOption in [soFull, soData]) then
    ComposeString(xml, 'description', value.descriptionElement);
end;

function TFHIRXmlParser.ParseGraphDefinition(element : TMXmlElement; path : string) : TFhirGraphDefinition;
var
  child : TMXmlElement;
begin
  result := TFhirGraphDefinition.Create;
  try
    parseCanonicalResourceAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseGraphDefinitionChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseGraphDefinitionChild(value : TFhirGraphDefinition; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'url') then
        value.urlElement := ParseUri(child, path+'/url')
      else if (child.localName = 'version') then
        value.versionElement := ParseString(child, path+'/version')
      else if (child.localName = 'versionAlgorithmCoding') then
        value.versionAlgorithm := ParseCoding(child, path+'/versionAlgorithmCoding')
      else if (child.localName = 'versionAlgorithmString') then
        value.versionAlgorithm := ParseString(child, path+'/versionAlgorithmString')
      else if (child.localName = 'name') then
        value.nameElement := ParseString(child, path+'/name')
      else if (child.localName = 'title') then
        value.titleElement := ParseString(child, path+'/title')
      else if (child.localName = 'status') then
        value.statusElement := ParseEnum(CODES_TFhirPublicationStatusEnum, SYSTEMS_TFhirPublicationStatusEnum, child, path+'/status')
      else if (child.localName = 'experimental') then
        value.experimentalElement := ParseBoolean(child, path+'/experimental')
      else if (child.localName = 'date') then
        value.dateElement := ParseDateTime(child, path+'/date')
      else if (child.localName = 'publisher') then
        value.publisherElement := ParseString(child, path+'/publisher')
      else if (child.localName = 'contact') then
        value.contactList.Add(ParseContactDetail(child, path+'/contact'))
      else if (child.localName = 'description') then
        value.descriptionElement := ParseMarkdown(child, path+'/description')
      else if (child.localName = 'useContext') then
        value.useContextList.Add(ParseUsageContext(child, path+'/useContext'))
      else if (child.localName = 'jurisdiction') then
        value.jurisdictionList.Add(ParseCodeableConcept(child, path+'/jurisdiction'))
      else if (child.localName = 'purpose') then
        value.purposeElement := ParseMarkdown(child, path+'/purpose')
      else if (child.localName = 'start') then
        value.startElement := ParseEnum(CODES_TFhirResourceTypesEnum, SYSTEMS_TFhirResourceTypesEnum, child, path+'/start')
      else if (child.localName = 'profile') then
        value.profileElement := ParseCanonical(child, path+'/profile')
      else if (child.localName = 'link') then
        value.link_List.Add(ParseGraphDefinitionLink(child, path+'/link'))
      else if Not ParseCanonicalResourceChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeGraphDefinition(xml : TXmlBuilder; name : String; value : TFhirGraphDefinition);
begin
  if (value = nil) then
    exit;
  composeCanonicalResourceAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeGraphDefinitionChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeGraphDefinitionChildren(xml : TXmlBuilder; value : TFhirGraphDefinition);
var
  i : integer;
begin
  composeCanonicalResourceChildren(xml, value);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeUri(xml, 'url', value.urlElement);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(xml, 'version', value.versionElement);
  if (SummaryOption in [soFull, soSummary, soData]) and (value.versionAlgorithm is TFhirCoding) {6} then
    ComposeCoding(xml, 'versionAlgorithmCoding', TFhirCoding(value.versionAlgorithm))
  else if (SummaryOption in [soFull, soSummary, soData]) and (value.versionAlgorithm is TFhirString) {6} then
    ComposeString(xml, 'versionAlgorithmString', TFhirString(value.versionAlgorithm));
  ComposeString(xml, 'name', value.nameElement);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(xml, 'title', value.titleElement);
  ComposeEnum(xml, 'status', value.statusElement, CODES_TFhirPublicationStatusEnum);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeBoolean(xml, 'experimental', value.experimentalElement);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDateTime(xml, 'date', value.dateElement);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(xml, 'publisher', value.publisherElement);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.contactList.Count - 1 do
      ComposeContactDetail(xml, 'contact', value.contactList[i]);
  if (SummaryOption in [soFull, soData]) then
    ComposeMarkdown(xml, 'description', value.descriptionElement);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.useContextList.Count - 1 do
      ComposeUsageContext(xml, 'useContext', value.useContextList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.jurisdictionList.Count - 1 do
      ComposeCodeableConcept(xml, 'jurisdiction', value.jurisdictionList[i]);
  if (SummaryOption in [soFull, soData]) then
    ComposeMarkdown(xml, 'purpose', value.purposeElement);
  ComposeEnum(xml, 'start', value.startElement, CODES_TFhirResourceTypesEnum);
  if (SummaryOption in [soFull, soData]) then
    ComposeCanonical(xml, 'profile', value.profileElement);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.link_List.Count - 1 do
      ComposeGraphDefinitionLink(xml, 'link', value.link_List[i]);
end;

{$ENDIF FHIR_GRAPHDEFINITION}
{$IFDEF FHIR_GROUP}
function TFHIRXmlParser.ParseGroupCharacteristic(element : TMXmlElement; path : string) : TFhirGroupCharacteristic;
var
  child : TMXmlElement;
begin
  result := TFhirGroupCharacteristic.Create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseGroupCharacteristicChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseGroupCharacteristicChild(value : TFhirGroupCharacteristic; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'code') then
        value.code := ParseCodeableConcept(child, path+'/code')
      else if (child.localName = 'valueCodeableConcept') then
        value.value := ParseCodeableConcept(child, path+'/valueCodeableConcept')
      else if (child.localName = 'valueQuantity') then
        value.value := ParseQuantity(child, path+'/valueQuantity')
      else if (child.localName = 'valueRange') then
        value.value := ParseRange(child, path+'/valueRange')
      else if (child.localName = 'valueReference') then
        value.value := ParseReference(child, path+'/valueReference')
      else if (child.localName = 'valueBoolean') then
        value.value := ParseBoolean(child, path+'/valueBoolean')
      else if (child.localName = 'exclude') then
        value.excludeElement := ParseBoolean(child, path+'/exclude')
      else if (child.localName = 'period') then
        value.period := ParsePeriod(child, path+'/period')
      else if Not ParseBackboneElementChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeGroupCharacteristic(xml : TXmlBuilder; name : String; value : TFhirGroupCharacteristic);
begin
  if (value = nil) then
    exit;
  composeElementAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeGroupCharacteristicChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeGroupCharacteristicChildren(xml : TXmlBuilder; value : TFhirGroupCharacteristic);
begin
  composeBackboneElementChildren(xml, value);
  ComposeCodeableConcept(xml, 'code', value.code);
  if (value.value is TFhirCodeableConcept) {6} then
    ComposeCodeableConcept(xml, 'valueCodeableConcept', TFhirCodeableConcept(value.value))
  else if (value.value is TFhirQuantity) {6} then
    ComposeQuantity(xml, 'valueQuantity', TFhirQuantity(value.value))
  else if (value.value is TFhirRange) {6} then
    ComposeRange(xml, 'valueRange', TFhirRange(value.value))
  else if (value.value is TFhirReference) {6} then
    ComposeReference(xml, 'valueReference', TFhirReference(value.value))
  else if (value.value is TFhirBoolean) {6} then
    ComposeBoolean(xml, 'valueBoolean', TFhirBoolean(value.value));
  ComposeBoolean(xml, 'exclude', value.excludeElement);
  if (SummaryOption in [soFull, soData]) then
    ComposePeriod(xml, 'period', value.period);
end;

function TFHIRXmlParser.ParseGroupMember(element : TMXmlElement; path : string) : TFhirGroupMember;
var
  child : TMXmlElement;
begin
  result := TFhirGroupMember.Create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseGroupMemberChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseGroupMemberChild(value : TFhirGroupMember; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'entity') then
        value.entity := ParseReference(child, path+'/entity')
      else if (child.localName = 'period') then
        value.period := ParsePeriod(child, path+'/period')
      else if (child.localName = 'inactive') then
        value.inactiveElement := ParseBoolean(child, path+'/inactive')
      else if Not ParseBackboneElementChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeGroupMember(xml : TXmlBuilder; name : String; value : TFhirGroupMember);
begin
  if (value = nil) then
    exit;
  composeElementAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeGroupMemberChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeGroupMemberChildren(xml : TXmlBuilder; value : TFhirGroupMember);
begin
  composeBackboneElementChildren(xml, value);
  ComposeReference(xml, 'entity', value.entity);
  if (SummaryOption in [soFull, soData]) then
    ComposePeriod(xml, 'period', value.period);
  if (SummaryOption in [soFull, soData]) then
    ComposeBoolean(xml, 'inactive', value.inactiveElement);
end;

function TFHIRXmlParser.ParseGroup(element : TMXmlElement; path : string) : TFhirGroup;
var
  child : TMXmlElement;
begin
  result := TFhirGroup.Create;
  try
    parseDomainResourceAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseGroupChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseGroupChild(value : TFhirGroup; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'identifier') then
        value.identifierList.Add(ParseIdentifier(child, path+'/identifier'))
      else if (child.localName = 'active') then
        value.activeElement := ParseBoolean(child, path+'/active')
      else if (child.localName = 'type') then
        value.type_Element := ParseEnum(CODES_TFhirGroupTypeEnum, SYSTEMS_TFhirGroupTypeEnum, child, path+'/type')
      else if (child.localName = 'membership') then
        value.membershipElement := ParseEnum(CODES_TFhirGroupMembershipBasisEnum, SYSTEMS_TFhirGroupMembershipBasisEnum, child, path+'/membership')
      else if (child.localName = 'code') then
        value.code := ParseCodeableConcept(child, path+'/code')
      else if (child.localName = 'name') then
        value.nameElement := ParseString(child, path+'/name')
      else if (child.localName = 'description') then
        value.descriptionElement := ParseMarkdown(child, path+'/description')
      else if (child.localName = 'quantity') then
        value.quantityElement := ParseUnsignedInt(child, path+'/quantity')
      else if (child.localName = 'managingEntity') then
        value.managingEntity := ParseReference(child, path+'/managingEntity')
      else if (child.localName = 'characteristic') then
        value.characteristicList.Add(ParseGroupCharacteristic(child, path+'/characteristic'))
      else if (child.localName = 'member') then
        value.memberList.Add(ParseGroupMember(child, path+'/member'))
      else if Not ParseDomainResourceChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeGroup(xml : TXmlBuilder; name : String; value : TFhirGroup);
begin
  if (value = nil) then
    exit;
  composeDomainResourceAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeGroupChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeGroupChildren(xml : TXmlBuilder; value : TFhirGroup);
var
  i : integer;
begin
  composeDomainResourceChildren(xml, value);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.identifierList.Count - 1 do
      ComposeIdentifier(xml, 'identifier', value.identifierList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeBoolean(xml, 'active', value.activeElement);
  ComposeEnum(xml, 'type', value.type_Element, CODES_TFhirGroupTypeEnum);
  ComposeEnum(xml, 'membership', value.membershipElement, CODES_TFhirGroupMembershipBasisEnum);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(xml, 'code', value.code);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(xml, 'name', value.nameElement);
  if (SummaryOption in [soFull, soData]) then
    ComposeMarkdown(xml, 'description', value.descriptionElement);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeUnsignedInt(xml, 'quantity', value.quantityElement);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference(xml, 'managingEntity', value.managingEntity);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.characteristicList.Count - 1 do
      ComposeGroupCharacteristic(xml, 'characteristic', value.characteristicList[i]);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.memberList.Count - 1 do
      ComposeGroupMember(xml, 'member', value.memberList[i]);
end;

{$ENDIF FHIR_GROUP}
{$IFDEF FHIR_GUIDANCERESPONSE}
function TFHIRXmlParser.ParseGuidanceResponse(element : TMXmlElement; path : string) : TFhirGuidanceResponse;
var
  child : TMXmlElement;
begin
  result := TFhirGuidanceResponse.Create;
  try
    parseDomainResourceAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseGuidanceResponseChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseGuidanceResponseChild(value : TFhirGuidanceResponse; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'requestIdentifier') then
        value.requestIdentifier := ParseIdentifier(child, path+'/requestIdentifier')
      else if (child.localName = 'identifier') then
        value.identifierList.Add(ParseIdentifier(child, path+'/identifier'))
      else if (child.localName = 'moduleCanonical') then
        value.module := ParseCanonical(child, path+'/moduleCanonical')
      else if (child.localName = 'moduleCodeableConcept') then
        value.module := ParseCodeableConcept(child, path+'/moduleCodeableConcept')
      else if (child.localName = 'moduleUri') then
        value.module := ParseUri(child, path+'/moduleUri')
      else if (child.localName = 'status') then
        value.statusElement := ParseEnum(CODES_TFhirGuidanceResponseStatusEnum, SYSTEMS_TFhirGuidanceResponseStatusEnum, child, path+'/status')
      else if (child.localName = 'subject') then
        value.subject := ParseReference(child, path+'/subject')
      else if (child.localName = 'encounter') then
        value.encounter := ParseReference(child, path+'/encounter')
      else if (child.localName = 'occurrenceDateTime') then
        value.occurrenceDateTimeElement := ParseDateTime(child, path+'/occurrenceDateTime')
      else if (child.localName = 'performer') then
        value.performer := ParseReference(child, path+'/performer')
      else if (child.localName = 'reason') then
        value.reasonList.Add(ParseCodeableReference(child, path+'/reason'))
      else if (child.localName = 'note') then
        value.noteList.Add(ParseAnnotation(child, path+'/note'))
      else if (child.localName = 'evaluationMessage') then
        value.evaluationMessageList.Add(ParseReference(child, path+'/evaluationMessage'))
      else if (child.localName = 'outputParameters') then
        value.outputParameters := ParseReference(child, path+'/outputParameters')
      else if (child.localName = 'result') then
        value.result := ParseReference(child, path+'/result')
      else if (child.localName = 'dataRequirement') then
        value.dataRequirementList.Add(ParseDataRequirement(child, path+'/dataRequirement'))
      else if Not ParseDomainResourceChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeGuidanceResponse(xml : TXmlBuilder; name : String; value : TFhirGuidanceResponse);
begin
  if (value = nil) then
    exit;
  composeDomainResourceAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeGuidanceResponseChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeGuidanceResponseChildren(xml : TXmlBuilder; value : TFhirGuidanceResponse);
var
  i : integer;
begin
  composeDomainResourceChildren(xml, value);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeIdentifier(xml, 'requestIdentifier', value.requestIdentifier);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.identifierList.Count - 1 do
      ComposeIdentifier(xml, 'identifier', value.identifierList[i]);
  if (value.module is TFhirCanonical) {6} then
    ComposeCanonical(xml, 'moduleCanonical', TFhirCanonical(value.module))
  else if (value.module is TFhirCodeableConcept) {6} then
    ComposeCodeableConcept(xml, 'moduleCodeableConcept', TFhirCodeableConcept(value.module))
  else if (value.module is TFhirUri) {6} then
    ComposeUri(xml, 'moduleUri', TFhirUri(value.module));
  ComposeEnum(xml, 'status', value.statusElement, CODES_TFhirGuidanceResponseStatusEnum);
  if (SummaryOption in [soFull, soData]) then
    ComposeReference(xml, 'subject', value.subject);
  if (SummaryOption in [soFull, soData]) then
    ComposeReference(xml, 'encounter', value.encounter);
  if (SummaryOption in [soFull, soData]) then
    ComposeDateTime(xml, 'occurrenceDateTime', value.occurrenceDateTimeElement);
  if (SummaryOption in [soFull, soData]) then
    ComposeReference(xml, 'performer', value.performer);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.reasonList.Count - 1 do
      ComposeCodeableReference(xml, 'reason', value.reasonList[i]);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.noteList.Count - 1 do
      ComposeAnnotation(xml, 'note', value.noteList[i]);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.evaluationMessageList.Count - 1 do
      ComposeReference(xml, 'evaluationMessage', value.evaluationMessageList[i]);
  if (SummaryOption in [soFull, soData]) then
    ComposeReference(xml, 'outputParameters', value.outputParameters);
  if (SummaryOption in [soFull, soData]) then
    ComposeReference(xml, 'result', value.result);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.dataRequirementList.Count - 1 do
      ComposeDataRequirement(xml, 'dataRequirement', value.dataRequirementList[i]);
end;

{$ENDIF FHIR_GUIDANCERESPONSE}
{$IFDEF FHIR_HEALTHCARESERVICE}
function TFHIRXmlParser.ParseHealthcareServiceEligibility(element : TMXmlElement; path : string) : TFhirHealthcareServiceEligibility;
var
  child : TMXmlElement;
begin
  result := TFhirHealthcareServiceEligibility.Create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseHealthcareServiceEligibilityChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseHealthcareServiceEligibilityChild(value : TFhirHealthcareServiceEligibility; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'code') then
        value.code := ParseCodeableConcept(child, path+'/code')
      else if (child.localName = 'comment') then
        value.commentElement := ParseMarkdown(child, path+'/comment')
      else if Not ParseBackboneElementChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeHealthcareServiceEligibility(xml : TXmlBuilder; name : String; value : TFhirHealthcareServiceEligibility);
begin
  if (value = nil) then
    exit;
  composeElementAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeHealthcareServiceEligibilityChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeHealthcareServiceEligibilityChildren(xml : TXmlBuilder; value : TFhirHealthcareServiceEligibility);
begin
  composeBackboneElementChildren(xml, value);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(xml, 'code', value.code);
  if (SummaryOption in [soFull, soData]) then
    ComposeMarkdown(xml, 'comment', value.commentElement);
end;

function TFHIRXmlParser.ParseHealthcareService(element : TMXmlElement; path : string) : TFhirHealthcareService;
var
  child : TMXmlElement;
begin
  result := TFhirHealthcareService.Create;
  try
    parseDomainResourceAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseHealthcareServiceChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseHealthcareServiceChild(value : TFhirHealthcareService; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'identifier') then
        value.identifierList.Add(ParseIdentifier(child, path+'/identifier'))
      else if (child.localName = 'active') then
        value.activeElement := ParseBoolean(child, path+'/active')
      else if (child.localName = 'providedBy') then
        value.providedBy := ParseReference(child, path+'/providedBy')
      else if (child.localName = 'offeredIn') then
        value.offeredInList.Add(ParseReference(child, path+'/offeredIn'))
      else if (child.localName = 'category') then
        value.categoryList.Add(ParseCodeableConcept(child, path+'/category'))
      else if (child.localName = 'type') then
        value.type_List.Add(ParseCodeableConcept(child, path+'/type'))
      else if (child.localName = 'specialty') then
        value.specialtyList.Add(ParseCodeableConcept(child, path+'/specialty'))
      else if (child.localName = 'location') then
        value.locationList.Add(ParseReference(child, path+'/location'))
      else if (child.localName = 'name') then
        value.nameElement := ParseString(child, path+'/name')
      else if (child.localName = 'comment') then
        value.commentElement := ParseString(child, path+'/comment')
      else if (child.localName = 'extraDetails') then
        value.extraDetailsElement := ParseMarkdown(child, path+'/extraDetails')
      else if (child.localName = 'photo') then
        value.photo := ParseAttachment(child, path+'/photo')
      else if (child.localName = 'contact') then
        value.contactList.Add(ParseExtendedContactDetail(child, path+'/contact'))
      else if (child.localName = 'coverageArea') then
        value.coverageAreaList.Add(ParseReference(child, path+'/coverageArea'))
      else if (child.localName = 'serviceProvisionCode') then
        value.serviceProvisionCodeList.Add(ParseCodeableConcept(child, path+'/serviceProvisionCode'))
      else if (child.localName = 'eligibility') then
        value.eligibilityList.Add(ParseHealthcareServiceEligibility(child, path+'/eligibility'))
      else if (child.localName = 'program') then
        value.program_List.Add(ParseCodeableConcept(child, path+'/program'))
      else if (child.localName = 'characteristic') then
        value.characteristicList.Add(ParseCodeableConcept(child, path+'/characteristic'))
      else if (child.localName = 'communication') then
        value.communicationList.Add(ParseCodeableConcept(child, path+'/communication'))
      else if (child.localName = 'referralMethod') then
        value.referralMethodList.Add(ParseCodeableConcept(child, path+'/referralMethod'))
      else if (child.localName = 'appointmentRequired') then
        value.appointmentRequiredElement := ParseBoolean(child, path+'/appointmentRequired')
      else if (child.localName = 'availability') then
        value.availabilityList.Add(ParseAvailability(child, path+'/availability'))
      else if (child.localName = 'endpoint') then
        value.endpointList.Add(ParseReference(child, path+'/endpoint'))
      else if Not ParseDomainResourceChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeHealthcareService(xml : TXmlBuilder; name : String; value : TFhirHealthcareService);
begin
  if (value = nil) then
    exit;
  composeDomainResourceAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeHealthcareServiceChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeHealthcareServiceChildren(xml : TXmlBuilder; value : TFhirHealthcareService);
var
  i : integer;
begin
  composeDomainResourceChildren(xml, value);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.identifierList.Count - 1 do
      ComposeIdentifier(xml, 'identifier', value.identifierList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeBoolean(xml, 'active', value.activeElement);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference(xml, 'providedBy', value.providedBy);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.offeredInList.Count - 1 do
      ComposeReference(xml, 'offeredIn', value.offeredInList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.categoryList.Count - 1 do
      ComposeCodeableConcept(xml, 'category', value.categoryList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.type_List.Count - 1 do
      ComposeCodeableConcept(xml, 'type', value.type_List[i]);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.specialtyList.Count - 1 do
      ComposeCodeableConcept(xml, 'specialty', value.specialtyList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.locationList.Count - 1 do
      ComposeReference(xml, 'location', value.locationList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(xml, 'name', value.nameElement);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(xml, 'comment', value.commentElement);
  if (SummaryOption in [soFull, soData]) then
    ComposeMarkdown(xml, 'extraDetails', value.extraDetailsElement);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeAttachment(xml, 'photo', value.photo);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.contactList.Count - 1 do
      ComposeExtendedContactDetail(xml, 'contact', value.contactList[i]);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.coverageAreaList.Count - 1 do
      ComposeReference(xml, 'coverageArea', value.coverageAreaList[i]);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.serviceProvisionCodeList.Count - 1 do
      ComposeCodeableConcept(xml, 'serviceProvisionCode', value.serviceProvisionCodeList[i]);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.eligibilityList.Count - 1 do
      ComposeHealthcareServiceEligibility(xml, 'eligibility', value.eligibilityList[i]);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.program_List.Count - 1 do
      ComposeCodeableConcept(xml, 'program', value.program_List[i]);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.characteristicList.Count - 1 do
      ComposeCodeableConcept(xml, 'characteristic', value.characteristicList[i]);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.communicationList.Count - 1 do
      ComposeCodeableConcept(xml, 'communication', value.communicationList[i]);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.referralMethodList.Count - 1 do
      ComposeCodeableConcept(xml, 'referralMethod', value.referralMethodList[i]);
  if (SummaryOption in [soFull, soData]) then
    ComposeBoolean(xml, 'appointmentRequired', value.appointmentRequiredElement);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.availabilityList.Count - 1 do
      ComposeAvailability(xml, 'availability', value.availabilityList[i]);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.endpointList.Count - 1 do
      ComposeReference(xml, 'endpoint', value.endpointList[i]);
end;

{$ENDIF FHIR_HEALTHCARESERVICE}
{$IFDEF FHIR_IMAGINGSELECTION}
function TFHIRXmlParser.ParseImagingSelectionPerformer(element : TMXmlElement; path : string) : TFhirImagingSelectionPerformer;
var
  child : TMXmlElement;
begin
  result := TFhirImagingSelectionPerformer.Create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseImagingSelectionPerformerChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseImagingSelectionPerformerChild(value : TFhirImagingSelectionPerformer; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'function') then
        value.function_ := ParseCodeableConcept(child, path+'/function')
      else if (child.localName = 'actor') then
        value.actor := ParseReference(child, path+'/actor')
      else if Not ParseBackboneElementChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeImagingSelectionPerformer(xml : TXmlBuilder; name : String; value : TFhirImagingSelectionPerformer);
begin
  if (value = nil) then
    exit;
  composeElementAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeImagingSelectionPerformerChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeImagingSelectionPerformerChildren(xml : TXmlBuilder; value : TFhirImagingSelectionPerformer);
begin
  composeBackboneElementChildren(xml, value);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(xml, 'function', value.function_);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference(xml, 'actor', value.actor);
end;

function TFHIRXmlParser.ParseImagingSelectionInstance(element : TMXmlElement; path : string) : TFhirImagingSelectionInstance;
var
  child : TMXmlElement;
begin
  result := TFhirImagingSelectionInstance.Create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseImagingSelectionInstanceChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseImagingSelectionInstanceChild(value : TFhirImagingSelectionInstance; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'uid') then
        value.uidElement := ParseId(child, path+'/uid')
      else if (child.localName = 'number') then
        value.numberElement := ParseUnsignedInt(child, path+'/number')
      else if (child.localName = 'sopClass') then
        value.sopClass := ParseCoding(child, path+'/sopClass')
      else if (child.localName = 'subset') then
        value.subsetList.Add(ParseString(child, path+'/subset'))
      else if (child.localName = 'imageRegion') then
        value.imageRegionList.Add(ParseImagingSelectionInstanceImageRegion(child, path+'/imageRegion'))
      else if Not ParseBackboneElementChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeImagingSelectionInstance(xml : TXmlBuilder; name : String; value : TFhirImagingSelectionInstance);
begin
  if (value = nil) then
    exit;
  composeElementAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeImagingSelectionInstanceChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeImagingSelectionInstanceChildren(xml : TXmlBuilder; value : TFhirImagingSelectionInstance);
var
  i : integer;
begin
  composeBackboneElementChildren(xml, value);
  ComposeId(xml, 'uid', value.uidElement);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeUnsignedInt(xml, 'number', value.numberElement);
  if (SummaryOption in [soFull, soData]) then
    ComposeCoding(xml, 'sopClass', value.sopClass);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.subsetList.Count - 1 do
      ComposeString(xml, 'subset', value.subsetList[i]);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.imageRegionList.Count - 1 do
      ComposeImagingSelectionInstanceImageRegion(xml, 'imageRegion', value.imageRegionList[i]);
end;

function TFHIRXmlParser.ParseImagingSelectionInstanceImageRegion(element : TMXmlElement; path : string) : TFhirImagingSelectionInstanceImageRegion;
var
  child : TMXmlElement;
begin
  result := TFhirImagingSelectionInstanceImageRegion.Create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseImagingSelectionInstanceImageRegionChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseImagingSelectionInstanceImageRegionChild(value : TFhirImagingSelectionInstanceImageRegion; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'regionType') then
        value.regionTypeElement := ParseEnum(CODES_TFhirImagingSelection2DGraphicTypeEnum, SYSTEMS_TFhirImagingSelection2DGraphicTypeEnum, child, path+'/regionType')
      else if (child.localName = 'coordinate') then
        value.coordinateList.Add(ParseDecimal(child, path+'/coordinate'))
      else if Not ParseBackboneElementChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeImagingSelectionInstanceImageRegion(xml : TXmlBuilder; name : String; value : TFhirImagingSelectionInstanceImageRegion);
begin
  if (value = nil) then
    exit;
  composeElementAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeImagingSelectionInstanceImageRegionChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeImagingSelectionInstanceImageRegionChildren(xml : TXmlBuilder; value : TFhirImagingSelectionInstanceImageRegion);
var
  i : integer;
begin
  composeBackboneElementChildren(xml, value);
  ComposeEnum(xml, 'regionType', value.regionTypeElement, CODES_TFhirImagingSelection2DGraphicTypeEnum);
  for i := 0 to value.coordinateList.Count - 1 do
      ComposeDecimal(xml, 'coordinate', value.coordinateList[i]);
end;

function TFHIRXmlParser.ParseImagingSelectionImageRegion(element : TMXmlElement; path : string) : TFhirImagingSelectionImageRegion;
var
  child : TMXmlElement;
begin
  result := TFhirImagingSelectionImageRegion.Create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseImagingSelectionImageRegionChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseImagingSelectionImageRegionChild(value : TFhirImagingSelectionImageRegion; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'regionType') then
        value.regionTypeElement := ParseEnum(CODES_TFhirImagingSelection3DGraphicTypeEnum, SYSTEMS_TFhirImagingSelection3DGraphicTypeEnum, child, path+'/regionType')
      else if (child.localName = 'coordinate') then
        value.coordinateList.Add(ParseDecimal(child, path+'/coordinate'))
      else if Not ParseBackboneElementChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeImagingSelectionImageRegion(xml : TXmlBuilder; name : String; value : TFhirImagingSelectionImageRegion);
begin
  if (value = nil) then
    exit;
  composeElementAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeImagingSelectionImageRegionChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeImagingSelectionImageRegionChildren(xml : TXmlBuilder; value : TFhirImagingSelectionImageRegion);
var
  i : integer;
begin
  composeBackboneElementChildren(xml, value);
  ComposeEnum(xml, 'regionType', value.regionTypeElement, CODES_TFhirImagingSelection3DGraphicTypeEnum);
  for i := 0 to value.coordinateList.Count - 1 do
      ComposeDecimal(xml, 'coordinate', value.coordinateList[i]);
end;

function TFHIRXmlParser.ParseImagingSelection(element : TMXmlElement; path : string) : TFhirImagingSelection;
var
  child : TMXmlElement;
begin
  result := TFhirImagingSelection.Create;
  try
    parseDomainResourceAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseImagingSelectionChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseImagingSelectionChild(value : TFhirImagingSelection; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'identifier') then
        value.identifierList.Add(ParseIdentifier(child, path+'/identifier'))
      else if (child.localName = 'status') then
        value.statusElement := ParseEnum(CODES_TFhirImagingSelectionStatusEnum, SYSTEMS_TFhirImagingSelectionStatusEnum, child, path+'/status')
      else if (child.localName = 'subject') then
        value.subject := ParseReference(child, path+'/subject')
      else if (child.localName = 'issued') then
        value.issuedElement := ParseInstant(child, path+'/issued')
      else if (child.localName = 'performer') then
        value.performerList.Add(ParseImagingSelectionPerformer(child, path+'/performer'))
      else if (child.localName = 'basedOn') then
        value.basedOnList.Add(ParseReference(child, path+'/basedOn'))
      else if (child.localName = 'category') then
        value.categoryList.Add(ParseCodeableConcept(child, path+'/category'))
      else if (child.localName = 'code') then
        value.code := ParseCodeableConcept(child, path+'/code')
      else if (child.localName = 'studyUid') then
        value.studyUidElement := ParseId(child, path+'/studyUid')
      else if (child.localName = 'derivedFrom') then
        value.derivedFromList.Add(ParseReference(child, path+'/derivedFrom'))
      else if (child.localName = 'endpoint') then
        value.endpointList.Add(ParseReference(child, path+'/endpoint'))
      else if (child.localName = 'seriesUid') then
        value.seriesUidElement := ParseId(child, path+'/seriesUid')
      else if (child.localName = 'seriesNumber') then
        value.seriesNumberElement := ParseUnsignedInt(child, path+'/seriesNumber')
      else if (child.localName = 'frameOfReferenceUid') then
        value.frameOfReferenceUidElement := ParseId(child, path+'/frameOfReferenceUid')
      else if (child.localName = 'bodySite') then
        value.bodySite := ParseCodeableReference(child, path+'/bodySite')
      else if (child.localName = 'focus') then
        value.focusList.Add(ParseReference(child, path+'/focus'))
      else if (child.localName = 'instance') then
        value.instanceList.Add(ParseImagingSelectionInstance(child, path+'/instance'))
      else if (child.localName = 'imageRegion') then
        value.imageRegionList.Add(ParseImagingSelectionImageRegion(child, path+'/imageRegion'))
      else if Not ParseDomainResourceChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeImagingSelection(xml : TXmlBuilder; name : String; value : TFhirImagingSelection);
begin
  if (value = nil) then
    exit;
  composeDomainResourceAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeImagingSelectionChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeImagingSelectionChildren(xml : TXmlBuilder; value : TFhirImagingSelection);
var
  i : integer;
begin
  composeDomainResourceChildren(xml, value);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.identifierList.Count - 1 do
      ComposeIdentifier(xml, 'identifier', value.identifierList[i]);
  ComposeEnum(xml, 'status', value.statusElement, CODES_TFhirImagingSelectionStatusEnum);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference(xml, 'subject', value.subject);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeInstant(xml, 'issued', value.issuedElement);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.performerList.Count - 1 do
      ComposeImagingSelectionPerformer(xml, 'performer', value.performerList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.basedOnList.Count - 1 do
      ComposeReference(xml, 'basedOn', value.basedOnList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.categoryList.Count - 1 do
      ComposeCodeableConcept(xml, 'category', value.categoryList[i]);
  ComposeCodeableConcept(xml, 'code', value.code);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeId(xml, 'studyUid', value.studyUidElement);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.derivedFromList.Count - 1 do
      ComposeReference(xml, 'derivedFrom', value.derivedFromList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.endpointList.Count - 1 do
      ComposeReference(xml, 'endpoint', value.endpointList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeId(xml, 'seriesUid', value.seriesUidElement);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeUnsignedInt(xml, 'seriesNumber', value.seriesNumberElement);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeId(xml, 'frameOfReferenceUid', value.frameOfReferenceUidElement);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableReference(xml, 'bodySite', value.bodySite);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.focusList.Count - 1 do
      ComposeReference(xml, 'focus', value.focusList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.instanceList.Count - 1 do
      ComposeImagingSelectionInstance(xml, 'instance', value.instanceList[i]);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.imageRegionList.Count - 1 do
      ComposeImagingSelectionImageRegion(xml, 'imageRegion', value.imageRegionList[i]);
end;

{$ENDIF FHIR_IMAGINGSELECTION}
{$IFDEF FHIR_IMAGINGSTUDY}
function TFHIRXmlParser.ParseImagingStudySeries(element : TMXmlElement; path : string) : TFhirImagingStudySeries;
var
  child : TMXmlElement;
begin
  result := TFhirImagingStudySeries.Create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseImagingStudySeriesChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseImagingStudySeriesChild(value : TFhirImagingStudySeries; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'uid') then
        value.uidElement := ParseId(child, path+'/uid')
      else if (child.localName = 'number') then
        value.numberElement := ParseUnsignedInt(child, path+'/number')
      else if (child.localName = 'modality') then
        value.modality := ParseCodeableConcept(child, path+'/modality')
      else if (child.localName = 'description') then
        value.descriptionElement := ParseString(child, path+'/description')
      else if (child.localName = 'numberOfInstances') then
        value.numberOfInstancesElement := ParseUnsignedInt(child, path+'/numberOfInstances')
      else if (child.localName = 'endpoint') then
        value.endpointList.Add(ParseReference(child, path+'/endpoint'))
      else if (child.localName = 'bodySite') then
        value.bodySite := ParseCodeableReference(child, path+'/bodySite')
      else if (child.localName = 'laterality') then
        value.laterality := ParseCodeableConcept(child, path+'/laterality')
      else if (child.localName = 'specimen') then
        value.specimenList.Add(ParseReference(child, path+'/specimen'))
      else if (child.localName = 'started') then
        value.startedElement := ParseDateTime(child, path+'/started')
      else if (child.localName = 'performer') then
        value.performerList.Add(ParseImagingStudySeriesPerformer(child, path+'/performer'))
      else if (child.localName = 'instance') then
        value.instanceList.Add(ParseImagingStudySeriesInstance(child, path+'/instance'))
      else if Not ParseBackboneElementChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeImagingStudySeries(xml : TXmlBuilder; name : String; value : TFhirImagingStudySeries);
begin
  if (value = nil) then
    exit;
  composeElementAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeImagingStudySeriesChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeImagingStudySeriesChildren(xml : TXmlBuilder; value : TFhirImagingStudySeries);
var
  i : integer;
begin
  composeBackboneElementChildren(xml, value);
  ComposeId(xml, 'uid', value.uidElement);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeUnsignedInt(xml, 'number', value.numberElement);
  ComposeCodeableConcept(xml, 'modality', value.modality);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(xml, 'description', value.descriptionElement);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeUnsignedInt(xml, 'numberOfInstances', value.numberOfInstancesElement);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.endpointList.Count - 1 do
      ComposeReference(xml, 'endpoint', value.endpointList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableReference(xml, 'bodySite', value.bodySite);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(xml, 'laterality', value.laterality);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.specimenList.Count - 1 do
      ComposeReference(xml, 'specimen', value.specimenList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDateTime(xml, 'started', value.startedElement);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.performerList.Count - 1 do
      ComposeImagingStudySeriesPerformer(xml, 'performer', value.performerList[i]);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.instanceList.Count - 1 do
      ComposeImagingStudySeriesInstance(xml, 'instance', value.instanceList[i]);
end;

function TFHIRXmlParser.ParseImagingStudySeriesPerformer(element : TMXmlElement; path : string) : TFhirImagingStudySeriesPerformer;
var
  child : TMXmlElement;
begin
  result := TFhirImagingStudySeriesPerformer.Create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseImagingStudySeriesPerformerChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseImagingStudySeriesPerformerChild(value : TFhirImagingStudySeriesPerformer; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'function') then
        value.function_ := ParseCodeableConcept(child, path+'/function')
      else if (child.localName = 'actor') then
        value.actor := ParseReference(child, path+'/actor')
      else if Not ParseBackboneElementChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeImagingStudySeriesPerformer(xml : TXmlBuilder; name : String; value : TFhirImagingStudySeriesPerformer);
begin
  if (value = nil) then
    exit;
  composeElementAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeImagingStudySeriesPerformerChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeImagingStudySeriesPerformerChildren(xml : TXmlBuilder; value : TFhirImagingStudySeriesPerformer);
begin
  composeBackboneElementChildren(xml, value);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(xml, 'function', value.function_);
  ComposeReference(xml, 'actor', value.actor);
end;

function TFHIRXmlParser.ParseImagingStudySeriesInstance(element : TMXmlElement; path : string) : TFhirImagingStudySeriesInstance;
var
  child : TMXmlElement;
begin
  result := TFhirImagingStudySeriesInstance.Create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseImagingStudySeriesInstanceChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseImagingStudySeriesInstanceChild(value : TFhirImagingStudySeriesInstance; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'uid') then
        value.uidElement := ParseId(child, path+'/uid')
      else if (child.localName = 'sopClass') then
        value.sopClass := ParseCoding(child, path+'/sopClass')
      else if (child.localName = 'number') then
        value.numberElement := ParseUnsignedInt(child, path+'/number')
      else if (child.localName = 'title') then
        value.titleElement := ParseString(child, path+'/title')
      else if Not ParseBackboneElementChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeImagingStudySeriesInstance(xml : TXmlBuilder; name : String; value : TFhirImagingStudySeriesInstance);
begin
  if (value = nil) then
    exit;
  composeElementAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeImagingStudySeriesInstanceChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeImagingStudySeriesInstanceChildren(xml : TXmlBuilder; value : TFhirImagingStudySeriesInstance);
begin
  composeBackboneElementChildren(xml, value);
  ComposeId(xml, 'uid', value.uidElement);
  ComposeCoding(xml, 'sopClass', value.sopClass);
  if (SummaryOption in [soFull, soData]) then
    ComposeUnsignedInt(xml, 'number', value.numberElement);
  if (SummaryOption in [soFull, soData]) then
    ComposeString(xml, 'title', value.titleElement);
end;

function TFHIRXmlParser.ParseImagingStudy(element : TMXmlElement; path : string) : TFhirImagingStudy;
var
  child : TMXmlElement;
begin
  result := TFhirImagingStudy.Create;
  try
    parseDomainResourceAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseImagingStudyChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseImagingStudyChild(value : TFhirImagingStudy; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'identifier') then
        value.identifierList.Add(ParseIdentifier(child, path+'/identifier'))
      else if (child.localName = 'status') then
        value.statusElement := ParseEnum(CODES_TFhirImagingStudyStatusEnum, SYSTEMS_TFhirImagingStudyStatusEnum, child, path+'/status')
      else if (child.localName = 'modality') then
        value.modalityList.Add(ParseCodeableConcept(child, path+'/modality'))
      else if (child.localName = 'subject') then
        value.subject := ParseReference(child, path+'/subject')
      else if (child.localName = 'encounter') then
        value.encounter := ParseReference(child, path+'/encounter')
      else if (child.localName = 'started') then
        value.startedElement := ParseDateTime(child, path+'/started')
      else if (child.localName = 'basedOn') then
        value.basedOnList.Add(ParseReference(child, path+'/basedOn'))
      else if (child.localName = 'referrer') then
        value.referrer := ParseReference(child, path+'/referrer')
      else if (child.localName = 'interpreter') then
        value.interpreterList.Add(ParseReference(child, path+'/interpreter'))
      else if (child.localName = 'endpoint') then
        value.endpointList.Add(ParseReference(child, path+'/endpoint'))
      else if (child.localName = 'numberOfSeries') then
        value.numberOfSeriesElement := ParseUnsignedInt(child, path+'/numberOfSeries')
      else if (child.localName = 'numberOfInstances') then
        value.numberOfInstancesElement := ParseUnsignedInt(child, path+'/numberOfInstances')
      else if (child.localName = 'procedure') then
        value.procedure_List.Add(ParseCodeableReference(child, path+'/procedure'))
      else if (child.localName = 'location') then
        value.location := ParseReference(child, path+'/location')
      else if (child.localName = 'reason') then
        value.reasonList.Add(ParseCodeableReference(child, path+'/reason'))
      else if (child.localName = 'note') then
        value.noteList.Add(ParseAnnotation(child, path+'/note'))
      else if (child.localName = 'description') then
        value.descriptionElement := ParseString(child, path+'/description')
      else if (child.localName = 'series') then
        value.seriesList.Add(ParseImagingStudySeries(child, path+'/series'))
      else if Not ParseDomainResourceChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeImagingStudy(xml : TXmlBuilder; name : String; value : TFhirImagingStudy);
begin
  if (value = nil) then
    exit;
  composeDomainResourceAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeImagingStudyChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeImagingStudyChildren(xml : TXmlBuilder; value : TFhirImagingStudy);
var
  i : integer;
begin
  composeDomainResourceChildren(xml, value);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.identifierList.Count - 1 do
      ComposeIdentifier(xml, 'identifier', value.identifierList[i]);
  ComposeEnum(xml, 'status', value.statusElement, CODES_TFhirImagingStudyStatusEnum);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.modalityList.Count - 1 do
      ComposeCodeableConcept(xml, 'modality', value.modalityList[i]);
  ComposeReference(xml, 'subject', value.subject);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference(xml, 'encounter', value.encounter);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDateTime(xml, 'started', value.startedElement);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.basedOnList.Count - 1 do
      ComposeReference(xml, 'basedOn', value.basedOnList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference(xml, 'referrer', value.referrer);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.interpreterList.Count - 1 do
      ComposeReference(xml, 'interpreter', value.interpreterList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.endpointList.Count - 1 do
      ComposeReference(xml, 'endpoint', value.endpointList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeUnsignedInt(xml, 'numberOfSeries', value.numberOfSeriesElement);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeUnsignedInt(xml, 'numberOfInstances', value.numberOfInstancesElement);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.procedure_List.Count - 1 do
      ComposeCodeableReference(xml, 'procedure', value.procedure_List[i]);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference(xml, 'location', value.location);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.reasonList.Count - 1 do
      ComposeCodeableReference(xml, 'reason', value.reasonList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.noteList.Count - 1 do
      ComposeAnnotation(xml, 'note', value.noteList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(xml, 'description', value.descriptionElement);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.seriesList.Count - 1 do
      ComposeImagingStudySeries(xml, 'series', value.seriesList[i]);
end;

{$ENDIF FHIR_IMAGINGSTUDY}
{$IFDEF FHIR_IMMUNIZATION}
function TFHIRXmlParser.ParseImmunizationPerformer(element : TMXmlElement; path : string) : TFhirImmunizationPerformer;
var
  child : TMXmlElement;
begin
  result := TFhirImmunizationPerformer.Create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseImmunizationPerformerChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseImmunizationPerformerChild(value : TFhirImmunizationPerformer; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'function') then
        value.function_ := ParseCodeableConcept(child, path+'/function')
      else if (child.localName = 'actor') then
        value.actor := ParseReference(child, path+'/actor')
      else if Not ParseBackboneElementChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeImmunizationPerformer(xml : TXmlBuilder; name : String; value : TFhirImmunizationPerformer);
begin
  if (value = nil) then
    exit;
  composeElementAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeImmunizationPerformerChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeImmunizationPerformerChildren(xml : TXmlBuilder; value : TFhirImmunizationPerformer);
begin
  composeBackboneElementChildren(xml, value);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(xml, 'function', value.function_);
  ComposeReference(xml, 'actor', value.actor);
end;

function TFHIRXmlParser.ParseImmunizationProgramEligibility(element : TMXmlElement; path : string) : TFhirImmunizationProgramEligibility;
var
  child : TMXmlElement;
begin
  result := TFhirImmunizationProgramEligibility.Create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseImmunizationProgramEligibilityChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseImmunizationProgramEligibilityChild(value : TFhirImmunizationProgramEligibility; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'program') then
        value.program_ := ParseCodeableConcept(child, path+'/program')
      else if (child.localName = 'programStatus') then
        value.programStatus := ParseCodeableConcept(child, path+'/programStatus')
      else if Not ParseBackboneElementChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeImmunizationProgramEligibility(xml : TXmlBuilder; name : String; value : TFhirImmunizationProgramEligibility);
begin
  if (value = nil) then
    exit;
  composeElementAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeImmunizationProgramEligibilityChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeImmunizationProgramEligibilityChildren(xml : TXmlBuilder; value : TFhirImmunizationProgramEligibility);
begin
  composeBackboneElementChildren(xml, value);
  ComposeCodeableConcept(xml, 'program', value.program_);
  ComposeCodeableConcept(xml, 'programStatus', value.programStatus);
end;

function TFHIRXmlParser.ParseImmunizationReaction(element : TMXmlElement; path : string) : TFhirImmunizationReaction;
var
  child : TMXmlElement;
begin
  result := TFhirImmunizationReaction.Create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseImmunizationReactionChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseImmunizationReactionChild(value : TFhirImmunizationReaction; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'date') then
        value.dateElement := ParseDateTime(child, path+'/date')
      else if (child.localName = 'manifestation') then
        value.manifestation := ParseCodeableReference(child, path+'/manifestation')
      else if (child.localName = 'reported') then
        value.reportedElement := ParseBoolean(child, path+'/reported')
      else if Not ParseBackboneElementChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeImmunizationReaction(xml : TXmlBuilder; name : String; value : TFhirImmunizationReaction);
begin
  if (value = nil) then
    exit;
  composeElementAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeImmunizationReactionChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeImmunizationReactionChildren(xml : TXmlBuilder; value : TFhirImmunizationReaction);
begin
  composeBackboneElementChildren(xml, value);
  if (SummaryOption in [soFull, soData]) then
    ComposeDateTime(xml, 'date', value.dateElement);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableReference(xml, 'manifestation', value.manifestation);
  if (SummaryOption in [soFull, soData]) then
    ComposeBoolean(xml, 'reported', value.reportedElement);
end;

function TFHIRXmlParser.ParseImmunizationProtocolApplied(element : TMXmlElement; path : string) : TFhirImmunizationProtocolApplied;
var
  child : TMXmlElement;
begin
  result := TFhirImmunizationProtocolApplied.Create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseImmunizationProtocolAppliedChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseImmunizationProtocolAppliedChild(value : TFhirImmunizationProtocolApplied; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'series') then
        value.seriesElement := ParseString(child, path+'/series')
      else if (child.localName = 'authority') then
        value.authority := ParseReference(child, path+'/authority')
      else if (child.localName = 'targetDisease') then
        value.targetDiseaseList.Add(ParseCodeableConcept(child, path+'/targetDisease'))
      else if (child.localName = 'doseNumber') then
        value.doseNumberElement := ParseString(child, path+'/doseNumber')
      else if (child.localName = 'seriesDoses') then
        value.seriesDosesElement := ParseString(child, path+'/seriesDoses')
      else if Not ParseBackboneElementChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeImmunizationProtocolApplied(xml : TXmlBuilder; name : String; value : TFhirImmunizationProtocolApplied);
begin
  if (value = nil) then
    exit;
  composeElementAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeImmunizationProtocolAppliedChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeImmunizationProtocolAppliedChildren(xml : TXmlBuilder; value : TFhirImmunizationProtocolApplied);
var
  i : integer;
begin
  composeBackboneElementChildren(xml, value);
  if (SummaryOption in [soFull, soData]) then
    ComposeString(xml, 'series', value.seriesElement);
  if (SummaryOption in [soFull, soData]) then
    ComposeReference(xml, 'authority', value.authority);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.targetDiseaseList.Count - 1 do
      ComposeCodeableConcept(xml, 'targetDisease', value.targetDiseaseList[i]);
  ComposeString(xml, 'doseNumber', value.doseNumberElement);
  if (SummaryOption in [soFull, soData]) then
    ComposeString(xml, 'seriesDoses', value.seriesDosesElement);
end;

function TFHIRXmlParser.ParseImmunization(element : TMXmlElement; path : string) : TFhirImmunization;
var
  child : TMXmlElement;
begin
  result := TFhirImmunization.Create;
  try
    parseDomainResourceAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseImmunizationChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseImmunizationChild(value : TFhirImmunization; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'identifier') then
        value.identifierList.Add(ParseIdentifier(child, path+'/identifier'))
      else if (child.localName = 'basedOn') then
        value.basedOnList.Add(ParseReference(child, path+'/basedOn'))
      else if (child.localName = 'status') then
        value.statusElement := ParseEnum(CODES_TFhirImmunizationStatusCodesEnum, SYSTEMS_TFhirImmunizationStatusCodesEnum, child, path+'/status')
      else if (child.localName = 'statusReason') then
        value.statusReason := ParseCodeableConcept(child, path+'/statusReason')
      else if (child.localName = 'vaccineCode') then
        value.vaccineCode := ParseCodeableConcept(child, path+'/vaccineCode')
      else if (child.localName = 'administeredProduct') then
        value.administeredProduct := ParseCodeableReference(child, path+'/administeredProduct')
      else if (child.localName = 'manufacturer') then
        value.manufacturer := ParseCodeableReference(child, path+'/manufacturer')
      else if (child.localName = 'lotNumber') then
        value.lotNumberElement := ParseString(child, path+'/lotNumber')
      else if (child.localName = 'expirationDate') then
        value.expirationDateElement := ParseDate(child, path+'/expirationDate')
      else if (child.localName = 'patient') then
        value.patient := ParseReference(child, path+'/patient')
      else if (child.localName = 'encounter') then
        value.encounter := ParseReference(child, path+'/encounter')
      else if (child.localName = 'supportingInformation') then
        value.supportingInformationList.Add(ParseReference(child, path+'/supportingInformation'))
      else if (child.localName = 'occurrenceDateTime') then
        value.occurrence := ParseDateTime(child, path+'/occurrenceDateTime')
      else if (child.localName = 'occurrenceString') then
        value.occurrence := ParseString(child, path+'/occurrenceString')
      else if (child.localName = 'primarySource') then
        value.primarySourceElement := ParseBoolean(child, path+'/primarySource')
      else if (child.localName = 'informationSource') then
        value.informationSource := ParseCodeableReference(child, path+'/informationSource')
      else if (child.localName = 'location') then
        value.location := ParseReference(child, path+'/location')
      else if (child.localName = 'site') then
        value.site := ParseCodeableConcept(child, path+'/site')
      else if (child.localName = 'route') then
        value.route := ParseCodeableConcept(child, path+'/route')
      else if (child.localName = 'doseQuantity') then
        value.doseQuantity := ParseQuantity(child, path+'/doseQuantity')
      else if (child.localName = 'performer') then
        value.performerList.Add(ParseImmunizationPerformer(child, path+'/performer'))
      else if (child.localName = 'note') then
        value.noteList.Add(ParseAnnotation(child, path+'/note'))
      else if (child.localName = 'reason') then
        value.reasonList.Add(ParseCodeableReference(child, path+'/reason'))
      else if (child.localName = 'isSubpotent') then
        value.isSubpotentElement := ParseBoolean(child, path+'/isSubpotent')
      else if (child.localName = 'subpotentReason') then
        value.subpotentReasonList.Add(ParseCodeableConcept(child, path+'/subpotentReason'))
      else if (child.localName = 'programEligibility') then
        value.programEligibilityList.Add(ParseImmunizationProgramEligibility(child, path+'/programEligibility'))
      else if (child.localName = 'fundingSource') then
        value.fundingSource := ParseCodeableConcept(child, path+'/fundingSource')
      else if (child.localName = 'reaction') then
        value.reactionList.Add(ParseImmunizationReaction(child, path+'/reaction'))
      else if (child.localName = 'protocolApplied') then
        value.protocolAppliedList.Add(ParseImmunizationProtocolApplied(child, path+'/protocolApplied'))
      else if Not ParseDomainResourceChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeImmunization(xml : TXmlBuilder; name : String; value : TFhirImmunization);
begin
  if (value = nil) then
    exit;
  composeDomainResourceAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeImmunizationChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeImmunizationChildren(xml : TXmlBuilder; value : TFhirImmunization);
var
  i : integer;
begin
  composeDomainResourceChildren(xml, value);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.identifierList.Count - 1 do
      ComposeIdentifier(xml, 'identifier', value.identifierList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.basedOnList.Count - 1 do
      ComposeReference(xml, 'basedOn', value.basedOnList[i]);
  ComposeEnum(xml, 'status', value.statusElement, CODES_TFhirImmunizationStatusCodesEnum);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(xml, 'statusReason', value.statusReason);
  ComposeCodeableConcept(xml, 'vaccineCode', value.vaccineCode);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableReference(xml, 'administeredProduct', value.administeredProduct);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableReference(xml, 'manufacturer', value.manufacturer);
  if (SummaryOption in [soFull, soData]) then
    ComposeString(xml, 'lotNumber', value.lotNumberElement);
  if (SummaryOption in [soFull, soData]) then
    ComposeDate(xml, 'expirationDate', value.expirationDateElement);
  ComposeReference(xml, 'patient', value.patient);
  if (SummaryOption in [soFull, soData]) then
    ComposeReference(xml, 'encounter', value.encounter);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.supportingInformationList.Count - 1 do
      ComposeReference(xml, 'supportingInformation', value.supportingInformationList[i]);
  if (value.occurrence is TFhirDateTime) {6} then
    ComposeDateTime(xml, 'occurrenceDateTime', TFhirDateTime(value.occurrence))
  else if (value.occurrence is TFhirString) {6} then
    ComposeString(xml, 'occurrenceString', TFhirString(value.occurrence));
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeBoolean(xml, 'primarySource', value.primarySourceElement);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableReference(xml, 'informationSource', value.informationSource);
  if (SummaryOption in [soFull, soData]) then
    ComposeReference(xml, 'location', value.location);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(xml, 'site', value.site);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(xml, 'route', value.route);
  if (SummaryOption in [soFull, soData]) then
    ComposeQuantity(xml, 'doseQuantity', value.doseQuantity);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.performerList.Count - 1 do
      ComposeImmunizationPerformer(xml, 'performer', value.performerList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.noteList.Count - 1 do
      ComposeAnnotation(xml, 'note', value.noteList[i]);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.reasonList.Count - 1 do
      ComposeCodeableReference(xml, 'reason', value.reasonList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeBoolean(xml, 'isSubpotent', value.isSubpotentElement);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.subpotentReasonList.Count - 1 do
      ComposeCodeableConcept(xml, 'subpotentReason', value.subpotentReasonList[i]);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.programEligibilityList.Count - 1 do
      ComposeImmunizationProgramEligibility(xml, 'programEligibility', value.programEligibilityList[i]);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(xml, 'fundingSource', value.fundingSource);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.reactionList.Count - 1 do
      ComposeImmunizationReaction(xml, 'reaction', value.reactionList[i]);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.protocolAppliedList.Count - 1 do
      ComposeImmunizationProtocolApplied(xml, 'protocolApplied', value.protocolAppliedList[i]);
end;

{$ENDIF FHIR_IMMUNIZATION}
{$IFDEF FHIR_IMMUNIZATIONEVALUATION}
function TFHIRXmlParser.ParseImmunizationEvaluation(element : TMXmlElement; path : string) : TFhirImmunizationEvaluation;
var
  child : TMXmlElement;
begin
  result := TFhirImmunizationEvaluation.Create;
  try
    parseDomainResourceAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseImmunizationEvaluationChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseImmunizationEvaluationChild(value : TFhirImmunizationEvaluation; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'identifier') then
        value.identifierList.Add(ParseIdentifier(child, path+'/identifier'))
      else if (child.localName = 'status') then
        value.statusElement := ParseEnum(CODES_TFhirImmunizationEvaluationStatusCodesEnum, SYSTEMS_TFhirImmunizationEvaluationStatusCodesEnum, child, path+'/status')
      else if (child.localName = 'patient') then
        value.patient := ParseReference(child, path+'/patient')
      else if (child.localName = 'date') then
        value.dateElement := ParseDateTime(child, path+'/date')
      else if (child.localName = 'authority') then
        value.authority := ParseReference(child, path+'/authority')
      else if (child.localName = 'targetDisease') then
        value.targetDisease := ParseCodeableConcept(child, path+'/targetDisease')
      else if (child.localName = 'immunizationEvent') then
        value.immunizationEvent := ParseReference(child, path+'/immunizationEvent')
      else if (child.localName = 'doseStatus') then
        value.doseStatus := ParseCodeableConcept(child, path+'/doseStatus')
      else if (child.localName = 'doseStatusReason') then
        value.doseStatusReasonList.Add(ParseCodeableConcept(child, path+'/doseStatusReason'))
      else if (child.localName = 'description') then
        value.descriptionElement := ParseString(child, path+'/description')
      else if (child.localName = 'series') then
        value.seriesElement := ParseString(child, path+'/series')
      else if (child.localName = 'doseNumber') then
        value.doseNumberElement := ParseString(child, path+'/doseNumber')
      else if (child.localName = 'seriesDoses') then
        value.seriesDosesElement := ParseString(child, path+'/seriesDoses')
      else if Not ParseDomainResourceChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeImmunizationEvaluation(xml : TXmlBuilder; name : String; value : TFhirImmunizationEvaluation);
begin
  if (value = nil) then
    exit;
  composeDomainResourceAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeImmunizationEvaluationChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeImmunizationEvaluationChildren(xml : TXmlBuilder; value : TFhirImmunizationEvaluation);
var
  i : integer;
begin
  composeDomainResourceChildren(xml, value);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.identifierList.Count - 1 do
      ComposeIdentifier(xml, 'identifier', value.identifierList[i]);
  ComposeEnum(xml, 'status', value.statusElement, CODES_TFhirImmunizationEvaluationStatusCodesEnum);
  ComposeReference(xml, 'patient', value.patient);
  if (SummaryOption in [soFull, soData]) then
    ComposeDateTime(xml, 'date', value.dateElement);
  if (SummaryOption in [soFull, soData]) then
    ComposeReference(xml, 'authority', value.authority);
  ComposeCodeableConcept(xml, 'targetDisease', value.targetDisease);
  ComposeReference(xml, 'immunizationEvent', value.immunizationEvent);
  ComposeCodeableConcept(xml, 'doseStatus', value.doseStatus);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.doseStatusReasonList.Count - 1 do
      ComposeCodeableConcept(xml, 'doseStatusReason', value.doseStatusReasonList[i]);
  if (SummaryOption in [soFull, soData]) then
    ComposeString(xml, 'description', value.descriptionElement);
  if (SummaryOption in [soFull, soData]) then
    ComposeString(xml, 'series', value.seriesElement);
  if (SummaryOption in [soFull, soData]) then
    ComposeString(xml, 'doseNumber', value.doseNumberElement);
  if (SummaryOption in [soFull, soData]) then
    ComposeString(xml, 'seriesDoses', value.seriesDosesElement);
end;

{$ENDIF FHIR_IMMUNIZATIONEVALUATION}
{$IFDEF FHIR_IMMUNIZATIONRECOMMENDATION}
function TFHIRXmlParser.ParseImmunizationRecommendationRecommendation(element : TMXmlElement; path : string) : TFhirImmunizationRecommendationRecommendation;
var
  child : TMXmlElement;
begin
  result := TFhirImmunizationRecommendationRecommendation.Create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseImmunizationRecommendationRecommendationChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseImmunizationRecommendationRecommendationChild(value : TFhirImmunizationRecommendationRecommendation; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'vaccineCode') then
        value.vaccineCodeList.Add(ParseCodeableConcept(child, path+'/vaccineCode'))
      else if (child.localName = 'targetDisease') then
        value.targetDiseaseList.Add(ParseCodeableConcept(child, path+'/targetDisease'))
      else if (child.localName = 'contraindicatedVaccineCode') then
        value.contraindicatedVaccineCodeList.Add(ParseCodeableConcept(child, path+'/contraindicatedVaccineCode'))
      else if (child.localName = 'forecastStatus') then
        value.forecastStatus := ParseCodeableConcept(child, path+'/forecastStatus')
      else if (child.localName = 'forecastReason') then
        value.forecastReasonList.Add(ParseCodeableConcept(child, path+'/forecastReason'))
      else if (child.localName = 'dateCriterion') then
        value.dateCriterionList.Add(ParseImmunizationRecommendationRecommendationDateCriterion(child, path+'/dateCriterion'))
      else if (child.localName = 'description') then
        value.descriptionElement := ParseString(child, path+'/description')
      else if (child.localName = 'series') then
        value.seriesElement := ParseString(child, path+'/series')
      else if (child.localName = 'doseNumber') then
        value.doseNumberElement := ParseString(child, path+'/doseNumber')
      else if (child.localName = 'seriesDoses') then
        value.seriesDosesElement := ParseString(child, path+'/seriesDoses')
      else if (child.localName = 'supportingImmunization') then
        value.supportingImmunizationList.Add(ParseReference(child, path+'/supportingImmunization'))
      else if (child.localName = 'supportingPatientInformation') then
        value.supportingPatientInformationList.Add(ParseReference(child, path+'/supportingPatientInformation'))
      else if Not ParseBackboneElementChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeImmunizationRecommendationRecommendation(xml : TXmlBuilder; name : String; value : TFhirImmunizationRecommendationRecommendation);
begin
  if (value = nil) then
    exit;
  composeElementAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeImmunizationRecommendationRecommendationChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeImmunizationRecommendationRecommendationChildren(xml : TXmlBuilder; value : TFhirImmunizationRecommendationRecommendation);
var
  i : integer;
begin
  composeBackboneElementChildren(xml, value);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.vaccineCodeList.Count - 1 do
      ComposeCodeableConcept(xml, 'vaccineCode', value.vaccineCodeList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.targetDiseaseList.Count - 1 do
      ComposeCodeableConcept(xml, 'targetDisease', value.targetDiseaseList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.contraindicatedVaccineCodeList.Count - 1 do
      ComposeCodeableConcept(xml, 'contraindicatedVaccineCode', value.contraindicatedVaccineCodeList[i]);
  ComposeCodeableConcept(xml, 'forecastStatus', value.forecastStatus);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.forecastReasonList.Count - 1 do
      ComposeCodeableConcept(xml, 'forecastReason', value.forecastReasonList[i]);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.dateCriterionList.Count - 1 do
      ComposeImmunizationRecommendationRecommendationDateCriterion(xml, 'dateCriterion', value.dateCriterionList[i]);
  if (SummaryOption in [soFull, soData]) then
    ComposeString(xml, 'description', value.descriptionElement);
  if (SummaryOption in [soFull, soData]) then
    ComposeString(xml, 'series', value.seriesElement);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(xml, 'doseNumber', value.doseNumberElement);
  if (SummaryOption in [soFull, soData]) then
    ComposeString(xml, 'seriesDoses', value.seriesDosesElement);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.supportingImmunizationList.Count - 1 do
      ComposeReference(xml, 'supportingImmunization', value.supportingImmunizationList[i]);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.supportingPatientInformationList.Count - 1 do
      ComposeReference(xml, 'supportingPatientInformation', value.supportingPatientInformationList[i]);
end;

function TFHIRXmlParser.ParseImmunizationRecommendationRecommendationDateCriterion(element : TMXmlElement; path : string) : TFhirImmunizationRecommendationRecommendationDateCriterion;
var
  child : TMXmlElement;
begin
  result := TFhirImmunizationRecommendationRecommendationDateCriterion.Create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseImmunizationRecommendationRecommendationDateCriterionChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseImmunizationRecommendationRecommendationDateCriterionChild(value : TFhirImmunizationRecommendationRecommendationDateCriterion; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'code') then
        value.code := ParseCodeableConcept(child, path+'/code')
      else if (child.localName = 'value') then
        value.valueElement := ParseDateTime(child, path+'/value')
      else if Not ParseBackboneElementChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeImmunizationRecommendationRecommendationDateCriterion(xml : TXmlBuilder; name : String; value : TFhirImmunizationRecommendationRecommendationDateCriterion);
begin
  if (value = nil) then
    exit;
  composeElementAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeImmunizationRecommendationRecommendationDateCriterionChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeImmunizationRecommendationRecommendationDateCriterionChildren(xml : TXmlBuilder; value : TFhirImmunizationRecommendationRecommendationDateCriterion);
begin
  composeBackboneElementChildren(xml, value);
  ComposeCodeableConcept(xml, 'code', value.code);
  ComposeDateTime(xml, 'value', value.valueElement);
end;

function TFHIRXmlParser.ParseImmunizationRecommendation(element : TMXmlElement; path : string) : TFhirImmunizationRecommendation;
var
  child : TMXmlElement;
begin
  result := TFhirImmunizationRecommendation.Create;
  try
    parseDomainResourceAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseImmunizationRecommendationChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseImmunizationRecommendationChild(value : TFhirImmunizationRecommendation; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'identifier') then
        value.identifierList.Add(ParseIdentifier(child, path+'/identifier'))
      else if (child.localName = 'patient') then
        value.patient := ParseReference(child, path+'/patient')
      else if (child.localName = 'date') then
        value.dateElement := ParseDateTime(child, path+'/date')
      else if (child.localName = 'authority') then
        value.authority := ParseReference(child, path+'/authority')
      else if (child.localName = 'recommendation') then
        value.recommendationList.Add(ParseImmunizationRecommendationRecommendation(child, path+'/recommendation'))
      else if Not ParseDomainResourceChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeImmunizationRecommendation(xml : TXmlBuilder; name : String; value : TFhirImmunizationRecommendation);
begin
  if (value = nil) then
    exit;
  composeDomainResourceAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeImmunizationRecommendationChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeImmunizationRecommendationChildren(xml : TXmlBuilder; value : TFhirImmunizationRecommendation);
var
  i : integer;
begin
  composeDomainResourceChildren(xml, value);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.identifierList.Count - 1 do
      ComposeIdentifier(xml, 'identifier', value.identifierList[i]);
  ComposeReference(xml, 'patient', value.patient);
  ComposeDateTime(xml, 'date', value.dateElement);
  if (SummaryOption in [soFull, soData]) then
    ComposeReference(xml, 'authority', value.authority);
  for i := 0 to value.recommendationList.Count - 1 do
      ComposeImmunizationRecommendationRecommendation(xml, 'recommendation', value.recommendationList[i]);
end;

{$ENDIF FHIR_IMMUNIZATIONRECOMMENDATION}
{$IFDEF FHIR_IMPLEMENTATIONGUIDE}
function TFHIRXmlParser.ParseImplementationGuideDependsOn(element : TMXmlElement; path : string) : TFhirImplementationGuideDependsOn;
var
  child : TMXmlElement;
begin
  result := TFhirImplementationGuideDependsOn.Create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseImplementationGuideDependsOnChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseImplementationGuideDependsOnChild(value : TFhirImplementationGuideDependsOn; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'uri') then
        value.uriElement := ParseCanonical(child, path+'/uri')
      else if (child.localName = 'packageId') then
        value.packageIdElement := ParseId(child, path+'/packageId')
      else if (child.localName = 'version') then
        value.versionElement := ParseString(child, path+'/version')
      else if (child.localName = 'reason') then
        value.reasonElement := ParseMarkdown(child, path+'/reason')
      else if Not ParseBackboneElementChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeImplementationGuideDependsOn(xml : TXmlBuilder; name : String; value : TFhirImplementationGuideDependsOn);
begin
  if (value = nil) then
    exit;
  composeElementAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeImplementationGuideDependsOnChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeImplementationGuideDependsOnChildren(xml : TXmlBuilder; value : TFhirImplementationGuideDependsOn);
begin
  composeBackboneElementChildren(xml, value);
  ComposeCanonical(xml, 'uri', value.uriElement);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeId(xml, 'packageId', value.packageIdElement);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(xml, 'version', value.versionElement);
  if (SummaryOption in [soFull, soData]) then
    ComposeMarkdown(xml, 'reason', value.reasonElement);
end;

function TFHIRXmlParser.ParseImplementationGuideGlobal(element : TMXmlElement; path : string) : TFhirImplementationGuideGlobal;
var
  child : TMXmlElement;
begin
  result := TFhirImplementationGuideGlobal.Create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseImplementationGuideGlobalChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseImplementationGuideGlobalChild(value : TFhirImplementationGuideGlobal; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'type') then
        value.type_Element := ParseEnum(CODES_TFhirResourceTypesEnum, SYSTEMS_TFhirResourceTypesEnum, child, path+'/type')
      else if (child.localName = 'profile') then
        value.profileElement := ParseCanonical(child, path+'/profile')
      else if Not ParseBackboneElementChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeImplementationGuideGlobal(xml : TXmlBuilder; name : String; value : TFhirImplementationGuideGlobal);
begin
  if (value = nil) then
    exit;
  composeElementAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeImplementationGuideGlobalChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeImplementationGuideGlobalChildren(xml : TXmlBuilder; value : TFhirImplementationGuideGlobal);
begin
  composeBackboneElementChildren(xml, value);
  ComposeEnum(xml, 'type', value.type_Element, CODES_TFhirResourceTypesEnum);
  ComposeCanonical(xml, 'profile', value.profileElement);
end;

function TFHIRXmlParser.ParseImplementationGuideDefinition(element : TMXmlElement; path : string) : TFhirImplementationGuideDefinition;
var
  child : TMXmlElement;
begin
  result := TFhirImplementationGuideDefinition.Create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseImplementationGuideDefinitionChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseImplementationGuideDefinitionChild(value : TFhirImplementationGuideDefinition; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'grouping') then
        value.groupingList.Add(ParseImplementationGuideDefinitionGrouping(child, path+'/grouping'))
      else if (child.localName = 'resource') then
        value.resourceList.Add(ParseImplementationGuideDefinitionResource(child, path+'/resource'))
      else if (child.localName = 'page') then
        value.page := ParseImplementationGuideDefinitionPage(child, path+'/page')
      else if (child.localName = 'parameter') then
        value.parameterList.Add(ParseImplementationGuideDefinitionParameter(child, path+'/parameter'))
      else if (child.localName = 'template') then
        value.templateList.Add(ParseImplementationGuideDefinitionTemplate(child, path+'/template'))
      else if Not ParseBackboneElementChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeImplementationGuideDefinition(xml : TXmlBuilder; name : String; value : TFhirImplementationGuideDefinition);
begin
  if (value = nil) then
    exit;
  composeElementAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeImplementationGuideDefinitionChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeImplementationGuideDefinitionChildren(xml : TXmlBuilder; value : TFhirImplementationGuideDefinition);
var
  i : integer;
begin
  composeBackboneElementChildren(xml, value);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.groupingList.Count - 1 do
      ComposeImplementationGuideDefinitionGrouping(xml, 'grouping', value.groupingList[i]);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.resourceList.Count - 1 do
      ComposeImplementationGuideDefinitionResource(xml, 'resource', value.resourceList[i]);
  if (SummaryOption in [soFull, soData]) then
    ComposeImplementationGuideDefinitionPage(xml, 'page', value.page);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.parameterList.Count - 1 do
      ComposeImplementationGuideDefinitionParameter(xml, 'parameter', value.parameterList[i]);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.templateList.Count - 1 do
      ComposeImplementationGuideDefinitionTemplate(xml, 'template', value.templateList[i]);
end;

function TFHIRXmlParser.ParseImplementationGuideDefinitionGrouping(element : TMXmlElement; path : string) : TFhirImplementationGuideDefinitionGrouping;
var
  child : TMXmlElement;
begin
  result := TFhirImplementationGuideDefinitionGrouping.Create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseImplementationGuideDefinitionGroupingChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseImplementationGuideDefinitionGroupingChild(value : TFhirImplementationGuideDefinitionGrouping; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'name') then
        value.nameElement := ParseString(child, path+'/name')
      else if (child.localName = 'description') then
        value.descriptionElement := ParseMarkdown(child, path+'/description')
      else if Not ParseBackboneElementChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeImplementationGuideDefinitionGrouping(xml : TXmlBuilder; name : String; value : TFhirImplementationGuideDefinitionGrouping);
begin
  if (value = nil) then
    exit;
  composeElementAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeImplementationGuideDefinitionGroupingChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeImplementationGuideDefinitionGroupingChildren(xml : TXmlBuilder; value : TFhirImplementationGuideDefinitionGrouping);
begin
  composeBackboneElementChildren(xml, value);
  ComposeString(xml, 'name', value.nameElement);
  if (SummaryOption in [soFull, soData]) then
    ComposeMarkdown(xml, 'description', value.descriptionElement);
end;

function TFHIRXmlParser.ParseImplementationGuideDefinitionResource(element : TMXmlElement; path : string) : TFhirImplementationGuideDefinitionResource;
var
  child : TMXmlElement;
begin
  result := TFhirImplementationGuideDefinitionResource.Create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseImplementationGuideDefinitionResourceChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseImplementationGuideDefinitionResourceChild(value : TFhirImplementationGuideDefinitionResource; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'reference') then
        value.reference := ParseReference(child, path+'/reference')
      else if (child.localName = 'fhirVersion') then
        value.fhirVersion.Add(ParseEnum(CODES_TFhirFHIRVersionEnum, SYSTEMS_TFhirFHIRVersionEnum, child, path+'/fhirVersion')){y.1}
      else if (child.localName = 'name') then
        value.nameElement := ParseString(child, path+'/name')
      else if (child.localName = 'description') then
        value.descriptionElement := ParseMarkdown(child, path+'/description')
      else if (child.localName = 'isExample') then
        value.isExampleElement := ParseBoolean(child, path+'/isExample')
      else if (child.localName = 'profile') then
        value.profileList.Add(ParseCanonical(child, path+'/profile'))
      else if (child.localName = 'groupingId') then
        value.groupingIdElement := ParseId(child, path+'/groupingId')
      else if Not ParseBackboneElementChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeImplementationGuideDefinitionResource(xml : TXmlBuilder; name : String; value : TFhirImplementationGuideDefinitionResource);
begin
  if (value = nil) then
    exit;
  composeElementAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeImplementationGuideDefinitionResourceChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeImplementationGuideDefinitionResourceChildren(xml : TXmlBuilder; value : TFhirImplementationGuideDefinitionResource);
var
  i : integer;
begin
  composeBackboneElementChildren(xml, value);
  ComposeReference(xml, 'reference', value.reference);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.fhirVersion.Count - 1 do
      ComposeEnum(xml, 'fhirVersion', value.fhirVersion[i], CODES_TFhirFHIRVersionEnum);
  if (SummaryOption in [soFull, soData]) then
    ComposeString(xml, 'name', value.nameElement);
  if (SummaryOption in [soFull, soData]) then
    ComposeMarkdown(xml, 'description', value.descriptionElement);
  if (SummaryOption in [soFull, soData]) then
    ComposeBoolean(xml, 'isExample', value.isExampleElement);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.profileList.Count - 1 do
      ComposeCanonical(xml, 'profile', value.profileList[i]);
  if (SummaryOption in [soFull, soData]) then
    ComposeId(xml, 'groupingId', value.groupingIdElement);
end;

function TFHIRXmlParser.ParseImplementationGuideDefinitionPage(element : TMXmlElement; path : string) : TFhirImplementationGuideDefinitionPage;
var
  child : TMXmlElement;
begin
  result := TFhirImplementationGuideDefinitionPage.Create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseImplementationGuideDefinitionPageChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseImplementationGuideDefinitionPageChild(value : TFhirImplementationGuideDefinitionPage; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'sourceUrl') then
        value.source := ParseUrl(child, path+'/sourceUrl')
      else if (child.localName = 'sourceMarkdown') then
        value.source := ParseMarkdown(child, path+'/sourceMarkdown')
      else if (child.localName = 'sourceString') then
        value.source := ParseString(child, path+'/sourceString')
      else if (child.localName = 'name') then
        value.nameElement := ParseUrl(child, path+'/name')
      else if (child.localName = 'title') then
        value.titleElement := ParseString(child, path+'/title')
      else if (child.localName = 'generation') then
        value.generationElement := ParseEnum(CODES_TFhirGuidePageGenerationEnum, SYSTEMS_TFhirGuidePageGenerationEnum, child, path+'/generation')
      else if (child.localName = 'page') then
        value.pageList.Add(ParseImplementationGuideDefinitionPage(child, path+'/page'))
      else if Not ParseBackboneElementChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeImplementationGuideDefinitionPage(xml : TXmlBuilder; name : String; value : TFhirImplementationGuideDefinitionPage);
begin
  if (value = nil) then
    exit;
  composeElementAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeImplementationGuideDefinitionPageChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeImplementationGuideDefinitionPageChildren(xml : TXmlBuilder; value : TFhirImplementationGuideDefinitionPage);
var
  i : integer;
begin
  composeBackboneElementChildren(xml, value);
  if (SummaryOption in [soFull, soData]) and (value.source is TFhirUrl) {6} then
    ComposeUrl(xml, 'sourceUrl', TFhirUrl(value.source))
  else if (SummaryOption in [soFull, soData]) and (value.source is TFhirMarkdown) {6} then
    ComposeMarkdown(xml, 'sourceMarkdown', TFhirMarkdown(value.source))
  else if (SummaryOption in [soFull, soData]) and (value.source is TFhirString) {6} then
    ComposeString(xml, 'sourceString', TFhirString(value.source));
  ComposeUrl(xml, 'name', value.nameElement);
  ComposeString(xml, 'title', value.titleElement);
  ComposeEnum(xml, 'generation', value.generationElement, CODES_TFhirGuidePageGenerationEnum);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.pageList.Count - 1 do
      ComposeImplementationGuideDefinitionPage(xml, 'page', value.pageList[i]);
end;

function TFHIRXmlParser.ParseImplementationGuideDefinitionParameter(element : TMXmlElement; path : string) : TFhirImplementationGuideDefinitionParameter;
var
  child : TMXmlElement;
begin
  result := TFhirImplementationGuideDefinitionParameter.Create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseImplementationGuideDefinitionParameterChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseImplementationGuideDefinitionParameterChild(value : TFhirImplementationGuideDefinitionParameter; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'code') then
        value.code := ParseCoding(child, path+'/code')
      else if (child.localName = 'value') then
        value.valueElement := ParseString(child, path+'/value')
      else if Not ParseBackboneElementChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeImplementationGuideDefinitionParameter(xml : TXmlBuilder; name : String; value : TFhirImplementationGuideDefinitionParameter);
begin
  if (value = nil) then
    exit;
  composeElementAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeImplementationGuideDefinitionParameterChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeImplementationGuideDefinitionParameterChildren(xml : TXmlBuilder; value : TFhirImplementationGuideDefinitionParameter);
begin
  composeBackboneElementChildren(xml, value);
  ComposeCoding(xml, 'code', value.code);
  ComposeString(xml, 'value', value.valueElement);
end;

function TFHIRXmlParser.ParseImplementationGuideDefinitionTemplate(element : TMXmlElement; path : string) : TFhirImplementationGuideDefinitionTemplate;
var
  child : TMXmlElement;
begin
  result := TFhirImplementationGuideDefinitionTemplate.Create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseImplementationGuideDefinitionTemplateChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseImplementationGuideDefinitionTemplateChild(value : TFhirImplementationGuideDefinitionTemplate; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'code') then
        value.codeElement := ParseCode(child, path+'/code')
      else if (child.localName = 'source') then
        value.sourceElement := ParseString(child, path+'/source')
      else if (child.localName = 'scope') then
        value.scopeElement := ParseString(child, path+'/scope')
      else if Not ParseBackboneElementChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeImplementationGuideDefinitionTemplate(xml : TXmlBuilder; name : String; value : TFhirImplementationGuideDefinitionTemplate);
begin
  if (value = nil) then
    exit;
  composeElementAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeImplementationGuideDefinitionTemplateChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeImplementationGuideDefinitionTemplateChildren(xml : TXmlBuilder; value : TFhirImplementationGuideDefinitionTemplate);
begin
  composeBackboneElementChildren(xml, value);
  ComposeCode(xml, 'code', value.codeElement);
  ComposeString(xml, 'source', value.sourceElement);
  if (SummaryOption in [soFull, soData]) then
    ComposeString(xml, 'scope', value.scopeElement);
end;

function TFHIRXmlParser.ParseImplementationGuideManifest(element : TMXmlElement; path : string) : TFhirImplementationGuideManifest;
var
  child : TMXmlElement;
begin
  result := TFhirImplementationGuideManifest.Create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseImplementationGuideManifestChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseImplementationGuideManifestChild(value : TFhirImplementationGuideManifest; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'rendering') then
        value.renderingElement := ParseUrl(child, path+'/rendering')
      else if (child.localName = 'resource') then
        value.resourceList.Add(ParseImplementationGuideManifestResource(child, path+'/resource'))
      else if (child.localName = 'page') then
        value.pageList.Add(ParseImplementationGuideManifestPage(child, path+'/page'))
      else if (child.localName = 'image') then
        value.imageList.Add(ParseString(child, path+'/image'))
      else if (child.localName = 'other') then
        value.otherList.Add(ParseString(child, path+'/other'))
      else if Not ParseBackboneElementChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeImplementationGuideManifest(xml : TXmlBuilder; name : String; value : TFhirImplementationGuideManifest);
begin
  if (value = nil) then
    exit;
  composeElementAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeImplementationGuideManifestChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeImplementationGuideManifestChildren(xml : TXmlBuilder; value : TFhirImplementationGuideManifest);
var
  i : integer;
begin
  composeBackboneElementChildren(xml, value);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeUrl(xml, 'rendering', value.renderingElement);
  for i := 0 to value.resourceList.Count - 1 do
      ComposeImplementationGuideManifestResource(xml, 'resource', value.resourceList[i]);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.pageList.Count - 1 do
      ComposeImplementationGuideManifestPage(xml, 'page', value.pageList[i]);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.imageList.Count - 1 do
      ComposeString(xml, 'image', value.imageList[i]);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.otherList.Count - 1 do
      ComposeString(xml, 'other', value.otherList[i]);
end;

function TFHIRXmlParser.ParseImplementationGuideManifestResource(element : TMXmlElement; path : string) : TFhirImplementationGuideManifestResource;
var
  child : TMXmlElement;
begin
  result := TFhirImplementationGuideManifestResource.Create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseImplementationGuideManifestResourceChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseImplementationGuideManifestResourceChild(value : TFhirImplementationGuideManifestResource; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'reference') then
        value.reference := ParseReference(child, path+'/reference')
      else if (child.localName = 'isExample') then
        value.isExampleElement := ParseBoolean(child, path+'/isExample')
      else if (child.localName = 'profile') then
        value.profileList.Add(ParseCanonical(child, path+'/profile'))
      else if (child.localName = 'relativePath') then
        value.relativePathElement := ParseUrl(child, path+'/relativePath')
      else if Not ParseBackboneElementChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeImplementationGuideManifestResource(xml : TXmlBuilder; name : String; value : TFhirImplementationGuideManifestResource);
begin
  if (value = nil) then
    exit;
  composeElementAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeImplementationGuideManifestResourceChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeImplementationGuideManifestResourceChildren(xml : TXmlBuilder; value : TFhirImplementationGuideManifestResource);
var
  i : integer;
begin
  composeBackboneElementChildren(xml, value);
  ComposeReference(xml, 'reference', value.reference);
  if (SummaryOption in [soFull, soData]) then
    ComposeBoolean(xml, 'isExample', value.isExampleElement);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.profileList.Count - 1 do
      ComposeCanonical(xml, 'profile', value.profileList[i]);
  if (SummaryOption in [soFull, soData]) then
    ComposeUrl(xml, 'relativePath', value.relativePathElement);
end;

function TFHIRXmlParser.ParseImplementationGuideManifestPage(element : TMXmlElement; path : string) : TFhirImplementationGuideManifestPage;
var
  child : TMXmlElement;
begin
  result := TFhirImplementationGuideManifestPage.Create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseImplementationGuideManifestPageChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseImplementationGuideManifestPageChild(value : TFhirImplementationGuideManifestPage; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'name') then
        value.nameElement := ParseString(child, path+'/name')
      else if (child.localName = 'title') then
        value.titleElement := ParseString(child, path+'/title')
      else if (child.localName = 'anchor') then
        value.anchorList.Add(ParseString(child, path+'/anchor'))
      else if Not ParseBackboneElementChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeImplementationGuideManifestPage(xml : TXmlBuilder; name : String; value : TFhirImplementationGuideManifestPage);
begin
  if (value = nil) then
    exit;
  composeElementAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeImplementationGuideManifestPageChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeImplementationGuideManifestPageChildren(xml : TXmlBuilder; value : TFhirImplementationGuideManifestPage);
var
  i : integer;
begin
  composeBackboneElementChildren(xml, value);
  ComposeString(xml, 'name', value.nameElement);
  if (SummaryOption in [soFull, soData]) then
    ComposeString(xml, 'title', value.titleElement);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.anchorList.Count - 1 do
      ComposeString(xml, 'anchor', value.anchorList[i]);
end;

function TFHIRXmlParser.ParseImplementationGuide(element : TMXmlElement; path : string) : TFhirImplementationGuide;
var
  child : TMXmlElement;
begin
  result := TFhirImplementationGuide.Create;
  try
    parseCanonicalResourceAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseImplementationGuideChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseImplementationGuideChild(value : TFhirImplementationGuide; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'url') then
        value.urlElement := ParseUri(child, path+'/url')
      else if (child.localName = 'version') then
        value.versionElement := ParseString(child, path+'/version')
      else if (child.localName = 'versionAlgorithmCoding') then
        value.versionAlgorithm := ParseCoding(child, path+'/versionAlgorithmCoding')
      else if (child.localName = 'versionAlgorithmString') then
        value.versionAlgorithm := ParseString(child, path+'/versionAlgorithmString')
      else if (child.localName = 'name') then
        value.nameElement := ParseString(child, path+'/name')
      else if (child.localName = 'title') then
        value.titleElement := ParseString(child, path+'/title')
      else if (child.localName = 'status') then
        value.statusElement := ParseEnum(CODES_TFhirPublicationStatusEnum, SYSTEMS_TFhirPublicationStatusEnum, child, path+'/status')
      else if (child.localName = 'experimental') then
        value.experimentalElement := ParseBoolean(child, path+'/experimental')
      else if (child.localName = 'date') then
        value.dateElement := ParseDateTime(child, path+'/date')
      else if (child.localName = 'publisher') then
        value.publisherElement := ParseString(child, path+'/publisher')
      else if (child.localName = 'contact') then
        value.contactList.Add(ParseContactDetail(child, path+'/contact'))
      else if (child.localName = 'description') then
        value.descriptionElement := ParseMarkdown(child, path+'/description')
      else if (child.localName = 'useContext') then
        value.useContextList.Add(ParseUsageContext(child, path+'/useContext'))
      else if (child.localName = 'jurisdiction') then
        value.jurisdictionList.Add(ParseCodeableConcept(child, path+'/jurisdiction'))
      else if (child.localName = 'copyright') then
        value.copyrightElement := ParseMarkdown(child, path+'/copyright')
      else if (child.localName = 'copyrightLabel') then
        value.copyrightLabelElement := ParseString(child, path+'/copyrightLabel')
      else if (child.localName = 'packageId') then
        value.packageIdElement := ParseId(child, path+'/packageId')
      else if (child.localName = 'license') then
        value.licenseElement := ParseEnum(CODES_TFhirSPDXLicenseEnum, SYSTEMS_TFhirSPDXLicenseEnum, child, path+'/license')
      else if (child.localName = 'fhirVersion') then
        value.fhirVersion.Add(ParseEnum(CODES_TFhirFHIRVersionEnum, SYSTEMS_TFhirFHIRVersionEnum, child, path+'/fhirVersion')){y.1}
      else if (child.localName = 'dependsOn') then
        value.dependsOnList.Add(ParseImplementationGuideDependsOn(child, path+'/dependsOn'))
      else if (child.localName = 'global') then
        value.globalList.Add(ParseImplementationGuideGlobal(child, path+'/global'))
      else if (child.localName = 'definition') then
        value.definition := ParseImplementationGuideDefinition(child, path+'/definition')
      else if (child.localName = 'manifest') then
        value.manifest := ParseImplementationGuideManifest(child, path+'/manifest')
      else if Not ParseCanonicalResourceChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeImplementationGuide(xml : TXmlBuilder; name : String; value : TFhirImplementationGuide);
begin
  if (value = nil) then
    exit;
  composeCanonicalResourceAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeImplementationGuideChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeImplementationGuideChildren(xml : TXmlBuilder; value : TFhirImplementationGuide);
var
  i : integer;
begin
  composeCanonicalResourceChildren(xml, value);
  ComposeUri(xml, 'url', value.urlElement);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(xml, 'version', value.versionElement);
  if (SummaryOption in [soFull, soSummary, soData]) and (value.versionAlgorithm is TFhirCoding) {6} then
    ComposeCoding(xml, 'versionAlgorithmCoding', TFhirCoding(value.versionAlgorithm))
  else if (SummaryOption in [soFull, soSummary, soData]) and (value.versionAlgorithm is TFhirString) {6} then
    ComposeString(xml, 'versionAlgorithmString', TFhirString(value.versionAlgorithm));
  ComposeString(xml, 'name', value.nameElement);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(xml, 'title', value.titleElement);
  ComposeEnum(xml, 'status', value.statusElement, CODES_TFhirPublicationStatusEnum);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeBoolean(xml, 'experimental', value.experimentalElement);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDateTime(xml, 'date', value.dateElement);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(xml, 'publisher', value.publisherElement);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.contactList.Count - 1 do
      ComposeContactDetail(xml, 'contact', value.contactList[i]);
  if (SummaryOption in [soFull, soData]) then
    ComposeMarkdown(xml, 'description', value.descriptionElement);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.useContextList.Count - 1 do
      ComposeUsageContext(xml, 'useContext', value.useContextList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.jurisdictionList.Count - 1 do
      ComposeCodeableConcept(xml, 'jurisdiction', value.jurisdictionList[i]);
  if (SummaryOption in [soFull, soData]) then
    ComposeMarkdown(xml, 'copyright', value.copyrightElement);
  if (SummaryOption in [soFull, soData]) then
    ComposeString(xml, 'copyrightLabel', value.copyrightLabelElement);
  ComposeId(xml, 'packageId', value.packageIdElement);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeEnum(xml, 'license', value.licenseElement, CODES_TFhirSPDXLicenseEnum);
  for i := 0 to value.fhirVersion.Count - 1 do
      ComposeEnum(xml, 'fhirVersion', value.fhirVersion[i], CODES_TFhirFHIRVersionEnum);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.dependsOnList.Count - 1 do
      ComposeImplementationGuideDependsOn(xml, 'dependsOn', value.dependsOnList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.globalList.Count - 1 do
      ComposeImplementationGuideGlobal(xml, 'global', value.globalList[i]);
  if (SummaryOption in [soFull, soData]) then
    ComposeImplementationGuideDefinition(xml, 'definition', value.definition);
  if (SummaryOption in [soFull, soData]) then
    ComposeImplementationGuideManifest(xml, 'manifest', value.manifest);
end;

{$ENDIF FHIR_IMPLEMENTATIONGUIDE}
{$IFDEF FHIR_INGREDIENT}
function TFHIRXmlParser.ParseIngredientManufacturer(element : TMXmlElement; path : string) : TFhirIngredientManufacturer;
var
  child : TMXmlElement;
begin
  result := TFhirIngredientManufacturer.Create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseIngredientManufacturerChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseIngredientManufacturerChild(value : TFhirIngredientManufacturer; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'role') then
        value.roleElement := ParseEnum(CODES_TFhirIngredientManufacturerRoleEnum, SYSTEMS_TFhirIngredientManufacturerRoleEnum, child, path+'/role')
      else if (child.localName = 'manufacturer') then
        value.manufacturer := ParseReference(child, path+'/manufacturer')
      else if Not ParseBackboneElementChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeIngredientManufacturer(xml : TXmlBuilder; name : String; value : TFhirIngredientManufacturer);
begin
  if (value = nil) then
    exit;
  composeElementAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeIngredientManufacturerChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeIngredientManufacturerChildren(xml : TXmlBuilder; value : TFhirIngredientManufacturer);
begin
  composeBackboneElementChildren(xml, value);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeEnum(xml, 'role', value.roleElement, CODES_TFhirIngredientManufacturerRoleEnum);
  ComposeReference(xml, 'manufacturer', value.manufacturer);
end;

function TFHIRXmlParser.ParseIngredientSubstance(element : TMXmlElement; path : string) : TFhirIngredientSubstance;
var
  child : TMXmlElement;
begin
  result := TFhirIngredientSubstance.Create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseIngredientSubstanceChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseIngredientSubstanceChild(value : TFhirIngredientSubstance; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'code') then
        value.code := ParseCodeableReference(child, path+'/code')
      else if (child.localName = 'strength') then
        value.strengthList.Add(ParseIngredientSubstanceStrength(child, path+'/strength'))
      else if Not ParseBackboneElementChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeIngredientSubstance(xml : TXmlBuilder; name : String; value : TFhirIngredientSubstance);
begin
  if (value = nil) then
    exit;
  composeElementAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeIngredientSubstanceChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeIngredientSubstanceChildren(xml : TXmlBuilder; value : TFhirIngredientSubstance);
var
  i : integer;
begin
  composeBackboneElementChildren(xml, value);
  ComposeCodeableReference(xml, 'code', value.code);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.strengthList.Count - 1 do
      ComposeIngredientSubstanceStrength(xml, 'strength', value.strengthList[i]);
end;

function TFHIRXmlParser.ParseIngredientSubstanceStrength(element : TMXmlElement; path : string) : TFhirIngredientSubstanceStrength;
var
  child : TMXmlElement;
begin
  result := TFhirIngredientSubstanceStrength.Create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseIngredientSubstanceStrengthChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseIngredientSubstanceStrengthChild(value : TFhirIngredientSubstanceStrength; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'presentationRatio') then
        value.presentation := ParseRatio(child, path+'/presentationRatio')
      else if (child.localName = 'presentationRatioRange') then
        value.presentation := ParseRatioRange(child, path+'/presentationRatioRange')
      else if (child.localName = 'presentationCodeableConcept') then
        value.presentation := ParseCodeableConcept(child, path+'/presentationCodeableConcept')
      else if (child.localName = 'presentationQuantity') then
        value.presentation := ParseQuantity(child, path+'/presentationQuantity')
      else if (child.localName = 'textPresentation') then
        value.textPresentationElement := ParseString(child, path+'/textPresentation')
      else if (child.localName = 'concentrationRatio') then
        value.concentration := ParseRatio(child, path+'/concentrationRatio')
      else if (child.localName = 'concentrationRatioRange') then
        value.concentration := ParseRatioRange(child, path+'/concentrationRatioRange')
      else if (child.localName = 'concentrationCodeableConcept') then
        value.concentration := ParseCodeableConcept(child, path+'/concentrationCodeableConcept')
      else if (child.localName = 'concentrationQuantity') then
        value.concentration := ParseQuantity(child, path+'/concentrationQuantity')
      else if (child.localName = 'textConcentration') then
        value.textConcentrationElement := ParseString(child, path+'/textConcentration')
      else if (child.localName = 'basis') then
        value.basis := ParseCodeableConcept(child, path+'/basis')
      else if (child.localName = 'measurementPoint') then
        value.measurementPointElement := ParseString(child, path+'/measurementPoint')
      else if (child.localName = 'country') then
        value.countryList.Add(ParseCodeableConcept(child, path+'/country'))
      else if (child.localName = 'referenceStrength') then
        value.referenceStrengthList.Add(ParseIngredientSubstanceStrengthReferenceStrength(child, path+'/referenceStrength'))
      else if Not ParseBackboneElementChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeIngredientSubstanceStrength(xml : TXmlBuilder; name : String; value : TFhirIngredientSubstanceStrength);
begin
  if (value = nil) then
    exit;
  composeElementAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeIngredientSubstanceStrengthChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeIngredientSubstanceStrengthChildren(xml : TXmlBuilder; value : TFhirIngredientSubstanceStrength);
var
  i : integer;
begin
  composeBackboneElementChildren(xml, value);
  if (SummaryOption in [soFull, soSummary, soData]) and (value.presentation is TFhirRatio) {6} then
    ComposeRatio(xml, 'presentationRatio', TFhirRatio(value.presentation))
  else if (SummaryOption in [soFull, soSummary, soData]) and (value.presentation is TFhirRatioRange) {6} then
    ComposeRatioRange(xml, 'presentationRatioRange', TFhirRatioRange(value.presentation))
  else if (SummaryOption in [soFull, soSummary, soData]) and (value.presentation is TFhirCodeableConcept) {6} then
    ComposeCodeableConcept(xml, 'presentationCodeableConcept', TFhirCodeableConcept(value.presentation))
  else if (SummaryOption in [soFull, soSummary, soData]) and (value.presentation is TFhirQuantity) {6} then
    ComposeQuantity(xml, 'presentationQuantity', TFhirQuantity(value.presentation));
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(xml, 'textPresentation', value.textPresentationElement);
  if (SummaryOption in [soFull, soSummary, soData]) and (value.concentration is TFhirRatio) {6} then
    ComposeRatio(xml, 'concentrationRatio', TFhirRatio(value.concentration))
  else if (SummaryOption in [soFull, soSummary, soData]) and (value.concentration is TFhirRatioRange) {6} then
    ComposeRatioRange(xml, 'concentrationRatioRange', TFhirRatioRange(value.concentration))
  else if (SummaryOption in [soFull, soSummary, soData]) and (value.concentration is TFhirCodeableConcept) {6} then
    ComposeCodeableConcept(xml, 'concentrationCodeableConcept', TFhirCodeableConcept(value.concentration))
  else if (SummaryOption in [soFull, soSummary, soData]) and (value.concentration is TFhirQuantity) {6} then
    ComposeQuantity(xml, 'concentrationQuantity', TFhirQuantity(value.concentration));
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(xml, 'textConcentration', value.textConcentrationElement);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(xml, 'basis', value.basis);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(xml, 'measurementPoint', value.measurementPointElement);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.countryList.Count - 1 do
      ComposeCodeableConcept(xml, 'country', value.countryList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.referenceStrengthList.Count - 1 do
      ComposeIngredientSubstanceStrengthReferenceStrength(xml, 'referenceStrength', value.referenceStrengthList[i]);
end;

function TFHIRXmlParser.ParseIngredientSubstanceStrengthReferenceStrength(element : TMXmlElement; path : string) : TFhirIngredientSubstanceStrengthReferenceStrength;
var
  child : TMXmlElement;
begin
  result := TFhirIngredientSubstanceStrengthReferenceStrength.Create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseIngredientSubstanceStrengthReferenceStrengthChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseIngredientSubstanceStrengthReferenceStrengthChild(value : TFhirIngredientSubstanceStrengthReferenceStrength; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'substance') then
        value.substance := ParseCodeableReference(child, path+'/substance')
      else if (child.localName = 'strengthRatio') then
        value.strength := ParseRatio(child, path+'/strengthRatio')
      else if (child.localName = 'strengthRatioRange') then
        value.strength := ParseRatioRange(child, path+'/strengthRatioRange')
      else if (child.localName = 'strengthQuantity') then
        value.strength := ParseQuantity(child, path+'/strengthQuantity')
      else if (child.localName = 'measurementPoint') then
        value.measurementPointElement := ParseString(child, path+'/measurementPoint')
      else if (child.localName = 'country') then
        value.countryList.Add(ParseCodeableConcept(child, path+'/country'))
      else if Not ParseBackboneElementChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeIngredientSubstanceStrengthReferenceStrength(xml : TXmlBuilder; name : String; value : TFhirIngredientSubstanceStrengthReferenceStrength);
begin
  if (value = nil) then
    exit;
  composeElementAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeIngredientSubstanceStrengthReferenceStrengthChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeIngredientSubstanceStrengthReferenceStrengthChildren(xml : TXmlBuilder; value : TFhirIngredientSubstanceStrengthReferenceStrength);
var
  i : integer;
begin
  composeBackboneElementChildren(xml, value);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableReference(xml, 'substance', value.substance);
  if (value.strength is TFhirRatio) {6} then
    ComposeRatio(xml, 'strengthRatio', TFhirRatio(value.strength))
  else if (value.strength is TFhirRatioRange) {6} then
    ComposeRatioRange(xml, 'strengthRatioRange', TFhirRatioRange(value.strength))
  else if (value.strength is TFhirQuantity) {6} then
    ComposeQuantity(xml, 'strengthQuantity', TFhirQuantity(value.strength));
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(xml, 'measurementPoint', value.measurementPointElement);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.countryList.Count - 1 do
      ComposeCodeableConcept(xml, 'country', value.countryList[i]);
end;

function TFHIRXmlParser.ParseIngredient(element : TMXmlElement; path : string) : TFhirIngredient;
var
  child : TMXmlElement;
begin
  result := TFhirIngredient.Create;
  try
    parseDomainResourceAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseIngredientChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseIngredientChild(value : TFhirIngredient; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'identifier') then
        value.identifier := ParseIdentifier(child, path+'/identifier')
      else if (child.localName = 'status') then
        value.statusElement := ParseEnum(CODES_TFhirPublicationStatusEnum, SYSTEMS_TFhirPublicationStatusEnum, child, path+'/status')
      else if (child.localName = 'for') then
        value.for_List.Add(ParseReference(child, path+'/for'))
      else if (child.localName = 'role') then
        value.role := ParseCodeableConcept(child, path+'/role')
      else if (child.localName = 'function') then
        value.function_List.Add(ParseCodeableConcept(child, path+'/function'))
      else if (child.localName = 'group') then
        value.group := ParseCodeableConcept(child, path+'/group')
      else if (child.localName = 'allergenicIndicator') then
        value.allergenicIndicatorElement := ParseBoolean(child, path+'/allergenicIndicator')
      else if (child.localName = 'manufacturer') then
        value.manufacturerList.Add(ParseIngredientManufacturer(child, path+'/manufacturer'))
      else if (child.localName = 'substance') then
        value.substance := ParseIngredientSubstance(child, path+'/substance')
      else if Not ParseDomainResourceChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeIngredient(xml : TXmlBuilder; name : String; value : TFhirIngredient);
begin
  if (value = nil) then
    exit;
  composeDomainResourceAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeIngredientChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeIngredientChildren(xml : TXmlBuilder; value : TFhirIngredient);
var
  i : integer;
begin
  composeDomainResourceChildren(xml, value);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeIdentifier(xml, 'identifier', value.identifier);
  ComposeEnum(xml, 'status', value.statusElement, CODES_TFhirPublicationStatusEnum);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.for_List.Count - 1 do
      ComposeReference(xml, 'for', value.for_List[i]);
  ComposeCodeableConcept(xml, 'role', value.role);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.function_List.Count - 1 do
      ComposeCodeableConcept(xml, 'function', value.function_List[i]);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(xml, 'group', value.group);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeBoolean(xml, 'allergenicIndicator', value.allergenicIndicatorElement);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.manufacturerList.Count - 1 do
      ComposeIngredientManufacturer(xml, 'manufacturer', value.manufacturerList[i]);
  ComposeIngredientSubstance(xml, 'substance', value.substance);
end;

{$ENDIF FHIR_INGREDIENT}
{$IFDEF FHIR_INSURANCEPLAN}
function TFHIRXmlParser.ParseInsurancePlanCoverage(element : TMXmlElement; path : string) : TFhirInsurancePlanCoverage;
var
  child : TMXmlElement;
begin
  result := TFhirInsurancePlanCoverage.Create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseInsurancePlanCoverageChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseInsurancePlanCoverageChild(value : TFhirInsurancePlanCoverage; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'type') then
        value.type_ := ParseCodeableConcept(child, path+'/type')
      else if (child.localName = 'network') then
        value.networkList.Add(ParseReference(child, path+'/network'))
      else if (child.localName = 'benefit') then
        value.benefitList.Add(ParseInsurancePlanCoverageBenefit(child, path+'/benefit'))
      else if Not ParseBackboneElementChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeInsurancePlanCoverage(xml : TXmlBuilder; name : String; value : TFhirInsurancePlanCoverage);
begin
  if (value = nil) then
    exit;
  composeElementAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeInsurancePlanCoverageChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeInsurancePlanCoverageChildren(xml : TXmlBuilder; value : TFhirInsurancePlanCoverage);
var
  i : integer;
begin
  composeBackboneElementChildren(xml, value);
  ComposeCodeableConcept(xml, 'type', value.type_);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.networkList.Count - 1 do
      ComposeReference(xml, 'network', value.networkList[i]);
  for i := 0 to value.benefitList.Count - 1 do
      ComposeInsurancePlanCoverageBenefit(xml, 'benefit', value.benefitList[i]);
end;

function TFHIRXmlParser.ParseInsurancePlanCoverageBenefit(element : TMXmlElement; path : string) : TFhirInsurancePlanCoverageBenefit;
var
  child : TMXmlElement;
begin
  result := TFhirInsurancePlanCoverageBenefit.Create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseInsurancePlanCoverageBenefitChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseInsurancePlanCoverageBenefitChild(value : TFhirInsurancePlanCoverageBenefit; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'type') then
        value.type_ := ParseCodeableConcept(child, path+'/type')
      else if (child.localName = 'requirement') then
        value.requirementElement := ParseString(child, path+'/requirement')
      else if (child.localName = 'limit') then
        value.limitList.Add(ParseInsurancePlanCoverageBenefitLimit(child, path+'/limit'))
      else if Not ParseBackboneElementChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeInsurancePlanCoverageBenefit(xml : TXmlBuilder; name : String; value : TFhirInsurancePlanCoverageBenefit);
begin
  if (value = nil) then
    exit;
  composeElementAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeInsurancePlanCoverageBenefitChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeInsurancePlanCoverageBenefitChildren(xml : TXmlBuilder; value : TFhirInsurancePlanCoverageBenefit);
var
  i : integer;
begin
  composeBackboneElementChildren(xml, value);
  ComposeCodeableConcept(xml, 'type', value.type_);
  if (SummaryOption in [soFull, soData]) then
    ComposeString(xml, 'requirement', value.requirementElement);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.limitList.Count - 1 do
      ComposeInsurancePlanCoverageBenefitLimit(xml, 'limit', value.limitList[i]);
end;

function TFHIRXmlParser.ParseInsurancePlanCoverageBenefitLimit(element : TMXmlElement; path : string) : TFhirInsurancePlanCoverageBenefitLimit;
var
  child : TMXmlElement;
begin
  result := TFhirInsurancePlanCoverageBenefitLimit.Create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseInsurancePlanCoverageBenefitLimitChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseInsurancePlanCoverageBenefitLimitChild(value : TFhirInsurancePlanCoverageBenefitLimit; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'value') then
        value.value := ParseQuantity(child, path+'/value')
      else if (child.localName = 'code') then
        value.code := ParseCodeableConcept(child, path+'/code')
      else if Not ParseBackboneElementChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeInsurancePlanCoverageBenefitLimit(xml : TXmlBuilder; name : String; value : TFhirInsurancePlanCoverageBenefitLimit);
begin
  if (value = nil) then
    exit;
  composeElementAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeInsurancePlanCoverageBenefitLimitChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeInsurancePlanCoverageBenefitLimitChildren(xml : TXmlBuilder; value : TFhirInsurancePlanCoverageBenefitLimit);
begin
  composeBackboneElementChildren(xml, value);
  if (SummaryOption in [soFull, soData]) then
    ComposeQuantity(xml, 'value', value.value);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(xml, 'code', value.code);
end;

function TFHIRXmlParser.ParseInsurancePlanPlan(element : TMXmlElement; path : string) : TFhirInsurancePlanPlan;
var
  child : TMXmlElement;
begin
  result := TFhirInsurancePlanPlan.Create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseInsurancePlanPlanChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseInsurancePlanPlanChild(value : TFhirInsurancePlanPlan; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'identifier') then
        value.identifierList.Add(ParseIdentifier(child, path+'/identifier'))
      else if (child.localName = 'type') then
        value.type_ := ParseCodeableConcept(child, path+'/type')
      else if (child.localName = 'coverageArea') then
        value.coverageAreaList.Add(ParseReference(child, path+'/coverageArea'))
      else if (child.localName = 'network') then
        value.networkList.Add(ParseReference(child, path+'/network'))
      else if (child.localName = 'generalCost') then
        value.generalCostList.Add(ParseInsurancePlanPlanGeneralCost(child, path+'/generalCost'))
      else if (child.localName = 'specificCost') then
        value.specificCostList.Add(ParseInsurancePlanPlanSpecificCost(child, path+'/specificCost'))
      else if Not ParseBackboneElementChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeInsurancePlanPlan(xml : TXmlBuilder; name : String; value : TFhirInsurancePlanPlan);
begin
  if (value = nil) then
    exit;
  composeElementAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeInsurancePlanPlanChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeInsurancePlanPlanChildren(xml : TXmlBuilder; value : TFhirInsurancePlanPlan);
var
  i : integer;
begin
  composeBackboneElementChildren(xml, value);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.identifierList.Count - 1 do
      ComposeIdentifier(xml, 'identifier', value.identifierList[i]);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(xml, 'type', value.type_);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.coverageAreaList.Count - 1 do
      ComposeReference(xml, 'coverageArea', value.coverageAreaList[i]);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.networkList.Count - 1 do
      ComposeReference(xml, 'network', value.networkList[i]);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.generalCostList.Count - 1 do
      ComposeInsurancePlanPlanGeneralCost(xml, 'generalCost', value.generalCostList[i]);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.specificCostList.Count - 1 do
      ComposeInsurancePlanPlanSpecificCost(xml, 'specificCost', value.specificCostList[i]);
end;

function TFHIRXmlParser.ParseInsurancePlanPlanGeneralCost(element : TMXmlElement; path : string) : TFhirInsurancePlanPlanGeneralCost;
var
  child : TMXmlElement;
begin
  result := TFhirInsurancePlanPlanGeneralCost.Create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseInsurancePlanPlanGeneralCostChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseInsurancePlanPlanGeneralCostChild(value : TFhirInsurancePlanPlanGeneralCost; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'type') then
        value.type_ := ParseCodeableConcept(child, path+'/type')
      else if (child.localName = 'groupSize') then
        value.groupSizeElement := ParsePositiveInt(child, path+'/groupSize')
      else if (child.localName = 'cost') then
        value.cost := ParseMoney(child, path+'/cost')
      else if (child.localName = 'comment') then
        value.commentElement := ParseString(child, path+'/comment')
      else if Not ParseBackboneElementChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeInsurancePlanPlanGeneralCost(xml : TXmlBuilder; name : String; value : TFhirInsurancePlanPlanGeneralCost);
begin
  if (value = nil) then
    exit;
  composeElementAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeInsurancePlanPlanGeneralCostChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeInsurancePlanPlanGeneralCostChildren(xml : TXmlBuilder; value : TFhirInsurancePlanPlanGeneralCost);
begin
  composeBackboneElementChildren(xml, value);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(xml, 'type', value.type_);
  if (SummaryOption in [soFull, soData]) then
    ComposePositiveInt(xml, 'groupSize', value.groupSizeElement);
  if (SummaryOption in [soFull, soData]) then
    ComposeMoney(xml, 'cost', value.cost);
  if (SummaryOption in [soFull, soData]) then
    ComposeString(xml, 'comment', value.commentElement);
end;

function TFHIRXmlParser.ParseInsurancePlanPlanSpecificCost(element : TMXmlElement; path : string) : TFhirInsurancePlanPlanSpecificCost;
var
  child : TMXmlElement;
begin
  result := TFhirInsurancePlanPlanSpecificCost.Create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseInsurancePlanPlanSpecificCostChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseInsurancePlanPlanSpecificCostChild(value : TFhirInsurancePlanPlanSpecificCost; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'category') then
        value.category := ParseCodeableConcept(child, path+'/category')
      else if (child.localName = 'benefit') then
        value.benefitList.Add(ParseInsurancePlanPlanSpecificCostBenefit(child, path+'/benefit'))
      else if Not ParseBackboneElementChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeInsurancePlanPlanSpecificCost(xml : TXmlBuilder; name : String; value : TFhirInsurancePlanPlanSpecificCost);
begin
  if (value = nil) then
    exit;
  composeElementAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeInsurancePlanPlanSpecificCostChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeInsurancePlanPlanSpecificCostChildren(xml : TXmlBuilder; value : TFhirInsurancePlanPlanSpecificCost);
var
  i : integer;
begin
  composeBackboneElementChildren(xml, value);
  ComposeCodeableConcept(xml, 'category', value.category);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.benefitList.Count - 1 do
      ComposeInsurancePlanPlanSpecificCostBenefit(xml, 'benefit', value.benefitList[i]);
end;

function TFHIRXmlParser.ParseInsurancePlanPlanSpecificCostBenefit(element : TMXmlElement; path : string) : TFhirInsurancePlanPlanSpecificCostBenefit;
var
  child : TMXmlElement;
begin
  result := TFhirInsurancePlanPlanSpecificCostBenefit.Create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseInsurancePlanPlanSpecificCostBenefitChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseInsurancePlanPlanSpecificCostBenefitChild(value : TFhirInsurancePlanPlanSpecificCostBenefit; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'type') then
        value.type_ := ParseCodeableConcept(child, path+'/type')
      else if (child.localName = 'cost') then
        value.costList.Add(ParseInsurancePlanPlanSpecificCostBenefitCost(child, path+'/cost'))
      else if Not ParseBackboneElementChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeInsurancePlanPlanSpecificCostBenefit(xml : TXmlBuilder; name : String; value : TFhirInsurancePlanPlanSpecificCostBenefit);
begin
  if (value = nil) then
    exit;
  composeElementAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeInsurancePlanPlanSpecificCostBenefitChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeInsurancePlanPlanSpecificCostBenefitChildren(xml : TXmlBuilder; value : TFhirInsurancePlanPlanSpecificCostBenefit);
var
  i : integer;
begin
  composeBackboneElementChildren(xml, value);
  ComposeCodeableConcept(xml, 'type', value.type_);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.costList.Count - 1 do
      ComposeInsurancePlanPlanSpecificCostBenefitCost(xml, 'cost', value.costList[i]);
end;

function TFHIRXmlParser.ParseInsurancePlanPlanSpecificCostBenefitCost(element : TMXmlElement; path : string) : TFhirInsurancePlanPlanSpecificCostBenefitCost;
var
  child : TMXmlElement;
begin
  result := TFhirInsurancePlanPlanSpecificCostBenefitCost.Create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseInsurancePlanPlanSpecificCostBenefitCostChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseInsurancePlanPlanSpecificCostBenefitCostChild(value : TFhirInsurancePlanPlanSpecificCostBenefitCost; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'type') then
        value.type_ := ParseCodeableConcept(child, path+'/type')
      else if (child.localName = 'applicability') then
        value.applicability := ParseCodeableConcept(child, path+'/applicability')
      else if (child.localName = 'qualifiers') then
        value.qualifiersList.Add(ParseCodeableConcept(child, path+'/qualifiers'))
      else if (child.localName = 'value') then
        value.value := ParseQuantity(child, path+'/value')
      else if Not ParseBackboneElementChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeInsurancePlanPlanSpecificCostBenefitCost(xml : TXmlBuilder; name : String; value : TFhirInsurancePlanPlanSpecificCostBenefitCost);
begin
  if (value = nil) then
    exit;
  composeElementAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeInsurancePlanPlanSpecificCostBenefitCostChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeInsurancePlanPlanSpecificCostBenefitCostChildren(xml : TXmlBuilder; value : TFhirInsurancePlanPlanSpecificCostBenefitCost);
var
  i : integer;
begin
  composeBackboneElementChildren(xml, value);
  ComposeCodeableConcept(xml, 'type', value.type_);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(xml, 'applicability', value.applicability);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.qualifiersList.Count - 1 do
      ComposeCodeableConcept(xml, 'qualifiers', value.qualifiersList[i]);
  if (SummaryOption in [soFull, soData]) then
    ComposeQuantity(xml, 'value', value.value);
end;

function TFHIRXmlParser.ParseInsurancePlan(element : TMXmlElement; path : string) : TFhirInsurancePlan;
var
  child : TMXmlElement;
begin
  result := TFhirInsurancePlan.Create;
  try
    parseDomainResourceAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseInsurancePlanChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseInsurancePlanChild(value : TFhirInsurancePlan; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'identifier') then
        value.identifierList.Add(ParseIdentifier(child, path+'/identifier'))
      else if (child.localName = 'status') then
        value.statusElement := ParseEnum(CODES_TFhirPublicationStatusEnum, SYSTEMS_TFhirPublicationStatusEnum, child, path+'/status')
      else if (child.localName = 'type') then
        value.type_List.Add(ParseCodeableConcept(child, path+'/type'))
      else if (child.localName = 'name') then
        value.nameElement := ParseString(child, path+'/name')
      else if (child.localName = 'alias') then
        value.aliasList.Add(ParseString(child, path+'/alias'))
      else if (child.localName = 'period') then
        value.period := ParsePeriod(child, path+'/period')
      else if (child.localName = 'ownedBy') then
        value.ownedBy := ParseReference(child, path+'/ownedBy')
      else if (child.localName = 'administeredBy') then
        value.administeredBy := ParseReference(child, path+'/administeredBy')
      else if (child.localName = 'coverageArea') then
        value.coverageAreaList.Add(ParseReference(child, path+'/coverageArea'))
      else if (child.localName = 'contact') then
        value.contactList.Add(ParseExtendedContactDetail(child, path+'/contact'))
      else if (child.localName = 'endpoint') then
        value.endpointList.Add(ParseReference(child, path+'/endpoint'))
      else if (child.localName = 'network') then
        value.networkList.Add(ParseReference(child, path+'/network'))
      else if (child.localName = 'coverage') then
        value.coverageList.Add(ParseInsurancePlanCoverage(child, path+'/coverage'))
      else if (child.localName = 'plan') then
        value.planList.Add(ParseInsurancePlanPlan(child, path+'/plan'))
      else if Not ParseDomainResourceChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeInsurancePlan(xml : TXmlBuilder; name : String; value : TFhirInsurancePlan);
begin
  if (value = nil) then
    exit;
  composeDomainResourceAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeInsurancePlanChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeInsurancePlanChildren(xml : TXmlBuilder; value : TFhirInsurancePlan);
var
  i : integer;
begin
  composeDomainResourceChildren(xml, value);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.identifierList.Count - 1 do
      ComposeIdentifier(xml, 'identifier', value.identifierList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeEnum(xml, 'status', value.statusElement, CODES_TFhirPublicationStatusEnum);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.type_List.Count - 1 do
      ComposeCodeableConcept(xml, 'type', value.type_List[i]);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(xml, 'name', value.nameElement);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.aliasList.Count - 1 do
      ComposeString(xml, 'alias', value.aliasList[i]);
  if (SummaryOption in [soFull, soData]) then
    ComposePeriod(xml, 'period', value.period);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference(xml, 'ownedBy', value.ownedBy);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference(xml, 'administeredBy', value.administeredBy);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.coverageAreaList.Count - 1 do
      ComposeReference(xml, 'coverageArea', value.coverageAreaList[i]);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.contactList.Count - 1 do
      ComposeExtendedContactDetail(xml, 'contact', value.contactList[i]);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.endpointList.Count - 1 do
      ComposeReference(xml, 'endpoint', value.endpointList[i]);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.networkList.Count - 1 do
      ComposeReference(xml, 'network', value.networkList[i]);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.coverageList.Count - 1 do
      ComposeInsurancePlanCoverage(xml, 'coverage', value.coverageList[i]);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.planList.Count - 1 do
      ComposeInsurancePlanPlan(xml, 'plan', value.planList[i]);
end;

{$ENDIF FHIR_INSURANCEPLAN}
{$IFDEF FHIR_INVENTORYREPORT}
function TFHIRXmlParser.ParseInventoryReportInventoryListing(element : TMXmlElement; path : string) : TFhirInventoryReportInventoryListing;
var
  child : TMXmlElement;
begin
  result := TFhirInventoryReportInventoryListing.Create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseInventoryReportInventoryListingChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseInventoryReportInventoryListingChild(value : TFhirInventoryReportInventoryListing; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'location') then
        value.location := ParseReference(child, path+'/location')
      else if (child.localName = 'itemStatus') then
        value.itemStatus := ParseCodeableConcept(child, path+'/itemStatus')
      else if (child.localName = 'countingDateTime') then
        value.countingDateTimeElement := ParseDateTime(child, path+'/countingDateTime')
      else if (child.localName = 'items') then
        value.itemsList.Add(ParseInventoryReportInventoryListingItems(child, path+'/items'))
      else if Not ParseBackboneElementChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeInventoryReportInventoryListing(xml : TXmlBuilder; name : String; value : TFhirInventoryReportInventoryListing);
begin
  if (value = nil) then
    exit;
  composeElementAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeInventoryReportInventoryListingChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeInventoryReportInventoryListingChildren(xml : TXmlBuilder; value : TFhirInventoryReportInventoryListing);
var
  i : integer;
begin
  composeBackboneElementChildren(xml, value);
  if (SummaryOption in [soFull, soData]) then
    ComposeReference(xml, 'location', value.location);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(xml, 'itemStatus', value.itemStatus);
  if (SummaryOption in [soFull, soData]) then
    ComposeDateTime(xml, 'countingDateTime', value.countingDateTimeElement);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.itemsList.Count - 1 do
      ComposeInventoryReportInventoryListingItems(xml, 'items', value.itemsList[i]);
end;

function TFHIRXmlParser.ParseInventoryReportInventoryListingItems(element : TMXmlElement; path : string) : TFhirInventoryReportInventoryListingItems;
var
  child : TMXmlElement;
begin
  result := TFhirInventoryReportInventoryListingItems.Create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseInventoryReportInventoryListingItemsChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseInventoryReportInventoryListingItemsChild(value : TFhirInventoryReportInventoryListingItems; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'category') then
        value.category := ParseCodeableConcept(child, path+'/category')
      else if (child.localName = 'quantity') then
        value.quantity := ParseQuantity(child, path+'/quantity')
      else if (child.localName = 'item') then
        value.item := ParseCodeableReference(child, path+'/item')
      else if (child.localName = 'lot') then
        value.lotElement := ParseString(child, path+'/lot')
      else if (child.localName = 'serial') then
        value.serialElement := ParseString(child, path+'/serial')
      else if (child.localName = 'expiry') then
        value.expiryElement := ParseDateTime(child, path+'/expiry')
      else if (child.localName = 'manufacturingDate') then
        value.manufacturingDateElement := ParseDateTime(child, path+'/manufacturingDate')
      else if Not ParseBackboneElementChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeInventoryReportInventoryListingItems(xml : TXmlBuilder; name : String; value : TFhirInventoryReportInventoryListingItems);
begin
  if (value = nil) then
    exit;
  composeElementAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeInventoryReportInventoryListingItemsChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeInventoryReportInventoryListingItemsChildren(xml : TXmlBuilder; value : TFhirInventoryReportInventoryListingItems);
begin
  composeBackboneElementChildren(xml, value);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(xml, 'category', value.category);
  ComposeQuantity(xml, 'quantity', value.quantity);
  ComposeCodeableReference(xml, 'item', value.item);
  if (SummaryOption in [soFull, soData]) then
    ComposeString(xml, 'lot', value.lotElement);
  if (SummaryOption in [soFull, soData]) then
    ComposeString(xml, 'serial', value.serialElement);
  if (SummaryOption in [soFull, soData]) then
    ComposeDateTime(xml, 'expiry', value.expiryElement);
  if (SummaryOption in [soFull, soData]) then
    ComposeDateTime(xml, 'manufacturingDate', value.manufacturingDateElement);
end;

function TFHIRXmlParser.ParseInventoryReport(element : TMXmlElement; path : string) : TFhirInventoryReport;
var
  child : TMXmlElement;
begin
  result := TFhirInventoryReport.Create;
  try
    parseDomainResourceAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseInventoryReportChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseInventoryReportChild(value : TFhirInventoryReport; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'identifier') then
        value.identifierList.Add(ParseIdentifier(child, path+'/identifier'))
      else if (child.localName = 'status') then
        value.statusElement := ParseEnum(CODES_TFhirInventoryReportStatusEnum, SYSTEMS_TFhirInventoryReportStatusEnum, child, path+'/status')
      else if (child.localName = 'countType') then
        value.countTypeElement := ParseEnum(CODES_TFhirInventoryCountTypeEnum, SYSTEMS_TFhirInventoryCountTypeEnum, child, path+'/countType')
      else if (child.localName = 'operationType') then
        value.operationType := ParseCodeableConcept(child, path+'/operationType')
      else if (child.localName = 'operationTypeReason') then
        value.operationTypeReason := ParseCodeableConcept(child, path+'/operationTypeReason')
      else if (child.localName = 'reportedDateTime') then
        value.reportedDateTimeElement := ParseDateTime(child, path+'/reportedDateTime')
      else if (child.localName = 'reporter') then
        value.reporter := ParseReference(child, path+'/reporter')
      else if (child.localName = 'reportingPeriod') then
        value.reportingPeriod := ParsePeriod(child, path+'/reportingPeriod')
      else if (child.localName = 'inventoryListing') then
        value.inventoryListingList.Add(ParseInventoryReportInventoryListing(child, path+'/inventoryListing'))
      else if (child.localName = 'note') then
        value.note := ParseAnnotation(child, path+'/note')
      else if Not ParseDomainResourceChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeInventoryReport(xml : TXmlBuilder; name : String; value : TFhirInventoryReport);
begin
  if (value = nil) then
    exit;
  composeDomainResourceAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeInventoryReportChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeInventoryReportChildren(xml : TXmlBuilder; value : TFhirInventoryReport);
var
  i : integer;
begin
  composeDomainResourceChildren(xml, value);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.identifierList.Count - 1 do
      ComposeIdentifier(xml, 'identifier', value.identifierList[i]);
  ComposeEnum(xml, 'status', value.statusElement, CODES_TFhirInventoryReportStatusEnum);
  ComposeEnum(xml, 'countType', value.countTypeElement, CODES_TFhirInventoryCountTypeEnum);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(xml, 'operationType', value.operationType);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(xml, 'operationTypeReason', value.operationTypeReason);
  ComposeDateTime(xml, 'reportedDateTime', value.reportedDateTimeElement);
  if (SummaryOption in [soFull, soData]) then
    ComposeReference(xml, 'reporter', value.reporter);
  if (SummaryOption in [soFull, soData]) then
    ComposePeriod(xml, 'reportingPeriod', value.reportingPeriod);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.inventoryListingList.Count - 1 do
      ComposeInventoryReportInventoryListing(xml, 'inventoryListing', value.inventoryListingList[i]);
  if (SummaryOption in [soFull, soData]) then
    ComposeAnnotation(xml, 'note', value.note);
end;

{$ENDIF FHIR_INVENTORYREPORT}
{$IFDEF FHIR_INVOICE}
function TFHIRXmlParser.ParseInvoiceParticipant(element : TMXmlElement; path : string) : TFhirInvoiceParticipant;
var
  child : TMXmlElement;
begin
  result := TFhirInvoiceParticipant.Create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseInvoiceParticipantChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseInvoiceParticipantChild(value : TFhirInvoiceParticipant; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'role') then
        value.role := ParseCodeableConcept(child, path+'/role')
      else if (child.localName = 'actor') then
        value.actor := ParseReference(child, path+'/actor')
      else if Not ParseBackboneElementChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeInvoiceParticipant(xml : TXmlBuilder; name : String; value : TFhirInvoiceParticipant);
begin
  if (value = nil) then
    exit;
  composeElementAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeInvoiceParticipantChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeInvoiceParticipantChildren(xml : TXmlBuilder; value : TFhirInvoiceParticipant);
begin
  composeBackboneElementChildren(xml, value);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(xml, 'role', value.role);
  ComposeReference(xml, 'actor', value.actor);
end;

function TFHIRXmlParser.ParseInvoiceLineItem(element : TMXmlElement; path : string) : TFhirInvoiceLineItem;
var
  child : TMXmlElement;
begin
  result := TFhirInvoiceLineItem.Create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseInvoiceLineItemChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseInvoiceLineItemChild(value : TFhirInvoiceLineItem; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'sequence') then
        value.sequenceElement := ParsePositiveInt(child, path+'/sequence')
      else if (child.localName = 'servicedPeriod') then
        value.serviced := ParsePeriod(child, path+'/servicedPeriod')
      else if (child.localName = 'servicedDate') then
        value.serviced := ParseDate(child, path+'/servicedDate')
      else if (child.localName = 'chargeItemReference') then
        value.chargeItem := ParseReference(child, path+'/chargeItemReference')
      else if (child.localName = 'chargeItemCodeableConcept') then
        value.chargeItem := ParseCodeableConcept(child, path+'/chargeItemCodeableConcept')
      else if (child.localName = 'priceComponent') then
        value.priceComponentList.Add(ParseMonetaryComponent(child, path+'/priceComponent'))
      else if Not ParseBackboneElementChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeInvoiceLineItem(xml : TXmlBuilder; name : String; value : TFhirInvoiceLineItem);
begin
  if (value = nil) then
    exit;
  composeElementAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeInvoiceLineItemChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeInvoiceLineItemChildren(xml : TXmlBuilder; value : TFhirInvoiceLineItem);
var
  i : integer;
begin
  composeBackboneElementChildren(xml, value);
  if (SummaryOption in [soFull, soData]) then
    ComposePositiveInt(xml, 'sequence', value.sequenceElement);
  if (SummaryOption in [soFull, soData]) and (value.serviced is TFhirPeriod) {6} then
    ComposePeriod(xml, 'servicedPeriod', TFhirPeriod(value.serviced))
  else if (SummaryOption in [soFull, soData]) and (value.serviced is TFhirDate) {6} then
    ComposeDate(xml, 'servicedDate', TFhirDate(value.serviced));
  if (value.chargeItem is TFhirReference) {2} then
    ComposeReference(xml, 'chargeItemReference', TFhirReference(value.chargeItem))
  else if (value.chargeItem is TFhirCodeableConcept) {6} then
    ComposeCodeableConcept(xml, 'chargeItemCodeableConcept', TFhirCodeableConcept(value.chargeItem));
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.priceComponentList.Count - 1 do
      ComposeMonetaryComponent(xml, 'priceComponent', value.priceComponentList[i]);
end;

function TFHIRXmlParser.ParseInvoice(element : TMXmlElement; path : string) : TFhirInvoice;
var
  child : TMXmlElement;
begin
  result := TFhirInvoice.Create;
  try
    parseDomainResourceAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseInvoiceChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseInvoiceChild(value : TFhirInvoice; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'identifier') then
        value.identifierList.Add(ParseIdentifier(child, path+'/identifier'))
      else if (child.localName = 'status') then
        value.statusElement := ParseEnum(CODES_TFhirInvoiceStatusEnum, SYSTEMS_TFhirInvoiceStatusEnum, child, path+'/status')
      else if (child.localName = 'cancelledReason') then
        value.cancelledReasonElement := ParseString(child, path+'/cancelledReason')
      else if (child.localName = 'type') then
        value.type_ := ParseCodeableConcept(child, path+'/type')
      else if (child.localName = 'subject') then
        value.subject := ParseReference(child, path+'/subject')
      else if (child.localName = 'recipient') then
        value.recipient := ParseReference(child, path+'/recipient')
      else if (child.localName = 'date') then
        value.dateElement := ParseDateTime(child, path+'/date')
      else if (child.localName = 'creation') then
        value.creationElement := ParseDateTime(child, path+'/creation')
      else if (child.localName = 'periodPeriod') then
        value.period := ParsePeriod(child, path+'/periodPeriod')
      else if (child.localName = 'periodDate') then
        value.period := ParseDate(child, path+'/periodDate')
      else if (child.localName = 'participant') then
        value.participantList.Add(ParseInvoiceParticipant(child, path+'/participant'))
      else if (child.localName = 'issuer') then
        value.issuer := ParseReference(child, path+'/issuer')
      else if (child.localName = 'account') then
        value.account := ParseReference(child, path+'/account')
      else if (child.localName = 'lineItem') then
        value.lineItemList.Add(ParseInvoiceLineItem(child, path+'/lineItem'))
      else if (child.localName = 'totalPriceComponent') then
        value.totalPriceComponentList.Add(ParseMonetaryComponent(child, path+'/totalPriceComponent'))
      else if (child.localName = 'totalNet') then
        value.totalNet := ParseMoney(child, path+'/totalNet')
      else if (child.localName = 'totalGross') then
        value.totalGross := ParseMoney(child, path+'/totalGross')
      else if (child.localName = 'paymentTerms') then
        value.paymentTermsElement := ParseMarkdown(child, path+'/paymentTerms')
      else if (child.localName = 'note') then
        value.noteList.Add(ParseAnnotation(child, path+'/note'))
      else if Not ParseDomainResourceChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeInvoice(xml : TXmlBuilder; name : String; value : TFhirInvoice);
begin
  if (value = nil) then
    exit;
  composeDomainResourceAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeInvoiceChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeInvoiceChildren(xml : TXmlBuilder; value : TFhirInvoice);
var
  i : integer;
begin
  composeDomainResourceChildren(xml, value);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.identifierList.Count - 1 do
      ComposeIdentifier(xml, 'identifier', value.identifierList[i]);
  ComposeEnum(xml, 'status', value.statusElement, CODES_TFhirInvoiceStatusEnum);
  if (SummaryOption in [soFull, soData]) then
    ComposeString(xml, 'cancelledReason', value.cancelledReasonElement);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(xml, 'type', value.type_);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference(xml, 'subject', value.subject);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference(xml, 'recipient', value.recipient);
  if (SummaryOption in [soFull, soData]) then
    ComposeDateTime(xml, 'date', value.dateElement);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDateTime(xml, 'creation', value.creationElement);
  if (SummaryOption in [soFull, soSummary, soData]) and (value.period is TFhirPeriod) {6} then
    ComposePeriod(xml, 'periodPeriod', TFhirPeriod(value.period))
  else if (SummaryOption in [soFull, soSummary, soData]) and (value.period is TFhirDate) {6} then
    ComposeDate(xml, 'periodDate', TFhirDate(value.period));
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.participantList.Count - 1 do
      ComposeInvoiceParticipant(xml, 'participant', value.participantList[i]);
  if (SummaryOption in [soFull, soData]) then
    ComposeReference(xml, 'issuer', value.issuer);
  if (SummaryOption in [soFull, soData]) then
    ComposeReference(xml, 'account', value.account);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.lineItemList.Count - 1 do
      ComposeInvoiceLineItem(xml, 'lineItem', value.lineItemList[i]);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.totalPriceComponentList.Count - 1 do
      ComposeMonetaryComponent(xml, 'totalPriceComponent', value.totalPriceComponentList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeMoney(xml, 'totalNet', value.totalNet);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeMoney(xml, 'totalGross', value.totalGross);
  if (SummaryOption in [soFull, soData]) then
    ComposeMarkdown(xml, 'paymentTerms', value.paymentTermsElement);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.noteList.Count - 1 do
      ComposeAnnotation(xml, 'note', value.noteList[i]);
end;

{$ENDIF FHIR_INVOICE}
{$IFDEF FHIR_LIBRARY}
function TFHIRXmlParser.ParseLibrary(element : TMXmlElement; path : string) : TFhirLibrary;
var
  child : TMXmlElement;
begin
  result := TFhirLibrary.Create;
  try
    parseMetadataResourceAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseLibraryChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseLibraryChild(value : TFhirLibrary; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'url') then
        value.urlElement := ParseUri(child, path+'/url')
      else if (child.localName = 'identifier') then
        value.identifierList.Add(ParseIdentifier(child, path+'/identifier'))
      else if (child.localName = 'version') then
        value.versionElement := ParseString(child, path+'/version')
      else if (child.localName = 'name') then
        value.nameElement := ParseString(child, path+'/name')
      else if (child.localName = 'title') then
        value.titleElement := ParseString(child, path+'/title')
      else if (child.localName = 'subtitle') then
        value.subtitleElement := ParseString(child, path+'/subtitle')
      else if (child.localName = 'status') then
        value.statusElement := ParseEnum(CODES_TFhirPublicationStatusEnum, SYSTEMS_TFhirPublicationStatusEnum, child, path+'/status')
      else if (child.localName = 'experimental') then
        value.experimentalElement := ParseBoolean(child, path+'/experimental')
      else if (child.localName = 'type') then
        value.type_ := ParseCodeableConcept(child, path+'/type')
      else if (child.localName = 'subjectCodeableConcept') then
        value.subject := ParseCodeableConcept(child, path+'/subjectCodeableConcept')
      else if (child.localName = 'subjectReference') then
        value.subject := ParseReference(child, path+'/subjectReference')
      else if (child.localName = 'date') then
        value.dateElement := ParseDateTime(child, path+'/date')
      else if (child.localName = 'publisher') then
        value.publisherElement := ParseString(child, path+'/publisher')
      else if (child.localName = 'contact') then
        value.contactList.Add(ParseContactDetail(child, path+'/contact'))
      else if (child.localName = 'description') then
        value.descriptionElement := ParseMarkdown(child, path+'/description')
      else if (child.localName = 'useContext') then
        value.useContextList.Add(ParseUsageContext(child, path+'/useContext'))
      else if (child.localName = 'jurisdiction') then
        value.jurisdictionList.Add(ParseCodeableConcept(child, path+'/jurisdiction'))
      else if (child.localName = 'purpose') then
        value.purposeElement := ParseMarkdown(child, path+'/purpose')
      else if (child.localName = 'usage') then
        value.usageElement := ParseString(child, path+'/usage')
      else if (child.localName = 'copyright') then
        value.copyrightElement := ParseMarkdown(child, path+'/copyright')
      else if (child.localName = 'approvalDate') then
        value.approvalDateElement := ParseDate(child, path+'/approvalDate')
      else if (child.localName = 'lastReviewDate') then
        value.lastReviewDateElement := ParseDate(child, path+'/lastReviewDate')
      else if (child.localName = 'effectivePeriod') then
        value.effectivePeriod := ParsePeriod(child, path+'/effectivePeriod')
      else if (child.localName = 'topic') then
        value.topicList.Add(ParseCodeableConcept(child, path+'/topic'))
      else if (child.localName = 'author') then
        value.authorList.Add(ParseContactDetail(child, path+'/author'))
      else if (child.localName = 'editor') then
        value.editorList.Add(ParseContactDetail(child, path+'/editor'))
      else if (child.localName = 'reviewer') then
        value.reviewerList.Add(ParseContactDetail(child, path+'/reviewer'))
      else if (child.localName = 'endorser') then
        value.endorserList.Add(ParseContactDetail(child, path+'/endorser'))
      else if (child.localName = 'relatedArtifact') then
        value.relatedArtifactList.Add(ParseRelatedArtifact(child, path+'/relatedArtifact'))
      else if (child.localName = 'parameter') then
        value.parameterList.Add(ParseParameterDefinition(child, path+'/parameter'))
      else if (child.localName = 'dataRequirement') then
        value.dataRequirementList.Add(ParseDataRequirement(child, path+'/dataRequirement'))
      else if (child.localName = 'content') then
        value.contentList.Add(ParseAttachment(child, path+'/content'))
      else if Not ParseMetadataResourceChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeLibrary(xml : TXmlBuilder; name : String; value : TFhirLibrary);
begin
  if (value = nil) then
    exit;
  composeMetadataResourceAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeLibraryChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeLibraryChildren(xml : TXmlBuilder; value : TFhirLibrary);
var
  i : integer;
begin
  composeMetadataResourceChildren(xml, value);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeUri(xml, 'url', value.urlElement);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.identifierList.Count - 1 do
      ComposeIdentifier(xml, 'identifier', value.identifierList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(xml, 'version', value.versionElement);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(xml, 'name', value.nameElement);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(xml, 'title', value.titleElement);
  if (SummaryOption in [soFull, soData]) then
    ComposeString(xml, 'subtitle', value.subtitleElement);
  ComposeEnum(xml, 'status', value.statusElement, CODES_TFhirPublicationStatusEnum);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeBoolean(xml, 'experimental', value.experimentalElement);
  ComposeCodeableConcept(xml, 'type', value.type_);
  if (SummaryOption in [soFull, soData]) and (value.subject is TFhirCodeableConcept) {6} then
    ComposeCodeableConcept(xml, 'subjectCodeableConcept', TFhirCodeableConcept(value.subject))
  else if (SummaryOption in [soFull, soData]) and (value.subject is TFhirReference) {2} then
    ComposeReference(xml, 'subjectReference', TFhirReference(value.subject));
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDateTime(xml, 'date', value.dateElement);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(xml, 'publisher', value.publisherElement);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.contactList.Count - 1 do
      ComposeContactDetail(xml, 'contact', value.contactList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeMarkdown(xml, 'description', value.descriptionElement);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.useContextList.Count - 1 do
      ComposeUsageContext(xml, 'useContext', value.useContextList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.jurisdictionList.Count - 1 do
      ComposeCodeableConcept(xml, 'jurisdiction', value.jurisdictionList[i]);
  if (SummaryOption in [soFull, soData]) then
    ComposeMarkdown(xml, 'purpose', value.purposeElement);
  if (SummaryOption in [soFull, soData]) then
    ComposeString(xml, 'usage', value.usageElement);
  if (SummaryOption in [soFull, soData]) then
    ComposeMarkdown(xml, 'copyright', value.copyrightElement);
  if (SummaryOption in [soFull, soData]) then
    ComposeDate(xml, 'approvalDate', value.approvalDateElement);
  if (SummaryOption in [soFull, soData]) then
    ComposeDate(xml, 'lastReviewDate', value.lastReviewDateElement);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposePeriod(xml, 'effectivePeriod', value.effectivePeriod);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.topicList.Count - 1 do
      ComposeCodeableConcept(xml, 'topic', value.topicList[i]);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.authorList.Count - 1 do
      ComposeContactDetail(xml, 'author', value.authorList[i]);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.editorList.Count - 1 do
      ComposeContactDetail(xml, 'editor', value.editorList[i]);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.reviewerList.Count - 1 do
      ComposeContactDetail(xml, 'reviewer', value.reviewerList[i]);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.endorserList.Count - 1 do
      ComposeContactDetail(xml, 'endorser', value.endorserList[i]);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.relatedArtifactList.Count - 1 do
      ComposeRelatedArtifact(xml, 'relatedArtifact', value.relatedArtifactList[i]);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.parameterList.Count - 1 do
      ComposeParameterDefinition(xml, 'parameter', value.parameterList[i]);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.dataRequirementList.Count - 1 do
      ComposeDataRequirement(xml, 'dataRequirement', value.dataRequirementList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.contentList.Count - 1 do
      ComposeAttachment(xml, 'content', value.contentList[i]);
end;

{$ENDIF FHIR_LIBRARY}
{$IFDEF FHIR_LINKAGE}
function TFHIRXmlParser.ParseLinkageItem(element : TMXmlElement; path : string) : TFhirLinkageItem;
var
  child : TMXmlElement;
begin
  result := TFhirLinkageItem.Create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseLinkageItemChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseLinkageItemChild(value : TFhirLinkageItem; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'type') then
        value.type_Element := ParseEnum(CODES_TFhirLinkageTypeEnum, SYSTEMS_TFhirLinkageTypeEnum, child, path+'/type')
      else if (child.localName = 'resource') then
        value.resource := ParseReference(child, path+'/resource')
      else if Not ParseBackboneElementChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeLinkageItem(xml : TXmlBuilder; name : String; value : TFhirLinkageItem);
begin
  if (value = nil) then
    exit;
  composeElementAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeLinkageItemChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeLinkageItemChildren(xml : TXmlBuilder; value : TFhirLinkageItem);
begin
  composeBackboneElementChildren(xml, value);
  ComposeEnum(xml, 'type', value.type_Element, CODES_TFhirLinkageTypeEnum);
  ComposeReference(xml, 'resource', value.resource);
end;

function TFHIRXmlParser.ParseLinkage(element : TMXmlElement; path : string) : TFhirLinkage;
var
  child : TMXmlElement;
begin
  result := TFhirLinkage.Create;
  try
    parseDomainResourceAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseLinkageChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseLinkageChild(value : TFhirLinkage; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'active') then
        value.activeElement := ParseBoolean(child, path+'/active')
      else if (child.localName = 'author') then
        value.author := ParseReference(child, path+'/author')
      else if (child.localName = 'item') then
        value.itemList.Add(ParseLinkageItem(child, path+'/item'))
      else if Not ParseDomainResourceChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeLinkage(xml : TXmlBuilder; name : String; value : TFhirLinkage);
begin
  if (value = nil) then
    exit;
  composeDomainResourceAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeLinkageChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeLinkageChildren(xml : TXmlBuilder; value : TFhirLinkage);
var
  i : integer;
begin
  composeDomainResourceChildren(xml, value);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeBoolean(xml, 'active', value.activeElement);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference(xml, 'author', value.author);
  for i := 0 to value.itemList.Count - 1 do
      ComposeLinkageItem(xml, 'item', value.itemList[i]);
end;

{$ENDIF FHIR_LINKAGE}
{$IFDEF FHIR_LIST}
function TFHIRXmlParser.ParseListEntry(element : TMXmlElement; path : string) : TFhirListEntry;
var
  child : TMXmlElement;
begin
  result := TFhirListEntry.Create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseListEntryChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseListEntryChild(value : TFhirListEntry; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'flag') then
        value.flag := ParseCodeableConcept(child, path+'/flag')
      else if (child.localName = 'deleted') then
        value.deletedElement := ParseBoolean(child, path+'/deleted')
      else if (child.localName = 'date') then
        value.dateElement := ParseDateTime(child, path+'/date')
      else if (child.localName = 'item') then
        value.item := ParseReference(child, path+'/item')
      else if Not ParseBackboneElementChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeListEntry(xml : TXmlBuilder; name : String; value : TFhirListEntry);
begin
  if (value = nil) then
    exit;
  composeElementAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeListEntryChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeListEntryChildren(xml : TXmlBuilder; value : TFhirListEntry);
begin
  composeBackboneElementChildren(xml, value);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(xml, 'flag', value.flag);
  if (SummaryOption in [soFull, soData]) then
    ComposeBoolean(xml, 'deleted', value.deletedElement);
  if (SummaryOption in [soFull, soData]) then
    ComposeDateTime(xml, 'date', value.dateElement);
  ComposeReference(xml, 'item', value.item);
end;

function TFHIRXmlParser.ParseList(element : TMXmlElement; path : string) : TFhirList;
var
  child : TMXmlElement;
begin
  result := TFhirList.Create;
  try
    parseDomainResourceAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseListChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseListChild(value : TFhirList; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'identifier') then
        value.identifierList.Add(ParseIdentifier(child, path+'/identifier'))
      else if (child.localName = 'status') then
        value.statusElement := ParseEnum(CODES_TFhirListStatusEnum, SYSTEMS_TFhirListStatusEnum, child, path+'/status')
      else if (child.localName = 'mode') then
        value.modeElement := ParseEnum(CODES_TFhirListModeEnum, SYSTEMS_TFhirListModeEnum, child, path+'/mode')
      else if (child.localName = 'title') then
        value.titleElement := ParseString(child, path+'/title')
      else if (child.localName = 'code') then
        value.code := ParseCodeableConcept(child, path+'/code')
      else if (child.localName = 'subject') then
        value.subject := ParseReference(child, path+'/subject')
      else if (child.localName = 'encounter') then
        value.encounter := ParseReference(child, path+'/encounter')
      else if (child.localName = 'date') then
        value.dateElement := ParseDateTime(child, path+'/date')
      else if (child.localName = 'source') then
        value.source := ParseReference(child, path+'/source')
      else if (child.localName = 'orderedBy') then
        value.orderedBy := ParseCodeableConcept(child, path+'/orderedBy')
      else if (child.localName = 'note') then
        value.noteList.Add(ParseAnnotation(child, path+'/note'))
      else if (child.localName = 'entry') then
        value.entryList.Add(ParseListEntry(child, path+'/entry'))
      else if (child.localName = 'emptyReason') then
        value.emptyReason := ParseCodeableConcept(child, path+'/emptyReason')
      else if Not ParseDomainResourceChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeList(xml : TXmlBuilder; name : String; value : TFhirList);
begin
  if (value = nil) then
    exit;
  composeDomainResourceAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeListChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeListChildren(xml : TXmlBuilder; value : TFhirList);
var
  i : integer;
begin
  composeDomainResourceChildren(xml, value);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.identifierList.Count - 1 do
      ComposeIdentifier(xml, 'identifier', value.identifierList[i]);
  ComposeEnum(xml, 'status', value.statusElement, CODES_TFhirListStatusEnum);
  ComposeEnum(xml, 'mode', value.modeElement, CODES_TFhirListModeEnum);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(xml, 'title', value.titleElement);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(xml, 'code', value.code);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference(xml, 'subject', value.subject);
  if (SummaryOption in [soFull, soData]) then
    ComposeReference(xml, 'encounter', value.encounter);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDateTime(xml, 'date', value.dateElement);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference(xml, 'source', value.source);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(xml, 'orderedBy', value.orderedBy);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.noteList.Count - 1 do
      ComposeAnnotation(xml, 'note', value.noteList[i]);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.entryList.Count - 1 do
      ComposeListEntry(xml, 'entry', value.entryList[i]);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(xml, 'emptyReason', value.emptyReason);
end;

{$ENDIF FHIR_LIST}
{$IFDEF FHIR_LOCATION}
function TFHIRXmlParser.ParseLocationPosition(element : TMXmlElement; path : string) : TFhirLocationPosition;
var
  child : TMXmlElement;
begin
  result := TFhirLocationPosition.Create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseLocationPositionChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseLocationPositionChild(value : TFhirLocationPosition; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'longitude') then
        value.longitudeElement := ParseDecimal(child, path+'/longitude')
      else if (child.localName = 'latitude') then
        value.latitudeElement := ParseDecimal(child, path+'/latitude')
      else if (child.localName = 'altitude') then
        value.altitudeElement := ParseDecimal(child, path+'/altitude')
      else if Not ParseBackboneElementChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeLocationPosition(xml : TXmlBuilder; name : String; value : TFhirLocationPosition);
begin
  if (value = nil) then
    exit;
  composeElementAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeLocationPositionChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeLocationPositionChildren(xml : TXmlBuilder; value : TFhirLocationPosition);
begin
  composeBackboneElementChildren(xml, value);
  ComposeDecimal(xml, 'longitude', value.longitudeElement);
  ComposeDecimal(xml, 'latitude', value.latitudeElement);
  if (SummaryOption in [soFull, soData]) then
    ComposeDecimal(xml, 'altitude', value.altitudeElement);
end;

function TFHIRXmlParser.ParseLocation(element : TMXmlElement; path : string) : TFhirLocation;
var
  child : TMXmlElement;
begin
  result := TFhirLocation.Create;
  try
    parseDomainResourceAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseLocationChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseLocationChild(value : TFhirLocation; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'identifier') then
        value.identifierList.Add(ParseIdentifier(child, path+'/identifier'))
      else if (child.localName = 'status') then
        value.statusElement := ParseEnum(CODES_TFhirLocationStatusEnum, SYSTEMS_TFhirLocationStatusEnum, child, path+'/status')
      else if (child.localName = 'operationalStatus') then
        value.operationalStatus := ParseCoding(child, path+'/operationalStatus')
      else if (child.localName = 'name') then
        value.nameElement := ParseString(child, path+'/name')
      else if (child.localName = 'alias') then
        value.aliasList.Add(ParseString(child, path+'/alias'))
      else if (child.localName = 'description') then
        value.descriptionElement := ParseString(child, path+'/description')
      else if (child.localName = 'mode') then
        value.modeElement := ParseEnum(CODES_TFhirLocationModeEnum, SYSTEMS_TFhirLocationModeEnum, child, path+'/mode')
      else if (child.localName = 'type') then
        value.type_List.Add(ParseCodeableConcept(child, path+'/type'))
      else if (child.localName = 'contact') then
        value.contactList.Add(ParseExtendedContactDetail(child, path+'/contact'))
      else if (child.localName = 'address') then
        value.address := ParseAddress(child, path+'/address')
      else if (child.localName = 'form') then
        value.form := ParseCodeableConcept(child, path+'/form')
      else if (child.localName = 'position') then
        value.position := ParseLocationPosition(child, path+'/position')
      else if (child.localName = 'managingOrganization') then
        value.managingOrganization := ParseReference(child, path+'/managingOrganization')
      else if (child.localName = 'partOf') then
        value.partOf := ParseReference(child, path+'/partOf')
      else if (child.localName = 'characteristic') then
        value.characteristicList.Add(ParseCodeableConcept(child, path+'/characteristic'))
      else if (child.localName = 'hoursOfOperation') then
        value.hoursOfOperationList.Add(ParseAvailability(child, path+'/hoursOfOperation'))
      else if (child.localName = 'virtualService') then
        value.virtualServiceList.Add(ParseVirtualServiceDetail(child, path+'/virtualService'))
      else if (child.localName = 'endpoint') then
        value.endpointList.Add(ParseReference(child, path+'/endpoint'))
      else if Not ParseDomainResourceChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeLocation(xml : TXmlBuilder; name : String; value : TFhirLocation);
begin
  if (value = nil) then
    exit;
  composeDomainResourceAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeLocationChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeLocationChildren(xml : TXmlBuilder; value : TFhirLocation);
var
  i : integer;
begin
  composeDomainResourceChildren(xml, value);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.identifierList.Count - 1 do
      ComposeIdentifier(xml, 'identifier', value.identifierList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeEnum(xml, 'status', value.statusElement, CODES_TFhirLocationStatusEnum);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCoding(xml, 'operationalStatus', value.operationalStatus);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(xml, 'name', value.nameElement);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.aliasList.Count - 1 do
      ComposeString(xml, 'alias', value.aliasList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(xml, 'description', value.descriptionElement);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeEnum(xml, 'mode', value.modeElement, CODES_TFhirLocationModeEnum);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.type_List.Count - 1 do
      ComposeCodeableConcept(xml, 'type', value.type_List[i]);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.contactList.Count - 1 do
      ComposeExtendedContactDetail(xml, 'contact', value.contactList[i]);
  if (SummaryOption in [soFull, soData]) then
    ComposeAddress(xml, 'address', value.address);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(xml, 'form', value.form);
  if (SummaryOption in [soFull, soData]) then
    ComposeLocationPosition(xml, 'position', value.position);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference(xml, 'managingOrganization', value.managingOrganization);
  if (SummaryOption in [soFull, soData]) then
    ComposeReference(xml, 'partOf', value.partOf);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.characteristicList.Count - 1 do
      ComposeCodeableConcept(xml, 'characteristic', value.characteristicList[i]);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.hoursOfOperationList.Count - 1 do
      ComposeAvailability(xml, 'hoursOfOperation', value.hoursOfOperationList[i]);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.virtualServiceList.Count - 1 do
      ComposeVirtualServiceDetail(xml, 'virtualService', value.virtualServiceList[i]);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.endpointList.Count - 1 do
      ComposeReference(xml, 'endpoint', value.endpointList[i]);
end;

{$ENDIF FHIR_LOCATION}
{$IFDEF FHIR_MANUFACTUREDITEMDEFINITION}
function TFHIRXmlParser.ParseManufacturedItemDefinitionProperty(element : TMXmlElement; path : string) : TFhirManufacturedItemDefinitionProperty;
var
  child : TMXmlElement;
begin
  result := TFhirManufacturedItemDefinitionProperty.Create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseManufacturedItemDefinitionPropertyChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseManufacturedItemDefinitionPropertyChild(value : TFhirManufacturedItemDefinitionProperty; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'type') then
        value.type_ := ParseCodeableConcept(child, path+'/type')
      else if (child.localName = 'valueCodeableConcept') then
        value.value := ParseCodeableConcept(child, path+'/valueCodeableConcept')
      else if (child.localName = 'valueQuantity') then
        value.value := ParseQuantity(child, path+'/valueQuantity')
      else if (child.localName = 'valueAttachment') then
        value.value := ParseAttachment(child, path+'/valueAttachment')
      else if (child.localName = 'valueDate') then
        value.value := ParseDate(child, path+'/valueDate')
      else if (child.localName = 'valueBoolean') then
        value.value := ParseBoolean(child, path+'/valueBoolean')
      else if Not ParseBackboneElementChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeManufacturedItemDefinitionProperty(xml : TXmlBuilder; name : String; value : TFhirManufacturedItemDefinitionProperty);
begin
  if (value = nil) then
    exit;
  composeElementAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeManufacturedItemDefinitionPropertyChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeManufacturedItemDefinitionPropertyChildren(xml : TXmlBuilder; value : TFhirManufacturedItemDefinitionProperty);
begin
  composeBackboneElementChildren(xml, value);
  ComposeCodeableConcept(xml, 'type', value.type_);
  if (SummaryOption in [soFull, soSummary, soData]) and (value.value is TFhirCodeableConcept) {6} then
    ComposeCodeableConcept(xml, 'valueCodeableConcept', TFhirCodeableConcept(value.value))
  else if (SummaryOption in [soFull, soSummary, soData]) and (value.value is TFhirQuantity) {6} then
    ComposeQuantity(xml, 'valueQuantity', TFhirQuantity(value.value))
  else if (SummaryOption in [soFull, soSummary, soData]) and (value.value is TFhirAttachment) {6} then
    ComposeAttachment(xml, 'valueAttachment', TFhirAttachment(value.value))
  else if (SummaryOption in [soFull, soSummary, soData]) and (value.value is TFhirDate) {6} then
    ComposeDate(xml, 'valueDate', TFhirDate(value.value))
  else if (SummaryOption in [soFull, soSummary, soData]) and (value.value is TFhirBoolean) {6} then
    ComposeBoolean(xml, 'valueBoolean', TFhirBoolean(value.value));
end;

function TFHIRXmlParser.ParseManufacturedItemDefinitionComponent(element : TMXmlElement; path : string) : TFhirManufacturedItemDefinitionComponent;
var
  child : TMXmlElement;
begin
  result := TFhirManufacturedItemDefinitionComponent.Create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseManufacturedItemDefinitionComponentChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseManufacturedItemDefinitionComponentChild(value : TFhirManufacturedItemDefinitionComponent; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'type') then
        value.type_ := ParseCodeableConcept(child, path+'/type')
      else if (child.localName = 'function') then
        value.function_List.Add(ParseCodeableConcept(child, path+'/function'))
      else if (child.localName = 'amount') then
        value.amountList.Add(ParseQuantity(child, path+'/amount'))
      else if (child.localName = 'constituent') then
        value.constituentList.Add(ParseManufacturedItemDefinitionComponentConstituent(child, path+'/constituent'))
      else if (child.localName = 'property') then
        value.property_List.Add(ParseManufacturedItemDefinitionProperty(child, path+'/property'))
      else if (child.localName = 'component') then
        value.componentList.Add(ParseManufacturedItemDefinitionComponent(child, path+'/component'))
      else if Not ParseBackboneElementChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeManufacturedItemDefinitionComponent(xml : TXmlBuilder; name : String; value : TFhirManufacturedItemDefinitionComponent);
begin
  if (value = nil) then
    exit;
  composeElementAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeManufacturedItemDefinitionComponentChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeManufacturedItemDefinitionComponentChildren(xml : TXmlBuilder; value : TFhirManufacturedItemDefinitionComponent);
var
  i : integer;
begin
  composeBackboneElementChildren(xml, value);
  ComposeCodeableConcept(xml, 'type', value.type_);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.function_List.Count - 1 do
      ComposeCodeableConcept(xml, 'function', value.function_List[i]);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.amountList.Count - 1 do
      ComposeQuantity(xml, 'amount', value.amountList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.constituentList.Count - 1 do
      ComposeManufacturedItemDefinitionComponentConstituent(xml, 'constituent', value.constituentList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.property_List.Count - 1 do
      ComposeManufacturedItemDefinitionProperty(xml, 'property', value.property_List[i]);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.componentList.Count - 1 do
      ComposeManufacturedItemDefinitionComponent(xml, 'component', value.componentList[i]);
end;

function TFHIRXmlParser.ParseManufacturedItemDefinitionComponentConstituent(element : TMXmlElement; path : string) : TFhirManufacturedItemDefinitionComponentConstituent;
var
  child : TMXmlElement;
begin
  result := TFhirManufacturedItemDefinitionComponentConstituent.Create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseManufacturedItemDefinitionComponentConstituentChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseManufacturedItemDefinitionComponentConstituentChild(value : TFhirManufacturedItemDefinitionComponentConstituent; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'amount') then
        value.amountList.Add(ParseQuantity(child, path+'/amount'))
      else if (child.localName = 'location') then
        value.locationList.Add(ParseCodeableConcept(child, path+'/location'))
      else if (child.localName = 'function') then
        value.function_List.Add(ParseCodeableConcept(child, path+'/function'))
      else if (child.localName = 'locationForIngredient') then
        value.locationForIngredientList.Add(ParseCodeableReference(child, path+'/locationForIngredient'))
      else if Not ParseBackboneElementChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeManufacturedItemDefinitionComponentConstituent(xml : TXmlBuilder; name : String; value : TFhirManufacturedItemDefinitionComponentConstituent);
begin
  if (value = nil) then
    exit;
  composeElementAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeManufacturedItemDefinitionComponentConstituentChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeManufacturedItemDefinitionComponentConstituentChildren(xml : TXmlBuilder; value : TFhirManufacturedItemDefinitionComponentConstituent);
var
  i : integer;
begin
  composeBackboneElementChildren(xml, value);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.amountList.Count - 1 do
      ComposeQuantity(xml, 'amount', value.amountList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.locationList.Count - 1 do
      ComposeCodeableConcept(xml, 'location', value.locationList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.function_List.Count - 1 do
      ComposeCodeableConcept(xml, 'function', value.function_List[i]);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.locationForIngredientList.Count - 1 do
      ComposeCodeableReference(xml, 'locationForIngredient', value.locationForIngredientList[i]);
end;

function TFHIRXmlParser.ParseManufacturedItemDefinition(element : TMXmlElement; path : string) : TFhirManufacturedItemDefinition;
var
  child : TMXmlElement;
begin
  result := TFhirManufacturedItemDefinition.Create;
  try
    parseDomainResourceAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseManufacturedItemDefinitionChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseManufacturedItemDefinitionChild(value : TFhirManufacturedItemDefinition; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'identifier') then
        value.identifierList.Add(ParseIdentifier(child, path+'/identifier'))
      else if (child.localName = 'status') then
        value.statusElement := ParseEnum(CODES_TFhirPublicationStatusEnum, SYSTEMS_TFhirPublicationStatusEnum, child, path+'/status')
      else if (child.localName = 'name') then
        value.nameElement := ParseString(child, path+'/name')
      else if (child.localName = 'manufacturedDoseForm') then
        value.manufacturedDoseForm := ParseCodeableConcept(child, path+'/manufacturedDoseForm')
      else if (child.localName = 'unitOfPresentation') then
        value.unitOfPresentation := ParseCodeableConcept(child, path+'/unitOfPresentation')
      else if (child.localName = 'manufacturer') then
        value.manufacturerList.Add(ParseReference(child, path+'/manufacturer'))
      else if (child.localName = 'marketingStatus') then
        value.marketingStatusList.Add(ParseMarketingStatus(child, path+'/marketingStatus'))
      else if (child.localName = 'ingredient') then
        value.ingredientList.Add(ParseCodeableConcept(child, path+'/ingredient'))
      else if (child.localName = 'property') then
        value.property_List.Add(ParseManufacturedItemDefinitionProperty(child, path+'/property'))
      else if (child.localName = 'component') then
        value.componentList.Add(ParseManufacturedItemDefinitionComponent(child, path+'/component'))
      else if Not ParseDomainResourceChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeManufacturedItemDefinition(xml : TXmlBuilder; name : String; value : TFhirManufacturedItemDefinition);
begin
  if (value = nil) then
    exit;
  composeDomainResourceAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeManufacturedItemDefinitionChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeManufacturedItemDefinitionChildren(xml : TXmlBuilder; value : TFhirManufacturedItemDefinition);
var
  i : integer;
begin
  composeDomainResourceChildren(xml, value);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.identifierList.Count - 1 do
      ComposeIdentifier(xml, 'identifier', value.identifierList[i]);
  ComposeEnum(xml, 'status', value.statusElement, CODES_TFhirPublicationStatusEnum);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(xml, 'name', value.nameElement);
  ComposeCodeableConcept(xml, 'manufacturedDoseForm', value.manufacturedDoseForm);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(xml, 'unitOfPresentation', value.unitOfPresentation);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.manufacturerList.Count - 1 do
      ComposeReference(xml, 'manufacturer', value.manufacturerList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.marketingStatusList.Count - 1 do
      ComposeMarketingStatus(xml, 'marketingStatus', value.marketingStatusList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.ingredientList.Count - 1 do
      ComposeCodeableConcept(xml, 'ingredient', value.ingredientList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.property_List.Count - 1 do
      ComposeManufacturedItemDefinitionProperty(xml, 'property', value.property_List[i]);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.componentList.Count - 1 do
      ComposeManufacturedItemDefinitionComponent(xml, 'component', value.componentList[i]);
end;

{$ENDIF FHIR_MANUFACTUREDITEMDEFINITION}
{$IFDEF FHIR_MEASURE}
function TFHIRXmlParser.ParseMeasureTerm(element : TMXmlElement; path : string) : TFhirMeasureTerm;
var
  child : TMXmlElement;
begin
  result := TFhirMeasureTerm.Create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseMeasureTermChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseMeasureTermChild(value : TFhirMeasureTerm; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'code') then
        value.code := ParseCodeableConcept(child, path+'/code')
      else if (child.localName = 'definition') then
        value.definitionElement := ParseMarkdown(child, path+'/definition')
      else if Not ParseBackboneElementChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeMeasureTerm(xml : TXmlBuilder; name : String; value : TFhirMeasureTerm);
begin
  if (value = nil) then
    exit;
  composeElementAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeMeasureTermChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeMeasureTermChildren(xml : TXmlBuilder; value : TFhirMeasureTerm);
begin
  composeBackboneElementChildren(xml, value);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(xml, 'code', value.code);
  if (SummaryOption in [soFull, soData]) then
    ComposeMarkdown(xml, 'definition', value.definitionElement);
end;

function TFHIRXmlParser.ParseMeasureGroup(element : TMXmlElement; path : string) : TFhirMeasureGroup;
var
  child : TMXmlElement;
begin
  result := TFhirMeasureGroup.Create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseMeasureGroupChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseMeasureGroupChild(value : TFhirMeasureGroup; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'code') then
        value.code := ParseCodeableConcept(child, path+'/code')
      else if (child.localName = 'description') then
        value.descriptionElement := ParseString(child, path+'/description')
      else if (child.localName = 'type') then
        value.type_List.Add(ParseCodeableConcept(child, path+'/type'))
      else if (child.localName = 'basis') then
        value.basisElement := ParseEnum(CODES_TFhirFHIRTypesEnum, SYSTEMS_TFhirFHIRTypesEnum, child, path+'/basis')
      else if (child.localName = 'scoring') then
        value.scoring := ParseCodeableConcept(child, path+'/scoring')
      else if (child.localName = 'scoringUnit') then
        value.scoringUnit := ParseCodeableConcept(child, path+'/scoringUnit')
      else if (child.localName = 'improvementNotation') then
        value.improvementNotation := ParseCodeableConcept(child, path+'/improvementNotation')
      else if (child.localName = 'population') then
        value.populationList.Add(ParseMeasureGroupPopulation(child, path+'/population'))
      else if (child.localName = 'stratifier') then
        value.stratifierList.Add(ParseMeasureGroupStratifier(child, path+'/stratifier'))
      else if Not ParseBackboneElementChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeMeasureGroup(xml : TXmlBuilder; name : String; value : TFhirMeasureGroup);
begin
  if (value = nil) then
    exit;
  composeElementAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeMeasureGroupChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeMeasureGroupChildren(xml : TXmlBuilder; value : TFhirMeasureGroup);
var
  i : integer;
begin
  composeBackboneElementChildren(xml, value);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(xml, 'code', value.code);
  if (SummaryOption in [soFull, soData]) then
    ComposeString(xml, 'description', value.descriptionElement);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.type_List.Count - 1 do
      ComposeCodeableConcept(xml, 'type', value.type_List[i]);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeEnum(xml, 'basis', value.basisElement, CODES_TFhirFHIRTypesEnum);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(xml, 'scoring', value.scoring);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(xml, 'scoringUnit', value.scoringUnit);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(xml, 'improvementNotation', value.improvementNotation);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.populationList.Count - 1 do
      ComposeMeasureGroupPopulation(xml, 'population', value.populationList[i]);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.stratifierList.Count - 1 do
      ComposeMeasureGroupStratifier(xml, 'stratifier', value.stratifierList[i]);
end;

function TFHIRXmlParser.ParseMeasureGroupPopulation(element : TMXmlElement; path : string) : TFhirMeasureGroupPopulation;
var
  child : TMXmlElement;
begin
  result := TFhirMeasureGroupPopulation.Create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseMeasureGroupPopulationChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseMeasureGroupPopulationChild(value : TFhirMeasureGroupPopulation; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'code') then
        value.code := ParseCodeableConcept(child, path+'/code')
      else if (child.localName = 'description') then
        value.descriptionElement := ParseString(child, path+'/description')
      else if (child.localName = 'criteria') then
        value.criteria := ParseExpression(child, path+'/criteria')
      else if (child.localName = 'inputPopulationId') then
        value.inputPopulationIdElement := ParseString(child, path+'/inputPopulationId')
      else if (child.localName = 'aggregateMethod') then
        value.aggregateMethod := ParseCodeableConcept(child, path+'/aggregateMethod')
      else if Not ParseBackboneElementChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeMeasureGroupPopulation(xml : TXmlBuilder; name : String; value : TFhirMeasureGroupPopulation);
begin
  if (value = nil) then
    exit;
  composeElementAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeMeasureGroupPopulationChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeMeasureGroupPopulationChildren(xml : TXmlBuilder; value : TFhirMeasureGroupPopulation);
begin
  composeBackboneElementChildren(xml, value);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(xml, 'code', value.code);
  if (SummaryOption in [soFull, soData]) then
    ComposeString(xml, 'description', value.descriptionElement);
  ComposeExpression(xml, 'criteria', value.criteria);
  if (SummaryOption in [soFull, soData]) then
    ComposeString(xml, 'inputPopulationId', value.inputPopulationIdElement);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(xml, 'aggregateMethod', value.aggregateMethod);
end;

function TFHIRXmlParser.ParseMeasureGroupStratifier(element : TMXmlElement; path : string) : TFhirMeasureGroupStratifier;
var
  child : TMXmlElement;
begin
  result := TFhirMeasureGroupStratifier.Create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseMeasureGroupStratifierChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseMeasureGroupStratifierChild(value : TFhirMeasureGroupStratifier; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'code') then
        value.code := ParseCodeableConcept(child, path+'/code')
      else if (child.localName = 'description') then
        value.descriptionElement := ParseString(child, path+'/description')
      else if (child.localName = 'criteria') then
        value.criteria := ParseExpression(child, path+'/criteria')
      else if (child.localName = 'component') then
        value.componentList.Add(ParseMeasureGroupStratifierComponent(child, path+'/component'))
      else if Not ParseBackboneElementChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeMeasureGroupStratifier(xml : TXmlBuilder; name : String; value : TFhirMeasureGroupStratifier);
begin
  if (value = nil) then
    exit;
  composeElementAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeMeasureGroupStratifierChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeMeasureGroupStratifierChildren(xml : TXmlBuilder; value : TFhirMeasureGroupStratifier);
var
  i : integer;
begin
  composeBackboneElementChildren(xml, value);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(xml, 'code', value.code);
  if (SummaryOption in [soFull, soData]) then
    ComposeString(xml, 'description', value.descriptionElement);
  if (SummaryOption in [soFull, soData]) then
    ComposeExpression(xml, 'criteria', value.criteria);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.componentList.Count - 1 do
      ComposeMeasureGroupStratifierComponent(xml, 'component', value.componentList[i]);
end;

function TFHIRXmlParser.ParseMeasureGroupStratifierComponent(element : TMXmlElement; path : string) : TFhirMeasureGroupStratifierComponent;
var
  child : TMXmlElement;
begin
  result := TFhirMeasureGroupStratifierComponent.Create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseMeasureGroupStratifierComponentChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseMeasureGroupStratifierComponentChild(value : TFhirMeasureGroupStratifierComponent; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'code') then
        value.code := ParseCodeableConcept(child, path+'/code')
      else if (child.localName = 'description') then
        value.descriptionElement := ParseString(child, path+'/description')
      else if (child.localName = 'criteria') then
        value.criteria := ParseExpression(child, path+'/criteria')
      else if Not ParseBackboneElementChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeMeasureGroupStratifierComponent(xml : TXmlBuilder; name : String; value : TFhirMeasureGroupStratifierComponent);
begin
  if (value = nil) then
    exit;
  composeElementAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeMeasureGroupStratifierComponentChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeMeasureGroupStratifierComponentChildren(xml : TXmlBuilder; value : TFhirMeasureGroupStratifierComponent);
begin
  composeBackboneElementChildren(xml, value);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(xml, 'code', value.code);
  if (SummaryOption in [soFull, soData]) then
    ComposeString(xml, 'description', value.descriptionElement);
  ComposeExpression(xml, 'criteria', value.criteria);
end;

function TFHIRXmlParser.ParseMeasureSupplementalData(element : TMXmlElement; path : string) : TFhirMeasureSupplementalData;
var
  child : TMXmlElement;
begin
  result := TFhirMeasureSupplementalData.Create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseMeasureSupplementalDataChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseMeasureSupplementalDataChild(value : TFhirMeasureSupplementalData; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'code') then
        value.code := ParseCodeableConcept(child, path+'/code')
      else if (child.localName = 'usage') then
        value.usageList.Add(ParseCodeableConcept(child, path+'/usage'))
      else if (child.localName = 'description') then
        value.descriptionElement := ParseString(child, path+'/description')
      else if (child.localName = 'criteria') then
        value.criteria := ParseExpression(child, path+'/criteria')
      else if Not ParseBackboneElementChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeMeasureSupplementalData(xml : TXmlBuilder; name : String; value : TFhirMeasureSupplementalData);
begin
  if (value = nil) then
    exit;
  composeElementAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeMeasureSupplementalDataChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeMeasureSupplementalDataChildren(xml : TXmlBuilder; value : TFhirMeasureSupplementalData);
var
  i : integer;
begin
  composeBackboneElementChildren(xml, value);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(xml, 'code', value.code);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.usageList.Count - 1 do
      ComposeCodeableConcept(xml, 'usage', value.usageList[i]);
  if (SummaryOption in [soFull, soData]) then
    ComposeString(xml, 'description', value.descriptionElement);
  ComposeExpression(xml, 'criteria', value.criteria);
end;

function TFHIRXmlParser.ParseMeasure(element : TMXmlElement; path : string) : TFhirMeasure;
var
  child : TMXmlElement;
begin
  result := TFhirMeasure.Create;
  try
    parseMetadataResourceAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseMeasureChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseMeasureChild(value : TFhirMeasure; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'url') then
        value.urlElement := ParseUri(child, path+'/url')
      else if (child.localName = 'identifier') then
        value.identifierList.Add(ParseIdentifier(child, path+'/identifier'))
      else if (child.localName = 'version') then
        value.versionElement := ParseString(child, path+'/version')
      else if (child.localName = 'name') then
        value.nameElement := ParseString(child, path+'/name')
      else if (child.localName = 'title') then
        value.titleElement := ParseString(child, path+'/title')
      else if (child.localName = 'subtitle') then
        value.subtitleElement := ParseString(child, path+'/subtitle')
      else if (child.localName = 'status') then
        value.statusElement := ParseEnum(CODES_TFhirPublicationStatusEnum, SYSTEMS_TFhirPublicationStatusEnum, child, path+'/status')
      else if (child.localName = 'experimental') then
        value.experimentalElement := ParseBoolean(child, path+'/experimental')
      else if (child.localName = 'subjectCodeableConcept') then
        value.subject := ParseCodeableConcept(child, path+'/subjectCodeableConcept')
      else if (child.localName = 'subjectReference') then
        value.subject := ParseReference(child, path+'/subjectReference')
      else if (child.localName = 'basis') then
        value.basisElement := ParseEnum(CODES_TFhirFHIRTypesEnum, SYSTEMS_TFhirFHIRTypesEnum, child, path+'/basis')
      else if (child.localName = 'date') then
        value.dateElement := ParseDateTime(child, path+'/date')
      else if (child.localName = 'publisher') then
        value.publisherElement := ParseString(child, path+'/publisher')
      else if (child.localName = 'contact') then
        value.contactList.Add(ParseContactDetail(child, path+'/contact'))
      else if (child.localName = 'description') then
        value.descriptionElement := ParseMarkdown(child, path+'/description')
      else if (child.localName = 'useContext') then
        value.useContextList.Add(ParseUsageContext(child, path+'/useContext'))
      else if (child.localName = 'jurisdiction') then
        value.jurisdictionList.Add(ParseCodeableConcept(child, path+'/jurisdiction'))
      else if (child.localName = 'purpose') then
        value.purposeElement := ParseMarkdown(child, path+'/purpose')
      else if (child.localName = 'usage') then
        value.usageElement := ParseString(child, path+'/usage')
      else if (child.localName = 'copyright') then
        value.copyrightElement := ParseMarkdown(child, path+'/copyright')
      else if (child.localName = 'approvalDate') then
        value.approvalDateElement := ParseDate(child, path+'/approvalDate')
      else if (child.localName = 'lastReviewDate') then
        value.lastReviewDateElement := ParseDate(child, path+'/lastReviewDate')
      else if (child.localName = 'effectivePeriod') then
        value.effectivePeriod := ParsePeriod(child, path+'/effectivePeriod')
      else if (child.localName = 'topic') then
        value.topicList.Add(ParseCodeableConcept(child, path+'/topic'))
      else if (child.localName = 'author') then
        value.authorList.Add(ParseContactDetail(child, path+'/author'))
      else if (child.localName = 'editor') then
        value.editorList.Add(ParseContactDetail(child, path+'/editor'))
      else if (child.localName = 'reviewer') then
        value.reviewerList.Add(ParseContactDetail(child, path+'/reviewer'))
      else if (child.localName = 'endorser') then
        value.endorserList.Add(ParseContactDetail(child, path+'/endorser'))
      else if (child.localName = 'relatedArtifact') then
        value.relatedArtifactList.Add(ParseRelatedArtifact(child, path+'/relatedArtifact'))
      else if (child.localName = 'library') then
        value.library_List.Add(ParseCanonical(child, path+'/library'))
      else if (child.localName = 'disclaimer') then
        value.disclaimerElement := ParseMarkdown(child, path+'/disclaimer')
      else if (child.localName = 'scoring') then
        value.scoring := ParseCodeableConcept(child, path+'/scoring')
      else if (child.localName = 'scoringUnit') then
        value.scoringUnit := ParseCodeableConcept(child, path+'/scoringUnit')
      else if (child.localName = 'compositeScoring') then
        value.compositeScoring := ParseCodeableConcept(child, path+'/compositeScoring')
      else if (child.localName = 'type') then
        value.type_List.Add(ParseCodeableConcept(child, path+'/type'))
      else if (child.localName = 'riskAdjustment') then
        value.riskAdjustmentElement := ParseString(child, path+'/riskAdjustment')
      else if (child.localName = 'rateAggregation') then
        value.rateAggregationElement := ParseString(child, path+'/rateAggregation')
      else if (child.localName = 'rationale') then
        value.rationaleElement := ParseMarkdown(child, path+'/rationale')
      else if (child.localName = 'clinicalRecommendationStatement') then
        value.clinicalRecommendationStatementElement := ParseMarkdown(child, path+'/clinicalRecommendationStatement')
      else if (child.localName = 'improvementNotation') then
        value.improvementNotation := ParseCodeableConcept(child, path+'/improvementNotation')
      else if (child.localName = 'term') then
        value.termList.Add(ParseMeasureTerm(child, path+'/term'))
      else if (child.localName = 'guidance') then
        value.guidanceElement := ParseMarkdown(child, path+'/guidance')
      else if (child.localName = 'group') then
        value.groupList.Add(ParseMeasureGroup(child, path+'/group'))
      else if (child.localName = 'supplementalData') then
        value.supplementalDataList.Add(ParseMeasureSupplementalData(child, path+'/supplementalData'))
      else if Not ParseMetadataResourceChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeMeasure(xml : TXmlBuilder; name : String; value : TFhirMeasure);
begin
  if (value = nil) then
    exit;
  composeMetadataResourceAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeMeasureChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeMeasureChildren(xml : TXmlBuilder; value : TFhirMeasure);
var
  i : integer;
begin
  composeMetadataResourceChildren(xml, value);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeUri(xml, 'url', value.urlElement);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.identifierList.Count - 1 do
      ComposeIdentifier(xml, 'identifier', value.identifierList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(xml, 'version', value.versionElement);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(xml, 'name', value.nameElement);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(xml, 'title', value.titleElement);
  if (SummaryOption in [soFull, soData]) then
    ComposeString(xml, 'subtitle', value.subtitleElement);
  ComposeEnum(xml, 'status', value.statusElement, CODES_TFhirPublicationStatusEnum);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeBoolean(xml, 'experimental', value.experimentalElement);
  if (SummaryOption in [soFull, soData]) and (value.subject is TFhirCodeableConcept) {6} then
    ComposeCodeableConcept(xml, 'subjectCodeableConcept', TFhirCodeableConcept(value.subject))
  else if (SummaryOption in [soFull, soData]) and (value.subject is TFhirReference) {2} then
    ComposeReference(xml, 'subjectReference', TFhirReference(value.subject));
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeEnum(xml, 'basis', value.basisElement, CODES_TFhirFHIRTypesEnum);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDateTime(xml, 'date', value.dateElement);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(xml, 'publisher', value.publisherElement);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.contactList.Count - 1 do
      ComposeContactDetail(xml, 'contact', value.contactList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeMarkdown(xml, 'description', value.descriptionElement);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.useContextList.Count - 1 do
      ComposeUsageContext(xml, 'useContext', value.useContextList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.jurisdictionList.Count - 1 do
      ComposeCodeableConcept(xml, 'jurisdiction', value.jurisdictionList[i]);
  if (SummaryOption in [soFull, soData]) then
    ComposeMarkdown(xml, 'purpose', value.purposeElement);
  if (SummaryOption in [soFull, soData]) then
    ComposeString(xml, 'usage', value.usageElement);
  if (SummaryOption in [soFull, soData]) then
    ComposeMarkdown(xml, 'copyright', value.copyrightElement);
  if (SummaryOption in [soFull, soData]) then
    ComposeDate(xml, 'approvalDate', value.approvalDateElement);
  if (SummaryOption in [soFull, soData]) then
    ComposeDate(xml, 'lastReviewDate', value.lastReviewDateElement);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposePeriod(xml, 'effectivePeriod', value.effectivePeriod);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.topicList.Count - 1 do
      ComposeCodeableConcept(xml, 'topic', value.topicList[i]);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.authorList.Count - 1 do
      ComposeContactDetail(xml, 'author', value.authorList[i]);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.editorList.Count - 1 do
      ComposeContactDetail(xml, 'editor', value.editorList[i]);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.reviewerList.Count - 1 do
      ComposeContactDetail(xml, 'reviewer', value.reviewerList[i]);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.endorserList.Count - 1 do
      ComposeContactDetail(xml, 'endorser', value.endorserList[i]);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.relatedArtifactList.Count - 1 do
      ComposeRelatedArtifact(xml, 'relatedArtifact', value.relatedArtifactList[i]);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.library_List.Count - 1 do
      ComposeCanonical(xml, 'library', value.library_List[i]);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeMarkdown(xml, 'disclaimer', value.disclaimerElement);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(xml, 'scoring', value.scoring);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(xml, 'scoringUnit', value.scoringUnit);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(xml, 'compositeScoring', value.compositeScoring);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.type_List.Count - 1 do
      ComposeCodeableConcept(xml, 'type', value.type_List[i]);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(xml, 'riskAdjustment', value.riskAdjustmentElement);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(xml, 'rateAggregation', value.rateAggregationElement);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeMarkdown(xml, 'rationale', value.rationaleElement);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeMarkdown(xml, 'clinicalRecommendationStatement', value.clinicalRecommendationStatementElement);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(xml, 'improvementNotation', value.improvementNotation);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.termList.Count - 1 do
      ComposeMeasureTerm(xml, 'term', value.termList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeMarkdown(xml, 'guidance', value.guidanceElement);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.groupList.Count - 1 do
      ComposeMeasureGroup(xml, 'group', value.groupList[i]);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.supplementalDataList.Count - 1 do
      ComposeMeasureSupplementalData(xml, 'supplementalData', value.supplementalDataList[i]);
end;

{$ENDIF FHIR_MEASURE}
{$IFDEF FHIR_MEASUREREPORT}
function TFHIRXmlParser.ParseMeasureReportGroup(element : TMXmlElement; path : string) : TFhirMeasureReportGroup;
var
  child : TMXmlElement;
begin
  result := TFhirMeasureReportGroup.Create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseMeasureReportGroupChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseMeasureReportGroupChild(value : TFhirMeasureReportGroup; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'code') then
        value.code := ParseCodeableConcept(child, path+'/code')
      else if (child.localName = 'population') then
        value.populationList.Add(ParseMeasureReportGroupPopulation(child, path+'/population'))
      else if (child.localName = 'measureScoreQuantity') then
        value.measureScore := ParseQuantity(child, path+'/measureScoreQuantity')
      else if (child.localName = 'measureScoreCodeableConcept') then
        value.measureScore := ParseCodeableConcept(child, path+'/measureScoreCodeableConcept')
      else if (child.localName = 'measureScorePeriod') then
        value.measureScore := ParsePeriod(child, path+'/measureScorePeriod')
      else if (child.localName = 'measureScoreRange') then
        value.measureScore := ParseRange(child, path+'/measureScoreRange')
      else if (child.localName = 'measureScoreDuration') then
        value.measureScore := ParseDuration(child, path+'/measureScoreDuration')
      else if (child.localName = 'measureScoreDateTime') then
        value.measureScore := ParseDateTime(child, path+'/measureScoreDateTime')
      else if (child.localName = 'stratifier') then
        value.stratifierList.Add(ParseMeasureReportGroupStratifier(child, path+'/stratifier'))
      else if Not ParseBackboneElementChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeMeasureReportGroup(xml : TXmlBuilder; name : String; value : TFhirMeasureReportGroup);
begin
  if (value = nil) then
    exit;
  composeElementAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeMeasureReportGroupChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeMeasureReportGroupChildren(xml : TXmlBuilder; value : TFhirMeasureReportGroup);
var
  i : integer;
begin
  composeBackboneElementChildren(xml, value);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(xml, 'code', value.code);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.populationList.Count - 1 do
      ComposeMeasureReportGroupPopulation(xml, 'population', value.populationList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) and (value.measureScore is TFhirQuantity) {6} then
    ComposeQuantity(xml, 'measureScoreQuantity', TFhirQuantity(value.measureScore))
  else if (SummaryOption in [soFull, soSummary, soData]) and (value.measureScore is TFhirCodeableConcept) {6} then
    ComposeCodeableConcept(xml, 'measureScoreCodeableConcept', TFhirCodeableConcept(value.measureScore))
  else if (SummaryOption in [soFull, soSummary, soData]) and (value.measureScore is TFhirPeriod) {6} then
    ComposePeriod(xml, 'measureScorePeriod', TFhirPeriod(value.measureScore))
  else if (SummaryOption in [soFull, soSummary, soData]) and (value.measureScore is TFhirRange) {6} then
    ComposeRange(xml, 'measureScoreRange', TFhirRange(value.measureScore))
  else if (SummaryOption in [soFull, soSummary, soData]) and (value.measureScore is TFhirDuration) {6} then
    ComposeDuration(xml, 'measureScoreDuration', TFhirDuration(value.measureScore))
  else if (SummaryOption in [soFull, soSummary, soData]) and (value.measureScore is TFhirDateTime) {6} then
    ComposeDateTime(xml, 'measureScoreDateTime', TFhirDateTime(value.measureScore));
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.stratifierList.Count - 1 do
      ComposeMeasureReportGroupStratifier(xml, 'stratifier', value.stratifierList[i]);
end;

function TFHIRXmlParser.ParseMeasureReportGroupPopulation(element : TMXmlElement; path : string) : TFhirMeasureReportGroupPopulation;
var
  child : TMXmlElement;
begin
  result := TFhirMeasureReportGroupPopulation.Create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseMeasureReportGroupPopulationChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseMeasureReportGroupPopulationChild(value : TFhirMeasureReportGroupPopulation; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'code') then
        value.code := ParseCodeableConcept(child, path+'/code')
      else if (child.localName = 'count') then
        value.countElement := ParseInteger(child, path+'/count')
      else if (child.localName = 'subjectResults') then
        value.subjectResults := ParseReference(child, path+'/subjectResults')
      else if Not ParseBackboneElementChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeMeasureReportGroupPopulation(xml : TXmlBuilder; name : String; value : TFhirMeasureReportGroupPopulation);
begin
  if (value = nil) then
    exit;
  composeElementAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeMeasureReportGroupPopulationChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeMeasureReportGroupPopulationChildren(xml : TXmlBuilder; value : TFhirMeasureReportGroupPopulation);
begin
  composeBackboneElementChildren(xml, value);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(xml, 'code', value.code);
  if (SummaryOption in [soFull, soData]) then
    ComposeInteger(xml, 'count', value.countElement);
  if (SummaryOption in [soFull, soData]) then
    ComposeReference(xml, 'subjectResults', value.subjectResults);
end;

function TFHIRXmlParser.ParseMeasureReportGroupStratifier(element : TMXmlElement; path : string) : TFhirMeasureReportGroupStratifier;
var
  child : TMXmlElement;
begin
  result := TFhirMeasureReportGroupStratifier.Create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseMeasureReportGroupStratifierChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseMeasureReportGroupStratifierChild(value : TFhirMeasureReportGroupStratifier; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'code') then
        value.code := ParseCodeableConcept(child, path+'/code')
      else if (child.localName = 'stratum') then
        value.stratumList.Add(ParseMeasureReportGroupStratifierStratum(child, path+'/stratum'))
      else if Not ParseBackboneElementChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeMeasureReportGroupStratifier(xml : TXmlBuilder; name : String; value : TFhirMeasureReportGroupStratifier);
begin
  if (value = nil) then
    exit;
  composeElementAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeMeasureReportGroupStratifierChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeMeasureReportGroupStratifierChildren(xml : TXmlBuilder; value : TFhirMeasureReportGroupStratifier);
var
  i : integer;
begin
  composeBackboneElementChildren(xml, value);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(xml, 'code', value.code);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.stratumList.Count - 1 do
      ComposeMeasureReportGroupStratifierStratum(xml, 'stratum', value.stratumList[i]);
end;

function TFHIRXmlParser.ParseMeasureReportGroupStratifierStratum(element : TMXmlElement; path : string) : TFhirMeasureReportGroupStratifierStratum;
var
  child : TMXmlElement;
begin
  result := TFhirMeasureReportGroupStratifierStratum.Create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseMeasureReportGroupStratifierStratumChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseMeasureReportGroupStratifierStratumChild(value : TFhirMeasureReportGroupStratifierStratum; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'valueCodeableConcept') then
        value.value := ParseCodeableConcept(child, path+'/valueCodeableConcept')
      else if (child.localName = 'valueQuantity') then
        value.value := ParseQuantity(child, path+'/valueQuantity')
      else if (child.localName = 'valueRange') then
        value.value := ParseRange(child, path+'/valueRange')
      else if (child.localName = 'valueReference') then
        value.value := ParseReference(child, path+'/valueReference')
      else if (child.localName = 'valueBoolean') then
        value.value := ParseBoolean(child, path+'/valueBoolean')
      else if (child.localName = 'component') then
        value.componentList.Add(ParseMeasureReportGroupStratifierStratumComponent(child, path+'/component'))
      else if (child.localName = 'population') then
        value.populationList.Add(ParseMeasureReportGroupStratifierStratumPopulation(child, path+'/population'))
      else if (child.localName = 'measureScoreQuantity') then
        value.measureScore := ParseQuantity(child, path+'/measureScoreQuantity')
      else if (child.localName = 'measureScoreCodeableConcept') then
        value.measureScore := ParseCodeableConcept(child, path+'/measureScoreCodeableConcept')
      else if (child.localName = 'measureScorePeriod') then
        value.measureScore := ParsePeriod(child, path+'/measureScorePeriod')
      else if (child.localName = 'measureScoreRange') then
        value.measureScore := ParseRange(child, path+'/measureScoreRange')
      else if (child.localName = 'measureScoreDuration') then
        value.measureScore := ParseDuration(child, path+'/measureScoreDuration')
      else if (child.localName = 'measureScoreDateTime') then
        value.measureScore := ParseDateTime(child, path+'/measureScoreDateTime')
      else if Not ParseBackboneElementChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeMeasureReportGroupStratifierStratum(xml : TXmlBuilder; name : String; value : TFhirMeasureReportGroupStratifierStratum);
begin
  if (value = nil) then
    exit;
  composeElementAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeMeasureReportGroupStratifierStratumChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeMeasureReportGroupStratifierStratumChildren(xml : TXmlBuilder; value : TFhirMeasureReportGroupStratifierStratum);
var
  i : integer;
begin
  composeBackboneElementChildren(xml, value);
  if (SummaryOption in [soFull, soData]) and (value.value is TFhirCodeableConcept) {6} then
    ComposeCodeableConcept(xml, 'valueCodeableConcept', TFhirCodeableConcept(value.value))
  else if (SummaryOption in [soFull, soData]) and (value.value is TFhirQuantity) {6} then
    ComposeQuantity(xml, 'valueQuantity', TFhirQuantity(value.value))
  else if (SummaryOption in [soFull, soData]) and (value.value is TFhirRange) {6} then
    ComposeRange(xml, 'valueRange', TFhirRange(value.value))
  else if (SummaryOption in [soFull, soData]) and (value.value is TFhirReference) {6} then
    ComposeReference(xml, 'valueReference', TFhirReference(value.value))
  else if (SummaryOption in [soFull, soData]) and (value.value is TFhirBoolean) {6} then
    ComposeBoolean(xml, 'valueBoolean', TFhirBoolean(value.value));
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.componentList.Count - 1 do
      ComposeMeasureReportGroupStratifierStratumComponent(xml, 'component', value.componentList[i]);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.populationList.Count - 1 do
      ComposeMeasureReportGroupStratifierStratumPopulation(xml, 'population', value.populationList[i]);
  if (SummaryOption in [soFull, soData]) and (value.measureScore is TFhirQuantity) {6} then
    ComposeQuantity(xml, 'measureScoreQuantity', TFhirQuantity(value.measureScore))
  else if (SummaryOption in [soFull, soData]) and (value.measureScore is TFhirCodeableConcept) {6} then
    ComposeCodeableConcept(xml, 'measureScoreCodeableConcept', TFhirCodeableConcept(value.measureScore))
  else if (SummaryOption in [soFull, soData]) and (value.measureScore is TFhirPeriod) {6} then
    ComposePeriod(xml, 'measureScorePeriod', TFhirPeriod(value.measureScore))
  else if (SummaryOption in [soFull, soData]) and (value.measureScore is TFhirRange) {6} then
    ComposeRange(xml, 'measureScoreRange', TFhirRange(value.measureScore))
  else if (SummaryOption in [soFull, soData]) and (value.measureScore is TFhirDuration) {6} then
    ComposeDuration(xml, 'measureScoreDuration', TFhirDuration(value.measureScore))
  else if (SummaryOption in [soFull, soData]) and (value.measureScore is TFhirDateTime) {6} then
    ComposeDateTime(xml, 'measureScoreDateTime', TFhirDateTime(value.measureScore));
end;

function TFHIRXmlParser.ParseMeasureReportGroupStratifierStratumComponent(element : TMXmlElement; path : string) : TFhirMeasureReportGroupStratifierStratumComponent;
var
  child : TMXmlElement;
begin
  result := TFhirMeasureReportGroupStratifierStratumComponent.Create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseMeasureReportGroupStratifierStratumComponentChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseMeasureReportGroupStratifierStratumComponentChild(value : TFhirMeasureReportGroupStratifierStratumComponent; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'code') then
        value.code := ParseCodeableConcept(child, path+'/code')
      else if (child.localName = 'valueCodeableConcept') then
        value.value := ParseCodeableConcept(child, path+'/valueCodeableConcept')
      else if (child.localName = 'valueQuantity') then
        value.value := ParseQuantity(child, path+'/valueQuantity')
      else if (child.localName = 'valueRange') then
        value.value := ParseRange(child, path+'/valueRange')
      else if (child.localName = 'valueReference') then
        value.value := ParseReference(child, path+'/valueReference')
      else if (child.localName = 'valueBoolean') then
        value.value := ParseBoolean(child, path+'/valueBoolean')
      else if Not ParseBackboneElementChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeMeasureReportGroupStratifierStratumComponent(xml : TXmlBuilder; name : String; value : TFhirMeasureReportGroupStratifierStratumComponent);
begin
  if (value = nil) then
    exit;
  composeElementAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeMeasureReportGroupStratifierStratumComponentChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeMeasureReportGroupStratifierStratumComponentChildren(xml : TXmlBuilder; value : TFhirMeasureReportGroupStratifierStratumComponent);
begin
  composeBackboneElementChildren(xml, value);
  ComposeCodeableConcept(xml, 'code', value.code);
  if (value.value is TFhirCodeableConcept) {6} then
    ComposeCodeableConcept(xml, 'valueCodeableConcept', TFhirCodeableConcept(value.value))
  else if (value.value is TFhirQuantity) {6} then
    ComposeQuantity(xml, 'valueQuantity', TFhirQuantity(value.value))
  else if (value.value is TFhirRange) {6} then
    ComposeRange(xml, 'valueRange', TFhirRange(value.value))
  else if (value.value is TFhirReference) {6} then
    ComposeReference(xml, 'valueReference', TFhirReference(value.value))
  else if (value.value is TFhirBoolean) {6} then
    ComposeBoolean(xml, 'valueBoolean', TFhirBoolean(value.value));
end;

function TFHIRXmlParser.ParseMeasureReportGroupStratifierStratumPopulation(element : TMXmlElement; path : string) : TFhirMeasureReportGroupStratifierStratumPopulation;
var
  child : TMXmlElement;
begin
  result := TFhirMeasureReportGroupStratifierStratumPopulation.Create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseMeasureReportGroupStratifierStratumPopulationChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseMeasureReportGroupStratifierStratumPopulationChild(value : TFhirMeasureReportGroupStratifierStratumPopulation; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'code') then
        value.code := ParseCodeableConcept(child, path+'/code')
      else if (child.localName = 'count') then
        value.countElement := ParseInteger(child, path+'/count')
      else if (child.localName = 'subjectResults') then
        value.subjectResults := ParseReference(child, path+'/subjectResults')
      else if Not ParseBackboneElementChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeMeasureReportGroupStratifierStratumPopulation(xml : TXmlBuilder; name : String; value : TFhirMeasureReportGroupStratifierStratumPopulation);
begin
  if (value = nil) then
    exit;
  composeElementAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeMeasureReportGroupStratifierStratumPopulationChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeMeasureReportGroupStratifierStratumPopulationChildren(xml : TXmlBuilder; value : TFhirMeasureReportGroupStratifierStratumPopulation);
begin
  composeBackboneElementChildren(xml, value);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(xml, 'code', value.code);
  if (SummaryOption in [soFull, soData]) then
    ComposeInteger(xml, 'count', value.countElement);
  if (SummaryOption in [soFull, soData]) then
    ComposeReference(xml, 'subjectResults', value.subjectResults);
end;

function TFHIRXmlParser.ParseMeasureReport(element : TMXmlElement; path : string) : TFhirMeasureReport;
var
  child : TMXmlElement;
begin
  result := TFhirMeasureReport.Create;
  try
    parseDomainResourceAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseMeasureReportChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseMeasureReportChild(value : TFhirMeasureReport; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'identifier') then
        value.identifierList.Add(ParseIdentifier(child, path+'/identifier'))
      else if (child.localName = 'status') then
        value.statusElement := ParseEnum(CODES_TFhirMeasureReportStatusEnum, SYSTEMS_TFhirMeasureReportStatusEnum, child, path+'/status')
      else if (child.localName = 'type') then
        value.type_Element := ParseEnum(CODES_TFhirMeasureReportTypeEnum, SYSTEMS_TFhirMeasureReportTypeEnum, child, path+'/type')
      else if (child.localName = 'dataUpdateType') then
        value.dataUpdateTypeElement := ParseEnum(CODES_TFhirSubmitDataUpdateTypeEnum, SYSTEMS_TFhirSubmitDataUpdateTypeEnum, child, path+'/dataUpdateType')
      else if (child.localName = 'measure') then
        value.measureElement := ParseCanonical(child, path+'/measure')
      else if (child.localName = 'subject') then
        value.subject := ParseReference(child, path+'/subject')
      else if (child.localName = 'date') then
        value.dateElement := ParseDateTime(child, path+'/date')
      else if (child.localName = 'reporter') then
        value.reporter := ParseReference(child, path+'/reporter')
      else if (child.localName = 'reportingVendor') then
        value.reportingVendor := ParseReference(child, path+'/reportingVendor')
      else if (child.localName = 'location') then
        value.location := ParseReference(child, path+'/location')
      else if (child.localName = 'period') then
        value.period := ParsePeriod(child, path+'/period')
      else if (child.localName = 'inputParameters') then
        value.inputParameters := ParseReference(child, path+'/inputParameters')
      else if (child.localName = 'scoring') then
        value.scoring := ParseCodeableConcept(child, path+'/scoring')
      else if (child.localName = 'improvementNotation') then
        value.improvementNotation := ParseCodeableConcept(child, path+'/improvementNotation')
      else if (child.localName = 'group') then
        value.groupList.Add(ParseMeasureReportGroup(child, path+'/group'))
      else if (child.localName = 'evaluatedResource') then
        value.evaluatedResourceList.Add(ParseReference(child, path+'/evaluatedResource'))
      else if Not ParseDomainResourceChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeMeasureReport(xml : TXmlBuilder; name : String; value : TFhirMeasureReport);
begin
  if (value = nil) then
    exit;
  composeDomainResourceAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeMeasureReportChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeMeasureReportChildren(xml : TXmlBuilder; value : TFhirMeasureReport);
var
  i : integer;
begin
  composeDomainResourceChildren(xml, value);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.identifierList.Count - 1 do
      ComposeIdentifier(xml, 'identifier', value.identifierList[i]);
  ComposeEnum(xml, 'status', value.statusElement, CODES_TFhirMeasureReportStatusEnum);
  ComposeEnum(xml, 'type', value.type_Element, CODES_TFhirMeasureReportTypeEnum);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeEnum(xml, 'dataUpdateType', value.dataUpdateTypeElement, CODES_TFhirSubmitDataUpdateTypeEnum);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCanonical(xml, 'measure', value.measureElement);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference(xml, 'subject', value.subject);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDateTime(xml, 'date', value.dateElement);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference(xml, 'reporter', value.reporter);
  if (SummaryOption in [soFull, soData]) then
    ComposeReference(xml, 'reportingVendor', value.reportingVendor);
  if (SummaryOption in [soFull, soData]) then
    ComposeReference(xml, 'location', value.location);
  ComposePeriod(xml, 'period', value.period);
  if (SummaryOption in [soFull, soData]) then
    ComposeReference(xml, 'inputParameters', value.inputParameters);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(xml, 'scoring', value.scoring);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(xml, 'improvementNotation', value.improvementNotation);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.groupList.Count - 1 do
      ComposeMeasureReportGroup(xml, 'group', value.groupList[i]);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.evaluatedResourceList.Count - 1 do
      ComposeReference(xml, 'evaluatedResource', value.evaluatedResourceList[i]);
end;

{$ENDIF FHIR_MEASUREREPORT}
{$IFDEF FHIR_MEDICATION}
function TFHIRXmlParser.ParseMedicationIngredient(element : TMXmlElement; path : string) : TFhirMedicationIngredient;
var
  child : TMXmlElement;
begin
  result := TFhirMedicationIngredient.Create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseMedicationIngredientChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseMedicationIngredientChild(value : TFhirMedicationIngredient; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'item') then
        value.item := ParseCodeableReference(child, path+'/item')
      else if (child.localName = 'isActive') then
        value.isActiveElement := ParseBoolean(child, path+'/isActive')
      else if (child.localName = 'strengthRatio') then
        value.strength := ParseRatio(child, path+'/strengthRatio')
      else if (child.localName = 'strengthCodeableConcept') then
        value.strength := ParseCodeableConcept(child, path+'/strengthCodeableConcept')
      else if (child.localName = 'strengthQuantity') then
        value.strength := ParseQuantity(child, path+'/strengthQuantity')
      else if Not ParseBackboneElementChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeMedicationIngredient(xml : TXmlBuilder; name : String; value : TFhirMedicationIngredient);
begin
  if (value = nil) then
    exit;
  composeElementAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeMedicationIngredientChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeMedicationIngredientChildren(xml : TXmlBuilder; value : TFhirMedicationIngredient);
begin
  composeBackboneElementChildren(xml, value);
  ComposeCodeableReference(xml, 'item', value.item);
  if (SummaryOption in [soFull, soData]) then
    ComposeBoolean(xml, 'isActive', value.isActiveElement);
  if (SummaryOption in [soFull, soData]) and (value.strength is TFhirRatio) {6} then
    ComposeRatio(xml, 'strengthRatio', TFhirRatio(value.strength))
  else if (SummaryOption in [soFull, soData]) and (value.strength is TFhirCodeableConcept) {6} then
    ComposeCodeableConcept(xml, 'strengthCodeableConcept', TFhirCodeableConcept(value.strength))
  else if (SummaryOption in [soFull, soData]) and (value.strength is TFhirQuantity) {6} then
    ComposeQuantity(xml, 'strengthQuantity', TFhirQuantity(value.strength));
end;

function TFHIRXmlParser.ParseMedicationBatch(element : TMXmlElement; path : string) : TFhirMedicationBatch;
var
  child : TMXmlElement;
begin
  result := TFhirMedicationBatch.Create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseMedicationBatchChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseMedicationBatchChild(value : TFhirMedicationBatch; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'lotNumber') then
        value.lotNumberElement := ParseString(child, path+'/lotNumber')
      else if (child.localName = 'expirationDate') then
        value.expirationDateElement := ParseDateTime(child, path+'/expirationDate')
      else if Not ParseBackboneElementChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeMedicationBatch(xml : TXmlBuilder; name : String; value : TFhirMedicationBatch);
begin
  if (value = nil) then
    exit;
  composeElementAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeMedicationBatchChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeMedicationBatchChildren(xml : TXmlBuilder; value : TFhirMedicationBatch);
begin
  composeBackboneElementChildren(xml, value);
  if (SummaryOption in [soFull, soData]) then
    ComposeString(xml, 'lotNumber', value.lotNumberElement);
  if (SummaryOption in [soFull, soData]) then
    ComposeDateTime(xml, 'expirationDate', value.expirationDateElement);
end;

function TFHIRXmlParser.ParseMedication(element : TMXmlElement; path : string) : TFhirMedication;
var
  child : TMXmlElement;
begin
  result := TFhirMedication.Create;
  try
    parseDomainResourceAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseMedicationChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseMedicationChild(value : TFhirMedication; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'identifier') then
        value.identifierList.Add(ParseIdentifier(child, path+'/identifier'))
      else if (child.localName = 'code') then
        value.code := ParseCodeableConcept(child, path+'/code')
      else if (child.localName = 'status') then
        value.statusElement := ParseEnum(CODES_TFhirMedicationStatusCodesEnum, SYSTEMS_TFhirMedicationStatusCodesEnum, child, path+'/status')
      else if (child.localName = 'marketingAuthorizationHolder') then
        value.marketingAuthorizationHolder := ParseReference(child, path+'/marketingAuthorizationHolder')
      else if (child.localName = 'doseForm') then
        value.doseForm := ParseCodeableConcept(child, path+'/doseForm')
      else if (child.localName = 'totalVolume') then
        value.totalVolume := ParseRatio(child, path+'/totalVolume')
      else if (child.localName = 'ingredient') then
        value.ingredientList.Add(ParseMedicationIngredient(child, path+'/ingredient'))
      else if (child.localName = 'batch') then
        value.batch := ParseMedicationBatch(child, path+'/batch')
      else if Not ParseDomainResourceChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeMedication(xml : TXmlBuilder; name : String; value : TFhirMedication);
begin
  if (value = nil) then
    exit;
  composeDomainResourceAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeMedicationChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeMedicationChildren(xml : TXmlBuilder; value : TFhirMedication);
var
  i : integer;
begin
  composeDomainResourceChildren(xml, value);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.identifierList.Count - 1 do
      ComposeIdentifier(xml, 'identifier', value.identifierList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(xml, 'code', value.code);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeEnum(xml, 'status', value.statusElement, CODES_TFhirMedicationStatusCodesEnum);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference(xml, 'marketingAuthorizationHolder', value.marketingAuthorizationHolder);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(xml, 'doseForm', value.doseForm);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeRatio(xml, 'totalVolume', value.totalVolume);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.ingredientList.Count - 1 do
      ComposeMedicationIngredient(xml, 'ingredient', value.ingredientList[i]);
  if (SummaryOption in [soFull, soData]) then
    ComposeMedicationBatch(xml, 'batch', value.batch);
end;

{$ENDIF FHIR_MEDICATION}
{$IFDEF FHIR_MEDICATIONADMINISTRATION}
function TFHIRXmlParser.ParseMedicationAdministrationPerformer(element : TMXmlElement; path : string) : TFhirMedicationAdministrationPerformer;
var
  child : TMXmlElement;
begin
  result := TFhirMedicationAdministrationPerformer.Create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseMedicationAdministrationPerformerChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseMedicationAdministrationPerformerChild(value : TFhirMedicationAdministrationPerformer; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'function') then
        value.function_ := ParseCodeableConcept(child, path+'/function')
      else if (child.localName = 'actor') then
        value.actor := ParseReference(child, path+'/actor')
      else if Not ParseBackboneElementChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeMedicationAdministrationPerformer(xml : TXmlBuilder; name : String; value : TFhirMedicationAdministrationPerformer);
begin
  if (value = nil) then
    exit;
  composeElementAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeMedicationAdministrationPerformerChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeMedicationAdministrationPerformerChildren(xml : TXmlBuilder; value : TFhirMedicationAdministrationPerformer);
begin
  composeBackboneElementChildren(xml, value);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(xml, 'function', value.function_);
  ComposeReference(xml, 'actor', value.actor);
end;

function TFHIRXmlParser.ParseMedicationAdministrationDosage(element : TMXmlElement; path : string) : TFhirMedicationAdministrationDosage;
var
  child : TMXmlElement;
begin
  result := TFhirMedicationAdministrationDosage.Create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseMedicationAdministrationDosageChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseMedicationAdministrationDosageChild(value : TFhirMedicationAdministrationDosage; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'text') then
        value.textElement := ParseString(child, path+'/text')
      else if (child.localName = 'site') then
        value.site := ParseCodeableConcept(child, path+'/site')
      else if (child.localName = 'route') then
        value.route := ParseCodeableConcept(child, path+'/route')
      else if (child.localName = 'method') then
        value.method := ParseCodeableConcept(child, path+'/method')
      else if (child.localName = 'dose') then
        value.dose := ParseQuantity(child, path+'/dose')
      else if (child.localName = 'rateRatio') then
        value.rate := ParseRatio(child, path+'/rateRatio')
      else if (child.localName = 'rateQuantity') then
        value.rate := ParseQuantity(child, path+'/rateQuantity')
      else if Not ParseBackboneElementChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeMedicationAdministrationDosage(xml : TXmlBuilder; name : String; value : TFhirMedicationAdministrationDosage);
begin
  if (value = nil) then
    exit;
  composeElementAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeMedicationAdministrationDosageChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeMedicationAdministrationDosageChildren(xml : TXmlBuilder; value : TFhirMedicationAdministrationDosage);
begin
  composeBackboneElementChildren(xml, value);
  if (SummaryOption in [soFull, soData]) then
    ComposeString(xml, 'text', value.textElement);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(xml, 'site', value.site);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(xml, 'route', value.route);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(xml, 'method', value.method);
  if (SummaryOption in [soFull, soData]) then
    ComposeQuantity(xml, 'dose', value.dose);
  if (SummaryOption in [soFull, soData]) and (value.rate is TFhirRatio) {6} then
    ComposeRatio(xml, 'rateRatio', TFhirRatio(value.rate))
  else if (SummaryOption in [soFull, soData]) and (value.rate is TFhirQuantity) {6} then
    ComposeQuantity(xml, 'rateQuantity', TFhirQuantity(value.rate));
end;

function TFHIRXmlParser.ParseMedicationAdministration(element : TMXmlElement; path : string) : TFhirMedicationAdministration;
var
  child : TMXmlElement;
begin
  result := TFhirMedicationAdministration.Create;
  try
    parseDomainResourceAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseMedicationAdministrationChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseMedicationAdministrationChild(value : TFhirMedicationAdministration; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'identifier') then
        value.identifierList.Add(ParseIdentifier(child, path+'/identifier'))
      else if (child.localName = 'basedOn') then
        value.basedOnList.Add(ParseReference(child, path+'/basedOn'))
      else if (child.localName = 'partOf') then
        value.partOfList.Add(ParseReference(child, path+'/partOf'))
      else if (child.localName = 'status') then
        value.statusElement := ParseEnum(CODES_TFhirMedicationAdministrationStatusCodesEnum, SYSTEMS_TFhirMedicationAdministrationStatusCodesEnum, child, path+'/status')
      else if (child.localName = 'statusReason') then
        value.statusReasonList.Add(ParseCodeableConcept(child, path+'/statusReason'))
      else if (child.localName = 'category') then
        value.categoryList.Add(ParseCodeableConcept(child, path+'/category'))
      else if (child.localName = 'medication') then
        value.medication := ParseCodeableReference(child, path+'/medication')
      else if (child.localName = 'subject') then
        value.subject := ParseReference(child, path+'/subject')
      else if (child.localName = 'encounter') then
        value.encounter := ParseReference(child, path+'/encounter')
      else if (child.localName = 'supportingInformation') then
        value.supportingInformationList.Add(ParseReference(child, path+'/supportingInformation'))
      else if (child.localName = 'occurencePeriod') then
        value.occurence := ParsePeriod(child, path+'/occurencePeriod')
      else if (child.localName = 'occurenceDateTime') then
        value.occurence := ParseDateTime(child, path+'/occurenceDateTime')
      else if (child.localName = 'recorded') then
        value.recordedElement := ParseDateTime(child, path+'/recorded')
      else if (child.localName = 'isSubPotent') then
        value.isSubPotentElement := ParseBoolean(child, path+'/isSubPotent')
      else if (child.localName = 'subPotentReason') then
        value.subPotentReasonList.Add(ParseCodeableConcept(child, path+'/subPotentReason'))
      else if (child.localName = 'performer') then
        value.performerList.Add(ParseMedicationAdministrationPerformer(child, path+'/performer'))
      else if (child.localName = 'reason') then
        value.reasonList.Add(ParseCodeableReference(child, path+'/reason'))
      else if (child.localName = 'request') then
        value.request := ParseReference(child, path+'/request')
      else if (child.localName = 'device') then
        value.deviceList.Add(ParseReference(child, path+'/device'))
      else if (child.localName = 'note') then
        value.noteList.Add(ParseAnnotation(child, path+'/note'))
      else if (child.localName = 'dosage') then
        value.dosage := ParseMedicationAdministrationDosage(child, path+'/dosage')
      else if (child.localName = 'eventHistory') then
        value.eventHistoryList.Add(ParseReference(child, path+'/eventHistory'))
      else if Not ParseDomainResourceChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeMedicationAdministration(xml : TXmlBuilder; name : String; value : TFhirMedicationAdministration);
begin
  if (value = nil) then
    exit;
  composeDomainResourceAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeMedicationAdministrationChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeMedicationAdministrationChildren(xml : TXmlBuilder; value : TFhirMedicationAdministration);
var
  i : integer;
begin
  composeDomainResourceChildren(xml, value);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.identifierList.Count - 1 do
      ComposeIdentifier(xml, 'identifier', value.identifierList[i]);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.basedOnList.Count - 1 do
      ComposeReference(xml, 'basedOn', value.basedOnList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.partOfList.Count - 1 do
      ComposeReference(xml, 'partOf', value.partOfList[i]);
  ComposeEnum(xml, 'status', value.statusElement, CODES_TFhirMedicationAdministrationStatusCodesEnum);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.statusReasonList.Count - 1 do
      ComposeCodeableConcept(xml, 'statusReason', value.statusReasonList[i]);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.categoryList.Count - 1 do
      ComposeCodeableConcept(xml, 'category', value.categoryList[i]);
  ComposeCodeableReference(xml, 'medication', value.medication);
  ComposeReference(xml, 'subject', value.subject);
  if (SummaryOption in [soFull, soData]) then
    ComposeReference(xml, 'encounter', value.encounter);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.supportingInformationList.Count - 1 do
      ComposeReference(xml, 'supportingInformation', value.supportingInformationList[i]);
  if (value.occurence is TFhirPeriod) {6} then
    ComposePeriod(xml, 'occurencePeriod', TFhirPeriod(value.occurence))
  else if (value.occurence is TFhirDateTime) {6} then
    ComposeDateTime(xml, 'occurenceDateTime', TFhirDateTime(value.occurence));
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDateTime(xml, 'recorded', value.recordedElement);
  if (SummaryOption in [soFull, soData]) then
    ComposeBoolean(xml, 'isSubPotent', value.isSubPotentElement);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.subPotentReasonList.Count - 1 do
      ComposeCodeableConcept(xml, 'subPotentReason', value.subPotentReasonList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.performerList.Count - 1 do
      ComposeMedicationAdministrationPerformer(xml, 'performer', value.performerList[i]);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.reasonList.Count - 1 do
      ComposeCodeableReference(xml, 'reason', value.reasonList[i]);
  if (SummaryOption in [soFull, soData]) then
    ComposeReference(xml, 'request', value.request);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.deviceList.Count - 1 do
      ComposeReference(xml, 'device', value.deviceList[i]);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.noteList.Count - 1 do
      ComposeAnnotation(xml, 'note', value.noteList[i]);
  if (SummaryOption in [soFull, soData]) then
    ComposeMedicationAdministrationDosage(xml, 'dosage', value.dosage);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.eventHistoryList.Count - 1 do
      ComposeReference(xml, 'eventHistory', value.eventHistoryList[i]);
end;

{$ENDIF FHIR_MEDICATIONADMINISTRATION}
{$IFDEF FHIR_MEDICATIONDISPENSE}
function TFHIRXmlParser.ParseMedicationDispensePerformer(element : TMXmlElement; path : string) : TFhirMedicationDispensePerformer;
var
  child : TMXmlElement;
begin
  result := TFhirMedicationDispensePerformer.Create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseMedicationDispensePerformerChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseMedicationDispensePerformerChild(value : TFhirMedicationDispensePerformer; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'function') then
        value.function_ := ParseCodeableConcept(child, path+'/function')
      else if (child.localName = 'actor') then
        value.actor := ParseReference(child, path+'/actor')
      else if Not ParseBackboneElementChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeMedicationDispensePerformer(xml : TXmlBuilder; name : String; value : TFhirMedicationDispensePerformer);
begin
  if (value = nil) then
    exit;
  composeElementAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeMedicationDispensePerformerChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeMedicationDispensePerformerChildren(xml : TXmlBuilder; value : TFhirMedicationDispensePerformer);
begin
  composeBackboneElementChildren(xml, value);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(xml, 'function', value.function_);
  ComposeReference(xml, 'actor', value.actor);
end;

function TFHIRXmlParser.ParseMedicationDispenseSubstitution(element : TMXmlElement; path : string) : TFhirMedicationDispenseSubstitution;
var
  child : TMXmlElement;
begin
  result := TFhirMedicationDispenseSubstitution.Create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseMedicationDispenseSubstitutionChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseMedicationDispenseSubstitutionChild(value : TFhirMedicationDispenseSubstitution; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'wasSubstituted') then
        value.wasSubstitutedElement := ParseBoolean(child, path+'/wasSubstituted')
      else if (child.localName = 'type') then
        value.type_ := ParseCodeableConcept(child, path+'/type')
      else if (child.localName = 'reason') then
        value.reasonList.Add(ParseCodeableConcept(child, path+'/reason'))
      else if (child.localName = 'responsibleParty') then
        value.responsibleParty := ParseReference(child, path+'/responsibleParty')
      else if Not ParseBackboneElementChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeMedicationDispenseSubstitution(xml : TXmlBuilder; name : String; value : TFhirMedicationDispenseSubstitution);
begin
  if (value = nil) then
    exit;
  composeElementAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeMedicationDispenseSubstitutionChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeMedicationDispenseSubstitutionChildren(xml : TXmlBuilder; value : TFhirMedicationDispenseSubstitution);
var
  i : integer;
begin
  composeBackboneElementChildren(xml, value);
  ComposeBoolean(xml, 'wasSubstituted', value.wasSubstitutedElement);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(xml, 'type', value.type_);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.reasonList.Count - 1 do
      ComposeCodeableConcept(xml, 'reason', value.reasonList[i]);
  if (SummaryOption in [soFull, soData]) then
    ComposeReference(xml, 'responsibleParty', value.responsibleParty);
end;

function TFHIRXmlParser.ParseMedicationDispense(element : TMXmlElement; path : string) : TFhirMedicationDispense;
var
  child : TMXmlElement;
begin
  result := TFhirMedicationDispense.Create;
  try
    parseDomainResourceAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseMedicationDispenseChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseMedicationDispenseChild(value : TFhirMedicationDispense; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'identifier') then
        value.identifierList.Add(ParseIdentifier(child, path+'/identifier'))
      else if (child.localName = 'basedOn') then
        value.basedOnList.Add(ParseReference(child, path+'/basedOn'))
      else if (child.localName = 'partOf') then
        value.partOfList.Add(ParseReference(child, path+'/partOf'))
      else if (child.localName = 'status') then
        value.statusElement := ParseEnum(CODES_TFhirMedicationDispenseStatusCodesEnum, SYSTEMS_TFhirMedicationDispenseStatusCodesEnum, child, path+'/status')
      else if (child.localName = 'notPerformedReason') then
        value.notPerformedReason := ParseCodeableReference(child, path+'/notPerformedReason')
      else if (child.localName = 'statusChanged') then
        value.statusChangedElement := ParseDateTime(child, path+'/statusChanged')
      else if (child.localName = 'category') then
        value.categoryList.Add(ParseCodeableConcept(child, path+'/category'))
      else if (child.localName = 'medication') then
        value.medication := ParseCodeableReference(child, path+'/medication')
      else if (child.localName = 'subject') then
        value.subject := ParseReference(child, path+'/subject')
      else if (child.localName = 'encounter') then
        value.encounter := ParseReference(child, path+'/encounter')
      else if (child.localName = 'supportingInformation') then
        value.supportingInformationList.Add(ParseReference(child, path+'/supportingInformation'))
      else if (child.localName = 'performer') then
        value.performerList.Add(ParseMedicationDispensePerformer(child, path+'/performer'))
      else if (child.localName = 'location') then
        value.location := ParseReference(child, path+'/location')
      else if (child.localName = 'authorizingPrescription') then
        value.authorizingPrescriptionList.Add(ParseReference(child, path+'/authorizingPrescription'))
      else if (child.localName = 'type') then
        value.type_ := ParseCodeableConcept(child, path+'/type')
      else if (child.localName = 'quantity') then
        value.quantity := ParseQuantity(child, path+'/quantity')
      else if (child.localName = 'daysSupply') then
        value.daysSupply := ParseQuantity(child, path+'/daysSupply')
      else if (child.localName = 'recorded') then
        value.recordedElement := ParseDateTime(child, path+'/recorded')
      else if (child.localName = 'whenPrepared') then
        value.whenPreparedElement := ParseDateTime(child, path+'/whenPrepared')
      else if (child.localName = 'whenHandedOver') then
        value.whenHandedOverElement := ParseDateTime(child, path+'/whenHandedOver')
      else if (child.localName = 'destination') then
        value.destination := ParseReference(child, path+'/destination')
      else if (child.localName = 'receiver') then
        value.receiverList.Add(ParseReference(child, path+'/receiver'))
      else if (child.localName = 'note') then
        value.noteList.Add(ParseAnnotation(child, path+'/note'))
      else if (child.localName = 'renderedDosageInstruction') then
        value.renderedDosageInstructionElement := ParseString(child, path+'/renderedDosageInstruction')
      else if (child.localName = 'dosageInstruction') then
        value.dosageInstructionList.Add(ParseDosage(child, path+'/dosageInstruction'))
      else if (child.localName = 'substitution') then
        value.substitution := ParseMedicationDispenseSubstitution(child, path+'/substitution')
      else if (child.localName = 'eventHistory') then
        value.eventHistoryList.Add(ParseReference(child, path+'/eventHistory'))
      else if Not ParseDomainResourceChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeMedicationDispense(xml : TXmlBuilder; name : String; value : TFhirMedicationDispense);
begin
  if (value = nil) then
    exit;
  composeDomainResourceAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeMedicationDispenseChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeMedicationDispenseChildren(xml : TXmlBuilder; value : TFhirMedicationDispense);
var
  i : integer;
begin
  composeDomainResourceChildren(xml, value);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.identifierList.Count - 1 do
      ComposeIdentifier(xml, 'identifier', value.identifierList[i]);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.basedOnList.Count - 1 do
      ComposeReference(xml, 'basedOn', value.basedOnList[i]);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.partOfList.Count - 1 do
      ComposeReference(xml, 'partOf', value.partOfList[i]);
  ComposeEnum(xml, 'status', value.statusElement, CODES_TFhirMedicationDispenseStatusCodesEnum);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableReference(xml, 'notPerformedReason', value.notPerformedReason);
  if (SummaryOption in [soFull, soData]) then
    ComposeDateTime(xml, 'statusChanged', value.statusChangedElement);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.categoryList.Count - 1 do
      ComposeCodeableConcept(xml, 'category', value.categoryList[i]);
  ComposeCodeableReference(xml, 'medication', value.medication);
  ComposeReference(xml, 'subject', value.subject);
  if (SummaryOption in [soFull, soData]) then
    ComposeReference(xml, 'encounter', value.encounter);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.supportingInformationList.Count - 1 do
      ComposeReference(xml, 'supportingInformation', value.supportingInformationList[i]);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.performerList.Count - 1 do
      ComposeMedicationDispensePerformer(xml, 'performer', value.performerList[i]);
  if (SummaryOption in [soFull, soData]) then
    ComposeReference(xml, 'location', value.location);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.authorizingPrescriptionList.Count - 1 do
      ComposeReference(xml, 'authorizingPrescription', value.authorizingPrescriptionList[i]);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(xml, 'type', value.type_);
  if (SummaryOption in [soFull, soData]) then
    ComposeQuantity(xml, 'quantity', value.quantity);
  if (SummaryOption in [soFull, soData]) then
    ComposeQuantity(xml, 'daysSupply', value.daysSupply);
  if (SummaryOption in [soFull, soData]) then
    ComposeDateTime(xml, 'recorded', value.recordedElement);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDateTime(xml, 'whenPrepared', value.whenPreparedElement);
  if (SummaryOption in [soFull, soData]) then
    ComposeDateTime(xml, 'whenHandedOver', value.whenHandedOverElement);
  if (SummaryOption in [soFull, soData]) then
    ComposeReference(xml, 'destination', value.destination);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.receiverList.Count - 1 do
      ComposeReference(xml, 'receiver', value.receiverList[i]);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.noteList.Count - 1 do
      ComposeAnnotation(xml, 'note', value.noteList[i]);
  if (SummaryOption in [soFull, soData]) then
    ComposeString(xml, 'renderedDosageInstruction', value.renderedDosageInstructionElement);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.dosageInstructionList.Count - 1 do
      ComposeDosage(xml, 'dosageInstruction', value.dosageInstructionList[i]);
  if (SummaryOption in [soFull, soData]) then
    ComposeMedicationDispenseSubstitution(xml, 'substitution', value.substitution);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.eventHistoryList.Count - 1 do
      ComposeReference(xml, 'eventHistory', value.eventHistoryList[i]);
end;

{$ENDIF FHIR_MEDICATIONDISPENSE}
{$IFDEF FHIR_MEDICATIONKNOWLEDGE}
function TFHIRXmlParser.ParseMedicationKnowledgeRelatedMedicationKnowledge(element : TMXmlElement; path : string) : TFhirMedicationKnowledgeRelatedMedicationKnowledge;
var
  child : TMXmlElement;
begin
  result := TFhirMedicationKnowledgeRelatedMedicationKnowledge.Create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseMedicationKnowledgeRelatedMedicationKnowledgeChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseMedicationKnowledgeRelatedMedicationKnowledgeChild(value : TFhirMedicationKnowledgeRelatedMedicationKnowledge; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'type') then
        value.type_ := ParseCodeableConcept(child, path+'/type')
      else if (child.localName = 'reference') then
        value.referenceList.Add(ParseReference(child, path+'/reference'))
      else if Not ParseBackboneElementChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeMedicationKnowledgeRelatedMedicationKnowledge(xml : TXmlBuilder; name : String; value : TFhirMedicationKnowledgeRelatedMedicationKnowledge);
begin
  if (value = nil) then
    exit;
  composeElementAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeMedicationKnowledgeRelatedMedicationKnowledgeChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeMedicationKnowledgeRelatedMedicationKnowledgeChildren(xml : TXmlBuilder; value : TFhirMedicationKnowledgeRelatedMedicationKnowledge);
var
  i : integer;
begin
  composeBackboneElementChildren(xml, value);
  ComposeCodeableConcept(xml, 'type', value.type_);
  for i := 0 to value.referenceList.Count - 1 do
      ComposeReference(xml, 'reference', value.referenceList[i]);
end;

function TFHIRXmlParser.ParseMedicationKnowledgeMonograph(element : TMXmlElement; path : string) : TFhirMedicationKnowledgeMonograph;
var
  child : TMXmlElement;
begin
  result := TFhirMedicationKnowledgeMonograph.Create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseMedicationKnowledgeMonographChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseMedicationKnowledgeMonographChild(value : TFhirMedicationKnowledgeMonograph; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'type') then
        value.type_ := ParseCodeableConcept(child, path+'/type')
      else if (child.localName = 'source') then
        value.source := ParseReference(child, path+'/source')
      else if Not ParseBackboneElementChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeMedicationKnowledgeMonograph(xml : TXmlBuilder; name : String; value : TFhirMedicationKnowledgeMonograph);
begin
  if (value = nil) then
    exit;
  composeElementAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeMedicationKnowledgeMonographChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeMedicationKnowledgeMonographChildren(xml : TXmlBuilder; value : TFhirMedicationKnowledgeMonograph);
begin
  composeBackboneElementChildren(xml, value);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(xml, 'type', value.type_);
  if (SummaryOption in [soFull, soData]) then
    ComposeReference(xml, 'source', value.source);
end;

function TFHIRXmlParser.ParseMedicationKnowledgeCost(element : TMXmlElement; path : string) : TFhirMedicationKnowledgeCost;
var
  child : TMXmlElement;
begin
  result := TFhirMedicationKnowledgeCost.Create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseMedicationKnowledgeCostChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseMedicationKnowledgeCostChild(value : TFhirMedicationKnowledgeCost; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'effectiveDate') then
        value.effectiveDateList.Add(ParsePeriod(child, path+'/effectiveDate'))
      else if (child.localName = 'type') then
        value.type_ := ParseCodeableConcept(child, path+'/type')
      else if (child.localName = 'source') then
        value.sourceElement := ParseString(child, path+'/source')
      else if (child.localName = 'costMoney') then
        value.cost := ParseMoney(child, path+'/costMoney')
      else if (child.localName = 'costCodeableConcept') then
        value.cost := ParseCodeableConcept(child, path+'/costCodeableConcept')
      else if Not ParseBackboneElementChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeMedicationKnowledgeCost(xml : TXmlBuilder; name : String; value : TFhirMedicationKnowledgeCost);
begin
  if (value = nil) then
    exit;
  composeElementAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeMedicationKnowledgeCostChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeMedicationKnowledgeCostChildren(xml : TXmlBuilder; value : TFhirMedicationKnowledgeCost);
var
  i : integer;
begin
  composeBackboneElementChildren(xml, value);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.effectiveDateList.Count - 1 do
      ComposePeriod(xml, 'effectiveDate', value.effectiveDateList[i]);
  ComposeCodeableConcept(xml, 'type', value.type_);
  if (SummaryOption in [soFull, soData]) then
    ComposeString(xml, 'source', value.sourceElement);
  if (value.cost is TFhirMoney) {6} then
    ComposeMoney(xml, 'costMoney', TFhirMoney(value.cost))
  else if (value.cost is TFhirCodeableConcept) {6} then
    ComposeCodeableConcept(xml, 'costCodeableConcept', TFhirCodeableConcept(value.cost));
end;

function TFHIRXmlParser.ParseMedicationKnowledgeMonitoringProgram(element : TMXmlElement; path : string) : TFhirMedicationKnowledgeMonitoringProgram;
var
  child : TMXmlElement;
begin
  result := TFhirMedicationKnowledgeMonitoringProgram.Create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseMedicationKnowledgeMonitoringProgramChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseMedicationKnowledgeMonitoringProgramChild(value : TFhirMedicationKnowledgeMonitoringProgram; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'type') then
        value.type_ := ParseCodeableConcept(child, path+'/type')
      else if (child.localName = 'name') then
        value.nameElement := ParseString(child, path+'/name')
      else if Not ParseBackboneElementChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeMedicationKnowledgeMonitoringProgram(xml : TXmlBuilder; name : String; value : TFhirMedicationKnowledgeMonitoringProgram);
begin
  if (value = nil) then
    exit;
  composeElementAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeMedicationKnowledgeMonitoringProgramChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeMedicationKnowledgeMonitoringProgramChildren(xml : TXmlBuilder; value : TFhirMedicationKnowledgeMonitoringProgram);
begin
  composeBackboneElementChildren(xml, value);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(xml, 'type', value.type_);
  if (SummaryOption in [soFull, soData]) then
    ComposeString(xml, 'name', value.nameElement);
end;

function TFHIRXmlParser.ParseMedicationKnowledgeIndicationGuideline(element : TMXmlElement; path : string) : TFhirMedicationKnowledgeIndicationGuideline;
var
  child : TMXmlElement;
begin
  result := TFhirMedicationKnowledgeIndicationGuideline.Create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseMedicationKnowledgeIndicationGuidelineChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseMedicationKnowledgeIndicationGuidelineChild(value : TFhirMedicationKnowledgeIndicationGuideline; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'indication') then
        value.indicationList.Add(ParseCodeableReference(child, path+'/indication'))
      else if (child.localName = 'dosingGuideline') then
        value.dosingGuidelineList.Add(ParseMedicationKnowledgeIndicationGuidelineDosingGuideline(child, path+'/dosingGuideline'))
      else if Not ParseBackboneElementChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeMedicationKnowledgeIndicationGuideline(xml : TXmlBuilder; name : String; value : TFhirMedicationKnowledgeIndicationGuideline);
begin
  if (value = nil) then
    exit;
  composeElementAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeMedicationKnowledgeIndicationGuidelineChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeMedicationKnowledgeIndicationGuidelineChildren(xml : TXmlBuilder; value : TFhirMedicationKnowledgeIndicationGuideline);
var
  i : integer;
begin
  composeBackboneElementChildren(xml, value);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.indicationList.Count - 1 do
      ComposeCodeableReference(xml, 'indication', value.indicationList[i]);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.dosingGuidelineList.Count - 1 do
      ComposeMedicationKnowledgeIndicationGuidelineDosingGuideline(xml, 'dosingGuideline', value.dosingGuidelineList[i]);
end;

function TFHIRXmlParser.ParseMedicationKnowledgeIndicationGuidelineDosingGuideline(element : TMXmlElement; path : string) : TFhirMedicationKnowledgeIndicationGuidelineDosingGuideline;
var
  child : TMXmlElement;
begin
  result := TFhirMedicationKnowledgeIndicationGuidelineDosingGuideline.Create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseMedicationKnowledgeIndicationGuidelineDosingGuidelineChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseMedicationKnowledgeIndicationGuidelineDosingGuidelineChild(value : TFhirMedicationKnowledgeIndicationGuidelineDosingGuideline; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'treatmentIntent') then
        value.treatmentIntent := ParseCodeableConcept(child, path+'/treatmentIntent')
      else if (child.localName = 'dosage') then
        value.dosageList.Add(ParseMedicationKnowledgeIndicationGuidelineDosingGuidelineDosage(child, path+'/dosage'))
      else if (child.localName = 'administrationTreatment') then
        value.administrationTreatment := ParseCodeableConcept(child, path+'/administrationTreatment')
      else if (child.localName = 'patientCharacteristic') then
        value.patientCharacteristicList.Add(ParseMedicationKnowledgeIndicationGuidelineDosingGuidelinePatientCharacteristic(child, path+'/patientCharacteristic'))
      else if Not ParseBackboneElementChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeMedicationKnowledgeIndicationGuidelineDosingGuideline(xml : TXmlBuilder; name : String; value : TFhirMedicationKnowledgeIndicationGuidelineDosingGuideline);
begin
  if (value = nil) then
    exit;
  composeElementAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeMedicationKnowledgeIndicationGuidelineDosingGuidelineChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeMedicationKnowledgeIndicationGuidelineDosingGuidelineChildren(xml : TXmlBuilder; value : TFhirMedicationKnowledgeIndicationGuidelineDosingGuideline);
var
  i : integer;
begin
  composeBackboneElementChildren(xml, value);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(xml, 'treatmentIntent', value.treatmentIntent);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.dosageList.Count - 1 do
      ComposeMedicationKnowledgeIndicationGuidelineDosingGuidelineDosage(xml, 'dosage', value.dosageList[i]);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(xml, 'administrationTreatment', value.administrationTreatment);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.patientCharacteristicList.Count - 1 do
      ComposeMedicationKnowledgeIndicationGuidelineDosingGuidelinePatientCharacteristic(xml, 'patientCharacteristic', value.patientCharacteristicList[i]);
end;

function TFHIRXmlParser.ParseMedicationKnowledgeIndicationGuidelineDosingGuidelineDosage(element : TMXmlElement; path : string) : TFhirMedicationKnowledgeIndicationGuidelineDosingGuidelineDosage;
var
  child : TMXmlElement;
begin
  result := TFhirMedicationKnowledgeIndicationGuidelineDosingGuidelineDosage.Create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseMedicationKnowledgeIndicationGuidelineDosingGuidelineDosageChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseMedicationKnowledgeIndicationGuidelineDosingGuidelineDosageChild(value : TFhirMedicationKnowledgeIndicationGuidelineDosingGuidelineDosage; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'type') then
        value.type_ := ParseCodeableConcept(child, path+'/type')
      else if (child.localName = 'dosage') then
        value.dosageList.Add(ParseDosage(child, path+'/dosage'))
      else if Not ParseBackboneElementChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeMedicationKnowledgeIndicationGuidelineDosingGuidelineDosage(xml : TXmlBuilder; name : String; value : TFhirMedicationKnowledgeIndicationGuidelineDosingGuidelineDosage);
begin
  if (value = nil) then
    exit;
  composeElementAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeMedicationKnowledgeIndicationGuidelineDosingGuidelineDosageChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeMedicationKnowledgeIndicationGuidelineDosingGuidelineDosageChildren(xml : TXmlBuilder; value : TFhirMedicationKnowledgeIndicationGuidelineDosingGuidelineDosage);
var
  i : integer;
begin
  composeBackboneElementChildren(xml, value);
  ComposeCodeableConcept(xml, 'type', value.type_);
  for i := 0 to value.dosageList.Count - 1 do
      ComposeDosage(xml, 'dosage', value.dosageList[i]);
end;

function TFHIRXmlParser.ParseMedicationKnowledgeIndicationGuidelineDosingGuidelinePatientCharacteristic(element : TMXmlElement; path : string) : TFhirMedicationKnowledgeIndicationGuidelineDosingGuidelinePatientCharacteristic;
var
  child : TMXmlElement;
begin
  result := TFhirMedicationKnowledgeIndicationGuidelineDosingGuidelinePatientCharacteristic.Create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseMedicationKnowledgeIndicationGuidelineDosingGuidelinePatientCharacteristicChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseMedicationKnowledgeIndicationGuidelineDosingGuidelinePatientCharacteristicChild(value : TFhirMedicationKnowledgeIndicationGuidelineDosingGuidelinePatientCharacteristic; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'type') then
        value.type_ := ParseCodeableConcept(child, path+'/type')
      else if (child.localName = 'valueCodeableConcept') then
        value.value := ParseCodeableConcept(child, path+'/valueCodeableConcept')
      else if (child.localName = 'valueQuantity') then
        value.value := ParseQuantity(child, path+'/valueQuantity')
      else if (child.localName = 'valueRange') then
        value.value := ParseRange(child, path+'/valueRange')
      else if Not ParseBackboneElementChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeMedicationKnowledgeIndicationGuidelineDosingGuidelinePatientCharacteristic(xml : TXmlBuilder; name : String; value : TFhirMedicationKnowledgeIndicationGuidelineDosingGuidelinePatientCharacteristic);
begin
  if (value = nil) then
    exit;
  composeElementAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeMedicationKnowledgeIndicationGuidelineDosingGuidelinePatientCharacteristicChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeMedicationKnowledgeIndicationGuidelineDosingGuidelinePatientCharacteristicChildren(xml : TXmlBuilder; value : TFhirMedicationKnowledgeIndicationGuidelineDosingGuidelinePatientCharacteristic);
begin
  composeBackboneElementChildren(xml, value);
  ComposeCodeableConcept(xml, 'type', value.type_);
  if (SummaryOption in [soFull, soData]) and (value.value is TFhirCodeableConcept) {6} then
    ComposeCodeableConcept(xml, 'valueCodeableConcept', TFhirCodeableConcept(value.value))
  else if (SummaryOption in [soFull, soData]) and (value.value is TFhirQuantity) {6} then
    ComposeQuantity(xml, 'valueQuantity', TFhirQuantity(value.value))
  else if (SummaryOption in [soFull, soData]) and (value.value is TFhirRange) {6} then
    ComposeRange(xml, 'valueRange', TFhirRange(value.value));
end;

function TFHIRXmlParser.ParseMedicationKnowledgeMedicineClassification(element : TMXmlElement; path : string) : TFhirMedicationKnowledgeMedicineClassification;
var
  child : TMXmlElement;
begin
  result := TFhirMedicationKnowledgeMedicineClassification.Create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseMedicationKnowledgeMedicineClassificationChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseMedicationKnowledgeMedicineClassificationChild(value : TFhirMedicationKnowledgeMedicineClassification; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'type') then
        value.type_ := ParseCodeableConcept(child, path+'/type')
      else if (child.localName = 'sourceString') then
        value.source := ParseString(child, path+'/sourceString')
      else if (child.localName = 'sourceUri') then
        value.source := ParseUri(child, path+'/sourceUri')
      else if (child.localName = 'classification') then
        value.classificationList.Add(ParseCodeableConcept(child, path+'/classification'))
      else if Not ParseBackboneElementChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeMedicationKnowledgeMedicineClassification(xml : TXmlBuilder; name : String; value : TFhirMedicationKnowledgeMedicineClassification);
begin
  if (value = nil) then
    exit;
  composeElementAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeMedicationKnowledgeMedicineClassificationChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeMedicationKnowledgeMedicineClassificationChildren(xml : TXmlBuilder; value : TFhirMedicationKnowledgeMedicineClassification);
var
  i : integer;
begin
  composeBackboneElementChildren(xml, value);
  ComposeCodeableConcept(xml, 'type', value.type_);
  if (SummaryOption in [soFull, soData]) and (value.source is TFhirString) {6} then
    ComposeString(xml, 'sourceString', TFhirString(value.source))
  else if (SummaryOption in [soFull, soData]) and (value.source is TFhirUri) {6} then
    ComposeUri(xml, 'sourceUri', TFhirUri(value.source));
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.classificationList.Count - 1 do
      ComposeCodeableConcept(xml, 'classification', value.classificationList[i]);
end;

function TFHIRXmlParser.ParseMedicationKnowledgePackaging(element : TMXmlElement; path : string) : TFhirMedicationKnowledgePackaging;
var
  child : TMXmlElement;
begin
  result := TFhirMedicationKnowledgePackaging.Create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseMedicationKnowledgePackagingChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseMedicationKnowledgePackagingChild(value : TFhirMedicationKnowledgePackaging; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'cost') then
        value.costList.Add(ParseMedicationKnowledgeCost(child, path+'/cost'))
      else if (child.localName = 'packagedProduct') then
        value.packagedProduct := ParseReference(child, path+'/packagedProduct')
      else if Not ParseBackboneElementChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeMedicationKnowledgePackaging(xml : TXmlBuilder; name : String; value : TFhirMedicationKnowledgePackaging);
begin
  if (value = nil) then
    exit;
  composeElementAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeMedicationKnowledgePackagingChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeMedicationKnowledgePackagingChildren(xml : TXmlBuilder; value : TFhirMedicationKnowledgePackaging);
var
  i : integer;
begin
  composeBackboneElementChildren(xml, value);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.costList.Count - 1 do
      ComposeMedicationKnowledgeCost(xml, 'cost', value.costList[i]);
  if (SummaryOption in [soFull, soData]) then
    ComposeReference(xml, 'packagedProduct', value.packagedProduct);
end;

function TFHIRXmlParser.ParseMedicationKnowledgeStorageGuideline(element : TMXmlElement; path : string) : TFhirMedicationKnowledgeStorageGuideline;
var
  child : TMXmlElement;
begin
  result := TFhirMedicationKnowledgeStorageGuideline.Create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseMedicationKnowledgeStorageGuidelineChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseMedicationKnowledgeStorageGuidelineChild(value : TFhirMedicationKnowledgeStorageGuideline; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'reference') then
        value.referenceElement := ParseUri(child, path+'/reference')
      else if (child.localName = 'note') then
        value.noteList.Add(ParseAnnotation(child, path+'/note'))
      else if (child.localName = 'stabilityDuration') then
        value.stabilityDuration := ParseDuration(child, path+'/stabilityDuration')
      else if (child.localName = 'environmentalSetting') then
        value.environmentalSettingList.Add(ParseMedicationKnowledgeStorageGuidelineEnvironmentalSetting(child, path+'/environmentalSetting'))
      else if Not ParseBackboneElementChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeMedicationKnowledgeStorageGuideline(xml : TXmlBuilder; name : String; value : TFhirMedicationKnowledgeStorageGuideline);
begin
  if (value = nil) then
    exit;
  composeElementAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeMedicationKnowledgeStorageGuidelineChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeMedicationKnowledgeStorageGuidelineChildren(xml : TXmlBuilder; value : TFhirMedicationKnowledgeStorageGuideline);
var
  i : integer;
begin
  composeBackboneElementChildren(xml, value);
  if (SummaryOption in [soFull, soData]) then
    ComposeUri(xml, 'reference', value.referenceElement);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.noteList.Count - 1 do
      ComposeAnnotation(xml, 'note', value.noteList[i]);
  if (SummaryOption in [soFull, soData]) then
    ComposeDuration(xml, 'stabilityDuration', value.stabilityDuration);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.environmentalSettingList.Count - 1 do
      ComposeMedicationKnowledgeStorageGuidelineEnvironmentalSetting(xml, 'environmentalSetting', value.environmentalSettingList[i]);
end;

function TFHIRXmlParser.ParseMedicationKnowledgeStorageGuidelineEnvironmentalSetting(element : TMXmlElement; path : string) : TFhirMedicationKnowledgeStorageGuidelineEnvironmentalSetting;
var
  child : TMXmlElement;
begin
  result := TFhirMedicationKnowledgeStorageGuidelineEnvironmentalSetting.Create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseMedicationKnowledgeStorageGuidelineEnvironmentalSettingChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseMedicationKnowledgeStorageGuidelineEnvironmentalSettingChild(value : TFhirMedicationKnowledgeStorageGuidelineEnvironmentalSetting; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'type') then
        value.type_ := ParseCodeableConcept(child, path+'/type')
      else if (child.localName = 'valueQuantity') then
        value.value := ParseQuantity(child, path+'/valueQuantity')
      else if (child.localName = 'valueRange') then
        value.value := ParseRange(child, path+'/valueRange')
      else if (child.localName = 'valueCodeableConcept') then
        value.value := ParseCodeableConcept(child, path+'/valueCodeableConcept')
      else if Not ParseBackboneElementChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeMedicationKnowledgeStorageGuidelineEnvironmentalSetting(xml : TXmlBuilder; name : String; value : TFhirMedicationKnowledgeStorageGuidelineEnvironmentalSetting);
begin
  if (value = nil) then
    exit;
  composeElementAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeMedicationKnowledgeStorageGuidelineEnvironmentalSettingChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeMedicationKnowledgeStorageGuidelineEnvironmentalSettingChildren(xml : TXmlBuilder; value : TFhirMedicationKnowledgeStorageGuidelineEnvironmentalSetting);
begin
  composeBackboneElementChildren(xml, value);
  ComposeCodeableConcept(xml, 'type', value.type_);
  if (value.value is TFhirQuantity) {6} then
    ComposeQuantity(xml, 'valueQuantity', TFhirQuantity(value.value))
  else if (value.value is TFhirRange) {6} then
    ComposeRange(xml, 'valueRange', TFhirRange(value.value))
  else if (value.value is TFhirCodeableConcept) {6} then
    ComposeCodeableConcept(xml, 'valueCodeableConcept', TFhirCodeableConcept(value.value));
end;

function TFHIRXmlParser.ParseMedicationKnowledgeRegulatory(element : TMXmlElement; path : string) : TFhirMedicationKnowledgeRegulatory;
var
  child : TMXmlElement;
begin
  result := TFhirMedicationKnowledgeRegulatory.Create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseMedicationKnowledgeRegulatoryChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseMedicationKnowledgeRegulatoryChild(value : TFhirMedicationKnowledgeRegulatory; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'regulatoryAuthority') then
        value.regulatoryAuthority := ParseReference(child, path+'/regulatoryAuthority')
      else if (child.localName = 'substitution') then
        value.substitutionList.Add(ParseMedicationKnowledgeRegulatorySubstitution(child, path+'/substitution'))
      else if (child.localName = 'schedule') then
        value.scheduleList.Add(ParseCodeableConcept(child, path+'/schedule'))
      else if (child.localName = 'maxDispense') then
        value.maxDispense := ParseMedicationKnowledgeRegulatoryMaxDispense(child, path+'/maxDispense')
      else if Not ParseBackboneElementChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeMedicationKnowledgeRegulatory(xml : TXmlBuilder; name : String; value : TFhirMedicationKnowledgeRegulatory);
begin
  if (value = nil) then
    exit;
  composeElementAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeMedicationKnowledgeRegulatoryChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeMedicationKnowledgeRegulatoryChildren(xml : TXmlBuilder; value : TFhirMedicationKnowledgeRegulatory);
var
  i : integer;
begin
  composeBackboneElementChildren(xml, value);
  ComposeReference(xml, 'regulatoryAuthority', value.regulatoryAuthority);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.substitutionList.Count - 1 do
      ComposeMedicationKnowledgeRegulatorySubstitution(xml, 'substitution', value.substitutionList[i]);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.scheduleList.Count - 1 do
      ComposeCodeableConcept(xml, 'schedule', value.scheduleList[i]);
  if (SummaryOption in [soFull, soData]) then
    ComposeMedicationKnowledgeRegulatoryMaxDispense(xml, 'maxDispense', value.maxDispense);
end;

function TFHIRXmlParser.ParseMedicationKnowledgeRegulatorySubstitution(element : TMXmlElement; path : string) : TFhirMedicationKnowledgeRegulatorySubstitution;
var
  child : TMXmlElement;
begin
  result := TFhirMedicationKnowledgeRegulatorySubstitution.Create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseMedicationKnowledgeRegulatorySubstitutionChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseMedicationKnowledgeRegulatorySubstitutionChild(value : TFhirMedicationKnowledgeRegulatorySubstitution; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'type') then
        value.type_ := ParseCodeableConcept(child, path+'/type')
      else if (child.localName = 'allowed') then
        value.allowedElement := ParseBoolean(child, path+'/allowed')
      else if Not ParseBackboneElementChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeMedicationKnowledgeRegulatorySubstitution(xml : TXmlBuilder; name : String; value : TFhirMedicationKnowledgeRegulatorySubstitution);
begin
  if (value = nil) then
    exit;
  composeElementAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeMedicationKnowledgeRegulatorySubstitutionChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeMedicationKnowledgeRegulatorySubstitutionChildren(xml : TXmlBuilder; value : TFhirMedicationKnowledgeRegulatorySubstitution);
begin
  composeBackboneElementChildren(xml, value);
  ComposeCodeableConcept(xml, 'type', value.type_);
  ComposeBoolean(xml, 'allowed', value.allowedElement);
end;

function TFHIRXmlParser.ParseMedicationKnowledgeRegulatoryMaxDispense(element : TMXmlElement; path : string) : TFhirMedicationKnowledgeRegulatoryMaxDispense;
var
  child : TMXmlElement;
begin
  result := TFhirMedicationKnowledgeRegulatoryMaxDispense.Create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseMedicationKnowledgeRegulatoryMaxDispenseChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseMedicationKnowledgeRegulatoryMaxDispenseChild(value : TFhirMedicationKnowledgeRegulatoryMaxDispense; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'quantity') then
        value.quantity := ParseQuantity(child, path+'/quantity')
      else if (child.localName = 'period') then
        value.period := ParseDuration(child, path+'/period')
      else if Not ParseBackboneElementChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeMedicationKnowledgeRegulatoryMaxDispense(xml : TXmlBuilder; name : String; value : TFhirMedicationKnowledgeRegulatoryMaxDispense);
begin
  if (value = nil) then
    exit;
  composeElementAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeMedicationKnowledgeRegulatoryMaxDispenseChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeMedicationKnowledgeRegulatoryMaxDispenseChildren(xml : TXmlBuilder; value : TFhirMedicationKnowledgeRegulatoryMaxDispense);
begin
  composeBackboneElementChildren(xml, value);
  ComposeQuantity(xml, 'quantity', value.quantity);
  if (SummaryOption in [soFull, soData]) then
    ComposeDuration(xml, 'period', value.period);
end;

function TFHIRXmlParser.ParseMedicationKnowledgeDefinitional(element : TMXmlElement; path : string) : TFhirMedicationKnowledgeDefinitional;
var
  child : TMXmlElement;
begin
  result := TFhirMedicationKnowledgeDefinitional.Create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseMedicationKnowledgeDefinitionalChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseMedicationKnowledgeDefinitionalChild(value : TFhirMedicationKnowledgeDefinitional; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'definition') then
        value.definitionList.Add(ParseReference(child, path+'/definition'))
      else if (child.localName = 'doseForm') then
        value.doseForm := ParseCodeableConcept(child, path+'/doseForm')
      else if (child.localName = 'intendedRoute') then
        value.intendedRouteList.Add(ParseCodeableConcept(child, path+'/intendedRoute'))
      else if (child.localName = 'ingredient') then
        value.ingredientList.Add(ParseMedicationKnowledgeDefinitionalIngredient(child, path+'/ingredient'))
      else if (child.localName = 'drugCharacteristic') then
        value.drugCharacteristicList.Add(ParseMedicationKnowledgeDefinitionalDrugCharacteristic(child, path+'/drugCharacteristic'))
      else if Not ParseBackboneElementChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeMedicationKnowledgeDefinitional(xml : TXmlBuilder; name : String; value : TFhirMedicationKnowledgeDefinitional);
begin
  if (value = nil) then
    exit;
  composeElementAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeMedicationKnowledgeDefinitionalChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeMedicationKnowledgeDefinitionalChildren(xml : TXmlBuilder; value : TFhirMedicationKnowledgeDefinitional);
var
  i : integer;
begin
  composeBackboneElementChildren(xml, value);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.definitionList.Count - 1 do
      ComposeReference(xml, 'definition', value.definitionList[i]);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(xml, 'doseForm', value.doseForm);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.intendedRouteList.Count - 1 do
      ComposeCodeableConcept(xml, 'intendedRoute', value.intendedRouteList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.ingredientList.Count - 1 do
      ComposeMedicationKnowledgeDefinitionalIngredient(xml, 'ingredient', value.ingredientList[i]);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.drugCharacteristicList.Count - 1 do
      ComposeMedicationKnowledgeDefinitionalDrugCharacteristic(xml, 'drugCharacteristic', value.drugCharacteristicList[i]);
end;

function TFHIRXmlParser.ParseMedicationKnowledgeDefinitionalIngredient(element : TMXmlElement; path : string) : TFhirMedicationKnowledgeDefinitionalIngredient;
var
  child : TMXmlElement;
begin
  result := TFhirMedicationKnowledgeDefinitionalIngredient.Create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseMedicationKnowledgeDefinitionalIngredientChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseMedicationKnowledgeDefinitionalIngredientChild(value : TFhirMedicationKnowledgeDefinitionalIngredient; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'item') then
        value.item := ParseCodeableReference(child, path+'/item')
      else if (child.localName = 'type') then
        value.type_ := ParseCodeableConcept(child, path+'/type')
      else if (child.localName = 'strengthRatio') then
        value.strength := ParseRatio(child, path+'/strengthRatio')
      else if (child.localName = 'strengthCodeableConcept') then
        value.strength := ParseCodeableConcept(child, path+'/strengthCodeableConcept')
      else if (child.localName = 'strengthQuantity') then
        value.strength := ParseQuantity(child, path+'/strengthQuantity')
      else if Not ParseBackboneElementChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeMedicationKnowledgeDefinitionalIngredient(xml : TXmlBuilder; name : String; value : TFhirMedicationKnowledgeDefinitionalIngredient);
begin
  if (value = nil) then
    exit;
  composeElementAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeMedicationKnowledgeDefinitionalIngredientChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeMedicationKnowledgeDefinitionalIngredientChildren(xml : TXmlBuilder; value : TFhirMedicationKnowledgeDefinitionalIngredient);
begin
  composeBackboneElementChildren(xml, value);
  ComposeCodeableReference(xml, 'item', value.item);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(xml, 'type', value.type_);
  if (SummaryOption in [soFull, soData]) and (value.strength is TFhirRatio) {6} then
    ComposeRatio(xml, 'strengthRatio', TFhirRatio(value.strength))
  else if (SummaryOption in [soFull, soData]) and (value.strength is TFhirCodeableConcept) {6} then
    ComposeCodeableConcept(xml, 'strengthCodeableConcept', TFhirCodeableConcept(value.strength))
  else if (SummaryOption in [soFull, soData]) and (value.strength is TFhirQuantity) {6} then
    ComposeQuantity(xml, 'strengthQuantity', TFhirQuantity(value.strength));
end;

function TFHIRXmlParser.ParseMedicationKnowledgeDefinitionalDrugCharacteristic(element : TMXmlElement; path : string) : TFhirMedicationKnowledgeDefinitionalDrugCharacteristic;
var
  child : TMXmlElement;
begin
  result := TFhirMedicationKnowledgeDefinitionalDrugCharacteristic.Create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseMedicationKnowledgeDefinitionalDrugCharacteristicChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseMedicationKnowledgeDefinitionalDrugCharacteristicChild(value : TFhirMedicationKnowledgeDefinitionalDrugCharacteristic; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'type') then
        value.type_ := ParseCodeableConcept(child, path+'/type')
      else if (child.localName = 'valueCodeableConcept') then
        value.value := ParseCodeableConcept(child, path+'/valueCodeableConcept')
      else if (child.localName = 'valueQuantity') then
        value.value := ParseQuantity(child, path+'/valueQuantity')
      else if (child.localName = 'valueAttachment') then
        value.value := ParseAttachment(child, path+'/valueAttachment')
      else if (child.localName = 'valueString') then
        value.value := ParseString(child, path+'/valueString')
      else if (child.localName = 'valueBase64Binary') then
        value.value := ParseBase64Binary(child, path+'/valueBase64Binary')
      else if Not ParseBackboneElementChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeMedicationKnowledgeDefinitionalDrugCharacteristic(xml : TXmlBuilder; name : String; value : TFhirMedicationKnowledgeDefinitionalDrugCharacteristic);
begin
  if (value = nil) then
    exit;
  composeElementAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeMedicationKnowledgeDefinitionalDrugCharacteristicChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeMedicationKnowledgeDefinitionalDrugCharacteristicChildren(xml : TXmlBuilder; value : TFhirMedicationKnowledgeDefinitionalDrugCharacteristic);
begin
  composeBackboneElementChildren(xml, value);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(xml, 'type', value.type_);
  if (SummaryOption in [soFull, soData]) and (value.value is TFhirCodeableConcept) {6} then
    ComposeCodeableConcept(xml, 'valueCodeableConcept', TFhirCodeableConcept(value.value))
  else if (SummaryOption in [soFull, soData]) and (value.value is TFhirQuantity) {6} then
    ComposeQuantity(xml, 'valueQuantity', TFhirQuantity(value.value))
  else if (SummaryOption in [soFull, soData]) and (value.value is TFhirAttachment) {6} then
    ComposeAttachment(xml, 'valueAttachment', TFhirAttachment(value.value))
  else if (SummaryOption in [soFull, soData]) and (value.value is TFhirString) {6} then
    ComposeString(xml, 'valueString', TFhirString(value.value))
  else if (SummaryOption in [soFull, soData]) and (value.value is TFhirBase64Binary) {6} then
    ComposeBase64Binary(xml, 'valueBase64Binary', TFhirBase64Binary(value.value));
end;

function TFHIRXmlParser.ParseMedicationKnowledge(element : TMXmlElement; path : string) : TFhirMedicationKnowledge;
var
  child : TMXmlElement;
begin
  result := TFhirMedicationKnowledge.Create;
  try
    parseMetadataResourceAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseMedicationKnowledgeChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseMedicationKnowledgeChild(value : TFhirMedicationKnowledge; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'identifier') then
        value.identifierList.Add(ParseIdentifier(child, path+'/identifier'))
      else if (child.localName = 'code') then
        value.code := ParseCodeableConcept(child, path+'/code')
      else if (child.localName = 'status') then
        value.statusElement := ParseEnum(CODES_TFhirMedicationKnowledgeStatusCodesEnum, SYSTEMS_TFhirMedicationKnowledgeStatusCodesEnum, child, path+'/status')
      else if (child.localName = 'author') then
        value.author := ParseContactDetail(child, path+'/author')
      else if (child.localName = 'intendedJurisdiction') then
        value.intendedJurisdictionList.Add(ParseCodeableConcept(child, path+'/intendedJurisdiction'))
      else if (child.localName = 'name') then
        value.nameList.Add(ParseString(child, path+'/name'))
      else if (child.localName = 'relatedMedicationKnowledge') then
        value.relatedMedicationKnowledgeList.Add(ParseMedicationKnowledgeRelatedMedicationKnowledge(child, path+'/relatedMedicationKnowledge'))
      else if (child.localName = 'associatedMedication') then
        value.associatedMedicationList.Add(ParseReference(child, path+'/associatedMedication'))
      else if (child.localName = 'productType') then
        value.productTypeList.Add(ParseCodeableConcept(child, path+'/productType'))
      else if (child.localName = 'monograph') then
        value.monographList.Add(ParseMedicationKnowledgeMonograph(child, path+'/monograph'))
      else if (child.localName = 'preparationInstruction') then
        value.preparationInstructionElement := ParseMarkdown(child, path+'/preparationInstruction')
      else if (child.localName = 'cost') then
        value.costList.Add(ParseMedicationKnowledgeCost(child, path+'/cost'))
      else if (child.localName = 'monitoringProgram') then
        value.monitoringProgramList.Add(ParseMedicationKnowledgeMonitoringProgram(child, path+'/monitoringProgram'))
      else if (child.localName = 'indicationGuideline') then
        value.indicationGuidelineList.Add(ParseMedicationKnowledgeIndicationGuideline(child, path+'/indicationGuideline'))
      else if (child.localName = 'medicineClassification') then
        value.medicineClassificationList.Add(ParseMedicationKnowledgeMedicineClassification(child, path+'/medicineClassification'))
      else if (child.localName = 'packaging') then
        value.packagingList.Add(ParseMedicationKnowledgePackaging(child, path+'/packaging'))
      else if (child.localName = 'clinicalUseIssue') then
        value.clinicalUseIssueList.Add(ParseReference(child, path+'/clinicalUseIssue'))
      else if (child.localName = 'storageGuideline') then
        value.storageGuidelineList.Add(ParseMedicationKnowledgeStorageGuideline(child, path+'/storageGuideline'))
      else if (child.localName = 'regulatory') then
        value.regulatoryList.Add(ParseMedicationKnowledgeRegulatory(child, path+'/regulatory'))
      else if (child.localName = 'definitional') then
        value.definitional := ParseMedicationKnowledgeDefinitional(child, path+'/definitional')
      else if Not ParseMetadataResourceChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeMedicationKnowledge(xml : TXmlBuilder; name : String; value : TFhirMedicationKnowledge);
begin
  if (value = nil) then
    exit;
  composeMetadataResourceAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeMedicationKnowledgeChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeMedicationKnowledgeChildren(xml : TXmlBuilder; value : TFhirMedicationKnowledge);
var
  i : integer;
begin
  composeMetadataResourceChildren(xml, value);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.identifierList.Count - 1 do
      ComposeIdentifier(xml, 'identifier', value.identifierList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(xml, 'code', value.code);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeEnum(xml, 'status', value.statusElement, CODES_TFhirMedicationKnowledgeStatusCodesEnum);
  if (SummaryOption in [soFull, soData]) then
    ComposeContactDetail(xml, 'author', value.author);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.intendedJurisdictionList.Count - 1 do
      ComposeCodeableConcept(xml, 'intendedJurisdiction', value.intendedJurisdictionList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.nameList.Count - 1 do
      ComposeString(xml, 'name', value.nameList[i]);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.relatedMedicationKnowledgeList.Count - 1 do
      ComposeMedicationKnowledgeRelatedMedicationKnowledge(xml, 'relatedMedicationKnowledge', value.relatedMedicationKnowledgeList[i]);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.associatedMedicationList.Count - 1 do
      ComposeReference(xml, 'associatedMedication', value.associatedMedicationList[i]);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.productTypeList.Count - 1 do
      ComposeCodeableConcept(xml, 'productType', value.productTypeList[i]);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.monographList.Count - 1 do
      ComposeMedicationKnowledgeMonograph(xml, 'monograph', value.monographList[i]);
  if (SummaryOption in [soFull, soData]) then
    ComposeMarkdown(xml, 'preparationInstruction', value.preparationInstructionElement);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.costList.Count - 1 do
      ComposeMedicationKnowledgeCost(xml, 'cost', value.costList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.monitoringProgramList.Count - 1 do
      ComposeMedicationKnowledgeMonitoringProgram(xml, 'monitoringProgram', value.monitoringProgramList[i]);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.indicationGuidelineList.Count - 1 do
      ComposeMedicationKnowledgeIndicationGuideline(xml, 'indicationGuideline', value.indicationGuidelineList[i]);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.medicineClassificationList.Count - 1 do
      ComposeMedicationKnowledgeMedicineClassification(xml, 'medicineClassification', value.medicineClassificationList[i]);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.packagingList.Count - 1 do
      ComposeMedicationKnowledgePackaging(xml, 'packaging', value.packagingList[i]);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.clinicalUseIssueList.Count - 1 do
      ComposeReference(xml, 'clinicalUseIssue', value.clinicalUseIssueList[i]);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.storageGuidelineList.Count - 1 do
      ComposeMedicationKnowledgeStorageGuideline(xml, 'storageGuideline', value.storageGuidelineList[i]);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.regulatoryList.Count - 1 do
      ComposeMedicationKnowledgeRegulatory(xml, 'regulatory', value.regulatoryList[i]);
  if (SummaryOption in [soFull, soData]) then
    ComposeMedicationKnowledgeDefinitional(xml, 'definitional', value.definitional);
end;

{$ENDIF FHIR_MEDICATIONKNOWLEDGE}
{$IFDEF FHIR_MEDICATIONREQUEST}
function TFHIRXmlParser.ParseMedicationRequestDose(element : TMXmlElement; path : string) : TFhirMedicationRequestDose;
var
  child : TMXmlElement;
begin
  result := TFhirMedicationRequestDose.Create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseMedicationRequestDoseChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseMedicationRequestDoseChild(value : TFhirMedicationRequestDose; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'renderedDosageInstruction') then
        value.renderedDosageInstructionElement := ParseString(child, path+'/renderedDosageInstruction')
      else if (child.localName = 'effectiveDosePeriod') then
        value.effectiveDosePeriod := ParsePeriod(child, path+'/effectiveDosePeriod')
      else if (child.localName = 'dosageInstruction') then
        value.dosageInstructionList.Add(ParseDosage(child, path+'/dosageInstruction'))
      else if Not ParseBackboneElementChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeMedicationRequestDose(xml : TXmlBuilder; name : String; value : TFhirMedicationRequestDose);
begin
  if (value = nil) then
    exit;
  composeElementAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeMedicationRequestDoseChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeMedicationRequestDoseChildren(xml : TXmlBuilder; value : TFhirMedicationRequestDose);
var
  i : integer;
begin
  composeBackboneElementChildren(xml, value);
  if (SummaryOption in [soFull, soData]) then
    ComposeString(xml, 'renderedDosageInstruction', value.renderedDosageInstructionElement);
  if (SummaryOption in [soFull, soData]) then
    ComposePeriod(xml, 'effectiveDosePeriod', value.effectiveDosePeriod);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.dosageInstructionList.Count - 1 do
      ComposeDosage(xml, 'dosageInstruction', value.dosageInstructionList[i]);
end;

function TFHIRXmlParser.ParseMedicationRequestDispenseRequest(element : TMXmlElement; path : string) : TFhirMedicationRequestDispenseRequest;
var
  child : TMXmlElement;
begin
  result := TFhirMedicationRequestDispenseRequest.Create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseMedicationRequestDispenseRequestChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseMedicationRequestDispenseRequestChild(value : TFhirMedicationRequestDispenseRequest; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'initialFill') then
        value.initialFill := ParseMedicationRequestDispenseRequestInitialFill(child, path+'/initialFill')
      else if (child.localName = 'dispenseInterval') then
        value.dispenseInterval := ParseDuration(child, path+'/dispenseInterval')
      else if (child.localName = 'validityPeriod') then
        value.validityPeriod := ParsePeriod(child, path+'/validityPeriod')
      else if (child.localName = 'numberOfRepeatsAllowed') then
        value.numberOfRepeatsAllowedElement := ParseUnsignedInt(child, path+'/numberOfRepeatsAllowed')
      else if (child.localName = 'quantity') then
        value.quantity := ParseQuantity(child, path+'/quantity')
      else if (child.localName = 'expectedSupplyDuration') then
        value.expectedSupplyDuration := ParseDuration(child, path+'/expectedSupplyDuration')
      else if (child.localName = 'dispenser') then
        value.dispenser := ParseReference(child, path+'/dispenser')
      else if (child.localName = 'dispenserInstruction') then
        value.dispenserInstructionList.Add(ParseAnnotation(child, path+'/dispenserInstruction'))
      else if (child.localName = 'doseAdministrationAid') then
        value.doseAdministrationAid := ParseCodeableConcept(child, path+'/doseAdministrationAid')
      else if Not ParseBackboneElementChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeMedicationRequestDispenseRequest(xml : TXmlBuilder; name : String; value : TFhirMedicationRequestDispenseRequest);
begin
  if (value = nil) then
    exit;
  composeElementAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeMedicationRequestDispenseRequestChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeMedicationRequestDispenseRequestChildren(xml : TXmlBuilder; value : TFhirMedicationRequestDispenseRequest);
var
  i : integer;
begin
  composeBackboneElementChildren(xml, value);
  if (SummaryOption in [soFull, soData]) then
    ComposeMedicationRequestDispenseRequestInitialFill(xml, 'initialFill', value.initialFill);
  if (SummaryOption in [soFull, soData]) then
    ComposeDuration(xml, 'dispenseInterval', value.dispenseInterval);
  if (SummaryOption in [soFull, soData]) then
    ComposePeriod(xml, 'validityPeriod', value.validityPeriod);
  if (SummaryOption in [soFull, soData]) then
    ComposeUnsignedInt(xml, 'numberOfRepeatsAllowed', value.numberOfRepeatsAllowedElement);
  if (SummaryOption in [soFull, soData]) then
    ComposeQuantity(xml, 'quantity', value.quantity);
  if (SummaryOption in [soFull, soData]) then
    ComposeDuration(xml, 'expectedSupplyDuration', value.expectedSupplyDuration);
  if (SummaryOption in [soFull, soData]) then
    ComposeReference(xml, 'dispenser', value.dispenser);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.dispenserInstructionList.Count - 1 do
      ComposeAnnotation(xml, 'dispenserInstruction', value.dispenserInstructionList[i]);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(xml, 'doseAdministrationAid', value.doseAdministrationAid);
end;

function TFHIRXmlParser.ParseMedicationRequestDispenseRequestInitialFill(element : TMXmlElement; path : string) : TFhirMedicationRequestDispenseRequestInitialFill;
var
  child : TMXmlElement;
begin
  result := TFhirMedicationRequestDispenseRequestInitialFill.Create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseMedicationRequestDispenseRequestInitialFillChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseMedicationRequestDispenseRequestInitialFillChild(value : TFhirMedicationRequestDispenseRequestInitialFill; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'quantity') then
        value.quantity := ParseQuantity(child, path+'/quantity')
      else if (child.localName = 'duration') then
        value.duration := ParseDuration(child, path+'/duration')
      else if Not ParseBackboneElementChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeMedicationRequestDispenseRequestInitialFill(xml : TXmlBuilder; name : String; value : TFhirMedicationRequestDispenseRequestInitialFill);
begin
  if (value = nil) then
    exit;
  composeElementAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeMedicationRequestDispenseRequestInitialFillChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeMedicationRequestDispenseRequestInitialFillChildren(xml : TXmlBuilder; value : TFhirMedicationRequestDispenseRequestInitialFill);
begin
  composeBackboneElementChildren(xml, value);
  if (SummaryOption in [soFull, soData]) then
    ComposeQuantity(xml, 'quantity', value.quantity);
  if (SummaryOption in [soFull, soData]) then
    ComposeDuration(xml, 'duration', value.duration);
end;

function TFHIRXmlParser.ParseMedicationRequestSubstitution(element : TMXmlElement; path : string) : TFhirMedicationRequestSubstitution;
var
  child : TMXmlElement;
begin
  result := TFhirMedicationRequestSubstitution.Create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseMedicationRequestSubstitutionChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseMedicationRequestSubstitutionChild(value : TFhirMedicationRequestSubstitution; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'allowedCodeableConcept') then
        value.allowed := ParseCodeableConcept(child, path+'/allowedCodeableConcept')
      else if (child.localName = 'allowedBoolean') then
        value.allowed := ParseBoolean(child, path+'/allowedBoolean')
      else if (child.localName = 'reason') then
        value.reason := ParseCodeableConcept(child, path+'/reason')
      else if Not ParseBackboneElementChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeMedicationRequestSubstitution(xml : TXmlBuilder; name : String; value : TFhirMedicationRequestSubstitution);
begin
  if (value = nil) then
    exit;
  composeElementAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeMedicationRequestSubstitutionChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeMedicationRequestSubstitutionChildren(xml : TXmlBuilder; value : TFhirMedicationRequestSubstitution);
begin
  composeBackboneElementChildren(xml, value);
  if (value.allowed is TFhirCodeableConcept) {6} then
    ComposeCodeableConcept(xml, 'allowedCodeableConcept', TFhirCodeableConcept(value.allowed))
  else if (value.allowed is TFhirBoolean) {6} then
    ComposeBoolean(xml, 'allowedBoolean', TFhirBoolean(value.allowed));
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(xml, 'reason', value.reason);
end;

function TFHIRXmlParser.ParseMedicationRequest(element : TMXmlElement; path : string) : TFhirMedicationRequest;
var
  child : TMXmlElement;
begin
  result := TFhirMedicationRequest.Create;
  try
    parseDomainResourceAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseMedicationRequestChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseMedicationRequestChild(value : TFhirMedicationRequest; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'identifier') then
        value.identifierList.Add(ParseIdentifier(child, path+'/identifier'))
      else if (child.localName = 'basedOn') then
        value.basedOnList.Add(ParseReference(child, path+'/basedOn'))
      else if (child.localName = 'priorPrescription') then
        value.priorPrescription := ParseReference(child, path+'/priorPrescription')
      else if (child.localName = 'groupIdentifier') then
        value.groupIdentifier := ParseIdentifier(child, path+'/groupIdentifier')
      else if (child.localName = 'status') then
        value.statusElement := ParseEnum(CODES_TFhirMedicationrequestStatusEnum, SYSTEMS_TFhirMedicationrequestStatusEnum, child, path+'/status')
      else if (child.localName = 'statusReason') then
        value.statusReason := ParseCodeableConcept(child, path+'/statusReason')
      else if (child.localName = 'statusChanged') then
        value.statusChangedElement := ParseDateTime(child, path+'/statusChanged')
      else if (child.localName = 'intent') then
        value.intentElement := ParseEnum(CODES_TFhirMedicationRequestIntentEnum, SYSTEMS_TFhirMedicationRequestIntentEnum, child, path+'/intent')
      else if (child.localName = 'category') then
        value.categoryList.Add(ParseCodeableConcept(child, path+'/category'))
      else if (child.localName = 'priority') then
        value.priorityElement := ParseEnum(CODES_TFhirRequestPriorityEnum, SYSTEMS_TFhirRequestPriorityEnum, child, path+'/priority')
      else if (child.localName = 'doNotPerform') then
        value.doNotPerformElement := ParseBoolean(child, path+'/doNotPerform')
      else if (child.localName = 'medication') then
        value.medication := ParseCodeableReference(child, path+'/medication')
      else if (child.localName = 'subject') then
        value.subject := ParseReference(child, path+'/subject')
      else if (child.localName = 'informationSource') then
        value.informationSourceList.Add(ParseReference(child, path+'/informationSource'))
      else if (child.localName = 'encounter') then
        value.encounter := ParseReference(child, path+'/encounter')
      else if (child.localName = 'supportingInformation') then
        value.supportingInformationList.Add(ParseReference(child, path+'/supportingInformation'))
      else if (child.localName = 'authoredOn') then
        value.authoredOnElement := ParseDateTime(child, path+'/authoredOn')
      else if (child.localName = 'requester') then
        value.requester := ParseReference(child, path+'/requester')
      else if (child.localName = 'reported') then
        value.reportedElement := ParseBoolean(child, path+'/reported')
      else if (child.localName = 'performerType') then
        value.performerType := ParseCodeableConcept(child, path+'/performerType')
      else if (child.localName = 'performer') then
        value.performerList.Add(ParseReference(child, path+'/performer'))
      else if (child.localName = 'device') then
        value.device := ParseCodeableReference(child, path+'/device')
      else if (child.localName = 'recorder') then
        value.recorder := ParseReference(child, path+'/recorder')
      else if (child.localName = 'reason') then
        value.reasonList.Add(ParseCodeableReference(child, path+'/reason'))
      else if (child.localName = 'courseOfTherapyType') then
        value.courseOfTherapyType := ParseCodeableConcept(child, path+'/courseOfTherapyType')
      else if (child.localName = 'insurance') then
        value.insuranceList.Add(ParseReference(child, path+'/insurance'))
      else if (child.localName = 'note') then
        value.noteList.Add(ParseAnnotation(child, path+'/note'))
      else if (child.localName = 'dose') then
        value.dose := ParseMedicationRequestDose(child, path+'/dose')
      else if (child.localName = 'dispenseRequest') then
        value.dispenseRequest := ParseMedicationRequestDispenseRequest(child, path+'/dispenseRequest')
      else if (child.localName = 'substitution') then
        value.substitution := ParseMedicationRequestSubstitution(child, path+'/substitution')
      else if (child.localName = 'eventHistory') then
        value.eventHistoryList.Add(ParseReference(child, path+'/eventHistory'))
      else if Not ParseDomainResourceChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeMedicationRequest(xml : TXmlBuilder; name : String; value : TFhirMedicationRequest);
begin
  if (value = nil) then
    exit;
  composeDomainResourceAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeMedicationRequestChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeMedicationRequestChildren(xml : TXmlBuilder; value : TFhirMedicationRequest);
var
  i : integer;
begin
  composeDomainResourceChildren(xml, value);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.identifierList.Count - 1 do
      ComposeIdentifier(xml, 'identifier', value.identifierList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.basedOnList.Count - 1 do
      ComposeReference(xml, 'basedOn', value.basedOnList[i]);
  if (SummaryOption in [soFull, soData]) then
    ComposeReference(xml, 'priorPrescription', value.priorPrescription);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeIdentifier(xml, 'groupIdentifier', value.groupIdentifier);
  ComposeEnum(xml, 'status', value.statusElement, CODES_TFhirMedicationrequestStatusEnum);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(xml, 'statusReason', value.statusReason);
  if (SummaryOption in [soFull, soData]) then
    ComposeDateTime(xml, 'statusChanged', value.statusChangedElement);
  ComposeEnum(xml, 'intent', value.intentElement, CODES_TFhirMedicationRequestIntentEnum);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.categoryList.Count - 1 do
      ComposeCodeableConcept(xml, 'category', value.categoryList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeEnum(xml, 'priority', value.priorityElement, CODES_TFhirRequestPriorityEnum);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeBoolean(xml, 'doNotPerform', value.doNotPerformElement);
  ComposeCodeableReference(xml, 'medication', value.medication);
  ComposeReference(xml, 'subject', value.subject);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.informationSourceList.Count - 1 do
      ComposeReference(xml, 'informationSource', value.informationSourceList[i]);
  if (SummaryOption in [soFull, soData]) then
    ComposeReference(xml, 'encounter', value.encounter);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.supportingInformationList.Count - 1 do
      ComposeReference(xml, 'supportingInformation', value.supportingInformationList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDateTime(xml, 'authoredOn', value.authoredOnElement);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference(xml, 'requester', value.requester);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeBoolean(xml, 'reported', value.reportedElement);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(xml, 'performerType', value.performerType);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.performerList.Count - 1 do
      ComposeReference(xml, 'performer', value.performerList[i]);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableReference(xml, 'device', value.device);
  if (SummaryOption in [soFull, soData]) then
    ComposeReference(xml, 'recorder', value.recorder);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.reasonList.Count - 1 do
      ComposeCodeableReference(xml, 'reason', value.reasonList[i]);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(xml, 'courseOfTherapyType', value.courseOfTherapyType);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.insuranceList.Count - 1 do
      ComposeReference(xml, 'insurance', value.insuranceList[i]);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.noteList.Count - 1 do
      ComposeAnnotation(xml, 'note', value.noteList[i]);
  if (SummaryOption in [soFull, soData]) then
    ComposeMedicationRequestDose(xml, 'dose', value.dose);
  if (SummaryOption in [soFull, soData]) then
    ComposeMedicationRequestDispenseRequest(xml, 'dispenseRequest', value.dispenseRequest);
  if (SummaryOption in [soFull, soData]) then
    ComposeMedicationRequestSubstitution(xml, 'substitution', value.substitution);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.eventHistoryList.Count - 1 do
      ComposeReference(xml, 'eventHistory', value.eventHistoryList[i]);
end;

{$ENDIF FHIR_MEDICATIONREQUEST}
{$IFDEF FHIR_MEDICATIONUSAGE}
function TFHIRXmlParser.ParseMedicationUsageAdherence(element : TMXmlElement; path : string) : TFhirMedicationUsageAdherence;
var
  child : TMXmlElement;
begin
  result := TFhirMedicationUsageAdherence.Create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseMedicationUsageAdherenceChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseMedicationUsageAdherenceChild(value : TFhirMedicationUsageAdherence; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'code') then
        value.code := ParseCodeableConcept(child, path+'/code')
      else if (child.localName = 'reason') then
        value.reason := ParseCodeableConcept(child, path+'/reason')
      else if Not ParseBackboneElementChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeMedicationUsageAdherence(xml : TXmlBuilder; name : String; value : TFhirMedicationUsageAdherence);
begin
  if (value = nil) then
    exit;
  composeElementAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeMedicationUsageAdherenceChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeMedicationUsageAdherenceChildren(xml : TXmlBuilder; value : TFhirMedicationUsageAdherence);
begin
  composeBackboneElementChildren(xml, value);
  ComposeCodeableConcept(xml, 'code', value.code);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(xml, 'reason', value.reason);
end;

function TFHIRXmlParser.ParseMedicationUsage(element : TMXmlElement; path : string) : TFhirMedicationUsage;
var
  child : TMXmlElement;
begin
  result := TFhirMedicationUsage.Create;
  try
    parseDomainResourceAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseMedicationUsageChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseMedicationUsageChild(value : TFhirMedicationUsage; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'identifier') then
        value.identifierList.Add(ParseIdentifier(child, path+'/identifier'))
      else if (child.localName = 'partOf') then
        value.partOfList.Add(ParseReference(child, path+'/partOf'))
      else if (child.localName = 'status') then
        value.statusElement := ParseEnum(CODES_TFhirMedicationUsageStatusCodesEnum, SYSTEMS_TFhirMedicationUsageStatusCodesEnum, child, path+'/status')
      else if (child.localName = 'category') then
        value.categoryList.Add(ParseCodeableConcept(child, path+'/category'))
      else if (child.localName = 'medication') then
        value.medication := ParseCodeableReference(child, path+'/medication')
      else if (child.localName = 'subject') then
        value.subject := ParseReference(child, path+'/subject')
      else if (child.localName = 'encounter') then
        value.encounter := ParseReference(child, path+'/encounter')
      else if (child.localName = 'effectivePeriod') then
        value.effective := ParsePeriod(child, path+'/effectivePeriod')
      else if (child.localName = 'effectiveDateTime') then
        value.effective := ParseDateTime(child, path+'/effectiveDateTime')
      else if (child.localName = 'dateAsserted') then
        value.dateAssertedElement := ParseDateTime(child, path+'/dateAsserted')
      else if (child.localName = 'informationSource') then
        value.informationSourceList.Add(ParseReference(child, path+'/informationSource'))
      else if (child.localName = 'derivedFrom') then
        value.derivedFromList.Add(ParseReference(child, path+'/derivedFrom'))
      else if (child.localName = 'reason') then
        value.reasonList.Add(ParseCodeableReference(child, path+'/reason'))
      else if (child.localName = 'note') then
        value.noteList.Add(ParseAnnotation(child, path+'/note'))
      else if (child.localName = 'relatedClinicalInformation') then
        value.relatedClinicalInformationList.Add(ParseReference(child, path+'/relatedClinicalInformation'))
      else if (child.localName = 'renderedDosageInstruction') then
        value.renderedDosageInstructionElement := ParseString(child, path+'/renderedDosageInstruction')
      else if (child.localName = 'dosage') then
        value.dosageList.Add(ParseDosage(child, path+'/dosage'))
      else if (child.localName = 'adherence') then
        value.adherence := ParseMedicationUsageAdherence(child, path+'/adherence')
      else if Not ParseDomainResourceChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeMedicationUsage(xml : TXmlBuilder; name : String; value : TFhirMedicationUsage);
begin
  if (value = nil) then
    exit;
  composeDomainResourceAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeMedicationUsageChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeMedicationUsageChildren(xml : TXmlBuilder; value : TFhirMedicationUsage);
var
  i : integer;
begin
  composeDomainResourceChildren(xml, value);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.identifierList.Count - 1 do
      ComposeIdentifier(xml, 'identifier', value.identifierList[i]);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.partOfList.Count - 1 do
      ComposeReference(xml, 'partOf', value.partOfList[i]);
  ComposeEnum(xml, 'status', value.statusElement, CODES_TFhirMedicationUsageStatusCodesEnum);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.categoryList.Count - 1 do
      ComposeCodeableConcept(xml, 'category', value.categoryList[i]);
  ComposeCodeableReference(xml, 'medication', value.medication);
  ComposeReference(xml, 'subject', value.subject);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference(xml, 'encounter', value.encounter);
  if (SummaryOption in [soFull, soSummary, soData]) and (value.effective is TFhirPeriod) {6} then
    ComposePeriod(xml, 'effectivePeriod', TFhirPeriod(value.effective))
  else if (SummaryOption in [soFull, soSummary, soData]) and (value.effective is TFhirDateTime) {6} then
    ComposeDateTime(xml, 'effectiveDateTime', TFhirDateTime(value.effective));
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDateTime(xml, 'dateAsserted', value.dateAssertedElement);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.informationSourceList.Count - 1 do
      ComposeReference(xml, 'informationSource', value.informationSourceList[i]);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.derivedFromList.Count - 1 do
      ComposeReference(xml, 'derivedFrom', value.derivedFromList[i]);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.reasonList.Count - 1 do
      ComposeCodeableReference(xml, 'reason', value.reasonList[i]);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.noteList.Count - 1 do
      ComposeAnnotation(xml, 'note', value.noteList[i]);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.relatedClinicalInformationList.Count - 1 do
      ComposeReference(xml, 'relatedClinicalInformation', value.relatedClinicalInformationList[i]);
  if (SummaryOption in [soFull, soData]) then
    ComposeString(xml, 'renderedDosageInstruction', value.renderedDosageInstructionElement);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.dosageList.Count - 1 do
      ComposeDosage(xml, 'dosage', value.dosageList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeMedicationUsageAdherence(xml, 'adherence', value.adherence);
end;

{$ENDIF FHIR_MEDICATIONUSAGE}
{$IFDEF FHIR_MEDICINALPRODUCTDEFINITION}
function TFHIRXmlParser.ParseMedicinalProductDefinitionContact(element : TMXmlElement; path : string) : TFhirMedicinalProductDefinitionContact;
var
  child : TMXmlElement;
begin
  result := TFhirMedicinalProductDefinitionContact.Create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseMedicinalProductDefinitionContactChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseMedicinalProductDefinitionContactChild(value : TFhirMedicinalProductDefinitionContact; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'type') then
        value.type_ := ParseCodeableConcept(child, path+'/type')
      else if (child.localName = 'contact') then
        value.contact := ParseReference(child, path+'/contact')
      else if Not ParseBackboneElementChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeMedicinalProductDefinitionContact(xml : TXmlBuilder; name : String; value : TFhirMedicinalProductDefinitionContact);
begin
  if (value = nil) then
    exit;
  composeElementAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeMedicinalProductDefinitionContactChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeMedicinalProductDefinitionContactChildren(xml : TXmlBuilder; value : TFhirMedicinalProductDefinitionContact);
begin
  composeBackboneElementChildren(xml, value);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(xml, 'type', value.type_);
  ComposeReference(xml, 'contact', value.contact);
end;

function TFHIRXmlParser.ParseMedicinalProductDefinitionName(element : TMXmlElement; path : string) : TFhirMedicinalProductDefinitionName;
var
  child : TMXmlElement;
begin
  result := TFhirMedicinalProductDefinitionName.Create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseMedicinalProductDefinitionNameChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseMedicinalProductDefinitionNameChild(value : TFhirMedicinalProductDefinitionName; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'productName') then
        value.productNameElement := ParseString(child, path+'/productName')
      else if (child.localName = 'type') then
        value.type_ := ParseCodeableConcept(child, path+'/type')
      else if (child.localName = 'part') then
        value.partList.Add(ParseMedicinalProductDefinitionNamePart(child, path+'/part'))
      else if (child.localName = 'usage') then
        value.usageList.Add(ParseMedicinalProductDefinitionNameUsage(child, path+'/usage'))
      else if Not ParseBackboneElementChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeMedicinalProductDefinitionName(xml : TXmlBuilder; name : String; value : TFhirMedicinalProductDefinitionName);
begin
  if (value = nil) then
    exit;
  composeElementAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeMedicinalProductDefinitionNameChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeMedicinalProductDefinitionNameChildren(xml : TXmlBuilder; value : TFhirMedicinalProductDefinitionName);
var
  i : integer;
begin
  composeBackboneElementChildren(xml, value);
  ComposeString(xml, 'productName', value.productNameElement);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(xml, 'type', value.type_);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.partList.Count - 1 do
      ComposeMedicinalProductDefinitionNamePart(xml, 'part', value.partList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.usageList.Count - 1 do
      ComposeMedicinalProductDefinitionNameUsage(xml, 'usage', value.usageList[i]);
end;

function TFHIRXmlParser.ParseMedicinalProductDefinitionNamePart(element : TMXmlElement; path : string) : TFhirMedicinalProductDefinitionNamePart;
var
  child : TMXmlElement;
begin
  result := TFhirMedicinalProductDefinitionNamePart.Create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseMedicinalProductDefinitionNamePartChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseMedicinalProductDefinitionNamePartChild(value : TFhirMedicinalProductDefinitionNamePart; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'part') then
        value.partElement := ParseString(child, path+'/part')
      else if (child.localName = 'type') then
        value.type_ := ParseCodeableConcept(child, path+'/type')
      else if Not ParseBackboneElementChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeMedicinalProductDefinitionNamePart(xml : TXmlBuilder; name : String; value : TFhirMedicinalProductDefinitionNamePart);
begin
  if (value = nil) then
    exit;
  composeElementAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeMedicinalProductDefinitionNamePartChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeMedicinalProductDefinitionNamePartChildren(xml : TXmlBuilder; value : TFhirMedicinalProductDefinitionNamePart);
begin
  composeBackboneElementChildren(xml, value);
  ComposeString(xml, 'part', value.partElement);
  ComposeCodeableConcept(xml, 'type', value.type_);
end;

function TFHIRXmlParser.ParseMedicinalProductDefinitionNameUsage(element : TMXmlElement; path : string) : TFhirMedicinalProductDefinitionNameUsage;
var
  child : TMXmlElement;
begin
  result := TFhirMedicinalProductDefinitionNameUsage.Create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseMedicinalProductDefinitionNameUsageChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseMedicinalProductDefinitionNameUsageChild(value : TFhirMedicinalProductDefinitionNameUsage; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'country') then
        value.country := ParseCodeableConcept(child, path+'/country')
      else if (child.localName = 'jurisdiction') then
        value.jurisdiction := ParseCodeableConcept(child, path+'/jurisdiction')
      else if (child.localName = 'language') then
        value.language := ParseCodeableConcept(child, path+'/language')
      else if Not ParseBackboneElementChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeMedicinalProductDefinitionNameUsage(xml : TXmlBuilder; name : String; value : TFhirMedicinalProductDefinitionNameUsage);
begin
  if (value = nil) then
    exit;
  composeElementAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeMedicinalProductDefinitionNameUsageChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeMedicinalProductDefinitionNameUsageChildren(xml : TXmlBuilder; value : TFhirMedicinalProductDefinitionNameUsage);
begin
  composeBackboneElementChildren(xml, value);
  ComposeCodeableConcept(xml, 'country', value.country);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(xml, 'jurisdiction', value.jurisdiction);
  ComposeCodeableConcept(xml, 'language', value.language);
end;

function TFHIRXmlParser.ParseMedicinalProductDefinitionCrossReference(element : TMXmlElement; path : string) : TFhirMedicinalProductDefinitionCrossReference;
var
  child : TMXmlElement;
begin
  result := TFhirMedicinalProductDefinitionCrossReference.Create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseMedicinalProductDefinitionCrossReferenceChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseMedicinalProductDefinitionCrossReferenceChild(value : TFhirMedicinalProductDefinitionCrossReference; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'product') then
        value.product := ParseCodeableReference(child, path+'/product')
      else if (child.localName = 'type') then
        value.type_ := ParseCodeableConcept(child, path+'/type')
      else if Not ParseBackboneElementChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeMedicinalProductDefinitionCrossReference(xml : TXmlBuilder; name : String; value : TFhirMedicinalProductDefinitionCrossReference);
begin
  if (value = nil) then
    exit;
  composeElementAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeMedicinalProductDefinitionCrossReferenceChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeMedicinalProductDefinitionCrossReferenceChildren(xml : TXmlBuilder; value : TFhirMedicinalProductDefinitionCrossReference);
begin
  composeBackboneElementChildren(xml, value);
  ComposeCodeableReference(xml, 'product', value.product);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(xml, 'type', value.type_);
end;

function TFHIRXmlParser.ParseMedicinalProductDefinitionOperation(element : TMXmlElement; path : string) : TFhirMedicinalProductDefinitionOperation;
var
  child : TMXmlElement;
begin
  result := TFhirMedicinalProductDefinitionOperation.Create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseMedicinalProductDefinitionOperationChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseMedicinalProductDefinitionOperationChild(value : TFhirMedicinalProductDefinitionOperation; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'type') then
        value.type_ := ParseCodeableReference(child, path+'/type')
      else if (child.localName = 'effectiveDate') then
        value.effectiveDate := ParsePeriod(child, path+'/effectiveDate')
      else if (child.localName = 'organization') then
        value.organizationList.Add(ParseReference(child, path+'/organization'))
      else if (child.localName = 'confidentialityIndicator') then
        value.confidentialityIndicator := ParseCodeableConcept(child, path+'/confidentialityIndicator')
      else if Not ParseBackboneElementChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeMedicinalProductDefinitionOperation(xml : TXmlBuilder; name : String; value : TFhirMedicinalProductDefinitionOperation);
begin
  if (value = nil) then
    exit;
  composeElementAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeMedicinalProductDefinitionOperationChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeMedicinalProductDefinitionOperationChildren(xml : TXmlBuilder; value : TFhirMedicinalProductDefinitionOperation);
var
  i : integer;
begin
  composeBackboneElementChildren(xml, value);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableReference(xml, 'type', value.type_);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposePeriod(xml, 'effectiveDate', value.effectiveDate);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.organizationList.Count - 1 do
      ComposeReference(xml, 'organization', value.organizationList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(xml, 'confidentialityIndicator', value.confidentialityIndicator);
end;

function TFHIRXmlParser.ParseMedicinalProductDefinitionCharacteristic(element : TMXmlElement; path : string) : TFhirMedicinalProductDefinitionCharacteristic;
var
  child : TMXmlElement;
begin
  result := TFhirMedicinalProductDefinitionCharacteristic.Create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseMedicinalProductDefinitionCharacteristicChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseMedicinalProductDefinitionCharacteristicChild(value : TFhirMedicinalProductDefinitionCharacteristic; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'type') then
        value.type_ := ParseCodeableConcept(child, path+'/type')
      else if (child.localName = 'valueCodeableConcept') then
        value.value := ParseCodeableConcept(child, path+'/valueCodeableConcept')
      else if (child.localName = 'valueQuantity') then
        value.value := ParseQuantity(child, path+'/valueQuantity')
      else if (child.localName = 'valueAttachment') then
        value.value := ParseAttachment(child, path+'/valueAttachment')
      else if (child.localName = 'valueString') then
        value.value := ParseString(child, path+'/valueString')
      else if (child.localName = 'valueInteger') then
        value.value := ParseInteger(child, path+'/valueInteger')
      else if (child.localName = 'valueDate') then
        value.value := ParseDate(child, path+'/valueDate')
      else if (child.localName = 'valueBoolean') then
        value.value := ParseBoolean(child, path+'/valueBoolean')
      else if Not ParseBackboneElementChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeMedicinalProductDefinitionCharacteristic(xml : TXmlBuilder; name : String; value : TFhirMedicinalProductDefinitionCharacteristic);
begin
  if (value = nil) then
    exit;
  composeElementAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeMedicinalProductDefinitionCharacteristicChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeMedicinalProductDefinitionCharacteristicChildren(xml : TXmlBuilder; value : TFhirMedicinalProductDefinitionCharacteristic);
begin
  composeBackboneElementChildren(xml, value);
  ComposeCodeableConcept(xml, 'type', value.type_);
  if (SummaryOption in [soFull, soSummary, soData]) and (value.value is TFhirCodeableConcept) {6} then
    ComposeCodeableConcept(xml, 'valueCodeableConcept', TFhirCodeableConcept(value.value))
  else if (SummaryOption in [soFull, soSummary, soData]) and (value.value is TFhirQuantity) {6} then
    ComposeQuantity(xml, 'valueQuantity', TFhirQuantity(value.value))
  else if (SummaryOption in [soFull, soSummary, soData]) and (value.value is TFhirAttachment) {6} then
    ComposeAttachment(xml, 'valueAttachment', TFhirAttachment(value.value))
  else if (SummaryOption in [soFull, soSummary, soData]) and (value.value is TFhirString) {6} then
    ComposeString(xml, 'valueString', TFhirString(value.value))
  else if (SummaryOption in [soFull, soSummary, soData]) and (value.value is TFhirInteger) {6} then
    ComposeInteger(xml, 'valueInteger', TFhirInteger(value.value))
  else if (SummaryOption in [soFull, soSummary, soData]) and (value.value is TFhirDate) {6} then
    ComposeDate(xml, 'valueDate', TFhirDate(value.value))
  else if (SummaryOption in [soFull, soSummary, soData]) and (value.value is TFhirBoolean) {6} then
    ComposeBoolean(xml, 'valueBoolean', TFhirBoolean(value.value));
end;

function TFHIRXmlParser.ParseMedicinalProductDefinition(element : TMXmlElement; path : string) : TFhirMedicinalProductDefinition;
var
  child : TMXmlElement;
begin
  result := TFhirMedicinalProductDefinition.Create;
  try
    parseDomainResourceAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseMedicinalProductDefinitionChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseMedicinalProductDefinitionChild(value : TFhirMedicinalProductDefinition; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'identifier') then
        value.identifierList.Add(ParseIdentifier(child, path+'/identifier'))
      else if (child.localName = 'type') then
        value.type_ := ParseCodeableConcept(child, path+'/type')
      else if (child.localName = 'domain') then
        value.domain := ParseCodeableConcept(child, path+'/domain')
      else if (child.localName = 'version') then
        value.versionElement := ParseString(child, path+'/version')
      else if (child.localName = 'status') then
        value.status := ParseCodeableConcept(child, path+'/status')
      else if (child.localName = 'statusDate') then
        value.statusDateElement := ParseDateTime(child, path+'/statusDate')
      else if (child.localName = 'description') then
        value.descriptionElement := ParseMarkdown(child, path+'/description')
      else if (child.localName = 'combinedPharmaceuticalDoseForm') then
        value.combinedPharmaceuticalDoseForm := ParseCodeableConcept(child, path+'/combinedPharmaceuticalDoseForm')
      else if (child.localName = 'route') then
        value.routeList.Add(ParseCodeableConcept(child, path+'/route'))
      else if (child.localName = 'indication') then
        value.indicationElement := ParseMarkdown(child, path+'/indication')
      else if (child.localName = 'legalStatusOfSupply') then
        value.legalStatusOfSupply := ParseCodeableConcept(child, path+'/legalStatusOfSupply')
      else if (child.localName = 'additionalMonitoringIndicator') then
        value.additionalMonitoringIndicator := ParseCodeableConcept(child, path+'/additionalMonitoringIndicator')
      else if (child.localName = 'specialMeasures') then
        value.specialMeasuresList.Add(ParseCodeableConcept(child, path+'/specialMeasures'))
      else if (child.localName = 'pediatricUseIndicator') then
        value.pediatricUseIndicator := ParseCodeableConcept(child, path+'/pediatricUseIndicator')
      else if (child.localName = 'classification') then
        value.classificationList.Add(ParseCodeableConcept(child, path+'/classification'))
      else if (child.localName = 'marketingStatus') then
        value.marketingStatusList.Add(ParseMarketingStatus(child, path+'/marketingStatus'))
      else if (child.localName = 'packagedMedicinalProduct') then
        value.packagedMedicinalProductList.Add(ParseCodeableConcept(child, path+'/packagedMedicinalProduct'))
      else if (child.localName = 'comprisedOf') then
        value.comprisedOfList.Add(ParseReference(child, path+'/comprisedOf'))
      else if (child.localName = 'ingredient') then
        value.ingredientList.Add(ParseCodeableConcept(child, path+'/ingredient'))
      else if (child.localName = 'impurity') then
        value.impurityList.Add(ParseCodeableReference(child, path+'/impurity'))
      else if (child.localName = 'attachedDocument') then
        value.attachedDocumentList.Add(ParseReference(child, path+'/attachedDocument'))
      else if (child.localName = 'masterFile') then
        value.masterFileList.Add(ParseReference(child, path+'/masterFile'))
      else if (child.localName = 'contact') then
        value.contactList.Add(ParseMedicinalProductDefinitionContact(child, path+'/contact'))
      else if (child.localName = 'clinicalTrial') then
        value.clinicalTrialList.Add(ParseReference(child, path+'/clinicalTrial'))
      else if (child.localName = 'code') then
        value.codeList.Add(ParseCoding(child, path+'/code'))
      else if (child.localName = 'name') then
        value.nameList.Add(ParseMedicinalProductDefinitionName(child, path+'/name'))
      else if (child.localName = 'crossReference') then
        value.crossReferenceList.Add(ParseMedicinalProductDefinitionCrossReference(child, path+'/crossReference'))
      else if (child.localName = 'operation') then
        value.operationList.Add(ParseMedicinalProductDefinitionOperation(child, path+'/operation'))
      else if (child.localName = 'characteristic') then
        value.characteristicList.Add(ParseMedicinalProductDefinitionCharacteristic(child, path+'/characteristic'))
      else if Not ParseDomainResourceChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeMedicinalProductDefinition(xml : TXmlBuilder; name : String; value : TFhirMedicinalProductDefinition);
begin
  if (value = nil) then
    exit;
  composeDomainResourceAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeMedicinalProductDefinitionChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeMedicinalProductDefinitionChildren(xml : TXmlBuilder; value : TFhirMedicinalProductDefinition);
var
  i : integer;
begin
  composeDomainResourceChildren(xml, value);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.identifierList.Count - 1 do
      ComposeIdentifier(xml, 'identifier', value.identifierList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(xml, 'type', value.type_);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(xml, 'domain', value.domain);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(xml, 'version', value.versionElement);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(xml, 'status', value.status);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDateTime(xml, 'statusDate', value.statusDateElement);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeMarkdown(xml, 'description', value.descriptionElement);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(xml, 'combinedPharmaceuticalDoseForm', value.combinedPharmaceuticalDoseForm);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.routeList.Count - 1 do
      ComposeCodeableConcept(xml, 'route', value.routeList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeMarkdown(xml, 'indication', value.indicationElement);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(xml, 'legalStatusOfSupply', value.legalStatusOfSupply);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(xml, 'additionalMonitoringIndicator', value.additionalMonitoringIndicator);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.specialMeasuresList.Count - 1 do
      ComposeCodeableConcept(xml, 'specialMeasures', value.specialMeasuresList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(xml, 'pediatricUseIndicator', value.pediatricUseIndicator);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.classificationList.Count - 1 do
      ComposeCodeableConcept(xml, 'classification', value.classificationList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.marketingStatusList.Count - 1 do
      ComposeMarketingStatus(xml, 'marketingStatus', value.marketingStatusList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.packagedMedicinalProductList.Count - 1 do
      ComposeCodeableConcept(xml, 'packagedMedicinalProduct', value.packagedMedicinalProductList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.comprisedOfList.Count - 1 do
      ComposeReference(xml, 'comprisedOf', value.comprisedOfList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.ingredientList.Count - 1 do
      ComposeCodeableConcept(xml, 'ingredient', value.ingredientList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.impurityList.Count - 1 do
      ComposeCodeableReference(xml, 'impurity', value.impurityList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.attachedDocumentList.Count - 1 do
      ComposeReference(xml, 'attachedDocument', value.attachedDocumentList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.masterFileList.Count - 1 do
      ComposeReference(xml, 'masterFile', value.masterFileList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.contactList.Count - 1 do
      ComposeMedicinalProductDefinitionContact(xml, 'contact', value.contactList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.clinicalTrialList.Count - 1 do
      ComposeReference(xml, 'clinicalTrial', value.clinicalTrialList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.codeList.Count - 1 do
      ComposeCoding(xml, 'code', value.codeList[i]);
  for i := 0 to value.nameList.Count - 1 do
      ComposeMedicinalProductDefinitionName(xml, 'name', value.nameList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.crossReferenceList.Count - 1 do
      ComposeMedicinalProductDefinitionCrossReference(xml, 'crossReference', value.crossReferenceList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.operationList.Count - 1 do
      ComposeMedicinalProductDefinitionOperation(xml, 'operation', value.operationList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.characteristicList.Count - 1 do
      ComposeMedicinalProductDefinitionCharacteristic(xml, 'characteristic', value.characteristicList[i]);
end;

{$ENDIF FHIR_MEDICINALPRODUCTDEFINITION}
{$IFDEF FHIR_MESSAGEDEFINITION}
function TFHIRXmlParser.ParseMessageDefinitionFocus(element : TMXmlElement; path : string) : TFhirMessageDefinitionFocus;
var
  child : TMXmlElement;
begin
  result := TFhirMessageDefinitionFocus.Create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseMessageDefinitionFocusChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseMessageDefinitionFocusChild(value : TFhirMessageDefinitionFocus; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'code') then
        value.codeElement := ParseEnum(CODES_TFhirResourceTypesEnum, SYSTEMS_TFhirResourceTypesEnum, child, path+'/code')
      else if (child.localName = 'profile') then
        value.profileElement := ParseCanonical(child, path+'/profile')
      else if (child.localName = 'min') then
        value.minElement := ParseUnsignedInt(child, path+'/min')
      else if (child.localName = 'max') then
        value.maxElement := ParseString(child, path+'/max')
      else if Not ParseBackboneElementChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeMessageDefinitionFocus(xml : TXmlBuilder; name : String; value : TFhirMessageDefinitionFocus);
begin
  if (value = nil) then
    exit;
  composeElementAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeMessageDefinitionFocusChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeMessageDefinitionFocusChildren(xml : TXmlBuilder; value : TFhirMessageDefinitionFocus);
begin
  composeBackboneElementChildren(xml, value);
  ComposeEnum(xml, 'code', value.codeElement, CODES_TFhirResourceTypesEnum);
  if (SummaryOption in [soFull, soData]) then
    ComposeCanonical(xml, 'profile', value.profileElement);
  ComposeUnsignedInt(xml, 'min', value.minElement);
  if (SummaryOption in [soFull, soData]) then
    ComposeString(xml, 'max', value.maxElement);
end;

function TFHIRXmlParser.ParseMessageDefinitionAllowedResponse(element : TMXmlElement; path : string) : TFhirMessageDefinitionAllowedResponse;
var
  child : TMXmlElement;
begin
  result := TFhirMessageDefinitionAllowedResponse.Create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseMessageDefinitionAllowedResponseChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseMessageDefinitionAllowedResponseChild(value : TFhirMessageDefinitionAllowedResponse; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'message') then
        value.messageElement := ParseCanonical(child, path+'/message')
      else if (child.localName = 'situation') then
        value.situationElement := ParseMarkdown(child, path+'/situation')
      else if Not ParseBackboneElementChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeMessageDefinitionAllowedResponse(xml : TXmlBuilder; name : String; value : TFhirMessageDefinitionAllowedResponse);
begin
  if (value = nil) then
    exit;
  composeElementAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeMessageDefinitionAllowedResponseChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeMessageDefinitionAllowedResponseChildren(xml : TXmlBuilder; value : TFhirMessageDefinitionAllowedResponse);
begin
  composeBackboneElementChildren(xml, value);
  ComposeCanonical(xml, 'message', value.messageElement);
  if (SummaryOption in [soFull, soData]) then
    ComposeMarkdown(xml, 'situation', value.situationElement);
end;

function TFHIRXmlParser.ParseMessageDefinition(element : TMXmlElement; path : string) : TFhirMessageDefinition;
var
  child : TMXmlElement;
begin
  result := TFhirMessageDefinition.Create;
  try
    parseCanonicalResourceAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseMessageDefinitionChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseMessageDefinitionChild(value : TFhirMessageDefinition; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'url') then
        value.urlElement := ParseUri(child, path+'/url')
      else if (child.localName = 'identifier') then
        value.identifierList.Add(ParseIdentifier(child, path+'/identifier'))
      else if (child.localName = 'version') then
        value.versionElement := ParseString(child, path+'/version')
      else if (child.localName = 'name') then
        value.nameElement := ParseString(child, path+'/name')
      else if (child.localName = 'title') then
        value.titleElement := ParseString(child, path+'/title')
      else if (child.localName = 'replaces') then
        value.replacesList.Add(ParseCanonical(child, path+'/replaces'))
      else if (child.localName = 'status') then
        value.statusElement := ParseEnum(CODES_TFhirPublicationStatusEnum, SYSTEMS_TFhirPublicationStatusEnum, child, path+'/status')
      else if (child.localName = 'experimental') then
        value.experimentalElement := ParseBoolean(child, path+'/experimental')
      else if (child.localName = 'date') then
        value.dateElement := ParseDateTime(child, path+'/date')
      else if (child.localName = 'publisher') then
        value.publisherElement := ParseString(child, path+'/publisher')
      else if (child.localName = 'contact') then
        value.contactList.Add(ParseContactDetail(child, path+'/contact'))
      else if (child.localName = 'description') then
        value.descriptionElement := ParseMarkdown(child, path+'/description')
      else if (child.localName = 'useContext') then
        value.useContextList.Add(ParseUsageContext(child, path+'/useContext'))
      else if (child.localName = 'jurisdiction') then
        value.jurisdictionList.Add(ParseCodeableConcept(child, path+'/jurisdiction'))
      else if (child.localName = 'purpose') then
        value.purposeElement := ParseMarkdown(child, path+'/purpose')
      else if (child.localName = 'copyright') then
        value.copyrightElement := ParseMarkdown(child, path+'/copyright')
      else if (child.localName = 'base') then
        value.baseElement := ParseCanonical(child, path+'/base')
      else if (child.localName = 'parent') then
        value.parentList.Add(ParseCanonical(child, path+'/parent'))
      else if (child.localName = 'eventCoding') then
        value.event := ParseCoding(child, path+'/eventCoding')
      else if (child.localName = 'eventUri') then
        value.event := ParseUri(child, path+'/eventUri')
      else if (child.localName = 'category') then
        value.categoryElement := ParseEnum(CODES_TFhirMessageSignificanceCategoryEnum, SYSTEMS_TFhirMessageSignificanceCategoryEnum, child, path+'/category')
      else if (child.localName = 'focus') then
        value.focusList.Add(ParseMessageDefinitionFocus(child, path+'/focus'))
      else if (child.localName = 'responseRequired') then
        value.responseRequiredElement := ParseEnum(CODES_TFhirMessageheaderResponseRequestEnum, SYSTEMS_TFhirMessageheaderResponseRequestEnum, child, path+'/responseRequired')
      else if (child.localName = 'allowedResponse') then
        value.allowedResponseList.Add(ParseMessageDefinitionAllowedResponse(child, path+'/allowedResponse'))
      else if (child.localName = 'graph') then
        value.graphElement := ParseCanonical(child, path+'/graph')
      else if Not ParseCanonicalResourceChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeMessageDefinition(xml : TXmlBuilder; name : String; value : TFhirMessageDefinition);
begin
  if (value = nil) then
    exit;
  composeCanonicalResourceAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeMessageDefinitionChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeMessageDefinitionChildren(xml : TXmlBuilder; value : TFhirMessageDefinition);
var
  i : integer;
begin
  composeCanonicalResourceChildren(xml, value);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeUri(xml, 'url', value.urlElement);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.identifierList.Count - 1 do
      ComposeIdentifier(xml, 'identifier', value.identifierList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(xml, 'version', value.versionElement);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(xml, 'name', value.nameElement);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(xml, 'title', value.titleElement);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.replacesList.Count - 1 do
      ComposeCanonical(xml, 'replaces', value.replacesList[i]);
  ComposeEnum(xml, 'status', value.statusElement, CODES_TFhirPublicationStatusEnum);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeBoolean(xml, 'experimental', value.experimentalElement);
  ComposeDateTime(xml, 'date', value.dateElement);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(xml, 'publisher', value.publisherElement);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.contactList.Count - 1 do
      ComposeContactDetail(xml, 'contact', value.contactList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeMarkdown(xml, 'description', value.descriptionElement);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.useContextList.Count - 1 do
      ComposeUsageContext(xml, 'useContext', value.useContextList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.jurisdictionList.Count - 1 do
      ComposeCodeableConcept(xml, 'jurisdiction', value.jurisdictionList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeMarkdown(xml, 'purpose', value.purposeElement);
  if (SummaryOption in [soFull, soData]) then
    ComposeMarkdown(xml, 'copyright', value.copyrightElement);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCanonical(xml, 'base', value.baseElement);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.parentList.Count - 1 do
      ComposeCanonical(xml, 'parent', value.parentList[i]);
  if (value.event is TFhirCoding) {6} then
    ComposeCoding(xml, 'eventCoding', TFhirCoding(value.event))
  else if (value.event is TFhirUri) {6} then
    ComposeUri(xml, 'eventUri', TFhirUri(value.event));
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeEnum(xml, 'category', value.categoryElement, CODES_TFhirMessageSignificanceCategoryEnum);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.focusList.Count - 1 do
      ComposeMessageDefinitionFocus(xml, 'focus', value.focusList[i]);
  if (SummaryOption in [soFull, soData]) then
    ComposeEnum(xml, 'responseRequired', value.responseRequiredElement, CODES_TFhirMessageheaderResponseRequestEnum);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.allowedResponseList.Count - 1 do
      ComposeMessageDefinitionAllowedResponse(xml, 'allowedResponse', value.allowedResponseList[i]);
  if (SummaryOption in [soFull, soData]) then
    ComposeCanonical(xml, 'graph', value.graphElement);
end;

{$ENDIF FHIR_MESSAGEDEFINITION}
{$IFDEF FHIR_MESSAGEHEADER}
function TFHIRXmlParser.ParseMessageHeaderDestination(element : TMXmlElement; path : string) : TFhirMessageHeaderDestination;
var
  child : TMXmlElement;
begin
  result := TFhirMessageHeaderDestination.Create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseMessageHeaderDestinationChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseMessageHeaderDestinationChild(value : TFhirMessageHeaderDestination; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'name') then
        value.nameElement := ParseString(child, path+'/name')
      else if (child.localName = 'target') then
        value.target := ParseReference(child, path+'/target')
      else if (child.localName = 'endpoint') then
        value.endpointElement := ParseUrl(child, path+'/endpoint')
      else if (child.localName = 'receiver') then
        value.receiver := ParseReference(child, path+'/receiver')
      else if Not ParseBackboneElementChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeMessageHeaderDestination(xml : TXmlBuilder; name : String; value : TFhirMessageHeaderDestination);
begin
  if (value = nil) then
    exit;
  composeElementAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeMessageHeaderDestinationChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeMessageHeaderDestinationChildren(xml : TXmlBuilder; value : TFhirMessageHeaderDestination);
begin
  composeBackboneElementChildren(xml, value);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(xml, 'name', value.nameElement);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference(xml, 'target', value.target);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeUrl(xml, 'endpoint', value.endpointElement);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference(xml, 'receiver', value.receiver);
end;

function TFHIRXmlParser.ParseMessageHeaderSource(element : TMXmlElement; path : string) : TFhirMessageHeaderSource;
var
  child : TMXmlElement;
begin
  result := TFhirMessageHeaderSource.Create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseMessageHeaderSourceChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseMessageHeaderSourceChild(value : TFhirMessageHeaderSource; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'name') then
        value.nameElement := ParseString(child, path+'/name')
      else if (child.localName = 'software') then
        value.softwareElement := ParseString(child, path+'/software')
      else if (child.localName = 'version') then
        value.versionElement := ParseString(child, path+'/version')
      else if (child.localName = 'contact') then
        value.contact := ParseContactPoint(child, path+'/contact')
      else if (child.localName = 'endpoint') then
        value.endpointElement := ParseUrl(child, path+'/endpoint')
      else if Not ParseBackboneElementChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeMessageHeaderSource(xml : TXmlBuilder; name : String; value : TFhirMessageHeaderSource);
begin
  if (value = nil) then
    exit;
  composeElementAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeMessageHeaderSourceChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeMessageHeaderSourceChildren(xml : TXmlBuilder; value : TFhirMessageHeaderSource);
begin
  composeBackboneElementChildren(xml, value);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(xml, 'name', value.nameElement);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(xml, 'software', value.softwareElement);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(xml, 'version', value.versionElement);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeContactPoint(xml, 'contact', value.contact);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeUrl(xml, 'endpoint', value.endpointElement);
end;

function TFHIRXmlParser.ParseMessageHeaderResponse(element : TMXmlElement; path : string) : TFhirMessageHeaderResponse;
var
  child : TMXmlElement;
begin
  result := TFhirMessageHeaderResponse.Create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseMessageHeaderResponseChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseMessageHeaderResponseChild(value : TFhirMessageHeaderResponse; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'identifier') then
        value.identifier := ParseIdentifier(child, path+'/identifier')
      else if (child.localName = 'code') then
        value.codeElement := ParseEnum(CODES_TFhirResponseTypeEnum, SYSTEMS_TFhirResponseTypeEnum, child, path+'/code')
      else if (child.localName = 'details') then
        value.details := ParseReference(child, path+'/details')
      else if Not ParseBackboneElementChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeMessageHeaderResponse(xml : TXmlBuilder; name : String; value : TFhirMessageHeaderResponse);
begin
  if (value = nil) then
    exit;
  composeElementAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeMessageHeaderResponseChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeMessageHeaderResponseChildren(xml : TXmlBuilder; value : TFhirMessageHeaderResponse);
begin
  composeBackboneElementChildren(xml, value);
  ComposeIdentifier(xml, 'identifier', value.identifier);
  ComposeEnum(xml, 'code', value.codeElement, CODES_TFhirResponseTypeEnum);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference(xml, 'details', value.details);
end;

function TFHIRXmlParser.ParseMessageHeader(element : TMXmlElement; path : string) : TFhirMessageHeader;
var
  child : TMXmlElement;
begin
  result := TFhirMessageHeader.Create;
  try
    parseDomainResourceAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseMessageHeaderChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseMessageHeaderChild(value : TFhirMessageHeader; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'eventCoding') then
        value.event := ParseCoding(child, path+'/eventCoding')
      else if (child.localName = 'eventCanonical') then
        value.event := ParseCanonical(child, path+'/eventCanonical')
      else if (child.localName = 'destination') then
        value.destinationList.Add(ParseMessageHeaderDestination(child, path+'/destination'))
      else if (child.localName = 'sender') then
        value.sender := ParseReference(child, path+'/sender')
      else if (child.localName = 'enterer') then
        value.enterer := ParseReference(child, path+'/enterer')
      else if (child.localName = 'author') then
        value.author := ParseReference(child, path+'/author')
      else if (child.localName = 'source') then
        value.source := ParseMessageHeaderSource(child, path+'/source')
      else if (child.localName = 'responsible') then
        value.responsible := ParseReference(child, path+'/responsible')
      else if (child.localName = 'reason') then
        value.reason := ParseCodeableConcept(child, path+'/reason')
      else if (child.localName = 'response') then
        value.response := ParseMessageHeaderResponse(child, path+'/response')
      else if (child.localName = 'focus') then
        value.focusList.Add(ParseReference(child, path+'/focus'))
      else if (child.localName = 'definition') then
        value.definitionElement := ParseCanonical(child, path+'/definition')
      else if Not ParseDomainResourceChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeMessageHeader(xml : TXmlBuilder; name : String; value : TFhirMessageHeader);
begin
  if (value = nil) then
    exit;
  composeDomainResourceAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeMessageHeaderChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeMessageHeaderChildren(xml : TXmlBuilder; value : TFhirMessageHeader);
var
  i : integer;
begin
  composeDomainResourceChildren(xml, value);
  if (value.event is TFhirCoding) {6} then
    ComposeCoding(xml, 'eventCoding', TFhirCoding(value.event))
  else if (value.event is TFhirCanonical) {6} then
    ComposeCanonical(xml, 'eventCanonical', TFhirCanonical(value.event));
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.destinationList.Count - 1 do
      ComposeMessageHeaderDestination(xml, 'destination', value.destinationList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference(xml, 'sender', value.sender);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference(xml, 'enterer', value.enterer);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference(xml, 'author', value.author);
  ComposeMessageHeaderSource(xml, 'source', value.source);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference(xml, 'responsible', value.responsible);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(xml, 'reason', value.reason);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeMessageHeaderResponse(xml, 'response', value.response);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.focusList.Count - 1 do
      ComposeReference(xml, 'focus', value.focusList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCanonical(xml, 'definition', value.definitionElement);
end;

{$ENDIF FHIR_MESSAGEHEADER}
{$IFDEF FHIR_MOLECULARSEQUENCE}
function TFHIRXmlParser.ParseMolecularSequenceRelative(element : TMXmlElement; path : string) : TFhirMolecularSequenceRelative;
var
  child : TMXmlElement;
begin
  result := TFhirMolecularSequenceRelative.Create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseMolecularSequenceRelativeChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseMolecularSequenceRelativeChild(value : TFhirMolecularSequenceRelative; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'coordinateSystem') then
        value.coordinateSystem := ParseCodeableConcept(child, path+'/coordinateSystem')
      else if (child.localName = 'ordinalPosition') then
        value.ordinalPositionElement := ParseInteger(child, path+'/ordinalPosition')
      else if (child.localName = 'sequenceRange') then
        value.sequenceRange := ParseRange(child, path+'/sequenceRange')
      else if (child.localName = 'startingSequence') then
        value.startingSequence := ParseMolecularSequenceRelativeStartingSequence(child, path+'/startingSequence')
      else if (child.localName = 'edit') then
        value.editList.Add(ParseMolecularSequenceRelativeEdit(child, path+'/edit'))
      else if Not ParseBackboneElementChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeMolecularSequenceRelative(xml : TXmlBuilder; name : String; value : TFhirMolecularSequenceRelative);
begin
  if (value = nil) then
    exit;
  composeElementAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeMolecularSequenceRelativeChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeMolecularSequenceRelativeChildren(xml : TXmlBuilder; value : TFhirMolecularSequenceRelative);
var
  i : integer;
begin
  composeBackboneElementChildren(xml, value);
  ComposeCodeableConcept(xml, 'coordinateSystem', value.coordinateSystem);
  if (SummaryOption in [soFull, soData]) then
    ComposeInteger(xml, 'ordinalPosition', value.ordinalPositionElement);
  if (SummaryOption in [soFull, soData]) then
    ComposeRange(xml, 'sequenceRange', value.sequenceRange);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeMolecularSequenceRelativeStartingSequence(xml, 'startingSequence', value.startingSequence);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.editList.Count - 1 do
      ComposeMolecularSequenceRelativeEdit(xml, 'edit', value.editList[i]);
end;

function TFHIRXmlParser.ParseMolecularSequenceRelativeStartingSequence(element : TMXmlElement; path : string) : TFhirMolecularSequenceRelativeStartingSequence;
var
  child : TMXmlElement;
begin
  result := TFhirMolecularSequenceRelativeStartingSequence.Create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseMolecularSequenceRelativeStartingSequenceChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseMolecularSequenceRelativeStartingSequenceChild(value : TFhirMolecularSequenceRelativeStartingSequence; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'genomeAssembly') then
        value.genomeAssembly := ParseCodeableConcept(child, path+'/genomeAssembly')
      else if (child.localName = 'chromosome') then
        value.chromosome := ParseCodeableConcept(child, path+'/chromosome')
      else if (child.localName = 'sequenceCodeableConcept') then
        value.sequence := ParseCodeableConcept(child, path+'/sequenceCodeableConcept')
      else if (child.localName = 'sequenceReference') then
        value.sequence := ParseReference(child, path+'/sequenceReference')
      else if (child.localName = 'sequenceString') then
        value.sequence := ParseString(child, path+'/sequenceString')
      else if (child.localName = 'windowStart') then
        value.windowStartElement := ParseInteger(child, path+'/windowStart')
      else if (child.localName = 'windowEnd') then
        value.windowEndElement := ParseInteger(child, path+'/windowEnd')
      else if (child.localName = 'orientation') then
        value.orientationElement := ParseEnum(CODES_TFhirOrientationTypeEnum, SYSTEMS_TFhirOrientationTypeEnum, child, path+'/orientation')
      else if (child.localName = 'strand') then
        value.strandElement := ParseEnum(CODES_TFhirStrandTypeEnum, SYSTEMS_TFhirStrandTypeEnum, child, path+'/strand')
      else if Not ParseBackboneElementChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeMolecularSequenceRelativeStartingSequence(xml : TXmlBuilder; name : String; value : TFhirMolecularSequenceRelativeStartingSequence);
begin
  if (value = nil) then
    exit;
  composeElementAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeMolecularSequenceRelativeStartingSequenceChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeMolecularSequenceRelativeStartingSequenceChildren(xml : TXmlBuilder; value : TFhirMolecularSequenceRelativeStartingSequence);
begin
  composeBackboneElementChildren(xml, value);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(xml, 'genomeAssembly', value.genomeAssembly);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(xml, 'chromosome', value.chromosome);
  if (SummaryOption in [soFull, soSummary, soData]) and (value.sequence is TFhirCodeableConcept) {6} then
    ComposeCodeableConcept(xml, 'sequenceCodeableConcept', TFhirCodeableConcept(value.sequence))
  else if (SummaryOption in [soFull, soSummary, soData]) and (value.sequence is TFhirReference) {2} then
    ComposeReference(xml, 'sequenceReference', TFhirReference(value.sequence))
  else if (SummaryOption in [soFull, soSummary, soData]) and (value.sequence is TFhirString) {6} then
    ComposeString(xml, 'sequenceString', TFhirString(value.sequence));
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeInteger(xml, 'windowStart', value.windowStartElement);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeInteger(xml, 'windowEnd', value.windowEndElement);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeEnum(xml, 'orientation', value.orientationElement, CODES_TFhirOrientationTypeEnum);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeEnum(xml, 'strand', value.strandElement, CODES_TFhirStrandTypeEnum);
end;

function TFHIRXmlParser.ParseMolecularSequenceRelativeEdit(element : TMXmlElement; path : string) : TFhirMolecularSequenceRelativeEdit;
var
  child : TMXmlElement;
begin
  result := TFhirMolecularSequenceRelativeEdit.Create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseMolecularSequenceRelativeEditChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseMolecularSequenceRelativeEditChild(value : TFhirMolecularSequenceRelativeEdit; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'start') then
        value.startElement := ParseInteger(child, path+'/start')
      else if (child.localName = 'end') then
        value.end_Element := ParseInteger(child, path+'/end')
      else if (child.localName = 'replacementSequence') then
        value.replacementSequenceElement := ParseString(child, path+'/replacementSequence')
      else if (child.localName = 'replacedSequence') then
        value.replacedSequenceElement := ParseString(child, path+'/replacedSequence')
      else if Not ParseBackboneElementChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeMolecularSequenceRelativeEdit(xml : TXmlBuilder; name : String; value : TFhirMolecularSequenceRelativeEdit);
begin
  if (value = nil) then
    exit;
  composeElementAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeMolecularSequenceRelativeEditChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeMolecularSequenceRelativeEditChildren(xml : TXmlBuilder; value : TFhirMolecularSequenceRelativeEdit);
begin
  composeBackboneElementChildren(xml, value);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeInteger(xml, 'start', value.startElement);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeInteger(xml, 'end', value.end_Element);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(xml, 'replacementSequence', value.replacementSequenceElement);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(xml, 'replacedSequence', value.replacedSequenceElement);
end;

function TFHIRXmlParser.ParseMolecularSequence(element : TMXmlElement; path : string) : TFhirMolecularSequence;
var
  child : TMXmlElement;
begin
  result := TFhirMolecularSequence.Create;
  try
    parseDomainResourceAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseMolecularSequenceChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseMolecularSequenceChild(value : TFhirMolecularSequence; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'identifier') then
        value.identifierList.Add(ParseIdentifier(child, path+'/identifier'))
      else if (child.localName = 'type') then
        value.type_Element := ParseEnum(CODES_TFhirSequenceTypeEnum, SYSTEMS_TFhirSequenceTypeEnum, child, path+'/type')
      else if (child.localName = 'subject') then
        value.subject := ParseReference(child, path+'/subject')
      else if (child.localName = 'specimen') then
        value.specimen := ParseReference(child, path+'/specimen')
      else if (child.localName = 'device') then
        value.device := ParseReference(child, path+'/device')
      else if (child.localName = 'performer') then
        value.performer := ParseReference(child, path+'/performer')
      else if (child.localName = 'literal') then
        value.literalElement := ParseString(child, path+'/literal')
      else if (child.localName = 'formatted') then
        value.formattedList.Add(ParseAttachment(child, path+'/formatted'))
      else if (child.localName = 'relative') then
        value.relativeList.Add(ParseMolecularSequenceRelative(child, path+'/relative'))
      else if Not ParseDomainResourceChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeMolecularSequence(xml : TXmlBuilder; name : String; value : TFhirMolecularSequence);
begin
  if (value = nil) then
    exit;
  composeDomainResourceAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeMolecularSequenceChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeMolecularSequenceChildren(xml : TXmlBuilder; value : TFhirMolecularSequence);
var
  i : integer;
begin
  composeDomainResourceChildren(xml, value);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.identifierList.Count - 1 do
      ComposeIdentifier(xml, 'identifier', value.identifierList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeEnum(xml, 'type', value.type_Element, CODES_TFhirSequenceTypeEnum);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference(xml, 'subject', value.subject);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference(xml, 'specimen', value.specimen);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference(xml, 'device', value.device);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference(xml, 'performer', value.performer);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(xml, 'literal', value.literalElement);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.formattedList.Count - 1 do
      ComposeAttachment(xml, 'formatted', value.formattedList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.relativeList.Count - 1 do
      ComposeMolecularSequenceRelative(xml, 'relative', value.relativeList[i]);
end;

{$ENDIF FHIR_MOLECULARSEQUENCE}
{$IFDEF FHIR_NAMINGSYSTEM}
function TFHIRXmlParser.ParseNamingSystemUniqueId(element : TMXmlElement; path : string) : TFhirNamingSystemUniqueId;
var
  child : TMXmlElement;
begin
  result := TFhirNamingSystemUniqueId.Create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseNamingSystemUniqueIdChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseNamingSystemUniqueIdChild(value : TFhirNamingSystemUniqueId; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'type') then
        value.type_Element := ParseEnum(CODES_TFhirNamingSystemIdentifierTypeEnum, SYSTEMS_TFhirNamingSystemIdentifierTypeEnum, child, path+'/type')
      else if (child.localName = 'value') then
        value.valueElement := ParseString(child, path+'/value')
      else if (child.localName = 'preferred') then
        value.preferredElement := ParseBoolean(child, path+'/preferred')
      else if (child.localName = 'comment') then
        value.commentElement := ParseString(child, path+'/comment')
      else if (child.localName = 'period') then
        value.period := ParsePeriod(child, path+'/period')
      else if (child.localName = 'authoritative') then
        value.authoritativeElement := ParseBoolean(child, path+'/authoritative')
      else if Not ParseBackboneElementChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeNamingSystemUniqueId(xml : TXmlBuilder; name : String; value : TFhirNamingSystemUniqueId);
begin
  if (value = nil) then
    exit;
  composeElementAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeNamingSystemUniqueIdChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeNamingSystemUniqueIdChildren(xml : TXmlBuilder; value : TFhirNamingSystemUniqueId);
begin
  composeBackboneElementChildren(xml, value);
  ComposeEnum(xml, 'type', value.type_Element, CODES_TFhirNamingSystemIdentifierTypeEnum);
  ComposeString(xml, 'value', value.valueElement);
  if (SummaryOption in [soFull, soData]) then
    ComposeBoolean(xml, 'preferred', value.preferredElement);
  if (SummaryOption in [soFull, soData]) then
    ComposeString(xml, 'comment', value.commentElement);
  if (SummaryOption in [soFull, soData]) then
    ComposePeriod(xml, 'period', value.period);
  if (SummaryOption in [soFull, soData]) then
    ComposeBoolean(xml, 'authoritative', value.authoritativeElement);
end;

function TFHIRXmlParser.ParseNamingSystem(element : TMXmlElement; path : string) : TFhirNamingSystem;
var
  child : TMXmlElement;
begin
  result := TFhirNamingSystem.Create;
  try
    parseMetadataResourceAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseNamingSystemChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseNamingSystemChild(value : TFhirNamingSystem; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'url') then
        value.urlElement := ParseUri(child, path+'/url')
      else if (child.localName = 'identifier') then
        value.identifierList.Add(ParseIdentifier(child, path+'/identifier'))
      else if (child.localName = 'version') then
        value.versionElement := ParseString(child, path+'/version')
      else if (child.localName = 'name') then
        value.nameElement := ParseString(child, path+'/name')
      else if (child.localName = 'title') then
        value.titleElement := ParseString(child, path+'/title')
      else if (child.localName = 'status') then
        value.statusElement := ParseEnum(CODES_TFhirPublicationStatusEnum, SYSTEMS_TFhirPublicationStatusEnum, child, path+'/status')
      else if (child.localName = 'kind') then
        value.kindElement := ParseEnum(CODES_TFhirNamingSystemTypeEnum, SYSTEMS_TFhirNamingSystemTypeEnum, child, path+'/kind')
      else if (child.localName = 'experimental') then
        value.experimentalElement := ParseBoolean(child, path+'/experimental')
      else if (child.localName = 'date') then
        value.dateElement := ParseDateTime(child, path+'/date')
      else if (child.localName = 'publisher') then
        value.publisherElement := ParseString(child, path+'/publisher')
      else if (child.localName = 'contact') then
        value.contactList.Add(ParseContactDetail(child, path+'/contact'))
      else if (child.localName = 'responsible') then
        value.responsibleElement := ParseString(child, path+'/responsible')
      else if (child.localName = 'type') then
        value.type_ := ParseCodeableConcept(child, path+'/type')
      else if (child.localName = 'description') then
        value.descriptionElement := ParseMarkdown(child, path+'/description')
      else if (child.localName = 'useContext') then
        value.useContextList.Add(ParseUsageContext(child, path+'/useContext'))
      else if (child.localName = 'jurisdiction') then
        value.jurisdictionList.Add(ParseCodeableConcept(child, path+'/jurisdiction'))
      else if (child.localName = 'purpose') then
        value.purposeElement := ParseMarkdown(child, path+'/purpose')
      else if (child.localName = 'copyright') then
        value.copyrightElement := ParseMarkdown(child, path+'/copyright')
      else if (child.localName = 'approvalDate') then
        value.approvalDateElement := ParseDate(child, path+'/approvalDate')
      else if (child.localName = 'lastReviewDate') then
        value.lastReviewDateElement := ParseDate(child, path+'/lastReviewDate')
      else if (child.localName = 'effectivePeriod') then
        value.effectivePeriod := ParsePeriod(child, path+'/effectivePeriod')
      else if (child.localName = 'topic') then
        value.topicList.Add(ParseCodeableConcept(child, path+'/topic'))
      else if (child.localName = 'author') then
        value.authorList.Add(ParseContactDetail(child, path+'/author'))
      else if (child.localName = 'editor') then
        value.editorList.Add(ParseContactDetail(child, path+'/editor'))
      else if (child.localName = 'reviewer') then
        value.reviewerList.Add(ParseContactDetail(child, path+'/reviewer'))
      else if (child.localName = 'endorser') then
        value.endorserList.Add(ParseContactDetail(child, path+'/endorser'))
      else if (child.localName = 'relatedArtifact') then
        value.relatedArtifactList.Add(ParseRelatedArtifact(child, path+'/relatedArtifact'))
      else if (child.localName = 'usage') then
        value.usageElement := ParseString(child, path+'/usage')
      else if (child.localName = 'uniqueId') then
        value.uniqueIdList.Add(ParseNamingSystemUniqueId(child, path+'/uniqueId'))
      else if Not ParseMetadataResourceChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeNamingSystem(xml : TXmlBuilder; name : String; value : TFhirNamingSystem);
begin
  if (value = nil) then
    exit;
  composeMetadataResourceAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeNamingSystemChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeNamingSystemChildren(xml : TXmlBuilder; value : TFhirNamingSystem);
var
  i : integer;
begin
  composeMetadataResourceChildren(xml, value);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeUri(xml, 'url', value.urlElement);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.identifierList.Count - 1 do
      ComposeIdentifier(xml, 'identifier', value.identifierList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(xml, 'version', value.versionElement);
  ComposeString(xml, 'name', value.nameElement);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(xml, 'title', value.titleElement);
  ComposeEnum(xml, 'status', value.statusElement, CODES_TFhirPublicationStatusEnum);
  ComposeEnum(xml, 'kind', value.kindElement, CODES_TFhirNamingSystemTypeEnum);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeBoolean(xml, 'experimental', value.experimentalElement);
  ComposeDateTime(xml, 'date', value.dateElement);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(xml, 'publisher', value.publisherElement);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.contactList.Count - 1 do
      ComposeContactDetail(xml, 'contact', value.contactList[i]);
  if (SummaryOption in [soFull, soData]) then
    ComposeString(xml, 'responsible', value.responsibleElement);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(xml, 'type', value.type_);
  if (SummaryOption in [soFull, soData]) then
    ComposeMarkdown(xml, 'description', value.descriptionElement);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.useContextList.Count - 1 do
      ComposeUsageContext(xml, 'useContext', value.useContextList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.jurisdictionList.Count - 1 do
      ComposeCodeableConcept(xml, 'jurisdiction', value.jurisdictionList[i]);
  if (SummaryOption in [soFull, soData]) then
    ComposeMarkdown(xml, 'purpose', value.purposeElement);
  if (SummaryOption in [soFull, soData]) then
    ComposeMarkdown(xml, 'copyright', value.copyrightElement);
  if (SummaryOption in [soFull, soData]) then
    ComposeDate(xml, 'approvalDate', value.approvalDateElement);
  if (SummaryOption in [soFull, soData]) then
    ComposeDate(xml, 'lastReviewDate', value.lastReviewDateElement);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposePeriod(xml, 'effectivePeriod', value.effectivePeriod);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.topicList.Count - 1 do
      ComposeCodeableConcept(xml, 'topic', value.topicList[i]);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.authorList.Count - 1 do
      ComposeContactDetail(xml, 'author', value.authorList[i]);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.editorList.Count - 1 do
      ComposeContactDetail(xml, 'editor', value.editorList[i]);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.reviewerList.Count - 1 do
      ComposeContactDetail(xml, 'reviewer', value.reviewerList[i]);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.endorserList.Count - 1 do
      ComposeContactDetail(xml, 'endorser', value.endorserList[i]);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.relatedArtifactList.Count - 1 do
      ComposeRelatedArtifact(xml, 'relatedArtifact', value.relatedArtifactList[i]);
  if (SummaryOption in [soFull, soData]) then
    ComposeString(xml, 'usage', value.usageElement);
  for i := 0 to value.uniqueIdList.Count - 1 do
      ComposeNamingSystemUniqueId(xml, 'uniqueId', value.uniqueIdList[i]);
end;

{$ENDIF FHIR_NAMINGSYSTEM}
{$IFDEF FHIR_NUTRITIONINTAKE}
function TFHIRXmlParser.ParseNutritionIntakeConsumedItem(element : TMXmlElement; path : string) : TFhirNutritionIntakeConsumedItem;
var
  child : TMXmlElement;
begin
  result := TFhirNutritionIntakeConsumedItem.Create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseNutritionIntakeConsumedItemChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseNutritionIntakeConsumedItemChild(value : TFhirNutritionIntakeConsumedItem; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'type') then
        value.type_ := ParseCodeableConcept(child, path+'/type')
      else if (child.localName = 'nutritionProduct') then
        value.nutritionProduct := ParseCodeableReference(child, path+'/nutritionProduct')
      else if (child.localName = 'schedule') then
        value.schedule := ParseTiming(child, path+'/schedule')
      else if (child.localName = 'amount') then
        value.amount := ParseQuantity(child, path+'/amount')
      else if (child.localName = 'rate') then
        value.rate := ParseQuantity(child, path+'/rate')
      else if (child.localName = 'notConsumed') then
        value.notConsumedElement := ParseBoolean(child, path+'/notConsumed')
      else if (child.localName = 'notConsumedReason') then
        value.notConsumedReason := ParseCodeableConcept(child, path+'/notConsumedReason')
      else if Not ParseBackboneElementChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeNutritionIntakeConsumedItem(xml : TXmlBuilder; name : String; value : TFhirNutritionIntakeConsumedItem);
begin
  if (value = nil) then
    exit;
  composeElementAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeNutritionIntakeConsumedItemChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeNutritionIntakeConsumedItemChildren(xml : TXmlBuilder; value : TFhirNutritionIntakeConsumedItem);
begin
  composeBackboneElementChildren(xml, value);
  ComposeCodeableConcept(xml, 'type', value.type_);
  ComposeCodeableReference(xml, 'nutritionProduct', value.nutritionProduct);
  if (SummaryOption in [soFull, soData]) then
    ComposeTiming(xml, 'schedule', value.schedule);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeQuantity(xml, 'amount', value.amount);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeQuantity(xml, 'rate', value.rate);
  if (SummaryOption in [soFull, soData]) then
    ComposeBoolean(xml, 'notConsumed', value.notConsumedElement);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(xml, 'notConsumedReason', value.notConsumedReason);
end;

function TFHIRXmlParser.ParseNutritionIntakeIngredientLabel(element : TMXmlElement; path : string) : TFhirNutritionIntakeIngredientLabel;
var
  child : TMXmlElement;
begin
  result := TFhirNutritionIntakeIngredientLabel.Create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseNutritionIntakeIngredientLabelChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseNutritionIntakeIngredientLabelChild(value : TFhirNutritionIntakeIngredientLabel; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'nutrient') then
        value.nutrient := ParseCodeableReference(child, path+'/nutrient')
      else if (child.localName = 'amount') then
        value.amount := ParseQuantity(child, path+'/amount')
      else if Not ParseBackboneElementChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeNutritionIntakeIngredientLabel(xml : TXmlBuilder; name : String; value : TFhirNutritionIntakeIngredientLabel);
begin
  if (value = nil) then
    exit;
  composeElementAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeNutritionIntakeIngredientLabelChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeNutritionIntakeIngredientLabelChildren(xml : TXmlBuilder; value : TFhirNutritionIntakeIngredientLabel);
begin
  composeBackboneElementChildren(xml, value);
  ComposeCodeableReference(xml, 'nutrient', value.nutrient);
  ComposeQuantity(xml, 'amount', value.amount);
end;

function TFHIRXmlParser.ParseNutritionIntakePerformer(element : TMXmlElement; path : string) : TFhirNutritionIntakePerformer;
var
  child : TMXmlElement;
begin
  result := TFhirNutritionIntakePerformer.Create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseNutritionIntakePerformerChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseNutritionIntakePerformerChild(value : TFhirNutritionIntakePerformer; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'function') then
        value.function_ := ParseCodeableConcept(child, path+'/function')
      else if (child.localName = 'actor') then
        value.actor := ParseReference(child, path+'/actor')
      else if Not ParseBackboneElementChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeNutritionIntakePerformer(xml : TXmlBuilder; name : String; value : TFhirNutritionIntakePerformer);
begin
  if (value = nil) then
    exit;
  composeElementAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeNutritionIntakePerformerChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeNutritionIntakePerformerChildren(xml : TXmlBuilder; value : TFhirNutritionIntakePerformer);
begin
  composeBackboneElementChildren(xml, value);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(xml, 'function', value.function_);
  ComposeReference(xml, 'actor', value.actor);
end;

function TFHIRXmlParser.ParseNutritionIntake(element : TMXmlElement; path : string) : TFhirNutritionIntake;
var
  child : TMXmlElement;
begin
  result := TFhirNutritionIntake.Create;
  try
    parseDomainResourceAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseNutritionIntakeChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseNutritionIntakeChild(value : TFhirNutritionIntake; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'identifier') then
        value.identifierList.Add(ParseIdentifier(child, path+'/identifier'))
      else if (child.localName = 'instantiatesCanonical') then
        value.instantiatesCanonicalList.Add(ParseCanonical(child, path+'/instantiatesCanonical'))
      else if (child.localName = 'instantiatesUri') then
        value.instantiatesUriList.Add(ParseUri(child, path+'/instantiatesUri'))
      else if (child.localName = 'basedOn') then
        value.basedOnList.Add(ParseReference(child, path+'/basedOn'))
      else if (child.localName = 'partOf') then
        value.partOfList.Add(ParseReference(child, path+'/partOf'))
      else if (child.localName = 'status') then
        value.statusElement := ParseEnum(CODES_TFhirEventStatusEnum, SYSTEMS_TFhirEventStatusEnum, child, path+'/status')
      else if (child.localName = 'statusReason') then
        value.statusReasonList.Add(ParseCodeableConcept(child, path+'/statusReason'))
      else if (child.localName = 'code') then
        value.code := ParseCodeableConcept(child, path+'/code')
      else if (child.localName = 'subject') then
        value.subject := ParseReference(child, path+'/subject')
      else if (child.localName = 'encounter') then
        value.encounter := ParseReference(child, path+'/encounter')
      else if (child.localName = 'occurrencePeriod') then
        value.occurrence := ParsePeriod(child, path+'/occurrencePeriod')
      else if (child.localName = 'occurrenceDateTime') then
        value.occurrence := ParseDateTime(child, path+'/occurrenceDateTime')
      else if (child.localName = 'recorded') then
        value.recordedElement := ParseDateTime(child, path+'/recorded')
      else if (child.localName = 'reportedReference') then
        value.reported := ParseReference(child, path+'/reportedReference')
      else if (child.localName = 'reportedBoolean') then
        value.reported := ParseBoolean(child, path+'/reportedBoolean')
      else if (child.localName = 'consumedItem') then
        value.consumedItemList.Add(ParseNutritionIntakeConsumedItem(child, path+'/consumedItem'))
      else if (child.localName = 'ingredientLabel') then
        value.ingredientLabelList.Add(ParseNutritionIntakeIngredientLabel(child, path+'/ingredientLabel'))
      else if (child.localName = 'performer') then
        value.performerList.Add(ParseNutritionIntakePerformer(child, path+'/performer'))
      else if (child.localName = 'location') then
        value.location := ParseReference(child, path+'/location')
      else if (child.localName = 'derivedFrom') then
        value.derivedFromList.Add(ParseReference(child, path+'/derivedFrom'))
      else if (child.localName = 'reason') then
        value.reasonList.Add(ParseCodeableReference(child, path+'/reason'))
      else if (child.localName = 'note') then
        value.noteList.Add(ParseAnnotation(child, path+'/note'))
      else if Not ParseDomainResourceChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeNutritionIntake(xml : TXmlBuilder; name : String; value : TFhirNutritionIntake);
begin
  if (value = nil) then
    exit;
  composeDomainResourceAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeNutritionIntakeChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeNutritionIntakeChildren(xml : TXmlBuilder; value : TFhirNutritionIntake);
var
  i : integer;
begin
  composeDomainResourceChildren(xml, value);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.identifierList.Count - 1 do
      ComposeIdentifier(xml, 'identifier', value.identifierList[i]);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.instantiatesCanonicalList.Count - 1 do
      ComposeCanonical(xml, 'instantiatesCanonical', value.instantiatesCanonicalList[i]);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.instantiatesUriList.Count - 1 do
      ComposeUri(xml, 'instantiatesUri', value.instantiatesUriList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.basedOnList.Count - 1 do
      ComposeReference(xml, 'basedOn', value.basedOnList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.partOfList.Count - 1 do
      ComposeReference(xml, 'partOf', value.partOfList[i]);
  ComposeEnum(xml, 'status', value.statusElement, CODES_TFhirEventStatusEnum);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.statusReasonList.Count - 1 do
      ComposeCodeableConcept(xml, 'statusReason', value.statusReasonList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(xml, 'code', value.code);
  ComposeReference(xml, 'subject', value.subject);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference(xml, 'encounter', value.encounter);
  if (SummaryOption in [soFull, soSummary, soData]) and (value.occurrence is TFhirPeriod) {6} then
    ComposePeriod(xml, 'occurrencePeriod', TFhirPeriod(value.occurrence))
  else if (SummaryOption in [soFull, soSummary, soData]) and (value.occurrence is TFhirDateTime) {6} then
    ComposeDateTime(xml, 'occurrenceDateTime', TFhirDateTime(value.occurrence));
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDateTime(xml, 'recorded', value.recordedElement);
  if (SummaryOption in [soFull, soData]) and (value.reported is TFhirReference) {2} then
    ComposeReference(xml, 'reportedReference', TFhirReference(value.reported))
  else if (SummaryOption in [soFull, soData]) and (value.reported is TFhirBoolean) {6} then
    ComposeBoolean(xml, 'reportedBoolean', TFhirBoolean(value.reported));
  for i := 0 to value.consumedItemList.Count - 1 do
      ComposeNutritionIntakeConsumedItem(xml, 'consumedItem', value.consumedItemList[i]);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.ingredientLabelList.Count - 1 do
      ComposeNutritionIntakeIngredientLabel(xml, 'ingredientLabel', value.ingredientLabelList[i]);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.performerList.Count - 1 do
      ComposeNutritionIntakePerformer(xml, 'performer', value.performerList[i]);
  if (SummaryOption in [soFull, soData]) then
    ComposeReference(xml, 'location', value.location);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.derivedFromList.Count - 1 do
      ComposeReference(xml, 'derivedFrom', value.derivedFromList[i]);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.reasonList.Count - 1 do
      ComposeCodeableReference(xml, 'reason', value.reasonList[i]);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.noteList.Count - 1 do
      ComposeAnnotation(xml, 'note', value.noteList[i]);
end;

{$ENDIF FHIR_NUTRITIONINTAKE}
{$IFDEF FHIR_NUTRITIONORDER}
function TFHIRXmlParser.ParseNutritionOrderOralDiet(element : TMXmlElement; path : string) : TFhirNutritionOrderOralDiet;
var
  child : TMXmlElement;
begin
  result := TFhirNutritionOrderOralDiet.Create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseNutritionOrderOralDietChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseNutritionOrderOralDietChild(value : TFhirNutritionOrderOralDiet; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'type') then
        value.type_List.Add(ParseCodeableConcept(child, path+'/type'))
      else if (child.localName = 'schedule') then
        value.schedule := ParseNutritionOrderOralDietSchedule(child, path+'/schedule')
      else if (child.localName = 'nutrient') then
        value.nutrientList.Add(ParseNutritionOrderOralDietNutrient(child, path+'/nutrient'))
      else if (child.localName = 'texture') then
        value.textureList.Add(ParseNutritionOrderOralDietTexture(child, path+'/texture'))
      else if (child.localName = 'fluidConsistencyType') then
        value.fluidConsistencyTypeList.Add(ParseCodeableConcept(child, path+'/fluidConsistencyType'))
      else if (child.localName = 'instruction') then
        value.instructionElement := ParseString(child, path+'/instruction')
      else if Not ParseBackboneElementChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeNutritionOrderOralDiet(xml : TXmlBuilder; name : String; value : TFhirNutritionOrderOralDiet);
begin
  if (value = nil) then
    exit;
  composeElementAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeNutritionOrderOralDietChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeNutritionOrderOralDietChildren(xml : TXmlBuilder; value : TFhirNutritionOrderOralDiet);
var
  i : integer;
begin
  composeBackboneElementChildren(xml, value);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.type_List.Count - 1 do
      ComposeCodeableConcept(xml, 'type', value.type_List[i]);
  if (SummaryOption in [soFull, soData]) then
    ComposeNutritionOrderOralDietSchedule(xml, 'schedule', value.schedule);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.nutrientList.Count - 1 do
      ComposeNutritionOrderOralDietNutrient(xml, 'nutrient', value.nutrientList[i]);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.textureList.Count - 1 do
      ComposeNutritionOrderOralDietTexture(xml, 'texture', value.textureList[i]);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.fluidConsistencyTypeList.Count - 1 do
      ComposeCodeableConcept(xml, 'fluidConsistencyType', value.fluidConsistencyTypeList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(xml, 'instruction', value.instructionElement);
end;

function TFHIRXmlParser.ParseNutritionOrderOralDietSchedule(element : TMXmlElement; path : string) : TFhirNutritionOrderOralDietSchedule;
var
  child : TMXmlElement;
begin
  result := TFhirNutritionOrderOralDietSchedule.Create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseNutritionOrderOralDietScheduleChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseNutritionOrderOralDietScheduleChild(value : TFhirNutritionOrderOralDietSchedule; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'timing') then
        value.timingList.Add(ParseTiming(child, path+'/timing'))
      else if (child.localName = 'asNeeded') then
        value.asNeededElement := ParseBoolean(child, path+'/asNeeded')
      else if (child.localName = 'asNeededFor') then
        value.asNeededFor := ParseCodeableConcept(child, path+'/asNeededFor')
      else if Not ParseBackboneElementChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeNutritionOrderOralDietSchedule(xml : TXmlBuilder; name : String; value : TFhirNutritionOrderOralDietSchedule);
begin
  if (value = nil) then
    exit;
  composeElementAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeNutritionOrderOralDietScheduleChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeNutritionOrderOralDietScheduleChildren(xml : TXmlBuilder; value : TFhirNutritionOrderOralDietSchedule);
var
  i : integer;
begin
  composeBackboneElementChildren(xml, value);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.timingList.Count - 1 do
      ComposeTiming(xml, 'timing', value.timingList[i]);
  if (SummaryOption in [soFull, soData]) then
    ComposeBoolean(xml, 'asNeeded', value.asNeededElement);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(xml, 'asNeededFor', value.asNeededFor);
end;

function TFHIRXmlParser.ParseNutritionOrderOralDietNutrient(element : TMXmlElement; path : string) : TFhirNutritionOrderOralDietNutrient;
var
  child : TMXmlElement;
begin
  result := TFhirNutritionOrderOralDietNutrient.Create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseNutritionOrderOralDietNutrientChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseNutritionOrderOralDietNutrientChild(value : TFhirNutritionOrderOralDietNutrient; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'modifier') then
        value.modifier := ParseCodeableConcept(child, path+'/modifier')
      else if (child.localName = 'amount') then
        value.amount := ParseQuantity(child, path+'/amount')
      else if Not ParseBackboneElementChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeNutritionOrderOralDietNutrient(xml : TXmlBuilder; name : String; value : TFhirNutritionOrderOralDietNutrient);
begin
  if (value = nil) then
    exit;
  composeElementAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeNutritionOrderOralDietNutrientChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeNutritionOrderOralDietNutrientChildren(xml : TXmlBuilder; value : TFhirNutritionOrderOralDietNutrient);
begin
  composeBackboneElementChildren(xml, value);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(xml, 'modifier', value.modifier);
  if (SummaryOption in [soFull, soData]) then
    ComposeQuantity(xml, 'amount', value.amount);
end;

function TFHIRXmlParser.ParseNutritionOrderOralDietTexture(element : TMXmlElement; path : string) : TFhirNutritionOrderOralDietTexture;
var
  child : TMXmlElement;
begin
  result := TFhirNutritionOrderOralDietTexture.Create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseNutritionOrderOralDietTextureChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseNutritionOrderOralDietTextureChild(value : TFhirNutritionOrderOralDietTexture; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'modifier') then
        value.modifier := ParseCodeableConcept(child, path+'/modifier')
      else if (child.localName = 'foodType') then
        value.foodType := ParseCodeableConcept(child, path+'/foodType')
      else if Not ParseBackboneElementChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeNutritionOrderOralDietTexture(xml : TXmlBuilder; name : String; value : TFhirNutritionOrderOralDietTexture);
begin
  if (value = nil) then
    exit;
  composeElementAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeNutritionOrderOralDietTextureChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeNutritionOrderOralDietTextureChildren(xml : TXmlBuilder; value : TFhirNutritionOrderOralDietTexture);
begin
  composeBackboneElementChildren(xml, value);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(xml, 'modifier', value.modifier);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(xml, 'foodType', value.foodType);
end;

function TFHIRXmlParser.ParseNutritionOrderSupplement(element : TMXmlElement; path : string) : TFhirNutritionOrderSupplement;
var
  child : TMXmlElement;
begin
  result := TFhirNutritionOrderSupplement.Create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseNutritionOrderSupplementChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseNutritionOrderSupplementChild(value : TFhirNutritionOrderSupplement; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'type') then
        value.type_ := ParseCodeableReference(child, path+'/type')
      else if (child.localName = 'productName') then
        value.productNameElement := ParseString(child, path+'/productName')
      else if (child.localName = 'schedule') then
        value.schedule := ParseNutritionOrderSupplementSchedule(child, path+'/schedule')
      else if (child.localName = 'quantity') then
        value.quantity := ParseQuantity(child, path+'/quantity')
      else if (child.localName = 'instruction') then
        value.instructionElement := ParseString(child, path+'/instruction')
      else if Not ParseBackboneElementChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeNutritionOrderSupplement(xml : TXmlBuilder; name : String; value : TFhirNutritionOrderSupplement);
begin
  if (value = nil) then
    exit;
  composeElementAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeNutritionOrderSupplementChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeNutritionOrderSupplementChildren(xml : TXmlBuilder; value : TFhirNutritionOrderSupplement);
begin
  composeBackboneElementChildren(xml, value);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableReference(xml, 'type', value.type_);
  if (SummaryOption in [soFull, soData]) then
    ComposeString(xml, 'productName', value.productNameElement);
  if (SummaryOption in [soFull, soData]) then
    ComposeNutritionOrderSupplementSchedule(xml, 'schedule', value.schedule);
  if (SummaryOption in [soFull, soData]) then
    ComposeQuantity(xml, 'quantity', value.quantity);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(xml, 'instruction', value.instructionElement);
end;

function TFHIRXmlParser.ParseNutritionOrderSupplementSchedule(element : TMXmlElement; path : string) : TFhirNutritionOrderSupplementSchedule;
var
  child : TMXmlElement;
begin
  result := TFhirNutritionOrderSupplementSchedule.Create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseNutritionOrderSupplementScheduleChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseNutritionOrderSupplementScheduleChild(value : TFhirNutritionOrderSupplementSchedule; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'timing') then
        value.timingList.Add(ParseTiming(child, path+'/timing'))
      else if (child.localName = 'asNeeded') then
        value.asNeededElement := ParseBoolean(child, path+'/asNeeded')
      else if (child.localName = 'asNeededFor') then
        value.asNeededFor := ParseCodeableConcept(child, path+'/asNeededFor')
      else if Not ParseBackboneElementChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeNutritionOrderSupplementSchedule(xml : TXmlBuilder; name : String; value : TFhirNutritionOrderSupplementSchedule);
begin
  if (value = nil) then
    exit;
  composeElementAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeNutritionOrderSupplementScheduleChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeNutritionOrderSupplementScheduleChildren(xml : TXmlBuilder; value : TFhirNutritionOrderSupplementSchedule);
var
  i : integer;
begin
  composeBackboneElementChildren(xml, value);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.timingList.Count - 1 do
      ComposeTiming(xml, 'timing', value.timingList[i]);
  if (SummaryOption in [soFull, soData]) then
    ComposeBoolean(xml, 'asNeeded', value.asNeededElement);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(xml, 'asNeededFor', value.asNeededFor);
end;

function TFHIRXmlParser.ParseNutritionOrderEnteralFormula(element : TMXmlElement; path : string) : TFhirNutritionOrderEnteralFormula;
var
  child : TMXmlElement;
begin
  result := TFhirNutritionOrderEnteralFormula.Create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseNutritionOrderEnteralFormulaChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseNutritionOrderEnteralFormulaChild(value : TFhirNutritionOrderEnteralFormula; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'baseFormulaType') then
        value.baseFormulaType := ParseCodeableReference(child, path+'/baseFormulaType')
      else if (child.localName = 'baseFormulaProductName') then
        value.baseFormulaProductNameElement := ParseString(child, path+'/baseFormulaProductName')
      else if (child.localName = 'deliveryDevice') then
        value.deliveryDeviceList.Add(ParseCodeableReference(child, path+'/deliveryDevice'))
      else if (child.localName = 'additive') then
        value.additiveList.Add(ParseNutritionOrderEnteralFormulaAdditive(child, path+'/additive'))
      else if (child.localName = 'caloricDensity') then
        value.caloricDensity := ParseQuantity(child, path+'/caloricDensity')
      else if (child.localName = 'routeOfAdministration') then
        value.routeOfAdministration := ParseCodeableConcept(child, path+'/routeOfAdministration')
      else if (child.localName = 'administration') then
        value.administrationList.Add(ParseNutritionOrderEnteralFormulaAdministration(child, path+'/administration'))
      else if (child.localName = 'maxVolumeToDeliver') then
        value.maxVolumeToDeliver := ParseQuantity(child, path+'/maxVolumeToDeliver')
      else if (child.localName = 'administrationInstruction') then
        value.administrationInstructionElement := ParseString(child, path+'/administrationInstruction')
      else if Not ParseBackboneElementChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeNutritionOrderEnteralFormula(xml : TXmlBuilder; name : String; value : TFhirNutritionOrderEnteralFormula);
begin
  if (value = nil) then
    exit;
  composeElementAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeNutritionOrderEnteralFormulaChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeNutritionOrderEnteralFormulaChildren(xml : TXmlBuilder; value : TFhirNutritionOrderEnteralFormula);
var
  i : integer;
begin
  composeBackboneElementChildren(xml, value);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableReference(xml, 'baseFormulaType', value.baseFormulaType);
  if (SummaryOption in [soFull, soData]) then
    ComposeString(xml, 'baseFormulaProductName', value.baseFormulaProductNameElement);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.deliveryDeviceList.Count - 1 do
      ComposeCodeableReference(xml, 'deliveryDevice', value.deliveryDeviceList[i]);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.additiveList.Count - 1 do
      ComposeNutritionOrderEnteralFormulaAdditive(xml, 'additive', value.additiveList[i]);
  if (SummaryOption in [soFull, soData]) then
    ComposeQuantity(xml, 'caloricDensity', value.caloricDensity);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(xml, 'routeOfAdministration', value.routeOfAdministration);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.administrationList.Count - 1 do
      ComposeNutritionOrderEnteralFormulaAdministration(xml, 'administration', value.administrationList[i]);
  if (SummaryOption in [soFull, soData]) then
    ComposeQuantity(xml, 'maxVolumeToDeliver', value.maxVolumeToDeliver);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(xml, 'administrationInstruction', value.administrationInstructionElement);
end;

function TFHIRXmlParser.ParseNutritionOrderEnteralFormulaAdditive(element : TMXmlElement; path : string) : TFhirNutritionOrderEnteralFormulaAdditive;
var
  child : TMXmlElement;
begin
  result := TFhirNutritionOrderEnteralFormulaAdditive.Create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseNutritionOrderEnteralFormulaAdditiveChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseNutritionOrderEnteralFormulaAdditiveChild(value : TFhirNutritionOrderEnteralFormulaAdditive; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'type') then
        value.type_ := ParseCodeableReference(child, path+'/type')
      else if (child.localName = 'productName') then
        value.productNameElement := ParseString(child, path+'/productName')
      else if (child.localName = 'quantity') then
        value.quantity := ParseQuantity(child, path+'/quantity')
      else if Not ParseBackboneElementChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeNutritionOrderEnteralFormulaAdditive(xml : TXmlBuilder; name : String; value : TFhirNutritionOrderEnteralFormulaAdditive);
begin
  if (value = nil) then
    exit;
  composeElementAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeNutritionOrderEnteralFormulaAdditiveChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeNutritionOrderEnteralFormulaAdditiveChildren(xml : TXmlBuilder; value : TFhirNutritionOrderEnteralFormulaAdditive);
begin
  composeBackboneElementChildren(xml, value);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableReference(xml, 'type', value.type_);
  if (SummaryOption in [soFull, soData]) then
    ComposeString(xml, 'productName', value.productNameElement);
  if (SummaryOption in [soFull, soData]) then
    ComposeQuantity(xml, 'quantity', value.quantity);
end;

function TFHIRXmlParser.ParseNutritionOrderEnteralFormulaAdministration(element : TMXmlElement; path : string) : TFhirNutritionOrderEnteralFormulaAdministration;
var
  child : TMXmlElement;
begin
  result := TFhirNutritionOrderEnteralFormulaAdministration.Create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseNutritionOrderEnteralFormulaAdministrationChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseNutritionOrderEnteralFormulaAdministrationChild(value : TFhirNutritionOrderEnteralFormulaAdministration; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'schedule') then
        value.schedule := ParseNutritionOrderEnteralFormulaAdministrationSchedule(child, path+'/schedule')
      else if (child.localName = 'quantity') then
        value.quantity := ParseQuantity(child, path+'/quantity')
      else if (child.localName = 'rateQuantity') then
        value.rate := ParseQuantity(child, path+'/rateQuantity')
      else if (child.localName = 'rateRatio') then
        value.rate := ParseRatio(child, path+'/rateRatio')
      else if Not ParseBackboneElementChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeNutritionOrderEnteralFormulaAdministration(xml : TXmlBuilder; name : String; value : TFhirNutritionOrderEnteralFormulaAdministration);
begin
  if (value = nil) then
    exit;
  composeElementAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeNutritionOrderEnteralFormulaAdministrationChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeNutritionOrderEnteralFormulaAdministrationChildren(xml : TXmlBuilder; value : TFhirNutritionOrderEnteralFormulaAdministration);
begin
  composeBackboneElementChildren(xml, value);
  if (SummaryOption in [soFull, soData]) then
    ComposeNutritionOrderEnteralFormulaAdministrationSchedule(xml, 'schedule', value.schedule);
  if (SummaryOption in [soFull, soData]) then
    ComposeQuantity(xml, 'quantity', value.quantity);
  if (SummaryOption in [soFull, soData]) and (value.rate is TFhirQuantity) {6} then
    ComposeQuantity(xml, 'rateQuantity', TFhirQuantity(value.rate))
  else if (SummaryOption in [soFull, soData]) and (value.rate is TFhirRatio) {6} then
    ComposeRatio(xml, 'rateRatio', TFhirRatio(value.rate));
end;

function TFHIRXmlParser.ParseNutritionOrderEnteralFormulaAdministrationSchedule(element : TMXmlElement; path : string) : TFhirNutritionOrderEnteralFormulaAdministrationSchedule;
var
  child : TMXmlElement;
begin
  result := TFhirNutritionOrderEnteralFormulaAdministrationSchedule.Create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseNutritionOrderEnteralFormulaAdministrationScheduleChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseNutritionOrderEnteralFormulaAdministrationScheduleChild(value : TFhirNutritionOrderEnteralFormulaAdministrationSchedule; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'timing') then
        value.timingList.Add(ParseTiming(child, path+'/timing'))
      else if (child.localName = 'asNeeded') then
        value.asNeededElement := ParseBoolean(child, path+'/asNeeded')
      else if (child.localName = 'asNeededFor') then
        value.asNeededFor := ParseCodeableConcept(child, path+'/asNeededFor')
      else if Not ParseBackboneElementChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeNutritionOrderEnteralFormulaAdministrationSchedule(xml : TXmlBuilder; name : String; value : TFhirNutritionOrderEnteralFormulaAdministrationSchedule);
begin
  if (value = nil) then
    exit;
  composeElementAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeNutritionOrderEnteralFormulaAdministrationScheduleChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeNutritionOrderEnteralFormulaAdministrationScheduleChildren(xml : TXmlBuilder; value : TFhirNutritionOrderEnteralFormulaAdministrationSchedule);
var
  i : integer;
begin
  composeBackboneElementChildren(xml, value);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.timingList.Count - 1 do
      ComposeTiming(xml, 'timing', value.timingList[i]);
  if (SummaryOption in [soFull, soData]) then
    ComposeBoolean(xml, 'asNeeded', value.asNeededElement);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(xml, 'asNeededFor', value.asNeededFor);
end;

function TFHIRXmlParser.ParseNutritionOrder(element : TMXmlElement; path : string) : TFhirNutritionOrder;
var
  child : TMXmlElement;
begin
  result := TFhirNutritionOrder.Create;
  try
    parseDomainResourceAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseNutritionOrderChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseNutritionOrderChild(value : TFhirNutritionOrder; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'identifier') then
        value.identifierList.Add(ParseIdentifier(child, path+'/identifier'))
      else if (child.localName = 'instantiatesCanonical') then
        value.instantiatesCanonicalList.Add(ParseCanonical(child, path+'/instantiatesCanonical'))
      else if (child.localName = 'instantiatesUri') then
        value.instantiatesUriList.Add(ParseUri(child, path+'/instantiatesUri'))
      else if (child.localName = 'instantiates') then
        value.instantiatesList.Add(ParseUri(child, path+'/instantiates'))
      else if (child.localName = 'basedOn') then
        value.basedOnList.Add(ParseReference(child, path+'/basedOn'))
      else if (child.localName = 'status') then
        value.statusElement := ParseEnum(CODES_TFhirRequestStatusEnum, SYSTEMS_TFhirRequestStatusEnum, child, path+'/status')
      else if (child.localName = 'intent') then
        value.intentElement := ParseEnum(CODES_TFhirRequestIntentEnum, SYSTEMS_TFhirRequestIntentEnum, child, path+'/intent')
      else if (child.localName = 'priority') then
        value.priorityElement := ParseEnum(CODES_TFhirRequestPriorityEnum, SYSTEMS_TFhirRequestPriorityEnum, child, path+'/priority')
      else if (child.localName = 'subject') then
        value.subject := ParseReference(child, path+'/subject')
      else if (child.localName = 'encounter') then
        value.encounter := ParseReference(child, path+'/encounter')
      else if (child.localName = 'supportingInformation') then
        value.supportingInformationList.Add(ParseReference(child, path+'/supportingInformation'))
      else if (child.localName = 'dateTime') then
        value.dateTimeElement := ParseDateTime(child, path+'/dateTime')
      else if (child.localName = 'orderer') then
        value.orderer := ParseReference(child, path+'/orderer')
      else if (child.localName = 'performer') then
        value.performerList.Add(ParseCodeableReference(child, path+'/performer'))
      else if (child.localName = 'allergyIntolerance') then
        value.allergyIntoleranceList.Add(ParseReference(child, path+'/allergyIntolerance'))
      else if (child.localName = 'foodPreferenceModifier') then
        value.foodPreferenceModifierList.Add(ParseCodeableConcept(child, path+'/foodPreferenceModifier'))
      else if (child.localName = 'excludeFoodModifier') then
        value.excludeFoodModifierList.Add(ParseCodeableConcept(child, path+'/excludeFoodModifier'))
      else if (child.localName = 'outsideFoodAllowed') then
        value.outsideFoodAllowedElement := ParseBoolean(child, path+'/outsideFoodAllowed')
      else if (child.localName = 'oralDiet') then
        value.oralDiet := ParseNutritionOrderOralDiet(child, path+'/oralDiet')
      else if (child.localName = 'supplement') then
        value.supplementList.Add(ParseNutritionOrderSupplement(child, path+'/supplement'))
      else if (child.localName = 'enteralFormula') then
        value.enteralFormula := ParseNutritionOrderEnteralFormula(child, path+'/enteralFormula')
      else if (child.localName = 'note') then
        value.noteList.Add(ParseAnnotation(child, path+'/note'))
      else if Not ParseDomainResourceChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeNutritionOrder(xml : TXmlBuilder; name : String; value : TFhirNutritionOrder);
begin
  if (value = nil) then
    exit;
  composeDomainResourceAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeNutritionOrderChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeNutritionOrderChildren(xml : TXmlBuilder; value : TFhirNutritionOrder);
var
  i : integer;
begin
  composeDomainResourceChildren(xml, value);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.identifierList.Count - 1 do
      ComposeIdentifier(xml, 'identifier', value.identifierList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.instantiatesCanonicalList.Count - 1 do
      ComposeCanonical(xml, 'instantiatesCanonical', value.instantiatesCanonicalList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.instantiatesUriList.Count - 1 do
      ComposeUri(xml, 'instantiatesUri', value.instantiatesUriList[i]);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.instantiatesList.Count - 1 do
      ComposeUri(xml, 'instantiates', value.instantiatesList[i]);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.basedOnList.Count - 1 do
      ComposeReference(xml, 'basedOn', value.basedOnList[i]);
  ComposeEnum(xml, 'status', value.statusElement, CODES_TFhirRequestStatusEnum);
  ComposeEnum(xml, 'intent', value.intentElement, CODES_TFhirRequestIntentEnum);
  if (SummaryOption in [soFull, soData]) then
    ComposeEnum(xml, 'priority', value.priorityElement, CODES_TFhirRequestPriorityEnum);
  ComposeReference(xml, 'subject', value.subject);
  if (SummaryOption in [soFull, soData]) then
    ComposeReference(xml, 'encounter', value.encounter);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.supportingInformationList.Count - 1 do
      ComposeReference(xml, 'supportingInformation', value.supportingInformationList[i]);
  ComposeDateTime(xml, 'dateTime', value.dateTimeElement);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference(xml, 'orderer', value.orderer);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.performerList.Count - 1 do
      ComposeCodeableReference(xml, 'performer', value.performerList[i]);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.allergyIntoleranceList.Count - 1 do
      ComposeReference(xml, 'allergyIntolerance', value.allergyIntoleranceList[i]);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.foodPreferenceModifierList.Count - 1 do
      ComposeCodeableConcept(xml, 'foodPreferenceModifier', value.foodPreferenceModifierList[i]);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.excludeFoodModifierList.Count - 1 do
      ComposeCodeableConcept(xml, 'excludeFoodModifier', value.excludeFoodModifierList[i]);
  if (SummaryOption in [soFull, soData]) then
    ComposeBoolean(xml, 'outsideFoodAllowed', value.outsideFoodAllowedElement);
  if (SummaryOption in [soFull, soData]) then
    ComposeNutritionOrderOralDiet(xml, 'oralDiet', value.oralDiet);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.supplementList.Count - 1 do
      ComposeNutritionOrderSupplement(xml, 'supplement', value.supplementList[i]);
  if (SummaryOption in [soFull, soData]) then
    ComposeNutritionOrderEnteralFormula(xml, 'enteralFormula', value.enteralFormula);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.noteList.Count - 1 do
      ComposeAnnotation(xml, 'note', value.noteList[i]);
end;

{$ENDIF FHIR_NUTRITIONORDER}
{$IFDEF FHIR_NUTRITIONPRODUCT}
function TFHIRXmlParser.ParseNutritionProductNutrient(element : TMXmlElement; path : string) : TFhirNutritionProductNutrient;
var
  child : TMXmlElement;
begin
  result := TFhirNutritionProductNutrient.Create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseNutritionProductNutrientChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseNutritionProductNutrientChild(value : TFhirNutritionProductNutrient; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'item') then
        value.item := ParseCodeableReference(child, path+'/item')
      else if (child.localName = 'amount') then
        value.amountList.Add(ParseRatio(child, path+'/amount'))
      else if Not ParseBackboneElementChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeNutritionProductNutrient(xml : TXmlBuilder; name : String; value : TFhirNutritionProductNutrient);
begin
  if (value = nil) then
    exit;
  composeElementAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeNutritionProductNutrientChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeNutritionProductNutrientChildren(xml : TXmlBuilder; value : TFhirNutritionProductNutrient);
var
  i : integer;
begin
  composeBackboneElementChildren(xml, value);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableReference(xml, 'item', value.item);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.amountList.Count - 1 do
      ComposeRatio(xml, 'amount', value.amountList[i]);
end;

function TFHIRXmlParser.ParseNutritionProductIngredient(element : TMXmlElement; path : string) : TFhirNutritionProductIngredient;
var
  child : TMXmlElement;
begin
  result := TFhirNutritionProductIngredient.Create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseNutritionProductIngredientChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseNutritionProductIngredientChild(value : TFhirNutritionProductIngredient; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'item') then
        value.item := ParseCodeableReference(child, path+'/item')
      else if (child.localName = 'amount') then
        value.amountList.Add(ParseRatio(child, path+'/amount'))
      else if Not ParseBackboneElementChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeNutritionProductIngredient(xml : TXmlBuilder; name : String; value : TFhirNutritionProductIngredient);
begin
  if (value = nil) then
    exit;
  composeElementAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeNutritionProductIngredientChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeNutritionProductIngredientChildren(xml : TXmlBuilder; value : TFhirNutritionProductIngredient);
var
  i : integer;
begin
  composeBackboneElementChildren(xml, value);
  ComposeCodeableReference(xml, 'item', value.item);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.amountList.Count - 1 do
      ComposeRatio(xml, 'amount', value.amountList[i]);
end;

function TFHIRXmlParser.ParseNutritionProductCharacteristic(element : TMXmlElement; path : string) : TFhirNutritionProductCharacteristic;
var
  child : TMXmlElement;
begin
  result := TFhirNutritionProductCharacteristic.Create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseNutritionProductCharacteristicChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseNutritionProductCharacteristicChild(value : TFhirNutritionProductCharacteristic; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'type') then
        value.type_ := ParseCodeableConcept(child, path+'/type')
      else if (child.localName = 'valueCodeableConcept') then
        value.value := ParseCodeableConcept(child, path+'/valueCodeableConcept')
      else if (child.localName = 'valueQuantity') then
        value.value := ParseQuantity(child, path+'/valueQuantity')
      else if (child.localName = 'valueAttachment') then
        value.value := ParseAttachment(child, path+'/valueAttachment')
      else if (child.localName = 'valueString') then
        value.value := ParseString(child, path+'/valueString')
      else if (child.localName = 'valueBase64Binary') then
        value.value := ParseBase64Binary(child, path+'/valueBase64Binary')
      else if (child.localName = 'valueBoolean') then
        value.value := ParseBoolean(child, path+'/valueBoolean')
      else if Not ParseBackboneElementChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeNutritionProductCharacteristic(xml : TXmlBuilder; name : String; value : TFhirNutritionProductCharacteristic);
begin
  if (value = nil) then
    exit;
  composeElementAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeNutritionProductCharacteristicChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeNutritionProductCharacteristicChildren(xml : TXmlBuilder; value : TFhirNutritionProductCharacteristic);
begin
  composeBackboneElementChildren(xml, value);
  ComposeCodeableConcept(xml, 'type', value.type_);
  if (value.value is TFhirCodeableConcept) {6} then
    ComposeCodeableConcept(xml, 'valueCodeableConcept', TFhirCodeableConcept(value.value))
  else if (value.value is TFhirQuantity) {6} then
    ComposeQuantity(xml, 'valueQuantity', TFhirQuantity(value.value))
  else if (value.value is TFhirAttachment) {6} then
    ComposeAttachment(xml, 'valueAttachment', TFhirAttachment(value.value))
  else if (value.value is TFhirString) {6} then
    ComposeString(xml, 'valueString', TFhirString(value.value))
  else if (value.value is TFhirBase64Binary) {6} then
    ComposeBase64Binary(xml, 'valueBase64Binary', TFhirBase64Binary(value.value))
  else if (value.value is TFhirBoolean) {6} then
    ComposeBoolean(xml, 'valueBoolean', TFhirBoolean(value.value));
end;

function TFHIRXmlParser.ParseNutritionProductInstance(element : TMXmlElement; path : string) : TFhirNutritionProductInstance;
var
  child : TMXmlElement;
begin
  result := TFhirNutritionProductInstance.Create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseNutritionProductInstanceChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseNutritionProductInstanceChild(value : TFhirNutritionProductInstance; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'quantity') then
        value.quantity := ParseQuantity(child, path+'/quantity')
      else if (child.localName = 'identifier') then
        value.identifierList.Add(ParseIdentifier(child, path+'/identifier'))
      else if (child.localName = 'name') then
        value.nameElement := ParseString(child, path+'/name')
      else if (child.localName = 'lotNumber') then
        value.lotNumberElement := ParseString(child, path+'/lotNumber')
      else if (child.localName = 'expiry') then
        value.expiryElement := ParseDateTime(child, path+'/expiry')
      else if (child.localName = 'useBy') then
        value.useByElement := ParseDateTime(child, path+'/useBy')
      else if (child.localName = 'biologicalSourceEvent') then
        value.biologicalSourceEvent := ParseIdentifier(child, path+'/biologicalSourceEvent')
      else if Not ParseBackboneElementChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeNutritionProductInstance(xml : TXmlBuilder; name : String; value : TFhirNutritionProductInstance);
begin
  if (value = nil) then
    exit;
  composeElementAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeNutritionProductInstanceChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeNutritionProductInstanceChildren(xml : TXmlBuilder; value : TFhirNutritionProductInstance);
var
  i : integer;
begin
  composeBackboneElementChildren(xml, value);
  if (SummaryOption in [soFull, soData]) then
    ComposeQuantity(xml, 'quantity', value.quantity);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.identifierList.Count - 1 do
      ComposeIdentifier(xml, 'identifier', value.identifierList[i]);
  if (SummaryOption in [soFull, soData]) then
    ComposeString(xml, 'name', value.nameElement);
  if (SummaryOption in [soFull, soData]) then
    ComposeString(xml, 'lotNumber', value.lotNumberElement);
  if (SummaryOption in [soFull, soData]) then
    ComposeDateTime(xml, 'expiry', value.expiryElement);
  if (SummaryOption in [soFull, soData]) then
    ComposeDateTime(xml, 'useBy', value.useByElement);
  if (SummaryOption in [soFull, soData]) then
    ComposeIdentifier(xml, 'biologicalSourceEvent', value.biologicalSourceEvent);
end;

function TFHIRXmlParser.ParseNutritionProduct(element : TMXmlElement; path : string) : TFhirNutritionProduct;
var
  child : TMXmlElement;
begin
  result := TFhirNutritionProduct.Create;
  try
    parseDomainResourceAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseNutritionProductChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseNutritionProductChild(value : TFhirNutritionProduct; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'code') then
        value.code := ParseCodeableConcept(child, path+'/code')
      else if (child.localName = 'status') then
        value.statusElement := ParseEnum(CODES_TFhirNutritionProductStatusEnum, SYSTEMS_TFhirNutritionProductStatusEnum, child, path+'/status')
      else if (child.localName = 'category') then
        value.categoryList.Add(ParseCodeableConcept(child, path+'/category'))
      else if (child.localName = 'manufacturer') then
        value.manufacturerList.Add(ParseReference(child, path+'/manufacturer'))
      else if (child.localName = 'nutrient') then
        value.nutrientList.Add(ParseNutritionProductNutrient(child, path+'/nutrient'))
      else if (child.localName = 'ingredient') then
        value.ingredientList.Add(ParseNutritionProductIngredient(child, path+'/ingredient'))
      else if (child.localName = 'knownAllergen') then
        value.knownAllergenList.Add(ParseCodeableReference(child, path+'/knownAllergen'))
      else if (child.localName = 'characteristic') then
        value.characteristicList.Add(ParseNutritionProductCharacteristic(child, path+'/characteristic'))
      else if (child.localName = 'instance') then
        value.instanceList.Add(ParseNutritionProductInstance(child, path+'/instance'))
      else if (child.localName = 'note') then
        value.noteList.Add(ParseAnnotation(child, path+'/note'))
      else if Not ParseDomainResourceChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeNutritionProduct(xml : TXmlBuilder; name : String; value : TFhirNutritionProduct);
begin
  if (value = nil) then
    exit;
  composeDomainResourceAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeNutritionProductChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeNutritionProductChildren(xml : TXmlBuilder; value : TFhirNutritionProduct);
var
  i : integer;
begin
  composeDomainResourceChildren(xml, value);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(xml, 'code', value.code);
  ComposeEnum(xml, 'status', value.statusElement, CODES_TFhirNutritionProductStatusEnum);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.categoryList.Count - 1 do
      ComposeCodeableConcept(xml, 'category', value.categoryList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.manufacturerList.Count - 1 do
      ComposeReference(xml, 'manufacturer', value.manufacturerList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.nutrientList.Count - 1 do
      ComposeNutritionProductNutrient(xml, 'nutrient', value.nutrientList[i]);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.ingredientList.Count - 1 do
      ComposeNutritionProductIngredient(xml, 'ingredient', value.ingredientList[i]);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.knownAllergenList.Count - 1 do
      ComposeCodeableReference(xml, 'knownAllergen', value.knownAllergenList[i]);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.characteristicList.Count - 1 do
      ComposeNutritionProductCharacteristic(xml, 'characteristic', value.characteristicList[i]);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.instanceList.Count - 1 do
      ComposeNutritionProductInstance(xml, 'instance', value.instanceList[i]);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.noteList.Count - 1 do
      ComposeAnnotation(xml, 'note', value.noteList[i]);
end;

{$ENDIF FHIR_NUTRITIONPRODUCT}
{$IFDEF FHIR_OBSERVATION}
function TFHIRXmlParser.ParseObservationTriggeredBy(element : TMXmlElement; path : string) : TFhirObservationTriggeredBy;
var
  child : TMXmlElement;
begin
  result := TFhirObservationTriggeredBy.Create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseObservationTriggeredByChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseObservationTriggeredByChild(value : TFhirObservationTriggeredBy; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'observation') then
        value.observation := ParseReference(child, path+'/observation')
      else if (child.localName = 'type') then
        value.type_Element := ParseEnum(CODES_TFhirTriggeredBytypeEnum, SYSTEMS_TFhirTriggeredBytypeEnum, child, path+'/type')
      else if (child.localName = 'reason') then
        value.reasonElement := ParseString(child, path+'/reason')
      else if Not ParseBackboneElementChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeObservationTriggeredBy(xml : TXmlBuilder; name : String; value : TFhirObservationTriggeredBy);
begin
  if (value = nil) then
    exit;
  composeElementAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeObservationTriggeredByChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeObservationTriggeredByChildren(xml : TXmlBuilder; value : TFhirObservationTriggeredBy);
begin
  composeBackboneElementChildren(xml, value);
  ComposeReference(xml, 'observation', value.observation);
  ComposeEnum(xml, 'type', value.type_Element, CODES_TFhirTriggeredBytypeEnum);
  if (SummaryOption in [soFull, soData]) then
    ComposeString(xml, 'reason', value.reasonElement);
end;

function TFHIRXmlParser.ParseObservationReferenceRange(element : TMXmlElement; path : string) : TFhirObservationReferenceRange;
var
  child : TMXmlElement;
begin
  result := TFhirObservationReferenceRange.Create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseObservationReferenceRangeChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseObservationReferenceRangeChild(value : TFhirObservationReferenceRange; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'low') then
        value.low := ParseQuantity(child, path+'/low')
      else if (child.localName = 'high') then
        value.high := ParseQuantity(child, path+'/high')
      else if (child.localName = 'normalValue') then
        value.normalValue := ParseCodeableConcept(child, path+'/normalValue')
      else if (child.localName = 'type') then
        value.type_ := ParseCodeableConcept(child, path+'/type')
      else if (child.localName = 'appliesTo') then
        value.appliesToList.Add(ParseCodeableConcept(child, path+'/appliesTo'))
      else if (child.localName = 'age') then
        value.age := ParseRange(child, path+'/age')
      else if (child.localName = 'text') then
        value.textElement := ParseString(child, path+'/text')
      else if Not ParseBackboneElementChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeObservationReferenceRange(xml : TXmlBuilder; name : String; value : TFhirObservationReferenceRange);
begin
  if (value = nil) then
    exit;
  composeElementAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeObservationReferenceRangeChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeObservationReferenceRangeChildren(xml : TXmlBuilder; value : TFhirObservationReferenceRange);
var
  i : integer;
begin
  composeBackboneElementChildren(xml, value);
  if (SummaryOption in [soFull, soData]) then
    ComposeQuantity(xml, 'low', value.low);
  if (SummaryOption in [soFull, soData]) then
    ComposeQuantity(xml, 'high', value.high);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(xml, 'normalValue', value.normalValue);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(xml, 'type', value.type_);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.appliesToList.Count - 1 do
      ComposeCodeableConcept(xml, 'appliesTo', value.appliesToList[i]);
  if (SummaryOption in [soFull, soData]) then
    ComposeRange(xml, 'age', value.age);
  if (SummaryOption in [soFull, soData]) then
    ComposeString(xml, 'text', value.textElement);
end;

function TFHIRXmlParser.ParseObservationComponent(element : TMXmlElement; path : string) : TFhirObservationComponent;
var
  child : TMXmlElement;
begin
  result := TFhirObservationComponent.Create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseObservationComponentChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseObservationComponentChild(value : TFhirObservationComponent; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'code') then
        value.code := ParseCodeableConcept(child, path+'/code')
      else if (child.localName = 'valueQuantity') then
        value.value := ParseQuantity(child, path+'/valueQuantity')
      else if (child.localName = 'valueCodeableConcept') then
        value.value := ParseCodeableConcept(child, path+'/valueCodeableConcept')
      else if (child.localName = 'valueRange') then
        value.value := ParseRange(child, path+'/valueRange')
      else if (child.localName = 'valueRatio') then
        value.value := ParseRatio(child, path+'/valueRatio')
      else if (child.localName = 'valueSampledData') then
        value.value := ParseSampledData(child, path+'/valueSampledData')
      else if (child.localName = 'valuePeriod') then
        value.value := ParsePeriod(child, path+'/valuePeriod')
      else if (child.localName = 'valueAttachment') then
        value.value := ParseAttachment(child, path+'/valueAttachment')
      else if (child.localName = 'valueString') then
        value.value := ParseString(child, path+'/valueString')
      else if (child.localName = 'valueBoolean') then
        value.value := ParseBoolean(child, path+'/valueBoolean')
      else if (child.localName = 'valueInteger') then
        value.value := ParseInteger(child, path+'/valueInteger')
      else if (child.localName = 'valueTime') then
        value.value := ParseTime(child, path+'/valueTime')
      else if (child.localName = 'valueDateTime') then
        value.value := ParseDateTime(child, path+'/valueDateTime')
      else if (child.localName = 'dataAbsentReason') then
        value.dataAbsentReason := ParseCodeableConcept(child, path+'/dataAbsentReason')
      else if (child.localName = 'interpretation') then
        value.interpretationList.Add(ParseCodeableConcept(child, path+'/interpretation'))
      else if (child.localName = 'referenceRange') then
        value.referenceRangeList.Add(ParseObservationReferenceRange(child, path+'/referenceRange'))
      else if Not ParseBackboneElementChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeObservationComponent(xml : TXmlBuilder; name : String; value : TFhirObservationComponent);
begin
  if (value = nil) then
    exit;
  composeElementAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeObservationComponentChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeObservationComponentChildren(xml : TXmlBuilder; value : TFhirObservationComponent);
var
  i : integer;
begin
  composeBackboneElementChildren(xml, value);
  ComposeCodeableConcept(xml, 'code', value.code);
  if (SummaryOption in [soFull, soSummary, soData]) and (value.value is TFhirQuantity) {6} then
    ComposeQuantity(xml, 'valueQuantity', TFhirQuantity(value.value))
  else if (SummaryOption in [soFull, soSummary, soData]) and (value.value is TFhirCodeableConcept) {6} then
    ComposeCodeableConcept(xml, 'valueCodeableConcept', TFhirCodeableConcept(value.value))
  else if (SummaryOption in [soFull, soSummary, soData]) and (value.value is TFhirRange) {6} then
    ComposeRange(xml, 'valueRange', TFhirRange(value.value))
  else if (SummaryOption in [soFull, soSummary, soData]) and (value.value is TFhirRatio) {6} then
    ComposeRatio(xml, 'valueRatio', TFhirRatio(value.value))
  else if (SummaryOption in [soFull, soSummary, soData]) and (value.value is TFhirSampledData) {6} then
    ComposeSampledData(xml, 'valueSampledData', TFhirSampledData(value.value))
  else if (SummaryOption in [soFull, soSummary, soData]) and (value.value is TFhirPeriod) {6} then
    ComposePeriod(xml, 'valuePeriod', TFhirPeriod(value.value))
  else if (SummaryOption in [soFull, soSummary, soData]) and (value.value is TFhirAttachment) {6} then
    ComposeAttachment(xml, 'valueAttachment', TFhirAttachment(value.value))
  else if (SummaryOption in [soFull, soSummary, soData]) and (value.value is TFhirString) {6} then
    ComposeString(xml, 'valueString', TFhirString(value.value))
  else if (SummaryOption in [soFull, soSummary, soData]) and (value.value is TFhirBoolean) {6} then
    ComposeBoolean(xml, 'valueBoolean', TFhirBoolean(value.value))
  else if (SummaryOption in [soFull, soSummary, soData]) and (value.value is TFhirInteger) {6} then
    ComposeInteger(xml, 'valueInteger', TFhirInteger(value.value))
  else if (SummaryOption in [soFull, soSummary, soData]) and (value.value is TFhirTime) {6} then
    ComposeTime(xml, 'valueTime', TFhirTime(value.value))
  else if (SummaryOption in [soFull, soSummary, soData]) and (value.value is TFhirDateTime) {6} then
    ComposeDateTime(xml, 'valueDateTime', TFhirDateTime(value.value));
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(xml, 'dataAbsentReason', value.dataAbsentReason);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.interpretationList.Count - 1 do
      ComposeCodeableConcept(xml, 'interpretation', value.interpretationList[i]);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.referenceRangeList.Count - 1 do
      ComposeObservationReferenceRange(xml, 'referenceRange', value.referenceRangeList[i]);
end;

function TFHIRXmlParser.ParseObservation(element : TMXmlElement; path : string) : TFhirObservation;
var
  child : TMXmlElement;
begin
  result := TFhirObservation.Create;
  try
    parseDomainResourceAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseObservationChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseObservationChild(value : TFhirObservation; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'identifier') then
        value.identifierList.Add(ParseIdentifier(child, path+'/identifier'))
      else if (child.localName = 'instantiatesCanonical') then
        value.instantiates := ParseCanonical(child, path+'/instantiatesCanonical')
      else if (child.localName = 'instantiatesReference') then
        value.instantiates := ParseReference(child, path+'/instantiatesReference')
      else if (child.localName = 'basedOn') then
        value.basedOnList.Add(ParseReference(child, path+'/basedOn'))
      else if (child.localName = 'triggeredBy') then
        value.triggeredByList.Add(ParseObservationTriggeredBy(child, path+'/triggeredBy'))
      else if (child.localName = 'partOf') then
        value.partOfList.Add(ParseReference(child, path+'/partOf'))
      else if (child.localName = 'status') then
        value.statusElement := ParseEnum(CODES_TFhirObservationStatusEnum, SYSTEMS_TFhirObservationStatusEnum, child, path+'/status')
      else if (child.localName = 'category') then
        value.categoryList.Add(ParseCodeableConcept(child, path+'/category'))
      else if (child.localName = 'code') then
        value.code := ParseCodeableConcept(child, path+'/code')
      else if (child.localName = 'subject') then
        value.subject := ParseReference(child, path+'/subject')
      else if (child.localName = 'focus') then
        value.focusList.Add(ParseReference(child, path+'/focus'))
      else if (child.localName = 'encounter') then
        value.encounter := ParseReference(child, path+'/encounter')
      else if (child.localName = 'effectivePeriod') then
        value.effective := ParsePeriod(child, path+'/effectivePeriod')
      else if (child.localName = 'effectiveTiming') then
        value.effective := ParseTiming(child, path+'/effectiveTiming')
      else if (child.localName = 'effectiveDateTime') then
        value.effective := ParseDateTime(child, path+'/effectiveDateTime')
      else if (child.localName = 'effectiveInstant') then
        value.effective := ParseInstant(child, path+'/effectiveInstant')
      else if (child.localName = 'issued') then
        value.issuedElement := ParseInstant(child, path+'/issued')
      else if (child.localName = 'performer') then
        value.performerList.Add(ParseReference(child, path+'/performer'))
      else if (child.localName = 'valueQuantity') then
        value.value := ParseQuantity(child, path+'/valueQuantity')
      else if (child.localName = 'valueCodeableConcept') then
        value.value := ParseCodeableConcept(child, path+'/valueCodeableConcept')
      else if (child.localName = 'valueRange') then
        value.value := ParseRange(child, path+'/valueRange')
      else if (child.localName = 'valueRatio') then
        value.value := ParseRatio(child, path+'/valueRatio')
      else if (child.localName = 'valueSampledData') then
        value.value := ParseSampledData(child, path+'/valueSampledData')
      else if (child.localName = 'valuePeriod') then
        value.value := ParsePeriod(child, path+'/valuePeriod')
      else if (child.localName = 'valueAttachment') then
        value.value := ParseAttachment(child, path+'/valueAttachment')
      else if (child.localName = 'valueString') then
        value.value := ParseString(child, path+'/valueString')
      else if (child.localName = 'valueBoolean') then
        value.value := ParseBoolean(child, path+'/valueBoolean')
      else if (child.localName = 'valueInteger') then
        value.value := ParseInteger(child, path+'/valueInteger')
      else if (child.localName = 'valueTime') then
        value.value := ParseTime(child, path+'/valueTime')
      else if (child.localName = 'valueDateTime') then
        value.value := ParseDateTime(child, path+'/valueDateTime')
      else if (child.localName = 'dataAbsentReason') then
        value.dataAbsentReason := ParseCodeableConcept(child, path+'/dataAbsentReason')
      else if (child.localName = 'interpretation') then
        value.interpretationList.Add(ParseCodeableConcept(child, path+'/interpretation'))
      else if (child.localName = 'note') then
        value.noteList.Add(ParseAnnotation(child, path+'/note'))
      else if (child.localName = 'bodySite') then
        value.bodySite := ParseCodeableConcept(child, path+'/bodySite')
      else if (child.localName = 'bodyStructure') then
        value.bodyStructure := ParseReference(child, path+'/bodyStructure')
      else if (child.localName = 'method') then
        value.method := ParseCodeableConcept(child, path+'/method')
      else if (child.localName = 'specimen') then
        value.specimen := ParseReference(child, path+'/specimen')
      else if (child.localName = 'device') then
        value.device := ParseReference(child, path+'/device')
      else if (child.localName = 'referenceRange') then
        value.referenceRangeList.Add(ParseObservationReferenceRange(child, path+'/referenceRange'))
      else if (child.localName = 'hasMember') then
        value.hasMemberList.Add(ParseReference(child, path+'/hasMember'))
      else if (child.localName = 'derivedFrom') then
        value.derivedFromList.Add(ParseReference(child, path+'/derivedFrom'))
      else if (child.localName = 'component') then
        value.componentList.Add(ParseObservationComponent(child, path+'/component'))
      else if Not ParseDomainResourceChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeObservation(xml : TXmlBuilder; name : String; value : TFhirObservation);
begin
  if (value = nil) then
    exit;
  composeDomainResourceAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeObservationChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeObservationChildren(xml : TXmlBuilder; value : TFhirObservation);
var
  i : integer;
begin
  composeDomainResourceChildren(xml, value);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.identifierList.Count - 1 do
      ComposeIdentifier(xml, 'identifier', value.identifierList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) and (value.instantiates is TFhirCanonical) {6} then
    ComposeCanonical(xml, 'instantiatesCanonical', TFhirCanonical(value.instantiates))
  else if (SummaryOption in [soFull, soSummary, soData]) and (value.instantiates is TFhirReference) {2} then
    ComposeReference(xml, 'instantiatesReference', TFhirReference(value.instantiates));
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.basedOnList.Count - 1 do
      ComposeReference(xml, 'basedOn', value.basedOnList[i]);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.triggeredByList.Count - 1 do
      ComposeObservationTriggeredBy(xml, 'triggeredBy', value.triggeredByList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.partOfList.Count - 1 do
      ComposeReference(xml, 'partOf', value.partOfList[i]);
  ComposeEnum(xml, 'status', value.statusElement, CODES_TFhirObservationStatusEnum);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.categoryList.Count - 1 do
      ComposeCodeableConcept(xml, 'category', value.categoryList[i]);
  ComposeCodeableConcept(xml, 'code', value.code);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference(xml, 'subject', value.subject);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.focusList.Count - 1 do
      ComposeReference(xml, 'focus', value.focusList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference(xml, 'encounter', value.encounter);
  if (SummaryOption in [soFull, soSummary, soData]) and (value.effective is TFhirPeriod) {6} then
    ComposePeriod(xml, 'effectivePeriod', TFhirPeriod(value.effective))
  else if (SummaryOption in [soFull, soSummary, soData]) and (value.effective is TFhirTiming) {6} then
    ComposeTiming(xml, 'effectiveTiming', TFhirTiming(value.effective))
  else if (SummaryOption in [soFull, soSummary, soData]) and (value.effective is TFhirDateTime) {6} then
    ComposeDateTime(xml, 'effectiveDateTime', TFhirDateTime(value.effective))
  else if (SummaryOption in [soFull, soSummary, soData]) and (value.effective is TFhirInstant) {6} then
    ComposeInstant(xml, 'effectiveInstant', TFhirInstant(value.effective));
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeInstant(xml, 'issued', value.issuedElement);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.performerList.Count - 1 do
      ComposeReference(xml, 'performer', value.performerList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) and (value.value is TFhirQuantity) {6} then
    ComposeQuantity(xml, 'valueQuantity', TFhirQuantity(value.value))
  else if (SummaryOption in [soFull, soSummary, soData]) and (value.value is TFhirCodeableConcept) {6} then
    ComposeCodeableConcept(xml, 'valueCodeableConcept', TFhirCodeableConcept(value.value))
  else if (SummaryOption in [soFull, soSummary, soData]) and (value.value is TFhirRange) {6} then
    ComposeRange(xml, 'valueRange', TFhirRange(value.value))
  else if (SummaryOption in [soFull, soSummary, soData]) and (value.value is TFhirRatio) {6} then
    ComposeRatio(xml, 'valueRatio', TFhirRatio(value.value))
  else if (SummaryOption in [soFull, soSummary, soData]) and (value.value is TFhirSampledData) {6} then
    ComposeSampledData(xml, 'valueSampledData', TFhirSampledData(value.value))
  else if (SummaryOption in [soFull, soSummary, soData]) and (value.value is TFhirPeriod) {6} then
    ComposePeriod(xml, 'valuePeriod', TFhirPeriod(value.value))
  else if (SummaryOption in [soFull, soSummary, soData]) and (value.value is TFhirAttachment) {6} then
    ComposeAttachment(xml, 'valueAttachment', TFhirAttachment(value.value))
  else if (SummaryOption in [soFull, soSummary, soData]) and (value.value is TFhirString) {6} then
    ComposeString(xml, 'valueString', TFhirString(value.value))
  else if (SummaryOption in [soFull, soSummary, soData]) and (value.value is TFhirBoolean) {6} then
    ComposeBoolean(xml, 'valueBoolean', TFhirBoolean(value.value))
  else if (SummaryOption in [soFull, soSummary, soData]) and (value.value is TFhirInteger) {6} then
    ComposeInteger(xml, 'valueInteger', TFhirInteger(value.value))
  else if (SummaryOption in [soFull, soSummary, soData]) and (value.value is TFhirTime) {6} then
    ComposeTime(xml, 'valueTime', TFhirTime(value.value))
  else if (SummaryOption in [soFull, soSummary, soData]) and (value.value is TFhirDateTime) {6} then
    ComposeDateTime(xml, 'valueDateTime', TFhirDateTime(value.value));
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(xml, 'dataAbsentReason', value.dataAbsentReason);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.interpretationList.Count - 1 do
      ComposeCodeableConcept(xml, 'interpretation', value.interpretationList[i]);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.noteList.Count - 1 do
      ComposeAnnotation(xml, 'note', value.noteList[i]);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(xml, 'bodySite', value.bodySite);
  if (SummaryOption in [soFull, soData]) then
    ComposeReference(xml, 'bodyStructure', value.bodyStructure);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(xml, 'method', value.method);
  if (SummaryOption in [soFull, soData]) then
    ComposeReference(xml, 'specimen', value.specimen);
  if (SummaryOption in [soFull, soData]) then
    ComposeReference(xml, 'device', value.device);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.referenceRangeList.Count - 1 do
      ComposeObservationReferenceRange(xml, 'referenceRange', value.referenceRangeList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.hasMemberList.Count - 1 do
      ComposeReference(xml, 'hasMember', value.hasMemberList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.derivedFromList.Count - 1 do
      ComposeReference(xml, 'derivedFrom', value.derivedFromList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.componentList.Count - 1 do
      ComposeObservationComponent(xml, 'component', value.componentList[i]);
end;

{$ENDIF FHIR_OBSERVATION}
{$IFDEF FHIR_OBSERVATIONDEFINITION}
function TFHIRXmlParser.ParseObservationDefinitionQuantitativeDetails(element : TMXmlElement; path : string) : TFhirObservationDefinitionQuantitativeDetails;
var
  child : TMXmlElement;
begin
  result := TFhirObservationDefinitionQuantitativeDetails.Create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseObservationDefinitionQuantitativeDetailsChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseObservationDefinitionQuantitativeDetailsChild(value : TFhirObservationDefinitionQuantitativeDetails; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'unit') then
        value.unit_ := ParseCodeableConcept(child, path+'/unit')
      else if (child.localName = 'customaryUnit') then
        value.customaryUnit := ParseCodeableConcept(child, path+'/customaryUnit')
      else if (child.localName = 'conversionFactor') then
        value.conversionFactorElement := ParseDecimal(child, path+'/conversionFactor')
      else if (child.localName = 'decimalPrecision') then
        value.decimalPrecisionElement := ParseInteger(child, path+'/decimalPrecision')
      else if Not ParseBackboneElementChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeObservationDefinitionQuantitativeDetails(xml : TXmlBuilder; name : String; value : TFhirObservationDefinitionQuantitativeDetails);
begin
  if (value = nil) then
    exit;
  composeElementAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeObservationDefinitionQuantitativeDetailsChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeObservationDefinitionQuantitativeDetailsChildren(xml : TXmlBuilder; value : TFhirObservationDefinitionQuantitativeDetails);
begin
  composeBackboneElementChildren(xml, value);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(xml, 'unit', value.unit_);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(xml, 'customaryUnit', value.customaryUnit);
  if (SummaryOption in [soFull, soData]) then
    ComposeDecimal(xml, 'conversionFactor', value.conversionFactorElement);
  if (SummaryOption in [soFull, soData]) then
    ComposeInteger(xml, 'decimalPrecision', value.decimalPrecisionElement);
end;

function TFHIRXmlParser.ParseObservationDefinitionQualifiedValue(element : TMXmlElement; path : string) : TFhirObservationDefinitionQualifiedValue;
var
  child : TMXmlElement;
begin
  result := TFhirObservationDefinitionQualifiedValue.Create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseObservationDefinitionQualifiedValueChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseObservationDefinitionQualifiedValueChild(value : TFhirObservationDefinitionQualifiedValue; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'context') then
        value.context := ParseCodeableConcept(child, path+'/context')
      else if (child.localName = 'appliesTo') then
        value.appliesToList.Add(ParseCodeableConcept(child, path+'/appliesTo'))
      else if (child.localName = 'gender') then
        value.genderElement := ParseEnum(CODES_TFhirAdministrativeGenderEnum, SYSTEMS_TFhirAdministrativeGenderEnum, child, path+'/gender')
      else if (child.localName = 'age') then
        value.age := ParseRange(child, path+'/age')
      else if (child.localName = 'gestationalAge') then
        value.gestationalAge := ParseRange(child, path+'/gestationalAge')
      else if (child.localName = 'condition') then
        value.conditionElement := ParseString(child, path+'/condition')
      else if (child.localName = 'rangeCategory') then
        value.rangeCategoryElement := ParseEnum(CODES_TFhirObservationRangeCategoryEnum, SYSTEMS_TFhirObservationRangeCategoryEnum, child, path+'/rangeCategory')
      else if (child.localName = 'range') then
        value.range := ParseRange(child, path+'/range')
      else if (child.localName = 'validCodedValueSet') then
        value.validCodedValueSetElement := ParseCanonical(child, path+'/validCodedValueSet')
      else if (child.localName = 'normalCodedValueSet') then
        value.normalCodedValueSetElement := ParseCanonical(child, path+'/normalCodedValueSet')
      else if (child.localName = 'abnormalCodedValueSet') then
        value.abnormalCodedValueSetElement := ParseCanonical(child, path+'/abnormalCodedValueSet')
      else if (child.localName = 'criticalCodedValueSet') then
        value.criticalCodedValueSetElement := ParseCanonical(child, path+'/criticalCodedValueSet')
      else if Not ParseBackboneElementChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeObservationDefinitionQualifiedValue(xml : TXmlBuilder; name : String; value : TFhirObservationDefinitionQualifiedValue);
begin
  if (value = nil) then
    exit;
  composeElementAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeObservationDefinitionQualifiedValueChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeObservationDefinitionQualifiedValueChildren(xml : TXmlBuilder; value : TFhirObservationDefinitionQualifiedValue);
var
  i : integer;
begin
  composeBackboneElementChildren(xml, value);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(xml, 'context', value.context);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.appliesToList.Count - 1 do
      ComposeCodeableConcept(xml, 'appliesTo', value.appliesToList[i]);
  if (SummaryOption in [soFull, soData]) then
    ComposeEnum(xml, 'gender', value.genderElement, CODES_TFhirAdministrativeGenderEnum);
  if (SummaryOption in [soFull, soData]) then
    ComposeRange(xml, 'age', value.age);
  if (SummaryOption in [soFull, soData]) then
    ComposeRange(xml, 'gestationalAge', value.gestationalAge);
  if (SummaryOption in [soFull, soData]) then
    ComposeString(xml, 'condition', value.conditionElement);
  if (SummaryOption in [soFull, soData]) then
    ComposeEnum(xml, 'rangeCategory', value.rangeCategoryElement, CODES_TFhirObservationRangeCategoryEnum);
  if (SummaryOption in [soFull, soData]) then
    ComposeRange(xml, 'range', value.range);
  if (SummaryOption in [soFull, soData]) then
    ComposeCanonical(xml, 'validCodedValueSet', value.validCodedValueSetElement);
  if (SummaryOption in [soFull, soData]) then
    ComposeCanonical(xml, 'normalCodedValueSet', value.normalCodedValueSetElement);
  if (SummaryOption in [soFull, soData]) then
    ComposeCanonical(xml, 'abnormalCodedValueSet', value.abnormalCodedValueSetElement);
  if (SummaryOption in [soFull, soData]) then
    ComposeCanonical(xml, 'criticalCodedValueSet', value.criticalCodedValueSetElement);
end;

function TFHIRXmlParser.ParseObservationDefinitionComponent(element : TMXmlElement; path : string) : TFhirObservationDefinitionComponent;
var
  child : TMXmlElement;
begin
  result := TFhirObservationDefinitionComponent.Create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseObservationDefinitionComponentChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseObservationDefinitionComponentChild(value : TFhirObservationDefinitionComponent; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'code') then
        value.code := ParseCodeableConcept(child, path+'/code')
      else if (child.localName = 'permittedDataType') then
        value.permittedDataTypeList.Add(ParseEnum(CODES_TFhirObservationDataTypeEnum, SYSTEMS_TFhirObservationDataTypeEnum, child, path+'/permittedDataType')){y.1}
      else if (child.localName = 'quantitativeDetails') then
        value.quantitativeDetails := ParseObservationDefinitionQuantitativeDetails(child, path+'/quantitativeDetails')
      else if (child.localName = 'qualifiedValue') then
        value.qualifiedValueList.Add(ParseObservationDefinitionQualifiedValue(child, path+'/qualifiedValue'))
      else if Not ParseBackboneElementChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeObservationDefinitionComponent(xml : TXmlBuilder; name : String; value : TFhirObservationDefinitionComponent);
begin
  if (value = nil) then
    exit;
  composeElementAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeObservationDefinitionComponentChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeObservationDefinitionComponentChildren(xml : TXmlBuilder; value : TFhirObservationDefinitionComponent);
var
  i : integer;
begin
  composeBackboneElementChildren(xml, value);
  ComposeCodeableConcept(xml, 'code', value.code);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.permittedDataTypeList.Count - 1 do
      ComposeEnum(xml, 'permittedDataType', value.permittedDataTypeList[i], CODES_TFhirObservationDataTypeEnum);
  if (SummaryOption in [soFull, soData]) then
    ComposeObservationDefinitionQuantitativeDetails(xml, 'quantitativeDetails', value.quantitativeDetails);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.qualifiedValueList.Count - 1 do
      ComposeObservationDefinitionQualifiedValue(xml, 'qualifiedValue', value.qualifiedValueList[i]);
end;

function TFHIRXmlParser.ParseObservationDefinition(element : TMXmlElement; path : string) : TFhirObservationDefinition;
var
  child : TMXmlElement;
begin
  result := TFhirObservationDefinition.Create;
  try
    parseMetadataResourceAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseObservationDefinitionChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseObservationDefinitionChild(value : TFhirObservationDefinition; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'url') then
        value.urlElement := ParseUri(child, path+'/url')
      else if (child.localName = 'identifier') then
        value.identifier := ParseIdentifier(child, path+'/identifier')
      else if (child.localName = 'version') then
        value.versionElement := ParseString(child, path+'/version')
      else if (child.localName = 'name') then
        value.nameElement := ParseString(child, path+'/name')
      else if (child.localName = 'title') then
        value.titleElement := ParseString(child, path+'/title')
      else if (child.localName = 'status') then
        value.statusElement := ParseEnum(CODES_TFhirPublicationStatusEnum, SYSTEMS_TFhirPublicationStatusEnum, child, path+'/status')
      else if (child.localName = 'experimental') then
        value.experimentalElement := ParseBoolean(child, path+'/experimental')
      else if (child.localName = 'date') then
        value.dateElement := ParseDateTime(child, path+'/date')
      else if (child.localName = 'publisher') then
        value.publisher := ParseString(child, path+'/publisher')
      else if (child.localName = 'contact') then
        value.contactList.Add(ParseContactDetail(child, path+'/contact'))
      else if (child.localName = 'description') then
        value.descriptionElement := ParseMarkdown(child, path+'/description')
      else if (child.localName = 'useContext') then
        value.useContextList.Add(ParseUsageContext(child, path+'/useContext'))
      else if (child.localName = 'jurisdiction') then
        value.jurisdictionList.Add(ParseCodeableConcept(child, path+'/jurisdiction'))
      else if (child.localName = 'purpose') then
        value.purposeElement := ParseMarkdown(child, path+'/purpose')
      else if (child.localName = 'copyright') then
        value.copyrightElement := ParseMarkdown(child, path+'/copyright')
      else if (child.localName = 'approvalDate') then
        value.approvalDateElement := ParseDate(child, path+'/approvalDate')
      else if (child.localName = 'lastReviewDate') then
        value.lastReviewDateElement := ParseDate(child, path+'/lastReviewDate')
      else if (child.localName = 'effectivePeriod') then
        value.effectivePeriod := ParsePeriod(child, path+'/effectivePeriod')
      else if (child.localName = 'derivedFromCanonical') then
        value.derivedFromCanonicalList.Add(ParseCanonical(child, path+'/derivedFromCanonical'))
      else if (child.localName = 'derivedFromUri') then
        value.derivedFromUriList.Add(ParseUri(child, path+'/derivedFromUri'))
      else if (child.localName = 'subject') then
        value.subjectList.Add(ParseCodeableConcept(child, path+'/subject'))
      else if (child.localName = 'performerType') then
        value.performerType := ParseCodeableConcept(child, path+'/performerType')
      else if (child.localName = 'category') then
        value.categoryList.Add(ParseCodeableConcept(child, path+'/category'))
      else if (child.localName = 'code') then
        value.code := ParseCodeableConcept(child, path+'/code')
      else if (child.localName = 'permittedDataType') then
        value.permittedDataTypeList.Add(ParseEnum(CODES_TFhirObservationDataTypeEnum, SYSTEMS_TFhirObservationDataTypeEnum, child, path+'/permittedDataType')){y.1}
      else if (child.localName = 'multipleResultsAllowed') then
        value.multipleResultsAllowedElement := ParseBoolean(child, path+'/multipleResultsAllowed')
      else if (child.localName = 'bodySite') then
        value.bodySite := ParseCodeableConcept(child, path+'/bodySite')
      else if (child.localName = 'method') then
        value.method := ParseCodeableConcept(child, path+'/method')
      else if (child.localName = 'specimen') then
        value.specimenList.Add(ParseReference(child, path+'/specimen'))
      else if (child.localName = 'device') then
        value.deviceList.Add(ParseReference(child, path+'/device'))
      else if (child.localName = 'preferredReportName') then
        value.preferredReportNameElement := ParseString(child, path+'/preferredReportName')
      else if (child.localName = 'quantitativeDetails') then
        value.quantitativeDetails := ParseObservationDefinitionQuantitativeDetails(child, path+'/quantitativeDetails')
      else if (child.localName = 'qualifiedValue') then
        value.qualifiedValueList.Add(ParseObservationDefinitionQualifiedValue(child, path+'/qualifiedValue'))
      else if (child.localName = 'hasMember') then
        value.hasMemberList.Add(ParseReference(child, path+'/hasMember'))
      else if (child.localName = 'component') then
        value.componentList.Add(ParseObservationDefinitionComponent(child, path+'/component'))
      else if Not ParseMetadataResourceChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeObservationDefinition(xml : TXmlBuilder; name : String; value : TFhirObservationDefinition);
begin
  if (value = nil) then
    exit;
  composeMetadataResourceAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeObservationDefinitionChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeObservationDefinitionChildren(xml : TXmlBuilder; value : TFhirObservationDefinition);
var
  i : integer;
begin
  composeMetadataResourceChildren(xml, value);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeUri(xml, 'url', value.urlElement);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeIdentifier(xml, 'identifier', value.identifier);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(xml, 'version', value.versionElement);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(xml, 'name', value.nameElement);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(xml, 'title', value.titleElement);
  ComposeEnum(xml, 'status', value.statusElement, CODES_TFhirPublicationStatusEnum);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeBoolean(xml, 'experimental', value.experimentalElement);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDateTime(xml, 'date', value.dateElement);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(xml, 'publisher', value.publisher);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.contactList.Count - 1 do
      ComposeContactDetail(xml, 'contact', value.contactList[i]);
  if (SummaryOption in [soFull, soData]) then
    ComposeMarkdown(xml, 'description', value.descriptionElement);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.useContextList.Count - 1 do
      ComposeUsageContext(xml, 'useContext', value.useContextList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.jurisdictionList.Count - 1 do
      ComposeCodeableConcept(xml, 'jurisdiction', value.jurisdictionList[i]);
  if (SummaryOption in [soFull, soData]) then
    ComposeMarkdown(xml, 'purpose', value.purposeElement);
  if (SummaryOption in [soFull, soData]) then
    ComposeMarkdown(xml, 'copyright', value.copyrightElement);
  if (SummaryOption in [soFull, soData]) then
    ComposeDate(xml, 'approvalDate', value.approvalDateElement);
  if (SummaryOption in [soFull, soData]) then
    ComposeDate(xml, 'lastReviewDate', value.lastReviewDateElement);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposePeriod(xml, 'effectivePeriod', value.effectivePeriod);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.derivedFromCanonicalList.Count - 1 do
      ComposeCanonical(xml, 'derivedFromCanonical', value.derivedFromCanonicalList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.derivedFromUriList.Count - 1 do
      ComposeUri(xml, 'derivedFromUri', value.derivedFromUriList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.subjectList.Count - 1 do
      ComposeCodeableConcept(xml, 'subject', value.subjectList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(xml, 'performerType', value.performerType);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.categoryList.Count - 1 do
      ComposeCodeableConcept(xml, 'category', value.categoryList[i]);
  ComposeCodeableConcept(xml, 'code', value.code);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.permittedDataTypeList.Count - 1 do
      ComposeEnum(xml, 'permittedDataType', value.permittedDataTypeList[i], CODES_TFhirObservationDataTypeEnum);
  if (SummaryOption in [soFull, soData]) then
    ComposeBoolean(xml, 'multipleResultsAllowed', value.multipleResultsAllowedElement);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(xml, 'bodySite', value.bodySite);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(xml, 'method', value.method);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.specimenList.Count - 1 do
      ComposeReference(xml, 'specimen', value.specimenList[i]);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.deviceList.Count - 1 do
      ComposeReference(xml, 'device', value.deviceList[i]);
  if (SummaryOption in [soFull, soData]) then
    ComposeString(xml, 'preferredReportName', value.preferredReportNameElement);
  if (SummaryOption in [soFull, soData]) then
    ComposeObservationDefinitionQuantitativeDetails(xml, 'quantitativeDetails', value.quantitativeDetails);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.qualifiedValueList.Count - 1 do
      ComposeObservationDefinitionQualifiedValue(xml, 'qualifiedValue', value.qualifiedValueList[i]);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.hasMemberList.Count - 1 do
      ComposeReference(xml, 'hasMember', value.hasMemberList[i]);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.componentList.Count - 1 do
      ComposeObservationDefinitionComponent(xml, 'component', value.componentList[i]);
end;

{$ENDIF FHIR_OBSERVATIONDEFINITION}
{$IFDEF FHIR_OPERATIONDEFINITION}
function TFHIRXmlParser.ParseOperationDefinitionParameter(element : TMXmlElement; path : string) : TFhirOperationDefinitionParameter;
var
  child : TMXmlElement;
begin
  result := TFhirOperationDefinitionParameter.Create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseOperationDefinitionParameterChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseOperationDefinitionParameterChild(value : TFhirOperationDefinitionParameter; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'name') then
        value.nameElement := ParseCode(child, path+'/name')
      else if (child.localName = 'use') then
        value.useElement := ParseEnum(CODES_TFhirOperationParameterUseEnum, SYSTEMS_TFhirOperationParameterUseEnum, child, path+'/use')
      else if (child.localName = 'scope') then
        value.scopeList.Add(ParseEnum(CODES_TFhirOperationParameterScopeEnum, SYSTEMS_TFhirOperationParameterScopeEnum, child, path+'/scope')){y.1}
      else if (child.localName = 'min') then
        value.minElement := ParseInteger(child, path+'/min')
      else if (child.localName = 'max') then
        value.maxElement := ParseString(child, path+'/max')
      else if (child.localName = 'documentation') then
        value.documentationElement := ParseMarkdown(child, path+'/documentation')
      else if (child.localName = 'type') then
        value.type_Element := ParseEnum(CODES_TFhirFHIRTypesEnum, SYSTEMS_TFhirFHIRTypesEnum, child, path+'/type')
      else if (child.localName = 'allowedType') then
        value.allowedType.Add(ParseEnum(CODES_TFhirFHIRTypesEnum, SYSTEMS_TFhirFHIRTypesEnum, child, path+'/allowedType')){y.1}
      else if (child.localName = 'targetProfile') then
        value.targetProfileList.Add(ParseCanonical(child, path+'/targetProfile'))
      else if (child.localName = 'searchType') then
        value.searchTypeElement := ParseEnum(CODES_TFhirSearchParamTypeEnum, SYSTEMS_TFhirSearchParamTypeEnum, child, path+'/searchType')
      else if (child.localName = 'binding') then
        value.binding := ParseOperationDefinitionParameterBinding(child, path+'/binding')
      else if (child.localName = 'referencedFrom') then
        value.referencedFromList.Add(ParseOperationDefinitionParameterReferencedFrom(child, path+'/referencedFrom'))
      else if (child.localName = 'part') then
        value.partList.Add(ParseOperationDefinitionParameter(child, path+'/part'))
      else if Not ParseBackboneElementChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeOperationDefinitionParameter(xml : TXmlBuilder; name : String; value : TFhirOperationDefinitionParameter);
begin
  if (value = nil) then
    exit;
  composeElementAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeOperationDefinitionParameterChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeOperationDefinitionParameterChildren(xml : TXmlBuilder; value : TFhirOperationDefinitionParameter);
var
  i : integer;
begin
  composeBackboneElementChildren(xml, value);
  ComposeCode(xml, 'name', value.nameElement);
  ComposeEnum(xml, 'use', value.useElement, CODES_TFhirOperationParameterUseEnum);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.scopeList.Count - 1 do
      ComposeEnum(xml, 'scope', value.scopeList[i], CODES_TFhirOperationParameterScopeEnum);
  ComposeInteger(xml, 'min', value.minElement);
  ComposeString(xml, 'max', value.maxElement);
  if (SummaryOption in [soFull, soData]) then
    ComposeMarkdown(xml, 'documentation', value.documentationElement);
  if (SummaryOption in [soFull, soData]) then
    ComposeEnum(xml, 'type', value.type_Element, CODES_TFhirFHIRTypesEnum);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.allowedType.Count - 1 do
      ComposeEnum(xml, 'allowedType', value.allowedType[i], CODES_TFhirFHIRTypesEnum);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.targetProfileList.Count - 1 do
      ComposeCanonical(xml, 'targetProfile', value.targetProfileList[i]);
  if (SummaryOption in [soFull, soData]) then
    ComposeEnum(xml, 'searchType', value.searchTypeElement, CODES_TFhirSearchParamTypeEnum);
  if (SummaryOption in [soFull, soData]) then
    ComposeOperationDefinitionParameterBinding(xml, 'binding', value.binding);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.referencedFromList.Count - 1 do
      ComposeOperationDefinitionParameterReferencedFrom(xml, 'referencedFrom', value.referencedFromList[i]);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.partList.Count - 1 do
      ComposeOperationDefinitionParameter(xml, 'part', value.partList[i]);
end;

function TFHIRXmlParser.ParseOperationDefinitionParameterBinding(element : TMXmlElement; path : string) : TFhirOperationDefinitionParameterBinding;
var
  child : TMXmlElement;
begin
  result := TFhirOperationDefinitionParameterBinding.Create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseOperationDefinitionParameterBindingChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseOperationDefinitionParameterBindingChild(value : TFhirOperationDefinitionParameterBinding; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'strength') then
        value.strengthElement := ParseEnum(CODES_TFhirBindingStrengthEnum, SYSTEMS_TFhirBindingStrengthEnum, child, path+'/strength')
      else if (child.localName = 'valueSet') then
        value.valueSetElement := ParseCanonical(child, path+'/valueSet')
      else if Not ParseBackboneElementChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeOperationDefinitionParameterBinding(xml : TXmlBuilder; name : String; value : TFhirOperationDefinitionParameterBinding);
begin
  if (value = nil) then
    exit;
  composeElementAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeOperationDefinitionParameterBindingChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeOperationDefinitionParameterBindingChildren(xml : TXmlBuilder; value : TFhirOperationDefinitionParameterBinding);
begin
  composeBackboneElementChildren(xml, value);
  ComposeEnum(xml, 'strength', value.strengthElement, CODES_TFhirBindingStrengthEnum);
  ComposeCanonical(xml, 'valueSet', value.valueSetElement);
end;

function TFHIRXmlParser.ParseOperationDefinitionParameterReferencedFrom(element : TMXmlElement; path : string) : TFhirOperationDefinitionParameterReferencedFrom;
var
  child : TMXmlElement;
begin
  result := TFhirOperationDefinitionParameterReferencedFrom.Create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseOperationDefinitionParameterReferencedFromChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseOperationDefinitionParameterReferencedFromChild(value : TFhirOperationDefinitionParameterReferencedFrom; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'source') then
        value.sourceElement := ParseString(child, path+'/source')
      else if (child.localName = 'sourceId') then
        value.sourceIdElement := ParseString(child, path+'/sourceId')
      else if Not ParseBackboneElementChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeOperationDefinitionParameterReferencedFrom(xml : TXmlBuilder; name : String; value : TFhirOperationDefinitionParameterReferencedFrom);
begin
  if (value = nil) then
    exit;
  composeElementAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeOperationDefinitionParameterReferencedFromChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeOperationDefinitionParameterReferencedFromChildren(xml : TXmlBuilder; value : TFhirOperationDefinitionParameterReferencedFrom);
begin
  composeBackboneElementChildren(xml, value);
  ComposeString(xml, 'source', value.sourceElement);
  if (SummaryOption in [soFull, soData]) then
    ComposeString(xml, 'sourceId', value.sourceIdElement);
end;

function TFHIRXmlParser.ParseOperationDefinitionOverload(element : TMXmlElement; path : string) : TFhirOperationDefinitionOverload;
var
  child : TMXmlElement;
begin
  result := TFhirOperationDefinitionOverload.Create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseOperationDefinitionOverloadChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseOperationDefinitionOverloadChild(value : TFhirOperationDefinitionOverload; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'parameterName') then
        value.parameterNameList.Add(ParseString(child, path+'/parameterName'))
      else if (child.localName = 'comment') then
        value.commentElement := ParseString(child, path+'/comment')
      else if Not ParseBackboneElementChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeOperationDefinitionOverload(xml : TXmlBuilder; name : String; value : TFhirOperationDefinitionOverload);
begin
  if (value = nil) then
    exit;
  composeElementAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeOperationDefinitionOverloadChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeOperationDefinitionOverloadChildren(xml : TXmlBuilder; value : TFhirOperationDefinitionOverload);
var
  i : integer;
begin
  composeBackboneElementChildren(xml, value);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.parameterNameList.Count - 1 do
      ComposeString(xml, 'parameterName', value.parameterNameList[i]);
  if (SummaryOption in [soFull, soData]) then
    ComposeString(xml, 'comment', value.commentElement);
end;

function TFHIRXmlParser.ParseOperationDefinition(element : TMXmlElement; path : string) : TFhirOperationDefinition;
var
  child : TMXmlElement;
begin
  result := TFhirOperationDefinition.Create;
  try
    parseCanonicalResourceAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseOperationDefinitionChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseOperationDefinitionChild(value : TFhirOperationDefinition; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'url') then
        value.urlElement := ParseUri(child, path+'/url')
      else if (child.localName = 'version') then
        value.versionElement := ParseString(child, path+'/version')
      else if (child.localName = 'versionAlgorithmCoding') then
        value.versionAlgorithm := ParseCoding(child, path+'/versionAlgorithmCoding')
      else if (child.localName = 'versionAlgorithmString') then
        value.versionAlgorithm := ParseString(child, path+'/versionAlgorithmString')
      else if (child.localName = 'name') then
        value.nameElement := ParseString(child, path+'/name')
      else if (child.localName = 'title') then
        value.titleElement := ParseString(child, path+'/title')
      else if (child.localName = 'status') then
        value.statusElement := ParseEnum(CODES_TFhirPublicationStatusEnum, SYSTEMS_TFhirPublicationStatusEnum, child, path+'/status')
      else if (child.localName = 'kind') then
        value.kindElement := ParseEnum(CODES_TFhirOperationKindEnum, SYSTEMS_TFhirOperationKindEnum, child, path+'/kind')
      else if (child.localName = 'experimental') then
        value.experimentalElement := ParseBoolean(child, path+'/experimental')
      else if (child.localName = 'date') then
        value.dateElement := ParseDateTime(child, path+'/date')
      else if (child.localName = 'publisher') then
        value.publisherElement := ParseString(child, path+'/publisher')
      else if (child.localName = 'contact') then
        value.contactList.Add(ParseContactDetail(child, path+'/contact'))
      else if (child.localName = 'description') then
        value.descriptionElement := ParseMarkdown(child, path+'/description')
      else if (child.localName = 'useContext') then
        value.useContextList.Add(ParseUsageContext(child, path+'/useContext'))
      else if (child.localName = 'jurisdiction') then
        value.jurisdictionList.Add(ParseCodeableConcept(child, path+'/jurisdiction'))
      else if (child.localName = 'purpose') then
        value.purposeElement := ParseMarkdown(child, path+'/purpose')
      else if (child.localName = 'copyright') then
        value.copyrightElement := ParseMarkdown(child, path+'/copyright')
      else if (child.localName = 'copyrightLabel') then
        value.copyrightLabelElement := ParseString(child, path+'/copyrightLabel')
      else if (child.localName = 'affectsState') then
        value.affectsStateElement := ParseBoolean(child, path+'/affectsState')
      else if (child.localName = 'code') then
        value.codeElement := ParseCode(child, path+'/code')
      else if (child.localName = 'comment') then
        value.commentElement := ParseMarkdown(child, path+'/comment')
      else if (child.localName = 'base') then
        value.baseElement := ParseCanonical(child, path+'/base')
      else if (child.localName = 'resource') then
        value.resource.Add(ParseEnum(CODES_TFhirResourceTypesEnum, SYSTEMS_TFhirResourceTypesEnum, child, path+'/resource')){y.1}
      else if (child.localName = 'system') then
        value.systemElement := ParseBoolean(child, path+'/system')
      else if (child.localName = 'type') then
        value.type_Element := ParseBoolean(child, path+'/type')
      else if (child.localName = 'instance') then
        value.instanceElement := ParseBoolean(child, path+'/instance')
      else if (child.localName = 'inputProfile') then
        value.inputProfileElement := ParseCanonical(child, path+'/inputProfile')
      else if (child.localName = 'outputProfile') then
        value.outputProfileElement := ParseCanonical(child, path+'/outputProfile')
      else if (child.localName = 'parameter') then
        value.parameterList.Add(ParseOperationDefinitionParameter(child, path+'/parameter'))
      else if (child.localName = 'overload') then
        value.overloadList.Add(ParseOperationDefinitionOverload(child, path+'/overload'))
      else if Not ParseCanonicalResourceChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeOperationDefinition(xml : TXmlBuilder; name : String; value : TFhirOperationDefinition);
begin
  if (value = nil) then
    exit;
  composeCanonicalResourceAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeOperationDefinitionChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeOperationDefinitionChildren(xml : TXmlBuilder; value : TFhirOperationDefinition);
var
  i : integer;
begin
  composeCanonicalResourceChildren(xml, value);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeUri(xml, 'url', value.urlElement);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(xml, 'version', value.versionElement);
  if (SummaryOption in [soFull, soSummary, soData]) and (value.versionAlgorithm is TFhirCoding) {6} then
    ComposeCoding(xml, 'versionAlgorithmCoding', TFhirCoding(value.versionAlgorithm))
  else if (SummaryOption in [soFull, soSummary, soData]) and (value.versionAlgorithm is TFhirString) {6} then
    ComposeString(xml, 'versionAlgorithmString', TFhirString(value.versionAlgorithm));
  ComposeString(xml, 'name', value.nameElement);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(xml, 'title', value.titleElement);
  ComposeEnum(xml, 'status', value.statusElement, CODES_TFhirPublicationStatusEnum);
  ComposeEnum(xml, 'kind', value.kindElement, CODES_TFhirOperationKindEnum);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeBoolean(xml, 'experimental', value.experimentalElement);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDateTime(xml, 'date', value.dateElement);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(xml, 'publisher', value.publisherElement);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.contactList.Count - 1 do
      ComposeContactDetail(xml, 'contact', value.contactList[i]);
  if (SummaryOption in [soFull, soData]) then
    ComposeMarkdown(xml, 'description', value.descriptionElement);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.useContextList.Count - 1 do
      ComposeUsageContext(xml, 'useContext', value.useContextList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.jurisdictionList.Count - 1 do
      ComposeCodeableConcept(xml, 'jurisdiction', value.jurisdictionList[i]);
  if (SummaryOption in [soFull, soData]) then
    ComposeMarkdown(xml, 'purpose', value.purposeElement);
  if (SummaryOption in [soFull, soData]) then
    ComposeMarkdown(xml, 'copyright', value.copyrightElement);
  if (SummaryOption in [soFull, soData]) then
    ComposeString(xml, 'copyrightLabel', value.copyrightLabelElement);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeBoolean(xml, 'affectsState', value.affectsStateElement);
  ComposeCode(xml, 'code', value.codeElement);
  if (SummaryOption in [soFull, soData]) then
    ComposeMarkdown(xml, 'comment', value.commentElement);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCanonical(xml, 'base', value.baseElement);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.resource.Count - 1 do
      ComposeEnum(xml, 'resource', value.resource[i], CODES_TFhirResourceTypesEnum);
  ComposeBoolean(xml, 'system', value.systemElement);
  ComposeBoolean(xml, 'type', value.type_Element);
  ComposeBoolean(xml, 'instance', value.instanceElement);
  if (SummaryOption in [soFull, soData]) then
    ComposeCanonical(xml, 'inputProfile', value.inputProfileElement);
  if (SummaryOption in [soFull, soData]) then
    ComposeCanonical(xml, 'outputProfile', value.outputProfileElement);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.parameterList.Count - 1 do
      ComposeOperationDefinitionParameter(xml, 'parameter', value.parameterList[i]);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.overloadList.Count - 1 do
      ComposeOperationDefinitionOverload(xml, 'overload', value.overloadList[i]);
end;

{$ENDIF FHIR_OPERATIONDEFINITION}
{$IFDEF FHIR_OPERATIONOUTCOME}
function TFHIRXmlParser.ParseOperationOutcomeIssue(element : TMXmlElement; path : string) : TFhirOperationOutcomeIssue;
var
  child : TMXmlElement;
begin
  result := TFhirOperationOutcomeIssue.Create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseOperationOutcomeIssueChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseOperationOutcomeIssueChild(value : TFhirOperationOutcomeIssue; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'severity') then
        value.severityElement := ParseEnum(CODES_TFhirIssueSeverityEnum, SYSTEMS_TFhirIssueSeverityEnum, child, path+'/severity')
      else if (child.localName = 'code') then
        value.codeElement := ParseEnum(CODES_TFhirIssueTypeEnum, SYSTEMS_TFhirIssueTypeEnum, child, path+'/code')
      else if (child.localName = 'details') then
        value.details := ParseCodeableConcept(child, path+'/details')
      else if (child.localName = 'diagnostics') then
        value.diagnosticsElement := ParseString(child, path+'/diagnostics')
      else if (child.localName = 'location') then
        value.locationList.Add(ParseString(child, path+'/location'))
      else if (child.localName = 'expression') then
        value.expressionList.Add(ParseString(child, path+'/expression'))
      else if Not ParseBackboneElementChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeOperationOutcomeIssue(xml : TXmlBuilder; name : String; value : TFhirOperationOutcomeIssue);
begin
  if (value = nil) then
    exit;
  composeElementAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeOperationOutcomeIssueChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeOperationOutcomeIssueChildren(xml : TXmlBuilder; value : TFhirOperationOutcomeIssue);
var
  i : integer;
begin
  composeBackboneElementChildren(xml, value);
  ComposeEnum(xml, 'severity', value.severityElement, CODES_TFhirIssueSeverityEnum);
  ComposeEnum(xml, 'code', value.codeElement, CODES_TFhirIssueTypeEnum);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(xml, 'details', value.details);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(xml, 'diagnostics', value.diagnosticsElement);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.locationList.Count - 1 do
      ComposeString(xml, 'location', value.locationList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.expressionList.Count - 1 do
      ComposeString(xml, 'expression', value.expressionList[i]);
end;

function TFHIRXmlParser.ParseOperationOutcome(element : TMXmlElement; path : string) : TFhirOperationOutcome;
var
  child : TMXmlElement;
begin
  result := TFhirOperationOutcome.Create;
  try
    parseDomainResourceAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseOperationOutcomeChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseOperationOutcomeChild(value : TFhirOperationOutcome; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'issue') then
        value.issueList.Add(ParseOperationOutcomeIssue(child, path+'/issue'))
      else if Not ParseDomainResourceChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeOperationOutcome(xml : TXmlBuilder; name : String; value : TFhirOperationOutcome);
begin
  if (value = nil) then
    exit;
  composeDomainResourceAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeOperationOutcomeChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeOperationOutcomeChildren(xml : TXmlBuilder; value : TFhirOperationOutcome);
var
  i : integer;
begin
  composeDomainResourceChildren(xml, value);
  for i := 0 to value.issueList.Count - 1 do
      ComposeOperationOutcomeIssue(xml, 'issue', value.issueList[i]);
end;

{$ENDIF FHIR_OPERATIONOUTCOME}
{$IFDEF FHIR_ORGANIZATION}
function TFHIRXmlParser.ParseOrganizationQualification(element : TMXmlElement; path : string) : TFhirOrganizationQualification;
var
  child : TMXmlElement;
begin
  result := TFhirOrganizationQualification.Create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseOrganizationQualificationChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseOrganizationQualificationChild(value : TFhirOrganizationQualification; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'identifier') then
        value.identifierList.Add(ParseIdentifier(child, path+'/identifier'))
      else if (child.localName = 'code') then
        value.code := ParseCodeableConcept(child, path+'/code')
      else if (child.localName = 'period') then
        value.period := ParsePeriod(child, path+'/period')
      else if (child.localName = 'issuer') then
        value.issuer := ParseReference(child, path+'/issuer')
      else if Not ParseBackboneElementChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeOrganizationQualification(xml : TXmlBuilder; name : String; value : TFhirOrganizationQualification);
begin
  if (value = nil) then
    exit;
  composeElementAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeOrganizationQualificationChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeOrganizationQualificationChildren(xml : TXmlBuilder; value : TFhirOrganizationQualification);
var
  i : integer;
begin
  composeBackboneElementChildren(xml, value);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.identifierList.Count - 1 do
      ComposeIdentifier(xml, 'identifier', value.identifierList[i]);
  ComposeCodeableConcept(xml, 'code', value.code);
  if (SummaryOption in [soFull, soData]) then
    ComposePeriod(xml, 'period', value.period);
  if (SummaryOption in [soFull, soData]) then
    ComposeReference(xml, 'issuer', value.issuer);
end;

function TFHIRXmlParser.ParseOrganization(element : TMXmlElement; path : string) : TFhirOrganization;
var
  child : TMXmlElement;
begin
  result := TFhirOrganization.Create;
  try
    parseDomainResourceAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseOrganizationChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseOrganizationChild(value : TFhirOrganization; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'identifier') then
        value.identifierList.Add(ParseIdentifier(child, path+'/identifier'))
      else if (child.localName = 'active') then
        value.activeElement := ParseBoolean(child, path+'/active')
      else if (child.localName = 'type') then
        value.type_List.Add(ParseCodeableConcept(child, path+'/type'))
      else if (child.localName = 'name') then
        value.nameElement := ParseString(child, path+'/name')
      else if (child.localName = 'alias') then
        value.aliasList.Add(ParseString(child, path+'/alias'))
      else if (child.localName = 'description') then
        value.descriptionElement := ParseString(child, path+'/description')
      else if (child.localName = 'contact') then
        value.contactList.Add(ParseExtendedContactDetail(child, path+'/contact'))
      else if (child.localName = 'partOf') then
        value.partOf := ParseReference(child, path+'/partOf')
      else if (child.localName = 'endpoint') then
        value.endpointList.Add(ParseReference(child, path+'/endpoint'))
      else if (child.localName = 'qualification') then
        value.qualificationList.Add(ParseOrganizationQualification(child, path+'/qualification'))
      else if Not ParseDomainResourceChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeOrganization(xml : TXmlBuilder; name : String; value : TFhirOrganization);
begin
  if (value = nil) then
    exit;
  composeDomainResourceAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeOrganizationChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeOrganizationChildren(xml : TXmlBuilder; value : TFhirOrganization);
var
  i : integer;
begin
  composeDomainResourceChildren(xml, value);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.identifierList.Count - 1 do
      ComposeIdentifier(xml, 'identifier', value.identifierList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeBoolean(xml, 'active', value.activeElement);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.type_List.Count - 1 do
      ComposeCodeableConcept(xml, 'type', value.type_List[i]);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(xml, 'name', value.nameElement);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.aliasList.Count - 1 do
      ComposeString(xml, 'alias', value.aliasList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(xml, 'description', value.descriptionElement);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.contactList.Count - 1 do
      ComposeExtendedContactDetail(xml, 'contact', value.contactList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference(xml, 'partOf', value.partOf);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.endpointList.Count - 1 do
      ComposeReference(xml, 'endpoint', value.endpointList[i]);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.qualificationList.Count - 1 do
      ComposeOrganizationQualification(xml, 'qualification', value.qualificationList[i]);
end;

{$ENDIF FHIR_ORGANIZATION}
{$IFDEF FHIR_ORGANIZATIONAFFILIATION}
function TFHIRXmlParser.ParseOrganizationAffiliation(element : TMXmlElement; path : string) : TFhirOrganizationAffiliation;
var
  child : TMXmlElement;
begin
  result := TFhirOrganizationAffiliation.Create;
  try
    parseDomainResourceAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseOrganizationAffiliationChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseOrganizationAffiliationChild(value : TFhirOrganizationAffiliation; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'identifier') then
        value.identifierList.Add(ParseIdentifier(child, path+'/identifier'))
      else if (child.localName = 'active') then
        value.activeElement := ParseBoolean(child, path+'/active')
      else if (child.localName = 'period') then
        value.period := ParsePeriod(child, path+'/period')
      else if (child.localName = 'organization') then
        value.organization := ParseReference(child, path+'/organization')
      else if (child.localName = 'participatingOrganization') then
        value.participatingOrganization := ParseReference(child, path+'/participatingOrganization')
      else if (child.localName = 'network') then
        value.networkList.Add(ParseReference(child, path+'/network'))
      else if (child.localName = 'code') then
        value.codeList.Add(ParseCodeableConcept(child, path+'/code'))
      else if (child.localName = 'specialty') then
        value.specialtyList.Add(ParseCodeableConcept(child, path+'/specialty'))
      else if (child.localName = 'location') then
        value.locationList.Add(ParseReference(child, path+'/location'))
      else if (child.localName = 'healthcareService') then
        value.healthcareServiceList.Add(ParseReference(child, path+'/healthcareService'))
      else if (child.localName = 'contact') then
        value.contactList.Add(ParseExtendedContactDetail(child, path+'/contact'))
      else if (child.localName = 'endpoint') then
        value.endpointList.Add(ParseReference(child, path+'/endpoint'))
      else if Not ParseDomainResourceChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeOrganizationAffiliation(xml : TXmlBuilder; name : String; value : TFhirOrganizationAffiliation);
begin
  if (value = nil) then
    exit;
  composeDomainResourceAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeOrganizationAffiliationChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeOrganizationAffiliationChildren(xml : TXmlBuilder; value : TFhirOrganizationAffiliation);
var
  i : integer;
begin
  composeDomainResourceChildren(xml, value);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.identifierList.Count - 1 do
      ComposeIdentifier(xml, 'identifier', value.identifierList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeBoolean(xml, 'active', value.activeElement);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposePeriod(xml, 'period', value.period);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference(xml, 'organization', value.organization);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference(xml, 'participatingOrganization', value.participatingOrganization);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.networkList.Count - 1 do
      ComposeReference(xml, 'network', value.networkList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.codeList.Count - 1 do
      ComposeCodeableConcept(xml, 'code', value.codeList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.specialtyList.Count - 1 do
      ComposeCodeableConcept(xml, 'specialty', value.specialtyList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.locationList.Count - 1 do
      ComposeReference(xml, 'location', value.locationList[i]);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.healthcareServiceList.Count - 1 do
      ComposeReference(xml, 'healthcareService', value.healthcareServiceList[i]);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.contactList.Count - 1 do
      ComposeExtendedContactDetail(xml, 'contact', value.contactList[i]);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.endpointList.Count - 1 do
      ComposeReference(xml, 'endpoint', value.endpointList[i]);
end;

{$ENDIF FHIR_ORGANIZATIONAFFILIATION}
{$IFDEF FHIR_PACKAGEDPRODUCTDEFINITION}
function TFHIRXmlParser.ParsePackagedProductDefinitionLegalStatusOfSupply(element : TMXmlElement; path : string) : TFhirPackagedProductDefinitionLegalStatusOfSupply;
var
  child : TMXmlElement;
begin
  result := TFhirPackagedProductDefinitionLegalStatusOfSupply.Create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParsePackagedProductDefinitionLegalStatusOfSupplyChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParsePackagedProductDefinitionLegalStatusOfSupplyChild(value : TFhirPackagedProductDefinitionLegalStatusOfSupply; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'code') then
        value.code := ParseCodeableConcept(child, path+'/code')
      else if (child.localName = 'jurisdiction') then
        value.jurisdiction := ParseCodeableConcept(child, path+'/jurisdiction')
      else if Not ParseBackboneElementChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposePackagedProductDefinitionLegalStatusOfSupply(xml : TXmlBuilder; name : String; value : TFhirPackagedProductDefinitionLegalStatusOfSupply);
begin
  if (value = nil) then
    exit;
  composeElementAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composePackagedProductDefinitionLegalStatusOfSupplyChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposePackagedProductDefinitionLegalStatusOfSupplyChildren(xml : TXmlBuilder; value : TFhirPackagedProductDefinitionLegalStatusOfSupply);
begin
  composeBackboneElementChildren(xml, value);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(xml, 'code', value.code);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(xml, 'jurisdiction', value.jurisdiction);
end;

function TFHIRXmlParser.ParsePackagedProductDefinitionPackaging(element : TMXmlElement; path : string) : TFhirPackagedProductDefinitionPackaging;
var
  child : TMXmlElement;
begin
  result := TFhirPackagedProductDefinitionPackaging.Create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParsePackagedProductDefinitionPackagingChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParsePackagedProductDefinitionPackagingChild(value : TFhirPackagedProductDefinitionPackaging; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'identifier') then
        value.identifierList.Add(ParseIdentifier(child, path+'/identifier'))
      else if (child.localName = 'type') then
        value.type_ := ParseCodeableConcept(child, path+'/type')
      else if (child.localName = 'quantity') then
        value.quantityElement := ParseInteger(child, path+'/quantity')
      else if (child.localName = 'material') then
        value.materialList.Add(ParseCodeableConcept(child, path+'/material'))
      else if (child.localName = 'alternateMaterial') then
        value.alternateMaterialList.Add(ParseCodeableConcept(child, path+'/alternateMaterial'))
      else if (child.localName = 'shelfLifeStorage') then
        value.shelfLifeStorageList.Add(ParseProductShelfLife(child, path+'/shelfLifeStorage'))
      else if (child.localName = 'manufacturer') then
        value.manufacturerList.Add(ParseReference(child, path+'/manufacturer'))
      else if (child.localName = 'property') then
        value.property_List.Add(ParsePackagedProductDefinitionPackagingProperty(child, path+'/property'))
      else if (child.localName = 'containedItem') then
        value.containedItemList.Add(ParsePackagedProductDefinitionPackagingContainedItem(child, path+'/containedItem'))
      else if (child.localName = 'packaging') then
        value.packagingList.Add(ParsePackagedProductDefinitionPackaging(child, path+'/packaging'))
      else if Not ParseBackboneElementChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposePackagedProductDefinitionPackaging(xml : TXmlBuilder; name : String; value : TFhirPackagedProductDefinitionPackaging);
begin
  if (value = nil) then
    exit;
  composeElementAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composePackagedProductDefinitionPackagingChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposePackagedProductDefinitionPackagingChildren(xml : TXmlBuilder; value : TFhirPackagedProductDefinitionPackaging);
var
  i : integer;
begin
  composeBackboneElementChildren(xml, value);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.identifierList.Count - 1 do
      ComposeIdentifier(xml, 'identifier', value.identifierList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(xml, 'type', value.type_);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeInteger(xml, 'quantity', value.quantityElement);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.materialList.Count - 1 do
      ComposeCodeableConcept(xml, 'material', value.materialList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.alternateMaterialList.Count - 1 do
      ComposeCodeableConcept(xml, 'alternateMaterial', value.alternateMaterialList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.shelfLifeStorageList.Count - 1 do
      ComposeProductShelfLife(xml, 'shelfLifeStorage', value.shelfLifeStorageList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.manufacturerList.Count - 1 do
      ComposeReference(xml, 'manufacturer', value.manufacturerList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.property_List.Count - 1 do
      ComposePackagedProductDefinitionPackagingProperty(xml, 'property', value.property_List[i]);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.containedItemList.Count - 1 do
      ComposePackagedProductDefinitionPackagingContainedItem(xml, 'containedItem', value.containedItemList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.packagingList.Count - 1 do
      ComposePackagedProductDefinitionPackaging(xml, 'packaging', value.packagingList[i]);
end;

function TFHIRXmlParser.ParsePackagedProductDefinitionPackagingProperty(element : TMXmlElement; path : string) : TFhirPackagedProductDefinitionPackagingProperty;
var
  child : TMXmlElement;
begin
  result := TFhirPackagedProductDefinitionPackagingProperty.Create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParsePackagedProductDefinitionPackagingPropertyChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParsePackagedProductDefinitionPackagingPropertyChild(value : TFhirPackagedProductDefinitionPackagingProperty; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'type') then
        value.type_ := ParseCodeableConcept(child, path+'/type')
      else if (child.localName = 'valueCodeableConcept') then
        value.value := ParseCodeableConcept(child, path+'/valueCodeableConcept')
      else if (child.localName = 'valueQuantity') then
        value.value := ParseQuantity(child, path+'/valueQuantity')
      else if (child.localName = 'valueAttachment') then
        value.value := ParseAttachment(child, path+'/valueAttachment')
      else if (child.localName = 'valueDate') then
        value.value := ParseDate(child, path+'/valueDate')
      else if (child.localName = 'valueBoolean') then
        value.value := ParseBoolean(child, path+'/valueBoolean')
      else if Not ParseBackboneElementChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposePackagedProductDefinitionPackagingProperty(xml : TXmlBuilder; name : String; value : TFhirPackagedProductDefinitionPackagingProperty);
begin
  if (value = nil) then
    exit;
  composeElementAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composePackagedProductDefinitionPackagingPropertyChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposePackagedProductDefinitionPackagingPropertyChildren(xml : TXmlBuilder; value : TFhirPackagedProductDefinitionPackagingProperty);
begin
  composeBackboneElementChildren(xml, value);
  ComposeCodeableConcept(xml, 'type', value.type_);
  if (SummaryOption in [soFull, soSummary, soData]) and (value.value is TFhirCodeableConcept) {6} then
    ComposeCodeableConcept(xml, 'valueCodeableConcept', TFhirCodeableConcept(value.value))
  else if (SummaryOption in [soFull, soSummary, soData]) and (value.value is TFhirQuantity) {6} then
    ComposeQuantity(xml, 'valueQuantity', TFhirQuantity(value.value))
  else if (SummaryOption in [soFull, soSummary, soData]) and (value.value is TFhirAttachment) {6} then
    ComposeAttachment(xml, 'valueAttachment', TFhirAttachment(value.value))
  else if (SummaryOption in [soFull, soSummary, soData]) and (value.value is TFhirDate) {6} then
    ComposeDate(xml, 'valueDate', TFhirDate(value.value))
  else if (SummaryOption in [soFull, soSummary, soData]) and (value.value is TFhirBoolean) {6} then
    ComposeBoolean(xml, 'valueBoolean', TFhirBoolean(value.value));
end;

function TFHIRXmlParser.ParsePackagedProductDefinitionPackagingContainedItem(element : TMXmlElement; path : string) : TFhirPackagedProductDefinitionPackagingContainedItem;
var
  child : TMXmlElement;
begin
  result := TFhirPackagedProductDefinitionPackagingContainedItem.Create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParsePackagedProductDefinitionPackagingContainedItemChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParsePackagedProductDefinitionPackagingContainedItemChild(value : TFhirPackagedProductDefinitionPackagingContainedItem; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'item') then
        value.item := ParseCodeableReference(child, path+'/item')
      else if (child.localName = 'amount') then
        value.amount := ParseQuantity(child, path+'/amount')
      else if Not ParseBackboneElementChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposePackagedProductDefinitionPackagingContainedItem(xml : TXmlBuilder; name : String; value : TFhirPackagedProductDefinitionPackagingContainedItem);
begin
  if (value = nil) then
    exit;
  composeElementAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composePackagedProductDefinitionPackagingContainedItemChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposePackagedProductDefinitionPackagingContainedItemChildren(xml : TXmlBuilder; value : TFhirPackagedProductDefinitionPackagingContainedItem);
begin
  composeBackboneElementChildren(xml, value);
  ComposeCodeableReference(xml, 'item', value.item);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeQuantity(xml, 'amount', value.amount);
end;

function TFHIRXmlParser.ParsePackagedProductDefinition(element : TMXmlElement; path : string) : TFhirPackagedProductDefinition;
var
  child : TMXmlElement;
begin
  result := TFhirPackagedProductDefinition.Create;
  try
    parseDomainResourceAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParsePackagedProductDefinitionChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParsePackagedProductDefinitionChild(value : TFhirPackagedProductDefinition; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'identifier') then
        value.identifierList.Add(ParseIdentifier(child, path+'/identifier'))
      else if (child.localName = 'name') then
        value.nameElement := ParseString(child, path+'/name')
      else if (child.localName = 'type') then
        value.type_ := ParseCodeableConcept(child, path+'/type')
      else if (child.localName = 'packageFor') then
        value.packageForList.Add(ParseReference(child, path+'/packageFor'))
      else if (child.localName = 'status') then
        value.status := ParseCodeableConcept(child, path+'/status')
      else if (child.localName = 'statusDate') then
        value.statusDateElement := ParseDateTime(child, path+'/statusDate')
      else if (child.localName = 'containedItemQuantity') then
        value.containedItemQuantityList.Add(ParseQuantity(child, path+'/containedItemQuantity'))
      else if (child.localName = 'description') then
        value.descriptionElement := ParseMarkdown(child, path+'/description')
      else if (child.localName = 'legalStatusOfSupply') then
        value.legalStatusOfSupplyList.Add(ParsePackagedProductDefinitionLegalStatusOfSupply(child, path+'/legalStatusOfSupply'))
      else if (child.localName = 'marketingStatus') then
        value.marketingStatusList.Add(ParseMarketingStatus(child, path+'/marketingStatus'))
      else if (child.localName = 'characteristic') then
        value.characteristicList.Add(ParseCodeableConcept(child, path+'/characteristic'))
      else if (child.localName = 'copackagedIndicator') then
        value.copackagedIndicatorElement := ParseBoolean(child, path+'/copackagedIndicator')
      else if (child.localName = 'manufacturer') then
        value.manufacturerList.Add(ParseReference(child, path+'/manufacturer'))
      else if (child.localName = 'attachedDocument') then
        value.attachedDocumentList.Add(ParseReference(child, path+'/attachedDocument'))
      else if (child.localName = 'packaging') then
        value.packaging := ParsePackagedProductDefinitionPackaging(child, path+'/packaging')
      else if Not ParseDomainResourceChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposePackagedProductDefinition(xml : TXmlBuilder; name : String; value : TFhirPackagedProductDefinition);
begin
  if (value = nil) then
    exit;
  composeDomainResourceAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composePackagedProductDefinitionChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposePackagedProductDefinitionChildren(xml : TXmlBuilder; value : TFhirPackagedProductDefinition);
var
  i : integer;
begin
  composeDomainResourceChildren(xml, value);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.identifierList.Count - 1 do
      ComposeIdentifier(xml, 'identifier', value.identifierList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(xml, 'name', value.nameElement);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(xml, 'type', value.type_);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.packageForList.Count - 1 do
      ComposeReference(xml, 'packageFor', value.packageForList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(xml, 'status', value.status);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDateTime(xml, 'statusDate', value.statusDateElement);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.containedItemQuantityList.Count - 1 do
      ComposeQuantity(xml, 'containedItemQuantity', value.containedItemQuantityList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeMarkdown(xml, 'description', value.descriptionElement);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.legalStatusOfSupplyList.Count - 1 do
      ComposePackagedProductDefinitionLegalStatusOfSupply(xml, 'legalStatusOfSupply', value.legalStatusOfSupplyList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.marketingStatusList.Count - 1 do
      ComposeMarketingStatus(xml, 'marketingStatus', value.marketingStatusList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.characteristicList.Count - 1 do
      ComposeCodeableConcept(xml, 'characteristic', value.characteristicList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeBoolean(xml, 'copackagedIndicator', value.copackagedIndicatorElement);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.manufacturerList.Count - 1 do
      ComposeReference(xml, 'manufacturer', value.manufacturerList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.attachedDocumentList.Count - 1 do
      ComposeReference(xml, 'attachedDocument', value.attachedDocumentList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposePackagedProductDefinitionPackaging(xml, 'packaging', value.packaging);
end;

{$ENDIF FHIR_PACKAGEDPRODUCTDEFINITION}
{$IFDEF FHIR_PARAMETERS}
function TFHIRXmlParser.ParseParametersParameter(element : TMXmlElement; path : string) : TFhirParametersParameter;
var
  child : TMXmlElement;
begin
  result := TFhirParametersParameter.Create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseParametersParameterChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseParametersParameterChild(value : TFhirParametersParameter; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'name') then
        value.nameElement := ParseString(child, path+'/name')
      else if (child.localName = 'valueCanonical') then
        value.value := ParseCanonical(child, path+'/valueCanonical')
      else if (child.localName = 'valueCode') then
        value.value := ParseCode(child, path+'/valueCode')
      else if (child.localName = 'valueId') then
        value.value := ParseId(child, path+'/valueId')
      else if (child.localName = 'valueMarkdown') then
        value.value := ParseMarkdown(child, path+'/valueMarkdown')
      else if (child.localName = 'valueOid') then
        value.value := ParseOid(child, path+'/valueOid')
      else if (child.localName = 'valuePositiveInt') then
        value.value := ParsePositiveInt(child, path+'/valuePositiveInt')
      else if (child.localName = 'valueUnsignedInt') then
        value.value := ParseUnsignedInt(child, path+'/valueUnsignedInt')
      else if (child.localName = 'valueUrl') then
        value.value := ParseUrl(child, path+'/valueUrl')
      else if (child.localName = 'valueUuid') then
        value.value := ParseUuid(child, path+'/valueUuid')
      else if (child.localName = 'valueAddress') then
        value.value := ParseAddress(child, path+'/valueAddress')
      else if (child.localName = 'valueAge') then
        value.value := ParseAge(child, path+'/valueAge')
      else if (child.localName = 'valueAnnotation') then
        value.value := ParseAnnotation(child, path+'/valueAnnotation')
      else if (child.localName = 'valueAttachment') then
        value.value := ParseAttachment(child, path+'/valueAttachment')
      else if (child.localName = 'valueCodeableConcept') then
        value.value := ParseCodeableConcept(child, path+'/valueCodeableConcept')
      else if (child.localName = 'valueCodeableReference') then
        value.value := ParseCodeableReference(child, path+'/valueCodeableReference')
      else if (child.localName = 'valueCoding') then
        value.value := ParseCoding(child, path+'/valueCoding')
      else if (child.localName = 'valueContactPoint') then
        value.value := ParseContactPoint(child, path+'/valueContactPoint')
      else if (child.localName = 'valueCount') then
        value.value := ParseCount(child, path+'/valueCount')
      else if (child.localName = 'valueDistance') then
        value.value := ParseDistance(child, path+'/valueDistance')
      else if (child.localName = 'valueDuration') then
        value.value := ParseDuration(child, path+'/valueDuration')
      else if (child.localName = 'valueHumanName') then
        value.value := ParseHumanName(child, path+'/valueHumanName')
      else if (child.localName = 'valueIdentifier') then
        value.value := ParseIdentifier(child, path+'/valueIdentifier')
      else if (child.localName = 'valueMoney') then
        value.value := ParseMoney(child, path+'/valueMoney')
      else if (child.localName = 'valuePeriod') then
        value.value := ParsePeriod(child, path+'/valuePeriod')
      else if (child.localName = 'valueQuantity') then
        value.value := ParseQuantity(child, path+'/valueQuantity')
      else if (child.localName = 'valueRange') then
        value.value := ParseRange(child, path+'/valueRange')
      else if (child.localName = 'valueRatio') then
        value.value := ParseRatio(child, path+'/valueRatio')
      else if (child.localName = 'valueRatioRange') then
        value.value := ParseRatioRange(child, path+'/valueRatioRange')
      else if (child.localName = 'valueReference') then
        value.value := ParseReference(child, path+'/valueReference')
      else if (child.localName = 'valueSampledData') then
        value.value := ParseSampledData(child, path+'/valueSampledData')
      else if (child.localName = 'valueSignature') then
        value.value := ParseSignature(child, path+'/valueSignature')
      else if (child.localName = 'valueTiming') then
        value.value := ParseTiming(child, path+'/valueTiming')
      else if (child.localName = 'valueContactDetail') then
        value.value := ParseContactDetail(child, path+'/valueContactDetail')
      else if (child.localName = 'valueDataRequirement') then
        value.value := ParseDataRequirement(child, path+'/valueDataRequirement')
      else if (child.localName = 'valueExpression') then
        value.value := ParseExpression(child, path+'/valueExpression')
      else if (child.localName = 'valueParameterDefinition') then
        value.value := ParseParameterDefinition(child, path+'/valueParameterDefinition')
      else if (child.localName = 'valueRelatedArtifact') then
        value.value := ParseRelatedArtifact(child, path+'/valueRelatedArtifact')
      else if (child.localName = 'valueTriggerDefinition') then
        value.value := ParseTriggerDefinition(child, path+'/valueTriggerDefinition')
      else if (child.localName = 'valueUsageContext') then
        value.value := ParseUsageContext(child, path+'/valueUsageContext')
      else if (child.localName = 'valueAvailability') then
        value.value := ParseAvailability(child, path+'/valueAvailability')
      else if (child.localName = 'valueExtendedContactDetail') then
        value.value := ParseExtendedContactDetail(child, path+'/valueExtendedContactDetail')
      else if (child.localName = 'valueDosage') then
        value.value := ParseDosage(child, path+'/valueDosage')
      else if (child.localName = 'valueMeta') then
        value.value := ParseMeta(child, path+'/valueMeta')
      else if (child.localName = 'valueBase64Binary') then
        value.value := ParseBase64Binary(child, path+'/valueBase64Binary')
      else if (child.localName = 'valueBoolean') then
        value.value := ParseBoolean(child, path+'/valueBoolean')
      else if (child.localName = 'valueDate') then
        value.value := ParseDate(child, path+'/valueDate')
      else if (child.localName = 'valueDateTime') then
        value.value := ParseDateTime(child, path+'/valueDateTime')
      else if (child.localName = 'valueDecimal') then
        value.value := ParseDecimal(child, path+'/valueDecimal')
      else if (child.localName = 'valueInstant') then
        value.value := ParseInstant(child, path+'/valueInstant')
      else if (child.localName = 'valueInteger') then
        value.value := ParseInteger(child, path+'/valueInteger')
      else if (child.localName = 'valueInteger64') then
        value.value := ParseInteger64(child, path+'/valueInteger64')
      else if (child.localName = 'valueString') then
        value.value := ParseString(child, path+'/valueString')
      else if (child.localName = 'valueTime') then
        value.value := ParseTime(child, path+'/valueTime')
      else if (child.localName = 'valueUri') then
        value.value := ParseUri(child, path+'/valueUri')
      else if (child.localName = 'resource') then
        value.resource := ParseInnerResource(child, path+'/resource')
      else if (child.localName = 'part') then
        value.partList.Add(ParseParametersParameter(child, path+'/part'))
      else if Not ParseBackboneElementChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeParametersParameter(xml : TXmlBuilder; name : String; value : TFhirParametersParameter);
begin
  if (value = nil) then
    exit;
  composeElementAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeParametersParameterChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeParametersParameterChildren(xml : TXmlBuilder; value : TFhirParametersParameter);
var
  i : integer;
begin
  composeBackboneElementChildren(xml, value);
  ComposeString(xml, 'name', value.nameElement);
  if (SummaryOption in [soFull, soSummary, soText, soData]) and (value.value is TFhirCanonical) {6} then
    ComposeCanonical(xml, 'valueCanonical', TFhirCanonical(value.value))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (value.value is TFhirCode) {6} then
    ComposeCode(xml, 'valueCode', TFhirCode(value.value))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (value.value is TFhirId) {6} then
    ComposeId(xml, 'valueId', TFhirId(value.value))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (value.value is TFhirMarkdown) {6} then
    ComposeMarkdown(xml, 'valueMarkdown', TFhirMarkdown(value.value))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (value.value is TFhirOid) {6} then
    ComposeOid(xml, 'valueOid', TFhirOid(value.value))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (value.value is TFhirPositiveInt) {6} then
    ComposePositiveInt(xml, 'valuePositiveInt', TFhirPositiveInt(value.value))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (value.value is TFhirUnsignedInt) {6} then
    ComposeUnsignedInt(xml, 'valueUnsignedInt', TFhirUnsignedInt(value.value))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (value.value is TFhirUrl) {6} then
    ComposeUrl(xml, 'valueUrl', TFhirUrl(value.value))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (value.value is TFhirUuid) {6} then
    ComposeUuid(xml, 'valueUuid', TFhirUuid(value.value))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (value.value is TFhirAddress) {6} then
    ComposeAddress(xml, 'valueAddress', TFhirAddress(value.value))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (value.value is TFhirAge) {6} then
    ComposeAge(xml, 'valueAge', TFhirAge(value.value))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (value.value is TFhirAnnotation) {6} then
    ComposeAnnotation(xml, 'valueAnnotation', TFhirAnnotation(value.value))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (value.value is TFhirAttachment) {6} then
    ComposeAttachment(xml, 'valueAttachment', TFhirAttachment(value.value))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (value.value is TFhirCodeableConcept) {6} then
    ComposeCodeableConcept(xml, 'valueCodeableConcept', TFhirCodeableConcept(value.value))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (value.value is TFhirCodeableReference) {6} then
    ComposeCodeableReference(xml, 'valueCodeableReference', TFhirCodeableReference(value.value))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (value.value is TFhirCoding) {6} then
    ComposeCoding(xml, 'valueCoding', TFhirCoding(value.value))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (value.value is TFhirContactPoint) {6} then
    ComposeContactPoint(xml, 'valueContactPoint', TFhirContactPoint(value.value))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (value.value is TFhirCount) {6} then
    ComposeCount(xml, 'valueCount', TFhirCount(value.value))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (value.value is TFhirDistance) {6} then
    ComposeDistance(xml, 'valueDistance', TFhirDistance(value.value))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (value.value is TFhirDuration) {6} then
    ComposeDuration(xml, 'valueDuration', TFhirDuration(value.value))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (value.value is TFhirHumanName) {6} then
    ComposeHumanName(xml, 'valueHumanName', TFhirHumanName(value.value))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (value.value is TFhirIdentifier) {6} then
    ComposeIdentifier(xml, 'valueIdentifier', TFhirIdentifier(value.value))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (value.value is TFhirMoney) {6} then
    ComposeMoney(xml, 'valueMoney', TFhirMoney(value.value))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (value.value is TFhirPeriod) {6} then
    ComposePeriod(xml, 'valuePeriod', TFhirPeriod(value.value))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (value.value is TFhirQuantity) {6} then
    ComposeQuantity(xml, 'valueQuantity', TFhirQuantity(value.value))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (value.value is TFhirRange) {6} then
    ComposeRange(xml, 'valueRange', TFhirRange(value.value))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (value.value is TFhirRatio) {6} then
    ComposeRatio(xml, 'valueRatio', TFhirRatio(value.value))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (value.value is TFhirRatioRange) {6} then
    ComposeRatioRange(xml, 'valueRatioRange', TFhirRatioRange(value.value))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (value.value is TFhirReference) {6} then
    ComposeReference(xml, 'valueReference', TFhirReference(value.value))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (value.value is TFhirSampledData) {6} then
    ComposeSampledData(xml, 'valueSampledData', TFhirSampledData(value.value))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (value.value is TFhirSignature) {6} then
    ComposeSignature(xml, 'valueSignature', TFhirSignature(value.value))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (value.value is TFhirTiming) {6} then
    ComposeTiming(xml, 'valueTiming', TFhirTiming(value.value))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (value.value is TFhirContactDetail) {6} then
    ComposeContactDetail(xml, 'valueContactDetail', TFhirContactDetail(value.value))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (value.value is TFhirDataRequirement) {6} then
    ComposeDataRequirement(xml, 'valueDataRequirement', TFhirDataRequirement(value.value))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (value.value is TFhirExpression) {6} then
    ComposeExpression(xml, 'valueExpression', TFhirExpression(value.value))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (value.value is TFhirParameterDefinition) {6} then
    ComposeParameterDefinition(xml, 'valueParameterDefinition', TFhirParameterDefinition(value.value))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (value.value is TFhirRelatedArtifact) {6} then
    ComposeRelatedArtifact(xml, 'valueRelatedArtifact', TFhirRelatedArtifact(value.value))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (value.value is TFhirTriggerDefinition) {6} then
    ComposeTriggerDefinition(xml, 'valueTriggerDefinition', TFhirTriggerDefinition(value.value))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (value.value is TFhirUsageContext) {6} then
    ComposeUsageContext(xml, 'valueUsageContext', TFhirUsageContext(value.value))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (value.value is TFhirAvailability) {6} then
    ComposeAvailability(xml, 'valueAvailability', TFhirAvailability(value.value))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (value.value is TFhirExtendedContactDetail) {6} then
    ComposeExtendedContactDetail(xml, 'valueExtendedContactDetail', TFhirExtendedContactDetail(value.value))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (value.value is TFhirDosage) {6} then
    ComposeDosage(xml, 'valueDosage', TFhirDosage(value.value))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (value.value is TFhirMeta) {6} then
    ComposeMeta(xml, 'valueMeta', TFhirMeta(value.value))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (value.value is TFhirBase64Binary) {6} then
    ComposeBase64Binary(xml, 'valueBase64Binary', TFhirBase64Binary(value.value))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (value.value is TFhirBoolean) {6} then
    ComposeBoolean(xml, 'valueBoolean', TFhirBoolean(value.value))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (value.value is TFhirDate) {6} then
    ComposeDate(xml, 'valueDate', TFhirDate(value.value))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (value.value is TFhirDateTime) {6} then
    ComposeDateTime(xml, 'valueDateTime', TFhirDateTime(value.value))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (value.value is TFhirDecimal) {6} then
    ComposeDecimal(xml, 'valueDecimal', TFhirDecimal(value.value))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (value.value is TFhirInstant) {6} then
    ComposeInstant(xml, 'valueInstant', TFhirInstant(value.value))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (value.value is TFhirInteger) {6} then
    ComposeInteger(xml, 'valueInteger', TFhirInteger(value.value))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (value.value is TFhirInteger64) {6} then
    ComposeInteger64(xml, 'valueInteger64', TFhirInteger64(value.value))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (value.value is TFhirString) {6} then
    ComposeString(xml, 'valueString', TFhirString(value.value))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (value.value is TFhirTime) {6} then
    ComposeTime(xml, 'valueTime', TFhirTime(value.value))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (value.value is TFhirUri) {6} then
    ComposeUri(xml, 'valueUri', TFhirUri(value.value));
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeInnerResource(xml, 'resource', value, value.resource);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    for i := 0 to value.partList.Count - 1 do
      ComposeParametersParameter(xml, 'part', value.partList[i]);
end;

function TFHIRXmlParser.ParseParameters(element : TMXmlElement; path : string) : TFhirParameters;
var
  child : TMXmlElement;
begin
  result := TFhirParameters.Create;
  try
    parseResourceAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseParametersChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseParametersChild(value : TFhirParameters; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'parameter') then
        value.parameterList.Add(ParseParametersParameter(child, path+'/parameter'))
      else if Not ParseResourceChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeParameters(xml : TXmlBuilder; name : String; value : TFhirParameters);
begin
  if (value = nil) then
    exit;
  composeResourceAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeParametersChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeParametersChildren(xml : TXmlBuilder; value : TFhirParameters);
var
  i : integer;
begin
  composeResourceChildren(xml, value);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    for i := 0 to value.parameterList.Count - 1 do
      ComposeParametersParameter(xml, 'parameter', value.parameterList[i]);
end;

{$ENDIF FHIR_PARAMETERS}
{$IFDEF FHIR_PATIENT}
function TFHIRXmlParser.ParsePatientContact(element : TMXmlElement; path : string) : TFhirPatientContact;
var
  child : TMXmlElement;
begin
  result := TFhirPatientContact.Create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParsePatientContactChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParsePatientContactChild(value : TFhirPatientContact; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'relationship') then
        value.relationshipList.Add(ParseCodeableConcept(child, path+'/relationship'))
      else if (child.localName = 'name') then
        value.name := ParseHumanName(child, path+'/name')
      else if (child.localName = 'telecom') then
        value.telecomList.Add(ParseContactPoint(child, path+'/telecom'))
      else if (child.localName = 'address') then
        value.address := ParseAddress(child, path+'/address')
      else if (child.localName = 'gender') then
        value.genderElement := ParseEnum(CODES_TFhirAdministrativeGenderEnum, SYSTEMS_TFhirAdministrativeGenderEnum, child, path+'/gender')
      else if (child.localName = 'organization') then
        value.organization := ParseReference(child, path+'/organization')
      else if (child.localName = 'period') then
        value.period := ParsePeriod(child, path+'/period')
      else if Not ParseBackboneElementChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposePatientContact(xml : TXmlBuilder; name : String; value : TFhirPatientContact);
begin
  if (value = nil) then
    exit;
  composeElementAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composePatientContactChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposePatientContactChildren(xml : TXmlBuilder; value : TFhirPatientContact);
var
  i : integer;
begin
  composeBackboneElementChildren(xml, value);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.relationshipList.Count - 1 do
      ComposeCodeableConcept(xml, 'relationship', value.relationshipList[i]);
  if (SummaryOption in [soFull, soData]) then
    ComposeHumanName(xml, 'name', value.name);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.telecomList.Count - 1 do
      ComposeContactPoint(xml, 'telecom', value.telecomList[i]);
  if (SummaryOption in [soFull, soData]) then
    ComposeAddress(xml, 'address', value.address);
  if (SummaryOption in [soFull, soData]) then
    ComposeEnum(xml, 'gender', value.genderElement, CODES_TFhirAdministrativeGenderEnum);
  if (SummaryOption in [soFull, soData]) then
    ComposeReference(xml, 'organization', value.organization);
  if (SummaryOption in [soFull, soData]) then
    ComposePeriod(xml, 'period', value.period);
end;

function TFHIRXmlParser.ParsePatientCommunication(element : TMXmlElement; path : string) : TFhirPatientCommunication;
var
  child : TMXmlElement;
begin
  result := TFhirPatientCommunication.Create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParsePatientCommunicationChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParsePatientCommunicationChild(value : TFhirPatientCommunication; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'language') then
        value.language := ParseCodeableConcept(child, path+'/language')
      else if (child.localName = 'preferred') then
        value.preferredElement := ParseBoolean(child, path+'/preferred')
      else if Not ParseBackboneElementChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposePatientCommunication(xml : TXmlBuilder; name : String; value : TFhirPatientCommunication);
begin
  if (value = nil) then
    exit;
  composeElementAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composePatientCommunicationChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposePatientCommunicationChildren(xml : TXmlBuilder; value : TFhirPatientCommunication);
begin
  composeBackboneElementChildren(xml, value);
  ComposeCodeableConcept(xml, 'language', value.language);
  if (SummaryOption in [soFull, soData]) then
    ComposeBoolean(xml, 'preferred', value.preferredElement);
end;

function TFHIRXmlParser.ParsePatientLink(element : TMXmlElement; path : string) : TFhirPatientLink;
var
  child : TMXmlElement;
begin
  result := TFhirPatientLink.Create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParsePatientLinkChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParsePatientLinkChild(value : TFhirPatientLink; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'other') then
        value.other := ParseReference(child, path+'/other')
      else if (child.localName = 'type') then
        value.type_Element := ParseEnum(CODES_TFhirLinkTypeEnum, SYSTEMS_TFhirLinkTypeEnum, child, path+'/type')
      else if Not ParseBackboneElementChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposePatientLink(xml : TXmlBuilder; name : String; value : TFhirPatientLink);
begin
  if (value = nil) then
    exit;
  composeElementAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composePatientLinkChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposePatientLinkChildren(xml : TXmlBuilder; value : TFhirPatientLink);
begin
  composeBackboneElementChildren(xml, value);
  ComposeReference(xml, 'other', value.other);
  ComposeEnum(xml, 'type', value.type_Element, CODES_TFhirLinkTypeEnum);
end;

function TFHIRXmlParser.ParsePatient(element : TMXmlElement; path : string) : TFhirPatient;
var
  child : TMXmlElement;
begin
  result := TFhirPatient.Create;
  try
    parseDomainResourceAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParsePatientChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParsePatientChild(value : TFhirPatient; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'identifier') then
        value.identifierList.Add(ParseIdentifier(child, path+'/identifier'))
      else if (child.localName = 'active') then
        value.activeElement := ParseBoolean(child, path+'/active')
      else if (child.localName = 'name') then
        value.nameList.Add(ParseHumanName(child, path+'/name'))
      else if (child.localName = 'telecom') then
        value.telecomList.Add(ParseContactPoint(child, path+'/telecom'))
      else if (child.localName = 'gender') then
        value.genderElement := ParseEnum(CODES_TFhirAdministrativeGenderEnum, SYSTEMS_TFhirAdministrativeGenderEnum, child, path+'/gender')
      else if (child.localName = 'birthDate') then
        value.birthDateElement := ParseDate(child, path+'/birthDate')
      else if (child.localName = 'deceasedBoolean') then
        value.deceased := ParseBoolean(child, path+'/deceasedBoolean')
      else if (child.localName = 'deceasedDateTime') then
        value.deceased := ParseDateTime(child, path+'/deceasedDateTime')
      else if (child.localName = 'address') then
        value.addressList.Add(ParseAddress(child, path+'/address'))
      else if (child.localName = 'maritalStatus') then
        value.maritalStatus := ParseCodeableConcept(child, path+'/maritalStatus')
      else if (child.localName = 'multipleBirthBoolean') then
        value.multipleBirth := ParseBoolean(child, path+'/multipleBirthBoolean')
      else if (child.localName = 'multipleBirthInteger') then
        value.multipleBirth := ParseInteger(child, path+'/multipleBirthInteger')
      else if (child.localName = 'photo') then
        value.photoList.Add(ParseAttachment(child, path+'/photo'))
      else if (child.localName = 'contact') then
        value.contactList.Add(ParsePatientContact(child, path+'/contact'))
      else if (child.localName = 'communication') then
        value.communicationList.Add(ParsePatientCommunication(child, path+'/communication'))
      else if (child.localName = 'generalPractitioner') then
        value.generalPractitionerList.Add(ParseReference(child, path+'/generalPractitioner'))
      else if (child.localName = 'managingOrganization') then
        value.managingOrganization := ParseReference(child, path+'/managingOrganization')
      else if (child.localName = 'link') then
        value.link_List.Add(ParsePatientLink(child, path+'/link'))
      else if Not ParseDomainResourceChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposePatient(xml : TXmlBuilder; name : String; value : TFhirPatient);
begin
  if (value = nil) then
    exit;
  composeDomainResourceAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composePatientChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposePatientChildren(xml : TXmlBuilder; value : TFhirPatient);
var
  i : integer;
begin
  composeDomainResourceChildren(xml, value);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.identifierList.Count - 1 do
      ComposeIdentifier(xml, 'identifier', value.identifierList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeBoolean(xml, 'active', value.activeElement);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.nameList.Count - 1 do
      ComposeHumanName(xml, 'name', value.nameList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.telecomList.Count - 1 do
      ComposeContactPoint(xml, 'telecom', value.telecomList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeEnum(xml, 'gender', value.genderElement, CODES_TFhirAdministrativeGenderEnum);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDate(xml, 'birthDate', value.birthDateElement);
  if (SummaryOption in [soFull, soSummary, soData]) and (value.deceased is TFhirBoolean) {6} then
    ComposeBoolean(xml, 'deceasedBoolean', TFhirBoolean(value.deceased))
  else if (SummaryOption in [soFull, soSummary, soData]) and (value.deceased is TFhirDateTime) {6} then
    ComposeDateTime(xml, 'deceasedDateTime', TFhirDateTime(value.deceased));
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.addressList.Count - 1 do
      ComposeAddress(xml, 'address', value.addressList[i]);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(xml, 'maritalStatus', value.maritalStatus);
  if (SummaryOption in [soFull, soData]) and (value.multipleBirth is TFhirBoolean) {6} then
    ComposeBoolean(xml, 'multipleBirthBoolean', TFhirBoolean(value.multipleBirth))
  else if (SummaryOption in [soFull, soData]) and (value.multipleBirth is TFhirInteger) {6} then
    ComposeInteger(xml, 'multipleBirthInteger', TFhirInteger(value.multipleBirth));
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.photoList.Count - 1 do
      ComposeAttachment(xml, 'photo', value.photoList[i]);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.contactList.Count - 1 do
      ComposePatientContact(xml, 'contact', value.contactList[i]);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.communicationList.Count - 1 do
      ComposePatientCommunication(xml, 'communication', value.communicationList[i]);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.generalPractitionerList.Count - 1 do
      ComposeReference(xml, 'generalPractitioner', value.generalPractitionerList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference(xml, 'managingOrganization', value.managingOrganization);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.link_List.Count - 1 do
      ComposePatientLink(xml, 'link', value.link_List[i]);
end;

{$ENDIF FHIR_PATIENT}
{$IFDEF FHIR_PAYMENTNOTICE}
function TFHIRXmlParser.ParsePaymentNotice(element : TMXmlElement; path : string) : TFhirPaymentNotice;
var
  child : TMXmlElement;
begin
  result := TFhirPaymentNotice.Create;
  try
    parseDomainResourceAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParsePaymentNoticeChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParsePaymentNoticeChild(value : TFhirPaymentNotice; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'identifier') then
        value.identifierList.Add(ParseIdentifier(child, path+'/identifier'))
      else if (child.localName = 'status') then
        value.statusElement := ParseEnum(CODES_TFhirFinancialResourceStatusCodesEnum, SYSTEMS_TFhirFinancialResourceStatusCodesEnum, child, path+'/status')
      else if (child.localName = 'request') then
        value.request := ParseReference(child, path+'/request')
      else if (child.localName = 'response') then
        value.response := ParseReference(child, path+'/response')
      else if (child.localName = 'created') then
        value.createdElement := ParseDateTime(child, path+'/created')
      else if (child.localName = 'provider') then
        value.provider := ParseReference(child, path+'/provider')
      else if (child.localName = 'payment') then
        value.payment := ParseReference(child, path+'/payment')
      else if (child.localName = 'paymentDate') then
        value.paymentDateElement := ParseDate(child, path+'/paymentDate')
      else if (child.localName = 'payee') then
        value.payee := ParseReference(child, path+'/payee')
      else if (child.localName = 'recipient') then
        value.recipient := ParseReference(child, path+'/recipient')
      else if (child.localName = 'amount') then
        value.amount := ParseMoney(child, path+'/amount')
      else if (child.localName = 'paymentStatus') then
        value.paymentStatus := ParseCodeableConcept(child, path+'/paymentStatus')
      else if Not ParseDomainResourceChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposePaymentNotice(xml : TXmlBuilder; name : String; value : TFhirPaymentNotice);
begin
  if (value = nil) then
    exit;
  composeDomainResourceAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composePaymentNoticeChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposePaymentNoticeChildren(xml : TXmlBuilder; value : TFhirPaymentNotice);
var
  i : integer;
begin
  composeDomainResourceChildren(xml, value);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.identifierList.Count - 1 do
      ComposeIdentifier(xml, 'identifier', value.identifierList[i]);
  ComposeEnum(xml, 'status', value.statusElement, CODES_TFhirFinancialResourceStatusCodesEnum);
  if (SummaryOption in [soFull, soData]) then
    ComposeReference(xml, 'request', value.request);
  if (SummaryOption in [soFull, soData]) then
    ComposeReference(xml, 'response', value.response);
  ComposeDateTime(xml, 'created', value.createdElement);
  if (SummaryOption in [soFull, soData]) then
    ComposeReference(xml, 'provider', value.provider);
  ComposeReference(xml, 'payment', value.payment);
  if (SummaryOption in [soFull, soData]) then
    ComposeDate(xml, 'paymentDate', value.paymentDateElement);
  if (SummaryOption in [soFull, soData]) then
    ComposeReference(xml, 'payee', value.payee);
  ComposeReference(xml, 'recipient', value.recipient);
  ComposeMoney(xml, 'amount', value.amount);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(xml, 'paymentStatus', value.paymentStatus);
end;

{$ENDIF FHIR_PAYMENTNOTICE}
{$IFDEF FHIR_PAYMENTRECONCILIATION}
function TFHIRXmlParser.ParsePaymentReconciliationAllocation(element : TMXmlElement; path : string) : TFhirPaymentReconciliationAllocation;
var
  child : TMXmlElement;
begin
  result := TFhirPaymentReconciliationAllocation.Create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParsePaymentReconciliationAllocationChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParsePaymentReconciliationAllocationChild(value : TFhirPaymentReconciliationAllocation; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'identifier') then
        value.identifier := ParseIdentifier(child, path+'/identifier')
      else if (child.localName = 'predecessor') then
        value.predecessor := ParseIdentifier(child, path+'/predecessor')
      else if (child.localName = 'target') then
        value.target := ParseReference(child, path+'/target')
      else if (child.localName = 'targetItemIdentifier') then
        value.targetItem := ParseIdentifier(child, path+'/targetItemIdentifier')
      else if (child.localName = 'targetItemPositiveInt') then
        value.targetItem := ParsePositiveInt(child, path+'/targetItemPositiveInt')
      else if (child.localName = 'targetItemString') then
        value.targetItem := ParseString(child, path+'/targetItemString')
      else if (child.localName = 'encounter') then
        value.encounter := ParseReference(child, path+'/encounter')
      else if (child.localName = 'account') then
        value.account := ParseReference(child, path+'/account')
      else if (child.localName = 'type') then
        value.type_ := ParseCodeableConcept(child, path+'/type')
      else if (child.localName = 'submitter') then
        value.submitter := ParseReference(child, path+'/submitter')
      else if (child.localName = 'response') then
        value.response := ParseReference(child, path+'/response')
      else if (child.localName = 'date') then
        value.dateElement := ParseDate(child, path+'/date')
      else if (child.localName = 'responsible') then
        value.responsible := ParseReference(child, path+'/responsible')
      else if (child.localName = 'payee') then
        value.payee := ParseReference(child, path+'/payee')
      else if (child.localName = 'amount') then
        value.amount := ParseMoney(child, path+'/amount')
      else if Not ParseBackboneElementChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposePaymentReconciliationAllocation(xml : TXmlBuilder; name : String; value : TFhirPaymentReconciliationAllocation);
begin
  if (value = nil) then
    exit;
  composeElementAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composePaymentReconciliationAllocationChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposePaymentReconciliationAllocationChildren(xml : TXmlBuilder; value : TFhirPaymentReconciliationAllocation);
begin
  composeBackboneElementChildren(xml, value);
  if (SummaryOption in [soFull, soData]) then
    ComposeIdentifier(xml, 'identifier', value.identifier);
  if (SummaryOption in [soFull, soData]) then
    ComposeIdentifier(xml, 'predecessor', value.predecessor);
  if (SummaryOption in [soFull, soData]) then
    ComposeReference(xml, 'target', value.target);
  if (SummaryOption in [soFull, soData]) and (value.targetItem is TFhirIdentifier) {6} then
    ComposeIdentifier(xml, 'targetItemIdentifier', TFhirIdentifier(value.targetItem))
  else if (SummaryOption in [soFull, soData]) and (value.targetItem is TFhirPositiveInt) {6} then
    ComposePositiveInt(xml, 'targetItemPositiveInt', TFhirPositiveInt(value.targetItem))
  else if (SummaryOption in [soFull, soData]) and (value.targetItem is TFhirString) {6} then
    ComposeString(xml, 'targetItemString', TFhirString(value.targetItem));
  if (SummaryOption in [soFull, soData]) then
    ComposeReference(xml, 'encounter', value.encounter);
  if (SummaryOption in [soFull, soData]) then
    ComposeReference(xml, 'account', value.account);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(xml, 'type', value.type_);
  if (SummaryOption in [soFull, soData]) then
    ComposeReference(xml, 'submitter', value.submitter);
  if (SummaryOption in [soFull, soData]) then
    ComposeReference(xml, 'response', value.response);
  if (SummaryOption in [soFull, soData]) then
    ComposeDate(xml, 'date', value.dateElement);
  if (SummaryOption in [soFull, soData]) then
    ComposeReference(xml, 'responsible', value.responsible);
  if (SummaryOption in [soFull, soData]) then
    ComposeReference(xml, 'payee', value.payee);
  if (SummaryOption in [soFull, soData]) then
    ComposeMoney(xml, 'amount', value.amount);
end;

function TFHIRXmlParser.ParsePaymentReconciliationProcessNote(element : TMXmlElement; path : string) : TFhirPaymentReconciliationProcessNote;
var
  child : TMXmlElement;
begin
  result := TFhirPaymentReconciliationProcessNote.Create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParsePaymentReconciliationProcessNoteChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParsePaymentReconciliationProcessNoteChild(value : TFhirPaymentReconciliationProcessNote; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'type') then
        value.type_Element := ParseEnum(CODES_TFhirNoteTypeEnum, SYSTEMS_TFhirNoteTypeEnum, child, path+'/type')
      else if (child.localName = 'text') then
        value.textElement := ParseString(child, path+'/text')
      else if Not ParseBackboneElementChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposePaymentReconciliationProcessNote(xml : TXmlBuilder; name : String; value : TFhirPaymentReconciliationProcessNote);
begin
  if (value = nil) then
    exit;
  composeElementAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composePaymentReconciliationProcessNoteChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposePaymentReconciliationProcessNoteChildren(xml : TXmlBuilder; value : TFhirPaymentReconciliationProcessNote);
begin
  composeBackboneElementChildren(xml, value);
  if (SummaryOption in [soFull, soData]) then
    ComposeEnum(xml, 'type', value.type_Element, CODES_TFhirNoteTypeEnum);
  if (SummaryOption in [soFull, soData]) then
    ComposeString(xml, 'text', value.textElement);
end;

function TFHIRXmlParser.ParsePaymentReconciliation(element : TMXmlElement; path : string) : TFhirPaymentReconciliation;
var
  child : TMXmlElement;
begin
  result := TFhirPaymentReconciliation.Create;
  try
    parseDomainResourceAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParsePaymentReconciliationChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParsePaymentReconciliationChild(value : TFhirPaymentReconciliation; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'identifier') then
        value.identifierList.Add(ParseIdentifier(child, path+'/identifier'))
      else if (child.localName = 'type') then
        value.type_ := ParseCodeableConcept(child, path+'/type')
      else if (child.localName = 'status') then
        value.statusElement := ParseEnum(CODES_TFhirFinancialResourceStatusCodesEnum, SYSTEMS_TFhirFinancialResourceStatusCodesEnum, child, path+'/status')
      else if (child.localName = 'kind') then
        value.kind := ParseCodeableConcept(child, path+'/kind')
      else if (child.localName = 'period') then
        value.period := ParsePeriod(child, path+'/period')
      else if (child.localName = 'created') then
        value.createdElement := ParseDateTime(child, path+'/created')
      else if (child.localName = 'enterer') then
        value.enterer := ParseReference(child, path+'/enterer')
      else if (child.localName = 'issuerType') then
        value.issuerType := ParseCodeableConcept(child, path+'/issuerType')
      else if (child.localName = 'paymentIssuer') then
        value.paymentIssuer := ParseReference(child, path+'/paymentIssuer')
      else if (child.localName = 'request') then
        value.request := ParseReference(child, path+'/request')
      else if (child.localName = 'requestor') then
        value.requestor := ParseReference(child, path+'/requestor')
      else if (child.localName = 'outcome') then
        value.outcomeElement := ParseEnum(CODES_TFhirPaymentOutcomeEnum, SYSTEMS_TFhirPaymentOutcomeEnum, child, path+'/outcome')
      else if (child.localName = 'disposition') then
        value.dispositionElement := ParseString(child, path+'/disposition')
      else if (child.localName = 'date') then
        value.dateElement := ParseDate(child, path+'/date')
      else if (child.localName = 'location') then
        value.location := ParseReference(child, path+'/location')
      else if (child.localName = 'method') then
        value.method := ParseCodeableConcept(child, path+'/method')
      else if (child.localName = 'cardBrand') then
        value.cardBrandElement := ParseString(child, path+'/cardBrand')
      else if (child.localName = 'accountNumber') then
        value.accountNumberElement := ParseString(child, path+'/accountNumber')
      else if (child.localName = 'expirationDate') then
        value.expirationDateElement := ParseDate(child, path+'/expirationDate')
      else if (child.localName = 'processor') then
        value.processorElement := ParseString(child, path+'/processor')
      else if (child.localName = 'referenceNumber') then
        value.referenceNumberElement := ParseString(child, path+'/referenceNumber')
      else if (child.localName = 'authorization') then
        value.authorizationElement := ParseString(child, path+'/authorization')
      else if (child.localName = 'tenderedAmount') then
        value.tenderedAmount := ParseMoney(child, path+'/tenderedAmount')
      else if (child.localName = 'returnedAmount') then
        value.returnedAmount := ParseMoney(child, path+'/returnedAmount')
      else if (child.localName = 'amount') then
        value.amount := ParseMoney(child, path+'/amount')
      else if (child.localName = 'paymentIdentifier') then
        value.paymentIdentifier := ParseIdentifier(child, path+'/paymentIdentifier')
      else if (child.localName = 'allocation') then
        value.allocationList.Add(ParsePaymentReconciliationAllocation(child, path+'/allocation'))
      else if (child.localName = 'formCode') then
        value.formCode := ParseCodeableConcept(child, path+'/formCode')
      else if (child.localName = 'processNote') then
        value.processNoteList.Add(ParsePaymentReconciliationProcessNote(child, path+'/processNote'))
      else if Not ParseDomainResourceChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposePaymentReconciliation(xml : TXmlBuilder; name : String; value : TFhirPaymentReconciliation);
begin
  if (value = nil) then
    exit;
  composeDomainResourceAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composePaymentReconciliationChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposePaymentReconciliationChildren(xml : TXmlBuilder; value : TFhirPaymentReconciliation);
var
  i : integer;
begin
  composeDomainResourceChildren(xml, value);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.identifierList.Count - 1 do
      ComposeIdentifier(xml, 'identifier', value.identifierList[i]);
  ComposeCodeableConcept(xml, 'type', value.type_);
  ComposeEnum(xml, 'status', value.statusElement, CODES_TFhirFinancialResourceStatusCodesEnum);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(xml, 'kind', value.kind);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposePeriod(xml, 'period', value.period);
  ComposeDateTime(xml, 'created', value.createdElement);
  if (SummaryOption in [soFull, soData]) then
    ComposeReference(xml, 'enterer', value.enterer);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(xml, 'issuerType', value.issuerType);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference(xml, 'paymentIssuer', value.paymentIssuer);
  if (SummaryOption in [soFull, soData]) then
    ComposeReference(xml, 'request', value.request);
  if (SummaryOption in [soFull, soData]) then
    ComposeReference(xml, 'requestor', value.requestor);
  if (SummaryOption in [soFull, soData]) then
    ComposeEnum(xml, 'outcome', value.outcomeElement, CODES_TFhirPaymentOutcomeEnum);
  if (SummaryOption in [soFull, soData]) then
    ComposeString(xml, 'disposition', value.dispositionElement);
  ComposeDate(xml, 'date', value.dateElement);
  if (SummaryOption in [soFull, soData]) then
    ComposeReference(xml, 'location', value.location);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(xml, 'method', value.method);
  if (SummaryOption in [soFull, soData]) then
    ComposeString(xml, 'cardBrand', value.cardBrandElement);
  if (SummaryOption in [soFull, soData]) then
    ComposeString(xml, 'accountNumber', value.accountNumberElement);
  if (SummaryOption in [soFull, soData]) then
    ComposeDate(xml, 'expirationDate', value.expirationDateElement);
  if (SummaryOption in [soFull, soData]) then
    ComposeString(xml, 'processor', value.processorElement);
  if (SummaryOption in [soFull, soData]) then
    ComposeString(xml, 'referenceNumber', value.referenceNumberElement);
  if (SummaryOption in [soFull, soData]) then
    ComposeString(xml, 'authorization', value.authorizationElement);
  if (SummaryOption in [soFull, soData]) then
    ComposeMoney(xml, 'tenderedAmount', value.tenderedAmount);
  if (SummaryOption in [soFull, soData]) then
    ComposeMoney(xml, 'returnedAmount', value.returnedAmount);
  ComposeMoney(xml, 'amount', value.amount);
  if (SummaryOption in [soFull, soData]) then
    ComposeIdentifier(xml, 'paymentIdentifier', value.paymentIdentifier);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.allocationList.Count - 1 do
      ComposePaymentReconciliationAllocation(xml, 'allocation', value.allocationList[i]);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(xml, 'formCode', value.formCode);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.processNoteList.Count - 1 do
      ComposePaymentReconciliationProcessNote(xml, 'processNote', value.processNoteList[i]);
end;

{$ENDIF FHIR_PAYMENTRECONCILIATION}
{$IFDEF FHIR_PERMISSION}
function TFHIRXmlParser.ParsePermissionJustification(element : TMXmlElement; path : string) : TFhirPermissionJustification;
var
  child : TMXmlElement;
begin
  result := TFhirPermissionJustification.Create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParsePermissionJustificationChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParsePermissionJustificationChild(value : TFhirPermissionJustification; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'basis') then
        value.basisList.Add(ParseCodeableConcept(child, path+'/basis'))
      else if (child.localName = 'evidence') then
        value.evidenceList.Add(ParseReference(child, path+'/evidence'))
      else if Not ParseBackboneElementChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposePermissionJustification(xml : TXmlBuilder; name : String; value : TFhirPermissionJustification);
begin
  if (value = nil) then
    exit;
  composeElementAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composePermissionJustificationChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposePermissionJustificationChildren(xml : TXmlBuilder; value : TFhirPermissionJustification);
var
  i : integer;
begin
  composeBackboneElementChildren(xml, value);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.basisList.Count - 1 do
      ComposeCodeableConcept(xml, 'basis', value.basisList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.evidenceList.Count - 1 do
      ComposeReference(xml, 'evidence', value.evidenceList[i]);
end;

function TFHIRXmlParser.ParsePermissionRule(element : TMXmlElement; path : string) : TFhirPermissionRule;
var
  child : TMXmlElement;
begin
  result := TFhirPermissionRule.Create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParsePermissionRuleChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParsePermissionRuleChild(value : TFhirPermissionRule; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'type') then
        value.type_Element := ParseEnum(CODES_TFhirConsentProvisionTypeEnum, SYSTEMS_TFhirConsentProvisionTypeEnum, child, path+'/type')
      else if (child.localName = 'data') then
        value.dataList.Add(ParsePermissionRuleData(child, path+'/data'))
      else if (child.localName = 'activity') then
        value.activityList.Add(ParsePermissionRuleActivity(child, path+'/activity'))
      else if (child.localName = 'limit') then
        value.limitList.Add(ParseCodeableConcept(child, path+'/limit'))
      else if Not ParseBackboneElementChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposePermissionRule(xml : TXmlBuilder; name : String; value : TFhirPermissionRule);
begin
  if (value = nil) then
    exit;
  composeElementAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composePermissionRuleChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposePermissionRuleChildren(xml : TXmlBuilder; value : TFhirPermissionRule);
var
  i : integer;
begin
  composeBackboneElementChildren(xml, value);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeEnum(xml, 'type', value.type_Element, CODES_TFhirConsentProvisionTypeEnum);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.dataList.Count - 1 do
      ComposePermissionRuleData(xml, 'data', value.dataList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.activityList.Count - 1 do
      ComposePermissionRuleActivity(xml, 'activity', value.activityList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.limitList.Count - 1 do
      ComposeCodeableConcept(xml, 'limit', value.limitList[i]);
end;

function TFHIRXmlParser.ParsePermissionRuleData(element : TMXmlElement; path : string) : TFhirPermissionRuleData;
var
  child : TMXmlElement;
begin
  result := TFhirPermissionRuleData.Create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParsePermissionRuleDataChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParsePermissionRuleDataChild(value : TFhirPermissionRuleData; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'resource') then
        value.resourceList.Add(ParsePermissionRuleDataResource(child, path+'/resource'))
      else if (child.localName = 'security') then
        value.securityList.Add(ParseCoding(child, path+'/security'))
      else if (child.localName = 'period') then
        value.periodList.Add(ParsePeriod(child, path+'/period'))
      else if (child.localName = 'expression') then
        value.expression := ParseExpression(child, path+'/expression')
      else if Not ParseBackboneElementChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposePermissionRuleData(xml : TXmlBuilder; name : String; value : TFhirPermissionRuleData);
begin
  if (value = nil) then
    exit;
  composeElementAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composePermissionRuleDataChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposePermissionRuleDataChildren(xml : TXmlBuilder; value : TFhirPermissionRuleData);
var
  i : integer;
begin
  composeBackboneElementChildren(xml, value);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.resourceList.Count - 1 do
      ComposePermissionRuleDataResource(xml, 'resource', value.resourceList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.securityList.Count - 1 do
      ComposeCoding(xml, 'security', value.securityList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.periodList.Count - 1 do
      ComposePeriod(xml, 'period', value.periodList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeExpression(xml, 'expression', value.expression);
end;

function TFHIRXmlParser.ParsePermissionRuleDataResource(element : TMXmlElement; path : string) : TFhirPermissionRuleDataResource;
var
  child : TMXmlElement;
begin
  result := TFhirPermissionRuleDataResource.Create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParsePermissionRuleDataResourceChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParsePermissionRuleDataResourceChild(value : TFhirPermissionRuleDataResource; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'meaning') then
        value.meaningElement := ParseEnum(CODES_TFhirConsentDataMeaningEnum, SYSTEMS_TFhirConsentDataMeaningEnum, child, path+'/meaning')
      else if (child.localName = 'reference') then
        value.reference := ParseReference(child, path+'/reference')
      else if Not ParseBackboneElementChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposePermissionRuleDataResource(xml : TXmlBuilder; name : String; value : TFhirPermissionRuleDataResource);
begin
  if (value = nil) then
    exit;
  composeElementAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composePermissionRuleDataResourceChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposePermissionRuleDataResourceChildren(xml : TXmlBuilder; value : TFhirPermissionRuleDataResource);
begin
  composeBackboneElementChildren(xml, value);
  ComposeEnum(xml, 'meaning', value.meaningElement, CODES_TFhirConsentDataMeaningEnum);
  ComposeReference(xml, 'reference', value.reference);
end;

function TFHIRXmlParser.ParsePermissionRuleActivity(element : TMXmlElement; path : string) : TFhirPermissionRuleActivity;
var
  child : TMXmlElement;
begin
  result := TFhirPermissionRuleActivity.Create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParsePermissionRuleActivityChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParsePermissionRuleActivityChild(value : TFhirPermissionRuleActivity; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'actor') then
        value.actorList.Add(ParseReference(child, path+'/actor'))
      else if (child.localName = 'action') then
        value.actionList.Add(ParseCodeableConcept(child, path+'/action'))
      else if (child.localName = 'purpose') then
        value.purposeList.Add(ParseCodeableConcept(child, path+'/purpose'))
      else if Not ParseBackboneElementChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposePermissionRuleActivity(xml : TXmlBuilder; name : String; value : TFhirPermissionRuleActivity);
begin
  if (value = nil) then
    exit;
  composeElementAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composePermissionRuleActivityChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposePermissionRuleActivityChildren(xml : TXmlBuilder; value : TFhirPermissionRuleActivity);
var
  i : integer;
begin
  composeBackboneElementChildren(xml, value);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.actorList.Count - 1 do
      ComposeReference(xml, 'actor', value.actorList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.actionList.Count - 1 do
      ComposeCodeableConcept(xml, 'action', value.actionList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.purposeList.Count - 1 do
      ComposeCodeableConcept(xml, 'purpose', value.purposeList[i]);
end;

function TFHIRXmlParser.ParsePermission(element : TMXmlElement; path : string) : TFhirPermission;
var
  child : TMXmlElement;
begin
  result := TFhirPermission.Create;
  try
    parseDomainResourceAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParsePermissionChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParsePermissionChild(value : TFhirPermission; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'status') then
        value.statusElement := ParseEnum(CODES_TFhirPermissionStatusEnum, SYSTEMS_TFhirPermissionStatusEnum, child, path+'/status')
      else if (child.localName = 'asserter') then
        value.asserter := ParseReference(child, path+'/asserter')
      else if (child.localName = 'date') then
        value.dateList.Add(ParseDateTime(child, path+'/date'))
      else if (child.localName = 'validity') then
        value.validity := ParsePeriod(child, path+'/validity')
      else if (child.localName = 'justification') then
        value.justification := ParsePermissionJustification(child, path+'/justification')
      else if (child.localName = 'combining') then
        value.combiningElement := ParseEnum(CODES_TFhirPermissionRuleCombiningEnum, SYSTEMS_TFhirPermissionRuleCombiningEnum, child, path+'/combining')
      else if (child.localName = 'rule') then
        value.ruleList.Add(ParsePermissionRule(child, path+'/rule'))
      else if Not ParseDomainResourceChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposePermission(xml : TXmlBuilder; name : String; value : TFhirPermission);
begin
  if (value = nil) then
    exit;
  composeDomainResourceAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composePermissionChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposePermissionChildren(xml : TXmlBuilder; value : TFhirPermission);
var
  i : integer;
begin
  composeDomainResourceChildren(xml, value);
  ComposeEnum(xml, 'status', value.statusElement, CODES_TFhirPermissionStatusEnum);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference(xml, 'asserter', value.asserter);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.dateList.Count - 1 do
      ComposeDateTime(xml, 'date', value.dateList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposePeriod(xml, 'validity', value.validity);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposePermissionJustification(xml, 'justification', value.justification);
  ComposeEnum(xml, 'combining', value.combiningElement, CODES_TFhirPermissionRuleCombiningEnum);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.ruleList.Count - 1 do
      ComposePermissionRule(xml, 'rule', value.ruleList[i]);
end;

{$ENDIF FHIR_PERMISSION}
{$IFDEF FHIR_PERSON}
function TFHIRXmlParser.ParsePersonCommunication(element : TMXmlElement; path : string) : TFhirPersonCommunication;
var
  child : TMXmlElement;
begin
  result := TFhirPersonCommunication.Create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParsePersonCommunicationChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParsePersonCommunicationChild(value : TFhirPersonCommunication; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'language') then
        value.language := ParseCodeableConcept(child, path+'/language')
      else if (child.localName = 'preferred') then
        value.preferredElement := ParseBoolean(child, path+'/preferred')
      else if Not ParseBackboneElementChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposePersonCommunication(xml : TXmlBuilder; name : String; value : TFhirPersonCommunication);
begin
  if (value = nil) then
    exit;
  composeElementAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composePersonCommunicationChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposePersonCommunicationChildren(xml : TXmlBuilder; value : TFhirPersonCommunication);
begin
  composeBackboneElementChildren(xml, value);
  ComposeCodeableConcept(xml, 'language', value.language);
  if (SummaryOption in [soFull, soData]) then
    ComposeBoolean(xml, 'preferred', value.preferredElement);
end;

function TFHIRXmlParser.ParsePersonLink(element : TMXmlElement; path : string) : TFhirPersonLink;
var
  child : TMXmlElement;
begin
  result := TFhirPersonLink.Create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParsePersonLinkChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParsePersonLinkChild(value : TFhirPersonLink; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'target') then
        value.target := ParseReference(child, path+'/target')
      else if (child.localName = 'assurance') then
        value.assuranceElement := ParseEnum(CODES_TFhirIdentityAssuranceLevelEnum, SYSTEMS_TFhirIdentityAssuranceLevelEnum, child, path+'/assurance')
      else if Not ParseBackboneElementChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposePersonLink(xml : TXmlBuilder; name : String; value : TFhirPersonLink);
begin
  if (value = nil) then
    exit;
  composeElementAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composePersonLinkChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposePersonLinkChildren(xml : TXmlBuilder; value : TFhirPersonLink);
begin
  composeBackboneElementChildren(xml, value);
  ComposeReference(xml, 'target', value.target);
  if (SummaryOption in [soFull, soData]) then
    ComposeEnum(xml, 'assurance', value.assuranceElement, CODES_TFhirIdentityAssuranceLevelEnum);
end;

function TFHIRXmlParser.ParsePerson(element : TMXmlElement; path : string) : TFhirPerson;
var
  child : TMXmlElement;
begin
  result := TFhirPerson.Create;
  try
    parseDomainResourceAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParsePersonChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParsePersonChild(value : TFhirPerson; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'identifier') then
        value.identifierList.Add(ParseIdentifier(child, path+'/identifier'))
      else if (child.localName = 'active') then
        value.activeElement := ParseBoolean(child, path+'/active')
      else if (child.localName = 'name') then
        value.nameList.Add(ParseHumanName(child, path+'/name'))
      else if (child.localName = 'telecom') then
        value.telecomList.Add(ParseContactPoint(child, path+'/telecom'))
      else if (child.localName = 'gender') then
        value.genderElement := ParseEnum(CODES_TFhirAdministrativeGenderEnum, SYSTEMS_TFhirAdministrativeGenderEnum, child, path+'/gender')
      else if (child.localName = 'birthDate') then
        value.birthDateElement := ParseDate(child, path+'/birthDate')
      else if (child.localName = 'deceasedBoolean') then
        value.deceased := ParseBoolean(child, path+'/deceasedBoolean')
      else if (child.localName = 'deceasedDateTime') then
        value.deceased := ParseDateTime(child, path+'/deceasedDateTime')
      else if (child.localName = 'address') then
        value.addressList.Add(ParseAddress(child, path+'/address'))
      else if (child.localName = 'maritalStatus') then
        value.maritalStatus := ParseCodeableConcept(child, path+'/maritalStatus')
      else if (child.localName = 'photo') then
        value.photoList.Add(ParseAttachment(child, path+'/photo'))
      else if (child.localName = 'communication') then
        value.communicationList.Add(ParsePersonCommunication(child, path+'/communication'))
      else if (child.localName = 'managingOrganization') then
        value.managingOrganization := ParseReference(child, path+'/managingOrganization')
      else if (child.localName = 'link') then
        value.link_List.Add(ParsePersonLink(child, path+'/link'))
      else if Not ParseDomainResourceChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposePerson(xml : TXmlBuilder; name : String; value : TFhirPerson);
begin
  if (value = nil) then
    exit;
  composeDomainResourceAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composePersonChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposePersonChildren(xml : TXmlBuilder; value : TFhirPerson);
var
  i : integer;
begin
  composeDomainResourceChildren(xml, value);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.identifierList.Count - 1 do
      ComposeIdentifier(xml, 'identifier', value.identifierList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeBoolean(xml, 'active', value.activeElement);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.nameList.Count - 1 do
      ComposeHumanName(xml, 'name', value.nameList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.telecomList.Count - 1 do
      ComposeContactPoint(xml, 'telecom', value.telecomList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeEnum(xml, 'gender', value.genderElement, CODES_TFhirAdministrativeGenderEnum);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDate(xml, 'birthDate', value.birthDateElement);
  if (SummaryOption in [soFull, soSummary, soData]) and (value.deceased is TFhirBoolean) {6} then
    ComposeBoolean(xml, 'deceasedBoolean', TFhirBoolean(value.deceased))
  else if (SummaryOption in [soFull, soSummary, soData]) and (value.deceased is TFhirDateTime) {6} then
    ComposeDateTime(xml, 'deceasedDateTime', TFhirDateTime(value.deceased));
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.addressList.Count - 1 do
      ComposeAddress(xml, 'address', value.addressList[i]);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(xml, 'maritalStatus', value.maritalStatus);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.photoList.Count - 1 do
      ComposeAttachment(xml, 'photo', value.photoList[i]);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.communicationList.Count - 1 do
      ComposePersonCommunication(xml, 'communication', value.communicationList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference(xml, 'managingOrganization', value.managingOrganization);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.link_List.Count - 1 do
      ComposePersonLink(xml, 'link', value.link_List[i]);
end;

{$ENDIF FHIR_PERSON}
{$IFDEF FHIR_PLANDEFINITION}
function TFHIRXmlParser.ParsePlanDefinitionGoal(element : TMXmlElement; path : string) : TFhirPlanDefinitionGoal;
var
  child : TMXmlElement;
begin
  result := TFhirPlanDefinitionGoal.Create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParsePlanDefinitionGoalChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParsePlanDefinitionGoalChild(value : TFhirPlanDefinitionGoal; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'category') then
        value.category := ParseCodeableConcept(child, path+'/category')
      else if (child.localName = 'description') then
        value.description := ParseCodeableConcept(child, path+'/description')
      else if (child.localName = 'priority') then
        value.priority := ParseCodeableConcept(child, path+'/priority')
      else if (child.localName = 'start') then
        value.start := ParseCodeableConcept(child, path+'/start')
      else if (child.localName = 'addresses') then
        value.addressesList.Add(ParseCodeableConcept(child, path+'/addresses'))
      else if (child.localName = 'documentation') then
        value.documentationList.Add(ParseRelatedArtifact(child, path+'/documentation'))
      else if (child.localName = 'target') then
        value.targetList.Add(ParsePlanDefinitionGoalTarget(child, path+'/target'))
      else if Not ParseBackboneElementChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposePlanDefinitionGoal(xml : TXmlBuilder; name : String; value : TFhirPlanDefinitionGoal);
begin
  if (value = nil) then
    exit;
  composeElementAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composePlanDefinitionGoalChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposePlanDefinitionGoalChildren(xml : TXmlBuilder; value : TFhirPlanDefinitionGoal);
var
  i : integer;
begin
  composeBackboneElementChildren(xml, value);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(xml, 'category', value.category);
  ComposeCodeableConcept(xml, 'description', value.description);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(xml, 'priority', value.priority);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(xml, 'start', value.start);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.addressesList.Count - 1 do
      ComposeCodeableConcept(xml, 'addresses', value.addressesList[i]);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.documentationList.Count - 1 do
      ComposeRelatedArtifact(xml, 'documentation', value.documentationList[i]);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.targetList.Count - 1 do
      ComposePlanDefinitionGoalTarget(xml, 'target', value.targetList[i]);
end;

function TFHIRXmlParser.ParsePlanDefinitionGoalTarget(element : TMXmlElement; path : string) : TFhirPlanDefinitionGoalTarget;
var
  child : TMXmlElement;
begin
  result := TFhirPlanDefinitionGoalTarget.Create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParsePlanDefinitionGoalTargetChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParsePlanDefinitionGoalTargetChild(value : TFhirPlanDefinitionGoalTarget; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'measure') then
        value.measure := ParseCodeableConcept(child, path+'/measure')
      else if (child.localName = 'detailQuantity') then
        value.detail := ParseQuantity(child, path+'/detailQuantity')
      else if (child.localName = 'detailRange') then
        value.detail := ParseRange(child, path+'/detailRange')
      else if (child.localName = 'detailCodeableConcept') then
        value.detail := ParseCodeableConcept(child, path+'/detailCodeableConcept')
      else if (child.localName = 'detailRatio') then
        value.detail := ParseRatio(child, path+'/detailRatio')
      else if (child.localName = 'detailString') then
        value.detail := ParseString(child, path+'/detailString')
      else if (child.localName = 'detailBoolean') then
        value.detail := ParseBoolean(child, path+'/detailBoolean')
      else if (child.localName = 'detailInteger') then
        value.detail := ParseInteger(child, path+'/detailInteger')
      else if (child.localName = 'due') then
        value.due := ParseDuration(child, path+'/due')
      else if Not ParseBackboneElementChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposePlanDefinitionGoalTarget(xml : TXmlBuilder; name : String; value : TFhirPlanDefinitionGoalTarget);
begin
  if (value = nil) then
    exit;
  composeElementAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composePlanDefinitionGoalTargetChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposePlanDefinitionGoalTargetChildren(xml : TXmlBuilder; value : TFhirPlanDefinitionGoalTarget);
begin
  composeBackboneElementChildren(xml, value);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(xml, 'measure', value.measure);
  if (SummaryOption in [soFull, soData]) and (value.detail is TFhirQuantity) {6} then
    ComposeQuantity(xml, 'detailQuantity', TFhirQuantity(value.detail))
  else if (SummaryOption in [soFull, soData]) and (value.detail is TFhirRange) {6} then
    ComposeRange(xml, 'detailRange', TFhirRange(value.detail))
  else if (SummaryOption in [soFull, soData]) and (value.detail is TFhirCodeableConcept) {6} then
    ComposeCodeableConcept(xml, 'detailCodeableConcept', TFhirCodeableConcept(value.detail))
  else if (SummaryOption in [soFull, soData]) and (value.detail is TFhirRatio) {6} then
    ComposeRatio(xml, 'detailRatio', TFhirRatio(value.detail))
  else if (SummaryOption in [soFull, soData]) and (value.detail is TFhirString) {6} then
    ComposeString(xml, 'detailString', TFhirString(value.detail))
  else if (SummaryOption in [soFull, soData]) and (value.detail is TFhirBoolean) {6} then
    ComposeBoolean(xml, 'detailBoolean', TFhirBoolean(value.detail))
  else if (SummaryOption in [soFull, soData]) and (value.detail is TFhirInteger) {6} then
    ComposeInteger(xml, 'detailInteger', TFhirInteger(value.detail));
  if (SummaryOption in [soFull, soData]) then
    ComposeDuration(xml, 'due', value.due);
end;

function TFHIRXmlParser.ParsePlanDefinitionActor(element : TMXmlElement; path : string) : TFhirPlanDefinitionActor;
var
  child : TMXmlElement;
begin
  result := TFhirPlanDefinitionActor.Create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParsePlanDefinitionActorChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParsePlanDefinitionActorChild(value : TFhirPlanDefinitionActor; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'title') then
        value.titleElement := ParseString(child, path+'/title')
      else if (child.localName = 'description') then
        value.descriptionElement := ParseMarkdown(child, path+'/description')
      else if (child.localName = 'option') then
        value.optionList.Add(ParsePlanDefinitionActorOption(child, path+'/option'))
      else if Not ParseBackboneElementChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposePlanDefinitionActor(xml : TXmlBuilder; name : String; value : TFhirPlanDefinitionActor);
begin
  if (value = nil) then
    exit;
  composeElementAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composePlanDefinitionActorChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposePlanDefinitionActorChildren(xml : TXmlBuilder; value : TFhirPlanDefinitionActor);
var
  i : integer;
begin
  composeBackboneElementChildren(xml, value);
  if (SummaryOption in [soFull, soData]) then
    ComposeString(xml, 'title', value.titleElement);
  if (SummaryOption in [soFull, soData]) then
    ComposeMarkdown(xml, 'description', value.descriptionElement);
  for i := 0 to value.optionList.Count - 1 do
      ComposePlanDefinitionActorOption(xml, 'option', value.optionList[i]);
end;

function TFHIRXmlParser.ParsePlanDefinitionActorOption(element : TMXmlElement; path : string) : TFhirPlanDefinitionActorOption;
var
  child : TMXmlElement;
begin
  result := TFhirPlanDefinitionActorOption.Create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParsePlanDefinitionActorOptionChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParsePlanDefinitionActorOptionChild(value : TFhirPlanDefinitionActorOption; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'type') then
        value.type_Element := ParseEnum(CODES_TFhirActionParticipantTypeEnum, SYSTEMS_TFhirActionParticipantTypeEnum, child, path+'/type')
      else if (child.localName = 'typeCanonical') then
        value.typeCanonicalElement := ParseCanonical(child, path+'/typeCanonical')
      else if (child.localName = 'typeReference') then
        value.typeReference := ParseReference(child, path+'/typeReference')
      else if (child.localName = 'role') then
        value.role := ParseCodeableConcept(child, path+'/role')
      else if Not ParseBackboneElementChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposePlanDefinitionActorOption(xml : TXmlBuilder; name : String; value : TFhirPlanDefinitionActorOption);
begin
  if (value = nil) then
    exit;
  composeElementAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composePlanDefinitionActorOptionChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposePlanDefinitionActorOptionChildren(xml : TXmlBuilder; value : TFhirPlanDefinitionActorOption);
begin
  composeBackboneElementChildren(xml, value);
  if (SummaryOption in [soFull, soData]) then
    ComposeEnum(xml, 'type', value.type_Element, CODES_TFhirActionParticipantTypeEnum);
  if (SummaryOption in [soFull, soData]) then
    ComposeCanonical(xml, 'typeCanonical', value.typeCanonicalElement);
  if (SummaryOption in [soFull, soData]) then
    ComposeReference(xml, 'typeReference', value.typeReference);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(xml, 'role', value.role);
end;

function TFHIRXmlParser.ParsePlanDefinitionAction(element : TMXmlElement; path : string) : TFhirPlanDefinitionAction;
var
  child : TMXmlElement;
begin
  result := TFhirPlanDefinitionAction.Create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParsePlanDefinitionActionChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParsePlanDefinitionActionChild(value : TFhirPlanDefinitionAction; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'linkId') then
        value.linkIdElement := ParseString(child, path+'/linkId')
      else if (child.localName = 'prefix') then
        value.prefixElement := ParseString(child, path+'/prefix')
      else if (child.localName = 'title') then
        value.titleElement := ParseString(child, path+'/title')
      else if (child.localName = 'description') then
        value.descriptionElement := ParseString(child, path+'/description')
      else if (child.localName = 'textEquivalent') then
        value.textEquivalentElement := ParseString(child, path+'/textEquivalent')
      else if (child.localName = 'priority') then
        value.priorityElement := ParseEnum(CODES_TFhirRequestPriorityEnum, SYSTEMS_TFhirRequestPriorityEnum, child, path+'/priority')
      else if (child.localName = 'code') then
        value.code := ParseCodeableConcept(child, path+'/code')
      else if (child.localName = 'reason') then
        value.reasonList.Add(ParseCodeableConcept(child, path+'/reason'))
      else if (child.localName = 'documentation') then
        value.documentationList.Add(ParseRelatedArtifact(child, path+'/documentation'))
      else if (child.localName = 'goalId') then
        value.goalIdList.Add(ParseId(child, path+'/goalId'))
      else if (child.localName = 'subjectCodeableConcept') then
        value.subject := ParseCodeableConcept(child, path+'/subjectCodeableConcept')
      else if (child.localName = 'subjectReference') then
        value.subject := ParseReference(child, path+'/subjectReference')
      else if (child.localName = 'subjectCanonical') then
        value.subject := ParseCanonical(child, path+'/subjectCanonical')
      else if (child.localName = 'trigger') then
        value.triggerList.Add(ParseTriggerDefinition(child, path+'/trigger'))
      else if (child.localName = 'condition') then
        value.conditionList.Add(ParsePlanDefinitionActionCondition(child, path+'/condition'))
      else if (child.localName = 'input') then
        value.inputList.Add(ParsePlanDefinitionActionInput(child, path+'/input'))
      else if (child.localName = 'output') then
        value.outputList.Add(ParsePlanDefinitionActionOutput(child, path+'/output'))
      else if (child.localName = 'relatedAction') then
        value.relatedActionList.Add(ParsePlanDefinitionActionRelatedAction(child, path+'/relatedAction'))
      else if (child.localName = 'timingAge') then
        value.timing := ParseAge(child, path+'/timingAge')
      else if (child.localName = 'timingDuration') then
        value.timing := ParseDuration(child, path+'/timingDuration')
      else if (child.localName = 'timingRange') then
        value.timing := ParseRange(child, path+'/timingRange')
      else if (child.localName = 'timingTiming') then
        value.timing := ParseTiming(child, path+'/timingTiming')
      else if (child.localName = 'location') then
        value.location := ParseCodeableReference(child, path+'/location')
      else if (child.localName = 'participant') then
        value.participantList.Add(ParsePlanDefinitionActionParticipant(child, path+'/participant'))
      else if (child.localName = 'type') then
        value.type_ := ParseCodeableConcept(child, path+'/type')
      else if (child.localName = 'groupingBehavior') then
        value.groupingBehaviorElement := ParseEnum(CODES_TFhirActionGroupingBehaviorEnum, SYSTEMS_TFhirActionGroupingBehaviorEnum, child, path+'/groupingBehavior')
      else if (child.localName = 'selectionBehavior') then
        value.selectionBehaviorElement := ParseEnum(CODES_TFhirActionSelectionBehaviorEnum, SYSTEMS_TFhirActionSelectionBehaviorEnum, child, path+'/selectionBehavior')
      else if (child.localName = 'requiredBehavior') then
        value.requiredBehaviorElement := ParseEnum(CODES_TFhirActionRequiredBehaviorEnum, SYSTEMS_TFhirActionRequiredBehaviorEnum, child, path+'/requiredBehavior')
      else if (child.localName = 'precheckBehavior') then
        value.precheckBehaviorElement := ParseEnum(CODES_TFhirActionPrecheckBehaviorEnum, SYSTEMS_TFhirActionPrecheckBehaviorEnum, child, path+'/precheckBehavior')
      else if (child.localName = 'cardinalityBehavior') then
        value.cardinalityBehaviorElement := ParseEnum(CODES_TFhirActionCardinalityBehaviorEnum, SYSTEMS_TFhirActionCardinalityBehaviorEnum, child, path+'/cardinalityBehavior')
      else if (child.localName = 'definitionCanonical') then
        value.definition := ParseCanonical(child, path+'/definitionCanonical')
      else if (child.localName = 'definitionUri') then
        value.definition := ParseUri(child, path+'/definitionUri')
      else if (child.localName = 'transform') then
        value.transformElement := ParseCanonical(child, path+'/transform')
      else if (child.localName = 'dynamicValue') then
        value.dynamicValueList.Add(ParsePlanDefinitionActionDynamicValue(child, path+'/dynamicValue'))
      else if (child.localName = 'action') then
        value.actionList.Add(ParsePlanDefinitionAction(child, path+'/action'))
      else if Not ParseBackboneElementChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposePlanDefinitionAction(xml : TXmlBuilder; name : String; value : TFhirPlanDefinitionAction);
begin
  if (value = nil) then
    exit;
  composeElementAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composePlanDefinitionActionChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposePlanDefinitionActionChildren(xml : TXmlBuilder; value : TFhirPlanDefinitionAction);
var
  i : integer;
begin
  composeBackboneElementChildren(xml, value);
  if (SummaryOption in [soFull, soData]) then
    ComposeString(xml, 'linkId', value.linkIdElement);
  if (SummaryOption in [soFull, soData]) then
    ComposeString(xml, 'prefix', value.prefixElement);
  if (SummaryOption in [soFull, soData]) then
    ComposeString(xml, 'title', value.titleElement);
  if (SummaryOption in [soFull, soData]) then
    ComposeString(xml, 'description', value.descriptionElement);
  if (SummaryOption in [soFull, soData]) then
    ComposeString(xml, 'textEquivalent', value.textEquivalentElement);
  if (SummaryOption in [soFull, soData]) then
    ComposeEnum(xml, 'priority', value.priorityElement, CODES_TFhirRequestPriorityEnum);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(xml, 'code', value.code);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.reasonList.Count - 1 do
      ComposeCodeableConcept(xml, 'reason', value.reasonList[i]);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.documentationList.Count - 1 do
      ComposeRelatedArtifact(xml, 'documentation', value.documentationList[i]);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.goalIdList.Count - 1 do
      ComposeId(xml, 'goalId', value.goalIdList[i]);
  if (SummaryOption in [soFull, soData]) and (value.subject is TFhirCodeableConcept) {6} then
    ComposeCodeableConcept(xml, 'subjectCodeableConcept', TFhirCodeableConcept(value.subject))
  else if (SummaryOption in [soFull, soData]) and (value.subject is TFhirReference) {2} then
    ComposeReference(xml, 'subjectReference', TFhirReference(value.subject))
  else if (SummaryOption in [soFull, soData]) and (value.subject is TFhirCanonical) {6} then
    ComposeCanonical(xml, 'subjectCanonical', TFhirCanonical(value.subject));
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.triggerList.Count - 1 do
      ComposeTriggerDefinition(xml, 'trigger', value.triggerList[i]);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.conditionList.Count - 1 do
      ComposePlanDefinitionActionCondition(xml, 'condition', value.conditionList[i]);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.inputList.Count - 1 do
      ComposePlanDefinitionActionInput(xml, 'input', value.inputList[i]);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.outputList.Count - 1 do
      ComposePlanDefinitionActionOutput(xml, 'output', value.outputList[i]);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.relatedActionList.Count - 1 do
      ComposePlanDefinitionActionRelatedAction(xml, 'relatedAction', value.relatedActionList[i]);
  if (SummaryOption in [soFull, soData]) and (value.timing is TFhirAge) {6} then
    ComposeAge(xml, 'timingAge', TFhirAge(value.timing))
  else if (SummaryOption in [soFull, soData]) and (value.timing is TFhirDuration) {6} then
    ComposeDuration(xml, 'timingDuration', TFhirDuration(value.timing))
  else if (SummaryOption in [soFull, soData]) and (value.timing is TFhirRange) {6} then
    ComposeRange(xml, 'timingRange', TFhirRange(value.timing))
  else if (SummaryOption in [soFull, soData]) and (value.timing is TFhirTiming) {6} then
    ComposeTiming(xml, 'timingTiming', TFhirTiming(value.timing));
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableReference(xml, 'location', value.location);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.participantList.Count - 1 do
      ComposePlanDefinitionActionParticipant(xml, 'participant', value.participantList[i]);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(xml, 'type', value.type_);
  if (SummaryOption in [soFull, soData]) then
    ComposeEnum(xml, 'groupingBehavior', value.groupingBehaviorElement, CODES_TFhirActionGroupingBehaviorEnum);
  if (SummaryOption in [soFull, soData]) then
    ComposeEnum(xml, 'selectionBehavior', value.selectionBehaviorElement, CODES_TFhirActionSelectionBehaviorEnum);
  if (SummaryOption in [soFull, soData]) then
    ComposeEnum(xml, 'requiredBehavior', value.requiredBehaviorElement, CODES_TFhirActionRequiredBehaviorEnum);
  if (SummaryOption in [soFull, soData]) then
    ComposeEnum(xml, 'precheckBehavior', value.precheckBehaviorElement, CODES_TFhirActionPrecheckBehaviorEnum);
  if (SummaryOption in [soFull, soData]) then
    ComposeEnum(xml, 'cardinalityBehavior', value.cardinalityBehaviorElement, CODES_TFhirActionCardinalityBehaviorEnum);
  if (SummaryOption in [soFull, soData]) and (value.definition is TFhirCanonical) {6} then
    ComposeCanonical(xml, 'definitionCanonical', TFhirCanonical(value.definition))
  else if (SummaryOption in [soFull, soData]) and (value.definition is TFhirUri) {6} then
    ComposeUri(xml, 'definitionUri', TFhirUri(value.definition));
  if (SummaryOption in [soFull, soData]) then
    ComposeCanonical(xml, 'transform', value.transformElement);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.dynamicValueList.Count - 1 do
      ComposePlanDefinitionActionDynamicValue(xml, 'dynamicValue', value.dynamicValueList[i]);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.actionList.Count - 1 do
      ComposePlanDefinitionAction(xml, 'action', value.actionList[i]);
end;

function TFHIRXmlParser.ParsePlanDefinitionActionCondition(element : TMXmlElement; path : string) : TFhirPlanDefinitionActionCondition;
var
  child : TMXmlElement;
begin
  result := TFhirPlanDefinitionActionCondition.Create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParsePlanDefinitionActionConditionChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParsePlanDefinitionActionConditionChild(value : TFhirPlanDefinitionActionCondition; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'kind') then
        value.kindElement := ParseEnum(CODES_TFhirActionConditionKindEnum, SYSTEMS_TFhirActionConditionKindEnum, child, path+'/kind')
      else if (child.localName = 'expression') then
        value.expression := ParseExpression(child, path+'/expression')
      else if Not ParseBackboneElementChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposePlanDefinitionActionCondition(xml : TXmlBuilder; name : String; value : TFhirPlanDefinitionActionCondition);
begin
  if (value = nil) then
    exit;
  composeElementAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composePlanDefinitionActionConditionChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposePlanDefinitionActionConditionChildren(xml : TXmlBuilder; value : TFhirPlanDefinitionActionCondition);
begin
  composeBackboneElementChildren(xml, value);
  ComposeEnum(xml, 'kind', value.kindElement, CODES_TFhirActionConditionKindEnum);
  if (SummaryOption in [soFull, soData]) then
    ComposeExpression(xml, 'expression', value.expression);
end;

function TFHIRXmlParser.ParsePlanDefinitionActionInput(element : TMXmlElement; path : string) : TFhirPlanDefinitionActionInput;
var
  child : TMXmlElement;
begin
  result := TFhirPlanDefinitionActionInput.Create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParsePlanDefinitionActionInputChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParsePlanDefinitionActionInputChild(value : TFhirPlanDefinitionActionInput; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'title') then
        value.titleElement := ParseString(child, path+'/title')
      else if (child.localName = 'requirement') then
        value.requirement := ParseDataRequirement(child, path+'/requirement')
      else if (child.localName = 'relatedData') then
        value.relatedDataElement := ParseId(child, path+'/relatedData')
      else if Not ParseBackboneElementChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposePlanDefinitionActionInput(xml : TXmlBuilder; name : String; value : TFhirPlanDefinitionActionInput);
begin
  if (value = nil) then
    exit;
  composeElementAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composePlanDefinitionActionInputChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposePlanDefinitionActionInputChildren(xml : TXmlBuilder; value : TFhirPlanDefinitionActionInput);
begin
  composeBackboneElementChildren(xml, value);
  if (SummaryOption in [soFull, soData]) then
    ComposeString(xml, 'title', value.titleElement);
  if (SummaryOption in [soFull, soData]) then
    ComposeDataRequirement(xml, 'requirement', value.requirement);
  if (SummaryOption in [soFull, soData]) then
    ComposeId(xml, 'relatedData', value.relatedDataElement);
end;

function TFHIRXmlParser.ParsePlanDefinitionActionOutput(element : TMXmlElement; path : string) : TFhirPlanDefinitionActionOutput;
var
  child : TMXmlElement;
begin
  result := TFhirPlanDefinitionActionOutput.Create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParsePlanDefinitionActionOutputChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParsePlanDefinitionActionOutputChild(value : TFhirPlanDefinitionActionOutput; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'title') then
        value.titleElement := ParseString(child, path+'/title')
      else if (child.localName = 'requirement') then
        value.requirement := ParseDataRequirement(child, path+'/requirement')
      else if (child.localName = 'relatedData') then
        value.relatedDataElement := ParseString(child, path+'/relatedData')
      else if Not ParseBackboneElementChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposePlanDefinitionActionOutput(xml : TXmlBuilder; name : String; value : TFhirPlanDefinitionActionOutput);
begin
  if (value = nil) then
    exit;
  composeElementAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composePlanDefinitionActionOutputChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposePlanDefinitionActionOutputChildren(xml : TXmlBuilder; value : TFhirPlanDefinitionActionOutput);
begin
  composeBackboneElementChildren(xml, value);
  if (SummaryOption in [soFull, soData]) then
    ComposeString(xml, 'title', value.titleElement);
  if (SummaryOption in [soFull, soData]) then
    ComposeDataRequirement(xml, 'requirement', value.requirement);
  if (SummaryOption in [soFull, soData]) then
    ComposeString(xml, 'relatedData', value.relatedDataElement);
end;

function TFHIRXmlParser.ParsePlanDefinitionActionRelatedAction(element : TMXmlElement; path : string) : TFhirPlanDefinitionActionRelatedAction;
var
  child : TMXmlElement;
begin
  result := TFhirPlanDefinitionActionRelatedAction.Create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParsePlanDefinitionActionRelatedActionChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParsePlanDefinitionActionRelatedActionChild(value : TFhirPlanDefinitionActionRelatedAction; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'targetId') then
        value.targetIdElement := ParseId(child, path+'/targetId')
      else if (child.localName = 'relationship') then
        value.relationshipElement := ParseEnum(CODES_TFhirActionRelationshipTypeEnum, SYSTEMS_TFhirActionRelationshipTypeEnum, child, path+'/relationship')
      else if (child.localName = 'offsetDuration') then
        value.offset := ParseDuration(child, path+'/offsetDuration')
      else if (child.localName = 'offsetRange') then
        value.offset := ParseRange(child, path+'/offsetRange')
      else if Not ParseBackboneElementChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposePlanDefinitionActionRelatedAction(xml : TXmlBuilder; name : String; value : TFhirPlanDefinitionActionRelatedAction);
begin
  if (value = nil) then
    exit;
  composeElementAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composePlanDefinitionActionRelatedActionChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposePlanDefinitionActionRelatedActionChildren(xml : TXmlBuilder; value : TFhirPlanDefinitionActionRelatedAction);
begin
  composeBackboneElementChildren(xml, value);
  ComposeId(xml, 'targetId', value.targetIdElement);
  ComposeEnum(xml, 'relationship', value.relationshipElement, CODES_TFhirActionRelationshipTypeEnum);
  if (SummaryOption in [soFull, soData]) and (value.offset is TFhirDuration) {6} then
    ComposeDuration(xml, 'offsetDuration', TFhirDuration(value.offset))
  else if (SummaryOption in [soFull, soData]) and (value.offset is TFhirRange) {6} then
    ComposeRange(xml, 'offsetRange', TFhirRange(value.offset));
end;

function TFHIRXmlParser.ParsePlanDefinitionActionParticipant(element : TMXmlElement; path : string) : TFhirPlanDefinitionActionParticipant;
var
  child : TMXmlElement;
begin
  result := TFhirPlanDefinitionActionParticipant.Create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParsePlanDefinitionActionParticipantChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParsePlanDefinitionActionParticipantChild(value : TFhirPlanDefinitionActionParticipant; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'actorId') then
        value.actorIdElement := ParseString(child, path+'/actorId')
      else if (child.localName = 'type') then
        value.type_Element := ParseEnum(CODES_TFhirActionParticipantTypeEnum, SYSTEMS_TFhirActionParticipantTypeEnum, child, path+'/type')
      else if (child.localName = 'typeCanonical') then
        value.typeCanonicalElement := ParseCanonical(child, path+'/typeCanonical')
      else if (child.localName = 'typeReference') then
        value.typeReference := ParseReference(child, path+'/typeReference')
      else if (child.localName = 'role') then
        value.role := ParseCodeableConcept(child, path+'/role')
      else if (child.localName = 'function') then
        value.function_ := ParseCodeableConcept(child, path+'/function')
      else if Not ParseBackboneElementChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposePlanDefinitionActionParticipant(xml : TXmlBuilder; name : String; value : TFhirPlanDefinitionActionParticipant);
begin
  if (value = nil) then
    exit;
  composeElementAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composePlanDefinitionActionParticipantChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposePlanDefinitionActionParticipantChildren(xml : TXmlBuilder; value : TFhirPlanDefinitionActionParticipant);
begin
  composeBackboneElementChildren(xml, value);
  if (SummaryOption in [soFull, soData]) then
    ComposeString(xml, 'actorId', value.actorIdElement);
  if (SummaryOption in [soFull, soData]) then
    ComposeEnum(xml, 'type', value.type_Element, CODES_TFhirActionParticipantTypeEnum);
  if (SummaryOption in [soFull, soData]) then
    ComposeCanonical(xml, 'typeCanonical', value.typeCanonicalElement);
  if (SummaryOption in [soFull, soData]) then
    ComposeReference(xml, 'typeReference', value.typeReference);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(xml, 'role', value.role);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(xml, 'function', value.function_);
end;

function TFHIRXmlParser.ParsePlanDefinitionActionDynamicValue(element : TMXmlElement; path : string) : TFhirPlanDefinitionActionDynamicValue;
var
  child : TMXmlElement;
begin
  result := TFhirPlanDefinitionActionDynamicValue.Create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParsePlanDefinitionActionDynamicValueChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParsePlanDefinitionActionDynamicValueChild(value : TFhirPlanDefinitionActionDynamicValue; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'path') then
        value.pathElement := ParseString(child, path+'/path')
      else if (child.localName = 'expression') then
        value.expression := ParseExpression(child, path+'/expression')
      else if Not ParseBackboneElementChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposePlanDefinitionActionDynamicValue(xml : TXmlBuilder; name : String; value : TFhirPlanDefinitionActionDynamicValue);
begin
  if (value = nil) then
    exit;
  composeElementAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composePlanDefinitionActionDynamicValueChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposePlanDefinitionActionDynamicValueChildren(xml : TXmlBuilder; value : TFhirPlanDefinitionActionDynamicValue);
begin
  composeBackboneElementChildren(xml, value);
  if (SummaryOption in [soFull, soData]) then
    ComposeString(xml, 'path', value.pathElement);
  if (SummaryOption in [soFull, soData]) then
    ComposeExpression(xml, 'expression', value.expression);
end;

function TFHIRXmlParser.ParsePlanDefinition(element : TMXmlElement; path : string) : TFhirPlanDefinition;
var
  child : TMXmlElement;
begin
  result := TFhirPlanDefinition.Create;
  try
    parseMetadataResourceAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParsePlanDefinitionChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParsePlanDefinitionChild(value : TFhirPlanDefinition; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'url') then
        value.urlElement := ParseUri(child, path+'/url')
      else if (child.localName = 'identifier') then
        value.identifierList.Add(ParseIdentifier(child, path+'/identifier'))
      else if (child.localName = 'version') then
        value.versionElement := ParseString(child, path+'/version')
      else if (child.localName = 'name') then
        value.nameElement := ParseString(child, path+'/name')
      else if (child.localName = 'title') then
        value.titleElement := ParseString(child, path+'/title')
      else if (child.localName = 'subtitle') then
        value.subtitleElement := ParseString(child, path+'/subtitle')
      else if (child.localName = 'type') then
        value.type_ := ParseCodeableConcept(child, path+'/type')
      else if (child.localName = 'status') then
        value.statusElement := ParseEnum(CODES_TFhirPublicationStatusEnum, SYSTEMS_TFhirPublicationStatusEnum, child, path+'/status')
      else if (child.localName = 'experimental') then
        value.experimentalElement := ParseBoolean(child, path+'/experimental')
      else if (child.localName = 'subjectCodeableConcept') then
        value.subject := ParseCodeableConcept(child, path+'/subjectCodeableConcept')
      else if (child.localName = 'subjectReference') then
        value.subject := ParseReference(child, path+'/subjectReference')
      else if (child.localName = 'subjectCanonical') then
        value.subject := ParseCanonical(child, path+'/subjectCanonical')
      else if (child.localName = 'date') then
        value.dateElement := ParseDateTime(child, path+'/date')
      else if (child.localName = 'publisher') then
        value.publisherElement := ParseString(child, path+'/publisher')
      else if (child.localName = 'contact') then
        value.contactList.Add(ParseContactDetail(child, path+'/contact'))
      else if (child.localName = 'description') then
        value.descriptionElement := ParseMarkdown(child, path+'/description')
      else if (child.localName = 'useContext') then
        value.useContextList.Add(ParseUsageContext(child, path+'/useContext'))
      else if (child.localName = 'jurisdiction') then
        value.jurisdictionList.Add(ParseCodeableConcept(child, path+'/jurisdiction'))
      else if (child.localName = 'purpose') then
        value.purposeElement := ParseMarkdown(child, path+'/purpose')
      else if (child.localName = 'usage') then
        value.usageElement := ParseString(child, path+'/usage')
      else if (child.localName = 'copyright') then
        value.copyrightElement := ParseMarkdown(child, path+'/copyright')
      else if (child.localName = 'approvalDate') then
        value.approvalDateElement := ParseDate(child, path+'/approvalDate')
      else if (child.localName = 'lastReviewDate') then
        value.lastReviewDateElement := ParseDate(child, path+'/lastReviewDate')
      else if (child.localName = 'effectivePeriod') then
        value.effectivePeriod := ParsePeriod(child, path+'/effectivePeriod')
      else if (child.localName = 'topic') then
        value.topicList.Add(ParseCodeableConcept(child, path+'/topic'))
      else if (child.localName = 'author') then
        value.authorList.Add(ParseContactDetail(child, path+'/author'))
      else if (child.localName = 'editor') then
        value.editorList.Add(ParseContactDetail(child, path+'/editor'))
      else if (child.localName = 'reviewer') then
        value.reviewerList.Add(ParseContactDetail(child, path+'/reviewer'))
      else if (child.localName = 'endorser') then
        value.endorserList.Add(ParseContactDetail(child, path+'/endorser'))
      else if (child.localName = 'relatedArtifact') then
        value.relatedArtifactList.Add(ParseRelatedArtifact(child, path+'/relatedArtifact'))
      else if (child.localName = 'library') then
        value.library_List.Add(ParseCanonical(child, path+'/library'))
      else if (child.localName = 'goal') then
        value.goalList.Add(ParsePlanDefinitionGoal(child, path+'/goal'))
      else if (child.localName = 'actor') then
        value.actorList.Add(ParsePlanDefinitionActor(child, path+'/actor'))
      else if (child.localName = 'action') then
        value.actionList.Add(ParsePlanDefinitionAction(child, path+'/action'))
      else if (child.localName = 'asNeededCodeableConcept') then
        value.asNeeded := ParseCodeableConcept(child, path+'/asNeededCodeableConcept')
      else if (child.localName = 'asNeededBoolean') then
        value.asNeeded := ParseBoolean(child, path+'/asNeededBoolean')
      else if Not ParseMetadataResourceChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposePlanDefinition(xml : TXmlBuilder; name : String; value : TFhirPlanDefinition);
begin
  if (value = nil) then
    exit;
  composeMetadataResourceAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composePlanDefinitionChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposePlanDefinitionChildren(xml : TXmlBuilder; value : TFhirPlanDefinition);
var
  i : integer;
begin
  composeMetadataResourceChildren(xml, value);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeUri(xml, 'url', value.urlElement);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.identifierList.Count - 1 do
      ComposeIdentifier(xml, 'identifier', value.identifierList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(xml, 'version', value.versionElement);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(xml, 'name', value.nameElement);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(xml, 'title', value.titleElement);
  if (SummaryOption in [soFull, soData]) then
    ComposeString(xml, 'subtitle', value.subtitleElement);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(xml, 'type', value.type_);
  ComposeEnum(xml, 'status', value.statusElement, CODES_TFhirPublicationStatusEnum);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeBoolean(xml, 'experimental', value.experimentalElement);
  if (SummaryOption in [soFull, soData]) and (value.subject is TFhirCodeableConcept) {6} then
    ComposeCodeableConcept(xml, 'subjectCodeableConcept', TFhirCodeableConcept(value.subject))
  else if (SummaryOption in [soFull, soData]) and (value.subject is TFhirReference) {2} then
    ComposeReference(xml, 'subjectReference', TFhirReference(value.subject))
  else if (SummaryOption in [soFull, soData]) and (value.subject is TFhirCanonical) {6} then
    ComposeCanonical(xml, 'subjectCanonical', TFhirCanonical(value.subject));
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDateTime(xml, 'date', value.dateElement);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(xml, 'publisher', value.publisherElement);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.contactList.Count - 1 do
      ComposeContactDetail(xml, 'contact', value.contactList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeMarkdown(xml, 'description', value.descriptionElement);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.useContextList.Count - 1 do
      ComposeUsageContext(xml, 'useContext', value.useContextList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.jurisdictionList.Count - 1 do
      ComposeCodeableConcept(xml, 'jurisdiction', value.jurisdictionList[i]);
  if (SummaryOption in [soFull, soData]) then
    ComposeMarkdown(xml, 'purpose', value.purposeElement);
  if (SummaryOption in [soFull, soData]) then
    ComposeString(xml, 'usage', value.usageElement);
  if (SummaryOption in [soFull, soData]) then
    ComposeMarkdown(xml, 'copyright', value.copyrightElement);
  if (SummaryOption in [soFull, soData]) then
    ComposeDate(xml, 'approvalDate', value.approvalDateElement);
  if (SummaryOption in [soFull, soData]) then
    ComposeDate(xml, 'lastReviewDate', value.lastReviewDateElement);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposePeriod(xml, 'effectivePeriod', value.effectivePeriod);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.topicList.Count - 1 do
      ComposeCodeableConcept(xml, 'topic', value.topicList[i]);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.authorList.Count - 1 do
      ComposeContactDetail(xml, 'author', value.authorList[i]);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.editorList.Count - 1 do
      ComposeContactDetail(xml, 'editor', value.editorList[i]);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.reviewerList.Count - 1 do
      ComposeContactDetail(xml, 'reviewer', value.reviewerList[i]);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.endorserList.Count - 1 do
      ComposeContactDetail(xml, 'endorser', value.endorserList[i]);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.relatedArtifactList.Count - 1 do
      ComposeRelatedArtifact(xml, 'relatedArtifact', value.relatedArtifactList[i]);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.library_List.Count - 1 do
      ComposeCanonical(xml, 'library', value.library_List[i]);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.goalList.Count - 1 do
      ComposePlanDefinitionGoal(xml, 'goal', value.goalList[i]);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.actorList.Count - 1 do
      ComposePlanDefinitionActor(xml, 'actor', value.actorList[i]);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.actionList.Count - 1 do
      ComposePlanDefinitionAction(xml, 'action', value.actionList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) and (value.asNeeded is TFhirCodeableConcept) {6} then
    ComposeCodeableConcept(xml, 'asNeededCodeableConcept', TFhirCodeableConcept(value.asNeeded))
  else if (SummaryOption in [soFull, soSummary, soData]) and (value.asNeeded is TFhirBoolean) {6} then
    ComposeBoolean(xml, 'asNeededBoolean', TFhirBoolean(value.asNeeded));
end;

{$ENDIF FHIR_PLANDEFINITION}
{$IFDEF FHIR_PRACTITIONER}
function TFHIRXmlParser.ParsePractitionerQualification(element : TMXmlElement; path : string) : TFhirPractitionerQualification;
var
  child : TMXmlElement;
begin
  result := TFhirPractitionerQualification.Create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParsePractitionerQualificationChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParsePractitionerQualificationChild(value : TFhirPractitionerQualification; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'identifier') then
        value.identifierList.Add(ParseIdentifier(child, path+'/identifier'))
      else if (child.localName = 'code') then
        value.code := ParseCodeableConcept(child, path+'/code')
      else if (child.localName = 'period') then
        value.period := ParsePeriod(child, path+'/period')
      else if (child.localName = 'issuer') then
        value.issuer := ParseReference(child, path+'/issuer')
      else if Not ParseBackboneElementChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposePractitionerQualification(xml : TXmlBuilder; name : String; value : TFhirPractitionerQualification);
begin
  if (value = nil) then
    exit;
  composeElementAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composePractitionerQualificationChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposePractitionerQualificationChildren(xml : TXmlBuilder; value : TFhirPractitionerQualification);
var
  i : integer;
begin
  composeBackboneElementChildren(xml, value);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.identifierList.Count - 1 do
      ComposeIdentifier(xml, 'identifier', value.identifierList[i]);
  ComposeCodeableConcept(xml, 'code', value.code);
  if (SummaryOption in [soFull, soData]) then
    ComposePeriod(xml, 'period', value.period);
  if (SummaryOption in [soFull, soData]) then
    ComposeReference(xml, 'issuer', value.issuer);
end;

function TFHIRXmlParser.ParsePractitioner(element : TMXmlElement; path : string) : TFhirPractitioner;
var
  child : TMXmlElement;
begin
  result := TFhirPractitioner.Create;
  try
    parseDomainResourceAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParsePractitionerChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParsePractitionerChild(value : TFhirPractitioner; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'identifier') then
        value.identifierList.Add(ParseIdentifier(child, path+'/identifier'))
      else if (child.localName = 'active') then
        value.activeElement := ParseBoolean(child, path+'/active')
      else if (child.localName = 'name') then
        value.nameList.Add(ParseHumanName(child, path+'/name'))
      else if (child.localName = 'telecom') then
        value.telecomList.Add(ParseContactPoint(child, path+'/telecom'))
      else if (child.localName = 'gender') then
        value.genderElement := ParseEnum(CODES_TFhirAdministrativeGenderEnum, SYSTEMS_TFhirAdministrativeGenderEnum, child, path+'/gender')
      else if (child.localName = 'birthDate') then
        value.birthDateElement := ParseDate(child, path+'/birthDate')
      else if (child.localName = 'deceasedBoolean') then
        value.deceased := ParseBoolean(child, path+'/deceasedBoolean')
      else if (child.localName = 'deceasedDateTime') then
        value.deceased := ParseDateTime(child, path+'/deceasedDateTime')
      else if (child.localName = 'address') then
        value.addressList.Add(ParseAddress(child, path+'/address'))
      else if (child.localName = 'photo') then
        value.photoList.Add(ParseAttachment(child, path+'/photo'))
      else if (child.localName = 'qualification') then
        value.qualificationList.Add(ParsePractitionerQualification(child, path+'/qualification'))
      else if (child.localName = 'communication') then
        value.communicationList.Add(ParseCodeableConcept(child, path+'/communication'))
      else if Not ParseDomainResourceChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposePractitioner(xml : TXmlBuilder; name : String; value : TFhirPractitioner);
begin
  if (value = nil) then
    exit;
  composeDomainResourceAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composePractitionerChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposePractitionerChildren(xml : TXmlBuilder; value : TFhirPractitioner);
var
  i : integer;
begin
  composeDomainResourceChildren(xml, value);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.identifierList.Count - 1 do
      ComposeIdentifier(xml, 'identifier', value.identifierList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeBoolean(xml, 'active', value.activeElement);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.nameList.Count - 1 do
      ComposeHumanName(xml, 'name', value.nameList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.telecomList.Count - 1 do
      ComposeContactPoint(xml, 'telecom', value.telecomList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeEnum(xml, 'gender', value.genderElement, CODES_TFhirAdministrativeGenderEnum);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDate(xml, 'birthDate', value.birthDateElement);
  if (SummaryOption in [soFull, soSummary, soData]) and (value.deceased is TFhirBoolean) {6} then
    ComposeBoolean(xml, 'deceasedBoolean', TFhirBoolean(value.deceased))
  else if (SummaryOption in [soFull, soSummary, soData]) and (value.deceased is TFhirDateTime) {6} then
    ComposeDateTime(xml, 'deceasedDateTime', TFhirDateTime(value.deceased));
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.addressList.Count - 1 do
      ComposeAddress(xml, 'address', value.addressList[i]);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.photoList.Count - 1 do
      ComposeAttachment(xml, 'photo', value.photoList[i]);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.qualificationList.Count - 1 do
      ComposePractitionerQualification(xml, 'qualification', value.qualificationList[i]);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.communicationList.Count - 1 do
      ComposeCodeableConcept(xml, 'communication', value.communicationList[i]);
end;

{$ENDIF FHIR_PRACTITIONER}
{$IFDEF FHIR_PRACTITIONERROLE}
function TFHIRXmlParser.ParsePractitionerRole(element : TMXmlElement; path : string) : TFhirPractitionerRole;
var
  child : TMXmlElement;
begin
  result := TFhirPractitionerRole.Create;
  try
    parseDomainResourceAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParsePractitionerRoleChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParsePractitionerRoleChild(value : TFhirPractitionerRole; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'identifier') then
        value.identifierList.Add(ParseIdentifier(child, path+'/identifier'))
      else if (child.localName = 'active') then
        value.activeElement := ParseBoolean(child, path+'/active')
      else if (child.localName = 'period') then
        value.period := ParsePeriod(child, path+'/period')
      else if (child.localName = 'practitioner') then
        value.practitioner := ParseReference(child, path+'/practitioner')
      else if (child.localName = 'organization') then
        value.organization := ParseReference(child, path+'/organization')
      else if (child.localName = 'code') then
        value.codeList.Add(ParseCodeableConcept(child, path+'/code'))
      else if (child.localName = 'specialty') then
        value.specialtyList.Add(ParseCodeableConcept(child, path+'/specialty'))
      else if (child.localName = 'location') then
        value.locationList.Add(ParseReference(child, path+'/location'))
      else if (child.localName = 'healthcareService') then
        value.healthcareServiceList.Add(ParseReference(child, path+'/healthcareService'))
      else if (child.localName = 'contact') then
        value.contactList.Add(ParseExtendedContactDetail(child, path+'/contact'))
      else if (child.localName = 'availability') then
        value.availabilityList.Add(ParseAvailability(child, path+'/availability'))
      else if (child.localName = 'endpoint') then
        value.endpointList.Add(ParseReference(child, path+'/endpoint'))
      else if Not ParseDomainResourceChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposePractitionerRole(xml : TXmlBuilder; name : String; value : TFhirPractitionerRole);
begin
  if (value = nil) then
    exit;
  composeDomainResourceAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composePractitionerRoleChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposePractitionerRoleChildren(xml : TXmlBuilder; value : TFhirPractitionerRole);
var
  i : integer;
begin
  composeDomainResourceChildren(xml, value);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.identifierList.Count - 1 do
      ComposeIdentifier(xml, 'identifier', value.identifierList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeBoolean(xml, 'active', value.activeElement);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposePeriod(xml, 'period', value.period);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference(xml, 'practitioner', value.practitioner);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference(xml, 'organization', value.organization);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.codeList.Count - 1 do
      ComposeCodeableConcept(xml, 'code', value.codeList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.specialtyList.Count - 1 do
      ComposeCodeableConcept(xml, 'specialty', value.specialtyList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.locationList.Count - 1 do
      ComposeReference(xml, 'location', value.locationList[i]);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.healthcareServiceList.Count - 1 do
      ComposeReference(xml, 'healthcareService', value.healthcareServiceList[i]);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.contactList.Count - 1 do
      ComposeExtendedContactDetail(xml, 'contact', value.contactList[i]);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.availabilityList.Count - 1 do
      ComposeAvailability(xml, 'availability', value.availabilityList[i]);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.endpointList.Count - 1 do
      ComposeReference(xml, 'endpoint', value.endpointList[i]);
end;

{$ENDIF FHIR_PRACTITIONERROLE}
{$IFDEF FHIR_PROCEDURE}
function TFHIRXmlParser.ParseProcedurePerformer(element : TMXmlElement; path : string) : TFhirProcedurePerformer;
var
  child : TMXmlElement;
begin
  result := TFhirProcedurePerformer.Create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseProcedurePerformerChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseProcedurePerformerChild(value : TFhirProcedurePerformer; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'function') then
        value.function_ := ParseCodeableConcept(child, path+'/function')
      else if (child.localName = 'actor') then
        value.actor := ParseReference(child, path+'/actor')
      else if (child.localName = 'onBehalfOf') then
        value.onBehalfOf := ParseReference(child, path+'/onBehalfOf')
      else if (child.localName = 'period') then
        value.period := ParsePeriod(child, path+'/period')
      else if Not ParseBackboneElementChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeProcedurePerformer(xml : TXmlBuilder; name : String; value : TFhirProcedurePerformer);
begin
  if (value = nil) then
    exit;
  composeElementAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeProcedurePerformerChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeProcedurePerformerChildren(xml : TXmlBuilder; value : TFhirProcedurePerformer);
begin
  composeBackboneElementChildren(xml, value);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(xml, 'function', value.function_);
  ComposeReference(xml, 'actor', value.actor);
  if (SummaryOption in [soFull, soData]) then
    ComposeReference(xml, 'onBehalfOf', value.onBehalfOf);
  if (SummaryOption in [soFull, soData]) then
    ComposePeriod(xml, 'period', value.period);
end;

function TFHIRXmlParser.ParseProcedureFocalDevice(element : TMXmlElement; path : string) : TFhirProcedureFocalDevice;
var
  child : TMXmlElement;
begin
  result := TFhirProcedureFocalDevice.Create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseProcedureFocalDeviceChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseProcedureFocalDeviceChild(value : TFhirProcedureFocalDevice; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'action') then
        value.action := ParseCodeableConcept(child, path+'/action')
      else if (child.localName = 'manipulated') then
        value.manipulated := ParseReference(child, path+'/manipulated')
      else if Not ParseBackboneElementChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeProcedureFocalDevice(xml : TXmlBuilder; name : String; value : TFhirProcedureFocalDevice);
begin
  if (value = nil) then
    exit;
  composeElementAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeProcedureFocalDeviceChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeProcedureFocalDeviceChildren(xml : TXmlBuilder; value : TFhirProcedureFocalDevice);
begin
  composeBackboneElementChildren(xml, value);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(xml, 'action', value.action);
  ComposeReference(xml, 'manipulated', value.manipulated);
end;

function TFHIRXmlParser.ParseProcedure(element : TMXmlElement; path : string) : TFhirProcedure;
var
  child : TMXmlElement;
begin
  result := TFhirProcedure.Create;
  try
    parseDomainResourceAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseProcedureChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseProcedureChild(value : TFhirProcedure; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'identifier') then
        value.identifierList.Add(ParseIdentifier(child, path+'/identifier'))
      else if (child.localName = 'instantiatesCanonical') then
        value.instantiatesCanonicalList.Add(ParseCanonical(child, path+'/instantiatesCanonical'))
      else if (child.localName = 'instantiatesUri') then
        value.instantiatesUriList.Add(ParseUri(child, path+'/instantiatesUri'))
      else if (child.localName = 'basedOn') then
        value.basedOnList.Add(ParseReference(child, path+'/basedOn'))
      else if (child.localName = 'partOf') then
        value.partOfList.Add(ParseReference(child, path+'/partOf'))
      else if (child.localName = 'status') then
        value.statusElement := ParseEnum(CODES_TFhirEventStatusEnum, SYSTEMS_TFhirEventStatusEnum, child, path+'/status')
      else if (child.localName = 'statusReason') then
        value.statusReason := ParseCodeableConcept(child, path+'/statusReason')
      else if (child.localName = 'category') then
        value.categoryList.Add(ParseCodeableConcept(child, path+'/category'))
      else if (child.localName = 'code') then
        value.code := ParseCodeableConcept(child, path+'/code')
      else if (child.localName = 'subject') then
        value.subject := ParseReference(child, path+'/subject')
      else if (child.localName = 'focus') then
        value.focus := ParseReference(child, path+'/focus')
      else if (child.localName = 'encounter') then
        value.encounter := ParseReference(child, path+'/encounter')
      else if (child.localName = 'occurrencePeriod') then
        value.occurrence := ParsePeriod(child, path+'/occurrencePeriod')
      else if (child.localName = 'occurrenceAge') then
        value.occurrence := ParseAge(child, path+'/occurrenceAge')
      else if (child.localName = 'occurrenceRange') then
        value.occurrence := ParseRange(child, path+'/occurrenceRange')
      else if (child.localName = 'occurrenceTiming') then
        value.occurrence := ParseTiming(child, path+'/occurrenceTiming')
      else if (child.localName = 'occurrenceDateTime') then
        value.occurrence := ParseDateTime(child, path+'/occurrenceDateTime')
      else if (child.localName = 'occurrenceString') then
        value.occurrence := ParseString(child, path+'/occurrenceString')
      else if (child.localName = 'recorded') then
        value.recordedElement := ParseDateTime(child, path+'/recorded')
      else if (child.localName = 'recorder') then
        value.recorder := ParseReference(child, path+'/recorder')
      else if (child.localName = 'reportedReference') then
        value.reported := ParseReference(child, path+'/reportedReference')
      else if (child.localName = 'reportedBoolean') then
        value.reported := ParseBoolean(child, path+'/reportedBoolean')
      else if (child.localName = 'performer') then
        value.performerList.Add(ParseProcedurePerformer(child, path+'/performer'))
      else if (child.localName = 'location') then
        value.location := ParseReference(child, path+'/location')
      else if (child.localName = 'reason') then
        value.reasonList.Add(ParseCodeableReference(child, path+'/reason'))
      else if (child.localName = 'bodySite') then
        value.bodySiteList.Add(ParseCodeableConcept(child, path+'/bodySite'))
      else if (child.localName = 'outcome') then
        value.outcome := ParseCodeableConcept(child, path+'/outcome')
      else if (child.localName = 'report') then
        value.reportList.Add(ParseReference(child, path+'/report'))
      else if (child.localName = 'complication') then
        value.complicationList.Add(ParseCodeableConcept(child, path+'/complication'))
      else if (child.localName = 'complicationDetail') then
        value.complicationDetailList.Add(ParseReference(child, path+'/complicationDetail'))
      else if (child.localName = 'followUp') then
        value.followUpList.Add(ParseCodeableConcept(child, path+'/followUp'))
      else if (child.localName = 'note') then
        value.noteList.Add(ParseAnnotation(child, path+'/note'))
      else if (child.localName = 'focalDevice') then
        value.focalDeviceList.Add(ParseProcedureFocalDevice(child, path+'/focalDevice'))
      else if (child.localName = 'used') then
        value.usedList.Add(ParseCodeableReference(child, path+'/used'))
      else if (child.localName = 'supportingInfo') then
        value.supportingInfoList.Add(ParseReference(child, path+'/supportingInfo'))
      else if Not ParseDomainResourceChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeProcedure(xml : TXmlBuilder; name : String; value : TFhirProcedure);
begin
  if (value = nil) then
    exit;
  composeDomainResourceAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeProcedureChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeProcedureChildren(xml : TXmlBuilder; value : TFhirProcedure);
var
  i : integer;
begin
  composeDomainResourceChildren(xml, value);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.identifierList.Count - 1 do
      ComposeIdentifier(xml, 'identifier', value.identifierList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.instantiatesCanonicalList.Count - 1 do
      ComposeCanonical(xml, 'instantiatesCanonical', value.instantiatesCanonicalList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.instantiatesUriList.Count - 1 do
      ComposeUri(xml, 'instantiatesUri', value.instantiatesUriList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.basedOnList.Count - 1 do
      ComposeReference(xml, 'basedOn', value.basedOnList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.partOfList.Count - 1 do
      ComposeReference(xml, 'partOf', value.partOfList[i]);
  ComposeEnum(xml, 'status', value.statusElement, CODES_TFhirEventStatusEnum);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(xml, 'statusReason', value.statusReason);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.categoryList.Count - 1 do
      ComposeCodeableConcept(xml, 'category', value.categoryList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(xml, 'code', value.code);
  ComposeReference(xml, 'subject', value.subject);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference(xml, 'focus', value.focus);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference(xml, 'encounter', value.encounter);
  if (SummaryOption in [soFull, soSummary, soData]) and (value.occurrence is TFhirPeriod) {6} then
    ComposePeriod(xml, 'occurrencePeriod', TFhirPeriod(value.occurrence))
  else if (SummaryOption in [soFull, soSummary, soData]) and (value.occurrence is TFhirAge) {6} then
    ComposeAge(xml, 'occurrenceAge', TFhirAge(value.occurrence))
  else if (SummaryOption in [soFull, soSummary, soData]) and (value.occurrence is TFhirRange) {6} then
    ComposeRange(xml, 'occurrenceRange', TFhirRange(value.occurrence))
  else if (SummaryOption in [soFull, soSummary, soData]) and (value.occurrence is TFhirTiming) {6} then
    ComposeTiming(xml, 'occurrenceTiming', TFhirTiming(value.occurrence))
  else if (SummaryOption in [soFull, soSummary, soData]) and (value.occurrence is TFhirDateTime) {6} then
    ComposeDateTime(xml, 'occurrenceDateTime', TFhirDateTime(value.occurrence))
  else if (SummaryOption in [soFull, soSummary, soData]) and (value.occurrence is TFhirString) {6} then
    ComposeString(xml, 'occurrenceString', TFhirString(value.occurrence));
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDateTime(xml, 'recorded', value.recordedElement);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference(xml, 'recorder', value.recorder);
  if (SummaryOption in [soFull, soSummary, soData]) and (value.reported is TFhirReference) {2} then
    ComposeReference(xml, 'reportedReference', TFhirReference(value.reported))
  else if (SummaryOption in [soFull, soSummary, soData]) and (value.reported is TFhirBoolean) {6} then
    ComposeBoolean(xml, 'reportedBoolean', TFhirBoolean(value.reported));
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.performerList.Count - 1 do
      ComposeProcedurePerformer(xml, 'performer', value.performerList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference(xml, 'location', value.location);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.reasonList.Count - 1 do
      ComposeCodeableReference(xml, 'reason', value.reasonList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.bodySiteList.Count - 1 do
      ComposeCodeableConcept(xml, 'bodySite', value.bodySiteList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(xml, 'outcome', value.outcome);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.reportList.Count - 1 do
      ComposeReference(xml, 'report', value.reportList[i]);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.complicationList.Count - 1 do
      ComposeCodeableConcept(xml, 'complication', value.complicationList[i]);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.complicationDetailList.Count - 1 do
      ComposeReference(xml, 'complicationDetail', value.complicationDetailList[i]);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.followUpList.Count - 1 do
      ComposeCodeableConcept(xml, 'followUp', value.followUpList[i]);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.noteList.Count - 1 do
      ComposeAnnotation(xml, 'note', value.noteList[i]);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.focalDeviceList.Count - 1 do
      ComposeProcedureFocalDevice(xml, 'focalDevice', value.focalDeviceList[i]);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.usedList.Count - 1 do
      ComposeCodeableReference(xml, 'used', value.usedList[i]);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.supportingInfoList.Count - 1 do
      ComposeReference(xml, 'supportingInfo', value.supportingInfoList[i]);
end;

{$ENDIF FHIR_PROCEDURE}
{$IFDEF FHIR_PROVENANCE}
function TFHIRXmlParser.ParseProvenanceAgent(element : TMXmlElement; path : string) : TFhirProvenanceAgent;
var
  child : TMXmlElement;
begin
  result := TFhirProvenanceAgent.Create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseProvenanceAgentChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseProvenanceAgentChild(value : TFhirProvenanceAgent; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'type') then
        value.type_ := ParseCodeableConcept(child, path+'/type')
      else if (child.localName = 'role') then
        value.roleList.Add(ParseCodeableConcept(child, path+'/role'))
      else if (child.localName = 'who') then
        value.who := ParseReference(child, path+'/who')
      else if (child.localName = 'onBehalfOf') then
        value.onBehalfOf := ParseReference(child, path+'/onBehalfOf')
      else if Not ParseBackboneElementChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeProvenanceAgent(xml : TXmlBuilder; name : String; value : TFhirProvenanceAgent);
begin
  if (value = nil) then
    exit;
  composeElementAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeProvenanceAgentChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeProvenanceAgentChildren(xml : TXmlBuilder; value : TFhirProvenanceAgent);
var
  i : integer;
begin
  composeBackboneElementChildren(xml, value);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(xml, 'type', value.type_);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.roleList.Count - 1 do
      ComposeCodeableConcept(xml, 'role', value.roleList[i]);
  ComposeReference(xml, 'who', value.who);
  if (SummaryOption in [soFull, soData]) then
    ComposeReference(xml, 'onBehalfOf', value.onBehalfOf);
end;

function TFHIRXmlParser.ParseProvenanceEntity(element : TMXmlElement; path : string) : TFhirProvenanceEntity;
var
  child : TMXmlElement;
begin
  result := TFhirProvenanceEntity.Create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseProvenanceEntityChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseProvenanceEntityChild(value : TFhirProvenanceEntity; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'role') then
        value.roleElement := ParseEnum(CODES_TFhirProvenanceEntityRoleEnum, SYSTEMS_TFhirProvenanceEntityRoleEnum, child, path+'/role')
      else if (child.localName = 'what') then
        value.what := ParseReference(child, path+'/what')
      else if (child.localName = 'agent') then
        value.agentList.Add(ParseProvenanceAgent(child, path+'/agent'))
      else if Not ParseBackboneElementChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeProvenanceEntity(xml : TXmlBuilder; name : String; value : TFhirProvenanceEntity);
begin
  if (value = nil) then
    exit;
  composeElementAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeProvenanceEntityChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeProvenanceEntityChildren(xml : TXmlBuilder; value : TFhirProvenanceEntity);
var
  i : integer;
begin
  composeBackboneElementChildren(xml, value);
  ComposeEnum(xml, 'role', value.roleElement, CODES_TFhirProvenanceEntityRoleEnum);
  ComposeReference(xml, 'what', value.what);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.agentList.Count - 1 do
      ComposeProvenanceAgent(xml, 'agent', value.agentList[i]);
end;

function TFHIRXmlParser.ParseProvenance(element : TMXmlElement; path : string) : TFhirProvenance;
var
  child : TMXmlElement;
begin
  result := TFhirProvenance.Create;
  try
    parseDomainResourceAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseProvenanceChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseProvenanceChild(value : TFhirProvenance; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'target') then
        value.targetList.Add(ParseReference(child, path+'/target'))
      else if (child.localName = 'occurredPeriod') then
        value.occurred := ParsePeriod(child, path+'/occurredPeriod')
      else if (child.localName = 'occurredDateTime') then
        value.occurred := ParseDateTime(child, path+'/occurredDateTime')
      else if (child.localName = 'recorded') then
        value.recordedElement := ParseInstant(child, path+'/recorded')
      else if (child.localName = 'policy') then
        value.policyList.Add(ParseUri(child, path+'/policy'))
      else if (child.localName = 'location') then
        value.location := ParseReference(child, path+'/location')
      else if (child.localName = 'authorization') then
        value.authorizationList.Add(ParseCodeableReference(child, path+'/authorization'))
      else if (child.localName = 'activity') then
        value.activity := ParseCodeableConcept(child, path+'/activity')
      else if (child.localName = 'basedOn') then
        value.basedOnList.Add(ParseReference(child, path+'/basedOn'))
      else if (child.localName = 'patient') then
        value.patient := ParseReference(child, path+'/patient')
      else if (child.localName = 'encounter') then
        value.encounter := ParseReference(child, path+'/encounter')
      else if (child.localName = 'agent') then
        value.agentList.Add(ParseProvenanceAgent(child, path+'/agent'))
      else if (child.localName = 'entity') then
        value.entityList.Add(ParseProvenanceEntity(child, path+'/entity'))
      else if (child.localName = 'signature') then
        value.signatureList.Add(ParseSignature(child, path+'/signature'))
      else if Not ParseDomainResourceChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeProvenance(xml : TXmlBuilder; name : String; value : TFhirProvenance);
begin
  if (value = nil) then
    exit;
  composeDomainResourceAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeProvenanceChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeProvenanceChildren(xml : TXmlBuilder; value : TFhirProvenance);
var
  i : integer;
begin
  composeDomainResourceChildren(xml, value);
  for i := 0 to value.targetList.Count - 1 do
      ComposeReference(xml, 'target', value.targetList[i]);
  if (SummaryOption in [soFull, soData]) and (value.occurred is TFhirPeriod) {6} then
    ComposePeriod(xml, 'occurredPeriod', TFhirPeriod(value.occurred))
  else if (SummaryOption in [soFull, soData]) and (value.occurred is TFhirDateTime) {6} then
    ComposeDateTime(xml, 'occurredDateTime', TFhirDateTime(value.occurred));
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeInstant(xml, 'recorded', value.recordedElement);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.policyList.Count - 1 do
      ComposeUri(xml, 'policy', value.policyList[i]);
  if (SummaryOption in [soFull, soData]) then
    ComposeReference(xml, 'location', value.location);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.authorizationList.Count - 1 do
      ComposeCodeableReference(xml, 'authorization', value.authorizationList[i]);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(xml, 'activity', value.activity);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.basedOnList.Count - 1 do
      ComposeReference(xml, 'basedOn', value.basedOnList[i]);
  if (SummaryOption in [soFull, soData]) then
    ComposeReference(xml, 'patient', value.patient);
  if (SummaryOption in [soFull, soData]) then
    ComposeReference(xml, 'encounter', value.encounter);
  for i := 0 to value.agentList.Count - 1 do
      ComposeProvenanceAgent(xml, 'agent', value.agentList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.entityList.Count - 1 do
      ComposeProvenanceEntity(xml, 'entity', value.entityList[i]);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.signatureList.Count - 1 do
      ComposeSignature(xml, 'signature', value.signatureList[i]);
end;

{$ENDIF FHIR_PROVENANCE}
{$IFDEF FHIR_QUESTIONNAIRE}
function TFHIRXmlParser.ParseQuestionnaireItem(element : TMXmlElement; path : string) : TFhirQuestionnaireItem;
var
  child : TMXmlElement;
begin
  result := TFhirQuestionnaireItem.Create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseQuestionnaireItemChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseQuestionnaireItemChild(value : TFhirQuestionnaireItem; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'linkId') then
        value.linkIdElement := ParseString(child, path+'/linkId')
      else if (child.localName = 'definition') then
        value.definitionElement := ParseUri(child, path+'/definition')
      else if (child.localName = 'code') then
        value.codeList.Add(ParseCoding(child, path+'/code'))
      else if (child.localName = 'prefix') then
        value.prefixElement := ParseString(child, path+'/prefix')
      else if (child.localName = 'text') then
        value.textElement := ParseString(child, path+'/text')
      else if (child.localName = 'type') then
        value.type_Element := ParseEnum(CODES_TFhirQuestionnaireItemTypeEnum, SYSTEMS_TFhirQuestionnaireItemTypeEnum, child, path+'/type')
      else if (child.localName = 'enableWhen') then
        value.enableWhenList.Add(ParseQuestionnaireItemEnableWhen(child, path+'/enableWhen'))
      else if (child.localName = 'enableBehavior') then
        value.enableBehaviorElement := ParseEnum(CODES_TFhirEnableWhenBehaviorEnum, SYSTEMS_TFhirEnableWhenBehaviorEnum, child, path+'/enableBehavior')
      else if (child.localName = 'disabledDisplay') then
        value.disabledDisplayElement := ParseEnum(CODES_TFhirQuestionnaireItemDisabledDisplayEnum, SYSTEMS_TFhirQuestionnaireItemDisabledDisplayEnum, child, path+'/disabledDisplay')
      else if (child.localName = 'required') then
        value.requiredElement := ParseBoolean(child, path+'/required')
      else if (child.localName = 'repeats') then
        value.repeatsElement := ParseBoolean(child, path+'/repeats')
      else if (child.localName = 'readOnly') then
        value.readOnlyElement := ParseBoolean(child, path+'/readOnly')
      else if (child.localName = 'maxLength') then
        value.maxLengthElement := ParseInteger(child, path+'/maxLength')
      else if (child.localName = 'answerConstraint') then
        value.answerConstraintElement := ParseEnum(CODES_TFhirQuestionnaireAnswerConstraintEnum, SYSTEMS_TFhirQuestionnaireAnswerConstraintEnum, child, path+'/answerConstraint')
      else if (child.localName = 'answerValueSet') then
        value.answerValueSetElement := ParseCanonical(child, path+'/answerValueSet')
      else if (child.localName = 'answerOption') then
        value.answerOptionList.Add(ParseQuestionnaireItemAnswerOption(child, path+'/answerOption'))
      else if (child.localName = 'initial') then
        value.initialList.Add(ParseQuestionnaireItemInitial(child, path+'/initial'))
      else if (child.localName = 'item') then
        value.itemList.Add(ParseQuestionnaireItem(child, path+'/item'))
      else if Not ParseBackboneElementChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeQuestionnaireItem(xml : TXmlBuilder; name : String; value : TFhirQuestionnaireItem);
begin
  if (value = nil) then
    exit;
  composeElementAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeQuestionnaireItemChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeQuestionnaireItemChildren(xml : TXmlBuilder; value : TFhirQuestionnaireItem);
var
  i : integer;
begin
  composeBackboneElementChildren(xml, value);
  ComposeString(xml, 'linkId', value.linkIdElement);
  if (SummaryOption in [soFull, soData]) then
    ComposeUri(xml, 'definition', value.definitionElement);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.codeList.Count - 1 do
      ComposeCoding(xml, 'code', value.codeList[i]);
  if (SummaryOption in [soFull, soData]) then
    ComposeString(xml, 'prefix', value.prefixElement);
  if (SummaryOption in [soFull, soData]) then
    ComposeString(xml, 'text', value.textElement);
  ComposeEnum(xml, 'type', value.type_Element, CODES_TFhirQuestionnaireItemTypeEnum);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.enableWhenList.Count - 1 do
      ComposeQuestionnaireItemEnableWhen(xml, 'enableWhen', value.enableWhenList[i]);
  if (SummaryOption in [soFull, soData]) then
    ComposeEnum(xml, 'enableBehavior', value.enableBehaviorElement, CODES_TFhirEnableWhenBehaviorEnum);
  if (SummaryOption in [soFull, soData]) then
    ComposeEnum(xml, 'disabledDisplay', value.disabledDisplayElement, CODES_TFhirQuestionnaireItemDisabledDisplayEnum);
  if (SummaryOption in [soFull, soData]) then
    ComposeBoolean(xml, 'required', value.requiredElement);
  if (SummaryOption in [soFull, soData]) then
    ComposeBoolean(xml, 'repeats', value.repeatsElement);
  if (SummaryOption in [soFull, soData]) then
    ComposeBoolean(xml, 'readOnly', value.readOnlyElement);
  if (SummaryOption in [soFull, soData]) then
    ComposeInteger(xml, 'maxLength', value.maxLengthElement);
  if (SummaryOption in [soFull, soData]) then
    ComposeEnum(xml, 'answerConstraint', value.answerConstraintElement, CODES_TFhirQuestionnaireAnswerConstraintEnum);
  if (SummaryOption in [soFull, soData]) then
    ComposeCanonical(xml, 'answerValueSet', value.answerValueSetElement);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.answerOptionList.Count - 1 do
      ComposeQuestionnaireItemAnswerOption(xml, 'answerOption', value.answerOptionList[i]);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.initialList.Count - 1 do
      ComposeQuestionnaireItemInitial(xml, 'initial', value.initialList[i]);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.itemList.Count - 1 do
      ComposeQuestionnaireItem(xml, 'item', value.itemList[i]);
end;

function TFHIRXmlParser.ParseQuestionnaireItemEnableWhen(element : TMXmlElement; path : string) : TFhirQuestionnaireItemEnableWhen;
var
  child : TMXmlElement;
begin
  result := TFhirQuestionnaireItemEnableWhen.Create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseQuestionnaireItemEnableWhenChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseQuestionnaireItemEnableWhenChild(value : TFhirQuestionnaireItemEnableWhen; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'question') then
        value.questionElement := ParseString(child, path+'/question')
      else if (child.localName = 'operator') then
        value.operatorElement := ParseEnum(CODES_TFhirQuestionnaireItemOperatorEnum, SYSTEMS_TFhirQuestionnaireItemOperatorEnum, child, path+'/operator')
      else if (child.localName = 'answerCoding') then
        value.answer := ParseCoding(child, path+'/answerCoding')
      else if (child.localName = 'answerQuantity') then
        value.answer := ParseQuantity(child, path+'/answerQuantity')
      else if (child.localName = 'answerReference') then
        value.answer := ParseReference(child, path+'/answerReference')
      else if (child.localName = 'answerBoolean') then
        value.answer := ParseBoolean(child, path+'/answerBoolean')
      else if (child.localName = 'answerDecimal') then
        value.answer := ParseDecimal(child, path+'/answerDecimal')
      else if (child.localName = 'answerInteger') then
        value.answer := ParseInteger(child, path+'/answerInteger')
      else if (child.localName = 'answerDate') then
        value.answer := ParseDate(child, path+'/answerDate')
      else if (child.localName = 'answerDateTime') then
        value.answer := ParseDateTime(child, path+'/answerDateTime')
      else if (child.localName = 'answerTime') then
        value.answer := ParseTime(child, path+'/answerTime')
      else if (child.localName = 'answerString') then
        value.answer := ParseString(child, path+'/answerString')
      else if Not ParseBackboneElementChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeQuestionnaireItemEnableWhen(xml : TXmlBuilder; name : String; value : TFhirQuestionnaireItemEnableWhen);
begin
  if (value = nil) then
    exit;
  composeElementAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeQuestionnaireItemEnableWhenChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeQuestionnaireItemEnableWhenChildren(xml : TXmlBuilder; value : TFhirQuestionnaireItemEnableWhen);
begin
  composeBackboneElementChildren(xml, value);
  ComposeString(xml, 'question', value.questionElement);
  ComposeEnum(xml, 'operator', value.operatorElement, CODES_TFhirQuestionnaireItemOperatorEnum);
  if (value.answer is TFhirCoding) {6} then
    ComposeCoding(xml, 'answerCoding', TFhirCoding(value.answer))
  else if (value.answer is TFhirQuantity) {6} then
    ComposeQuantity(xml, 'answerQuantity', TFhirQuantity(value.answer))
  else if (value.answer is TFhirReference) {2} then
    ComposeReference(xml, 'answerReference', TFhirReference(value.answer))
  else if (value.answer is TFhirBoolean) {6} then
    ComposeBoolean(xml, 'answerBoolean', TFhirBoolean(value.answer))
  else if (value.answer is TFhirDecimal) {6} then
    ComposeDecimal(xml, 'answerDecimal', TFhirDecimal(value.answer))
  else if (value.answer is TFhirInteger) {6} then
    ComposeInteger(xml, 'answerInteger', TFhirInteger(value.answer))
  else if (value.answer is TFhirDate) {6} then
    ComposeDate(xml, 'answerDate', TFhirDate(value.answer))
  else if (value.answer is TFhirDateTime) {6} then
    ComposeDateTime(xml, 'answerDateTime', TFhirDateTime(value.answer))
  else if (value.answer is TFhirTime) {6} then
    ComposeTime(xml, 'answerTime', TFhirTime(value.answer))
  else if (value.answer is TFhirString) {6} then
    ComposeString(xml, 'answerString', TFhirString(value.answer));
end;

function TFHIRXmlParser.ParseQuestionnaireItemAnswerOption(element : TMXmlElement; path : string) : TFhirQuestionnaireItemAnswerOption;
var
  child : TMXmlElement;
begin
  result := TFhirQuestionnaireItemAnswerOption.Create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseQuestionnaireItemAnswerOptionChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseQuestionnaireItemAnswerOptionChild(value : TFhirQuestionnaireItemAnswerOption; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'valueCoding') then
        value.value := ParseCoding(child, path+'/valueCoding')
      else if (child.localName = 'valueReference') then
        value.value := ParseReference(child, path+'/valueReference')
      else if (child.localName = 'valueInteger') then
        value.value := ParseInteger(child, path+'/valueInteger')
      else if (child.localName = 'valueDate') then
        value.value := ParseDate(child, path+'/valueDate')
      else if (child.localName = 'valueTime') then
        value.value := ParseTime(child, path+'/valueTime')
      else if (child.localName = 'valueString') then
        value.value := ParseString(child, path+'/valueString')
      else if (child.localName = 'initialSelected') then
        value.initialSelectedElement := ParseBoolean(child, path+'/initialSelected')
      else if Not ParseBackboneElementChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeQuestionnaireItemAnswerOption(xml : TXmlBuilder; name : String; value : TFhirQuestionnaireItemAnswerOption);
begin
  if (value = nil) then
    exit;
  composeElementAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeQuestionnaireItemAnswerOptionChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeQuestionnaireItemAnswerOptionChildren(xml : TXmlBuilder; value : TFhirQuestionnaireItemAnswerOption);
begin
  composeBackboneElementChildren(xml, value);
  if (value.value is TFhirCoding) {6} then
    ComposeCoding(xml, 'valueCoding', TFhirCoding(value.value))
  else if (value.value is TFhirReference) {2} then
    ComposeReference(xml, 'valueReference', TFhirReference(value.value))
  else if (value.value is TFhirInteger) {6} then
    ComposeInteger(xml, 'valueInteger', TFhirInteger(value.value))
  else if (value.value is TFhirDate) {6} then
    ComposeDate(xml, 'valueDate', TFhirDate(value.value))
  else if (value.value is TFhirTime) {6} then
    ComposeTime(xml, 'valueTime', TFhirTime(value.value))
  else if (value.value is TFhirString) {6} then
    ComposeString(xml, 'valueString', TFhirString(value.value));
  if (SummaryOption in [soFull, soData]) then
    ComposeBoolean(xml, 'initialSelected', value.initialSelectedElement);
end;

function TFHIRXmlParser.ParseQuestionnaireItemInitial(element : TMXmlElement; path : string) : TFhirQuestionnaireItemInitial;
var
  child : TMXmlElement;
begin
  result := TFhirQuestionnaireItemInitial.Create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseQuestionnaireItemInitialChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseQuestionnaireItemInitialChild(value : TFhirQuestionnaireItemInitial; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'valueAttachment') then
        value.value := ParseAttachment(child, path+'/valueAttachment')
      else if (child.localName = 'valueCoding') then
        value.value := ParseCoding(child, path+'/valueCoding')
      else if (child.localName = 'valueQuantity') then
        value.value := ParseQuantity(child, path+'/valueQuantity')
      else if (child.localName = 'valueReference') then
        value.value := ParseReference(child, path+'/valueReference')
      else if (child.localName = 'valueBoolean') then
        value.value := ParseBoolean(child, path+'/valueBoolean')
      else if (child.localName = 'valueDecimal') then
        value.value := ParseDecimal(child, path+'/valueDecimal')
      else if (child.localName = 'valueInteger') then
        value.value := ParseInteger(child, path+'/valueInteger')
      else if (child.localName = 'valueDate') then
        value.value := ParseDate(child, path+'/valueDate')
      else if (child.localName = 'valueDateTime') then
        value.value := ParseDateTime(child, path+'/valueDateTime')
      else if (child.localName = 'valueTime') then
        value.value := ParseTime(child, path+'/valueTime')
      else if (child.localName = 'valueString') then
        value.value := ParseString(child, path+'/valueString')
      else if (child.localName = 'valueUri') then
        value.value := ParseUri(child, path+'/valueUri')
      else if Not ParseBackboneElementChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeQuestionnaireItemInitial(xml : TXmlBuilder; name : String; value : TFhirQuestionnaireItemInitial);
begin
  if (value = nil) then
    exit;
  composeElementAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeQuestionnaireItemInitialChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeQuestionnaireItemInitialChildren(xml : TXmlBuilder; value : TFhirQuestionnaireItemInitial);
begin
  composeBackboneElementChildren(xml, value);
  if (value.value is TFhirAttachment) {6} then
    ComposeAttachment(xml, 'valueAttachment', TFhirAttachment(value.value))
  else if (value.value is TFhirCoding) {6} then
    ComposeCoding(xml, 'valueCoding', TFhirCoding(value.value))
  else if (value.value is TFhirQuantity) {6} then
    ComposeQuantity(xml, 'valueQuantity', TFhirQuantity(value.value))
  else if (value.value is TFhirReference) {2} then
    ComposeReference(xml, 'valueReference', TFhirReference(value.value))
  else if (value.value is TFhirBoolean) {6} then
    ComposeBoolean(xml, 'valueBoolean', TFhirBoolean(value.value))
  else if (value.value is TFhirDecimal) {6} then
    ComposeDecimal(xml, 'valueDecimal', TFhirDecimal(value.value))
  else if (value.value is TFhirInteger) {6} then
    ComposeInteger(xml, 'valueInteger', TFhirInteger(value.value))
  else if (value.value is TFhirDate) {6} then
    ComposeDate(xml, 'valueDate', TFhirDate(value.value))
  else if (value.value is TFhirDateTime) {6} then
    ComposeDateTime(xml, 'valueDateTime', TFhirDateTime(value.value))
  else if (value.value is TFhirTime) {6} then
    ComposeTime(xml, 'valueTime', TFhirTime(value.value))
  else if (value.value is TFhirString) {6} then
    ComposeString(xml, 'valueString', TFhirString(value.value))
  else if (value.value is TFhirUri) {6} then
    ComposeUri(xml, 'valueUri', TFhirUri(value.value));
end;

function TFHIRXmlParser.ParseQuestionnaire(element : TMXmlElement; path : string) : TFhirQuestionnaire;
var
  child : TMXmlElement;
begin
  result := TFhirQuestionnaire.Create;
  try
    parseMetadataResourceAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseQuestionnaireChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseQuestionnaireChild(value : TFhirQuestionnaire; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'url') then
        value.urlElement := ParseUri(child, path+'/url')
      else if (child.localName = 'identifier') then
        value.identifierList.Add(ParseIdentifier(child, path+'/identifier'))
      else if (child.localName = 'version') then
        value.versionElement := ParseString(child, path+'/version')
      else if (child.localName = 'versionAlgorithmCoding') then
        value.versionAlgorithm := ParseCoding(child, path+'/versionAlgorithmCoding')
      else if (child.localName = 'versionAlgorithmString') then
        value.versionAlgorithm := ParseString(child, path+'/versionAlgorithmString')
      else if (child.localName = 'name') then
        value.nameElement := ParseString(child, path+'/name')
      else if (child.localName = 'title') then
        value.titleElement := ParseString(child, path+'/title')
      else if (child.localName = 'derivedFrom') then
        value.derivedFromList.Add(ParseCanonical(child, path+'/derivedFrom'))
      else if (child.localName = 'status') then
        value.statusElement := ParseEnum(CODES_TFhirPublicationStatusEnum, SYSTEMS_TFhirPublicationStatusEnum, child, path+'/status')
      else if (child.localName = 'experimental') then
        value.experimentalElement := ParseBoolean(child, path+'/experimental')
      else if (child.localName = 'subjectType') then
        value.subjectType.Add(ParseEnum(CODES_TFhirResourceTypesEnum, SYSTEMS_TFhirResourceTypesEnum, child, path+'/subjectType')){y.1}
      else if (child.localName = 'date') then
        value.dateElement := ParseDateTime(child, path+'/date')
      else if (child.localName = 'publisher') then
        value.publisherElement := ParseString(child, path+'/publisher')
      else if (child.localName = 'contact') then
        value.contactList.Add(ParseContactDetail(child, path+'/contact'))
      else if (child.localName = 'description') then
        value.descriptionElement := ParseMarkdown(child, path+'/description')
      else if (child.localName = 'useContext') then
        value.useContextList.Add(ParseUsageContext(child, path+'/useContext'))
      else if (child.localName = 'jurisdiction') then
        value.jurisdictionList.Add(ParseCodeableConcept(child, path+'/jurisdiction'))
      else if (child.localName = 'purpose') then
        value.purposeElement := ParseMarkdown(child, path+'/purpose')
      else if (child.localName = 'copyright') then
        value.copyrightElement := ParseMarkdown(child, path+'/copyright')
      else if (child.localName = 'copyrightLabel') then
        value.copyrightLabelElement := ParseString(child, path+'/copyrightLabel')
      else if (child.localName = 'approvalDate') then
        value.approvalDateElement := ParseDate(child, path+'/approvalDate')
      else if (child.localName = 'lastReviewDate') then
        value.lastReviewDateElement := ParseDate(child, path+'/lastReviewDate')
      else if (child.localName = 'effectivePeriod') then
        value.effectivePeriod := ParsePeriod(child, path+'/effectivePeriod')
      else if (child.localName = 'code') then
        value.codeList.Add(ParseCoding(child, path+'/code'))
      else if (child.localName = 'item') then
        value.itemList.Add(ParseQuestionnaireItem(child, path+'/item'))
      else if Not ParseMetadataResourceChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeQuestionnaire(xml : TXmlBuilder; name : String; value : TFhirQuestionnaire);
begin
  if (value = nil) then
    exit;
  composeMetadataResourceAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeQuestionnaireChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeQuestionnaireChildren(xml : TXmlBuilder; value : TFhirQuestionnaire);
var
  i : integer;
begin
  composeMetadataResourceChildren(xml, value);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeUri(xml, 'url', value.urlElement);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.identifierList.Count - 1 do
      ComposeIdentifier(xml, 'identifier', value.identifierList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(xml, 'version', value.versionElement);
  if (SummaryOption in [soFull, soSummary, soData]) and (value.versionAlgorithm is TFhirCoding) {6} then
    ComposeCoding(xml, 'versionAlgorithmCoding', TFhirCoding(value.versionAlgorithm))
  else if (SummaryOption in [soFull, soSummary, soData]) and (value.versionAlgorithm is TFhirString) {6} then
    ComposeString(xml, 'versionAlgorithmString', TFhirString(value.versionAlgorithm));
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(xml, 'name', value.nameElement);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(xml, 'title', value.titleElement);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.derivedFromList.Count - 1 do
      ComposeCanonical(xml, 'derivedFrom', value.derivedFromList[i]);
  ComposeEnum(xml, 'status', value.statusElement, CODES_TFhirPublicationStatusEnum);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeBoolean(xml, 'experimental', value.experimentalElement);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.subjectType.Count - 1 do
      ComposeEnum(xml, 'subjectType', value.subjectType[i], CODES_TFhirResourceTypesEnum);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDateTime(xml, 'date', value.dateElement);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(xml, 'publisher', value.publisherElement);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.contactList.Count - 1 do
      ComposeContactDetail(xml, 'contact', value.contactList[i]);
  if (SummaryOption in [soFull, soData]) then
    ComposeMarkdown(xml, 'description', value.descriptionElement);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.useContextList.Count - 1 do
      ComposeUsageContext(xml, 'useContext', value.useContextList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.jurisdictionList.Count - 1 do
      ComposeCodeableConcept(xml, 'jurisdiction', value.jurisdictionList[i]);
  if (SummaryOption in [soFull, soData]) then
    ComposeMarkdown(xml, 'purpose', value.purposeElement);
  if (SummaryOption in [soFull, soData]) then
    ComposeMarkdown(xml, 'copyright', value.copyrightElement);
  if (SummaryOption in [soFull, soData]) then
    ComposeString(xml, 'copyrightLabel', value.copyrightLabelElement);
  if (SummaryOption in [soFull, soData]) then
    ComposeDate(xml, 'approvalDate', value.approvalDateElement);
  if (SummaryOption in [soFull, soData]) then
    ComposeDate(xml, 'lastReviewDate', value.lastReviewDateElement);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposePeriod(xml, 'effectivePeriod', value.effectivePeriod);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.codeList.Count - 1 do
      ComposeCoding(xml, 'code', value.codeList[i]);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.itemList.Count - 1 do
      ComposeQuestionnaireItem(xml, 'item', value.itemList[i]);
end;

{$ENDIF FHIR_QUESTIONNAIRE}
{$IFDEF FHIR_QUESTIONNAIRERESPONSE}
function TFHIRXmlParser.ParseQuestionnaireResponseItem(element : TMXmlElement; path : string) : TFhirQuestionnaireResponseItem;
var
  child : TMXmlElement;
begin
  result := TFhirQuestionnaireResponseItem.Create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseQuestionnaireResponseItemChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseQuestionnaireResponseItemChild(value : TFhirQuestionnaireResponseItem; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'linkId') then
        value.linkIdElement := ParseString(child, path+'/linkId')
      else if (child.localName = 'definition') then
        value.definitionElement := ParseUri(child, path+'/definition')
      else if (child.localName = 'text') then
        value.textElement := ParseString(child, path+'/text')
      else if (child.localName = 'answer') then
        value.answerList.Add(ParseQuestionnaireResponseItemAnswer(child, path+'/answer'))
      else if (child.localName = 'item') then
        value.itemList.Add(ParseQuestionnaireResponseItem(child, path+'/item'))
      else if Not ParseBackboneElementChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeQuestionnaireResponseItem(xml : TXmlBuilder; name : String; value : TFhirQuestionnaireResponseItem);
begin
  if (value = nil) then
    exit;
  composeElementAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeQuestionnaireResponseItemChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeQuestionnaireResponseItemChildren(xml : TXmlBuilder; value : TFhirQuestionnaireResponseItem);
var
  i : integer;
begin
  composeBackboneElementChildren(xml, value);
  ComposeString(xml, 'linkId', value.linkIdElement);
  if (SummaryOption in [soFull, soData]) then
    ComposeUri(xml, 'definition', value.definitionElement);
  if (SummaryOption in [soFull, soData]) then
    ComposeString(xml, 'text', value.textElement);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.answerList.Count - 1 do
      ComposeQuestionnaireResponseItemAnswer(xml, 'answer', value.answerList[i]);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.itemList.Count - 1 do
      ComposeQuestionnaireResponseItem(xml, 'item', value.itemList[i]);
end;

function TFHIRXmlParser.ParseQuestionnaireResponseItemAnswer(element : TMXmlElement; path : string) : TFhirQuestionnaireResponseItemAnswer;
var
  child : TMXmlElement;
begin
  result := TFhirQuestionnaireResponseItemAnswer.Create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseQuestionnaireResponseItemAnswerChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseQuestionnaireResponseItemAnswerChild(value : TFhirQuestionnaireResponseItemAnswer; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'valueAttachment') then
        value.value := ParseAttachment(child, path+'/valueAttachment')
      else if (child.localName = 'valueCoding') then
        value.value := ParseCoding(child, path+'/valueCoding')
      else if (child.localName = 'valueQuantity') then
        value.value := ParseQuantity(child, path+'/valueQuantity')
      else if (child.localName = 'valueReference') then
        value.value := ParseReference(child, path+'/valueReference')
      else if (child.localName = 'valueBoolean') then
        value.value := ParseBoolean(child, path+'/valueBoolean')
      else if (child.localName = 'valueDecimal') then
        value.value := ParseDecimal(child, path+'/valueDecimal')
      else if (child.localName = 'valueInteger') then
        value.value := ParseInteger(child, path+'/valueInteger')
      else if (child.localName = 'valueDate') then
        value.value := ParseDate(child, path+'/valueDate')
      else if (child.localName = 'valueDateTime') then
        value.value := ParseDateTime(child, path+'/valueDateTime')
      else if (child.localName = 'valueTime') then
        value.value := ParseTime(child, path+'/valueTime')
      else if (child.localName = 'valueString') then
        value.value := ParseString(child, path+'/valueString')
      else if (child.localName = 'valueUri') then
        value.value := ParseUri(child, path+'/valueUri')
      else if (child.localName = 'item') then
        value.itemList.Add(ParseQuestionnaireResponseItem(child, path+'/item'))
      else if Not ParseBackboneElementChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeQuestionnaireResponseItemAnswer(xml : TXmlBuilder; name : String; value : TFhirQuestionnaireResponseItemAnswer);
begin
  if (value = nil) then
    exit;
  composeElementAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeQuestionnaireResponseItemAnswerChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeQuestionnaireResponseItemAnswerChildren(xml : TXmlBuilder; value : TFhirQuestionnaireResponseItemAnswer);
var
  i : integer;
begin
  composeBackboneElementChildren(xml, value);
  if (value.value is TFhirAttachment) {6} then
    ComposeAttachment(xml, 'valueAttachment', TFhirAttachment(value.value))
  else if (value.value is TFhirCoding) {6} then
    ComposeCoding(xml, 'valueCoding', TFhirCoding(value.value))
  else if (value.value is TFhirQuantity) {6} then
    ComposeQuantity(xml, 'valueQuantity', TFhirQuantity(value.value))
  else if (value.value is TFhirReference) {2} then
    ComposeReference(xml, 'valueReference', TFhirReference(value.value))
  else if (value.value is TFhirBoolean) {6} then
    ComposeBoolean(xml, 'valueBoolean', TFhirBoolean(value.value))
  else if (value.value is TFhirDecimal) {6} then
    ComposeDecimal(xml, 'valueDecimal', TFhirDecimal(value.value))
  else if (value.value is TFhirInteger) {6} then
    ComposeInteger(xml, 'valueInteger', TFhirInteger(value.value))
  else if (value.value is TFhirDate) {6} then
    ComposeDate(xml, 'valueDate', TFhirDate(value.value))
  else if (value.value is TFhirDateTime) {6} then
    ComposeDateTime(xml, 'valueDateTime', TFhirDateTime(value.value))
  else if (value.value is TFhirTime) {6} then
    ComposeTime(xml, 'valueTime', TFhirTime(value.value))
  else if (value.value is TFhirString) {6} then
    ComposeString(xml, 'valueString', TFhirString(value.value))
  else if (value.value is TFhirUri) {6} then
    ComposeUri(xml, 'valueUri', TFhirUri(value.value));
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.itemList.Count - 1 do
      ComposeQuestionnaireResponseItem(xml, 'item', value.itemList[i]);
end;

function TFHIRXmlParser.ParseQuestionnaireResponse(element : TMXmlElement; path : string) : TFhirQuestionnaireResponse;
var
  child : TMXmlElement;
begin
  result := TFhirQuestionnaireResponse.Create;
  try
    parseDomainResourceAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseQuestionnaireResponseChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseQuestionnaireResponseChild(value : TFhirQuestionnaireResponse; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'identifier') then
        value.identifierList.Add(ParseIdentifier(child, path+'/identifier'))
      else if (child.localName = 'basedOn') then
        value.basedOnList.Add(ParseReference(child, path+'/basedOn'))
      else if (child.localName = 'partOf') then
        value.partOfList.Add(ParseReference(child, path+'/partOf'))
      else if (child.localName = 'questionnaire') then
        value.questionnaireElement := ParseCanonical(child, path+'/questionnaire')
      else if (child.localName = 'status') then
        value.statusElement := ParseEnum(CODES_TFhirQuestionnaireResponseStatusEnum, SYSTEMS_TFhirQuestionnaireResponseStatusEnum, child, path+'/status')
      else if (child.localName = 'subject') then
        value.subject := ParseReference(child, path+'/subject')
      else if (child.localName = 'encounter') then
        value.encounter := ParseReference(child, path+'/encounter')
      else if (child.localName = 'authored') then
        value.authoredElement := ParseDateTime(child, path+'/authored')
      else if (child.localName = 'author') then
        value.author := ParseReference(child, path+'/author')
      else if (child.localName = 'source') then
        value.source := ParseReference(child, path+'/source')
      else if (child.localName = 'item') then
        value.itemList.Add(ParseQuestionnaireResponseItem(child, path+'/item'))
      else if Not ParseDomainResourceChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeQuestionnaireResponse(xml : TXmlBuilder; name : String; value : TFhirQuestionnaireResponse);
begin
  if (value = nil) then
    exit;
  composeDomainResourceAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeQuestionnaireResponseChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeQuestionnaireResponseChildren(xml : TXmlBuilder; value : TFhirQuestionnaireResponse);
var
  i : integer;
begin
  composeDomainResourceChildren(xml, value);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.identifierList.Count - 1 do
      ComposeIdentifier(xml, 'identifier', value.identifierList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.basedOnList.Count - 1 do
      ComposeReference(xml, 'basedOn', value.basedOnList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.partOfList.Count - 1 do
      ComposeReference(xml, 'partOf', value.partOfList[i]);
  ComposeCanonical(xml, 'questionnaire', value.questionnaireElement);
  ComposeEnum(xml, 'status', value.statusElement, CODES_TFhirQuestionnaireResponseStatusEnum);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference(xml, 'subject', value.subject);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference(xml, 'encounter', value.encounter);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDateTime(xml, 'authored', value.authoredElement);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference(xml, 'author', value.author);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference(xml, 'source', value.source);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.itemList.Count - 1 do
      ComposeQuestionnaireResponseItem(xml, 'item', value.itemList[i]);
end;

{$ENDIF FHIR_QUESTIONNAIRERESPONSE}
{$IFDEF FHIR_REGULATEDAUTHORIZATION}
function TFHIRXmlParser.ParseRegulatedAuthorizationCase(element : TMXmlElement; path : string) : TFhirRegulatedAuthorizationCase;
var
  child : TMXmlElement;
begin
  result := TFhirRegulatedAuthorizationCase.Create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseRegulatedAuthorizationCaseChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseRegulatedAuthorizationCaseChild(value : TFhirRegulatedAuthorizationCase; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'identifier') then
        value.identifier := ParseIdentifier(child, path+'/identifier')
      else if (child.localName = 'type') then
        value.type_ := ParseCodeableConcept(child, path+'/type')
      else if (child.localName = 'status') then
        value.status := ParseCodeableConcept(child, path+'/status')
      else if (child.localName = 'datePeriod') then
        value.date := ParsePeriod(child, path+'/datePeriod')
      else if (child.localName = 'dateDateTime') then
        value.date := ParseDateTime(child, path+'/dateDateTime')
      else if (child.localName = 'application') then
        value.applicationList.Add(ParseRegulatedAuthorizationCase(child, path+'/application'))
      else if Not ParseBackboneElementChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeRegulatedAuthorizationCase(xml : TXmlBuilder; name : String; value : TFhirRegulatedAuthorizationCase);
begin
  if (value = nil) then
    exit;
  composeElementAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeRegulatedAuthorizationCaseChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeRegulatedAuthorizationCaseChildren(xml : TXmlBuilder; value : TFhirRegulatedAuthorizationCase);
var
  i : integer;
begin
  composeBackboneElementChildren(xml, value);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeIdentifier(xml, 'identifier', value.identifier);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(xml, 'type', value.type_);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(xml, 'status', value.status);
  if (SummaryOption in [soFull, soSummary, soData]) and (value.date is TFhirPeriod) {6} then
    ComposePeriod(xml, 'datePeriod', TFhirPeriod(value.date))
  else if (SummaryOption in [soFull, soSummary, soData]) and (value.date is TFhirDateTime) {6} then
    ComposeDateTime(xml, 'dateDateTime', TFhirDateTime(value.date));
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.applicationList.Count - 1 do
      ComposeRegulatedAuthorizationCase(xml, 'application', value.applicationList[i]);
end;

function TFHIRXmlParser.ParseRegulatedAuthorization(element : TMXmlElement; path : string) : TFhirRegulatedAuthorization;
var
  child : TMXmlElement;
begin
  result := TFhirRegulatedAuthorization.Create;
  try
    parseDomainResourceAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseRegulatedAuthorizationChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseRegulatedAuthorizationChild(value : TFhirRegulatedAuthorization; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'identifier') then
        value.identifierList.Add(ParseIdentifier(child, path+'/identifier'))
      else if (child.localName = 'subject') then
        value.subjectList.Add(ParseReference(child, path+'/subject'))
      else if (child.localName = 'type') then
        value.type_ := ParseCodeableConcept(child, path+'/type')
      else if (child.localName = 'description') then
        value.descriptionElement := ParseMarkdown(child, path+'/description')
      else if (child.localName = 'region') then
        value.regionList.Add(ParseCodeableConcept(child, path+'/region'))
      else if (child.localName = 'status') then
        value.status := ParseCodeableConcept(child, path+'/status')
      else if (child.localName = 'statusDate') then
        value.statusDateElement := ParseDateTime(child, path+'/statusDate')
      else if (child.localName = 'validityPeriod') then
        value.validityPeriod := ParsePeriod(child, path+'/validityPeriod')
      else if (child.localName = 'indication') then
        value.indicationList.Add(ParseCodeableReference(child, path+'/indication'))
      else if (child.localName = 'intendedUse') then
        value.intendedUse := ParseCodeableConcept(child, path+'/intendedUse')
      else if (child.localName = 'basis') then
        value.basisList.Add(ParseCodeableConcept(child, path+'/basis'))
      else if (child.localName = 'holder') then
        value.holder := ParseReference(child, path+'/holder')
      else if (child.localName = 'regulator') then
        value.regulator := ParseReference(child, path+'/regulator')
      else if (child.localName = 'attachedDocument') then
        value.attachedDocumentList.Add(ParseReference(child, path+'/attachedDocument'))
      else if (child.localName = 'case') then
        value.case_ := ParseRegulatedAuthorizationCase(child, path+'/case')
      else if Not ParseDomainResourceChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeRegulatedAuthorization(xml : TXmlBuilder; name : String; value : TFhirRegulatedAuthorization);
begin
  if (value = nil) then
    exit;
  composeDomainResourceAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeRegulatedAuthorizationChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeRegulatedAuthorizationChildren(xml : TXmlBuilder; value : TFhirRegulatedAuthorization);
var
  i : integer;
begin
  composeDomainResourceChildren(xml, value);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.identifierList.Count - 1 do
      ComposeIdentifier(xml, 'identifier', value.identifierList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.subjectList.Count - 1 do
      ComposeReference(xml, 'subject', value.subjectList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(xml, 'type', value.type_);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeMarkdown(xml, 'description', value.descriptionElement);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.regionList.Count - 1 do
      ComposeCodeableConcept(xml, 'region', value.regionList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(xml, 'status', value.status);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDateTime(xml, 'statusDate', value.statusDateElement);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposePeriod(xml, 'validityPeriod', value.validityPeriod);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.indicationList.Count - 1 do
      ComposeCodeableReference(xml, 'indication', value.indicationList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(xml, 'intendedUse', value.intendedUse);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.basisList.Count - 1 do
      ComposeCodeableConcept(xml, 'basis', value.basisList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference(xml, 'holder', value.holder);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference(xml, 'regulator', value.regulator);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.attachedDocumentList.Count - 1 do
      ComposeReference(xml, 'attachedDocument', value.attachedDocumentList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeRegulatedAuthorizationCase(xml, 'case', value.case_);
end;

{$ENDIF FHIR_REGULATEDAUTHORIZATION}
{$IFDEF FHIR_RELATEDPERSON}
function TFHIRXmlParser.ParseRelatedPersonCommunication(element : TMXmlElement; path : string) : TFhirRelatedPersonCommunication;
var
  child : TMXmlElement;
begin
  result := TFhirRelatedPersonCommunication.Create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseRelatedPersonCommunicationChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseRelatedPersonCommunicationChild(value : TFhirRelatedPersonCommunication; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'language') then
        value.language := ParseCodeableConcept(child, path+'/language')
      else if (child.localName = 'preferred') then
        value.preferredElement := ParseBoolean(child, path+'/preferred')
      else if Not ParseBackboneElementChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeRelatedPersonCommunication(xml : TXmlBuilder; name : String; value : TFhirRelatedPersonCommunication);
begin
  if (value = nil) then
    exit;
  composeElementAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeRelatedPersonCommunicationChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeRelatedPersonCommunicationChildren(xml : TXmlBuilder; value : TFhirRelatedPersonCommunication);
begin
  composeBackboneElementChildren(xml, value);
  ComposeCodeableConcept(xml, 'language', value.language);
  if (SummaryOption in [soFull, soData]) then
    ComposeBoolean(xml, 'preferred', value.preferredElement);
end;

function TFHIRXmlParser.ParseRelatedPerson(element : TMXmlElement; path : string) : TFhirRelatedPerson;
var
  child : TMXmlElement;
begin
  result := TFhirRelatedPerson.Create;
  try
    parseDomainResourceAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseRelatedPersonChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseRelatedPersonChild(value : TFhirRelatedPerson; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'identifier') then
        value.identifierList.Add(ParseIdentifier(child, path+'/identifier'))
      else if (child.localName = 'active') then
        value.activeElement := ParseBoolean(child, path+'/active')
      else if (child.localName = 'patient') then
        value.patient := ParseReference(child, path+'/patient')
      else if (child.localName = 'relationship') then
        value.relationshipList.Add(ParseCodeableConcept(child, path+'/relationship'))
      else if (child.localName = 'name') then
        value.nameList.Add(ParseHumanName(child, path+'/name'))
      else if (child.localName = 'telecom') then
        value.telecomList.Add(ParseContactPoint(child, path+'/telecom'))
      else if (child.localName = 'gender') then
        value.genderElement := ParseEnum(CODES_TFhirAdministrativeGenderEnum, SYSTEMS_TFhirAdministrativeGenderEnum, child, path+'/gender')
      else if (child.localName = 'birthDate') then
        value.birthDateElement := ParseDate(child, path+'/birthDate')
      else if (child.localName = 'address') then
        value.addressList.Add(ParseAddress(child, path+'/address'))
      else if (child.localName = 'photo') then
        value.photoList.Add(ParseAttachment(child, path+'/photo'))
      else if (child.localName = 'period') then
        value.period := ParsePeriod(child, path+'/period')
      else if (child.localName = 'communication') then
        value.communicationList.Add(ParseRelatedPersonCommunication(child, path+'/communication'))
      else if Not ParseDomainResourceChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeRelatedPerson(xml : TXmlBuilder; name : String; value : TFhirRelatedPerson);
begin
  if (value = nil) then
    exit;
  composeDomainResourceAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeRelatedPersonChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeRelatedPersonChildren(xml : TXmlBuilder; value : TFhirRelatedPerson);
var
  i : integer;
begin
  composeDomainResourceChildren(xml, value);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.identifierList.Count - 1 do
      ComposeIdentifier(xml, 'identifier', value.identifierList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeBoolean(xml, 'active', value.activeElement);
  ComposeReference(xml, 'patient', value.patient);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.relationshipList.Count - 1 do
      ComposeCodeableConcept(xml, 'relationship', value.relationshipList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.nameList.Count - 1 do
      ComposeHumanName(xml, 'name', value.nameList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.telecomList.Count - 1 do
      ComposeContactPoint(xml, 'telecom', value.telecomList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeEnum(xml, 'gender', value.genderElement, CODES_TFhirAdministrativeGenderEnum);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDate(xml, 'birthDate', value.birthDateElement);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.addressList.Count - 1 do
      ComposeAddress(xml, 'address', value.addressList[i]);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.photoList.Count - 1 do
      ComposeAttachment(xml, 'photo', value.photoList[i]);
  if (SummaryOption in [soFull, soData]) then
    ComposePeriod(xml, 'period', value.period);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.communicationList.Count - 1 do
      ComposeRelatedPersonCommunication(xml, 'communication', value.communicationList[i]);
end;

{$ENDIF FHIR_RELATEDPERSON}
{$IFDEF FHIR_REQUESTGROUP}
function TFHIRXmlParser.ParseRequestGroupAction(element : TMXmlElement; path : string) : TFhirRequestGroupAction;
var
  child : TMXmlElement;
begin
  result := TFhirRequestGroupAction.Create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseRequestGroupActionChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseRequestGroupActionChild(value : TFhirRequestGroupAction; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'linkId') then
        value.linkIdElement := ParseString(child, path+'/linkId')
      else if (child.localName = 'prefix') then
        value.prefixElement := ParseString(child, path+'/prefix')
      else if (child.localName = 'title') then
        value.titleElement := ParseString(child, path+'/title')
      else if (child.localName = 'description') then
        value.descriptionElement := ParseString(child, path+'/description')
      else if (child.localName = 'textEquivalent') then
        value.textEquivalentElement := ParseString(child, path+'/textEquivalent')
      else if (child.localName = 'priority') then
        value.priorityElement := ParseCode(child, path+'/priority')
      else if (child.localName = 'code') then
        value.codeList.Add(ParseCodeableConcept(child, path+'/code'))
      else if (child.localName = 'documentation') then
        value.documentationList.Add(ParseRelatedArtifact(child, path+'/documentation'))
      else if (child.localName = 'goal') then
        value.goalList.Add(ParseReference(child, path+'/goal'))
      else if (child.localName = 'condition') then
        value.conditionList.Add(ParseRequestGroupActionCondition(child, path+'/condition'))
      else if (child.localName = 'relatedAction') then
        value.relatedActionList.Add(ParseRequestGroupActionRelatedAction(child, path+'/relatedAction'))
      else if (child.localName = 'timingAge') then
        value.timing := ParseAge(child, path+'/timingAge')
      else if (child.localName = 'timingPeriod') then
        value.timing := ParsePeriod(child, path+'/timingPeriod')
      else if (child.localName = 'timingDuration') then
        value.timing := ParseDuration(child, path+'/timingDuration')
      else if (child.localName = 'timingRange') then
        value.timing := ParseRange(child, path+'/timingRange')
      else if (child.localName = 'timingTiming') then
        value.timing := ParseTiming(child, path+'/timingTiming')
      else if (child.localName = 'timingDateTime') then
        value.timing := ParseDateTime(child, path+'/timingDateTime')
      else if (child.localName = 'location') then
        value.location := ParseCodeableReference(child, path+'/location')
      else if (child.localName = 'participant') then
        value.participantList.Add(ParseRequestGroupActionParticipant(child, path+'/participant'))
      else if (child.localName = 'type') then
        value.type_ := ParseCodeableConcept(child, path+'/type')
      else if (child.localName = 'groupingBehavior') then
        value.groupingBehaviorElement := ParseCode(child, path+'/groupingBehavior')
      else if (child.localName = 'selectionBehavior') then
        value.selectionBehaviorElement := ParseCode(child, path+'/selectionBehavior')
      else if (child.localName = 'requiredBehavior') then
        value.requiredBehaviorElement := ParseCode(child, path+'/requiredBehavior')
      else if (child.localName = 'precheckBehavior') then
        value.precheckBehaviorElement := ParseCode(child, path+'/precheckBehavior')
      else if (child.localName = 'cardinalityBehavior') then
        value.cardinalityBehaviorElement := ParseCode(child, path+'/cardinalityBehavior')
      else if (child.localName = 'resource') then
        value.resource := ParseReference(child, path+'/resource')
      else if (child.localName = 'action') then
        value.actionList.Add(ParseRequestGroupAction(child, path+'/action'))
      else if Not ParseBackboneElementChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeRequestGroupAction(xml : TXmlBuilder; name : String; value : TFhirRequestGroupAction);
begin
  if (value = nil) then
    exit;
  composeElementAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeRequestGroupActionChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeRequestGroupActionChildren(xml : TXmlBuilder; value : TFhirRequestGroupAction);
var
  i : integer;
begin
  composeBackboneElementChildren(xml, value);
  if (SummaryOption in [soFull, soData]) then
    ComposeString(xml, 'linkId', value.linkIdElement);
  if (SummaryOption in [soFull, soData]) then
    ComposeString(xml, 'prefix', value.prefixElement);
  if (SummaryOption in [soFull, soData]) then
    ComposeString(xml, 'title', value.titleElement);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(xml, 'description', value.descriptionElement);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(xml, 'textEquivalent', value.textEquivalentElement);
  if (SummaryOption in [soFull, soData]) then
    ComposeCode(xml, 'priority', value.priorityElement);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.codeList.Count - 1 do
      ComposeCodeableConcept(xml, 'code', value.codeList[i]);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.documentationList.Count - 1 do
      ComposeRelatedArtifact(xml, 'documentation', value.documentationList[i]);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.goalList.Count - 1 do
      ComposeReference(xml, 'goal', value.goalList[i]);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.conditionList.Count - 1 do
      ComposeRequestGroupActionCondition(xml, 'condition', value.conditionList[i]);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.relatedActionList.Count - 1 do
      ComposeRequestGroupActionRelatedAction(xml, 'relatedAction', value.relatedActionList[i]);
  if (SummaryOption in [soFull, soData]) and (value.timing is TFhirAge) {6} then
    ComposeAge(xml, 'timingAge', TFhirAge(value.timing))
  else if (SummaryOption in [soFull, soData]) and (value.timing is TFhirPeriod) {6} then
    ComposePeriod(xml, 'timingPeriod', TFhirPeriod(value.timing))
  else if (SummaryOption in [soFull, soData]) and (value.timing is TFhirDuration) {6} then
    ComposeDuration(xml, 'timingDuration', TFhirDuration(value.timing))
  else if (SummaryOption in [soFull, soData]) and (value.timing is TFhirRange) {6} then
    ComposeRange(xml, 'timingRange', TFhirRange(value.timing))
  else if (SummaryOption in [soFull, soData]) and (value.timing is TFhirTiming) {6} then
    ComposeTiming(xml, 'timingTiming', TFhirTiming(value.timing))
  else if (SummaryOption in [soFull, soData]) and (value.timing is TFhirDateTime) {6} then
    ComposeDateTime(xml, 'timingDateTime', TFhirDateTime(value.timing));
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableReference(xml, 'location', value.location);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.participantList.Count - 1 do
      ComposeRequestGroupActionParticipant(xml, 'participant', value.participantList[i]);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(xml, 'type', value.type_);
  if (SummaryOption in [soFull, soData]) then
    ComposeCode(xml, 'groupingBehavior', value.groupingBehaviorElement);
  if (SummaryOption in [soFull, soData]) then
    ComposeCode(xml, 'selectionBehavior', value.selectionBehaviorElement);
  if (SummaryOption in [soFull, soData]) then
    ComposeCode(xml, 'requiredBehavior', value.requiredBehaviorElement);
  if (SummaryOption in [soFull, soData]) then
    ComposeCode(xml, 'precheckBehavior', value.precheckBehaviorElement);
  if (SummaryOption in [soFull, soData]) then
    ComposeCode(xml, 'cardinalityBehavior', value.cardinalityBehaviorElement);
  if (SummaryOption in [soFull, soData]) then
    ComposeReference(xml, 'resource', value.resource);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.actionList.Count - 1 do
      ComposeRequestGroupAction(xml, 'action', value.actionList[i]);
end;

function TFHIRXmlParser.ParseRequestGroupActionCondition(element : TMXmlElement; path : string) : TFhirRequestGroupActionCondition;
var
  child : TMXmlElement;
begin
  result := TFhirRequestGroupActionCondition.Create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseRequestGroupActionConditionChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseRequestGroupActionConditionChild(value : TFhirRequestGroupActionCondition; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'kind') then
        value.kindElement := ParseCode(child, path+'/kind')
      else if (child.localName = 'expression') then
        value.expression := ParseExpression(child, path+'/expression')
      else if Not ParseBackboneElementChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeRequestGroupActionCondition(xml : TXmlBuilder; name : String; value : TFhirRequestGroupActionCondition);
begin
  if (value = nil) then
    exit;
  composeElementAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeRequestGroupActionConditionChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeRequestGroupActionConditionChildren(xml : TXmlBuilder; value : TFhirRequestGroupActionCondition);
begin
  composeBackboneElementChildren(xml, value);
  ComposeCode(xml, 'kind', value.kindElement);
  if (SummaryOption in [soFull, soData]) then
    ComposeExpression(xml, 'expression', value.expression);
end;

function TFHIRXmlParser.ParseRequestGroupActionRelatedAction(element : TMXmlElement; path : string) : TFhirRequestGroupActionRelatedAction;
var
  child : TMXmlElement;
begin
  result := TFhirRequestGroupActionRelatedAction.Create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseRequestGroupActionRelatedActionChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseRequestGroupActionRelatedActionChild(value : TFhirRequestGroupActionRelatedAction; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'targetId') then
        value.targetIdElement := ParseId(child, path+'/targetId')
      else if (child.localName = 'relationship') then
        value.relationshipElement := ParseCode(child, path+'/relationship')
      else if (child.localName = 'offsetDuration') then
        value.offset := ParseDuration(child, path+'/offsetDuration')
      else if (child.localName = 'offsetRange') then
        value.offset := ParseRange(child, path+'/offsetRange')
      else if Not ParseBackboneElementChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeRequestGroupActionRelatedAction(xml : TXmlBuilder; name : String; value : TFhirRequestGroupActionRelatedAction);
begin
  if (value = nil) then
    exit;
  composeElementAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeRequestGroupActionRelatedActionChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeRequestGroupActionRelatedActionChildren(xml : TXmlBuilder; value : TFhirRequestGroupActionRelatedAction);
begin
  composeBackboneElementChildren(xml, value);
  ComposeId(xml, 'targetId', value.targetIdElement);
  ComposeCode(xml, 'relationship', value.relationshipElement);
  if (SummaryOption in [soFull, soData]) and (value.offset is TFhirDuration) {6} then
    ComposeDuration(xml, 'offsetDuration', TFhirDuration(value.offset))
  else if (SummaryOption in [soFull, soData]) and (value.offset is TFhirRange) {6} then
    ComposeRange(xml, 'offsetRange', TFhirRange(value.offset));
end;

function TFHIRXmlParser.ParseRequestGroupActionParticipant(element : TMXmlElement; path : string) : TFhirRequestGroupActionParticipant;
var
  child : TMXmlElement;
begin
  result := TFhirRequestGroupActionParticipant.Create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseRequestGroupActionParticipantChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseRequestGroupActionParticipantChild(value : TFhirRequestGroupActionParticipant; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'type') then
        value.type_Element := ParseCode(child, path+'/type')
      else if (child.localName = 'typeReference') then
        value.typeReference := ParseReference(child, path+'/typeReference')
      else if (child.localName = 'role') then
        value.role := ParseCodeableConcept(child, path+'/role')
      else if (child.localName = 'function') then
        value.function_ := ParseCodeableConcept(child, path+'/function')
      else if (child.localName = 'actor') then
        value.actor := ParseReference(child, path+'/actor')
      else if Not ParseBackboneElementChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeRequestGroupActionParticipant(xml : TXmlBuilder; name : String; value : TFhirRequestGroupActionParticipant);
begin
  if (value = nil) then
    exit;
  composeElementAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeRequestGroupActionParticipantChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeRequestGroupActionParticipantChildren(xml : TXmlBuilder; value : TFhirRequestGroupActionParticipant);
begin
  composeBackboneElementChildren(xml, value);
  if (SummaryOption in [soFull, soData]) then
    ComposeCode(xml, 'type', value.type_Element);
  if (SummaryOption in [soFull, soData]) then
    ComposeReference(xml, 'typeReference', value.typeReference);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(xml, 'role', value.role);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(xml, 'function', value.function_);
  if (SummaryOption in [soFull, soData]) then
    ComposeReference(xml, 'actor', value.actor);
end;

function TFHIRXmlParser.ParseRequestGroup(element : TMXmlElement; path : string) : TFhirRequestGroup;
var
  child : TMXmlElement;
begin
  result := TFhirRequestGroup.Create;
  try
    parseDomainResourceAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseRequestGroupChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseRequestGroupChild(value : TFhirRequestGroup; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'identifier') then
        value.identifierList.Add(ParseIdentifier(child, path+'/identifier'))
      else if (child.localName = 'instantiatesCanonical') then
        value.instantiatesCanonicalList.Add(ParseCanonical(child, path+'/instantiatesCanonical'))
      else if (child.localName = 'instantiatesUri') then
        value.instantiatesUriList.Add(ParseUri(child, path+'/instantiatesUri'))
      else if (child.localName = 'basedOn') then
        value.basedOnList.Add(ParseReference(child, path+'/basedOn'))
      else if (child.localName = 'replaces') then
        value.replacesList.Add(ParseReference(child, path+'/replaces'))
      else if (child.localName = 'groupIdentifier') then
        value.groupIdentifier := ParseIdentifier(child, path+'/groupIdentifier')
      else if (child.localName = 'status') then
        value.statusElement := ParseCode(child, path+'/status')
      else if (child.localName = 'intent') then
        value.intentElement := ParseCode(child, path+'/intent')
      else if (child.localName = 'priority') then
        value.priorityElement := ParseCode(child, path+'/priority')
      else if (child.localName = 'code') then
        value.code := ParseCodeableConcept(child, path+'/code')
      else if (child.localName = 'subject') then
        value.subject := ParseReference(child, path+'/subject')
      else if (child.localName = 'encounter') then
        value.encounter := ParseReference(child, path+'/encounter')
      else if (child.localName = 'authoredOn') then
        value.authoredOnElement := ParseDateTime(child, path+'/authoredOn')
      else if (child.localName = 'author') then
        value.author := ParseReference(child, path+'/author')
      else if (child.localName = 'reason') then
        value.reasonList.Add(ParseCodeableReference(child, path+'/reason'))
      else if (child.localName = 'goal') then
        value.goalList.Add(ParseReference(child, path+'/goal'))
      else if (child.localName = 'note') then
        value.noteList.Add(ParseAnnotation(child, path+'/note'))
      else if (child.localName = 'action') then
        value.actionList.Add(ParseRequestGroupAction(child, path+'/action'))
      else if Not ParseDomainResourceChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeRequestGroup(xml : TXmlBuilder; name : String; value : TFhirRequestGroup);
begin
  if (value = nil) then
    exit;
  composeDomainResourceAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeRequestGroupChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeRequestGroupChildren(xml : TXmlBuilder; value : TFhirRequestGroup);
var
  i : integer;
begin
  composeDomainResourceChildren(xml, value);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.identifierList.Count - 1 do
      ComposeIdentifier(xml, 'identifier', value.identifierList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.instantiatesCanonicalList.Count - 1 do
      ComposeCanonical(xml, 'instantiatesCanonical', value.instantiatesCanonicalList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.instantiatesUriList.Count - 1 do
      ComposeUri(xml, 'instantiatesUri', value.instantiatesUriList[i]);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.basedOnList.Count - 1 do
      ComposeReference(xml, 'basedOn', value.basedOnList[i]);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.replacesList.Count - 1 do
      ComposeReference(xml, 'replaces', value.replacesList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeIdentifier(xml, 'groupIdentifier', value.groupIdentifier);
  ComposeCode(xml, 'status', value.statusElement);
  ComposeCode(xml, 'intent', value.intentElement);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCode(xml, 'priority', value.priorityElement);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(xml, 'code', value.code);
  if (SummaryOption in [soFull, soData]) then
    ComposeReference(xml, 'subject', value.subject);
  if (SummaryOption in [soFull, soData]) then
    ComposeReference(xml, 'encounter', value.encounter);
  if (SummaryOption in [soFull, soData]) then
    ComposeDateTime(xml, 'authoredOn', value.authoredOnElement);
  if (SummaryOption in [soFull, soData]) then
    ComposeReference(xml, 'author', value.author);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.reasonList.Count - 1 do
      ComposeCodeableReference(xml, 'reason', value.reasonList[i]);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.goalList.Count - 1 do
      ComposeReference(xml, 'goal', value.goalList[i]);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.noteList.Count - 1 do
      ComposeAnnotation(xml, 'note', value.noteList[i]);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.actionList.Count - 1 do
      ComposeRequestGroupAction(xml, 'action', value.actionList[i]);
end;

{$ENDIF FHIR_REQUESTGROUP}
{$IFDEF FHIR_REQUESTORCHESTRATION}
function TFHIRXmlParser.ParseRequestOrchestrationAction(element : TMXmlElement; path : string) : TFhirRequestOrchestrationAction;
var
  child : TMXmlElement;
begin
  result := TFhirRequestOrchestrationAction.Create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseRequestOrchestrationActionChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseRequestOrchestrationActionChild(value : TFhirRequestOrchestrationAction; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'linkId') then
        value.linkIdElement := ParseString(child, path+'/linkId')
      else if (child.localName = 'prefix') then
        value.prefixElement := ParseString(child, path+'/prefix')
      else if (child.localName = 'title') then
        value.titleElement := ParseString(child, path+'/title')
      else if (child.localName = 'description') then
        value.descriptionElement := ParseString(child, path+'/description')
      else if (child.localName = 'textEquivalent') then
        value.textEquivalentElement := ParseString(child, path+'/textEquivalent')
      else if (child.localName = 'priority') then
        value.priorityElement := ParseEnum(CODES_TFhirRequestPriorityEnum, SYSTEMS_TFhirRequestPriorityEnum, child, path+'/priority')
      else if (child.localName = 'code') then
        value.codeList.Add(ParseCodeableConcept(child, path+'/code'))
      else if (child.localName = 'documentation') then
        value.documentationList.Add(ParseRelatedArtifact(child, path+'/documentation'))
      else if (child.localName = 'goal') then
        value.goalList.Add(ParseReference(child, path+'/goal'))
      else if (child.localName = 'condition') then
        value.conditionList.Add(ParseRequestOrchestrationActionCondition(child, path+'/condition'))
      else if (child.localName = 'input') then
        value.inputList.Add(ParseRequestOrchestrationActionInput(child, path+'/input'))
      else if (child.localName = 'output') then
        value.outputList.Add(ParseRequestOrchestrationActionOutput(child, path+'/output'))
      else if (child.localName = 'relatedAction') then
        value.relatedActionList.Add(ParseRequestOrchestrationActionRelatedAction(child, path+'/relatedAction'))
      else if (child.localName = 'timingAge') then
        value.timing := ParseAge(child, path+'/timingAge')
      else if (child.localName = 'timingPeriod') then
        value.timing := ParsePeriod(child, path+'/timingPeriod')
      else if (child.localName = 'timingDuration') then
        value.timing := ParseDuration(child, path+'/timingDuration')
      else if (child.localName = 'timingRange') then
        value.timing := ParseRange(child, path+'/timingRange')
      else if (child.localName = 'timingTiming') then
        value.timing := ParseTiming(child, path+'/timingTiming')
      else if (child.localName = 'timingDateTime') then
        value.timing := ParseDateTime(child, path+'/timingDateTime')
      else if (child.localName = 'location') then
        value.location := ParseCodeableReference(child, path+'/location')
      else if (child.localName = 'participant') then
        value.participantList.Add(ParseRequestOrchestrationActionParticipant(child, path+'/participant'))
      else if (child.localName = 'type') then
        value.type_ := ParseCodeableConcept(child, path+'/type')
      else if (child.localName = 'groupingBehavior') then
        value.groupingBehaviorElement := ParseEnum(CODES_TFhirActionGroupingBehaviorEnum, SYSTEMS_TFhirActionGroupingBehaviorEnum, child, path+'/groupingBehavior')
      else if (child.localName = 'selectionBehavior') then
        value.selectionBehaviorElement := ParseEnum(CODES_TFhirActionSelectionBehaviorEnum, SYSTEMS_TFhirActionSelectionBehaviorEnum, child, path+'/selectionBehavior')
      else if (child.localName = 'requiredBehavior') then
        value.requiredBehaviorElement := ParseEnum(CODES_TFhirActionRequiredBehaviorEnum, SYSTEMS_TFhirActionRequiredBehaviorEnum, child, path+'/requiredBehavior')
      else if (child.localName = 'precheckBehavior') then
        value.precheckBehaviorElement := ParseEnum(CODES_TFhirActionPrecheckBehaviorEnum, SYSTEMS_TFhirActionPrecheckBehaviorEnum, child, path+'/precheckBehavior')
      else if (child.localName = 'cardinalityBehavior') then
        value.cardinalityBehaviorElement := ParseEnum(CODES_TFhirActionCardinalityBehaviorEnum, SYSTEMS_TFhirActionCardinalityBehaviorEnum, child, path+'/cardinalityBehavior')
      else if (child.localName = 'resource') then
        value.resource := ParseReference(child, path+'/resource')
      else if (child.localName = 'definitionCanonical') then
        value.definition := ParseCanonical(child, path+'/definitionCanonical')
      else if (child.localName = 'definitionUri') then
        value.definition := ParseUri(child, path+'/definitionUri')
      else if (child.localName = 'transform') then
        value.transformElement := ParseCanonical(child, path+'/transform')
      else if (child.localName = 'dynamicValue') then
        value.dynamicValueList.Add(ParseRequestOrchestrationActionDynamicValue(child, path+'/dynamicValue'))
      else if (child.localName = 'action') then
        value.actionList.Add(ParseRequestOrchestrationAction(child, path+'/action'))
      else if Not ParseBackboneElementChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeRequestOrchestrationAction(xml : TXmlBuilder; name : String; value : TFhirRequestOrchestrationAction);
begin
  if (value = nil) then
    exit;
  composeElementAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeRequestOrchestrationActionChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeRequestOrchestrationActionChildren(xml : TXmlBuilder; value : TFhirRequestOrchestrationAction);
var
  i : integer;
begin
  composeBackboneElementChildren(xml, value);
  if (SummaryOption in [soFull, soData]) then
    ComposeString(xml, 'linkId', value.linkIdElement);
  if (SummaryOption in [soFull, soData]) then
    ComposeString(xml, 'prefix', value.prefixElement);
  if (SummaryOption in [soFull, soData]) then
    ComposeString(xml, 'title', value.titleElement);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(xml, 'description', value.descriptionElement);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(xml, 'textEquivalent', value.textEquivalentElement);
  if (SummaryOption in [soFull, soData]) then
    ComposeEnum(xml, 'priority', value.priorityElement, CODES_TFhirRequestPriorityEnum);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.codeList.Count - 1 do
      ComposeCodeableConcept(xml, 'code', value.codeList[i]);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.documentationList.Count - 1 do
      ComposeRelatedArtifact(xml, 'documentation', value.documentationList[i]);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.goalList.Count - 1 do
      ComposeReference(xml, 'goal', value.goalList[i]);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.conditionList.Count - 1 do
      ComposeRequestOrchestrationActionCondition(xml, 'condition', value.conditionList[i]);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.inputList.Count - 1 do
      ComposeRequestOrchestrationActionInput(xml, 'input', value.inputList[i]);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.outputList.Count - 1 do
      ComposeRequestOrchestrationActionOutput(xml, 'output', value.outputList[i]);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.relatedActionList.Count - 1 do
      ComposeRequestOrchestrationActionRelatedAction(xml, 'relatedAction', value.relatedActionList[i]);
  if (SummaryOption in [soFull, soData]) and (value.timing is TFhirAge) {6} then
    ComposeAge(xml, 'timingAge', TFhirAge(value.timing))
  else if (SummaryOption in [soFull, soData]) and (value.timing is TFhirPeriod) {6} then
    ComposePeriod(xml, 'timingPeriod', TFhirPeriod(value.timing))
  else if (SummaryOption in [soFull, soData]) and (value.timing is TFhirDuration) {6} then
    ComposeDuration(xml, 'timingDuration', TFhirDuration(value.timing))
  else if (SummaryOption in [soFull, soData]) and (value.timing is TFhirRange) {6} then
    ComposeRange(xml, 'timingRange', TFhirRange(value.timing))
  else if (SummaryOption in [soFull, soData]) and (value.timing is TFhirTiming) {6} then
    ComposeTiming(xml, 'timingTiming', TFhirTiming(value.timing))
  else if (SummaryOption in [soFull, soData]) and (value.timing is TFhirDateTime) {6} then
    ComposeDateTime(xml, 'timingDateTime', TFhirDateTime(value.timing));
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableReference(xml, 'location', value.location);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.participantList.Count - 1 do
      ComposeRequestOrchestrationActionParticipant(xml, 'participant', value.participantList[i]);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(xml, 'type', value.type_);
  if (SummaryOption in [soFull, soData]) then
    ComposeEnum(xml, 'groupingBehavior', value.groupingBehaviorElement, CODES_TFhirActionGroupingBehaviorEnum);
  if (SummaryOption in [soFull, soData]) then
    ComposeEnum(xml, 'selectionBehavior', value.selectionBehaviorElement, CODES_TFhirActionSelectionBehaviorEnum);
  if (SummaryOption in [soFull, soData]) then
    ComposeEnum(xml, 'requiredBehavior', value.requiredBehaviorElement, CODES_TFhirActionRequiredBehaviorEnum);
  if (SummaryOption in [soFull, soData]) then
    ComposeEnum(xml, 'precheckBehavior', value.precheckBehaviorElement, CODES_TFhirActionPrecheckBehaviorEnum);
  if (SummaryOption in [soFull, soData]) then
    ComposeEnum(xml, 'cardinalityBehavior', value.cardinalityBehaviorElement, CODES_TFhirActionCardinalityBehaviorEnum);
  if (SummaryOption in [soFull, soData]) then
    ComposeReference(xml, 'resource', value.resource);
  if (SummaryOption in [soFull, soData]) and (value.definition is TFhirCanonical) {6} then
    ComposeCanonical(xml, 'definitionCanonical', TFhirCanonical(value.definition))
  else if (SummaryOption in [soFull, soData]) and (value.definition is TFhirUri) {6} then
    ComposeUri(xml, 'definitionUri', TFhirUri(value.definition));
  if (SummaryOption in [soFull, soData]) then
    ComposeCanonical(xml, 'transform', value.transformElement);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.dynamicValueList.Count - 1 do
      ComposeRequestOrchestrationActionDynamicValue(xml, 'dynamicValue', value.dynamicValueList[i]);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.actionList.Count - 1 do
      ComposeRequestOrchestrationAction(xml, 'action', value.actionList[i]);
end;

function TFHIRXmlParser.ParseRequestOrchestrationActionCondition(element : TMXmlElement; path : string) : TFhirRequestOrchestrationActionCondition;
var
  child : TMXmlElement;
begin
  result := TFhirRequestOrchestrationActionCondition.Create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseRequestOrchestrationActionConditionChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseRequestOrchestrationActionConditionChild(value : TFhirRequestOrchestrationActionCondition; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'kind') then
        value.kindElement := ParseEnum(CODES_TFhirActionConditionKindEnum, SYSTEMS_TFhirActionConditionKindEnum, child, path+'/kind')
      else if (child.localName = 'expression') then
        value.expression := ParseExpression(child, path+'/expression')
      else if Not ParseBackboneElementChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeRequestOrchestrationActionCondition(xml : TXmlBuilder; name : String; value : TFhirRequestOrchestrationActionCondition);
begin
  if (value = nil) then
    exit;
  composeElementAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeRequestOrchestrationActionConditionChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeRequestOrchestrationActionConditionChildren(xml : TXmlBuilder; value : TFhirRequestOrchestrationActionCondition);
begin
  composeBackboneElementChildren(xml, value);
  ComposeEnum(xml, 'kind', value.kindElement, CODES_TFhirActionConditionKindEnum);
  if (SummaryOption in [soFull, soData]) then
    ComposeExpression(xml, 'expression', value.expression);
end;

function TFHIRXmlParser.ParseRequestOrchestrationActionInput(element : TMXmlElement; path : string) : TFhirRequestOrchestrationActionInput;
var
  child : TMXmlElement;
begin
  result := TFhirRequestOrchestrationActionInput.Create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseRequestOrchestrationActionInputChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseRequestOrchestrationActionInputChild(value : TFhirRequestOrchestrationActionInput; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'title') then
        value.titleElement := ParseString(child, path+'/title')
      else if (child.localName = 'requirement') then
        value.requirement := ParseDataRequirement(child, path+'/requirement')
      else if (child.localName = 'relatedData') then
        value.relatedDataElement := ParseId(child, path+'/relatedData')
      else if Not ParseBackboneElementChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeRequestOrchestrationActionInput(xml : TXmlBuilder; name : String; value : TFhirRequestOrchestrationActionInput);
begin
  if (value = nil) then
    exit;
  composeElementAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeRequestOrchestrationActionInputChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeRequestOrchestrationActionInputChildren(xml : TXmlBuilder; value : TFhirRequestOrchestrationActionInput);
begin
  composeBackboneElementChildren(xml, value);
  if (SummaryOption in [soFull, soData]) then
    ComposeString(xml, 'title', value.titleElement);
  if (SummaryOption in [soFull, soData]) then
    ComposeDataRequirement(xml, 'requirement', value.requirement);
  if (SummaryOption in [soFull, soData]) then
    ComposeId(xml, 'relatedData', value.relatedDataElement);
end;

function TFHIRXmlParser.ParseRequestOrchestrationActionOutput(element : TMXmlElement; path : string) : TFhirRequestOrchestrationActionOutput;
var
  child : TMXmlElement;
begin
  result := TFhirRequestOrchestrationActionOutput.Create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseRequestOrchestrationActionOutputChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseRequestOrchestrationActionOutputChild(value : TFhirRequestOrchestrationActionOutput; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'title') then
        value.titleElement := ParseString(child, path+'/title')
      else if (child.localName = 'requirement') then
        value.requirement := ParseDataRequirement(child, path+'/requirement')
      else if (child.localName = 'relatedData') then
        value.relatedDataElement := ParseString(child, path+'/relatedData')
      else if Not ParseBackboneElementChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeRequestOrchestrationActionOutput(xml : TXmlBuilder; name : String; value : TFhirRequestOrchestrationActionOutput);
begin
  if (value = nil) then
    exit;
  composeElementAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeRequestOrchestrationActionOutputChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeRequestOrchestrationActionOutputChildren(xml : TXmlBuilder; value : TFhirRequestOrchestrationActionOutput);
begin
  composeBackboneElementChildren(xml, value);
  if (SummaryOption in [soFull, soData]) then
    ComposeString(xml, 'title', value.titleElement);
  if (SummaryOption in [soFull, soData]) then
    ComposeDataRequirement(xml, 'requirement', value.requirement);
  if (SummaryOption in [soFull, soData]) then
    ComposeString(xml, 'relatedData', value.relatedDataElement);
end;

function TFHIRXmlParser.ParseRequestOrchestrationActionRelatedAction(element : TMXmlElement; path : string) : TFhirRequestOrchestrationActionRelatedAction;
var
  child : TMXmlElement;
begin
  result := TFhirRequestOrchestrationActionRelatedAction.Create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseRequestOrchestrationActionRelatedActionChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseRequestOrchestrationActionRelatedActionChild(value : TFhirRequestOrchestrationActionRelatedAction; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'targetId') then
        value.targetIdElement := ParseId(child, path+'/targetId')
      else if (child.localName = 'relationship') then
        value.relationshipElement := ParseEnum(CODES_TFhirActionRelationshipTypeEnum, SYSTEMS_TFhirActionRelationshipTypeEnum, child, path+'/relationship')
      else if (child.localName = 'offsetDuration') then
        value.offset := ParseDuration(child, path+'/offsetDuration')
      else if (child.localName = 'offsetRange') then
        value.offset := ParseRange(child, path+'/offsetRange')
      else if Not ParseBackboneElementChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeRequestOrchestrationActionRelatedAction(xml : TXmlBuilder; name : String; value : TFhirRequestOrchestrationActionRelatedAction);
begin
  if (value = nil) then
    exit;
  composeElementAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeRequestOrchestrationActionRelatedActionChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeRequestOrchestrationActionRelatedActionChildren(xml : TXmlBuilder; value : TFhirRequestOrchestrationActionRelatedAction);
begin
  composeBackboneElementChildren(xml, value);
  ComposeId(xml, 'targetId', value.targetIdElement);
  ComposeEnum(xml, 'relationship', value.relationshipElement, CODES_TFhirActionRelationshipTypeEnum);
  if (SummaryOption in [soFull, soData]) and (value.offset is TFhirDuration) {6} then
    ComposeDuration(xml, 'offsetDuration', TFhirDuration(value.offset))
  else if (SummaryOption in [soFull, soData]) and (value.offset is TFhirRange) {6} then
    ComposeRange(xml, 'offsetRange', TFhirRange(value.offset));
end;

function TFHIRXmlParser.ParseRequestOrchestrationActionParticipant(element : TMXmlElement; path : string) : TFhirRequestOrchestrationActionParticipant;
var
  child : TMXmlElement;
begin
  result := TFhirRequestOrchestrationActionParticipant.Create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseRequestOrchestrationActionParticipantChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseRequestOrchestrationActionParticipantChild(value : TFhirRequestOrchestrationActionParticipant; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'type') then
        value.type_Element := ParseEnum(CODES_TFhirActionParticipantTypeEnum, SYSTEMS_TFhirActionParticipantTypeEnum, child, path+'/type')
      else if (child.localName = 'typeCanonical') then
        value.typeCanonicalElement := ParseCanonical(child, path+'/typeCanonical')
      else if (child.localName = 'typeReference') then
        value.typeReference := ParseReference(child, path+'/typeReference')
      else if (child.localName = 'role') then
        value.role := ParseCodeableConcept(child, path+'/role')
      else if (child.localName = 'function') then
        value.function_ := ParseCodeableConcept(child, path+'/function')
      else if (child.localName = 'actorCanonical') then
        value.actor := ParseCanonical(child, path+'/actorCanonical')
      else if (child.localName = 'actorReference') then
        value.actor := ParseReference(child, path+'/actorReference')
      else if Not ParseBackboneElementChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeRequestOrchestrationActionParticipant(xml : TXmlBuilder; name : String; value : TFhirRequestOrchestrationActionParticipant);
begin
  if (value = nil) then
    exit;
  composeElementAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeRequestOrchestrationActionParticipantChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeRequestOrchestrationActionParticipantChildren(xml : TXmlBuilder; value : TFhirRequestOrchestrationActionParticipant);
begin
  composeBackboneElementChildren(xml, value);
  if (SummaryOption in [soFull, soData]) then
    ComposeEnum(xml, 'type', value.type_Element, CODES_TFhirActionParticipantTypeEnum);
  if (SummaryOption in [soFull, soData]) then
    ComposeCanonical(xml, 'typeCanonical', value.typeCanonicalElement);
  if (SummaryOption in [soFull, soData]) then
    ComposeReference(xml, 'typeReference', value.typeReference);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(xml, 'role', value.role);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(xml, 'function', value.function_);
  if (SummaryOption in [soFull, soData]) and (value.actor is TFhirCanonical) {6} then
    ComposeCanonical(xml, 'actorCanonical', TFhirCanonical(value.actor))
  else if (SummaryOption in [soFull, soData]) and (value.actor is TFhirReference) {2} then
    ComposeReference(xml, 'actorReference', TFhirReference(value.actor));
end;

function TFHIRXmlParser.ParseRequestOrchestrationActionDynamicValue(element : TMXmlElement; path : string) : TFhirRequestOrchestrationActionDynamicValue;
var
  child : TMXmlElement;
begin
  result := TFhirRequestOrchestrationActionDynamicValue.Create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseRequestOrchestrationActionDynamicValueChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseRequestOrchestrationActionDynamicValueChild(value : TFhirRequestOrchestrationActionDynamicValue; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'path') then
        value.pathElement := ParseString(child, path+'/path')
      else if (child.localName = 'expression') then
        value.expression := ParseExpression(child, path+'/expression')
      else if Not ParseBackboneElementChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeRequestOrchestrationActionDynamicValue(xml : TXmlBuilder; name : String; value : TFhirRequestOrchestrationActionDynamicValue);
begin
  if (value = nil) then
    exit;
  composeElementAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeRequestOrchestrationActionDynamicValueChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeRequestOrchestrationActionDynamicValueChildren(xml : TXmlBuilder; value : TFhirRequestOrchestrationActionDynamicValue);
begin
  composeBackboneElementChildren(xml, value);
  if (SummaryOption in [soFull, soData]) then
    ComposeString(xml, 'path', value.pathElement);
  if (SummaryOption in [soFull, soData]) then
    ComposeExpression(xml, 'expression', value.expression);
end;

function TFHIRXmlParser.ParseRequestOrchestration(element : TMXmlElement; path : string) : TFhirRequestOrchestration;
var
  child : TMXmlElement;
begin
  result := TFhirRequestOrchestration.Create;
  try
    parseDomainResourceAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseRequestOrchestrationChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseRequestOrchestrationChild(value : TFhirRequestOrchestration; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'identifier') then
        value.identifierList.Add(ParseIdentifier(child, path+'/identifier'))
      else if (child.localName = 'instantiatesCanonical') then
        value.instantiatesCanonicalList.Add(ParseCanonical(child, path+'/instantiatesCanonical'))
      else if (child.localName = 'instantiatesUri') then
        value.instantiatesUriList.Add(ParseUri(child, path+'/instantiatesUri'))
      else if (child.localName = 'basedOn') then
        value.basedOnList.Add(ParseReference(child, path+'/basedOn'))
      else if (child.localName = 'replaces') then
        value.replacesList.Add(ParseReference(child, path+'/replaces'))
      else if (child.localName = 'groupIdentifier') then
        value.groupIdentifier := ParseIdentifier(child, path+'/groupIdentifier')
      else if (child.localName = 'status') then
        value.statusElement := ParseEnum(CODES_TFhirRequestStatusEnum, SYSTEMS_TFhirRequestStatusEnum, child, path+'/status')
      else if (child.localName = 'intent') then
        value.intentElement := ParseEnum(CODES_TFhirRequestIntentEnum, SYSTEMS_TFhirRequestIntentEnum, child, path+'/intent')
      else if (child.localName = 'priority') then
        value.priorityElement := ParseEnum(CODES_TFhirRequestPriorityEnum, SYSTEMS_TFhirRequestPriorityEnum, child, path+'/priority')
      else if (child.localName = 'code') then
        value.code := ParseCodeableConcept(child, path+'/code')
      else if (child.localName = 'subject') then
        value.subject := ParseReference(child, path+'/subject')
      else if (child.localName = 'encounter') then
        value.encounter := ParseReference(child, path+'/encounter')
      else if (child.localName = 'authoredOn') then
        value.authoredOnElement := ParseDateTime(child, path+'/authoredOn')
      else if (child.localName = 'author') then
        value.author := ParseReference(child, path+'/author')
      else if (child.localName = 'reason') then
        value.reasonList.Add(ParseCodeableReference(child, path+'/reason'))
      else if (child.localName = 'goal') then
        value.goalList.Add(ParseReference(child, path+'/goal'))
      else if (child.localName = 'note') then
        value.noteList.Add(ParseAnnotation(child, path+'/note'))
      else if (child.localName = 'action') then
        value.actionList.Add(ParseRequestOrchestrationAction(child, path+'/action'))
      else if Not ParseDomainResourceChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeRequestOrchestration(xml : TXmlBuilder; name : String; value : TFhirRequestOrchestration);
begin
  if (value = nil) then
    exit;
  composeDomainResourceAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeRequestOrchestrationChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeRequestOrchestrationChildren(xml : TXmlBuilder; value : TFhirRequestOrchestration);
var
  i : integer;
begin
  composeDomainResourceChildren(xml, value);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.identifierList.Count - 1 do
      ComposeIdentifier(xml, 'identifier', value.identifierList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.instantiatesCanonicalList.Count - 1 do
      ComposeCanonical(xml, 'instantiatesCanonical', value.instantiatesCanonicalList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.instantiatesUriList.Count - 1 do
      ComposeUri(xml, 'instantiatesUri', value.instantiatesUriList[i]);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.basedOnList.Count - 1 do
      ComposeReference(xml, 'basedOn', value.basedOnList[i]);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.replacesList.Count - 1 do
      ComposeReference(xml, 'replaces', value.replacesList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeIdentifier(xml, 'groupIdentifier', value.groupIdentifier);
  ComposeEnum(xml, 'status', value.statusElement, CODES_TFhirRequestStatusEnum);
  ComposeEnum(xml, 'intent', value.intentElement, CODES_TFhirRequestIntentEnum);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeEnum(xml, 'priority', value.priorityElement, CODES_TFhirRequestPriorityEnum);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(xml, 'code', value.code);
  if (SummaryOption in [soFull, soData]) then
    ComposeReference(xml, 'subject', value.subject);
  if (SummaryOption in [soFull, soData]) then
    ComposeReference(xml, 'encounter', value.encounter);
  if (SummaryOption in [soFull, soData]) then
    ComposeDateTime(xml, 'authoredOn', value.authoredOnElement);
  if (SummaryOption in [soFull, soData]) then
    ComposeReference(xml, 'author', value.author);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.reasonList.Count - 1 do
      ComposeCodeableReference(xml, 'reason', value.reasonList[i]);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.goalList.Count - 1 do
      ComposeReference(xml, 'goal', value.goalList[i]);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.noteList.Count - 1 do
      ComposeAnnotation(xml, 'note', value.noteList[i]);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.actionList.Count - 1 do
      ComposeRequestOrchestrationAction(xml, 'action', value.actionList[i]);
end;

{$ENDIF FHIR_REQUESTORCHESTRATION}
{$IFDEF FHIR_REQUIREMENTS}
function TFHIRXmlParser.ParseRequirementsStatement(element : TMXmlElement; path : string) : TFhirRequirementsStatement;
var
  child : TMXmlElement;
begin
  result := TFhirRequirementsStatement.Create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseRequirementsStatementChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseRequirementsStatementChild(value : TFhirRequirementsStatement; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'key') then
        value.keyElement := ParseId(child, path+'/key')
      else if (child.localName = 'label') then
        value.label_Element := ParseString(child, path+'/label')
      else if (child.localName = 'conformance') then
        value.conformanceList.Add(ParseEnum(CODES_TFhirConformanceExpectationEnum, SYSTEMS_TFhirConformanceExpectationEnum, child, path+'/conformance')){y.1}
      else if (child.localName = 'requirement') then
        value.requirementElement := ParseMarkdown(child, path+'/requirement')
      else if (child.localName = 'derivedFrom') then
        value.derivedFromElement := ParseString(child, path+'/derivedFrom')
      else if (child.localName = 'satisfiedBy') then
        value.satisfiedByList.Add(ParseUrl(child, path+'/satisfiedBy'))
      else if (child.localName = 'reference') then
        value.referenceList.Add(ParseUrl(child, path+'/reference'))
      else if (child.localName = 'source') then
        value.sourceList.Add(ParseReference(child, path+'/source'))
      else if Not ParseBackboneElementChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeRequirementsStatement(xml : TXmlBuilder; name : String; value : TFhirRequirementsStatement);
begin
  if (value = nil) then
    exit;
  composeElementAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeRequirementsStatementChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeRequirementsStatementChildren(xml : TXmlBuilder; value : TFhirRequirementsStatement);
var
  i : integer;
begin
  composeBackboneElementChildren(xml, value);
  ComposeId(xml, 'key', value.keyElement);
  if (SummaryOption in [soFull, soData]) then
    ComposeString(xml, 'label', value.label_Element);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.conformanceList.Count - 1 do
      ComposeEnum(xml, 'conformance', value.conformanceList[i], CODES_TFhirConformanceExpectationEnum);
  ComposeMarkdown(xml, 'requirement', value.requirementElement);
  if (SummaryOption in [soFull, soData]) then
    ComposeString(xml, 'derivedFrom', value.derivedFromElement);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.satisfiedByList.Count - 1 do
      ComposeUrl(xml, 'satisfiedBy', value.satisfiedByList[i]);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.referenceList.Count - 1 do
      ComposeUrl(xml, 'reference', value.referenceList[i]);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.sourceList.Count - 1 do
      ComposeReference(xml, 'source', value.sourceList[i]);
end;

function TFHIRXmlParser.ParseRequirements(element : TMXmlElement; path : string) : TFhirRequirements;
var
  child : TMXmlElement;
begin
  result := TFhirRequirements.Create;
  try
    parseCanonicalResourceAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseRequirementsChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseRequirementsChild(value : TFhirRequirements; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'url') then
        value.urlElement := ParseUri(child, path+'/url')
      else if (child.localName = 'identifier') then
        value.identifierList.Add(ParseIdentifier(child, path+'/identifier'))
      else if (child.localName = 'version') then
        value.versionElement := ParseString(child, path+'/version')
      else if (child.localName = 'name') then
        value.nameElement := ParseString(child, path+'/name')
      else if (child.localName = 'title') then
        value.titleElement := ParseString(child, path+'/title')
      else if (child.localName = 'status') then
        value.statusElement := ParseEnum(CODES_TFhirPublicationStatusEnum, SYSTEMS_TFhirPublicationStatusEnum, child, path+'/status')
      else if (child.localName = 'experimental') then
        value.experimentalElement := ParseBoolean(child, path+'/experimental')
      else if (child.localName = 'date') then
        value.dateElement := ParseDateTime(child, path+'/date')
      else if (child.localName = 'publisher') then
        value.publisherElement := ParseString(child, path+'/publisher')
      else if (child.localName = 'contact') then
        value.contactList.Add(ParseContactDetail(child, path+'/contact'))
      else if (child.localName = 'description') then
        value.descriptionElement := ParseMarkdown(child, path+'/description')
      else if (child.localName = 'useContext') then
        value.useContextList.Add(ParseUsageContext(child, path+'/useContext'))
      else if (child.localName = 'jurisdiction') then
        value.jurisdictionList.Add(ParseCodeableConcept(child, path+'/jurisdiction'))
      else if (child.localName = 'purpose') then
        value.purposeElement := ParseMarkdown(child, path+'/purpose')
      else if (child.localName = 'copyright') then
        value.copyrightElement := ParseMarkdown(child, path+'/copyright')
      else if (child.localName = 'copyrightLabel') then
        value.copyrightLabelElement := ParseString(child, path+'/copyrightLabel')
      else if (child.localName = 'derivedFrom') then
        value.derivedFromList.Add(ParseCanonical(child, path+'/derivedFrom'))
      else if (child.localName = 'actor') then
        value.actorList.Add(ParseCanonical(child, path+'/actor'))
      else if (child.localName = 'statement') then
        value.statementList.Add(ParseRequirementsStatement(child, path+'/statement'))
      else if Not ParseCanonicalResourceChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeRequirements(xml : TXmlBuilder; name : String; value : TFhirRequirements);
begin
  if (value = nil) then
    exit;
  composeCanonicalResourceAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeRequirementsChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeRequirementsChildren(xml : TXmlBuilder; value : TFhirRequirements);
var
  i : integer;
begin
  composeCanonicalResourceChildren(xml, value);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeUri(xml, 'url', value.urlElement);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.identifierList.Count - 1 do
      ComposeIdentifier(xml, 'identifier', value.identifierList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(xml, 'version', value.versionElement);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(xml, 'name', value.nameElement);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(xml, 'title', value.titleElement);
  ComposeEnum(xml, 'status', value.statusElement, CODES_TFhirPublicationStatusEnum);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeBoolean(xml, 'experimental', value.experimentalElement);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDateTime(xml, 'date', value.dateElement);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(xml, 'publisher', value.publisherElement);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.contactList.Count - 1 do
      ComposeContactDetail(xml, 'contact', value.contactList[i]);
  if (SummaryOption in [soFull, soData]) then
    ComposeMarkdown(xml, 'description', value.descriptionElement);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.useContextList.Count - 1 do
      ComposeUsageContext(xml, 'useContext', value.useContextList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.jurisdictionList.Count - 1 do
      ComposeCodeableConcept(xml, 'jurisdiction', value.jurisdictionList[i]);
  if (SummaryOption in [soFull, soData]) then
    ComposeMarkdown(xml, 'purpose', value.purposeElement);
  if (SummaryOption in [soFull, soData]) then
    ComposeMarkdown(xml, 'copyright', value.copyrightElement);
  if (SummaryOption in [soFull, soData]) then
    ComposeString(xml, 'copyrightLabel', value.copyrightLabelElement);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.derivedFromList.Count - 1 do
      ComposeCanonical(xml, 'derivedFrom', value.derivedFromList[i]);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.actorList.Count - 1 do
      ComposeCanonical(xml, 'actor', value.actorList[i]);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.statementList.Count - 1 do
      ComposeRequirementsStatement(xml, 'statement', value.statementList[i]);
end;

{$ENDIF FHIR_REQUIREMENTS}
{$IFDEF FHIR_RESEARCHSTUDY}
function TFHIRXmlParser.ParseResearchStudyLabel(element : TMXmlElement; path : string) : TFhirResearchStudyLabel;
var
  child : TMXmlElement;
begin
  result := TFhirResearchStudyLabel.Create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseResearchStudyLabelChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseResearchStudyLabelChild(value : TFhirResearchStudyLabel; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'type') then
        value.type_ := ParseCodeableConcept(child, path+'/type')
      else if (child.localName = 'value') then
        value.valueElement := ParseString(child, path+'/value')
      else if Not ParseBackboneElementChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeResearchStudyLabel(xml : TXmlBuilder; name : String; value : TFhirResearchStudyLabel);
begin
  if (value = nil) then
    exit;
  composeElementAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeResearchStudyLabelChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeResearchStudyLabelChildren(xml : TXmlBuilder; value : TFhirResearchStudyLabel);
begin
  composeBackboneElementChildren(xml, value);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(xml, 'type', value.type_);
  if (SummaryOption in [soFull, soData]) then
    ComposeString(xml, 'value', value.valueElement);
end;

function TFHIRXmlParser.ParseResearchStudyFocus(element : TMXmlElement; path : string) : TFhirResearchStudyFocus;
var
  child : TMXmlElement;
begin
  result := TFhirResearchStudyFocus.Create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseResearchStudyFocusChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseResearchStudyFocusChild(value : TFhirResearchStudyFocus; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'productCode') then
        value.productCode := ParseCodeableConcept(child, path+'/productCode')
      else if (child.localName = 'focusType') then
        value.focusTypeList.Add(ParseCodeableConcept(child, path+'/focusType'))
      else if (child.localName = 'factor') then
        value.factorElement := ParseMarkdown(child, path+'/factor')
      else if Not ParseBackboneElementChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeResearchStudyFocus(xml : TXmlBuilder; name : String; value : TFhirResearchStudyFocus);
begin
  if (value = nil) then
    exit;
  composeElementAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeResearchStudyFocusChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeResearchStudyFocusChildren(xml : TXmlBuilder; value : TFhirResearchStudyFocus);
var
  i : integer;
begin
  composeBackboneElementChildren(xml, value);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(xml, 'productCode', value.productCode);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.focusTypeList.Count - 1 do
      ComposeCodeableConcept(xml, 'focusType', value.focusTypeList[i]);
  if (SummaryOption in [soFull, soData]) then
    ComposeMarkdown(xml, 'factor', value.factorElement);
end;

function TFHIRXmlParser.ParseResearchStudyAssociatedParty(element : TMXmlElement; path : string) : TFhirResearchStudyAssociatedParty;
var
  child : TMXmlElement;
begin
  result := TFhirResearchStudyAssociatedParty.Create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseResearchStudyAssociatedPartyChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseResearchStudyAssociatedPartyChild(value : TFhirResearchStudyAssociatedParty; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'name') then
        value.nameElement := ParseString(child, path+'/name')
      else if (child.localName = 'role') then
        value.role := ParseCodeableConcept(child, path+'/role')
      else if (child.localName = 'period') then
        value.periodList.Add(ParsePeriod(child, path+'/period'))
      else if (child.localName = 'classifier') then
        value.classifierList.Add(ParseCodeableConcept(child, path+'/classifier'))
      else if (child.localName = 'party') then
        value.party := ParseReference(child, path+'/party')
      else if Not ParseBackboneElementChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeResearchStudyAssociatedParty(xml : TXmlBuilder; name : String; value : TFhirResearchStudyAssociatedParty);
begin
  if (value = nil) then
    exit;
  composeElementAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeResearchStudyAssociatedPartyChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeResearchStudyAssociatedPartyChildren(xml : TXmlBuilder; value : TFhirResearchStudyAssociatedParty);
var
  i : integer;
begin
  composeBackboneElementChildren(xml, value);
  if (SummaryOption in [soFull, soData]) then
    ComposeString(xml, 'name', value.nameElement);
  ComposeCodeableConcept(xml, 'role', value.role);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.periodList.Count - 1 do
      ComposePeriod(xml, 'period', value.periodList[i]);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.classifierList.Count - 1 do
      ComposeCodeableConcept(xml, 'classifier', value.classifierList[i]);
  if (SummaryOption in [soFull, soData]) then
    ComposeReference(xml, 'party', value.party);
end;

function TFHIRXmlParser.ParseResearchStudyProgressStatus(element : TMXmlElement; path : string) : TFhirResearchStudyProgressStatus;
var
  child : TMXmlElement;
begin
  result := TFhirResearchStudyProgressStatus.Create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseResearchStudyProgressStatusChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseResearchStudyProgressStatusChild(value : TFhirResearchStudyProgressStatus; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'state') then
        value.state := ParseCodeableConcept(child, path+'/state')
      else if (child.localName = 'actual') then
        value.actualElement := ParseBoolean(child, path+'/actual')
      else if (child.localName = 'period') then
        value.period := ParsePeriod(child, path+'/period')
      else if Not ParseBackboneElementChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeResearchStudyProgressStatus(xml : TXmlBuilder; name : String; value : TFhirResearchStudyProgressStatus);
begin
  if (value = nil) then
    exit;
  composeElementAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeResearchStudyProgressStatusChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeResearchStudyProgressStatusChildren(xml : TXmlBuilder; value : TFhirResearchStudyProgressStatus);
begin
  composeBackboneElementChildren(xml, value);
  ComposeCodeableConcept(xml, 'state', value.state);
  if (SummaryOption in [soFull, soData]) then
    ComposeBoolean(xml, 'actual', value.actualElement);
  if (SummaryOption in [soFull, soData]) then
    ComposePeriod(xml, 'period', value.period);
end;

function TFHIRXmlParser.ParseResearchStudyRecruitment(element : TMXmlElement; path : string) : TFhirResearchStudyRecruitment;
var
  child : TMXmlElement;
begin
  result := TFhirResearchStudyRecruitment.Create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseResearchStudyRecruitmentChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseResearchStudyRecruitmentChild(value : TFhirResearchStudyRecruitment; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'targetNumber') then
        value.targetNumberElement := ParseUnsignedInt(child, path+'/targetNumber')
      else if (child.localName = 'actualNumber') then
        value.actualNumberElement := ParseUnsignedInt(child, path+'/actualNumber')
      else if (child.localName = 'eligibility') then
        value.eligibility := ParseReference(child, path+'/eligibility')
      else if (child.localName = 'actualGroup') then
        value.actualGroup := ParseReference(child, path+'/actualGroup')
      else if Not ParseBackboneElementChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeResearchStudyRecruitment(xml : TXmlBuilder; name : String; value : TFhirResearchStudyRecruitment);
begin
  if (value = nil) then
    exit;
  composeElementAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeResearchStudyRecruitmentChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeResearchStudyRecruitmentChildren(xml : TXmlBuilder; value : TFhirResearchStudyRecruitment);
begin
  composeBackboneElementChildren(xml, value);
  if (SummaryOption in [soFull, soData]) then
    ComposeUnsignedInt(xml, 'targetNumber', value.targetNumberElement);
  if (SummaryOption in [soFull, soData]) then
    ComposeUnsignedInt(xml, 'actualNumber', value.actualNumberElement);
  if (SummaryOption in [soFull, soData]) then
    ComposeReference(xml, 'eligibility', value.eligibility);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference(xml, 'actualGroup', value.actualGroup);
end;

function TFHIRXmlParser.ParseResearchStudyComparisonGroup(element : TMXmlElement; path : string) : TFhirResearchStudyComparisonGroup;
var
  child : TMXmlElement;
begin
  result := TFhirResearchStudyComparisonGroup.Create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseResearchStudyComparisonGroupChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseResearchStudyComparisonGroupChild(value : TFhirResearchStudyComparisonGroup; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'identifierIdentifier') then
        value.identifier := ParseIdentifier(child, path+'/identifierIdentifier')
      else if (child.localName = 'identifierUri') then
        value.identifier := ParseUri(child, path+'/identifierUri')
      else if (child.localName = 'name') then
        value.nameElement := ParseString(child, path+'/name')
      else if (child.localName = 'type') then
        value.type_ := ParseCodeableConcept(child, path+'/type')
      else if (child.localName = 'description') then
        value.descriptionElement := ParseMarkdown(child, path+'/description')
      else if (child.localName = 'intendedExposure') then
        value.intendedExposureList.Add(ParseReference(child, path+'/intendedExposure'))
      else if (child.localName = 'observedGroup') then
        value.observedGroup := ParseReference(child, path+'/observedGroup')
      else if Not ParseBackboneElementChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeResearchStudyComparisonGroup(xml : TXmlBuilder; name : String; value : TFhirResearchStudyComparisonGroup);
begin
  if (value = nil) then
    exit;
  composeElementAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeResearchStudyComparisonGroupChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeResearchStudyComparisonGroupChildren(xml : TXmlBuilder; value : TFhirResearchStudyComparisonGroup);
var
  i : integer;
begin
  composeBackboneElementChildren(xml, value);
  if (SummaryOption in [soFull, soData]) and (value.identifier is TFhirIdentifier) {6} then
    ComposeIdentifier(xml, 'identifierIdentifier', TFhirIdentifier(value.identifier))
  else if (SummaryOption in [soFull, soData]) and (value.identifier is TFhirUri) {6} then
    ComposeUri(xml, 'identifierUri', TFhirUri(value.identifier));
  ComposeString(xml, 'name', value.nameElement);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(xml, 'type', value.type_);
  if (SummaryOption in [soFull, soData]) then
    ComposeMarkdown(xml, 'description', value.descriptionElement);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.intendedExposureList.Count - 1 do
      ComposeReference(xml, 'intendedExposure', value.intendedExposureList[i]);
  if (SummaryOption in [soFull, soData]) then
    ComposeReference(xml, 'observedGroup', value.observedGroup);
end;

function TFHIRXmlParser.ParseResearchStudyObjective(element : TMXmlElement; path : string) : TFhirResearchStudyObjective;
var
  child : TMXmlElement;
begin
  result := TFhirResearchStudyObjective.Create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseResearchStudyObjectiveChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseResearchStudyObjectiveChild(value : TFhirResearchStudyObjective; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'name') then
        value.nameElement := ParseString(child, path+'/name')
      else if (child.localName = 'type') then
        value.type_ := ParseCodeableConcept(child, path+'/type')
      else if (child.localName = 'description') then
        value.descriptionElement := ParseMarkdown(child, path+'/description')
      else if Not ParseBackboneElementChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeResearchStudyObjective(xml : TXmlBuilder; name : String; value : TFhirResearchStudyObjective);
begin
  if (value = nil) then
    exit;
  composeElementAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeResearchStudyObjectiveChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeResearchStudyObjectiveChildren(xml : TXmlBuilder; value : TFhirResearchStudyObjective);
begin
  composeBackboneElementChildren(xml, value);
  if (SummaryOption in [soFull, soData]) then
    ComposeString(xml, 'name', value.nameElement);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(xml, 'type', value.type_);
  if (SummaryOption in [soFull, soData]) then
    ComposeMarkdown(xml, 'description', value.descriptionElement);
end;

function TFHIRXmlParser.ParseResearchStudyOutcomeMeasure(element : TMXmlElement; path : string) : TFhirResearchStudyOutcomeMeasure;
var
  child : TMXmlElement;
begin
  result := TFhirResearchStudyOutcomeMeasure.Create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseResearchStudyOutcomeMeasureChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseResearchStudyOutcomeMeasureChild(value : TFhirResearchStudyOutcomeMeasure; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'name') then
        value.nameElement := ParseString(child, path+'/name')
      else if (child.localName = 'type') then
        value.type_List.Add(ParseCodeableConcept(child, path+'/type'))
      else if (child.localName = 'description') then
        value.descriptionElement := ParseMarkdown(child, path+'/description')
      else if (child.localName = 'reference') then
        value.reference := ParseReference(child, path+'/reference')
      else if Not ParseBackboneElementChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeResearchStudyOutcomeMeasure(xml : TXmlBuilder; name : String; value : TFhirResearchStudyOutcomeMeasure);
begin
  if (value = nil) then
    exit;
  composeElementAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeResearchStudyOutcomeMeasureChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeResearchStudyOutcomeMeasureChildren(xml : TXmlBuilder; value : TFhirResearchStudyOutcomeMeasure);
var
  i : integer;
begin
  composeBackboneElementChildren(xml, value);
  if (SummaryOption in [soFull, soData]) then
    ComposeString(xml, 'name', value.nameElement);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.type_List.Count - 1 do
      ComposeCodeableConcept(xml, 'type', value.type_List[i]);
  if (SummaryOption in [soFull, soData]) then
    ComposeMarkdown(xml, 'description', value.descriptionElement);
  if (SummaryOption in [soFull, soData]) then
    ComposeReference(xml, 'reference', value.reference);
end;

function TFHIRXmlParser.ParseResearchStudyWebLocation(element : TMXmlElement; path : string) : TFhirResearchStudyWebLocation;
var
  child : TMXmlElement;
begin
  result := TFhirResearchStudyWebLocation.Create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseResearchStudyWebLocationChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseResearchStudyWebLocationChild(value : TFhirResearchStudyWebLocation; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'classifier') then
        value.classifier := ParseCodeableConcept(child, path+'/classifier')
      else if (child.localName = 'url') then
        value.urlElement := ParseUri(child, path+'/url')
      else if Not ParseBackboneElementChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeResearchStudyWebLocation(xml : TXmlBuilder; name : String; value : TFhirResearchStudyWebLocation);
begin
  if (value = nil) then
    exit;
  composeElementAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeResearchStudyWebLocationChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeResearchStudyWebLocationChildren(xml : TXmlBuilder; value : TFhirResearchStudyWebLocation);
begin
  composeBackboneElementChildren(xml, value);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(xml, 'classifier', value.classifier);
  ComposeUri(xml, 'url', value.urlElement);
end;

function TFHIRXmlParser.ParseResearchStudy(element : TMXmlElement; path : string) : TFhirResearchStudy;
var
  child : TMXmlElement;
begin
  result := TFhirResearchStudy.Create;
  try
    parseDomainResourceAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseResearchStudyChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseResearchStudyChild(value : TFhirResearchStudy; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'url') then
        value.urlElement := ParseUri(child, path+'/url')
      else if (child.localName = 'identifier') then
        value.identifierList.Add(ParseIdentifier(child, path+'/identifier'))
      else if (child.localName = 'version') then
        value.versionElement := ParseString(child, path+'/version')
      else if (child.localName = 'name') then
        value.nameElement := ParseString(child, path+'/name')
      else if (child.localName = 'title') then
        value.titleElement := ParseString(child, path+'/title')
      else if (child.localName = 'label') then
        value.label_List.Add(ParseResearchStudyLabel(child, path+'/label'))
      else if (child.localName = 'protocol') then
        value.protocolList.Add(ParseReference(child, path+'/protocol'))
      else if (child.localName = 'partOf') then
        value.partOfList.Add(ParseReference(child, path+'/partOf'))
      else if (child.localName = 'relatedArtifact') then
        value.relatedArtifactList.Add(ParseRelatedArtifact(child, path+'/relatedArtifact'))
      else if (child.localName = 'date') then
        value.dateElement := ParseDateTime(child, path+'/date')
      else if (child.localName = 'status') then
        value.statusElement := ParseEnum(CODES_TFhirPublicationStatusEnum, SYSTEMS_TFhirPublicationStatusEnum, child, path+'/status')
      else if (child.localName = 'primaryPurposeType') then
        value.primaryPurposeType := ParseCodeableConcept(child, path+'/primaryPurposeType')
      else if (child.localName = 'phase') then
        value.phase := ParseCodeableConcept(child, path+'/phase')
      else if (child.localName = 'studyDesign') then
        value.studyDesignList.Add(ParseCodeableConcept(child, path+'/studyDesign'))
      else if (child.localName = 'focus') then
        value.focusList.Add(ParseResearchStudyFocus(child, path+'/focus'))
      else if (child.localName = 'condition') then
        value.conditionList.Add(ParseCodeableConcept(child, path+'/condition'))
      else if (child.localName = 'keyword') then
        value.keywordList.Add(ParseCodeableConcept(child, path+'/keyword'))
      else if (child.localName = 'region') then
        value.regionList.Add(ParseCodeableConcept(child, path+'/region'))
      else if (child.localName = 'descriptionSummary') then
        value.descriptionSummaryElement := ParseMarkdown(child, path+'/descriptionSummary')
      else if (child.localName = 'description') then
        value.descriptionElement := ParseMarkdown(child, path+'/description')
      else if (child.localName = 'period') then
        value.period := ParsePeriod(child, path+'/period')
      else if (child.localName = 'site') then
        value.siteList.Add(ParseReference(child, path+'/site'))
      else if (child.localName = 'note') then
        value.noteList.Add(ParseAnnotation(child, path+'/note'))
      else if (child.localName = 'classifier') then
        value.classifierList.Add(ParseCodeableConcept(child, path+'/classifier'))
      else if (child.localName = 'associatedParty') then
        value.associatedPartyList.Add(ParseResearchStudyAssociatedParty(child, path+'/associatedParty'))
      else if (child.localName = 'progressStatus') then
        value.progressStatusList.Add(ParseResearchStudyProgressStatus(child, path+'/progressStatus'))
      else if (child.localName = 'whyStopped') then
        value.whyStopped := ParseCodeableConcept(child, path+'/whyStopped')
      else if (child.localName = 'recruitment') then
        value.recruitment := ParseResearchStudyRecruitment(child, path+'/recruitment')
      else if (child.localName = 'comparisonGroup') then
        value.comparisonGroupList.Add(ParseResearchStudyComparisonGroup(child, path+'/comparisonGroup'))
      else if (child.localName = 'objective') then
        value.objectiveList.Add(ParseResearchStudyObjective(child, path+'/objective'))
      else if (child.localName = 'outcomeMeasure') then
        value.outcomeMeasureList.Add(ParseResearchStudyOutcomeMeasure(child, path+'/outcomeMeasure'))
      else if (child.localName = 'result') then
        value.resultList.Add(ParseReference(child, path+'/result'))
      else if (child.localName = 'webLocation') then
        value.webLocationList.Add(ParseResearchStudyWebLocation(child, path+'/webLocation'))
      else if Not ParseDomainResourceChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeResearchStudy(xml : TXmlBuilder; name : String; value : TFhirResearchStudy);
begin
  if (value = nil) then
    exit;
  composeDomainResourceAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeResearchStudyChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeResearchStudyChildren(xml : TXmlBuilder; value : TFhirResearchStudy);
var
  i : integer;
begin
  composeDomainResourceChildren(xml, value);
  if (SummaryOption in [soFull, soData]) then
    ComposeUri(xml, 'url', value.urlElement);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.identifierList.Count - 1 do
      ComposeIdentifier(xml, 'identifier', value.identifierList[i]);
  if (SummaryOption in [soFull, soData]) then
    ComposeString(xml, 'version', value.versionElement);
  if (SummaryOption in [soFull, soData]) then
    ComposeString(xml, 'name', value.nameElement);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(xml, 'title', value.titleElement);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.label_List.Count - 1 do
      ComposeResearchStudyLabel(xml, 'label', value.label_List[i]);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.protocolList.Count - 1 do
      ComposeReference(xml, 'protocol', value.protocolList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.partOfList.Count - 1 do
      ComposeReference(xml, 'partOf', value.partOfList[i]);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.relatedArtifactList.Count - 1 do
      ComposeRelatedArtifact(xml, 'relatedArtifact', value.relatedArtifactList[i]);
  if (SummaryOption in [soFull, soData]) then
    ComposeDateTime(xml, 'date', value.dateElement);
  ComposeEnum(xml, 'status', value.statusElement, CODES_TFhirPublicationStatusEnum);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(xml, 'primaryPurposeType', value.primaryPurposeType);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(xml, 'phase', value.phase);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.studyDesignList.Count - 1 do
      ComposeCodeableConcept(xml, 'studyDesign', value.studyDesignList[i]);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.focusList.Count - 1 do
      ComposeResearchStudyFocus(xml, 'focus', value.focusList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.conditionList.Count - 1 do
      ComposeCodeableConcept(xml, 'condition', value.conditionList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.keywordList.Count - 1 do
      ComposeCodeableConcept(xml, 'keyword', value.keywordList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.regionList.Count - 1 do
      ComposeCodeableConcept(xml, 'region', value.regionList[i]);
  if (SummaryOption in [soFull, soData]) then
    ComposeMarkdown(xml, 'descriptionSummary', value.descriptionSummaryElement);
  if (SummaryOption in [soFull, soData]) then
    ComposeMarkdown(xml, 'description', value.descriptionElement);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposePeriod(xml, 'period', value.period);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.siteList.Count - 1 do
      ComposeReference(xml, 'site', value.siteList[i]);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.noteList.Count - 1 do
      ComposeAnnotation(xml, 'note', value.noteList[i]);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.classifierList.Count - 1 do
      ComposeCodeableConcept(xml, 'classifier', value.classifierList[i]);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.associatedPartyList.Count - 1 do
      ComposeResearchStudyAssociatedParty(xml, 'associatedParty', value.associatedPartyList[i]);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.progressStatusList.Count - 1 do
      ComposeResearchStudyProgressStatus(xml, 'progressStatus', value.progressStatusList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(xml, 'whyStopped', value.whyStopped);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeResearchStudyRecruitment(xml, 'recruitment', value.recruitment);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.comparisonGroupList.Count - 1 do
      ComposeResearchStudyComparisonGroup(xml, 'comparisonGroup', value.comparisonGroupList[i]);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.objectiveList.Count - 1 do
      ComposeResearchStudyObjective(xml, 'objective', value.objectiveList[i]);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.outcomeMeasureList.Count - 1 do
      ComposeResearchStudyOutcomeMeasure(xml, 'outcomeMeasure', value.outcomeMeasureList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.resultList.Count - 1 do
      ComposeReference(xml, 'result', value.resultList[i]);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.webLocationList.Count - 1 do
      ComposeResearchStudyWebLocation(xml, 'webLocation', value.webLocationList[i]);
end;

{$ENDIF FHIR_RESEARCHSTUDY}
{$IFDEF FHIR_RESEARCHSUBJECT}
function TFHIRXmlParser.ParseResearchSubjectProgress(element : TMXmlElement; path : string) : TFhirResearchSubjectProgress;
var
  child : TMXmlElement;
begin
  result := TFhirResearchSubjectProgress.Create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseResearchSubjectProgressChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseResearchSubjectProgressChild(value : TFhirResearchSubjectProgress; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'type') then
        value.type_ := ParseCodeableConcept(child, path+'/type')
      else if (child.localName = 'subjectState') then
        value.subjectState := ParseCodeableConcept(child, path+'/subjectState')
      else if (child.localName = 'milestone') then
        value.milestone := ParseCodeableConcept(child, path+'/milestone')
      else if (child.localName = 'reason') then
        value.reason := ParseCodeableConcept(child, path+'/reason')
      else if (child.localName = 'startDate') then
        value.startDateElement := ParseDateTime(child, path+'/startDate')
      else if (child.localName = 'endDate') then
        value.endDateElement := ParseDateTime(child, path+'/endDate')
      else if Not ParseBackboneElementChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeResearchSubjectProgress(xml : TXmlBuilder; name : String; value : TFhirResearchSubjectProgress);
begin
  if (value = nil) then
    exit;
  composeElementAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeResearchSubjectProgressChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeResearchSubjectProgressChildren(xml : TXmlBuilder; value : TFhirResearchSubjectProgress);
begin
  composeBackboneElementChildren(xml, value);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(xml, 'type', value.type_);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(xml, 'subjectState', value.subjectState);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(xml, 'milestone', value.milestone);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(xml, 'reason', value.reason);
  if (SummaryOption in [soFull, soData]) then
    ComposeDateTime(xml, 'startDate', value.startDateElement);
  if (SummaryOption in [soFull, soData]) then
    ComposeDateTime(xml, 'endDate', value.endDateElement);
end;

function TFHIRXmlParser.ParseResearchSubject(element : TMXmlElement; path : string) : TFhirResearchSubject;
var
  child : TMXmlElement;
begin
  result := TFhirResearchSubject.Create;
  try
    parseDomainResourceAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseResearchSubjectChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseResearchSubjectChild(value : TFhirResearchSubject; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'identifier') then
        value.identifierList.Add(ParseIdentifier(child, path+'/identifier'))
      else if (child.localName = 'status') then
        value.statusElement := ParseEnum(CODES_TFhirPublicationStatusEnum, SYSTEMS_TFhirPublicationStatusEnum, child, path+'/status')
      else if (child.localName = 'progress') then
        value.progressList.Add(ParseResearchSubjectProgress(child, path+'/progress'))
      else if (child.localName = 'period') then
        value.period := ParsePeriod(child, path+'/period')
      else if (child.localName = 'study') then
        value.study := ParseReference(child, path+'/study')
      else if (child.localName = 'subject') then
        value.subject := ParseReference(child, path+'/subject')
      else if (child.localName = 'assignedArm') then
        value.assignedArmElement := ParseString(child, path+'/assignedArm')
      else if (child.localName = 'actualArm') then
        value.actualArmElement := ParseString(child, path+'/actualArm')
      else if (child.localName = 'consent') then
        value.consent := ParseReference(child, path+'/consent')
      else if Not ParseDomainResourceChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeResearchSubject(xml : TXmlBuilder; name : String; value : TFhirResearchSubject);
begin
  if (value = nil) then
    exit;
  composeDomainResourceAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeResearchSubjectChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeResearchSubjectChildren(xml : TXmlBuilder; value : TFhirResearchSubject);
var
  i : integer;
begin
  composeDomainResourceChildren(xml, value);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.identifierList.Count - 1 do
      ComposeIdentifier(xml, 'identifier', value.identifierList[i]);
  ComposeEnum(xml, 'status', value.statusElement, CODES_TFhirPublicationStatusEnum);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.progressList.Count - 1 do
      ComposeResearchSubjectProgress(xml, 'progress', value.progressList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposePeriod(xml, 'period', value.period);
  ComposeReference(xml, 'study', value.study);
  ComposeReference(xml, 'subject', value.subject);
  if (SummaryOption in [soFull, soData]) then
    ComposeString(xml, 'assignedArm', value.assignedArmElement);
  if (SummaryOption in [soFull, soData]) then
    ComposeString(xml, 'actualArm', value.actualArmElement);
  if (SummaryOption in [soFull, soData]) then
    ComposeReference(xml, 'consent', value.consent);
end;

{$ENDIF FHIR_RESEARCHSUBJECT}
{$IFDEF FHIR_RISKASSESSMENT}
function TFHIRXmlParser.ParseRiskAssessmentPrediction(element : TMXmlElement; path : string) : TFhirRiskAssessmentPrediction;
var
  child : TMXmlElement;
begin
  result := TFhirRiskAssessmentPrediction.Create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseRiskAssessmentPredictionChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseRiskAssessmentPredictionChild(value : TFhirRiskAssessmentPrediction; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'outcome') then
        value.outcome := ParseCodeableConcept(child, path+'/outcome')
      else if (child.localName = 'probabilityRange') then
        value.probability := ParseRange(child, path+'/probabilityRange')
      else if (child.localName = 'probabilityDecimal') then
        value.probability := ParseDecimal(child, path+'/probabilityDecimal')
      else if (child.localName = 'qualitativeRisk') then
        value.qualitativeRisk := ParseCodeableConcept(child, path+'/qualitativeRisk')
      else if (child.localName = 'relativeRisk') then
        value.relativeRiskElement := ParseDecimal(child, path+'/relativeRisk')
      else if (child.localName = 'whenPeriod') then
        value.when := ParsePeriod(child, path+'/whenPeriod')
      else if (child.localName = 'whenRange') then
        value.when := ParseRange(child, path+'/whenRange')
      else if (child.localName = 'rationale') then
        value.rationaleElement := ParseString(child, path+'/rationale')
      else if Not ParseBackboneElementChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeRiskAssessmentPrediction(xml : TXmlBuilder; name : String; value : TFhirRiskAssessmentPrediction);
begin
  if (value = nil) then
    exit;
  composeElementAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeRiskAssessmentPredictionChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeRiskAssessmentPredictionChildren(xml : TXmlBuilder; value : TFhirRiskAssessmentPrediction);
begin
  composeBackboneElementChildren(xml, value);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(xml, 'outcome', value.outcome);
  if (SummaryOption in [soFull, soData]) and (value.probability is TFhirRange) {6} then
    ComposeRange(xml, 'probabilityRange', TFhirRange(value.probability))
  else if (SummaryOption in [soFull, soData]) and (value.probability is TFhirDecimal) {6} then
    ComposeDecimal(xml, 'probabilityDecimal', TFhirDecimal(value.probability));
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(xml, 'qualitativeRisk', value.qualitativeRisk);
  if (SummaryOption in [soFull, soData]) then
    ComposeDecimal(xml, 'relativeRisk', value.relativeRiskElement);
  if (SummaryOption in [soFull, soData]) and (value.when is TFhirPeriod) {6} then
    ComposePeriod(xml, 'whenPeriod', TFhirPeriod(value.when))
  else if (SummaryOption in [soFull, soData]) and (value.when is TFhirRange) {6} then
    ComposeRange(xml, 'whenRange', TFhirRange(value.when));
  if (SummaryOption in [soFull, soData]) then
    ComposeString(xml, 'rationale', value.rationaleElement);
end;

function TFHIRXmlParser.ParseRiskAssessment(element : TMXmlElement; path : string) : TFhirRiskAssessment;
var
  child : TMXmlElement;
begin
  result := TFhirRiskAssessment.Create;
  try
    parseDomainResourceAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseRiskAssessmentChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseRiskAssessmentChild(value : TFhirRiskAssessment; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'identifier') then
        value.identifierList.Add(ParseIdentifier(child, path+'/identifier'))
      else if (child.localName = 'basedOn') then
        value.basedOn := ParseReference(child, path+'/basedOn')
      else if (child.localName = 'parent') then
        value.parent := ParseReference(child, path+'/parent')
      else if (child.localName = 'status') then
        value.statusElement := ParseEnum(CODES_TFhirObservationStatusEnum, SYSTEMS_TFhirObservationStatusEnum, child, path+'/status')
      else if (child.localName = 'method') then
        value.method := ParseCodeableConcept(child, path+'/method')
      else if (child.localName = 'code') then
        value.code := ParseCodeableConcept(child, path+'/code')
      else if (child.localName = 'subject') then
        value.subject := ParseReference(child, path+'/subject')
      else if (child.localName = 'encounter') then
        value.encounter := ParseReference(child, path+'/encounter')
      else if (child.localName = 'occurrencePeriod') then
        value.occurrence := ParsePeriod(child, path+'/occurrencePeriod')
      else if (child.localName = 'occurrenceDateTime') then
        value.occurrence := ParseDateTime(child, path+'/occurrenceDateTime')
      else if (child.localName = 'condition') then
        value.condition := ParseReference(child, path+'/condition')
      else if (child.localName = 'performer') then
        value.performer := ParseReference(child, path+'/performer')
      else if (child.localName = 'reason') then
        value.reasonList.Add(ParseCodeableReference(child, path+'/reason'))
      else if (child.localName = 'basis') then
        value.basisList.Add(ParseReference(child, path+'/basis'))
      else if (child.localName = 'prediction') then
        value.predictionList.Add(ParseRiskAssessmentPrediction(child, path+'/prediction'))
      else if (child.localName = 'mitigation') then
        value.mitigationElement := ParseString(child, path+'/mitigation')
      else if (child.localName = 'note') then
        value.noteList.Add(ParseAnnotation(child, path+'/note'))
      else if Not ParseDomainResourceChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeRiskAssessment(xml : TXmlBuilder; name : String; value : TFhirRiskAssessment);
begin
  if (value = nil) then
    exit;
  composeDomainResourceAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeRiskAssessmentChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeRiskAssessmentChildren(xml : TXmlBuilder; value : TFhirRiskAssessment);
var
  i : integer;
begin
  composeDomainResourceChildren(xml, value);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.identifierList.Count - 1 do
      ComposeIdentifier(xml, 'identifier', value.identifierList[i]);
  if (SummaryOption in [soFull, soData]) then
    ComposeReference(xml, 'basedOn', value.basedOn);
  if (SummaryOption in [soFull, soData]) then
    ComposeReference(xml, 'parent', value.parent);
  ComposeEnum(xml, 'status', value.statusElement, CODES_TFhirObservationStatusEnum);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(xml, 'method', value.method);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(xml, 'code', value.code);
  ComposeReference(xml, 'subject', value.subject);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference(xml, 'encounter', value.encounter);
  if (SummaryOption in [soFull, soSummary, soData]) and (value.occurrence is TFhirPeriod) {6} then
    ComposePeriod(xml, 'occurrencePeriod', TFhirPeriod(value.occurrence))
  else if (SummaryOption in [soFull, soSummary, soData]) and (value.occurrence is TFhirDateTime) {6} then
    ComposeDateTime(xml, 'occurrenceDateTime', TFhirDateTime(value.occurrence));
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference(xml, 'condition', value.condition);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference(xml, 'performer', value.performer);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.reasonList.Count - 1 do
      ComposeCodeableReference(xml, 'reason', value.reasonList[i]);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.basisList.Count - 1 do
      ComposeReference(xml, 'basis', value.basisList[i]);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.predictionList.Count - 1 do
      ComposeRiskAssessmentPrediction(xml, 'prediction', value.predictionList[i]);
  if (SummaryOption in [soFull, soData]) then
    ComposeString(xml, 'mitigation', value.mitigationElement);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.noteList.Count - 1 do
      ComposeAnnotation(xml, 'note', value.noteList[i]);
end;

{$ENDIF FHIR_RISKASSESSMENT}
{$IFDEF FHIR_SCHEDULE}
function TFHIRXmlParser.ParseSchedule(element : TMXmlElement; path : string) : TFhirSchedule;
var
  child : TMXmlElement;
begin
  result := TFhirSchedule.Create;
  try
    parseDomainResourceAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseScheduleChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseScheduleChild(value : TFhirSchedule; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'identifier') then
        value.identifierList.Add(ParseIdentifier(child, path+'/identifier'))
      else if (child.localName = 'active') then
        value.activeElement := ParseBoolean(child, path+'/active')
      else if (child.localName = 'serviceCategory') then
        value.serviceCategoryList.Add(ParseCodeableConcept(child, path+'/serviceCategory'))
      else if (child.localName = 'serviceType') then
        value.serviceTypeList.Add(ParseCodeableReference(child, path+'/serviceType'))
      else if (child.localName = 'specialty') then
        value.specialtyList.Add(ParseCodeableConcept(child, path+'/specialty'))
      else if (child.localName = 'name') then
        value.nameElement := ParseString(child, path+'/name')
      else if (child.localName = 'actor') then
        value.actorList.Add(ParseReference(child, path+'/actor'))
      else if (child.localName = 'planningHorizon') then
        value.planningHorizon := ParsePeriod(child, path+'/planningHorizon')
      else if (child.localName = 'comment') then
        value.commentElement := ParseString(child, path+'/comment')
      else if Not ParseDomainResourceChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeSchedule(xml : TXmlBuilder; name : String; value : TFhirSchedule);
begin
  if (value = nil) then
    exit;
  composeDomainResourceAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeScheduleChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeScheduleChildren(xml : TXmlBuilder; value : TFhirSchedule);
var
  i : integer;
begin
  composeDomainResourceChildren(xml, value);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.identifierList.Count - 1 do
      ComposeIdentifier(xml, 'identifier', value.identifierList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeBoolean(xml, 'active', value.activeElement);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.serviceCategoryList.Count - 1 do
      ComposeCodeableConcept(xml, 'serviceCategory', value.serviceCategoryList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.serviceTypeList.Count - 1 do
      ComposeCodeableReference(xml, 'serviceType', value.serviceTypeList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.specialtyList.Count - 1 do
      ComposeCodeableConcept(xml, 'specialty', value.specialtyList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(xml, 'name', value.nameElement);
  for i := 0 to value.actorList.Count - 1 do
      ComposeReference(xml, 'actor', value.actorList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposePeriod(xml, 'planningHorizon', value.planningHorizon);
  if (SummaryOption in [soFull, soData]) then
    ComposeString(xml, 'comment', value.commentElement);
end;

{$ENDIF FHIR_SCHEDULE}
{$IFDEF FHIR_SEARCHPARAMETER}
function TFHIRXmlParser.ParseSearchParameterComponent(element : TMXmlElement; path : string) : TFhirSearchParameterComponent;
var
  child : TMXmlElement;
begin
  result := TFhirSearchParameterComponent.Create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseSearchParameterComponentChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseSearchParameterComponentChild(value : TFhirSearchParameterComponent; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'definition') then
        value.definitionElement := ParseCanonical(child, path+'/definition')
      else if (child.localName = 'expression') then
        value.expressionElement := ParseString(child, path+'/expression')
      else if Not ParseBackboneElementChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeSearchParameterComponent(xml : TXmlBuilder; name : String; value : TFhirSearchParameterComponent);
begin
  if (value = nil) then
    exit;
  composeElementAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeSearchParameterComponentChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeSearchParameterComponentChildren(xml : TXmlBuilder; value : TFhirSearchParameterComponent);
begin
  composeBackboneElementChildren(xml, value);
  ComposeCanonical(xml, 'definition', value.definitionElement);
  ComposeString(xml, 'expression', value.expressionElement);
end;

function TFHIRXmlParser.ParseSearchParameter(element : TMXmlElement; path : string) : TFhirSearchParameter;
var
  child : TMXmlElement;
begin
  result := TFhirSearchParameter.Create;
  try
    parseCanonicalResourceAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseSearchParameterChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseSearchParameterChild(value : TFhirSearchParameter; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'url') then
        value.urlElement := ParseUri(child, path+'/url')
      else if (child.localName = 'version') then
        value.versionElement := ParseString(child, path+'/version')
      else if (child.localName = 'versionAlgorithmCoding') then
        value.versionAlgorithm := ParseCoding(child, path+'/versionAlgorithmCoding')
      else if (child.localName = 'versionAlgorithmString') then
        value.versionAlgorithm := ParseString(child, path+'/versionAlgorithmString')
      else if (child.localName = 'name') then
        value.nameElement := ParseString(child, path+'/name')
      else if (child.localName = 'title') then
        value.titleElement := ParseString(child, path+'/title')
      else if (child.localName = 'derivedFrom') then
        value.derivedFromElement := ParseCanonical(child, path+'/derivedFrom')
      else if (child.localName = 'status') then
        value.statusElement := ParseEnum(CODES_TFhirPublicationStatusEnum, SYSTEMS_TFhirPublicationStatusEnum, child, path+'/status')
      else if (child.localName = 'experimental') then
        value.experimentalElement := ParseBoolean(child, path+'/experimental')
      else if (child.localName = 'date') then
        value.dateElement := ParseDateTime(child, path+'/date')
      else if (child.localName = 'publisher') then
        value.publisherElement := ParseString(child, path+'/publisher')
      else if (child.localName = 'contact') then
        value.contactList.Add(ParseContactDetail(child, path+'/contact'))
      else if (child.localName = 'description') then
        value.descriptionElement := ParseMarkdown(child, path+'/description')
      else if (child.localName = 'useContext') then
        value.useContextList.Add(ParseUsageContext(child, path+'/useContext'))
      else if (child.localName = 'jurisdiction') then
        value.jurisdictionList.Add(ParseCodeableConcept(child, path+'/jurisdiction'))
      else if (child.localName = 'purpose') then
        value.purposeElement := ParseMarkdown(child, path+'/purpose')
      else if (child.localName = 'code') then
        value.codeElement := ParseCode(child, path+'/code')
      else if (child.localName = 'base') then
        value.base.Add(ParseEnum(CODES_TFhirAllResourceTypesEnum, SYSTEMS_TFhirAllResourceTypesEnum, child, path+'/base')){y.1}
      else if (child.localName = 'type') then
        value.type_Element := ParseEnum(CODES_TFhirSearchParamTypeEnum, SYSTEMS_TFhirSearchParamTypeEnum, child, path+'/type')
      else if (child.localName = 'expression') then
        value.expressionElement := ParseString(child, path+'/expression')
      else if (child.localName = 'processingMode') then
        value.processingModeElement := ParseEnum(CODES_TFhirSearchProcessingModeTypeEnum, SYSTEMS_TFhirSearchProcessingModeTypeEnum, child, path+'/processingMode')
      else if (child.localName = 'constraint') then
        value.constraintElement := ParseString(child, path+'/constraint')
      else if (child.localName = 'target') then
        value.target.Add(ParseEnum(CODES_TFhirResourceTypesEnum, SYSTEMS_TFhirResourceTypesEnum, child, path+'/target')){y.1}
      else if (child.localName = 'multipleOr') then
        value.multipleOrElement := ParseBoolean(child, path+'/multipleOr')
      else if (child.localName = 'multipleAnd') then
        value.multipleAndElement := ParseBoolean(child, path+'/multipleAnd')
      else if (child.localName = 'comparator') then
        value.comparatorList.Add(ParseEnum(CODES_TFhirSearchComparatorEnum, SYSTEMS_TFhirSearchComparatorEnum, child, path+'/comparator')){y.1}
      else if (child.localName = 'modifier') then
        value.modifierList.Add(ParseEnum(CODES_TFhirSearchModifierCodeEnum, SYSTEMS_TFhirSearchModifierCodeEnum, child, path+'/modifier')){y.1}
      else if (child.localName = 'chain') then
        value.chainList.Add(ParseString(child, path+'/chain'))
      else if (child.localName = 'component') then
        value.componentList.Add(ParseSearchParameterComponent(child, path+'/component'))
      else if Not ParseCanonicalResourceChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeSearchParameter(xml : TXmlBuilder; name : String; value : TFhirSearchParameter);
begin
  if (value = nil) then
    exit;
  composeCanonicalResourceAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeSearchParameterChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeSearchParameterChildren(xml : TXmlBuilder; value : TFhirSearchParameter);
var
  i : integer;
begin
  composeCanonicalResourceChildren(xml, value);
  ComposeUri(xml, 'url', value.urlElement);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(xml, 'version', value.versionElement);
  if (SummaryOption in [soFull, soSummary, soData]) and (value.versionAlgorithm is TFhirCoding) {6} then
    ComposeCoding(xml, 'versionAlgorithmCoding', TFhirCoding(value.versionAlgorithm))
  else if (SummaryOption in [soFull, soSummary, soData]) and (value.versionAlgorithm is TFhirString) {6} then
    ComposeString(xml, 'versionAlgorithmString', TFhirString(value.versionAlgorithm));
  ComposeString(xml, 'name', value.nameElement);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(xml, 'title', value.titleElement);
  if (SummaryOption in [soFull, soData]) then
    ComposeCanonical(xml, 'derivedFrom', value.derivedFromElement);
  ComposeEnum(xml, 'status', value.statusElement, CODES_TFhirPublicationStatusEnum);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeBoolean(xml, 'experimental', value.experimentalElement);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDateTime(xml, 'date', value.dateElement);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(xml, 'publisher', value.publisherElement);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.contactList.Count - 1 do
      ComposeContactDetail(xml, 'contact', value.contactList[i]);
  ComposeMarkdown(xml, 'description', value.descriptionElement);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.useContextList.Count - 1 do
      ComposeUsageContext(xml, 'useContext', value.useContextList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.jurisdictionList.Count - 1 do
      ComposeCodeableConcept(xml, 'jurisdiction', value.jurisdictionList[i]);
  if (SummaryOption in [soFull, soData]) then
    ComposeMarkdown(xml, 'purpose', value.purposeElement);
  ComposeCode(xml, 'code', value.codeElement);
  for i := 0 to value.base.Count - 1 do
      ComposeEnum(xml, 'base', value.base[i], CODES_TFhirAllResourceTypesEnum);
  ComposeEnum(xml, 'type', value.type_Element, CODES_TFhirSearchParamTypeEnum);
  if (SummaryOption in [soFull, soData]) then
    ComposeString(xml, 'expression', value.expressionElement);
  if (SummaryOption in [soFull, soData]) then
    ComposeEnum(xml, 'processingMode', value.processingModeElement, CODES_TFhirSearchProcessingModeTypeEnum);
  if (SummaryOption in [soFull, soData]) then
    ComposeString(xml, 'constraint', value.constraintElement);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.target.Count - 1 do
      ComposeEnum(xml, 'target', value.target[i], CODES_TFhirResourceTypesEnum);
  if (SummaryOption in [soFull, soData]) then
    ComposeBoolean(xml, 'multipleOr', value.multipleOrElement);
  if (SummaryOption in [soFull, soData]) then
    ComposeBoolean(xml, 'multipleAnd', value.multipleAndElement);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.comparatorList.Count - 1 do
      ComposeEnum(xml, 'comparator', value.comparatorList[i], CODES_TFhirSearchComparatorEnum);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.modifierList.Count - 1 do
      ComposeEnum(xml, 'modifier', value.modifierList[i], CODES_TFhirSearchModifierCodeEnum);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.chainList.Count - 1 do
      ComposeString(xml, 'chain', value.chainList[i]);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.componentList.Count - 1 do
      ComposeSearchParameterComponent(xml, 'component', value.componentList[i]);
end;

{$ENDIF FHIR_SEARCHPARAMETER}
{$IFDEF FHIR_SERVICEREQUEST}
function TFHIRXmlParser.ParseServiceRequest(element : TMXmlElement; path : string) : TFhirServiceRequest;
var
  child : TMXmlElement;
begin
  result := TFhirServiceRequest.Create;
  try
    parseDomainResourceAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseServiceRequestChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseServiceRequestChild(value : TFhirServiceRequest; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'identifier') then
        value.identifierList.Add(ParseIdentifier(child, path+'/identifier'))
      else if (child.localName = 'instantiatesCanonical') then
        value.instantiatesCanonicalList.Add(ParseCanonical(child, path+'/instantiatesCanonical'))
      else if (child.localName = 'instantiatesUri') then
        value.instantiatesUriList.Add(ParseUri(child, path+'/instantiatesUri'))
      else if (child.localName = 'basedOn') then
        value.basedOnList.Add(ParseReference(child, path+'/basedOn'))
      else if (child.localName = 'replaces') then
        value.replacesList.Add(ParseReference(child, path+'/replaces'))
      else if (child.localName = 'requisition') then
        value.requisition := ParseIdentifier(child, path+'/requisition')
      else if (child.localName = 'status') then
        value.statusElement := ParseEnum(CODES_TFhirRequestStatusEnum, SYSTEMS_TFhirRequestStatusEnum, child, path+'/status')
      else if (child.localName = 'intent') then
        value.intentElement := ParseEnum(CODES_TFhirRequestIntentEnum, SYSTEMS_TFhirRequestIntentEnum, child, path+'/intent')
      else if (child.localName = 'category') then
        value.categoryList.Add(ParseCodeableConcept(child, path+'/category'))
      else if (child.localName = 'priority') then
        value.priorityElement := ParseEnum(CODES_TFhirRequestPriorityEnum, SYSTEMS_TFhirRequestPriorityEnum, child, path+'/priority')
      else if (child.localName = 'doNotPerform') then
        value.doNotPerformElement := ParseBoolean(child, path+'/doNotPerform')
      else if (child.localName = 'code') then
        value.code := ParseCodeableReference(child, path+'/code')
      else if (child.localName = 'orderDetail') then
        value.orderDetailList.Add(ParseCodeableConcept(child, path+'/orderDetail'))
      else if (child.localName = 'quantityQuantity') then
        value.quantity := ParseQuantity(child, path+'/quantityQuantity')
      else if (child.localName = 'quantityRatio') then
        value.quantity := ParseRatio(child, path+'/quantityRatio')
      else if (child.localName = 'quantityRange') then
        value.quantity := ParseRange(child, path+'/quantityRange')
      else if (child.localName = 'subject') then
        value.subject := ParseReference(child, path+'/subject')
      else if (child.localName = 'focus') then
        value.focusList.Add(ParseReference(child, path+'/focus'))
      else if (child.localName = 'encounter') then
        value.encounter := ParseReference(child, path+'/encounter')
      else if (child.localName = 'occurrencePeriod') then
        value.occurrence := ParsePeriod(child, path+'/occurrencePeriod')
      else if (child.localName = 'occurrenceTiming') then
        value.occurrence := ParseTiming(child, path+'/occurrenceTiming')
      else if (child.localName = 'occurrenceDateTime') then
        value.occurrence := ParseDateTime(child, path+'/occurrenceDateTime')
      else if (child.localName = 'asNeededCodeableConcept') then
        value.asNeeded := ParseCodeableConcept(child, path+'/asNeededCodeableConcept')
      else if (child.localName = 'asNeededBoolean') then
        value.asNeeded := ParseBoolean(child, path+'/asNeededBoolean')
      else if (child.localName = 'authoredOn') then
        value.authoredOnElement := ParseDateTime(child, path+'/authoredOn')
      else if (child.localName = 'requester') then
        value.requester := ParseReference(child, path+'/requester')
      else if (child.localName = 'performerType') then
        value.performerType := ParseCodeableConcept(child, path+'/performerType')
      else if (child.localName = 'performer') then
        value.performerList.Add(ParseReference(child, path+'/performer'))
      else if (child.localName = 'location') then
        value.locationList.Add(ParseCodeableReference(child, path+'/location'))
      else if (child.localName = 'reason') then
        value.reasonList.Add(ParseCodeableReference(child, path+'/reason'))
      else if (child.localName = 'insurance') then
        value.insuranceList.Add(ParseReference(child, path+'/insurance'))
      else if (child.localName = 'supportingInfo') then
        value.supportingInfoList.Add(ParseReference(child, path+'/supportingInfo'))
      else if (child.localName = 'specimen') then
        value.specimenList.Add(ParseReference(child, path+'/specimen'))
      else if (child.localName = 'bodySite') then
        value.bodySiteList.Add(ParseCodeableConcept(child, path+'/bodySite'))
      else if (child.localName = 'bodyStructure') then
        value.bodyStructure := ParseReference(child, path+'/bodyStructure')
      else if (child.localName = 'note') then
        value.noteList.Add(ParseAnnotation(child, path+'/note'))
      else if (child.localName = 'patientInstruction') then
        value.patientInstructionElement := ParseString(child, path+'/patientInstruction')
      else if (child.localName = 'relevantHistory') then
        value.relevantHistoryList.Add(ParseReference(child, path+'/relevantHistory'))
      else if Not ParseDomainResourceChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeServiceRequest(xml : TXmlBuilder; name : String; value : TFhirServiceRequest);
begin
  if (value = nil) then
    exit;
  composeDomainResourceAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeServiceRequestChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeServiceRequestChildren(xml : TXmlBuilder; value : TFhirServiceRequest);
var
  i : integer;
begin
  composeDomainResourceChildren(xml, value);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.identifierList.Count - 1 do
      ComposeIdentifier(xml, 'identifier', value.identifierList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.instantiatesCanonicalList.Count - 1 do
      ComposeCanonical(xml, 'instantiatesCanonical', value.instantiatesCanonicalList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.instantiatesUriList.Count - 1 do
      ComposeUri(xml, 'instantiatesUri', value.instantiatesUriList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.basedOnList.Count - 1 do
      ComposeReference(xml, 'basedOn', value.basedOnList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.replacesList.Count - 1 do
      ComposeReference(xml, 'replaces', value.replacesList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeIdentifier(xml, 'requisition', value.requisition);
  ComposeEnum(xml, 'status', value.statusElement, CODES_TFhirRequestStatusEnum);
  ComposeEnum(xml, 'intent', value.intentElement, CODES_TFhirRequestIntentEnum);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.categoryList.Count - 1 do
      ComposeCodeableConcept(xml, 'category', value.categoryList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeEnum(xml, 'priority', value.priorityElement, CODES_TFhirRequestPriorityEnum);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeBoolean(xml, 'doNotPerform', value.doNotPerformElement);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableReference(xml, 'code', value.code);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.orderDetailList.Count - 1 do
      ComposeCodeableConcept(xml, 'orderDetail', value.orderDetailList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) and (value.quantity is TFhirQuantity) {6} then
    ComposeQuantity(xml, 'quantityQuantity', TFhirQuantity(value.quantity))
  else if (SummaryOption in [soFull, soSummary, soData]) and (value.quantity is TFhirRatio) {6} then
    ComposeRatio(xml, 'quantityRatio', TFhirRatio(value.quantity))
  else if (SummaryOption in [soFull, soSummary, soData]) and (value.quantity is TFhirRange) {6} then
    ComposeRange(xml, 'quantityRange', TFhirRange(value.quantity));
  ComposeReference(xml, 'subject', value.subject);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.focusList.Count - 1 do
      ComposeReference(xml, 'focus', value.focusList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference(xml, 'encounter', value.encounter);
  if (SummaryOption in [soFull, soSummary, soData]) and (value.occurrence is TFhirPeriod) {6} then
    ComposePeriod(xml, 'occurrencePeriod', TFhirPeriod(value.occurrence))
  else if (SummaryOption in [soFull, soSummary, soData]) and (value.occurrence is TFhirTiming) {6} then
    ComposeTiming(xml, 'occurrenceTiming', TFhirTiming(value.occurrence))
  else if (SummaryOption in [soFull, soSummary, soData]) and (value.occurrence is TFhirDateTime) {6} then
    ComposeDateTime(xml, 'occurrenceDateTime', TFhirDateTime(value.occurrence));
  if (SummaryOption in [soFull, soSummary, soData]) and (value.asNeeded is TFhirCodeableConcept) {6} then
    ComposeCodeableConcept(xml, 'asNeededCodeableConcept', TFhirCodeableConcept(value.asNeeded))
  else if (SummaryOption in [soFull, soSummary, soData]) and (value.asNeeded is TFhirBoolean) {6} then
    ComposeBoolean(xml, 'asNeededBoolean', TFhirBoolean(value.asNeeded));
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDateTime(xml, 'authoredOn', value.authoredOnElement);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference(xml, 'requester', value.requester);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(xml, 'performerType', value.performerType);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.performerList.Count - 1 do
      ComposeReference(xml, 'performer', value.performerList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.locationList.Count - 1 do
      ComposeCodeableReference(xml, 'location', value.locationList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.reasonList.Count - 1 do
      ComposeCodeableReference(xml, 'reason', value.reasonList[i]);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.insuranceList.Count - 1 do
      ComposeReference(xml, 'insurance', value.insuranceList[i]);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.supportingInfoList.Count - 1 do
      ComposeReference(xml, 'supportingInfo', value.supportingInfoList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.specimenList.Count - 1 do
      ComposeReference(xml, 'specimen', value.specimenList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.bodySiteList.Count - 1 do
      ComposeCodeableConcept(xml, 'bodySite', value.bodySiteList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference(xml, 'bodyStructure', value.bodyStructure);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.noteList.Count - 1 do
      ComposeAnnotation(xml, 'note', value.noteList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(xml, 'patientInstruction', value.patientInstructionElement);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.relevantHistoryList.Count - 1 do
      ComposeReference(xml, 'relevantHistory', value.relevantHistoryList[i]);
end;

{$ENDIF FHIR_SERVICEREQUEST}
{$IFDEF FHIR_SLOT}
function TFHIRXmlParser.ParseSlot(element : TMXmlElement; path : string) : TFhirSlot;
var
  child : TMXmlElement;
begin
  result := TFhirSlot.Create;
  try
    parseDomainResourceAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseSlotChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseSlotChild(value : TFhirSlot; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'identifier') then
        value.identifierList.Add(ParseIdentifier(child, path+'/identifier'))
      else if (child.localName = 'serviceCategory') then
        value.serviceCategoryList.Add(ParseCodeableConcept(child, path+'/serviceCategory'))
      else if (child.localName = 'serviceType') then
        value.serviceTypeList.Add(ParseCodeableReference(child, path+'/serviceType'))
      else if (child.localName = 'specialty') then
        value.specialtyList.Add(ParseCodeableConcept(child, path+'/specialty'))
      else if (child.localName = 'appointmentType') then
        value.appointmentTypeList.Add(ParseCodeableConcept(child, path+'/appointmentType'))
      else if (child.localName = 'schedule') then
        value.schedule := ParseReference(child, path+'/schedule')
      else if (child.localName = 'status') then
        value.statusElement := ParseEnum(CODES_TFhirSlotStatusEnum, SYSTEMS_TFhirSlotStatusEnum, child, path+'/status')
      else if (child.localName = 'start') then
        value.startElement := ParseInstant(child, path+'/start')
      else if (child.localName = 'end') then
        value.end_Element := ParseInstant(child, path+'/end')
      else if (child.localName = 'overbooked') then
        value.overbookedElement := ParseBoolean(child, path+'/overbooked')
      else if (child.localName = 'comment') then
        value.commentElement := ParseString(child, path+'/comment')
      else if Not ParseDomainResourceChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeSlot(xml : TXmlBuilder; name : String; value : TFhirSlot);
begin
  if (value = nil) then
    exit;
  composeDomainResourceAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeSlotChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeSlotChildren(xml : TXmlBuilder; value : TFhirSlot);
var
  i : integer;
begin
  composeDomainResourceChildren(xml, value);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.identifierList.Count - 1 do
      ComposeIdentifier(xml, 'identifier', value.identifierList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.serviceCategoryList.Count - 1 do
      ComposeCodeableConcept(xml, 'serviceCategory', value.serviceCategoryList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.serviceTypeList.Count - 1 do
      ComposeCodeableReference(xml, 'serviceType', value.serviceTypeList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.specialtyList.Count - 1 do
      ComposeCodeableConcept(xml, 'specialty', value.specialtyList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.appointmentTypeList.Count - 1 do
      ComposeCodeableConcept(xml, 'appointmentType', value.appointmentTypeList[i]);
  ComposeReference(xml, 'schedule', value.schedule);
  ComposeEnum(xml, 'status', value.statusElement, CODES_TFhirSlotStatusEnum);
  ComposeInstant(xml, 'start', value.startElement);
  ComposeInstant(xml, 'end', value.end_Element);
  if (SummaryOption in [soFull, soData]) then
    ComposeBoolean(xml, 'overbooked', value.overbookedElement);
  if (SummaryOption in [soFull, soData]) then
    ComposeString(xml, 'comment', value.commentElement);
end;

{$ENDIF FHIR_SLOT}
{$IFDEF FHIR_SPECIMEN}
function TFHIRXmlParser.ParseSpecimenFeature(element : TMXmlElement; path : string) : TFhirSpecimenFeature;
var
  child : TMXmlElement;
begin
  result := TFhirSpecimenFeature.Create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseSpecimenFeatureChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseSpecimenFeatureChild(value : TFhirSpecimenFeature; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'type') then
        value.type_ := ParseCodeableConcept(child, path+'/type')
      else if (child.localName = 'description') then
        value.descriptionElement := ParseString(child, path+'/description')
      else if Not ParseBackboneElementChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeSpecimenFeature(xml : TXmlBuilder; name : String; value : TFhirSpecimenFeature);
begin
  if (value = nil) then
    exit;
  composeElementAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeSpecimenFeatureChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeSpecimenFeatureChildren(xml : TXmlBuilder; value : TFhirSpecimenFeature);
begin
  composeBackboneElementChildren(xml, value);
  ComposeCodeableConcept(xml, 'type', value.type_);
  ComposeString(xml, 'description', value.descriptionElement);
end;

function TFHIRXmlParser.ParseSpecimenCollection(element : TMXmlElement; path : string) : TFhirSpecimenCollection;
var
  child : TMXmlElement;
begin
  result := TFhirSpecimenCollection.Create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseSpecimenCollectionChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseSpecimenCollectionChild(value : TFhirSpecimenCollection; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'collector') then
        value.collector := ParseReference(child, path+'/collector')
      else if (child.localName = 'collectedPeriod') then
        value.collected := ParsePeriod(child, path+'/collectedPeriod')
      else if (child.localName = 'collectedDateTime') then
        value.collected := ParseDateTime(child, path+'/collectedDateTime')
      else if (child.localName = 'duration') then
        value.duration := ParseDuration(child, path+'/duration')
      else if (child.localName = 'quantity') then
        value.quantity := ParseQuantity(child, path+'/quantity')
      else if (child.localName = 'method') then
        value.method := ParseCodeableConcept(child, path+'/method')
      else if (child.localName = 'device') then
        value.device := ParseCodeableReference(child, path+'/device')
      else if (child.localName = 'procedure') then
        value.procedure_ := ParseReference(child, path+'/procedure')
      else if (child.localName = 'bodySite') then
        value.bodySite := ParseCodeableReference(child, path+'/bodySite')
      else if (child.localName = 'fastingStatusCodeableConcept') then
        value.fastingStatus := ParseCodeableConcept(child, path+'/fastingStatusCodeableConcept')
      else if (child.localName = 'fastingStatusDuration') then
        value.fastingStatus := ParseDuration(child, path+'/fastingStatusDuration')
      else if Not ParseBackboneElementChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeSpecimenCollection(xml : TXmlBuilder; name : String; value : TFhirSpecimenCollection);
begin
  if (value = nil) then
    exit;
  composeElementAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeSpecimenCollectionChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeSpecimenCollectionChildren(xml : TXmlBuilder; value : TFhirSpecimenCollection);
begin
  composeBackboneElementChildren(xml, value);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference(xml, 'collector', value.collector);
  if (SummaryOption in [soFull, soSummary, soData]) and (value.collected is TFhirPeriod) {6} then
    ComposePeriod(xml, 'collectedPeriod', TFhirPeriod(value.collected))
  else if (SummaryOption in [soFull, soSummary, soData]) and (value.collected is TFhirDateTime) {6} then
    ComposeDateTime(xml, 'collectedDateTime', TFhirDateTime(value.collected));
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDuration(xml, 'duration', value.duration);
  if (SummaryOption in [soFull, soData]) then
    ComposeQuantity(xml, 'quantity', value.quantity);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(xml, 'method', value.method);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableReference(xml, 'device', value.device);
  if (SummaryOption in [soFull, soData]) then
    ComposeReference(xml, 'procedure', value.procedure_);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableReference(xml, 'bodySite', value.bodySite);
  if (SummaryOption in [soFull, soSummary, soData]) and (value.fastingStatus is TFhirCodeableConcept) {6} then
    ComposeCodeableConcept(xml, 'fastingStatusCodeableConcept', TFhirCodeableConcept(value.fastingStatus))
  else if (SummaryOption in [soFull, soSummary, soData]) and (value.fastingStatus is TFhirDuration) {6} then
    ComposeDuration(xml, 'fastingStatusDuration', TFhirDuration(value.fastingStatus));
end;

function TFHIRXmlParser.ParseSpecimenProcessing(element : TMXmlElement; path : string) : TFhirSpecimenProcessing;
var
  child : TMXmlElement;
begin
  result := TFhirSpecimenProcessing.Create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseSpecimenProcessingChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseSpecimenProcessingChild(value : TFhirSpecimenProcessing; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'description') then
        value.descriptionElement := ParseString(child, path+'/description')
      else if (child.localName = 'method') then
        value.method := ParseCodeableConcept(child, path+'/method')
      else if (child.localName = 'additive') then
        value.additiveList.Add(ParseReference(child, path+'/additive'))
      else if (child.localName = 'timePeriod') then
        value.time := ParsePeriod(child, path+'/timePeriod')
      else if (child.localName = 'timeDateTime') then
        value.time := ParseDateTime(child, path+'/timeDateTime')
      else if Not ParseBackboneElementChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeSpecimenProcessing(xml : TXmlBuilder; name : String; value : TFhirSpecimenProcessing);
begin
  if (value = nil) then
    exit;
  composeElementAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeSpecimenProcessingChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeSpecimenProcessingChildren(xml : TXmlBuilder; value : TFhirSpecimenProcessing);
var
  i : integer;
begin
  composeBackboneElementChildren(xml, value);
  if (SummaryOption in [soFull, soData]) then
    ComposeString(xml, 'description', value.descriptionElement);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(xml, 'method', value.method);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.additiveList.Count - 1 do
      ComposeReference(xml, 'additive', value.additiveList[i]);
  if (SummaryOption in [soFull, soData]) and (value.time is TFhirPeriod) {6} then
    ComposePeriod(xml, 'timePeriod', TFhirPeriod(value.time))
  else if (SummaryOption in [soFull, soData]) and (value.time is TFhirDateTime) {6} then
    ComposeDateTime(xml, 'timeDateTime', TFhirDateTime(value.time));
end;

function TFHIRXmlParser.ParseSpecimenContainer(element : TMXmlElement; path : string) : TFhirSpecimenContainer;
var
  child : TMXmlElement;
begin
  result := TFhirSpecimenContainer.Create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseSpecimenContainerChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseSpecimenContainerChild(value : TFhirSpecimenContainer; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'device') then
        value.device := ParseReference(child, path+'/device')
      else if (child.localName = 'location') then
        value.location := ParseReference(child, path+'/location')
      else if (child.localName = 'specimenQuantity') then
        value.specimenQuantity := ParseQuantity(child, path+'/specimenQuantity')
      else if Not ParseBackboneElementChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeSpecimenContainer(xml : TXmlBuilder; name : String; value : TFhirSpecimenContainer);
begin
  if (value = nil) then
    exit;
  composeElementAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeSpecimenContainerChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeSpecimenContainerChildren(xml : TXmlBuilder; value : TFhirSpecimenContainer);
begin
  composeBackboneElementChildren(xml, value);
  ComposeReference(xml, 'device', value.device);
  if (SummaryOption in [soFull, soData]) then
    ComposeReference(xml, 'location', value.location);
  if (SummaryOption in [soFull, soData]) then
    ComposeQuantity(xml, 'specimenQuantity', value.specimenQuantity);
end;

function TFHIRXmlParser.ParseSpecimen(element : TMXmlElement; path : string) : TFhirSpecimen;
var
  child : TMXmlElement;
begin
  result := TFhirSpecimen.Create;
  try
    parseDomainResourceAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseSpecimenChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseSpecimenChild(value : TFhirSpecimen; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'identifier') then
        value.identifierList.Add(ParseIdentifier(child, path+'/identifier'))
      else if (child.localName = 'accessionIdentifier') then
        value.accessionIdentifier := ParseIdentifier(child, path+'/accessionIdentifier')
      else if (child.localName = 'status') then
        value.statusElement := ParseEnum(CODES_TFhirSpecimenStatusEnum, SYSTEMS_TFhirSpecimenStatusEnum, child, path+'/status')
      else if (child.localName = 'type') then
        value.type_ := ParseCodeableConcept(child, path+'/type')
      else if (child.localName = 'subject') then
        value.subject := ParseReference(child, path+'/subject')
      else if (child.localName = 'receivedTime') then
        value.receivedTimeElement := ParseDateTime(child, path+'/receivedTime')
      else if (child.localName = 'parent') then
        value.parentList.Add(ParseReference(child, path+'/parent'))
      else if (child.localName = 'request') then
        value.requestList.Add(ParseReference(child, path+'/request'))
      else if (child.localName = 'combined') then
        value.combinedElement := ParseEnum(CODES_TFhirSpecimenCombinedEnum, SYSTEMS_TFhirSpecimenCombinedEnum, child, path+'/combined')
      else if (child.localName = 'role') then
        value.roleList.Add(ParseCodeableConcept(child, path+'/role'))
      else if (child.localName = 'feature') then
        value.featureList.Add(ParseSpecimenFeature(child, path+'/feature'))
      else if (child.localName = 'collection') then
        value.collection := ParseSpecimenCollection(child, path+'/collection')
      else if (child.localName = 'processing') then
        value.processingList.Add(ParseSpecimenProcessing(child, path+'/processing'))
      else if (child.localName = 'container') then
        value.containerList.Add(ParseSpecimenContainer(child, path+'/container'))
      else if (child.localName = 'condition') then
        value.conditionList.Add(ParseCodeableConcept(child, path+'/condition'))
      else if (child.localName = 'note') then
        value.noteList.Add(ParseAnnotation(child, path+'/note'))
      else if Not ParseDomainResourceChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeSpecimen(xml : TXmlBuilder; name : String; value : TFhirSpecimen);
begin
  if (value = nil) then
    exit;
  composeDomainResourceAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeSpecimenChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeSpecimenChildren(xml : TXmlBuilder; value : TFhirSpecimen);
var
  i : integer;
begin
  composeDomainResourceChildren(xml, value);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.identifierList.Count - 1 do
      ComposeIdentifier(xml, 'identifier', value.identifierList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeIdentifier(xml, 'accessionIdentifier', value.accessionIdentifier);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeEnum(xml, 'status', value.statusElement, CODES_TFhirSpecimenStatusEnum);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(xml, 'type', value.type_);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference(xml, 'subject', value.subject);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDateTime(xml, 'receivedTime', value.receivedTimeElement);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.parentList.Count - 1 do
      ComposeReference(xml, 'parent', value.parentList[i]);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.requestList.Count - 1 do
      ComposeReference(xml, 'request', value.requestList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeEnum(xml, 'combined', value.combinedElement, CODES_TFhirSpecimenCombinedEnum);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.roleList.Count - 1 do
      ComposeCodeableConcept(xml, 'role', value.roleList[i]);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.featureList.Count - 1 do
      ComposeSpecimenFeature(xml, 'feature', value.featureList[i]);
  if (SummaryOption in [soFull, soData]) then
    ComposeSpecimenCollection(xml, 'collection', value.collection);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.processingList.Count - 1 do
      ComposeSpecimenProcessing(xml, 'processing', value.processingList[i]);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.containerList.Count - 1 do
      ComposeSpecimenContainer(xml, 'container', value.containerList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.conditionList.Count - 1 do
      ComposeCodeableConcept(xml, 'condition', value.conditionList[i]);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.noteList.Count - 1 do
      ComposeAnnotation(xml, 'note', value.noteList[i]);
end;

{$ENDIF FHIR_SPECIMEN}
{$IFDEF FHIR_SPECIMENDEFINITION}
function TFHIRXmlParser.ParseSpecimenDefinitionTypeTested(element : TMXmlElement; path : string) : TFhirSpecimenDefinitionTypeTested;
var
  child : TMXmlElement;
begin
  result := TFhirSpecimenDefinitionTypeTested.Create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseSpecimenDefinitionTypeTestedChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseSpecimenDefinitionTypeTestedChild(value : TFhirSpecimenDefinitionTypeTested; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'isDerived') then
        value.isDerivedElement := ParseBoolean(child, path+'/isDerived')
      else if (child.localName = 'type') then
        value.type_ := ParseCodeableConcept(child, path+'/type')
      else if (child.localName = 'preference') then
        value.preferenceElement := ParseEnum(CODES_TFhirSpecimenContainedPreferenceEnum, SYSTEMS_TFhirSpecimenContainedPreferenceEnum, child, path+'/preference')
      else if (child.localName = 'container') then
        value.container := ParseSpecimenDefinitionTypeTestedContainer(child, path+'/container')
      else if (child.localName = 'requirement') then
        value.requirementElement := ParseString(child, path+'/requirement')
      else if (child.localName = 'retentionTime') then
        value.retentionTime := ParseDuration(child, path+'/retentionTime')
      else if (child.localName = 'singleUse') then
        value.singleUseElement := ParseBoolean(child, path+'/singleUse')
      else if (child.localName = 'rejectionCriterion') then
        value.rejectionCriterionList.Add(ParseCodeableConcept(child, path+'/rejectionCriterion'))
      else if (child.localName = 'handling') then
        value.handlingList.Add(ParseSpecimenDefinitionTypeTestedHandling(child, path+'/handling'))
      else if (child.localName = 'testingDestination') then
        value.testingDestinationList.Add(ParseCodeableConcept(child, path+'/testingDestination'))
      else if Not ParseBackboneElementChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeSpecimenDefinitionTypeTested(xml : TXmlBuilder; name : String; value : TFhirSpecimenDefinitionTypeTested);
begin
  if (value = nil) then
    exit;
  composeElementAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeSpecimenDefinitionTypeTestedChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeSpecimenDefinitionTypeTestedChildren(xml : TXmlBuilder; value : TFhirSpecimenDefinitionTypeTested);
var
  i : integer;
begin
  composeBackboneElementChildren(xml, value);
  if (SummaryOption in [soFull, soData]) then
    ComposeBoolean(xml, 'isDerived', value.isDerivedElement);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(xml, 'type', value.type_);
  ComposeEnum(xml, 'preference', value.preferenceElement, CODES_TFhirSpecimenContainedPreferenceEnum);
  if (SummaryOption in [soFull, soData]) then
    ComposeSpecimenDefinitionTypeTestedContainer(xml, 'container', value.container);
  if (SummaryOption in [soFull, soData]) then
    ComposeString(xml, 'requirement', value.requirementElement);
  if (SummaryOption in [soFull, soData]) then
    ComposeDuration(xml, 'retentionTime', value.retentionTime);
  if (SummaryOption in [soFull, soData]) then
    ComposeBoolean(xml, 'singleUse', value.singleUseElement);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.rejectionCriterionList.Count - 1 do
      ComposeCodeableConcept(xml, 'rejectionCriterion', value.rejectionCriterionList[i]);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.handlingList.Count - 1 do
      ComposeSpecimenDefinitionTypeTestedHandling(xml, 'handling', value.handlingList[i]);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.testingDestinationList.Count - 1 do
      ComposeCodeableConcept(xml, 'testingDestination', value.testingDestinationList[i]);
end;

function TFHIRXmlParser.ParseSpecimenDefinitionTypeTestedContainer(element : TMXmlElement; path : string) : TFhirSpecimenDefinitionTypeTestedContainer;
var
  child : TMXmlElement;
begin
  result := TFhirSpecimenDefinitionTypeTestedContainer.Create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseSpecimenDefinitionTypeTestedContainerChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseSpecimenDefinitionTypeTestedContainerChild(value : TFhirSpecimenDefinitionTypeTestedContainer; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'material') then
        value.material := ParseCodeableConcept(child, path+'/material')
      else if (child.localName = 'type') then
        value.type_ := ParseCodeableConcept(child, path+'/type')
      else if (child.localName = 'cap') then
        value.cap := ParseCodeableConcept(child, path+'/cap')
      else if (child.localName = 'description') then
        value.descriptionElement := ParseString(child, path+'/description')
      else if (child.localName = 'capacity') then
        value.capacity := ParseQuantity(child, path+'/capacity')
      else if (child.localName = 'minimumVolumeQuantity') then
        value.minimumVolume := ParseQuantity(child, path+'/minimumVolumeQuantity')
      else if (child.localName = 'minimumVolumeString') then
        value.minimumVolume := ParseString(child, path+'/minimumVolumeString')
      else if (child.localName = 'additive') then
        value.additiveList.Add(ParseSpecimenDefinitionTypeTestedContainerAdditive(child, path+'/additive'))
      else if (child.localName = 'preparation') then
        value.preparationElement := ParseString(child, path+'/preparation')
      else if Not ParseBackboneElementChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeSpecimenDefinitionTypeTestedContainer(xml : TXmlBuilder; name : String; value : TFhirSpecimenDefinitionTypeTestedContainer);
begin
  if (value = nil) then
    exit;
  composeElementAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeSpecimenDefinitionTypeTestedContainerChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeSpecimenDefinitionTypeTestedContainerChildren(xml : TXmlBuilder; value : TFhirSpecimenDefinitionTypeTestedContainer);
var
  i : integer;
begin
  composeBackboneElementChildren(xml, value);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(xml, 'material', value.material);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(xml, 'type', value.type_);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(xml, 'cap', value.cap);
  if (SummaryOption in [soFull, soData]) then
    ComposeString(xml, 'description', value.descriptionElement);
  if (SummaryOption in [soFull, soData]) then
    ComposeQuantity(xml, 'capacity', value.capacity);
  if (SummaryOption in [soFull, soData]) and (value.minimumVolume is TFhirQuantity) {6} then
    ComposeQuantity(xml, 'minimumVolumeQuantity', TFhirQuantity(value.minimumVolume))
  else if (SummaryOption in [soFull, soData]) and (value.minimumVolume is TFhirString) {6} then
    ComposeString(xml, 'minimumVolumeString', TFhirString(value.minimumVolume));
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.additiveList.Count - 1 do
      ComposeSpecimenDefinitionTypeTestedContainerAdditive(xml, 'additive', value.additiveList[i]);
  if (SummaryOption in [soFull, soData]) then
    ComposeString(xml, 'preparation', value.preparationElement);
end;

function TFHIRXmlParser.ParseSpecimenDefinitionTypeTestedContainerAdditive(element : TMXmlElement; path : string) : TFhirSpecimenDefinitionTypeTestedContainerAdditive;
var
  child : TMXmlElement;
begin
  result := TFhirSpecimenDefinitionTypeTestedContainerAdditive.Create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseSpecimenDefinitionTypeTestedContainerAdditiveChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseSpecimenDefinitionTypeTestedContainerAdditiveChild(value : TFhirSpecimenDefinitionTypeTestedContainerAdditive; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'additiveCodeableConcept') then
        value.additive := ParseCodeableConcept(child, path+'/additiveCodeableConcept')
      else if (child.localName = 'additiveReference') then
        value.additive := ParseReference(child, path+'/additiveReference')
      else if Not ParseBackboneElementChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeSpecimenDefinitionTypeTestedContainerAdditive(xml : TXmlBuilder; name : String; value : TFhirSpecimenDefinitionTypeTestedContainerAdditive);
begin
  if (value = nil) then
    exit;
  composeElementAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeSpecimenDefinitionTypeTestedContainerAdditiveChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeSpecimenDefinitionTypeTestedContainerAdditiveChildren(xml : TXmlBuilder; value : TFhirSpecimenDefinitionTypeTestedContainerAdditive);
begin
  composeBackboneElementChildren(xml, value);
  if (value.additive is TFhirCodeableConcept) {6} then
    ComposeCodeableConcept(xml, 'additiveCodeableConcept', TFhirCodeableConcept(value.additive))
  else if (value.additive is TFhirReference) {2} then
    ComposeReference(xml, 'additiveReference', TFhirReference(value.additive));
end;

function TFHIRXmlParser.ParseSpecimenDefinitionTypeTestedHandling(element : TMXmlElement; path : string) : TFhirSpecimenDefinitionTypeTestedHandling;
var
  child : TMXmlElement;
begin
  result := TFhirSpecimenDefinitionTypeTestedHandling.Create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseSpecimenDefinitionTypeTestedHandlingChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseSpecimenDefinitionTypeTestedHandlingChild(value : TFhirSpecimenDefinitionTypeTestedHandling; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'temperatureQualifier') then
        value.temperatureQualifier := ParseCodeableConcept(child, path+'/temperatureQualifier')
      else if (child.localName = 'temperatureRange') then
        value.temperatureRange := ParseRange(child, path+'/temperatureRange')
      else if (child.localName = 'maxDuration') then
        value.maxDuration := ParseDuration(child, path+'/maxDuration')
      else if (child.localName = 'instruction') then
        value.instructionElement := ParseString(child, path+'/instruction')
      else if Not ParseBackboneElementChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeSpecimenDefinitionTypeTestedHandling(xml : TXmlBuilder; name : String; value : TFhirSpecimenDefinitionTypeTestedHandling);
begin
  if (value = nil) then
    exit;
  composeElementAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeSpecimenDefinitionTypeTestedHandlingChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeSpecimenDefinitionTypeTestedHandlingChildren(xml : TXmlBuilder; value : TFhirSpecimenDefinitionTypeTestedHandling);
begin
  composeBackboneElementChildren(xml, value);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(xml, 'temperatureQualifier', value.temperatureQualifier);
  if (SummaryOption in [soFull, soData]) then
    ComposeRange(xml, 'temperatureRange', value.temperatureRange);
  if (SummaryOption in [soFull, soData]) then
    ComposeDuration(xml, 'maxDuration', value.maxDuration);
  if (SummaryOption in [soFull, soData]) then
    ComposeString(xml, 'instruction', value.instructionElement);
end;

function TFHIRXmlParser.ParseSpecimenDefinition(element : TMXmlElement; path : string) : TFhirSpecimenDefinition;
var
  child : TMXmlElement;
begin
  result := TFhirSpecimenDefinition.Create;
  try
    parseMetadataResourceAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseSpecimenDefinitionChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseSpecimenDefinitionChild(value : TFhirSpecimenDefinition; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'url') then
        value.urlElement := ParseUri(child, path+'/url')
      else if (child.localName = 'identifier') then
        value.identifier := ParseIdentifier(child, path+'/identifier')
      else if (child.localName = 'version') then
        value.versionElement := ParseString(child, path+'/version')
      else if (child.localName = 'title') then
        value.titleElement := ParseString(child, path+'/title')
      else if (child.localName = 'derivedFromCanonical') then
        value.derivedFromCanonicalList.Add(ParseCanonical(child, path+'/derivedFromCanonical'))
      else if (child.localName = 'derivedFromUri') then
        value.derivedFromUriList.Add(ParseUri(child, path+'/derivedFromUri'))
      else if (child.localName = 'status') then
        value.statusElement := ParseEnum(CODES_TFhirPublicationStatusEnum, SYSTEMS_TFhirPublicationStatusEnum, child, path+'/status')
      else if (child.localName = 'experimental') then
        value.experimentalElement := ParseBoolean(child, path+'/experimental')
      else if (child.localName = 'subjectCodeableConcept') then
        value.subject := ParseCodeableConcept(child, path+'/subjectCodeableConcept')
      else if (child.localName = 'subjectReference') then
        value.subject := ParseReference(child, path+'/subjectReference')
      else if (child.localName = 'date') then
        value.dateElement := ParseDateTime(child, path+'/date')
      else if (child.localName = 'publisher') then
        value.publisher := ParseString(child, path+'/publisher')
      else if (child.localName = 'contact') then
        value.contactList.Add(ParseContactDetail(child, path+'/contact'))
      else if (child.localName = 'description') then
        value.descriptionElement := ParseMarkdown(child, path+'/description')
      else if (child.localName = 'useContext') then
        value.useContextList.Add(ParseUsageContext(child, path+'/useContext'))
      else if (child.localName = 'jurisdiction') then
        value.jurisdictionList.Add(ParseCodeableConcept(child, path+'/jurisdiction'))
      else if (child.localName = 'purpose') then
        value.purposeElement := ParseMarkdown(child, path+'/purpose')
      else if (child.localName = 'copyright') then
        value.copyrightElement := ParseMarkdown(child, path+'/copyright')
      else if (child.localName = 'approvalDate') then
        value.approvalDateElement := ParseDate(child, path+'/approvalDate')
      else if (child.localName = 'lastReviewDate') then
        value.lastReviewDateElement := ParseDate(child, path+'/lastReviewDate')
      else if (child.localName = 'effectivePeriod') then
        value.effectivePeriod := ParsePeriod(child, path+'/effectivePeriod')
      else if (child.localName = 'typeCollected') then
        value.typeCollected := ParseCodeableConcept(child, path+'/typeCollected')
      else if (child.localName = 'patientPreparation') then
        value.patientPreparationList.Add(ParseCodeableConcept(child, path+'/patientPreparation'))
      else if (child.localName = 'timeAspect') then
        value.timeAspectElement := ParseString(child, path+'/timeAspect')
      else if (child.localName = 'collection') then
        value.collectionList.Add(ParseCodeableConcept(child, path+'/collection'))
      else if (child.localName = 'typeTested') then
        value.typeTestedList.Add(ParseSpecimenDefinitionTypeTested(child, path+'/typeTested'))
      else if Not ParseMetadataResourceChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeSpecimenDefinition(xml : TXmlBuilder; name : String; value : TFhirSpecimenDefinition);
begin
  if (value = nil) then
    exit;
  composeMetadataResourceAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeSpecimenDefinitionChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeSpecimenDefinitionChildren(xml : TXmlBuilder; value : TFhirSpecimenDefinition);
var
  i : integer;
begin
  composeMetadataResourceChildren(xml, value);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeUri(xml, 'url', value.urlElement);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeIdentifier(xml, 'identifier', value.identifier);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(xml, 'version', value.versionElement);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(xml, 'title', value.titleElement);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.derivedFromCanonicalList.Count - 1 do
      ComposeCanonical(xml, 'derivedFromCanonical', value.derivedFromCanonicalList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.derivedFromUriList.Count - 1 do
      ComposeUri(xml, 'derivedFromUri', value.derivedFromUriList[i]);
  ComposeEnum(xml, 'status', value.statusElement, CODES_TFhirPublicationStatusEnum);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeBoolean(xml, 'experimental', value.experimentalElement);
  if (SummaryOption in [soFull, soSummary, soData]) and (value.subject is TFhirCodeableConcept) {6} then
    ComposeCodeableConcept(xml, 'subjectCodeableConcept', TFhirCodeableConcept(value.subject))
  else if (SummaryOption in [soFull, soSummary, soData]) and (value.subject is TFhirReference) {2} then
    ComposeReference(xml, 'subjectReference', TFhirReference(value.subject));
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDateTime(xml, 'date', value.dateElement);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(xml, 'publisher', value.publisher);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.contactList.Count - 1 do
      ComposeContactDetail(xml, 'contact', value.contactList[i]);
  if (SummaryOption in [soFull, soData]) then
    ComposeMarkdown(xml, 'description', value.descriptionElement);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.useContextList.Count - 1 do
      ComposeUsageContext(xml, 'useContext', value.useContextList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.jurisdictionList.Count - 1 do
      ComposeCodeableConcept(xml, 'jurisdiction', value.jurisdictionList[i]);
  if (SummaryOption in [soFull, soData]) then
    ComposeMarkdown(xml, 'purpose', value.purposeElement);
  if (SummaryOption in [soFull, soData]) then
    ComposeMarkdown(xml, 'copyright', value.copyrightElement);
  if (SummaryOption in [soFull, soData]) then
    ComposeDate(xml, 'approvalDate', value.approvalDateElement);
  if (SummaryOption in [soFull, soData]) then
    ComposeDate(xml, 'lastReviewDate', value.lastReviewDateElement);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposePeriod(xml, 'effectivePeriod', value.effectivePeriod);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(xml, 'typeCollected', value.typeCollected);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.patientPreparationList.Count - 1 do
      ComposeCodeableConcept(xml, 'patientPreparation', value.patientPreparationList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(xml, 'timeAspect', value.timeAspectElement);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.collectionList.Count - 1 do
      ComposeCodeableConcept(xml, 'collection', value.collectionList[i]);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.typeTestedList.Count - 1 do
      ComposeSpecimenDefinitionTypeTested(xml, 'typeTested', value.typeTestedList[i]);
end;

{$ENDIF FHIR_SPECIMENDEFINITION}
{$IFDEF FHIR_STRUCTUREDEFINITION}
function TFHIRXmlParser.ParseStructureDefinitionMapping(element : TMXmlElement; path : string) : TFhirStructureDefinitionMapping;
var
  child : TMXmlElement;
begin
  result := TFhirStructureDefinitionMapping.Create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseStructureDefinitionMappingChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseStructureDefinitionMappingChild(value : TFhirStructureDefinitionMapping; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'identity') then
        value.identityElement := ParseId(child, path+'/identity')
      else if (child.localName = 'uri') then
        value.uriElement := ParseUri(child, path+'/uri')
      else if (child.localName = 'name') then
        value.nameElement := ParseString(child, path+'/name')
      else if (child.localName = 'comment') then
        value.commentElement := ParseString(child, path+'/comment')
      else if Not ParseBackboneElementChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeStructureDefinitionMapping(xml : TXmlBuilder; name : String; value : TFhirStructureDefinitionMapping);
begin
  if (value = nil) then
    exit;
  composeElementAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeStructureDefinitionMappingChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeStructureDefinitionMappingChildren(xml : TXmlBuilder; value : TFhirStructureDefinitionMapping);
begin
  composeBackboneElementChildren(xml, value);
  ComposeId(xml, 'identity', value.identityElement);
  if (SummaryOption in [soFull, soData]) then
    ComposeUri(xml, 'uri', value.uriElement);
  if (SummaryOption in [soFull, soData]) then
    ComposeString(xml, 'name', value.nameElement);
  if (SummaryOption in [soFull, soData]) then
    ComposeString(xml, 'comment', value.commentElement);
end;

function TFHIRXmlParser.ParseStructureDefinitionContext(element : TMXmlElement; path : string) : TFhirStructureDefinitionContext;
var
  child : TMXmlElement;
begin
  result := TFhirStructureDefinitionContext.Create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseStructureDefinitionContextChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseStructureDefinitionContextChild(value : TFhirStructureDefinitionContext; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'type') then
        value.type_Element := ParseEnum(CODES_TFhirExtensionContextTypeEnum, SYSTEMS_TFhirExtensionContextTypeEnum, child, path+'/type')
      else if (child.localName = 'expression') then
        value.expressionElement := ParseString(child, path+'/expression')
      else if Not ParseBackboneElementChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeStructureDefinitionContext(xml : TXmlBuilder; name : String; value : TFhirStructureDefinitionContext);
begin
  if (value = nil) then
    exit;
  composeElementAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeStructureDefinitionContextChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeStructureDefinitionContextChildren(xml : TXmlBuilder; value : TFhirStructureDefinitionContext);
begin
  composeBackboneElementChildren(xml, value);
  ComposeEnum(xml, 'type', value.type_Element, CODES_TFhirExtensionContextTypeEnum);
  ComposeString(xml, 'expression', value.expressionElement);
end;

function TFHIRXmlParser.ParseStructureDefinitionSnapshot(element : TMXmlElement; path : string) : TFhirStructureDefinitionSnapshot;
var
  child : TMXmlElement;
begin
  result := TFhirStructureDefinitionSnapshot.Create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseStructureDefinitionSnapshotChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseStructureDefinitionSnapshotChild(value : TFhirStructureDefinitionSnapshot; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'element') then
        value.elementList.Add(ParseElementDefinition(child, path+'/element'))
      else if Not ParseBackboneElementChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeStructureDefinitionSnapshot(xml : TXmlBuilder; name : String; value : TFhirStructureDefinitionSnapshot);
begin
  if (value = nil) then
    exit;
  composeElementAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeStructureDefinitionSnapshotChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeStructureDefinitionSnapshotChildren(xml : TXmlBuilder; value : TFhirStructureDefinitionSnapshot);
var
  i : integer;
begin
  composeBackboneElementChildren(xml, value);
  for i := 0 to value.elementList.Count - 1 do
      ComposeElementDefinition(xml, 'element', value.elementList[i]);
end;

function TFHIRXmlParser.ParseStructureDefinitionDifferential(element : TMXmlElement; path : string) : TFhirStructureDefinitionDifferential;
var
  child : TMXmlElement;
begin
  result := TFhirStructureDefinitionDifferential.Create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseStructureDefinitionDifferentialChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseStructureDefinitionDifferentialChild(value : TFhirStructureDefinitionDifferential; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'element') then
        value.elementList.Add(ParseElementDefinition(child, path+'/element'))
      else if Not ParseBackboneElementChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeStructureDefinitionDifferential(xml : TXmlBuilder; name : String; value : TFhirStructureDefinitionDifferential);
begin
  if (value = nil) then
    exit;
  composeElementAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeStructureDefinitionDifferentialChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeStructureDefinitionDifferentialChildren(xml : TXmlBuilder; value : TFhirStructureDefinitionDifferential);
var
  i : integer;
begin
  composeBackboneElementChildren(xml, value);
  for i := 0 to value.elementList.Count - 1 do
      ComposeElementDefinition(xml, 'element', value.elementList[i]);
end;

function TFHIRXmlParser.ParseStructureDefinition(element : TMXmlElement; path : string) : TFhirStructureDefinition;
var
  child : TMXmlElement;
begin
  result := TFhirStructureDefinition.Create;
  try
    parseCanonicalResourceAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseStructureDefinitionChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseStructureDefinitionChild(value : TFhirStructureDefinition; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'url') then
        value.urlElement := ParseUri(child, path+'/url')
      else if (child.localName = 'identifier') then
        value.identifierList.Add(ParseIdentifier(child, path+'/identifier'))
      else if (child.localName = 'version') then
        value.versionElement := ParseString(child, path+'/version')
      else if (child.localName = 'versionAlgorithmCoding') then
        value.versionAlgorithm := ParseCoding(child, path+'/versionAlgorithmCoding')
      else if (child.localName = 'versionAlgorithmString') then
        value.versionAlgorithm := ParseString(child, path+'/versionAlgorithmString')
      else if (child.localName = 'name') then
        value.nameElement := ParseString(child, path+'/name')
      else if (child.localName = 'title') then
        value.titleElement := ParseString(child, path+'/title')
      else if (child.localName = 'status') then
        value.statusElement := ParseEnum(CODES_TFhirPublicationStatusEnum, SYSTEMS_TFhirPublicationStatusEnum, child, path+'/status')
      else if (child.localName = 'experimental') then
        value.experimentalElement := ParseBoolean(child, path+'/experimental')
      else if (child.localName = 'date') then
        value.dateElement := ParseDateTime(child, path+'/date')
      else if (child.localName = 'publisher') then
        value.publisherElement := ParseString(child, path+'/publisher')
      else if (child.localName = 'contact') then
        value.contactList.Add(ParseContactDetail(child, path+'/contact'))
      else if (child.localName = 'description') then
        value.descriptionElement := ParseMarkdown(child, path+'/description')
      else if (child.localName = 'useContext') then
        value.useContextList.Add(ParseUsageContext(child, path+'/useContext'))
      else if (child.localName = 'jurisdiction') then
        value.jurisdictionList.Add(ParseCodeableConcept(child, path+'/jurisdiction'))
      else if (child.localName = 'purpose') then
        value.purposeElement := ParseMarkdown(child, path+'/purpose')
      else if (child.localName = 'copyright') then
        value.copyrightElement := ParseMarkdown(child, path+'/copyright')
      else if (child.localName = 'copyrightLabel') then
        value.copyrightLabelElement := ParseString(child, path+'/copyrightLabel')
      else if (child.localName = 'keyword') then
        value.keywordList.Add(ParseCoding(child, path+'/keyword'))
      else if (child.localName = 'fhirVersion') then
        value.fhirVersionElement := ParseEnum(CODES_TFhirFHIRVersionEnum, SYSTEMS_TFhirFHIRVersionEnum, child, path+'/fhirVersion')
      else if (child.localName = 'mapping') then
        value.mappingList.Add(ParseStructureDefinitionMapping(child, path+'/mapping'))
      else if (child.localName = 'kind') then
        value.kindElement := ParseEnum(CODES_TFhirStructureDefinitionKindEnum, SYSTEMS_TFhirStructureDefinitionKindEnum, child, path+'/kind')
      else if (child.localName = 'abstract') then
        value.abstractElement := ParseBoolean(child, path+'/abstract')
      else if (child.localName = 'context') then
        value.contextList.Add(ParseStructureDefinitionContext(child, path+'/context'))
      else if (child.localName = 'contextInvariant') then
        value.contextInvariantList.Add(ParseString(child, path+'/contextInvariant'))
      else if (child.localName = 'type') then
        value.type_Element := ParseUri(child, path+'/type')
      else if (child.localName = 'baseDefinition') then
        value.baseDefinitionElement := ParseCanonical(child, path+'/baseDefinition')
      else if (child.localName = 'derivation') then
        value.derivationElement := ParseEnum(CODES_TFhirTypeDerivationRuleEnum, SYSTEMS_TFhirTypeDerivationRuleEnum, child, path+'/derivation')
      else if (child.localName = 'snapshot') then
        value.snapshot := ParseStructureDefinitionSnapshot(child, path+'/snapshot')
      else if (child.localName = 'differential') then
        value.differential := ParseStructureDefinitionDifferential(child, path+'/differential')
      else if Not ParseCanonicalResourceChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeStructureDefinition(xml : TXmlBuilder; name : String; value : TFhirStructureDefinition);
begin
  if (value = nil) then
    exit;
  composeCanonicalResourceAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeStructureDefinitionChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeStructureDefinitionChildren(xml : TXmlBuilder; value : TFhirStructureDefinition);
var
  i : integer;
begin
  composeCanonicalResourceChildren(xml, value);
  ComposeUri(xml, 'url', value.urlElement);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.identifierList.Count - 1 do
      ComposeIdentifier(xml, 'identifier', value.identifierList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(xml, 'version', value.versionElement);
  if (SummaryOption in [soFull, soSummary, soData]) and (value.versionAlgorithm is TFhirCoding) {6} then
    ComposeCoding(xml, 'versionAlgorithmCoding', TFhirCoding(value.versionAlgorithm))
  else if (SummaryOption in [soFull, soSummary, soData]) and (value.versionAlgorithm is TFhirString) {6} then
    ComposeString(xml, 'versionAlgorithmString', TFhirString(value.versionAlgorithm));
  ComposeString(xml, 'name', value.nameElement);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(xml, 'title', value.titleElement);
  ComposeEnum(xml, 'status', value.statusElement, CODES_TFhirPublicationStatusEnum);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeBoolean(xml, 'experimental', value.experimentalElement);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDateTime(xml, 'date', value.dateElement);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(xml, 'publisher', value.publisherElement);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.contactList.Count - 1 do
      ComposeContactDetail(xml, 'contact', value.contactList[i]);
  if (SummaryOption in [soFull, soData]) then
    ComposeMarkdown(xml, 'description', value.descriptionElement);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.useContextList.Count - 1 do
      ComposeUsageContext(xml, 'useContext', value.useContextList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.jurisdictionList.Count - 1 do
      ComposeCodeableConcept(xml, 'jurisdiction', value.jurisdictionList[i]);
  if (SummaryOption in [soFull, soData]) then
    ComposeMarkdown(xml, 'purpose', value.purposeElement);
  if (SummaryOption in [soFull, soData]) then
    ComposeMarkdown(xml, 'copyright', value.copyrightElement);
  if (SummaryOption in [soFull, soData]) then
    ComposeString(xml, 'copyrightLabel', value.copyrightLabelElement);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.keywordList.Count - 1 do
      ComposeCoding(xml, 'keyword', value.keywordList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeEnum(xml, 'fhirVersion', value.fhirVersionElement, CODES_TFhirFHIRVersionEnum);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.mappingList.Count - 1 do
      ComposeStructureDefinitionMapping(xml, 'mapping', value.mappingList[i]);
  ComposeEnum(xml, 'kind', value.kindElement, CODES_TFhirStructureDefinitionKindEnum);
  ComposeBoolean(xml, 'abstract', value.abstractElement);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.contextList.Count - 1 do
      ComposeStructureDefinitionContext(xml, 'context', value.contextList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.contextInvariantList.Count - 1 do
      ComposeString(xml, 'contextInvariant', value.contextInvariantList[i]);
  ComposeUri(xml, 'type', value.type_Element);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCanonical(xml, 'baseDefinition', value.baseDefinitionElement);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeEnum(xml, 'derivation', value.derivationElement, CODES_TFhirTypeDerivationRuleEnum);
  if (SummaryOption in [soFull, soData]) then
    ComposeStructureDefinitionSnapshot(xml, 'snapshot', value.snapshot);
  if (SummaryOption in [soFull, soData]) then
    ComposeStructureDefinitionDifferential(xml, 'differential', value.differential);
end;

{$ENDIF FHIR_STRUCTUREDEFINITION}
{$IFDEF FHIR_STRUCTUREMAP}
function TFHIRXmlParser.ParseStructureMapStructure(element : TMXmlElement; path : string) : TFhirStructureMapStructure;
var
  child : TMXmlElement;
begin
  result := TFhirStructureMapStructure.Create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseStructureMapStructureChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseStructureMapStructureChild(value : TFhirStructureMapStructure; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'url') then
        value.urlElement := ParseCanonical(child, path+'/url')
      else if (child.localName = 'mode') then
        value.modeElement := ParseEnum(CODES_TFhirStructureMapModelModeEnum, SYSTEMS_TFhirStructureMapModelModeEnum, child, path+'/mode')
      else if (child.localName = 'alias') then
        value.aliasElement := ParseString(child, path+'/alias')
      else if (child.localName = 'documentation') then
        value.documentationElement := ParseString(child, path+'/documentation')
      else if Not ParseBackboneElementChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeStructureMapStructure(xml : TXmlBuilder; name : String; value : TFhirStructureMapStructure);
begin
  if (value = nil) then
    exit;
  composeElementAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeStructureMapStructureChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeStructureMapStructureChildren(xml : TXmlBuilder; value : TFhirStructureMapStructure);
begin
  composeBackboneElementChildren(xml, value);
  ComposeCanonical(xml, 'url', value.urlElement);
  ComposeEnum(xml, 'mode', value.modeElement, CODES_TFhirStructureMapModelModeEnum);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(xml, 'alias', value.aliasElement);
  if (SummaryOption in [soFull, soData]) then
    ComposeString(xml, 'documentation', value.documentationElement);
end;

function TFHIRXmlParser.ParseStructureMapGroup(element : TMXmlElement; path : string) : TFhirStructureMapGroup;
var
  child : TMXmlElement;
begin
  result := TFhirStructureMapGroup.Create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseStructureMapGroupChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseStructureMapGroupChild(value : TFhirStructureMapGroup; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'name') then
        value.nameElement := ParseId(child, path+'/name')
      else if (child.localName = 'extends') then
        value.extendsElement := ParseId(child, path+'/extends')
      else if (child.localName = 'typeMode') then
        value.typeModeElement := ParseEnum(CODES_TFhirStructureMapGroupTypeModeEnum, SYSTEMS_TFhirStructureMapGroupTypeModeEnum, child, path+'/typeMode')
      else if (child.localName = 'documentation') then
        value.documentationElement := ParseString(child, path+'/documentation')
      else if (child.localName = 'input') then
        value.inputList.Add(ParseStructureMapGroupInput(child, path+'/input'))
      else if (child.localName = 'rule') then
        value.ruleList.Add(ParseStructureMapGroupRule(child, path+'/rule'))
      else if Not ParseBackboneElementChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeStructureMapGroup(xml : TXmlBuilder; name : String; value : TFhirStructureMapGroup);
begin
  if (value = nil) then
    exit;
  composeElementAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeStructureMapGroupChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeStructureMapGroupChildren(xml : TXmlBuilder; value : TFhirStructureMapGroup);
var
  i : integer;
begin
  composeBackboneElementChildren(xml, value);
  ComposeId(xml, 'name', value.nameElement);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeId(xml, 'extends', value.extendsElement);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeEnum(xml, 'typeMode', value.typeModeElement, CODES_TFhirStructureMapGroupTypeModeEnum);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(xml, 'documentation', value.documentationElement);
  for i := 0 to value.inputList.Count - 1 do
      ComposeStructureMapGroupInput(xml, 'input', value.inputList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.ruleList.Count - 1 do
      ComposeStructureMapGroupRule(xml, 'rule', value.ruleList[i]);
end;

function TFHIRXmlParser.ParseStructureMapGroupInput(element : TMXmlElement; path : string) : TFhirStructureMapGroupInput;
var
  child : TMXmlElement;
begin
  result := TFhirStructureMapGroupInput.Create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseStructureMapGroupInputChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseStructureMapGroupInputChild(value : TFhirStructureMapGroupInput; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'name') then
        value.nameElement := ParseId(child, path+'/name')
      else if (child.localName = 'type') then
        value.type_Element := ParseString(child, path+'/type')
      else if (child.localName = 'mode') then
        value.modeElement := ParseEnum(CODES_TFhirStructureMapInputModeEnum, SYSTEMS_TFhirStructureMapInputModeEnum, child, path+'/mode')
      else if (child.localName = 'documentation') then
        value.documentationElement := ParseString(child, path+'/documentation')
      else if Not ParseBackboneElementChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeStructureMapGroupInput(xml : TXmlBuilder; name : String; value : TFhirStructureMapGroupInput);
begin
  if (value = nil) then
    exit;
  composeElementAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeStructureMapGroupInputChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeStructureMapGroupInputChildren(xml : TXmlBuilder; value : TFhirStructureMapGroupInput);
begin
  composeBackboneElementChildren(xml, value);
  ComposeId(xml, 'name', value.nameElement);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(xml, 'type', value.type_Element);
  ComposeEnum(xml, 'mode', value.modeElement, CODES_TFhirStructureMapInputModeEnum);
  if (SummaryOption in [soFull, soData]) then
    ComposeString(xml, 'documentation', value.documentationElement);
end;

function TFHIRXmlParser.ParseStructureMapGroupRule(element : TMXmlElement; path : string) : TFhirStructureMapGroupRule;
var
  child : TMXmlElement;
begin
  result := TFhirStructureMapGroupRule.Create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseStructureMapGroupRuleChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseStructureMapGroupRuleChild(value : TFhirStructureMapGroupRule; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'name') then
        value.nameElement := ParseId(child, path+'/name')
      else if (child.localName = 'source') then
        value.sourceList.Add(ParseStructureMapGroupRuleSource(child, path+'/source'))
      else if (child.localName = 'target') then
        value.targetList.Add(ParseStructureMapGroupRuleTarget(child, path+'/target'))
      else if (child.localName = 'rule') then
        value.ruleList.Add(ParseStructureMapGroupRule(child, path+'/rule'))
      else if (child.localName = 'dependent') then
        value.dependentList.Add(ParseStructureMapGroupRuleDependent(child, path+'/dependent'))
      else if (child.localName = 'documentation') then
        value.documentationElement := ParseString(child, path+'/documentation')
      else if Not ParseBackboneElementChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeStructureMapGroupRule(xml : TXmlBuilder; name : String; value : TFhirStructureMapGroupRule);
begin
  if (value = nil) then
    exit;
  composeElementAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeStructureMapGroupRuleChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeStructureMapGroupRuleChildren(xml : TXmlBuilder; value : TFhirStructureMapGroupRule);
var
  i : integer;
begin
  composeBackboneElementChildren(xml, value);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeId(xml, 'name', value.nameElement);
  for i := 0 to value.sourceList.Count - 1 do
      ComposeStructureMapGroupRuleSource(xml, 'source', value.sourceList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.targetList.Count - 1 do
      ComposeStructureMapGroupRuleTarget(xml, 'target', value.targetList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.ruleList.Count - 1 do
      ComposeStructureMapGroupRule(xml, 'rule', value.ruleList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.dependentList.Count - 1 do
      ComposeStructureMapGroupRuleDependent(xml, 'dependent', value.dependentList[i]);
  if (SummaryOption in [soFull, soData]) then
    ComposeString(xml, 'documentation', value.documentationElement);
end;

function TFHIRXmlParser.ParseStructureMapGroupRuleSource(element : TMXmlElement; path : string) : TFhirStructureMapGroupRuleSource;
var
  child : TMXmlElement;
begin
  result := TFhirStructureMapGroupRuleSource.Create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseStructureMapGroupRuleSourceChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseStructureMapGroupRuleSourceChild(value : TFhirStructureMapGroupRuleSource; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'context') then
        value.contextElement := ParseId(child, path+'/context')
      else if (child.localName = 'min') then
        value.minElement := ParseInteger(child, path+'/min')
      else if (child.localName = 'max') then
        value.maxElement := ParseString(child, path+'/max')
      else if (child.localName = 'type') then
        value.type_Element := ParseString(child, path+'/type')
      else if (child.localName = 'defaultValue') then
        value.defaultValueElement := ParseString(child, path+'/defaultValue')
      else if (child.localName = 'element') then
        value.elementElement := ParseString(child, path+'/element')
      else if (child.localName = 'listMode') then
        value.listModeElement := ParseEnum(CODES_TFhirStructureMapSourceListModeEnum, SYSTEMS_TFhirStructureMapSourceListModeEnum, child, path+'/listMode')
      else if (child.localName = 'variable') then
        value.variableElement := ParseId(child, path+'/variable')
      else if (child.localName = 'condition') then
        value.conditionElement := ParseString(child, path+'/condition')
      else if (child.localName = 'check') then
        value.checkElement := ParseString(child, path+'/check')
      else if (child.localName = 'logMessage') then
        value.logMessageElement := ParseString(child, path+'/logMessage')
      else if Not ParseBackboneElementChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeStructureMapGroupRuleSource(xml : TXmlBuilder; name : String; value : TFhirStructureMapGroupRuleSource);
begin
  if (value = nil) then
    exit;
  composeElementAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeStructureMapGroupRuleSourceChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeStructureMapGroupRuleSourceChildren(xml : TXmlBuilder; value : TFhirStructureMapGroupRuleSource);
begin
  composeBackboneElementChildren(xml, value);
  ComposeId(xml, 'context', value.contextElement);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeInteger(xml, 'min', value.minElement);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(xml, 'max', value.maxElement);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(xml, 'type', value.type_Element);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(xml, 'defaultValue', value.defaultValueElement);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(xml, 'element', value.elementElement);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeEnum(xml, 'listMode', value.listModeElement, CODES_TFhirStructureMapSourceListModeEnum);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeId(xml, 'variable', value.variableElement);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(xml, 'condition', value.conditionElement);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(xml, 'check', value.checkElement);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(xml, 'logMessage', value.logMessageElement);
end;

function TFHIRXmlParser.ParseStructureMapGroupRuleTarget(element : TMXmlElement; path : string) : TFhirStructureMapGroupRuleTarget;
var
  child : TMXmlElement;
begin
  result := TFhirStructureMapGroupRuleTarget.Create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseStructureMapGroupRuleTargetChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseStructureMapGroupRuleTargetChild(value : TFhirStructureMapGroupRuleTarget; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'context') then
        value.contextElement := ParseId(child, path+'/context')
      else if (child.localName = 'element') then
        value.elementElement := ParseString(child, path+'/element')
      else if (child.localName = 'variable') then
        value.variableElement := ParseId(child, path+'/variable')
      else if (child.localName = 'listMode') then
        value.listModeList.Add(ParseEnum(CODES_TFhirStructureMapTargetListModeEnum, SYSTEMS_TFhirStructureMapTargetListModeEnum, child, path+'/listMode')){y.1}
      else if (child.localName = 'listRuleId') then
        value.listRuleIdElement := ParseId(child, path+'/listRuleId')
      else if (child.localName = 'transform') then
        value.transformElement := ParseEnum(CODES_TFhirStructureMapTransformEnum, SYSTEMS_TFhirStructureMapTransformEnum, child, path+'/transform')
      else if (child.localName = 'parameter') then
        value.parameterList.Add(ParseStructureMapGroupRuleTargetParameter(child, path+'/parameter'))
      else if Not ParseBackboneElementChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeStructureMapGroupRuleTarget(xml : TXmlBuilder; name : String; value : TFhirStructureMapGroupRuleTarget);
begin
  if (value = nil) then
    exit;
  composeElementAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeStructureMapGroupRuleTargetChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeStructureMapGroupRuleTargetChildren(xml : TXmlBuilder; value : TFhirStructureMapGroupRuleTarget);
var
  i : integer;
begin
  composeBackboneElementChildren(xml, value);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeId(xml, 'context', value.contextElement);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(xml, 'element', value.elementElement);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeId(xml, 'variable', value.variableElement);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.listModeList.Count - 1 do
      ComposeEnum(xml, 'listMode', value.listModeList[i], CODES_TFhirStructureMapTargetListModeEnum);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeId(xml, 'listRuleId', value.listRuleIdElement);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeEnum(xml, 'transform', value.transformElement, CODES_TFhirStructureMapTransformEnum);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.parameterList.Count - 1 do
      ComposeStructureMapGroupRuleTargetParameter(xml, 'parameter', value.parameterList[i]);
end;

function TFHIRXmlParser.ParseStructureMapGroupRuleTargetParameter(element : TMXmlElement; path : string) : TFhirStructureMapGroupRuleTargetParameter;
var
  child : TMXmlElement;
begin
  result := TFhirStructureMapGroupRuleTargetParameter.Create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseStructureMapGroupRuleTargetParameterChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseStructureMapGroupRuleTargetParameterChild(value : TFhirStructureMapGroupRuleTargetParameter; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'valueId') then
        value.value := ParseId(child, path+'/valueId')
      else if (child.localName = 'valueString') then
        value.value := ParseString(child, path+'/valueString')
      else if (child.localName = 'valueBoolean') then
        value.value := ParseBoolean(child, path+'/valueBoolean')
      else if (child.localName = 'valueInteger') then
        value.value := ParseInteger(child, path+'/valueInteger')
      else if (child.localName = 'valueDecimal') then
        value.value := ParseDecimal(child, path+'/valueDecimal')
      else if (child.localName = 'valueDate') then
        value.value := ParseDate(child, path+'/valueDate')
      else if (child.localName = 'valueTime') then
        value.value := ParseTime(child, path+'/valueTime')
      else if (child.localName = 'valueDateTime') then
        value.value := ParseDateTime(child, path+'/valueDateTime')
      else if Not ParseBackboneElementChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeStructureMapGroupRuleTargetParameter(xml : TXmlBuilder; name : String; value : TFhirStructureMapGroupRuleTargetParameter);
begin
  if (value = nil) then
    exit;
  composeElementAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeStructureMapGroupRuleTargetParameterChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeStructureMapGroupRuleTargetParameterChildren(xml : TXmlBuilder; value : TFhirStructureMapGroupRuleTargetParameter);
begin
  composeBackboneElementChildren(xml, value);
  if (value.value is TFhirId) {6} then
    ComposeId(xml, 'valueId', TFhirId(value.value))
  else if (value.value is TFhirString) {6} then
    ComposeString(xml, 'valueString', TFhirString(value.value))
  else if (value.value is TFhirBoolean) {6} then
    ComposeBoolean(xml, 'valueBoolean', TFhirBoolean(value.value))
  else if (value.value is TFhirInteger) {6} then
    ComposeInteger(xml, 'valueInteger', TFhirInteger(value.value))
  else if (value.value is TFhirDecimal) {6} then
    ComposeDecimal(xml, 'valueDecimal', TFhirDecimal(value.value))
  else if (value.value is TFhirDate) {6} then
    ComposeDate(xml, 'valueDate', TFhirDate(value.value))
  else if (value.value is TFhirTime) {6} then
    ComposeTime(xml, 'valueTime', TFhirTime(value.value))
  else if (value.value is TFhirDateTime) {6} then
    ComposeDateTime(xml, 'valueDateTime', TFhirDateTime(value.value));
end;

function TFHIRXmlParser.ParseStructureMapGroupRuleDependent(element : TMXmlElement; path : string) : TFhirStructureMapGroupRuleDependent;
var
  child : TMXmlElement;
begin
  result := TFhirStructureMapGroupRuleDependent.Create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseStructureMapGroupRuleDependentChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseStructureMapGroupRuleDependentChild(value : TFhirStructureMapGroupRuleDependent; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'name') then
        value.nameElement := ParseId(child, path+'/name')
      else if (child.localName = 'parameter') then
        value.parameterList.Add(ParseStructureMapGroupRuleTargetParameter(child, path+'/parameter'))
      else if Not ParseBackboneElementChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeStructureMapGroupRuleDependent(xml : TXmlBuilder; name : String; value : TFhirStructureMapGroupRuleDependent);
begin
  if (value = nil) then
    exit;
  composeElementAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeStructureMapGroupRuleDependentChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeStructureMapGroupRuleDependentChildren(xml : TXmlBuilder; value : TFhirStructureMapGroupRuleDependent);
var
  i : integer;
begin
  composeBackboneElementChildren(xml, value);
  ComposeId(xml, 'name', value.nameElement);
  for i := 0 to value.parameterList.Count - 1 do
      ComposeStructureMapGroupRuleTargetParameter(xml, 'parameter', value.parameterList[i]);
end;

function TFHIRXmlParser.ParseStructureMap(element : TMXmlElement; path : string) : TFhirStructureMap;
var
  child : TMXmlElement;
begin
  result := TFhirStructureMap.Create;
  try
    parseCanonicalResourceAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseStructureMapChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseStructureMapChild(value : TFhirStructureMap; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'url') then
        value.urlElement := ParseUri(child, path+'/url')
      else if (child.localName = 'identifier') then
        value.identifierList.Add(ParseIdentifier(child, path+'/identifier'))
      else if (child.localName = 'version') then
        value.versionElement := ParseString(child, path+'/version')
      else if (child.localName = 'versionAlgorithmCoding') then
        value.versionAlgorithm := ParseCoding(child, path+'/versionAlgorithmCoding')
      else if (child.localName = 'versionAlgorithmString') then
        value.versionAlgorithm := ParseString(child, path+'/versionAlgorithmString')
      else if (child.localName = 'name') then
        value.nameElement := ParseString(child, path+'/name')
      else if (child.localName = 'title') then
        value.titleElement := ParseString(child, path+'/title')
      else if (child.localName = 'status') then
        value.statusElement := ParseEnum(CODES_TFhirPublicationStatusEnum, SYSTEMS_TFhirPublicationStatusEnum, child, path+'/status')
      else if (child.localName = 'experimental') then
        value.experimentalElement := ParseBoolean(child, path+'/experimental')
      else if (child.localName = 'date') then
        value.dateElement := ParseDateTime(child, path+'/date')
      else if (child.localName = 'publisher') then
        value.publisherElement := ParseString(child, path+'/publisher')
      else if (child.localName = 'contact') then
        value.contactList.Add(ParseContactDetail(child, path+'/contact'))
      else if (child.localName = 'description') then
        value.descriptionElement := ParseMarkdown(child, path+'/description')
      else if (child.localName = 'useContext') then
        value.useContextList.Add(ParseUsageContext(child, path+'/useContext'))
      else if (child.localName = 'jurisdiction') then
        value.jurisdictionList.Add(ParseCodeableConcept(child, path+'/jurisdiction'))
      else if (child.localName = 'purpose') then
        value.purposeElement := ParseMarkdown(child, path+'/purpose')
      else if (child.localName = 'copyright') then
        value.copyrightElement := ParseMarkdown(child, path+'/copyright')
      else if (child.localName = 'copyrightLabel') then
        value.copyrightLabelElement := ParseString(child, path+'/copyrightLabel')
      else if (child.localName = 'structure') then
        value.structureList.Add(ParseStructureMapStructure(child, path+'/structure'))
      else if (child.localName = 'import') then
        value.importList.Add(ParseCanonical(child, path+'/import'))
      else if (child.localName = 'group') then
        value.groupList.Add(ParseStructureMapGroup(child, path+'/group'))
      else if Not ParseCanonicalResourceChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeStructureMap(xml : TXmlBuilder; name : String; value : TFhirStructureMap);
begin
  if (value = nil) then
    exit;
  composeCanonicalResourceAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeStructureMapChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeStructureMapChildren(xml : TXmlBuilder; value : TFhirStructureMap);
var
  i : integer;
begin
  composeCanonicalResourceChildren(xml, value);
  ComposeUri(xml, 'url', value.urlElement);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.identifierList.Count - 1 do
      ComposeIdentifier(xml, 'identifier', value.identifierList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(xml, 'version', value.versionElement);
  if (SummaryOption in [soFull, soSummary, soData]) and (value.versionAlgorithm is TFhirCoding) {6} then
    ComposeCoding(xml, 'versionAlgorithmCoding', TFhirCoding(value.versionAlgorithm))
  else if (SummaryOption in [soFull, soSummary, soData]) and (value.versionAlgorithm is TFhirString) {6} then
    ComposeString(xml, 'versionAlgorithmString', TFhirString(value.versionAlgorithm));
  ComposeString(xml, 'name', value.nameElement);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(xml, 'title', value.titleElement);
  ComposeEnum(xml, 'status', value.statusElement, CODES_TFhirPublicationStatusEnum);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeBoolean(xml, 'experimental', value.experimentalElement);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDateTime(xml, 'date', value.dateElement);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(xml, 'publisher', value.publisherElement);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.contactList.Count - 1 do
      ComposeContactDetail(xml, 'contact', value.contactList[i]);
  if (SummaryOption in [soFull, soData]) then
    ComposeMarkdown(xml, 'description', value.descriptionElement);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.useContextList.Count - 1 do
      ComposeUsageContext(xml, 'useContext', value.useContextList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.jurisdictionList.Count - 1 do
      ComposeCodeableConcept(xml, 'jurisdiction', value.jurisdictionList[i]);
  if (SummaryOption in [soFull, soData]) then
    ComposeMarkdown(xml, 'purpose', value.purposeElement);
  if (SummaryOption in [soFull, soData]) then
    ComposeMarkdown(xml, 'copyright', value.copyrightElement);
  if (SummaryOption in [soFull, soData]) then
    ComposeString(xml, 'copyrightLabel', value.copyrightLabelElement);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.structureList.Count - 1 do
      ComposeStructureMapStructure(xml, 'structure', value.structureList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.importList.Count - 1 do
      ComposeCanonical(xml, 'import', value.importList[i]);
  for i := 0 to value.groupList.Count - 1 do
      ComposeStructureMapGroup(xml, 'group', value.groupList[i]);
end;

{$ENDIF FHIR_STRUCTUREMAP}
{$IFDEF FHIR_SUBSCRIPTION}
function TFHIRXmlParser.ParseSubscriptionFilterBy(element : TMXmlElement; path : string) : TFhirSubscriptionFilterBy;
var
  child : TMXmlElement;
begin
  result := TFhirSubscriptionFilterBy.Create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseSubscriptionFilterByChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseSubscriptionFilterByChild(value : TFhirSubscriptionFilterBy; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'resourceType') then
        value.resourceTypeElement := ParseUri(child, path+'/resourceType')
      else if (child.localName = 'filterParameter') then
        value.filterParameterElement := ParseString(child, path+'/filterParameter')
      else if (child.localName = 'modifier') then
        value.modifierElement := ParseEnum(CODES_TFhirSubscriptionSearchModifierEnum, SYSTEMS_TFhirSubscriptionSearchModifierEnum, child, path+'/modifier')
      else if (child.localName = 'value') then
        value.valueElement := ParseString(child, path+'/value')
      else if Not ParseBackboneElementChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeSubscriptionFilterBy(xml : TXmlBuilder; name : String; value : TFhirSubscriptionFilterBy);
begin
  if (value = nil) then
    exit;
  composeElementAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeSubscriptionFilterByChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeSubscriptionFilterByChildren(xml : TXmlBuilder; value : TFhirSubscriptionFilterBy);
begin
  composeBackboneElementChildren(xml, value);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeUri(xml, 'resourceType', value.resourceTypeElement);
  ComposeString(xml, 'filterParameter', value.filterParameterElement);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeEnum(xml, 'modifier', value.modifierElement, CODES_TFhirSubscriptionSearchModifierEnum);
  ComposeString(xml, 'value', value.valueElement);
end;

function TFHIRXmlParser.ParseSubscription(element : TMXmlElement; path : string) : TFhirSubscription;
var
  child : TMXmlElement;
begin
  result := TFhirSubscription.Create;
  try
    parseDomainResourceAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseSubscriptionChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseSubscriptionChild(value : TFhirSubscription; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'identifier') then
        value.identifierList.Add(ParseIdentifier(child, path+'/identifier'))
      else if (child.localName = 'name') then
        value.nameElement := ParseString(child, path+'/name')
      else if (child.localName = 'status') then
        value.statusElement := ParseEnum(CODES_TFhirSubscriptionStatusCodesEnum, SYSTEMS_TFhirSubscriptionStatusCodesEnum, child, path+'/status')
      else if (child.localName = 'topic') then
        value.topicElement := ParseCanonical(child, path+'/topic')
      else if (child.localName = 'contact') then
        value.contactList.Add(ParseContactPoint(child, path+'/contact'))
      else if (child.localName = 'end') then
        value.end_Element := ParseInstant(child, path+'/end')
      else if (child.localName = 'managingEntity') then
        value.managingEntity := ParseReference(child, path+'/managingEntity')
      else if (child.localName = 'reason') then
        value.reasonElement := ParseString(child, path+'/reason')
      else if (child.localName = 'filterBy') then
        value.filterByList.Add(ParseSubscriptionFilterBy(child, path+'/filterBy'))
      else if (child.localName = 'channelType') then
        value.channelType := ParseCoding(child, path+'/channelType')
      else if (child.localName = 'endpoint') then
        value.endpointElement := ParseUrl(child, path+'/endpoint')
      else if (child.localName = 'header') then
        value.headerList.Add(ParseString(child, path+'/header'))
      else if (child.localName = 'heartbeatPeriod') then
        value.heartbeatPeriodElement := ParseUnsignedInt(child, path+'/heartbeatPeriod')
      else if (child.localName = 'timeout') then
        value.timeoutElement := ParseUnsignedInt(child, path+'/timeout')
      else if (child.localName = 'contentType') then
        value.contentTypeElement := ParseCode(child, path+'/contentType')
      else if (child.localName = 'content') then
        value.contentElement := ParseEnum(CODES_TFhirSubscriptionPayloadContentEnum, SYSTEMS_TFhirSubscriptionPayloadContentEnum, child, path+'/content')
      else if (child.localName = 'maxCount') then
        value.maxCountElement := ParsePositiveInt(child, path+'/maxCount')
      else if Not ParseDomainResourceChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeSubscription(xml : TXmlBuilder; name : String; value : TFhirSubscription);
begin
  if (value = nil) then
    exit;
  composeDomainResourceAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeSubscriptionChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeSubscriptionChildren(xml : TXmlBuilder; value : TFhirSubscription);
var
  i : integer;
begin
  composeDomainResourceChildren(xml, value);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.identifierList.Count - 1 do
      ComposeIdentifier(xml, 'identifier', value.identifierList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(xml, 'name', value.nameElement);
  ComposeEnum(xml, 'status', value.statusElement, CODES_TFhirSubscriptionStatusCodesEnum);
  ComposeCanonical(xml, 'topic', value.topicElement);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.contactList.Count - 1 do
      ComposeContactPoint(xml, 'contact', value.contactList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeInstant(xml, 'end', value.end_Element);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference(xml, 'managingEntity', value.managingEntity);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(xml, 'reason', value.reasonElement);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.filterByList.Count - 1 do
      ComposeSubscriptionFilterBy(xml, 'filterBy', value.filterByList[i]);
  ComposeCoding(xml, 'channelType', value.channelType);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeUrl(xml, 'endpoint', value.endpointElement);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.headerList.Count - 1 do
      ComposeString(xml, 'header', value.headerList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeUnsignedInt(xml, 'heartbeatPeriod', value.heartbeatPeriodElement);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeUnsignedInt(xml, 'timeout', value.timeoutElement);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCode(xml, 'contentType', value.contentTypeElement);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeEnum(xml, 'content', value.contentElement, CODES_TFhirSubscriptionPayloadContentEnum);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposePositiveInt(xml, 'maxCount', value.maxCountElement);
end;

{$ENDIF FHIR_SUBSCRIPTION}
{$IFDEF FHIR_SUBSCRIPTIONSTATUS}
function TFHIRXmlParser.ParseSubscriptionStatusNotificationEvent(element : TMXmlElement; path : string) : TFhirSubscriptionStatusNotificationEvent;
var
  child : TMXmlElement;
begin
  result := TFhirSubscriptionStatusNotificationEvent.Create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseSubscriptionStatusNotificationEventChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseSubscriptionStatusNotificationEventChild(value : TFhirSubscriptionStatusNotificationEvent; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'eventNumber') then
        value.eventNumberElement := ParseInteger64(child, path+'/eventNumber')
      else if (child.localName = 'timestamp') then
        value.timestampElement := ParseInstant(child, path+'/timestamp')
      else if (child.localName = 'focus') then
        value.focus := ParseReference(child, path+'/focus')
      else if (child.localName = 'additionalContext') then
        value.additionalContextList.Add(ParseReference(child, path+'/additionalContext'))
      else if Not ParseBackboneElementChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeSubscriptionStatusNotificationEvent(xml : TXmlBuilder; name : String; value : TFhirSubscriptionStatusNotificationEvent);
begin
  if (value = nil) then
    exit;
  composeElementAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeSubscriptionStatusNotificationEventChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeSubscriptionStatusNotificationEventChildren(xml : TXmlBuilder; value : TFhirSubscriptionStatusNotificationEvent);
var
  i : integer;
begin
  composeBackboneElementChildren(xml, value);
  ComposeInteger64(xml, 'eventNumber', value.eventNumberElement);
  if (SummaryOption in [soFull, soData]) then
    ComposeInstant(xml, 'timestamp', value.timestampElement);
  if (SummaryOption in [soFull, soData]) then
    ComposeReference(xml, 'focus', value.focus);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.additionalContextList.Count - 1 do
      ComposeReference(xml, 'additionalContext', value.additionalContextList[i]);
end;

function TFHIRXmlParser.ParseSubscriptionStatus(element : TMXmlElement; path : string) : TFhirSubscriptionStatus;
var
  child : TMXmlElement;
begin
  result := TFhirSubscriptionStatus.Create;
  try
    parseDomainResourceAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseSubscriptionStatusChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseSubscriptionStatusChild(value : TFhirSubscriptionStatus; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'status') then
        value.statusElement := ParseEnum(CODES_TFhirSubscriptionStatusCodesEnum, SYSTEMS_TFhirSubscriptionStatusCodesEnum, child, path+'/status')
      else if (child.localName = 'type') then
        value.type_Element := ParseEnum(CODES_TFhirSubscriptionNotificationTypeEnum, SYSTEMS_TFhirSubscriptionNotificationTypeEnum, child, path+'/type')
      else if (child.localName = 'eventsSinceSubscriptionStart') then
        value.eventsSinceSubscriptionStartElement := ParseInteger64(child, path+'/eventsSinceSubscriptionStart')
      else if (child.localName = 'notificationEvent') then
        value.notificationEventList.Add(ParseSubscriptionStatusNotificationEvent(child, path+'/notificationEvent'))
      else if (child.localName = 'subscription') then
        value.subscription := ParseReference(child, path+'/subscription')
      else if (child.localName = 'topic') then
        value.topicElement := ParseCanonical(child, path+'/topic')
      else if (child.localName = 'error') then
        value.errorList.Add(ParseCodeableConcept(child, path+'/error'))
      else if Not ParseDomainResourceChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeSubscriptionStatus(xml : TXmlBuilder; name : String; value : TFhirSubscriptionStatus);
begin
  if (value = nil) then
    exit;
  composeDomainResourceAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeSubscriptionStatusChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeSubscriptionStatusChildren(xml : TXmlBuilder; value : TFhirSubscriptionStatus);
var
  i : integer;
begin
  composeDomainResourceChildren(xml, value);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeEnum(xml, 'status', value.statusElement, CODES_TFhirSubscriptionStatusCodesEnum);
  ComposeEnum(xml, 'type', value.type_Element, CODES_TFhirSubscriptionNotificationTypeEnum);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeInteger64(xml, 'eventsSinceSubscriptionStart', value.eventsSinceSubscriptionStartElement);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.notificationEventList.Count - 1 do
      ComposeSubscriptionStatusNotificationEvent(xml, 'notificationEvent', value.notificationEventList[i]);
  ComposeReference(xml, 'subscription', value.subscription);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCanonical(xml, 'topic', value.topicElement);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.errorList.Count - 1 do
      ComposeCodeableConcept(xml, 'error', value.errorList[i]);
end;

{$ENDIF FHIR_SUBSCRIPTIONSTATUS}
{$IFDEF FHIR_SUBSCRIPTIONTOPIC}
function TFHIRXmlParser.ParseSubscriptionTopicResourceTrigger(element : TMXmlElement; path : string) : TFhirSubscriptionTopicResourceTrigger;
var
  child : TMXmlElement;
begin
  result := TFhirSubscriptionTopicResourceTrigger.Create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseSubscriptionTopicResourceTriggerChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseSubscriptionTopicResourceTriggerChild(value : TFhirSubscriptionTopicResourceTrigger; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'description') then
        value.descriptionElement := ParseMarkdown(child, path+'/description')
      else if (child.localName = 'resource') then
        value.resourceElement := ParseUri(child, path+'/resource')
      else if (child.localName = 'supportedInteraction') then
        value.supportedInteractionList.Add(ParseEnum(CODES_TFhirInteractionTriggerEnum, SYSTEMS_TFhirInteractionTriggerEnum, child, path+'/supportedInteraction')){y.1}
      else if (child.localName = 'queryCriteria') then
        value.queryCriteria := ParseSubscriptionTopicResourceTriggerQueryCriteria(child, path+'/queryCriteria')
      else if (child.localName = 'fhirPathCriteria') then
        value.fhirPathCriteriaElement := ParseString(child, path+'/fhirPathCriteria')
      else if Not ParseBackboneElementChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeSubscriptionTopicResourceTrigger(xml : TXmlBuilder; name : String; value : TFhirSubscriptionTopicResourceTrigger);
begin
  if (value = nil) then
    exit;
  composeElementAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeSubscriptionTopicResourceTriggerChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeSubscriptionTopicResourceTriggerChildren(xml : TXmlBuilder; value : TFhirSubscriptionTopicResourceTrigger);
var
  i : integer;
begin
  composeBackboneElementChildren(xml, value);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeMarkdown(xml, 'description', value.descriptionElement);
  ComposeUri(xml, 'resource', value.resourceElement);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.supportedInteractionList.Count - 1 do
      ComposeEnum(xml, 'supportedInteraction', value.supportedInteractionList[i], CODES_TFhirInteractionTriggerEnum);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeSubscriptionTopicResourceTriggerQueryCriteria(xml, 'queryCriteria', value.queryCriteria);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(xml, 'fhirPathCriteria', value.fhirPathCriteriaElement);
end;

function TFHIRXmlParser.ParseSubscriptionTopicResourceTriggerQueryCriteria(element : TMXmlElement; path : string) : TFhirSubscriptionTopicResourceTriggerQueryCriteria;
var
  child : TMXmlElement;
begin
  result := TFhirSubscriptionTopicResourceTriggerQueryCriteria.Create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseSubscriptionTopicResourceTriggerQueryCriteriaChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseSubscriptionTopicResourceTriggerQueryCriteriaChild(value : TFhirSubscriptionTopicResourceTriggerQueryCriteria; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'previous') then
        value.previousElement := ParseString(child, path+'/previous')
      else if (child.localName = 'resultForCreate') then
        value.resultForCreateElement := ParseEnum(CODES_TFhirCriteriaNotExistsBehaviorEnum, SYSTEMS_TFhirCriteriaNotExistsBehaviorEnum, child, path+'/resultForCreate')
      else if (child.localName = 'current') then
        value.currentElement := ParseString(child, path+'/current')
      else if (child.localName = 'resultForDelete') then
        value.resultForDeleteElement := ParseEnum(CODES_TFhirCriteriaNotExistsBehaviorEnum, SYSTEMS_TFhirCriteriaNotExistsBehaviorEnum, child, path+'/resultForDelete')
      else if (child.localName = 'requireBoth') then
        value.requireBothElement := ParseBoolean(child, path+'/requireBoth')
      else if Not ParseBackboneElementChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeSubscriptionTopicResourceTriggerQueryCriteria(xml : TXmlBuilder; name : String; value : TFhirSubscriptionTopicResourceTriggerQueryCriteria);
begin
  if (value = nil) then
    exit;
  composeElementAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeSubscriptionTopicResourceTriggerQueryCriteriaChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeSubscriptionTopicResourceTriggerQueryCriteriaChildren(xml : TXmlBuilder; value : TFhirSubscriptionTopicResourceTriggerQueryCriteria);
begin
  composeBackboneElementChildren(xml, value);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(xml, 'previous', value.previousElement);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeEnum(xml, 'resultForCreate', value.resultForCreateElement, CODES_TFhirCriteriaNotExistsBehaviorEnum);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(xml, 'current', value.currentElement);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeEnum(xml, 'resultForDelete', value.resultForDeleteElement, CODES_TFhirCriteriaNotExistsBehaviorEnum);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeBoolean(xml, 'requireBoth', value.requireBothElement);
end;

function TFHIRXmlParser.ParseSubscriptionTopicEventTrigger(element : TMXmlElement; path : string) : TFhirSubscriptionTopicEventTrigger;
var
  child : TMXmlElement;
begin
  result := TFhirSubscriptionTopicEventTrigger.Create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseSubscriptionTopicEventTriggerChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseSubscriptionTopicEventTriggerChild(value : TFhirSubscriptionTopicEventTrigger; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'description') then
        value.descriptionElement := ParseMarkdown(child, path+'/description')
      else if (child.localName = 'event') then
        value.event := ParseCodeableConcept(child, path+'/event')
      else if (child.localName = 'resource') then
        value.resourceElement := ParseUri(child, path+'/resource')
      else if Not ParseBackboneElementChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeSubscriptionTopicEventTrigger(xml : TXmlBuilder; name : String; value : TFhirSubscriptionTopicEventTrigger);
begin
  if (value = nil) then
    exit;
  composeElementAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeSubscriptionTopicEventTriggerChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeSubscriptionTopicEventTriggerChildren(xml : TXmlBuilder; value : TFhirSubscriptionTopicEventTrigger);
begin
  composeBackboneElementChildren(xml, value);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeMarkdown(xml, 'description', value.descriptionElement);
  ComposeCodeableConcept(xml, 'event', value.event);
  ComposeUri(xml, 'resource', value.resourceElement);
end;

function TFHIRXmlParser.ParseSubscriptionTopicCanFilterBy(element : TMXmlElement; path : string) : TFhirSubscriptionTopicCanFilterBy;
var
  child : TMXmlElement;
begin
  result := TFhirSubscriptionTopicCanFilterBy.Create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseSubscriptionTopicCanFilterByChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseSubscriptionTopicCanFilterByChild(value : TFhirSubscriptionTopicCanFilterBy; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'description') then
        value.descriptionElement := ParseMarkdown(child, path+'/description')
      else if (child.localName = 'resource') then
        value.resourceElement := ParseUri(child, path+'/resource')
      else if (child.localName = 'filterParameter') then
        value.filterParameterElement := ParseString(child, path+'/filterParameter')
      else if (child.localName = 'filterDefinition') then
        value.filterDefinitionElement := ParseUri(child, path+'/filterDefinition')
      else if (child.localName = 'modifier') then
        value.modifierList.Add(ParseEnum(CODES_TFhirSubscriptionSearchModifierEnum, SYSTEMS_TFhirSubscriptionSearchModifierEnum, child, path+'/modifier')){y.1}
      else if Not ParseBackboneElementChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeSubscriptionTopicCanFilterBy(xml : TXmlBuilder; name : String; value : TFhirSubscriptionTopicCanFilterBy);
begin
  if (value = nil) then
    exit;
  composeElementAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeSubscriptionTopicCanFilterByChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeSubscriptionTopicCanFilterByChildren(xml : TXmlBuilder; value : TFhirSubscriptionTopicCanFilterBy);
var
  i : integer;
begin
  composeBackboneElementChildren(xml, value);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeMarkdown(xml, 'description', value.descriptionElement);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeUri(xml, 'resource', value.resourceElement);
  ComposeString(xml, 'filterParameter', value.filterParameterElement);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeUri(xml, 'filterDefinition', value.filterDefinitionElement);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.modifierList.Count - 1 do
      ComposeEnum(xml, 'modifier', value.modifierList[i], CODES_TFhirSubscriptionSearchModifierEnum);
end;

function TFHIRXmlParser.ParseSubscriptionTopicNotificationShape(element : TMXmlElement; path : string) : TFhirSubscriptionTopicNotificationShape;
var
  child : TMXmlElement;
begin
  result := TFhirSubscriptionTopicNotificationShape.Create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseSubscriptionTopicNotificationShapeChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseSubscriptionTopicNotificationShapeChild(value : TFhirSubscriptionTopicNotificationShape; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'resource') then
        value.resourceElement := ParseUri(child, path+'/resource')
      else if (child.localName = 'include') then
        value.includeList.Add(ParseString(child, path+'/include'))
      else if (child.localName = 'revInclude') then
        value.revIncludeList.Add(ParseString(child, path+'/revInclude'))
      else if Not ParseBackboneElementChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeSubscriptionTopicNotificationShape(xml : TXmlBuilder; name : String; value : TFhirSubscriptionTopicNotificationShape);
begin
  if (value = nil) then
    exit;
  composeElementAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeSubscriptionTopicNotificationShapeChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeSubscriptionTopicNotificationShapeChildren(xml : TXmlBuilder; value : TFhirSubscriptionTopicNotificationShape);
var
  i : integer;
begin
  composeBackboneElementChildren(xml, value);
  ComposeUri(xml, 'resource', value.resourceElement);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.includeList.Count - 1 do
      ComposeString(xml, 'include', value.includeList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.revIncludeList.Count - 1 do
      ComposeString(xml, 'revInclude', value.revIncludeList[i]);
end;

function TFHIRXmlParser.ParseSubscriptionTopic(element : TMXmlElement; path : string) : TFhirSubscriptionTopic;
var
  child : TMXmlElement;
begin
  result := TFhirSubscriptionTopic.Create;
  try
    parseCanonicalResourceAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseSubscriptionTopicChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseSubscriptionTopicChild(value : TFhirSubscriptionTopic; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'url') then
        value.urlElement := ParseUri(child, path+'/url')
      else if (child.localName = 'identifier') then
        value.identifierList.Add(ParseIdentifier(child, path+'/identifier'))
      else if (child.localName = 'version') then
        value.versionElement := ParseString(child, path+'/version')
      else if (child.localName = 'title') then
        value.titleElement := ParseString(child, path+'/title')
      else if (child.localName = 'derivedFrom') then
        value.derivedFromList.Add(ParseCanonical(child, path+'/derivedFrom'))
      else if (child.localName = 'status') then
        value.statusElement := ParseEnum(CODES_TFhirPublicationStatusEnum, SYSTEMS_TFhirPublicationStatusEnum, child, path+'/status')
      else if (child.localName = 'experimental') then
        value.experimentalElement := ParseBoolean(child, path+'/experimental')
      else if (child.localName = 'date') then
        value.dateElement := ParseDateTime(child, path+'/date')
      else if (child.localName = 'publisher') then
        value.publisherElement := ParseString(child, path+'/publisher')
      else if (child.localName = 'contact') then
        value.contactList.Add(ParseContactDetail(child, path+'/contact'))
      else if (child.localName = 'description') then
        value.descriptionElement := ParseMarkdown(child, path+'/description')
      else if (child.localName = 'useContext') then
        value.useContextList.Add(ParseUsageContext(child, path+'/useContext'))
      else if (child.localName = 'jurisdiction') then
        value.jurisdictionList.Add(ParseCodeableConcept(child, path+'/jurisdiction'))
      else if (child.localName = 'purpose') then
        value.purposeElement := ParseMarkdown(child, path+'/purpose')
      else if (child.localName = 'copyright') then
        value.copyrightElement := ParseMarkdown(child, path+'/copyright')
      else if (child.localName = 'copyrightLabel') then
        value.copyrightLabelElement := ParseString(child, path+'/copyrightLabel')
      else if (child.localName = 'approvalDate') then
        value.approvalDateElement := ParseDate(child, path+'/approvalDate')
      else if (child.localName = 'lastReviewDate') then
        value.lastReviewDateElement := ParseDate(child, path+'/lastReviewDate')
      else if (child.localName = 'effectivePeriod') then
        value.effectivePeriod := ParsePeriod(child, path+'/effectivePeriod')
      else if (child.localName = 'resourceTrigger') then
        value.resourceTriggerList.Add(ParseSubscriptionTopicResourceTrigger(child, path+'/resourceTrigger'))
      else if (child.localName = 'eventTrigger') then
        value.eventTriggerList.Add(ParseSubscriptionTopicEventTrigger(child, path+'/eventTrigger'))
      else if (child.localName = 'canFilterBy') then
        value.canFilterByList.Add(ParseSubscriptionTopicCanFilterBy(child, path+'/canFilterBy'))
      else if (child.localName = 'notificationShape') then
        value.notificationShapeList.Add(ParseSubscriptionTopicNotificationShape(child, path+'/notificationShape'))
      else if Not ParseCanonicalResourceChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeSubscriptionTopic(xml : TXmlBuilder; name : String; value : TFhirSubscriptionTopic);
begin
  if (value = nil) then
    exit;
  composeCanonicalResourceAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeSubscriptionTopicChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeSubscriptionTopicChildren(xml : TXmlBuilder; value : TFhirSubscriptionTopic);
var
  i : integer;
begin
  composeCanonicalResourceChildren(xml, value);
  ComposeUri(xml, 'url', value.urlElement);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.identifierList.Count - 1 do
      ComposeIdentifier(xml, 'identifier', value.identifierList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(xml, 'version', value.versionElement);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(xml, 'title', value.titleElement);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.derivedFromList.Count - 1 do
      ComposeCanonical(xml, 'derivedFrom', value.derivedFromList[i]);
  ComposeEnum(xml, 'status', value.statusElement, CODES_TFhirPublicationStatusEnum);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeBoolean(xml, 'experimental', value.experimentalElement);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDateTime(xml, 'date', value.dateElement);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(xml, 'publisher', value.publisherElement);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.contactList.Count - 1 do
      ComposeContactDetail(xml, 'contact', value.contactList[i]);
  if (SummaryOption in [soFull, soData]) then
    ComposeMarkdown(xml, 'description', value.descriptionElement);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.useContextList.Count - 1 do
      ComposeUsageContext(xml, 'useContext', value.useContextList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.jurisdictionList.Count - 1 do
      ComposeCodeableConcept(xml, 'jurisdiction', value.jurisdictionList[i]);
  if (SummaryOption in [soFull, soData]) then
    ComposeMarkdown(xml, 'purpose', value.purposeElement);
  if (SummaryOption in [soFull, soData]) then
    ComposeMarkdown(xml, 'copyright', value.copyrightElement);
  if (SummaryOption in [soFull, soData]) then
    ComposeString(xml, 'copyrightLabel', value.copyrightLabelElement);
  if (SummaryOption in [soFull, soData]) then
    ComposeDate(xml, 'approvalDate', value.approvalDateElement);
  if (SummaryOption in [soFull, soData]) then
    ComposeDate(xml, 'lastReviewDate', value.lastReviewDateElement);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposePeriod(xml, 'effectivePeriod', value.effectivePeriod);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.resourceTriggerList.Count - 1 do
      ComposeSubscriptionTopicResourceTrigger(xml, 'resourceTrigger', value.resourceTriggerList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.eventTriggerList.Count - 1 do
      ComposeSubscriptionTopicEventTrigger(xml, 'eventTrigger', value.eventTriggerList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.canFilterByList.Count - 1 do
      ComposeSubscriptionTopicCanFilterBy(xml, 'canFilterBy', value.canFilterByList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.notificationShapeList.Count - 1 do
      ComposeSubscriptionTopicNotificationShape(xml, 'notificationShape', value.notificationShapeList[i]);
end;

{$ENDIF FHIR_SUBSCRIPTIONTOPIC}
{$IFDEF FHIR_SUBSTANCE}
function TFHIRXmlParser.ParseSubstanceIngredient(element : TMXmlElement; path : string) : TFhirSubstanceIngredient;
var
  child : TMXmlElement;
begin
  result := TFhirSubstanceIngredient.Create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseSubstanceIngredientChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseSubstanceIngredientChild(value : TFhirSubstanceIngredient; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'quantity') then
        value.quantity := ParseRatio(child, path+'/quantity')
      else if (child.localName = 'substanceCodeableConcept') then
        value.substance := ParseCodeableConcept(child, path+'/substanceCodeableConcept')
      else if (child.localName = 'substanceReference') then
        value.substance := ParseReference(child, path+'/substanceReference')
      else if Not ParseBackboneElementChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeSubstanceIngredient(xml : TXmlBuilder; name : String; value : TFhirSubstanceIngredient);
begin
  if (value = nil) then
    exit;
  composeElementAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeSubstanceIngredientChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeSubstanceIngredientChildren(xml : TXmlBuilder; value : TFhirSubstanceIngredient);
begin
  composeBackboneElementChildren(xml, value);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeRatio(xml, 'quantity', value.quantity);
  if (value.substance is TFhirCodeableConcept) {6} then
    ComposeCodeableConcept(xml, 'substanceCodeableConcept', TFhirCodeableConcept(value.substance))
  else if (value.substance is TFhirReference) {2} then
    ComposeReference(xml, 'substanceReference', TFhirReference(value.substance));
end;

function TFHIRXmlParser.ParseSubstance(element : TMXmlElement; path : string) : TFhirSubstance;
var
  child : TMXmlElement;
begin
  result := TFhirSubstance.Create;
  try
    parseDomainResourceAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseSubstanceChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseSubstanceChild(value : TFhirSubstance; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'identifier') then
        value.identifierList.Add(ParseIdentifier(child, path+'/identifier'))
      else if (child.localName = 'instance') then
        value.instanceElement := ParseBoolean(child, path+'/instance')
      else if (child.localName = 'status') then
        value.statusElement := ParseEnum(CODES_TFhirFHIRSubstanceStatusEnum, SYSTEMS_TFhirFHIRSubstanceStatusEnum, child, path+'/status')
      else if (child.localName = 'category') then
        value.categoryList.Add(ParseCodeableConcept(child, path+'/category'))
      else if (child.localName = 'code') then
        value.code := ParseCodeableReference(child, path+'/code')
      else if (child.localName = 'description') then
        value.descriptionElement := ParseString(child, path+'/description')
      else if (child.localName = 'expiry') then
        value.expiryElement := ParseDateTime(child, path+'/expiry')
      else if (child.localName = 'quantity') then
        value.quantity := ParseQuantity(child, path+'/quantity')
      else if (child.localName = 'ingredient') then
        value.ingredientList.Add(ParseSubstanceIngredient(child, path+'/ingredient'))
      else if Not ParseDomainResourceChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeSubstance(xml : TXmlBuilder; name : String; value : TFhirSubstance);
begin
  if (value = nil) then
    exit;
  composeDomainResourceAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeSubstanceChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeSubstanceChildren(xml : TXmlBuilder; value : TFhirSubstance);
var
  i : integer;
begin
  composeDomainResourceChildren(xml, value);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.identifierList.Count - 1 do
      ComposeIdentifier(xml, 'identifier', value.identifierList[i]);
  ComposeBoolean(xml, 'instance', value.instanceElement);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeEnum(xml, 'status', value.statusElement, CODES_TFhirFHIRSubstanceStatusEnum);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.categoryList.Count - 1 do
      ComposeCodeableConcept(xml, 'category', value.categoryList[i]);
  ComposeCodeableReference(xml, 'code', value.code);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(xml, 'description', value.descriptionElement);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDateTime(xml, 'expiry', value.expiryElement);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeQuantity(xml, 'quantity', value.quantity);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.ingredientList.Count - 1 do
      ComposeSubstanceIngredient(xml, 'ingredient', value.ingredientList[i]);
end;

{$ENDIF FHIR_SUBSTANCE}
{$IFDEF FHIR_SUBSTANCEDEFINITION}
function TFHIRXmlParser.ParseSubstanceDefinitionMoiety(element : TMXmlElement; path : string) : TFhirSubstanceDefinitionMoiety;
var
  child : TMXmlElement;
begin
  result := TFhirSubstanceDefinitionMoiety.Create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseSubstanceDefinitionMoietyChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseSubstanceDefinitionMoietyChild(value : TFhirSubstanceDefinitionMoiety; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'role') then
        value.role := ParseCodeableConcept(child, path+'/role')
      else if (child.localName = 'identifier') then
        value.identifier := ParseIdentifier(child, path+'/identifier')
      else if (child.localName = 'name') then
        value.nameElement := ParseString(child, path+'/name')
      else if (child.localName = 'stereochemistry') then
        value.stereochemistry := ParseCodeableConcept(child, path+'/stereochemistry')
      else if (child.localName = 'opticalActivity') then
        value.opticalActivity := ParseCodeableConcept(child, path+'/opticalActivity')
      else if (child.localName = 'molecularFormula') then
        value.molecularFormulaElement := ParseString(child, path+'/molecularFormula')
      else if (child.localName = 'amountQuantity') then
        value.amount := ParseQuantity(child, path+'/amountQuantity')
      else if (child.localName = 'amountString') then
        value.amount := ParseString(child, path+'/amountString')
      else if (child.localName = 'measurementType') then
        value.measurementType := ParseCodeableConcept(child, path+'/measurementType')
      else if Not ParseBackboneElementChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeSubstanceDefinitionMoiety(xml : TXmlBuilder; name : String; value : TFhirSubstanceDefinitionMoiety);
begin
  if (value = nil) then
    exit;
  composeElementAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeSubstanceDefinitionMoietyChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeSubstanceDefinitionMoietyChildren(xml : TXmlBuilder; value : TFhirSubstanceDefinitionMoiety);
begin
  composeBackboneElementChildren(xml, value);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(xml, 'role', value.role);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeIdentifier(xml, 'identifier', value.identifier);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(xml, 'name', value.nameElement);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(xml, 'stereochemistry', value.stereochemistry);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(xml, 'opticalActivity', value.opticalActivity);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(xml, 'molecularFormula', value.molecularFormulaElement);
  if (SummaryOption in [soFull, soSummary, soData]) and (value.amount is TFhirQuantity) {6} then
    ComposeQuantity(xml, 'amountQuantity', TFhirQuantity(value.amount))
  else if (SummaryOption in [soFull, soSummary, soData]) and (value.amount is TFhirString) {6} then
    ComposeString(xml, 'amountString', TFhirString(value.amount));
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(xml, 'measurementType', value.measurementType);
end;

function TFHIRXmlParser.ParseSubstanceDefinitionProperty(element : TMXmlElement; path : string) : TFhirSubstanceDefinitionProperty;
var
  child : TMXmlElement;
begin
  result := TFhirSubstanceDefinitionProperty.Create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseSubstanceDefinitionPropertyChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseSubstanceDefinitionPropertyChild(value : TFhirSubstanceDefinitionProperty; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'type') then
        value.type_ := ParseCodeableConcept(child, path+'/type')
      else if (child.localName = 'valueCodeableConcept') then
        value.value := ParseCodeableConcept(child, path+'/valueCodeableConcept')
      else if (child.localName = 'valueQuantity') then
        value.value := ParseQuantity(child, path+'/valueQuantity')
      else if (child.localName = 'valueAttachment') then
        value.value := ParseAttachment(child, path+'/valueAttachment')
      else if (child.localName = 'valueDate') then
        value.value := ParseDate(child, path+'/valueDate')
      else if (child.localName = 'valueBoolean') then
        value.value := ParseBoolean(child, path+'/valueBoolean')
      else if Not ParseBackboneElementChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeSubstanceDefinitionProperty(xml : TXmlBuilder; name : String; value : TFhirSubstanceDefinitionProperty);
begin
  if (value = nil) then
    exit;
  composeElementAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeSubstanceDefinitionPropertyChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeSubstanceDefinitionPropertyChildren(xml : TXmlBuilder; value : TFhirSubstanceDefinitionProperty);
begin
  composeBackboneElementChildren(xml, value);
  ComposeCodeableConcept(xml, 'type', value.type_);
  if (SummaryOption in [soFull, soSummary, soData]) and (value.value is TFhirCodeableConcept) {6} then
    ComposeCodeableConcept(xml, 'valueCodeableConcept', TFhirCodeableConcept(value.value))
  else if (SummaryOption in [soFull, soSummary, soData]) and (value.value is TFhirQuantity) {6} then
    ComposeQuantity(xml, 'valueQuantity', TFhirQuantity(value.value))
  else if (SummaryOption in [soFull, soSummary, soData]) and (value.value is TFhirAttachment) {6} then
    ComposeAttachment(xml, 'valueAttachment', TFhirAttachment(value.value))
  else if (SummaryOption in [soFull, soSummary, soData]) and (value.value is TFhirDate) {6} then
    ComposeDate(xml, 'valueDate', TFhirDate(value.value))
  else if (SummaryOption in [soFull, soSummary, soData]) and (value.value is TFhirBoolean) {6} then
    ComposeBoolean(xml, 'valueBoolean', TFhirBoolean(value.value));
end;

function TFHIRXmlParser.ParseSubstanceDefinitionMolecularWeight(element : TMXmlElement; path : string) : TFhirSubstanceDefinitionMolecularWeight;
var
  child : TMXmlElement;
begin
  result := TFhirSubstanceDefinitionMolecularWeight.Create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseSubstanceDefinitionMolecularWeightChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseSubstanceDefinitionMolecularWeightChild(value : TFhirSubstanceDefinitionMolecularWeight; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'method') then
        value.method := ParseCodeableConcept(child, path+'/method')
      else if (child.localName = 'type') then
        value.type_ := ParseCodeableConcept(child, path+'/type')
      else if (child.localName = 'amount') then
        value.amount := ParseQuantity(child, path+'/amount')
      else if Not ParseBackboneElementChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeSubstanceDefinitionMolecularWeight(xml : TXmlBuilder; name : String; value : TFhirSubstanceDefinitionMolecularWeight);
begin
  if (value = nil) then
    exit;
  composeElementAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeSubstanceDefinitionMolecularWeightChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeSubstanceDefinitionMolecularWeightChildren(xml : TXmlBuilder; value : TFhirSubstanceDefinitionMolecularWeight);
begin
  composeBackboneElementChildren(xml, value);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(xml, 'method', value.method);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(xml, 'type', value.type_);
  ComposeQuantity(xml, 'amount', value.amount);
end;

function TFHIRXmlParser.ParseSubstanceDefinitionStructure(element : TMXmlElement; path : string) : TFhirSubstanceDefinitionStructure;
var
  child : TMXmlElement;
begin
  result := TFhirSubstanceDefinitionStructure.Create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseSubstanceDefinitionStructureChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseSubstanceDefinitionStructureChild(value : TFhirSubstanceDefinitionStructure; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'stereochemistry') then
        value.stereochemistry := ParseCodeableConcept(child, path+'/stereochemistry')
      else if (child.localName = 'opticalActivity') then
        value.opticalActivity := ParseCodeableConcept(child, path+'/opticalActivity')
      else if (child.localName = 'molecularFormula') then
        value.molecularFormulaElement := ParseString(child, path+'/molecularFormula')
      else if (child.localName = 'molecularFormulaByMoiety') then
        value.molecularFormulaByMoietyElement := ParseString(child, path+'/molecularFormulaByMoiety')
      else if (child.localName = 'molecularWeight') then
        value.molecularWeight := ParseSubstanceDefinitionMolecularWeight(child, path+'/molecularWeight')
      else if (child.localName = 'technique') then
        value.techniqueList.Add(ParseCodeableConcept(child, path+'/technique'))
      else if (child.localName = 'sourceDocument') then
        value.sourceDocumentList.Add(ParseReference(child, path+'/sourceDocument'))
      else if (child.localName = 'representation') then
        value.representationList.Add(ParseSubstanceDefinitionStructureRepresentation(child, path+'/representation'))
      else if Not ParseBackboneElementChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeSubstanceDefinitionStructure(xml : TXmlBuilder; name : String; value : TFhirSubstanceDefinitionStructure);
begin
  if (value = nil) then
    exit;
  composeElementAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeSubstanceDefinitionStructureChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeSubstanceDefinitionStructureChildren(xml : TXmlBuilder; value : TFhirSubstanceDefinitionStructure);
var
  i : integer;
begin
  composeBackboneElementChildren(xml, value);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(xml, 'stereochemistry', value.stereochemistry);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(xml, 'opticalActivity', value.opticalActivity);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(xml, 'molecularFormula', value.molecularFormulaElement);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(xml, 'molecularFormulaByMoiety', value.molecularFormulaByMoietyElement);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeSubstanceDefinitionMolecularWeight(xml, 'molecularWeight', value.molecularWeight);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.techniqueList.Count - 1 do
      ComposeCodeableConcept(xml, 'technique', value.techniqueList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.sourceDocumentList.Count - 1 do
      ComposeReference(xml, 'sourceDocument', value.sourceDocumentList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.representationList.Count - 1 do
      ComposeSubstanceDefinitionStructureRepresentation(xml, 'representation', value.representationList[i]);
end;

function TFHIRXmlParser.ParseSubstanceDefinitionStructureRepresentation(element : TMXmlElement; path : string) : TFhirSubstanceDefinitionStructureRepresentation;
var
  child : TMXmlElement;
begin
  result := TFhirSubstanceDefinitionStructureRepresentation.Create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseSubstanceDefinitionStructureRepresentationChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseSubstanceDefinitionStructureRepresentationChild(value : TFhirSubstanceDefinitionStructureRepresentation; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'type') then
        value.type_ := ParseCodeableConcept(child, path+'/type')
      else if (child.localName = 'representation') then
        value.representationElement := ParseString(child, path+'/representation')
      else if (child.localName = 'format') then
        value.format := ParseCodeableConcept(child, path+'/format')
      else if (child.localName = 'document') then
        value.document := ParseReference(child, path+'/document')
      else if Not ParseBackboneElementChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeSubstanceDefinitionStructureRepresentation(xml : TXmlBuilder; name : String; value : TFhirSubstanceDefinitionStructureRepresentation);
begin
  if (value = nil) then
    exit;
  composeElementAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeSubstanceDefinitionStructureRepresentationChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeSubstanceDefinitionStructureRepresentationChildren(xml : TXmlBuilder; value : TFhirSubstanceDefinitionStructureRepresentation);
begin
  composeBackboneElementChildren(xml, value);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(xml, 'type', value.type_);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(xml, 'representation', value.representationElement);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(xml, 'format', value.format);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference(xml, 'document', value.document);
end;

function TFHIRXmlParser.ParseSubstanceDefinitionCode(element : TMXmlElement; path : string) : TFhirSubstanceDefinitionCode;
var
  child : TMXmlElement;
begin
  result := TFhirSubstanceDefinitionCode.Create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseSubstanceDefinitionCodeChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseSubstanceDefinitionCodeChild(value : TFhirSubstanceDefinitionCode; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'code') then
        value.code := ParseCodeableConcept(child, path+'/code')
      else if (child.localName = 'status') then
        value.status := ParseCodeableConcept(child, path+'/status')
      else if (child.localName = 'statusDate') then
        value.statusDateElement := ParseDateTime(child, path+'/statusDate')
      else if (child.localName = 'note') then
        value.noteList.Add(ParseAnnotation(child, path+'/note'))
      else if (child.localName = 'source') then
        value.sourceList.Add(ParseReference(child, path+'/source'))
      else if Not ParseBackboneElementChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeSubstanceDefinitionCode(xml : TXmlBuilder; name : String; value : TFhirSubstanceDefinitionCode);
begin
  if (value = nil) then
    exit;
  composeElementAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeSubstanceDefinitionCodeChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeSubstanceDefinitionCodeChildren(xml : TXmlBuilder; value : TFhirSubstanceDefinitionCode);
var
  i : integer;
begin
  composeBackboneElementChildren(xml, value);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(xml, 'code', value.code);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(xml, 'status', value.status);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDateTime(xml, 'statusDate', value.statusDateElement);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.noteList.Count - 1 do
      ComposeAnnotation(xml, 'note', value.noteList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.sourceList.Count - 1 do
      ComposeReference(xml, 'source', value.sourceList[i]);
end;

function TFHIRXmlParser.ParseSubstanceDefinitionName(element : TMXmlElement; path : string) : TFhirSubstanceDefinitionName;
var
  child : TMXmlElement;
begin
  result := TFhirSubstanceDefinitionName.Create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseSubstanceDefinitionNameChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseSubstanceDefinitionNameChild(value : TFhirSubstanceDefinitionName; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'name') then
        value.nameElement := ParseString(child, path+'/name')
      else if (child.localName = 'type') then
        value.type_ := ParseCodeableConcept(child, path+'/type')
      else if (child.localName = 'status') then
        value.status := ParseCodeableConcept(child, path+'/status')
      else if (child.localName = 'preferred') then
        value.preferredElement := ParseBoolean(child, path+'/preferred')
      else if (child.localName = 'language') then
        value.languageList.Add(ParseCodeableConcept(child, path+'/language'))
      else if (child.localName = 'domain') then
        value.domainList.Add(ParseCodeableConcept(child, path+'/domain'))
      else if (child.localName = 'jurisdiction') then
        value.jurisdictionList.Add(ParseCodeableConcept(child, path+'/jurisdiction'))
      else if (child.localName = 'synonym') then
        value.synonymList.Add(ParseSubstanceDefinitionName(child, path+'/synonym'))
      else if (child.localName = 'translation') then
        value.translationList.Add(ParseSubstanceDefinitionName(child, path+'/translation'))
      else if (child.localName = 'official') then
        value.officialList.Add(ParseSubstanceDefinitionNameOfficial(child, path+'/official'))
      else if (child.localName = 'source') then
        value.sourceList.Add(ParseReference(child, path+'/source'))
      else if Not ParseBackboneElementChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeSubstanceDefinitionName(xml : TXmlBuilder; name : String; value : TFhirSubstanceDefinitionName);
begin
  if (value = nil) then
    exit;
  composeElementAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeSubstanceDefinitionNameChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeSubstanceDefinitionNameChildren(xml : TXmlBuilder; value : TFhirSubstanceDefinitionName);
var
  i : integer;
begin
  composeBackboneElementChildren(xml, value);
  ComposeString(xml, 'name', value.nameElement);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(xml, 'type', value.type_);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(xml, 'status', value.status);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeBoolean(xml, 'preferred', value.preferredElement);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.languageList.Count - 1 do
      ComposeCodeableConcept(xml, 'language', value.languageList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.domainList.Count - 1 do
      ComposeCodeableConcept(xml, 'domain', value.domainList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.jurisdictionList.Count - 1 do
      ComposeCodeableConcept(xml, 'jurisdiction', value.jurisdictionList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.synonymList.Count - 1 do
      ComposeSubstanceDefinitionName(xml, 'synonym', value.synonymList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.translationList.Count - 1 do
      ComposeSubstanceDefinitionName(xml, 'translation', value.translationList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.officialList.Count - 1 do
      ComposeSubstanceDefinitionNameOfficial(xml, 'official', value.officialList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.sourceList.Count - 1 do
      ComposeReference(xml, 'source', value.sourceList[i]);
end;

function TFHIRXmlParser.ParseSubstanceDefinitionNameOfficial(element : TMXmlElement; path : string) : TFhirSubstanceDefinitionNameOfficial;
var
  child : TMXmlElement;
begin
  result := TFhirSubstanceDefinitionNameOfficial.Create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseSubstanceDefinitionNameOfficialChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseSubstanceDefinitionNameOfficialChild(value : TFhirSubstanceDefinitionNameOfficial; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'authority') then
        value.authority := ParseCodeableConcept(child, path+'/authority')
      else if (child.localName = 'status') then
        value.status := ParseCodeableConcept(child, path+'/status')
      else if (child.localName = 'date') then
        value.dateElement := ParseDateTime(child, path+'/date')
      else if Not ParseBackboneElementChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeSubstanceDefinitionNameOfficial(xml : TXmlBuilder; name : String; value : TFhirSubstanceDefinitionNameOfficial);
begin
  if (value = nil) then
    exit;
  composeElementAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeSubstanceDefinitionNameOfficialChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeSubstanceDefinitionNameOfficialChildren(xml : TXmlBuilder; value : TFhirSubstanceDefinitionNameOfficial);
begin
  composeBackboneElementChildren(xml, value);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(xml, 'authority', value.authority);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(xml, 'status', value.status);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDateTime(xml, 'date', value.dateElement);
end;

function TFHIRXmlParser.ParseSubstanceDefinitionRelationship(element : TMXmlElement; path : string) : TFhirSubstanceDefinitionRelationship;
var
  child : TMXmlElement;
begin
  result := TFhirSubstanceDefinitionRelationship.Create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseSubstanceDefinitionRelationshipChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseSubstanceDefinitionRelationshipChild(value : TFhirSubstanceDefinitionRelationship; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'substanceDefinitionReference') then
        value.substanceDefinition := ParseReference(child, path+'/substanceDefinitionReference')
      else if (child.localName = 'substanceDefinitionCodeableConcept') then
        value.substanceDefinition := ParseCodeableConcept(child, path+'/substanceDefinitionCodeableConcept')
      else if (child.localName = 'type') then
        value.type_ := ParseCodeableConcept(child, path+'/type')
      else if (child.localName = 'isDefining') then
        value.isDefiningElement := ParseBoolean(child, path+'/isDefining')
      else if (child.localName = 'amountQuantity') then
        value.amount := ParseQuantity(child, path+'/amountQuantity')
      else if (child.localName = 'amountRatio') then
        value.amount := ParseRatio(child, path+'/amountRatio')
      else if (child.localName = 'amountString') then
        value.amount := ParseString(child, path+'/amountString')
      else if (child.localName = 'ratioHighLimitAmount') then
        value.ratioHighLimitAmount := ParseRatio(child, path+'/ratioHighLimitAmount')
      else if (child.localName = 'comparator') then
        value.comparator := ParseCodeableConcept(child, path+'/comparator')
      else if (child.localName = 'source') then
        value.sourceList.Add(ParseReference(child, path+'/source'))
      else if Not ParseBackboneElementChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeSubstanceDefinitionRelationship(xml : TXmlBuilder; name : String; value : TFhirSubstanceDefinitionRelationship);
begin
  if (value = nil) then
    exit;
  composeElementAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeSubstanceDefinitionRelationshipChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeSubstanceDefinitionRelationshipChildren(xml : TXmlBuilder; value : TFhirSubstanceDefinitionRelationship);
var
  i : integer;
begin
  composeBackboneElementChildren(xml, value);
  if (SummaryOption in [soFull, soSummary, soData]) and (value.substanceDefinition is TFhirReference) {2} then
    ComposeReference(xml, 'substanceDefinitionReference', TFhirReference(value.substanceDefinition))
  else if (SummaryOption in [soFull, soSummary, soData]) and (value.substanceDefinition is TFhirCodeableConcept) {6} then
    ComposeCodeableConcept(xml, 'substanceDefinitionCodeableConcept', TFhirCodeableConcept(value.substanceDefinition));
  ComposeCodeableConcept(xml, 'type', value.type_);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeBoolean(xml, 'isDefining', value.isDefiningElement);
  if (SummaryOption in [soFull, soSummary, soData]) and (value.amount is TFhirQuantity) {6} then
    ComposeQuantity(xml, 'amountQuantity', TFhirQuantity(value.amount))
  else if (SummaryOption in [soFull, soSummary, soData]) and (value.amount is TFhirRatio) {6} then
    ComposeRatio(xml, 'amountRatio', TFhirRatio(value.amount))
  else if (SummaryOption in [soFull, soSummary, soData]) and (value.amount is TFhirString) {6} then
    ComposeString(xml, 'amountString', TFhirString(value.amount));
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeRatio(xml, 'ratioHighLimitAmount', value.ratioHighLimitAmount);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(xml, 'comparator', value.comparator);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.sourceList.Count - 1 do
      ComposeReference(xml, 'source', value.sourceList[i]);
end;

function TFHIRXmlParser.ParseSubstanceDefinitionSourceMaterial(element : TMXmlElement; path : string) : TFhirSubstanceDefinitionSourceMaterial;
var
  child : TMXmlElement;
begin
  result := TFhirSubstanceDefinitionSourceMaterial.Create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseSubstanceDefinitionSourceMaterialChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseSubstanceDefinitionSourceMaterialChild(value : TFhirSubstanceDefinitionSourceMaterial; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'type') then
        value.type_ := ParseCodeableConcept(child, path+'/type')
      else if (child.localName = 'genus') then
        value.genus := ParseCodeableConcept(child, path+'/genus')
      else if (child.localName = 'species') then
        value.species := ParseCodeableConcept(child, path+'/species')
      else if (child.localName = 'part') then
        value.part := ParseCodeableConcept(child, path+'/part')
      else if (child.localName = 'countryOfOrigin') then
        value.countryOfOriginList.Add(ParseCodeableConcept(child, path+'/countryOfOrigin'))
      else if Not ParseBackboneElementChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeSubstanceDefinitionSourceMaterial(xml : TXmlBuilder; name : String; value : TFhirSubstanceDefinitionSourceMaterial);
begin
  if (value = nil) then
    exit;
  composeElementAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeSubstanceDefinitionSourceMaterialChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeSubstanceDefinitionSourceMaterialChildren(xml : TXmlBuilder; value : TFhirSubstanceDefinitionSourceMaterial);
var
  i : integer;
begin
  composeBackboneElementChildren(xml, value);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(xml, 'type', value.type_);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(xml, 'genus', value.genus);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(xml, 'species', value.species);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(xml, 'part', value.part);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.countryOfOriginList.Count - 1 do
      ComposeCodeableConcept(xml, 'countryOfOrigin', value.countryOfOriginList[i]);
end;

function TFHIRXmlParser.ParseSubstanceDefinition(element : TMXmlElement; path : string) : TFhirSubstanceDefinition;
var
  child : TMXmlElement;
begin
  result := TFhirSubstanceDefinition.Create;
  try
    parseDomainResourceAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseSubstanceDefinitionChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseSubstanceDefinitionChild(value : TFhirSubstanceDefinition; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'identifier') then
        value.identifierList.Add(ParseIdentifier(child, path+'/identifier'))
      else if (child.localName = 'version') then
        value.versionElement := ParseString(child, path+'/version')
      else if (child.localName = 'status') then
        value.status := ParseCodeableConcept(child, path+'/status')
      else if (child.localName = 'classification') then
        value.classificationList.Add(ParseCodeableConcept(child, path+'/classification'))
      else if (child.localName = 'domain') then
        value.domain := ParseCodeableConcept(child, path+'/domain')
      else if (child.localName = 'grade') then
        value.gradeList.Add(ParseCodeableConcept(child, path+'/grade'))
      else if (child.localName = 'description') then
        value.descriptionElement := ParseMarkdown(child, path+'/description')
      else if (child.localName = 'informationSource') then
        value.informationSourceList.Add(ParseReference(child, path+'/informationSource'))
      else if (child.localName = 'note') then
        value.noteList.Add(ParseAnnotation(child, path+'/note'))
      else if (child.localName = 'manufacturer') then
        value.manufacturerList.Add(ParseReference(child, path+'/manufacturer'))
      else if (child.localName = 'supplier') then
        value.supplierList.Add(ParseReference(child, path+'/supplier'))
      else if (child.localName = 'moiety') then
        value.moietyList.Add(ParseSubstanceDefinitionMoiety(child, path+'/moiety'))
      else if (child.localName = 'property') then
        value.property_List.Add(ParseSubstanceDefinitionProperty(child, path+'/property'))
      else if (child.localName = 'referenceInformation') then
        value.referenceInformation := ParseReference(child, path+'/referenceInformation')
      else if (child.localName = 'molecularWeight') then
        value.molecularWeightList.Add(ParseSubstanceDefinitionMolecularWeight(child, path+'/molecularWeight'))
      else if (child.localName = 'structure') then
        value.structure := ParseSubstanceDefinitionStructure(child, path+'/structure')
      else if (child.localName = 'code') then
        value.codeList.Add(ParseSubstanceDefinitionCode(child, path+'/code'))
      else if (child.localName = 'name') then
        value.nameList.Add(ParseSubstanceDefinitionName(child, path+'/name'))
      else if (child.localName = 'relationship') then
        value.relationshipList.Add(ParseSubstanceDefinitionRelationship(child, path+'/relationship'))
      else if (child.localName = 'nucleicAcid') then
        value.nucleicAcid := ParseReference(child, path+'/nucleicAcid')
      else if (child.localName = 'polymer') then
        value.polymer := ParseReference(child, path+'/polymer')
      else if (child.localName = 'protein') then
        value.protein := ParseReference(child, path+'/protein')
      else if (child.localName = 'sourceMaterial') then
        value.sourceMaterial := ParseSubstanceDefinitionSourceMaterial(child, path+'/sourceMaterial')
      else if Not ParseDomainResourceChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeSubstanceDefinition(xml : TXmlBuilder; name : String; value : TFhirSubstanceDefinition);
begin
  if (value = nil) then
    exit;
  composeDomainResourceAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeSubstanceDefinitionChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeSubstanceDefinitionChildren(xml : TXmlBuilder; value : TFhirSubstanceDefinition);
var
  i : integer;
begin
  composeDomainResourceChildren(xml, value);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.identifierList.Count - 1 do
      ComposeIdentifier(xml, 'identifier', value.identifierList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(xml, 'version', value.versionElement);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(xml, 'status', value.status);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.classificationList.Count - 1 do
      ComposeCodeableConcept(xml, 'classification', value.classificationList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(xml, 'domain', value.domain);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.gradeList.Count - 1 do
      ComposeCodeableConcept(xml, 'grade', value.gradeList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeMarkdown(xml, 'description', value.descriptionElement);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.informationSourceList.Count - 1 do
      ComposeReference(xml, 'informationSource', value.informationSourceList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.noteList.Count - 1 do
      ComposeAnnotation(xml, 'note', value.noteList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.manufacturerList.Count - 1 do
      ComposeReference(xml, 'manufacturer', value.manufacturerList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.supplierList.Count - 1 do
      ComposeReference(xml, 'supplier', value.supplierList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.moietyList.Count - 1 do
      ComposeSubstanceDefinitionMoiety(xml, 'moiety', value.moietyList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.property_List.Count - 1 do
      ComposeSubstanceDefinitionProperty(xml, 'property', value.property_List[i]);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference(xml, 'referenceInformation', value.referenceInformation);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.molecularWeightList.Count - 1 do
      ComposeSubstanceDefinitionMolecularWeight(xml, 'molecularWeight', value.molecularWeightList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeSubstanceDefinitionStructure(xml, 'structure', value.structure);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.codeList.Count - 1 do
      ComposeSubstanceDefinitionCode(xml, 'code', value.codeList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.nameList.Count - 1 do
      ComposeSubstanceDefinitionName(xml, 'name', value.nameList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.relationshipList.Count - 1 do
      ComposeSubstanceDefinitionRelationship(xml, 'relationship', value.relationshipList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference(xml, 'nucleicAcid', value.nucleicAcid);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference(xml, 'polymer', value.polymer);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference(xml, 'protein', value.protein);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeSubstanceDefinitionSourceMaterial(xml, 'sourceMaterial', value.sourceMaterial);
end;

{$ENDIF FHIR_SUBSTANCEDEFINITION}
{$IFDEF FHIR_SUBSTANCENUCLEICACID}
function TFHIRXmlParser.ParseSubstanceNucleicAcidSubunit(element : TMXmlElement; path : string) : TFhirSubstanceNucleicAcidSubunit;
var
  child : TMXmlElement;
begin
  result := TFhirSubstanceNucleicAcidSubunit.Create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseSubstanceNucleicAcidSubunitChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseSubstanceNucleicAcidSubunitChild(value : TFhirSubstanceNucleicAcidSubunit; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'subunit') then
        value.subunitElement := ParseInteger(child, path+'/subunit')
      else if (child.localName = 'sequence') then
        value.sequenceElement := ParseString(child, path+'/sequence')
      else if (child.localName = 'length') then
        value.lengthElement := ParseInteger(child, path+'/length')
      else if (child.localName = 'sequenceAttachment') then
        value.sequenceAttachment := ParseAttachment(child, path+'/sequenceAttachment')
      else if (child.localName = 'fivePrime') then
        value.fivePrime := ParseCodeableConcept(child, path+'/fivePrime')
      else if (child.localName = 'threePrime') then
        value.threePrime := ParseCodeableConcept(child, path+'/threePrime')
      else if (child.localName = 'linkage') then
        value.linkageList.Add(ParseSubstanceNucleicAcidSubunitLinkage(child, path+'/linkage'))
      else if (child.localName = 'sugar') then
        value.sugarList.Add(ParseSubstanceNucleicAcidSubunitSugar(child, path+'/sugar'))
      else if Not ParseBackboneElementChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeSubstanceNucleicAcidSubunit(xml : TXmlBuilder; name : String; value : TFhirSubstanceNucleicAcidSubunit);
begin
  if (value = nil) then
    exit;
  composeElementAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeSubstanceNucleicAcidSubunitChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeSubstanceNucleicAcidSubunitChildren(xml : TXmlBuilder; value : TFhirSubstanceNucleicAcidSubunit);
var
  i : integer;
begin
  composeBackboneElementChildren(xml, value);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeInteger(xml, 'subunit', value.subunitElement);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(xml, 'sequence', value.sequenceElement);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeInteger(xml, 'length', value.lengthElement);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeAttachment(xml, 'sequenceAttachment', value.sequenceAttachment);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(xml, 'fivePrime', value.fivePrime);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(xml, 'threePrime', value.threePrime);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.linkageList.Count - 1 do
      ComposeSubstanceNucleicAcidSubunitLinkage(xml, 'linkage', value.linkageList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.sugarList.Count - 1 do
      ComposeSubstanceNucleicAcidSubunitSugar(xml, 'sugar', value.sugarList[i]);
end;

function TFHIRXmlParser.ParseSubstanceNucleicAcidSubunitLinkage(element : TMXmlElement; path : string) : TFhirSubstanceNucleicAcidSubunitLinkage;
var
  child : TMXmlElement;
begin
  result := TFhirSubstanceNucleicAcidSubunitLinkage.Create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseSubstanceNucleicAcidSubunitLinkageChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseSubstanceNucleicAcidSubunitLinkageChild(value : TFhirSubstanceNucleicAcidSubunitLinkage; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'connectivity') then
        value.connectivityElement := ParseString(child, path+'/connectivity')
      else if (child.localName = 'identifier') then
        value.identifier := ParseIdentifier(child, path+'/identifier')
      else if (child.localName = 'name') then
        value.nameElement := ParseString(child, path+'/name')
      else if (child.localName = 'residueSite') then
        value.residueSiteElement := ParseString(child, path+'/residueSite')
      else if Not ParseBackboneElementChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeSubstanceNucleicAcidSubunitLinkage(xml : TXmlBuilder; name : String; value : TFhirSubstanceNucleicAcidSubunitLinkage);
begin
  if (value = nil) then
    exit;
  composeElementAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeSubstanceNucleicAcidSubunitLinkageChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeSubstanceNucleicAcidSubunitLinkageChildren(xml : TXmlBuilder; value : TFhirSubstanceNucleicAcidSubunitLinkage);
begin
  composeBackboneElementChildren(xml, value);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(xml, 'connectivity', value.connectivityElement);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeIdentifier(xml, 'identifier', value.identifier);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(xml, 'name', value.nameElement);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(xml, 'residueSite', value.residueSiteElement);
end;

function TFHIRXmlParser.ParseSubstanceNucleicAcidSubunitSugar(element : TMXmlElement; path : string) : TFhirSubstanceNucleicAcidSubunitSugar;
var
  child : TMXmlElement;
begin
  result := TFhirSubstanceNucleicAcidSubunitSugar.Create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseSubstanceNucleicAcidSubunitSugarChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseSubstanceNucleicAcidSubunitSugarChild(value : TFhirSubstanceNucleicAcidSubunitSugar; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'identifier') then
        value.identifier := ParseIdentifier(child, path+'/identifier')
      else if (child.localName = 'name') then
        value.nameElement := ParseString(child, path+'/name')
      else if (child.localName = 'residueSite') then
        value.residueSiteElement := ParseString(child, path+'/residueSite')
      else if Not ParseBackboneElementChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeSubstanceNucleicAcidSubunitSugar(xml : TXmlBuilder; name : String; value : TFhirSubstanceNucleicAcidSubunitSugar);
begin
  if (value = nil) then
    exit;
  composeElementAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeSubstanceNucleicAcidSubunitSugarChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeSubstanceNucleicAcidSubunitSugarChildren(xml : TXmlBuilder; value : TFhirSubstanceNucleicAcidSubunitSugar);
begin
  composeBackboneElementChildren(xml, value);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeIdentifier(xml, 'identifier', value.identifier);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(xml, 'name', value.nameElement);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(xml, 'residueSite', value.residueSiteElement);
end;

function TFHIRXmlParser.ParseSubstanceNucleicAcid(element : TMXmlElement; path : string) : TFhirSubstanceNucleicAcid;
var
  child : TMXmlElement;
begin
  result := TFhirSubstanceNucleicAcid.Create;
  try
    parseDomainResourceAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseSubstanceNucleicAcidChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseSubstanceNucleicAcidChild(value : TFhirSubstanceNucleicAcid; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'sequenceType') then
        value.sequenceType := ParseCodeableConcept(child, path+'/sequenceType')
      else if (child.localName = 'numberOfSubunits') then
        value.numberOfSubunitsElement := ParseInteger(child, path+'/numberOfSubunits')
      else if (child.localName = 'areaOfHybridisation') then
        value.areaOfHybridisationElement := ParseString(child, path+'/areaOfHybridisation')
      else if (child.localName = 'oligoNucleotideType') then
        value.oligoNucleotideType := ParseCodeableConcept(child, path+'/oligoNucleotideType')
      else if (child.localName = 'subunit') then
        value.subunitList.Add(ParseSubstanceNucleicAcidSubunit(child, path+'/subunit'))
      else if Not ParseDomainResourceChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeSubstanceNucleicAcid(xml : TXmlBuilder; name : String; value : TFhirSubstanceNucleicAcid);
begin
  if (value = nil) then
    exit;
  composeDomainResourceAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeSubstanceNucleicAcidChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeSubstanceNucleicAcidChildren(xml : TXmlBuilder; value : TFhirSubstanceNucleicAcid);
var
  i : integer;
begin
  composeDomainResourceChildren(xml, value);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(xml, 'sequenceType', value.sequenceType);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeInteger(xml, 'numberOfSubunits', value.numberOfSubunitsElement);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(xml, 'areaOfHybridisation', value.areaOfHybridisationElement);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(xml, 'oligoNucleotideType', value.oligoNucleotideType);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.subunitList.Count - 1 do
      ComposeSubstanceNucleicAcidSubunit(xml, 'subunit', value.subunitList[i]);
end;

{$ENDIF FHIR_SUBSTANCENUCLEICACID}
{$IFDEF FHIR_SUBSTANCEPOLYMER}
function TFHIRXmlParser.ParseSubstancePolymerMonomerSet(element : TMXmlElement; path : string) : TFhirSubstancePolymerMonomerSet;
var
  child : TMXmlElement;
begin
  result := TFhirSubstancePolymerMonomerSet.Create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseSubstancePolymerMonomerSetChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseSubstancePolymerMonomerSetChild(value : TFhirSubstancePolymerMonomerSet; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'ratioType') then
        value.ratioType := ParseCodeableConcept(child, path+'/ratioType')
      else if (child.localName = 'startingMaterial') then
        value.startingMaterialList.Add(ParseSubstancePolymerMonomerSetStartingMaterial(child, path+'/startingMaterial'))
      else if Not ParseBackboneElementChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeSubstancePolymerMonomerSet(xml : TXmlBuilder; name : String; value : TFhirSubstancePolymerMonomerSet);
begin
  if (value = nil) then
    exit;
  composeElementAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeSubstancePolymerMonomerSetChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeSubstancePolymerMonomerSetChildren(xml : TXmlBuilder; value : TFhirSubstancePolymerMonomerSet);
var
  i : integer;
begin
  composeBackboneElementChildren(xml, value);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(xml, 'ratioType', value.ratioType);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.startingMaterialList.Count - 1 do
      ComposeSubstancePolymerMonomerSetStartingMaterial(xml, 'startingMaterial', value.startingMaterialList[i]);
end;

function TFHIRXmlParser.ParseSubstancePolymerMonomerSetStartingMaterial(element : TMXmlElement; path : string) : TFhirSubstancePolymerMonomerSetStartingMaterial;
var
  child : TMXmlElement;
begin
  result := TFhirSubstancePolymerMonomerSetStartingMaterial.Create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseSubstancePolymerMonomerSetStartingMaterialChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseSubstancePolymerMonomerSetStartingMaterialChild(value : TFhirSubstancePolymerMonomerSetStartingMaterial; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'code') then
        value.code := ParseCodeableConcept(child, path+'/code')
      else if (child.localName = 'category') then
        value.category := ParseCodeableConcept(child, path+'/category')
      else if (child.localName = 'isDefining') then
        value.isDefiningElement := ParseBoolean(child, path+'/isDefining')
      else if (child.localName = 'amount') then
        value.amount := ParseQuantity(child, path+'/amount')
      else if Not ParseBackboneElementChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeSubstancePolymerMonomerSetStartingMaterial(xml : TXmlBuilder; name : String; value : TFhirSubstancePolymerMonomerSetStartingMaterial);
begin
  if (value = nil) then
    exit;
  composeElementAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeSubstancePolymerMonomerSetStartingMaterialChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeSubstancePolymerMonomerSetStartingMaterialChildren(xml : TXmlBuilder; value : TFhirSubstancePolymerMonomerSetStartingMaterial);
begin
  composeBackboneElementChildren(xml, value);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(xml, 'code', value.code);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(xml, 'category', value.category);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeBoolean(xml, 'isDefining', value.isDefiningElement);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeQuantity(xml, 'amount', value.amount);
end;

function TFHIRXmlParser.ParseSubstancePolymerRepeat(element : TMXmlElement; path : string) : TFhirSubstancePolymerRepeat;
var
  child : TMXmlElement;
begin
  result := TFhirSubstancePolymerRepeat.Create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseSubstancePolymerRepeatChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseSubstancePolymerRepeatChild(value : TFhirSubstancePolymerRepeat; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'averageMolecularFormula') then
        value.averageMolecularFormulaElement := ParseString(child, path+'/averageMolecularFormula')
      else if (child.localName = 'repeatUnitAmountType') then
        value.repeatUnitAmountType := ParseCodeableConcept(child, path+'/repeatUnitAmountType')
      else if (child.localName = 'repeatUnit') then
        value.repeatUnitList.Add(ParseSubstancePolymerRepeatRepeatUnit(child, path+'/repeatUnit'))
      else if Not ParseBackboneElementChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeSubstancePolymerRepeat(xml : TXmlBuilder; name : String; value : TFhirSubstancePolymerRepeat);
begin
  if (value = nil) then
    exit;
  composeElementAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeSubstancePolymerRepeatChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeSubstancePolymerRepeatChildren(xml : TXmlBuilder; value : TFhirSubstancePolymerRepeat);
var
  i : integer;
begin
  composeBackboneElementChildren(xml, value);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(xml, 'averageMolecularFormula', value.averageMolecularFormulaElement);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(xml, 'repeatUnitAmountType', value.repeatUnitAmountType);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.repeatUnitList.Count - 1 do
      ComposeSubstancePolymerRepeatRepeatUnit(xml, 'repeatUnit', value.repeatUnitList[i]);
end;

function TFHIRXmlParser.ParseSubstancePolymerRepeatRepeatUnit(element : TMXmlElement; path : string) : TFhirSubstancePolymerRepeatRepeatUnit;
var
  child : TMXmlElement;
begin
  result := TFhirSubstancePolymerRepeatRepeatUnit.Create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseSubstancePolymerRepeatRepeatUnitChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseSubstancePolymerRepeatRepeatUnitChild(value : TFhirSubstancePolymerRepeatRepeatUnit; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'unit') then
        value.unit_Element := ParseString(child, path+'/unit')
      else if (child.localName = 'orientation') then
        value.orientation := ParseCodeableConcept(child, path+'/orientation')
      else if (child.localName = 'amount') then
        value.amountElement := ParseInteger(child, path+'/amount')
      else if (child.localName = 'degreeOfPolymerisation') then
        value.degreeOfPolymerisationList.Add(ParseSubstancePolymerRepeatRepeatUnitDegreeOfPolymerisation(child, path+'/degreeOfPolymerisation'))
      else if (child.localName = 'structuralRepresentation') then
        value.structuralRepresentationList.Add(ParseSubstancePolymerRepeatRepeatUnitStructuralRepresentation(child, path+'/structuralRepresentation'))
      else if Not ParseBackboneElementChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeSubstancePolymerRepeatRepeatUnit(xml : TXmlBuilder; name : String; value : TFhirSubstancePolymerRepeatRepeatUnit);
begin
  if (value = nil) then
    exit;
  composeElementAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeSubstancePolymerRepeatRepeatUnitChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeSubstancePolymerRepeatRepeatUnitChildren(xml : TXmlBuilder; value : TFhirSubstancePolymerRepeatRepeatUnit);
var
  i : integer;
begin
  composeBackboneElementChildren(xml, value);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(xml, 'unit', value.unit_Element);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(xml, 'orientation', value.orientation);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeInteger(xml, 'amount', value.amountElement);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.degreeOfPolymerisationList.Count - 1 do
      ComposeSubstancePolymerRepeatRepeatUnitDegreeOfPolymerisation(xml, 'degreeOfPolymerisation', value.degreeOfPolymerisationList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.structuralRepresentationList.Count - 1 do
      ComposeSubstancePolymerRepeatRepeatUnitStructuralRepresentation(xml, 'structuralRepresentation', value.structuralRepresentationList[i]);
end;

function TFHIRXmlParser.ParseSubstancePolymerRepeatRepeatUnitDegreeOfPolymerisation(element : TMXmlElement; path : string) : TFhirSubstancePolymerRepeatRepeatUnitDegreeOfPolymerisation;
var
  child : TMXmlElement;
begin
  result := TFhirSubstancePolymerRepeatRepeatUnitDegreeOfPolymerisation.Create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseSubstancePolymerRepeatRepeatUnitDegreeOfPolymerisationChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseSubstancePolymerRepeatRepeatUnitDegreeOfPolymerisationChild(value : TFhirSubstancePolymerRepeatRepeatUnitDegreeOfPolymerisation; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'type') then
        value.type_ := ParseCodeableConcept(child, path+'/type')
      else if (child.localName = 'average') then
        value.averageElement := ParseInteger(child, path+'/average')
      else if (child.localName = 'low') then
        value.lowElement := ParseInteger(child, path+'/low')
      else if (child.localName = 'high') then
        value.highElement := ParseInteger(child, path+'/high')
      else if Not ParseBackboneElementChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeSubstancePolymerRepeatRepeatUnitDegreeOfPolymerisation(xml : TXmlBuilder; name : String; value : TFhirSubstancePolymerRepeatRepeatUnitDegreeOfPolymerisation);
begin
  if (value = nil) then
    exit;
  composeElementAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeSubstancePolymerRepeatRepeatUnitDegreeOfPolymerisationChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeSubstancePolymerRepeatRepeatUnitDegreeOfPolymerisationChildren(xml : TXmlBuilder; value : TFhirSubstancePolymerRepeatRepeatUnitDegreeOfPolymerisation);
begin
  composeBackboneElementChildren(xml, value);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(xml, 'type', value.type_);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeInteger(xml, 'average', value.averageElement);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeInteger(xml, 'low', value.lowElement);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeInteger(xml, 'high', value.highElement);
end;

function TFHIRXmlParser.ParseSubstancePolymerRepeatRepeatUnitStructuralRepresentation(element : TMXmlElement; path : string) : TFhirSubstancePolymerRepeatRepeatUnitStructuralRepresentation;
var
  child : TMXmlElement;
begin
  result := TFhirSubstancePolymerRepeatRepeatUnitStructuralRepresentation.Create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseSubstancePolymerRepeatRepeatUnitStructuralRepresentationChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseSubstancePolymerRepeatRepeatUnitStructuralRepresentationChild(value : TFhirSubstancePolymerRepeatRepeatUnitStructuralRepresentation; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'type') then
        value.type_ := ParseCodeableConcept(child, path+'/type')
      else if (child.localName = 'representation') then
        value.representationElement := ParseString(child, path+'/representation')
      else if (child.localName = 'format') then
        value.format := ParseCodeableConcept(child, path+'/format')
      else if (child.localName = 'attachment') then
        value.attachment := ParseAttachment(child, path+'/attachment')
      else if Not ParseBackboneElementChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeSubstancePolymerRepeatRepeatUnitStructuralRepresentation(xml : TXmlBuilder; name : String; value : TFhirSubstancePolymerRepeatRepeatUnitStructuralRepresentation);
begin
  if (value = nil) then
    exit;
  composeElementAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeSubstancePolymerRepeatRepeatUnitStructuralRepresentationChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeSubstancePolymerRepeatRepeatUnitStructuralRepresentationChildren(xml : TXmlBuilder; value : TFhirSubstancePolymerRepeatRepeatUnitStructuralRepresentation);
begin
  composeBackboneElementChildren(xml, value);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(xml, 'type', value.type_);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(xml, 'representation', value.representationElement);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(xml, 'format', value.format);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeAttachment(xml, 'attachment', value.attachment);
end;

function TFHIRXmlParser.ParseSubstancePolymer(element : TMXmlElement; path : string) : TFhirSubstancePolymer;
var
  child : TMXmlElement;
begin
  result := TFhirSubstancePolymer.Create;
  try
    parseDomainResourceAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseSubstancePolymerChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseSubstancePolymerChild(value : TFhirSubstancePolymer; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'identifier') then
        value.identifier := ParseIdentifier(child, path+'/identifier')
      else if (child.localName = 'class') then
        value.class_ := ParseCodeableConcept(child, path+'/class')
      else if (child.localName = 'geometry') then
        value.geometry := ParseCodeableConcept(child, path+'/geometry')
      else if (child.localName = 'copolymerConnectivity') then
        value.copolymerConnectivityList.Add(ParseCodeableConcept(child, path+'/copolymerConnectivity'))
      else if (child.localName = 'modification') then
        value.modificationElement := ParseString(child, path+'/modification')
      else if (child.localName = 'monomerSet') then
        value.monomerSetList.Add(ParseSubstancePolymerMonomerSet(child, path+'/monomerSet'))
      else if (child.localName = 'repeat') then
        value.repeat_List.Add(ParseSubstancePolymerRepeat(child, path+'/repeat'))
      else if Not ParseDomainResourceChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeSubstancePolymer(xml : TXmlBuilder; name : String; value : TFhirSubstancePolymer);
begin
  if (value = nil) then
    exit;
  composeDomainResourceAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeSubstancePolymerChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeSubstancePolymerChildren(xml : TXmlBuilder; value : TFhirSubstancePolymer);
var
  i : integer;
begin
  composeDomainResourceChildren(xml, value);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeIdentifier(xml, 'identifier', value.identifier);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(xml, 'class', value.class_);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(xml, 'geometry', value.geometry);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.copolymerConnectivityList.Count - 1 do
      ComposeCodeableConcept(xml, 'copolymerConnectivity', value.copolymerConnectivityList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(xml, 'modification', value.modificationElement);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.monomerSetList.Count - 1 do
      ComposeSubstancePolymerMonomerSet(xml, 'monomerSet', value.monomerSetList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.repeat_List.Count - 1 do
      ComposeSubstancePolymerRepeat(xml, 'repeat', value.repeat_List[i]);
end;

{$ENDIF FHIR_SUBSTANCEPOLYMER}
{$IFDEF FHIR_SUBSTANCEPROTEIN}
function TFHIRXmlParser.ParseSubstanceProteinSubunit(element : TMXmlElement; path : string) : TFhirSubstanceProteinSubunit;
var
  child : TMXmlElement;
begin
  result := TFhirSubstanceProteinSubunit.Create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseSubstanceProteinSubunitChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseSubstanceProteinSubunitChild(value : TFhirSubstanceProteinSubunit; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'subunit') then
        value.subunitElement := ParseInteger(child, path+'/subunit')
      else if (child.localName = 'sequence') then
        value.sequenceElement := ParseString(child, path+'/sequence')
      else if (child.localName = 'length') then
        value.lengthElement := ParseInteger(child, path+'/length')
      else if (child.localName = 'sequenceAttachment') then
        value.sequenceAttachment := ParseAttachment(child, path+'/sequenceAttachment')
      else if (child.localName = 'nTerminalModificationId') then
        value.nTerminalModificationId := ParseIdentifier(child, path+'/nTerminalModificationId')
      else if (child.localName = 'nTerminalModification') then
        value.nTerminalModificationElement := ParseString(child, path+'/nTerminalModification')
      else if (child.localName = 'cTerminalModificationId') then
        value.cTerminalModificationId := ParseIdentifier(child, path+'/cTerminalModificationId')
      else if (child.localName = 'cTerminalModification') then
        value.cTerminalModificationElement := ParseString(child, path+'/cTerminalModification')
      else if Not ParseBackboneElementChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeSubstanceProteinSubunit(xml : TXmlBuilder; name : String; value : TFhirSubstanceProteinSubunit);
begin
  if (value = nil) then
    exit;
  composeElementAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeSubstanceProteinSubunitChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeSubstanceProteinSubunitChildren(xml : TXmlBuilder; value : TFhirSubstanceProteinSubunit);
begin
  composeBackboneElementChildren(xml, value);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeInteger(xml, 'subunit', value.subunitElement);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(xml, 'sequence', value.sequenceElement);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeInteger(xml, 'length', value.lengthElement);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeAttachment(xml, 'sequenceAttachment', value.sequenceAttachment);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeIdentifier(xml, 'nTerminalModificationId', value.nTerminalModificationId);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(xml, 'nTerminalModification', value.nTerminalModificationElement);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeIdentifier(xml, 'cTerminalModificationId', value.cTerminalModificationId);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(xml, 'cTerminalModification', value.cTerminalModificationElement);
end;

function TFHIRXmlParser.ParseSubstanceProtein(element : TMXmlElement; path : string) : TFhirSubstanceProtein;
var
  child : TMXmlElement;
begin
  result := TFhirSubstanceProtein.Create;
  try
    parseDomainResourceAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseSubstanceProteinChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseSubstanceProteinChild(value : TFhirSubstanceProtein; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'sequenceType') then
        value.sequenceType := ParseCodeableConcept(child, path+'/sequenceType')
      else if (child.localName = 'numberOfSubunits') then
        value.numberOfSubunitsElement := ParseInteger(child, path+'/numberOfSubunits')
      else if (child.localName = 'disulfideLinkage') then
        value.disulfideLinkageList.Add(ParseString(child, path+'/disulfideLinkage'))
      else if (child.localName = 'subunit') then
        value.subunitList.Add(ParseSubstanceProteinSubunit(child, path+'/subunit'))
      else if Not ParseDomainResourceChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeSubstanceProtein(xml : TXmlBuilder; name : String; value : TFhirSubstanceProtein);
begin
  if (value = nil) then
    exit;
  composeDomainResourceAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeSubstanceProteinChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeSubstanceProteinChildren(xml : TXmlBuilder; value : TFhirSubstanceProtein);
var
  i : integer;
begin
  composeDomainResourceChildren(xml, value);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(xml, 'sequenceType', value.sequenceType);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeInteger(xml, 'numberOfSubunits', value.numberOfSubunitsElement);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.disulfideLinkageList.Count - 1 do
      ComposeString(xml, 'disulfideLinkage', value.disulfideLinkageList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.subunitList.Count - 1 do
      ComposeSubstanceProteinSubunit(xml, 'subunit', value.subunitList[i]);
end;

{$ENDIF FHIR_SUBSTANCEPROTEIN}
{$IFDEF FHIR_SUBSTANCEREFERENCEINFORMATION}
function TFHIRXmlParser.ParseSubstanceReferenceInformationGene(element : TMXmlElement; path : string) : TFhirSubstanceReferenceInformationGene;
var
  child : TMXmlElement;
begin
  result := TFhirSubstanceReferenceInformationGene.Create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseSubstanceReferenceInformationGeneChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseSubstanceReferenceInformationGeneChild(value : TFhirSubstanceReferenceInformationGene; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'geneSequenceOrigin') then
        value.geneSequenceOrigin := ParseCodeableConcept(child, path+'/geneSequenceOrigin')
      else if (child.localName = 'gene') then
        value.gene := ParseCodeableConcept(child, path+'/gene')
      else if (child.localName = 'source') then
        value.sourceList.Add(ParseReference(child, path+'/source'))
      else if Not ParseBackboneElementChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeSubstanceReferenceInformationGene(xml : TXmlBuilder; name : String; value : TFhirSubstanceReferenceInformationGene);
begin
  if (value = nil) then
    exit;
  composeElementAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeSubstanceReferenceInformationGeneChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeSubstanceReferenceInformationGeneChildren(xml : TXmlBuilder; value : TFhirSubstanceReferenceInformationGene);
var
  i : integer;
begin
  composeBackboneElementChildren(xml, value);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(xml, 'geneSequenceOrigin', value.geneSequenceOrigin);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(xml, 'gene', value.gene);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.sourceList.Count - 1 do
      ComposeReference(xml, 'source', value.sourceList[i]);
end;

function TFHIRXmlParser.ParseSubstanceReferenceInformationGeneElement(element : TMXmlElement; path : string) : TFhirSubstanceReferenceInformationGeneElement;
var
  child : TMXmlElement;
begin
  result := TFhirSubstanceReferenceInformationGeneElement.Create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseSubstanceReferenceInformationGeneElementChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseSubstanceReferenceInformationGeneElementChild(value : TFhirSubstanceReferenceInformationGeneElement; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'type') then
        value.type_ := ParseCodeableConcept(child, path+'/type')
      else if (child.localName = 'element') then
        value.element := ParseIdentifier(child, path+'/element')
      else if (child.localName = 'source') then
        value.sourceList.Add(ParseReference(child, path+'/source'))
      else if Not ParseBackboneElementChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeSubstanceReferenceInformationGeneElement(xml : TXmlBuilder; name : String; value : TFhirSubstanceReferenceInformationGeneElement);
begin
  if (value = nil) then
    exit;
  composeElementAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeSubstanceReferenceInformationGeneElementChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeSubstanceReferenceInformationGeneElementChildren(xml : TXmlBuilder; value : TFhirSubstanceReferenceInformationGeneElement);
var
  i : integer;
begin
  composeBackboneElementChildren(xml, value);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(xml, 'type', value.type_);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeIdentifier(xml, 'element', value.element);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.sourceList.Count - 1 do
      ComposeReference(xml, 'source', value.sourceList[i]);
end;

function TFHIRXmlParser.ParseSubstanceReferenceInformationTarget(element : TMXmlElement; path : string) : TFhirSubstanceReferenceInformationTarget;
var
  child : TMXmlElement;
begin
  result := TFhirSubstanceReferenceInformationTarget.Create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseSubstanceReferenceInformationTargetChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseSubstanceReferenceInformationTargetChild(value : TFhirSubstanceReferenceInformationTarget; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'target') then
        value.target := ParseIdentifier(child, path+'/target')
      else if (child.localName = 'type') then
        value.type_ := ParseCodeableConcept(child, path+'/type')
      else if (child.localName = 'interaction') then
        value.interaction := ParseCodeableConcept(child, path+'/interaction')
      else if (child.localName = 'organism') then
        value.organism := ParseCodeableConcept(child, path+'/organism')
      else if (child.localName = 'organismType') then
        value.organismType := ParseCodeableConcept(child, path+'/organismType')
      else if (child.localName = 'amountQuantity') then
        value.amount := ParseQuantity(child, path+'/amountQuantity')
      else if (child.localName = 'amountRange') then
        value.amount := ParseRange(child, path+'/amountRange')
      else if (child.localName = 'amountString') then
        value.amount := ParseString(child, path+'/amountString')
      else if (child.localName = 'amountType') then
        value.amountType := ParseCodeableConcept(child, path+'/amountType')
      else if (child.localName = 'source') then
        value.sourceList.Add(ParseReference(child, path+'/source'))
      else if Not ParseBackboneElementChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeSubstanceReferenceInformationTarget(xml : TXmlBuilder; name : String; value : TFhirSubstanceReferenceInformationTarget);
begin
  if (value = nil) then
    exit;
  composeElementAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeSubstanceReferenceInformationTargetChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeSubstanceReferenceInformationTargetChildren(xml : TXmlBuilder; value : TFhirSubstanceReferenceInformationTarget);
var
  i : integer;
begin
  composeBackboneElementChildren(xml, value);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeIdentifier(xml, 'target', value.target);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(xml, 'type', value.type_);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(xml, 'interaction', value.interaction);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(xml, 'organism', value.organism);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(xml, 'organismType', value.organismType);
  if (SummaryOption in [soFull, soSummary, soData]) and (value.amount is TFhirQuantity) {6} then
    ComposeQuantity(xml, 'amountQuantity', TFhirQuantity(value.amount))
  else if (SummaryOption in [soFull, soSummary, soData]) and (value.amount is TFhirRange) {6} then
    ComposeRange(xml, 'amountRange', TFhirRange(value.amount))
  else if (SummaryOption in [soFull, soSummary, soData]) and (value.amount is TFhirString) {6} then
    ComposeString(xml, 'amountString', TFhirString(value.amount));
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(xml, 'amountType', value.amountType);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.sourceList.Count - 1 do
      ComposeReference(xml, 'source', value.sourceList[i]);
end;

function TFHIRXmlParser.ParseSubstanceReferenceInformation(element : TMXmlElement; path : string) : TFhirSubstanceReferenceInformation;
var
  child : TMXmlElement;
begin
  result := TFhirSubstanceReferenceInformation.Create;
  try
    parseDomainResourceAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseSubstanceReferenceInformationChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseSubstanceReferenceInformationChild(value : TFhirSubstanceReferenceInformation; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'comment') then
        value.commentElement := ParseString(child, path+'/comment')
      else if (child.localName = 'gene') then
        value.geneList.Add(ParseSubstanceReferenceInformationGene(child, path+'/gene'))
      else if (child.localName = 'geneElement') then
        value.geneElementList.Add(ParseSubstanceReferenceInformationGeneElement(child, path+'/geneElement'))
      else if (child.localName = 'target') then
        value.targetList.Add(ParseSubstanceReferenceInformationTarget(child, path+'/target'))
      else if Not ParseDomainResourceChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeSubstanceReferenceInformation(xml : TXmlBuilder; name : String; value : TFhirSubstanceReferenceInformation);
begin
  if (value = nil) then
    exit;
  composeDomainResourceAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeSubstanceReferenceInformationChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeSubstanceReferenceInformationChildren(xml : TXmlBuilder; value : TFhirSubstanceReferenceInformation);
var
  i : integer;
begin
  composeDomainResourceChildren(xml, value);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(xml, 'comment', value.commentElement);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.geneList.Count - 1 do
      ComposeSubstanceReferenceInformationGene(xml, 'gene', value.geneList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.geneElementList.Count - 1 do
      ComposeSubstanceReferenceInformationGeneElement(xml, 'geneElement', value.geneElementList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.targetList.Count - 1 do
      ComposeSubstanceReferenceInformationTarget(xml, 'target', value.targetList[i]);
end;

{$ENDIF FHIR_SUBSTANCEREFERENCEINFORMATION}
{$IFDEF FHIR_SUBSTANCESOURCEMATERIAL}
function TFHIRXmlParser.ParseSubstanceSourceMaterialFractionDescription(element : TMXmlElement; path : string) : TFhirSubstanceSourceMaterialFractionDescription;
var
  child : TMXmlElement;
begin
  result := TFhirSubstanceSourceMaterialFractionDescription.Create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseSubstanceSourceMaterialFractionDescriptionChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseSubstanceSourceMaterialFractionDescriptionChild(value : TFhirSubstanceSourceMaterialFractionDescription; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'fraction') then
        value.fractionElement := ParseString(child, path+'/fraction')
      else if (child.localName = 'materialType') then
        value.materialType := ParseCodeableConcept(child, path+'/materialType')
      else if Not ParseBackboneElementChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeSubstanceSourceMaterialFractionDescription(xml : TXmlBuilder; name : String; value : TFhirSubstanceSourceMaterialFractionDescription);
begin
  if (value = nil) then
    exit;
  composeElementAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeSubstanceSourceMaterialFractionDescriptionChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeSubstanceSourceMaterialFractionDescriptionChildren(xml : TXmlBuilder; value : TFhirSubstanceSourceMaterialFractionDescription);
begin
  composeBackboneElementChildren(xml, value);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(xml, 'fraction', value.fractionElement);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(xml, 'materialType', value.materialType);
end;

function TFHIRXmlParser.ParseSubstanceSourceMaterialOrganism(element : TMXmlElement; path : string) : TFhirSubstanceSourceMaterialOrganism;
var
  child : TMXmlElement;
begin
  result := TFhirSubstanceSourceMaterialOrganism.Create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseSubstanceSourceMaterialOrganismChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseSubstanceSourceMaterialOrganismChild(value : TFhirSubstanceSourceMaterialOrganism; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'family') then
        value.family := ParseCodeableConcept(child, path+'/family')
      else if (child.localName = 'genus') then
        value.genus := ParseCodeableConcept(child, path+'/genus')
      else if (child.localName = 'species') then
        value.species := ParseCodeableConcept(child, path+'/species')
      else if (child.localName = 'intraspecificType') then
        value.intraspecificType := ParseCodeableConcept(child, path+'/intraspecificType')
      else if (child.localName = 'intraspecificDescription') then
        value.intraspecificDescriptionElement := ParseString(child, path+'/intraspecificDescription')
      else if (child.localName = 'author') then
        value.authorList.Add(ParseSubstanceSourceMaterialOrganismAuthor(child, path+'/author'))
      else if (child.localName = 'hybrid') then
        value.hybrid := ParseSubstanceSourceMaterialOrganismHybrid(child, path+'/hybrid')
      else if (child.localName = 'organismGeneral') then
        value.organismGeneral := ParseSubstanceSourceMaterialOrganismOrganismGeneral(child, path+'/organismGeneral')
      else if Not ParseBackboneElementChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeSubstanceSourceMaterialOrganism(xml : TXmlBuilder; name : String; value : TFhirSubstanceSourceMaterialOrganism);
begin
  if (value = nil) then
    exit;
  composeElementAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeSubstanceSourceMaterialOrganismChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeSubstanceSourceMaterialOrganismChildren(xml : TXmlBuilder; value : TFhirSubstanceSourceMaterialOrganism);
var
  i : integer;
begin
  composeBackboneElementChildren(xml, value);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(xml, 'family', value.family);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(xml, 'genus', value.genus);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(xml, 'species', value.species);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(xml, 'intraspecificType', value.intraspecificType);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(xml, 'intraspecificDescription', value.intraspecificDescriptionElement);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.authorList.Count - 1 do
      ComposeSubstanceSourceMaterialOrganismAuthor(xml, 'author', value.authorList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeSubstanceSourceMaterialOrganismHybrid(xml, 'hybrid', value.hybrid);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeSubstanceSourceMaterialOrganismOrganismGeneral(xml, 'organismGeneral', value.organismGeneral);
end;

function TFHIRXmlParser.ParseSubstanceSourceMaterialOrganismAuthor(element : TMXmlElement; path : string) : TFhirSubstanceSourceMaterialOrganismAuthor;
var
  child : TMXmlElement;
begin
  result := TFhirSubstanceSourceMaterialOrganismAuthor.Create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseSubstanceSourceMaterialOrganismAuthorChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseSubstanceSourceMaterialOrganismAuthorChild(value : TFhirSubstanceSourceMaterialOrganismAuthor; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'authorType') then
        value.authorType := ParseCodeableConcept(child, path+'/authorType')
      else if (child.localName = 'authorDescription') then
        value.authorDescriptionElement := ParseString(child, path+'/authorDescription')
      else if Not ParseBackboneElementChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeSubstanceSourceMaterialOrganismAuthor(xml : TXmlBuilder; name : String; value : TFhirSubstanceSourceMaterialOrganismAuthor);
begin
  if (value = nil) then
    exit;
  composeElementAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeSubstanceSourceMaterialOrganismAuthorChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeSubstanceSourceMaterialOrganismAuthorChildren(xml : TXmlBuilder; value : TFhirSubstanceSourceMaterialOrganismAuthor);
begin
  composeBackboneElementChildren(xml, value);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(xml, 'authorType', value.authorType);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(xml, 'authorDescription', value.authorDescriptionElement);
end;

function TFHIRXmlParser.ParseSubstanceSourceMaterialOrganismHybrid(element : TMXmlElement; path : string) : TFhirSubstanceSourceMaterialOrganismHybrid;
var
  child : TMXmlElement;
begin
  result := TFhirSubstanceSourceMaterialOrganismHybrid.Create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseSubstanceSourceMaterialOrganismHybridChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseSubstanceSourceMaterialOrganismHybridChild(value : TFhirSubstanceSourceMaterialOrganismHybrid; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'maternalOrganismId') then
        value.maternalOrganismIdElement := ParseString(child, path+'/maternalOrganismId')
      else if (child.localName = 'maternalOrganismName') then
        value.maternalOrganismNameElement := ParseString(child, path+'/maternalOrganismName')
      else if (child.localName = 'paternalOrganismId') then
        value.paternalOrganismIdElement := ParseString(child, path+'/paternalOrganismId')
      else if (child.localName = 'paternalOrganismName') then
        value.paternalOrganismNameElement := ParseString(child, path+'/paternalOrganismName')
      else if (child.localName = 'hybridType') then
        value.hybridType := ParseCodeableConcept(child, path+'/hybridType')
      else if Not ParseBackboneElementChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeSubstanceSourceMaterialOrganismHybrid(xml : TXmlBuilder; name : String; value : TFhirSubstanceSourceMaterialOrganismHybrid);
begin
  if (value = nil) then
    exit;
  composeElementAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeSubstanceSourceMaterialOrganismHybridChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeSubstanceSourceMaterialOrganismHybridChildren(xml : TXmlBuilder; value : TFhirSubstanceSourceMaterialOrganismHybrid);
begin
  composeBackboneElementChildren(xml, value);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(xml, 'maternalOrganismId', value.maternalOrganismIdElement);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(xml, 'maternalOrganismName', value.maternalOrganismNameElement);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(xml, 'paternalOrganismId', value.paternalOrganismIdElement);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(xml, 'paternalOrganismName', value.paternalOrganismNameElement);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(xml, 'hybridType', value.hybridType);
end;

function TFHIRXmlParser.ParseSubstanceSourceMaterialOrganismOrganismGeneral(element : TMXmlElement; path : string) : TFhirSubstanceSourceMaterialOrganismOrganismGeneral;
var
  child : TMXmlElement;
begin
  result := TFhirSubstanceSourceMaterialOrganismOrganismGeneral.Create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseSubstanceSourceMaterialOrganismOrganismGeneralChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseSubstanceSourceMaterialOrganismOrganismGeneralChild(value : TFhirSubstanceSourceMaterialOrganismOrganismGeneral; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'kingdom') then
        value.kingdom := ParseCodeableConcept(child, path+'/kingdom')
      else if (child.localName = 'phylum') then
        value.phylum := ParseCodeableConcept(child, path+'/phylum')
      else if (child.localName = 'class') then
        value.class_ := ParseCodeableConcept(child, path+'/class')
      else if (child.localName = 'order') then
        value.order := ParseCodeableConcept(child, path+'/order')
      else if Not ParseBackboneElementChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeSubstanceSourceMaterialOrganismOrganismGeneral(xml : TXmlBuilder; name : String; value : TFhirSubstanceSourceMaterialOrganismOrganismGeneral);
begin
  if (value = nil) then
    exit;
  composeElementAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeSubstanceSourceMaterialOrganismOrganismGeneralChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeSubstanceSourceMaterialOrganismOrganismGeneralChildren(xml : TXmlBuilder; value : TFhirSubstanceSourceMaterialOrganismOrganismGeneral);
begin
  composeBackboneElementChildren(xml, value);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(xml, 'kingdom', value.kingdom);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(xml, 'phylum', value.phylum);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(xml, 'class', value.class_);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(xml, 'order', value.order);
end;

function TFHIRXmlParser.ParseSubstanceSourceMaterialPartDescription(element : TMXmlElement; path : string) : TFhirSubstanceSourceMaterialPartDescription;
var
  child : TMXmlElement;
begin
  result := TFhirSubstanceSourceMaterialPartDescription.Create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseSubstanceSourceMaterialPartDescriptionChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseSubstanceSourceMaterialPartDescriptionChild(value : TFhirSubstanceSourceMaterialPartDescription; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'part') then
        value.part := ParseCodeableConcept(child, path+'/part')
      else if (child.localName = 'partLocation') then
        value.partLocation := ParseCodeableConcept(child, path+'/partLocation')
      else if Not ParseBackboneElementChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeSubstanceSourceMaterialPartDescription(xml : TXmlBuilder; name : String; value : TFhirSubstanceSourceMaterialPartDescription);
begin
  if (value = nil) then
    exit;
  composeElementAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeSubstanceSourceMaterialPartDescriptionChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeSubstanceSourceMaterialPartDescriptionChildren(xml : TXmlBuilder; value : TFhirSubstanceSourceMaterialPartDescription);
begin
  composeBackboneElementChildren(xml, value);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(xml, 'part', value.part);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(xml, 'partLocation', value.partLocation);
end;

function TFHIRXmlParser.ParseSubstanceSourceMaterial(element : TMXmlElement; path : string) : TFhirSubstanceSourceMaterial;
var
  child : TMXmlElement;
begin
  result := TFhirSubstanceSourceMaterial.Create;
  try
    parseDomainResourceAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseSubstanceSourceMaterialChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseSubstanceSourceMaterialChild(value : TFhirSubstanceSourceMaterial; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'sourceMaterialClass') then
        value.sourceMaterialClass := ParseCodeableConcept(child, path+'/sourceMaterialClass')
      else if (child.localName = 'sourceMaterialType') then
        value.sourceMaterialType := ParseCodeableConcept(child, path+'/sourceMaterialType')
      else if (child.localName = 'sourceMaterialState') then
        value.sourceMaterialState := ParseCodeableConcept(child, path+'/sourceMaterialState')
      else if (child.localName = 'organismId') then
        value.organismId := ParseIdentifier(child, path+'/organismId')
      else if (child.localName = 'organismName') then
        value.organismNameElement := ParseString(child, path+'/organismName')
      else if (child.localName = 'parentSubstanceId') then
        value.parentSubstanceIdList.Add(ParseIdentifier(child, path+'/parentSubstanceId'))
      else if (child.localName = 'parentSubstanceName') then
        value.parentSubstanceNameList.Add(ParseString(child, path+'/parentSubstanceName'))
      else if (child.localName = 'countryOfOrigin') then
        value.countryOfOriginList.Add(ParseCodeableConcept(child, path+'/countryOfOrigin'))
      else if (child.localName = 'geographicalLocation') then
        value.geographicalLocationList.Add(ParseString(child, path+'/geographicalLocation'))
      else if (child.localName = 'developmentStage') then
        value.developmentStage := ParseCodeableConcept(child, path+'/developmentStage')
      else if (child.localName = 'fractionDescription') then
        value.fractionDescriptionList.Add(ParseSubstanceSourceMaterialFractionDescription(child, path+'/fractionDescription'))
      else if (child.localName = 'organism') then
        value.organism := ParseSubstanceSourceMaterialOrganism(child, path+'/organism')
      else if (child.localName = 'partDescription') then
        value.partDescriptionList.Add(ParseSubstanceSourceMaterialPartDescription(child, path+'/partDescription'))
      else if Not ParseDomainResourceChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeSubstanceSourceMaterial(xml : TXmlBuilder; name : String; value : TFhirSubstanceSourceMaterial);
begin
  if (value = nil) then
    exit;
  composeDomainResourceAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeSubstanceSourceMaterialChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeSubstanceSourceMaterialChildren(xml : TXmlBuilder; value : TFhirSubstanceSourceMaterial);
var
  i : integer;
begin
  composeDomainResourceChildren(xml, value);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(xml, 'sourceMaterialClass', value.sourceMaterialClass);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(xml, 'sourceMaterialType', value.sourceMaterialType);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(xml, 'sourceMaterialState', value.sourceMaterialState);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeIdentifier(xml, 'organismId', value.organismId);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(xml, 'organismName', value.organismNameElement);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.parentSubstanceIdList.Count - 1 do
      ComposeIdentifier(xml, 'parentSubstanceId', value.parentSubstanceIdList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.parentSubstanceNameList.Count - 1 do
      ComposeString(xml, 'parentSubstanceName', value.parentSubstanceNameList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.countryOfOriginList.Count - 1 do
      ComposeCodeableConcept(xml, 'countryOfOrigin', value.countryOfOriginList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.geographicalLocationList.Count - 1 do
      ComposeString(xml, 'geographicalLocation', value.geographicalLocationList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(xml, 'developmentStage', value.developmentStage);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.fractionDescriptionList.Count - 1 do
      ComposeSubstanceSourceMaterialFractionDescription(xml, 'fractionDescription', value.fractionDescriptionList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeSubstanceSourceMaterialOrganism(xml, 'organism', value.organism);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.partDescriptionList.Count - 1 do
      ComposeSubstanceSourceMaterialPartDescription(xml, 'partDescription', value.partDescriptionList[i]);
end;

{$ENDIF FHIR_SUBSTANCESOURCEMATERIAL}
{$IFDEF FHIR_SUPPLYDELIVERY}
function TFHIRXmlParser.ParseSupplyDeliverySuppliedItem(element : TMXmlElement; path : string) : TFhirSupplyDeliverySuppliedItem;
var
  child : TMXmlElement;
begin
  result := TFhirSupplyDeliverySuppliedItem.Create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseSupplyDeliverySuppliedItemChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseSupplyDeliverySuppliedItemChild(value : TFhirSupplyDeliverySuppliedItem; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'quantity') then
        value.quantity := ParseQuantity(child, path+'/quantity')
      else if (child.localName = 'itemCodeableConcept') then
        value.item := ParseCodeableConcept(child, path+'/itemCodeableConcept')
      else if (child.localName = 'itemReference') then
        value.item := ParseReference(child, path+'/itemReference')
      else if Not ParseBackboneElementChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeSupplyDeliverySuppliedItem(xml : TXmlBuilder; name : String; value : TFhirSupplyDeliverySuppliedItem);
begin
  if (value = nil) then
    exit;
  composeElementAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeSupplyDeliverySuppliedItemChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeSupplyDeliverySuppliedItemChildren(xml : TXmlBuilder; value : TFhirSupplyDeliverySuppliedItem);
begin
  composeBackboneElementChildren(xml, value);
  if (SummaryOption in [soFull, soData]) then
    ComposeQuantity(xml, 'quantity', value.quantity);
  if (SummaryOption in [soFull, soData]) and (value.item is TFhirCodeableConcept) {6} then
    ComposeCodeableConcept(xml, 'itemCodeableConcept', TFhirCodeableConcept(value.item))
  else if (SummaryOption in [soFull, soData]) and (value.item is TFhirReference) {2} then
    ComposeReference(xml, 'itemReference', TFhirReference(value.item));
end;

function TFHIRXmlParser.ParseSupplyDelivery(element : TMXmlElement; path : string) : TFhirSupplyDelivery;
var
  child : TMXmlElement;
begin
  result := TFhirSupplyDelivery.Create;
  try
    parseDomainResourceAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseSupplyDeliveryChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseSupplyDeliveryChild(value : TFhirSupplyDelivery; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'identifier') then
        value.identifierList.Add(ParseIdentifier(child, path+'/identifier'))
      else if (child.localName = 'basedOn') then
        value.basedOnList.Add(ParseReference(child, path+'/basedOn'))
      else if (child.localName = 'partOf') then
        value.partOfList.Add(ParseReference(child, path+'/partOf'))
      else if (child.localName = 'status') then
        value.statusElement := ParseEnum(CODES_TFhirSupplyDeliveryStatusEnum, SYSTEMS_TFhirSupplyDeliveryStatusEnum, child, path+'/status')
      else if (child.localName = 'patient') then
        value.patient := ParseReference(child, path+'/patient')
      else if (child.localName = 'type') then
        value.type_ := ParseCodeableConcept(child, path+'/type')
      else if (child.localName = 'suppliedItem') then
        value.suppliedItemList.Add(ParseSupplyDeliverySuppliedItem(child, path+'/suppliedItem'))
      else if (child.localName = 'occurrencePeriod') then
        value.occurrence := ParsePeriod(child, path+'/occurrencePeriod')
      else if (child.localName = 'occurrenceTiming') then
        value.occurrence := ParseTiming(child, path+'/occurrenceTiming')
      else if (child.localName = 'occurrenceDateTime') then
        value.occurrence := ParseDateTime(child, path+'/occurrenceDateTime')
      else if (child.localName = 'supplier') then
        value.supplier := ParseReference(child, path+'/supplier')
      else if (child.localName = 'destination') then
        value.destination := ParseReference(child, path+'/destination')
      else if (child.localName = 'receiver') then
        value.receiverList.Add(ParseReference(child, path+'/receiver'))
      else if Not ParseDomainResourceChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeSupplyDelivery(xml : TXmlBuilder; name : String; value : TFhirSupplyDelivery);
begin
  if (value = nil) then
    exit;
  composeDomainResourceAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeSupplyDeliveryChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeSupplyDeliveryChildren(xml : TXmlBuilder; value : TFhirSupplyDelivery);
var
  i : integer;
begin
  composeDomainResourceChildren(xml, value);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.identifierList.Count - 1 do
      ComposeIdentifier(xml, 'identifier', value.identifierList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.basedOnList.Count - 1 do
      ComposeReference(xml, 'basedOn', value.basedOnList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.partOfList.Count - 1 do
      ComposeReference(xml, 'partOf', value.partOfList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeEnum(xml, 'status', value.statusElement, CODES_TFhirSupplyDeliveryStatusEnum);
  if (SummaryOption in [soFull, soData]) then
    ComposeReference(xml, 'patient', value.patient);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(xml, 'type', value.type_);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.suppliedItemList.Count - 1 do
      ComposeSupplyDeliverySuppliedItem(xml, 'suppliedItem', value.suppliedItemList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) and (value.occurrence is TFhirPeriod) {6} then
    ComposePeriod(xml, 'occurrencePeriod', TFhirPeriod(value.occurrence))
  else if (SummaryOption in [soFull, soSummary, soData]) and (value.occurrence is TFhirTiming) {6} then
    ComposeTiming(xml, 'occurrenceTiming', TFhirTiming(value.occurrence))
  else if (SummaryOption in [soFull, soSummary, soData]) and (value.occurrence is TFhirDateTime) {6} then
    ComposeDateTime(xml, 'occurrenceDateTime', TFhirDateTime(value.occurrence));
  if (SummaryOption in [soFull, soData]) then
    ComposeReference(xml, 'supplier', value.supplier);
  if (SummaryOption in [soFull, soData]) then
    ComposeReference(xml, 'destination', value.destination);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.receiverList.Count - 1 do
      ComposeReference(xml, 'receiver', value.receiverList[i]);
end;

{$ENDIF FHIR_SUPPLYDELIVERY}
{$IFDEF FHIR_SUPPLYREQUEST}
function TFHIRXmlParser.ParseSupplyRequestParameter(element : TMXmlElement; path : string) : TFhirSupplyRequestParameter;
var
  child : TMXmlElement;
begin
  result := TFhirSupplyRequestParameter.Create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseSupplyRequestParameterChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseSupplyRequestParameterChild(value : TFhirSupplyRequestParameter; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'code') then
        value.code := ParseCodeableConcept(child, path+'/code')
      else if (child.localName = 'valueCodeableConcept') then
        value.value := ParseCodeableConcept(child, path+'/valueCodeableConcept')
      else if (child.localName = 'valueQuantity') then
        value.value := ParseQuantity(child, path+'/valueQuantity')
      else if (child.localName = 'valueRange') then
        value.value := ParseRange(child, path+'/valueRange')
      else if (child.localName = 'valueBoolean') then
        value.value := ParseBoolean(child, path+'/valueBoolean')
      else if Not ParseBackboneElementChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeSupplyRequestParameter(xml : TXmlBuilder; name : String; value : TFhirSupplyRequestParameter);
begin
  if (value = nil) then
    exit;
  composeElementAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeSupplyRequestParameterChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeSupplyRequestParameterChildren(xml : TXmlBuilder; value : TFhirSupplyRequestParameter);
begin
  composeBackboneElementChildren(xml, value);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(xml, 'code', value.code);
  if (SummaryOption in [soFull, soData]) and (value.value is TFhirCodeableConcept) {6} then
    ComposeCodeableConcept(xml, 'valueCodeableConcept', TFhirCodeableConcept(value.value))
  else if (SummaryOption in [soFull, soData]) and (value.value is TFhirQuantity) {6} then
    ComposeQuantity(xml, 'valueQuantity', TFhirQuantity(value.value))
  else if (SummaryOption in [soFull, soData]) and (value.value is TFhirRange) {6} then
    ComposeRange(xml, 'valueRange', TFhirRange(value.value))
  else if (SummaryOption in [soFull, soData]) and (value.value is TFhirBoolean) {6} then
    ComposeBoolean(xml, 'valueBoolean', TFhirBoolean(value.value));
end;

function TFHIRXmlParser.ParseSupplyRequest(element : TMXmlElement; path : string) : TFhirSupplyRequest;
var
  child : TMXmlElement;
begin
  result := TFhirSupplyRequest.Create;
  try
    parseDomainResourceAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseSupplyRequestChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseSupplyRequestChild(value : TFhirSupplyRequest; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'identifier') then
        value.identifierList.Add(ParseIdentifier(child, path+'/identifier'))
      else if (child.localName = 'status') then
        value.statusElement := ParseEnum(CODES_TFhirSupplyRequestStatusEnum, SYSTEMS_TFhirSupplyRequestStatusEnum, child, path+'/status')
      else if (child.localName = 'basedOn') then
        value.basedOnList.Add(ParseReference(child, path+'/basedOn'))
      else if (child.localName = 'category') then
        value.category := ParseCodeableConcept(child, path+'/category')
      else if (child.localName = 'priority') then
        value.priorityElement := ParseEnum(CODES_TFhirRequestPriorityEnum, SYSTEMS_TFhirRequestPriorityEnum, child, path+'/priority')
      else if (child.localName = 'item') then
        value.item := ParseCodeableReference(child, path+'/item')
      else if (child.localName = 'quantity') then
        value.quantity := ParseQuantity(child, path+'/quantity')
      else if (child.localName = 'parameter') then
        value.parameterList.Add(ParseSupplyRequestParameter(child, path+'/parameter'))
      else if (child.localName = 'occurrencePeriod') then
        value.occurrence := ParsePeriod(child, path+'/occurrencePeriod')
      else if (child.localName = 'occurrenceTiming') then
        value.occurrence := ParseTiming(child, path+'/occurrenceTiming')
      else if (child.localName = 'occurrenceDateTime') then
        value.occurrence := ParseDateTime(child, path+'/occurrenceDateTime')
      else if (child.localName = 'authoredOn') then
        value.authoredOnElement := ParseDateTime(child, path+'/authoredOn')
      else if (child.localName = 'requester') then
        value.requester := ParseReference(child, path+'/requester')
      else if (child.localName = 'supplier') then
        value.supplierList.Add(ParseReference(child, path+'/supplier'))
      else if (child.localName = 'reason') then
        value.reasonList.Add(ParseCodeableReference(child, path+'/reason'))
      else if (child.localName = 'deliverFrom') then
        value.deliverFrom := ParseReference(child, path+'/deliverFrom')
      else if (child.localName = 'deliverTo') then
        value.deliverTo := ParseReference(child, path+'/deliverTo')
      else if Not ParseDomainResourceChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeSupplyRequest(xml : TXmlBuilder; name : String; value : TFhirSupplyRequest);
begin
  if (value = nil) then
    exit;
  composeDomainResourceAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeSupplyRequestChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeSupplyRequestChildren(xml : TXmlBuilder; value : TFhirSupplyRequest);
var
  i : integer;
begin
  composeDomainResourceChildren(xml, value);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.identifierList.Count - 1 do
      ComposeIdentifier(xml, 'identifier', value.identifierList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeEnum(xml, 'status', value.statusElement, CODES_TFhirSupplyRequestStatusEnum);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.basedOnList.Count - 1 do
      ComposeReference(xml, 'basedOn', value.basedOnList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(xml, 'category', value.category);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeEnum(xml, 'priority', value.priorityElement, CODES_TFhirRequestPriorityEnum);
  ComposeCodeableReference(xml, 'item', value.item);
  ComposeQuantity(xml, 'quantity', value.quantity);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.parameterList.Count - 1 do
      ComposeSupplyRequestParameter(xml, 'parameter', value.parameterList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) and (value.occurrence is TFhirPeriod) {6} then
    ComposePeriod(xml, 'occurrencePeriod', TFhirPeriod(value.occurrence))
  else if (SummaryOption in [soFull, soSummary, soData]) and (value.occurrence is TFhirTiming) {6} then
    ComposeTiming(xml, 'occurrenceTiming', TFhirTiming(value.occurrence))
  else if (SummaryOption in [soFull, soSummary, soData]) and (value.occurrence is TFhirDateTime) {6} then
    ComposeDateTime(xml, 'occurrenceDateTime', TFhirDateTime(value.occurrence));
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDateTime(xml, 'authoredOn', value.authoredOnElement);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference(xml, 'requester', value.requester);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.supplierList.Count - 1 do
      ComposeReference(xml, 'supplier', value.supplierList[i]);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.reasonList.Count - 1 do
      ComposeCodeableReference(xml, 'reason', value.reasonList[i]);
  if (SummaryOption in [soFull, soData]) then
    ComposeReference(xml, 'deliverFrom', value.deliverFrom);
  if (SummaryOption in [soFull, soData]) then
    ComposeReference(xml, 'deliverTo', value.deliverTo);
end;

{$ENDIF FHIR_SUPPLYREQUEST}
{$IFDEF FHIR_TASK}
function TFHIRXmlParser.ParseTaskRestriction(element : TMXmlElement; path : string) : TFhirTaskRestriction;
var
  child : TMXmlElement;
begin
  result := TFhirTaskRestriction.Create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseTaskRestrictionChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseTaskRestrictionChild(value : TFhirTaskRestriction; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'repetitions') then
        value.repetitionsElement := ParsePositiveInt(child, path+'/repetitions')
      else if (child.localName = 'period') then
        value.period := ParsePeriod(child, path+'/period')
      else if (child.localName = 'recipient') then
        value.recipientList.Add(ParseReference(child, path+'/recipient'))
      else if Not ParseBackboneElementChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeTaskRestriction(xml : TXmlBuilder; name : String; value : TFhirTaskRestriction);
begin
  if (value = nil) then
    exit;
  composeElementAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeTaskRestrictionChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeTaskRestrictionChildren(xml : TXmlBuilder; value : TFhirTaskRestriction);
var
  i : integer;
begin
  composeBackboneElementChildren(xml, value);
  if (SummaryOption in [soFull, soData]) then
    ComposePositiveInt(xml, 'repetitions', value.repetitionsElement);
  if (SummaryOption in [soFull, soData]) then
    ComposePeriod(xml, 'period', value.period);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.recipientList.Count - 1 do
      ComposeReference(xml, 'recipient', value.recipientList[i]);
end;

function TFHIRXmlParser.ParseTaskInput(element : TMXmlElement; path : string) : TFhirTaskInput;
var
  child : TMXmlElement;
begin
  result := TFhirTaskInput.Create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseTaskInputChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseTaskInputChild(value : TFhirTaskInput; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'type') then
        value.type_ := ParseCodeableConcept(child, path+'/type')
      else if (child.localName = 'valueCanonical') then
        value.value := ParseCanonical(child, path+'/valueCanonical')
      else if (child.localName = 'valueCode') then
        value.value := ParseCode(child, path+'/valueCode')
      else if (child.localName = 'valueId') then
        value.value := ParseId(child, path+'/valueId')
      else if (child.localName = 'valueMarkdown') then
        value.value := ParseMarkdown(child, path+'/valueMarkdown')
      else if (child.localName = 'valueOid') then
        value.value := ParseOid(child, path+'/valueOid')
      else if (child.localName = 'valuePositiveInt') then
        value.value := ParsePositiveInt(child, path+'/valuePositiveInt')
      else if (child.localName = 'valueUnsignedInt') then
        value.value := ParseUnsignedInt(child, path+'/valueUnsignedInt')
      else if (child.localName = 'valueUrl') then
        value.value := ParseUrl(child, path+'/valueUrl')
      else if (child.localName = 'valueUuid') then
        value.value := ParseUuid(child, path+'/valueUuid')
      else if (child.localName = 'valueAddress') then
        value.value := ParseAddress(child, path+'/valueAddress')
      else if (child.localName = 'valueAge') then
        value.value := ParseAge(child, path+'/valueAge')
      else if (child.localName = 'valueAnnotation') then
        value.value := ParseAnnotation(child, path+'/valueAnnotation')
      else if (child.localName = 'valueAttachment') then
        value.value := ParseAttachment(child, path+'/valueAttachment')
      else if (child.localName = 'valueCodeableConcept') then
        value.value := ParseCodeableConcept(child, path+'/valueCodeableConcept')
      else if (child.localName = 'valueCodeableReference') then
        value.value := ParseCodeableReference(child, path+'/valueCodeableReference')
      else if (child.localName = 'valueCoding') then
        value.value := ParseCoding(child, path+'/valueCoding')
      else if (child.localName = 'valueContactPoint') then
        value.value := ParseContactPoint(child, path+'/valueContactPoint')
      else if (child.localName = 'valueCount') then
        value.value := ParseCount(child, path+'/valueCount')
      else if (child.localName = 'valueDistance') then
        value.value := ParseDistance(child, path+'/valueDistance')
      else if (child.localName = 'valueDuration') then
        value.value := ParseDuration(child, path+'/valueDuration')
      else if (child.localName = 'valueHumanName') then
        value.value := ParseHumanName(child, path+'/valueHumanName')
      else if (child.localName = 'valueIdentifier') then
        value.value := ParseIdentifier(child, path+'/valueIdentifier')
      else if (child.localName = 'valueMoney') then
        value.value := ParseMoney(child, path+'/valueMoney')
      else if (child.localName = 'valuePeriod') then
        value.value := ParsePeriod(child, path+'/valuePeriod')
      else if (child.localName = 'valueQuantity') then
        value.value := ParseQuantity(child, path+'/valueQuantity')
      else if (child.localName = 'valueRange') then
        value.value := ParseRange(child, path+'/valueRange')
      else if (child.localName = 'valueRatio') then
        value.value := ParseRatio(child, path+'/valueRatio')
      else if (child.localName = 'valueRatioRange') then
        value.value := ParseRatioRange(child, path+'/valueRatioRange')
      else if (child.localName = 'valueReference') then
        value.value := ParseReference(child, path+'/valueReference')
      else if (child.localName = 'valueSampledData') then
        value.value := ParseSampledData(child, path+'/valueSampledData')
      else if (child.localName = 'valueSignature') then
        value.value := ParseSignature(child, path+'/valueSignature')
      else if (child.localName = 'valueTiming') then
        value.value := ParseTiming(child, path+'/valueTiming')
      else if (child.localName = 'valueContactDetail') then
        value.value := ParseContactDetail(child, path+'/valueContactDetail')
      else if (child.localName = 'valueDataRequirement') then
        value.value := ParseDataRequirement(child, path+'/valueDataRequirement')
      else if (child.localName = 'valueExpression') then
        value.value := ParseExpression(child, path+'/valueExpression')
      else if (child.localName = 'valueParameterDefinition') then
        value.value := ParseParameterDefinition(child, path+'/valueParameterDefinition')
      else if (child.localName = 'valueRelatedArtifact') then
        value.value := ParseRelatedArtifact(child, path+'/valueRelatedArtifact')
      else if (child.localName = 'valueTriggerDefinition') then
        value.value := ParseTriggerDefinition(child, path+'/valueTriggerDefinition')
      else if (child.localName = 'valueUsageContext') then
        value.value := ParseUsageContext(child, path+'/valueUsageContext')
      else if (child.localName = 'valueAvailability') then
        value.value := ParseAvailability(child, path+'/valueAvailability')
      else if (child.localName = 'valueExtendedContactDetail') then
        value.value := ParseExtendedContactDetail(child, path+'/valueExtendedContactDetail')
      else if (child.localName = 'valueDosage') then
        value.value := ParseDosage(child, path+'/valueDosage')
      else if (child.localName = 'valueMeta') then
        value.value := ParseMeta(child, path+'/valueMeta')
      else if (child.localName = 'valueBase64Binary') then
        value.value := ParseBase64Binary(child, path+'/valueBase64Binary')
      else if (child.localName = 'valueBoolean') then
        value.value := ParseBoolean(child, path+'/valueBoolean')
      else if (child.localName = 'valueDate') then
        value.value := ParseDate(child, path+'/valueDate')
      else if (child.localName = 'valueDateTime') then
        value.value := ParseDateTime(child, path+'/valueDateTime')
      else if (child.localName = 'valueDecimal') then
        value.value := ParseDecimal(child, path+'/valueDecimal')
      else if (child.localName = 'valueInstant') then
        value.value := ParseInstant(child, path+'/valueInstant')
      else if (child.localName = 'valueInteger') then
        value.value := ParseInteger(child, path+'/valueInteger')
      else if (child.localName = 'valueInteger64') then
        value.value := ParseInteger64(child, path+'/valueInteger64')
      else if (child.localName = 'valueString') then
        value.value := ParseString(child, path+'/valueString')
      else if (child.localName = 'valueTime') then
        value.value := ParseTime(child, path+'/valueTime')
      else if (child.localName = 'valueUri') then
        value.value := ParseUri(child, path+'/valueUri')
      else if Not ParseBackboneElementChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeTaskInput(xml : TXmlBuilder; name : String; value : TFhirTaskInput);
begin
  if (value = nil) then
    exit;
  composeElementAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeTaskInputChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeTaskInputChildren(xml : TXmlBuilder; value : TFhirTaskInput);
begin
  composeBackboneElementChildren(xml, value);
  ComposeCodeableConcept(xml, 'type', value.type_);
  if (value.value is TFhirCanonical) {6} then
    ComposeCanonical(xml, 'valueCanonical', TFhirCanonical(value.value))
  else if (value.value is TFhirCode) {6} then
    ComposeCode(xml, 'valueCode', TFhirCode(value.value))
  else if (value.value is TFhirId) {6} then
    ComposeId(xml, 'valueId', TFhirId(value.value))
  else if (value.value is TFhirMarkdown) {6} then
    ComposeMarkdown(xml, 'valueMarkdown', TFhirMarkdown(value.value))
  else if (value.value is TFhirOid) {6} then
    ComposeOid(xml, 'valueOid', TFhirOid(value.value))
  else if (value.value is TFhirPositiveInt) {6} then
    ComposePositiveInt(xml, 'valuePositiveInt', TFhirPositiveInt(value.value))
  else if (value.value is TFhirUnsignedInt) {6} then
    ComposeUnsignedInt(xml, 'valueUnsignedInt', TFhirUnsignedInt(value.value))
  else if (value.value is TFhirUrl) {6} then
    ComposeUrl(xml, 'valueUrl', TFhirUrl(value.value))
  else if (value.value is TFhirUuid) {6} then
    ComposeUuid(xml, 'valueUuid', TFhirUuid(value.value))
  else if (value.value is TFhirAddress) {6} then
    ComposeAddress(xml, 'valueAddress', TFhirAddress(value.value))
  else if (value.value is TFhirAge) {6} then
    ComposeAge(xml, 'valueAge', TFhirAge(value.value))
  else if (value.value is TFhirAnnotation) {6} then
    ComposeAnnotation(xml, 'valueAnnotation', TFhirAnnotation(value.value))
  else if (value.value is TFhirAttachment) {6} then
    ComposeAttachment(xml, 'valueAttachment', TFhirAttachment(value.value))
  else if (value.value is TFhirCodeableConcept) {6} then
    ComposeCodeableConcept(xml, 'valueCodeableConcept', TFhirCodeableConcept(value.value))
  else if (value.value is TFhirCodeableReference) {6} then
    ComposeCodeableReference(xml, 'valueCodeableReference', TFhirCodeableReference(value.value))
  else if (value.value is TFhirCoding) {6} then
    ComposeCoding(xml, 'valueCoding', TFhirCoding(value.value))
  else if (value.value is TFhirContactPoint) {6} then
    ComposeContactPoint(xml, 'valueContactPoint', TFhirContactPoint(value.value))
  else if (value.value is TFhirCount) {6} then
    ComposeCount(xml, 'valueCount', TFhirCount(value.value))
  else if (value.value is TFhirDistance) {6} then
    ComposeDistance(xml, 'valueDistance', TFhirDistance(value.value))
  else if (value.value is TFhirDuration) {6} then
    ComposeDuration(xml, 'valueDuration', TFhirDuration(value.value))
  else if (value.value is TFhirHumanName) {6} then
    ComposeHumanName(xml, 'valueHumanName', TFhirHumanName(value.value))
  else if (value.value is TFhirIdentifier) {6} then
    ComposeIdentifier(xml, 'valueIdentifier', TFhirIdentifier(value.value))
  else if (value.value is TFhirMoney) {6} then
    ComposeMoney(xml, 'valueMoney', TFhirMoney(value.value))
  else if (value.value is TFhirPeriod) {6} then
    ComposePeriod(xml, 'valuePeriod', TFhirPeriod(value.value))
  else if (value.value is TFhirQuantity) {6} then
    ComposeQuantity(xml, 'valueQuantity', TFhirQuantity(value.value))
  else if (value.value is TFhirRange) {6} then
    ComposeRange(xml, 'valueRange', TFhirRange(value.value))
  else if (value.value is TFhirRatio) {6} then
    ComposeRatio(xml, 'valueRatio', TFhirRatio(value.value))
  else if (value.value is TFhirRatioRange) {6} then
    ComposeRatioRange(xml, 'valueRatioRange', TFhirRatioRange(value.value))
  else if (value.value is TFhirReference) {6} then
    ComposeReference(xml, 'valueReference', TFhirReference(value.value))
  else if (value.value is TFhirSampledData) {6} then
    ComposeSampledData(xml, 'valueSampledData', TFhirSampledData(value.value))
  else if (value.value is TFhirSignature) {6} then
    ComposeSignature(xml, 'valueSignature', TFhirSignature(value.value))
  else if (value.value is TFhirTiming) {6} then
    ComposeTiming(xml, 'valueTiming', TFhirTiming(value.value))
  else if (value.value is TFhirContactDetail) {6} then
    ComposeContactDetail(xml, 'valueContactDetail', TFhirContactDetail(value.value))
  else if (value.value is TFhirDataRequirement) {6} then
    ComposeDataRequirement(xml, 'valueDataRequirement', TFhirDataRequirement(value.value))
  else if (value.value is TFhirExpression) {6} then
    ComposeExpression(xml, 'valueExpression', TFhirExpression(value.value))
  else if (value.value is TFhirParameterDefinition) {6} then
    ComposeParameterDefinition(xml, 'valueParameterDefinition', TFhirParameterDefinition(value.value))
  else if (value.value is TFhirRelatedArtifact) {6} then
    ComposeRelatedArtifact(xml, 'valueRelatedArtifact', TFhirRelatedArtifact(value.value))
  else if (value.value is TFhirTriggerDefinition) {6} then
    ComposeTriggerDefinition(xml, 'valueTriggerDefinition', TFhirTriggerDefinition(value.value))
  else if (value.value is TFhirUsageContext) {6} then
    ComposeUsageContext(xml, 'valueUsageContext', TFhirUsageContext(value.value))
  else if (value.value is TFhirAvailability) {6} then
    ComposeAvailability(xml, 'valueAvailability', TFhirAvailability(value.value))
  else if (value.value is TFhirExtendedContactDetail) {6} then
    ComposeExtendedContactDetail(xml, 'valueExtendedContactDetail', TFhirExtendedContactDetail(value.value))
  else if (value.value is TFhirDosage) {6} then
    ComposeDosage(xml, 'valueDosage', TFhirDosage(value.value))
  else if (value.value is TFhirMeta) {6} then
    ComposeMeta(xml, 'valueMeta', TFhirMeta(value.value))
  else if (value.value is TFhirBase64Binary) {6} then
    ComposeBase64Binary(xml, 'valueBase64Binary', TFhirBase64Binary(value.value))
  else if (value.value is TFhirBoolean) {6} then
    ComposeBoolean(xml, 'valueBoolean', TFhirBoolean(value.value))
  else if (value.value is TFhirDate) {6} then
    ComposeDate(xml, 'valueDate', TFhirDate(value.value))
  else if (value.value is TFhirDateTime) {6} then
    ComposeDateTime(xml, 'valueDateTime', TFhirDateTime(value.value))
  else if (value.value is TFhirDecimal) {6} then
    ComposeDecimal(xml, 'valueDecimal', TFhirDecimal(value.value))
  else if (value.value is TFhirInstant) {6} then
    ComposeInstant(xml, 'valueInstant', TFhirInstant(value.value))
  else if (value.value is TFhirInteger) {6} then
    ComposeInteger(xml, 'valueInteger', TFhirInteger(value.value))
  else if (value.value is TFhirInteger64) {6} then
    ComposeInteger64(xml, 'valueInteger64', TFhirInteger64(value.value))
  else if (value.value is TFhirString) {6} then
    ComposeString(xml, 'valueString', TFhirString(value.value))
  else if (value.value is TFhirTime) {6} then
    ComposeTime(xml, 'valueTime', TFhirTime(value.value))
  else if (value.value is TFhirUri) {6} then
    ComposeUri(xml, 'valueUri', TFhirUri(value.value));
end;

function TFHIRXmlParser.ParseTaskOutput(element : TMXmlElement; path : string) : TFhirTaskOutput;
var
  child : TMXmlElement;
begin
  result := TFhirTaskOutput.Create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseTaskOutputChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseTaskOutputChild(value : TFhirTaskOutput; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'type') then
        value.type_ := ParseCodeableConcept(child, path+'/type')
      else if (child.localName = 'valueCanonical') then
        value.value := ParseCanonical(child, path+'/valueCanonical')
      else if (child.localName = 'valueCode') then
        value.value := ParseCode(child, path+'/valueCode')
      else if (child.localName = 'valueId') then
        value.value := ParseId(child, path+'/valueId')
      else if (child.localName = 'valueMarkdown') then
        value.value := ParseMarkdown(child, path+'/valueMarkdown')
      else if (child.localName = 'valueOid') then
        value.value := ParseOid(child, path+'/valueOid')
      else if (child.localName = 'valuePositiveInt') then
        value.value := ParsePositiveInt(child, path+'/valuePositiveInt')
      else if (child.localName = 'valueUnsignedInt') then
        value.value := ParseUnsignedInt(child, path+'/valueUnsignedInt')
      else if (child.localName = 'valueUrl') then
        value.value := ParseUrl(child, path+'/valueUrl')
      else if (child.localName = 'valueUuid') then
        value.value := ParseUuid(child, path+'/valueUuid')
      else if (child.localName = 'valueAddress') then
        value.value := ParseAddress(child, path+'/valueAddress')
      else if (child.localName = 'valueAge') then
        value.value := ParseAge(child, path+'/valueAge')
      else if (child.localName = 'valueAnnotation') then
        value.value := ParseAnnotation(child, path+'/valueAnnotation')
      else if (child.localName = 'valueAttachment') then
        value.value := ParseAttachment(child, path+'/valueAttachment')
      else if (child.localName = 'valueCodeableConcept') then
        value.value := ParseCodeableConcept(child, path+'/valueCodeableConcept')
      else if (child.localName = 'valueCodeableReference') then
        value.value := ParseCodeableReference(child, path+'/valueCodeableReference')
      else if (child.localName = 'valueCoding') then
        value.value := ParseCoding(child, path+'/valueCoding')
      else if (child.localName = 'valueContactPoint') then
        value.value := ParseContactPoint(child, path+'/valueContactPoint')
      else if (child.localName = 'valueCount') then
        value.value := ParseCount(child, path+'/valueCount')
      else if (child.localName = 'valueDistance') then
        value.value := ParseDistance(child, path+'/valueDistance')
      else if (child.localName = 'valueDuration') then
        value.value := ParseDuration(child, path+'/valueDuration')
      else if (child.localName = 'valueHumanName') then
        value.value := ParseHumanName(child, path+'/valueHumanName')
      else if (child.localName = 'valueIdentifier') then
        value.value := ParseIdentifier(child, path+'/valueIdentifier')
      else if (child.localName = 'valueMoney') then
        value.value := ParseMoney(child, path+'/valueMoney')
      else if (child.localName = 'valuePeriod') then
        value.value := ParsePeriod(child, path+'/valuePeriod')
      else if (child.localName = 'valueQuantity') then
        value.value := ParseQuantity(child, path+'/valueQuantity')
      else if (child.localName = 'valueRange') then
        value.value := ParseRange(child, path+'/valueRange')
      else if (child.localName = 'valueRatio') then
        value.value := ParseRatio(child, path+'/valueRatio')
      else if (child.localName = 'valueRatioRange') then
        value.value := ParseRatioRange(child, path+'/valueRatioRange')
      else if (child.localName = 'valueReference') then
        value.value := ParseReference(child, path+'/valueReference')
      else if (child.localName = 'valueSampledData') then
        value.value := ParseSampledData(child, path+'/valueSampledData')
      else if (child.localName = 'valueSignature') then
        value.value := ParseSignature(child, path+'/valueSignature')
      else if (child.localName = 'valueTiming') then
        value.value := ParseTiming(child, path+'/valueTiming')
      else if (child.localName = 'valueContactDetail') then
        value.value := ParseContactDetail(child, path+'/valueContactDetail')
      else if (child.localName = 'valueDataRequirement') then
        value.value := ParseDataRequirement(child, path+'/valueDataRequirement')
      else if (child.localName = 'valueExpression') then
        value.value := ParseExpression(child, path+'/valueExpression')
      else if (child.localName = 'valueParameterDefinition') then
        value.value := ParseParameterDefinition(child, path+'/valueParameterDefinition')
      else if (child.localName = 'valueRelatedArtifact') then
        value.value := ParseRelatedArtifact(child, path+'/valueRelatedArtifact')
      else if (child.localName = 'valueTriggerDefinition') then
        value.value := ParseTriggerDefinition(child, path+'/valueTriggerDefinition')
      else if (child.localName = 'valueUsageContext') then
        value.value := ParseUsageContext(child, path+'/valueUsageContext')
      else if (child.localName = 'valueAvailability') then
        value.value := ParseAvailability(child, path+'/valueAvailability')
      else if (child.localName = 'valueExtendedContactDetail') then
        value.value := ParseExtendedContactDetail(child, path+'/valueExtendedContactDetail')
      else if (child.localName = 'valueDosage') then
        value.value := ParseDosage(child, path+'/valueDosage')
      else if (child.localName = 'valueMeta') then
        value.value := ParseMeta(child, path+'/valueMeta')
      else if (child.localName = 'valueBase64Binary') then
        value.value := ParseBase64Binary(child, path+'/valueBase64Binary')
      else if (child.localName = 'valueBoolean') then
        value.value := ParseBoolean(child, path+'/valueBoolean')
      else if (child.localName = 'valueDate') then
        value.value := ParseDate(child, path+'/valueDate')
      else if (child.localName = 'valueDateTime') then
        value.value := ParseDateTime(child, path+'/valueDateTime')
      else if (child.localName = 'valueDecimal') then
        value.value := ParseDecimal(child, path+'/valueDecimal')
      else if (child.localName = 'valueInstant') then
        value.value := ParseInstant(child, path+'/valueInstant')
      else if (child.localName = 'valueInteger') then
        value.value := ParseInteger(child, path+'/valueInteger')
      else if (child.localName = 'valueInteger64') then
        value.value := ParseInteger64(child, path+'/valueInteger64')
      else if (child.localName = 'valueString') then
        value.value := ParseString(child, path+'/valueString')
      else if (child.localName = 'valueTime') then
        value.value := ParseTime(child, path+'/valueTime')
      else if (child.localName = 'valueUri') then
        value.value := ParseUri(child, path+'/valueUri')
      else if Not ParseBackboneElementChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeTaskOutput(xml : TXmlBuilder; name : String; value : TFhirTaskOutput);
begin
  if (value = nil) then
    exit;
  composeElementAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeTaskOutputChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeTaskOutputChildren(xml : TXmlBuilder; value : TFhirTaskOutput);
begin
  composeBackboneElementChildren(xml, value);
  ComposeCodeableConcept(xml, 'type', value.type_);
  if (value.value is TFhirCanonical) {6} then
    ComposeCanonical(xml, 'valueCanonical', TFhirCanonical(value.value))
  else if (value.value is TFhirCode) {6} then
    ComposeCode(xml, 'valueCode', TFhirCode(value.value))
  else if (value.value is TFhirId) {6} then
    ComposeId(xml, 'valueId', TFhirId(value.value))
  else if (value.value is TFhirMarkdown) {6} then
    ComposeMarkdown(xml, 'valueMarkdown', TFhirMarkdown(value.value))
  else if (value.value is TFhirOid) {6} then
    ComposeOid(xml, 'valueOid', TFhirOid(value.value))
  else if (value.value is TFhirPositiveInt) {6} then
    ComposePositiveInt(xml, 'valuePositiveInt', TFhirPositiveInt(value.value))
  else if (value.value is TFhirUnsignedInt) {6} then
    ComposeUnsignedInt(xml, 'valueUnsignedInt', TFhirUnsignedInt(value.value))
  else if (value.value is TFhirUrl) {6} then
    ComposeUrl(xml, 'valueUrl', TFhirUrl(value.value))
  else if (value.value is TFhirUuid) {6} then
    ComposeUuid(xml, 'valueUuid', TFhirUuid(value.value))
  else if (value.value is TFhirAddress) {6} then
    ComposeAddress(xml, 'valueAddress', TFhirAddress(value.value))
  else if (value.value is TFhirAge) {6} then
    ComposeAge(xml, 'valueAge', TFhirAge(value.value))
  else if (value.value is TFhirAnnotation) {6} then
    ComposeAnnotation(xml, 'valueAnnotation', TFhirAnnotation(value.value))
  else if (value.value is TFhirAttachment) {6} then
    ComposeAttachment(xml, 'valueAttachment', TFhirAttachment(value.value))
  else if (value.value is TFhirCodeableConcept) {6} then
    ComposeCodeableConcept(xml, 'valueCodeableConcept', TFhirCodeableConcept(value.value))
  else if (value.value is TFhirCodeableReference) {6} then
    ComposeCodeableReference(xml, 'valueCodeableReference', TFhirCodeableReference(value.value))
  else if (value.value is TFhirCoding) {6} then
    ComposeCoding(xml, 'valueCoding', TFhirCoding(value.value))
  else if (value.value is TFhirContactPoint) {6} then
    ComposeContactPoint(xml, 'valueContactPoint', TFhirContactPoint(value.value))
  else if (value.value is TFhirCount) {6} then
    ComposeCount(xml, 'valueCount', TFhirCount(value.value))
  else if (value.value is TFhirDistance) {6} then
    ComposeDistance(xml, 'valueDistance', TFhirDistance(value.value))
  else if (value.value is TFhirDuration) {6} then
    ComposeDuration(xml, 'valueDuration', TFhirDuration(value.value))
  else if (value.value is TFhirHumanName) {6} then
    ComposeHumanName(xml, 'valueHumanName', TFhirHumanName(value.value))
  else if (value.value is TFhirIdentifier) {6} then
    ComposeIdentifier(xml, 'valueIdentifier', TFhirIdentifier(value.value))
  else if (value.value is TFhirMoney) {6} then
    ComposeMoney(xml, 'valueMoney', TFhirMoney(value.value))
  else if (value.value is TFhirPeriod) {6} then
    ComposePeriod(xml, 'valuePeriod', TFhirPeriod(value.value))
  else if (value.value is TFhirQuantity) {6} then
    ComposeQuantity(xml, 'valueQuantity', TFhirQuantity(value.value))
  else if (value.value is TFhirRange) {6} then
    ComposeRange(xml, 'valueRange', TFhirRange(value.value))
  else if (value.value is TFhirRatio) {6} then
    ComposeRatio(xml, 'valueRatio', TFhirRatio(value.value))
  else if (value.value is TFhirRatioRange) {6} then
    ComposeRatioRange(xml, 'valueRatioRange', TFhirRatioRange(value.value))
  else if (value.value is TFhirReference) {6} then
    ComposeReference(xml, 'valueReference', TFhirReference(value.value))
  else if (value.value is TFhirSampledData) {6} then
    ComposeSampledData(xml, 'valueSampledData', TFhirSampledData(value.value))
  else if (value.value is TFhirSignature) {6} then
    ComposeSignature(xml, 'valueSignature', TFhirSignature(value.value))
  else if (value.value is TFhirTiming) {6} then
    ComposeTiming(xml, 'valueTiming', TFhirTiming(value.value))
  else if (value.value is TFhirContactDetail) {6} then
    ComposeContactDetail(xml, 'valueContactDetail', TFhirContactDetail(value.value))
  else if (value.value is TFhirDataRequirement) {6} then
    ComposeDataRequirement(xml, 'valueDataRequirement', TFhirDataRequirement(value.value))
  else if (value.value is TFhirExpression) {6} then
    ComposeExpression(xml, 'valueExpression', TFhirExpression(value.value))
  else if (value.value is TFhirParameterDefinition) {6} then
    ComposeParameterDefinition(xml, 'valueParameterDefinition', TFhirParameterDefinition(value.value))
  else if (value.value is TFhirRelatedArtifact) {6} then
    ComposeRelatedArtifact(xml, 'valueRelatedArtifact', TFhirRelatedArtifact(value.value))
  else if (value.value is TFhirTriggerDefinition) {6} then
    ComposeTriggerDefinition(xml, 'valueTriggerDefinition', TFhirTriggerDefinition(value.value))
  else if (value.value is TFhirUsageContext) {6} then
    ComposeUsageContext(xml, 'valueUsageContext', TFhirUsageContext(value.value))
  else if (value.value is TFhirAvailability) {6} then
    ComposeAvailability(xml, 'valueAvailability', TFhirAvailability(value.value))
  else if (value.value is TFhirExtendedContactDetail) {6} then
    ComposeExtendedContactDetail(xml, 'valueExtendedContactDetail', TFhirExtendedContactDetail(value.value))
  else if (value.value is TFhirDosage) {6} then
    ComposeDosage(xml, 'valueDosage', TFhirDosage(value.value))
  else if (value.value is TFhirMeta) {6} then
    ComposeMeta(xml, 'valueMeta', TFhirMeta(value.value))
  else if (value.value is TFhirBase64Binary) {6} then
    ComposeBase64Binary(xml, 'valueBase64Binary', TFhirBase64Binary(value.value))
  else if (value.value is TFhirBoolean) {6} then
    ComposeBoolean(xml, 'valueBoolean', TFhirBoolean(value.value))
  else if (value.value is TFhirDate) {6} then
    ComposeDate(xml, 'valueDate', TFhirDate(value.value))
  else if (value.value is TFhirDateTime) {6} then
    ComposeDateTime(xml, 'valueDateTime', TFhirDateTime(value.value))
  else if (value.value is TFhirDecimal) {6} then
    ComposeDecimal(xml, 'valueDecimal', TFhirDecimal(value.value))
  else if (value.value is TFhirInstant) {6} then
    ComposeInstant(xml, 'valueInstant', TFhirInstant(value.value))
  else if (value.value is TFhirInteger) {6} then
    ComposeInteger(xml, 'valueInteger', TFhirInteger(value.value))
  else if (value.value is TFhirInteger64) {6} then
    ComposeInteger64(xml, 'valueInteger64', TFhirInteger64(value.value))
  else if (value.value is TFhirString) {6} then
    ComposeString(xml, 'valueString', TFhirString(value.value))
  else if (value.value is TFhirTime) {6} then
    ComposeTime(xml, 'valueTime', TFhirTime(value.value))
  else if (value.value is TFhirUri) {6} then
    ComposeUri(xml, 'valueUri', TFhirUri(value.value));
end;

function TFHIRXmlParser.ParseTask(element : TMXmlElement; path : string) : TFhirTask;
var
  child : TMXmlElement;
begin
  result := TFhirTask.Create;
  try
    parseDomainResourceAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseTaskChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseTaskChild(value : TFhirTask; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'identifier') then
        value.identifierList.Add(ParseIdentifier(child, path+'/identifier'))
      else if (child.localName = 'instantiatesCanonical') then
        value.instantiatesCanonicalElement := ParseCanonical(child, path+'/instantiatesCanonical')
      else if (child.localName = 'instantiatesUri') then
        value.instantiatesUriElement := ParseUri(child, path+'/instantiatesUri')
      else if (child.localName = 'basedOn') then
        value.basedOnList.Add(ParseReference(child, path+'/basedOn'))
      else if (child.localName = 'groupIdentifier') then
        value.groupIdentifier := ParseIdentifier(child, path+'/groupIdentifier')
      else if (child.localName = 'partOf') then
        value.partOfList.Add(ParseReference(child, path+'/partOf'))
      else if (child.localName = 'status') then
        value.statusElement := ParseEnum(CODES_TFhirTaskStatusEnum, SYSTEMS_TFhirTaskStatusEnum, child, path+'/status')
      else if (child.localName = 'statusReason') then
        value.statusReason := ParseCodeableReference(child, path+'/statusReason')
      else if (child.localName = 'businessStatus') then
        value.businessStatus := ParseCodeableConcept(child, path+'/businessStatus')
      else if (child.localName = 'intent') then
        value.intentElement := ParseEnum(CODES_TFhirTaskIntentEnum, SYSTEMS_TFhirTaskIntentEnum, child, path+'/intent')
      else if (child.localName = 'priority') then
        value.priorityElement := ParseEnum(CODES_TFhirRequestPriorityEnum, SYSTEMS_TFhirRequestPriorityEnum, child, path+'/priority')
      else if (child.localName = 'doNotPerform') then
        value.doNotPerformElement := ParseBoolean(child, path+'/doNotPerform')
      else if (child.localName = 'code') then
        value.code := ParseCodeableConcept(child, path+'/code')
      else if (child.localName = 'description') then
        value.descriptionElement := ParseString(child, path+'/description')
      else if (child.localName = 'focus') then
        value.focus := ParseReference(child, path+'/focus')
      else if (child.localName = 'for') then
        value.for_ := ParseReference(child, path+'/for')
      else if (child.localName = 'encounter') then
        value.encounter := ParseReference(child, path+'/encounter')
      else if (child.localName = 'requestedPeriod') then
        value.requestedPeriod := ParsePeriod(child, path+'/requestedPeriod')
      else if (child.localName = 'executionPeriod') then
        value.executionPeriod := ParsePeriod(child, path+'/executionPeriod')
      else if (child.localName = 'authoredOn') then
        value.authoredOnElement := ParseDateTime(child, path+'/authoredOn')
      else if (child.localName = 'lastModified') then
        value.lastModifiedElement := ParseDateTime(child, path+'/lastModified')
      else if (child.localName = 'requester') then
        value.requester := ParseReference(child, path+'/requester')
      else if (child.localName = 'requestedPerformer') then
        value.requestedPerformerList.Add(ParseCodeableReference(child, path+'/requestedPerformer'))
      else if (child.localName = 'owner') then
        value.owner := ParseReference(child, path+'/owner')
      else if (child.localName = 'location') then
        value.location := ParseReference(child, path+'/location')
      else if (child.localName = 'reason') then
        value.reasonList.Add(ParseCodeableReference(child, path+'/reason'))
      else if (child.localName = 'insurance') then
        value.insuranceList.Add(ParseReference(child, path+'/insurance'))
      else if (child.localName = 'note') then
        value.noteList.Add(ParseAnnotation(child, path+'/note'))
      else if (child.localName = 'relevantHistory') then
        value.relevantHistoryList.Add(ParseReference(child, path+'/relevantHistory'))
      else if (child.localName = 'restriction') then
        value.restriction := ParseTaskRestriction(child, path+'/restriction')
      else if (child.localName = 'input') then
        value.inputList.Add(ParseTaskInput(child, path+'/input'))
      else if (child.localName = 'output') then
        value.outputList.Add(ParseTaskOutput(child, path+'/output'))
      else if Not ParseDomainResourceChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeTask(xml : TXmlBuilder; name : String; value : TFhirTask);
begin
  if (value = nil) then
    exit;
  composeDomainResourceAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeTaskChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeTaskChildren(xml : TXmlBuilder; value : TFhirTask);
var
  i : integer;
begin
  composeDomainResourceChildren(xml, value);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.identifierList.Count - 1 do
      ComposeIdentifier(xml, 'identifier', value.identifierList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCanonical(xml, 'instantiatesCanonical', value.instantiatesCanonicalElement);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeUri(xml, 'instantiatesUri', value.instantiatesUriElement);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.basedOnList.Count - 1 do
      ComposeReference(xml, 'basedOn', value.basedOnList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeIdentifier(xml, 'groupIdentifier', value.groupIdentifier);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.partOfList.Count - 1 do
      ComposeReference(xml, 'partOf', value.partOfList[i]);
  ComposeEnum(xml, 'status', value.statusElement, CODES_TFhirTaskStatusEnum);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableReference(xml, 'statusReason', value.statusReason);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(xml, 'businessStatus', value.businessStatus);
  ComposeEnum(xml, 'intent', value.intentElement, CODES_TFhirTaskIntentEnum);
  if (SummaryOption in [soFull, soData]) then
    ComposeEnum(xml, 'priority', value.priorityElement, CODES_TFhirRequestPriorityEnum);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeBoolean(xml, 'doNotPerform', value.doNotPerformElement);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(xml, 'code', value.code);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(xml, 'description', value.descriptionElement);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference(xml, 'focus', value.focus);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference(xml, 'for', value.for_);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference(xml, 'encounter', value.encounter);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposePeriod(xml, 'requestedPeriod', value.requestedPeriod);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposePeriod(xml, 'executionPeriod', value.executionPeriod);
  if (SummaryOption in [soFull, soData]) then
    ComposeDateTime(xml, 'authoredOn', value.authoredOnElement);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDateTime(xml, 'lastModified', value.lastModifiedElement);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference(xml, 'requester', value.requester);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.requestedPerformerList.Count - 1 do
      ComposeCodeableReference(xml, 'requestedPerformer', value.requestedPerformerList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference(xml, 'owner', value.owner);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference(xml, 'location', value.location);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.reasonList.Count - 1 do
      ComposeCodeableReference(xml, 'reason', value.reasonList[i]);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.insuranceList.Count - 1 do
      ComposeReference(xml, 'insurance', value.insuranceList[i]);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.noteList.Count - 1 do
      ComposeAnnotation(xml, 'note', value.noteList[i]);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.relevantHistoryList.Count - 1 do
      ComposeReference(xml, 'relevantHistory', value.relevantHistoryList[i]);
  if (SummaryOption in [soFull, soData]) then
    ComposeTaskRestriction(xml, 'restriction', value.restriction);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.inputList.Count - 1 do
      ComposeTaskInput(xml, 'input', value.inputList[i]);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.outputList.Count - 1 do
      ComposeTaskOutput(xml, 'output', value.outputList[i]);
end;

{$ENDIF FHIR_TASK}
{$IFDEF FHIR_TERMINOLOGYCAPABILITIES}
function TFHIRXmlParser.ParseTerminologyCapabilitiesSoftware(element : TMXmlElement; path : string) : TFhirTerminologyCapabilitiesSoftware;
var
  child : TMXmlElement;
begin
  result := TFhirTerminologyCapabilitiesSoftware.Create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseTerminologyCapabilitiesSoftwareChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseTerminologyCapabilitiesSoftwareChild(value : TFhirTerminologyCapabilitiesSoftware; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'name') then
        value.nameElement := ParseString(child, path+'/name')
      else if (child.localName = 'version') then
        value.versionElement := ParseString(child, path+'/version')
      else if Not ParseBackboneElementChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeTerminologyCapabilitiesSoftware(xml : TXmlBuilder; name : String; value : TFhirTerminologyCapabilitiesSoftware);
begin
  if (value = nil) then
    exit;
  composeElementAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeTerminologyCapabilitiesSoftwareChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeTerminologyCapabilitiesSoftwareChildren(xml : TXmlBuilder; value : TFhirTerminologyCapabilitiesSoftware);
begin
  composeBackboneElementChildren(xml, value);
  ComposeString(xml, 'name', value.nameElement);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(xml, 'version', value.versionElement);
end;

function TFHIRXmlParser.ParseTerminologyCapabilitiesImplementation(element : TMXmlElement; path : string) : TFhirTerminologyCapabilitiesImplementation;
var
  child : TMXmlElement;
begin
  result := TFhirTerminologyCapabilitiesImplementation.Create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseTerminologyCapabilitiesImplementationChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseTerminologyCapabilitiesImplementationChild(value : TFhirTerminologyCapabilitiesImplementation; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'description') then
        value.descriptionElement := ParseString(child, path+'/description')
      else if (child.localName = 'url') then
        value.urlElement := ParseUrl(child, path+'/url')
      else if Not ParseBackboneElementChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeTerminologyCapabilitiesImplementation(xml : TXmlBuilder; name : String; value : TFhirTerminologyCapabilitiesImplementation);
begin
  if (value = nil) then
    exit;
  composeElementAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeTerminologyCapabilitiesImplementationChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeTerminologyCapabilitiesImplementationChildren(xml : TXmlBuilder; value : TFhirTerminologyCapabilitiesImplementation);
begin
  composeBackboneElementChildren(xml, value);
  ComposeString(xml, 'description', value.descriptionElement);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeUrl(xml, 'url', value.urlElement);
end;

function TFHIRXmlParser.ParseTerminologyCapabilitiesCodeSystem(element : TMXmlElement; path : string) : TFhirTerminologyCapabilitiesCodeSystem;
var
  child : TMXmlElement;
begin
  result := TFhirTerminologyCapabilitiesCodeSystem.Create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseTerminologyCapabilitiesCodeSystemChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseTerminologyCapabilitiesCodeSystemChild(value : TFhirTerminologyCapabilitiesCodeSystem; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'uri') then
        value.uriElement := ParseCanonical(child, path+'/uri')
      else if (child.localName = 'version') then
        value.versionList.Add(ParseTerminologyCapabilitiesCodeSystemVersion(child, path+'/version'))
      else if (child.localName = 'content') then
        value.contentElement := ParseCode(child, path+'/content')
      else if (child.localName = 'subsumption') then
        value.subsumptionElement := ParseBoolean(child, path+'/subsumption')
      else if Not ParseBackboneElementChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeTerminologyCapabilitiesCodeSystem(xml : TXmlBuilder; name : String; value : TFhirTerminologyCapabilitiesCodeSystem);
begin
  if (value = nil) then
    exit;
  composeElementAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeTerminologyCapabilitiesCodeSystemChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeTerminologyCapabilitiesCodeSystemChildren(xml : TXmlBuilder; value : TFhirTerminologyCapabilitiesCodeSystem);
var
  i : integer;
begin
  composeBackboneElementChildren(xml, value);
  if (SummaryOption in [soFull, soData]) then
    ComposeCanonical(xml, 'uri', value.uriElement);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.versionList.Count - 1 do
      ComposeTerminologyCapabilitiesCodeSystemVersion(xml, 'version', value.versionList[i]);
  ComposeCode(xml, 'content', value.contentElement);
  if (SummaryOption in [soFull, soData]) then
    ComposeBoolean(xml, 'subsumption', value.subsumptionElement);
end;

function TFHIRXmlParser.ParseTerminologyCapabilitiesCodeSystemVersion(element : TMXmlElement; path : string) : TFhirTerminologyCapabilitiesCodeSystemVersion;
var
  child : TMXmlElement;
begin
  result := TFhirTerminologyCapabilitiesCodeSystemVersion.Create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseTerminologyCapabilitiesCodeSystemVersionChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseTerminologyCapabilitiesCodeSystemVersionChild(value : TFhirTerminologyCapabilitiesCodeSystemVersion; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'code') then
        value.codeElement := ParseString(child, path+'/code')
      else if (child.localName = 'isDefault') then
        value.isDefaultElement := ParseBoolean(child, path+'/isDefault')
      else if (child.localName = 'compositional') then
        value.compositionalElement := ParseBoolean(child, path+'/compositional')
      else if (child.localName = 'language') then
        value.language.Add(ParseEnum(CODES_TFhirCommonLanguagesEnum, SYSTEMS_TFhirCommonLanguagesEnum, child, path+'/language')){y.1}
      else if (child.localName = 'filter') then
        value.filterList.Add(ParseTerminologyCapabilitiesCodeSystemVersionFilter(child, path+'/filter'))
      else if (child.localName = 'property') then
        value.property_List.Add(ParseCode(child, path+'/property'))
      else if Not ParseBackboneElementChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeTerminologyCapabilitiesCodeSystemVersion(xml : TXmlBuilder; name : String; value : TFhirTerminologyCapabilitiesCodeSystemVersion);
begin
  if (value = nil) then
    exit;
  composeElementAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeTerminologyCapabilitiesCodeSystemVersionChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeTerminologyCapabilitiesCodeSystemVersionChildren(xml : TXmlBuilder; value : TFhirTerminologyCapabilitiesCodeSystemVersion);
var
  i : integer;
begin
  composeBackboneElementChildren(xml, value);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(xml, 'code', value.codeElement);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeBoolean(xml, 'isDefault', value.isDefaultElement);
  if (SummaryOption in [soFull, soData]) then
    ComposeBoolean(xml, 'compositional', value.compositionalElement);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.language.Count - 1 do
      ComposeEnum(xml, 'language', value.language[i], CODES_TFhirCommonLanguagesEnum);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.filterList.Count - 1 do
      ComposeTerminologyCapabilitiesCodeSystemVersionFilter(xml, 'filter', value.filterList[i]);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.property_List.Count - 1 do
      ComposeCode(xml, 'property', value.property_List[i]);
end;

function TFHIRXmlParser.ParseTerminologyCapabilitiesCodeSystemVersionFilter(element : TMXmlElement; path : string) : TFhirTerminologyCapabilitiesCodeSystemVersionFilter;
var
  child : TMXmlElement;
begin
  result := TFhirTerminologyCapabilitiesCodeSystemVersionFilter.Create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseTerminologyCapabilitiesCodeSystemVersionFilterChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseTerminologyCapabilitiesCodeSystemVersionFilterChild(value : TFhirTerminologyCapabilitiesCodeSystemVersionFilter; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'code') then
        value.codeElement := ParseCode(child, path+'/code')
      else if (child.localName = 'op') then
        value.opList.Add(ParseCode(child, path+'/op'))
      else if Not ParseBackboneElementChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeTerminologyCapabilitiesCodeSystemVersionFilter(xml : TXmlBuilder; name : String; value : TFhirTerminologyCapabilitiesCodeSystemVersionFilter);
begin
  if (value = nil) then
    exit;
  composeElementAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeTerminologyCapabilitiesCodeSystemVersionFilterChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeTerminologyCapabilitiesCodeSystemVersionFilterChildren(xml : TXmlBuilder; value : TFhirTerminologyCapabilitiesCodeSystemVersionFilter);
var
  i : integer;
begin
  composeBackboneElementChildren(xml, value);
  ComposeCode(xml, 'code', value.codeElement);
  for i := 0 to value.opList.Count - 1 do
      ComposeCode(xml, 'op', value.opList[i]);
end;

function TFHIRXmlParser.ParseTerminologyCapabilitiesExpansion(element : TMXmlElement; path : string) : TFhirTerminologyCapabilitiesExpansion;
var
  child : TMXmlElement;
begin
  result := TFhirTerminologyCapabilitiesExpansion.Create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseTerminologyCapabilitiesExpansionChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseTerminologyCapabilitiesExpansionChild(value : TFhirTerminologyCapabilitiesExpansion; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'hierarchical') then
        value.hierarchicalElement := ParseBoolean(child, path+'/hierarchical')
      else if (child.localName = 'paging') then
        value.pagingElement := ParseBoolean(child, path+'/paging')
      else if (child.localName = 'incomplete') then
        value.incompleteElement := ParseBoolean(child, path+'/incomplete')
      else if (child.localName = 'parameter') then
        value.parameterList.Add(ParseTerminologyCapabilitiesExpansionParameter(child, path+'/parameter'))
      else if (child.localName = 'textFilter') then
        value.textFilterElement := ParseMarkdown(child, path+'/textFilter')
      else if Not ParseBackboneElementChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeTerminologyCapabilitiesExpansion(xml : TXmlBuilder; name : String; value : TFhirTerminologyCapabilitiesExpansion);
begin
  if (value = nil) then
    exit;
  composeElementAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeTerminologyCapabilitiesExpansionChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeTerminologyCapabilitiesExpansionChildren(xml : TXmlBuilder; value : TFhirTerminologyCapabilitiesExpansion);
var
  i : integer;
begin
  composeBackboneElementChildren(xml, value);
  if (SummaryOption in [soFull, soData]) then
    ComposeBoolean(xml, 'hierarchical', value.hierarchicalElement);
  if (SummaryOption in [soFull, soData]) then
    ComposeBoolean(xml, 'paging', value.pagingElement);
  if (SummaryOption in [soFull, soData]) then
    ComposeBoolean(xml, 'incomplete', value.incompleteElement);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.parameterList.Count - 1 do
      ComposeTerminologyCapabilitiesExpansionParameter(xml, 'parameter', value.parameterList[i]);
  if (SummaryOption in [soFull, soData]) then
    ComposeMarkdown(xml, 'textFilter', value.textFilterElement);
end;

function TFHIRXmlParser.ParseTerminologyCapabilitiesExpansionParameter(element : TMXmlElement; path : string) : TFhirTerminologyCapabilitiesExpansionParameter;
var
  child : TMXmlElement;
begin
  result := TFhirTerminologyCapabilitiesExpansionParameter.Create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseTerminologyCapabilitiesExpansionParameterChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseTerminologyCapabilitiesExpansionParameterChild(value : TFhirTerminologyCapabilitiesExpansionParameter; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'name') then
        value.nameElement := ParseCode(child, path+'/name')
      else if (child.localName = 'documentation') then
        value.documentationElement := ParseString(child, path+'/documentation')
      else if Not ParseBackboneElementChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeTerminologyCapabilitiesExpansionParameter(xml : TXmlBuilder; name : String; value : TFhirTerminologyCapabilitiesExpansionParameter);
begin
  if (value = nil) then
    exit;
  composeElementAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeTerminologyCapabilitiesExpansionParameterChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeTerminologyCapabilitiesExpansionParameterChildren(xml : TXmlBuilder; value : TFhirTerminologyCapabilitiesExpansionParameter);
begin
  composeBackboneElementChildren(xml, value);
  ComposeCode(xml, 'name', value.nameElement);
  if (SummaryOption in [soFull, soData]) then
    ComposeString(xml, 'documentation', value.documentationElement);
end;

function TFHIRXmlParser.ParseTerminologyCapabilitiesValidateCode(element : TMXmlElement; path : string) : TFhirTerminologyCapabilitiesValidateCode;
var
  child : TMXmlElement;
begin
  result := TFhirTerminologyCapabilitiesValidateCode.Create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseTerminologyCapabilitiesValidateCodeChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseTerminologyCapabilitiesValidateCodeChild(value : TFhirTerminologyCapabilitiesValidateCode; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'translations') then
        value.translationsElement := ParseBoolean(child, path+'/translations')
      else if Not ParseBackboneElementChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeTerminologyCapabilitiesValidateCode(xml : TXmlBuilder; name : String; value : TFhirTerminologyCapabilitiesValidateCode);
begin
  if (value = nil) then
    exit;
  composeElementAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeTerminologyCapabilitiesValidateCodeChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeTerminologyCapabilitiesValidateCodeChildren(xml : TXmlBuilder; value : TFhirTerminologyCapabilitiesValidateCode);
begin
  composeBackboneElementChildren(xml, value);
  ComposeBoolean(xml, 'translations', value.translationsElement);
end;

function TFHIRXmlParser.ParseTerminologyCapabilitiesTranslation(element : TMXmlElement; path : string) : TFhirTerminologyCapabilitiesTranslation;
var
  child : TMXmlElement;
begin
  result := TFhirTerminologyCapabilitiesTranslation.Create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseTerminologyCapabilitiesTranslationChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseTerminologyCapabilitiesTranslationChild(value : TFhirTerminologyCapabilitiesTranslation; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'needsMap') then
        value.needsMapElement := ParseBoolean(child, path+'/needsMap')
      else if Not ParseBackboneElementChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeTerminologyCapabilitiesTranslation(xml : TXmlBuilder; name : String; value : TFhirTerminologyCapabilitiesTranslation);
begin
  if (value = nil) then
    exit;
  composeElementAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeTerminologyCapabilitiesTranslationChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeTerminologyCapabilitiesTranslationChildren(xml : TXmlBuilder; value : TFhirTerminologyCapabilitiesTranslation);
begin
  composeBackboneElementChildren(xml, value);
  ComposeBoolean(xml, 'needsMap', value.needsMapElement);
end;

function TFHIRXmlParser.ParseTerminologyCapabilitiesClosure(element : TMXmlElement; path : string) : TFhirTerminologyCapabilitiesClosure;
var
  child : TMXmlElement;
begin
  result := TFhirTerminologyCapabilitiesClosure.Create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseTerminologyCapabilitiesClosureChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseTerminologyCapabilitiesClosureChild(value : TFhirTerminologyCapabilitiesClosure; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'translation') then
        value.translationElement := ParseBoolean(child, path+'/translation')
      else if Not ParseBackboneElementChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeTerminologyCapabilitiesClosure(xml : TXmlBuilder; name : String; value : TFhirTerminologyCapabilitiesClosure);
begin
  if (value = nil) then
    exit;
  composeElementAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeTerminologyCapabilitiesClosureChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeTerminologyCapabilitiesClosureChildren(xml : TXmlBuilder; value : TFhirTerminologyCapabilitiesClosure);
begin
  composeBackboneElementChildren(xml, value);
  if (SummaryOption in [soFull, soData]) then
    ComposeBoolean(xml, 'translation', value.translationElement);
end;

function TFHIRXmlParser.ParseTerminologyCapabilities(element : TMXmlElement; path : string) : TFhirTerminologyCapabilities;
var
  child : TMXmlElement;
begin
  result := TFhirTerminologyCapabilities.Create;
  try
    parseCanonicalResourceAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseTerminologyCapabilitiesChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseTerminologyCapabilitiesChild(value : TFhirTerminologyCapabilities; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'url') then
        value.urlElement := ParseUri(child, path+'/url')
      else if (child.localName = 'identifier') then
        value.identifierList.Add(ParseIdentifier(child, path+'/identifier'))
      else if (child.localName = 'version') then
        value.versionElement := ParseString(child, path+'/version')
      else if (child.localName = 'name') then
        value.nameElement := ParseString(child, path+'/name')
      else if (child.localName = 'title') then
        value.titleElement := ParseString(child, path+'/title')
      else if (child.localName = 'status') then
        value.statusElement := ParseEnum(CODES_TFhirPublicationStatusEnum, SYSTEMS_TFhirPublicationStatusEnum, child, path+'/status')
      else if (child.localName = 'experimental') then
        value.experimentalElement := ParseBoolean(child, path+'/experimental')
      else if (child.localName = 'date') then
        value.dateElement := ParseDateTime(child, path+'/date')
      else if (child.localName = 'publisher') then
        value.publisherElement := ParseString(child, path+'/publisher')
      else if (child.localName = 'contact') then
        value.contactList.Add(ParseContactDetail(child, path+'/contact'))
      else if (child.localName = 'description') then
        value.descriptionElement := ParseMarkdown(child, path+'/description')
      else if (child.localName = 'useContext') then
        value.useContextList.Add(ParseUsageContext(child, path+'/useContext'))
      else if (child.localName = 'jurisdiction') then
        value.jurisdictionList.Add(ParseCodeableConcept(child, path+'/jurisdiction'))
      else if (child.localName = 'purpose') then
        value.purposeElement := ParseMarkdown(child, path+'/purpose')
      else if (child.localName = 'copyright') then
        value.copyrightElement := ParseMarkdown(child, path+'/copyright')
      else if (child.localName = 'kind') then
        value.kindElement := ParseEnum(CODES_TFhirCapabilityStatementKindEnum, SYSTEMS_TFhirCapabilityStatementKindEnum, child, path+'/kind')
      else if (child.localName = 'software') then
        value.software := ParseTerminologyCapabilitiesSoftware(child, path+'/software')
      else if (child.localName = 'implementation') then
        value.implementation_ := ParseTerminologyCapabilitiesImplementation(child, path+'/implementation')
      else if (child.localName = 'lockedDate') then
        value.lockedDateElement := ParseBoolean(child, path+'/lockedDate')
      else if (child.localName = 'codeSystem') then
        value.codeSystemList.Add(ParseTerminologyCapabilitiesCodeSystem(child, path+'/codeSystem'))
      else if (child.localName = 'expansion') then
        value.expansion := ParseTerminologyCapabilitiesExpansion(child, path+'/expansion')
      else if (child.localName = 'codeSearch') then
        value.codeSearchElement := ParseEnum(CODES_TFhirCodeSearchSupportEnum, SYSTEMS_TFhirCodeSearchSupportEnum, child, path+'/codeSearch')
      else if (child.localName = 'validateCode') then
        value.validateCode := ParseTerminologyCapabilitiesValidateCode(child, path+'/validateCode')
      else if (child.localName = 'translation') then
        value.translation := ParseTerminologyCapabilitiesTranslation(child, path+'/translation')
      else if (child.localName = 'closure') then
        value.closure := ParseTerminologyCapabilitiesClosure(child, path+'/closure')
      else if Not ParseCanonicalResourceChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeTerminologyCapabilities(xml : TXmlBuilder; name : String; value : TFhirTerminologyCapabilities);
begin
  if (value = nil) then
    exit;
  composeCanonicalResourceAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeTerminologyCapabilitiesChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeTerminologyCapabilitiesChildren(xml : TXmlBuilder; value : TFhirTerminologyCapabilities);
var
  i : integer;
begin
  composeCanonicalResourceChildren(xml, value);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeUri(xml, 'url', value.urlElement);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.identifierList.Count - 1 do
      ComposeIdentifier(xml, 'identifier', value.identifierList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(xml, 'version', value.versionElement);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(xml, 'name', value.nameElement);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(xml, 'title', value.titleElement);
  ComposeEnum(xml, 'status', value.statusElement, CODES_TFhirPublicationStatusEnum);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeBoolean(xml, 'experimental', value.experimentalElement);
  ComposeDateTime(xml, 'date', value.dateElement);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(xml, 'publisher', value.publisherElement);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.contactList.Count - 1 do
      ComposeContactDetail(xml, 'contact', value.contactList[i]);
  if (SummaryOption in [soFull, soData]) then
    ComposeMarkdown(xml, 'description', value.descriptionElement);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.useContextList.Count - 1 do
      ComposeUsageContext(xml, 'useContext', value.useContextList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.jurisdictionList.Count - 1 do
      ComposeCodeableConcept(xml, 'jurisdiction', value.jurisdictionList[i]);
  if (SummaryOption in [soFull, soData]) then
    ComposeMarkdown(xml, 'purpose', value.purposeElement);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeMarkdown(xml, 'copyright', value.copyrightElement);
  ComposeEnum(xml, 'kind', value.kindElement, CODES_TFhirCapabilityStatementKindEnum);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeTerminologyCapabilitiesSoftware(xml, 'software', value.software);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeTerminologyCapabilitiesImplementation(xml, 'implementation', value.implementation_);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeBoolean(xml, 'lockedDate', value.lockedDateElement);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.codeSystemList.Count - 1 do
      ComposeTerminologyCapabilitiesCodeSystem(xml, 'codeSystem', value.codeSystemList[i]);
  if (SummaryOption in [soFull, soData]) then
    ComposeTerminologyCapabilitiesExpansion(xml, 'expansion', value.expansion);
  if (SummaryOption in [soFull, soData]) then
    ComposeEnum(xml, 'codeSearch', value.codeSearchElement, CODES_TFhirCodeSearchSupportEnum);
  if (SummaryOption in [soFull, soData]) then
    ComposeTerminologyCapabilitiesValidateCode(xml, 'validateCode', value.validateCode);
  if (SummaryOption in [soFull, soData]) then
    ComposeTerminologyCapabilitiesTranslation(xml, 'translation', value.translation);
  if (SummaryOption in [soFull, soData]) then
    ComposeTerminologyCapabilitiesClosure(xml, 'closure', value.closure);
end;

{$ENDIF FHIR_TERMINOLOGYCAPABILITIES}
{$IFDEF FHIR_TESTREPORT}
function TFHIRXmlParser.ParseTestReportParticipant(element : TMXmlElement; path : string) : TFhirTestReportParticipant;
var
  child : TMXmlElement;
begin
  result := TFhirTestReportParticipant.Create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseTestReportParticipantChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseTestReportParticipantChild(value : TFhirTestReportParticipant; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'type') then
        value.type_Element := ParseEnum(CODES_TFhirTestReportParticipantTypeEnum, SYSTEMS_TFhirTestReportParticipantTypeEnum, child, path+'/type')
      else if (child.localName = 'uri') then
        value.uriElement := ParseUri(child, path+'/uri')
      else if (child.localName = 'display') then
        value.displayElement := ParseString(child, path+'/display')
      else if Not ParseBackboneElementChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeTestReportParticipant(xml : TXmlBuilder; name : String; value : TFhirTestReportParticipant);
begin
  if (value = nil) then
    exit;
  composeElementAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeTestReportParticipantChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeTestReportParticipantChildren(xml : TXmlBuilder; value : TFhirTestReportParticipant);
begin
  composeBackboneElementChildren(xml, value);
  ComposeEnum(xml, 'type', value.type_Element, CODES_TFhirTestReportParticipantTypeEnum);
  ComposeUri(xml, 'uri', value.uriElement);
  if (SummaryOption in [soFull, soData]) then
    ComposeString(xml, 'display', value.displayElement);
end;

function TFHIRXmlParser.ParseTestReportSetup(element : TMXmlElement; path : string) : TFhirTestReportSetup;
var
  child : TMXmlElement;
begin
  result := TFhirTestReportSetup.Create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseTestReportSetupChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseTestReportSetupChild(value : TFhirTestReportSetup; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'action') then
        value.actionList.Add(ParseTestReportSetupAction(child, path+'/action'))
      else if Not ParseBackboneElementChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeTestReportSetup(xml : TXmlBuilder; name : String; value : TFhirTestReportSetup);
begin
  if (value = nil) then
    exit;
  composeElementAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeTestReportSetupChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeTestReportSetupChildren(xml : TXmlBuilder; value : TFhirTestReportSetup);
var
  i : integer;
begin
  composeBackboneElementChildren(xml, value);
  for i := 0 to value.actionList.Count - 1 do
      ComposeTestReportSetupAction(xml, 'action', value.actionList[i]);
end;

function TFHIRXmlParser.ParseTestReportSetupAction(element : TMXmlElement; path : string) : TFhirTestReportSetupAction;
var
  child : TMXmlElement;
begin
  result := TFhirTestReportSetupAction.Create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseTestReportSetupActionChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseTestReportSetupActionChild(value : TFhirTestReportSetupAction; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'operation') then
        value.operation := ParseTestReportSetupActionOperation(child, path+'/operation')
      else if (child.localName = 'assert') then
        value.assert := ParseTestReportSetupActionAssert(child, path+'/assert')
      else if Not ParseBackboneElementChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeTestReportSetupAction(xml : TXmlBuilder; name : String; value : TFhirTestReportSetupAction);
begin
  if (value = nil) then
    exit;
  composeElementAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeTestReportSetupActionChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeTestReportSetupActionChildren(xml : TXmlBuilder; value : TFhirTestReportSetupAction);
begin
  composeBackboneElementChildren(xml, value);
  if (SummaryOption in [soFull, soData]) then
    ComposeTestReportSetupActionOperation(xml, 'operation', value.operation);
  if (SummaryOption in [soFull, soData]) then
    ComposeTestReportSetupActionAssert(xml, 'assert', value.assert);
end;

function TFHIRXmlParser.ParseTestReportSetupActionOperation(element : TMXmlElement; path : string) : TFhirTestReportSetupActionOperation;
var
  child : TMXmlElement;
begin
  result := TFhirTestReportSetupActionOperation.Create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseTestReportSetupActionOperationChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseTestReportSetupActionOperationChild(value : TFhirTestReportSetupActionOperation; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'result') then
        value.resultElement := ParseEnum(CODES_TFhirTestReportActionResultEnum, SYSTEMS_TFhirTestReportActionResultEnum, child, path+'/result')
      else if (child.localName = 'message') then
        value.messageElement := ParseMarkdown(child, path+'/message')
      else if (child.localName = 'detail') then
        value.detailElement := ParseUri(child, path+'/detail')
      else if Not ParseBackboneElementChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeTestReportSetupActionOperation(xml : TXmlBuilder; name : String; value : TFhirTestReportSetupActionOperation);
begin
  if (value = nil) then
    exit;
  composeElementAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeTestReportSetupActionOperationChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeTestReportSetupActionOperationChildren(xml : TXmlBuilder; value : TFhirTestReportSetupActionOperation);
begin
  composeBackboneElementChildren(xml, value);
  ComposeEnum(xml, 'result', value.resultElement, CODES_TFhirTestReportActionResultEnum);
  if (SummaryOption in [soFull, soData]) then
    ComposeMarkdown(xml, 'message', value.messageElement);
  if (SummaryOption in [soFull, soData]) then
    ComposeUri(xml, 'detail', value.detailElement);
end;

function TFHIRXmlParser.ParseTestReportSetupActionAssert(element : TMXmlElement; path : string) : TFhirTestReportSetupActionAssert;
var
  child : TMXmlElement;
begin
  result := TFhirTestReportSetupActionAssert.Create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseTestReportSetupActionAssertChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseTestReportSetupActionAssertChild(value : TFhirTestReportSetupActionAssert; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'result') then
        value.resultElement := ParseEnum(CODES_TFhirTestReportActionResultEnum, SYSTEMS_TFhirTestReportActionResultEnum, child, path+'/result')
      else if (child.localName = 'message') then
        value.messageElement := ParseMarkdown(child, path+'/message')
      else if (child.localName = 'detail') then
        value.detailElement := ParseString(child, path+'/detail')
      else if Not ParseBackboneElementChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeTestReportSetupActionAssert(xml : TXmlBuilder; name : String; value : TFhirTestReportSetupActionAssert);
begin
  if (value = nil) then
    exit;
  composeElementAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeTestReportSetupActionAssertChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeTestReportSetupActionAssertChildren(xml : TXmlBuilder; value : TFhirTestReportSetupActionAssert);
begin
  composeBackboneElementChildren(xml, value);
  ComposeEnum(xml, 'result', value.resultElement, CODES_TFhirTestReportActionResultEnum);
  if (SummaryOption in [soFull, soData]) then
    ComposeMarkdown(xml, 'message', value.messageElement);
  if (SummaryOption in [soFull, soData]) then
    ComposeString(xml, 'detail', value.detailElement);
end;

function TFHIRXmlParser.ParseTestReportTest(element : TMXmlElement; path : string) : TFhirTestReportTest;
var
  child : TMXmlElement;
begin
  result := TFhirTestReportTest.Create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseTestReportTestChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseTestReportTestChild(value : TFhirTestReportTest; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'name') then
        value.nameElement := ParseString(child, path+'/name')
      else if (child.localName = 'description') then
        value.descriptionElement := ParseString(child, path+'/description')
      else if (child.localName = 'action') then
        value.actionList.Add(ParseTestReportTestAction(child, path+'/action'))
      else if Not ParseBackboneElementChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeTestReportTest(xml : TXmlBuilder; name : String; value : TFhirTestReportTest);
begin
  if (value = nil) then
    exit;
  composeElementAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeTestReportTestChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeTestReportTestChildren(xml : TXmlBuilder; value : TFhirTestReportTest);
var
  i : integer;
begin
  composeBackboneElementChildren(xml, value);
  if (SummaryOption in [soFull, soData]) then
    ComposeString(xml, 'name', value.nameElement);
  if (SummaryOption in [soFull, soData]) then
    ComposeString(xml, 'description', value.descriptionElement);
  for i := 0 to value.actionList.Count - 1 do
      ComposeTestReportTestAction(xml, 'action', value.actionList[i]);
end;

function TFHIRXmlParser.ParseTestReportTestAction(element : TMXmlElement; path : string) : TFhirTestReportTestAction;
var
  child : TMXmlElement;
begin
  result := TFhirTestReportTestAction.Create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseTestReportTestActionChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseTestReportTestActionChild(value : TFhirTestReportTestAction; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'operation') then
        value.operation := ParseTestReportSetupActionOperation(child, path+'/operation')
      else if (child.localName = 'assert') then
        value.assert := ParseTestReportSetupActionAssert(child, path+'/assert')
      else if Not ParseBackboneElementChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeTestReportTestAction(xml : TXmlBuilder; name : String; value : TFhirTestReportTestAction);
begin
  if (value = nil) then
    exit;
  composeElementAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeTestReportTestActionChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeTestReportTestActionChildren(xml : TXmlBuilder; value : TFhirTestReportTestAction);
begin
  composeBackboneElementChildren(xml, value);
  if (SummaryOption in [soFull, soData]) then
    ComposeTestReportSetupActionOperation(xml, 'operation', value.operation);
  if (SummaryOption in [soFull, soData]) then
    ComposeTestReportSetupActionAssert(xml, 'assert', value.assert);
end;

function TFHIRXmlParser.ParseTestReportTeardown(element : TMXmlElement; path : string) : TFhirTestReportTeardown;
var
  child : TMXmlElement;
begin
  result := TFhirTestReportTeardown.Create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseTestReportTeardownChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseTestReportTeardownChild(value : TFhirTestReportTeardown; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'action') then
        value.actionList.Add(ParseTestReportTeardownAction(child, path+'/action'))
      else if Not ParseBackboneElementChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeTestReportTeardown(xml : TXmlBuilder; name : String; value : TFhirTestReportTeardown);
begin
  if (value = nil) then
    exit;
  composeElementAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeTestReportTeardownChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeTestReportTeardownChildren(xml : TXmlBuilder; value : TFhirTestReportTeardown);
var
  i : integer;
begin
  composeBackboneElementChildren(xml, value);
  for i := 0 to value.actionList.Count - 1 do
      ComposeTestReportTeardownAction(xml, 'action', value.actionList[i]);
end;

function TFHIRXmlParser.ParseTestReportTeardownAction(element : TMXmlElement; path : string) : TFhirTestReportTeardownAction;
var
  child : TMXmlElement;
begin
  result := TFhirTestReportTeardownAction.Create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseTestReportTeardownActionChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseTestReportTeardownActionChild(value : TFhirTestReportTeardownAction; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'operation') then
        value.operation := ParseTestReportSetupActionOperation(child, path+'/operation')
      else if Not ParseBackboneElementChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeTestReportTeardownAction(xml : TXmlBuilder; name : String; value : TFhirTestReportTeardownAction);
begin
  if (value = nil) then
    exit;
  composeElementAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeTestReportTeardownActionChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeTestReportTeardownActionChildren(xml : TXmlBuilder; value : TFhirTestReportTeardownAction);
begin
  composeBackboneElementChildren(xml, value);
  ComposeTestReportSetupActionOperation(xml, 'operation', value.operation);
end;

function TFHIRXmlParser.ParseTestReport(element : TMXmlElement; path : string) : TFhirTestReport;
var
  child : TMXmlElement;
begin
  result := TFhirTestReport.Create;
  try
    parseDomainResourceAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseTestReportChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseTestReportChild(value : TFhirTestReport; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'identifier') then
        value.identifier := ParseIdentifier(child, path+'/identifier')
      else if (child.localName = 'name') then
        value.nameElement := ParseString(child, path+'/name')
      else if (child.localName = 'status') then
        value.statusElement := ParseEnum(CODES_TFhirTestReportStatusEnum, SYSTEMS_TFhirTestReportStatusEnum, child, path+'/status')
      else if (child.localName = 'testScript') then
        value.testScriptElement := ParseCanonical(child, path+'/testScript')
      else if (child.localName = 'result') then
        value.resultElement := ParseEnum(CODES_TFhirTestReportResultEnum, SYSTEMS_TFhirTestReportResultEnum, child, path+'/result')
      else if (child.localName = 'score') then
        value.scoreElement := ParseDecimal(child, path+'/score')
      else if (child.localName = 'tester') then
        value.testerElement := ParseString(child, path+'/tester')
      else if (child.localName = 'issued') then
        value.issuedElement := ParseDateTime(child, path+'/issued')
      else if (child.localName = 'participant') then
        value.participantList.Add(ParseTestReportParticipant(child, path+'/participant'))
      else if (child.localName = 'setup') then
        value.setup := ParseTestReportSetup(child, path+'/setup')
      else if (child.localName = 'test') then
        value.testList.Add(ParseTestReportTest(child, path+'/test'))
      else if (child.localName = 'teardown') then
        value.teardown := ParseTestReportTeardown(child, path+'/teardown')
      else if Not ParseDomainResourceChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeTestReport(xml : TXmlBuilder; name : String; value : TFhirTestReport);
begin
  if (value = nil) then
    exit;
  composeDomainResourceAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeTestReportChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeTestReportChildren(xml : TXmlBuilder; value : TFhirTestReport);
var
  i : integer;
begin
  composeDomainResourceChildren(xml, value);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeIdentifier(xml, 'identifier', value.identifier);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(xml, 'name', value.nameElement);
  ComposeEnum(xml, 'status', value.statusElement, CODES_TFhirTestReportStatusEnum);
  ComposeCanonical(xml, 'testScript', value.testScriptElement);
  ComposeEnum(xml, 'result', value.resultElement, CODES_TFhirTestReportResultEnum);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDecimal(xml, 'score', value.scoreElement);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(xml, 'tester', value.testerElement);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDateTime(xml, 'issued', value.issuedElement);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.participantList.Count - 1 do
      ComposeTestReportParticipant(xml, 'participant', value.participantList[i]);
  if (SummaryOption in [soFull, soData]) then
    ComposeTestReportSetup(xml, 'setup', value.setup);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.testList.Count - 1 do
      ComposeTestReportTest(xml, 'test', value.testList[i]);
  if (SummaryOption in [soFull, soData]) then
    ComposeTestReportTeardown(xml, 'teardown', value.teardown);
end;

{$ENDIF FHIR_TESTREPORT}
{$IFDEF FHIR_TESTSCRIPT}
function TFHIRXmlParser.ParseTestScriptOrigin(element : TMXmlElement; path : string) : TFhirTestScriptOrigin;
var
  child : TMXmlElement;
begin
  result := TFhirTestScriptOrigin.Create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseTestScriptOriginChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseTestScriptOriginChild(value : TFhirTestScriptOrigin; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'index') then
        value.indexElement := ParseInteger(child, path+'/index')
      else if (child.localName = 'profile') then
        value.profile := ParseCoding(child, path+'/profile')
      else if Not ParseBackboneElementChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeTestScriptOrigin(xml : TXmlBuilder; name : String; value : TFhirTestScriptOrigin);
begin
  if (value = nil) then
    exit;
  composeElementAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeTestScriptOriginChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeTestScriptOriginChildren(xml : TXmlBuilder; value : TFhirTestScriptOrigin);
begin
  composeBackboneElementChildren(xml, value);
  ComposeInteger(xml, 'index', value.indexElement);
  ComposeCoding(xml, 'profile', value.profile);
end;

function TFHIRXmlParser.ParseTestScriptDestination(element : TMXmlElement; path : string) : TFhirTestScriptDestination;
var
  child : TMXmlElement;
begin
  result := TFhirTestScriptDestination.Create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseTestScriptDestinationChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseTestScriptDestinationChild(value : TFhirTestScriptDestination; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'index') then
        value.indexElement := ParseInteger(child, path+'/index')
      else if (child.localName = 'profile') then
        value.profile := ParseCoding(child, path+'/profile')
      else if Not ParseBackboneElementChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeTestScriptDestination(xml : TXmlBuilder; name : String; value : TFhirTestScriptDestination);
begin
  if (value = nil) then
    exit;
  composeElementAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeTestScriptDestinationChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeTestScriptDestinationChildren(xml : TXmlBuilder; value : TFhirTestScriptDestination);
begin
  composeBackboneElementChildren(xml, value);
  ComposeInteger(xml, 'index', value.indexElement);
  ComposeCoding(xml, 'profile', value.profile);
end;

function TFHIRXmlParser.ParseTestScriptMetadata(element : TMXmlElement; path : string) : TFhirTestScriptMetadata;
var
  child : TMXmlElement;
begin
  result := TFhirTestScriptMetadata.Create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseTestScriptMetadataChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseTestScriptMetadataChild(value : TFhirTestScriptMetadata; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'link') then
        value.link_List.Add(ParseTestScriptMetadataLink(child, path+'/link'))
      else if (child.localName = 'capability') then
        value.capabilityList.Add(ParseTestScriptMetadataCapability(child, path+'/capability'))
      else if Not ParseBackboneElementChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeTestScriptMetadata(xml : TXmlBuilder; name : String; value : TFhirTestScriptMetadata);
begin
  if (value = nil) then
    exit;
  composeElementAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeTestScriptMetadataChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeTestScriptMetadataChildren(xml : TXmlBuilder; value : TFhirTestScriptMetadata);
var
  i : integer;
begin
  composeBackboneElementChildren(xml, value);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.link_List.Count - 1 do
      ComposeTestScriptMetadataLink(xml, 'link', value.link_List[i]);
  for i := 0 to value.capabilityList.Count - 1 do
      ComposeTestScriptMetadataCapability(xml, 'capability', value.capabilityList[i]);
end;

function TFHIRXmlParser.ParseTestScriptMetadataLink(element : TMXmlElement; path : string) : TFhirTestScriptMetadataLink;
var
  child : TMXmlElement;
begin
  result := TFhirTestScriptMetadataLink.Create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseTestScriptMetadataLinkChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseTestScriptMetadataLinkChild(value : TFhirTestScriptMetadataLink; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'url') then
        value.urlElement := ParseUri(child, path+'/url')
      else if (child.localName = 'description') then
        value.descriptionElement := ParseString(child, path+'/description')
      else if Not ParseBackboneElementChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeTestScriptMetadataLink(xml : TXmlBuilder; name : String; value : TFhirTestScriptMetadataLink);
begin
  if (value = nil) then
    exit;
  composeElementAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeTestScriptMetadataLinkChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeTestScriptMetadataLinkChildren(xml : TXmlBuilder; value : TFhirTestScriptMetadataLink);
begin
  composeBackboneElementChildren(xml, value);
  ComposeUri(xml, 'url', value.urlElement);
  if (SummaryOption in [soFull, soData]) then
    ComposeString(xml, 'description', value.descriptionElement);
end;

function TFHIRXmlParser.ParseTestScriptMetadataCapability(element : TMXmlElement; path : string) : TFhirTestScriptMetadataCapability;
var
  child : TMXmlElement;
begin
  result := TFhirTestScriptMetadataCapability.Create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseTestScriptMetadataCapabilityChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseTestScriptMetadataCapabilityChild(value : TFhirTestScriptMetadataCapability; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'required') then
        value.requiredElement := ParseBoolean(child, path+'/required')
      else if (child.localName = 'validated') then
        value.validatedElement := ParseBoolean(child, path+'/validated')
      else if (child.localName = 'description') then
        value.descriptionElement := ParseString(child, path+'/description')
      else if (child.localName = 'origin') then
        value.originList.Add(ParseInteger(child, path+'/origin'))
      else if (child.localName = 'destination') then
        value.destinationElement := ParseInteger(child, path+'/destination')
      else if (child.localName = 'link') then
        value.link_List.Add(ParseUri(child, path+'/link'))
      else if (child.localName = 'capabilities') then
        value.capabilitiesElement := ParseCanonical(child, path+'/capabilities')
      else if Not ParseBackboneElementChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeTestScriptMetadataCapability(xml : TXmlBuilder; name : String; value : TFhirTestScriptMetadataCapability);
begin
  if (value = nil) then
    exit;
  composeElementAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeTestScriptMetadataCapabilityChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeTestScriptMetadataCapabilityChildren(xml : TXmlBuilder; value : TFhirTestScriptMetadataCapability);
var
  i : integer;
begin
  composeBackboneElementChildren(xml, value);
  ComposeBoolean(xml, 'required', value.requiredElement);
  ComposeBoolean(xml, 'validated', value.validatedElement);
  if (SummaryOption in [soFull, soData]) then
    ComposeString(xml, 'description', value.descriptionElement);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.originList.Count - 1 do
      ComposeInteger(xml, 'origin', value.originList[i]);
  if (SummaryOption in [soFull, soData]) then
    ComposeInteger(xml, 'destination', value.destinationElement);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.link_List.Count - 1 do
      ComposeUri(xml, 'link', value.link_List[i]);
  ComposeCanonical(xml, 'capabilities', value.capabilitiesElement);
end;

function TFHIRXmlParser.ParseTestScriptScope(element : TMXmlElement; path : string) : TFhirTestScriptScope;
var
  child : TMXmlElement;
begin
  result := TFhirTestScriptScope.Create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseTestScriptScopeChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseTestScriptScopeChild(value : TFhirTestScriptScope; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'artifact') then
        value.artifactElement := ParseCanonical(child, path+'/artifact')
      else if (child.localName = 'conformance') then
        value.conformance := ParseCodeableConcept(child, path+'/conformance')
      else if (child.localName = 'phase') then
        value.phase := ParseCodeableConcept(child, path+'/phase')
      else if Not ParseBackboneElementChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeTestScriptScope(xml : TXmlBuilder; name : String; value : TFhirTestScriptScope);
begin
  if (value = nil) then
    exit;
  composeElementAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeTestScriptScopeChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeTestScriptScopeChildren(xml : TXmlBuilder; value : TFhirTestScriptScope);
begin
  composeBackboneElementChildren(xml, value);
  ComposeCanonical(xml, 'artifact', value.artifactElement);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(xml, 'conformance', value.conformance);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(xml, 'phase', value.phase);
end;

function TFHIRXmlParser.ParseTestScriptFixture(element : TMXmlElement; path : string) : TFhirTestScriptFixture;
var
  child : TMXmlElement;
begin
  result := TFhirTestScriptFixture.Create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseTestScriptFixtureChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseTestScriptFixtureChild(value : TFhirTestScriptFixture; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'autocreate') then
        value.autocreateElement := ParseBoolean(child, path+'/autocreate')
      else if (child.localName = 'autodelete') then
        value.autodeleteElement := ParseBoolean(child, path+'/autodelete')
      else if (child.localName = 'resource') then
        value.resource := ParseReference(child, path+'/resource')
      else if Not ParseBackboneElementChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeTestScriptFixture(xml : TXmlBuilder; name : String; value : TFhirTestScriptFixture);
begin
  if (value = nil) then
    exit;
  composeElementAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeTestScriptFixtureChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeTestScriptFixtureChildren(xml : TXmlBuilder; value : TFhirTestScriptFixture);
begin
  composeBackboneElementChildren(xml, value);
  ComposeBoolean(xml, 'autocreate', value.autocreateElement);
  ComposeBoolean(xml, 'autodelete', value.autodeleteElement);
  if (SummaryOption in [soFull, soData]) then
    ComposeReference(xml, 'resource', value.resource);
end;

function TFHIRXmlParser.ParseTestScriptVariable(element : TMXmlElement; path : string) : TFhirTestScriptVariable;
var
  child : TMXmlElement;
begin
  result := TFhirTestScriptVariable.Create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseTestScriptVariableChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseTestScriptVariableChild(value : TFhirTestScriptVariable; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'name') then
        value.nameElement := ParseString(child, path+'/name')
      else if (child.localName = 'defaultValue') then
        value.defaultValueElement := ParseString(child, path+'/defaultValue')
      else if (child.localName = 'description') then
        value.descriptionElement := ParseString(child, path+'/description')
      else if (child.localName = 'expression') then
        value.expressionElement := ParseString(child, path+'/expression')
      else if (child.localName = 'headerField') then
        value.headerFieldElement := ParseString(child, path+'/headerField')
      else if (child.localName = 'hint') then
        value.hintElement := ParseString(child, path+'/hint')
      else if (child.localName = 'path') then
        value.pathElement := ParseString(child, path+'/path')
      else if (child.localName = 'sourceId') then
        value.sourceIdElement := ParseId(child, path+'/sourceId')
      else if Not ParseBackboneElementChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeTestScriptVariable(xml : TXmlBuilder; name : String; value : TFhirTestScriptVariable);
begin
  if (value = nil) then
    exit;
  composeElementAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeTestScriptVariableChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeTestScriptVariableChildren(xml : TXmlBuilder; value : TFhirTestScriptVariable);
begin
  composeBackboneElementChildren(xml, value);
  ComposeString(xml, 'name', value.nameElement);
  if (SummaryOption in [soFull, soData]) then
    ComposeString(xml, 'defaultValue', value.defaultValueElement);
  if (SummaryOption in [soFull, soData]) then
    ComposeString(xml, 'description', value.descriptionElement);
  if (SummaryOption in [soFull, soData]) then
    ComposeString(xml, 'expression', value.expressionElement);
  if (SummaryOption in [soFull, soData]) then
    ComposeString(xml, 'headerField', value.headerFieldElement);
  if (SummaryOption in [soFull, soData]) then
    ComposeString(xml, 'hint', value.hintElement);
  if (SummaryOption in [soFull, soData]) then
    ComposeString(xml, 'path', value.pathElement);
  if (SummaryOption in [soFull, soData]) then
    ComposeId(xml, 'sourceId', value.sourceIdElement);
end;

function TFHIRXmlParser.ParseTestScriptSetup(element : TMXmlElement; path : string) : TFhirTestScriptSetup;
var
  child : TMXmlElement;
begin
  result := TFhirTestScriptSetup.Create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseTestScriptSetupChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseTestScriptSetupChild(value : TFhirTestScriptSetup; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'action') then
        value.actionList.Add(ParseTestScriptSetupAction(child, path+'/action'))
      else if Not ParseBackboneElementChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeTestScriptSetup(xml : TXmlBuilder; name : String; value : TFhirTestScriptSetup);
begin
  if (value = nil) then
    exit;
  composeElementAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeTestScriptSetupChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeTestScriptSetupChildren(xml : TXmlBuilder; value : TFhirTestScriptSetup);
var
  i : integer;
begin
  composeBackboneElementChildren(xml, value);
  for i := 0 to value.actionList.Count - 1 do
      ComposeTestScriptSetupAction(xml, 'action', value.actionList[i]);
end;

function TFHIRXmlParser.ParseTestScriptSetupAction(element : TMXmlElement; path : string) : TFhirTestScriptSetupAction;
var
  child : TMXmlElement;
begin
  result := TFhirTestScriptSetupAction.Create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseTestScriptSetupActionChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseTestScriptSetupActionChild(value : TFhirTestScriptSetupAction; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'operation') then
        value.operation := ParseTestScriptSetupActionOperation(child, path+'/operation')
      else if (child.localName = 'assert') then
        value.assert := ParseTestScriptSetupActionAssert(child, path+'/assert')
      else if Not ParseBackboneElementChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeTestScriptSetupAction(xml : TXmlBuilder; name : String; value : TFhirTestScriptSetupAction);
begin
  if (value = nil) then
    exit;
  composeElementAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeTestScriptSetupActionChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeTestScriptSetupActionChildren(xml : TXmlBuilder; value : TFhirTestScriptSetupAction);
begin
  composeBackboneElementChildren(xml, value);
  if (SummaryOption in [soFull, soData]) then
    ComposeTestScriptSetupActionOperation(xml, 'operation', value.operation);
  if (SummaryOption in [soFull, soData]) then
    ComposeTestScriptSetupActionAssert(xml, 'assert', value.assert);
end;

function TFHIRXmlParser.ParseTestScriptSetupActionOperation(element : TMXmlElement; path : string) : TFhirTestScriptSetupActionOperation;
var
  child : TMXmlElement;
begin
  result := TFhirTestScriptSetupActionOperation.Create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseTestScriptSetupActionOperationChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseTestScriptSetupActionOperationChild(value : TFhirTestScriptSetupActionOperation; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'type') then
        value.type_ := ParseCoding(child, path+'/type')
      else if (child.localName = 'resource') then
        value.resourceElement := ParseUri(child, path+'/resource')
      else if (child.localName = 'label') then
        value.label_Element := ParseString(child, path+'/label')
      else if (child.localName = 'description') then
        value.descriptionElement := ParseString(child, path+'/description')
      else if (child.localName = 'accept') then
        value.acceptElement := ParseCode(child, path+'/accept')
      else if (child.localName = 'contentType') then
        value.contentTypeElement := ParseCode(child, path+'/contentType')
      else if (child.localName = 'destination') then
        value.destinationElement := ParseInteger(child, path+'/destination')
      else if (child.localName = 'encodeRequestUrl') then
        value.encodeRequestUrlElement := ParseBoolean(child, path+'/encodeRequestUrl')
      else if (child.localName = 'method') then
        value.methodElement := ParseEnum(CODES_TFhirTestScriptRequestMethodCodeEnum, SYSTEMS_TFhirTestScriptRequestMethodCodeEnum, child, path+'/method')
      else if (child.localName = 'origin') then
        value.originElement := ParseInteger(child, path+'/origin')
      else if (child.localName = 'params') then
        value.paramsElement := ParseString(child, path+'/params')
      else if (child.localName = 'requestHeader') then
        value.requestHeaderList.Add(ParseTestScriptSetupActionOperationRequestHeader(child, path+'/requestHeader'))
      else if (child.localName = 'requestId') then
        value.requestIdElement := ParseId(child, path+'/requestId')
      else if (child.localName = 'responseId') then
        value.responseIdElement := ParseId(child, path+'/responseId')
      else if (child.localName = 'sourceId') then
        value.sourceIdElement := ParseId(child, path+'/sourceId')
      else if (child.localName = 'targetId') then
        value.targetIdElement := ParseId(child, path+'/targetId')
      else if (child.localName = 'url') then
        value.urlElement := ParseString(child, path+'/url')
      else if Not ParseBackboneElementChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeTestScriptSetupActionOperation(xml : TXmlBuilder; name : String; value : TFhirTestScriptSetupActionOperation);
begin
  if (value = nil) then
    exit;
  composeElementAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeTestScriptSetupActionOperationChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeTestScriptSetupActionOperationChildren(xml : TXmlBuilder; value : TFhirTestScriptSetupActionOperation);
var
  i : integer;
begin
  composeBackboneElementChildren(xml, value);
  if (SummaryOption in [soFull, soData]) then
    ComposeCoding(xml, 'type', value.type_);
  if (SummaryOption in [soFull, soData]) then
    ComposeUri(xml, 'resource', value.resourceElement);
  if (SummaryOption in [soFull, soData]) then
    ComposeString(xml, 'label', value.label_Element);
  if (SummaryOption in [soFull, soData]) then
    ComposeString(xml, 'description', value.descriptionElement);
  if (SummaryOption in [soFull, soData]) then
    ComposeCode(xml, 'accept', value.acceptElement);
  if (SummaryOption in [soFull, soData]) then
    ComposeCode(xml, 'contentType', value.contentTypeElement);
  if (SummaryOption in [soFull, soData]) then
    ComposeInteger(xml, 'destination', value.destinationElement);
  ComposeBoolean(xml, 'encodeRequestUrl', value.encodeRequestUrlElement);
  if (SummaryOption in [soFull, soData]) then
    ComposeEnum(xml, 'method', value.methodElement, CODES_TFhirTestScriptRequestMethodCodeEnum);
  if (SummaryOption in [soFull, soData]) then
    ComposeInteger(xml, 'origin', value.originElement);
  if (SummaryOption in [soFull, soData]) then
    ComposeString(xml, 'params', value.paramsElement);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.requestHeaderList.Count - 1 do
      ComposeTestScriptSetupActionOperationRequestHeader(xml, 'requestHeader', value.requestHeaderList[i]);
  if (SummaryOption in [soFull, soData]) then
    ComposeId(xml, 'requestId', value.requestIdElement);
  if (SummaryOption in [soFull, soData]) then
    ComposeId(xml, 'responseId', value.responseIdElement);
  if (SummaryOption in [soFull, soData]) then
    ComposeId(xml, 'sourceId', value.sourceIdElement);
  if (SummaryOption in [soFull, soData]) then
    ComposeId(xml, 'targetId', value.targetIdElement);
  if (SummaryOption in [soFull, soData]) then
    ComposeString(xml, 'url', value.urlElement);
end;

function TFHIRXmlParser.ParseTestScriptSetupActionOperationRequestHeader(element : TMXmlElement; path : string) : TFhirTestScriptSetupActionOperationRequestHeader;
var
  child : TMXmlElement;
begin
  result := TFhirTestScriptSetupActionOperationRequestHeader.Create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseTestScriptSetupActionOperationRequestHeaderChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseTestScriptSetupActionOperationRequestHeaderChild(value : TFhirTestScriptSetupActionOperationRequestHeader; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'field') then
        value.fieldElement := ParseString(child, path+'/field')
      else if (child.localName = 'value') then
        value.valueElement := ParseString(child, path+'/value')
      else if Not ParseBackboneElementChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeTestScriptSetupActionOperationRequestHeader(xml : TXmlBuilder; name : String; value : TFhirTestScriptSetupActionOperationRequestHeader);
begin
  if (value = nil) then
    exit;
  composeElementAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeTestScriptSetupActionOperationRequestHeaderChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeTestScriptSetupActionOperationRequestHeaderChildren(xml : TXmlBuilder; value : TFhirTestScriptSetupActionOperationRequestHeader);
begin
  composeBackboneElementChildren(xml, value);
  ComposeString(xml, 'field', value.fieldElement);
  ComposeString(xml, 'value', value.valueElement);
end;

function TFHIRXmlParser.ParseTestScriptSetupActionAssert(element : TMXmlElement; path : string) : TFhirTestScriptSetupActionAssert;
var
  child : TMXmlElement;
begin
  result := TFhirTestScriptSetupActionAssert.Create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseTestScriptSetupActionAssertChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseTestScriptSetupActionAssertChild(value : TFhirTestScriptSetupActionAssert; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'label') then
        value.label_Element := ParseString(child, path+'/label')
      else if (child.localName = 'description') then
        value.descriptionElement := ParseString(child, path+'/description')
      else if (child.localName = 'direction') then
        value.directionElement := ParseEnum(CODES_TFhirAssertionDirectionTypeEnum, SYSTEMS_TFhirAssertionDirectionTypeEnum, child, path+'/direction')
      else if (child.localName = 'compareToSourceId') then
        value.compareToSourceIdElement := ParseString(child, path+'/compareToSourceId')
      else if (child.localName = 'compareToSourceExpression') then
        value.compareToSourceExpressionElement := ParseString(child, path+'/compareToSourceExpression')
      else if (child.localName = 'compareToSourcePath') then
        value.compareToSourcePathElement := ParseString(child, path+'/compareToSourcePath')
      else if (child.localName = 'contentType') then
        value.contentTypeElement := ParseCode(child, path+'/contentType')
      else if (child.localName = 'expression') then
        value.expressionElement := ParseString(child, path+'/expression')
      else if (child.localName = 'headerField') then
        value.headerFieldElement := ParseString(child, path+'/headerField')
      else if (child.localName = 'minimumId') then
        value.minimumIdElement := ParseString(child, path+'/minimumId')
      else if (child.localName = 'navigationLinks') then
        value.navigationLinksElement := ParseBoolean(child, path+'/navigationLinks')
      else if (child.localName = 'operator') then
        value.operatorElement := ParseEnum(CODES_TFhirAssertionOperatorTypeEnum, SYSTEMS_TFhirAssertionOperatorTypeEnum, child, path+'/operator')
      else if (child.localName = 'path') then
        value.pathElement := ParseString(child, path+'/path')
      else if (child.localName = 'requestMethod') then
        value.requestMethodElement := ParseEnum(CODES_TFhirTestScriptRequestMethodCodeEnum, SYSTEMS_TFhirTestScriptRequestMethodCodeEnum, child, path+'/requestMethod')
      else if (child.localName = 'requestURL') then
        value.requestURLElement := ParseString(child, path+'/requestURL')
      else if (child.localName = 'resource') then
        value.resourceElement := ParseUri(child, path+'/resource')
      else if (child.localName = 'response') then
        value.responseElement := ParseEnum(CODES_TFhirAssertionResponseTypesEnum, SYSTEMS_TFhirAssertionResponseTypesEnum, child, path+'/response')
      else if (child.localName = 'responseCode') then
        value.responseCodeElement := ParseString(child, path+'/responseCode')
      else if (child.localName = 'sourceId') then
        value.sourceIdElement := ParseId(child, path+'/sourceId')
      else if (child.localName = 'stopTestOnFail') then
        value.stopTestOnFailElement := ParseBoolean(child, path+'/stopTestOnFail')
      else if (child.localName = 'validateProfileId') then
        value.validateProfileIdElement := ParseId(child, path+'/validateProfileId')
      else if (child.localName = 'value') then
        value.valueElement := ParseString(child, path+'/value')
      else if (child.localName = 'warningOnly') then
        value.warningOnlyElement := ParseBoolean(child, path+'/warningOnly')
      else if Not ParseBackboneElementChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeTestScriptSetupActionAssert(xml : TXmlBuilder; name : String; value : TFhirTestScriptSetupActionAssert);
begin
  if (value = nil) then
    exit;
  composeElementAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeTestScriptSetupActionAssertChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeTestScriptSetupActionAssertChildren(xml : TXmlBuilder; value : TFhirTestScriptSetupActionAssert);
begin
  composeBackboneElementChildren(xml, value);
  if (SummaryOption in [soFull, soData]) then
    ComposeString(xml, 'label', value.label_Element);
  if (SummaryOption in [soFull, soData]) then
    ComposeString(xml, 'description', value.descriptionElement);
  if (SummaryOption in [soFull, soData]) then
    ComposeEnum(xml, 'direction', value.directionElement, CODES_TFhirAssertionDirectionTypeEnum);
  if (SummaryOption in [soFull, soData]) then
    ComposeString(xml, 'compareToSourceId', value.compareToSourceIdElement);
  if (SummaryOption in [soFull, soData]) then
    ComposeString(xml, 'compareToSourceExpression', value.compareToSourceExpressionElement);
  if (SummaryOption in [soFull, soData]) then
    ComposeString(xml, 'compareToSourcePath', value.compareToSourcePathElement);
  if (SummaryOption in [soFull, soData]) then
    ComposeCode(xml, 'contentType', value.contentTypeElement);
  if (SummaryOption in [soFull, soData]) then
    ComposeString(xml, 'expression', value.expressionElement);
  if (SummaryOption in [soFull, soData]) then
    ComposeString(xml, 'headerField', value.headerFieldElement);
  if (SummaryOption in [soFull, soData]) then
    ComposeString(xml, 'minimumId', value.minimumIdElement);
  if (SummaryOption in [soFull, soData]) then
    ComposeBoolean(xml, 'navigationLinks', value.navigationLinksElement);
  if (SummaryOption in [soFull, soData]) then
    ComposeEnum(xml, 'operator', value.operatorElement, CODES_TFhirAssertionOperatorTypeEnum);
  if (SummaryOption in [soFull, soData]) then
    ComposeString(xml, 'path', value.pathElement);
  if (SummaryOption in [soFull, soData]) then
    ComposeEnum(xml, 'requestMethod', value.requestMethodElement, CODES_TFhirTestScriptRequestMethodCodeEnum);
  if (SummaryOption in [soFull, soData]) then
    ComposeString(xml, 'requestURL', value.requestURLElement);
  if (SummaryOption in [soFull, soData]) then
    ComposeUri(xml, 'resource', value.resourceElement);
  if (SummaryOption in [soFull, soData]) then
    ComposeEnum(xml, 'response', value.responseElement, CODES_TFhirAssertionResponseTypesEnum);
  if (SummaryOption in [soFull, soData]) then
    ComposeString(xml, 'responseCode', value.responseCodeElement);
  if (SummaryOption in [soFull, soData]) then
    ComposeId(xml, 'sourceId', value.sourceIdElement);
  ComposeBoolean(xml, 'stopTestOnFail', value.stopTestOnFailElement);
  if (SummaryOption in [soFull, soData]) then
    ComposeId(xml, 'validateProfileId', value.validateProfileIdElement);
  if (SummaryOption in [soFull, soData]) then
    ComposeString(xml, 'value', value.valueElement);
  ComposeBoolean(xml, 'warningOnly', value.warningOnlyElement);
end;

function TFHIRXmlParser.ParseTestScriptTest(element : TMXmlElement; path : string) : TFhirTestScriptTest;
var
  child : TMXmlElement;
begin
  result := TFhirTestScriptTest.Create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseTestScriptTestChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseTestScriptTestChild(value : TFhirTestScriptTest; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'name') then
        value.nameElement := ParseString(child, path+'/name')
      else if (child.localName = 'description') then
        value.descriptionElement := ParseString(child, path+'/description')
      else if (child.localName = 'action') then
        value.actionList.Add(ParseTestScriptTestAction(child, path+'/action'))
      else if Not ParseBackboneElementChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeTestScriptTest(xml : TXmlBuilder; name : String; value : TFhirTestScriptTest);
begin
  if (value = nil) then
    exit;
  composeElementAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeTestScriptTestChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeTestScriptTestChildren(xml : TXmlBuilder; value : TFhirTestScriptTest);
var
  i : integer;
begin
  composeBackboneElementChildren(xml, value);
  if (SummaryOption in [soFull, soData]) then
    ComposeString(xml, 'name', value.nameElement);
  if (SummaryOption in [soFull, soData]) then
    ComposeString(xml, 'description', value.descriptionElement);
  for i := 0 to value.actionList.Count - 1 do
      ComposeTestScriptTestAction(xml, 'action', value.actionList[i]);
end;

function TFHIRXmlParser.ParseTestScriptTestAction(element : TMXmlElement; path : string) : TFhirTestScriptTestAction;
var
  child : TMXmlElement;
begin
  result := TFhirTestScriptTestAction.Create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseTestScriptTestActionChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseTestScriptTestActionChild(value : TFhirTestScriptTestAction; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'operation') then
        value.operation := ParseTestScriptSetupActionOperation(child, path+'/operation')
      else if (child.localName = 'assert') then
        value.assert := ParseTestScriptSetupActionAssert(child, path+'/assert')
      else if Not ParseBackboneElementChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeTestScriptTestAction(xml : TXmlBuilder; name : String; value : TFhirTestScriptTestAction);
begin
  if (value = nil) then
    exit;
  composeElementAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeTestScriptTestActionChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeTestScriptTestActionChildren(xml : TXmlBuilder; value : TFhirTestScriptTestAction);
begin
  composeBackboneElementChildren(xml, value);
  if (SummaryOption in [soFull, soData]) then
    ComposeTestScriptSetupActionOperation(xml, 'operation', value.operation);
  if (SummaryOption in [soFull, soData]) then
    ComposeTestScriptSetupActionAssert(xml, 'assert', value.assert);
end;

function TFHIRXmlParser.ParseTestScriptTeardown(element : TMXmlElement; path : string) : TFhirTestScriptTeardown;
var
  child : TMXmlElement;
begin
  result := TFhirTestScriptTeardown.Create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseTestScriptTeardownChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseTestScriptTeardownChild(value : TFhirTestScriptTeardown; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'action') then
        value.actionList.Add(ParseTestScriptTeardownAction(child, path+'/action'))
      else if Not ParseBackboneElementChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeTestScriptTeardown(xml : TXmlBuilder; name : String; value : TFhirTestScriptTeardown);
begin
  if (value = nil) then
    exit;
  composeElementAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeTestScriptTeardownChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeTestScriptTeardownChildren(xml : TXmlBuilder; value : TFhirTestScriptTeardown);
var
  i : integer;
begin
  composeBackboneElementChildren(xml, value);
  for i := 0 to value.actionList.Count - 1 do
      ComposeTestScriptTeardownAction(xml, 'action', value.actionList[i]);
end;

function TFHIRXmlParser.ParseTestScriptTeardownAction(element : TMXmlElement; path : string) : TFhirTestScriptTeardownAction;
var
  child : TMXmlElement;
begin
  result := TFhirTestScriptTeardownAction.Create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseTestScriptTeardownActionChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseTestScriptTeardownActionChild(value : TFhirTestScriptTeardownAction; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'operation') then
        value.operation := ParseTestScriptSetupActionOperation(child, path+'/operation')
      else if Not ParseBackboneElementChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeTestScriptTeardownAction(xml : TXmlBuilder; name : String; value : TFhirTestScriptTeardownAction);
begin
  if (value = nil) then
    exit;
  composeElementAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeTestScriptTeardownActionChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeTestScriptTeardownActionChildren(xml : TXmlBuilder; value : TFhirTestScriptTeardownAction);
begin
  composeBackboneElementChildren(xml, value);
  ComposeTestScriptSetupActionOperation(xml, 'operation', value.operation);
end;

function TFHIRXmlParser.ParseTestScript(element : TMXmlElement; path : string) : TFhirTestScript;
var
  child : TMXmlElement;
begin
  result := TFhirTestScript.Create;
  try
    parseCanonicalResourceAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseTestScriptChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseTestScriptChild(value : TFhirTestScript; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'url') then
        value.urlElement := ParseUri(child, path+'/url')
      else if (child.localName = 'identifier') then
        value.identifierList.Add(ParseIdentifier(child, path+'/identifier'))
      else if (child.localName = 'version') then
        value.versionElement := ParseString(child, path+'/version')
      else if (child.localName = 'versionAlgorithmCoding') then
        value.versionAlgorithm := ParseCoding(child, path+'/versionAlgorithmCoding')
      else if (child.localName = 'versionAlgorithmString') then
        value.versionAlgorithm := ParseString(child, path+'/versionAlgorithmString')
      else if (child.localName = 'name') then
        value.nameElement := ParseString(child, path+'/name')
      else if (child.localName = 'title') then
        value.titleElement := ParseString(child, path+'/title')
      else if (child.localName = 'status') then
        value.statusElement := ParseEnum(CODES_TFhirPublicationStatusEnum, SYSTEMS_TFhirPublicationStatusEnum, child, path+'/status')
      else if (child.localName = 'experimental') then
        value.experimentalElement := ParseBoolean(child, path+'/experimental')
      else if (child.localName = 'date') then
        value.dateElement := ParseDateTime(child, path+'/date')
      else if (child.localName = 'publisher') then
        value.publisherElement := ParseString(child, path+'/publisher')
      else if (child.localName = 'contact') then
        value.contactList.Add(ParseContactDetail(child, path+'/contact'))
      else if (child.localName = 'description') then
        value.descriptionElement := ParseMarkdown(child, path+'/description')
      else if (child.localName = 'useContext') then
        value.useContextList.Add(ParseUsageContext(child, path+'/useContext'))
      else if (child.localName = 'jurisdiction') then
        value.jurisdictionList.Add(ParseCodeableConcept(child, path+'/jurisdiction'))
      else if (child.localName = 'purpose') then
        value.purposeElement := ParseMarkdown(child, path+'/purpose')
      else if (child.localName = 'copyright') then
        value.copyrightElement := ParseMarkdown(child, path+'/copyright')
      else if (child.localName = 'copyrightLabel') then
        value.copyrightLabelElement := ParseString(child, path+'/copyrightLabel')
      else if (child.localName = 'origin') then
        value.originList.Add(ParseTestScriptOrigin(child, path+'/origin'))
      else if (child.localName = 'destination') then
        value.destinationList.Add(ParseTestScriptDestination(child, path+'/destination'))
      else if (child.localName = 'metadata') then
        value.metadata := ParseTestScriptMetadata(child, path+'/metadata')
      else if (child.localName = 'scope') then
        value.scopeList.Add(ParseTestScriptScope(child, path+'/scope'))
      else if (child.localName = 'fixture') then
        value.fixtureList.Add(ParseTestScriptFixture(child, path+'/fixture'))
      else if (child.localName = 'profile') then
        value.profileList.Add(ParseReference(child, path+'/profile'))
      else if (child.localName = 'variable') then
        value.variableList.Add(ParseTestScriptVariable(child, path+'/variable'))
      else if (child.localName = 'setup') then
        value.setup := ParseTestScriptSetup(child, path+'/setup')
      else if (child.localName = 'test') then
        value.testList.Add(ParseTestScriptTest(child, path+'/test'))
      else if (child.localName = 'teardown') then
        value.teardown := ParseTestScriptTeardown(child, path+'/teardown')
      else if Not ParseCanonicalResourceChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeTestScript(xml : TXmlBuilder; name : String; value : TFhirTestScript);
begin
  if (value = nil) then
    exit;
  composeCanonicalResourceAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeTestScriptChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeTestScriptChildren(xml : TXmlBuilder; value : TFhirTestScript);
var
  i : integer;
begin
  composeCanonicalResourceChildren(xml, value);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeUri(xml, 'url', value.urlElement);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.identifierList.Count - 1 do
      ComposeIdentifier(xml, 'identifier', value.identifierList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(xml, 'version', value.versionElement);
  if (SummaryOption in [soFull, soSummary, soData]) and (value.versionAlgorithm is TFhirCoding) {6} then
    ComposeCoding(xml, 'versionAlgorithmCoding', TFhirCoding(value.versionAlgorithm))
  else if (SummaryOption in [soFull, soSummary, soData]) and (value.versionAlgorithm is TFhirString) {6} then
    ComposeString(xml, 'versionAlgorithmString', TFhirString(value.versionAlgorithm));
  ComposeString(xml, 'name', value.nameElement);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(xml, 'title', value.titleElement);
  ComposeEnum(xml, 'status', value.statusElement, CODES_TFhirPublicationStatusEnum);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeBoolean(xml, 'experimental', value.experimentalElement);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDateTime(xml, 'date', value.dateElement);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(xml, 'publisher', value.publisherElement);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.contactList.Count - 1 do
      ComposeContactDetail(xml, 'contact', value.contactList[i]);
  if (SummaryOption in [soFull, soData]) then
    ComposeMarkdown(xml, 'description', value.descriptionElement);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.useContextList.Count - 1 do
      ComposeUsageContext(xml, 'useContext', value.useContextList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.jurisdictionList.Count - 1 do
      ComposeCodeableConcept(xml, 'jurisdiction', value.jurisdictionList[i]);
  if (SummaryOption in [soFull, soData]) then
    ComposeMarkdown(xml, 'purpose', value.purposeElement);
  if (SummaryOption in [soFull, soData]) then
    ComposeMarkdown(xml, 'copyright', value.copyrightElement);
  if (SummaryOption in [soFull, soData]) then
    ComposeString(xml, 'copyrightLabel', value.copyrightLabelElement);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.originList.Count - 1 do
      ComposeTestScriptOrigin(xml, 'origin', value.originList[i]);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.destinationList.Count - 1 do
      ComposeTestScriptDestination(xml, 'destination', value.destinationList[i]);
  if (SummaryOption in [soFull, soData]) then
    ComposeTestScriptMetadata(xml, 'metadata', value.metadata);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.scopeList.Count - 1 do
      ComposeTestScriptScope(xml, 'scope', value.scopeList[i]);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.fixtureList.Count - 1 do
      ComposeTestScriptFixture(xml, 'fixture', value.fixtureList[i]);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.profileList.Count - 1 do
      ComposeReference(xml, 'profile', value.profileList[i]);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.variableList.Count - 1 do
      ComposeTestScriptVariable(xml, 'variable', value.variableList[i]);
  if (SummaryOption in [soFull, soData]) then
    ComposeTestScriptSetup(xml, 'setup', value.setup);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.testList.Count - 1 do
      ComposeTestScriptTest(xml, 'test', value.testList[i]);
  if (SummaryOption in [soFull, soData]) then
    ComposeTestScriptTeardown(xml, 'teardown', value.teardown);
end;

{$ENDIF FHIR_TESTSCRIPT}
{$IFDEF FHIR_TRANSPORT}
function TFHIRXmlParser.ParseTransportRestriction(element : TMXmlElement; path : string) : TFhirTransportRestriction;
var
  child : TMXmlElement;
begin
  result := TFhirTransportRestriction.Create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseTransportRestrictionChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseTransportRestrictionChild(value : TFhirTransportRestriction; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'repetitions') then
        value.repetitionsElement := ParsePositiveInt(child, path+'/repetitions')
      else if (child.localName = 'period') then
        value.period := ParsePeriod(child, path+'/period')
      else if (child.localName = 'recipient') then
        value.recipientList.Add(ParseReference(child, path+'/recipient'))
      else if Not ParseBackboneElementChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeTransportRestriction(xml : TXmlBuilder; name : String; value : TFhirTransportRestriction);
begin
  if (value = nil) then
    exit;
  composeElementAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeTransportRestrictionChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeTransportRestrictionChildren(xml : TXmlBuilder; value : TFhirTransportRestriction);
var
  i : integer;
begin
  composeBackboneElementChildren(xml, value);
  if (SummaryOption in [soFull, soData]) then
    ComposePositiveInt(xml, 'repetitions', value.repetitionsElement);
  if (SummaryOption in [soFull, soData]) then
    ComposePeriod(xml, 'period', value.period);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.recipientList.Count - 1 do
      ComposeReference(xml, 'recipient', value.recipientList[i]);
end;

function TFHIRXmlParser.ParseTransportInput(element : TMXmlElement; path : string) : TFhirTransportInput;
var
  child : TMXmlElement;
begin
  result := TFhirTransportInput.Create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseTransportInputChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseTransportInputChild(value : TFhirTransportInput; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'type') then
        value.type_ := ParseCodeableConcept(child, path+'/type')
      else if (child.localName = 'valueCanonical') then
        value.value := ParseCanonical(child, path+'/valueCanonical')
      else if (child.localName = 'valueCode') then
        value.value := ParseCode(child, path+'/valueCode')
      else if (child.localName = 'valueId') then
        value.value := ParseId(child, path+'/valueId')
      else if (child.localName = 'valueMarkdown') then
        value.value := ParseMarkdown(child, path+'/valueMarkdown')
      else if (child.localName = 'valueOid') then
        value.value := ParseOid(child, path+'/valueOid')
      else if (child.localName = 'valuePositiveInt') then
        value.value := ParsePositiveInt(child, path+'/valuePositiveInt')
      else if (child.localName = 'valueUnsignedInt') then
        value.value := ParseUnsignedInt(child, path+'/valueUnsignedInt')
      else if (child.localName = 'valueUrl') then
        value.value := ParseUrl(child, path+'/valueUrl')
      else if (child.localName = 'valueUuid') then
        value.value := ParseUuid(child, path+'/valueUuid')
      else if (child.localName = 'valueAddress') then
        value.value := ParseAddress(child, path+'/valueAddress')
      else if (child.localName = 'valueAge') then
        value.value := ParseAge(child, path+'/valueAge')
      else if (child.localName = 'valueAnnotation') then
        value.value := ParseAnnotation(child, path+'/valueAnnotation')
      else if (child.localName = 'valueAttachment') then
        value.value := ParseAttachment(child, path+'/valueAttachment')
      else if (child.localName = 'valueCodeableConcept') then
        value.value := ParseCodeableConcept(child, path+'/valueCodeableConcept')
      else if (child.localName = 'valueCodeableReference') then
        value.value := ParseCodeableReference(child, path+'/valueCodeableReference')
      else if (child.localName = 'valueCoding') then
        value.value := ParseCoding(child, path+'/valueCoding')
      else if (child.localName = 'valueContactPoint') then
        value.value := ParseContactPoint(child, path+'/valueContactPoint')
      else if (child.localName = 'valueCount') then
        value.value := ParseCount(child, path+'/valueCount')
      else if (child.localName = 'valueDistance') then
        value.value := ParseDistance(child, path+'/valueDistance')
      else if (child.localName = 'valueDuration') then
        value.value := ParseDuration(child, path+'/valueDuration')
      else if (child.localName = 'valueHumanName') then
        value.value := ParseHumanName(child, path+'/valueHumanName')
      else if (child.localName = 'valueIdentifier') then
        value.value := ParseIdentifier(child, path+'/valueIdentifier')
      else if (child.localName = 'valueMoney') then
        value.value := ParseMoney(child, path+'/valueMoney')
      else if (child.localName = 'valuePeriod') then
        value.value := ParsePeriod(child, path+'/valuePeriod')
      else if (child.localName = 'valueQuantity') then
        value.value := ParseQuantity(child, path+'/valueQuantity')
      else if (child.localName = 'valueRange') then
        value.value := ParseRange(child, path+'/valueRange')
      else if (child.localName = 'valueRatio') then
        value.value := ParseRatio(child, path+'/valueRatio')
      else if (child.localName = 'valueRatioRange') then
        value.value := ParseRatioRange(child, path+'/valueRatioRange')
      else if (child.localName = 'valueReference') then
        value.value := ParseReference(child, path+'/valueReference')
      else if (child.localName = 'valueSampledData') then
        value.value := ParseSampledData(child, path+'/valueSampledData')
      else if (child.localName = 'valueSignature') then
        value.value := ParseSignature(child, path+'/valueSignature')
      else if (child.localName = 'valueTiming') then
        value.value := ParseTiming(child, path+'/valueTiming')
      else if (child.localName = 'valueContactDetail') then
        value.value := ParseContactDetail(child, path+'/valueContactDetail')
      else if (child.localName = 'valueDataRequirement') then
        value.value := ParseDataRequirement(child, path+'/valueDataRequirement')
      else if (child.localName = 'valueExpression') then
        value.value := ParseExpression(child, path+'/valueExpression')
      else if (child.localName = 'valueParameterDefinition') then
        value.value := ParseParameterDefinition(child, path+'/valueParameterDefinition')
      else if (child.localName = 'valueRelatedArtifact') then
        value.value := ParseRelatedArtifact(child, path+'/valueRelatedArtifact')
      else if (child.localName = 'valueTriggerDefinition') then
        value.value := ParseTriggerDefinition(child, path+'/valueTriggerDefinition')
      else if (child.localName = 'valueUsageContext') then
        value.value := ParseUsageContext(child, path+'/valueUsageContext')
      else if (child.localName = 'valueAvailability') then
        value.value := ParseAvailability(child, path+'/valueAvailability')
      else if (child.localName = 'valueExtendedContactDetail') then
        value.value := ParseExtendedContactDetail(child, path+'/valueExtendedContactDetail')
      else if (child.localName = 'valueDosage') then
        value.value := ParseDosage(child, path+'/valueDosage')
      else if (child.localName = 'valueMeta') then
        value.value := ParseMeta(child, path+'/valueMeta')
      else if (child.localName = 'valueBase64Binary') then
        value.value := ParseBase64Binary(child, path+'/valueBase64Binary')
      else if (child.localName = 'valueBoolean') then
        value.value := ParseBoolean(child, path+'/valueBoolean')
      else if (child.localName = 'valueDate') then
        value.value := ParseDate(child, path+'/valueDate')
      else if (child.localName = 'valueDateTime') then
        value.value := ParseDateTime(child, path+'/valueDateTime')
      else if (child.localName = 'valueDecimal') then
        value.value := ParseDecimal(child, path+'/valueDecimal')
      else if (child.localName = 'valueInstant') then
        value.value := ParseInstant(child, path+'/valueInstant')
      else if (child.localName = 'valueInteger') then
        value.value := ParseInteger(child, path+'/valueInteger')
      else if (child.localName = 'valueInteger64') then
        value.value := ParseInteger64(child, path+'/valueInteger64')
      else if (child.localName = 'valueString') then
        value.value := ParseString(child, path+'/valueString')
      else if (child.localName = 'valueTime') then
        value.value := ParseTime(child, path+'/valueTime')
      else if (child.localName = 'valueUri') then
        value.value := ParseUri(child, path+'/valueUri')
      else if Not ParseBackboneElementChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeTransportInput(xml : TXmlBuilder; name : String; value : TFhirTransportInput);
begin
  if (value = nil) then
    exit;
  composeElementAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeTransportInputChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeTransportInputChildren(xml : TXmlBuilder; value : TFhirTransportInput);
begin
  composeBackboneElementChildren(xml, value);
  ComposeCodeableConcept(xml, 'type', value.type_);
  if (value.value is TFhirCanonical) {6} then
    ComposeCanonical(xml, 'valueCanonical', TFhirCanonical(value.value))
  else if (value.value is TFhirCode) {6} then
    ComposeCode(xml, 'valueCode', TFhirCode(value.value))
  else if (value.value is TFhirId) {6} then
    ComposeId(xml, 'valueId', TFhirId(value.value))
  else if (value.value is TFhirMarkdown) {6} then
    ComposeMarkdown(xml, 'valueMarkdown', TFhirMarkdown(value.value))
  else if (value.value is TFhirOid) {6} then
    ComposeOid(xml, 'valueOid', TFhirOid(value.value))
  else if (value.value is TFhirPositiveInt) {6} then
    ComposePositiveInt(xml, 'valuePositiveInt', TFhirPositiveInt(value.value))
  else if (value.value is TFhirUnsignedInt) {6} then
    ComposeUnsignedInt(xml, 'valueUnsignedInt', TFhirUnsignedInt(value.value))
  else if (value.value is TFhirUrl) {6} then
    ComposeUrl(xml, 'valueUrl', TFhirUrl(value.value))
  else if (value.value is TFhirUuid) {6} then
    ComposeUuid(xml, 'valueUuid', TFhirUuid(value.value))
  else if (value.value is TFhirAddress) {6} then
    ComposeAddress(xml, 'valueAddress', TFhirAddress(value.value))
  else if (value.value is TFhirAge) {6} then
    ComposeAge(xml, 'valueAge', TFhirAge(value.value))
  else if (value.value is TFhirAnnotation) {6} then
    ComposeAnnotation(xml, 'valueAnnotation', TFhirAnnotation(value.value))
  else if (value.value is TFhirAttachment) {6} then
    ComposeAttachment(xml, 'valueAttachment', TFhirAttachment(value.value))
  else if (value.value is TFhirCodeableConcept) {6} then
    ComposeCodeableConcept(xml, 'valueCodeableConcept', TFhirCodeableConcept(value.value))
  else if (value.value is TFhirCodeableReference) {6} then
    ComposeCodeableReference(xml, 'valueCodeableReference', TFhirCodeableReference(value.value))
  else if (value.value is TFhirCoding) {6} then
    ComposeCoding(xml, 'valueCoding', TFhirCoding(value.value))
  else if (value.value is TFhirContactPoint) {6} then
    ComposeContactPoint(xml, 'valueContactPoint', TFhirContactPoint(value.value))
  else if (value.value is TFhirCount) {6} then
    ComposeCount(xml, 'valueCount', TFhirCount(value.value))
  else if (value.value is TFhirDistance) {6} then
    ComposeDistance(xml, 'valueDistance', TFhirDistance(value.value))
  else if (value.value is TFhirDuration) {6} then
    ComposeDuration(xml, 'valueDuration', TFhirDuration(value.value))
  else if (value.value is TFhirHumanName) {6} then
    ComposeHumanName(xml, 'valueHumanName', TFhirHumanName(value.value))
  else if (value.value is TFhirIdentifier) {6} then
    ComposeIdentifier(xml, 'valueIdentifier', TFhirIdentifier(value.value))
  else if (value.value is TFhirMoney) {6} then
    ComposeMoney(xml, 'valueMoney', TFhirMoney(value.value))
  else if (value.value is TFhirPeriod) {6} then
    ComposePeriod(xml, 'valuePeriod', TFhirPeriod(value.value))
  else if (value.value is TFhirQuantity) {6} then
    ComposeQuantity(xml, 'valueQuantity', TFhirQuantity(value.value))
  else if (value.value is TFhirRange) {6} then
    ComposeRange(xml, 'valueRange', TFhirRange(value.value))
  else if (value.value is TFhirRatio) {6} then
    ComposeRatio(xml, 'valueRatio', TFhirRatio(value.value))
  else if (value.value is TFhirRatioRange) {6} then
    ComposeRatioRange(xml, 'valueRatioRange', TFhirRatioRange(value.value))
  else if (value.value is TFhirReference) {6} then
    ComposeReference(xml, 'valueReference', TFhirReference(value.value))
  else if (value.value is TFhirSampledData) {6} then
    ComposeSampledData(xml, 'valueSampledData', TFhirSampledData(value.value))
  else if (value.value is TFhirSignature) {6} then
    ComposeSignature(xml, 'valueSignature', TFhirSignature(value.value))
  else if (value.value is TFhirTiming) {6} then
    ComposeTiming(xml, 'valueTiming', TFhirTiming(value.value))
  else if (value.value is TFhirContactDetail) {6} then
    ComposeContactDetail(xml, 'valueContactDetail', TFhirContactDetail(value.value))
  else if (value.value is TFhirDataRequirement) {6} then
    ComposeDataRequirement(xml, 'valueDataRequirement', TFhirDataRequirement(value.value))
  else if (value.value is TFhirExpression) {6} then
    ComposeExpression(xml, 'valueExpression', TFhirExpression(value.value))
  else if (value.value is TFhirParameterDefinition) {6} then
    ComposeParameterDefinition(xml, 'valueParameterDefinition', TFhirParameterDefinition(value.value))
  else if (value.value is TFhirRelatedArtifact) {6} then
    ComposeRelatedArtifact(xml, 'valueRelatedArtifact', TFhirRelatedArtifact(value.value))
  else if (value.value is TFhirTriggerDefinition) {6} then
    ComposeTriggerDefinition(xml, 'valueTriggerDefinition', TFhirTriggerDefinition(value.value))
  else if (value.value is TFhirUsageContext) {6} then
    ComposeUsageContext(xml, 'valueUsageContext', TFhirUsageContext(value.value))
  else if (value.value is TFhirAvailability) {6} then
    ComposeAvailability(xml, 'valueAvailability', TFhirAvailability(value.value))
  else if (value.value is TFhirExtendedContactDetail) {6} then
    ComposeExtendedContactDetail(xml, 'valueExtendedContactDetail', TFhirExtendedContactDetail(value.value))
  else if (value.value is TFhirDosage) {6} then
    ComposeDosage(xml, 'valueDosage', TFhirDosage(value.value))
  else if (value.value is TFhirMeta) {6} then
    ComposeMeta(xml, 'valueMeta', TFhirMeta(value.value))
  else if (value.value is TFhirBase64Binary) {6} then
    ComposeBase64Binary(xml, 'valueBase64Binary', TFhirBase64Binary(value.value))
  else if (value.value is TFhirBoolean) {6} then
    ComposeBoolean(xml, 'valueBoolean', TFhirBoolean(value.value))
  else if (value.value is TFhirDate) {6} then
    ComposeDate(xml, 'valueDate', TFhirDate(value.value))
  else if (value.value is TFhirDateTime) {6} then
    ComposeDateTime(xml, 'valueDateTime', TFhirDateTime(value.value))
  else if (value.value is TFhirDecimal) {6} then
    ComposeDecimal(xml, 'valueDecimal', TFhirDecimal(value.value))
  else if (value.value is TFhirInstant) {6} then
    ComposeInstant(xml, 'valueInstant', TFhirInstant(value.value))
  else if (value.value is TFhirInteger) {6} then
    ComposeInteger(xml, 'valueInteger', TFhirInteger(value.value))
  else if (value.value is TFhirInteger64) {6} then
    ComposeInteger64(xml, 'valueInteger64', TFhirInteger64(value.value))
  else if (value.value is TFhirString) {6} then
    ComposeString(xml, 'valueString', TFhirString(value.value))
  else if (value.value is TFhirTime) {6} then
    ComposeTime(xml, 'valueTime', TFhirTime(value.value))
  else if (value.value is TFhirUri) {6} then
    ComposeUri(xml, 'valueUri', TFhirUri(value.value));
end;

function TFHIRXmlParser.ParseTransportOutput(element : TMXmlElement; path : string) : TFhirTransportOutput;
var
  child : TMXmlElement;
begin
  result := TFhirTransportOutput.Create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseTransportOutputChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseTransportOutputChild(value : TFhirTransportOutput; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'type') then
        value.type_ := ParseCodeableConcept(child, path+'/type')
      else if (child.localName = 'valueCanonical') then
        value.value := ParseCanonical(child, path+'/valueCanonical')
      else if (child.localName = 'valueCode') then
        value.value := ParseCode(child, path+'/valueCode')
      else if (child.localName = 'valueId') then
        value.value := ParseId(child, path+'/valueId')
      else if (child.localName = 'valueMarkdown') then
        value.value := ParseMarkdown(child, path+'/valueMarkdown')
      else if (child.localName = 'valueOid') then
        value.value := ParseOid(child, path+'/valueOid')
      else if (child.localName = 'valuePositiveInt') then
        value.value := ParsePositiveInt(child, path+'/valuePositiveInt')
      else if (child.localName = 'valueUnsignedInt') then
        value.value := ParseUnsignedInt(child, path+'/valueUnsignedInt')
      else if (child.localName = 'valueUrl') then
        value.value := ParseUrl(child, path+'/valueUrl')
      else if (child.localName = 'valueUuid') then
        value.value := ParseUuid(child, path+'/valueUuid')
      else if (child.localName = 'valueAddress') then
        value.value := ParseAddress(child, path+'/valueAddress')
      else if (child.localName = 'valueAge') then
        value.value := ParseAge(child, path+'/valueAge')
      else if (child.localName = 'valueAnnotation') then
        value.value := ParseAnnotation(child, path+'/valueAnnotation')
      else if (child.localName = 'valueAttachment') then
        value.value := ParseAttachment(child, path+'/valueAttachment')
      else if (child.localName = 'valueCodeableConcept') then
        value.value := ParseCodeableConcept(child, path+'/valueCodeableConcept')
      else if (child.localName = 'valueCodeableReference') then
        value.value := ParseCodeableReference(child, path+'/valueCodeableReference')
      else if (child.localName = 'valueCoding') then
        value.value := ParseCoding(child, path+'/valueCoding')
      else if (child.localName = 'valueContactPoint') then
        value.value := ParseContactPoint(child, path+'/valueContactPoint')
      else if (child.localName = 'valueCount') then
        value.value := ParseCount(child, path+'/valueCount')
      else if (child.localName = 'valueDistance') then
        value.value := ParseDistance(child, path+'/valueDistance')
      else if (child.localName = 'valueDuration') then
        value.value := ParseDuration(child, path+'/valueDuration')
      else if (child.localName = 'valueHumanName') then
        value.value := ParseHumanName(child, path+'/valueHumanName')
      else if (child.localName = 'valueIdentifier') then
        value.value := ParseIdentifier(child, path+'/valueIdentifier')
      else if (child.localName = 'valueMoney') then
        value.value := ParseMoney(child, path+'/valueMoney')
      else if (child.localName = 'valuePeriod') then
        value.value := ParsePeriod(child, path+'/valuePeriod')
      else if (child.localName = 'valueQuantity') then
        value.value := ParseQuantity(child, path+'/valueQuantity')
      else if (child.localName = 'valueRange') then
        value.value := ParseRange(child, path+'/valueRange')
      else if (child.localName = 'valueRatio') then
        value.value := ParseRatio(child, path+'/valueRatio')
      else if (child.localName = 'valueRatioRange') then
        value.value := ParseRatioRange(child, path+'/valueRatioRange')
      else if (child.localName = 'valueReference') then
        value.value := ParseReference(child, path+'/valueReference')
      else if (child.localName = 'valueSampledData') then
        value.value := ParseSampledData(child, path+'/valueSampledData')
      else if (child.localName = 'valueSignature') then
        value.value := ParseSignature(child, path+'/valueSignature')
      else if (child.localName = 'valueTiming') then
        value.value := ParseTiming(child, path+'/valueTiming')
      else if (child.localName = 'valueContactDetail') then
        value.value := ParseContactDetail(child, path+'/valueContactDetail')
      else if (child.localName = 'valueDataRequirement') then
        value.value := ParseDataRequirement(child, path+'/valueDataRequirement')
      else if (child.localName = 'valueExpression') then
        value.value := ParseExpression(child, path+'/valueExpression')
      else if (child.localName = 'valueParameterDefinition') then
        value.value := ParseParameterDefinition(child, path+'/valueParameterDefinition')
      else if (child.localName = 'valueRelatedArtifact') then
        value.value := ParseRelatedArtifact(child, path+'/valueRelatedArtifact')
      else if (child.localName = 'valueTriggerDefinition') then
        value.value := ParseTriggerDefinition(child, path+'/valueTriggerDefinition')
      else if (child.localName = 'valueUsageContext') then
        value.value := ParseUsageContext(child, path+'/valueUsageContext')
      else if (child.localName = 'valueAvailability') then
        value.value := ParseAvailability(child, path+'/valueAvailability')
      else if (child.localName = 'valueExtendedContactDetail') then
        value.value := ParseExtendedContactDetail(child, path+'/valueExtendedContactDetail')
      else if (child.localName = 'valueDosage') then
        value.value := ParseDosage(child, path+'/valueDosage')
      else if (child.localName = 'valueMeta') then
        value.value := ParseMeta(child, path+'/valueMeta')
      else if (child.localName = 'valueBase64Binary') then
        value.value := ParseBase64Binary(child, path+'/valueBase64Binary')
      else if (child.localName = 'valueBoolean') then
        value.value := ParseBoolean(child, path+'/valueBoolean')
      else if (child.localName = 'valueDate') then
        value.value := ParseDate(child, path+'/valueDate')
      else if (child.localName = 'valueDateTime') then
        value.value := ParseDateTime(child, path+'/valueDateTime')
      else if (child.localName = 'valueDecimal') then
        value.value := ParseDecimal(child, path+'/valueDecimal')
      else if (child.localName = 'valueInstant') then
        value.value := ParseInstant(child, path+'/valueInstant')
      else if (child.localName = 'valueInteger') then
        value.value := ParseInteger(child, path+'/valueInteger')
      else if (child.localName = 'valueInteger64') then
        value.value := ParseInteger64(child, path+'/valueInteger64')
      else if (child.localName = 'valueString') then
        value.value := ParseString(child, path+'/valueString')
      else if (child.localName = 'valueTime') then
        value.value := ParseTime(child, path+'/valueTime')
      else if (child.localName = 'valueUri') then
        value.value := ParseUri(child, path+'/valueUri')
      else if Not ParseBackboneElementChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeTransportOutput(xml : TXmlBuilder; name : String; value : TFhirTransportOutput);
begin
  if (value = nil) then
    exit;
  composeElementAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeTransportOutputChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeTransportOutputChildren(xml : TXmlBuilder; value : TFhirTransportOutput);
begin
  composeBackboneElementChildren(xml, value);
  ComposeCodeableConcept(xml, 'type', value.type_);
  if (value.value is TFhirCanonical) {6} then
    ComposeCanonical(xml, 'valueCanonical', TFhirCanonical(value.value))
  else if (value.value is TFhirCode) {6} then
    ComposeCode(xml, 'valueCode', TFhirCode(value.value))
  else if (value.value is TFhirId) {6} then
    ComposeId(xml, 'valueId', TFhirId(value.value))
  else if (value.value is TFhirMarkdown) {6} then
    ComposeMarkdown(xml, 'valueMarkdown', TFhirMarkdown(value.value))
  else if (value.value is TFhirOid) {6} then
    ComposeOid(xml, 'valueOid', TFhirOid(value.value))
  else if (value.value is TFhirPositiveInt) {6} then
    ComposePositiveInt(xml, 'valuePositiveInt', TFhirPositiveInt(value.value))
  else if (value.value is TFhirUnsignedInt) {6} then
    ComposeUnsignedInt(xml, 'valueUnsignedInt', TFhirUnsignedInt(value.value))
  else if (value.value is TFhirUrl) {6} then
    ComposeUrl(xml, 'valueUrl', TFhirUrl(value.value))
  else if (value.value is TFhirUuid) {6} then
    ComposeUuid(xml, 'valueUuid', TFhirUuid(value.value))
  else if (value.value is TFhirAddress) {6} then
    ComposeAddress(xml, 'valueAddress', TFhirAddress(value.value))
  else if (value.value is TFhirAge) {6} then
    ComposeAge(xml, 'valueAge', TFhirAge(value.value))
  else if (value.value is TFhirAnnotation) {6} then
    ComposeAnnotation(xml, 'valueAnnotation', TFhirAnnotation(value.value))
  else if (value.value is TFhirAttachment) {6} then
    ComposeAttachment(xml, 'valueAttachment', TFhirAttachment(value.value))
  else if (value.value is TFhirCodeableConcept) {6} then
    ComposeCodeableConcept(xml, 'valueCodeableConcept', TFhirCodeableConcept(value.value))
  else if (value.value is TFhirCodeableReference) {6} then
    ComposeCodeableReference(xml, 'valueCodeableReference', TFhirCodeableReference(value.value))
  else if (value.value is TFhirCoding) {6} then
    ComposeCoding(xml, 'valueCoding', TFhirCoding(value.value))
  else if (value.value is TFhirContactPoint) {6} then
    ComposeContactPoint(xml, 'valueContactPoint', TFhirContactPoint(value.value))
  else if (value.value is TFhirCount) {6} then
    ComposeCount(xml, 'valueCount', TFhirCount(value.value))
  else if (value.value is TFhirDistance) {6} then
    ComposeDistance(xml, 'valueDistance', TFhirDistance(value.value))
  else if (value.value is TFhirDuration) {6} then
    ComposeDuration(xml, 'valueDuration', TFhirDuration(value.value))
  else if (value.value is TFhirHumanName) {6} then
    ComposeHumanName(xml, 'valueHumanName', TFhirHumanName(value.value))
  else if (value.value is TFhirIdentifier) {6} then
    ComposeIdentifier(xml, 'valueIdentifier', TFhirIdentifier(value.value))
  else if (value.value is TFhirMoney) {6} then
    ComposeMoney(xml, 'valueMoney', TFhirMoney(value.value))
  else if (value.value is TFhirPeriod) {6} then
    ComposePeriod(xml, 'valuePeriod', TFhirPeriod(value.value))
  else if (value.value is TFhirQuantity) {6} then
    ComposeQuantity(xml, 'valueQuantity', TFhirQuantity(value.value))
  else if (value.value is TFhirRange) {6} then
    ComposeRange(xml, 'valueRange', TFhirRange(value.value))
  else if (value.value is TFhirRatio) {6} then
    ComposeRatio(xml, 'valueRatio', TFhirRatio(value.value))
  else if (value.value is TFhirRatioRange) {6} then
    ComposeRatioRange(xml, 'valueRatioRange', TFhirRatioRange(value.value))
  else if (value.value is TFhirReference) {6} then
    ComposeReference(xml, 'valueReference', TFhirReference(value.value))
  else if (value.value is TFhirSampledData) {6} then
    ComposeSampledData(xml, 'valueSampledData', TFhirSampledData(value.value))
  else if (value.value is TFhirSignature) {6} then
    ComposeSignature(xml, 'valueSignature', TFhirSignature(value.value))
  else if (value.value is TFhirTiming) {6} then
    ComposeTiming(xml, 'valueTiming', TFhirTiming(value.value))
  else if (value.value is TFhirContactDetail) {6} then
    ComposeContactDetail(xml, 'valueContactDetail', TFhirContactDetail(value.value))
  else if (value.value is TFhirDataRequirement) {6} then
    ComposeDataRequirement(xml, 'valueDataRequirement', TFhirDataRequirement(value.value))
  else if (value.value is TFhirExpression) {6} then
    ComposeExpression(xml, 'valueExpression', TFhirExpression(value.value))
  else if (value.value is TFhirParameterDefinition) {6} then
    ComposeParameterDefinition(xml, 'valueParameterDefinition', TFhirParameterDefinition(value.value))
  else if (value.value is TFhirRelatedArtifact) {6} then
    ComposeRelatedArtifact(xml, 'valueRelatedArtifact', TFhirRelatedArtifact(value.value))
  else if (value.value is TFhirTriggerDefinition) {6} then
    ComposeTriggerDefinition(xml, 'valueTriggerDefinition', TFhirTriggerDefinition(value.value))
  else if (value.value is TFhirUsageContext) {6} then
    ComposeUsageContext(xml, 'valueUsageContext', TFhirUsageContext(value.value))
  else if (value.value is TFhirAvailability) {6} then
    ComposeAvailability(xml, 'valueAvailability', TFhirAvailability(value.value))
  else if (value.value is TFhirExtendedContactDetail) {6} then
    ComposeExtendedContactDetail(xml, 'valueExtendedContactDetail', TFhirExtendedContactDetail(value.value))
  else if (value.value is TFhirDosage) {6} then
    ComposeDosage(xml, 'valueDosage', TFhirDosage(value.value))
  else if (value.value is TFhirMeta) {6} then
    ComposeMeta(xml, 'valueMeta', TFhirMeta(value.value))
  else if (value.value is TFhirBase64Binary) {6} then
    ComposeBase64Binary(xml, 'valueBase64Binary', TFhirBase64Binary(value.value))
  else if (value.value is TFhirBoolean) {6} then
    ComposeBoolean(xml, 'valueBoolean', TFhirBoolean(value.value))
  else if (value.value is TFhirDate) {6} then
    ComposeDate(xml, 'valueDate', TFhirDate(value.value))
  else if (value.value is TFhirDateTime) {6} then
    ComposeDateTime(xml, 'valueDateTime', TFhirDateTime(value.value))
  else if (value.value is TFhirDecimal) {6} then
    ComposeDecimal(xml, 'valueDecimal', TFhirDecimal(value.value))
  else if (value.value is TFhirInstant) {6} then
    ComposeInstant(xml, 'valueInstant', TFhirInstant(value.value))
  else if (value.value is TFhirInteger) {6} then
    ComposeInteger(xml, 'valueInteger', TFhirInteger(value.value))
  else if (value.value is TFhirInteger64) {6} then
    ComposeInteger64(xml, 'valueInteger64', TFhirInteger64(value.value))
  else if (value.value is TFhirString) {6} then
    ComposeString(xml, 'valueString', TFhirString(value.value))
  else if (value.value is TFhirTime) {6} then
    ComposeTime(xml, 'valueTime', TFhirTime(value.value))
  else if (value.value is TFhirUri) {6} then
    ComposeUri(xml, 'valueUri', TFhirUri(value.value));
end;

function TFHIRXmlParser.ParseTransport(element : TMXmlElement; path : string) : TFhirTransport;
var
  child : TMXmlElement;
begin
  result := TFhirTransport.Create;
  try
    parseDomainResourceAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseTransportChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseTransportChild(value : TFhirTransport; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'identifier') then
        value.identifierList.Add(ParseIdentifier(child, path+'/identifier'))
      else if (child.localName = 'instantiatesCanonical') then
        value.instantiatesCanonicalElement := ParseCanonical(child, path+'/instantiatesCanonical')
      else if (child.localName = 'instantiatesUri') then
        value.instantiatesUriElement := ParseUri(child, path+'/instantiatesUri')
      else if (child.localName = 'basedOn') then
        value.basedOnList.Add(ParseReference(child, path+'/basedOn'))
      else if (child.localName = 'groupIdentifier') then
        value.groupIdentifier := ParseIdentifier(child, path+'/groupIdentifier')
      else if (child.localName = 'partOf') then
        value.partOfList.Add(ParseReference(child, path+'/partOf'))
      else if (child.localName = 'status') then
        value.statusElement := ParseEnum(CODES_TFhirTransportStatusEnum, SYSTEMS_TFhirTransportStatusEnum, child, path+'/status')
      else if (child.localName = 'statusReason') then
        value.statusReason := ParseCodeableConcept(child, path+'/statusReason')
      else if (child.localName = 'intent') then
        value.intentElement := ParseEnum(CODES_TFhirTransportIntentEnum, SYSTEMS_TFhirTransportIntentEnum, child, path+'/intent')
      else if (child.localName = 'priority') then
        value.priorityElement := ParseEnum(CODES_TFhirRequestPriorityEnum, SYSTEMS_TFhirRequestPriorityEnum, child, path+'/priority')
      else if (child.localName = 'code') then
        value.code := ParseCodeableConcept(child, path+'/code')
      else if (child.localName = 'description') then
        value.descriptionElement := ParseString(child, path+'/description')
      else if (child.localName = 'focus') then
        value.focus := ParseReference(child, path+'/focus')
      else if (child.localName = 'for') then
        value.for_ := ParseReference(child, path+'/for')
      else if (child.localName = 'encounter') then
        value.encounter := ParseReference(child, path+'/encounter')
      else if (child.localName = 'completionTime') then
        value.completionTimeElement := ParseDateTime(child, path+'/completionTime')
      else if (child.localName = 'authoredOn') then
        value.authoredOnElement := ParseDateTime(child, path+'/authoredOn')
      else if (child.localName = 'lastModified') then
        value.lastModifiedElement := ParseDateTime(child, path+'/lastModified')
      else if (child.localName = 'requester') then
        value.requester := ParseReference(child, path+'/requester')
      else if (child.localName = 'performerType') then
        value.performerTypeList.Add(ParseCodeableConcept(child, path+'/performerType'))
      else if (child.localName = 'owner') then
        value.owner := ParseReference(child, path+'/owner')
      else if (child.localName = 'location') then
        value.location := ParseReference(child, path+'/location')
      else if (child.localName = 'reasonCode') then
        value.reasonCode := ParseCodeableConcept(child, path+'/reasonCode')
      else if (child.localName = 'reasonReference') then
        value.reasonReference := ParseReference(child, path+'/reasonReference')
      else if (child.localName = 'insurance') then
        value.insuranceList.Add(ParseReference(child, path+'/insurance'))
      else if (child.localName = 'note') then
        value.noteList.Add(ParseAnnotation(child, path+'/note'))
      else if (child.localName = 'relevantHistory') then
        value.relevantHistoryList.Add(ParseReference(child, path+'/relevantHistory'))
      else if (child.localName = 'restriction') then
        value.restriction := ParseTransportRestriction(child, path+'/restriction')
      else if (child.localName = 'input') then
        value.inputList.Add(ParseTransportInput(child, path+'/input'))
      else if (child.localName = 'output') then
        value.outputList.Add(ParseTransportOutput(child, path+'/output'))
      else if (child.localName = 'requestedLocation') then
        value.requestedLocation := ParseReference(child, path+'/requestedLocation')
      else if (child.localName = 'currentLocation') then
        value.currentLocation := ParseReference(child, path+'/currentLocation')
      else if (child.localName = 'history') then
        value.history := ParseReference(child, path+'/history')
      else if Not ParseDomainResourceChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeTransport(xml : TXmlBuilder; name : String; value : TFhirTransport);
begin
  if (value = nil) then
    exit;
  composeDomainResourceAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeTransportChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeTransportChildren(xml : TXmlBuilder; value : TFhirTransport);
var
  i : integer;
begin
  composeDomainResourceChildren(xml, value);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.identifierList.Count - 1 do
      ComposeIdentifier(xml, 'identifier', value.identifierList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCanonical(xml, 'instantiatesCanonical', value.instantiatesCanonicalElement);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeUri(xml, 'instantiatesUri', value.instantiatesUriElement);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.basedOnList.Count - 1 do
      ComposeReference(xml, 'basedOn', value.basedOnList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeIdentifier(xml, 'groupIdentifier', value.groupIdentifier);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.partOfList.Count - 1 do
      ComposeReference(xml, 'partOf', value.partOfList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeEnum(xml, 'status', value.statusElement, CODES_TFhirTransportStatusEnum);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(xml, 'statusReason', value.statusReason);
  ComposeEnum(xml, 'intent', value.intentElement, CODES_TFhirTransportIntentEnum);
  if (SummaryOption in [soFull, soData]) then
    ComposeEnum(xml, 'priority', value.priorityElement, CODES_TFhirRequestPriorityEnum);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(xml, 'code', value.code);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(xml, 'description', value.descriptionElement);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference(xml, 'focus', value.focus);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference(xml, 'for', value.for_);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference(xml, 'encounter', value.encounter);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDateTime(xml, 'completionTime', value.completionTimeElement);
  if (SummaryOption in [soFull, soData]) then
    ComposeDateTime(xml, 'authoredOn', value.authoredOnElement);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDateTime(xml, 'lastModified', value.lastModifiedElement);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference(xml, 'requester', value.requester);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.performerTypeList.Count - 1 do
      ComposeCodeableConcept(xml, 'performerType', value.performerTypeList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference(xml, 'owner', value.owner);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference(xml, 'location', value.location);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(xml, 'reasonCode', value.reasonCode);
  if (SummaryOption in [soFull, soData]) then
    ComposeReference(xml, 'reasonReference', value.reasonReference);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.insuranceList.Count - 1 do
      ComposeReference(xml, 'insurance', value.insuranceList[i]);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.noteList.Count - 1 do
      ComposeAnnotation(xml, 'note', value.noteList[i]);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.relevantHistoryList.Count - 1 do
      ComposeReference(xml, 'relevantHistory', value.relevantHistoryList[i]);
  if (SummaryOption in [soFull, soData]) then
    ComposeTransportRestriction(xml, 'restriction', value.restriction);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.inputList.Count - 1 do
      ComposeTransportInput(xml, 'input', value.inputList[i]);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.outputList.Count - 1 do
      ComposeTransportOutput(xml, 'output', value.outputList[i]);
  ComposeReference(xml, 'requestedLocation', value.requestedLocation);
  ComposeReference(xml, 'currentLocation', value.currentLocation);
  if (SummaryOption in [soFull, soData]) then
    ComposeReference(xml, 'history', value.history);
end;

{$ENDIF FHIR_TRANSPORT}
{$IFDEF FHIR_VALUESET}
function TFHIRXmlParser.ParseValueSetCompose(element : TMXmlElement; path : string) : TFhirValueSetCompose;
var
  child : TMXmlElement;
begin
  result := TFhirValueSetCompose.Create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseValueSetComposeChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseValueSetComposeChild(value : TFhirValueSetCompose; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'lockedDate') then
        value.lockedDateElement := ParseDate(child, path+'/lockedDate')
      else if (child.localName = 'inactive') then
        value.inactiveElement := ParseBoolean(child, path+'/inactive')
      else if (child.localName = 'include') then
        value.includeList.Add(ParseValueSetComposeInclude(child, path+'/include'))
      else if (child.localName = 'exclude') then
        value.excludeList.Add(ParseValueSetComposeInclude(child, path+'/exclude'))
      else if (child.localName = 'property') then
        value.property_List.Add(ParseString(child, path+'/property'))
      else if Not ParseBackboneElementChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeValueSetCompose(xml : TXmlBuilder; name : String; value : TFhirValueSetCompose);
begin
  if (value = nil) then
    exit;
  composeElementAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeValueSetComposeChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeValueSetComposeChildren(xml : TXmlBuilder; value : TFhirValueSetCompose);
var
  i : integer;
begin
  composeBackboneElementChildren(xml, value);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDate(xml, 'lockedDate', value.lockedDateElement);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeBoolean(xml, 'inactive', value.inactiveElement);
  for i := 0 to value.includeList.Count - 1 do
      ComposeValueSetComposeInclude(xml, 'include', value.includeList[i]);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.excludeList.Count - 1 do
      ComposeValueSetComposeInclude(xml, 'exclude', value.excludeList[i]);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.property_List.Count - 1 do
      ComposeString(xml, 'property', value.property_List[i]);
end;

function TFHIRXmlParser.ParseValueSetComposeInclude(element : TMXmlElement; path : string) : TFhirValueSetComposeInclude;
var
  child : TMXmlElement;
begin
  result := TFhirValueSetComposeInclude.Create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseValueSetComposeIncludeChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseValueSetComposeIncludeChild(value : TFhirValueSetComposeInclude; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'system') then
        value.systemElement := ParseUri(child, path+'/system')
      else if (child.localName = 'version') then
        value.versionElement := ParseString(child, path+'/version')
      else if (child.localName = 'concept') then
        value.conceptList.Add(ParseValueSetComposeIncludeConcept(child, path+'/concept'))
      else if (child.localName = 'filter') then
        value.filterList.Add(ParseValueSetComposeIncludeFilter(child, path+'/filter'))
      else if (child.localName = 'valueSet') then
        value.valueSetList.Add(ParseCanonical(child, path+'/valueSet'))
      else if (child.localName = 'copyright') then
        value.copyrightElement := ParseString(child, path+'/copyright')
      else if Not ParseBackboneElementChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeValueSetComposeInclude(xml : TXmlBuilder; name : String; value : TFhirValueSetComposeInclude);
begin
  if (value = nil) then
    exit;
  composeElementAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeValueSetComposeIncludeChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeValueSetComposeIncludeChildren(xml : TXmlBuilder; value : TFhirValueSetComposeInclude);
var
  i : integer;
begin
  composeBackboneElementChildren(xml, value);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeUri(xml, 'system', value.systemElement);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(xml, 'version', value.versionElement);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.conceptList.Count - 1 do
      ComposeValueSetComposeIncludeConcept(xml, 'concept', value.conceptList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.filterList.Count - 1 do
      ComposeValueSetComposeIncludeFilter(xml, 'filter', value.filterList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.valueSetList.Count - 1 do
      ComposeCanonical(xml, 'valueSet', value.valueSetList[i]);
  if (SummaryOption in [soFull, soData]) then
    ComposeString(xml, 'copyright', value.copyrightElement);
end;

function TFHIRXmlParser.ParseValueSetComposeIncludeConcept(element : TMXmlElement; path : string) : TFhirValueSetComposeIncludeConcept;
var
  child : TMXmlElement;
begin
  result := TFhirValueSetComposeIncludeConcept.Create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseValueSetComposeIncludeConceptChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseValueSetComposeIncludeConceptChild(value : TFhirValueSetComposeIncludeConcept; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'code') then
        value.codeElement := ParseCode(child, path+'/code')
      else if (child.localName = 'display') then
        value.displayElement := ParseString(child, path+'/display')
      else if (child.localName = 'designation') then
        value.designationList.Add(ParseValueSetComposeIncludeConceptDesignation(child, path+'/designation'))
      else if Not ParseBackboneElementChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeValueSetComposeIncludeConcept(xml : TXmlBuilder; name : String; value : TFhirValueSetComposeIncludeConcept);
begin
  if (value = nil) then
    exit;
  composeElementAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeValueSetComposeIncludeConceptChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeValueSetComposeIncludeConceptChildren(xml : TXmlBuilder; value : TFhirValueSetComposeIncludeConcept);
var
  i : integer;
begin
  composeBackboneElementChildren(xml, value);
  ComposeCode(xml, 'code', value.codeElement);
  if (SummaryOption in [soFull, soData]) then
    ComposeString(xml, 'display', value.displayElement);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.designationList.Count - 1 do
      ComposeValueSetComposeIncludeConceptDesignation(xml, 'designation', value.designationList[i]);
end;

function TFHIRXmlParser.ParseValueSetComposeIncludeConceptDesignation(element : TMXmlElement; path : string) : TFhirValueSetComposeIncludeConceptDesignation;
var
  child : TMXmlElement;
begin
  result := TFhirValueSetComposeIncludeConceptDesignation.Create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseValueSetComposeIncludeConceptDesignationChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseValueSetComposeIncludeConceptDesignationChild(value : TFhirValueSetComposeIncludeConceptDesignation; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'language') then
        value.languageElement := ParseCode(child, path+'/language')
      else if (child.localName = 'use') then
        value.use := ParseCoding(child, path+'/use')
      else if (child.localName = 'additionalUse') then
        value.additionalUseList.Add(ParseCoding(child, path+'/additionalUse'))
      else if (child.localName = 'value') then
        value.valueElement := ParseString(child, path+'/value')
      else if Not ParseBackboneElementChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeValueSetComposeIncludeConceptDesignation(xml : TXmlBuilder; name : String; value : TFhirValueSetComposeIncludeConceptDesignation);
begin
  if (value = nil) then
    exit;
  composeElementAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeValueSetComposeIncludeConceptDesignationChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeValueSetComposeIncludeConceptDesignationChildren(xml : TXmlBuilder; value : TFhirValueSetComposeIncludeConceptDesignation);
var
  i : integer;
begin
  composeBackboneElementChildren(xml, value);
  if (SummaryOption in [soFull, soData]) then
    ComposeCode(xml, 'language', value.languageElement);
  if (SummaryOption in [soFull, soData]) then
    ComposeCoding(xml, 'use', value.use);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.additionalUseList.Count - 1 do
      ComposeCoding(xml, 'additionalUse', value.additionalUseList[i]);
  ComposeString(xml, 'value', value.valueElement);
end;

function TFHIRXmlParser.ParseValueSetComposeIncludeFilter(element : TMXmlElement; path : string) : TFhirValueSetComposeIncludeFilter;
var
  child : TMXmlElement;
begin
  result := TFhirValueSetComposeIncludeFilter.Create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseValueSetComposeIncludeFilterChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseValueSetComposeIncludeFilterChild(value : TFhirValueSetComposeIncludeFilter; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'property') then
        value.property_Element := ParseCode(child, path+'/property')
      else if (child.localName = 'op') then
        value.opElement := ParseEnum(CODES_TFhirFilterOperatorEnum, SYSTEMS_TFhirFilterOperatorEnum, child, path+'/op')
      else if (child.localName = 'value') then
        value.valueElement := ParseString(child, path+'/value')
      else if Not ParseBackboneElementChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeValueSetComposeIncludeFilter(xml : TXmlBuilder; name : String; value : TFhirValueSetComposeIncludeFilter);
begin
  if (value = nil) then
    exit;
  composeElementAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeValueSetComposeIncludeFilterChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeValueSetComposeIncludeFilterChildren(xml : TXmlBuilder; value : TFhirValueSetComposeIncludeFilter);
begin
  composeBackboneElementChildren(xml, value);
  ComposeCode(xml, 'property', value.property_Element);
  ComposeEnum(xml, 'op', value.opElement, CODES_TFhirFilterOperatorEnum);
  ComposeString(xml, 'value', value.valueElement);
end;

function TFHIRXmlParser.ParseValueSetExpansion(element : TMXmlElement; path : string) : TFhirValueSetExpansion;
var
  child : TMXmlElement;
begin
  result := TFhirValueSetExpansion.Create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseValueSetExpansionChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseValueSetExpansionChild(value : TFhirValueSetExpansion; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'identifier') then
        value.identifierElement := ParseUri(child, path+'/identifier')
      else if (child.localName = 'next') then
        value.nextElement := ParseUri(child, path+'/next')
      else if (child.localName = 'timestamp') then
        value.timestampElement := ParseDateTime(child, path+'/timestamp')
      else if (child.localName = 'total') then
        value.totalElement := ParseInteger(child, path+'/total')
      else if (child.localName = 'offset') then
        value.offsetElement := ParseInteger(child, path+'/offset')
      else if (child.localName = 'parameter') then
        value.parameterList.Add(ParseValueSetExpansionParameter(child, path+'/parameter'))
      else if (child.localName = 'property') then
        value.property_List.Add(ParseValueSetExpansionProperty(child, path+'/property'))
      else if (child.localName = 'contains') then
        value.containsList.Add(ParseValueSetExpansionContains(child, path+'/contains'))
      else if Not ParseBackboneElementChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeValueSetExpansion(xml : TXmlBuilder; name : String; value : TFhirValueSetExpansion);
begin
  if (value = nil) then
    exit;
  composeElementAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeValueSetExpansionChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeValueSetExpansionChildren(xml : TXmlBuilder; value : TFhirValueSetExpansion);
var
  i : integer;
begin
  composeBackboneElementChildren(xml, value);
  if (SummaryOption in [soFull, soData]) then
    ComposeUri(xml, 'identifier', value.identifierElement);
  if (SummaryOption in [soFull, soData]) then
    ComposeUri(xml, 'next', value.nextElement);
  ComposeDateTime(xml, 'timestamp', value.timestampElement);
  if (SummaryOption in [soFull, soData]) then
    ComposeInteger(xml, 'total', value.totalElement);
  if (SummaryOption in [soFull, soData]) then
    ComposeInteger(xml, 'offset', value.offsetElement);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.parameterList.Count - 1 do
      ComposeValueSetExpansionParameter(xml, 'parameter', value.parameterList[i]);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.property_List.Count - 1 do
      ComposeValueSetExpansionProperty(xml, 'property', value.property_List[i]);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.containsList.Count - 1 do
      ComposeValueSetExpansionContains(xml, 'contains', value.containsList[i]);
end;

function TFHIRXmlParser.ParseValueSetExpansionParameter(element : TMXmlElement; path : string) : TFhirValueSetExpansionParameter;
var
  child : TMXmlElement;
begin
  result := TFhirValueSetExpansionParameter.Create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseValueSetExpansionParameterChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseValueSetExpansionParameterChild(value : TFhirValueSetExpansionParameter; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'name') then
        value.nameElement := ParseString(child, path+'/name')
      else if (child.localName = 'valueCode') then
        value.value := ParseCode(child, path+'/valueCode')
      else if (child.localName = 'valueString') then
        value.value := ParseString(child, path+'/valueString')
      else if (child.localName = 'valueBoolean') then
        value.value := ParseBoolean(child, path+'/valueBoolean')
      else if (child.localName = 'valueInteger') then
        value.value := ParseInteger(child, path+'/valueInteger')
      else if (child.localName = 'valueDecimal') then
        value.value := ParseDecimal(child, path+'/valueDecimal')
      else if (child.localName = 'valueUri') then
        value.value := ParseUri(child, path+'/valueUri')
      else if (child.localName = 'valueDateTime') then
        value.value := ParseDateTime(child, path+'/valueDateTime')
      else if Not ParseBackboneElementChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeValueSetExpansionParameter(xml : TXmlBuilder; name : String; value : TFhirValueSetExpansionParameter);
begin
  if (value = nil) then
    exit;
  composeElementAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeValueSetExpansionParameterChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeValueSetExpansionParameterChildren(xml : TXmlBuilder; value : TFhirValueSetExpansionParameter);
begin
  composeBackboneElementChildren(xml, value);
  ComposeString(xml, 'name', value.nameElement);
  if (SummaryOption in [soFull, soData]) and (value.value is TFhirCode) {6} then
    ComposeCode(xml, 'valueCode', TFhirCode(value.value))
  else if (SummaryOption in [soFull, soData]) and (value.value is TFhirString) {6} then
    ComposeString(xml, 'valueString', TFhirString(value.value))
  else if (SummaryOption in [soFull, soData]) and (value.value is TFhirBoolean) {6} then
    ComposeBoolean(xml, 'valueBoolean', TFhirBoolean(value.value))
  else if (SummaryOption in [soFull, soData]) and (value.value is TFhirInteger) {6} then
    ComposeInteger(xml, 'valueInteger', TFhirInteger(value.value))
  else if (SummaryOption in [soFull, soData]) and (value.value is TFhirDecimal) {6} then
    ComposeDecimal(xml, 'valueDecimal', TFhirDecimal(value.value))
  else if (SummaryOption in [soFull, soData]) and (value.value is TFhirUri) {6} then
    ComposeUri(xml, 'valueUri', TFhirUri(value.value))
  else if (SummaryOption in [soFull, soData]) and (value.value is TFhirDateTime) {6} then
    ComposeDateTime(xml, 'valueDateTime', TFhirDateTime(value.value));
end;

function TFHIRXmlParser.ParseValueSetExpansionProperty(element : TMXmlElement; path : string) : TFhirValueSetExpansionProperty;
var
  child : TMXmlElement;
begin
  result := TFhirValueSetExpansionProperty.Create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseValueSetExpansionPropertyChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseValueSetExpansionPropertyChild(value : TFhirValueSetExpansionProperty; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'code') then
        value.codeElement := ParseCode(child, path+'/code')
      else if (child.localName = 'uri') then
        value.uriElement := ParseUri(child, path+'/uri')
      else if Not ParseBackboneElementChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeValueSetExpansionProperty(xml : TXmlBuilder; name : String; value : TFhirValueSetExpansionProperty);
begin
  if (value = nil) then
    exit;
  composeElementAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeValueSetExpansionPropertyChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeValueSetExpansionPropertyChildren(xml : TXmlBuilder; value : TFhirValueSetExpansionProperty);
begin
  composeBackboneElementChildren(xml, value);
  ComposeCode(xml, 'code', value.codeElement);
  if (SummaryOption in [soFull, soData]) then
    ComposeUri(xml, 'uri', value.uriElement);
end;

function TFHIRXmlParser.ParseValueSetExpansionContains(element : TMXmlElement; path : string) : TFhirValueSetExpansionContains;
var
  child : TMXmlElement;
begin
  result := TFhirValueSetExpansionContains.Create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseValueSetExpansionContainsChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseValueSetExpansionContainsChild(value : TFhirValueSetExpansionContains; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'system') then
        value.systemElement := ParseUri(child, path+'/system')
      else if (child.localName = 'abstract') then
        value.abstractElement := ParseBoolean(child, path+'/abstract')
      else if (child.localName = 'inactive') then
        value.inactiveElement := ParseBoolean(child, path+'/inactive')
      else if (child.localName = 'version') then
        value.versionElement := ParseString(child, path+'/version')
      else if (child.localName = 'code') then
        value.codeElement := ParseCode(child, path+'/code')
      else if (child.localName = 'display') then
        value.displayElement := ParseString(child, path+'/display')
      else if (child.localName = 'designation') then
        value.designationList.Add(ParseValueSetComposeIncludeConceptDesignation(child, path+'/designation'))
      else if (child.localName = 'property') then
        value.property_List.Add(ParseValueSetExpansionContainsProperty(child, path+'/property'))
      else if (child.localName = 'contains') then
        value.containsList.Add(ParseValueSetExpansionContains(child, path+'/contains'))
      else if Not ParseBackboneElementChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeValueSetExpansionContains(xml : TXmlBuilder; name : String; value : TFhirValueSetExpansionContains);
begin
  if (value = nil) then
    exit;
  composeElementAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeValueSetExpansionContainsChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeValueSetExpansionContainsChildren(xml : TXmlBuilder; value : TFhirValueSetExpansionContains);
var
  i : integer;
begin
  composeBackboneElementChildren(xml, value);
  if (SummaryOption in [soFull, soData]) then
    ComposeUri(xml, 'system', value.systemElement);
  if (SummaryOption in [soFull, soData]) then
    ComposeBoolean(xml, 'abstract', value.abstractElement);
  if (SummaryOption in [soFull, soData]) then
    ComposeBoolean(xml, 'inactive', value.inactiveElement);
  if (SummaryOption in [soFull, soData]) then
    ComposeString(xml, 'version', value.versionElement);
  if (SummaryOption in [soFull, soData]) then
    ComposeCode(xml, 'code', value.codeElement);
  if (SummaryOption in [soFull, soData]) then
    ComposeString(xml, 'display', value.displayElement);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.designationList.Count - 1 do
      ComposeValueSetComposeIncludeConceptDesignation(xml, 'designation', value.designationList[i]);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.property_List.Count - 1 do
      ComposeValueSetExpansionContainsProperty(xml, 'property', value.property_List[i]);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.containsList.Count - 1 do
      ComposeValueSetExpansionContains(xml, 'contains', value.containsList[i]);
end;

function TFHIRXmlParser.ParseValueSetExpansionContainsProperty(element : TMXmlElement; path : string) : TFhirValueSetExpansionContainsProperty;
var
  child : TMXmlElement;
begin
  result := TFhirValueSetExpansionContainsProperty.Create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseValueSetExpansionContainsPropertyChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseValueSetExpansionContainsPropertyChild(value : TFhirValueSetExpansionContainsProperty; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'code') then
        value.codeElement := ParseCode(child, path+'/code')
      else if (child.localName = 'valueCode') then
        value.value := ParseCode(child, path+'/valueCode')
      else if (child.localName = 'valueCoding') then
        value.value := ParseCoding(child, path+'/valueCoding')
      else if (child.localName = 'valueString') then
        value.value := ParseString(child, path+'/valueString')
      else if (child.localName = 'valueInteger') then
        value.value := ParseInteger(child, path+'/valueInteger')
      else if (child.localName = 'valueBoolean') then
        value.value := ParseBoolean(child, path+'/valueBoolean')
      else if (child.localName = 'valueDateTime') then
        value.value := ParseDateTime(child, path+'/valueDateTime')
      else if (child.localName = 'valueDecimal') then
        value.value := ParseDecimal(child, path+'/valueDecimal')
      else if (child.localName = 'subProperty') then
        value.subPropertyList.Add(ParseValueSetExpansionContainsPropertySubProperty(child, path+'/subProperty'))
      else if Not ParseBackboneElementChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeValueSetExpansionContainsProperty(xml : TXmlBuilder; name : String; value : TFhirValueSetExpansionContainsProperty);
begin
  if (value = nil) then
    exit;
  composeElementAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeValueSetExpansionContainsPropertyChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeValueSetExpansionContainsPropertyChildren(xml : TXmlBuilder; value : TFhirValueSetExpansionContainsProperty);
var
  i : integer;
begin
  composeBackboneElementChildren(xml, value);
  ComposeCode(xml, 'code', value.codeElement);
  if (value.value is TFhirCode) {6} then
    ComposeCode(xml, 'valueCode', TFhirCode(value.value))
  else if (value.value is TFhirCoding) {6} then
    ComposeCoding(xml, 'valueCoding', TFhirCoding(value.value))
  else if (value.value is TFhirString) {6} then
    ComposeString(xml, 'valueString', TFhirString(value.value))
  else if (value.value is TFhirInteger) {6} then
    ComposeInteger(xml, 'valueInteger', TFhirInteger(value.value))
  else if (value.value is TFhirBoolean) {6} then
    ComposeBoolean(xml, 'valueBoolean', TFhirBoolean(value.value))
  else if (value.value is TFhirDateTime) {6} then
    ComposeDateTime(xml, 'valueDateTime', TFhirDateTime(value.value))
  else if (value.value is TFhirDecimal) {6} then
    ComposeDecimal(xml, 'valueDecimal', TFhirDecimal(value.value));
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.subPropertyList.Count - 1 do
      ComposeValueSetExpansionContainsPropertySubProperty(xml, 'subProperty', value.subPropertyList[i]);
end;

function TFHIRXmlParser.ParseValueSetExpansionContainsPropertySubProperty(element : TMXmlElement; path : string) : TFhirValueSetExpansionContainsPropertySubProperty;
var
  child : TMXmlElement;
begin
  result := TFhirValueSetExpansionContainsPropertySubProperty.Create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseValueSetExpansionContainsPropertySubPropertyChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseValueSetExpansionContainsPropertySubPropertyChild(value : TFhirValueSetExpansionContainsPropertySubProperty; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'code') then
        value.codeElement := ParseCode(child, path+'/code')
      else if (child.localName = 'valueCode') then
        value.value := ParseCode(child, path+'/valueCode')
      else if (child.localName = 'valueCoding') then
        value.value := ParseCoding(child, path+'/valueCoding')
      else if (child.localName = 'valueString') then
        value.value := ParseString(child, path+'/valueString')
      else if (child.localName = 'valueInteger') then
        value.value := ParseInteger(child, path+'/valueInteger')
      else if (child.localName = 'valueBoolean') then
        value.value := ParseBoolean(child, path+'/valueBoolean')
      else if (child.localName = 'valueDateTime') then
        value.value := ParseDateTime(child, path+'/valueDateTime')
      else if (child.localName = 'valueDecimal') then
        value.value := ParseDecimal(child, path+'/valueDecimal')
      else if Not ParseBackboneElementChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeValueSetExpansionContainsPropertySubProperty(xml : TXmlBuilder; name : String; value : TFhirValueSetExpansionContainsPropertySubProperty);
begin
  if (value = nil) then
    exit;
  composeElementAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeValueSetExpansionContainsPropertySubPropertyChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeValueSetExpansionContainsPropertySubPropertyChildren(xml : TXmlBuilder; value : TFhirValueSetExpansionContainsPropertySubProperty);
begin
  composeBackboneElementChildren(xml, value);
  ComposeCode(xml, 'code', value.codeElement);
  if (value.value is TFhirCode) {6} then
    ComposeCode(xml, 'valueCode', TFhirCode(value.value))
  else if (value.value is TFhirCoding) {6} then
    ComposeCoding(xml, 'valueCoding', TFhirCoding(value.value))
  else if (value.value is TFhirString) {6} then
    ComposeString(xml, 'valueString', TFhirString(value.value))
  else if (value.value is TFhirInteger) {6} then
    ComposeInteger(xml, 'valueInteger', TFhirInteger(value.value))
  else if (value.value is TFhirBoolean) {6} then
    ComposeBoolean(xml, 'valueBoolean', TFhirBoolean(value.value))
  else if (value.value is TFhirDateTime) {6} then
    ComposeDateTime(xml, 'valueDateTime', TFhirDateTime(value.value))
  else if (value.value is TFhirDecimal) {6} then
    ComposeDecimal(xml, 'valueDecimal', TFhirDecimal(value.value));
end;

function TFHIRXmlParser.ParseValueSetScope(element : TMXmlElement; path : string) : TFhirValueSetScope;
var
  child : TMXmlElement;
begin
  result := TFhirValueSetScope.Create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseValueSetScopeChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseValueSetScopeChild(value : TFhirValueSetScope; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'inclusionCriteria') then
        value.inclusionCriteriaElement := ParseString(child, path+'/inclusionCriteria')
      else if (child.localName = 'exclusionCriteria') then
        value.exclusionCriteriaElement := ParseString(child, path+'/exclusionCriteria')
      else if Not ParseBackboneElementChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeValueSetScope(xml : TXmlBuilder; name : String; value : TFhirValueSetScope);
begin
  if (value = nil) then
    exit;
  composeElementAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeValueSetScopeChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeValueSetScopeChildren(xml : TXmlBuilder; value : TFhirValueSetScope);
begin
  composeBackboneElementChildren(xml, value);
  if (SummaryOption in [soFull, soData]) then
    ComposeString(xml, 'inclusionCriteria', value.inclusionCriteriaElement);
  if (SummaryOption in [soFull, soData]) then
    ComposeString(xml, 'exclusionCriteria', value.exclusionCriteriaElement);
end;

function TFHIRXmlParser.ParseValueSet(element : TMXmlElement; path : string) : TFhirValueSet;
var
  child : TMXmlElement;
begin
  result := TFhirValueSet.Create;
  try
    parseMetadataResourceAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseValueSetChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseValueSetChild(value : TFhirValueSet; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'url') then
        value.urlElement := ParseUri(child, path+'/url')
      else if (child.localName = 'identifier') then
        value.identifierList.Add(ParseIdentifier(child, path+'/identifier'))
      else if (child.localName = 'version') then
        value.versionElement := ParseString(child, path+'/version')
      else if (child.localName = 'name') then
        value.nameElement := ParseString(child, path+'/name')
      else if (child.localName = 'title') then
        value.titleElement := ParseString(child, path+'/title')
      else if (child.localName = 'status') then
        value.statusElement := ParseEnum(CODES_TFhirPublicationStatusEnum, SYSTEMS_TFhirPublicationStatusEnum, child, path+'/status')
      else if (child.localName = 'experimental') then
        value.experimentalElement := ParseBoolean(child, path+'/experimental')
      else if (child.localName = 'date') then
        value.dateElement := ParseDateTime(child, path+'/date')
      else if (child.localName = 'publisher') then
        value.publisherElement := ParseString(child, path+'/publisher')
      else if (child.localName = 'contact') then
        value.contactList.Add(ParseContactDetail(child, path+'/contact'))
      else if (child.localName = 'description') then
        value.descriptionElement := ParseMarkdown(child, path+'/description')
      else if (child.localName = 'useContext') then
        value.useContextList.Add(ParseUsageContext(child, path+'/useContext'))
      else if (child.localName = 'jurisdiction') then
        value.jurisdictionList.Add(ParseCodeableConcept(child, path+'/jurisdiction'))
      else if (child.localName = 'immutable') then
        value.immutableElement := ParseBoolean(child, path+'/immutable')
      else if (child.localName = 'purpose') then
        value.purposeElement := ParseMarkdown(child, path+'/purpose')
      else if (child.localName = 'copyright') then
        value.copyrightElement := ParseMarkdown(child, path+'/copyright')
      else if (child.localName = 'approvalDate') then
        value.approvalDateElement := ParseDate(child, path+'/approvalDate')
      else if (child.localName = 'lastReviewDate') then
        value.lastReviewDateElement := ParseDate(child, path+'/lastReviewDate')
      else if (child.localName = 'effectivePeriod') then
        value.effectivePeriod := ParsePeriod(child, path+'/effectivePeriod')
      else if (child.localName = 'topic') then
        value.topicList.Add(ParseCodeableConcept(child, path+'/topic'))
      else if (child.localName = 'author') then
        value.authorList.Add(ParseContactDetail(child, path+'/author'))
      else if (child.localName = 'editor') then
        value.editorList.Add(ParseContactDetail(child, path+'/editor'))
      else if (child.localName = 'reviewer') then
        value.reviewerList.Add(ParseContactDetail(child, path+'/reviewer'))
      else if (child.localName = 'endorser') then
        value.endorserList.Add(ParseContactDetail(child, path+'/endorser'))
      else if (child.localName = 'relatedArtifact') then
        value.relatedArtifactList.Add(ParseRelatedArtifact(child, path+'/relatedArtifact'))
      else if (child.localName = 'compose') then
        value.compose := ParseValueSetCompose(child, path+'/compose')
      else if (child.localName = 'expansion') then
        value.expansion := ParseValueSetExpansion(child, path+'/expansion')
      else if (child.localName = 'scope') then
        value.scope := ParseValueSetScope(child, path+'/scope')
      else if Not ParseMetadataResourceChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeValueSet(xml : TXmlBuilder; name : String; value : TFhirValueSet);
begin
  if (value = nil) then
    exit;
  composeMetadataResourceAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeValueSetChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeValueSetChildren(xml : TXmlBuilder; value : TFhirValueSet);
var
  i : integer;
begin
  composeMetadataResourceChildren(xml, value);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeUri(xml, 'url', value.urlElement);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.identifierList.Count - 1 do
      ComposeIdentifier(xml, 'identifier', value.identifierList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(xml, 'version', value.versionElement);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(xml, 'name', value.nameElement);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(xml, 'title', value.titleElement);
  ComposeEnum(xml, 'status', value.statusElement, CODES_TFhirPublicationStatusEnum);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeBoolean(xml, 'experimental', value.experimentalElement);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDateTime(xml, 'date', value.dateElement);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(xml, 'publisher', value.publisherElement);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.contactList.Count - 1 do
      ComposeContactDetail(xml, 'contact', value.contactList[i]);
  if (SummaryOption in [soFull, soData]) then
    ComposeMarkdown(xml, 'description', value.descriptionElement);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.useContextList.Count - 1 do
      ComposeUsageContext(xml, 'useContext', value.useContextList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.jurisdictionList.Count - 1 do
      ComposeCodeableConcept(xml, 'jurisdiction', value.jurisdictionList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeBoolean(xml, 'immutable', value.immutableElement);
  if (SummaryOption in [soFull, soData]) then
    ComposeMarkdown(xml, 'purpose', value.purposeElement);
  if (SummaryOption in [soFull, soData]) then
    ComposeMarkdown(xml, 'copyright', value.copyrightElement);
  if (SummaryOption in [soFull, soData]) then
    ComposeDate(xml, 'approvalDate', value.approvalDateElement);
  if (SummaryOption in [soFull, soData]) then
    ComposeDate(xml, 'lastReviewDate', value.lastReviewDateElement);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposePeriod(xml, 'effectivePeriod', value.effectivePeriod);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.topicList.Count - 1 do
      ComposeCodeableConcept(xml, 'topic', value.topicList[i]);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.authorList.Count - 1 do
      ComposeContactDetail(xml, 'author', value.authorList[i]);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.editorList.Count - 1 do
      ComposeContactDetail(xml, 'editor', value.editorList[i]);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.reviewerList.Count - 1 do
      ComposeContactDetail(xml, 'reviewer', value.reviewerList[i]);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.endorserList.Count - 1 do
      ComposeContactDetail(xml, 'endorser', value.endorserList[i]);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.relatedArtifactList.Count - 1 do
      ComposeRelatedArtifact(xml, 'relatedArtifact', value.relatedArtifactList[i]);
  if (SummaryOption in [soFull, soData]) then
    ComposeValueSetCompose(xml, 'compose', value.compose);
  if (SummaryOption in [soFull, soData]) then
    ComposeValueSetExpansion(xml, 'expansion', value.expansion);
  if (SummaryOption in [soFull, soData]) then
    ComposeValueSetScope(xml, 'scope', value.scope);
end;

{$ENDIF FHIR_VALUESET}
{$IFDEF FHIR_VERIFICATIONRESULT}
function TFHIRXmlParser.ParseVerificationResultPrimarySource(element : TMXmlElement; path : string) : TFhirVerificationResultPrimarySource;
var
  child : TMXmlElement;
begin
  result := TFhirVerificationResultPrimarySource.Create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseVerificationResultPrimarySourceChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseVerificationResultPrimarySourceChild(value : TFhirVerificationResultPrimarySource; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'who') then
        value.who := ParseReference(child, path+'/who')
      else if (child.localName = 'type') then
        value.type_List.Add(ParseCodeableConcept(child, path+'/type'))
      else if (child.localName = 'communicationMethod') then
        value.communicationMethodList.Add(ParseCodeableConcept(child, path+'/communicationMethod'))
      else if (child.localName = 'validationStatus') then
        value.validationStatus := ParseCodeableConcept(child, path+'/validationStatus')
      else if (child.localName = 'validationDate') then
        value.validationDateElement := ParseDateTime(child, path+'/validationDate')
      else if (child.localName = 'canPushUpdates') then
        value.canPushUpdates := ParseCodeableConcept(child, path+'/canPushUpdates')
      else if (child.localName = 'pushTypeAvailable') then
        value.pushTypeAvailableList.Add(ParseCodeableConcept(child, path+'/pushTypeAvailable'))
      else if Not ParseBackboneElementChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeVerificationResultPrimarySource(xml : TXmlBuilder; name : String; value : TFhirVerificationResultPrimarySource);
begin
  if (value = nil) then
    exit;
  composeElementAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeVerificationResultPrimarySourceChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeVerificationResultPrimarySourceChildren(xml : TXmlBuilder; value : TFhirVerificationResultPrimarySource);
var
  i : integer;
begin
  composeBackboneElementChildren(xml, value);
  if (SummaryOption in [soFull, soData]) then
    ComposeReference(xml, 'who', value.who);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.type_List.Count - 1 do
      ComposeCodeableConcept(xml, 'type', value.type_List[i]);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.communicationMethodList.Count - 1 do
      ComposeCodeableConcept(xml, 'communicationMethod', value.communicationMethodList[i]);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(xml, 'validationStatus', value.validationStatus);
  if (SummaryOption in [soFull, soData]) then
    ComposeDateTime(xml, 'validationDate', value.validationDateElement);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(xml, 'canPushUpdates', value.canPushUpdates);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.pushTypeAvailableList.Count - 1 do
      ComposeCodeableConcept(xml, 'pushTypeAvailable', value.pushTypeAvailableList[i]);
end;

function TFHIRXmlParser.ParseVerificationResultAttestation(element : TMXmlElement; path : string) : TFhirVerificationResultAttestation;
var
  child : TMXmlElement;
begin
  result := TFhirVerificationResultAttestation.Create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseVerificationResultAttestationChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseVerificationResultAttestationChild(value : TFhirVerificationResultAttestation; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'who') then
        value.who := ParseReference(child, path+'/who')
      else if (child.localName = 'onBehalfOf') then
        value.onBehalfOf := ParseReference(child, path+'/onBehalfOf')
      else if (child.localName = 'communicationMethod') then
        value.communicationMethod := ParseCodeableConcept(child, path+'/communicationMethod')
      else if (child.localName = 'date') then
        value.dateElement := ParseDate(child, path+'/date')
      else if (child.localName = 'sourceIdentityCertificate') then
        value.sourceIdentityCertificateElement := ParseString(child, path+'/sourceIdentityCertificate')
      else if (child.localName = 'proxyIdentityCertificate') then
        value.proxyIdentityCertificateElement := ParseString(child, path+'/proxyIdentityCertificate')
      else if (child.localName = 'proxySignature') then
        value.proxySignature := ParseSignature(child, path+'/proxySignature')
      else if (child.localName = 'sourceSignature') then
        value.sourceSignature := ParseSignature(child, path+'/sourceSignature')
      else if Not ParseBackboneElementChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeVerificationResultAttestation(xml : TXmlBuilder; name : String; value : TFhirVerificationResultAttestation);
begin
  if (value = nil) then
    exit;
  composeElementAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeVerificationResultAttestationChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeVerificationResultAttestationChildren(xml : TXmlBuilder; value : TFhirVerificationResultAttestation);
begin
  composeBackboneElementChildren(xml, value);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference(xml, 'who', value.who);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference(xml, 'onBehalfOf', value.onBehalfOf);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(xml, 'communicationMethod', value.communicationMethod);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDate(xml, 'date', value.dateElement);
  if (SummaryOption in [soFull, soData]) then
    ComposeString(xml, 'sourceIdentityCertificate', value.sourceIdentityCertificateElement);
  if (SummaryOption in [soFull, soData]) then
    ComposeString(xml, 'proxyIdentityCertificate', value.proxyIdentityCertificateElement);
  if (SummaryOption in [soFull, soData]) then
    ComposeSignature(xml, 'proxySignature', value.proxySignature);
  if (SummaryOption in [soFull, soData]) then
    ComposeSignature(xml, 'sourceSignature', value.sourceSignature);
end;

function TFHIRXmlParser.ParseVerificationResultValidator(element : TMXmlElement; path : string) : TFhirVerificationResultValidator;
var
  child : TMXmlElement;
begin
  result := TFhirVerificationResultValidator.Create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseVerificationResultValidatorChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseVerificationResultValidatorChild(value : TFhirVerificationResultValidator; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'organization') then
        value.organization := ParseReference(child, path+'/organization')
      else if (child.localName = 'identityCertificate') then
        value.identityCertificateElement := ParseString(child, path+'/identityCertificate')
      else if (child.localName = 'attestationSignature') then
        value.attestationSignature := ParseSignature(child, path+'/attestationSignature')
      else if Not ParseBackboneElementChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeVerificationResultValidator(xml : TXmlBuilder; name : String; value : TFhirVerificationResultValidator);
begin
  if (value = nil) then
    exit;
  composeElementAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeVerificationResultValidatorChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeVerificationResultValidatorChildren(xml : TXmlBuilder; value : TFhirVerificationResultValidator);
begin
  composeBackboneElementChildren(xml, value);
  ComposeReference(xml, 'organization', value.organization);
  if (SummaryOption in [soFull, soData]) then
    ComposeString(xml, 'identityCertificate', value.identityCertificateElement);
  if (SummaryOption in [soFull, soData]) then
    ComposeSignature(xml, 'attestationSignature', value.attestationSignature);
end;

function TFHIRXmlParser.ParseVerificationResult(element : TMXmlElement; path : string) : TFhirVerificationResult;
var
  child : TMXmlElement;
begin
  result := TFhirVerificationResult.Create;
  try
    parseDomainResourceAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseVerificationResultChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseVerificationResultChild(value : TFhirVerificationResult; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'target') then
        value.targetList.Add(ParseReference(child, path+'/target'))
      else if (child.localName = 'targetLocation') then
        value.targetLocationList.Add(ParseString(child, path+'/targetLocation'))
      else if (child.localName = 'need') then
        value.need := ParseCodeableConcept(child, path+'/need')
      else if (child.localName = 'status') then
        value.statusElement := ParseEnum(CODES_TFhirStatusEnum, SYSTEMS_TFhirStatusEnum, child, path+'/status')
      else if (child.localName = 'statusDate') then
        value.statusDateElement := ParseDateTime(child, path+'/statusDate')
      else if (child.localName = 'validationType') then
        value.validationType := ParseCodeableConcept(child, path+'/validationType')
      else if (child.localName = 'validationProcess') then
        value.validationProcessList.Add(ParseCodeableConcept(child, path+'/validationProcess'))
      else if (child.localName = 'frequency') then
        value.frequency := ParseTiming(child, path+'/frequency')
      else if (child.localName = 'lastPerformed') then
        value.lastPerformedElement := ParseDateTime(child, path+'/lastPerformed')
      else if (child.localName = 'nextScheduled') then
        value.nextScheduledElement := ParseDate(child, path+'/nextScheduled')
      else if (child.localName = 'failureAction') then
        value.failureAction := ParseCodeableConcept(child, path+'/failureAction')
      else if (child.localName = 'primarySource') then
        value.primarySourceList.Add(ParseVerificationResultPrimarySource(child, path+'/primarySource'))
      else if (child.localName = 'attestation') then
        value.attestation := ParseVerificationResultAttestation(child, path+'/attestation')
      else if (child.localName = 'validator') then
        value.validatorList.Add(ParseVerificationResultValidator(child, path+'/validator'))
      else if Not ParseDomainResourceChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeVerificationResult(xml : TXmlBuilder; name : String; value : TFhirVerificationResult);
begin
  if (value = nil) then
    exit;
  composeDomainResourceAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeVerificationResultChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeVerificationResultChildren(xml : TXmlBuilder; value : TFhirVerificationResult);
var
  i : integer;
begin
  composeDomainResourceChildren(xml, value);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.targetList.Count - 1 do
      ComposeReference(xml, 'target', value.targetList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.targetLocationList.Count - 1 do
      ComposeString(xml, 'targetLocation', value.targetLocationList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(xml, 'need', value.need);
  ComposeEnum(xml, 'status', value.statusElement, CODES_TFhirStatusEnum);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDateTime(xml, 'statusDate', value.statusDateElement);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(xml, 'validationType', value.validationType);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.validationProcessList.Count - 1 do
      ComposeCodeableConcept(xml, 'validationProcess', value.validationProcessList[i]);
  if (SummaryOption in [soFull, soData]) then
    ComposeTiming(xml, 'frequency', value.frequency);
  if (SummaryOption in [soFull, soData]) then
    ComposeDateTime(xml, 'lastPerformed', value.lastPerformedElement);
  if (SummaryOption in [soFull, soData]) then
    ComposeDate(xml, 'nextScheduled', value.nextScheduledElement);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(xml, 'failureAction', value.failureAction);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.primarySourceList.Count - 1 do
      ComposeVerificationResultPrimarySource(xml, 'primarySource', value.primarySourceList[i]);
  if (SummaryOption in [soFull, soData]) then
    ComposeVerificationResultAttestation(xml, 'attestation', value.attestation);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.validatorList.Count - 1 do
      ComposeVerificationResultValidator(xml, 'validator', value.validatorList[i]);
end;

{$ENDIF FHIR_VERIFICATIONRESULT}
{$IFDEF FHIR_VISIONPRESCRIPTION}
function TFHIRXmlParser.ParseVisionPrescriptionLensSpecification(element : TMXmlElement; path : string) : TFhirVisionPrescriptionLensSpecification;
var
  child : TMXmlElement;
begin
  result := TFhirVisionPrescriptionLensSpecification.Create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseVisionPrescriptionLensSpecificationChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseVisionPrescriptionLensSpecificationChild(value : TFhirVisionPrescriptionLensSpecification; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'product') then
        value.product := ParseCodeableConcept(child, path+'/product')
      else if (child.localName = 'eye') then
        value.eyeElement := ParseEnum(CODES_TFhirVisionEyesEnum, SYSTEMS_TFhirVisionEyesEnum, child, path+'/eye')
      else if (child.localName = 'sphere') then
        value.sphereElement := ParseDecimal(child, path+'/sphere')
      else if (child.localName = 'cylinder') then
        value.cylinderElement := ParseDecimal(child, path+'/cylinder')
      else if (child.localName = 'axis') then
        value.axisElement := ParseInteger(child, path+'/axis')
      else if (child.localName = 'prism') then
        value.prismList.Add(ParseVisionPrescriptionLensSpecificationPrism(child, path+'/prism'))
      else if (child.localName = 'add') then
        value.addElement := ParseDecimal(child, path+'/add')
      else if (child.localName = 'power') then
        value.powerElement := ParseDecimal(child, path+'/power')
      else if (child.localName = 'backCurve') then
        value.backCurveElement := ParseDecimal(child, path+'/backCurve')
      else if (child.localName = 'diameter') then
        value.diameterElement := ParseDecimal(child, path+'/diameter')
      else if (child.localName = 'duration') then
        value.duration := ParseQuantity(child, path+'/duration')
      else if (child.localName = 'color') then
        value.colorElement := ParseString(child, path+'/color')
      else if (child.localName = 'brand') then
        value.brandElement := ParseString(child, path+'/brand')
      else if (child.localName = 'note') then
        value.noteList.Add(ParseAnnotation(child, path+'/note'))
      else if Not ParseBackboneElementChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeVisionPrescriptionLensSpecification(xml : TXmlBuilder; name : String; value : TFhirVisionPrescriptionLensSpecification);
begin
  if (value = nil) then
    exit;
  composeElementAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeVisionPrescriptionLensSpecificationChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeVisionPrescriptionLensSpecificationChildren(xml : TXmlBuilder; value : TFhirVisionPrescriptionLensSpecification);
var
  i : integer;
begin
  composeBackboneElementChildren(xml, value);
  ComposeCodeableConcept(xml, 'product', value.product);
  ComposeEnum(xml, 'eye', value.eyeElement, CODES_TFhirVisionEyesEnum);
  if (SummaryOption in [soFull, soData]) then
    ComposeDecimal(xml, 'sphere', value.sphereElement);
  if (SummaryOption in [soFull, soData]) then
    ComposeDecimal(xml, 'cylinder', value.cylinderElement);
  if (SummaryOption in [soFull, soData]) then
    ComposeInteger(xml, 'axis', value.axisElement);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.prismList.Count - 1 do
      ComposeVisionPrescriptionLensSpecificationPrism(xml, 'prism', value.prismList[i]);
  if (SummaryOption in [soFull, soData]) then
    ComposeDecimal(xml, 'add', value.addElement);
  if (SummaryOption in [soFull, soData]) then
    ComposeDecimal(xml, 'power', value.powerElement);
  if (SummaryOption in [soFull, soData]) then
    ComposeDecimal(xml, 'backCurve', value.backCurveElement);
  if (SummaryOption in [soFull, soData]) then
    ComposeDecimal(xml, 'diameter', value.diameterElement);
  if (SummaryOption in [soFull, soData]) then
    ComposeQuantity(xml, 'duration', value.duration);
  if (SummaryOption in [soFull, soData]) then
    ComposeString(xml, 'color', value.colorElement);
  if (SummaryOption in [soFull, soData]) then
    ComposeString(xml, 'brand', value.brandElement);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.noteList.Count - 1 do
      ComposeAnnotation(xml, 'note', value.noteList[i]);
end;

function TFHIRXmlParser.ParseVisionPrescriptionLensSpecificationPrism(element : TMXmlElement; path : string) : TFhirVisionPrescriptionLensSpecificationPrism;
var
  child : TMXmlElement;
begin
  result := TFhirVisionPrescriptionLensSpecificationPrism.Create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseVisionPrescriptionLensSpecificationPrismChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseVisionPrescriptionLensSpecificationPrismChild(value : TFhirVisionPrescriptionLensSpecificationPrism; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'amount') then
        value.amountElement := ParseDecimal(child, path+'/amount')
      else if (child.localName = 'base') then
        value.baseElement := ParseEnum(CODES_TFhirVisionBaseEnum, SYSTEMS_TFhirVisionBaseEnum, child, path+'/base')
      else if Not ParseBackboneElementChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeVisionPrescriptionLensSpecificationPrism(xml : TXmlBuilder; name : String; value : TFhirVisionPrescriptionLensSpecificationPrism);
begin
  if (value = nil) then
    exit;
  composeElementAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeVisionPrescriptionLensSpecificationPrismChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeVisionPrescriptionLensSpecificationPrismChildren(xml : TXmlBuilder; value : TFhirVisionPrescriptionLensSpecificationPrism);
begin
  composeBackboneElementChildren(xml, value);
  ComposeDecimal(xml, 'amount', value.amountElement);
  ComposeEnum(xml, 'base', value.baseElement, CODES_TFhirVisionBaseEnum);
end;

function TFHIRXmlParser.ParseVisionPrescription(element : TMXmlElement; path : string) : TFhirVisionPrescription;
var
  child : TMXmlElement;
begin
  result := TFhirVisionPrescription.Create;
  try
    parseDomainResourceAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseVisionPrescriptionChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseVisionPrescriptionChild(value : TFhirVisionPrescription; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'identifier') then
        value.identifierList.Add(ParseIdentifier(child, path+'/identifier'))
      else if (child.localName = 'status') then
        value.statusElement := ParseEnum(CODES_TFhirFinancialResourceStatusCodesEnum, SYSTEMS_TFhirFinancialResourceStatusCodesEnum, child, path+'/status')
      else if (child.localName = 'created') then
        value.createdElement := ParseDateTime(child, path+'/created')
      else if (child.localName = 'patient') then
        value.patient := ParseReference(child, path+'/patient')
      else if (child.localName = 'encounter') then
        value.encounter := ParseReference(child, path+'/encounter')
      else if (child.localName = 'dateWritten') then
        value.dateWrittenElement := ParseDateTime(child, path+'/dateWritten')
      else if (child.localName = 'prescriber') then
        value.prescriber := ParseReference(child, path+'/prescriber')
      else if (child.localName = 'lensSpecification') then
        value.lensSpecificationList.Add(ParseVisionPrescriptionLensSpecification(child, path+'/lensSpecification'))
      else if Not ParseDomainResourceChild(value, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeVisionPrescription(xml : TXmlBuilder; name : String; value : TFhirVisionPrescription);
begin
  if (value = nil) then
    exit;
  composeDomainResourceAttributes(xml, value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeVisionPrescriptionChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeVisionPrescriptionChildren(xml : TXmlBuilder; value : TFhirVisionPrescription);
var
  i : integer;
begin
  composeDomainResourceChildren(xml, value);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.identifierList.Count - 1 do
      ComposeIdentifier(xml, 'identifier', value.identifierList[i]);
  ComposeEnum(xml, 'status', value.statusElement, CODES_TFhirFinancialResourceStatusCodesEnum);
  ComposeDateTime(xml, 'created', value.createdElement);
  ComposeReference(xml, 'patient', value.patient);
  if (SummaryOption in [soFull, soData]) then
    ComposeReference(xml, 'encounter', value.encounter);
  ComposeDateTime(xml, 'dateWritten', value.dateWrittenElement);
  ComposeReference(xml, 'prescriber', value.prescriber);
  for i := 0 to value.lensSpecificationList.Count - 1 do
      ComposeVisionPrescriptionLensSpecification(xml, 'lensSpecification', value.lensSpecificationList[i]);
end;

{$ENDIF FHIR_VISIONPRESCRIPTION}


function TFHIRXmlParser.ParseResource(element : TMXmlElement; path : String) : TFhirResource;
begin
  if (element = nil) Then
    Raise EXmlException.Create('error - element is nil')
{$IFDEF FHIR_ACCOUNT}
  else if element.localName = 'Account' Then
    result := ParseAccount(element, path+'/Account')
{$ENDIF FHIR_ACCOUNT}
{$IFDEF FHIR_ACTIVITYDEFINITION}
  else if element.localName = 'ActivityDefinition' Then
    result := ParseActivityDefinition(element, path+'/ActivityDefinition')
{$ENDIF FHIR_ACTIVITYDEFINITION}
{$IFDEF FHIR_ACTORDEFINITION}
  else if element.localName = 'ActorDefinition' Then
    result := ParseActorDefinition(element, path+'/ActorDefinition')
{$ENDIF FHIR_ACTORDEFINITION}
{$IFDEF FHIR_ADMINISTRABLEPRODUCTDEFINITION}
  else if element.localName = 'AdministrableProductDefinition' Then
    result := ParseAdministrableProductDefinition(element, path+'/AdministrableProductDefinition')
{$ENDIF FHIR_ADMINISTRABLEPRODUCTDEFINITION}
{$IFDEF FHIR_ADVERSEEVENT}
  else if element.localName = 'AdverseEvent' Then
    result := ParseAdverseEvent(element, path+'/AdverseEvent')
{$ENDIF FHIR_ADVERSEEVENT}
{$IFDEF FHIR_ALLERGYINTOLERANCE}
  else if element.localName = 'AllergyIntolerance' Then
    result := ParseAllergyIntolerance(element, path+'/AllergyIntolerance')
{$ENDIF FHIR_ALLERGYINTOLERANCE}
{$IFDEF FHIR_APPOINTMENT}
  else if element.localName = 'Appointment' Then
    result := ParseAppointment(element, path+'/Appointment')
{$ENDIF FHIR_APPOINTMENT}
{$IFDEF FHIR_APPOINTMENTRESPONSE}
  else if element.localName = 'AppointmentResponse' Then
    result := ParseAppointmentResponse(element, path+'/AppointmentResponse')
{$ENDIF FHIR_APPOINTMENTRESPONSE}
{$IFDEF FHIR_ARTIFACTASSESSMENT}
  else if element.localName = 'ArtifactAssessment' Then
    result := ParseArtifactAssessment(element, path+'/ArtifactAssessment')
{$ENDIF FHIR_ARTIFACTASSESSMENT}
{$IFDEF FHIR_AUDITEVENT}
  else if element.localName = 'AuditEvent' Then
    result := ParseAuditEvent(element, path+'/AuditEvent')
{$ENDIF FHIR_AUDITEVENT}
{$IFDEF FHIR_BASIC}
  else if element.localName = 'Basic' Then
    result := ParseBasic(element, path+'/Basic')
{$ENDIF FHIR_BASIC}
{$IFDEF FHIR_BINARY}
  else if element.localName = 'Binary' Then
    result := ParseBinary(element, path+'/Binary')
{$ENDIF FHIR_BINARY}
{$IFDEF FHIR_BIOLOGICALLYDERIVEDPRODUCT}
  else if element.localName = 'BiologicallyDerivedProduct' Then
    result := ParseBiologicallyDerivedProduct(element, path+'/BiologicallyDerivedProduct')
{$ENDIF FHIR_BIOLOGICALLYDERIVEDPRODUCT}
{$IFDEF FHIR_BODYSTRUCTURE}
  else if element.localName = 'BodyStructure' Then
    result := ParseBodyStructure(element, path+'/BodyStructure')
{$ENDIF FHIR_BODYSTRUCTURE}
{$IFDEF FHIR_BUNDLE}
  else if element.localName = 'Bundle' Then
    result := ParseBundle(element, path+'/Bundle')
{$ENDIF FHIR_BUNDLE}
{$IFDEF FHIR_CAPABILITYSTATEMENT}
  else if element.localName = 'CapabilityStatement' Then
    result := ParseCapabilityStatement(element, path+'/CapabilityStatement')
{$ENDIF FHIR_CAPABILITYSTATEMENT}
{$IFDEF FHIR_CAREPLAN}
  else if element.localName = 'CarePlan' Then
    result := ParseCarePlan(element, path+'/CarePlan')
{$ENDIF FHIR_CAREPLAN}
{$IFDEF FHIR_CARETEAM}
  else if element.localName = 'CareTeam' Then
    result := ParseCareTeam(element, path+'/CareTeam')
{$ENDIF FHIR_CARETEAM}
{$IFDEF FHIR_CHARGEITEM}
  else if element.localName = 'ChargeItem' Then
    result := ParseChargeItem(element, path+'/ChargeItem')
{$ENDIF FHIR_CHARGEITEM}
{$IFDEF FHIR_CHARGEITEMDEFINITION}
  else if element.localName = 'ChargeItemDefinition' Then
    result := ParseChargeItemDefinition(element, path+'/ChargeItemDefinition')
{$ENDIF FHIR_CHARGEITEMDEFINITION}
{$IFDEF FHIR_CITATION}
  else if element.localName = 'Citation' Then
    result := ParseCitation(element, path+'/Citation')
{$ENDIF FHIR_CITATION}
{$IFDEF FHIR_CLAIM}
  else if element.localName = 'Claim' Then
    result := ParseClaim(element, path+'/Claim')
{$ENDIF FHIR_CLAIM}
{$IFDEF FHIR_CLAIMRESPONSE}
  else if element.localName = 'ClaimResponse' Then
    result := ParseClaimResponse(element, path+'/ClaimResponse')
{$ENDIF FHIR_CLAIMRESPONSE}
{$IFDEF FHIR_CLINICALIMPRESSION}
  else if element.localName = 'ClinicalImpression' Then
    result := ParseClinicalImpression(element, path+'/ClinicalImpression')
{$ENDIF FHIR_CLINICALIMPRESSION}
{$IFDEF FHIR_CLINICALUSEDEFINITION}
  else if element.localName = 'ClinicalUseDefinition' Then
    result := ParseClinicalUseDefinition(element, path+'/ClinicalUseDefinition')
{$ENDIF FHIR_CLINICALUSEDEFINITION}
{$IFDEF FHIR_CODESYSTEM}
  else if element.localName = 'CodeSystem' Then
    result := ParseCodeSystem(element, path+'/CodeSystem')
{$ENDIF FHIR_CODESYSTEM}
{$IFDEF FHIR_COMMUNICATION}
  else if element.localName = 'Communication' Then
    result := ParseCommunication(element, path+'/Communication')
{$ENDIF FHIR_COMMUNICATION}
{$IFDEF FHIR_COMMUNICATIONREQUEST}
  else if element.localName = 'CommunicationRequest' Then
    result := ParseCommunicationRequest(element, path+'/CommunicationRequest')
{$ENDIF FHIR_COMMUNICATIONREQUEST}
{$IFDEF FHIR_COMPARTMENTDEFINITION}
  else if element.localName = 'CompartmentDefinition' Then
    result := ParseCompartmentDefinition(element, path+'/CompartmentDefinition')
{$ENDIF FHIR_COMPARTMENTDEFINITION}
{$IFDEF FHIR_COMPOSITION}
  else if element.localName = 'Composition' Then
    result := ParseComposition(element, path+'/Composition')
{$ENDIF FHIR_COMPOSITION}
{$IFDEF FHIR_CONCEPTMAP}
  else if element.localName = 'ConceptMap' Then
    result := ParseConceptMap(element, path+'/ConceptMap')
{$ENDIF FHIR_CONCEPTMAP}
{$IFDEF FHIR_CONDITION}
  else if element.localName = 'Condition' Then
    result := ParseCondition(element, path+'/Condition')
{$ENDIF FHIR_CONDITION}
{$IFDEF FHIR_CONDITIONDEFINITION}
  else if element.localName = 'ConditionDefinition' Then
    result := ParseConditionDefinition(element, path+'/ConditionDefinition')
{$ENDIF FHIR_CONDITIONDEFINITION}
{$IFDEF FHIR_CONSENT}
  else if element.localName = 'Consent' Then
    result := ParseConsent(element, path+'/Consent')
{$ENDIF FHIR_CONSENT}
{$IFDEF FHIR_CONTRACT}
  else if element.localName = 'Contract' Then
    result := ParseContract(element, path+'/Contract')
{$ENDIF FHIR_CONTRACT}
{$IFDEF FHIR_COVERAGE}
  else if element.localName = 'Coverage' Then
    result := ParseCoverage(element, path+'/Coverage')
{$ENDIF FHIR_COVERAGE}
{$IFDEF FHIR_COVERAGEELIGIBILITYREQUEST}
  else if element.localName = 'CoverageEligibilityRequest' Then
    result := ParseCoverageEligibilityRequest(element, path+'/CoverageEligibilityRequest')
{$ENDIF FHIR_COVERAGEELIGIBILITYREQUEST}
{$IFDEF FHIR_COVERAGEELIGIBILITYRESPONSE}
  else if element.localName = 'CoverageEligibilityResponse' Then
    result := ParseCoverageEligibilityResponse(element, path+'/CoverageEligibilityResponse')
{$ENDIF FHIR_COVERAGEELIGIBILITYRESPONSE}
{$IFDEF FHIR_DETECTEDISSUE}
  else if element.localName = 'DetectedIssue' Then
    result := ParseDetectedIssue(element, path+'/DetectedIssue')
{$ENDIF FHIR_DETECTEDISSUE}
{$IFDEF FHIR_DEVICE}
  else if element.localName = 'Device' Then
    result := ParseDevice(element, path+'/Device')
{$ENDIF FHIR_DEVICE}
{$IFDEF FHIR_DEVICEDEFINITION}
  else if element.localName = 'DeviceDefinition' Then
    result := ParseDeviceDefinition(element, path+'/DeviceDefinition')
{$ENDIF FHIR_DEVICEDEFINITION}
{$IFDEF FHIR_DEVICEDISPENSE}
  else if element.localName = 'DeviceDispense' Then
    result := ParseDeviceDispense(element, path+'/DeviceDispense')
{$ENDIF FHIR_DEVICEDISPENSE}
{$IFDEF FHIR_DEVICEMETRIC}
  else if element.localName = 'DeviceMetric' Then
    result := ParseDeviceMetric(element, path+'/DeviceMetric')
{$ENDIF FHIR_DEVICEMETRIC}
{$IFDEF FHIR_DEVICEREQUEST}
  else if element.localName = 'DeviceRequest' Then
    result := ParseDeviceRequest(element, path+'/DeviceRequest')
{$ENDIF FHIR_DEVICEREQUEST}
{$IFDEF FHIR_DEVICEUSAGE}
  else if element.localName = 'DeviceUsage' Then
    result := ParseDeviceUsage(element, path+'/DeviceUsage')
{$ENDIF FHIR_DEVICEUSAGE}
{$IFDEF FHIR_DIAGNOSTICREPORT}
  else if element.localName = 'DiagnosticReport' Then
    result := ParseDiagnosticReport(element, path+'/DiagnosticReport')
{$ENDIF FHIR_DIAGNOSTICREPORT}
{$IFDEF FHIR_DOCUMENTMANIFEST}
  else if element.localName = 'DocumentManifest' Then
    result := ParseDocumentManifest(element, path+'/DocumentManifest')
{$ENDIF FHIR_DOCUMENTMANIFEST}
{$IFDEF FHIR_DOCUMENTREFERENCE}
  else if element.localName = 'DocumentReference' Then
    result := ParseDocumentReference(element, path+'/DocumentReference')
{$ENDIF FHIR_DOCUMENTREFERENCE}
{$IFDEF FHIR_ENCOUNTER}
  else if element.localName = 'Encounter' Then
    result := ParseEncounter(element, path+'/Encounter')
{$ENDIF FHIR_ENCOUNTER}
{$IFDEF FHIR_ENDPOINT}
  else if element.localName = 'Endpoint' Then
    result := ParseEndpoint(element, path+'/Endpoint')
{$ENDIF FHIR_ENDPOINT}
{$IFDEF FHIR_ENROLLMENTREQUEST}
  else if element.localName = 'EnrollmentRequest' Then
    result := ParseEnrollmentRequest(element, path+'/EnrollmentRequest')
{$ENDIF FHIR_ENROLLMENTREQUEST}
{$IFDEF FHIR_ENROLLMENTRESPONSE}
  else if element.localName = 'EnrollmentResponse' Then
    result := ParseEnrollmentResponse(element, path+'/EnrollmentResponse')
{$ENDIF FHIR_ENROLLMENTRESPONSE}
{$IFDEF FHIR_EPISODEOFCARE}
  else if element.localName = 'EpisodeOfCare' Then
    result := ParseEpisodeOfCare(element, path+'/EpisodeOfCare')
{$ENDIF FHIR_EPISODEOFCARE}
{$IFDEF FHIR_EVENTDEFINITION}
  else if element.localName = 'EventDefinition' Then
    result := ParseEventDefinition(element, path+'/EventDefinition')
{$ENDIF FHIR_EVENTDEFINITION}
{$IFDEF FHIR_EVIDENCE}
  else if element.localName = 'Evidence' Then
    result := ParseEvidence(element, path+'/Evidence')
{$ENDIF FHIR_EVIDENCE}
{$IFDEF FHIR_EVIDENCEREPORT}
  else if element.localName = 'EvidenceReport' Then
    result := ParseEvidenceReport(element, path+'/EvidenceReport')
{$ENDIF FHIR_EVIDENCEREPORT}
{$IFDEF FHIR_EVIDENCEVARIABLE}
  else if element.localName = 'EvidenceVariable' Then
    result := ParseEvidenceVariable(element, path+'/EvidenceVariable')
{$ENDIF FHIR_EVIDENCEVARIABLE}
{$IFDEF FHIR_EXAMPLESCENARIO}
  else if element.localName = 'ExampleScenario' Then
    result := ParseExampleScenario(element, path+'/ExampleScenario')
{$ENDIF FHIR_EXAMPLESCENARIO}
{$IFDEF FHIR_EXPLANATIONOFBENEFIT}
  else if element.localName = 'ExplanationOfBenefit' Then
    result := ParseExplanationOfBenefit(element, path+'/ExplanationOfBenefit')
{$ENDIF FHIR_EXPLANATIONOFBENEFIT}
{$IFDEF FHIR_FAMILYMEMBERHISTORY}
  else if element.localName = 'FamilyMemberHistory' Then
    result := ParseFamilyMemberHistory(element, path+'/FamilyMemberHistory')
{$ENDIF FHIR_FAMILYMEMBERHISTORY}
{$IFDEF FHIR_FLAG}
  else if element.localName = 'Flag' Then
    result := ParseFlag(element, path+'/Flag')
{$ENDIF FHIR_FLAG}
{$IFDEF FHIR_FORMULARYITEM}
  else if element.localName = 'FormularyItem' Then
    result := ParseFormularyItem(element, path+'/FormularyItem')
{$ENDIF FHIR_FORMULARYITEM}
{$IFDEF FHIR_GENOMICSTUDY}
  else if element.localName = 'GenomicStudy' Then
    result := ParseGenomicStudy(element, path+'/GenomicStudy')
{$ENDIF FHIR_GENOMICSTUDY}
{$IFDEF FHIR_GOAL}
  else if element.localName = 'Goal' Then
    result := ParseGoal(element, path+'/Goal')
{$ENDIF FHIR_GOAL}
{$IFDEF FHIR_GRAPHDEFINITION}
  else if element.localName = 'GraphDefinition' Then
    result := ParseGraphDefinition(element, path+'/GraphDefinition')
{$ENDIF FHIR_GRAPHDEFINITION}
{$IFDEF FHIR_GROUP}
  else if element.localName = 'Group' Then
    result := ParseGroup(element, path+'/Group')
{$ENDIF FHIR_GROUP}
{$IFDEF FHIR_GUIDANCERESPONSE}
  else if element.localName = 'GuidanceResponse' Then
    result := ParseGuidanceResponse(element, path+'/GuidanceResponse')
{$ENDIF FHIR_GUIDANCERESPONSE}
{$IFDEF FHIR_HEALTHCARESERVICE}
  else if element.localName = 'HealthcareService' Then
    result := ParseHealthcareService(element, path+'/HealthcareService')
{$ENDIF FHIR_HEALTHCARESERVICE}
{$IFDEF FHIR_IMAGINGSELECTION}
  else if element.localName = 'ImagingSelection' Then
    result := ParseImagingSelection(element, path+'/ImagingSelection')
{$ENDIF FHIR_IMAGINGSELECTION}
{$IFDEF FHIR_IMAGINGSTUDY}
  else if element.localName = 'ImagingStudy' Then
    result := ParseImagingStudy(element, path+'/ImagingStudy')
{$ENDIF FHIR_IMAGINGSTUDY}
{$IFDEF FHIR_IMMUNIZATION}
  else if element.localName = 'Immunization' Then
    result := ParseImmunization(element, path+'/Immunization')
{$ENDIF FHIR_IMMUNIZATION}
{$IFDEF FHIR_IMMUNIZATIONEVALUATION}
  else if element.localName = 'ImmunizationEvaluation' Then
    result := ParseImmunizationEvaluation(element, path+'/ImmunizationEvaluation')
{$ENDIF FHIR_IMMUNIZATIONEVALUATION}
{$IFDEF FHIR_IMMUNIZATIONRECOMMENDATION}
  else if element.localName = 'ImmunizationRecommendation' Then
    result := ParseImmunizationRecommendation(element, path+'/ImmunizationRecommendation')
{$ENDIF FHIR_IMMUNIZATIONRECOMMENDATION}
{$IFDEF FHIR_IMPLEMENTATIONGUIDE}
  else if element.localName = 'ImplementationGuide' Then
    result := ParseImplementationGuide(element, path+'/ImplementationGuide')
{$ENDIF FHIR_IMPLEMENTATIONGUIDE}
{$IFDEF FHIR_INGREDIENT}
  else if element.localName = 'Ingredient' Then
    result := ParseIngredient(element, path+'/Ingredient')
{$ENDIF FHIR_INGREDIENT}
{$IFDEF FHIR_INSURANCEPLAN}
  else if element.localName = 'InsurancePlan' Then
    result := ParseInsurancePlan(element, path+'/InsurancePlan')
{$ENDIF FHIR_INSURANCEPLAN}
{$IFDEF FHIR_INVENTORYREPORT}
  else if element.localName = 'InventoryReport' Then
    result := ParseInventoryReport(element, path+'/InventoryReport')
{$ENDIF FHIR_INVENTORYREPORT}
{$IFDEF FHIR_INVOICE}
  else if element.localName = 'Invoice' Then
    result := ParseInvoice(element, path+'/Invoice')
{$ENDIF FHIR_INVOICE}
{$IFDEF FHIR_LIBRARY}
  else if element.localName = 'Library' Then
    result := ParseLibrary(element, path+'/Library')
{$ENDIF FHIR_LIBRARY}
{$IFDEF FHIR_LINKAGE}
  else if element.localName = 'Linkage' Then
    result := ParseLinkage(element, path+'/Linkage')
{$ENDIF FHIR_LINKAGE}
{$IFDEF FHIR_LIST}
  else if element.localName = 'List' Then
    result := ParseList(element, path+'/List')
{$ENDIF FHIR_LIST}
{$IFDEF FHIR_LOCATION}
  else if element.localName = 'Location' Then
    result := ParseLocation(element, path+'/Location')
{$ENDIF FHIR_LOCATION}
{$IFDEF FHIR_MANUFACTUREDITEMDEFINITION}
  else if element.localName = 'ManufacturedItemDefinition' Then
    result := ParseManufacturedItemDefinition(element, path+'/ManufacturedItemDefinition')
{$ENDIF FHIR_MANUFACTUREDITEMDEFINITION}
{$IFDEF FHIR_MEASURE}
  else if element.localName = 'Measure' Then
    result := ParseMeasure(element, path+'/Measure')
{$ENDIF FHIR_MEASURE}
{$IFDEF FHIR_MEASUREREPORT}
  else if element.localName = 'MeasureReport' Then
    result := ParseMeasureReport(element, path+'/MeasureReport')
{$ENDIF FHIR_MEASUREREPORT}
{$IFDEF FHIR_MEDICATION}
  else if element.localName = 'Medication' Then
    result := ParseMedication(element, path+'/Medication')
{$ENDIF FHIR_MEDICATION}
{$IFDEF FHIR_MEDICATIONADMINISTRATION}
  else if element.localName = 'MedicationAdministration' Then
    result := ParseMedicationAdministration(element, path+'/MedicationAdministration')
{$ENDIF FHIR_MEDICATIONADMINISTRATION}
{$IFDEF FHIR_MEDICATIONDISPENSE}
  else if element.localName = 'MedicationDispense' Then
    result := ParseMedicationDispense(element, path+'/MedicationDispense')
{$ENDIF FHIR_MEDICATIONDISPENSE}
{$IFDEF FHIR_MEDICATIONKNOWLEDGE}
  else if element.localName = 'MedicationKnowledge' Then
    result := ParseMedicationKnowledge(element, path+'/MedicationKnowledge')
{$ENDIF FHIR_MEDICATIONKNOWLEDGE}
{$IFDEF FHIR_MEDICATIONREQUEST}
  else if element.localName = 'MedicationRequest' Then
    result := ParseMedicationRequest(element, path+'/MedicationRequest')
{$ENDIF FHIR_MEDICATIONREQUEST}
{$IFDEF FHIR_MEDICATIONUSAGE}
  else if element.localName = 'MedicationUsage' Then
    result := ParseMedicationUsage(element, path+'/MedicationUsage')
{$ENDIF FHIR_MEDICATIONUSAGE}
{$IFDEF FHIR_MEDICINALPRODUCTDEFINITION}
  else if element.localName = 'MedicinalProductDefinition' Then
    result := ParseMedicinalProductDefinition(element, path+'/MedicinalProductDefinition')
{$ENDIF FHIR_MEDICINALPRODUCTDEFINITION}
{$IFDEF FHIR_MESSAGEDEFINITION}
  else if element.localName = 'MessageDefinition' Then
    result := ParseMessageDefinition(element, path+'/MessageDefinition')
{$ENDIF FHIR_MESSAGEDEFINITION}
{$IFDEF FHIR_MESSAGEHEADER}
  else if element.localName = 'MessageHeader' Then
    result := ParseMessageHeader(element, path+'/MessageHeader')
{$ENDIF FHIR_MESSAGEHEADER}
{$IFDEF FHIR_MOLECULARSEQUENCE}
  else if element.localName = 'MolecularSequence' Then
    result := ParseMolecularSequence(element, path+'/MolecularSequence')
{$ENDIF FHIR_MOLECULARSEQUENCE}
{$IFDEF FHIR_NAMINGSYSTEM}
  else if element.localName = 'NamingSystem' Then
    result := ParseNamingSystem(element, path+'/NamingSystem')
{$ENDIF FHIR_NAMINGSYSTEM}
{$IFDEF FHIR_NUTRITIONINTAKE}
  else if element.localName = 'NutritionIntake' Then
    result := ParseNutritionIntake(element, path+'/NutritionIntake')
{$ENDIF FHIR_NUTRITIONINTAKE}
{$IFDEF FHIR_NUTRITIONORDER}
  else if element.localName = 'NutritionOrder' Then
    result := ParseNutritionOrder(element, path+'/NutritionOrder')
{$ENDIF FHIR_NUTRITIONORDER}
{$IFDEF FHIR_NUTRITIONPRODUCT}
  else if element.localName = 'NutritionProduct' Then
    result := ParseNutritionProduct(element, path+'/NutritionProduct')
{$ENDIF FHIR_NUTRITIONPRODUCT}
{$IFDEF FHIR_OBSERVATION}
  else if element.localName = 'Observation' Then
    result := ParseObservation(element, path+'/Observation')
{$ENDIF FHIR_OBSERVATION}
{$IFDEF FHIR_OBSERVATIONDEFINITION}
  else if element.localName = 'ObservationDefinition' Then
    result := ParseObservationDefinition(element, path+'/ObservationDefinition')
{$ENDIF FHIR_OBSERVATIONDEFINITION}
{$IFDEF FHIR_OPERATIONDEFINITION}
  else if element.localName = 'OperationDefinition' Then
    result := ParseOperationDefinition(element, path+'/OperationDefinition')
{$ENDIF FHIR_OPERATIONDEFINITION}
{$IFDEF FHIR_OPERATIONOUTCOME}
  else if element.localName = 'OperationOutcome' Then
    result := ParseOperationOutcome(element, path+'/OperationOutcome')
{$ENDIF FHIR_OPERATIONOUTCOME}
{$IFDEF FHIR_ORGANIZATION}
  else if element.localName = 'Organization' Then
    result := ParseOrganization(element, path+'/Organization')
{$ENDIF FHIR_ORGANIZATION}
{$IFDEF FHIR_ORGANIZATIONAFFILIATION}
  else if element.localName = 'OrganizationAffiliation' Then
    result := ParseOrganizationAffiliation(element, path+'/OrganizationAffiliation')
{$ENDIF FHIR_ORGANIZATIONAFFILIATION}
{$IFDEF FHIR_PACKAGEDPRODUCTDEFINITION}
  else if element.localName = 'PackagedProductDefinition' Then
    result := ParsePackagedProductDefinition(element, path+'/PackagedProductDefinition')
{$ENDIF FHIR_PACKAGEDPRODUCTDEFINITION}
{$IFDEF FHIR_PARAMETERS}
  else if element.localName = 'Parameters' Then
    result := ParseParameters(element, path+'/Parameters')
{$ENDIF FHIR_PARAMETERS}
{$IFDEF FHIR_PATIENT}
  else if element.localName = 'Patient' Then
    result := ParsePatient(element, path+'/Patient')
{$ENDIF FHIR_PATIENT}
{$IFDEF FHIR_PAYMENTNOTICE}
  else if element.localName = 'PaymentNotice' Then
    result := ParsePaymentNotice(element, path+'/PaymentNotice')
{$ENDIF FHIR_PAYMENTNOTICE}
{$IFDEF FHIR_PAYMENTRECONCILIATION}
  else if element.localName = 'PaymentReconciliation' Then
    result := ParsePaymentReconciliation(element, path+'/PaymentReconciliation')
{$ENDIF FHIR_PAYMENTRECONCILIATION}
{$IFDEF FHIR_PERMISSION}
  else if element.localName = 'Permission' Then
    result := ParsePermission(element, path+'/Permission')
{$ENDIF FHIR_PERMISSION}
{$IFDEF FHIR_PERSON}
  else if element.localName = 'Person' Then
    result := ParsePerson(element, path+'/Person')
{$ENDIF FHIR_PERSON}
{$IFDEF FHIR_PLANDEFINITION}
  else if element.localName = 'PlanDefinition' Then
    result := ParsePlanDefinition(element, path+'/PlanDefinition')
{$ENDIF FHIR_PLANDEFINITION}
{$IFDEF FHIR_PRACTITIONER}
  else if element.localName = 'Practitioner' Then
    result := ParsePractitioner(element, path+'/Practitioner')
{$ENDIF FHIR_PRACTITIONER}
{$IFDEF FHIR_PRACTITIONERROLE}
  else if element.localName = 'PractitionerRole' Then
    result := ParsePractitionerRole(element, path+'/PractitionerRole')
{$ENDIF FHIR_PRACTITIONERROLE}
{$IFDEF FHIR_PROCEDURE}
  else if element.localName = 'Procedure' Then
    result := ParseProcedure(element, path+'/Procedure')
{$ENDIF FHIR_PROCEDURE}
{$IFDEF FHIR_PROVENANCE}
  else if element.localName = 'Provenance' Then
    result := ParseProvenance(element, path+'/Provenance')
{$ENDIF FHIR_PROVENANCE}
{$IFDEF FHIR_QUESTIONNAIRE}
  else if element.localName = 'Questionnaire' Then
    result := ParseQuestionnaire(element, path+'/Questionnaire')
{$ENDIF FHIR_QUESTIONNAIRE}
{$IFDEF FHIR_QUESTIONNAIRERESPONSE}
  else if element.localName = 'QuestionnaireResponse' Then
    result := ParseQuestionnaireResponse(element, path+'/QuestionnaireResponse')
{$ENDIF FHIR_QUESTIONNAIRERESPONSE}
{$IFDEF FHIR_REGULATEDAUTHORIZATION}
  else if element.localName = 'RegulatedAuthorization' Then
    result := ParseRegulatedAuthorization(element, path+'/RegulatedAuthorization')
{$ENDIF FHIR_REGULATEDAUTHORIZATION}
{$IFDEF FHIR_RELATEDPERSON}
  else if element.localName = 'RelatedPerson' Then
    result := ParseRelatedPerson(element, path+'/RelatedPerson')
{$ENDIF FHIR_RELATEDPERSON}
{$IFDEF FHIR_REQUESTGROUP}
  else if element.localName = 'RequestGroup' Then
    result := ParseRequestGroup(element, path+'/RequestGroup')
{$ENDIF FHIR_REQUESTGROUP}
{$IFDEF FHIR_REQUESTORCHESTRATION}
  else if element.localName = 'RequestOrchestration' Then
    result := ParseRequestOrchestration(element, path+'/RequestOrchestration')
{$ENDIF FHIR_REQUESTORCHESTRATION}
{$IFDEF FHIR_REQUIREMENTS}
  else if element.localName = 'Requirements' Then
    result := ParseRequirements(element, path+'/Requirements')
{$ENDIF FHIR_REQUIREMENTS}
{$IFDEF FHIR_RESEARCHSTUDY}
  else if element.localName = 'ResearchStudy' Then
    result := ParseResearchStudy(element, path+'/ResearchStudy')
{$ENDIF FHIR_RESEARCHSTUDY}
{$IFDEF FHIR_RESEARCHSUBJECT}
  else if element.localName = 'ResearchSubject' Then
    result := ParseResearchSubject(element, path+'/ResearchSubject')
{$ENDIF FHIR_RESEARCHSUBJECT}
{$IFDEF FHIR_RISKASSESSMENT}
  else if element.localName = 'RiskAssessment' Then
    result := ParseRiskAssessment(element, path+'/RiskAssessment')
{$ENDIF FHIR_RISKASSESSMENT}
{$IFDEF FHIR_SCHEDULE}
  else if element.localName = 'Schedule' Then
    result := ParseSchedule(element, path+'/Schedule')
{$ENDIF FHIR_SCHEDULE}
{$IFDEF FHIR_SEARCHPARAMETER}
  else if element.localName = 'SearchParameter' Then
    result := ParseSearchParameter(element, path+'/SearchParameter')
{$ENDIF FHIR_SEARCHPARAMETER}
{$IFDEF FHIR_SERVICEREQUEST}
  else if element.localName = 'ServiceRequest' Then
    result := ParseServiceRequest(element, path+'/ServiceRequest')
{$ENDIF FHIR_SERVICEREQUEST}
{$IFDEF FHIR_SLOT}
  else if element.localName = 'Slot' Then
    result := ParseSlot(element, path+'/Slot')
{$ENDIF FHIR_SLOT}
{$IFDEF FHIR_SPECIMEN}
  else if element.localName = 'Specimen' Then
    result := ParseSpecimen(element, path+'/Specimen')
{$ENDIF FHIR_SPECIMEN}
{$IFDEF FHIR_SPECIMENDEFINITION}
  else if element.localName = 'SpecimenDefinition' Then
    result := ParseSpecimenDefinition(element, path+'/SpecimenDefinition')
{$ENDIF FHIR_SPECIMENDEFINITION}
{$IFDEF FHIR_STRUCTUREDEFINITION}
  else if element.localName = 'StructureDefinition' Then
    result := ParseStructureDefinition(element, path+'/StructureDefinition')
{$ENDIF FHIR_STRUCTUREDEFINITION}
{$IFDEF FHIR_STRUCTUREMAP}
  else if element.localName = 'StructureMap' Then
    result := ParseStructureMap(element, path+'/StructureMap')
{$ENDIF FHIR_STRUCTUREMAP}
{$IFDEF FHIR_SUBSCRIPTION}
  else if element.localName = 'Subscription' Then
    result := ParseSubscription(element, path+'/Subscription')
{$ENDIF FHIR_SUBSCRIPTION}
{$IFDEF FHIR_SUBSCRIPTIONSTATUS}
  else if element.localName = 'SubscriptionStatus' Then
    result := ParseSubscriptionStatus(element, path+'/SubscriptionStatus')
{$ENDIF FHIR_SUBSCRIPTIONSTATUS}
{$IFDEF FHIR_SUBSCRIPTIONTOPIC}
  else if element.localName = 'SubscriptionTopic' Then
    result := ParseSubscriptionTopic(element, path+'/SubscriptionTopic')
{$ENDIF FHIR_SUBSCRIPTIONTOPIC}
{$IFDEF FHIR_SUBSTANCE}
  else if element.localName = 'Substance' Then
    result := ParseSubstance(element, path+'/Substance')
{$ENDIF FHIR_SUBSTANCE}
{$IFDEF FHIR_SUBSTANCEDEFINITION}
  else if element.localName = 'SubstanceDefinition' Then
    result := ParseSubstanceDefinition(element, path+'/SubstanceDefinition')
{$ENDIF FHIR_SUBSTANCEDEFINITION}
{$IFDEF FHIR_SUBSTANCENUCLEICACID}
  else if element.localName = 'SubstanceNucleicAcid' Then
    result := ParseSubstanceNucleicAcid(element, path+'/SubstanceNucleicAcid')
{$ENDIF FHIR_SUBSTANCENUCLEICACID}
{$IFDEF FHIR_SUBSTANCEPOLYMER}
  else if element.localName = 'SubstancePolymer' Then
    result := ParseSubstancePolymer(element, path+'/SubstancePolymer')
{$ENDIF FHIR_SUBSTANCEPOLYMER}
{$IFDEF FHIR_SUBSTANCEPROTEIN}
  else if element.localName = 'SubstanceProtein' Then
    result := ParseSubstanceProtein(element, path+'/SubstanceProtein')
{$ENDIF FHIR_SUBSTANCEPROTEIN}
{$IFDEF FHIR_SUBSTANCEREFERENCEINFORMATION}
  else if element.localName = 'SubstanceReferenceInformation' Then
    result := ParseSubstanceReferenceInformation(element, path+'/SubstanceReferenceInformation')
{$ENDIF FHIR_SUBSTANCEREFERENCEINFORMATION}
{$IFDEF FHIR_SUBSTANCESOURCEMATERIAL}
  else if element.localName = 'SubstanceSourceMaterial' Then
    result := ParseSubstanceSourceMaterial(element, path+'/SubstanceSourceMaterial')
{$ENDIF FHIR_SUBSTANCESOURCEMATERIAL}
{$IFDEF FHIR_SUPPLYDELIVERY}
  else if element.localName = 'SupplyDelivery' Then
    result := ParseSupplyDelivery(element, path+'/SupplyDelivery')
{$ENDIF FHIR_SUPPLYDELIVERY}
{$IFDEF FHIR_SUPPLYREQUEST}
  else if element.localName = 'SupplyRequest' Then
    result := ParseSupplyRequest(element, path+'/SupplyRequest')
{$ENDIF FHIR_SUPPLYREQUEST}
{$IFDEF FHIR_TASK}
  else if element.localName = 'Task' Then
    result := ParseTask(element, path+'/Task')
{$ENDIF FHIR_TASK}
{$IFDEF FHIR_TERMINOLOGYCAPABILITIES}
  else if element.localName = 'TerminologyCapabilities' Then
    result := ParseTerminologyCapabilities(element, path+'/TerminologyCapabilities')
{$ENDIF FHIR_TERMINOLOGYCAPABILITIES}
{$IFDEF FHIR_TESTREPORT}
  else if element.localName = 'TestReport' Then
    result := ParseTestReport(element, path+'/TestReport')
{$ENDIF FHIR_TESTREPORT}
{$IFDEF FHIR_TESTSCRIPT}
  else if element.localName = 'TestScript' Then
    result := ParseTestScript(element, path+'/TestScript')
{$ENDIF FHIR_TESTSCRIPT}
{$IFDEF FHIR_TRANSPORT}
  else if element.localName = 'Transport' Then
    result := ParseTransport(element, path+'/Transport')
{$ENDIF FHIR_TRANSPORT}
{$IFDEF FHIR_VALUESET}
  else if element.localName = 'ValueSet' Then
    result := ParseValueSet(element, path+'/ValueSet')
{$ENDIF FHIR_VALUESET}
{$IFDEF FHIR_VERIFICATIONRESULT}
  else if element.localName = 'VerificationResult' Then
    result := ParseVerificationResult(element, path+'/VerificationResult')
{$ENDIF FHIR_VERIFICATIONRESULT}
{$IFDEF FHIR_VISIONPRESCRIPTION}
  else if element.localName = 'VisionPrescription' Then
    result := ParseVisionPrescription(element, path+'/VisionPrescription')
{$ENDIF FHIR_VISIONPRESCRIPTION}

  else
    raise EXmlException.Create('Error: the element '+element.localName+' is not recognised as a valid resource name');
end;

procedure TFHIRXmlComposer.ComposeResource(xml : TXmlBuilder; resource: TFhirResource);
begin
  if (resource = nil) Then
    Raise EXmlException.Create('error - resource is nil');
  Case resource.ResourceType of
{$IFDEF FHIR_ACCOUNT}
    frtAccount: ComposeAccount(xml, 'Account', TFhirAccount(resource));
{$ENDIF FHIR_ACCOUNT}
{$IFDEF FHIR_ACTIVITYDEFINITION}
    frtActivityDefinition: ComposeActivityDefinition(xml, 'ActivityDefinition', TFhirActivityDefinition(resource));
{$ENDIF FHIR_ACTIVITYDEFINITION}
{$IFDEF FHIR_ACTORDEFINITION}
    frtActorDefinition: ComposeActorDefinition(xml, 'ActorDefinition', TFhirActorDefinition(resource));
{$ENDIF FHIR_ACTORDEFINITION}
{$IFDEF FHIR_ADMINISTRABLEPRODUCTDEFINITION}
    frtAdministrableProductDefinition: ComposeAdministrableProductDefinition(xml, 'AdministrableProductDefinition', TFhirAdministrableProductDefinition(resource));
{$ENDIF FHIR_ADMINISTRABLEPRODUCTDEFINITION}
{$IFDEF FHIR_ADVERSEEVENT}
    frtAdverseEvent: ComposeAdverseEvent(xml, 'AdverseEvent', TFhirAdverseEvent(resource));
{$ENDIF FHIR_ADVERSEEVENT}
{$IFDEF FHIR_ALLERGYINTOLERANCE}
    frtAllergyIntolerance: ComposeAllergyIntolerance(xml, 'AllergyIntolerance', TFhirAllergyIntolerance(resource));
{$ENDIF FHIR_ALLERGYINTOLERANCE}
{$IFDEF FHIR_APPOINTMENT}
    frtAppointment: ComposeAppointment(xml, 'Appointment', TFhirAppointment(resource));
{$ENDIF FHIR_APPOINTMENT}
{$IFDEF FHIR_APPOINTMENTRESPONSE}
    frtAppointmentResponse: ComposeAppointmentResponse(xml, 'AppointmentResponse', TFhirAppointmentResponse(resource));
{$ENDIF FHIR_APPOINTMENTRESPONSE}
{$IFDEF FHIR_ARTIFACTASSESSMENT}
    frtArtifactAssessment: ComposeArtifactAssessment(xml, 'ArtifactAssessment', TFhirArtifactAssessment(resource));
{$ENDIF FHIR_ARTIFACTASSESSMENT}
{$IFDEF FHIR_AUDITEVENT}
    frtAuditEvent: ComposeAuditEvent(xml, 'AuditEvent', TFhirAuditEvent(resource));
{$ENDIF FHIR_AUDITEVENT}
{$IFDEF FHIR_BASIC}
    frtBasic: ComposeBasic(xml, 'Basic', TFhirBasic(resource));
{$ENDIF FHIR_BASIC}
{$IFDEF FHIR_BINARY}
    frtBinary: ComposeBinary(xml, 'Binary', TFhirBinary(resource));
{$ENDIF FHIR_BINARY}
{$IFDEF FHIR_BIOLOGICALLYDERIVEDPRODUCT}
    frtBiologicallyDerivedProduct: ComposeBiologicallyDerivedProduct(xml, 'BiologicallyDerivedProduct', TFhirBiologicallyDerivedProduct(resource));
{$ENDIF FHIR_BIOLOGICALLYDERIVEDPRODUCT}
{$IFDEF FHIR_BODYSTRUCTURE}
    frtBodyStructure: ComposeBodyStructure(xml, 'BodyStructure', TFhirBodyStructure(resource));
{$ENDIF FHIR_BODYSTRUCTURE}
{$IFDEF FHIR_BUNDLE}
    frtBundle: ComposeBundle(xml, 'Bundle', TFhirBundle(resource));
{$ENDIF FHIR_BUNDLE}
{$IFDEF FHIR_CAPABILITYSTATEMENT}
    frtCapabilityStatement: ComposeCapabilityStatement(xml, 'CapabilityStatement', TFhirCapabilityStatement(resource));
{$ENDIF FHIR_CAPABILITYSTATEMENT}
{$IFDEF FHIR_CAREPLAN}
    frtCarePlan: ComposeCarePlan(xml, 'CarePlan', TFhirCarePlan(resource));
{$ENDIF FHIR_CAREPLAN}
{$IFDEF FHIR_CARETEAM}
    frtCareTeam: ComposeCareTeam(xml, 'CareTeam', TFhirCareTeam(resource));
{$ENDIF FHIR_CARETEAM}
{$IFDEF FHIR_CHARGEITEM}
    frtChargeItem: ComposeChargeItem(xml, 'ChargeItem', TFhirChargeItem(resource));
{$ENDIF FHIR_CHARGEITEM}
{$IFDEF FHIR_CHARGEITEMDEFINITION}
    frtChargeItemDefinition: ComposeChargeItemDefinition(xml, 'ChargeItemDefinition', TFhirChargeItemDefinition(resource));
{$ENDIF FHIR_CHARGEITEMDEFINITION}
{$IFDEF FHIR_CITATION}
    frtCitation: ComposeCitation(xml, 'Citation', TFhirCitation(resource));
{$ENDIF FHIR_CITATION}
{$IFDEF FHIR_CLAIM}
    frtClaim: ComposeClaim(xml, 'Claim', TFhirClaim(resource));
{$ENDIF FHIR_CLAIM}
{$IFDEF FHIR_CLAIMRESPONSE}
    frtClaimResponse: ComposeClaimResponse(xml, 'ClaimResponse', TFhirClaimResponse(resource));
{$ENDIF FHIR_CLAIMRESPONSE}
{$IFDEF FHIR_CLINICALIMPRESSION}
    frtClinicalImpression: ComposeClinicalImpression(xml, 'ClinicalImpression', TFhirClinicalImpression(resource));
{$ENDIF FHIR_CLINICALIMPRESSION}
{$IFDEF FHIR_CLINICALUSEDEFINITION}
    frtClinicalUseDefinition: ComposeClinicalUseDefinition(xml, 'ClinicalUseDefinition', TFhirClinicalUseDefinition(resource));
{$ENDIF FHIR_CLINICALUSEDEFINITION}
{$IFDEF FHIR_CODESYSTEM}
    frtCodeSystem: ComposeCodeSystem(xml, 'CodeSystem', TFhirCodeSystem(resource));
{$ENDIF FHIR_CODESYSTEM}
{$IFDEF FHIR_COMMUNICATION}
    frtCommunication: ComposeCommunication(xml, 'Communication', TFhirCommunication(resource));
{$ENDIF FHIR_COMMUNICATION}
{$IFDEF FHIR_COMMUNICATIONREQUEST}
    frtCommunicationRequest: ComposeCommunicationRequest(xml, 'CommunicationRequest', TFhirCommunicationRequest(resource));
{$ENDIF FHIR_COMMUNICATIONREQUEST}
{$IFDEF FHIR_COMPARTMENTDEFINITION}
    frtCompartmentDefinition: ComposeCompartmentDefinition(xml, 'CompartmentDefinition', TFhirCompartmentDefinition(resource));
{$ENDIF FHIR_COMPARTMENTDEFINITION}
{$IFDEF FHIR_COMPOSITION}
    frtComposition: ComposeComposition(xml, 'Composition', TFhirComposition(resource));
{$ENDIF FHIR_COMPOSITION}
{$IFDEF FHIR_CONCEPTMAP}
    frtConceptMap: ComposeConceptMap(xml, 'ConceptMap', TFhirConceptMap(resource));
{$ENDIF FHIR_CONCEPTMAP}
{$IFDEF FHIR_CONDITION}
    frtCondition: ComposeCondition(xml, 'Condition', TFhirCondition(resource));
{$ENDIF FHIR_CONDITION}
{$IFDEF FHIR_CONDITIONDEFINITION}
    frtConditionDefinition: ComposeConditionDefinition(xml, 'ConditionDefinition', TFhirConditionDefinition(resource));
{$ENDIF FHIR_CONDITIONDEFINITION}
{$IFDEF FHIR_CONSENT}
    frtConsent: ComposeConsent(xml, 'Consent', TFhirConsent(resource));
{$ENDIF FHIR_CONSENT}
{$IFDEF FHIR_CONTRACT}
    frtContract: ComposeContract(xml, 'Contract', TFhirContract(resource));
{$ENDIF FHIR_CONTRACT}
{$IFDEF FHIR_COVERAGE}
    frtCoverage: ComposeCoverage(xml, 'Coverage', TFhirCoverage(resource));
{$ENDIF FHIR_COVERAGE}
{$IFDEF FHIR_COVERAGEELIGIBILITYREQUEST}
    frtCoverageEligibilityRequest: ComposeCoverageEligibilityRequest(xml, 'CoverageEligibilityRequest', TFhirCoverageEligibilityRequest(resource));
{$ENDIF FHIR_COVERAGEELIGIBILITYREQUEST}
{$IFDEF FHIR_COVERAGEELIGIBILITYRESPONSE}
    frtCoverageEligibilityResponse: ComposeCoverageEligibilityResponse(xml, 'CoverageEligibilityResponse', TFhirCoverageEligibilityResponse(resource));
{$ENDIF FHIR_COVERAGEELIGIBILITYRESPONSE}
{$IFDEF FHIR_DETECTEDISSUE}
    frtDetectedIssue: ComposeDetectedIssue(xml, 'DetectedIssue', TFhirDetectedIssue(resource));
{$ENDIF FHIR_DETECTEDISSUE}
{$IFDEF FHIR_DEVICE}
    frtDevice: ComposeDevice(xml, 'Device', TFhirDevice(resource));
{$ENDIF FHIR_DEVICE}
{$IFDEF FHIR_DEVICEDEFINITION}
    frtDeviceDefinition: ComposeDeviceDefinition(xml, 'DeviceDefinition', TFhirDeviceDefinition(resource));
{$ENDIF FHIR_DEVICEDEFINITION}
{$IFDEF FHIR_DEVICEDISPENSE}
    frtDeviceDispense: ComposeDeviceDispense(xml, 'DeviceDispense', TFhirDeviceDispense(resource));
{$ENDIF FHIR_DEVICEDISPENSE}
{$IFDEF FHIR_DEVICEMETRIC}
    frtDeviceMetric: ComposeDeviceMetric(xml, 'DeviceMetric', TFhirDeviceMetric(resource));
{$ENDIF FHIR_DEVICEMETRIC}
{$IFDEF FHIR_DEVICEREQUEST}
    frtDeviceRequest: ComposeDeviceRequest(xml, 'DeviceRequest', TFhirDeviceRequest(resource));
{$ENDIF FHIR_DEVICEREQUEST}
{$IFDEF FHIR_DEVICEUSAGE}
    frtDeviceUsage: ComposeDeviceUsage(xml, 'DeviceUsage', TFhirDeviceUsage(resource));
{$ENDIF FHIR_DEVICEUSAGE}
{$IFDEF FHIR_DIAGNOSTICREPORT}
    frtDiagnosticReport: ComposeDiagnosticReport(xml, 'DiagnosticReport', TFhirDiagnosticReport(resource));
{$ENDIF FHIR_DIAGNOSTICREPORT}
{$IFDEF FHIR_DOCUMENTMANIFEST}
    frtDocumentManifest: ComposeDocumentManifest(xml, 'DocumentManifest', TFhirDocumentManifest(resource));
{$ENDIF FHIR_DOCUMENTMANIFEST}
{$IFDEF FHIR_DOCUMENTREFERENCE}
    frtDocumentReference: ComposeDocumentReference(xml, 'DocumentReference', TFhirDocumentReference(resource));
{$ENDIF FHIR_DOCUMENTREFERENCE}
{$IFDEF FHIR_ENCOUNTER}
    frtEncounter: ComposeEncounter(xml, 'Encounter', TFhirEncounter(resource));
{$ENDIF FHIR_ENCOUNTER}
{$IFDEF FHIR_ENDPOINT}
    frtEndpoint: ComposeEndpoint(xml, 'Endpoint', TFhirEndpoint(resource));
{$ENDIF FHIR_ENDPOINT}
{$IFDEF FHIR_ENROLLMENTREQUEST}
    frtEnrollmentRequest: ComposeEnrollmentRequest(xml, 'EnrollmentRequest', TFhirEnrollmentRequest(resource));
{$ENDIF FHIR_ENROLLMENTREQUEST}
{$IFDEF FHIR_ENROLLMENTRESPONSE}
    frtEnrollmentResponse: ComposeEnrollmentResponse(xml, 'EnrollmentResponse', TFhirEnrollmentResponse(resource));
{$ENDIF FHIR_ENROLLMENTRESPONSE}
{$IFDEF FHIR_EPISODEOFCARE}
    frtEpisodeOfCare: ComposeEpisodeOfCare(xml, 'EpisodeOfCare', TFhirEpisodeOfCare(resource));
{$ENDIF FHIR_EPISODEOFCARE}
{$IFDEF FHIR_EVENTDEFINITION}
    frtEventDefinition: ComposeEventDefinition(xml, 'EventDefinition', TFhirEventDefinition(resource));
{$ENDIF FHIR_EVENTDEFINITION}
{$IFDEF FHIR_EVIDENCE}
    frtEvidence: ComposeEvidence(xml, 'Evidence', TFhirEvidence(resource));
{$ENDIF FHIR_EVIDENCE}
{$IFDEF FHIR_EVIDENCEREPORT}
    frtEvidenceReport: ComposeEvidenceReport(xml, 'EvidenceReport', TFhirEvidenceReport(resource));
{$ENDIF FHIR_EVIDENCEREPORT}
{$IFDEF FHIR_EVIDENCEVARIABLE}
    frtEvidenceVariable: ComposeEvidenceVariable(xml, 'EvidenceVariable', TFhirEvidenceVariable(resource));
{$ENDIF FHIR_EVIDENCEVARIABLE}
{$IFDEF FHIR_EXAMPLESCENARIO}
    frtExampleScenario: ComposeExampleScenario(xml, 'ExampleScenario', TFhirExampleScenario(resource));
{$ENDIF FHIR_EXAMPLESCENARIO}
{$IFDEF FHIR_EXPLANATIONOFBENEFIT}
    frtExplanationOfBenefit: ComposeExplanationOfBenefit(xml, 'ExplanationOfBenefit', TFhirExplanationOfBenefit(resource));
{$ENDIF FHIR_EXPLANATIONOFBENEFIT}
{$IFDEF FHIR_FAMILYMEMBERHISTORY}
    frtFamilyMemberHistory: ComposeFamilyMemberHistory(xml, 'FamilyMemberHistory', TFhirFamilyMemberHistory(resource));
{$ENDIF FHIR_FAMILYMEMBERHISTORY}
{$IFDEF FHIR_FLAG}
    frtFlag: ComposeFlag(xml, 'Flag', TFhirFlag(resource));
{$ENDIF FHIR_FLAG}
{$IFDEF FHIR_FORMULARYITEM}
    frtFormularyItem: ComposeFormularyItem(xml, 'FormularyItem', TFhirFormularyItem(resource));
{$ENDIF FHIR_FORMULARYITEM}
{$IFDEF FHIR_GENOMICSTUDY}
    frtGenomicStudy: ComposeGenomicStudy(xml, 'GenomicStudy', TFhirGenomicStudy(resource));
{$ENDIF FHIR_GENOMICSTUDY}
{$IFDEF FHIR_GOAL}
    frtGoal: ComposeGoal(xml, 'Goal', TFhirGoal(resource));
{$ENDIF FHIR_GOAL}
{$IFDEF FHIR_GRAPHDEFINITION}
    frtGraphDefinition: ComposeGraphDefinition(xml, 'GraphDefinition', TFhirGraphDefinition(resource));
{$ENDIF FHIR_GRAPHDEFINITION}
{$IFDEF FHIR_GROUP}
    frtGroup: ComposeGroup(xml, 'Group', TFhirGroup(resource));
{$ENDIF FHIR_GROUP}
{$IFDEF FHIR_GUIDANCERESPONSE}
    frtGuidanceResponse: ComposeGuidanceResponse(xml, 'GuidanceResponse', TFhirGuidanceResponse(resource));
{$ENDIF FHIR_GUIDANCERESPONSE}
{$IFDEF FHIR_HEALTHCARESERVICE}
    frtHealthcareService: ComposeHealthcareService(xml, 'HealthcareService', TFhirHealthcareService(resource));
{$ENDIF FHIR_HEALTHCARESERVICE}
{$IFDEF FHIR_IMAGINGSELECTION}
    frtImagingSelection: ComposeImagingSelection(xml, 'ImagingSelection', TFhirImagingSelection(resource));
{$ENDIF FHIR_IMAGINGSELECTION}
{$IFDEF FHIR_IMAGINGSTUDY}
    frtImagingStudy: ComposeImagingStudy(xml, 'ImagingStudy', TFhirImagingStudy(resource));
{$ENDIF FHIR_IMAGINGSTUDY}
{$IFDEF FHIR_IMMUNIZATION}
    frtImmunization: ComposeImmunization(xml, 'Immunization', TFhirImmunization(resource));
{$ENDIF FHIR_IMMUNIZATION}
{$IFDEF FHIR_IMMUNIZATIONEVALUATION}
    frtImmunizationEvaluation: ComposeImmunizationEvaluation(xml, 'ImmunizationEvaluation', TFhirImmunizationEvaluation(resource));
{$ENDIF FHIR_IMMUNIZATIONEVALUATION}
{$IFDEF FHIR_IMMUNIZATIONRECOMMENDATION}
    frtImmunizationRecommendation: ComposeImmunizationRecommendation(xml, 'ImmunizationRecommendation', TFhirImmunizationRecommendation(resource));
{$ENDIF FHIR_IMMUNIZATIONRECOMMENDATION}
{$IFDEF FHIR_IMPLEMENTATIONGUIDE}
    frtImplementationGuide: ComposeImplementationGuide(xml, 'ImplementationGuide', TFhirImplementationGuide(resource));
{$ENDIF FHIR_IMPLEMENTATIONGUIDE}
{$IFDEF FHIR_INGREDIENT}
    frtIngredient: ComposeIngredient(xml, 'Ingredient', TFhirIngredient(resource));
{$ENDIF FHIR_INGREDIENT}
{$IFDEF FHIR_INSURANCEPLAN}
    frtInsurancePlan: ComposeInsurancePlan(xml, 'InsurancePlan', TFhirInsurancePlan(resource));
{$ENDIF FHIR_INSURANCEPLAN}
{$IFDEF FHIR_INVENTORYREPORT}
    frtInventoryReport: ComposeInventoryReport(xml, 'InventoryReport', TFhirInventoryReport(resource));
{$ENDIF FHIR_INVENTORYREPORT}
{$IFDEF FHIR_INVOICE}
    frtInvoice: ComposeInvoice(xml, 'Invoice', TFhirInvoice(resource));
{$ENDIF FHIR_INVOICE}
{$IFDEF FHIR_LIBRARY}
    frtLibrary: ComposeLibrary(xml, 'Library', TFhirLibrary(resource));
{$ENDIF FHIR_LIBRARY}
{$IFDEF FHIR_LINKAGE}
    frtLinkage: ComposeLinkage(xml, 'Linkage', TFhirLinkage(resource));
{$ENDIF FHIR_LINKAGE}
{$IFDEF FHIR_LIST}
    frtList: ComposeList(xml, 'List', TFhirList(resource));
{$ENDIF FHIR_LIST}
{$IFDEF FHIR_LOCATION}
    frtLocation: ComposeLocation(xml, 'Location', TFhirLocation(resource));
{$ENDIF FHIR_LOCATION}
{$IFDEF FHIR_MANUFACTUREDITEMDEFINITION}
    frtManufacturedItemDefinition: ComposeManufacturedItemDefinition(xml, 'ManufacturedItemDefinition', TFhirManufacturedItemDefinition(resource));
{$ENDIF FHIR_MANUFACTUREDITEMDEFINITION}
{$IFDEF FHIR_MEASURE}
    frtMeasure: ComposeMeasure(xml, 'Measure', TFhirMeasure(resource));
{$ENDIF FHIR_MEASURE}
{$IFDEF FHIR_MEASUREREPORT}
    frtMeasureReport: ComposeMeasureReport(xml, 'MeasureReport', TFhirMeasureReport(resource));
{$ENDIF FHIR_MEASUREREPORT}
{$IFDEF FHIR_MEDICATION}
    frtMedication: ComposeMedication(xml, 'Medication', TFhirMedication(resource));
{$ENDIF FHIR_MEDICATION}
{$IFDEF FHIR_MEDICATIONADMINISTRATION}
    frtMedicationAdministration: ComposeMedicationAdministration(xml, 'MedicationAdministration', TFhirMedicationAdministration(resource));
{$ENDIF FHIR_MEDICATIONADMINISTRATION}
{$IFDEF FHIR_MEDICATIONDISPENSE}
    frtMedicationDispense: ComposeMedicationDispense(xml, 'MedicationDispense', TFhirMedicationDispense(resource));
{$ENDIF FHIR_MEDICATIONDISPENSE}
{$IFDEF FHIR_MEDICATIONKNOWLEDGE}
    frtMedicationKnowledge: ComposeMedicationKnowledge(xml, 'MedicationKnowledge', TFhirMedicationKnowledge(resource));
{$ENDIF FHIR_MEDICATIONKNOWLEDGE}
{$IFDEF FHIR_MEDICATIONREQUEST}
    frtMedicationRequest: ComposeMedicationRequest(xml, 'MedicationRequest', TFhirMedicationRequest(resource));
{$ENDIF FHIR_MEDICATIONREQUEST}
{$IFDEF FHIR_MEDICATIONUSAGE}
    frtMedicationUsage: ComposeMedicationUsage(xml, 'MedicationUsage', TFhirMedicationUsage(resource));
{$ENDIF FHIR_MEDICATIONUSAGE}
{$IFDEF FHIR_MEDICINALPRODUCTDEFINITION}
    frtMedicinalProductDefinition: ComposeMedicinalProductDefinition(xml, 'MedicinalProductDefinition', TFhirMedicinalProductDefinition(resource));
{$ENDIF FHIR_MEDICINALPRODUCTDEFINITION}
{$IFDEF FHIR_MESSAGEDEFINITION}
    frtMessageDefinition: ComposeMessageDefinition(xml, 'MessageDefinition', TFhirMessageDefinition(resource));
{$ENDIF FHIR_MESSAGEDEFINITION}
{$IFDEF FHIR_MESSAGEHEADER}
    frtMessageHeader: ComposeMessageHeader(xml, 'MessageHeader', TFhirMessageHeader(resource));
{$ENDIF FHIR_MESSAGEHEADER}
{$IFDEF FHIR_MOLECULARSEQUENCE}
    frtMolecularSequence: ComposeMolecularSequence(xml, 'MolecularSequence', TFhirMolecularSequence(resource));
{$ENDIF FHIR_MOLECULARSEQUENCE}
{$IFDEF FHIR_NAMINGSYSTEM}
    frtNamingSystem: ComposeNamingSystem(xml, 'NamingSystem', TFhirNamingSystem(resource));
{$ENDIF FHIR_NAMINGSYSTEM}
{$IFDEF FHIR_NUTRITIONINTAKE}
    frtNutritionIntake: ComposeNutritionIntake(xml, 'NutritionIntake', TFhirNutritionIntake(resource));
{$ENDIF FHIR_NUTRITIONINTAKE}
{$IFDEF FHIR_NUTRITIONORDER}
    frtNutritionOrder: ComposeNutritionOrder(xml, 'NutritionOrder', TFhirNutritionOrder(resource));
{$ENDIF FHIR_NUTRITIONORDER}
{$IFDEF FHIR_NUTRITIONPRODUCT}
    frtNutritionProduct: ComposeNutritionProduct(xml, 'NutritionProduct', TFhirNutritionProduct(resource));
{$ENDIF FHIR_NUTRITIONPRODUCT}
{$IFDEF FHIR_OBSERVATION}
    frtObservation: ComposeObservation(xml, 'Observation', TFhirObservation(resource));
{$ENDIF FHIR_OBSERVATION}
{$IFDEF FHIR_OBSERVATIONDEFINITION}
    frtObservationDefinition: ComposeObservationDefinition(xml, 'ObservationDefinition', TFhirObservationDefinition(resource));
{$ENDIF FHIR_OBSERVATIONDEFINITION}
{$IFDEF FHIR_OPERATIONDEFINITION}
    frtOperationDefinition: ComposeOperationDefinition(xml, 'OperationDefinition', TFhirOperationDefinition(resource));
{$ENDIF FHIR_OPERATIONDEFINITION}
{$IFDEF FHIR_OPERATIONOUTCOME}
    frtOperationOutcome: ComposeOperationOutcome(xml, 'OperationOutcome', TFhirOperationOutcome(resource));
{$ENDIF FHIR_OPERATIONOUTCOME}
{$IFDEF FHIR_ORGANIZATION}
    frtOrganization: ComposeOrganization(xml, 'Organization', TFhirOrganization(resource));
{$ENDIF FHIR_ORGANIZATION}
{$IFDEF FHIR_ORGANIZATIONAFFILIATION}
    frtOrganizationAffiliation: ComposeOrganizationAffiliation(xml, 'OrganizationAffiliation', TFhirOrganizationAffiliation(resource));
{$ENDIF FHIR_ORGANIZATIONAFFILIATION}
{$IFDEF FHIR_PACKAGEDPRODUCTDEFINITION}
    frtPackagedProductDefinition: ComposePackagedProductDefinition(xml, 'PackagedProductDefinition', TFhirPackagedProductDefinition(resource));
{$ENDIF FHIR_PACKAGEDPRODUCTDEFINITION}
{$IFDEF FHIR_PARAMETERS}
    frtParameters: ComposeParameters(xml, 'Parameters', TFhirParameters(resource));
{$ENDIF FHIR_PARAMETERS}
{$IFDEF FHIR_PATIENT}
    frtPatient: ComposePatient(xml, 'Patient', TFhirPatient(resource));
{$ENDIF FHIR_PATIENT}
{$IFDEF FHIR_PAYMENTNOTICE}
    frtPaymentNotice: ComposePaymentNotice(xml, 'PaymentNotice', TFhirPaymentNotice(resource));
{$ENDIF FHIR_PAYMENTNOTICE}
{$IFDEF FHIR_PAYMENTRECONCILIATION}
    frtPaymentReconciliation: ComposePaymentReconciliation(xml, 'PaymentReconciliation', TFhirPaymentReconciliation(resource));
{$ENDIF FHIR_PAYMENTRECONCILIATION}
{$IFDEF FHIR_PERMISSION}
    frtPermission: ComposePermission(xml, 'Permission', TFhirPermission(resource));
{$ENDIF FHIR_PERMISSION}
{$IFDEF FHIR_PERSON}
    frtPerson: ComposePerson(xml, 'Person', TFhirPerson(resource));
{$ENDIF FHIR_PERSON}
{$IFDEF FHIR_PLANDEFINITION}
    frtPlanDefinition: ComposePlanDefinition(xml, 'PlanDefinition', TFhirPlanDefinition(resource));
{$ENDIF FHIR_PLANDEFINITION}
{$IFDEF FHIR_PRACTITIONER}
    frtPractitioner: ComposePractitioner(xml, 'Practitioner', TFhirPractitioner(resource));
{$ENDIF FHIR_PRACTITIONER}
{$IFDEF FHIR_PRACTITIONERROLE}
    frtPractitionerRole: ComposePractitionerRole(xml, 'PractitionerRole', TFhirPractitionerRole(resource));
{$ENDIF FHIR_PRACTITIONERROLE}
{$IFDEF FHIR_PROCEDURE}
    frtProcedure: ComposeProcedure(xml, 'Procedure', TFhirProcedure(resource));
{$ENDIF FHIR_PROCEDURE}
{$IFDEF FHIR_PROVENANCE}
    frtProvenance: ComposeProvenance(xml, 'Provenance', TFhirProvenance(resource));
{$ENDIF FHIR_PROVENANCE}
{$IFDEF FHIR_QUESTIONNAIRE}
    frtQuestionnaire: ComposeQuestionnaire(xml, 'Questionnaire', TFhirQuestionnaire(resource));
{$ENDIF FHIR_QUESTIONNAIRE}
{$IFDEF FHIR_QUESTIONNAIRERESPONSE}
    frtQuestionnaireResponse: ComposeQuestionnaireResponse(xml, 'QuestionnaireResponse', TFhirQuestionnaireResponse(resource));
{$ENDIF FHIR_QUESTIONNAIRERESPONSE}
{$IFDEF FHIR_REGULATEDAUTHORIZATION}
    frtRegulatedAuthorization: ComposeRegulatedAuthorization(xml, 'RegulatedAuthorization', TFhirRegulatedAuthorization(resource));
{$ENDIF FHIR_REGULATEDAUTHORIZATION}
{$IFDEF FHIR_RELATEDPERSON}
    frtRelatedPerson: ComposeRelatedPerson(xml, 'RelatedPerson', TFhirRelatedPerson(resource));
{$ENDIF FHIR_RELATEDPERSON}
{$IFDEF FHIR_REQUESTGROUP}
    frtRequestGroup: ComposeRequestGroup(xml, 'RequestGroup', TFhirRequestGroup(resource));
{$ENDIF FHIR_REQUESTGROUP}
{$IFDEF FHIR_REQUESTORCHESTRATION}
    frtRequestOrchestration: ComposeRequestOrchestration(xml, 'RequestOrchestration', TFhirRequestOrchestration(resource));
{$ENDIF FHIR_REQUESTORCHESTRATION}
{$IFDEF FHIR_REQUIREMENTS}
    frtRequirements: ComposeRequirements(xml, 'Requirements', TFhirRequirements(resource));
{$ENDIF FHIR_REQUIREMENTS}
{$IFDEF FHIR_RESEARCHSTUDY}
    frtResearchStudy: ComposeResearchStudy(xml, 'ResearchStudy', TFhirResearchStudy(resource));
{$ENDIF FHIR_RESEARCHSTUDY}
{$IFDEF FHIR_RESEARCHSUBJECT}
    frtResearchSubject: ComposeResearchSubject(xml, 'ResearchSubject', TFhirResearchSubject(resource));
{$ENDIF FHIR_RESEARCHSUBJECT}
{$IFDEF FHIR_RISKASSESSMENT}
    frtRiskAssessment: ComposeRiskAssessment(xml, 'RiskAssessment', TFhirRiskAssessment(resource));
{$ENDIF FHIR_RISKASSESSMENT}
{$IFDEF FHIR_SCHEDULE}
    frtSchedule: ComposeSchedule(xml, 'Schedule', TFhirSchedule(resource));
{$ENDIF FHIR_SCHEDULE}
{$IFDEF FHIR_SEARCHPARAMETER}
    frtSearchParameter: ComposeSearchParameter(xml, 'SearchParameter', TFhirSearchParameter(resource));
{$ENDIF FHIR_SEARCHPARAMETER}
{$IFDEF FHIR_SERVICEREQUEST}
    frtServiceRequest: ComposeServiceRequest(xml, 'ServiceRequest', TFhirServiceRequest(resource));
{$ENDIF FHIR_SERVICEREQUEST}
{$IFDEF FHIR_SLOT}
    frtSlot: ComposeSlot(xml, 'Slot', TFhirSlot(resource));
{$ENDIF FHIR_SLOT}
{$IFDEF FHIR_SPECIMEN}
    frtSpecimen: ComposeSpecimen(xml, 'Specimen', TFhirSpecimen(resource));
{$ENDIF FHIR_SPECIMEN}
{$IFDEF FHIR_SPECIMENDEFINITION}
    frtSpecimenDefinition: ComposeSpecimenDefinition(xml, 'SpecimenDefinition', TFhirSpecimenDefinition(resource));
{$ENDIF FHIR_SPECIMENDEFINITION}
{$IFDEF FHIR_STRUCTUREDEFINITION}
    frtStructureDefinition: ComposeStructureDefinition(xml, 'StructureDefinition', TFhirStructureDefinition(resource));
{$ENDIF FHIR_STRUCTUREDEFINITION}
{$IFDEF FHIR_STRUCTUREMAP}
    frtStructureMap: ComposeStructureMap(xml, 'StructureMap', TFhirStructureMap(resource));
{$ENDIF FHIR_STRUCTUREMAP}
{$IFDEF FHIR_SUBSCRIPTION}
    frtSubscription: ComposeSubscription(xml, 'Subscription', TFhirSubscription(resource));
{$ENDIF FHIR_SUBSCRIPTION}
{$IFDEF FHIR_SUBSCRIPTIONSTATUS}
    frtSubscriptionStatus: ComposeSubscriptionStatus(xml, 'SubscriptionStatus', TFhirSubscriptionStatus(resource));
{$ENDIF FHIR_SUBSCRIPTIONSTATUS}
{$IFDEF FHIR_SUBSCRIPTIONTOPIC}
    frtSubscriptionTopic: ComposeSubscriptionTopic(xml, 'SubscriptionTopic', TFhirSubscriptionTopic(resource));
{$ENDIF FHIR_SUBSCRIPTIONTOPIC}
{$IFDEF FHIR_SUBSTANCE}
    frtSubstance: ComposeSubstance(xml, 'Substance', TFhirSubstance(resource));
{$ENDIF FHIR_SUBSTANCE}
{$IFDEF FHIR_SUBSTANCEDEFINITION}
    frtSubstanceDefinition: ComposeSubstanceDefinition(xml, 'SubstanceDefinition', TFhirSubstanceDefinition(resource));
{$ENDIF FHIR_SUBSTANCEDEFINITION}
{$IFDEF FHIR_SUBSTANCENUCLEICACID}
    frtSubstanceNucleicAcid: ComposeSubstanceNucleicAcid(xml, 'SubstanceNucleicAcid', TFhirSubstanceNucleicAcid(resource));
{$ENDIF FHIR_SUBSTANCENUCLEICACID}
{$IFDEF FHIR_SUBSTANCEPOLYMER}
    frtSubstancePolymer: ComposeSubstancePolymer(xml, 'SubstancePolymer', TFhirSubstancePolymer(resource));
{$ENDIF FHIR_SUBSTANCEPOLYMER}
{$IFDEF FHIR_SUBSTANCEPROTEIN}
    frtSubstanceProtein: ComposeSubstanceProtein(xml, 'SubstanceProtein', TFhirSubstanceProtein(resource));
{$ENDIF FHIR_SUBSTANCEPROTEIN}
{$IFDEF FHIR_SUBSTANCEREFERENCEINFORMATION}
    frtSubstanceReferenceInformation: ComposeSubstanceReferenceInformation(xml, 'SubstanceReferenceInformation', TFhirSubstanceReferenceInformation(resource));
{$ENDIF FHIR_SUBSTANCEREFERENCEINFORMATION}
{$IFDEF FHIR_SUBSTANCESOURCEMATERIAL}
    frtSubstanceSourceMaterial: ComposeSubstanceSourceMaterial(xml, 'SubstanceSourceMaterial', TFhirSubstanceSourceMaterial(resource));
{$ENDIF FHIR_SUBSTANCESOURCEMATERIAL}
{$IFDEF FHIR_SUPPLYDELIVERY}
    frtSupplyDelivery: ComposeSupplyDelivery(xml, 'SupplyDelivery', TFhirSupplyDelivery(resource));
{$ENDIF FHIR_SUPPLYDELIVERY}
{$IFDEF FHIR_SUPPLYREQUEST}
    frtSupplyRequest: ComposeSupplyRequest(xml, 'SupplyRequest', TFhirSupplyRequest(resource));
{$ENDIF FHIR_SUPPLYREQUEST}
{$IFDEF FHIR_TASK}
    frtTask: ComposeTask(xml, 'Task', TFhirTask(resource));
{$ENDIF FHIR_TASK}
{$IFDEF FHIR_TERMINOLOGYCAPABILITIES}
    frtTerminologyCapabilities: ComposeTerminologyCapabilities(xml, 'TerminologyCapabilities', TFhirTerminologyCapabilities(resource));
{$ENDIF FHIR_TERMINOLOGYCAPABILITIES}
{$IFDEF FHIR_TESTREPORT}
    frtTestReport: ComposeTestReport(xml, 'TestReport', TFhirTestReport(resource));
{$ENDIF FHIR_TESTREPORT}
{$IFDEF FHIR_TESTSCRIPT}
    frtTestScript: ComposeTestScript(xml, 'TestScript', TFhirTestScript(resource));
{$ENDIF FHIR_TESTSCRIPT}
{$IFDEF FHIR_TRANSPORT}
    frtTransport: ComposeTransport(xml, 'Transport', TFhirTransport(resource));
{$ENDIF FHIR_TRANSPORT}
{$IFDEF FHIR_VALUESET}
    frtValueSet: ComposeValueSet(xml, 'ValueSet', TFhirValueSet(resource));
{$ENDIF FHIR_VALUESET}
{$IFDEF FHIR_VERIFICATIONRESULT}
    frtVerificationResult: ComposeVerificationResult(xml, 'VerificationResult', TFhirVerificationResult(resource));
{$ENDIF FHIR_VERIFICATIONRESULT}
{$IFDEF FHIR_VISIONPRESCRIPTION}
    frtVisionPrescription: ComposeVisionPrescription(xml, 'VisionPrescription', TFhirVisionPrescription(resource));
{$ENDIF FHIR_VISIONPRESCRIPTION}

  else
    raise EXmlException.Create('Internal error: the resource type '+CODES_TFhirResourceType[resource.ResourceType]+' is not a valid resource type');
  end;
end;

function TFHIRXmlParser.ParseFragment(element : TMXmlElement) : TFHIRObject;
begin
  if (element = nil) Then
    Raise EXmlException.Create('error - element is nil')
  else if SameText(element.Name, 'Address') then
    result := parseAddress(element, element.Name)
  else if SameText(element.Name, 'Annotation') then
    result := parseAnnotation(element, element.Name)
  else if SameText(element.Name, 'Attachment') then
    result := parseAttachment(element, element.Name)
  else if SameText(element.Name, 'Availability') then
    result := parseAvailability(element, element.Name)
  else if SameText(element.Name, 'CodeableConcept') then
    result := parseCodeableConcept(element, element.Name)
  else if SameText(element.Name, 'CodeableReference') then
    result := parseCodeableReference(element, element.Name)
  else if SameText(element.Name, 'Coding') then
    result := parseCoding(element, element.Name)
  else if SameText(element.Name, 'ContactDetail') then
    result := parseContactDetail(element, element.Name)
  else if SameText(element.Name, 'ContactPoint') then
    result := parseContactPoint(element, element.Name)
  else if SameText(element.Name, 'Contributor') then
    result := parseContributor(element, element.Name)
  else if SameText(element.Name, 'DataRequirement') then
    result := parseDataRequirement(element, element.Name)
  else if SameText(element.Name, 'Expression') then
    result := parseExpression(element, element.Name)
  else if SameText(element.Name, 'ExtendedContactDetail') then
    result := parseExtendedContactDetail(element, element.Name)
  else if SameText(element.Name, 'Extension') then
    result := parseExtension(element, element.Name)
  else if SameText(element.Name, 'HumanName') then
    result := parseHumanName(element, element.Name)
  else if SameText(element.Name, 'Identifier') then
    result := parseIdentifier(element, element.Name)
  else if SameText(element.Name, 'Meta') then
    result := parseMeta(element, element.Name)
  else if SameText(element.Name, 'MonetaryComponent') then
    result := parseMonetaryComponent(element, element.Name)
  else if SameText(element.Name, 'Money') then
    result := parseMoney(element, element.Name)
  else if SameText(element.Name, 'Narrative') then
    result := parseNarrative(element, element.Name)
  else if SameText(element.Name, 'ParameterDefinition') then
    result := parseParameterDefinition(element, element.Name)
  else if SameText(element.Name, 'Period') then
    result := parsePeriod(element, element.Name)
  else if SameText(element.Name, 'Quantity') then
    result := parseQuantity(element, element.Name)
  else if SameText(element.Name, 'Range') then
    result := parseRange(element, element.Name)
  else if SameText(element.Name, 'Ratio') then
    result := parseRatio(element, element.Name)
  else if SameText(element.Name, 'RatioRange') then
    result := parseRatioRange(element, element.Name)
  else if SameText(element.Name, 'Reference') then
    result := parseReference(element, element.Name)
  else if SameText(element.Name, 'RelatedArtifact') then
    result := parseRelatedArtifact(element, element.Name)
  else if SameText(element.Name, 'SampledData') then
    result := parseSampledData(element, element.Name)
  else if SameText(element.Name, 'Signature') then
    result := parseSignature(element, element.Name)
  else if SameText(element.Name, 'TriggerDefinition') then
    result := parseTriggerDefinition(element, element.Name)
  else if SameText(element.Name, 'UsageContext') then
    result := parseUsageContext(element, element.Name)
  else if SameText(element.Name, 'VirtualServiceDetail') then
    result := parseVirtualServiceDetail(element, element.Name)
  else if SameText(element.Name, 'Age') then
    result := parseAge(element, element.Name)
  else if SameText(element.Name, 'Count') then
    result := parseCount(element, element.Name)
  else if SameText(element.Name, 'Distance') then
    result := parseDistance(element, element.Name)
  else if SameText(element.Name, 'Dosage') then
    result := parseDosage(element, element.Name)
  else if SameText(element.Name, 'Duration') then
    result := parseDuration(element, element.Name)
  else if SameText(element.Name, 'ElementDefinition') then
    result := parseElementDefinition(element, element.Name)
  else if SameText(element.Name, 'MarketingStatus') then
    result := parseMarketingStatus(element, element.Name)
  else if SameText(element.Name, 'Population') then
    result := parsePopulation(element, element.Name)
  else if SameText(element.Name, 'ProductShelfLife') then
    result := parseProductShelfLife(element, element.Name)
  else if SameText(element.Name, 'Timing') then
    result := parseTiming(element, element.Name)
{$IFDEF FHIR_ACCOUNT}
  else if SameText(element.Name, 'Account') then
    result := parseAccount(element, element.Name)
{$ENDIF FHIR_ACCOUNT}
{$IFDEF FHIR_ACTIVITYDEFINITION}
  else if SameText(element.Name, 'ActivityDefinition') then
    result := parseActivityDefinition(element, element.Name)
{$ENDIF FHIR_ACTIVITYDEFINITION}
{$IFDEF FHIR_ACTORDEFINITION}
  else if SameText(element.Name, 'ActorDefinition') then
    result := parseActorDefinition(element, element.Name)
{$ENDIF FHIR_ACTORDEFINITION}
{$IFDEF FHIR_ADMINISTRABLEPRODUCTDEFINITION}
  else if SameText(element.Name, 'AdministrableProductDefinition') then
    result := parseAdministrableProductDefinition(element, element.Name)
{$ENDIF FHIR_ADMINISTRABLEPRODUCTDEFINITION}
{$IFDEF FHIR_ADVERSEEVENT}
  else if SameText(element.Name, 'AdverseEvent') then
    result := parseAdverseEvent(element, element.Name)
{$ENDIF FHIR_ADVERSEEVENT}
{$IFDEF FHIR_ALLERGYINTOLERANCE}
  else if SameText(element.Name, 'AllergyIntolerance') then
    result := parseAllergyIntolerance(element, element.Name)
{$ENDIF FHIR_ALLERGYINTOLERANCE}
{$IFDEF FHIR_APPOINTMENT}
  else if SameText(element.Name, 'Appointment') then
    result := parseAppointment(element, element.Name)
{$ENDIF FHIR_APPOINTMENT}
{$IFDEF FHIR_APPOINTMENTRESPONSE}
  else if SameText(element.Name, 'AppointmentResponse') then
    result := parseAppointmentResponse(element, element.Name)
{$ENDIF FHIR_APPOINTMENTRESPONSE}
{$IFDEF FHIR_ARTIFACTASSESSMENT}
  else if SameText(element.Name, 'ArtifactAssessment') then
    result := parseArtifactAssessment(element, element.Name)
{$ENDIF FHIR_ARTIFACTASSESSMENT}
{$IFDEF FHIR_AUDITEVENT}
  else if SameText(element.Name, 'AuditEvent') then
    result := parseAuditEvent(element, element.Name)
{$ENDIF FHIR_AUDITEVENT}
{$IFDEF FHIR_BASIC}
  else if SameText(element.Name, 'Basic') then
    result := parseBasic(element, element.Name)
{$ENDIF FHIR_BASIC}
{$IFDEF FHIR_BINARY}
  else if SameText(element.Name, 'Binary') then
    result := parseBinary(element, element.Name)
{$ENDIF FHIR_BINARY}
{$IFDEF FHIR_BIOLOGICALLYDERIVEDPRODUCT}
  else if SameText(element.Name, 'BiologicallyDerivedProduct') then
    result := parseBiologicallyDerivedProduct(element, element.Name)
{$ENDIF FHIR_BIOLOGICALLYDERIVEDPRODUCT}
{$IFDEF FHIR_BODYSTRUCTURE}
  else if SameText(element.Name, 'BodyStructure') then
    result := parseBodyStructure(element, element.Name)
{$ENDIF FHIR_BODYSTRUCTURE}
{$IFDEF FHIR_BUNDLE}
  else if SameText(element.Name, 'Bundle') then
    result := parseBundle(element, element.Name)
{$ENDIF FHIR_BUNDLE}
{$IFDEF FHIR_CAPABILITYSTATEMENT}
  else if SameText(element.Name, 'CapabilityStatement') then
    result := parseCapabilityStatement(element, element.Name)
{$ENDIF FHIR_CAPABILITYSTATEMENT}
{$IFDEF FHIR_CAREPLAN}
  else if SameText(element.Name, 'CarePlan') then
    result := parseCarePlan(element, element.Name)
{$ENDIF FHIR_CAREPLAN}
{$IFDEF FHIR_CARETEAM}
  else if SameText(element.Name, 'CareTeam') then
    result := parseCareTeam(element, element.Name)
{$ENDIF FHIR_CARETEAM}
{$IFDEF FHIR_CHARGEITEM}
  else if SameText(element.Name, 'ChargeItem') then
    result := parseChargeItem(element, element.Name)
{$ENDIF FHIR_CHARGEITEM}
{$IFDEF FHIR_CHARGEITEMDEFINITION}
  else if SameText(element.Name, 'ChargeItemDefinition') then
    result := parseChargeItemDefinition(element, element.Name)
{$ENDIF FHIR_CHARGEITEMDEFINITION}
{$IFDEF FHIR_CITATION}
  else if SameText(element.Name, 'Citation') then
    result := parseCitation(element, element.Name)
{$ENDIF FHIR_CITATION}
{$IFDEF FHIR_CLAIM}
  else if SameText(element.Name, 'Claim') then
    result := parseClaim(element, element.Name)
{$ENDIF FHIR_CLAIM}
{$IFDEF FHIR_CLAIMRESPONSE}
  else if SameText(element.Name, 'ClaimResponse') then
    result := parseClaimResponse(element, element.Name)
{$ENDIF FHIR_CLAIMRESPONSE}
{$IFDEF FHIR_CLINICALIMPRESSION}
  else if SameText(element.Name, 'ClinicalImpression') then
    result := parseClinicalImpression(element, element.Name)
{$ENDIF FHIR_CLINICALIMPRESSION}
{$IFDEF FHIR_CLINICALUSEDEFINITION}
  else if SameText(element.Name, 'ClinicalUseDefinition') then
    result := parseClinicalUseDefinition(element, element.Name)
{$ENDIF FHIR_CLINICALUSEDEFINITION}
{$IFDEF FHIR_CODESYSTEM}
  else if SameText(element.Name, 'CodeSystem') then
    result := parseCodeSystem(element, element.Name)
{$ENDIF FHIR_CODESYSTEM}
{$IFDEF FHIR_COMMUNICATION}
  else if SameText(element.Name, 'Communication') then
    result := parseCommunication(element, element.Name)
{$ENDIF FHIR_COMMUNICATION}
{$IFDEF FHIR_COMMUNICATIONREQUEST}
  else if SameText(element.Name, 'CommunicationRequest') then
    result := parseCommunicationRequest(element, element.Name)
{$ENDIF FHIR_COMMUNICATIONREQUEST}
{$IFDEF FHIR_COMPARTMENTDEFINITION}
  else if SameText(element.Name, 'CompartmentDefinition') then
    result := parseCompartmentDefinition(element, element.Name)
{$ENDIF FHIR_COMPARTMENTDEFINITION}
{$IFDEF FHIR_COMPOSITION}
  else if SameText(element.Name, 'Composition') then
    result := parseComposition(element, element.Name)
{$ENDIF FHIR_COMPOSITION}
{$IFDEF FHIR_CONCEPTMAP}
  else if SameText(element.Name, 'ConceptMap') then
    result := parseConceptMap(element, element.Name)
{$ENDIF FHIR_CONCEPTMAP}
{$IFDEF FHIR_CONDITION}
  else if SameText(element.Name, 'Condition') then
    result := parseCondition(element, element.Name)
{$ENDIF FHIR_CONDITION}
{$IFDEF FHIR_CONDITIONDEFINITION}
  else if SameText(element.Name, 'ConditionDefinition') then
    result := parseConditionDefinition(element, element.Name)
{$ENDIF FHIR_CONDITIONDEFINITION}
{$IFDEF FHIR_CONSENT}
  else if SameText(element.Name, 'Consent') then
    result := parseConsent(element, element.Name)
{$ENDIF FHIR_CONSENT}
{$IFDEF FHIR_CONTRACT}
  else if SameText(element.Name, 'Contract') then
    result := parseContract(element, element.Name)
{$ENDIF FHIR_CONTRACT}
{$IFDEF FHIR_COVERAGE}
  else if SameText(element.Name, 'Coverage') then
    result := parseCoverage(element, element.Name)
{$ENDIF FHIR_COVERAGE}
{$IFDEF FHIR_COVERAGEELIGIBILITYREQUEST}
  else if SameText(element.Name, 'CoverageEligibilityRequest') then
    result := parseCoverageEligibilityRequest(element, element.Name)
{$ENDIF FHIR_COVERAGEELIGIBILITYREQUEST}
{$IFDEF FHIR_COVERAGEELIGIBILITYRESPONSE}
  else if SameText(element.Name, 'CoverageEligibilityResponse') then
    result := parseCoverageEligibilityResponse(element, element.Name)
{$ENDIF FHIR_COVERAGEELIGIBILITYRESPONSE}
{$IFDEF FHIR_DETECTEDISSUE}
  else if SameText(element.Name, 'DetectedIssue') then
    result := parseDetectedIssue(element, element.Name)
{$ENDIF FHIR_DETECTEDISSUE}
{$IFDEF FHIR_DEVICE}
  else if SameText(element.Name, 'Device') then
    result := parseDevice(element, element.Name)
{$ENDIF FHIR_DEVICE}
{$IFDEF FHIR_DEVICEDEFINITION}
  else if SameText(element.Name, 'DeviceDefinition') then
    result := parseDeviceDefinition(element, element.Name)
{$ENDIF FHIR_DEVICEDEFINITION}
{$IFDEF FHIR_DEVICEDISPENSE}
  else if SameText(element.Name, 'DeviceDispense') then
    result := parseDeviceDispense(element, element.Name)
{$ENDIF FHIR_DEVICEDISPENSE}
{$IFDEF FHIR_DEVICEMETRIC}
  else if SameText(element.Name, 'DeviceMetric') then
    result := parseDeviceMetric(element, element.Name)
{$ENDIF FHIR_DEVICEMETRIC}
{$IFDEF FHIR_DEVICEREQUEST}
  else if SameText(element.Name, 'DeviceRequest') then
    result := parseDeviceRequest(element, element.Name)
{$ENDIF FHIR_DEVICEREQUEST}
{$IFDEF FHIR_DEVICEUSAGE}
  else if SameText(element.Name, 'DeviceUsage') then
    result := parseDeviceUsage(element, element.Name)
{$ENDIF FHIR_DEVICEUSAGE}
{$IFDEF FHIR_DIAGNOSTICREPORT}
  else if SameText(element.Name, 'DiagnosticReport') then
    result := parseDiagnosticReport(element, element.Name)
{$ENDIF FHIR_DIAGNOSTICREPORT}
{$IFDEF FHIR_DOCUMENTMANIFEST}
  else if SameText(element.Name, 'DocumentManifest') then
    result := parseDocumentManifest(element, element.Name)
{$ENDIF FHIR_DOCUMENTMANIFEST}
{$IFDEF FHIR_DOCUMENTREFERENCE}
  else if SameText(element.Name, 'DocumentReference') then
    result := parseDocumentReference(element, element.Name)
{$ENDIF FHIR_DOCUMENTREFERENCE}
{$IFDEF FHIR_ENCOUNTER}
  else if SameText(element.Name, 'Encounter') then
    result := parseEncounter(element, element.Name)
{$ENDIF FHIR_ENCOUNTER}
{$IFDEF FHIR_ENDPOINT}
  else if SameText(element.Name, 'Endpoint') then
    result := parseEndpoint(element, element.Name)
{$ENDIF FHIR_ENDPOINT}
{$IFDEF FHIR_ENROLLMENTREQUEST}
  else if SameText(element.Name, 'EnrollmentRequest') then
    result := parseEnrollmentRequest(element, element.Name)
{$ENDIF FHIR_ENROLLMENTREQUEST}
{$IFDEF FHIR_ENROLLMENTRESPONSE}
  else if SameText(element.Name, 'EnrollmentResponse') then
    result := parseEnrollmentResponse(element, element.Name)
{$ENDIF FHIR_ENROLLMENTRESPONSE}
{$IFDEF FHIR_EPISODEOFCARE}
  else if SameText(element.Name, 'EpisodeOfCare') then
    result := parseEpisodeOfCare(element, element.Name)
{$ENDIF FHIR_EPISODEOFCARE}
{$IFDEF FHIR_EVENTDEFINITION}
  else if SameText(element.Name, 'EventDefinition') then
    result := parseEventDefinition(element, element.Name)
{$ENDIF FHIR_EVENTDEFINITION}
{$IFDEF FHIR_EVIDENCE}
  else if SameText(element.Name, 'Evidence') then
    result := parseEvidence(element, element.Name)
{$ENDIF FHIR_EVIDENCE}
{$IFDEF FHIR_EVIDENCEREPORT}
  else if SameText(element.Name, 'EvidenceReport') then
    result := parseEvidenceReport(element, element.Name)
{$ENDIF FHIR_EVIDENCEREPORT}
{$IFDEF FHIR_EVIDENCEVARIABLE}
  else if SameText(element.Name, 'EvidenceVariable') then
    result := parseEvidenceVariable(element, element.Name)
{$ENDIF FHIR_EVIDENCEVARIABLE}
{$IFDEF FHIR_EXAMPLESCENARIO}
  else if SameText(element.Name, 'ExampleScenario') then
    result := parseExampleScenario(element, element.Name)
{$ENDIF FHIR_EXAMPLESCENARIO}
{$IFDEF FHIR_EXPLANATIONOFBENEFIT}
  else if SameText(element.Name, 'ExplanationOfBenefit') then
    result := parseExplanationOfBenefit(element, element.Name)
{$ENDIF FHIR_EXPLANATIONOFBENEFIT}
{$IFDEF FHIR_FAMILYMEMBERHISTORY}
  else if SameText(element.Name, 'FamilyMemberHistory') then
    result := parseFamilyMemberHistory(element, element.Name)
{$ENDIF FHIR_FAMILYMEMBERHISTORY}
{$IFDEF FHIR_FLAG}
  else if SameText(element.Name, 'Flag') then
    result := parseFlag(element, element.Name)
{$ENDIF FHIR_FLAG}
{$IFDEF FHIR_FORMULARYITEM}
  else if SameText(element.Name, 'FormularyItem') then
    result := parseFormularyItem(element, element.Name)
{$ENDIF FHIR_FORMULARYITEM}
{$IFDEF FHIR_GENOMICSTUDY}
  else if SameText(element.Name, 'GenomicStudy') then
    result := parseGenomicStudy(element, element.Name)
{$ENDIF FHIR_GENOMICSTUDY}
{$IFDEF FHIR_GOAL}
  else if SameText(element.Name, 'Goal') then
    result := parseGoal(element, element.Name)
{$ENDIF FHIR_GOAL}
{$IFDEF FHIR_GRAPHDEFINITION}
  else if SameText(element.Name, 'GraphDefinition') then
    result := parseGraphDefinition(element, element.Name)
{$ENDIF FHIR_GRAPHDEFINITION}
{$IFDEF FHIR_GROUP}
  else if SameText(element.Name, 'Group') then
    result := parseGroup(element, element.Name)
{$ENDIF FHIR_GROUP}
{$IFDEF FHIR_GUIDANCERESPONSE}
  else if SameText(element.Name, 'GuidanceResponse') then
    result := parseGuidanceResponse(element, element.Name)
{$ENDIF FHIR_GUIDANCERESPONSE}
{$IFDEF FHIR_HEALTHCARESERVICE}
  else if SameText(element.Name, 'HealthcareService') then
    result := parseHealthcareService(element, element.Name)
{$ENDIF FHIR_HEALTHCARESERVICE}
{$IFDEF FHIR_IMAGINGSELECTION}
  else if SameText(element.Name, 'ImagingSelection') then
    result := parseImagingSelection(element, element.Name)
{$ENDIF FHIR_IMAGINGSELECTION}
{$IFDEF FHIR_IMAGINGSTUDY}
  else if SameText(element.Name, 'ImagingStudy') then
    result := parseImagingStudy(element, element.Name)
{$ENDIF FHIR_IMAGINGSTUDY}
{$IFDEF FHIR_IMMUNIZATION}
  else if SameText(element.Name, 'Immunization') then
    result := parseImmunization(element, element.Name)
{$ENDIF FHIR_IMMUNIZATION}
{$IFDEF FHIR_IMMUNIZATIONEVALUATION}
  else if SameText(element.Name, 'ImmunizationEvaluation') then
    result := parseImmunizationEvaluation(element, element.Name)
{$ENDIF FHIR_IMMUNIZATIONEVALUATION}
{$IFDEF FHIR_IMMUNIZATIONRECOMMENDATION}
  else if SameText(element.Name, 'ImmunizationRecommendation') then
    result := parseImmunizationRecommendation(element, element.Name)
{$ENDIF FHIR_IMMUNIZATIONRECOMMENDATION}
{$IFDEF FHIR_IMPLEMENTATIONGUIDE}
  else if SameText(element.Name, 'ImplementationGuide') then
    result := parseImplementationGuide(element, element.Name)
{$ENDIF FHIR_IMPLEMENTATIONGUIDE}
{$IFDEF FHIR_INGREDIENT}
  else if SameText(element.Name, 'Ingredient') then
    result := parseIngredient(element, element.Name)
{$ENDIF FHIR_INGREDIENT}
{$IFDEF FHIR_INSURANCEPLAN}
  else if SameText(element.Name, 'InsurancePlan') then
    result := parseInsurancePlan(element, element.Name)
{$ENDIF FHIR_INSURANCEPLAN}
{$IFDEF FHIR_INVENTORYREPORT}
  else if SameText(element.Name, 'InventoryReport') then
    result := parseInventoryReport(element, element.Name)
{$ENDIF FHIR_INVENTORYREPORT}
{$IFDEF FHIR_INVOICE}
  else if SameText(element.Name, 'Invoice') then
    result := parseInvoice(element, element.Name)
{$ENDIF FHIR_INVOICE}
{$IFDEF FHIR_LIBRARY}
  else if SameText(element.Name, 'Library') then
    result := parseLibrary(element, element.Name)
{$ENDIF FHIR_LIBRARY}
{$IFDEF FHIR_LINKAGE}
  else if SameText(element.Name, 'Linkage') then
    result := parseLinkage(element, element.Name)
{$ENDIF FHIR_LINKAGE}
{$IFDEF FHIR_LIST}
  else if SameText(element.Name, 'List') then
    result := parseList(element, element.Name)
{$ENDIF FHIR_LIST}
{$IFDEF FHIR_LOCATION}
  else if SameText(element.Name, 'Location') then
    result := parseLocation(element, element.Name)
{$ENDIF FHIR_LOCATION}
{$IFDEF FHIR_MANUFACTUREDITEMDEFINITION}
  else if SameText(element.Name, 'ManufacturedItemDefinition') then
    result := parseManufacturedItemDefinition(element, element.Name)
{$ENDIF FHIR_MANUFACTUREDITEMDEFINITION}
{$IFDEF FHIR_MEASURE}
  else if SameText(element.Name, 'Measure') then
    result := parseMeasure(element, element.Name)
{$ENDIF FHIR_MEASURE}
{$IFDEF FHIR_MEASUREREPORT}
  else if SameText(element.Name, 'MeasureReport') then
    result := parseMeasureReport(element, element.Name)
{$ENDIF FHIR_MEASUREREPORT}
{$IFDEF FHIR_MEDICATION}
  else if SameText(element.Name, 'Medication') then
    result := parseMedication(element, element.Name)
{$ENDIF FHIR_MEDICATION}
{$IFDEF FHIR_MEDICATIONADMINISTRATION}
  else if SameText(element.Name, 'MedicationAdministration') then
    result := parseMedicationAdministration(element, element.Name)
{$ENDIF FHIR_MEDICATIONADMINISTRATION}
{$IFDEF FHIR_MEDICATIONDISPENSE}
  else if SameText(element.Name, 'MedicationDispense') then
    result := parseMedicationDispense(element, element.Name)
{$ENDIF FHIR_MEDICATIONDISPENSE}
{$IFDEF FHIR_MEDICATIONKNOWLEDGE}
  else if SameText(element.Name, 'MedicationKnowledge') then
    result := parseMedicationKnowledge(element, element.Name)
{$ENDIF FHIR_MEDICATIONKNOWLEDGE}
{$IFDEF FHIR_MEDICATIONREQUEST}
  else if SameText(element.Name, 'MedicationRequest') then
    result := parseMedicationRequest(element, element.Name)
{$ENDIF FHIR_MEDICATIONREQUEST}
{$IFDEF FHIR_MEDICATIONUSAGE}
  else if SameText(element.Name, 'MedicationUsage') then
    result := parseMedicationUsage(element, element.Name)
{$ENDIF FHIR_MEDICATIONUSAGE}
{$IFDEF FHIR_MEDICINALPRODUCTDEFINITION}
  else if SameText(element.Name, 'MedicinalProductDefinition') then
    result := parseMedicinalProductDefinition(element, element.Name)
{$ENDIF FHIR_MEDICINALPRODUCTDEFINITION}
{$IFDEF FHIR_MESSAGEDEFINITION}
  else if SameText(element.Name, 'MessageDefinition') then
    result := parseMessageDefinition(element, element.Name)
{$ENDIF FHIR_MESSAGEDEFINITION}
{$IFDEF FHIR_MESSAGEHEADER}
  else if SameText(element.Name, 'MessageHeader') then
    result := parseMessageHeader(element, element.Name)
{$ENDIF FHIR_MESSAGEHEADER}
{$IFDEF FHIR_MOLECULARSEQUENCE}
  else if SameText(element.Name, 'MolecularSequence') then
    result := parseMolecularSequence(element, element.Name)
{$ENDIF FHIR_MOLECULARSEQUENCE}
{$IFDEF FHIR_NAMINGSYSTEM}
  else if SameText(element.Name, 'NamingSystem') then
    result := parseNamingSystem(element, element.Name)
{$ENDIF FHIR_NAMINGSYSTEM}
{$IFDEF FHIR_NUTRITIONINTAKE}
  else if SameText(element.Name, 'NutritionIntake') then
    result := parseNutritionIntake(element, element.Name)
{$ENDIF FHIR_NUTRITIONINTAKE}
{$IFDEF FHIR_NUTRITIONORDER}
  else if SameText(element.Name, 'NutritionOrder') then
    result := parseNutritionOrder(element, element.Name)
{$ENDIF FHIR_NUTRITIONORDER}
{$IFDEF FHIR_NUTRITIONPRODUCT}
  else if SameText(element.Name, 'NutritionProduct') then
    result := parseNutritionProduct(element, element.Name)
{$ENDIF FHIR_NUTRITIONPRODUCT}
{$IFDEF FHIR_OBSERVATION}
  else if SameText(element.Name, 'Observation') then
    result := parseObservation(element, element.Name)
{$ENDIF FHIR_OBSERVATION}
{$IFDEF FHIR_OBSERVATIONDEFINITION}
  else if SameText(element.Name, 'ObservationDefinition') then
    result := parseObservationDefinition(element, element.Name)
{$ENDIF FHIR_OBSERVATIONDEFINITION}
{$IFDEF FHIR_OPERATIONDEFINITION}
  else if SameText(element.Name, 'OperationDefinition') then
    result := parseOperationDefinition(element, element.Name)
{$ENDIF FHIR_OPERATIONDEFINITION}
{$IFDEF FHIR_OPERATIONOUTCOME}
  else if SameText(element.Name, 'OperationOutcome') then
    result := parseOperationOutcome(element, element.Name)
{$ENDIF FHIR_OPERATIONOUTCOME}
{$IFDEF FHIR_ORGANIZATION}
  else if SameText(element.Name, 'Organization') then
    result := parseOrganization(element, element.Name)
{$ENDIF FHIR_ORGANIZATION}
{$IFDEF FHIR_ORGANIZATIONAFFILIATION}
  else if SameText(element.Name, 'OrganizationAffiliation') then
    result := parseOrganizationAffiliation(element, element.Name)
{$ENDIF FHIR_ORGANIZATIONAFFILIATION}
{$IFDEF FHIR_PACKAGEDPRODUCTDEFINITION}
  else if SameText(element.Name, 'PackagedProductDefinition') then
    result := parsePackagedProductDefinition(element, element.Name)
{$ENDIF FHIR_PACKAGEDPRODUCTDEFINITION}
{$IFDEF FHIR_PARAMETERS}
  else if SameText(element.Name, 'Parameters') then
    result := parseParameters(element, element.Name)
{$ENDIF FHIR_PARAMETERS}
{$IFDEF FHIR_PATIENT}
  else if SameText(element.Name, 'Patient') then
    result := parsePatient(element, element.Name)
{$ENDIF FHIR_PATIENT}
{$IFDEF FHIR_PAYMENTNOTICE}
  else if SameText(element.Name, 'PaymentNotice') then
    result := parsePaymentNotice(element, element.Name)
{$ENDIF FHIR_PAYMENTNOTICE}
{$IFDEF FHIR_PAYMENTRECONCILIATION}
  else if SameText(element.Name, 'PaymentReconciliation') then
    result := parsePaymentReconciliation(element, element.Name)
{$ENDIF FHIR_PAYMENTRECONCILIATION}
{$IFDEF FHIR_PERMISSION}
  else if SameText(element.Name, 'Permission') then
    result := parsePermission(element, element.Name)
{$ENDIF FHIR_PERMISSION}
{$IFDEF FHIR_PERSON}
  else if SameText(element.Name, 'Person') then
    result := parsePerson(element, element.Name)
{$ENDIF FHIR_PERSON}
{$IFDEF FHIR_PLANDEFINITION}
  else if SameText(element.Name, 'PlanDefinition') then
    result := parsePlanDefinition(element, element.Name)
{$ENDIF FHIR_PLANDEFINITION}
{$IFDEF FHIR_PRACTITIONER}
  else if SameText(element.Name, 'Practitioner') then
    result := parsePractitioner(element, element.Name)
{$ENDIF FHIR_PRACTITIONER}
{$IFDEF FHIR_PRACTITIONERROLE}
  else if SameText(element.Name, 'PractitionerRole') then
    result := parsePractitionerRole(element, element.Name)
{$ENDIF FHIR_PRACTITIONERROLE}
{$IFDEF FHIR_PROCEDURE}
  else if SameText(element.Name, 'Procedure') then
    result := parseProcedure(element, element.Name)
{$ENDIF FHIR_PROCEDURE}
{$IFDEF FHIR_PROVENANCE}
  else if SameText(element.Name, 'Provenance') then
    result := parseProvenance(element, element.Name)
{$ENDIF FHIR_PROVENANCE}
{$IFDEF FHIR_QUESTIONNAIRE}
  else if SameText(element.Name, 'Questionnaire') then
    result := parseQuestionnaire(element, element.Name)
{$ENDIF FHIR_QUESTIONNAIRE}
{$IFDEF FHIR_QUESTIONNAIRERESPONSE}
  else if SameText(element.Name, 'QuestionnaireResponse') then
    result := parseQuestionnaireResponse(element, element.Name)
{$ENDIF FHIR_QUESTIONNAIRERESPONSE}
{$IFDEF FHIR_REGULATEDAUTHORIZATION}
  else if SameText(element.Name, 'RegulatedAuthorization') then
    result := parseRegulatedAuthorization(element, element.Name)
{$ENDIF FHIR_REGULATEDAUTHORIZATION}
{$IFDEF FHIR_RELATEDPERSON}
  else if SameText(element.Name, 'RelatedPerson') then
    result := parseRelatedPerson(element, element.Name)
{$ENDIF FHIR_RELATEDPERSON}
{$IFDEF FHIR_REQUESTGROUP}
  else if SameText(element.Name, 'RequestGroup') then
    result := parseRequestGroup(element, element.Name)
{$ENDIF FHIR_REQUESTGROUP}
{$IFDEF FHIR_REQUESTORCHESTRATION}
  else if SameText(element.Name, 'RequestOrchestration') then
    result := parseRequestOrchestration(element, element.Name)
{$ENDIF FHIR_REQUESTORCHESTRATION}
{$IFDEF FHIR_REQUIREMENTS}
  else if SameText(element.Name, 'Requirements') then
    result := parseRequirements(element, element.Name)
{$ENDIF FHIR_REQUIREMENTS}
{$IFDEF FHIR_RESEARCHSTUDY}
  else if SameText(element.Name, 'ResearchStudy') then
    result := parseResearchStudy(element, element.Name)
{$ENDIF FHIR_RESEARCHSTUDY}
{$IFDEF FHIR_RESEARCHSUBJECT}
  else if SameText(element.Name, 'ResearchSubject') then
    result := parseResearchSubject(element, element.Name)
{$ENDIF FHIR_RESEARCHSUBJECT}
{$IFDEF FHIR_RISKASSESSMENT}
  else if SameText(element.Name, 'RiskAssessment') then
    result := parseRiskAssessment(element, element.Name)
{$ENDIF FHIR_RISKASSESSMENT}
{$IFDEF FHIR_SCHEDULE}
  else if SameText(element.Name, 'Schedule') then
    result := parseSchedule(element, element.Name)
{$ENDIF FHIR_SCHEDULE}
{$IFDEF FHIR_SEARCHPARAMETER}
  else if SameText(element.Name, 'SearchParameter') then
    result := parseSearchParameter(element, element.Name)
{$ENDIF FHIR_SEARCHPARAMETER}
{$IFDEF FHIR_SERVICEREQUEST}
  else if SameText(element.Name, 'ServiceRequest') then
    result := parseServiceRequest(element, element.Name)
{$ENDIF FHIR_SERVICEREQUEST}
{$IFDEF FHIR_SLOT}
  else if SameText(element.Name, 'Slot') then
    result := parseSlot(element, element.Name)
{$ENDIF FHIR_SLOT}
{$IFDEF FHIR_SPECIMEN}
  else if SameText(element.Name, 'Specimen') then
    result := parseSpecimen(element, element.Name)
{$ENDIF FHIR_SPECIMEN}
{$IFDEF FHIR_SPECIMENDEFINITION}
  else if SameText(element.Name, 'SpecimenDefinition') then
    result := parseSpecimenDefinition(element, element.Name)
{$ENDIF FHIR_SPECIMENDEFINITION}
{$IFDEF FHIR_STRUCTUREDEFINITION}
  else if SameText(element.Name, 'StructureDefinition') then
    result := parseStructureDefinition(element, element.Name)
{$ENDIF FHIR_STRUCTUREDEFINITION}
{$IFDEF FHIR_STRUCTUREMAP}
  else if SameText(element.Name, 'StructureMap') then
    result := parseStructureMap(element, element.Name)
{$ENDIF FHIR_STRUCTUREMAP}
{$IFDEF FHIR_SUBSCRIPTION}
  else if SameText(element.Name, 'Subscription') then
    result := parseSubscription(element, element.Name)
{$ENDIF FHIR_SUBSCRIPTION}
{$IFDEF FHIR_SUBSCRIPTIONSTATUS}
  else if SameText(element.Name, 'SubscriptionStatus') then
    result := parseSubscriptionStatus(element, element.Name)
{$ENDIF FHIR_SUBSCRIPTIONSTATUS}
{$IFDEF FHIR_SUBSCRIPTIONTOPIC}
  else if SameText(element.Name, 'SubscriptionTopic') then
    result := parseSubscriptionTopic(element, element.Name)
{$ENDIF FHIR_SUBSCRIPTIONTOPIC}
{$IFDEF FHIR_SUBSTANCE}
  else if SameText(element.Name, 'Substance') then
    result := parseSubstance(element, element.Name)
{$ENDIF FHIR_SUBSTANCE}
{$IFDEF FHIR_SUBSTANCEDEFINITION}
  else if SameText(element.Name, 'SubstanceDefinition') then
    result := parseSubstanceDefinition(element, element.Name)
{$ENDIF FHIR_SUBSTANCEDEFINITION}
{$IFDEF FHIR_SUBSTANCENUCLEICACID}
  else if SameText(element.Name, 'SubstanceNucleicAcid') then
    result := parseSubstanceNucleicAcid(element, element.Name)
{$ENDIF FHIR_SUBSTANCENUCLEICACID}
{$IFDEF FHIR_SUBSTANCEPOLYMER}
  else if SameText(element.Name, 'SubstancePolymer') then
    result := parseSubstancePolymer(element, element.Name)
{$ENDIF FHIR_SUBSTANCEPOLYMER}
{$IFDEF FHIR_SUBSTANCEPROTEIN}
  else if SameText(element.Name, 'SubstanceProtein') then
    result := parseSubstanceProtein(element, element.Name)
{$ENDIF FHIR_SUBSTANCEPROTEIN}
{$IFDEF FHIR_SUBSTANCEREFERENCEINFORMATION}
  else if SameText(element.Name, 'SubstanceReferenceInformation') then
    result := parseSubstanceReferenceInformation(element, element.Name)
{$ENDIF FHIR_SUBSTANCEREFERENCEINFORMATION}
{$IFDEF FHIR_SUBSTANCESOURCEMATERIAL}
  else if SameText(element.Name, 'SubstanceSourceMaterial') then
    result := parseSubstanceSourceMaterial(element, element.Name)
{$ENDIF FHIR_SUBSTANCESOURCEMATERIAL}
{$IFDEF FHIR_SUPPLYDELIVERY}
  else if SameText(element.Name, 'SupplyDelivery') then
    result := parseSupplyDelivery(element, element.Name)
{$ENDIF FHIR_SUPPLYDELIVERY}
{$IFDEF FHIR_SUPPLYREQUEST}
  else if SameText(element.Name, 'SupplyRequest') then
    result := parseSupplyRequest(element, element.Name)
{$ENDIF FHIR_SUPPLYREQUEST}
{$IFDEF FHIR_TASK}
  else if SameText(element.Name, 'Task') then
    result := parseTask(element, element.Name)
{$ENDIF FHIR_TASK}
{$IFDEF FHIR_TERMINOLOGYCAPABILITIES}
  else if SameText(element.Name, 'TerminologyCapabilities') then
    result := parseTerminologyCapabilities(element, element.Name)
{$ENDIF FHIR_TERMINOLOGYCAPABILITIES}
{$IFDEF FHIR_TESTREPORT}
  else if SameText(element.Name, 'TestReport') then
    result := parseTestReport(element, element.Name)
{$ENDIF FHIR_TESTREPORT}
{$IFDEF FHIR_TESTSCRIPT}
  else if SameText(element.Name, 'TestScript') then
    result := parseTestScript(element, element.Name)
{$ENDIF FHIR_TESTSCRIPT}
{$IFDEF FHIR_TRANSPORT}
  else if SameText(element.Name, 'Transport') then
    result := parseTransport(element, element.Name)
{$ENDIF FHIR_TRANSPORT}
{$IFDEF FHIR_VALUESET}
  else if SameText(element.Name, 'ValueSet') then
    result := parseValueSet(element, element.Name)
{$ENDIF FHIR_VALUESET}
{$IFDEF FHIR_VERIFICATIONRESULT}
  else if SameText(element.Name, 'VerificationResult') then
    result := parseVerificationResult(element, element.Name)
{$ENDIF FHIR_VERIFICATIONRESULT}
{$IFDEF FHIR_VISIONPRESCRIPTION}
  else if SameText(element.Name, 'VisionPrescription') then
    result := parseVisionPrescription(element, element.Name)
{$ENDIF FHIR_VISIONPRESCRIPTION}

  else
    raise EXmlException.Create('error: the element '+element.Name+' is not a valid fragment name');
end;

function TFHIRXmlParser.ParseDataType(element : TMXmlElement; name : String; type_ : TFHIRDataTypeClass) : TFhirDataType;
begin
  if (name <> '') and (name <> element.localName) then
    raise EXmlException.Create('Expected Name mismatch : expected "'+name+'"+, but found "'+element.localName+'"')
  else if (type_ = TFhirAddress) then
    result := parseAddress(element, name)
  else if (type_ = TFhirAnnotation) then
    result := parseAnnotation(element, name)
  else if (type_ = TFhirAttachment) then
    result := parseAttachment(element, name)
  else if (type_ = TFhirAvailability) then
    result := parseAvailability(element, name)
  else if (type_ = TFhirCodeableConcept) then
    result := parseCodeableConcept(element, name)
  else if (type_ = TFhirCodeableReference) then
    result := parseCodeableReference(element, name)
  else if (type_ = TFhirCoding) then
    result := parseCoding(element, name)
  else if (type_ = TFhirContactDetail) then
    result := parseContactDetail(element, name)
  else if (type_ = TFhirContactPoint) then
    result := parseContactPoint(element, name)
  else if (type_ = TFhirContributor) then
    result := parseContributor(element, name)
  else if (type_ = TFhirDataRequirement) then
    result := parseDataRequirement(element, name)
  else if (type_ = TFhirExpression) then
    result := parseExpression(element, name)
  else if (type_ = TFhirExtendedContactDetail) then
    result := parseExtendedContactDetail(element, name)
  else if (type_ = TFhirExtension) then
    result := parseExtension(element, name)
  else if (type_ = TFhirHumanName) then
    result := parseHumanName(element, name)
  else if (type_ = TFhirIdentifier) then
    result := parseIdentifier(element, name)
  else if (type_ = TFhirMeta) then
    result := parseMeta(element, name)
  else if (type_ = TFhirMonetaryComponent) then
    result := parseMonetaryComponent(element, name)
  else if (type_ = TFhirMoney) then
    result := parseMoney(element, name)
  else if (type_ = TFhirNarrative) then
    result := parseNarrative(element, name)
  else if (type_ = TFhirParameterDefinition) then
    result := parseParameterDefinition(element, name)
  else if (type_ = TFhirPeriod) then
    result := parsePeriod(element, name)
  else if (type_ = TFhirQuantity) then
    result := parseQuantity(element, name)
  else if (type_ = TFhirRange) then
    result := parseRange(element, name)
  else if (type_ = TFhirRatio) then
    result := parseRatio(element, name)
  else if (type_ = TFhirRatioRange) then
    result := parseRatioRange(element, name)
  else if (type_ = TFhirReference) then
    result := parseReference(element, name)
  else if (type_ = TFhirRelatedArtifact) then
    result := parseRelatedArtifact(element, name)
  else if (type_ = TFhirSampledData) then
    result := parseSampledData(element, name)
  else if (type_ = TFhirSignature) then
    result := parseSignature(element, name)
  else if (type_ = TFhirTriggerDefinition) then
    result := parseTriggerDefinition(element, name)
  else if (type_ = TFhirUsageContext) then
    result := parseUsageContext(element, name)
  else if (type_ = TFhirVirtualServiceDetail) then
    result := parseVirtualServiceDetail(element, name)
  else if (type_ = TFhirAge) then
    result := parseAge(element, name)
  else if (type_ = TFhirCount) then
    result := parseCount(element, name)
  else if (type_ = TFhirDistance) then
    result := parseDistance(element, name)
  else if (type_ = TFhirDosage) then
    result := parseDosage(element, name)
  else if (type_ = TFhirDuration) then
    result := parseDuration(element, name)
  else if (type_ = TFhirElementDefinition) then
    result := parseElementDefinition(element, name)
  else if (type_ = TFhirMarketingStatus) then
    result := parseMarketingStatus(element, name)
  else if (type_ = TFhirPopulation) then
    result := parsePopulation(element, name)
  else if (type_ = TFhirProductShelfLife) then
    result := parseProductShelfLife(element, name)
  else if (type_ = TFhirTiming) then
    result := parseTiming(element, name)

  else
    raise EXmlException.Create('Unknown Type');
end;

procedure TFHIRXmlComposer.ComposeBase(xml : TXmlBuilder; name : String; base : TFHIRObject);
begin
  if (base = nil) Then
    Raise EXmlException.Create('error - base is nil')
  else if (base is TFhirAddress) then
    composeAddress(xml, name,  TFhirAddress(base))
  else if (base is TFhirAnnotation) then
    composeAnnotation(xml, name,  TFhirAnnotation(base))
  else if (base is TFhirAttachment) then
    composeAttachment(xml, name,  TFhirAttachment(base))
  else if (base is TFhirAvailability) then
    composeAvailability(xml, name,  TFhirAvailability(base))
  else if (base is TFhirCodeableConcept) then
    composeCodeableConcept(xml, name,  TFhirCodeableConcept(base))
  else if (base is TFhirCodeableReference) then
    composeCodeableReference(xml, name,  TFhirCodeableReference(base))
  else if (base is TFhirCoding) then
    composeCoding(xml, name,  TFhirCoding(base))
  else if (base is TFhirContactDetail) then
    composeContactDetail(xml, name,  TFhirContactDetail(base))
  else if (base is TFhirContactPoint) then
    composeContactPoint(xml, name,  TFhirContactPoint(base))
  else if (base is TFhirContributor) then
    composeContributor(xml, name,  TFhirContributor(base))
  else if (base is TFhirDataRequirement) then
    composeDataRequirement(xml, name,  TFhirDataRequirement(base))
  else if (base is TFhirExpression) then
    composeExpression(xml, name,  TFhirExpression(base))
  else if (base is TFhirExtendedContactDetail) then
    composeExtendedContactDetail(xml, name,  TFhirExtendedContactDetail(base))
  else if (base is TFhirExtension) then
    composeExtension(xml, name,  TFhirExtension(base))
  else if (base is TFhirHumanName) then
    composeHumanName(xml, name,  TFhirHumanName(base))
  else if (base is TFhirIdentifier) then
    composeIdentifier(xml, name,  TFhirIdentifier(base))
  else if (base is TFhirMeta) then
    composeMeta(xml, name,  TFhirMeta(base))
  else if (base is TFhirMonetaryComponent) then
    composeMonetaryComponent(xml, name,  TFhirMonetaryComponent(base))
  else if (base is TFhirMoney) then
    composeMoney(xml, name,  TFhirMoney(base))
  else if (base is TFhirNarrative) then
    composeNarrative(xml, name,  TFhirNarrative(base))
  else if (base is TFhirParameterDefinition) then
    composeParameterDefinition(xml, name,  TFhirParameterDefinition(base))
  else if (base is TFhirPeriod) then
    composePeriod(xml, name,  TFhirPeriod(base))
  else if (base is TFhirQuantity) then
    composeQuantity(xml, name,  TFhirQuantity(base))
  else if (base is TFhirRange) then
    composeRange(xml, name,  TFhirRange(base))
  else if (base is TFhirRatio) then
    composeRatio(xml, name,  TFhirRatio(base))
  else if (base is TFhirRatioRange) then
    composeRatioRange(xml, name,  TFhirRatioRange(base))
  else if (base is TFhirReference) then
    composeReference(xml, name,  TFhirReference(base))
  else if (base is TFhirRelatedArtifact) then
    composeRelatedArtifact(xml, name,  TFhirRelatedArtifact(base))
  else if (base is TFhirSampledData) then
    composeSampledData(xml, name,  TFhirSampledData(base))
  else if (base is TFhirSignature) then
    composeSignature(xml, name,  TFhirSignature(base))
  else if (base is TFhirTriggerDefinition) then
    composeTriggerDefinition(xml, name,  TFhirTriggerDefinition(base))
  else if (base is TFhirUsageContext) then
    composeUsageContext(xml, name,  TFhirUsageContext(base))
  else if (base is TFhirVirtualServiceDetail) then
    composeVirtualServiceDetail(xml, name,  TFhirVirtualServiceDetail(base))
  else if (base is TFhirAge) then
    composeAge(xml, name,  TFhirAge(base))
  else if (base is TFhirCount) then
    composeCount(xml, name,  TFhirCount(base))
  else if (base is TFhirDistance) then
    composeDistance(xml, name,  TFhirDistance(base))
  else if (base is TFhirDosage) then
    composeDosage(xml, name,  TFhirDosage(base))
  else if (base is TFhirDuration) then
    composeDuration(xml, name,  TFhirDuration(base))
  else if (base is TFhirElementDefinition) then
    composeElementDefinition(xml, name,  TFhirElementDefinition(base))
  else if (base is TFhirMarketingStatus) then
    composeMarketingStatus(xml, name,  TFhirMarketingStatus(base))
  else if (base is TFhirPopulation) then
    composePopulation(xml, name,  TFhirPopulation(base))
  else if (base is TFhirProductShelfLife) then
    composeProductShelfLife(xml, name,  TFhirProductShelfLife(base))
  else if (base is TFhirTiming) then
    composeTiming(xml, name,  TFhirTiming(base))
  else if (base is TFhirAccount) then
    composeAccount(xml, name,  TFhirAccount(base))
  else if (base is TFhirActivityDefinition) then
    composeActivityDefinition(xml, name,  TFhirActivityDefinition(base))
  else if (base is TFhirActorDefinition) then
    composeActorDefinition(xml, name,  TFhirActorDefinition(base))
  else if (base is TFhirAdministrableProductDefinition) then
    composeAdministrableProductDefinition(xml, name,  TFhirAdministrableProductDefinition(base))
  else if (base is TFhirAdverseEvent) then
    composeAdverseEvent(xml, name,  TFhirAdverseEvent(base))
  else if (base is TFhirAllergyIntolerance) then
    composeAllergyIntolerance(xml, name,  TFhirAllergyIntolerance(base))
  else if (base is TFhirAppointment) then
    composeAppointment(xml, name,  TFhirAppointment(base))
  else if (base is TFhirAppointmentResponse) then
    composeAppointmentResponse(xml, name,  TFhirAppointmentResponse(base))
  else if (base is TFhirArtifactAssessment) then
    composeArtifactAssessment(xml, name,  TFhirArtifactAssessment(base))
  else if (base is TFhirAuditEvent) then
    composeAuditEvent(xml, name,  TFhirAuditEvent(base))
  else if (base is TFhirBasic) then
    composeBasic(xml, name,  TFhirBasic(base))
  else if (base is TFhirBinary) then
    composeBinary(xml, name,  TFhirBinary(base))
  else if (base is TFhirBiologicallyDerivedProduct) then
    composeBiologicallyDerivedProduct(xml, name,  TFhirBiologicallyDerivedProduct(base))
  else if (base is TFhirBodyStructure) then
    composeBodyStructure(xml, name,  TFhirBodyStructure(base))
  else if (base is TFhirBundle) then
    composeBundle(xml, name,  TFhirBundle(base))
  else if (base is TFhirCapabilityStatement) then
    composeCapabilityStatement(xml, name,  TFhirCapabilityStatement(base))
  else if (base is TFhirCarePlan) then
    composeCarePlan(xml, name,  TFhirCarePlan(base))
  else if (base is TFhirCareTeam) then
    composeCareTeam(xml, name,  TFhirCareTeam(base))
  else if (base is TFhirChargeItem) then
    composeChargeItem(xml, name,  TFhirChargeItem(base))
  else if (base is TFhirChargeItemDefinition) then
    composeChargeItemDefinition(xml, name,  TFhirChargeItemDefinition(base))
  else if (base is TFhirCitation) then
    composeCitation(xml, name,  TFhirCitation(base))
  else if (base is TFhirClaim) then
    composeClaim(xml, name,  TFhirClaim(base))
  else if (base is TFhirClaimResponse) then
    composeClaimResponse(xml, name,  TFhirClaimResponse(base))
  else if (base is TFhirClinicalImpression) then
    composeClinicalImpression(xml, name,  TFhirClinicalImpression(base))
  else if (base is TFhirClinicalUseDefinition) then
    composeClinicalUseDefinition(xml, name,  TFhirClinicalUseDefinition(base))
  else if (base is TFhirCodeSystem) then
    composeCodeSystem(xml, name,  TFhirCodeSystem(base))
  else if (base is TFhirCommunication) then
    composeCommunication(xml, name,  TFhirCommunication(base))
  else if (base is TFhirCommunicationRequest) then
    composeCommunicationRequest(xml, name,  TFhirCommunicationRequest(base))
  else if (base is TFhirCompartmentDefinition) then
    composeCompartmentDefinition(xml, name,  TFhirCompartmentDefinition(base))
  else if (base is TFhirComposition) then
    composeComposition(xml, name,  TFhirComposition(base))
  else if (base is TFhirConceptMap) then
    composeConceptMap(xml, name,  TFhirConceptMap(base))
  else if (base is TFhirCondition) then
    composeCondition(xml, name,  TFhirCondition(base))
  else if (base is TFhirConditionDefinition) then
    composeConditionDefinition(xml, name,  TFhirConditionDefinition(base))
  else if (base is TFhirConsent) then
    composeConsent(xml, name,  TFhirConsent(base))
  else if (base is TFhirContract) then
    composeContract(xml, name,  TFhirContract(base))
  else if (base is TFhirCoverage) then
    composeCoverage(xml, name,  TFhirCoverage(base))
  else if (base is TFhirCoverageEligibilityRequest) then
    composeCoverageEligibilityRequest(xml, name,  TFhirCoverageEligibilityRequest(base))
  else if (base is TFhirCoverageEligibilityResponse) then
    composeCoverageEligibilityResponse(xml, name,  TFhirCoverageEligibilityResponse(base))
  else if (base is TFhirDetectedIssue) then
    composeDetectedIssue(xml, name,  TFhirDetectedIssue(base))
  else if (base is TFhirDevice) then
    composeDevice(xml, name,  TFhirDevice(base))
  else if (base is TFhirDeviceDefinition) then
    composeDeviceDefinition(xml, name,  TFhirDeviceDefinition(base))
  else if (base is TFhirDeviceDispense) then
    composeDeviceDispense(xml, name,  TFhirDeviceDispense(base))
  else if (base is TFhirDeviceMetric) then
    composeDeviceMetric(xml, name,  TFhirDeviceMetric(base))
  else if (base is TFhirDeviceRequest) then
    composeDeviceRequest(xml, name,  TFhirDeviceRequest(base))
  else if (base is TFhirDeviceUsage) then
    composeDeviceUsage(xml, name,  TFhirDeviceUsage(base))
  else if (base is TFhirDiagnosticReport) then
    composeDiagnosticReport(xml, name,  TFhirDiagnosticReport(base))
  else if (base is TFhirDocumentManifest) then
    composeDocumentManifest(xml, name,  TFhirDocumentManifest(base))
  else if (base is TFhirDocumentReference) then
    composeDocumentReference(xml, name,  TFhirDocumentReference(base))
  else if (base is TFhirEncounter) then
    composeEncounter(xml, name,  TFhirEncounter(base))
  else if (base is TFhirEndpoint) then
    composeEndpoint(xml, name,  TFhirEndpoint(base))
  else if (base is TFhirEnrollmentRequest) then
    composeEnrollmentRequest(xml, name,  TFhirEnrollmentRequest(base))
  else if (base is TFhirEnrollmentResponse) then
    composeEnrollmentResponse(xml, name,  TFhirEnrollmentResponse(base))
  else if (base is TFhirEpisodeOfCare) then
    composeEpisodeOfCare(xml, name,  TFhirEpisodeOfCare(base))
  else if (base is TFhirEventDefinition) then
    composeEventDefinition(xml, name,  TFhirEventDefinition(base))
  else if (base is TFhirEvidence) then
    composeEvidence(xml, name,  TFhirEvidence(base))
  else if (base is TFhirEvidenceReport) then
    composeEvidenceReport(xml, name,  TFhirEvidenceReport(base))
  else if (base is TFhirEvidenceVariable) then
    composeEvidenceVariable(xml, name,  TFhirEvidenceVariable(base))
  else if (base is TFhirExampleScenario) then
    composeExampleScenario(xml, name,  TFhirExampleScenario(base))
  else if (base is TFhirExplanationOfBenefit) then
    composeExplanationOfBenefit(xml, name,  TFhirExplanationOfBenefit(base))
  else if (base is TFhirFamilyMemberHistory) then
    composeFamilyMemberHistory(xml, name,  TFhirFamilyMemberHistory(base))
  else if (base is TFhirFlag) then
    composeFlag(xml, name,  TFhirFlag(base))
  else if (base is TFhirFormularyItem) then
    composeFormularyItem(xml, name,  TFhirFormularyItem(base))
  else if (base is TFhirGenomicStudy) then
    composeGenomicStudy(xml, name,  TFhirGenomicStudy(base))
  else if (base is TFhirGoal) then
    composeGoal(xml, name,  TFhirGoal(base))
  else if (base is TFhirGraphDefinition) then
    composeGraphDefinition(xml, name,  TFhirGraphDefinition(base))
  else if (base is TFhirGroup) then
    composeGroup(xml, name,  TFhirGroup(base))
  else if (base is TFhirGuidanceResponse) then
    composeGuidanceResponse(xml, name,  TFhirGuidanceResponse(base))
  else if (base is TFhirHealthcareService) then
    composeHealthcareService(xml, name,  TFhirHealthcareService(base))
  else if (base is TFhirImagingSelection) then
    composeImagingSelection(xml, name,  TFhirImagingSelection(base))
  else if (base is TFhirImagingStudy) then
    composeImagingStudy(xml, name,  TFhirImagingStudy(base))
  else if (base is TFhirImmunization) then
    composeImmunization(xml, name,  TFhirImmunization(base))
  else if (base is TFhirImmunizationEvaluation) then
    composeImmunizationEvaluation(xml, name,  TFhirImmunizationEvaluation(base))
  else if (base is TFhirImmunizationRecommendation) then
    composeImmunizationRecommendation(xml, name,  TFhirImmunizationRecommendation(base))
  else if (base is TFhirImplementationGuide) then
    composeImplementationGuide(xml, name,  TFhirImplementationGuide(base))
  else if (base is TFhirIngredient) then
    composeIngredient(xml, name,  TFhirIngredient(base))
  else if (base is TFhirInsurancePlan) then
    composeInsurancePlan(xml, name,  TFhirInsurancePlan(base))
  else if (base is TFhirInventoryReport) then
    composeInventoryReport(xml, name,  TFhirInventoryReport(base))
  else if (base is TFhirInvoice) then
    composeInvoice(xml, name,  TFhirInvoice(base))
  else if (base is TFhirLibrary) then
    composeLibrary(xml, name,  TFhirLibrary(base))
  else if (base is TFhirLinkage) then
    composeLinkage(xml, name,  TFhirLinkage(base))
  else if (base is TFhirList) then
    composeList(xml, name,  TFhirList(base))
  else if (base is TFhirLocation) then
    composeLocation(xml, name,  TFhirLocation(base))
  else if (base is TFhirManufacturedItemDefinition) then
    composeManufacturedItemDefinition(xml, name,  TFhirManufacturedItemDefinition(base))
  else if (base is TFhirMeasure) then
    composeMeasure(xml, name,  TFhirMeasure(base))
  else if (base is TFhirMeasureReport) then
    composeMeasureReport(xml, name,  TFhirMeasureReport(base))
  else if (base is TFhirMedication) then
    composeMedication(xml, name,  TFhirMedication(base))
  else if (base is TFhirMedicationAdministration) then
    composeMedicationAdministration(xml, name,  TFhirMedicationAdministration(base))
  else if (base is TFhirMedicationDispense) then
    composeMedicationDispense(xml, name,  TFhirMedicationDispense(base))
  else if (base is TFhirMedicationKnowledge) then
    composeMedicationKnowledge(xml, name,  TFhirMedicationKnowledge(base))
  else if (base is TFhirMedicationRequest) then
    composeMedicationRequest(xml, name,  TFhirMedicationRequest(base))
  else if (base is TFhirMedicationUsage) then
    composeMedicationUsage(xml, name,  TFhirMedicationUsage(base))
  else if (base is TFhirMedicinalProductDefinition) then
    composeMedicinalProductDefinition(xml, name,  TFhirMedicinalProductDefinition(base))
  else if (base is TFhirMessageDefinition) then
    composeMessageDefinition(xml, name,  TFhirMessageDefinition(base))
  else if (base is TFhirMessageHeader) then
    composeMessageHeader(xml, name,  TFhirMessageHeader(base))
  else if (base is TFhirMolecularSequence) then
    composeMolecularSequence(xml, name,  TFhirMolecularSequence(base))
  else if (base is TFhirNamingSystem) then
    composeNamingSystem(xml, name,  TFhirNamingSystem(base))
  else if (base is TFhirNutritionIntake) then
    composeNutritionIntake(xml, name,  TFhirNutritionIntake(base))
  else if (base is TFhirNutritionOrder) then
    composeNutritionOrder(xml, name,  TFhirNutritionOrder(base))
  else if (base is TFhirNutritionProduct) then
    composeNutritionProduct(xml, name,  TFhirNutritionProduct(base))
  else if (base is TFhirObservation) then
    composeObservation(xml, name,  TFhirObservation(base))
  else if (base is TFhirObservationDefinition) then
    composeObservationDefinition(xml, name,  TFhirObservationDefinition(base))
  else if (base is TFhirOperationDefinition) then
    composeOperationDefinition(xml, name,  TFhirOperationDefinition(base))
  else if (base is TFhirOperationOutcome) then
    composeOperationOutcome(xml, name,  TFhirOperationOutcome(base))
  else if (base is TFhirOrganization) then
    composeOrganization(xml, name,  TFhirOrganization(base))
  else if (base is TFhirOrganizationAffiliation) then
    composeOrganizationAffiliation(xml, name,  TFhirOrganizationAffiliation(base))
  else if (base is TFhirPackagedProductDefinition) then
    composePackagedProductDefinition(xml, name,  TFhirPackagedProductDefinition(base))
  else if (base is TFhirParameters) then
    composeParameters(xml, name,  TFhirParameters(base))
  else if (base is TFhirPatient) then
    composePatient(xml, name,  TFhirPatient(base))
  else if (base is TFhirPaymentNotice) then
    composePaymentNotice(xml, name,  TFhirPaymentNotice(base))
  else if (base is TFhirPaymentReconciliation) then
    composePaymentReconciliation(xml, name,  TFhirPaymentReconciliation(base))
  else if (base is TFhirPermission) then
    composePermission(xml, name,  TFhirPermission(base))
  else if (base is TFhirPerson) then
    composePerson(xml, name,  TFhirPerson(base))
  else if (base is TFhirPlanDefinition) then
    composePlanDefinition(xml, name,  TFhirPlanDefinition(base))
  else if (base is TFhirPractitioner) then
    composePractitioner(xml, name,  TFhirPractitioner(base))
  else if (base is TFhirPractitionerRole) then
    composePractitionerRole(xml, name,  TFhirPractitionerRole(base))
  else if (base is TFhirProcedure) then
    composeProcedure(xml, name,  TFhirProcedure(base))
  else if (base is TFhirProvenance) then
    composeProvenance(xml, name,  TFhirProvenance(base))
  else if (base is TFhirQuestionnaire) then
    composeQuestionnaire(xml, name,  TFhirQuestionnaire(base))
  else if (base is TFhirQuestionnaireResponse) then
    composeQuestionnaireResponse(xml, name,  TFhirQuestionnaireResponse(base))
  else if (base is TFhirRegulatedAuthorization) then
    composeRegulatedAuthorization(xml, name,  TFhirRegulatedAuthorization(base))
  else if (base is TFhirRelatedPerson) then
    composeRelatedPerson(xml, name,  TFhirRelatedPerson(base))
  else if (base is TFhirRequestGroup) then
    composeRequestGroup(xml, name,  TFhirRequestGroup(base))
  else if (base is TFhirRequestOrchestration) then
    composeRequestOrchestration(xml, name,  TFhirRequestOrchestration(base))
  else if (base is TFhirRequirements) then
    composeRequirements(xml, name,  TFhirRequirements(base))
  else if (base is TFhirResearchStudy) then
    composeResearchStudy(xml, name,  TFhirResearchStudy(base))
  else if (base is TFhirResearchSubject) then
    composeResearchSubject(xml, name,  TFhirResearchSubject(base))
  else if (base is TFhirRiskAssessment) then
    composeRiskAssessment(xml, name,  TFhirRiskAssessment(base))
  else if (base is TFhirSchedule) then
    composeSchedule(xml, name,  TFhirSchedule(base))
  else if (base is TFhirSearchParameter) then
    composeSearchParameter(xml, name,  TFhirSearchParameter(base))
  else if (base is TFhirServiceRequest) then
    composeServiceRequest(xml, name,  TFhirServiceRequest(base))
  else if (base is TFhirSlot) then
    composeSlot(xml, name,  TFhirSlot(base))
  else if (base is TFhirSpecimen) then
    composeSpecimen(xml, name,  TFhirSpecimen(base))
  else if (base is TFhirSpecimenDefinition) then
    composeSpecimenDefinition(xml, name,  TFhirSpecimenDefinition(base))
  else if (base is TFhirStructureDefinition) then
    composeStructureDefinition(xml, name,  TFhirStructureDefinition(base))
  else if (base is TFhirStructureMap) then
    composeStructureMap(xml, name,  TFhirStructureMap(base))
  else if (base is TFhirSubscription) then
    composeSubscription(xml, name,  TFhirSubscription(base))
  else if (base is TFhirSubscriptionStatus) then
    composeSubscriptionStatus(xml, name,  TFhirSubscriptionStatus(base))
  else if (base is TFhirSubscriptionTopic) then
    composeSubscriptionTopic(xml, name,  TFhirSubscriptionTopic(base))
  else if (base is TFhirSubstance) then
    composeSubstance(xml, name,  TFhirSubstance(base))
  else if (base is TFhirSubstanceDefinition) then
    composeSubstanceDefinition(xml, name,  TFhirSubstanceDefinition(base))
  else if (base is TFhirSubstanceNucleicAcid) then
    composeSubstanceNucleicAcid(xml, name,  TFhirSubstanceNucleicAcid(base))
  else if (base is TFhirSubstancePolymer) then
    composeSubstancePolymer(xml, name,  TFhirSubstancePolymer(base))
  else if (base is TFhirSubstanceProtein) then
    composeSubstanceProtein(xml, name,  TFhirSubstanceProtein(base))
  else if (base is TFhirSubstanceReferenceInformation) then
    composeSubstanceReferenceInformation(xml, name,  TFhirSubstanceReferenceInformation(base))
  else if (base is TFhirSubstanceSourceMaterial) then
    composeSubstanceSourceMaterial(xml, name,  TFhirSubstanceSourceMaterial(base))
  else if (base is TFhirSupplyDelivery) then
    composeSupplyDelivery(xml, name,  TFhirSupplyDelivery(base))
  else if (base is TFhirSupplyRequest) then
    composeSupplyRequest(xml, name,  TFhirSupplyRequest(base))
  else if (base is TFhirTask) then
    composeTask(xml, name,  TFhirTask(base))
  else if (base is TFhirTerminologyCapabilities) then
    composeTerminologyCapabilities(xml, name,  TFhirTerminologyCapabilities(base))
  else if (base is TFhirTestReport) then
    composeTestReport(xml, name,  TFhirTestReport(base))
  else if (base is TFhirTestScript) then
    composeTestScript(xml, name,  TFhirTestScript(base))
  else if (base is TFhirTransport) then
    composeTransport(xml, name,  TFhirTransport(base))
  else if (base is TFhirValueSet) then
    composeValueSet(xml, name,  TFhirValueSet(base))
  else if (base is TFhirVerificationResult) then
    composeVerificationResult(xml, name,  TFhirVerificationResult(base))
  else if (base is TFhirVisionPrescription) then
    composeVisionPrescription(xml, name,  TFhirVisionPrescription(base))

  else
    inherited ComposeBase(xml, name, base);
end;


end.

