unit fhir5_resources_medications;

{
  Copyright (c) 2011+, HL7 and Health Intersections Pty Ltd (http://www.healthintersections.com.au)
  All rights reserved.
  
  Redistribution and use in source and binary forms, with or without modification, 
  are permitted provided that the following conditions are met:
  
   * Redistributions of source code must retain the above copyright notice, this 
     list of conditions and the following disclaimer.
   * Redistributions in binary form must reproduce the above copyright notice, 
     this list of conditions and the following disclaimer in the documentation 
     and/or other materials provided with the distribution.
   * Neither the name of HL7 nor the names of its contributors may be used to 
     endorse or promote products derived from this software without specific 
     prior written permission.
  
  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND 
  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED 
  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. 
  IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, 
  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT 
  NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR 
  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, 
  WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) 
  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE 
  POSSIBILITY OF SUCH DAMAGE.
  
}

{$i fhir.inc}
{$i fhir5.inc}

interface

// Generated on Thu, Nov 10, 2022 for FHIR v5.0.0



uses
  SysUtils, Classes, 
  fsl_base, fsl_utilities, fsl_stream, 
  fhir_objects, fhir_utilities,  
  fhir5_base, fhir5_enums, fhir5_types, fhir5_resources_base, fhir5_resources_canonical;



type
{$IFDEF FHIR_ADMINISTRABLEPRODUCTDEFINITION}
  TFhirAdministrableProductDefinitionProperty = class;
  TFhirAdministrableProductDefinitionPropertyList = class;
  TFhirAdministrableProductDefinitionRouteOfAdministration = class;
  TFhirAdministrableProductDefinitionRouteOfAdministrationList = class;
  TFhirAdministrableProductDefinitionRouteOfAdministrationTargetSpecies = class;
  TFhirAdministrableProductDefinitionRouteOfAdministrationTargetSpeciesList = class;
  TFhirAdministrableProductDefinitionRouteOfAdministrationTargetSpeciesWithdrawalPeriod = class;
  TFhirAdministrableProductDefinitionRouteOfAdministrationTargetSpeciesWithdrawalPeriodList = class;
  TFhirAdministrableProductDefinition = class;
  TFhirAdministrableProductDefinitionList = class;
{$ENDIF FHIR_ADMINISTRABLEPRODUCTDEFINITION}
{$IFDEF FHIR_FORMULARYITEM}
  TFhirFormularyItem = class;
  TFhirFormularyItemList = class;
{$ENDIF FHIR_FORMULARYITEM}
{$IFDEF FHIR_INGREDIENT}
  TFhirIngredientManufacturer = class;
  TFhirIngredientManufacturerList = class;
  TFhirIngredientSubstance = class;
  TFhirIngredientSubstanceList = class;
  TFhirIngredientSubstanceStrength = class;
  TFhirIngredientSubstanceStrengthList = class;
  TFhirIngredientSubstanceStrengthReferenceStrength = class;
  TFhirIngredientSubstanceStrengthReferenceStrengthList = class;
  TFhirIngredient = class;
  TFhirIngredientList = class;
{$ENDIF FHIR_INGREDIENT}
{$IFDEF FHIR_MANUFACTUREDITEMDEFINITION}
  TFhirManufacturedItemDefinitionProperty = class;
  TFhirManufacturedItemDefinitionPropertyList = class;
  TFhirManufacturedItemDefinitionComponent = class;
  TFhirManufacturedItemDefinitionComponentList = class;
  TFhirManufacturedItemDefinitionComponentConstituent = class;
  TFhirManufacturedItemDefinitionComponentConstituentList = class;
  TFhirManufacturedItemDefinition = class;
  TFhirManufacturedItemDefinitionList = class;
{$ENDIF FHIR_MANUFACTUREDITEMDEFINITION}
{$IFDEF FHIR_MEDICATION}
  TFhirMedicationIngredient = class;
  TFhirMedicationIngredientList = class;
  TFhirMedicationBatch = class;
  TFhirMedicationBatchList = class;
  TFhirMedication = class;
  TFhirMedicationList = class;
{$ENDIF FHIR_MEDICATION}
{$IFDEF FHIR_MEDICATIONKNOWLEDGE}
  TFhirMedicationKnowledgeRelatedMedicationKnowledge = class;
  TFhirMedicationKnowledgeRelatedMedicationKnowledgeList = class;
  TFhirMedicationKnowledgeMonograph = class;
  TFhirMedicationKnowledgeMonographList = class;
  TFhirMedicationKnowledgeCost = class;
  TFhirMedicationKnowledgeCostList = class;
  TFhirMedicationKnowledgeMonitoringProgram = class;
  TFhirMedicationKnowledgeMonitoringProgramList = class;
  TFhirMedicationKnowledgeIndicationGuideline = class;
  TFhirMedicationKnowledgeIndicationGuidelineList = class;
  TFhirMedicationKnowledgeIndicationGuidelineDosingGuideline = class;
  TFhirMedicationKnowledgeIndicationGuidelineDosingGuidelineList = class;
  TFhirMedicationKnowledgeIndicationGuidelineDosingGuidelineDosage = class;
  TFhirMedicationKnowledgeIndicationGuidelineDosingGuidelineDosageList = class;
  TFhirMedicationKnowledgeIndicationGuidelineDosingGuidelinePatientCharacteristic = class;
  TFhirMedicationKnowledgeIndicationGuidelineDosingGuidelinePatientCharacteristicList = class;
  TFhirMedicationKnowledgeMedicineClassification = class;
  TFhirMedicationKnowledgeMedicineClassificationList = class;
  TFhirMedicationKnowledgePackaging = class;
  TFhirMedicationKnowledgePackagingList = class;
  TFhirMedicationKnowledgeStorageGuideline = class;
  TFhirMedicationKnowledgeStorageGuidelineList = class;
  TFhirMedicationKnowledgeStorageGuidelineEnvironmentalSetting = class;
  TFhirMedicationKnowledgeStorageGuidelineEnvironmentalSettingList = class;
  TFhirMedicationKnowledgeRegulatory = class;
  TFhirMedicationKnowledgeRegulatoryList = class;
  TFhirMedicationKnowledgeRegulatorySubstitution = class;
  TFhirMedicationKnowledgeRegulatorySubstitutionList = class;
  TFhirMedicationKnowledgeRegulatoryMaxDispense = class;
  TFhirMedicationKnowledgeRegulatoryMaxDispenseList = class;
  TFhirMedicationKnowledgeDefinitional = class;
  TFhirMedicationKnowledgeDefinitionalList = class;
  TFhirMedicationKnowledgeDefinitionalIngredient = class;
  TFhirMedicationKnowledgeDefinitionalIngredientList = class;
  TFhirMedicationKnowledgeDefinitionalDrugCharacteristic = class;
  TFhirMedicationKnowledgeDefinitionalDrugCharacteristicList = class;
  TFhirMedicationKnowledge = class;
  TFhirMedicationKnowledgeList = class;
{$ENDIF FHIR_MEDICATIONKNOWLEDGE}
{$IFDEF FHIR_MEDICINALPRODUCTDEFINITION}
  TFhirMedicinalProductDefinitionContact = class;
  TFhirMedicinalProductDefinitionContactList = class;
  TFhirMedicinalProductDefinitionName = class;
  TFhirMedicinalProductDefinitionNameList = class;
  TFhirMedicinalProductDefinitionNamePart = class;
  TFhirMedicinalProductDefinitionNamePartList = class;
  TFhirMedicinalProductDefinitionNameUsage = class;
  TFhirMedicinalProductDefinitionNameUsageList = class;
  TFhirMedicinalProductDefinitionCrossReference = class;
  TFhirMedicinalProductDefinitionCrossReferenceList = class;
  TFhirMedicinalProductDefinitionOperation = class;
  TFhirMedicinalProductDefinitionOperationList = class;
  TFhirMedicinalProductDefinitionCharacteristic = class;
  TFhirMedicinalProductDefinitionCharacteristicList = class;
  TFhirMedicinalProductDefinition = class;
  TFhirMedicinalProductDefinitionList = class;
{$ENDIF FHIR_MEDICINALPRODUCTDEFINITION}
{$IFDEF FHIR_NUTRITIONPRODUCT}
  TFhirNutritionProductNutrient = class;
  TFhirNutritionProductNutrientList = class;
  TFhirNutritionProductIngredient = class;
  TFhirNutritionProductIngredientList = class;
  TFhirNutritionProductCharacteristic = class;
  TFhirNutritionProductCharacteristicList = class;
  TFhirNutritionProductInstance = class;
  TFhirNutritionProductInstanceList = class;
  TFhirNutritionProduct = class;
  TFhirNutritionProductList = class;
{$ENDIF FHIR_NUTRITIONPRODUCT}
{$IFDEF FHIR_PACKAGEDPRODUCTDEFINITION}
  TFhirPackagedProductDefinitionLegalStatusOfSupply = class;
  TFhirPackagedProductDefinitionLegalStatusOfSupplyList = class;
  TFhirPackagedProductDefinitionPackaging = class;
  TFhirPackagedProductDefinitionPackagingList = class;
  TFhirPackagedProductDefinitionPackagingProperty = class;
  TFhirPackagedProductDefinitionPackagingPropertyList = class;
  TFhirPackagedProductDefinitionPackagingContainedItem = class;
  TFhirPackagedProductDefinitionPackagingContainedItemList = class;
  TFhirPackagedProductDefinition = class;
  TFhirPackagedProductDefinitionList = class;
{$ENDIF FHIR_PACKAGEDPRODUCTDEFINITION}
{$IFDEF FHIR_REGULATEDAUTHORIZATION}
  TFhirRegulatedAuthorizationCase = class;
  TFhirRegulatedAuthorizationCaseList = class;
  TFhirRegulatedAuthorization = class;
  TFhirRegulatedAuthorizationList = class;
{$ENDIF FHIR_REGULATEDAUTHORIZATION}
{$IFDEF FHIR_SUBSTANCE}
  TFhirSubstanceIngredient = class;
  TFhirSubstanceIngredientList = class;
  TFhirSubstance = class;
  TFhirSubstanceList = class;
{$ENDIF FHIR_SUBSTANCE}
{$IFDEF FHIR_SUBSTANCEDEFINITION}
  TFhirSubstanceDefinitionMoiety = class;
  TFhirSubstanceDefinitionMoietyList = class;
  TFhirSubstanceDefinitionProperty = class;
  TFhirSubstanceDefinitionPropertyList = class;
  TFhirSubstanceDefinitionMolecularWeight = class;
  TFhirSubstanceDefinitionMolecularWeightList = class;
  TFhirSubstanceDefinitionStructure = class;
  TFhirSubstanceDefinitionStructureList = class;
  TFhirSubstanceDefinitionStructureRepresentation = class;
  TFhirSubstanceDefinitionStructureRepresentationList = class;
  TFhirSubstanceDefinitionCode = class;
  TFhirSubstanceDefinitionCodeList = class;
  TFhirSubstanceDefinitionName = class;
  TFhirSubstanceDefinitionNameList = class;
  TFhirSubstanceDefinitionNameOfficial = class;
  TFhirSubstanceDefinitionNameOfficialList = class;
  TFhirSubstanceDefinitionRelationship = class;
  TFhirSubstanceDefinitionRelationshipList = class;
  TFhirSubstanceDefinitionSourceMaterial = class;
  TFhirSubstanceDefinitionSourceMaterialList = class;
  TFhirSubstanceDefinition = class;
  TFhirSubstanceDefinitionList = class;
{$ENDIF FHIR_SUBSTANCEDEFINITION}
{$IFDEF FHIR_SUBSTANCENUCLEICACID}
  TFhirSubstanceNucleicAcidSubunit = class;
  TFhirSubstanceNucleicAcidSubunitList = class;
  TFhirSubstanceNucleicAcidSubunitLinkage = class;
  TFhirSubstanceNucleicAcidSubunitLinkageList = class;
  TFhirSubstanceNucleicAcidSubunitSugar = class;
  TFhirSubstanceNucleicAcidSubunitSugarList = class;
  TFhirSubstanceNucleicAcid = class;
  TFhirSubstanceNucleicAcidList = class;
{$ENDIF FHIR_SUBSTANCENUCLEICACID}
{$IFDEF FHIR_SUBSTANCEPOLYMER}
  TFhirSubstancePolymerMonomerSet = class;
  TFhirSubstancePolymerMonomerSetList = class;
  TFhirSubstancePolymerMonomerSetStartingMaterial = class;
  TFhirSubstancePolymerMonomerSetStartingMaterialList = class;
  TFhirSubstancePolymerRepeat = class;
  TFhirSubstancePolymerRepeatList = class;
  TFhirSubstancePolymerRepeatRepeatUnit = class;
  TFhirSubstancePolymerRepeatRepeatUnitList = class;
  TFhirSubstancePolymerRepeatRepeatUnitDegreeOfPolymerisation = class;
  TFhirSubstancePolymerRepeatRepeatUnitDegreeOfPolymerisationList = class;
  TFhirSubstancePolymerRepeatRepeatUnitStructuralRepresentation = class;
  TFhirSubstancePolymerRepeatRepeatUnitStructuralRepresentationList = class;
  TFhirSubstancePolymer = class;
  TFhirSubstancePolymerList = class;
{$ENDIF FHIR_SUBSTANCEPOLYMER}
{$IFDEF FHIR_SUBSTANCEPROTEIN}
  TFhirSubstanceProteinSubunit = class;
  TFhirSubstanceProteinSubunitList = class;
  TFhirSubstanceProtein = class;
  TFhirSubstanceProteinList = class;
{$ENDIF FHIR_SUBSTANCEPROTEIN}
{$IFDEF FHIR_SUBSTANCEREFERENCEINFORMATION}
  TFhirSubstanceReferenceInformationGene = class;
  TFhirSubstanceReferenceInformationGeneList = class;
  TFhirSubstanceReferenceInformationGeneElement = class;
  TFhirSubstanceReferenceInformationGeneElementList = class;
  TFhirSubstanceReferenceInformationTarget = class;
  TFhirSubstanceReferenceInformationTargetList = class;
  TFhirSubstanceReferenceInformation = class;
  TFhirSubstanceReferenceInformationList = class;
{$ENDIF FHIR_SUBSTANCEREFERENCEINFORMATION}
{$IFDEF FHIR_SUBSTANCESOURCEMATERIAL}
  TFhirSubstanceSourceMaterialFractionDescription = class;
  TFhirSubstanceSourceMaterialFractionDescriptionList = class;
  TFhirSubstanceSourceMaterialOrganism = class;
  TFhirSubstanceSourceMaterialOrganismList = class;
  TFhirSubstanceSourceMaterialOrganismAuthor = class;
  TFhirSubstanceSourceMaterialOrganismAuthorList = class;
  TFhirSubstanceSourceMaterialOrganismHybrid = class;
  TFhirSubstanceSourceMaterialOrganismHybridList = class;
  TFhirSubstanceSourceMaterialOrganismOrganismGeneral = class;
  TFhirSubstanceSourceMaterialOrganismOrganismGeneralList = class;
  TFhirSubstanceSourceMaterialPartDescription = class;
  TFhirSubstanceSourceMaterialPartDescriptionList = class;
  TFhirSubstanceSourceMaterial = class;
  TFhirSubstanceSourceMaterialList = class;
{$ENDIF FHIR_SUBSTANCESOURCEMATERIAL}




{$IFDEF FHIR_ADMINISTRABLEPRODUCTDEFINITION}
  // Characteristics e.g. a product's onset of action.
  TFhirAdministrableProductDefinitionProperty = class (TFhirBackboneElement)
  protected
    FType_ : TFhirCodeableConcept;
    FValue : TFhirDataType;
    FStatus : TFhirCodeableConcept;
    procedure SetType_(value : TFhirCodeableConcept);
    procedure SetValue(value : TFhirDataType);
    procedure SetStatus(value : TFhirCodeableConcept);
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirAdministrableProductDefinitionProperty; overload;
    function Clone : TFhirAdministrableProductDefinitionProperty; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to A code expressing the type of characteristic. (defined for API consistency)
    property type_ : TFhirCodeableConcept read FType_ write SetType_;
    // A code expressing the type of characteristic.
    property type_Element : TFhirCodeableConcept read FType_ write SetType_;

    // Typed access to A value for the characteristic. (defined for API consistency)
    property value : TFhirDataType read FValue write SetValue;
    // A value for the characteristic.
    property valueElement : TFhirDataType read FValue write SetValue;

    // Typed access to The status of characteristic e.g. assigned or pending. (defined for API consistency)
    property status : TFhirCodeableConcept read FStatus write SetStatus;
    // The status of characteristic e.g. assigned or pending.
    property statusElement : TFhirCodeableConcept read FStatus write SetStatus;

  end;

  TFhirAdministrableProductDefinitionPropertyListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirAdministrableProductDefinitionPropertyList;
    function GetCurrent : TFhirAdministrableProductDefinitionProperty;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirAdministrableProductDefinitionPropertyList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirAdministrableProductDefinitionProperty read GetCurrent;
  end;

  TFhirAdministrableProductDefinitionPropertyList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirAdministrableProductDefinitionProperty;
    procedure SetItemN(index : Integer; value : TFhirAdministrableProductDefinitionProperty);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirAdministrableProductDefinitionPropertyList; overload;
    function Clone : TFhirAdministrableProductDefinitionPropertyList; overload;
    function GetEnumerator : TFhirAdministrableProductDefinitionPropertyListEnumerator;
    
    //  Add a FhirAdministrableProductDefinitionProperty to the end of the list.
    function Append : TFhirAdministrableProductDefinitionProperty;
    
    // Add an already existing FhirAdministrableProductDefinitionProperty to the end of the list.
    function AddItem(value : TFhirAdministrableProductDefinitionProperty) : TFhirAdministrableProductDefinitionProperty; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirAdministrableProductDefinitionProperty) : Integer;
    
    // Insert FhirAdministrableProductDefinitionProperty before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirAdministrableProductDefinitionProperty;
    
    // Insert an existing FhirAdministrableProductDefinitionProperty before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirAdministrableProductDefinitionProperty);
    
    // Get the iIndexth FhirAdministrableProductDefinitionProperty. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirAdministrableProductDefinitionProperty);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirAdministrableProductDefinitionProperty;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirAdministrableProductDefinitionProperties[index : Integer] : TFhirAdministrableProductDefinitionProperty read GetItemN write SetItemN; default;
  End;

  // The path by which the product is taken into or makes contact with the body. In some regions this is referred to as the licenced or approved route. RouteOfAdministration cannot be used when the 'formOf' product already uses MedicinalProductDefinition.route (and vice versa).
  TFhirAdministrableProductDefinitionRouteOfAdministration = class (TFhirBackboneElement)
  protected
    FCode : TFhirCodeableConcept;
    FFirstDose : TFhirQuantity;
    FMaxSingleDose : TFhirQuantity;
    FMaxDosePerDay : TFhirQuantity;
    FMaxDosePerTreatmentPeriod : TFhirRatio;
    FMaxTreatmentPeriod : TFhirDuration;
    FtargetSpeciesList : TFhirAdministrableProductDefinitionRouteOfAdministrationTargetSpeciesList;
    procedure SetCode(value : TFhirCodeableConcept);
    procedure SetFirstDose(value : TFhirQuantity);
    procedure SetMaxSingleDose(value : TFhirQuantity);
    procedure SetMaxDosePerDay(value : TFhirQuantity);
    procedure SetMaxDosePerTreatmentPeriod(value : TFhirRatio);
    procedure SetMaxTreatmentPeriod(value : TFhirDuration);
    function GetTargetSpeciesList : TFhirAdministrableProductDefinitionRouteOfAdministrationTargetSpeciesList;
    function GetHasTargetSpeciesList : Boolean;
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirAdministrableProductDefinitionRouteOfAdministration; overload;
    function Clone : TFhirAdministrableProductDefinitionRouteOfAdministration; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to Coded expression for the route. (defined for API consistency)
    property code : TFhirCodeableConcept read FCode write SetCode;
    // Coded expression for the route.
    property codeElement : TFhirCodeableConcept read FCode write SetCode;

    // Typed access to The first dose (dose quantity) administered can be specified for the product, using a numerical value and its unit of measurement. (defined for API consistency)
    property firstDose : TFhirQuantity read FFirstDose write SetFirstDose;
    // The first dose (dose quantity) administered can be specified for the product, using a numerical value and its unit of measurement.
    property firstDoseElement : TFhirQuantity read FFirstDose write SetFirstDose;

    // Typed access to The maximum single dose that can be administered, specified using a numerical value and its unit of measurement. (defined for API consistency)
    property maxSingleDose : TFhirQuantity read FMaxSingleDose write SetMaxSingleDose;
    // The maximum single dose that can be administered, specified using a numerical value and its unit of measurement.
    property maxSingleDoseElement : TFhirQuantity read FMaxSingleDose write SetMaxSingleDose;

    // Typed access to The maximum dose per day (maximum dose quantity to be administered in any one 24-h period) that can be administered. (defined for API consistency)
    property maxDosePerDay : TFhirQuantity read FMaxDosePerDay write SetMaxDosePerDay;
    // The maximum dose per day (maximum dose quantity to be administered in any one 24-h period) that can be administered.
    property maxDosePerDayElement : TFhirQuantity read FMaxDosePerDay write SetMaxDosePerDay;

    // Typed access to The maximum dose per treatment period that can be administered. (defined for API consistency)
    property maxDosePerTreatmentPeriod : TFhirRatio read FMaxDosePerTreatmentPeriod write SetMaxDosePerTreatmentPeriod;
    // The maximum dose per treatment period that can be administered.
    property maxDosePerTreatmentPeriodElement : TFhirRatio read FMaxDosePerTreatmentPeriod write SetMaxDosePerTreatmentPeriod;

    // Typed access to The maximum treatment period during which the product can be administered. (defined for API consistency)
    property maxTreatmentPeriod : TFhirDuration read FMaxTreatmentPeriod write SetMaxTreatmentPeriod;
    // The maximum treatment period during which the product can be administered.
    property maxTreatmentPeriodElement : TFhirDuration read FMaxTreatmentPeriod write SetMaxTreatmentPeriod;

    // A species for which this route applies.
    property targetSpeciesList : TFhirAdministrableProductDefinitionRouteOfAdministrationTargetSpeciesList read GetTargetSpeciesList;
    property hasTargetSpeciesList : boolean read GetHasTargetSpeciesList;

  end;

  TFhirAdministrableProductDefinitionRouteOfAdministrationListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirAdministrableProductDefinitionRouteOfAdministrationList;
    function GetCurrent : TFhirAdministrableProductDefinitionRouteOfAdministration;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirAdministrableProductDefinitionRouteOfAdministrationList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirAdministrableProductDefinitionRouteOfAdministration read GetCurrent;
  end;

  TFhirAdministrableProductDefinitionRouteOfAdministrationList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirAdministrableProductDefinitionRouteOfAdministration;
    procedure SetItemN(index : Integer; value : TFhirAdministrableProductDefinitionRouteOfAdministration);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirAdministrableProductDefinitionRouteOfAdministrationList; overload;
    function Clone : TFhirAdministrableProductDefinitionRouteOfAdministrationList; overload;
    function GetEnumerator : TFhirAdministrableProductDefinitionRouteOfAdministrationListEnumerator;
    
    //  Add a FhirAdministrableProductDefinitionRouteOfAdministration to the end of the list.
    function Append : TFhirAdministrableProductDefinitionRouteOfAdministration;
    
    // Add an already existing FhirAdministrableProductDefinitionRouteOfAdministration to the end of the list.
    function AddItem(value : TFhirAdministrableProductDefinitionRouteOfAdministration) : TFhirAdministrableProductDefinitionRouteOfAdministration; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirAdministrableProductDefinitionRouteOfAdministration) : Integer;
    
    // Insert FhirAdministrableProductDefinitionRouteOfAdministration before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirAdministrableProductDefinitionRouteOfAdministration;
    
    // Insert an existing FhirAdministrableProductDefinitionRouteOfAdministration before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirAdministrableProductDefinitionRouteOfAdministration);
    
    // Get the iIndexth FhirAdministrableProductDefinitionRouteOfAdministration. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirAdministrableProductDefinitionRouteOfAdministration);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirAdministrableProductDefinitionRouteOfAdministration;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirAdministrableProductDefinitionRouteOfAdministrations[index : Integer] : TFhirAdministrableProductDefinitionRouteOfAdministration read GetItemN write SetItemN; default;
  End;

  // A species for which this route applies.
  TFhirAdministrableProductDefinitionRouteOfAdministrationTargetSpecies = class (TFhirBackboneElement)
  protected
    FCode : TFhirCodeableConcept;
    FwithdrawalPeriodList : TFhirAdministrableProductDefinitionRouteOfAdministrationTargetSpeciesWithdrawalPeriodList;
    procedure SetCode(value : TFhirCodeableConcept);
    function GetWithdrawalPeriodList : TFhirAdministrableProductDefinitionRouteOfAdministrationTargetSpeciesWithdrawalPeriodList;
    function GetHasWithdrawalPeriodList : Boolean;
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirAdministrableProductDefinitionRouteOfAdministrationTargetSpecies; overload;
    function Clone : TFhirAdministrableProductDefinitionRouteOfAdministrationTargetSpecies; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to Coded expression for the species. (defined for API consistency)
    property code : TFhirCodeableConcept read FCode write SetCode;
    // Coded expression for the species.
    property codeElement : TFhirCodeableConcept read FCode write SetCode;

    // A species specific time during which consumption of animal product is not appropriate.
    property withdrawalPeriodList : TFhirAdministrableProductDefinitionRouteOfAdministrationTargetSpeciesWithdrawalPeriodList read GetWithdrawalPeriodList;
    property hasWithdrawalPeriodList : boolean read GetHasWithdrawalPeriodList;

  end;

  TFhirAdministrableProductDefinitionRouteOfAdministrationTargetSpeciesListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirAdministrableProductDefinitionRouteOfAdministrationTargetSpeciesList;
    function GetCurrent : TFhirAdministrableProductDefinitionRouteOfAdministrationTargetSpecies;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirAdministrableProductDefinitionRouteOfAdministrationTargetSpeciesList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirAdministrableProductDefinitionRouteOfAdministrationTargetSpecies read GetCurrent;
  end;

  TFhirAdministrableProductDefinitionRouteOfAdministrationTargetSpeciesList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirAdministrableProductDefinitionRouteOfAdministrationTargetSpecies;
    procedure SetItemN(index : Integer; value : TFhirAdministrableProductDefinitionRouteOfAdministrationTargetSpecies);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirAdministrableProductDefinitionRouteOfAdministrationTargetSpeciesList; overload;
    function Clone : TFhirAdministrableProductDefinitionRouteOfAdministrationTargetSpeciesList; overload;
    function GetEnumerator : TFhirAdministrableProductDefinitionRouteOfAdministrationTargetSpeciesListEnumerator;
    
    //  Add a FhirAdministrableProductDefinitionRouteOfAdministrationTargetSpecies to the end of the list.
    function Append : TFhirAdministrableProductDefinitionRouteOfAdministrationTargetSpecies;
    
    // Add an already existing FhirAdministrableProductDefinitionRouteOfAdministrationTargetSpecies to the end of the list.
    function AddItem(value : TFhirAdministrableProductDefinitionRouteOfAdministrationTargetSpecies) : TFhirAdministrableProductDefinitionRouteOfAdministrationTargetSpecies; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirAdministrableProductDefinitionRouteOfAdministrationTargetSpecies) : Integer;
    
    // Insert FhirAdministrableProductDefinitionRouteOfAdministrationTargetSpecies before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirAdministrableProductDefinitionRouteOfAdministrationTargetSpecies;
    
    // Insert an existing FhirAdministrableProductDefinitionRouteOfAdministrationTargetSpecies before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirAdministrableProductDefinitionRouteOfAdministrationTargetSpecies);
    
    // Get the iIndexth FhirAdministrableProductDefinitionRouteOfAdministrationTargetSpecies. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirAdministrableProductDefinitionRouteOfAdministrationTargetSpecies);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirAdministrableProductDefinitionRouteOfAdministrationTargetSpecies;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirAdministrableProductDefinitionRouteOfAdministrationTargetSpecies[index : Integer] : TFhirAdministrableProductDefinitionRouteOfAdministrationTargetSpecies read GetItemN write SetItemN; default;
  End;

  // A species specific time during which consumption of animal product is not appropriate.
  TFhirAdministrableProductDefinitionRouteOfAdministrationTargetSpeciesWithdrawalPeriod = class (TFhirBackboneElement)
  protected
    FTissue : TFhirCodeableConcept;
    FValue : TFhirQuantity;
    FSupportingInformation : TFhirString;
    procedure SetTissue(value : TFhirCodeableConcept);
    procedure SetValue(value : TFhirQuantity);
    procedure SetSupportingInformation(value : TFhirString);
    function GetSupportingInformationST : String;
    procedure SetSupportingInformationST(value : String);
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirAdministrableProductDefinitionRouteOfAdministrationTargetSpeciesWithdrawalPeriod; overload;
    function Clone : TFhirAdministrableProductDefinitionRouteOfAdministrationTargetSpeciesWithdrawalPeriod; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to Coded expression for the type of tissue for which the withdrawal period applies, e.g. meat, milk. (defined for API consistency)
    property tissue : TFhirCodeableConcept read FTissue write SetTissue;
    // Coded expression for the type of tissue for which the withdrawal period applies, e.g. meat, milk.
    property tissueElement : TFhirCodeableConcept read FTissue write SetTissue;

    // Typed access to A value for the time. (defined for API consistency)
    property value : TFhirQuantity read FValue write SetValue;
    // A value for the time.
    property valueElement : TFhirQuantity read FValue write SetValue;

    // Typed access to Extra information about the withdrawal period.
    property supportingInformation : String read GetSupportingInformationST write SetSupportingInformationST;
    // Extra information about the withdrawal period.
    property supportingInformationElement : TFhirString read FSupportingInformation write SetSupportingInformation;

  end;

  TFhirAdministrableProductDefinitionRouteOfAdministrationTargetSpeciesWithdrawalPeriodListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirAdministrableProductDefinitionRouteOfAdministrationTargetSpeciesWithdrawalPeriodList;
    function GetCurrent : TFhirAdministrableProductDefinitionRouteOfAdministrationTargetSpeciesWithdrawalPeriod;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirAdministrableProductDefinitionRouteOfAdministrationTargetSpeciesWithdrawalPeriodList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirAdministrableProductDefinitionRouteOfAdministrationTargetSpeciesWithdrawalPeriod read GetCurrent;
  end;

  TFhirAdministrableProductDefinitionRouteOfAdministrationTargetSpeciesWithdrawalPeriodList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirAdministrableProductDefinitionRouteOfAdministrationTargetSpeciesWithdrawalPeriod;
    procedure SetItemN(index : Integer; value : TFhirAdministrableProductDefinitionRouteOfAdministrationTargetSpeciesWithdrawalPeriod);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirAdministrableProductDefinitionRouteOfAdministrationTargetSpeciesWithdrawalPeriodList; overload;
    function Clone : TFhirAdministrableProductDefinitionRouteOfAdministrationTargetSpeciesWithdrawalPeriodList; overload;
    function GetEnumerator : TFhirAdministrableProductDefinitionRouteOfAdministrationTargetSpeciesWithdrawalPeriodListEnumerator;
    
    //  Add a FhirAdministrableProductDefinitionRouteOfAdministrationTargetSpeciesWithdrawalPeriod to the end of the list.
    function Append : TFhirAdministrableProductDefinitionRouteOfAdministrationTargetSpeciesWithdrawalPeriod;
    
    // Add an already existing FhirAdministrableProductDefinitionRouteOfAdministrationTargetSpeciesWithdrawalPeriod to the end of the list.
    function AddItem(value : TFhirAdministrableProductDefinitionRouteOfAdministrationTargetSpeciesWithdrawalPeriod) : TFhirAdministrableProductDefinitionRouteOfAdministrationTargetSpeciesWithdrawalPeriod; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirAdministrableProductDefinitionRouteOfAdministrationTargetSpeciesWithdrawalPeriod) : Integer;
    
    // Insert FhirAdministrableProductDefinitionRouteOfAdministrationTargetSpeciesWithdrawalPeriod before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirAdministrableProductDefinitionRouteOfAdministrationTargetSpeciesWithdrawalPeriod;
    
    // Insert an existing FhirAdministrableProductDefinitionRouteOfAdministrationTargetSpeciesWithdrawalPeriod before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirAdministrableProductDefinitionRouteOfAdministrationTargetSpeciesWithdrawalPeriod);
    
    // Get the iIndexth FhirAdministrableProductDefinitionRouteOfAdministrationTargetSpeciesWithdrawalPeriod. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirAdministrableProductDefinitionRouteOfAdministrationTargetSpeciesWithdrawalPeriod);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirAdministrableProductDefinitionRouteOfAdministrationTargetSpeciesWithdrawalPeriod;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirAdministrableProductDefinitionRouteOfAdministrationTargetSpeciesWithdrawalPeriods[index : Integer] : TFhirAdministrableProductDefinitionRouteOfAdministrationTargetSpeciesWithdrawalPeriod read GetItemN write SetItemN; default;
  End;

  // A medicinal product in the final form which is suitable for administering to a patient (after any mixing of multiple components, dissolution etc. has been performed).
  TFhirAdministrableProductDefinition = class (TFhirDomainResource)
  protected
    FidentifierList : TFhirIdentifierList;
    FStatus : TFhirEnum;
    FformOfList : TFhirReferenceList;
    FAdministrableDoseForm : TFhirCodeableConcept;
    FUnitOfPresentation : TFhirCodeableConcept;
    FproducedFromList : TFhirReferenceList;
    FingredientList : TFhirCodeableConceptList;
    FDevice : TFhirReference;
    Fproperty_List : TFhirAdministrableProductDefinitionPropertyList;
    FrouteOfAdministrationList : TFhirAdministrableProductDefinitionRouteOfAdministrationList;
    function GetIdentifierList : TFhirIdentifierList;
    function GetHasIdentifierList : Boolean;
    procedure SetStatus(value : TFhirEnum);
    function GetStatusST : TFhirPublicationStatusEnum;
    procedure SetStatusST(value : TFhirPublicationStatusEnum);
    function GetFormOfList : TFhirReferenceList;
    function GetHasFormOfList : Boolean;
    procedure SetAdministrableDoseForm(value : TFhirCodeableConcept);
    procedure SetUnitOfPresentation(value : TFhirCodeableConcept);
    function GetProducedFromList : TFhirReferenceList;
    function GetHasProducedFromList : Boolean;
    function GetIngredientList : TFhirCodeableConceptList;
    function GetHasIngredientList : Boolean;
    procedure SetDevice(value : TFhirReference);
    function GetProperty_List : TFhirAdministrableProductDefinitionPropertyList;
    function GetHasProperty_List : Boolean;
    function GetRouteOfAdministrationList : TFhirAdministrableProductDefinitionRouteOfAdministrationList;
    function GetHasRouteOfAdministrationList : Boolean;
  
    function GetResourceType : TFhirResourceType; override;
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirAdministrableProductDefinition; overload;
    function Clone : TFhirAdministrableProductDefinition; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // An identifier for the administrable product.
    property identifierList : TFhirIdentifierList read GetIdentifierList;
    property hasIdentifierList : boolean read GetHasIdentifierList;

    // The status of this administrable product. Enables tracking the life-cycle of the content.
    property status : TFhirPublicationStatusEnum read GetStatusST write SetStatusST;
    property statusElement : TFhirEnum read FStatus write SetStatus;

    // References a product from which one or more of the constituent parts of that product can be prepared and used as described by this administrable product.  If this administrable product describes the administration of a crushed tablet, the 'formOf' would be the product representing a distribution containing tablets and possibly also a cream.  This is distinct from the 'producedFrom' which refers to the specific components of the product that are used in this preparation, rather than the product as a whole.
    property formOfList : TFhirReferenceList read GetFormOfList;
    property hasFormOfList : boolean read GetHasFormOfList;

    // Typed access to The dose form of the final product after necessary reconstitution or processing. Contrasts to the manufactured dose form (see ManufacturedItemDefinition). If the manufactured form was 'powder for solution for injection', the administrable dose form could be 'solution for injection' (once mixed with another item having manufactured form 'solvent for solution for injection'). (defined for API consistency)
    property administrableDoseForm : TFhirCodeableConcept read FAdministrableDoseForm write SetAdministrableDoseForm;
    // The dose form of the final product after necessary reconstitution or processing. Contrasts to the manufactured dose form (see ManufacturedItemDefinition). If the manufactured form was 'powder for solution for injection', the administrable dose form could be 'solution for injection' (once mixed with another item having manufactured form 'solvent for solution for injection').
    property administrableDoseFormElement : TFhirCodeableConcept read FAdministrableDoseForm write SetAdministrableDoseForm;

    // Typed access to The presentation type in which this item is given to a patient. e.g. for a spray - 'puff' (as in 'contains 100 mcg per puff'), or for a liquid - 'vial' (as in 'contains 5 ml per vial'). (defined for API consistency)
    property unitOfPresentation : TFhirCodeableConcept read FUnitOfPresentation write SetUnitOfPresentation;
    // The presentation type in which this item is given to a patient. e.g. for a spray - 'puff' (as in 'contains 100 mcg per puff'), or for a liquid - 'vial' (as in 'contains 5 ml per vial').
    property unitOfPresentationElement : TFhirCodeableConcept read FUnitOfPresentation write SetUnitOfPresentation;

    // Indicates the specific manufactured items that are part of the 'formOf' product that are used in the preparation of this specific administrable form.  In some cases, an administrable form might use all of the items from the overall product (or there might only be one item), while in other cases, an administrable form might use only a subset of the items available in the overall product.  For example, an administrable form might involve combining a liquid and a powder available as part of an overall product, but not involve applying the also supplied cream.
    property producedFromList : TFhirReferenceList read GetProducedFromList;
    property hasProducedFromList : boolean read GetHasProducedFromList;

    // The ingredients of this administrable medicinal product. This is only needed if the ingredients are not specified either using ManufacturedItemDefiniton (via AdministrableProductDefinition.producedFrom) to state which component items are used to make this, or using by incoming references from the Ingredient resource, to state in detail which substances exist within this. This element allows a basic coded ingredient to be used.
    property ingredientList : TFhirCodeableConceptList read GetIngredientList;
    property hasIngredientList : boolean read GetHasIngredientList;

    // Typed access to A device that is integral to the medicinal product, in effect being considered as an "ingredient" of the medicinal product. This is not intended for devices that are just co-packaged. (defined for API consistency)
    property device : TFhirReference read FDevice write SetDevice;
    // A device that is integral to the medicinal product, in effect being considered as an "ingredient" of the medicinal product. This is not intended for devices that are just co-packaged.
    property deviceElement : TFhirReference read FDevice write SetDevice;

    // Characteristics e.g. a product's onset of action.
    property property_List : TFhirAdministrableProductDefinitionPropertyList read GetProperty_List;
    property hasProperty_List : boolean read GetHasProperty_List;

    // The path by which the product is taken into or makes contact with the body. In some regions this is referred to as the licenced or approved route. RouteOfAdministration cannot be used when the 'formOf' product already uses MedicinalProductDefinition.route (and vice versa).
    property routeOfAdministrationList : TFhirAdministrableProductDefinitionRouteOfAdministrationList read GetRouteOfAdministrationList;
    property hasRouteOfAdministrationList : boolean read GetHasRouteOfAdministrationList;

  end;

  TFhirAdministrableProductDefinitionListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirAdministrableProductDefinitionList;
    function GetCurrent : TFhirAdministrableProductDefinition;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirAdministrableProductDefinitionList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirAdministrableProductDefinition read GetCurrent;
  end;

  TFhirAdministrableProductDefinitionList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirAdministrableProductDefinition;
    procedure SetItemN(index : Integer; value : TFhirAdministrableProductDefinition);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirAdministrableProductDefinitionList; overload;
    function Clone : TFhirAdministrableProductDefinitionList; overload;
    function GetEnumerator : TFhirAdministrableProductDefinitionListEnumerator;
    
    //  Add a FhirAdministrableProductDefinition to the end of the list.
    function Append : TFhirAdministrableProductDefinition;
    
    // Add an already existing FhirAdministrableProductDefinition to the end of the list.
    function AddItem(value : TFhirAdministrableProductDefinition) : TFhirAdministrableProductDefinition; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirAdministrableProductDefinition) : Integer;
    
    // Insert FhirAdministrableProductDefinition before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirAdministrableProductDefinition;
    
    // Insert an existing FhirAdministrableProductDefinition before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirAdministrableProductDefinition);
    
    // Get the iIndexth FhirAdministrableProductDefinition. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirAdministrableProductDefinition);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirAdministrableProductDefinition;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirAdministrableProductDefinitions[index : Integer] : TFhirAdministrableProductDefinition read GetItemN write SetItemN; default;
  End;

{$ENDIF FHIR_ADMINISTRABLEPRODUCTDEFINITION}
{$IFDEF FHIR_FORMULARYITEM}
  // This resource describes a product or service that is available through a program and includes the conditions and constraints of availability.  All of the information in this resource is specific to the inclusion of the item in the formulary and is not inherent to the item itself.
  TFhirFormularyItem = class (TFhirDomainResource)
  protected
    FidentifierList : TFhirIdentifierList;
    FCode : TFhirCodeableConcept;
    FStatus : TFhirEnum;
    function GetIdentifierList : TFhirIdentifierList;
    function GetHasIdentifierList : Boolean;
    procedure SetCode(value : TFhirCodeableConcept);
    procedure SetStatus(value : TFhirEnum);
    function GetStatusST : TFhirFormularyItemStatusCodesEnum;
    procedure SetStatusST(value : TFhirFormularyItemStatusCodesEnum);
  
    function GetResourceType : TFhirResourceType; override;
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirFormularyItem; overload;
    function Clone : TFhirFormularyItem; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Business identifier for this formulary item.
    property identifierList : TFhirIdentifierList read GetIdentifierList;
    property hasIdentifierList : boolean read GetHasIdentifierList;

    // Typed access to A code (or set of codes) that specify the product or service that is identified by this formulary item. (defined for API consistency)
    property code : TFhirCodeableConcept read FCode write SetCode;
    // A code (or set of codes) that specify the product or service that is identified by this formulary item.
    property codeElement : TFhirCodeableConcept read FCode write SetCode;

    // The validity about the information of the formulary item and not of the underlying product or service itself.
    property status : TFhirFormularyItemStatusCodesEnum read GetStatusST write SetStatusST;
    property statusElement : TFhirEnum read FStatus write SetStatus;

  end;

  TFhirFormularyItemListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirFormularyItemList;
    function GetCurrent : TFhirFormularyItem;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirFormularyItemList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirFormularyItem read GetCurrent;
  end;

  TFhirFormularyItemList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirFormularyItem;
    procedure SetItemN(index : Integer; value : TFhirFormularyItem);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirFormularyItemList; overload;
    function Clone : TFhirFormularyItemList; overload;
    function GetEnumerator : TFhirFormularyItemListEnumerator;
    
    //  Add a FhirFormularyItem to the end of the list.
    function Append : TFhirFormularyItem;
    
    // Add an already existing FhirFormularyItem to the end of the list.
    function AddItem(value : TFhirFormularyItem) : TFhirFormularyItem; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirFormularyItem) : Integer;
    
    // Insert FhirFormularyItem before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirFormularyItem;
    
    // Insert an existing FhirFormularyItem before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirFormularyItem);
    
    // Get the iIndexth FhirFormularyItem. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirFormularyItem);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirFormularyItem;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirFormularyItems[index : Integer] : TFhirFormularyItem read GetItemN write SetItemN; default;
  End;

{$ENDIF FHIR_FORMULARYITEM}
{$IFDEF FHIR_INGREDIENT}
  // The organization(s) that manufacture this ingredient. Can be used to indicate:         1) Organizations we are aware of that manufacture this ingredient         2) Specific Manufacturer(s) currently being used         3) Set of organisations allowed to manufacture this ingredient for this product         Users must be clear on the application of context relevant to their use case.
  TFhirIngredientManufacturer = class (TFhirBackboneElement)
  protected
    FRole : TFhirEnum;
    FManufacturer : TFhirReference;
    procedure SetRole(value : TFhirEnum);
    function GetRoleST : TFhirIngredientManufacturerRoleEnum;
    procedure SetRoleST(value : TFhirIngredientManufacturerRoleEnum);
    procedure SetManufacturer(value : TFhirReference);
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirIngredientManufacturer; overload;
    function Clone : TFhirIngredientManufacturer; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // The way in which this manufacturer is associated with the ingredient. For example whether it is a possible one (others allowed), or an exclusive authorized one for this ingredient. Note that this is not the manufacturing process role.
    property role : TFhirIngredientManufacturerRoleEnum read GetRoleST write SetRoleST;
    property roleElement : TFhirEnum read FRole write SetRole;

    // Typed access to An organization that manufactures this ingredient. (defined for API consistency)
    property manufacturer : TFhirReference read FManufacturer write SetManufacturer;
    // An organization that manufactures this ingredient.
    property manufacturerElement : TFhirReference read FManufacturer write SetManufacturer;

  end;

  TFhirIngredientManufacturerListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirIngredientManufacturerList;
    function GetCurrent : TFhirIngredientManufacturer;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirIngredientManufacturerList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirIngredientManufacturer read GetCurrent;
  end;

  TFhirIngredientManufacturerList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirIngredientManufacturer;
    procedure SetItemN(index : Integer; value : TFhirIngredientManufacturer);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirIngredientManufacturerList; overload;
    function Clone : TFhirIngredientManufacturerList; overload;
    function GetEnumerator : TFhirIngredientManufacturerListEnumerator;
    
    //  Add a FhirIngredientManufacturer to the end of the list.
    function Append : TFhirIngredientManufacturer;
    
    // Add an already existing FhirIngredientManufacturer to the end of the list.
    function AddItem(value : TFhirIngredientManufacturer) : TFhirIngredientManufacturer; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirIngredientManufacturer) : Integer;
    
    // Insert FhirIngredientManufacturer before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirIngredientManufacturer;
    
    // Insert an existing FhirIngredientManufacturer before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirIngredientManufacturer);
    
    // Get the iIndexth FhirIngredientManufacturer. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirIngredientManufacturer);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirIngredientManufacturer;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirIngredientManufacturers[index : Integer] : TFhirIngredientManufacturer read GetItemN write SetItemN; default;
  End;

  // The substance that comprises this ingredient.
  TFhirIngredientSubstance = class (TFhirBackboneElement)
  protected
    FCode : TFhirCodeableReference;
    FstrengthList : TFhirIngredientSubstanceStrengthList;
    procedure SetCode(value : TFhirCodeableReference);
    function GetStrengthList : TFhirIngredientSubstanceStrengthList;
    function GetHasStrengthList : Boolean;
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirIngredientSubstance; overload;
    function Clone : TFhirIngredientSubstance; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to A code or full resource that represents the ingredient's substance. (defined for API consistency)
    property code : TFhirCodeableReference read FCode write SetCode;
    // A code or full resource that represents the ingredient's substance.
    property codeElement : TFhirCodeableReference read FCode write SetCode;

    // The quantity of substance in the unit of presentation, or in the volume (or mass) of the single pharmaceutical product or manufactured item. The allowed repetitions do not represent different strengths, but are different representations - mathematically equivalent - of a single strength.
    property strengthList : TFhirIngredientSubstanceStrengthList read GetStrengthList;
    property hasStrengthList : boolean read GetHasStrengthList;

  end;

  TFhirIngredientSubstanceListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirIngredientSubstanceList;
    function GetCurrent : TFhirIngredientSubstance;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirIngredientSubstanceList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirIngredientSubstance read GetCurrent;
  end;

  TFhirIngredientSubstanceList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirIngredientSubstance;
    procedure SetItemN(index : Integer; value : TFhirIngredientSubstance);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirIngredientSubstanceList; overload;
    function Clone : TFhirIngredientSubstanceList; overload;
    function GetEnumerator : TFhirIngredientSubstanceListEnumerator;
    
    //  Add a FhirIngredientSubstance to the end of the list.
    function Append : TFhirIngredientSubstance;
    
    // Add an already existing FhirIngredientSubstance to the end of the list.
    function AddItem(value : TFhirIngredientSubstance) : TFhirIngredientSubstance; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirIngredientSubstance) : Integer;
    
    // Insert FhirIngredientSubstance before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirIngredientSubstance;
    
    // Insert an existing FhirIngredientSubstance before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirIngredientSubstance);
    
    // Get the iIndexth FhirIngredientSubstance. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirIngredientSubstance);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirIngredientSubstance;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirIngredientSubstances[index : Integer] : TFhirIngredientSubstance read GetItemN write SetItemN; default;
  End;

  // The quantity of substance in the unit of presentation, or in the volume (or mass) of the single pharmaceutical product or manufactured item. The allowed repetitions do not represent different strengths, but are different representations - mathematically equivalent - of a single strength.
  TFhirIngredientSubstanceStrength = class (TFhirBackboneElement)
  protected
    FPresentation : TFhirDataType;
    FTextPresentation : TFhirString;
    FConcentration : TFhirDataType;
    FTextConcentration : TFhirString;
    FBasis : TFhirCodeableConcept;
    FMeasurementPoint : TFhirString;
    FcountryList : TFhirCodeableConceptList;
    FreferenceStrengthList : TFhirIngredientSubstanceStrengthReferenceStrengthList;
    procedure SetPresentation(value : TFhirDataType);
    procedure SetTextPresentation(value : TFhirString);
    function GetTextPresentationST : String;
    procedure SetTextPresentationST(value : String);
    procedure SetConcentration(value : TFhirDataType);
    procedure SetTextConcentration(value : TFhirString);
    function GetTextConcentrationST : String;
    procedure SetTextConcentrationST(value : String);
    procedure SetBasis(value : TFhirCodeableConcept);
    procedure SetMeasurementPoint(value : TFhirString);
    function GetMeasurementPointST : String;
    procedure SetMeasurementPointST(value : String);
    function GetCountryList : TFhirCodeableConceptList;
    function GetHasCountryList : Boolean;
    function GetReferenceStrengthList : TFhirIngredientSubstanceStrengthReferenceStrengthList;
    function GetHasReferenceStrengthList : Boolean;
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirIngredientSubstanceStrength; overload;
    function Clone : TFhirIngredientSubstanceStrength; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to The quantity of substance in the unit of presentation, or in the volume (or mass) of the single pharmaceutical product or manufactured item. Unit of presentation refers to the quantity that the item occurs in e.g. a strength per tablet size, perhaps 'per 20mg' (the size of the tablet). It is not generally normalized as a unitary unit, which would be 'per mg'). (defined for API consistency)
    property presentation : TFhirDataType read FPresentation write SetPresentation;
    // The quantity of substance in the unit of presentation, or in the volume (or mass) of the single pharmaceutical product or manufactured item. Unit of presentation refers to the quantity that the item occurs in e.g. a strength per tablet size, perhaps 'per 20mg' (the size of the tablet). It is not generally normalized as a unitary unit, which would be 'per mg').
    property presentationElement : TFhirDataType read FPresentation write SetPresentation;

    // Typed access to A textual represention of either the whole of the presentation strength or a part of it - with the rest being in Strength.presentation as a ratio.
    property textPresentation : String read GetTextPresentationST write SetTextPresentationST;
    // A textual represention of either the whole of the presentation strength or a part of it - with the rest being in Strength.presentation as a ratio.
    property textPresentationElement : TFhirString read FTextPresentation write SetTextPresentation;

    // Typed access to The strength per unitary volume (or mass). (defined for API consistency)
    property concentration : TFhirDataType read FConcentration write SetConcentration;
    // The strength per unitary volume (or mass).
    property concentrationElement : TFhirDataType read FConcentration write SetConcentration;

    // Typed access to A textual represention of either the whole of the concentration strength or a part of it - with the rest being in Strength.concentration as a ratio.
    property textConcentration : String read GetTextConcentrationST write SetTextConcentrationST;
    // A textual represention of either the whole of the concentration strength or a part of it - with the rest being in Strength.concentration as a ratio.
    property textConcentrationElement : TFhirString read FTextConcentration write SetTextConcentration;

    // Typed access to A code that indicates if the strength is, for example, based on the ingredient substance as stated or on the substance base (when the ingredient is a salt). (defined for API consistency)
    property basis : TFhirCodeableConcept read FBasis write SetBasis;
    // A code that indicates if the strength is, for example, based on the ingredient substance as stated or on the substance base (when the ingredient is a salt).
    property basisElement : TFhirCodeableConcept read FBasis write SetBasis;

    // Typed access to For when strength is measured at a particular point or distance. There are products where strength is measured at a particular point. For example, the strength of the ingredient in some inhalers is measured at a particular position relative to the point of aerosolization.
    property measurementPoint : String read GetMeasurementPointST write SetMeasurementPointST;
    // For when strength is measured at a particular point or distance. There are products where strength is measured at a particular point. For example, the strength of the ingredient in some inhalers is measured at a particular position relative to the point of aerosolization.
    property measurementPointElement : TFhirString read FMeasurementPoint write SetMeasurementPoint;

    // The country or countries for which the strength range applies.
    property countryList : TFhirCodeableConceptList read GetCountryList;
    property hasCountryList : boolean read GetHasCountryList;

    // Strength expressed in terms of a reference substance. For when the ingredient strength is additionally expressed as equivalent to the strength of some other closely related substance (e.g. salt vs. base). Reference strength represents the strength (quantitative composition) of the active moiety of the active substance. There are situations when the active substance and active moiety are different, therefore both a strength and a reference strength are needed.
    property referenceStrengthList : TFhirIngredientSubstanceStrengthReferenceStrengthList read GetReferenceStrengthList;
    property hasReferenceStrengthList : boolean read GetHasReferenceStrengthList;

  end;

  TFhirIngredientSubstanceStrengthListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirIngredientSubstanceStrengthList;
    function GetCurrent : TFhirIngredientSubstanceStrength;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirIngredientSubstanceStrengthList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirIngredientSubstanceStrength read GetCurrent;
  end;

  TFhirIngredientSubstanceStrengthList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirIngredientSubstanceStrength;
    procedure SetItemN(index : Integer; value : TFhirIngredientSubstanceStrength);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirIngredientSubstanceStrengthList; overload;
    function Clone : TFhirIngredientSubstanceStrengthList; overload;
    function GetEnumerator : TFhirIngredientSubstanceStrengthListEnumerator;
    
    //  Add a FhirIngredientSubstanceStrength to the end of the list.
    function Append : TFhirIngredientSubstanceStrength;
    
    // Add an already existing FhirIngredientSubstanceStrength to the end of the list.
    function AddItem(value : TFhirIngredientSubstanceStrength) : TFhirIngredientSubstanceStrength; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirIngredientSubstanceStrength) : Integer;
    
    // Insert FhirIngredientSubstanceStrength before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirIngredientSubstanceStrength;
    
    // Insert an existing FhirIngredientSubstanceStrength before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirIngredientSubstanceStrength);
    
    // Get the iIndexth FhirIngredientSubstanceStrength. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirIngredientSubstanceStrength);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirIngredientSubstanceStrength;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirIngredientSubstanceStrengths[index : Integer] : TFhirIngredientSubstanceStrength read GetItemN write SetItemN; default;
  End;

  // Strength expressed in terms of a reference substance. For when the ingredient strength is additionally expressed as equivalent to the strength of some other closely related substance (e.g. salt vs. base). Reference strength represents the strength (quantitative composition) of the active moiety of the active substance. There are situations when the active substance and active moiety are different, therefore both a strength and a reference strength are needed.
  TFhirIngredientSubstanceStrengthReferenceStrength = class (TFhirBackboneElement)
  protected
    FSubstance : TFhirCodeableReference;
    FStrength : TFhirDataType;
    FMeasurementPoint : TFhirString;
    FcountryList : TFhirCodeableConceptList;
    procedure SetSubstance(value : TFhirCodeableReference);
    procedure SetStrength(value : TFhirDataType);
    procedure SetMeasurementPoint(value : TFhirString);
    function GetMeasurementPointST : String;
    procedure SetMeasurementPointST(value : String);
    function GetCountryList : TFhirCodeableConceptList;
    function GetHasCountryList : Boolean;
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirIngredientSubstanceStrengthReferenceStrength; overload;
    function Clone : TFhirIngredientSubstanceStrengthReferenceStrength; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to Relevant reference substance. (defined for API consistency)
    property substance : TFhirCodeableReference read FSubstance write SetSubstance;
    // Relevant reference substance.
    property substanceElement : TFhirCodeableReference read FSubstance write SetSubstance;

    // Typed access to Strength expressed in terms of a reference substance. (defined for API consistency)
    property strength : TFhirDataType read FStrength write SetStrength;
    // Strength expressed in terms of a reference substance.
    property strengthElement : TFhirDataType read FStrength write SetStrength;

    // Typed access to For when strength is measured at a particular point or distance.
    property measurementPoint : String read GetMeasurementPointST write SetMeasurementPointST;
    // For when strength is measured at a particular point or distance.
    property measurementPointElement : TFhirString read FMeasurementPoint write SetMeasurementPoint;

    // The country or countries for which the strength range applies.
    property countryList : TFhirCodeableConceptList read GetCountryList;
    property hasCountryList : boolean read GetHasCountryList;

  end;

  TFhirIngredientSubstanceStrengthReferenceStrengthListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirIngredientSubstanceStrengthReferenceStrengthList;
    function GetCurrent : TFhirIngredientSubstanceStrengthReferenceStrength;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirIngredientSubstanceStrengthReferenceStrengthList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirIngredientSubstanceStrengthReferenceStrength read GetCurrent;
  end;

  TFhirIngredientSubstanceStrengthReferenceStrengthList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirIngredientSubstanceStrengthReferenceStrength;
    procedure SetItemN(index : Integer; value : TFhirIngredientSubstanceStrengthReferenceStrength);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirIngredientSubstanceStrengthReferenceStrengthList; overload;
    function Clone : TFhirIngredientSubstanceStrengthReferenceStrengthList; overload;
    function GetEnumerator : TFhirIngredientSubstanceStrengthReferenceStrengthListEnumerator;
    
    //  Add a FhirIngredientSubstanceStrengthReferenceStrength to the end of the list.
    function Append : TFhirIngredientSubstanceStrengthReferenceStrength;
    
    // Add an already existing FhirIngredientSubstanceStrengthReferenceStrength to the end of the list.
    function AddItem(value : TFhirIngredientSubstanceStrengthReferenceStrength) : TFhirIngredientSubstanceStrengthReferenceStrength; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirIngredientSubstanceStrengthReferenceStrength) : Integer;
    
    // Insert FhirIngredientSubstanceStrengthReferenceStrength before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirIngredientSubstanceStrengthReferenceStrength;
    
    // Insert an existing FhirIngredientSubstanceStrengthReferenceStrength before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirIngredientSubstanceStrengthReferenceStrength);
    
    // Get the iIndexth FhirIngredientSubstanceStrengthReferenceStrength. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirIngredientSubstanceStrengthReferenceStrength);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirIngredientSubstanceStrengthReferenceStrength;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirIngredientSubstanceStrengthReferenceStrengths[index : Integer] : TFhirIngredientSubstanceStrengthReferenceStrength read GetItemN write SetItemN; default;
  End;

  // An ingredient of a manufactured item or pharmaceutical product.
  TFhirIngredient = class (TFhirDomainResource)
  protected
    FIdentifier : TFhirIdentifier;
    FStatus : TFhirEnum;
    Ffor_List : TFhirReferenceList;
    FRole : TFhirCodeableConcept;
    Ffunction_List : TFhirCodeableConceptList;
    FGroup : TFhirCodeableConcept;
    FAllergenicIndicator : TFhirBoolean;
    FmanufacturerList : TFhirIngredientManufacturerList;
    FSubstance : TFhirIngredientSubstance;
    procedure SetIdentifier(value : TFhirIdentifier);
    procedure SetStatus(value : TFhirEnum);
    function GetStatusST : TFhirPublicationStatusEnum;
    procedure SetStatusST(value : TFhirPublicationStatusEnum);
    function GetFor_List : TFhirReferenceList;
    function GetHasFor_List : Boolean;
    procedure SetRole(value : TFhirCodeableConcept);
    function GetFunction_List : TFhirCodeableConceptList;
    function GetHasFunction_List : Boolean;
    procedure SetGroup(value : TFhirCodeableConcept);
    procedure SetAllergenicIndicator(value : TFhirBoolean);
    function GetAllergenicIndicatorST : Boolean;
    procedure SetAllergenicIndicatorST(value : Boolean);
    function GetManufacturerList : TFhirIngredientManufacturerList;
    function GetHasManufacturerList : Boolean;
    procedure SetSubstance(value : TFhirIngredientSubstance);
  
    function GetResourceType : TFhirResourceType; override;
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirIngredient; overload;
    function Clone : TFhirIngredient; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to The identifier(s) of this Ingredient that are assigned by business processes and/or used to refer to it when a direct URL reference to the resource itself is not appropriate. (defined for API consistency)
    property identifier : TFhirIdentifier read FIdentifier write SetIdentifier;
    // The identifier(s) of this Ingredient that are assigned by business processes and/or used to refer to it when a direct URL reference to the resource itself is not appropriate.
    property identifierElement : TFhirIdentifier read FIdentifier write SetIdentifier;

    // The status of this ingredient. Enables tracking the life-cycle of the content.
    property status : TFhirPublicationStatusEnum read GetStatusST write SetStatusST;
    property statusElement : TFhirEnum read FStatus write SetStatus;

    // The product which this ingredient is a constituent part of.
    property for_List : TFhirReferenceList read GetFor_List;
    property hasFor_List : boolean read GetHasFor_List;

    // Typed access to A classification of the ingredient identifying its purpose within the product, e.g. active, inactive. (defined for API consistency)
    property role : TFhirCodeableConcept read FRole write SetRole;
    // A classification of the ingredient identifying its purpose within the product, e.g. active, inactive.
    property roleElement : TFhirCodeableConcept read FRole write SetRole;

    // A classification of the ingredient identifying its precise purpose(s) in the drug product. This extends the Ingredient.role to add more detail. Example: antioxidant, alkalizing agent.
    property function_List : TFhirCodeableConceptList read GetFunction_List;
    property hasFunction_List : boolean read GetHasFunction_List;

    // Typed access to A classification of the ingredient according to where in the physical item it tends to be used, such the outer shell of a tablet, inner body or ink. (defined for API consistency)
    property group : TFhirCodeableConcept read FGroup write SetGroup;
    // A classification of the ingredient according to where in the physical item it tends to be used, such the outer shell of a tablet, inner body or ink.
    property groupElement : TFhirCodeableConcept read FGroup write SetGroup;

    // Typed access to If the ingredient is a known or suspected allergen. Note that this is a property of the substance, so if a reference to a SubstanceDefinition is used to decribe that (rather than just a code), the allergen information should go there, not here.
    property allergenicIndicator : Boolean read GetAllergenicIndicatorST write SetAllergenicIndicatorST;
    // If the ingredient is a known or suspected allergen. Note that this is a property of the substance, so if a reference to a SubstanceDefinition is used to decribe that (rather than just a code), the allergen information should go there, not here.
    property allergenicIndicatorElement : TFhirBoolean read FAllergenicIndicator write SetAllergenicIndicator;

    // The organization(s) that manufacture this ingredient. Can be used to indicate:         1) Organizations we are aware of that manufacture this ingredient         2) Specific Manufacturer(s) currently being used         3) Set of organisations allowed to manufacture this ingredient for this product         Users must be clear on the application of context relevant to their use case.
    property manufacturerList : TFhirIngredientManufacturerList read GetManufacturerList;
    property hasManufacturerList : boolean read GetHasManufacturerList;

    // Typed access to The substance that comprises this ingredient. (defined for API consistency)
    property substance : TFhirIngredientSubstance read FSubstance write SetSubstance;
    // The substance that comprises this ingredient.
    property substanceElement : TFhirIngredientSubstance read FSubstance write SetSubstance;

  end;

  TFhirIngredientListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirIngredientList;
    function GetCurrent : TFhirIngredient;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirIngredientList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirIngredient read GetCurrent;
  end;

  TFhirIngredientList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirIngredient;
    procedure SetItemN(index : Integer; value : TFhirIngredient);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirIngredientList; overload;
    function Clone : TFhirIngredientList; overload;
    function GetEnumerator : TFhirIngredientListEnumerator;
    
    //  Add a FhirIngredient to the end of the list.
    function Append : TFhirIngredient;
    
    // Add an already existing FhirIngredient to the end of the list.
    function AddItem(value : TFhirIngredient) : TFhirIngredient; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirIngredient) : Integer;
    
    // Insert FhirIngredient before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirIngredient;
    
    // Insert an existing FhirIngredient before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirIngredient);
    
    // Get the iIndexth FhirIngredient. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirIngredient);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirIngredient;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirIngredients[index : Integer] : TFhirIngredient read GetItemN write SetItemN; default;
  End;

{$ENDIF FHIR_INGREDIENT}
{$IFDEF FHIR_MANUFACTUREDITEMDEFINITION}
  // General characteristics of this item.
  TFhirManufacturedItemDefinitionProperty = class (TFhirBackboneElement)
  protected
    FType_ : TFhirCodeableConcept;
    FValue : TFhirDataType;
    procedure SetType_(value : TFhirCodeableConcept);
    procedure SetValue(value : TFhirDataType);
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirManufacturedItemDefinitionProperty; overload;
    function Clone : TFhirManufacturedItemDefinitionProperty; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to A code expressing the type of characteristic. (defined for API consistency)
    property type_ : TFhirCodeableConcept read FType_ write SetType_;
    // A code expressing the type of characteristic.
    property type_Element : TFhirCodeableConcept read FType_ write SetType_;

    // Typed access to A value for the characteristic. (defined for API consistency)
    property value : TFhirDataType read FValue write SetValue;
    // A value for the characteristic.
    property valueElement : TFhirDataType read FValue write SetValue;

  end;

  TFhirManufacturedItemDefinitionPropertyListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirManufacturedItemDefinitionPropertyList;
    function GetCurrent : TFhirManufacturedItemDefinitionProperty;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirManufacturedItemDefinitionPropertyList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirManufacturedItemDefinitionProperty read GetCurrent;
  end;

  TFhirManufacturedItemDefinitionPropertyList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirManufacturedItemDefinitionProperty;
    procedure SetItemN(index : Integer; value : TFhirManufacturedItemDefinitionProperty);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirManufacturedItemDefinitionPropertyList; overload;
    function Clone : TFhirManufacturedItemDefinitionPropertyList; overload;
    function GetEnumerator : TFhirManufacturedItemDefinitionPropertyListEnumerator;
    
    //  Add a FhirManufacturedItemDefinitionProperty to the end of the list.
    function Append : TFhirManufacturedItemDefinitionProperty;
    
    // Add an already existing FhirManufacturedItemDefinitionProperty to the end of the list.
    function AddItem(value : TFhirManufacturedItemDefinitionProperty) : TFhirManufacturedItemDefinitionProperty; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirManufacturedItemDefinitionProperty) : Integer;
    
    // Insert FhirManufacturedItemDefinitionProperty before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirManufacturedItemDefinitionProperty;
    
    // Insert an existing FhirManufacturedItemDefinitionProperty before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirManufacturedItemDefinitionProperty);
    
    // Get the iIndexth FhirManufacturedItemDefinitionProperty. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirManufacturedItemDefinitionProperty);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirManufacturedItemDefinitionProperty;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirManufacturedItemDefinitionProperties[index : Integer] : TFhirManufacturedItemDefinitionProperty read GetItemN write SetItemN; default;
  End;

  // Physical parts of the manufactured item, that it is intrisically made from. This is distinct from the ingredients that are part of its chemical makeup.
  TFhirManufacturedItemDefinitionComponent = class (TFhirBackboneElement)
  protected
    FType_ : TFhirCodeableConcept;
    Ffunction_List : TFhirCodeableConceptList;
    FamountList : TFhirQuantityList;
    FconstituentList : TFhirManufacturedItemDefinitionComponentConstituentList;
    Fproperty_List : TFhirManufacturedItemDefinitionPropertyList;
    FcomponentList : TFhirManufacturedItemDefinitionComponentList;
    procedure SetType_(value : TFhirCodeableConcept);
    function GetFunction_List : TFhirCodeableConceptList;
    function GetHasFunction_List : Boolean;
    function GetAmountList : TFhirQuantityList;
    function GetHasAmountList : Boolean;
    function GetConstituentList : TFhirManufacturedItemDefinitionComponentConstituentList;
    function GetHasConstituentList : Boolean;
    function GetProperty_List : TFhirManufacturedItemDefinitionPropertyList;
    function GetHasProperty_List : Boolean;
    function GetComponentList : TFhirManufacturedItemDefinitionComponentList;
    function GetHasComponentList : Boolean;
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirManufacturedItemDefinitionComponent; overload;
    function Clone : TFhirManufacturedItemDefinitionComponent; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to Defining type of the component e.g. shell, layer, ink. (defined for API consistency)
    property type_ : TFhirCodeableConcept read FType_ write SetType_;
    // Defining type of the component e.g. shell, layer, ink.
    property type_Element : TFhirCodeableConcept read FType_ write SetType_;

    // The function of this component within the item e.g. delivers active ingredient, masks taste.
    property function_List : TFhirCodeableConceptList read GetFunction_List;
    property hasFunction_List : boolean read GetHasFunction_List;

    // The measurable amount of substance in this component, expressable in different ways (e.g. by mass or volume).
    property amountList : TFhirQuantityList read GetAmountList;
    property hasAmountList : boolean read GetHasAmountList;

    // A reference to an constituent of the manufactured item as a whole, linked here so that its component location within the item can be indicated. This not where the item's ingredient are primarily stated (for which see Ingredient.for or ManufacturedItemDefinition.ingredient).
    property constituentList : TFhirManufacturedItemDefinitionComponentConstituentList read GetConstituentList;
    property hasConstituentList : boolean read GetHasConstituentList;

    // General characteristics of this component.
    property property_List : TFhirManufacturedItemDefinitionPropertyList read GetProperty_List;
    property hasProperty_List : boolean read GetHasProperty_List;

    // A component that this component contains or is made from.
    property componentList : TFhirManufacturedItemDefinitionComponentList read GetComponentList;
    property hasComponentList : boolean read GetHasComponentList;

  end;

  TFhirManufacturedItemDefinitionComponentListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirManufacturedItemDefinitionComponentList;
    function GetCurrent : TFhirManufacturedItemDefinitionComponent;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirManufacturedItemDefinitionComponentList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirManufacturedItemDefinitionComponent read GetCurrent;
  end;

  TFhirManufacturedItemDefinitionComponentList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirManufacturedItemDefinitionComponent;
    procedure SetItemN(index : Integer; value : TFhirManufacturedItemDefinitionComponent);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirManufacturedItemDefinitionComponentList; overload;
    function Clone : TFhirManufacturedItemDefinitionComponentList; overload;
    function GetEnumerator : TFhirManufacturedItemDefinitionComponentListEnumerator;
    
    //  Add a FhirManufacturedItemDefinitionComponent to the end of the list.
    function Append : TFhirManufacturedItemDefinitionComponent;
    
    // Add an already existing FhirManufacturedItemDefinitionComponent to the end of the list.
    function AddItem(value : TFhirManufacturedItemDefinitionComponent) : TFhirManufacturedItemDefinitionComponent; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirManufacturedItemDefinitionComponent) : Integer;
    
    // Insert FhirManufacturedItemDefinitionComponent before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirManufacturedItemDefinitionComponent;
    
    // Insert an existing FhirManufacturedItemDefinitionComponent before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirManufacturedItemDefinitionComponent);
    
    // Get the iIndexth FhirManufacturedItemDefinitionComponent. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirManufacturedItemDefinitionComponent);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirManufacturedItemDefinitionComponent;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirManufacturedItemDefinitionComponents[index : Integer] : TFhirManufacturedItemDefinitionComponent read GetItemN write SetItemN; default;
  End;

  // A reference to an constituent of the manufactured item as a whole, linked here so that its component location within the item can be indicated. This not where the item's ingredient are primarily stated (for which see Ingredient.for or ManufacturedItemDefinition.ingredient).
  TFhirManufacturedItemDefinitionComponentConstituent = class (TFhirBackboneElement)
  protected
    FamountList : TFhirQuantityList;
    FlocationList : TFhirCodeableConceptList;
    Ffunction_List : TFhirCodeableConceptList;
    FlocationForIngredientList : TFhirCodeableReferenceList;
    function GetAmountList : TFhirQuantityList;
    function GetHasAmountList : Boolean;
    function GetLocationList : TFhirCodeableConceptList;
    function GetHasLocationList : Boolean;
    function GetFunction_List : TFhirCodeableConceptList;
    function GetHasFunction_List : Boolean;
    function GetLocationForIngredientList : TFhirCodeableReferenceList;
    function GetHasLocationForIngredientList : Boolean;
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirManufacturedItemDefinitionComponentConstituent; overload;
    function Clone : TFhirManufacturedItemDefinitionComponentConstituent; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // The measurable amount of this constituent in this component, expressable in different ways (e.g. by mass or volume).
    property amountList : TFhirQuantityList read GetAmountList;
    property hasAmountList : boolean read GetHasAmountList;

    // The type of location of the constituent within this component e.g. intragranular, blend.
    property locationList : TFhirCodeableConceptList read GetLocationList;
    property hasLocationList : boolean read GetHasLocationList;

    // The function of this constituent within the component e.g. binder.
    property function_List : TFhirCodeableConceptList read GetFunction_List;
    property hasFunction_List : boolean read GetHasFunction_List;

    // An ingredient that this component is the location for in this manufactured item. The component is physically made of this ingredient (and possibly others), rather than just being a container for it.
    property locationForIngredientList : TFhirCodeableReferenceList read GetLocationForIngredientList;
    property hasLocationForIngredientList : boolean read GetHasLocationForIngredientList;

  end;

  TFhirManufacturedItemDefinitionComponentConstituentListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirManufacturedItemDefinitionComponentConstituentList;
    function GetCurrent : TFhirManufacturedItemDefinitionComponentConstituent;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirManufacturedItemDefinitionComponentConstituentList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirManufacturedItemDefinitionComponentConstituent read GetCurrent;
  end;

  TFhirManufacturedItemDefinitionComponentConstituentList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirManufacturedItemDefinitionComponentConstituent;
    procedure SetItemN(index : Integer; value : TFhirManufacturedItemDefinitionComponentConstituent);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirManufacturedItemDefinitionComponentConstituentList; overload;
    function Clone : TFhirManufacturedItemDefinitionComponentConstituentList; overload;
    function GetEnumerator : TFhirManufacturedItemDefinitionComponentConstituentListEnumerator;
    
    //  Add a FhirManufacturedItemDefinitionComponentConstituent to the end of the list.
    function Append : TFhirManufacturedItemDefinitionComponentConstituent;
    
    // Add an already existing FhirManufacturedItemDefinitionComponentConstituent to the end of the list.
    function AddItem(value : TFhirManufacturedItemDefinitionComponentConstituent) : TFhirManufacturedItemDefinitionComponentConstituent; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirManufacturedItemDefinitionComponentConstituent) : Integer;
    
    // Insert FhirManufacturedItemDefinitionComponentConstituent before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirManufacturedItemDefinitionComponentConstituent;
    
    // Insert an existing FhirManufacturedItemDefinitionComponentConstituent before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirManufacturedItemDefinitionComponentConstituent);
    
    // Get the iIndexth FhirManufacturedItemDefinitionComponentConstituent. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirManufacturedItemDefinitionComponentConstituent);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirManufacturedItemDefinitionComponentConstituent;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirManufacturedItemDefinitionComponentConstituents[index : Integer] : TFhirManufacturedItemDefinitionComponentConstituent read GetItemN write SetItemN; default;
  End;

  // The definition and characteristics of a medicinal manufactured item, such as a tablet or capsule, as contained in a packaged medicinal product.
  TFhirManufacturedItemDefinition = class (TFhirDomainResource)
  protected
    FidentifierList : TFhirIdentifierList;
    FStatus : TFhirEnum;
    FName : TFhirString;
    FManufacturedDoseForm : TFhirCodeableConcept;
    FUnitOfPresentation : TFhirCodeableConcept;
    FmanufacturerList : TFhirReferenceList;
    FmarketingStatusList : TFhirMarketingStatusList;
    FingredientList : TFhirCodeableConceptList;
    Fproperty_List : TFhirManufacturedItemDefinitionPropertyList;
    FcomponentList : TFhirManufacturedItemDefinitionComponentList;
    function GetIdentifierList : TFhirIdentifierList;
    function GetHasIdentifierList : Boolean;
    procedure SetStatus(value : TFhirEnum);
    function GetStatusST : TFhirPublicationStatusEnum;
    procedure SetStatusST(value : TFhirPublicationStatusEnum);
    procedure SetName(value : TFhirString);
    function GetNameST : String;
    procedure SetNameST(value : String);
    procedure SetManufacturedDoseForm(value : TFhirCodeableConcept);
    procedure SetUnitOfPresentation(value : TFhirCodeableConcept);
    function GetManufacturerList : TFhirReferenceList;
    function GetHasManufacturerList : Boolean;
    function GetMarketingStatusList : TFhirMarketingStatusList;
    function GetHasMarketingStatusList : Boolean;
    function GetIngredientList : TFhirCodeableConceptList;
    function GetHasIngredientList : Boolean;
    function GetProperty_List : TFhirManufacturedItemDefinitionPropertyList;
    function GetHasProperty_List : Boolean;
    function GetComponentList : TFhirManufacturedItemDefinitionComponentList;
    function GetHasComponentList : Boolean;
  
    function GetResourceType : TFhirResourceType; override;
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirManufacturedItemDefinition; overload;
    function Clone : TFhirManufacturedItemDefinition; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Unique identifier.
    property identifierList : TFhirIdentifierList read GetIdentifierList;
    property hasIdentifierList : boolean read GetHasIdentifierList;

    // The status of this item. Enables tracking the life-cycle of the content.
    property status : TFhirPublicationStatusEnum read GetStatusST write SetStatusST;
    property statusElement : TFhirEnum read FStatus write SetStatus;

    // Typed access to A descriptive name applied to this item.
    property name : String read GetNameST write SetNameST;
    // A descriptive name applied to this item.
    property nameElement : TFhirString read FName write SetName;

    // Typed access to Dose form as manufactured and before any transformation into the pharmaceutical product. (defined for API consistency)
    property manufacturedDoseForm : TFhirCodeableConcept read FManufacturedDoseForm write SetManufacturedDoseForm;
    // Dose form as manufactured and before any transformation into the pharmaceutical product.
    property manufacturedDoseFormElement : TFhirCodeableConcept read FManufacturedDoseForm write SetManufacturedDoseForm;

    // Typed access to The “real world” units in which the quantity of the manufactured item is described. (defined for API consistency)
    property unitOfPresentation : TFhirCodeableConcept read FUnitOfPresentation write SetUnitOfPresentation;
    // The “real world” units in which the quantity of the manufactured item is described.
    property unitOfPresentationElement : TFhirCodeableConcept read FUnitOfPresentation write SetUnitOfPresentation;

    // Manufacturer of the item, one of several possible.
    property manufacturerList : TFhirReferenceList read GetManufacturerList;
    property hasManufacturerList : boolean read GetHasManufacturerList;

    // Allows specifying that an item is on the market for sale, or that it is not available, and the dates and locations associated.
    property marketingStatusList : TFhirMarketingStatusList read GetMarketingStatusList;
    property hasMarketingStatusList : boolean read GetHasMarketingStatusList;

    // The ingredients of this manufactured item. This is only needed if the ingredients are not specified by incoming references from the Ingredient resource.
    property ingredientList : TFhirCodeableConceptList read GetIngredientList;
    property hasIngredientList : boolean read GetHasIngredientList;

    // General characteristics of this item.
    property property_List : TFhirManufacturedItemDefinitionPropertyList read GetProperty_List;
    property hasProperty_List : boolean read GetHasProperty_List;

    // Physical parts of the manufactured item, that it is intrisically made from. This is distinct from the ingredients that are part of its chemical makeup.
    property componentList : TFhirManufacturedItemDefinitionComponentList read GetComponentList;
    property hasComponentList : boolean read GetHasComponentList;

  end;

  TFhirManufacturedItemDefinitionListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirManufacturedItemDefinitionList;
    function GetCurrent : TFhirManufacturedItemDefinition;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirManufacturedItemDefinitionList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirManufacturedItemDefinition read GetCurrent;
  end;

  TFhirManufacturedItemDefinitionList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirManufacturedItemDefinition;
    procedure SetItemN(index : Integer; value : TFhirManufacturedItemDefinition);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirManufacturedItemDefinitionList; overload;
    function Clone : TFhirManufacturedItemDefinitionList; overload;
    function GetEnumerator : TFhirManufacturedItemDefinitionListEnumerator;
    
    //  Add a FhirManufacturedItemDefinition to the end of the list.
    function Append : TFhirManufacturedItemDefinition;
    
    // Add an already existing FhirManufacturedItemDefinition to the end of the list.
    function AddItem(value : TFhirManufacturedItemDefinition) : TFhirManufacturedItemDefinition; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirManufacturedItemDefinition) : Integer;
    
    // Insert FhirManufacturedItemDefinition before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirManufacturedItemDefinition;
    
    // Insert an existing FhirManufacturedItemDefinition before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirManufacturedItemDefinition);
    
    // Get the iIndexth FhirManufacturedItemDefinition. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirManufacturedItemDefinition);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirManufacturedItemDefinition;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirManufacturedItemDefinitions[index : Integer] : TFhirManufacturedItemDefinition read GetItemN write SetItemN; default;
  End;

{$ENDIF FHIR_MANUFACTUREDITEMDEFINITION}
{$IFDEF FHIR_MEDICATION}
  // Identifies a particular constituent of interest in the product.
  TFhirMedicationIngredient = class (TFhirBackboneElement)
  protected
    FItem : TFhirCodeableReference;
    FIsActive : TFhirBoolean;
    FStrength : TFhirDataType;
    procedure SetItem(value : TFhirCodeableReference);
    procedure SetIsActive(value : TFhirBoolean);
    function GetIsActiveST : Boolean;
    procedure SetIsActiveST(value : Boolean);
    procedure SetStrength(value : TFhirDataType);
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirMedicationIngredient; overload;
    function Clone : TFhirMedicationIngredient; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to The ingredient (substance or medication) that the ingredient.strength relates to.  This is represented as a concept from a code system or described in another resource (Substance or Medication). (defined for API consistency)
    property item : TFhirCodeableReference read FItem write SetItem;
    // The ingredient (substance or medication) that the ingredient.strength relates to.  This is represented as a concept from a code system or described in another resource (Substance or Medication).
    property itemElement : TFhirCodeableReference read FItem write SetItem;

    // Typed access to Indication of whether this ingredient affects the therapeutic action of the drug.
    property isActive : Boolean read GetIsActiveST write SetIsActiveST;
    // Indication of whether this ingredient affects the therapeutic action of the drug.
    property isActiveElement : TFhirBoolean read FIsActive write SetIsActive;

    // Typed access to Specifies how many (or how much) of the items there are in this Medication.  For example, 250 mg per tablet.  This is expressed as a ratio where the numerator is 250mg and the denominator is 1 tablet but can also be expressed a quantity when the denominator is assumed to be 1 tablet. (defined for API consistency)
    property strength : TFhirDataType read FStrength write SetStrength;
    // Specifies how many (or how much) of the items there are in this Medication.  For example, 250 mg per tablet.  This is expressed as a ratio where the numerator is 250mg and the denominator is 1 tablet but can also be expressed a quantity when the denominator is assumed to be 1 tablet.
    property strengthElement : TFhirDataType read FStrength write SetStrength;

  end;

  TFhirMedicationIngredientListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirMedicationIngredientList;
    function GetCurrent : TFhirMedicationIngredient;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirMedicationIngredientList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirMedicationIngredient read GetCurrent;
  end;

  TFhirMedicationIngredientList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirMedicationIngredient;
    procedure SetItemN(index : Integer; value : TFhirMedicationIngredient);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirMedicationIngredientList; overload;
    function Clone : TFhirMedicationIngredientList; overload;
    function GetEnumerator : TFhirMedicationIngredientListEnumerator;
    
    //  Add a FhirMedicationIngredient to the end of the list.
    function Append : TFhirMedicationIngredient;
    
    // Add an already existing FhirMedicationIngredient to the end of the list.
    function AddItem(value : TFhirMedicationIngredient) : TFhirMedicationIngredient; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirMedicationIngredient) : Integer;
    
    // Insert FhirMedicationIngredient before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirMedicationIngredient;
    
    // Insert an existing FhirMedicationIngredient before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirMedicationIngredient);
    
    // Get the iIndexth FhirMedicationIngredient. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirMedicationIngredient);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirMedicationIngredient;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirMedicationIngredients[index : Integer] : TFhirMedicationIngredient read GetItemN write SetItemN; default;
  End;

  // Information that only applies to packages (not products).
  TFhirMedicationBatch = class (TFhirBackboneElement)
  protected
    FLotNumber : TFhirString;
    FExpirationDate : TFhirDateTime;
    procedure SetLotNumber(value : TFhirString);
    function GetLotNumberST : String;
    procedure SetLotNumberST(value : String);
    procedure SetExpirationDate(value : TFhirDateTime);
    function GetExpirationDateST : TFslDateTime;
    procedure SetExpirationDateST(value : TFslDateTime);
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirMedicationBatch; overload;
    function Clone : TFhirMedicationBatch; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to The assigned lot number of a batch of the specified product.
    property lotNumber : String read GetLotNumberST write SetLotNumberST;
    // The assigned lot number of a batch of the specified product.
    property lotNumberElement : TFhirString read FLotNumber write SetLotNumber;

    // Typed access to When this specific batch of product will expire.
    property expirationDate : TFslDateTime read GetExpirationDateST write SetExpirationDateST;
    // When this specific batch of product will expire.
    property expirationDateElement : TFhirDateTime read FExpirationDate write SetExpirationDate;

  end;

  TFhirMedicationBatchListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirMedicationBatchList;
    function GetCurrent : TFhirMedicationBatch;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirMedicationBatchList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirMedicationBatch read GetCurrent;
  end;

  TFhirMedicationBatchList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirMedicationBatch;
    procedure SetItemN(index : Integer; value : TFhirMedicationBatch);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirMedicationBatchList; overload;
    function Clone : TFhirMedicationBatchList; overload;
    function GetEnumerator : TFhirMedicationBatchListEnumerator;
    
    //  Add a FhirMedicationBatch to the end of the list.
    function Append : TFhirMedicationBatch;
    
    // Add an already existing FhirMedicationBatch to the end of the list.
    function AddItem(value : TFhirMedicationBatch) : TFhirMedicationBatch; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirMedicationBatch) : Integer;
    
    // Insert FhirMedicationBatch before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirMedicationBatch;
    
    // Insert an existing FhirMedicationBatch before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirMedicationBatch);
    
    // Get the iIndexth FhirMedicationBatch. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirMedicationBatch);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirMedicationBatch;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirMedicationBatches[index : Integer] : TFhirMedicationBatch read GetItemN write SetItemN; default;
  End;

  // This resource is primarily used for the identification and definition of a medication, including ingredients, for the purposes of prescribing, dispensing, and administering a medication as well as for making statements about medication use.
  TFhirMedication = class (TFhirDomainResource)
  protected
    FidentifierList : TFhirIdentifierList;
    FCode : TFhirCodeableConcept;
    FStatus : TFhirEnum;
    FMarketingAuthorizationHolder : TFhirReference;
    FDoseForm : TFhirCodeableConcept;
    FTotalVolume : TFhirRatio;
    FingredientList : TFhirMedicationIngredientList;
    FBatch : TFhirMedicationBatch;
    function GetIdentifierList : TFhirIdentifierList;
    function GetHasIdentifierList : Boolean;
    procedure SetCode(value : TFhirCodeableConcept);
    procedure SetStatus(value : TFhirEnum);
    function GetStatusST : TFhirMedicationStatusCodesEnum;
    procedure SetStatusST(value : TFhirMedicationStatusCodesEnum);
    procedure SetMarketingAuthorizationHolder(value : TFhirReference);
    procedure SetDoseForm(value : TFhirCodeableConcept);
    procedure SetTotalVolume(value : TFhirRatio);
    function GetIngredientList : TFhirMedicationIngredientList;
    function GetHasIngredientList : Boolean;
    procedure SetBatch(value : TFhirMedicationBatch);
  
    function GetResourceType : TFhirResourceType; override;
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirMedication; overload;
    function Clone : TFhirMedication; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Business identifier for this medication.
    property identifierList : TFhirIdentifierList read GetIdentifierList;
    property hasIdentifierList : boolean read GetHasIdentifierList;

    // Typed access to A code (or set of codes) that specify this medication, or a textual description if no code is available. Usage note: This could be a standard medication code such as a code from RxNorm, SNOMED CT, IDMP etc. It could also be a national or local formulary code, optionally with translations to other code systems. (defined for API consistency)
    property code : TFhirCodeableConcept read FCode write SetCode;
    // A code (or set of codes) that specify this medication, or a textual description if no code is available. Usage note: This could be a standard medication code such as a code from RxNorm, SNOMED CT, IDMP etc. It could also be a national or local formulary code, optionally with translations to other code systems.
    property codeElement : TFhirCodeableConcept read FCode write SetCode;

    // A code to indicate if the medication is in active use.
    property status : TFhirMedicationStatusCodesEnum read GetStatusST write SetStatusST;
    property statusElement : TFhirEnum read FStatus write SetStatus;

    // Typed access to The company or other legal entity that has authorization, from the appropriate drug regulatory authority,  to market a medicine in one or more jurisdictions.  Typically abbreviated MAH.Note:  The MAH may manufacture the product and may also contract the manufacturing of the product to one or more companies (organizations). (defined for API consistency)
    property marketingAuthorizationHolder : TFhirReference read FMarketingAuthorizationHolder write SetMarketingAuthorizationHolder;
    // The company or other legal entity that has authorization, from the appropriate drug regulatory authority,  to market a medicine in one or more jurisdictions.  Typically abbreviated MAH.Note:  The MAH may manufacture the product and may also contract the manufacturing of the product to one or more companies (organizations).
    property marketingAuthorizationHolderElement : TFhirReference read FMarketingAuthorizationHolder write SetMarketingAuthorizationHolder;

    // Typed access to Describes the form of the item.  Powder; tablets; capsule. (defined for API consistency)
    property doseForm : TFhirCodeableConcept read FDoseForm write SetDoseForm;
    // Describes the form of the item.  Powder; tablets; capsule.
    property doseFormElement : TFhirCodeableConcept read FDoseForm write SetDoseForm;

    // Typed access to When the specified product code does not infer a package size, this is the specific amount of drug in the product.  For example, when specifying a product that has the same strength (For example, Insulin glargine 100 unit per mL solution for injection), this attribute provides additional clarification of the package amount (For example, 3 mL, 10mL, etc.). (defined for API consistency)
    property totalVolume : TFhirRatio read FTotalVolume write SetTotalVolume;
    // When the specified product code does not infer a package size, this is the specific amount of drug in the product.  For example, when specifying a product that has the same strength (For example, Insulin glargine 100 unit per mL solution for injection), this attribute provides additional clarification of the package amount (For example, 3 mL, 10mL, etc.).
    property totalVolumeElement : TFhirRatio read FTotalVolume write SetTotalVolume;

    // Identifies a particular constituent of interest in the product.
    property ingredientList : TFhirMedicationIngredientList read GetIngredientList;
    property hasIngredientList : boolean read GetHasIngredientList;

    // Typed access to Information that only applies to packages (not products). (defined for API consistency)
    property batch : TFhirMedicationBatch read FBatch write SetBatch;
    // Information that only applies to packages (not products).
    property batchElement : TFhirMedicationBatch read FBatch write SetBatch;

  end;

  TFhirMedicationListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirMedicationList;
    function GetCurrent : TFhirMedication;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirMedicationList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirMedication read GetCurrent;
  end;

  TFhirMedicationList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirMedication;
    procedure SetItemN(index : Integer; value : TFhirMedication);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirMedicationList; overload;
    function Clone : TFhirMedicationList; overload;
    function GetEnumerator : TFhirMedicationListEnumerator;
    
    //  Add a FhirMedication to the end of the list.
    function Append : TFhirMedication;
    
    // Add an already existing FhirMedication to the end of the list.
    function AddItem(value : TFhirMedication) : TFhirMedication; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirMedication) : Integer;
    
    // Insert FhirMedication before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirMedication;
    
    // Insert an existing FhirMedication before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirMedication);
    
    // Get the iIndexth FhirMedication. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirMedication);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirMedication;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirMedications[index : Integer] : TFhirMedication read GetItemN write SetItemN; default;
  End;

{$ENDIF FHIR_MEDICATION}
{$IFDEF FHIR_MEDICATIONKNOWLEDGE}
  // Associated or related medications. For example, if the medication is a branded product (e.g. Crestor), this is the Therapeutic Moeity (e.g. Rosuvastatin) or if this is a generic medication (e.g. Rosuvastatin), this would link to a branded product (e.g. Crestor.
  TFhirMedicationKnowledgeRelatedMedicationKnowledge = class (TFhirBackboneElement)
  protected
    FType_ : TFhirCodeableConcept;
    FreferenceList : TFhirReferenceList;
    procedure SetType_(value : TFhirCodeableConcept);
    function GetReferenceList : TFhirReferenceList;
    function GetHasReferenceList : Boolean;
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirMedicationKnowledgeRelatedMedicationKnowledge; overload;
    function Clone : TFhirMedicationKnowledgeRelatedMedicationKnowledge; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to The category of the associated medication knowledge reference. (defined for API consistency)
    property type_ : TFhirCodeableConcept read FType_ write SetType_;
    // The category of the associated medication knowledge reference.
    property type_Element : TFhirCodeableConcept read FType_ write SetType_;

    // Associated documentation about the associated medication knowledge.
    property referenceList : TFhirReferenceList read GetReferenceList;
    property hasReferenceList : boolean read GetHasReferenceList;

  end;

  TFhirMedicationKnowledgeRelatedMedicationKnowledgeListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirMedicationKnowledgeRelatedMedicationKnowledgeList;
    function GetCurrent : TFhirMedicationKnowledgeRelatedMedicationKnowledge;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirMedicationKnowledgeRelatedMedicationKnowledgeList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirMedicationKnowledgeRelatedMedicationKnowledge read GetCurrent;
  end;

  TFhirMedicationKnowledgeRelatedMedicationKnowledgeList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirMedicationKnowledgeRelatedMedicationKnowledge;
    procedure SetItemN(index : Integer; value : TFhirMedicationKnowledgeRelatedMedicationKnowledge);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirMedicationKnowledgeRelatedMedicationKnowledgeList; overload;
    function Clone : TFhirMedicationKnowledgeRelatedMedicationKnowledgeList; overload;
    function GetEnumerator : TFhirMedicationKnowledgeRelatedMedicationKnowledgeListEnumerator;
    
    //  Add a FhirMedicationKnowledgeRelatedMedicationKnowledge to the end of the list.
    function Append : TFhirMedicationKnowledgeRelatedMedicationKnowledge;
    
    // Add an already existing FhirMedicationKnowledgeRelatedMedicationKnowledge to the end of the list.
    function AddItem(value : TFhirMedicationKnowledgeRelatedMedicationKnowledge) : TFhirMedicationKnowledgeRelatedMedicationKnowledge; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirMedicationKnowledgeRelatedMedicationKnowledge) : Integer;
    
    // Insert FhirMedicationKnowledgeRelatedMedicationKnowledge before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirMedicationKnowledgeRelatedMedicationKnowledge;
    
    // Insert an existing FhirMedicationKnowledgeRelatedMedicationKnowledge before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirMedicationKnowledgeRelatedMedicationKnowledge);
    
    // Get the iIndexth FhirMedicationKnowledgeRelatedMedicationKnowledge. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirMedicationKnowledgeRelatedMedicationKnowledge);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirMedicationKnowledgeRelatedMedicationKnowledge;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirMedicationKnowledgeRelatedMedicationKnowledges[index : Integer] : TFhirMedicationKnowledgeRelatedMedicationKnowledge read GetItemN write SetItemN; default;
  End;

  // Associated documentation about the medication.
  TFhirMedicationKnowledgeMonograph = class (TFhirBackboneElement)
  protected
    FType_ : TFhirCodeableConcept;
    FSource : TFhirReference;
    procedure SetType_(value : TFhirCodeableConcept);
    procedure SetSource(value : TFhirReference);
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirMedicationKnowledgeMonograph; overload;
    function Clone : TFhirMedicationKnowledgeMonograph; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to The category of documentation about the medication. (e.g. professional monograph, patient education monograph). (defined for API consistency)
    property type_ : TFhirCodeableConcept read FType_ write SetType_;
    // The category of documentation about the medication. (e.g. professional monograph, patient education monograph).
    property type_Element : TFhirCodeableConcept read FType_ write SetType_;

    // Typed access to Associated documentation about the medication. (defined for API consistency)
    property source : TFhirReference read FSource write SetSource;
    // Associated documentation about the medication.
    property sourceElement : TFhirReference read FSource write SetSource;

  end;

  TFhirMedicationKnowledgeMonographListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirMedicationKnowledgeMonographList;
    function GetCurrent : TFhirMedicationKnowledgeMonograph;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirMedicationKnowledgeMonographList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirMedicationKnowledgeMonograph read GetCurrent;
  end;

  TFhirMedicationKnowledgeMonographList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirMedicationKnowledgeMonograph;
    procedure SetItemN(index : Integer; value : TFhirMedicationKnowledgeMonograph);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirMedicationKnowledgeMonographList; overload;
    function Clone : TFhirMedicationKnowledgeMonographList; overload;
    function GetEnumerator : TFhirMedicationKnowledgeMonographListEnumerator;
    
    //  Add a FhirMedicationKnowledgeMonograph to the end of the list.
    function Append : TFhirMedicationKnowledgeMonograph;
    
    // Add an already existing FhirMedicationKnowledgeMonograph to the end of the list.
    function AddItem(value : TFhirMedicationKnowledgeMonograph) : TFhirMedicationKnowledgeMonograph; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirMedicationKnowledgeMonograph) : Integer;
    
    // Insert FhirMedicationKnowledgeMonograph before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirMedicationKnowledgeMonograph;
    
    // Insert an existing FhirMedicationKnowledgeMonograph before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirMedicationKnowledgeMonograph);
    
    // Get the iIndexth FhirMedicationKnowledgeMonograph. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirMedicationKnowledgeMonograph);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirMedicationKnowledgeMonograph;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirMedicationKnowledgeMonographs[index : Integer] : TFhirMedicationKnowledgeMonograph read GetItemN write SetItemN; default;
  End;

  // The price of the medication.
  TFhirMedicationKnowledgeCost = class (TFhirBackboneElement)
  protected
    FeffectiveDateList : TFhirPeriodList;
    FType_ : TFhirCodeableConcept;
    FSource : TFhirString;
    FCost : TFhirDataType;
    function GetEffectiveDateList : TFhirPeriodList;
    function GetHasEffectiveDateList : Boolean;
    procedure SetType_(value : TFhirCodeableConcept);
    procedure SetSource(value : TFhirString);
    function GetSourceST : String;
    procedure SetSourceST(value : String);
    procedure SetCost(value : TFhirDataType);
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirMedicationKnowledgeCost; overload;
    function Clone : TFhirMedicationKnowledgeCost; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // The date range for which the cost information of the medication is effective.
    property effectiveDateList : TFhirPeriodList read GetEffectiveDateList;
    property hasEffectiveDateList : boolean read GetHasEffectiveDateList;

    // Typed access to The category of the cost information.  For example, manufacturers' cost, patient cost, claim reimbursement cost, actual acquisition cost. (defined for API consistency)
    property type_ : TFhirCodeableConcept read FType_ write SetType_;
    // The category of the cost information.  For example, manufacturers' cost, patient cost, claim reimbursement cost, actual acquisition cost.
    property type_Element : TFhirCodeableConcept read FType_ write SetType_;

    // Typed access to The source or owner that assigns the price to the medication.
    property source : String read GetSourceST write SetSourceST;
    // The source or owner that assigns the price to the medication.
    property sourceElement : TFhirString read FSource write SetSource;

    // Typed access to The price or representation of the cost (for example, Band A, Band B or $, $$) of the medication. (defined for API consistency)
    property cost : TFhirDataType read FCost write SetCost;
    // The price or representation of the cost (for example, Band A, Band B or $, $$) of the medication.
    property costElement : TFhirDataType read FCost write SetCost;

  end;

  TFhirMedicationKnowledgeCostListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirMedicationKnowledgeCostList;
    function GetCurrent : TFhirMedicationKnowledgeCost;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirMedicationKnowledgeCostList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirMedicationKnowledgeCost read GetCurrent;
  end;

  TFhirMedicationKnowledgeCostList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirMedicationKnowledgeCost;
    procedure SetItemN(index : Integer; value : TFhirMedicationKnowledgeCost);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirMedicationKnowledgeCostList; overload;
    function Clone : TFhirMedicationKnowledgeCostList; overload;
    function GetEnumerator : TFhirMedicationKnowledgeCostListEnumerator;
    
    //  Add a FhirMedicationKnowledgeCost to the end of the list.
    function Append : TFhirMedicationKnowledgeCost;
    
    // Add an already existing FhirMedicationKnowledgeCost to the end of the list.
    function AddItem(value : TFhirMedicationKnowledgeCost) : TFhirMedicationKnowledgeCost; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirMedicationKnowledgeCost) : Integer;
    
    // Insert FhirMedicationKnowledgeCost before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirMedicationKnowledgeCost;
    
    // Insert an existing FhirMedicationKnowledgeCost before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirMedicationKnowledgeCost);
    
    // Get the iIndexth FhirMedicationKnowledgeCost. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirMedicationKnowledgeCost);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirMedicationKnowledgeCost;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirMedicationKnowledgeCosts[index : Integer] : TFhirMedicationKnowledgeCost read GetItemN write SetItemN; default;
  End;

  // The program under which the medication is reviewed.
  TFhirMedicationKnowledgeMonitoringProgram = class (TFhirBackboneElement)
  protected
    FType_ : TFhirCodeableConcept;
    FName : TFhirString;
    procedure SetType_(value : TFhirCodeableConcept);
    procedure SetName(value : TFhirString);
    function GetNameST : String;
    procedure SetNameST(value : String);
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirMedicationKnowledgeMonitoringProgram; overload;
    function Clone : TFhirMedicationKnowledgeMonitoringProgram; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to Type of program under which the medication is monitored. (defined for API consistency)
    property type_ : TFhirCodeableConcept read FType_ write SetType_;
    // Type of program under which the medication is monitored.
    property type_Element : TFhirCodeableConcept read FType_ write SetType_;

    // Typed access to Name of the reviewing program.
    property name : String read GetNameST write SetNameST;
    // Name of the reviewing program.
    property nameElement : TFhirString read FName write SetName;

  end;

  TFhirMedicationKnowledgeMonitoringProgramListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirMedicationKnowledgeMonitoringProgramList;
    function GetCurrent : TFhirMedicationKnowledgeMonitoringProgram;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirMedicationKnowledgeMonitoringProgramList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirMedicationKnowledgeMonitoringProgram read GetCurrent;
  end;

  TFhirMedicationKnowledgeMonitoringProgramList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirMedicationKnowledgeMonitoringProgram;
    procedure SetItemN(index : Integer; value : TFhirMedicationKnowledgeMonitoringProgram);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirMedicationKnowledgeMonitoringProgramList; overload;
    function Clone : TFhirMedicationKnowledgeMonitoringProgramList; overload;
    function GetEnumerator : TFhirMedicationKnowledgeMonitoringProgramListEnumerator;
    
    //  Add a FhirMedicationKnowledgeMonitoringProgram to the end of the list.
    function Append : TFhirMedicationKnowledgeMonitoringProgram;
    
    // Add an already existing FhirMedicationKnowledgeMonitoringProgram to the end of the list.
    function AddItem(value : TFhirMedicationKnowledgeMonitoringProgram) : TFhirMedicationKnowledgeMonitoringProgram; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirMedicationKnowledgeMonitoringProgram) : Integer;
    
    // Insert FhirMedicationKnowledgeMonitoringProgram before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirMedicationKnowledgeMonitoringProgram;
    
    // Insert an existing FhirMedicationKnowledgeMonitoringProgram before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirMedicationKnowledgeMonitoringProgram);
    
    // Get the iIndexth FhirMedicationKnowledgeMonitoringProgram. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirMedicationKnowledgeMonitoringProgram);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirMedicationKnowledgeMonitoringProgram;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirMedicationKnowledgeMonitoringPrograms[index : Integer] : TFhirMedicationKnowledgeMonitoringProgram read GetItemN write SetItemN; default;
  End;

  // Guidelines or protocols that are applicable for the administration of the medication based on indication.
  TFhirMedicationKnowledgeIndicationGuideline = class (TFhirBackboneElement)
  protected
    FindicationList : TFhirCodeableReferenceList;
    FdosingGuidelineList : TFhirMedicationKnowledgeIndicationGuidelineDosingGuidelineList;
    function GetIndicationList : TFhirCodeableReferenceList;
    function GetHasIndicationList : Boolean;
    function GetDosingGuidelineList : TFhirMedicationKnowledgeIndicationGuidelineDosingGuidelineList;
    function GetHasDosingGuidelineList : Boolean;
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirMedicationKnowledgeIndicationGuideline; overload;
    function Clone : TFhirMedicationKnowledgeIndicationGuideline; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Indication or reason for use of the medication that applies to the specific administration guideline.
    property indicationList : TFhirCodeableReferenceList read GetIndicationList;
    property hasIndicationList : boolean read GetHasIndicationList;

    // The guidelines for the dosage of the medication for the indication.
    property dosingGuidelineList : TFhirMedicationKnowledgeIndicationGuidelineDosingGuidelineList read GetDosingGuidelineList;
    property hasDosingGuidelineList : boolean read GetHasDosingGuidelineList;

  end;

  TFhirMedicationKnowledgeIndicationGuidelineListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirMedicationKnowledgeIndicationGuidelineList;
    function GetCurrent : TFhirMedicationKnowledgeIndicationGuideline;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirMedicationKnowledgeIndicationGuidelineList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirMedicationKnowledgeIndicationGuideline read GetCurrent;
  end;

  TFhirMedicationKnowledgeIndicationGuidelineList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirMedicationKnowledgeIndicationGuideline;
    procedure SetItemN(index : Integer; value : TFhirMedicationKnowledgeIndicationGuideline);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirMedicationKnowledgeIndicationGuidelineList; overload;
    function Clone : TFhirMedicationKnowledgeIndicationGuidelineList; overload;
    function GetEnumerator : TFhirMedicationKnowledgeIndicationGuidelineListEnumerator;
    
    //  Add a FhirMedicationKnowledgeIndicationGuideline to the end of the list.
    function Append : TFhirMedicationKnowledgeIndicationGuideline;
    
    // Add an already existing FhirMedicationKnowledgeIndicationGuideline to the end of the list.
    function AddItem(value : TFhirMedicationKnowledgeIndicationGuideline) : TFhirMedicationKnowledgeIndicationGuideline; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirMedicationKnowledgeIndicationGuideline) : Integer;
    
    // Insert FhirMedicationKnowledgeIndicationGuideline before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirMedicationKnowledgeIndicationGuideline;
    
    // Insert an existing FhirMedicationKnowledgeIndicationGuideline before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirMedicationKnowledgeIndicationGuideline);
    
    // Get the iIndexth FhirMedicationKnowledgeIndicationGuideline. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirMedicationKnowledgeIndicationGuideline);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirMedicationKnowledgeIndicationGuideline;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirMedicationKnowledgeIndicationGuidelines[index : Integer] : TFhirMedicationKnowledgeIndicationGuideline read GetItemN write SetItemN; default;
  End;

  // The guidelines for the dosage of the medication for the indication.
  TFhirMedicationKnowledgeIndicationGuidelineDosingGuideline = class (TFhirBackboneElement)
  protected
    FTreatmentIntent : TFhirCodeableConcept;
    FdosageList : TFhirMedicationKnowledgeIndicationGuidelineDosingGuidelineDosageList;
    FAdministrationTreatment : TFhirCodeableConcept;
    FpatientCharacteristicList : TFhirMedicationKnowledgeIndicationGuidelineDosingGuidelinePatientCharacteristicList;
    procedure SetTreatmentIntent(value : TFhirCodeableConcept);
    function GetDosageList : TFhirMedicationKnowledgeIndicationGuidelineDosingGuidelineDosageList;
    function GetHasDosageList : Boolean;
    procedure SetAdministrationTreatment(value : TFhirCodeableConcept);
    function GetPatientCharacteristicList : TFhirMedicationKnowledgeIndicationGuidelineDosingGuidelinePatientCharacteristicList;
    function GetHasPatientCharacteristicList : Boolean;
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirMedicationKnowledgeIndicationGuidelineDosingGuideline; overload;
    function Clone : TFhirMedicationKnowledgeIndicationGuidelineDosingGuideline; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to The overall intention of the treatment, for example, prophylactic, supporative, curative, etc. (defined for API consistency)
    property treatmentIntent : TFhirCodeableConcept read FTreatmentIntent write SetTreatmentIntent;
    // The overall intention of the treatment, for example, prophylactic, supporative, curative, etc.
    property treatmentIntentElement : TFhirCodeableConcept read FTreatmentIntent write SetTreatmentIntent;

    // Dosage for the medication for the specific guidelines.
    property dosageList : TFhirMedicationKnowledgeIndicationGuidelineDosingGuidelineDosageList read GetDosageList;
    property hasDosageList : boolean read GetHasDosageList;

    // Typed access to The type of the treatment that the guideline applies to, for example, long term therapy, first line treatment, etc. (defined for API consistency)
    property administrationTreatment : TFhirCodeableConcept read FAdministrationTreatment write SetAdministrationTreatment;
    // The type of the treatment that the guideline applies to, for example, long term therapy, first line treatment, etc.
    property administrationTreatmentElement : TFhirCodeableConcept read FAdministrationTreatment write SetAdministrationTreatment;

    // Characteristics of the patient that are relevant to the administration guidelines (for example, height, weight, gender, etc.).
    property patientCharacteristicList : TFhirMedicationKnowledgeIndicationGuidelineDosingGuidelinePatientCharacteristicList read GetPatientCharacteristicList;
    property hasPatientCharacteristicList : boolean read GetHasPatientCharacteristicList;

  end;

  TFhirMedicationKnowledgeIndicationGuidelineDosingGuidelineListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirMedicationKnowledgeIndicationGuidelineDosingGuidelineList;
    function GetCurrent : TFhirMedicationKnowledgeIndicationGuidelineDosingGuideline;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirMedicationKnowledgeIndicationGuidelineDosingGuidelineList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirMedicationKnowledgeIndicationGuidelineDosingGuideline read GetCurrent;
  end;

  TFhirMedicationKnowledgeIndicationGuidelineDosingGuidelineList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirMedicationKnowledgeIndicationGuidelineDosingGuideline;
    procedure SetItemN(index : Integer; value : TFhirMedicationKnowledgeIndicationGuidelineDosingGuideline);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirMedicationKnowledgeIndicationGuidelineDosingGuidelineList; overload;
    function Clone : TFhirMedicationKnowledgeIndicationGuidelineDosingGuidelineList; overload;
    function GetEnumerator : TFhirMedicationKnowledgeIndicationGuidelineDosingGuidelineListEnumerator;
    
    //  Add a FhirMedicationKnowledgeIndicationGuidelineDosingGuideline to the end of the list.
    function Append : TFhirMedicationKnowledgeIndicationGuidelineDosingGuideline;
    
    // Add an already existing FhirMedicationKnowledgeIndicationGuidelineDosingGuideline to the end of the list.
    function AddItem(value : TFhirMedicationKnowledgeIndicationGuidelineDosingGuideline) : TFhirMedicationKnowledgeIndicationGuidelineDosingGuideline; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirMedicationKnowledgeIndicationGuidelineDosingGuideline) : Integer;
    
    // Insert FhirMedicationKnowledgeIndicationGuidelineDosingGuideline before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirMedicationKnowledgeIndicationGuidelineDosingGuideline;
    
    // Insert an existing FhirMedicationKnowledgeIndicationGuidelineDosingGuideline before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirMedicationKnowledgeIndicationGuidelineDosingGuideline);
    
    // Get the iIndexth FhirMedicationKnowledgeIndicationGuidelineDosingGuideline. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirMedicationKnowledgeIndicationGuidelineDosingGuideline);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirMedicationKnowledgeIndicationGuidelineDosingGuideline;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirMedicationKnowledgeIndicationGuidelineDosingGuidelines[index : Integer] : TFhirMedicationKnowledgeIndicationGuidelineDosingGuideline read GetItemN write SetItemN; default;
  End;

  // Dosage for the medication for the specific guidelines.
  TFhirMedicationKnowledgeIndicationGuidelineDosingGuidelineDosage = class (TFhirBackboneElement)
  protected
    FType_ : TFhirCodeableConcept;
    FdosageList : TFhirDosageList;
    procedure SetType_(value : TFhirCodeableConcept);
    function GetDosageList : TFhirDosageList;
    function GetHasDosageList : Boolean;
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirMedicationKnowledgeIndicationGuidelineDosingGuidelineDosage; overload;
    function Clone : TFhirMedicationKnowledgeIndicationGuidelineDosingGuidelineDosage; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to The type or category of dosage for a given medication (for example, prophylaxis, maintenance, therapeutic, etc.). (defined for API consistency)
    property type_ : TFhirCodeableConcept read FType_ write SetType_;
    // The type or category of dosage for a given medication (for example, prophylaxis, maintenance, therapeutic, etc.).
    property type_Element : TFhirCodeableConcept read FType_ write SetType_;

    // Dosage for the medication for the specific guidelines.
    property dosageList : TFhirDosageList read GetDosageList;
    property hasDosageList : boolean read GetHasDosageList;

  end;

  TFhirMedicationKnowledgeIndicationGuidelineDosingGuidelineDosageListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirMedicationKnowledgeIndicationGuidelineDosingGuidelineDosageList;
    function GetCurrent : TFhirMedicationKnowledgeIndicationGuidelineDosingGuidelineDosage;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirMedicationKnowledgeIndicationGuidelineDosingGuidelineDosageList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirMedicationKnowledgeIndicationGuidelineDosingGuidelineDosage read GetCurrent;
  end;

  TFhirMedicationKnowledgeIndicationGuidelineDosingGuidelineDosageList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirMedicationKnowledgeIndicationGuidelineDosingGuidelineDosage;
    procedure SetItemN(index : Integer; value : TFhirMedicationKnowledgeIndicationGuidelineDosingGuidelineDosage);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirMedicationKnowledgeIndicationGuidelineDosingGuidelineDosageList; overload;
    function Clone : TFhirMedicationKnowledgeIndicationGuidelineDosingGuidelineDosageList; overload;
    function GetEnumerator : TFhirMedicationKnowledgeIndicationGuidelineDosingGuidelineDosageListEnumerator;
    
    //  Add a FhirMedicationKnowledgeIndicationGuidelineDosingGuidelineDosage to the end of the list.
    function Append : TFhirMedicationKnowledgeIndicationGuidelineDosingGuidelineDosage;
    
    // Add an already existing FhirMedicationKnowledgeIndicationGuidelineDosingGuidelineDosage to the end of the list.
    function AddItem(value : TFhirMedicationKnowledgeIndicationGuidelineDosingGuidelineDosage) : TFhirMedicationKnowledgeIndicationGuidelineDosingGuidelineDosage; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirMedicationKnowledgeIndicationGuidelineDosingGuidelineDosage) : Integer;
    
    // Insert FhirMedicationKnowledgeIndicationGuidelineDosingGuidelineDosage before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirMedicationKnowledgeIndicationGuidelineDosingGuidelineDosage;
    
    // Insert an existing FhirMedicationKnowledgeIndicationGuidelineDosingGuidelineDosage before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirMedicationKnowledgeIndicationGuidelineDosingGuidelineDosage);
    
    // Get the iIndexth FhirMedicationKnowledgeIndicationGuidelineDosingGuidelineDosage. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirMedicationKnowledgeIndicationGuidelineDosingGuidelineDosage);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirMedicationKnowledgeIndicationGuidelineDosingGuidelineDosage;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirMedicationKnowledgeIndicationGuidelineDosingGuidelineDosages[index : Integer] : TFhirMedicationKnowledgeIndicationGuidelineDosingGuidelineDosage read GetItemN write SetItemN; default;
  End;

  // Characteristics of the patient that are relevant to the administration guidelines (for example, height, weight, gender, etc.).
  TFhirMedicationKnowledgeIndicationGuidelineDosingGuidelinePatientCharacteristic = class (TFhirBackboneElement)
  protected
    FType_ : TFhirCodeableConcept;
    FValue : TFhirDataType;
    procedure SetType_(value : TFhirCodeableConcept);
    procedure SetValue(value : TFhirDataType);
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirMedicationKnowledgeIndicationGuidelineDosingGuidelinePatientCharacteristic; overload;
    function Clone : TFhirMedicationKnowledgeIndicationGuidelineDosingGuidelinePatientCharacteristic; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to The categorization of the specific characteristic that is relevant to the administration guideline (e.g. height, weight, gender). (defined for API consistency)
    property type_ : TFhirCodeableConcept read FType_ write SetType_;
    // The categorization of the specific characteristic that is relevant to the administration guideline (e.g. height, weight, gender).
    property type_Element : TFhirCodeableConcept read FType_ write SetType_;

    // Typed access to The specific characteristic (e.g. height, weight, gender, etc.). (defined for API consistency)
    property value : TFhirDataType read FValue write SetValue;
    // The specific characteristic (e.g. height, weight, gender, etc.).
    property valueElement : TFhirDataType read FValue write SetValue;

  end;

  TFhirMedicationKnowledgeIndicationGuidelineDosingGuidelinePatientCharacteristicListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirMedicationKnowledgeIndicationGuidelineDosingGuidelinePatientCharacteristicList;
    function GetCurrent : TFhirMedicationKnowledgeIndicationGuidelineDosingGuidelinePatientCharacteristic;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirMedicationKnowledgeIndicationGuidelineDosingGuidelinePatientCharacteristicList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirMedicationKnowledgeIndicationGuidelineDosingGuidelinePatientCharacteristic read GetCurrent;
  end;

  TFhirMedicationKnowledgeIndicationGuidelineDosingGuidelinePatientCharacteristicList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirMedicationKnowledgeIndicationGuidelineDosingGuidelinePatientCharacteristic;
    procedure SetItemN(index : Integer; value : TFhirMedicationKnowledgeIndicationGuidelineDosingGuidelinePatientCharacteristic);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirMedicationKnowledgeIndicationGuidelineDosingGuidelinePatientCharacteristicList; overload;
    function Clone : TFhirMedicationKnowledgeIndicationGuidelineDosingGuidelinePatientCharacteristicList; overload;
    function GetEnumerator : TFhirMedicationKnowledgeIndicationGuidelineDosingGuidelinePatientCharacteristicListEnumerator;
    
    //  Add a FhirMedicationKnowledgeIndicationGuidelineDosingGuidelinePatientCharacteristic to the end of the list.
    function Append : TFhirMedicationKnowledgeIndicationGuidelineDosingGuidelinePatientCharacteristic;
    
    // Add an already existing FhirMedicationKnowledgeIndicationGuidelineDosingGuidelinePatientCharacteristic to the end of the list.
    function AddItem(value : TFhirMedicationKnowledgeIndicationGuidelineDosingGuidelinePatientCharacteristic) : TFhirMedicationKnowledgeIndicationGuidelineDosingGuidelinePatientCharacteristic; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirMedicationKnowledgeIndicationGuidelineDosingGuidelinePatientCharacteristic) : Integer;
    
    // Insert FhirMedicationKnowledgeIndicationGuidelineDosingGuidelinePatientCharacteristic before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirMedicationKnowledgeIndicationGuidelineDosingGuidelinePatientCharacteristic;
    
    // Insert an existing FhirMedicationKnowledgeIndicationGuidelineDosingGuidelinePatientCharacteristic before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirMedicationKnowledgeIndicationGuidelineDosingGuidelinePatientCharacteristic);
    
    // Get the iIndexth FhirMedicationKnowledgeIndicationGuidelineDosingGuidelinePatientCharacteristic. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirMedicationKnowledgeIndicationGuidelineDosingGuidelinePatientCharacteristic);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirMedicationKnowledgeIndicationGuidelineDosingGuidelinePatientCharacteristic;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirMedicationKnowledgeIndicationGuidelineDosingGuidelinePatientCharacteristics[index : Integer] : TFhirMedicationKnowledgeIndicationGuidelineDosingGuidelinePatientCharacteristic read GetItemN write SetItemN; default;
  End;

  // Categorization of the medication within a formulary or classification system.
  TFhirMedicationKnowledgeMedicineClassification = class (TFhirBackboneElement)
  protected
    FType_ : TFhirCodeableConcept;
    FSource : TFhirDataType;
    FclassificationList : TFhirCodeableConceptList;
    procedure SetType_(value : TFhirCodeableConcept);
    procedure SetSource(value : TFhirDataType);
    function GetClassificationList : TFhirCodeableConceptList;
    function GetHasClassificationList : Boolean;
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirMedicationKnowledgeMedicineClassification; overload;
    function Clone : TFhirMedicationKnowledgeMedicineClassification; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to The type of category for the medication (for example, therapeutic classification, therapeutic sub-classification). (defined for API consistency)
    property type_ : TFhirCodeableConcept read FType_ write SetType_;
    // The type of category for the medication (for example, therapeutic classification, therapeutic sub-classification).
    property type_Element : TFhirCodeableConcept read FType_ write SetType_;

    // Typed access to Either a textual source of the classification or a reference to an online source. (defined for API consistency)
    property source : TFhirDataType read FSource write SetSource;
    // Either a textual source of the classification or a reference to an online source.
    property sourceElement : TFhirDataType read FSource write SetSource;

    // Specific category assigned to the medication (e.g. anti-infective, anti-hypertensive, antibiotic, etc.).
    property classificationList : TFhirCodeableConceptList read GetClassificationList;
    property hasClassificationList : boolean read GetHasClassificationList;

  end;

  TFhirMedicationKnowledgeMedicineClassificationListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirMedicationKnowledgeMedicineClassificationList;
    function GetCurrent : TFhirMedicationKnowledgeMedicineClassification;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirMedicationKnowledgeMedicineClassificationList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirMedicationKnowledgeMedicineClassification read GetCurrent;
  end;

  TFhirMedicationKnowledgeMedicineClassificationList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirMedicationKnowledgeMedicineClassification;
    procedure SetItemN(index : Integer; value : TFhirMedicationKnowledgeMedicineClassification);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirMedicationKnowledgeMedicineClassificationList; overload;
    function Clone : TFhirMedicationKnowledgeMedicineClassificationList; overload;
    function GetEnumerator : TFhirMedicationKnowledgeMedicineClassificationListEnumerator;
    
    //  Add a FhirMedicationKnowledgeMedicineClassification to the end of the list.
    function Append : TFhirMedicationKnowledgeMedicineClassification;
    
    // Add an already existing FhirMedicationKnowledgeMedicineClassification to the end of the list.
    function AddItem(value : TFhirMedicationKnowledgeMedicineClassification) : TFhirMedicationKnowledgeMedicineClassification; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirMedicationKnowledgeMedicineClassification) : Integer;
    
    // Insert FhirMedicationKnowledgeMedicineClassification before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirMedicationKnowledgeMedicineClassification;
    
    // Insert an existing FhirMedicationKnowledgeMedicineClassification before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirMedicationKnowledgeMedicineClassification);
    
    // Get the iIndexth FhirMedicationKnowledgeMedicineClassification. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirMedicationKnowledgeMedicineClassification);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirMedicationKnowledgeMedicineClassification;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirMedicationKnowledgeMedicineClassifications[index : Integer] : TFhirMedicationKnowledgeMedicineClassification read GetItemN write SetItemN; default;
  End;

  // Information that only applies to packages (not products).
  TFhirMedicationKnowledgePackaging = class (TFhirBackboneElement)
  protected
    FcostList : TFhirMedicationKnowledgeCostList;
    FPackagedProduct : TFhirReference;
    function GetCostList : TFhirMedicationKnowledgeCostList;
    function GetHasCostList : Boolean;
    procedure SetPackagedProduct(value : TFhirReference);
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirMedicationKnowledgePackaging; overload;
    function Clone : TFhirMedicationKnowledgePackaging; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // The cost of the packaged medication.
    property costList : TFhirMedicationKnowledgeCostList read GetCostList;
    property hasCostList : boolean read GetHasCostList;

    // Typed access to A reference to a PackagedProductDefinition that provides the details of the product that is in the packaging and is being priced. (defined for API consistency)
    property packagedProduct : TFhirReference read FPackagedProduct write SetPackagedProduct;
    // A reference to a PackagedProductDefinition that provides the details of the product that is in the packaging and is being priced.
    property packagedProductElement : TFhirReference read FPackagedProduct write SetPackagedProduct;

  end;

  TFhirMedicationKnowledgePackagingListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirMedicationKnowledgePackagingList;
    function GetCurrent : TFhirMedicationKnowledgePackaging;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirMedicationKnowledgePackagingList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirMedicationKnowledgePackaging read GetCurrent;
  end;

  TFhirMedicationKnowledgePackagingList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirMedicationKnowledgePackaging;
    procedure SetItemN(index : Integer; value : TFhirMedicationKnowledgePackaging);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirMedicationKnowledgePackagingList; overload;
    function Clone : TFhirMedicationKnowledgePackagingList; overload;
    function GetEnumerator : TFhirMedicationKnowledgePackagingListEnumerator;
    
    //  Add a FhirMedicationKnowledgePackaging to the end of the list.
    function Append : TFhirMedicationKnowledgePackaging;
    
    // Add an already existing FhirMedicationKnowledgePackaging to the end of the list.
    function AddItem(value : TFhirMedicationKnowledgePackaging) : TFhirMedicationKnowledgePackaging; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirMedicationKnowledgePackaging) : Integer;
    
    // Insert FhirMedicationKnowledgePackaging before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirMedicationKnowledgePackaging;
    
    // Insert an existing FhirMedicationKnowledgePackaging before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirMedicationKnowledgePackaging);
    
    // Get the iIndexth FhirMedicationKnowledgePackaging. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirMedicationKnowledgePackaging);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirMedicationKnowledgePackaging;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirMedicationKnowledgePackagings[index : Integer] : TFhirMedicationKnowledgePackaging read GetItemN write SetItemN; default;
  End;

  // Information on how the medication should be stored, for example, refrigeration temperatures and length of stability at a given temperature.
  TFhirMedicationKnowledgeStorageGuideline = class (TFhirBackboneElement)
  protected
    FReference : TFhirUri;
    FnoteList : TFhirAnnotationList;
    FStabilityDuration : TFhirDuration;
    FenvironmentalSettingList : TFhirMedicationKnowledgeStorageGuidelineEnvironmentalSettingList;
    procedure SetReference(value : TFhirUri);
    function GetReferenceST : String;
    procedure SetReferenceST(value : String);
    function GetNoteList : TFhirAnnotationList;
    function GetHasNoteList : Boolean;
    procedure SetStabilityDuration(value : TFhirDuration);
    function GetEnvironmentalSettingList : TFhirMedicationKnowledgeStorageGuidelineEnvironmentalSettingList;
    function GetHasEnvironmentalSettingList : Boolean;
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirMedicationKnowledgeStorageGuideline; overload;
    function Clone : TFhirMedicationKnowledgeStorageGuideline; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to Reference to additional information about the storage guidelines.
    property reference : String read GetReferenceST write SetReferenceST;
    // Reference to additional information about the storage guidelines.
    property referenceElement : TFhirUri read FReference write SetReference;

    // Additional notes about the storage.
    property noteList : TFhirAnnotationList read GetNoteList;
    property hasNoteList : boolean read GetHasNoteList;

    // Typed access to Duration that the medication remains stable if the environmentalSetting is respected. (defined for API consistency)
    property stabilityDuration : TFhirDuration read FStabilityDuration write SetStabilityDuration;
    // Duration that the medication remains stable if the environmentalSetting is respected.
    property stabilityDurationElement : TFhirDuration read FStabilityDuration write SetStabilityDuration;

    // Describes a setting/value on the environment for the adequate storage of the medication and other substances.  Environment settings may involve temperature, humidity, or exposure to light.
    property environmentalSettingList : TFhirMedicationKnowledgeStorageGuidelineEnvironmentalSettingList read GetEnvironmentalSettingList;
    property hasEnvironmentalSettingList : boolean read GetHasEnvironmentalSettingList;

  end;

  TFhirMedicationKnowledgeStorageGuidelineListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirMedicationKnowledgeStorageGuidelineList;
    function GetCurrent : TFhirMedicationKnowledgeStorageGuideline;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirMedicationKnowledgeStorageGuidelineList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirMedicationKnowledgeStorageGuideline read GetCurrent;
  end;

  TFhirMedicationKnowledgeStorageGuidelineList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirMedicationKnowledgeStorageGuideline;
    procedure SetItemN(index : Integer; value : TFhirMedicationKnowledgeStorageGuideline);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirMedicationKnowledgeStorageGuidelineList; overload;
    function Clone : TFhirMedicationKnowledgeStorageGuidelineList; overload;
    function GetEnumerator : TFhirMedicationKnowledgeStorageGuidelineListEnumerator;
    
    //  Add a FhirMedicationKnowledgeStorageGuideline to the end of the list.
    function Append : TFhirMedicationKnowledgeStorageGuideline;
    
    // Add an already existing FhirMedicationKnowledgeStorageGuideline to the end of the list.
    function AddItem(value : TFhirMedicationKnowledgeStorageGuideline) : TFhirMedicationKnowledgeStorageGuideline; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirMedicationKnowledgeStorageGuideline) : Integer;
    
    // Insert FhirMedicationKnowledgeStorageGuideline before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirMedicationKnowledgeStorageGuideline;
    
    // Insert an existing FhirMedicationKnowledgeStorageGuideline before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirMedicationKnowledgeStorageGuideline);
    
    // Get the iIndexth FhirMedicationKnowledgeStorageGuideline. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirMedicationKnowledgeStorageGuideline);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirMedicationKnowledgeStorageGuideline;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirMedicationKnowledgeStorageGuidelines[index : Integer] : TFhirMedicationKnowledgeStorageGuideline read GetItemN write SetItemN; default;
  End;

  // Describes a setting/value on the environment for the adequate storage of the medication and other substances.  Environment settings may involve temperature, humidity, or exposure to light.
  TFhirMedicationKnowledgeStorageGuidelineEnvironmentalSetting = class (TFhirBackboneElement)
  protected
    FType_ : TFhirCodeableConcept;
    FValue : TFhirDataType;
    procedure SetType_(value : TFhirCodeableConcept);
    procedure SetValue(value : TFhirDataType);
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirMedicationKnowledgeStorageGuidelineEnvironmentalSetting; overload;
    function Clone : TFhirMedicationKnowledgeStorageGuidelineEnvironmentalSetting; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to Identifies the category or type of setting (e.g., type of location, temperature, humidity). (defined for API consistency)
    property type_ : TFhirCodeableConcept read FType_ write SetType_;
    // Identifies the category or type of setting (e.g., type of location, temperature, humidity).
    property type_Element : TFhirCodeableConcept read FType_ write SetType_;

    // Typed access to Value associated to the setting. E.g., 40° – 50°F for temperature. (defined for API consistency)
    property value : TFhirDataType read FValue write SetValue;
    // Value associated to the setting. E.g., 40° – 50°F for temperature.
    property valueElement : TFhirDataType read FValue write SetValue;

  end;

  TFhirMedicationKnowledgeStorageGuidelineEnvironmentalSettingListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirMedicationKnowledgeStorageGuidelineEnvironmentalSettingList;
    function GetCurrent : TFhirMedicationKnowledgeStorageGuidelineEnvironmentalSetting;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirMedicationKnowledgeStorageGuidelineEnvironmentalSettingList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirMedicationKnowledgeStorageGuidelineEnvironmentalSetting read GetCurrent;
  end;

  TFhirMedicationKnowledgeStorageGuidelineEnvironmentalSettingList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirMedicationKnowledgeStorageGuidelineEnvironmentalSetting;
    procedure SetItemN(index : Integer; value : TFhirMedicationKnowledgeStorageGuidelineEnvironmentalSetting);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirMedicationKnowledgeStorageGuidelineEnvironmentalSettingList; overload;
    function Clone : TFhirMedicationKnowledgeStorageGuidelineEnvironmentalSettingList; overload;
    function GetEnumerator : TFhirMedicationKnowledgeStorageGuidelineEnvironmentalSettingListEnumerator;
    
    //  Add a FhirMedicationKnowledgeStorageGuidelineEnvironmentalSetting to the end of the list.
    function Append : TFhirMedicationKnowledgeStorageGuidelineEnvironmentalSetting;
    
    // Add an already existing FhirMedicationKnowledgeStorageGuidelineEnvironmentalSetting to the end of the list.
    function AddItem(value : TFhirMedicationKnowledgeStorageGuidelineEnvironmentalSetting) : TFhirMedicationKnowledgeStorageGuidelineEnvironmentalSetting; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirMedicationKnowledgeStorageGuidelineEnvironmentalSetting) : Integer;
    
    // Insert FhirMedicationKnowledgeStorageGuidelineEnvironmentalSetting before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirMedicationKnowledgeStorageGuidelineEnvironmentalSetting;
    
    // Insert an existing FhirMedicationKnowledgeStorageGuidelineEnvironmentalSetting before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirMedicationKnowledgeStorageGuidelineEnvironmentalSetting);
    
    // Get the iIndexth FhirMedicationKnowledgeStorageGuidelineEnvironmentalSetting. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirMedicationKnowledgeStorageGuidelineEnvironmentalSetting);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirMedicationKnowledgeStorageGuidelineEnvironmentalSetting;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirMedicationKnowledgeStorageGuidelineEnvironmentalSettings[index : Integer] : TFhirMedicationKnowledgeStorageGuidelineEnvironmentalSetting read GetItemN write SetItemN; default;
  End;

  // Regulatory information about a medication.
  TFhirMedicationKnowledgeRegulatory = class (TFhirBackboneElement)
  protected
    FRegulatoryAuthority : TFhirReference;
    FsubstitutionList : TFhirMedicationKnowledgeRegulatorySubstitutionList;
    FscheduleList : TFhirCodeableConceptList;
    FMaxDispense : TFhirMedicationKnowledgeRegulatoryMaxDispense;
    procedure SetRegulatoryAuthority(value : TFhirReference);
    function GetSubstitutionList : TFhirMedicationKnowledgeRegulatorySubstitutionList;
    function GetHasSubstitutionList : Boolean;
    function GetScheduleList : TFhirCodeableConceptList;
    function GetHasScheduleList : Boolean;
    procedure SetMaxDispense(value : TFhirMedicationKnowledgeRegulatoryMaxDispense);
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirMedicationKnowledgeRegulatory; overload;
    function Clone : TFhirMedicationKnowledgeRegulatory; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to The authority that is specifying the regulations. (defined for API consistency)
    property regulatoryAuthority : TFhirReference read FRegulatoryAuthority write SetRegulatoryAuthority;
    // The authority that is specifying the regulations.
    property regulatoryAuthorityElement : TFhirReference read FRegulatoryAuthority write SetRegulatoryAuthority;

    // Specifies if changes are allowed when dispensing a medication from a regulatory perspective.
    property substitutionList : TFhirMedicationKnowledgeRegulatorySubstitutionList read GetSubstitutionList;
    property hasSubstitutionList : boolean read GetHasSubstitutionList;

    // Specifies the schedule of a medication in jurisdiction.
    property scheduleList : TFhirCodeableConceptList read GetScheduleList;
    property hasScheduleList : boolean read GetHasScheduleList;

    // Typed access to The maximum number of units of the medication that can be dispensed in a period. (defined for API consistency)
    property maxDispense : TFhirMedicationKnowledgeRegulatoryMaxDispense read FMaxDispense write SetMaxDispense;
    // The maximum number of units of the medication that can be dispensed in a period.
    property maxDispenseElement : TFhirMedicationKnowledgeRegulatoryMaxDispense read FMaxDispense write SetMaxDispense;

  end;

  TFhirMedicationKnowledgeRegulatoryListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirMedicationKnowledgeRegulatoryList;
    function GetCurrent : TFhirMedicationKnowledgeRegulatory;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirMedicationKnowledgeRegulatoryList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirMedicationKnowledgeRegulatory read GetCurrent;
  end;

  TFhirMedicationKnowledgeRegulatoryList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirMedicationKnowledgeRegulatory;
    procedure SetItemN(index : Integer; value : TFhirMedicationKnowledgeRegulatory);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirMedicationKnowledgeRegulatoryList; overload;
    function Clone : TFhirMedicationKnowledgeRegulatoryList; overload;
    function GetEnumerator : TFhirMedicationKnowledgeRegulatoryListEnumerator;
    
    //  Add a FhirMedicationKnowledgeRegulatory to the end of the list.
    function Append : TFhirMedicationKnowledgeRegulatory;
    
    // Add an already existing FhirMedicationKnowledgeRegulatory to the end of the list.
    function AddItem(value : TFhirMedicationKnowledgeRegulatory) : TFhirMedicationKnowledgeRegulatory; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirMedicationKnowledgeRegulatory) : Integer;
    
    // Insert FhirMedicationKnowledgeRegulatory before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirMedicationKnowledgeRegulatory;
    
    // Insert an existing FhirMedicationKnowledgeRegulatory before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirMedicationKnowledgeRegulatory);
    
    // Get the iIndexth FhirMedicationKnowledgeRegulatory. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirMedicationKnowledgeRegulatory);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirMedicationKnowledgeRegulatory;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirMedicationKnowledgeRegulatories[index : Integer] : TFhirMedicationKnowledgeRegulatory read GetItemN write SetItemN; default;
  End;

  // Specifies if changes are allowed when dispensing a medication from a regulatory perspective.
  TFhirMedicationKnowledgeRegulatorySubstitution = class (TFhirBackboneElement)
  protected
    FType_ : TFhirCodeableConcept;
    FAllowed : TFhirBoolean;
    procedure SetType_(value : TFhirCodeableConcept);
    procedure SetAllowed(value : TFhirBoolean);
    function GetAllowedST : Boolean;
    procedure SetAllowedST(value : Boolean);
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirMedicationKnowledgeRegulatorySubstitution; overload;
    function Clone : TFhirMedicationKnowledgeRegulatorySubstitution; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to Specifies the type of substitution allowed. (defined for API consistency)
    property type_ : TFhirCodeableConcept read FType_ write SetType_;
    // Specifies the type of substitution allowed.
    property type_Element : TFhirCodeableConcept read FType_ write SetType_;

    // Typed access to Specifies if regulation allows for changes in the medication when dispensing.
    property allowed : Boolean read GetAllowedST write SetAllowedST;
    // Specifies if regulation allows for changes in the medication when dispensing.
    property allowedElement : TFhirBoolean read FAllowed write SetAllowed;

  end;

  TFhirMedicationKnowledgeRegulatorySubstitutionListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirMedicationKnowledgeRegulatorySubstitutionList;
    function GetCurrent : TFhirMedicationKnowledgeRegulatorySubstitution;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirMedicationKnowledgeRegulatorySubstitutionList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirMedicationKnowledgeRegulatorySubstitution read GetCurrent;
  end;

  TFhirMedicationKnowledgeRegulatorySubstitutionList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirMedicationKnowledgeRegulatorySubstitution;
    procedure SetItemN(index : Integer; value : TFhirMedicationKnowledgeRegulatorySubstitution);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirMedicationKnowledgeRegulatorySubstitutionList; overload;
    function Clone : TFhirMedicationKnowledgeRegulatorySubstitutionList; overload;
    function GetEnumerator : TFhirMedicationKnowledgeRegulatorySubstitutionListEnumerator;
    
    //  Add a FhirMedicationKnowledgeRegulatorySubstitution to the end of the list.
    function Append : TFhirMedicationKnowledgeRegulatorySubstitution;
    
    // Add an already existing FhirMedicationKnowledgeRegulatorySubstitution to the end of the list.
    function AddItem(value : TFhirMedicationKnowledgeRegulatorySubstitution) : TFhirMedicationKnowledgeRegulatorySubstitution; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirMedicationKnowledgeRegulatorySubstitution) : Integer;
    
    // Insert FhirMedicationKnowledgeRegulatorySubstitution before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirMedicationKnowledgeRegulatorySubstitution;
    
    // Insert an existing FhirMedicationKnowledgeRegulatorySubstitution before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirMedicationKnowledgeRegulatorySubstitution);
    
    // Get the iIndexth FhirMedicationKnowledgeRegulatorySubstitution. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirMedicationKnowledgeRegulatorySubstitution);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirMedicationKnowledgeRegulatorySubstitution;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirMedicationKnowledgeRegulatorySubstitutions[index : Integer] : TFhirMedicationKnowledgeRegulatorySubstitution read GetItemN write SetItemN; default;
  End;

  // The maximum number of units of the medication that can be dispensed in a period.
  TFhirMedicationKnowledgeRegulatoryMaxDispense = class (TFhirBackboneElement)
  protected
    FQuantity : TFhirQuantity;
    FPeriod : TFhirDuration;
    procedure SetQuantity(value : TFhirQuantity);
    procedure SetPeriod(value : TFhirDuration);
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirMedicationKnowledgeRegulatoryMaxDispense; overload;
    function Clone : TFhirMedicationKnowledgeRegulatoryMaxDispense; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to The maximum number of units of the medication that can be dispensed. (defined for API consistency)
    property quantity : TFhirQuantity read FQuantity write SetQuantity;
    // The maximum number of units of the medication that can be dispensed.
    property quantityElement : TFhirQuantity read FQuantity write SetQuantity;

    // Typed access to The period that applies to the maximum number of units. (defined for API consistency)
    property period : TFhirDuration read FPeriod write SetPeriod;
    // The period that applies to the maximum number of units.
    property periodElement : TFhirDuration read FPeriod write SetPeriod;

  end;

  TFhirMedicationKnowledgeRegulatoryMaxDispenseListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirMedicationKnowledgeRegulatoryMaxDispenseList;
    function GetCurrent : TFhirMedicationKnowledgeRegulatoryMaxDispense;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirMedicationKnowledgeRegulatoryMaxDispenseList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirMedicationKnowledgeRegulatoryMaxDispense read GetCurrent;
  end;

  TFhirMedicationKnowledgeRegulatoryMaxDispenseList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirMedicationKnowledgeRegulatoryMaxDispense;
    procedure SetItemN(index : Integer; value : TFhirMedicationKnowledgeRegulatoryMaxDispense);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirMedicationKnowledgeRegulatoryMaxDispenseList; overload;
    function Clone : TFhirMedicationKnowledgeRegulatoryMaxDispenseList; overload;
    function GetEnumerator : TFhirMedicationKnowledgeRegulatoryMaxDispenseListEnumerator;
    
    //  Add a FhirMedicationKnowledgeRegulatoryMaxDispense to the end of the list.
    function Append : TFhirMedicationKnowledgeRegulatoryMaxDispense;
    
    // Add an already existing FhirMedicationKnowledgeRegulatoryMaxDispense to the end of the list.
    function AddItem(value : TFhirMedicationKnowledgeRegulatoryMaxDispense) : TFhirMedicationKnowledgeRegulatoryMaxDispense; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirMedicationKnowledgeRegulatoryMaxDispense) : Integer;
    
    // Insert FhirMedicationKnowledgeRegulatoryMaxDispense before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirMedicationKnowledgeRegulatoryMaxDispense;
    
    // Insert an existing FhirMedicationKnowledgeRegulatoryMaxDispense before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirMedicationKnowledgeRegulatoryMaxDispense);
    
    // Get the iIndexth FhirMedicationKnowledgeRegulatoryMaxDispense. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirMedicationKnowledgeRegulatoryMaxDispense);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirMedicationKnowledgeRegulatoryMaxDispense;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirMedicationKnowledgeRegulatoryMaxDispenses[index : Integer] : TFhirMedicationKnowledgeRegulatoryMaxDispense read GetItemN write SetItemN; default;
  End;

  // Along with the link to a Medicinal Product Definition resource, this information provides common definitional elements that are needed to understand the specific medication that is being described.
  TFhirMedicationKnowledgeDefinitional = class (TFhirBackboneElement)
  protected
    FdefinitionList : TFhirReferenceList;
    FDoseForm : TFhirCodeableConcept;
    FintendedRouteList : TFhirCodeableConceptList;
    FingredientList : TFhirMedicationKnowledgeDefinitionalIngredientList;
    FdrugCharacteristicList : TFhirMedicationKnowledgeDefinitionalDrugCharacteristicList;
    function GetDefinitionList : TFhirReferenceList;
    function GetHasDefinitionList : Boolean;
    procedure SetDoseForm(value : TFhirCodeableConcept);
    function GetIntendedRouteList : TFhirCodeableConceptList;
    function GetHasIntendedRouteList : Boolean;
    function GetIngredientList : TFhirMedicationKnowledgeDefinitionalIngredientList;
    function GetHasIngredientList : Boolean;
    function GetDrugCharacteristicList : TFhirMedicationKnowledgeDefinitionalDrugCharacteristicList;
    function GetHasDrugCharacteristicList : Boolean;
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirMedicationKnowledgeDefinitional; overload;
    function Clone : TFhirMedicationKnowledgeDefinitional; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Associated definitions for this medication.
    property definitionList : TFhirReferenceList read GetDefinitionList;
    property hasDefinitionList : boolean read GetHasDefinitionList;

    // Typed access to Describes the form of the item.  Powder; tablets; capsule. (defined for API consistency)
    property doseForm : TFhirCodeableConcept read FDoseForm write SetDoseForm;
    // Describes the form of the item.  Powder; tablets; capsule.
    property doseFormElement : TFhirCodeableConcept read FDoseForm write SetDoseForm;

    // The intended or approved route of administration.
    property intendedRouteList : TFhirCodeableConceptList read GetIntendedRouteList;
    property hasIntendedRouteList : boolean read GetHasIntendedRouteList;

    // Identifies a particular constituent of interest in the product.
    property ingredientList : TFhirMedicationKnowledgeDefinitionalIngredientList read GetIngredientList;
    property hasIngredientList : boolean read GetHasIngredientList;

    // Specifies descriptive properties of the medicine, such as color, shape, imprints, etc.
    property drugCharacteristicList : TFhirMedicationKnowledgeDefinitionalDrugCharacteristicList read GetDrugCharacteristicList;
    property hasDrugCharacteristicList : boolean read GetHasDrugCharacteristicList;

  end;

  TFhirMedicationKnowledgeDefinitionalListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirMedicationKnowledgeDefinitionalList;
    function GetCurrent : TFhirMedicationKnowledgeDefinitional;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirMedicationKnowledgeDefinitionalList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirMedicationKnowledgeDefinitional read GetCurrent;
  end;

  TFhirMedicationKnowledgeDefinitionalList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirMedicationKnowledgeDefinitional;
    procedure SetItemN(index : Integer; value : TFhirMedicationKnowledgeDefinitional);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirMedicationKnowledgeDefinitionalList; overload;
    function Clone : TFhirMedicationKnowledgeDefinitionalList; overload;
    function GetEnumerator : TFhirMedicationKnowledgeDefinitionalListEnumerator;
    
    //  Add a FhirMedicationKnowledgeDefinitional to the end of the list.
    function Append : TFhirMedicationKnowledgeDefinitional;
    
    // Add an already existing FhirMedicationKnowledgeDefinitional to the end of the list.
    function AddItem(value : TFhirMedicationKnowledgeDefinitional) : TFhirMedicationKnowledgeDefinitional; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirMedicationKnowledgeDefinitional) : Integer;
    
    // Insert FhirMedicationKnowledgeDefinitional before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirMedicationKnowledgeDefinitional;
    
    // Insert an existing FhirMedicationKnowledgeDefinitional before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirMedicationKnowledgeDefinitional);
    
    // Get the iIndexth FhirMedicationKnowledgeDefinitional. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirMedicationKnowledgeDefinitional);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirMedicationKnowledgeDefinitional;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirMedicationKnowledgeDefinitionals[index : Integer] : TFhirMedicationKnowledgeDefinitional read GetItemN write SetItemN; default;
  End;

  // Identifies a particular constituent of interest in the product.
  TFhirMedicationKnowledgeDefinitionalIngredient = class (TFhirBackboneElement)
  protected
    FItem : TFhirCodeableReference;
    FType_ : TFhirCodeableConcept;
    FStrength : TFhirDataType;
    procedure SetItem(value : TFhirCodeableReference);
    procedure SetType_(value : TFhirCodeableConcept);
    procedure SetStrength(value : TFhirDataType);
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirMedicationKnowledgeDefinitionalIngredient; overload;
    function Clone : TFhirMedicationKnowledgeDefinitionalIngredient; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to A reference to the resource that provides information about the ingredient. (defined for API consistency)
    property item : TFhirCodeableReference read FItem write SetItem;
    // A reference to the resource that provides information about the ingredient.
    property itemElement : TFhirCodeableReference read FItem write SetItem;

    // Typed access to Indication of whether this ingredient affects the therapeutic action of the drug. (defined for API consistency)
    property type_ : TFhirCodeableConcept read FType_ write SetType_;
    // Indication of whether this ingredient affects the therapeutic action of the drug.
    property type_Element : TFhirCodeableConcept read FType_ write SetType_;

    // Typed access to Specifies how many (or how much) of the items there are in this Medication.  For example, 250 mg per tablet.  This is expressed as a ratio where the numerator is 250mg and the denominator is 1 tablet but can also be expressed a quantity when the denominator is assumed to be 1 tablet. (defined for API consistency)
    property strength : TFhirDataType read FStrength write SetStrength;
    // Specifies how many (or how much) of the items there are in this Medication.  For example, 250 mg per tablet.  This is expressed as a ratio where the numerator is 250mg and the denominator is 1 tablet but can also be expressed a quantity when the denominator is assumed to be 1 tablet.
    property strengthElement : TFhirDataType read FStrength write SetStrength;

  end;

  TFhirMedicationKnowledgeDefinitionalIngredientListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirMedicationKnowledgeDefinitionalIngredientList;
    function GetCurrent : TFhirMedicationKnowledgeDefinitionalIngredient;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirMedicationKnowledgeDefinitionalIngredientList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirMedicationKnowledgeDefinitionalIngredient read GetCurrent;
  end;

  TFhirMedicationKnowledgeDefinitionalIngredientList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirMedicationKnowledgeDefinitionalIngredient;
    procedure SetItemN(index : Integer; value : TFhirMedicationKnowledgeDefinitionalIngredient);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirMedicationKnowledgeDefinitionalIngredientList; overload;
    function Clone : TFhirMedicationKnowledgeDefinitionalIngredientList; overload;
    function GetEnumerator : TFhirMedicationKnowledgeDefinitionalIngredientListEnumerator;
    
    //  Add a FhirMedicationKnowledgeDefinitionalIngredient to the end of the list.
    function Append : TFhirMedicationKnowledgeDefinitionalIngredient;
    
    // Add an already existing FhirMedicationKnowledgeDefinitionalIngredient to the end of the list.
    function AddItem(value : TFhirMedicationKnowledgeDefinitionalIngredient) : TFhirMedicationKnowledgeDefinitionalIngredient; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirMedicationKnowledgeDefinitionalIngredient) : Integer;
    
    // Insert FhirMedicationKnowledgeDefinitionalIngredient before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirMedicationKnowledgeDefinitionalIngredient;
    
    // Insert an existing FhirMedicationKnowledgeDefinitionalIngredient before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirMedicationKnowledgeDefinitionalIngredient);
    
    // Get the iIndexth FhirMedicationKnowledgeDefinitionalIngredient. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirMedicationKnowledgeDefinitionalIngredient);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirMedicationKnowledgeDefinitionalIngredient;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirMedicationKnowledgeDefinitionalIngredients[index : Integer] : TFhirMedicationKnowledgeDefinitionalIngredient read GetItemN write SetItemN; default;
  End;

  // Specifies descriptive properties of the medicine, such as color, shape, imprints, etc.
  TFhirMedicationKnowledgeDefinitionalDrugCharacteristic = class (TFhirBackboneElement)
  protected
    FType_ : TFhirCodeableConcept;
    FValue : TFhirDataType;
    procedure SetType_(value : TFhirCodeableConcept);
    procedure SetValue(value : TFhirDataType);
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirMedicationKnowledgeDefinitionalDrugCharacteristic; overload;
    function Clone : TFhirMedicationKnowledgeDefinitionalDrugCharacteristic; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to A code specifying which characteristic of the medicine is being described (for example, colour, shape, imprint). (defined for API consistency)
    property type_ : TFhirCodeableConcept read FType_ write SetType_;
    // A code specifying which characteristic of the medicine is being described (for example, colour, shape, imprint).
    property type_Element : TFhirCodeableConcept read FType_ write SetType_;

    // Typed access to Description of the characteristic. (defined for API consistency)
    property value : TFhirDataType read FValue write SetValue;
    // Description of the characteristic.
    property valueElement : TFhirDataType read FValue write SetValue;

  end;

  TFhirMedicationKnowledgeDefinitionalDrugCharacteristicListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirMedicationKnowledgeDefinitionalDrugCharacteristicList;
    function GetCurrent : TFhirMedicationKnowledgeDefinitionalDrugCharacteristic;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirMedicationKnowledgeDefinitionalDrugCharacteristicList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirMedicationKnowledgeDefinitionalDrugCharacteristic read GetCurrent;
  end;

  TFhirMedicationKnowledgeDefinitionalDrugCharacteristicList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirMedicationKnowledgeDefinitionalDrugCharacteristic;
    procedure SetItemN(index : Integer; value : TFhirMedicationKnowledgeDefinitionalDrugCharacteristic);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirMedicationKnowledgeDefinitionalDrugCharacteristicList; overload;
    function Clone : TFhirMedicationKnowledgeDefinitionalDrugCharacteristicList; overload;
    function GetEnumerator : TFhirMedicationKnowledgeDefinitionalDrugCharacteristicListEnumerator;
    
    //  Add a FhirMedicationKnowledgeDefinitionalDrugCharacteristic to the end of the list.
    function Append : TFhirMedicationKnowledgeDefinitionalDrugCharacteristic;
    
    // Add an already existing FhirMedicationKnowledgeDefinitionalDrugCharacteristic to the end of the list.
    function AddItem(value : TFhirMedicationKnowledgeDefinitionalDrugCharacteristic) : TFhirMedicationKnowledgeDefinitionalDrugCharacteristic; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirMedicationKnowledgeDefinitionalDrugCharacteristic) : Integer;
    
    // Insert FhirMedicationKnowledgeDefinitionalDrugCharacteristic before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirMedicationKnowledgeDefinitionalDrugCharacteristic;
    
    // Insert an existing FhirMedicationKnowledgeDefinitionalDrugCharacteristic before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirMedicationKnowledgeDefinitionalDrugCharacteristic);
    
    // Get the iIndexth FhirMedicationKnowledgeDefinitionalDrugCharacteristic. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirMedicationKnowledgeDefinitionalDrugCharacteristic);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirMedicationKnowledgeDefinitionalDrugCharacteristic;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirMedicationKnowledgeDefinitionalDrugCharacteristics[index : Integer] : TFhirMedicationKnowledgeDefinitionalDrugCharacteristic read GetItemN write SetItemN; default;
  End;

  // Information about a medication that is used to support knowledge.
  TFhirMedicationKnowledge = class (TFhirMetadataResource)
  protected
    FCode : TFhirCodeableConcept;
    FintendedJurisdictionList : TFhirCodeableConceptList;
    FrelatedMedicationKnowledgeList : TFhirMedicationKnowledgeRelatedMedicationKnowledgeList;
    FassociatedMedicationList : TFhirReferenceList;
    FproductTypeList : TFhirCodeableConceptList;
    FmonographList : TFhirMedicationKnowledgeMonographList;
    FPreparationInstruction : TFhirMarkdown;
    FcostList : TFhirMedicationKnowledgeCostList;
    FmonitoringProgramList : TFhirMedicationKnowledgeMonitoringProgramList;
    FindicationGuidelineList : TFhirMedicationKnowledgeIndicationGuidelineList;
    FmedicineClassificationList : TFhirMedicationKnowledgeMedicineClassificationList;
    FpackagingList : TFhirMedicationKnowledgePackagingList;
    FclinicalUseIssueList : TFhirReferenceList;
    FstorageGuidelineList : TFhirMedicationKnowledgeStorageGuidelineList;
    FregulatoryList : TFhirMedicationKnowledgeRegulatoryList;
    FDefinitional : TFhirMedicationKnowledgeDefinitional;
    function GetIdentifierList : TFhirIdentifierList;
    function GetHasIdentifierList : Boolean;
    procedure SetCode(value : TFhirCodeableConcept);
    procedure SetStatus(value : TFhirEnum);
    function GetStatusST : TFhirMedicationKnowledgeStatusCodesEnum;
    procedure SetStatusST(value : TFhirMedicationKnowledgeStatusCodesEnum);
    procedure SetAuthor(value : TFhirContactDetail);
    function GetAuthor : TFhirContactDetail;
    function GetIntendedJurisdictionList : TFhirCodeableConceptList;
    function GetHasIntendedJurisdictionList : Boolean;
    function GetNameList : TFhirStringList;
    function GetHasNameList : Boolean;
    function GetRelatedMedicationKnowledgeList : TFhirMedicationKnowledgeRelatedMedicationKnowledgeList;
    function GetHasRelatedMedicationKnowledgeList : Boolean;
    function GetAssociatedMedicationList : TFhirReferenceList;
    function GetHasAssociatedMedicationList : Boolean;
    function GetProductTypeList : TFhirCodeableConceptList;
    function GetHasProductTypeList : Boolean;
    function GetMonographList : TFhirMedicationKnowledgeMonographList;
    function GetHasMonographList : Boolean;
    procedure SetPreparationInstruction(value : TFhirMarkdown);
    function GetPreparationInstructionST : String;
    procedure SetPreparationInstructionST(value : String);
    function GetCostList : TFhirMedicationKnowledgeCostList;
    function GetHasCostList : Boolean;
    function GetMonitoringProgramList : TFhirMedicationKnowledgeMonitoringProgramList;
    function GetHasMonitoringProgramList : Boolean;
    function GetIndicationGuidelineList : TFhirMedicationKnowledgeIndicationGuidelineList;
    function GetHasIndicationGuidelineList : Boolean;
    function GetMedicineClassificationList : TFhirMedicationKnowledgeMedicineClassificationList;
    function GetHasMedicineClassificationList : Boolean;
    function GetPackagingList : TFhirMedicationKnowledgePackagingList;
    function GetHasPackagingList : Boolean;
    function GetClinicalUseIssueList : TFhirReferenceList;
    function GetHasClinicalUseIssueList : Boolean;
    function GetStorageGuidelineList : TFhirMedicationKnowledgeStorageGuidelineList;
    function GetHasStorageGuidelineList : Boolean;
    function GetRegulatoryList : TFhirMedicationKnowledgeRegulatoryList;
    function GetHasRegulatoryList : Boolean;
    procedure SetDefinitional(value : TFhirMedicationKnowledgeDefinitional);
  
    function GetResourceType : TFhirResourceType; override;
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirMedicationKnowledge; overload;
    function Clone : TFhirMedicationKnowledge; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Business identifier for this medication.
    property identifierList : TFhirIdentifierList read GetIdentifierList;
    property hasIdentifierList : boolean read GetHasIdentifierList;

    // Typed access to A code that specifies this medication, or a textual description if no code is available. Usage note: This could be a standard medication code such as a code from RxNorm, SNOMED CT, IDMP etc. It could also be a national or local formulary code, optionally with translations to other code systems. (defined for API consistency)
    property code : TFhirCodeableConcept read FCode write SetCode;
    // A code that specifies this medication, or a textual description if no code is available. Usage note: This could be a standard medication code such as a code from RxNorm, SNOMED CT, IDMP etc. It could also be a national or local formulary code, optionally with translations to other code systems.
    property codeElement : TFhirCodeableConcept read FCode write SetCode;

    // A code to indicate if the medication referred to by this MedicationKnowledge is in active use within the drug database or inventory system. The status refers to the validity about the information of the medication and not to its medicinal properties.
    property status : TFhirMedicationKnowledgeStatusCodesEnum read GetStatusST write SetStatusST;
    property statusElement : TFhirEnum read FStatus write SetStatus;

    // Typed access to The creator or owner of the knowledge or information about the medication. (defined for API consistency)
    property author : TFhirContactDetail read GetAuthor write SetAuthor; // !! change cardinality - base has a list
    // The creator or owner of the knowledge or information about the medication.
    property authorElement : TFhirContactDetail read GetAuthor write SetAuthor;

    // Lists the jurisdictions that this medication knowledge was written for.
    property intendedJurisdictionList : TFhirCodeableConceptList read GetIntendedJurisdictionList;
    property hasIntendedJurisdictionList : boolean read GetHasIntendedJurisdictionList;

    // All of the names for a medication, for example, the name(s) given to a medication in different countries.  For example, acetaminophen and paracetamol or salbutamol and albuterol.
    property nameList : TFhirStringList read GetNameList;
    property hasNameList : boolean read GetHasNameList;

    // Associated or related medications. For example, if the medication is a branded product (e.g. Crestor), this is the Therapeutic Moeity (e.g. Rosuvastatin) or if this is a generic medication (e.g. Rosuvastatin), this would link to a branded product (e.g. Crestor.
    property relatedMedicationKnowledgeList : TFhirMedicationKnowledgeRelatedMedicationKnowledgeList read GetRelatedMedicationKnowledgeList;
    property hasRelatedMedicationKnowledgeList : boolean read GetHasRelatedMedicationKnowledgeList;

    // Links to associated medications that could be prescribed, dispensed or administered.
    property associatedMedicationList : TFhirReferenceList read GetAssociatedMedicationList;
    property hasAssociatedMedicationList : boolean read GetHasAssociatedMedicationList;

    // Category of the medication or product (e.g. branded product, therapeutic moeity, generic product, innovator product, etc.).
    property productTypeList : TFhirCodeableConceptList read GetProductTypeList;
    property hasProductTypeList : boolean read GetHasProductTypeList;

    // Associated documentation about the medication.
    property monographList : TFhirMedicationKnowledgeMonographList read GetMonographList;
    property hasMonographList : boolean read GetHasMonographList;

    // Typed access to The instructions for preparing the medication.
    property preparationInstruction : String read GetPreparationInstructionST write SetPreparationInstructionST;
    // The instructions for preparing the medication.
    property preparationInstructionElement : TFhirMarkdown read FPreparationInstruction write SetPreparationInstruction;

    // The price of the medication.
    property costList : TFhirMedicationKnowledgeCostList read GetCostList;
    property hasCostList : boolean read GetHasCostList;

    // The program under which the medication is reviewed.
    property monitoringProgramList : TFhirMedicationKnowledgeMonitoringProgramList read GetMonitoringProgramList;
    property hasMonitoringProgramList : boolean read GetHasMonitoringProgramList;

    // Guidelines or protocols that are applicable for the administration of the medication based on indication.
    property indicationGuidelineList : TFhirMedicationKnowledgeIndicationGuidelineList read GetIndicationGuidelineList;
    property hasIndicationGuidelineList : boolean read GetHasIndicationGuidelineList;

    // Categorization of the medication within a formulary or classification system.
    property medicineClassificationList : TFhirMedicationKnowledgeMedicineClassificationList read GetMedicineClassificationList;
    property hasMedicineClassificationList : boolean read GetHasMedicineClassificationList;

    // Information that only applies to packages (not products).
    property packagingList : TFhirMedicationKnowledgePackagingList read GetPackagingList;
    property hasPackagingList : boolean read GetHasPackagingList;

    // Potential clinical issue with or between medication(s) (for example, drug-drug interaction, drug-disease contraindication, drug-allergy interaction, etc.).
    property clinicalUseIssueList : TFhirReferenceList read GetClinicalUseIssueList;
    property hasClinicalUseIssueList : boolean read GetHasClinicalUseIssueList;

    // Information on how the medication should be stored, for example, refrigeration temperatures and length of stability at a given temperature.
    property storageGuidelineList : TFhirMedicationKnowledgeStorageGuidelineList read GetStorageGuidelineList;
    property hasStorageGuidelineList : boolean read GetHasStorageGuidelineList;

    // Regulatory information about a medication.
    property regulatoryList : TFhirMedicationKnowledgeRegulatoryList read GetRegulatoryList;
    property hasRegulatoryList : boolean read GetHasRegulatoryList;

    // Typed access to Along with the link to a Medicinal Product Definition resource, this information provides common definitional elements that are needed to understand the specific medication that is being described. (defined for API consistency)
    property definitional : TFhirMedicationKnowledgeDefinitional read FDefinitional write SetDefinitional;
    // Along with the link to a Medicinal Product Definition resource, this information provides common definitional elements that are needed to understand the specific medication that is being described.
    property definitionalElement : TFhirMedicationKnowledgeDefinitional read FDefinitional write SetDefinitional;

  end;

  TFhirMedicationKnowledgeListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirMedicationKnowledgeList;
    function GetCurrent : TFhirMedicationKnowledge;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirMedicationKnowledgeList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirMedicationKnowledge read GetCurrent;
  end;

  TFhirMedicationKnowledgeList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirMedicationKnowledge;
    procedure SetItemN(index : Integer; value : TFhirMedicationKnowledge);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirMedicationKnowledgeList; overload;
    function Clone : TFhirMedicationKnowledgeList; overload;
    function GetEnumerator : TFhirMedicationKnowledgeListEnumerator;
    
    //  Add a FhirMedicationKnowledge to the end of the list.
    function Append : TFhirMedicationKnowledge;
    
    // Add an already existing FhirMedicationKnowledge to the end of the list.
    function AddItem(value : TFhirMedicationKnowledge) : TFhirMedicationKnowledge; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirMedicationKnowledge) : Integer;
    
    // Insert FhirMedicationKnowledge before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirMedicationKnowledge;
    
    // Insert an existing FhirMedicationKnowledge before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirMedicationKnowledge);
    
    // Get the iIndexth FhirMedicationKnowledge. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirMedicationKnowledge);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirMedicationKnowledge;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirMedicationKnowledges[index : Integer] : TFhirMedicationKnowledge read GetItemN write SetItemN; default;
  End;

{$ENDIF FHIR_MEDICATIONKNOWLEDGE}
{$IFDEF FHIR_MEDICINALPRODUCTDEFINITION}
  // A product specific contact, person (in a role), or an organization.
  TFhirMedicinalProductDefinitionContact = class (TFhirBackboneElement)
  protected
    FType_ : TFhirCodeableConcept;
    FContact : TFhirReference;
    procedure SetType_(value : TFhirCodeableConcept);
    procedure SetContact(value : TFhirReference);
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirMedicinalProductDefinitionContact; overload;
    function Clone : TFhirMedicinalProductDefinitionContact; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to Allows the contact to be classified, for example QPPV, Pharmacovigilance Enquiry Information. (defined for API consistency)
    property type_ : TFhirCodeableConcept read FType_ write SetType_;
    // Allows the contact to be classified, for example QPPV, Pharmacovigilance Enquiry Information.
    property type_Element : TFhirCodeableConcept read FType_ write SetType_;

    // Typed access to A product specific contact, person (in a role), or an organization. (defined for API consistency)
    property contact : TFhirReference read FContact write SetContact;
    // A product specific contact, person (in a role), or an organization.
    property contactElement : TFhirReference read FContact write SetContact;

  end;

  TFhirMedicinalProductDefinitionContactListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirMedicinalProductDefinitionContactList;
    function GetCurrent : TFhirMedicinalProductDefinitionContact;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirMedicinalProductDefinitionContactList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirMedicinalProductDefinitionContact read GetCurrent;
  end;

  TFhirMedicinalProductDefinitionContactList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirMedicinalProductDefinitionContact;
    procedure SetItemN(index : Integer; value : TFhirMedicinalProductDefinitionContact);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirMedicinalProductDefinitionContactList; overload;
    function Clone : TFhirMedicinalProductDefinitionContactList; overload;
    function GetEnumerator : TFhirMedicinalProductDefinitionContactListEnumerator;
    
    //  Add a FhirMedicinalProductDefinitionContact to the end of the list.
    function Append : TFhirMedicinalProductDefinitionContact;
    
    // Add an already existing FhirMedicinalProductDefinitionContact to the end of the list.
    function AddItem(value : TFhirMedicinalProductDefinitionContact) : TFhirMedicinalProductDefinitionContact; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirMedicinalProductDefinitionContact) : Integer;
    
    // Insert FhirMedicinalProductDefinitionContact before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirMedicinalProductDefinitionContact;
    
    // Insert an existing FhirMedicinalProductDefinitionContact before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirMedicinalProductDefinitionContact);
    
    // Get the iIndexth FhirMedicinalProductDefinitionContact. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirMedicinalProductDefinitionContact);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirMedicinalProductDefinitionContact;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirMedicinalProductDefinitionContacts[index : Integer] : TFhirMedicinalProductDefinitionContact read GetItemN write SetItemN; default;
  End;

  // The product's name, including full name and possibly coded parts.
  TFhirMedicinalProductDefinitionName = class (TFhirBackboneElement)
  protected
    FProductName : TFhirString;
    FType_ : TFhirCodeableConcept;
    FpartList : TFhirMedicinalProductDefinitionNamePartList;
    FusageList : TFhirMedicinalProductDefinitionNameUsageList;
    procedure SetProductName(value : TFhirString);
    function GetProductNameST : String;
    procedure SetProductNameST(value : String);
    procedure SetType_(value : TFhirCodeableConcept);
    function GetPartList : TFhirMedicinalProductDefinitionNamePartList;
    function GetHasPartList : Boolean;
    function GetUsageList : TFhirMedicinalProductDefinitionNameUsageList;
    function GetHasUsageList : Boolean;
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirMedicinalProductDefinitionName; overload;
    function Clone : TFhirMedicinalProductDefinitionName; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to The full product name.
    property productName : String read GetProductNameST write SetProductNameST;
    // The full product name.
    property productNameElement : TFhirString read FProductName write SetProductName;

    // Typed access to Type of product name, such as rINN, BAN, Proprietary, Non-Proprietary. (defined for API consistency)
    property type_ : TFhirCodeableConcept read FType_ write SetType_;
    // Type of product name, such as rINN, BAN, Proprietary, Non-Proprietary.
    property type_Element : TFhirCodeableConcept read FType_ write SetType_;

    // Coding words or phrases of the name.
    property partList : TFhirMedicinalProductDefinitionNamePartList read GetPartList;
    property hasPartList : boolean read GetHasPartList;

    // Country and jurisdiction where the name applies, and associated language.
    property usageList : TFhirMedicinalProductDefinitionNameUsageList read GetUsageList;
    property hasUsageList : boolean read GetHasUsageList;

  end;

  TFhirMedicinalProductDefinitionNameListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirMedicinalProductDefinitionNameList;
    function GetCurrent : TFhirMedicinalProductDefinitionName;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirMedicinalProductDefinitionNameList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirMedicinalProductDefinitionName read GetCurrent;
  end;

  TFhirMedicinalProductDefinitionNameList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirMedicinalProductDefinitionName;
    procedure SetItemN(index : Integer; value : TFhirMedicinalProductDefinitionName);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirMedicinalProductDefinitionNameList; overload;
    function Clone : TFhirMedicinalProductDefinitionNameList; overload;
    function GetEnumerator : TFhirMedicinalProductDefinitionNameListEnumerator;
    
    //  Add a FhirMedicinalProductDefinitionName to the end of the list.
    function Append : TFhirMedicinalProductDefinitionName;
    
    // Add an already existing FhirMedicinalProductDefinitionName to the end of the list.
    function AddItem(value : TFhirMedicinalProductDefinitionName) : TFhirMedicinalProductDefinitionName; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirMedicinalProductDefinitionName) : Integer;
    
    // Insert FhirMedicinalProductDefinitionName before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirMedicinalProductDefinitionName;
    
    // Insert an existing FhirMedicinalProductDefinitionName before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirMedicinalProductDefinitionName);
    
    // Get the iIndexth FhirMedicinalProductDefinitionName. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirMedicinalProductDefinitionName);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirMedicinalProductDefinitionName;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirMedicinalProductDefinitionNames[index : Integer] : TFhirMedicinalProductDefinitionName read GetItemN write SetItemN; default;
  End;

  // Coding words or phrases of the name.
  TFhirMedicinalProductDefinitionNamePart = class (TFhirBackboneElement)
  protected
    FPart : TFhirString;
    FType_ : TFhirCodeableConcept;
    procedure SetPart(value : TFhirString);
    function GetPartST : String;
    procedure SetPartST(value : String);
    procedure SetType_(value : TFhirCodeableConcept);
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirMedicinalProductDefinitionNamePart; overload;
    function Clone : TFhirMedicinalProductDefinitionNamePart; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to A fragment of a product name.
    property part : String read GetPartST write SetPartST;
    // A fragment of a product name.
    property partElement : TFhirString read FPart write SetPart;

    // Typed access to Identifying type for this part of the name (e.g. strength part). (defined for API consistency)
    property type_ : TFhirCodeableConcept read FType_ write SetType_;
    // Identifying type for this part of the name (e.g. strength part).
    property type_Element : TFhirCodeableConcept read FType_ write SetType_;

  end;

  TFhirMedicinalProductDefinitionNamePartListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirMedicinalProductDefinitionNamePartList;
    function GetCurrent : TFhirMedicinalProductDefinitionNamePart;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirMedicinalProductDefinitionNamePartList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirMedicinalProductDefinitionNamePart read GetCurrent;
  end;

  TFhirMedicinalProductDefinitionNamePartList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirMedicinalProductDefinitionNamePart;
    procedure SetItemN(index : Integer; value : TFhirMedicinalProductDefinitionNamePart);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirMedicinalProductDefinitionNamePartList; overload;
    function Clone : TFhirMedicinalProductDefinitionNamePartList; overload;
    function GetEnumerator : TFhirMedicinalProductDefinitionNamePartListEnumerator;
    
    //  Add a FhirMedicinalProductDefinitionNamePart to the end of the list.
    function Append : TFhirMedicinalProductDefinitionNamePart;
    
    // Add an already existing FhirMedicinalProductDefinitionNamePart to the end of the list.
    function AddItem(value : TFhirMedicinalProductDefinitionNamePart) : TFhirMedicinalProductDefinitionNamePart; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirMedicinalProductDefinitionNamePart) : Integer;
    
    // Insert FhirMedicinalProductDefinitionNamePart before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirMedicinalProductDefinitionNamePart;
    
    // Insert an existing FhirMedicinalProductDefinitionNamePart before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirMedicinalProductDefinitionNamePart);
    
    // Get the iIndexth FhirMedicinalProductDefinitionNamePart. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirMedicinalProductDefinitionNamePart);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirMedicinalProductDefinitionNamePart;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirMedicinalProductDefinitionNameParts[index : Integer] : TFhirMedicinalProductDefinitionNamePart read GetItemN write SetItemN; default;
  End;

  // Country and jurisdiction where the name applies, and associated language.
  TFhirMedicinalProductDefinitionNameUsage = class (TFhirBackboneElement)
  protected
    FCountry : TFhirCodeableConcept;
    FJurisdiction : TFhirCodeableConcept;
    FLanguage : TFhirCodeableConcept;
    procedure SetCountry(value : TFhirCodeableConcept);
    procedure SetJurisdiction(value : TFhirCodeableConcept);
    procedure SetLanguage(value : TFhirCodeableConcept);
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirMedicinalProductDefinitionNameUsage; overload;
    function Clone : TFhirMedicinalProductDefinitionNameUsage; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to Country code for where this name applies. (defined for API consistency)
    property country : TFhirCodeableConcept read FCountry write SetCountry;
    // Country code for where this name applies.
    property countryElement : TFhirCodeableConcept read FCountry write SetCountry;

    // Typed access to Jurisdiction code for where this name applies. A jurisdiction may be a sub- or supra-national entity (e.g. a state or a geographic region). (defined for API consistency)
    property jurisdiction : TFhirCodeableConcept read FJurisdiction write SetJurisdiction;
    // Jurisdiction code for where this name applies. A jurisdiction may be a sub- or supra-national entity (e.g. a state or a geographic region).
    property jurisdictionElement : TFhirCodeableConcept read FJurisdiction write SetJurisdiction;

    // Typed access to Language code for this name. (defined for API consistency)
    property language : TFhirCodeableConcept read FLanguage write SetLanguage;
    // Language code for this name.
    property languageElement : TFhirCodeableConcept read FLanguage write SetLanguage;

  end;

  TFhirMedicinalProductDefinitionNameUsageListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirMedicinalProductDefinitionNameUsageList;
    function GetCurrent : TFhirMedicinalProductDefinitionNameUsage;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirMedicinalProductDefinitionNameUsageList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirMedicinalProductDefinitionNameUsage read GetCurrent;
  end;

  TFhirMedicinalProductDefinitionNameUsageList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirMedicinalProductDefinitionNameUsage;
    procedure SetItemN(index : Integer; value : TFhirMedicinalProductDefinitionNameUsage);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirMedicinalProductDefinitionNameUsageList; overload;
    function Clone : TFhirMedicinalProductDefinitionNameUsageList; overload;
    function GetEnumerator : TFhirMedicinalProductDefinitionNameUsageListEnumerator;
    
    //  Add a FhirMedicinalProductDefinitionNameUsage to the end of the list.
    function Append : TFhirMedicinalProductDefinitionNameUsage;
    
    // Add an already existing FhirMedicinalProductDefinitionNameUsage to the end of the list.
    function AddItem(value : TFhirMedicinalProductDefinitionNameUsage) : TFhirMedicinalProductDefinitionNameUsage; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirMedicinalProductDefinitionNameUsage) : Integer;
    
    // Insert FhirMedicinalProductDefinitionNameUsage before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirMedicinalProductDefinitionNameUsage;
    
    // Insert an existing FhirMedicinalProductDefinitionNameUsage before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirMedicinalProductDefinitionNameUsage);
    
    // Get the iIndexth FhirMedicinalProductDefinitionNameUsage. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirMedicinalProductDefinitionNameUsage);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirMedicinalProductDefinitionNameUsage;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirMedicinalProductDefinitionNameUsages[index : Integer] : TFhirMedicinalProductDefinitionNameUsage read GetItemN write SetItemN; default;
  End;

  // Reference to another product, e.g. for linking authorised to investigational product, or a virtual product.
  TFhirMedicinalProductDefinitionCrossReference = class (TFhirBackboneElement)
  protected
    FProduct : TFhirCodeableReference;
    FType_ : TFhirCodeableConcept;
    procedure SetProduct(value : TFhirCodeableReference);
    procedure SetType_(value : TFhirCodeableConcept);
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirMedicinalProductDefinitionCrossReference; overload;
    function Clone : TFhirMedicinalProductDefinitionCrossReference; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to Reference to another product, e.g. for linking authorised to investigational product. (defined for API consistency)
    property product : TFhirCodeableReference read FProduct write SetProduct;
    // Reference to another product, e.g. for linking authorised to investigational product.
    property productElement : TFhirCodeableReference read FProduct write SetProduct;

    // Typed access to The type of relationship, for instance branded to generic, virtual to actual product, product to development product (investigational), parallel import version. (defined for API consistency)
    property type_ : TFhirCodeableConcept read FType_ write SetType_;
    // The type of relationship, for instance branded to generic, virtual to actual product, product to development product (investigational), parallel import version.
    property type_Element : TFhirCodeableConcept read FType_ write SetType_;

  end;

  TFhirMedicinalProductDefinitionCrossReferenceListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirMedicinalProductDefinitionCrossReferenceList;
    function GetCurrent : TFhirMedicinalProductDefinitionCrossReference;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirMedicinalProductDefinitionCrossReferenceList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirMedicinalProductDefinitionCrossReference read GetCurrent;
  end;

  TFhirMedicinalProductDefinitionCrossReferenceList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirMedicinalProductDefinitionCrossReference;
    procedure SetItemN(index : Integer; value : TFhirMedicinalProductDefinitionCrossReference);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirMedicinalProductDefinitionCrossReferenceList; overload;
    function Clone : TFhirMedicinalProductDefinitionCrossReferenceList; overload;
    function GetEnumerator : TFhirMedicinalProductDefinitionCrossReferenceListEnumerator;
    
    //  Add a FhirMedicinalProductDefinitionCrossReference to the end of the list.
    function Append : TFhirMedicinalProductDefinitionCrossReference;
    
    // Add an already existing FhirMedicinalProductDefinitionCrossReference to the end of the list.
    function AddItem(value : TFhirMedicinalProductDefinitionCrossReference) : TFhirMedicinalProductDefinitionCrossReference; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirMedicinalProductDefinitionCrossReference) : Integer;
    
    // Insert FhirMedicinalProductDefinitionCrossReference before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirMedicinalProductDefinitionCrossReference;
    
    // Insert an existing FhirMedicinalProductDefinitionCrossReference before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirMedicinalProductDefinitionCrossReference);
    
    // Get the iIndexth FhirMedicinalProductDefinitionCrossReference. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirMedicinalProductDefinitionCrossReference);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirMedicinalProductDefinitionCrossReference;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirMedicinalProductDefinitionCrossReferences[index : Integer] : TFhirMedicinalProductDefinitionCrossReference read GetItemN write SetItemN; default;
  End;

  // A manufacturing or administrative process or step associated with (or performed on) the medicinal product.
  TFhirMedicinalProductDefinitionOperation = class (TFhirBackboneElement)
  protected
    FType_ : TFhirCodeableReference;
    FEffectiveDate : TFhirPeriod;
    ForganizationList : TFhirReferenceList;
    FConfidentialityIndicator : TFhirCodeableConcept;
    procedure SetType_(value : TFhirCodeableReference);
    procedure SetEffectiveDate(value : TFhirPeriod);
    function GetOrganizationList : TFhirReferenceList;
    function GetHasOrganizationList : Boolean;
    procedure SetConfidentialityIndicator(value : TFhirCodeableConcept);
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirMedicinalProductDefinitionOperation; overload;
    function Clone : TFhirMedicinalProductDefinitionOperation; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to The type of manufacturing operation e.g. manufacturing itself, re-packaging. For the authorization of this, a RegulatedAuthorization would point to the same plan or activity referenced here. (defined for API consistency)
    property type_ : TFhirCodeableReference read FType_ write SetType_;
    // The type of manufacturing operation e.g. manufacturing itself, re-packaging. For the authorization of this, a RegulatedAuthorization would point to the same plan or activity referenced here.
    property type_Element : TFhirCodeableReference read FType_ write SetType_;

    // Typed access to Date range of applicability. (defined for API consistency)
    property effectiveDate : TFhirPeriod read FEffectiveDate write SetEffectiveDate;
    // Date range of applicability.
    property effectiveDateElement : TFhirPeriod read FEffectiveDate write SetEffectiveDate;

    // The organization or establishment responsible for (or associated with) the particular process or step, examples include the manufacturer, importer, agent.
    property organizationList : TFhirReferenceList read GetOrganizationList;
    property hasOrganizationList : boolean read GetHasOrganizationList;

    // Typed access to Specifies whether this particular business or manufacturing process is considered proprietary or confidential. (defined for API consistency)
    property confidentialityIndicator : TFhirCodeableConcept read FConfidentialityIndicator write SetConfidentialityIndicator;
    // Specifies whether this particular business or manufacturing process is considered proprietary or confidential.
    property confidentialityIndicatorElement : TFhirCodeableConcept read FConfidentialityIndicator write SetConfidentialityIndicator;

  end;

  TFhirMedicinalProductDefinitionOperationListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirMedicinalProductDefinitionOperationList;
    function GetCurrent : TFhirMedicinalProductDefinitionOperation;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirMedicinalProductDefinitionOperationList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirMedicinalProductDefinitionOperation read GetCurrent;
  end;

  TFhirMedicinalProductDefinitionOperationList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirMedicinalProductDefinitionOperation;
    procedure SetItemN(index : Integer; value : TFhirMedicinalProductDefinitionOperation);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirMedicinalProductDefinitionOperationList; overload;
    function Clone : TFhirMedicinalProductDefinitionOperationList; overload;
    function GetEnumerator : TFhirMedicinalProductDefinitionOperationListEnumerator;
    
    //  Add a FhirMedicinalProductDefinitionOperation to the end of the list.
    function Append : TFhirMedicinalProductDefinitionOperation;
    
    // Add an already existing FhirMedicinalProductDefinitionOperation to the end of the list.
    function AddItem(value : TFhirMedicinalProductDefinitionOperation) : TFhirMedicinalProductDefinitionOperation; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirMedicinalProductDefinitionOperation) : Integer;
    
    // Insert FhirMedicinalProductDefinitionOperation before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirMedicinalProductDefinitionOperation;
    
    // Insert an existing FhirMedicinalProductDefinitionOperation before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirMedicinalProductDefinitionOperation);
    
    // Get the iIndexth FhirMedicinalProductDefinitionOperation. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirMedicinalProductDefinitionOperation);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirMedicinalProductDefinitionOperation;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirMedicinalProductDefinitionOperations[index : Integer] : TFhirMedicinalProductDefinitionOperation read GetItemN write SetItemN; default;
  End;

  // Allows the key product features to be recorded, such as "sugar free", "modified release", "parallel import".
  TFhirMedicinalProductDefinitionCharacteristic = class (TFhirBackboneElement)
  protected
    FType_ : TFhirCodeableConcept;
    FValue : TFhirDataType;
    procedure SetType_(value : TFhirCodeableConcept);
    procedure SetValue(value : TFhirDataType);
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirMedicinalProductDefinitionCharacteristic; overload;
    function Clone : TFhirMedicinalProductDefinitionCharacteristic; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to A code expressing the type of characteristic. (defined for API consistency)
    property type_ : TFhirCodeableConcept read FType_ write SetType_;
    // A code expressing the type of characteristic.
    property type_Element : TFhirCodeableConcept read FType_ write SetType_;

    // Typed access to A value for the characteristic.text. (defined for API consistency)
    property value : TFhirDataType read FValue write SetValue;
    // A value for the characteristic.text.
    property valueElement : TFhirDataType read FValue write SetValue;

  end;

  TFhirMedicinalProductDefinitionCharacteristicListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirMedicinalProductDefinitionCharacteristicList;
    function GetCurrent : TFhirMedicinalProductDefinitionCharacteristic;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirMedicinalProductDefinitionCharacteristicList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirMedicinalProductDefinitionCharacteristic read GetCurrent;
  end;

  TFhirMedicinalProductDefinitionCharacteristicList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirMedicinalProductDefinitionCharacteristic;
    procedure SetItemN(index : Integer; value : TFhirMedicinalProductDefinitionCharacteristic);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirMedicinalProductDefinitionCharacteristicList; overload;
    function Clone : TFhirMedicinalProductDefinitionCharacteristicList; overload;
    function GetEnumerator : TFhirMedicinalProductDefinitionCharacteristicListEnumerator;
    
    //  Add a FhirMedicinalProductDefinitionCharacteristic to the end of the list.
    function Append : TFhirMedicinalProductDefinitionCharacteristic;
    
    // Add an already existing FhirMedicinalProductDefinitionCharacteristic to the end of the list.
    function AddItem(value : TFhirMedicinalProductDefinitionCharacteristic) : TFhirMedicinalProductDefinitionCharacteristic; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirMedicinalProductDefinitionCharacteristic) : Integer;
    
    // Insert FhirMedicinalProductDefinitionCharacteristic before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirMedicinalProductDefinitionCharacteristic;
    
    // Insert an existing FhirMedicinalProductDefinitionCharacteristic before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirMedicinalProductDefinitionCharacteristic);
    
    // Get the iIndexth FhirMedicinalProductDefinitionCharacteristic. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirMedicinalProductDefinitionCharacteristic);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirMedicinalProductDefinitionCharacteristic;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirMedicinalProductDefinitionCharacteristics[index : Integer] : TFhirMedicinalProductDefinitionCharacteristic read GetItemN write SetItemN; default;
  End;

  // A medicinal product, being a substance or combination of substances that is intended to treat, prevent or diagnose a disease, or to restore, correct or modify physiological functions by exerting a pharmacological, immunological or metabolic action. This resource is intended to define and detail such products and their properties, for uses other than direct patient care (e.g. regulatory use, or drug catalogs).
  TFhirMedicinalProductDefinition = class (TFhirDomainResource)
  protected
    FidentifierList : TFhirIdentifierList;
    FType_ : TFhirCodeableConcept;
    FDomain : TFhirCodeableConcept;
    FVersion : TFhirString;
    FStatus : TFhirCodeableConcept;
    FStatusDate : TFhirDateTime;
    FDescription : TFhirMarkdown;
    FCombinedPharmaceuticalDoseForm : TFhirCodeableConcept;
    FrouteList : TFhirCodeableConceptList;
    FIndication : TFhirMarkdown;
    FLegalStatusOfSupply : TFhirCodeableConcept;
    FAdditionalMonitoringIndicator : TFhirCodeableConcept;
    FspecialMeasuresList : TFhirCodeableConceptList;
    FPediatricUseIndicator : TFhirCodeableConcept;
    FclassificationList : TFhirCodeableConceptList;
    FmarketingStatusList : TFhirMarketingStatusList;
    FpackagedMedicinalProductList : TFhirCodeableConceptList;
    FcomprisedOfList : TFhirReferenceList;
    FingredientList : TFhirCodeableConceptList;
    FimpurityList : TFhirCodeableReferenceList;
    FattachedDocumentList : TFhirReferenceList;
    FmasterFileList : TFhirReferenceList;
    FcontactList : TFhirMedicinalProductDefinitionContactList;
    FclinicalTrialList : TFhirReferenceList;
    FcodeList : TFhirCodingList;
    FnameList : TFhirMedicinalProductDefinitionNameList;
    FcrossReferenceList : TFhirMedicinalProductDefinitionCrossReferenceList;
    FoperationList : TFhirMedicinalProductDefinitionOperationList;
    FcharacteristicList : TFhirMedicinalProductDefinitionCharacteristicList;
    function GetIdentifierList : TFhirIdentifierList;
    function GetHasIdentifierList : Boolean;
    procedure SetType_(value : TFhirCodeableConcept);
    procedure SetDomain(value : TFhirCodeableConcept);
    procedure SetVersion(value : TFhirString);
    function GetVersionST : String;
    procedure SetVersionST(value : String);
    procedure SetStatus(value : TFhirCodeableConcept);
    procedure SetStatusDate(value : TFhirDateTime);
    function GetStatusDateST : TFslDateTime;
    procedure SetStatusDateST(value : TFslDateTime);
    procedure SetDescription(value : TFhirMarkdown);
    function GetDescriptionST : String;
    procedure SetDescriptionST(value : String);
    procedure SetCombinedPharmaceuticalDoseForm(value : TFhirCodeableConcept);
    function GetRouteList : TFhirCodeableConceptList;
    function GetHasRouteList : Boolean;
    procedure SetIndication(value : TFhirMarkdown);
    function GetIndicationST : String;
    procedure SetIndicationST(value : String);
    procedure SetLegalStatusOfSupply(value : TFhirCodeableConcept);
    procedure SetAdditionalMonitoringIndicator(value : TFhirCodeableConcept);
    function GetSpecialMeasuresList : TFhirCodeableConceptList;
    function GetHasSpecialMeasuresList : Boolean;
    procedure SetPediatricUseIndicator(value : TFhirCodeableConcept);
    function GetClassificationList : TFhirCodeableConceptList;
    function GetHasClassificationList : Boolean;
    function GetMarketingStatusList : TFhirMarketingStatusList;
    function GetHasMarketingStatusList : Boolean;
    function GetPackagedMedicinalProductList : TFhirCodeableConceptList;
    function GetHasPackagedMedicinalProductList : Boolean;
    function GetComprisedOfList : TFhirReferenceList;
    function GetHasComprisedOfList : Boolean;
    function GetIngredientList : TFhirCodeableConceptList;
    function GetHasIngredientList : Boolean;
    function GetImpurityList : TFhirCodeableReferenceList;
    function GetHasImpurityList : Boolean;
    function GetAttachedDocumentList : TFhirReferenceList;
    function GetHasAttachedDocumentList : Boolean;
    function GetMasterFileList : TFhirReferenceList;
    function GetHasMasterFileList : Boolean;
    function GetContactList : TFhirMedicinalProductDefinitionContactList;
    function GetHasContactList : Boolean;
    function GetClinicalTrialList : TFhirReferenceList;
    function GetHasClinicalTrialList : Boolean;
    function GetCodeList : TFhirCodingList;
    function GetHasCodeList : Boolean;
    function GetNameList : TFhirMedicinalProductDefinitionNameList;
    function GetHasNameList : Boolean;
    function GetCrossReferenceList : TFhirMedicinalProductDefinitionCrossReferenceList;
    function GetHasCrossReferenceList : Boolean;
    function GetOperationList : TFhirMedicinalProductDefinitionOperationList;
    function GetHasOperationList : Boolean;
    function GetCharacteristicList : TFhirMedicinalProductDefinitionCharacteristicList;
    function GetHasCharacteristicList : Boolean;
  
    function GetResourceType : TFhirResourceType; override;
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirMedicinalProductDefinition; overload;
    function Clone : TFhirMedicinalProductDefinition; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Business identifier for this product. Could be an MPID. When in development or being regulated, products are typically referenced by official identifiers, assigned by a manufacturer or regulator, and unique to a product (which, when compared to a product instance being prescribed, is actually a product type). See also MedicinalProductDefinition.code.
    property identifierList : TFhirIdentifierList read GetIdentifierList;
    property hasIdentifierList : boolean read GetHasIdentifierList;

    // Typed access to Regulatory type, e.g. Investigational or Authorized. (defined for API consistency)
    property type_ : TFhirCodeableConcept read FType_ write SetType_;
    // Regulatory type, e.g. Investigational or Authorized.
    property type_Element : TFhirCodeableConcept read FType_ write SetType_;

    // Typed access to If this medicine applies to human or veterinary uses. (defined for API consistency)
    property domain : TFhirCodeableConcept read FDomain write SetDomain;
    // If this medicine applies to human or veterinary uses.
    property domainElement : TFhirCodeableConcept read FDomain write SetDomain;

    // Typed access to A business identifier relating to a specific version of the product, this is commonly used to support revisions to an existing product.
    property version : String read GetVersionST write SetVersionST;
    // A business identifier relating to a specific version of the product, this is commonly used to support revisions to an existing product.
    property versionElement : TFhirString read FVersion write SetVersion;

    // Typed access to The status within the lifecycle of this product record. A high-level status, this is not intended to duplicate details carried elsewhere such as legal status, or authorization status. (defined for API consistency)
    property status : TFhirCodeableConcept read FStatus write SetStatus;
    // The status within the lifecycle of this product record. A high-level status, this is not intended to duplicate details carried elsewhere such as legal status, or authorization status.
    property statusElement : TFhirCodeableConcept read FStatus write SetStatus;

    // Typed access to The date at which the given status became applicable.
    property statusDate : TFslDateTime read GetStatusDateST write SetStatusDateST;
    // The date at which the given status became applicable.
    property statusDateElement : TFhirDateTime read FStatusDate write SetStatusDate;

    // Typed access to General description of this product.
    property description : String read GetDescriptionST write SetDescriptionST;
    // General description of this product.
    property descriptionElement : TFhirMarkdown read FDescription write SetDescription;

    // Typed access to The dose form for a single part product, or combined form of a multiple part product. This is one concept that describes all the components. It does not represent the form with components physically mixed, if that might be necessary, for which see (AdministrableProductDefinition.administrableDoseForm). (defined for API consistency)
    property combinedPharmaceuticalDoseForm : TFhirCodeableConcept read FCombinedPharmaceuticalDoseForm write SetCombinedPharmaceuticalDoseForm;
    // The dose form for a single part product, or combined form of a multiple part product. This is one concept that describes all the components. It does not represent the form with components physically mixed, if that might be necessary, for which see (AdministrableProductDefinition.administrableDoseForm).
    property combinedPharmaceuticalDoseFormElement : TFhirCodeableConcept read FCombinedPharmaceuticalDoseForm write SetCombinedPharmaceuticalDoseForm;

    // The path by which the product is taken into or makes contact with the body. In some regions this is referred to as the licenced or approved route. See also AdministrableProductDefinition resource. MedicinalProductDefinition.route is the same concept as AdministrableProductDefinition.routeOfAdministration.code, and they cannot be used together.
    property routeList : TFhirCodeableConceptList read GetRouteList;
    property hasRouteList : boolean read GetHasRouteList;

    // Typed access to Description of indication(s) for this product, used when structured indications are not required. In cases where structured indications are required, they are captured using the ClinicalUseDefinition resource. An indication is a medical situation for which using the product is appropriate.
    property indication : String read GetIndicationST write SetIndicationST;
    // Description of indication(s) for this product, used when structured indications are not required. In cases where structured indications are required, they are captured using the ClinicalUseDefinition resource. An indication is a medical situation for which using the product is appropriate.
    property indicationElement : TFhirMarkdown read FIndication write SetIndication;

    // Typed access to The legal status of supply of the medicinal product as classified by the regulator. (defined for API consistency)
    property legalStatusOfSupply : TFhirCodeableConcept read FLegalStatusOfSupply write SetLegalStatusOfSupply;
    // The legal status of supply of the medicinal product as classified by the regulator.
    property legalStatusOfSupplyElement : TFhirCodeableConcept read FLegalStatusOfSupply write SetLegalStatusOfSupply;

    // Typed access to Whether the Medicinal Product is subject to additional monitoring for regulatory reasons, such as heightened reporting requirements. (defined for API consistency)
    property additionalMonitoringIndicator : TFhirCodeableConcept read FAdditionalMonitoringIndicator write SetAdditionalMonitoringIndicator;
    // Whether the Medicinal Product is subject to additional monitoring for regulatory reasons, such as heightened reporting requirements.
    property additionalMonitoringIndicatorElement : TFhirCodeableConcept read FAdditionalMonitoringIndicator write SetAdditionalMonitoringIndicator;

    // Whether the Medicinal Product is subject to special measures for regulatory reasons, such as a requirement to conduct post-authorisation studies.
    property specialMeasuresList : TFhirCodeableConceptList read GetSpecialMeasuresList;
    property hasSpecialMeasuresList : boolean read GetHasSpecialMeasuresList;

    // Typed access to If authorised for use in children, or infants, neonates etc. (defined for API consistency)
    property pediatricUseIndicator : TFhirCodeableConcept read FPediatricUseIndicator write SetPediatricUseIndicator;
    // If authorised for use in children, or infants, neonates etc.
    property pediatricUseIndicatorElement : TFhirCodeableConcept read FPediatricUseIndicator write SetPediatricUseIndicator;

    // Allows the product to be classified by various systems, commonly WHO ATC.
    property classificationList : TFhirCodeableConceptList read GetClassificationList;
    property hasClassificationList : boolean read GetHasClassificationList;

    // Marketing status of the medicinal product, in contrast to marketing authorization. This refers to the product being actually 'on the market' as opposed to being allowed to be on the market (which is an authorization).
    property marketingStatusList : TFhirMarketingStatusList read GetMarketingStatusList;
    property hasMarketingStatusList : boolean read GetHasMarketingStatusList;

    // Package type for the product. See also the PackagedProductDefinition resource.
    property packagedMedicinalProductList : TFhirCodeableConceptList read GetPackagedMedicinalProductList;
    property hasPackagedMedicinalProductList : boolean read GetHasPackagedMedicinalProductList;

    // Types of medicinal manufactured items and/or devices that this product consists of, such as tablets, capsule, or syringes. Used as a direct link when the item's packaging is not being recorded (see also PackagedProductDefinition.package.containedItem.item).
    property comprisedOfList : TFhirReferenceList read GetComprisedOfList;
    property hasComprisedOfList : boolean read GetHasComprisedOfList;

    // The ingredients of this medicinal product - when not detailed in other resources. This is only needed if the ingredients are not specified by incoming references from the Ingredient resource, or indirectly via incoming AdministrableProductDefinition, PackagedProductDefinition or ManufacturedItemDefinition references. In cases where those levels of detail are not used, the ingredients may be specified directly here as codes.
    property ingredientList : TFhirCodeableConceptList read GetIngredientList;
    property hasIngredientList : boolean read GetHasIngredientList;

    // Any component of the drug product which is not the chemical entity defined as the drug substance, or an excipient in the drug product. This includes process-related impurities and contaminants, product-related impurities including degradation products.
    property impurityList : TFhirCodeableReferenceList read GetImpurityList;
    property hasImpurityList : boolean read GetHasImpurityList;

    // Additional information or supporting documentation about the medicinal product.
    property attachedDocumentList : TFhirReferenceList read GetAttachedDocumentList;
    property hasAttachedDocumentList : boolean read GetHasAttachedDocumentList;

    // A master file for the medicinal product (e.g. Pharmacovigilance System Master File). Drug master files (DMFs) are documents submitted to regulatory agencies to provide confidential detailed information about facilities, processes or articles used in the manufacturing, processing, packaging and storing of drug products.
    property masterFileList : TFhirReferenceList read GetMasterFileList;
    property hasMasterFileList : boolean read GetHasMasterFileList;

    // A product specific contact, person (in a role), or an organization.
    property contactList : TFhirMedicinalProductDefinitionContactList read GetContactList;
    property hasContactList : boolean read GetHasContactList;

    // Clinical trials or studies that this product is involved in.
    property clinicalTrialList : TFhirReferenceList read GetClinicalTrialList;
    property hasClinicalTrialList : boolean read GetHasClinicalTrialList;

    // A code that this product is known by, usually within some formal terminology, perhaps assigned by a third party (i.e. not the manufacturer or regulator). Products (types of medications) tend to be known by identifiers during development and within regulatory process. However when they are prescribed they tend to be identified by codes. The same product may be have multiple codes, applied to it by multiple organizations.
    property codeList : TFhirCodingList read GetCodeList;
    property hasCodeList : boolean read GetHasCodeList;

    // The product's name, including full name and possibly coded parts.
    property nameList : TFhirMedicinalProductDefinitionNameList read GetNameList;
    property hasNameList : boolean read GetHasNameList;

    // Reference to another product, e.g. for linking authorised to investigational product, or a virtual product.
    property crossReferenceList : TFhirMedicinalProductDefinitionCrossReferenceList read GetCrossReferenceList;
    property hasCrossReferenceList : boolean read GetHasCrossReferenceList;

    // A manufacturing or administrative process or step associated with (or performed on) the medicinal product.
    property operationList : TFhirMedicinalProductDefinitionOperationList read GetOperationList;
    property hasOperationList : boolean read GetHasOperationList;

    // Allows the key product features to be recorded, such as "sugar free", "modified release", "parallel import".
    property characteristicList : TFhirMedicinalProductDefinitionCharacteristicList read GetCharacteristicList;
    property hasCharacteristicList : boolean read GetHasCharacteristicList;

  end;

  TFhirMedicinalProductDefinitionListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirMedicinalProductDefinitionList;
    function GetCurrent : TFhirMedicinalProductDefinition;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirMedicinalProductDefinitionList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirMedicinalProductDefinition read GetCurrent;
  end;

  TFhirMedicinalProductDefinitionList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirMedicinalProductDefinition;
    procedure SetItemN(index : Integer; value : TFhirMedicinalProductDefinition);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirMedicinalProductDefinitionList; overload;
    function Clone : TFhirMedicinalProductDefinitionList; overload;
    function GetEnumerator : TFhirMedicinalProductDefinitionListEnumerator;
    
    //  Add a FhirMedicinalProductDefinition to the end of the list.
    function Append : TFhirMedicinalProductDefinition;
    
    // Add an already existing FhirMedicinalProductDefinition to the end of the list.
    function AddItem(value : TFhirMedicinalProductDefinition) : TFhirMedicinalProductDefinition; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirMedicinalProductDefinition) : Integer;
    
    // Insert FhirMedicinalProductDefinition before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirMedicinalProductDefinition;
    
    // Insert an existing FhirMedicinalProductDefinition before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirMedicinalProductDefinition);
    
    // Get the iIndexth FhirMedicinalProductDefinition. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirMedicinalProductDefinition);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirMedicinalProductDefinition;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirMedicinalProductDefinitions[index : Integer] : TFhirMedicinalProductDefinition read GetItemN write SetItemN; default;
  End;

{$ENDIF FHIR_MEDICINALPRODUCTDEFINITION}
{$IFDEF FHIR_NUTRITIONPRODUCT}
  // The product's nutritional information expressed by the nutrients.
  TFhirNutritionProductNutrient = class (TFhirBackboneElement)
  protected
    FItem : TFhirCodeableReference;
    FamountList : TFhirRatioList;
    procedure SetItem(value : TFhirCodeableReference);
    function GetAmountList : TFhirRatioList;
    function GetHasAmountList : Boolean;
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirNutritionProductNutrient; overload;
    function Clone : TFhirNutritionProductNutrient; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to The (relevant) nutrients in the product. (defined for API consistency)
    property item : TFhirCodeableReference read FItem write SetItem;
    // The (relevant) nutrients in the product.
    property itemElement : TFhirCodeableReference read FItem write SetItem;

    // The amount of nutrient expressed in one or more units: X per pack / per serving / per dose.
    property amountList : TFhirRatioList read GetAmountList;
    property hasAmountList : boolean read GetHasAmountList;

  end;

  TFhirNutritionProductNutrientListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirNutritionProductNutrientList;
    function GetCurrent : TFhirNutritionProductNutrient;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirNutritionProductNutrientList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirNutritionProductNutrient read GetCurrent;
  end;

  TFhirNutritionProductNutrientList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirNutritionProductNutrient;
    procedure SetItemN(index : Integer; value : TFhirNutritionProductNutrient);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirNutritionProductNutrientList; overload;
    function Clone : TFhirNutritionProductNutrientList; overload;
    function GetEnumerator : TFhirNutritionProductNutrientListEnumerator;
    
    //  Add a FhirNutritionProductNutrient to the end of the list.
    function Append : TFhirNutritionProductNutrient;
    
    // Add an already existing FhirNutritionProductNutrient to the end of the list.
    function AddItem(value : TFhirNutritionProductNutrient) : TFhirNutritionProductNutrient; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirNutritionProductNutrient) : Integer;
    
    // Insert FhirNutritionProductNutrient before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirNutritionProductNutrient;
    
    // Insert an existing FhirNutritionProductNutrient before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirNutritionProductNutrient);
    
    // Get the iIndexth FhirNutritionProductNutrient. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirNutritionProductNutrient);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirNutritionProductNutrient;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirNutritionProductNutrients[index : Integer] : TFhirNutritionProductNutrient read GetItemN write SetItemN; default;
  End;

  // Ingredients contained in this product.
  TFhirNutritionProductIngredient = class (TFhirBackboneElement)
  protected
    FItem : TFhirCodeableReference;
    FamountList : TFhirRatioList;
    procedure SetItem(value : TFhirCodeableReference);
    function GetAmountList : TFhirRatioList;
    function GetHasAmountList : Boolean;
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirNutritionProductIngredient; overload;
    function Clone : TFhirNutritionProductIngredient; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to The ingredient contained in the product. (defined for API consistency)
    property item : TFhirCodeableReference read FItem write SetItem;
    // The ingredient contained in the product.
    property itemElement : TFhirCodeableReference read FItem write SetItem;

    // The amount of ingredient that is in the product.
    property amountList : TFhirRatioList read GetAmountList;
    property hasAmountList : boolean read GetHasAmountList;

  end;

  TFhirNutritionProductIngredientListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirNutritionProductIngredientList;
    function GetCurrent : TFhirNutritionProductIngredient;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirNutritionProductIngredientList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirNutritionProductIngredient read GetCurrent;
  end;

  TFhirNutritionProductIngredientList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirNutritionProductIngredient;
    procedure SetItemN(index : Integer; value : TFhirNutritionProductIngredient);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirNutritionProductIngredientList; overload;
    function Clone : TFhirNutritionProductIngredientList; overload;
    function GetEnumerator : TFhirNutritionProductIngredientListEnumerator;
    
    //  Add a FhirNutritionProductIngredient to the end of the list.
    function Append : TFhirNutritionProductIngredient;
    
    // Add an already existing FhirNutritionProductIngredient to the end of the list.
    function AddItem(value : TFhirNutritionProductIngredient) : TFhirNutritionProductIngredient; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirNutritionProductIngredient) : Integer;
    
    // Insert FhirNutritionProductIngredient before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirNutritionProductIngredient;
    
    // Insert an existing FhirNutritionProductIngredient before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirNutritionProductIngredient);
    
    // Get the iIndexth FhirNutritionProductIngredient. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirNutritionProductIngredient);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirNutritionProductIngredient;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirNutritionProductIngredients[index : Integer] : TFhirNutritionProductIngredient read GetItemN write SetItemN; default;
  End;

  // Specifies descriptive properties of the nutrition product.
  TFhirNutritionProductCharacteristic = class (TFhirBackboneElement)
  protected
    FType_ : TFhirCodeableConcept;
    FValue : TFhirDataType;
    procedure SetType_(value : TFhirCodeableConcept);
    procedure SetValue(value : TFhirDataType);
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirNutritionProductCharacteristic; overload;
    function Clone : TFhirNutritionProductCharacteristic; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to A code specifying which characteristic of the product is being described (for example, colour, shape). (defined for API consistency)
    property type_ : TFhirCodeableConcept read FType_ write SetType_;
    // A code specifying which characteristic of the product is being described (for example, colour, shape).
    property type_Element : TFhirCodeableConcept read FType_ write SetType_;

    // Typed access to The actual characteristic value corresponding to the type. (defined for API consistency)
    property value : TFhirDataType read FValue write SetValue;
    // The actual characteristic value corresponding to the type.
    property valueElement : TFhirDataType read FValue write SetValue;

  end;

  TFhirNutritionProductCharacteristicListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirNutritionProductCharacteristicList;
    function GetCurrent : TFhirNutritionProductCharacteristic;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirNutritionProductCharacteristicList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirNutritionProductCharacteristic read GetCurrent;
  end;

  TFhirNutritionProductCharacteristicList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirNutritionProductCharacteristic;
    procedure SetItemN(index : Integer; value : TFhirNutritionProductCharacteristic);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirNutritionProductCharacteristicList; overload;
    function Clone : TFhirNutritionProductCharacteristicList; overload;
    function GetEnumerator : TFhirNutritionProductCharacteristicListEnumerator;
    
    //  Add a FhirNutritionProductCharacteristic to the end of the list.
    function Append : TFhirNutritionProductCharacteristic;
    
    // Add an already existing FhirNutritionProductCharacteristic to the end of the list.
    function AddItem(value : TFhirNutritionProductCharacteristic) : TFhirNutritionProductCharacteristic; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirNutritionProductCharacteristic) : Integer;
    
    // Insert FhirNutritionProductCharacteristic before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirNutritionProductCharacteristic;
    
    // Insert an existing FhirNutritionProductCharacteristic before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirNutritionProductCharacteristic);
    
    // Get the iIndexth FhirNutritionProductCharacteristic. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirNutritionProductCharacteristic);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirNutritionProductCharacteristic;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirNutritionProductCharacteristics[index : Integer] : TFhirNutritionProductCharacteristic read GetItemN write SetItemN; default;
  End;

  // Conveys instance-level information about this product item. One or several physical, countable instances or occurrences of the product.
  TFhirNutritionProductInstance = class (TFhirBackboneElement)
  protected
    FQuantity : TFhirQuantity;
    FidentifierList : TFhirIdentifierList;
    FName : TFhirString;
    FLotNumber : TFhirString;
    FExpiry : TFhirDateTime;
    FUseBy : TFhirDateTime;
    FBiologicalSourceEvent : TFhirIdentifier;
    procedure SetQuantity(value : TFhirQuantity);
    function GetIdentifierList : TFhirIdentifierList;
    function GetHasIdentifierList : Boolean;
    procedure SetName(value : TFhirString);
    function GetNameST : String;
    procedure SetNameST(value : String);
    procedure SetLotNumber(value : TFhirString);
    function GetLotNumberST : String;
    procedure SetLotNumberST(value : String);
    procedure SetExpiry(value : TFhirDateTime);
    function GetExpiryST : TFslDateTime;
    procedure SetExpiryST(value : TFslDateTime);
    procedure SetUseBy(value : TFhirDateTime);
    function GetUseByST : TFslDateTime;
    procedure SetUseByST(value : TFslDateTime);
    procedure SetBiologicalSourceEvent(value : TFhirIdentifier);
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirNutritionProductInstance; overload;
    function Clone : TFhirNutritionProductInstance; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to The amount of items or instances that the resource considers, for instance when referring to 2 identical units together. (defined for API consistency)
    property quantity : TFhirQuantity read FQuantity write SetQuantity;
    // The amount of items or instances that the resource considers, for instance when referring to 2 identical units together.
    property quantityElement : TFhirQuantity read FQuantity write SetQuantity;

    // The identifier for the physical instance, typically a serial number or manufacturer number.
    property identifierList : TFhirIdentifierList read GetIdentifierList;
    property hasIdentifierList : boolean read GetHasIdentifierList;

    // Typed access to The name for the specific product.
    property name : String read GetNameST write SetNameST;
    // The name for the specific product.
    property nameElement : TFhirString read FName write SetName;

    // Typed access to The identification of the batch or lot of the product.
    property lotNumber : String read GetLotNumberST write SetLotNumberST;
    // The identification of the batch or lot of the product.
    property lotNumberElement : TFhirString read FLotNumber write SetLotNumber;

    // Typed access to The time after which the product is no longer expected to be in proper condition, or its use is not advised or not allowed.
    property expiry : TFslDateTime read GetExpiryST write SetExpiryST;
    // The time after which the product is no longer expected to be in proper condition, or its use is not advised or not allowed.
    property expiryElement : TFhirDateTime read FExpiry write SetExpiry;

    // Typed access to The time after which the product is no longer expected to be in proper condition, or its use is not advised or not allowed.
    property useBy : TFslDateTime read GetUseByST write SetUseByST;
    // The time after which the product is no longer expected to be in proper condition, or its use is not advised or not allowed.
    property useByElement : TFhirDateTime read FUseBy write SetUseBy;

    // Typed access to An identifier that supports traceability to the event during which material in this product from one or more biological entities was obtained or pooled. (defined for API consistency)
    property biologicalSourceEvent : TFhirIdentifier read FBiologicalSourceEvent write SetBiologicalSourceEvent;
    // An identifier that supports traceability to the event during which material in this product from one or more biological entities was obtained or pooled.
    property biologicalSourceEventElement : TFhirIdentifier read FBiologicalSourceEvent write SetBiologicalSourceEvent;

  end;

  TFhirNutritionProductInstanceListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirNutritionProductInstanceList;
    function GetCurrent : TFhirNutritionProductInstance;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirNutritionProductInstanceList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirNutritionProductInstance read GetCurrent;
  end;

  TFhirNutritionProductInstanceList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirNutritionProductInstance;
    procedure SetItemN(index : Integer; value : TFhirNutritionProductInstance);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirNutritionProductInstanceList; overload;
    function Clone : TFhirNutritionProductInstanceList; overload;
    function GetEnumerator : TFhirNutritionProductInstanceListEnumerator;
    
    //  Add a FhirNutritionProductInstance to the end of the list.
    function Append : TFhirNutritionProductInstance;
    
    // Add an already existing FhirNutritionProductInstance to the end of the list.
    function AddItem(value : TFhirNutritionProductInstance) : TFhirNutritionProductInstance; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirNutritionProductInstance) : Integer;
    
    // Insert FhirNutritionProductInstance before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirNutritionProductInstance;
    
    // Insert an existing FhirNutritionProductInstance before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirNutritionProductInstance);
    
    // Get the iIndexth FhirNutritionProductInstance. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirNutritionProductInstance);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirNutritionProductInstance;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirNutritionProductInstances[index : Integer] : TFhirNutritionProductInstance read GetItemN write SetItemN; default;
  End;

  // A food or supplement that is consumed by patients.
  TFhirNutritionProduct = class (TFhirDomainResource)
  protected
    FCode : TFhirCodeableConcept;
    FStatus : TFhirEnum;
    FcategoryList : TFhirCodeableConceptList;
    FmanufacturerList : TFhirReferenceList;
    FnutrientList : TFhirNutritionProductNutrientList;
    FingredientList : TFhirNutritionProductIngredientList;
    FknownAllergenList : TFhirCodeableReferenceList;
    FcharacteristicList : TFhirNutritionProductCharacteristicList;
    FinstanceList : TFhirNutritionProductInstanceList;
    FnoteList : TFhirAnnotationList;
    procedure SetCode(value : TFhirCodeableConcept);
    procedure SetStatus(value : TFhirEnum);
    function GetStatusST : TFhirNutritionProductStatusEnum;
    procedure SetStatusST(value : TFhirNutritionProductStatusEnum);
    function GetCategoryList : TFhirCodeableConceptList;
    function GetHasCategoryList : Boolean;
    function GetManufacturerList : TFhirReferenceList;
    function GetHasManufacturerList : Boolean;
    function GetNutrientList : TFhirNutritionProductNutrientList;
    function GetHasNutrientList : Boolean;
    function GetIngredientList : TFhirNutritionProductIngredientList;
    function GetHasIngredientList : Boolean;
    function GetKnownAllergenList : TFhirCodeableReferenceList;
    function GetHasKnownAllergenList : Boolean;
    function GetCharacteristicList : TFhirNutritionProductCharacteristicList;
    function GetHasCharacteristicList : Boolean;
    function GetInstanceList : TFhirNutritionProductInstanceList;
    function GetHasInstanceList : Boolean;
    function GetNoteList : TFhirAnnotationList;
    function GetHasNoteList : Boolean;
  
    function GetResourceType : TFhirResourceType; override;
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirNutritionProduct; overload;
    function Clone : TFhirNutritionProduct; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to The code assigned to the product, for example a USDA NDB number, a USDA FDC ID number, or a Langual code. (defined for API consistency)
    property code : TFhirCodeableConcept read FCode write SetCode;
    // The code assigned to the product, for example a USDA NDB number, a USDA FDC ID number, or a Langual code.
    property codeElement : TFhirCodeableConcept read FCode write SetCode;

    // The current state of the product.
    property status : TFhirNutritionProductStatusEnum read GetStatusST write SetStatusST;
    property statusElement : TFhirEnum read FStatus write SetStatus;

    // Nutrition products can have different classifications - according to its nutritional properties, preparation methods, etc.
    property categoryList : TFhirCodeableConceptList read GetCategoryList;
    property hasCategoryList : boolean read GetHasCategoryList;

    // The organisation (manufacturer, representative or legal authorisation holder) that is responsible for the device.
    property manufacturerList : TFhirReferenceList read GetManufacturerList;
    property hasManufacturerList : boolean read GetHasManufacturerList;

    // The product's nutritional information expressed by the nutrients.
    property nutrientList : TFhirNutritionProductNutrientList read GetNutrientList;
    property hasNutrientList : boolean read GetHasNutrientList;

    // Ingredients contained in this product.
    property ingredientList : TFhirNutritionProductIngredientList read GetIngredientList;
    property hasIngredientList : boolean read GetHasIngredientList;

    // Allergens that are known or suspected to be a part of this nutrition product.
    property knownAllergenList : TFhirCodeableReferenceList read GetKnownAllergenList;
    property hasKnownAllergenList : boolean read GetHasKnownAllergenList;

    // Specifies descriptive properties of the nutrition product.
    property characteristicList : TFhirNutritionProductCharacteristicList read GetCharacteristicList;
    property hasCharacteristicList : boolean read GetHasCharacteristicList;

    // Conveys instance-level information about this product item. One or several physical, countable instances or occurrences of the product.
    property instanceList : TFhirNutritionProductInstanceList read GetInstanceList;
    property hasInstanceList : boolean read GetHasInstanceList;

    // Comments made about the product.
    property noteList : TFhirAnnotationList read GetNoteList;
    property hasNoteList : boolean read GetHasNoteList;

  end;

  TFhirNutritionProductListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirNutritionProductList;
    function GetCurrent : TFhirNutritionProduct;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirNutritionProductList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirNutritionProduct read GetCurrent;
  end;

  TFhirNutritionProductList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirNutritionProduct;
    procedure SetItemN(index : Integer; value : TFhirNutritionProduct);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirNutritionProductList; overload;
    function Clone : TFhirNutritionProductList; overload;
    function GetEnumerator : TFhirNutritionProductListEnumerator;
    
    //  Add a FhirNutritionProduct to the end of the list.
    function Append : TFhirNutritionProduct;
    
    // Add an already existing FhirNutritionProduct to the end of the list.
    function AddItem(value : TFhirNutritionProduct) : TFhirNutritionProduct; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirNutritionProduct) : Integer;
    
    // Insert FhirNutritionProduct before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirNutritionProduct;
    
    // Insert an existing FhirNutritionProduct before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirNutritionProduct);
    
    // Get the iIndexth FhirNutritionProduct. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirNutritionProduct);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirNutritionProduct;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirNutritionProducts[index : Integer] : TFhirNutritionProduct read GetItemN write SetItemN; default;
  End;

{$ENDIF FHIR_NUTRITIONPRODUCT}
{$IFDEF FHIR_PACKAGEDPRODUCTDEFINITION}
  // The legal status of supply of the packaged item as classified by the regulator.
  TFhirPackagedProductDefinitionLegalStatusOfSupply = class (TFhirBackboneElement)
  protected
    FCode : TFhirCodeableConcept;
    FJurisdiction : TFhirCodeableConcept;
    procedure SetCode(value : TFhirCodeableConcept);
    procedure SetJurisdiction(value : TFhirCodeableConcept);
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirPackagedProductDefinitionLegalStatusOfSupply; overload;
    function Clone : TFhirPackagedProductDefinitionLegalStatusOfSupply; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to The actual status of supply. Conveys in what situation this package type may be supplied for use. (defined for API consistency)
    property code : TFhirCodeableConcept read FCode write SetCode;
    // The actual status of supply. Conveys in what situation this package type may be supplied for use.
    property codeElement : TFhirCodeableConcept read FCode write SetCode;

    // Typed access to The place where the legal status of supply applies. When not specified, this indicates it is unknown in this context. (defined for API consistency)
    property jurisdiction : TFhirCodeableConcept read FJurisdiction write SetJurisdiction;
    // The place where the legal status of supply applies. When not specified, this indicates it is unknown in this context.
    property jurisdictionElement : TFhirCodeableConcept read FJurisdiction write SetJurisdiction;

  end;

  TFhirPackagedProductDefinitionLegalStatusOfSupplyListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirPackagedProductDefinitionLegalStatusOfSupplyList;
    function GetCurrent : TFhirPackagedProductDefinitionLegalStatusOfSupply;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirPackagedProductDefinitionLegalStatusOfSupplyList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirPackagedProductDefinitionLegalStatusOfSupply read GetCurrent;
  end;

  TFhirPackagedProductDefinitionLegalStatusOfSupplyList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirPackagedProductDefinitionLegalStatusOfSupply;
    procedure SetItemN(index : Integer; value : TFhirPackagedProductDefinitionLegalStatusOfSupply);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirPackagedProductDefinitionLegalStatusOfSupplyList; overload;
    function Clone : TFhirPackagedProductDefinitionLegalStatusOfSupplyList; overload;
    function GetEnumerator : TFhirPackagedProductDefinitionLegalStatusOfSupplyListEnumerator;
    
    //  Add a FhirPackagedProductDefinitionLegalStatusOfSupply to the end of the list.
    function Append : TFhirPackagedProductDefinitionLegalStatusOfSupply;
    
    // Add an already existing FhirPackagedProductDefinitionLegalStatusOfSupply to the end of the list.
    function AddItem(value : TFhirPackagedProductDefinitionLegalStatusOfSupply) : TFhirPackagedProductDefinitionLegalStatusOfSupply; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirPackagedProductDefinitionLegalStatusOfSupply) : Integer;
    
    // Insert FhirPackagedProductDefinitionLegalStatusOfSupply before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirPackagedProductDefinitionLegalStatusOfSupply;
    
    // Insert an existing FhirPackagedProductDefinitionLegalStatusOfSupply before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirPackagedProductDefinitionLegalStatusOfSupply);
    
    // Get the iIndexth FhirPackagedProductDefinitionLegalStatusOfSupply. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirPackagedProductDefinitionLegalStatusOfSupply);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirPackagedProductDefinitionLegalStatusOfSupply;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirPackagedProductDefinitionLegalStatusOfSupplies[index : Integer] : TFhirPackagedProductDefinitionLegalStatusOfSupply read GetItemN write SetItemN; default;
  End;

  // A packaging item, as a container for medically related items, possibly with other packaging items within, or a packaging component, such as bottle cap (which is not a device or a medication manufactured item).
  TFhirPackagedProductDefinitionPackaging = class (TFhirBackboneElement)
  protected
    FidentifierList : TFhirIdentifierList;
    FType_ : TFhirCodeableConcept;
    FQuantity : TFhirInteger;
    FmaterialList : TFhirCodeableConceptList;
    FalternateMaterialList : TFhirCodeableConceptList;
    FshelfLifeStorageList : TFhirProductShelfLifeList;
    FmanufacturerList : TFhirReferenceList;
    Fproperty_List : TFhirPackagedProductDefinitionPackagingPropertyList;
    FcontainedItemList : TFhirPackagedProductDefinitionPackagingContainedItemList;
    FpackagingList : TFhirPackagedProductDefinitionPackagingList;
    function GetIdentifierList : TFhirIdentifierList;
    function GetHasIdentifierList : Boolean;
    procedure SetType_(value : TFhirCodeableConcept);
    procedure SetQuantity(value : TFhirInteger);
    function GetQuantityST : String;
    procedure SetQuantityST(value : String);
    function GetMaterialList : TFhirCodeableConceptList;
    function GetHasMaterialList : Boolean;
    function GetAlternateMaterialList : TFhirCodeableConceptList;
    function GetHasAlternateMaterialList : Boolean;
    function GetShelfLifeStorageList : TFhirProductShelfLifeList;
    function GetHasShelfLifeStorageList : Boolean;
    function GetManufacturerList : TFhirReferenceList;
    function GetHasManufacturerList : Boolean;
    function GetProperty_List : TFhirPackagedProductDefinitionPackagingPropertyList;
    function GetHasProperty_List : Boolean;
    function GetContainedItemList : TFhirPackagedProductDefinitionPackagingContainedItemList;
    function GetHasContainedItemList : Boolean;
    function GetPackagingList : TFhirPackagedProductDefinitionPackagingList;
    function GetHasPackagingList : Boolean;
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirPackagedProductDefinitionPackaging; overload;
    function Clone : TFhirPackagedProductDefinitionPackaging; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // A business identifier that is specific to this particular part of the packaging, often assigned by the manufacturer. Including possibly Data Carrier Identifier (a GS1 barcode).
    property identifierList : TFhirIdentifierList read GetIdentifierList;
    property hasIdentifierList : boolean read GetHasIdentifierList;

    // Typed access to The physical type of the container of the items. (defined for API consistency)
    property type_ : TFhirCodeableConcept read FType_ write SetType_;
    // The physical type of the container of the items.
    property type_Element : TFhirCodeableConcept read FType_ write SetType_;

    // Typed access to The quantity of packaging items contained at this layer of the package. This does not relate to the number of contained items but relates solely to the number of packaging items. When looking at the outermost layer it is always 1. If there are two boxes within, at the next layer it would be 2.
    property quantity : String read GetQuantityST write SetQuantityST;
    // The quantity of packaging items contained at this layer of the package. This does not relate to the number of contained items but relates solely to the number of packaging items. When looking at the outermost layer it is always 1. If there are two boxes within, at the next layer it would be 2.
    property quantityElement : TFhirInteger read FQuantity write SetQuantity;

    // Material type of the package item.
    property materialList : TFhirCodeableConceptList read GetMaterialList;
    property hasMaterialList : boolean read GetHasMaterialList;

    // A possible alternate material for this part of the packaging, that is allowed to be used instead of the usual material (e.g. different types of plastic for a blister sleeve).
    property alternateMaterialList : TFhirCodeableConceptList read GetAlternateMaterialList;
    property hasAlternateMaterialList : boolean read GetHasAlternateMaterialList;

    // Shelf Life and storage information.
    property shelfLifeStorageList : TFhirProductShelfLifeList read GetShelfLifeStorageList;
    property hasShelfLifeStorageList : boolean read GetHasShelfLifeStorageList;

    // Manufacturer of this packaging item. When there are multiple values each one is a potential manufacturer of this packaging item.
    property manufacturerList : TFhirReferenceList read GetManufacturerList;
    property hasManufacturerList : boolean read GetHasManufacturerList;

    // General characteristics of this item.
    property property_List : TFhirPackagedProductDefinitionPackagingPropertyList read GetProperty_List;
    property hasProperty_List : boolean read GetHasProperty_List;

    // The item(s) within the packaging.
    property containedItemList : TFhirPackagedProductDefinitionPackagingContainedItemList read GetContainedItemList;
    property hasContainedItemList : boolean read GetHasContainedItemList;

    // Allows containers (and parts of containers) parwithin containers, still a single packaged product.  See also PackagedProductDefinition.packaging.containedItem.item(PackagedProductDefinition).
    property packagingList : TFhirPackagedProductDefinitionPackagingList read GetPackagingList;
    property hasPackagingList : boolean read GetHasPackagingList;

  end;

  TFhirPackagedProductDefinitionPackagingListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirPackagedProductDefinitionPackagingList;
    function GetCurrent : TFhirPackagedProductDefinitionPackaging;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirPackagedProductDefinitionPackagingList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirPackagedProductDefinitionPackaging read GetCurrent;
  end;

  TFhirPackagedProductDefinitionPackagingList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirPackagedProductDefinitionPackaging;
    procedure SetItemN(index : Integer; value : TFhirPackagedProductDefinitionPackaging);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirPackagedProductDefinitionPackagingList; overload;
    function Clone : TFhirPackagedProductDefinitionPackagingList; overload;
    function GetEnumerator : TFhirPackagedProductDefinitionPackagingListEnumerator;
    
    //  Add a FhirPackagedProductDefinitionPackaging to the end of the list.
    function Append : TFhirPackagedProductDefinitionPackaging;
    
    // Add an already existing FhirPackagedProductDefinitionPackaging to the end of the list.
    function AddItem(value : TFhirPackagedProductDefinitionPackaging) : TFhirPackagedProductDefinitionPackaging; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirPackagedProductDefinitionPackaging) : Integer;
    
    // Insert FhirPackagedProductDefinitionPackaging before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirPackagedProductDefinitionPackaging;
    
    // Insert an existing FhirPackagedProductDefinitionPackaging before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirPackagedProductDefinitionPackaging);
    
    // Get the iIndexth FhirPackagedProductDefinitionPackaging. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirPackagedProductDefinitionPackaging);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirPackagedProductDefinitionPackaging;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirPackagedProductDefinitionPackagings[index : Integer] : TFhirPackagedProductDefinitionPackaging read GetItemN write SetItemN; default;
  End;

  // General characteristics of this item.
  TFhirPackagedProductDefinitionPackagingProperty = class (TFhirBackboneElement)
  protected
    FType_ : TFhirCodeableConcept;
    FValue : TFhirDataType;
    procedure SetType_(value : TFhirCodeableConcept);
    procedure SetValue(value : TFhirDataType);
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirPackagedProductDefinitionPackagingProperty; overload;
    function Clone : TFhirPackagedProductDefinitionPackagingProperty; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to A code expressing the type of characteristic. (defined for API consistency)
    property type_ : TFhirCodeableConcept read FType_ write SetType_;
    // A code expressing the type of characteristic.
    property type_Element : TFhirCodeableConcept read FType_ write SetType_;

    // Typed access to A value for the characteristic. (defined for API consistency)
    property value : TFhirDataType read FValue write SetValue;
    // A value for the characteristic.
    property valueElement : TFhirDataType read FValue write SetValue;

  end;

  TFhirPackagedProductDefinitionPackagingPropertyListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirPackagedProductDefinitionPackagingPropertyList;
    function GetCurrent : TFhirPackagedProductDefinitionPackagingProperty;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirPackagedProductDefinitionPackagingPropertyList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirPackagedProductDefinitionPackagingProperty read GetCurrent;
  end;

  TFhirPackagedProductDefinitionPackagingPropertyList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirPackagedProductDefinitionPackagingProperty;
    procedure SetItemN(index : Integer; value : TFhirPackagedProductDefinitionPackagingProperty);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirPackagedProductDefinitionPackagingPropertyList; overload;
    function Clone : TFhirPackagedProductDefinitionPackagingPropertyList; overload;
    function GetEnumerator : TFhirPackagedProductDefinitionPackagingPropertyListEnumerator;
    
    //  Add a FhirPackagedProductDefinitionPackagingProperty to the end of the list.
    function Append : TFhirPackagedProductDefinitionPackagingProperty;
    
    // Add an already existing FhirPackagedProductDefinitionPackagingProperty to the end of the list.
    function AddItem(value : TFhirPackagedProductDefinitionPackagingProperty) : TFhirPackagedProductDefinitionPackagingProperty; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirPackagedProductDefinitionPackagingProperty) : Integer;
    
    // Insert FhirPackagedProductDefinitionPackagingProperty before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirPackagedProductDefinitionPackagingProperty;
    
    // Insert an existing FhirPackagedProductDefinitionPackagingProperty before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirPackagedProductDefinitionPackagingProperty);
    
    // Get the iIndexth FhirPackagedProductDefinitionPackagingProperty. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirPackagedProductDefinitionPackagingProperty);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirPackagedProductDefinitionPackagingProperty;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirPackagedProductDefinitionPackagingProperties[index : Integer] : TFhirPackagedProductDefinitionPackagingProperty read GetItemN write SetItemN; default;
  End;

  // The item(s) within the packaging.
  TFhirPackagedProductDefinitionPackagingContainedItem = class (TFhirBackboneElement)
  protected
    FItem : TFhirCodeableReference;
    FAmount : TFhirQuantity;
    procedure SetItem(value : TFhirCodeableReference);
    procedure SetAmount(value : TFhirQuantity);
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirPackagedProductDefinitionPackagingContainedItem; overload;
    function Clone : TFhirPackagedProductDefinitionPackagingContainedItem; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to The actual item(s) of medication, as manufactured, or a device (typically, but not necessarily, a co-packaged one), or other medically related item (such as food, biologicals, raw materials, medical fluids, gases etc.), as contained in the package. This also allows another whole packaged product to be included, which is solely for the case where a package of other entire packages is wanted - such as a wholesale or distribution pack (for layers within one package, use PackagedProductDefinition.packaging.packaging). (defined for API consistency)
    property item : TFhirCodeableReference read FItem write SetItem;
    // The actual item(s) of medication, as manufactured, or a device (typically, but not necessarily, a co-packaged one), or other medically related item (such as food, biologicals, raw materials, medical fluids, gases etc.), as contained in the package. This also allows another whole packaged product to be included, which is solely for the case where a package of other entire packages is wanted - such as a wholesale or distribution pack (for layers within one package, use PackagedProductDefinition.packaging.packaging).
    property itemElement : TFhirCodeableReference read FItem write SetItem;

    // Typed access to The number of this type of item within this packaging. (defined for API consistency)
    property amount : TFhirQuantity read FAmount write SetAmount;
    // The number of this type of item within this packaging.
    property amountElement : TFhirQuantity read FAmount write SetAmount;

  end;

  TFhirPackagedProductDefinitionPackagingContainedItemListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirPackagedProductDefinitionPackagingContainedItemList;
    function GetCurrent : TFhirPackagedProductDefinitionPackagingContainedItem;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirPackagedProductDefinitionPackagingContainedItemList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirPackagedProductDefinitionPackagingContainedItem read GetCurrent;
  end;

  TFhirPackagedProductDefinitionPackagingContainedItemList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirPackagedProductDefinitionPackagingContainedItem;
    procedure SetItemN(index : Integer; value : TFhirPackagedProductDefinitionPackagingContainedItem);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirPackagedProductDefinitionPackagingContainedItemList; overload;
    function Clone : TFhirPackagedProductDefinitionPackagingContainedItemList; overload;
    function GetEnumerator : TFhirPackagedProductDefinitionPackagingContainedItemListEnumerator;
    
    //  Add a FhirPackagedProductDefinitionPackagingContainedItem to the end of the list.
    function Append : TFhirPackagedProductDefinitionPackagingContainedItem;
    
    // Add an already existing FhirPackagedProductDefinitionPackagingContainedItem to the end of the list.
    function AddItem(value : TFhirPackagedProductDefinitionPackagingContainedItem) : TFhirPackagedProductDefinitionPackagingContainedItem; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirPackagedProductDefinitionPackagingContainedItem) : Integer;
    
    // Insert FhirPackagedProductDefinitionPackagingContainedItem before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirPackagedProductDefinitionPackagingContainedItem;
    
    // Insert an existing FhirPackagedProductDefinitionPackagingContainedItem before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirPackagedProductDefinitionPackagingContainedItem);
    
    // Get the iIndexth FhirPackagedProductDefinitionPackagingContainedItem. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirPackagedProductDefinitionPackagingContainedItem);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirPackagedProductDefinitionPackagingContainedItem;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirPackagedProductDefinitionPackagingContainedItems[index : Integer] : TFhirPackagedProductDefinitionPackagingContainedItem read GetItemN write SetItemN; default;
  End;

  // A medically related item or items, in a container or package.
  TFhirPackagedProductDefinition = class (TFhirDomainResource)
  protected
    FidentifierList : TFhirIdentifierList;
    FName : TFhirString;
    FType_ : TFhirCodeableConcept;
    FpackageForList : TFhirReferenceList;
    FStatus : TFhirCodeableConcept;
    FStatusDate : TFhirDateTime;
    FcontainedItemQuantityList : TFhirQuantityList;
    FDescription : TFhirMarkdown;
    FlegalStatusOfSupplyList : TFhirPackagedProductDefinitionLegalStatusOfSupplyList;
    FmarketingStatusList : TFhirMarketingStatusList;
    FcharacteristicList : TFhirCodeableConceptList;
    FCopackagedIndicator : TFhirBoolean;
    FmanufacturerList : TFhirReferenceList;
    FattachedDocumentList : TFhirReferenceList;
    FPackaging : TFhirPackagedProductDefinitionPackaging;
    function GetIdentifierList : TFhirIdentifierList;
    function GetHasIdentifierList : Boolean;
    procedure SetName(value : TFhirString);
    function GetNameST : String;
    procedure SetNameST(value : String);
    procedure SetType_(value : TFhirCodeableConcept);
    function GetPackageForList : TFhirReferenceList;
    function GetHasPackageForList : Boolean;
    procedure SetStatus(value : TFhirCodeableConcept);
    procedure SetStatusDate(value : TFhirDateTime);
    function GetStatusDateST : TFslDateTime;
    procedure SetStatusDateST(value : TFslDateTime);
    function GetContainedItemQuantityList : TFhirQuantityList;
    function GetHasContainedItemQuantityList : Boolean;
    procedure SetDescription(value : TFhirMarkdown);
    function GetDescriptionST : String;
    procedure SetDescriptionST(value : String);
    function GetLegalStatusOfSupplyList : TFhirPackagedProductDefinitionLegalStatusOfSupplyList;
    function GetHasLegalStatusOfSupplyList : Boolean;
    function GetMarketingStatusList : TFhirMarketingStatusList;
    function GetHasMarketingStatusList : Boolean;
    function GetCharacteristicList : TFhirCodeableConceptList;
    function GetHasCharacteristicList : Boolean;
    procedure SetCopackagedIndicator(value : TFhirBoolean);
    function GetCopackagedIndicatorST : Boolean;
    procedure SetCopackagedIndicatorST(value : Boolean);
    function GetManufacturerList : TFhirReferenceList;
    function GetHasManufacturerList : Boolean;
    function GetAttachedDocumentList : TFhirReferenceList;
    function GetHasAttachedDocumentList : Boolean;
    procedure SetPackaging(value : TFhirPackagedProductDefinitionPackaging);
  
    function GetResourceType : TFhirResourceType; override;
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirPackagedProductDefinition; overload;
    function Clone : TFhirPackagedProductDefinition; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // A unique identifier for this package as whole - not the the content of the package. Unique instance identifiers assigned to a package by manufacturers, regulators, drug catalogue custodians or other organizations.
    property identifierList : TFhirIdentifierList read GetIdentifierList;
    property hasIdentifierList : boolean read GetHasIdentifierList;

    // Typed access to A name for this package. Typically what it would be listed as in a drug formulary or catalogue, inventory etc.
    property name : String read GetNameST write SetNameST;
    // A name for this package. Typically what it would be listed as in a drug formulary or catalogue, inventory etc.
    property nameElement : TFhirString read FName write SetName;

    // Typed access to A high level category e.g. medicinal product, raw material, shipping/transport container, etc. (defined for API consistency)
    property type_ : TFhirCodeableConcept read FType_ write SetType_;
    // A high level category e.g. medicinal product, raw material, shipping/transport container, etc.
    property type_Element : TFhirCodeableConcept read FType_ write SetType_;

    // The product this package model relates to, not the contents of the package (for which see package.containedItem).
    property packageForList : TFhirReferenceList read GetPackageForList;
    property hasPackageForList : boolean read GetHasPackageForList;

    // Typed access to The status within the lifecycle of this item. A high level status, this is not intended to duplicate details carried elsewhere such as legal status, or authorization or marketing status. (defined for API consistency)
    property status : TFhirCodeableConcept read FStatus write SetStatus;
    // The status within the lifecycle of this item. A high level status, this is not intended to duplicate details carried elsewhere such as legal status, or authorization or marketing status.
    property statusElement : TFhirCodeableConcept read FStatus write SetStatus;

    // Typed access to The date at which the given status became applicable.
    property statusDate : TFslDateTime read GetStatusDateST write SetStatusDateST;
    // The date at which the given status became applicable.
    property statusDateElement : TFhirDateTime read FStatusDate write SetStatusDate;

    // A total of the complete count of contained items of a particular type/form, independent of sub-packaging or organization. This can be considered as the pack size. This attribute differs from containedItem.amount in that it can give a single aggregated count of all tablet types in a pack, even when these are different manufactured items. For example a pill pack of 21 tablets plus 7 sugar tablets, can be denoted here as '28 tablets'. This attribute is repeatable so that the different item types in one pack type can be counted (e.g. a count of vials and count of syringes). Each repeat must have different units, so that it is clear what the different sets of counted items are, and it is not intended to allow different counts of similar items (e.g. not '2 tubes and 3 tubes'). Repeats are not to be used to represent different pack sizes (e.g. 20 pack vs. 50 pack) - which would be different instances of this resource.
    property containedItemQuantityList : TFhirQuantityList read GetContainedItemQuantityList;
    property hasContainedItemQuantityList : boolean read GetHasContainedItemQuantityList;

    // Typed access to Textual description. Note that this is not the name of the package or product.
    property description : String read GetDescriptionST write SetDescriptionST;
    // Textual description. Note that this is not the name of the package or product.
    property descriptionElement : TFhirMarkdown read FDescription write SetDescription;

    // The legal status of supply of the packaged item as classified by the regulator.
    property legalStatusOfSupplyList : TFhirPackagedProductDefinitionLegalStatusOfSupplyList read GetLegalStatusOfSupplyList;
    property hasLegalStatusOfSupplyList : boolean read GetHasLegalStatusOfSupplyList;

    // Allows specifying that an item is on the market for sale, or that it is not available, and the dates and locations associated.
    property marketingStatusList : TFhirMarketingStatusList read GetMarketingStatusList;
    property hasMarketingStatusList : boolean read GetHasMarketingStatusList;

    // Allows the key features to be recorded, such as "hospital pack", "nurse prescribable", "calendar pack".
    property characteristicList : TFhirCodeableConceptList read GetCharacteristicList;
    property hasCharacteristicList : boolean read GetHasCharacteristicList;

    // Typed access to Identifies if the package contains different items, such as when a drug product is supplied with another item e.g. a diluent or adjuvant.
    property copackagedIndicator : Boolean read GetCopackagedIndicatorST write SetCopackagedIndicatorST;
    // Identifies if the package contains different items, such as when a drug product is supplied with another item e.g. a diluent or adjuvant.
    property copackagedIndicatorElement : TFhirBoolean read FCopackagedIndicator write SetCopackagedIndicator;

    // Manufacturer of this package type. When there are multiple it means these are all possible manufacturers.
    property manufacturerList : TFhirReferenceList read GetManufacturerList;
    property hasManufacturerList : boolean read GetHasManufacturerList;

    // Additional information or supporting documentation about the packaged product.
    property attachedDocumentList : TFhirReferenceList read GetAttachedDocumentList;
    property hasAttachedDocumentList : boolean read GetHasAttachedDocumentList;

    // Typed access to A packaging item, as a container for medically related items, possibly with other packaging items within, or a packaging component, such as bottle cap (which is not a device or a medication manufactured item). (defined for API consistency)
    property packaging : TFhirPackagedProductDefinitionPackaging read FPackaging write SetPackaging;
    // A packaging item, as a container for medically related items, possibly with other packaging items within, or a packaging component, such as bottle cap (which is not a device or a medication manufactured item).
    property packagingElement : TFhirPackagedProductDefinitionPackaging read FPackaging write SetPackaging;

  end;

  TFhirPackagedProductDefinitionListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirPackagedProductDefinitionList;
    function GetCurrent : TFhirPackagedProductDefinition;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirPackagedProductDefinitionList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirPackagedProductDefinition read GetCurrent;
  end;

  TFhirPackagedProductDefinitionList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirPackagedProductDefinition;
    procedure SetItemN(index : Integer; value : TFhirPackagedProductDefinition);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirPackagedProductDefinitionList; overload;
    function Clone : TFhirPackagedProductDefinitionList; overload;
    function GetEnumerator : TFhirPackagedProductDefinitionListEnumerator;
    
    //  Add a FhirPackagedProductDefinition to the end of the list.
    function Append : TFhirPackagedProductDefinition;
    
    // Add an already existing FhirPackagedProductDefinition to the end of the list.
    function AddItem(value : TFhirPackagedProductDefinition) : TFhirPackagedProductDefinition; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirPackagedProductDefinition) : Integer;
    
    // Insert FhirPackagedProductDefinition before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirPackagedProductDefinition;
    
    // Insert an existing FhirPackagedProductDefinition before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirPackagedProductDefinition);
    
    // Get the iIndexth FhirPackagedProductDefinition. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirPackagedProductDefinition);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirPackagedProductDefinition;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirPackagedProductDefinitions[index : Integer] : TFhirPackagedProductDefinition read GetItemN write SetItemN; default;
  End;

{$ENDIF FHIR_PACKAGEDPRODUCTDEFINITION}
{$IFDEF FHIR_REGULATEDAUTHORIZATION}
  // The case or regulatory procedure for granting or amending a regulated authorization. An authorization is granted in response to submissions/applications by those seeking authorization. A case is the administrative process that deals with the application(s) that relate to this and assesses them. Note: This area is subject to ongoing review and the workgroup is seeking implementer feedback on its use (see link at bottom of page).
  TFhirRegulatedAuthorizationCase = class (TFhirBackboneElement)
  protected
    FIdentifier : TFhirIdentifier;
    FType_ : TFhirCodeableConcept;
    FStatus : TFhirCodeableConcept;
    FDate : TFhirDataType;
    FapplicationList : TFhirRegulatedAuthorizationCaseList;
    procedure SetIdentifier(value : TFhirIdentifier);
    procedure SetType_(value : TFhirCodeableConcept);
    procedure SetStatus(value : TFhirCodeableConcept);
    procedure SetDate(value : TFhirDataType);
    function GetApplicationList : TFhirRegulatedAuthorizationCaseList;
    function GetHasApplicationList : Boolean;
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirRegulatedAuthorizationCase; overload;
    function Clone : TFhirRegulatedAuthorizationCase; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to Identifier by which this case can be referenced. (defined for API consistency)
    property identifier : TFhirIdentifier read FIdentifier write SetIdentifier;
    // Identifier by which this case can be referenced.
    property identifierElement : TFhirIdentifier read FIdentifier write SetIdentifier;

    // Typed access to The defining type of case. (defined for API consistency)
    property type_ : TFhirCodeableConcept read FType_ write SetType_;
    // The defining type of case.
    property type_Element : TFhirCodeableConcept read FType_ write SetType_;

    // Typed access to The status associated with the case. (defined for API consistency)
    property status : TFhirCodeableConcept read FStatus write SetStatus;
    // The status associated with the case.
    property statusElement : TFhirCodeableConcept read FStatus write SetStatus;

    // Typed access to Relevant date for this case. (defined for API consistency)
    property date : TFhirDataType read FDate write SetDate;
    // Relevant date for this case.
    property dateElement : TFhirDataType read FDate write SetDate;

    // A regulatory submission from an organization to a regulator, as part of an assessing case. Multiple applications may occur over time, with more or different information to support or modify the submission or the authorization. The applications can be considered as steps within the longer running case or procedure for this authorization process.
    property applicationList : TFhirRegulatedAuthorizationCaseList read GetApplicationList;
    property hasApplicationList : boolean read GetHasApplicationList;

  end;

  TFhirRegulatedAuthorizationCaseListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirRegulatedAuthorizationCaseList;
    function GetCurrent : TFhirRegulatedAuthorizationCase;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirRegulatedAuthorizationCaseList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirRegulatedAuthorizationCase read GetCurrent;
  end;

  TFhirRegulatedAuthorizationCaseList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirRegulatedAuthorizationCase;
    procedure SetItemN(index : Integer; value : TFhirRegulatedAuthorizationCase);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirRegulatedAuthorizationCaseList; overload;
    function Clone : TFhirRegulatedAuthorizationCaseList; overload;
    function GetEnumerator : TFhirRegulatedAuthorizationCaseListEnumerator;
    
    //  Add a FhirRegulatedAuthorizationCase to the end of the list.
    function Append : TFhirRegulatedAuthorizationCase;
    
    // Add an already existing FhirRegulatedAuthorizationCase to the end of the list.
    function AddItem(value : TFhirRegulatedAuthorizationCase) : TFhirRegulatedAuthorizationCase; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirRegulatedAuthorizationCase) : Integer;
    
    // Insert FhirRegulatedAuthorizationCase before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirRegulatedAuthorizationCase;
    
    // Insert an existing FhirRegulatedAuthorizationCase before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirRegulatedAuthorizationCase);
    
    // Get the iIndexth FhirRegulatedAuthorizationCase. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirRegulatedAuthorizationCase);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirRegulatedAuthorizationCase;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirRegulatedAuthorizationCases[index : Integer] : TFhirRegulatedAuthorizationCase read GetItemN write SetItemN; default;
  End;

  // Regulatory approval, clearance or licencing related to a regulated product, treatment, facility or activity that is cited in a guidance, regulation, rule or legislative act. An example is Market Authorization relating to a Medicinal Product.
  TFhirRegulatedAuthorization = class (TFhirDomainResource)
  protected
    FidentifierList : TFhirIdentifierList;
    FsubjectList : TFhirReferenceList;
    FType_ : TFhirCodeableConcept;
    FDescription : TFhirMarkdown;
    FregionList : TFhirCodeableConceptList;
    FStatus : TFhirCodeableConcept;
    FStatusDate : TFhirDateTime;
    FValidityPeriod : TFhirPeriod;
    FindicationList : TFhirCodeableReferenceList;
    FIntendedUse : TFhirCodeableConcept;
    FbasisList : TFhirCodeableConceptList;
    FHolder : TFhirReference;
    FRegulator : TFhirReference;
    FattachedDocumentList : TFhirReferenceList;
    FCase_ : TFhirRegulatedAuthorizationCase;
    function GetIdentifierList : TFhirIdentifierList;
    function GetHasIdentifierList : Boolean;
    function GetSubjectList : TFhirReferenceList;
    function GetHasSubjectList : Boolean;
    procedure SetType_(value : TFhirCodeableConcept);
    procedure SetDescription(value : TFhirMarkdown);
    function GetDescriptionST : String;
    procedure SetDescriptionST(value : String);
    function GetRegionList : TFhirCodeableConceptList;
    function GetHasRegionList : Boolean;
    procedure SetStatus(value : TFhirCodeableConcept);
    procedure SetStatusDate(value : TFhirDateTime);
    function GetStatusDateST : TFslDateTime;
    procedure SetStatusDateST(value : TFslDateTime);
    procedure SetValidityPeriod(value : TFhirPeriod);
    function GetIndicationList : TFhirCodeableReferenceList;
    function GetHasIndicationList : Boolean;
    procedure SetIntendedUse(value : TFhirCodeableConcept);
    function GetBasisList : TFhirCodeableConceptList;
    function GetHasBasisList : Boolean;
    procedure SetHolder(value : TFhirReference);
    procedure SetRegulator(value : TFhirReference);
    function GetAttachedDocumentList : TFhirReferenceList;
    function GetHasAttachedDocumentList : Boolean;
    procedure SetCase_(value : TFhirRegulatedAuthorizationCase);
  
    function GetResourceType : TFhirResourceType; override;
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirRegulatedAuthorization; overload;
    function Clone : TFhirRegulatedAuthorization; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Business identifier for the authorization, typically assigned by the authorizing body.
    property identifierList : TFhirIdentifierList read GetIdentifierList;
    property hasIdentifierList : boolean read GetHasIdentifierList;

    // The product type, treatment, facility or activity that is being authorized.
    property subjectList : TFhirReferenceList read GetSubjectList;
    property hasSubjectList : boolean read GetHasSubjectList;

    // Typed access to Overall type of this authorization, for example drug marketing approval, orphan drug designation. (defined for API consistency)
    property type_ : TFhirCodeableConcept read FType_ write SetType_;
    // Overall type of this authorization, for example drug marketing approval, orphan drug designation.
    property type_Element : TFhirCodeableConcept read FType_ write SetType_;

    // Typed access to General textual supporting information.
    property description : String read GetDescriptionST write SetDescriptionST;
    // General textual supporting information.
    property descriptionElement : TFhirMarkdown read FDescription write SetDescription;

    // The territory (e.g., country, jurisdiction etc.) in which the authorization has been granted.
    property regionList : TFhirCodeableConceptList read GetRegionList;
    property hasRegionList : boolean read GetHasRegionList;

    // Typed access to The status that is authorised e.g. approved. Intermediate states and actions can be tracked with cases and applications. (defined for API consistency)
    property status : TFhirCodeableConcept read FStatus write SetStatus;
    // The status that is authorised e.g. approved. Intermediate states and actions can be tracked with cases and applications.
    property statusElement : TFhirCodeableConcept read FStatus write SetStatus;

    // Typed access to The date at which the current status was assigned.
    property statusDate : TFslDateTime read GetStatusDateST write SetStatusDateST;
    // The date at which the current status was assigned.
    property statusDateElement : TFhirDateTime read FStatusDate write SetStatusDate;

    // Typed access to The time period in which the regulatory approval, clearance or licencing is in effect. As an example, a Marketing Authorization includes the date of authorization and/or an expiration date. (defined for API consistency)
    property validityPeriod : TFhirPeriod read FValidityPeriod write SetValidityPeriod;
    // The time period in which the regulatory approval, clearance or licencing is in effect. As an example, a Marketing Authorization includes the date of authorization and/or an expiration date.
    property validityPeriodElement : TFhirPeriod read FValidityPeriod write SetValidityPeriod;

    // Condition for which the use of the regulated product applies.
    property indicationList : TFhirCodeableReferenceList read GetIndicationList;
    property hasIndicationList : boolean read GetHasIndicationList;

    // Typed access to The intended use of the product, e.g. prevention, treatment, diagnosis. (defined for API consistency)
    property intendedUse : TFhirCodeableConcept read FIntendedUse write SetIntendedUse;
    // The intended use of the product, e.g. prevention, treatment, diagnosis.
    property intendedUseElement : TFhirCodeableConcept read FIntendedUse write SetIntendedUse;

    // The legal or regulatory framework against which this authorization is granted, or other reasons for it.
    property basisList : TFhirCodeableConceptList read GetBasisList;
    property hasBasisList : boolean read GetHasBasisList;

    // Typed access to The organization that has been granted this authorization, by some authoritative body (the 'regulator'). (defined for API consistency)
    property holder : TFhirReference read FHolder write SetHolder;
    // The organization that has been granted this authorization, by some authoritative body (the 'regulator').
    property holderElement : TFhirReference read FHolder write SetHolder;

    // Typed access to The regulatory authority or authorizing body granting the authorization. For example, European Medicines Agency (EMA), Food and Drug Administration (FDA), Health Canada (HC), etc. (defined for API consistency)
    property regulator : TFhirReference read FRegulator write SetRegulator;
    // The regulatory authority or authorizing body granting the authorization. For example, European Medicines Agency (EMA), Food and Drug Administration (FDA), Health Canada (HC), etc.
    property regulatorElement : TFhirReference read FRegulator write SetRegulator;

    // Additional information or supporting documentation about the authorization.
    property attachedDocumentList : TFhirReferenceList read GetAttachedDocumentList;
    property hasAttachedDocumentList : boolean read GetHasAttachedDocumentList;

    // Typed access to The case or regulatory procedure for granting or amending a regulated authorization. An authorization is granted in response to submissions/applications by those seeking authorization. A case is the administrative process that deals with the application(s) that relate to this and assesses them. Note: This area is subject to ongoing review and the workgroup is seeking implementer feedback on its use (see link at bottom of page). (defined for API consistency)
    property case_ : TFhirRegulatedAuthorizationCase read FCase_ write SetCase_;
    // The case or regulatory procedure for granting or amending a regulated authorization. An authorization is granted in response to submissions/applications by those seeking authorization. A case is the administrative process that deals with the application(s) that relate to this and assesses them. Note: This area is subject to ongoing review and the workgroup is seeking implementer feedback on its use (see link at bottom of page).
    property case_Element : TFhirRegulatedAuthorizationCase read FCase_ write SetCase_;

  end;

  TFhirRegulatedAuthorizationListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirRegulatedAuthorizationList;
    function GetCurrent : TFhirRegulatedAuthorization;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirRegulatedAuthorizationList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirRegulatedAuthorization read GetCurrent;
  end;

  TFhirRegulatedAuthorizationList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirRegulatedAuthorization;
    procedure SetItemN(index : Integer; value : TFhirRegulatedAuthorization);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirRegulatedAuthorizationList; overload;
    function Clone : TFhirRegulatedAuthorizationList; overload;
    function GetEnumerator : TFhirRegulatedAuthorizationListEnumerator;
    
    //  Add a FhirRegulatedAuthorization to the end of the list.
    function Append : TFhirRegulatedAuthorization;
    
    // Add an already existing FhirRegulatedAuthorization to the end of the list.
    function AddItem(value : TFhirRegulatedAuthorization) : TFhirRegulatedAuthorization; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirRegulatedAuthorization) : Integer;
    
    // Insert FhirRegulatedAuthorization before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirRegulatedAuthorization;
    
    // Insert an existing FhirRegulatedAuthorization before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirRegulatedAuthorization);
    
    // Get the iIndexth FhirRegulatedAuthorization. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirRegulatedAuthorization);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirRegulatedAuthorization;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirRegulatedAuthorizations[index : Integer] : TFhirRegulatedAuthorization read GetItemN write SetItemN; default;
  End;

{$ENDIF FHIR_REGULATEDAUTHORIZATION}
{$IFDEF FHIR_SUBSTANCE}
  // A substance can be composed of other substances.
  TFhirSubstanceIngredient = class (TFhirBackboneElement)
  protected
    FQuantity : TFhirRatio;
    FSubstance : TFhirDataType;
    procedure SetQuantity(value : TFhirRatio);
    procedure SetSubstance(value : TFhirDataType);
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirSubstanceIngredient; overload;
    function Clone : TFhirSubstanceIngredient; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to The amount of the ingredient in the substance - a concentration ratio. (defined for API consistency)
    property quantity : TFhirRatio read FQuantity write SetQuantity;
    // The amount of the ingredient in the substance - a concentration ratio.
    property quantityElement : TFhirRatio read FQuantity write SetQuantity;

    // Typed access to Another substance that is a component of this substance. (defined for API consistency)
    property substance : TFhirDataType read FSubstance write SetSubstance;
    // Another substance that is a component of this substance.
    property substanceElement : TFhirDataType read FSubstance write SetSubstance;

  end;

  TFhirSubstanceIngredientListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirSubstanceIngredientList;
    function GetCurrent : TFhirSubstanceIngredient;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirSubstanceIngredientList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirSubstanceIngredient read GetCurrent;
  end;

  TFhirSubstanceIngredientList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirSubstanceIngredient;
    procedure SetItemN(index : Integer; value : TFhirSubstanceIngredient);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirSubstanceIngredientList; overload;
    function Clone : TFhirSubstanceIngredientList; overload;
    function GetEnumerator : TFhirSubstanceIngredientListEnumerator;
    
    //  Add a FhirSubstanceIngredient to the end of the list.
    function Append : TFhirSubstanceIngredient;
    
    // Add an already existing FhirSubstanceIngredient to the end of the list.
    function AddItem(value : TFhirSubstanceIngredient) : TFhirSubstanceIngredient; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirSubstanceIngredient) : Integer;
    
    // Insert FhirSubstanceIngredient before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirSubstanceIngredient;
    
    // Insert an existing FhirSubstanceIngredient before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirSubstanceIngredient);
    
    // Get the iIndexth FhirSubstanceIngredient. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirSubstanceIngredient);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirSubstanceIngredient;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirSubstanceIngredients[index : Integer] : TFhirSubstanceIngredient read GetItemN write SetItemN; default;
  End;

  // A homogeneous material with a definite composition.
  TFhirSubstance = class (TFhirDomainResource)
  protected
    FidentifierList : TFhirIdentifierList;
    FInstance : TFhirBoolean;
    FStatus : TFhirEnum;
    FcategoryList : TFhirCodeableConceptList;
    FCode : TFhirCodeableReference;
    FDescription : TFhirString;
    FExpiry : TFhirDateTime;
    FQuantity : TFhirQuantity;
    FingredientList : TFhirSubstanceIngredientList;
    function GetIdentifierList : TFhirIdentifierList;
    function GetHasIdentifierList : Boolean;
    procedure SetInstance(value : TFhirBoolean);
    function GetInstanceST : Boolean;
    procedure SetInstanceST(value : Boolean);
    procedure SetStatus(value : TFhirEnum);
    function GetStatusST : TFhirFHIRSubstanceStatusEnum;
    procedure SetStatusST(value : TFhirFHIRSubstanceStatusEnum);
    function GetCategoryList : TFhirCodeableConceptList;
    function GetHasCategoryList : Boolean;
    procedure SetCode(value : TFhirCodeableReference);
    procedure SetDescription(value : TFhirString);
    function GetDescriptionST : String;
    procedure SetDescriptionST(value : String);
    procedure SetExpiry(value : TFhirDateTime);
    function GetExpiryST : TFslDateTime;
    procedure SetExpiryST(value : TFslDateTime);
    procedure SetQuantity(value : TFhirQuantity);
    function GetIngredientList : TFhirSubstanceIngredientList;
    function GetHasIngredientList : Boolean;
  
    function GetResourceType : TFhirResourceType; override;
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirSubstance; overload;
    function Clone : TFhirSubstance; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Unique identifier for the substance. For an instance, an identifier associated with the package/container (usually a label affixed directly).
    property identifierList : TFhirIdentifierList read GetIdentifierList;
    property hasIdentifierList : boolean read GetHasIdentifierList;

    // Typed access to A boolean to indicate if this an instance of a substance or a kind of one (a definition).
    property instance : Boolean read GetInstanceST write SetInstanceST;
    // A boolean to indicate if this an instance of a substance or a kind of one (a definition).
    property instanceElement : TFhirBoolean read FInstance write SetInstance;

    // A code to indicate if the substance is actively used.
    property status : TFhirFHIRSubstanceStatusEnum read GetStatusST write SetStatusST;
    property statusElement : TFhirEnum read FStatus write SetStatus;

    // A code that classifies the general type of substance.  This is used  for searching, sorting and display purposes.
    property categoryList : TFhirCodeableConceptList read GetCategoryList;
    property hasCategoryList : boolean read GetHasCategoryList;

    // Typed access to A code (or set of codes) that identify this substance. (defined for API consistency)
    property code : TFhirCodeableReference read FCode write SetCode;
    // A code (or set of codes) that identify this substance.
    property codeElement : TFhirCodeableReference read FCode write SetCode;

    // Typed access to A description of the substance - its appearance, handling requirements, and other usage notes.
    property description : String read GetDescriptionST write SetDescriptionST;
    // A description of the substance - its appearance, handling requirements, and other usage notes.
    property descriptionElement : TFhirString read FDescription write SetDescription;

    // Typed access to When the substance is no longer valid to use. For some substances, a single arbitrary date is used for expiry.
    property expiry : TFslDateTime read GetExpiryST write SetExpiryST;
    // When the substance is no longer valid to use. For some substances, a single arbitrary date is used for expiry.
    property expiryElement : TFhirDateTime read FExpiry write SetExpiry;

    // Typed access to The amount of the substance. (defined for API consistency)
    property quantity : TFhirQuantity read FQuantity write SetQuantity;
    // The amount of the substance.
    property quantityElement : TFhirQuantity read FQuantity write SetQuantity;

    // A substance can be composed of other substances.
    property ingredientList : TFhirSubstanceIngredientList read GetIngredientList;
    property hasIngredientList : boolean read GetHasIngredientList;

  end;

  TFhirSubstanceListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirSubstanceList;
    function GetCurrent : TFhirSubstance;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirSubstanceList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirSubstance read GetCurrent;
  end;

  TFhirSubstanceList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirSubstance;
    procedure SetItemN(index : Integer; value : TFhirSubstance);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirSubstanceList; overload;
    function Clone : TFhirSubstanceList; overload;
    function GetEnumerator : TFhirSubstanceListEnumerator;
    
    //  Add a FhirSubstance to the end of the list.
    function Append : TFhirSubstance;
    
    // Add an already existing FhirSubstance to the end of the list.
    function AddItem(value : TFhirSubstance) : TFhirSubstance; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirSubstance) : Integer;
    
    // Insert FhirSubstance before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirSubstance;
    
    // Insert an existing FhirSubstance before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirSubstance);
    
    // Get the iIndexth FhirSubstance. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirSubstance);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirSubstance;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirSubstances[index : Integer] : TFhirSubstance read GetItemN write SetItemN; default;
  End;

{$ENDIF FHIR_SUBSTANCE}
{$IFDEF FHIR_SUBSTANCEDEFINITION}
  // Moiety, for structural modifications.
  TFhirSubstanceDefinitionMoiety = class (TFhirBackboneElement)
  protected
    FRole : TFhirCodeableConcept;
    FIdentifier : TFhirIdentifier;
    FName : TFhirString;
    FStereochemistry : TFhirCodeableConcept;
    FOpticalActivity : TFhirCodeableConcept;
    FMolecularFormula : TFhirString;
    FAmount : TFhirDataType;
    FMeasurementType : TFhirCodeableConcept;
    procedure SetRole(value : TFhirCodeableConcept);
    procedure SetIdentifier(value : TFhirIdentifier);
    procedure SetName(value : TFhirString);
    function GetNameST : String;
    procedure SetNameST(value : String);
    procedure SetStereochemistry(value : TFhirCodeableConcept);
    procedure SetOpticalActivity(value : TFhirCodeableConcept);
    procedure SetMolecularFormula(value : TFhirString);
    function GetMolecularFormulaST : String;
    procedure SetMolecularFormulaST(value : String);
    procedure SetAmount(value : TFhirDataType);
    procedure SetMeasurementType(value : TFhirCodeableConcept);
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirSubstanceDefinitionMoiety; overload;
    function Clone : TFhirSubstanceDefinitionMoiety; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to Role that the moiety is playing. (defined for API consistency)
    property role : TFhirCodeableConcept read FRole write SetRole;
    // Role that the moiety is playing.
    property roleElement : TFhirCodeableConcept read FRole write SetRole;

    // Typed access to Identifier by which this moiety substance is known. (defined for API consistency)
    property identifier : TFhirIdentifier read FIdentifier write SetIdentifier;
    // Identifier by which this moiety substance is known.
    property identifierElement : TFhirIdentifier read FIdentifier write SetIdentifier;

    // Typed access to Textual name for this moiety substance.
    property name : String read GetNameST write SetNameST;
    // Textual name for this moiety substance.
    property nameElement : TFhirString read FName write SetName;

    // Typed access to Stereochemistry type. (defined for API consistency)
    property stereochemistry : TFhirCodeableConcept read FStereochemistry write SetStereochemistry;
    // Stereochemistry type.
    property stereochemistryElement : TFhirCodeableConcept read FStereochemistry write SetStereochemistry;

    // Typed access to Optical activity type. (defined for API consistency)
    property opticalActivity : TFhirCodeableConcept read FOpticalActivity write SetOpticalActivity;
    // Optical activity type.
    property opticalActivityElement : TFhirCodeableConcept read FOpticalActivity write SetOpticalActivity;

    // Typed access to Molecular formula for this moiety of this substance, typically using the Hill system.
    property molecularFormula : String read GetMolecularFormulaST write SetMolecularFormulaST;
    // Molecular formula for this moiety of this substance, typically using the Hill system.
    property molecularFormulaElement : TFhirString read FMolecularFormula write SetMolecularFormula;

    // Typed access to Quantitative value for this moiety. (defined for API consistency)
    property amount : TFhirDataType read FAmount write SetAmount;
    // Quantitative value for this moiety.
    property amountElement : TFhirDataType read FAmount write SetAmount;

    // Typed access to The measurement type of the quantitative value. In capturing the actual relative amounts of substances or molecular fragments it may be necessary to indicate whether the amount refers to, for example, a mole ratio or weight ratio. (defined for API consistency)
    property measurementType : TFhirCodeableConcept read FMeasurementType write SetMeasurementType;
    // The measurement type of the quantitative value. In capturing the actual relative amounts of substances or molecular fragments it may be necessary to indicate whether the amount refers to, for example, a mole ratio or weight ratio.
    property measurementTypeElement : TFhirCodeableConcept read FMeasurementType write SetMeasurementType;

  end;

  TFhirSubstanceDefinitionMoietyListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirSubstanceDefinitionMoietyList;
    function GetCurrent : TFhirSubstanceDefinitionMoiety;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirSubstanceDefinitionMoietyList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirSubstanceDefinitionMoiety read GetCurrent;
  end;

  TFhirSubstanceDefinitionMoietyList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirSubstanceDefinitionMoiety;
    procedure SetItemN(index : Integer; value : TFhirSubstanceDefinitionMoiety);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirSubstanceDefinitionMoietyList; overload;
    function Clone : TFhirSubstanceDefinitionMoietyList; overload;
    function GetEnumerator : TFhirSubstanceDefinitionMoietyListEnumerator;
    
    //  Add a FhirSubstanceDefinitionMoiety to the end of the list.
    function Append : TFhirSubstanceDefinitionMoiety;
    
    // Add an already existing FhirSubstanceDefinitionMoiety to the end of the list.
    function AddItem(value : TFhirSubstanceDefinitionMoiety) : TFhirSubstanceDefinitionMoiety; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirSubstanceDefinitionMoiety) : Integer;
    
    // Insert FhirSubstanceDefinitionMoiety before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirSubstanceDefinitionMoiety;
    
    // Insert an existing FhirSubstanceDefinitionMoiety before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirSubstanceDefinitionMoiety);
    
    // Get the iIndexth FhirSubstanceDefinitionMoiety. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirSubstanceDefinitionMoiety);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirSubstanceDefinitionMoiety;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirSubstanceDefinitionMoieties[index : Integer] : TFhirSubstanceDefinitionMoiety read GetItemN write SetItemN; default;
  End;

  // General specifications for this substance.
  TFhirSubstanceDefinitionProperty = class (TFhirBackboneElement)
  protected
    FType_ : TFhirCodeableConcept;
    FValue : TFhirDataType;
    procedure SetType_(value : TFhirCodeableConcept);
    procedure SetValue(value : TFhirDataType);
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirSubstanceDefinitionProperty; overload;
    function Clone : TFhirSubstanceDefinitionProperty; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to A code expressing the type of property. (defined for API consistency)
    property type_ : TFhirCodeableConcept read FType_ write SetType_;
    // A code expressing the type of property.
    property type_Element : TFhirCodeableConcept read FType_ write SetType_;

    // Typed access to A value for the property. (defined for API consistency)
    property value : TFhirDataType read FValue write SetValue;
    // A value for the property.
    property valueElement : TFhirDataType read FValue write SetValue;

  end;

  TFhirSubstanceDefinitionPropertyListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirSubstanceDefinitionPropertyList;
    function GetCurrent : TFhirSubstanceDefinitionProperty;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirSubstanceDefinitionPropertyList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirSubstanceDefinitionProperty read GetCurrent;
  end;

  TFhirSubstanceDefinitionPropertyList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirSubstanceDefinitionProperty;
    procedure SetItemN(index : Integer; value : TFhirSubstanceDefinitionProperty);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirSubstanceDefinitionPropertyList; overload;
    function Clone : TFhirSubstanceDefinitionPropertyList; overload;
    function GetEnumerator : TFhirSubstanceDefinitionPropertyListEnumerator;
    
    //  Add a FhirSubstanceDefinitionProperty to the end of the list.
    function Append : TFhirSubstanceDefinitionProperty;
    
    // Add an already existing FhirSubstanceDefinitionProperty to the end of the list.
    function AddItem(value : TFhirSubstanceDefinitionProperty) : TFhirSubstanceDefinitionProperty; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirSubstanceDefinitionProperty) : Integer;
    
    // Insert FhirSubstanceDefinitionProperty before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirSubstanceDefinitionProperty;
    
    // Insert an existing FhirSubstanceDefinitionProperty before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirSubstanceDefinitionProperty);
    
    // Get the iIndexth FhirSubstanceDefinitionProperty. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirSubstanceDefinitionProperty);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirSubstanceDefinitionProperty;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirSubstanceDefinitionProperties[index : Integer] : TFhirSubstanceDefinitionProperty read GetItemN write SetItemN; default;
  End;

  // The molecular weight or weight range (for proteins, polymers or nucleic acids).
  TFhirSubstanceDefinitionMolecularWeight = class (TFhirBackboneElement)
  protected
    FMethod : TFhirCodeableConcept;
    FType_ : TFhirCodeableConcept;
    FAmount : TFhirQuantity;
    procedure SetMethod(value : TFhirCodeableConcept);
    procedure SetType_(value : TFhirCodeableConcept);
    procedure SetAmount(value : TFhirQuantity);
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirSubstanceDefinitionMolecularWeight; overload;
    function Clone : TFhirSubstanceDefinitionMolecularWeight; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to The method by which the molecular weight was determined. (defined for API consistency)
    property method : TFhirCodeableConcept read FMethod write SetMethod;
    // The method by which the molecular weight was determined.
    property methodElement : TFhirCodeableConcept read FMethod write SetMethod;

    // Typed access to Type of molecular weight such as exact, average (also known as. number average), weight average. (defined for API consistency)
    property type_ : TFhirCodeableConcept read FType_ write SetType_;
    // Type of molecular weight such as exact, average (also known as. number average), weight average.
    property type_Element : TFhirCodeableConcept read FType_ write SetType_;

    // Typed access to Used to capture quantitative values for a variety of elements. If only limits are given, the arithmetic mean would be the average. If only a single definite value for a given element is given, it would be captured in this field. (defined for API consistency)
    property amount : TFhirQuantity read FAmount write SetAmount;
    // Used to capture quantitative values for a variety of elements. If only limits are given, the arithmetic mean would be the average. If only a single definite value for a given element is given, it would be captured in this field.
    property amountElement : TFhirQuantity read FAmount write SetAmount;

  end;

  TFhirSubstanceDefinitionMolecularWeightListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirSubstanceDefinitionMolecularWeightList;
    function GetCurrent : TFhirSubstanceDefinitionMolecularWeight;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirSubstanceDefinitionMolecularWeightList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirSubstanceDefinitionMolecularWeight read GetCurrent;
  end;

  TFhirSubstanceDefinitionMolecularWeightList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirSubstanceDefinitionMolecularWeight;
    procedure SetItemN(index : Integer; value : TFhirSubstanceDefinitionMolecularWeight);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirSubstanceDefinitionMolecularWeightList; overload;
    function Clone : TFhirSubstanceDefinitionMolecularWeightList; overload;
    function GetEnumerator : TFhirSubstanceDefinitionMolecularWeightListEnumerator;
    
    //  Add a FhirSubstanceDefinitionMolecularWeight to the end of the list.
    function Append : TFhirSubstanceDefinitionMolecularWeight;
    
    // Add an already existing FhirSubstanceDefinitionMolecularWeight to the end of the list.
    function AddItem(value : TFhirSubstanceDefinitionMolecularWeight) : TFhirSubstanceDefinitionMolecularWeight; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirSubstanceDefinitionMolecularWeight) : Integer;
    
    // Insert FhirSubstanceDefinitionMolecularWeight before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirSubstanceDefinitionMolecularWeight;
    
    // Insert an existing FhirSubstanceDefinitionMolecularWeight before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirSubstanceDefinitionMolecularWeight);
    
    // Get the iIndexth FhirSubstanceDefinitionMolecularWeight. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirSubstanceDefinitionMolecularWeight);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirSubstanceDefinitionMolecularWeight;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirSubstanceDefinitionMolecularWeights[index : Integer] : TFhirSubstanceDefinitionMolecularWeight read GetItemN write SetItemN; default;
  End;

  // Structural information.
  TFhirSubstanceDefinitionStructure = class (TFhirBackboneElement)
  protected
    FStereochemistry : TFhirCodeableConcept;
    FOpticalActivity : TFhirCodeableConcept;
    FMolecularFormula : TFhirString;
    FMolecularFormulaByMoiety : TFhirString;
    FMolecularWeight : TFhirSubstanceDefinitionMolecularWeight;
    FtechniqueList : TFhirCodeableConceptList;
    FsourceDocumentList : TFhirReferenceList;
    FrepresentationList : TFhirSubstanceDefinitionStructureRepresentationList;
    procedure SetStereochemistry(value : TFhirCodeableConcept);
    procedure SetOpticalActivity(value : TFhirCodeableConcept);
    procedure SetMolecularFormula(value : TFhirString);
    function GetMolecularFormulaST : String;
    procedure SetMolecularFormulaST(value : String);
    procedure SetMolecularFormulaByMoiety(value : TFhirString);
    function GetMolecularFormulaByMoietyST : String;
    procedure SetMolecularFormulaByMoietyST(value : String);
    procedure SetMolecularWeight(value : TFhirSubstanceDefinitionMolecularWeight);
    function GetTechniqueList : TFhirCodeableConceptList;
    function GetHasTechniqueList : Boolean;
    function GetSourceDocumentList : TFhirReferenceList;
    function GetHasSourceDocumentList : Boolean;
    function GetRepresentationList : TFhirSubstanceDefinitionStructureRepresentationList;
    function GetHasRepresentationList : Boolean;
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirSubstanceDefinitionStructure; overload;
    function Clone : TFhirSubstanceDefinitionStructure; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to Stereochemistry type. (defined for API consistency)
    property stereochemistry : TFhirCodeableConcept read FStereochemistry write SetStereochemistry;
    // Stereochemistry type.
    property stereochemistryElement : TFhirCodeableConcept read FStereochemistry write SetStereochemistry;

    // Typed access to Optical activity type. (defined for API consistency)
    property opticalActivity : TFhirCodeableConcept read FOpticalActivity write SetOpticalActivity;
    // Optical activity type.
    property opticalActivityElement : TFhirCodeableConcept read FOpticalActivity write SetOpticalActivity;

    // Typed access to Molecular formula of this substance, typically using the Hill system.
    property molecularFormula : String read GetMolecularFormulaST write SetMolecularFormulaST;
    // Molecular formula of this substance, typically using the Hill system.
    property molecularFormulaElement : TFhirString read FMolecularFormula write SetMolecularFormula;

    // Typed access to Specified per moiety according to the Hill system, i.e. first C, then H, then alphabetical, each moiety separated by a dot.
    property molecularFormulaByMoiety : String read GetMolecularFormulaByMoietyST write SetMolecularFormulaByMoietyST;
    // Specified per moiety according to the Hill system, i.e. first C, then H, then alphabetical, each moiety separated by a dot.
    property molecularFormulaByMoietyElement : TFhirString read FMolecularFormulaByMoiety write SetMolecularFormulaByMoiety;

    // Typed access to The molecular weight or weight range (for proteins, polymers or nucleic acids). (defined for API consistency)
    property molecularWeight : TFhirSubstanceDefinitionMolecularWeight read FMolecularWeight write SetMolecularWeight;
    // The molecular weight or weight range (for proteins, polymers or nucleic acids).
    property molecularWeightElement : TFhirSubstanceDefinitionMolecularWeight read FMolecularWeight write SetMolecularWeight;

    // The method used to elucidate the structure or characterization of the drug substance. Examples: X-ray, HPLC, NMR, Peptide mapping, Ligand binding assay.
    property techniqueList : TFhirCodeableConceptList read GetTechniqueList;
    property hasTechniqueList : boolean read GetHasTechniqueList;

    // The source of information about the structure.
    property sourceDocumentList : TFhirReferenceList read GetSourceDocumentList;
    property hasSourceDocumentList : boolean read GetHasSourceDocumentList;

    // A depiction of the structure or characterization of the substance.
    property representationList : TFhirSubstanceDefinitionStructureRepresentationList read GetRepresentationList;
    property hasRepresentationList : boolean read GetHasRepresentationList;

  end;

  TFhirSubstanceDefinitionStructureListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirSubstanceDefinitionStructureList;
    function GetCurrent : TFhirSubstanceDefinitionStructure;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirSubstanceDefinitionStructureList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirSubstanceDefinitionStructure read GetCurrent;
  end;

  TFhirSubstanceDefinitionStructureList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirSubstanceDefinitionStructure;
    procedure SetItemN(index : Integer; value : TFhirSubstanceDefinitionStructure);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirSubstanceDefinitionStructureList; overload;
    function Clone : TFhirSubstanceDefinitionStructureList; overload;
    function GetEnumerator : TFhirSubstanceDefinitionStructureListEnumerator;
    
    //  Add a FhirSubstanceDefinitionStructure to the end of the list.
    function Append : TFhirSubstanceDefinitionStructure;
    
    // Add an already existing FhirSubstanceDefinitionStructure to the end of the list.
    function AddItem(value : TFhirSubstanceDefinitionStructure) : TFhirSubstanceDefinitionStructure; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirSubstanceDefinitionStructure) : Integer;
    
    // Insert FhirSubstanceDefinitionStructure before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirSubstanceDefinitionStructure;
    
    // Insert an existing FhirSubstanceDefinitionStructure before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirSubstanceDefinitionStructure);
    
    // Get the iIndexth FhirSubstanceDefinitionStructure. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirSubstanceDefinitionStructure);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirSubstanceDefinitionStructure;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirSubstanceDefinitionStructures[index : Integer] : TFhirSubstanceDefinitionStructure read GetItemN write SetItemN; default;
  End;

  // A depiction of the structure or characterization of the substance.
  TFhirSubstanceDefinitionStructureRepresentation = class (TFhirBackboneElement)
  protected
    FType_ : TFhirCodeableConcept;
    FRepresentation : TFhirString;
    FFormat : TFhirCodeableConcept;
    FDocument : TFhirReference;
    procedure SetType_(value : TFhirCodeableConcept);
    procedure SetRepresentation(value : TFhirString);
    function GetRepresentationST : String;
    procedure SetRepresentationST(value : String);
    procedure SetFormat(value : TFhirCodeableConcept);
    procedure SetDocument(value : TFhirReference);
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirSubstanceDefinitionStructureRepresentation; overload;
    function Clone : TFhirSubstanceDefinitionStructureRepresentation; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to The kind of structural representation (e.g. full, partial). (defined for API consistency)
    property type_ : TFhirCodeableConcept read FType_ write SetType_;
    // The kind of structural representation (e.g. full, partial).
    property type_Element : TFhirCodeableConcept read FType_ write SetType_;

    // Typed access to The structural representation or characterization as a text string in a standard format.
    property representation : String read GetRepresentationST write SetRepresentationST;
    // The structural representation or characterization as a text string in a standard format.
    property representationElement : TFhirString read FRepresentation write SetRepresentation;

    // Typed access to The format of the representation e.g. InChI, SMILES, MOLFILE, CDX, SDF, PDB, mmCIF. The logical content type rather than the physical file format of a document. (defined for API consistency)
    property format : TFhirCodeableConcept read FFormat write SetFormat;
    // The format of the representation e.g. InChI, SMILES, MOLFILE, CDX, SDF, PDB, mmCIF. The logical content type rather than the physical file format of a document.
    property formatElement : TFhirCodeableConcept read FFormat write SetFormat;

    // Typed access to An attached file with the structural representation or characterization e.g. a molecular structure graphic of the substance, a JCAMP or AnIML file. (defined for API consistency)
    property document : TFhirReference read FDocument write SetDocument;
    // An attached file with the structural representation or characterization e.g. a molecular structure graphic of the substance, a JCAMP or AnIML file.
    property documentElement : TFhirReference read FDocument write SetDocument;

  end;

  TFhirSubstanceDefinitionStructureRepresentationListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirSubstanceDefinitionStructureRepresentationList;
    function GetCurrent : TFhirSubstanceDefinitionStructureRepresentation;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirSubstanceDefinitionStructureRepresentationList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirSubstanceDefinitionStructureRepresentation read GetCurrent;
  end;

  TFhirSubstanceDefinitionStructureRepresentationList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirSubstanceDefinitionStructureRepresentation;
    procedure SetItemN(index : Integer; value : TFhirSubstanceDefinitionStructureRepresentation);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirSubstanceDefinitionStructureRepresentationList; overload;
    function Clone : TFhirSubstanceDefinitionStructureRepresentationList; overload;
    function GetEnumerator : TFhirSubstanceDefinitionStructureRepresentationListEnumerator;
    
    //  Add a FhirSubstanceDefinitionStructureRepresentation to the end of the list.
    function Append : TFhirSubstanceDefinitionStructureRepresentation;
    
    // Add an already existing FhirSubstanceDefinitionStructureRepresentation to the end of the list.
    function AddItem(value : TFhirSubstanceDefinitionStructureRepresentation) : TFhirSubstanceDefinitionStructureRepresentation; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirSubstanceDefinitionStructureRepresentation) : Integer;
    
    // Insert FhirSubstanceDefinitionStructureRepresentation before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirSubstanceDefinitionStructureRepresentation;
    
    // Insert an existing FhirSubstanceDefinitionStructureRepresentation before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirSubstanceDefinitionStructureRepresentation);
    
    // Get the iIndexth FhirSubstanceDefinitionStructureRepresentation. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirSubstanceDefinitionStructureRepresentation);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirSubstanceDefinitionStructureRepresentation;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirSubstanceDefinitionStructureRepresentations[index : Integer] : TFhirSubstanceDefinitionStructureRepresentation read GetItemN write SetItemN; default;
  End;

  // Codes associated with the substance.
  TFhirSubstanceDefinitionCode = class (TFhirBackboneElement)
  protected
    FCode : TFhirCodeableConcept;
    FStatus : TFhirCodeableConcept;
    FStatusDate : TFhirDateTime;
    FnoteList : TFhirAnnotationList;
    FsourceList : TFhirReferenceList;
    procedure SetCode(value : TFhirCodeableConcept);
    procedure SetStatus(value : TFhirCodeableConcept);
    procedure SetStatusDate(value : TFhirDateTime);
    function GetStatusDateST : TFslDateTime;
    procedure SetStatusDateST(value : TFslDateTime);
    function GetNoteList : TFhirAnnotationList;
    function GetHasNoteList : Boolean;
    function GetSourceList : TFhirReferenceList;
    function GetHasSourceList : Boolean;
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirSubstanceDefinitionCode; overload;
    function Clone : TFhirSubstanceDefinitionCode; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to The specific code. (defined for API consistency)
    property code : TFhirCodeableConcept read FCode write SetCode;
    // The specific code.
    property codeElement : TFhirCodeableConcept read FCode write SetCode;

    // Typed access to Status of the code assignment, for example 'provisional', 'approved'. (defined for API consistency)
    property status : TFhirCodeableConcept read FStatus write SetStatus;
    // Status of the code assignment, for example 'provisional', 'approved'.
    property statusElement : TFhirCodeableConcept read FStatus write SetStatus;

    // Typed access to The date at which the code status was changed as part of the terminology maintenance.
    property statusDate : TFslDateTime read GetStatusDateST write SetStatusDateST;
    // The date at which the code status was changed as part of the terminology maintenance.
    property statusDateElement : TFhirDateTime read FStatusDate write SetStatusDate;

    // Any comment can be provided in this field, if necessary.
    property noteList : TFhirAnnotationList read GetNoteList;
    property hasNoteList : boolean read GetHasNoteList;

    // Supporting literature.
    property sourceList : TFhirReferenceList read GetSourceList;
    property hasSourceList : boolean read GetHasSourceList;

  end;

  TFhirSubstanceDefinitionCodeListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirSubstanceDefinitionCodeList;
    function GetCurrent : TFhirSubstanceDefinitionCode;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirSubstanceDefinitionCodeList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirSubstanceDefinitionCode read GetCurrent;
  end;

  TFhirSubstanceDefinitionCodeList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirSubstanceDefinitionCode;
    procedure SetItemN(index : Integer; value : TFhirSubstanceDefinitionCode);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirSubstanceDefinitionCodeList; overload;
    function Clone : TFhirSubstanceDefinitionCodeList; overload;
    function GetEnumerator : TFhirSubstanceDefinitionCodeListEnumerator;
    
    //  Add a FhirSubstanceDefinitionCode to the end of the list.
    function Append : TFhirSubstanceDefinitionCode;
    
    // Add an already existing FhirSubstanceDefinitionCode to the end of the list.
    function AddItem(value : TFhirSubstanceDefinitionCode) : TFhirSubstanceDefinitionCode; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirSubstanceDefinitionCode) : Integer;
    
    // Insert FhirSubstanceDefinitionCode before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirSubstanceDefinitionCode;
    
    // Insert an existing FhirSubstanceDefinitionCode before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirSubstanceDefinitionCode);
    
    // Get the iIndexth FhirSubstanceDefinitionCode. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirSubstanceDefinitionCode);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirSubstanceDefinitionCode;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirSubstanceDefinitionCodes[index : Integer] : TFhirSubstanceDefinitionCode read GetItemN write SetItemN; default;
  End;

  // Names applicable to this substance.
  TFhirSubstanceDefinitionName = class (TFhirBackboneElement)
  protected
    FName : TFhirString;
    FType_ : TFhirCodeableConcept;
    FStatus : TFhirCodeableConcept;
    FPreferred : TFhirBoolean;
    FlanguageList : TFhirCodeableConceptList;
    FdomainList : TFhirCodeableConceptList;
    FjurisdictionList : TFhirCodeableConceptList;
    FsynonymList : TFhirSubstanceDefinitionNameList;
    FtranslationList : TFhirSubstanceDefinitionNameList;
    FofficialList : TFhirSubstanceDefinitionNameOfficialList;
    FsourceList : TFhirReferenceList;
    procedure SetName(value : TFhirString);
    function GetNameST : String;
    procedure SetNameST(value : String);
    procedure SetType_(value : TFhirCodeableConcept);
    procedure SetStatus(value : TFhirCodeableConcept);
    procedure SetPreferred(value : TFhirBoolean);
    function GetPreferredST : Boolean;
    procedure SetPreferredST(value : Boolean);
    function GetLanguageList : TFhirCodeableConceptList;
    function GetHasLanguageList : Boolean;
    function GetDomainList : TFhirCodeableConceptList;
    function GetHasDomainList : Boolean;
    function GetJurisdictionList : TFhirCodeableConceptList;
    function GetHasJurisdictionList : Boolean;
    function GetSynonymList : TFhirSubstanceDefinitionNameList;
    function GetHasSynonymList : Boolean;
    function GetTranslationList : TFhirSubstanceDefinitionNameList;
    function GetHasTranslationList : Boolean;
    function GetOfficialList : TFhirSubstanceDefinitionNameOfficialList;
    function GetHasOfficialList : Boolean;
    function GetSourceList : TFhirReferenceList;
    function GetHasSourceList : Boolean;
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirSubstanceDefinitionName; overload;
    function Clone : TFhirSubstanceDefinitionName; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to The actual name.
    property name : String read GetNameST write SetNameST;
    // The actual name.
    property nameElement : TFhirString read FName write SetName;

    // Typed access to Name type, for example 'systematic',  'scientific, 'brand'. (defined for API consistency)
    property type_ : TFhirCodeableConcept read FType_ write SetType_;
    // Name type, for example 'systematic',  'scientific, 'brand'.
    property type_Element : TFhirCodeableConcept read FType_ write SetType_;

    // Typed access to The status of the name, for example 'current', 'proposed'. (defined for API consistency)
    property status : TFhirCodeableConcept read FStatus write SetStatus;
    // The status of the name, for example 'current', 'proposed'.
    property statusElement : TFhirCodeableConcept read FStatus write SetStatus;

    // Typed access to If this is the preferred name for this substance.
    property preferred : Boolean read GetPreferredST write SetPreferredST;
    // If this is the preferred name for this substance.
    property preferredElement : TFhirBoolean read FPreferred write SetPreferred;

    // Human language that the name is written in.
    property languageList : TFhirCodeableConceptList read GetLanguageList;
    property hasLanguageList : boolean read GetHasLanguageList;

    // The use context of this name for example if there is a different name a drug active ingredient as opposed to a food colour additive.
    property domainList : TFhirCodeableConceptList read GetDomainList;
    property hasDomainList : boolean read GetHasDomainList;

    // The jurisdiction where this name applies.
    property jurisdictionList : TFhirCodeableConceptList read GetJurisdictionList;
    property hasJurisdictionList : boolean read GetHasJurisdictionList;

    // A synonym of this particular name, by which the substance is also known.
    property synonymList : TFhirSubstanceDefinitionNameList read GetSynonymList;
    property hasSynonymList : boolean read GetHasSynonymList;

    // A translation for this name into another human language.
    property translationList : TFhirSubstanceDefinitionNameList read GetTranslationList;
    property hasTranslationList : boolean read GetHasTranslationList;

    // Details of the official nature of this name.
    property officialList : TFhirSubstanceDefinitionNameOfficialList read GetOfficialList;
    property hasOfficialList : boolean read GetHasOfficialList;

    // Supporting literature.
    property sourceList : TFhirReferenceList read GetSourceList;
    property hasSourceList : boolean read GetHasSourceList;

  end;

  TFhirSubstanceDefinitionNameListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirSubstanceDefinitionNameList;
    function GetCurrent : TFhirSubstanceDefinitionName;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirSubstanceDefinitionNameList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirSubstanceDefinitionName read GetCurrent;
  end;

  TFhirSubstanceDefinitionNameList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirSubstanceDefinitionName;
    procedure SetItemN(index : Integer; value : TFhirSubstanceDefinitionName);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirSubstanceDefinitionNameList; overload;
    function Clone : TFhirSubstanceDefinitionNameList; overload;
    function GetEnumerator : TFhirSubstanceDefinitionNameListEnumerator;
    
    //  Add a FhirSubstanceDefinitionName to the end of the list.
    function Append : TFhirSubstanceDefinitionName;
    
    // Add an already existing FhirSubstanceDefinitionName to the end of the list.
    function AddItem(value : TFhirSubstanceDefinitionName) : TFhirSubstanceDefinitionName; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirSubstanceDefinitionName) : Integer;
    
    // Insert FhirSubstanceDefinitionName before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirSubstanceDefinitionName;
    
    // Insert an existing FhirSubstanceDefinitionName before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirSubstanceDefinitionName);
    
    // Get the iIndexth FhirSubstanceDefinitionName. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirSubstanceDefinitionName);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirSubstanceDefinitionName;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirSubstanceDefinitionNames[index : Integer] : TFhirSubstanceDefinitionName read GetItemN write SetItemN; default;
  End;

  // Details of the official nature of this name.
  TFhirSubstanceDefinitionNameOfficial = class (TFhirBackboneElement)
  protected
    FAuthority : TFhirCodeableConcept;
    FStatus : TFhirCodeableConcept;
    FDate : TFhirDateTime;
    procedure SetAuthority(value : TFhirCodeableConcept);
    procedure SetStatus(value : TFhirCodeableConcept);
    procedure SetDate(value : TFhirDateTime);
    function GetDateST : TFslDateTime;
    procedure SetDateST(value : TFslDateTime);
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirSubstanceDefinitionNameOfficial; overload;
    function Clone : TFhirSubstanceDefinitionNameOfficial; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to Which authority uses this official name. (defined for API consistency)
    property authority : TFhirCodeableConcept read FAuthority write SetAuthority;
    // Which authority uses this official name.
    property authorityElement : TFhirCodeableConcept read FAuthority write SetAuthority;

    // Typed access to The status of the official name, for example 'draft', 'active', 'retired'. (defined for API consistency)
    property status : TFhirCodeableConcept read FStatus write SetStatus;
    // The status of the official name, for example 'draft', 'active', 'retired'.
    property statusElement : TFhirCodeableConcept read FStatus write SetStatus;

    // Typed access to Date of the official name change.
    property date : TFslDateTime read GetDateST write SetDateST;
    // Date of the official name change.
    property dateElement : TFhirDateTime read FDate write SetDate;

  end;

  TFhirSubstanceDefinitionNameOfficialListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirSubstanceDefinitionNameOfficialList;
    function GetCurrent : TFhirSubstanceDefinitionNameOfficial;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirSubstanceDefinitionNameOfficialList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirSubstanceDefinitionNameOfficial read GetCurrent;
  end;

  TFhirSubstanceDefinitionNameOfficialList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirSubstanceDefinitionNameOfficial;
    procedure SetItemN(index : Integer; value : TFhirSubstanceDefinitionNameOfficial);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirSubstanceDefinitionNameOfficialList; overload;
    function Clone : TFhirSubstanceDefinitionNameOfficialList; overload;
    function GetEnumerator : TFhirSubstanceDefinitionNameOfficialListEnumerator;
    
    //  Add a FhirSubstanceDefinitionNameOfficial to the end of the list.
    function Append : TFhirSubstanceDefinitionNameOfficial;
    
    // Add an already existing FhirSubstanceDefinitionNameOfficial to the end of the list.
    function AddItem(value : TFhirSubstanceDefinitionNameOfficial) : TFhirSubstanceDefinitionNameOfficial; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirSubstanceDefinitionNameOfficial) : Integer;
    
    // Insert FhirSubstanceDefinitionNameOfficial before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirSubstanceDefinitionNameOfficial;
    
    // Insert an existing FhirSubstanceDefinitionNameOfficial before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirSubstanceDefinitionNameOfficial);
    
    // Get the iIndexth FhirSubstanceDefinitionNameOfficial. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirSubstanceDefinitionNameOfficial);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirSubstanceDefinitionNameOfficial;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirSubstanceDefinitionNameOfficials[index : Integer] : TFhirSubstanceDefinitionNameOfficial read GetItemN write SetItemN; default;
  End;

  // A link between this substance and another, with details of the relationship.
  TFhirSubstanceDefinitionRelationship = class (TFhirBackboneElement)
  protected
    FSubstanceDefinition : TFhirDataType;
    FType_ : TFhirCodeableConcept;
    FIsDefining : TFhirBoolean;
    FAmount : TFhirDataType;
    FRatioHighLimitAmount : TFhirRatio;
    FComparator : TFhirCodeableConcept;
    FsourceList : TFhirReferenceList;
    procedure SetSubstanceDefinition(value : TFhirDataType);
    procedure SetType_(value : TFhirCodeableConcept);
    procedure SetIsDefining(value : TFhirBoolean);
    function GetIsDefiningST : Boolean;
    procedure SetIsDefiningST(value : Boolean);
    procedure SetAmount(value : TFhirDataType);
    procedure SetRatioHighLimitAmount(value : TFhirRatio);
    procedure SetComparator(value : TFhirCodeableConcept);
    function GetSourceList : TFhirReferenceList;
    function GetHasSourceList : Boolean;
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirSubstanceDefinitionRelationship; overload;
    function Clone : TFhirSubstanceDefinitionRelationship; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to A pointer to another substance, as a resource or just a representational code. (defined for API consistency)
    property substanceDefinition : TFhirDataType read FSubstanceDefinition write SetSubstanceDefinition;
    // A pointer to another substance, as a resource or just a representational code.
    property substanceDefinitionElement : TFhirDataType read FSubstanceDefinition write SetSubstanceDefinition;

    // Typed access to For example "salt to parent", "active moiety", "starting material", "polymorph", "impurity of". (defined for API consistency)
    property type_ : TFhirCodeableConcept read FType_ write SetType_;
    // For example "salt to parent", "active moiety", "starting material", "polymorph", "impurity of".
    property type_Element : TFhirCodeableConcept read FType_ write SetType_;

    // Typed access to For example where an enzyme strongly bonds with a particular substance, this is a defining relationship for that enzyme, out of several possible substance relationships.
    property isDefining : Boolean read GetIsDefiningST write SetIsDefiningST;
    // For example where an enzyme strongly bonds with a particular substance, this is a defining relationship for that enzyme, out of several possible substance relationships.
    property isDefiningElement : TFhirBoolean read FIsDefining write SetIsDefining;

    // Typed access to A numeric factor for the relationship, for instance to express that the salt of a substance has some percentage of the active substance in relation to some other. (defined for API consistency)
    property amount : TFhirDataType read FAmount write SetAmount;
    // A numeric factor for the relationship, for instance to express that the salt of a substance has some percentage of the active substance in relation to some other.
    property amountElement : TFhirDataType read FAmount write SetAmount;

    // Typed access to For use when the numeric has an uncertain range. (defined for API consistency)
    property ratioHighLimitAmount : TFhirRatio read FRatioHighLimitAmount write SetRatioHighLimitAmount;
    // For use when the numeric has an uncertain range.
    property ratioHighLimitAmountElement : TFhirRatio read FRatioHighLimitAmount write SetRatioHighLimitAmount;

    // Typed access to An operator for the amount, for example "average", "approximately", "less than". (defined for API consistency)
    property comparator : TFhirCodeableConcept read FComparator write SetComparator;
    // An operator for the amount, for example "average", "approximately", "less than".
    property comparatorElement : TFhirCodeableConcept read FComparator write SetComparator;

    // Supporting literature.
    property sourceList : TFhirReferenceList read GetSourceList;
    property hasSourceList : boolean read GetHasSourceList;

  end;

  TFhirSubstanceDefinitionRelationshipListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirSubstanceDefinitionRelationshipList;
    function GetCurrent : TFhirSubstanceDefinitionRelationship;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirSubstanceDefinitionRelationshipList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirSubstanceDefinitionRelationship read GetCurrent;
  end;

  TFhirSubstanceDefinitionRelationshipList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirSubstanceDefinitionRelationship;
    procedure SetItemN(index : Integer; value : TFhirSubstanceDefinitionRelationship);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirSubstanceDefinitionRelationshipList; overload;
    function Clone : TFhirSubstanceDefinitionRelationshipList; overload;
    function GetEnumerator : TFhirSubstanceDefinitionRelationshipListEnumerator;
    
    //  Add a FhirSubstanceDefinitionRelationship to the end of the list.
    function Append : TFhirSubstanceDefinitionRelationship;
    
    // Add an already existing FhirSubstanceDefinitionRelationship to the end of the list.
    function AddItem(value : TFhirSubstanceDefinitionRelationship) : TFhirSubstanceDefinitionRelationship; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirSubstanceDefinitionRelationship) : Integer;
    
    // Insert FhirSubstanceDefinitionRelationship before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirSubstanceDefinitionRelationship;
    
    // Insert an existing FhirSubstanceDefinitionRelationship before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirSubstanceDefinitionRelationship);
    
    // Get the iIndexth FhirSubstanceDefinitionRelationship. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirSubstanceDefinitionRelationship);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirSubstanceDefinitionRelationship;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirSubstanceDefinitionRelationships[index : Integer] : TFhirSubstanceDefinitionRelationship read GetItemN write SetItemN; default;
  End;

  // Material or taxonomic/anatomical source for the substance.
  TFhirSubstanceDefinitionSourceMaterial = class (TFhirBackboneElement)
  protected
    FType_ : TFhirCodeableConcept;
    FGenus : TFhirCodeableConcept;
    FSpecies : TFhirCodeableConcept;
    FPart : TFhirCodeableConcept;
    FcountryOfOriginList : TFhirCodeableConceptList;
    procedure SetType_(value : TFhirCodeableConcept);
    procedure SetGenus(value : TFhirCodeableConcept);
    procedure SetSpecies(value : TFhirCodeableConcept);
    procedure SetPart(value : TFhirCodeableConcept);
    function GetCountryOfOriginList : TFhirCodeableConceptList;
    function GetHasCountryOfOriginList : Boolean;
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirSubstanceDefinitionSourceMaterial; overload;
    function Clone : TFhirSubstanceDefinitionSourceMaterial; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to A classification that provides the origin of the raw material. Example: cat hair would be an Animal source type. (defined for API consistency)
    property type_ : TFhirCodeableConcept read FType_ write SetType_;
    // A classification that provides the origin of the raw material. Example: cat hair would be an Animal source type.
    property type_Element : TFhirCodeableConcept read FType_ write SetType_;

    // Typed access to The genus of an organism, typically referring to the Latin epithet of the genus element of the plant/animal scientific name. (defined for API consistency)
    property genus : TFhirCodeableConcept read FGenus write SetGenus;
    // The genus of an organism, typically referring to the Latin epithet of the genus element of the plant/animal scientific name.
    property genusElement : TFhirCodeableConcept read FGenus write SetGenus;

    // Typed access to The species of an organism, typically referring to the Latin epithet of the species of the plant/animal. (defined for API consistency)
    property species : TFhirCodeableConcept read FSpecies write SetSpecies;
    // The species of an organism, typically referring to the Latin epithet of the species of the plant/animal.
    property speciesElement : TFhirCodeableConcept read FSpecies write SetSpecies;

    // Typed access to An anatomical origin of the source material within an organism. (defined for API consistency)
    property part : TFhirCodeableConcept read FPart write SetPart;
    // An anatomical origin of the source material within an organism.
    property partElement : TFhirCodeableConcept read FPart write SetPart;

    // The country or countries where the material is harvested.
    property countryOfOriginList : TFhirCodeableConceptList read GetCountryOfOriginList;
    property hasCountryOfOriginList : boolean read GetHasCountryOfOriginList;

  end;

  TFhirSubstanceDefinitionSourceMaterialListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirSubstanceDefinitionSourceMaterialList;
    function GetCurrent : TFhirSubstanceDefinitionSourceMaterial;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirSubstanceDefinitionSourceMaterialList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirSubstanceDefinitionSourceMaterial read GetCurrent;
  end;

  TFhirSubstanceDefinitionSourceMaterialList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirSubstanceDefinitionSourceMaterial;
    procedure SetItemN(index : Integer; value : TFhirSubstanceDefinitionSourceMaterial);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirSubstanceDefinitionSourceMaterialList; overload;
    function Clone : TFhirSubstanceDefinitionSourceMaterialList; overload;
    function GetEnumerator : TFhirSubstanceDefinitionSourceMaterialListEnumerator;
    
    //  Add a FhirSubstanceDefinitionSourceMaterial to the end of the list.
    function Append : TFhirSubstanceDefinitionSourceMaterial;
    
    // Add an already existing FhirSubstanceDefinitionSourceMaterial to the end of the list.
    function AddItem(value : TFhirSubstanceDefinitionSourceMaterial) : TFhirSubstanceDefinitionSourceMaterial; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirSubstanceDefinitionSourceMaterial) : Integer;
    
    // Insert FhirSubstanceDefinitionSourceMaterial before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirSubstanceDefinitionSourceMaterial;
    
    // Insert an existing FhirSubstanceDefinitionSourceMaterial before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirSubstanceDefinitionSourceMaterial);
    
    // Get the iIndexth FhirSubstanceDefinitionSourceMaterial. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirSubstanceDefinitionSourceMaterial);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirSubstanceDefinitionSourceMaterial;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirSubstanceDefinitionSourceMaterials[index : Integer] : TFhirSubstanceDefinitionSourceMaterial read GetItemN write SetItemN; default;
  End;

  // The detailed description of a substance, typically at a level beyond what is used for prescribing.
  TFhirSubstanceDefinition = class (TFhirDomainResource)
  protected
    FidentifierList : TFhirIdentifierList;
    FVersion : TFhirString;
    FStatus : TFhirCodeableConcept;
    FclassificationList : TFhirCodeableConceptList;
    FDomain : TFhirCodeableConcept;
    FgradeList : TFhirCodeableConceptList;
    FDescription : TFhirMarkdown;
    FinformationSourceList : TFhirReferenceList;
    FnoteList : TFhirAnnotationList;
    FmanufacturerList : TFhirReferenceList;
    FsupplierList : TFhirReferenceList;
    FmoietyList : TFhirSubstanceDefinitionMoietyList;
    Fproperty_List : TFhirSubstanceDefinitionPropertyList;
    FReferenceInformation : TFhirReference;
    FmolecularWeightList : TFhirSubstanceDefinitionMolecularWeightList;
    FStructure : TFhirSubstanceDefinitionStructure;
    FcodeList : TFhirSubstanceDefinitionCodeList;
    FnameList : TFhirSubstanceDefinitionNameList;
    FrelationshipList : TFhirSubstanceDefinitionRelationshipList;
    FNucleicAcid : TFhirReference;
    FPolymer : TFhirReference;
    FProtein : TFhirReference;
    FSourceMaterial : TFhirSubstanceDefinitionSourceMaterial;
    function GetIdentifierList : TFhirIdentifierList;
    function GetHasIdentifierList : Boolean;
    procedure SetVersion(value : TFhirString);
    function GetVersionST : String;
    procedure SetVersionST(value : String);
    procedure SetStatus(value : TFhirCodeableConcept);
    function GetClassificationList : TFhirCodeableConceptList;
    function GetHasClassificationList : Boolean;
    procedure SetDomain(value : TFhirCodeableConcept);
    function GetGradeList : TFhirCodeableConceptList;
    function GetHasGradeList : Boolean;
    procedure SetDescription(value : TFhirMarkdown);
    function GetDescriptionST : String;
    procedure SetDescriptionST(value : String);
    function GetInformationSourceList : TFhirReferenceList;
    function GetHasInformationSourceList : Boolean;
    function GetNoteList : TFhirAnnotationList;
    function GetHasNoteList : Boolean;
    function GetManufacturerList : TFhirReferenceList;
    function GetHasManufacturerList : Boolean;
    function GetSupplierList : TFhirReferenceList;
    function GetHasSupplierList : Boolean;
    function GetMoietyList : TFhirSubstanceDefinitionMoietyList;
    function GetHasMoietyList : Boolean;
    function GetProperty_List : TFhirSubstanceDefinitionPropertyList;
    function GetHasProperty_List : Boolean;
    procedure SetReferenceInformation(value : TFhirReference);
    function GetMolecularWeightList : TFhirSubstanceDefinitionMolecularWeightList;
    function GetHasMolecularWeightList : Boolean;
    procedure SetStructure(value : TFhirSubstanceDefinitionStructure);
    function GetCodeList : TFhirSubstanceDefinitionCodeList;
    function GetHasCodeList : Boolean;
    function GetNameList : TFhirSubstanceDefinitionNameList;
    function GetHasNameList : Boolean;
    function GetRelationshipList : TFhirSubstanceDefinitionRelationshipList;
    function GetHasRelationshipList : Boolean;
    procedure SetNucleicAcid(value : TFhirReference);
    procedure SetPolymer(value : TFhirReference);
    procedure SetProtein(value : TFhirReference);
    procedure SetSourceMaterial(value : TFhirSubstanceDefinitionSourceMaterial);
  
    function GetResourceType : TFhirResourceType; override;
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirSubstanceDefinition; overload;
    function Clone : TFhirSubstanceDefinition; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Identifier by which this substance is known.
    property identifierList : TFhirIdentifierList read GetIdentifierList;
    property hasIdentifierList : boolean read GetHasIdentifierList;

    // Typed access to A business level version identifier of the substance.
    property version : String read GetVersionST write SetVersionST;
    // A business level version identifier of the substance.
    property versionElement : TFhirString read FVersion write SetVersion;

    // Typed access to Status of substance within the catalogue e.g. active, retired. (defined for API consistency)
    property status : TFhirCodeableConcept read FStatus write SetStatus;
    // Status of substance within the catalogue e.g. active, retired.
    property statusElement : TFhirCodeableConcept read FStatus write SetStatus;

    // A high level categorization, e.g. polymer or nucleic acid, or food, chemical, biological, or a lower level such as the general types of polymer (linear or branch chain) or type of impurity (process related or contaminant).
    property classificationList : TFhirCodeableConceptList read GetClassificationList;
    property hasClassificationList : boolean read GetHasClassificationList;

    // Typed access to If the substance applies to human or veterinary use. (defined for API consistency)
    property domain : TFhirCodeableConcept read FDomain write SetDomain;
    // If the substance applies to human or veterinary use.
    property domainElement : TFhirCodeableConcept read FDomain write SetDomain;

    // The quality standard, established benchmark, to which substance complies (e.g. USP/NF, Ph. Eur, JP, BP, Company Standard).
    property gradeList : TFhirCodeableConceptList read GetGradeList;
    property hasGradeList : boolean read GetHasGradeList;

    // Typed access to Textual description of the substance.
    property description : String read GetDescriptionST write SetDescriptionST;
    // Textual description of the substance.
    property descriptionElement : TFhirMarkdown read FDescription write SetDescription;

    // Supporting literature.
    property informationSourceList : TFhirReferenceList read GetInformationSourceList;
    property hasInformationSourceList : boolean read GetHasInformationSourceList;

    // Textual comment about the substance's catalogue or registry record.
    property noteList : TFhirAnnotationList read GetNoteList;
    property hasNoteList : boolean read GetHasNoteList;

    // The entity that creates, makes, produces or fabricates the substance. This is a set of potential manufacturers but is not necessarily comprehensive.
    property manufacturerList : TFhirReferenceList read GetManufacturerList;
    property hasManufacturerList : boolean read GetHasManufacturerList;

    // An entity that is the source for the substance. It may be different from the manufacturer. Supplier is synonymous to a distributor.
    property supplierList : TFhirReferenceList read GetSupplierList;
    property hasSupplierList : boolean read GetHasSupplierList;

    // Moiety, for structural modifications.
    property moietyList : TFhirSubstanceDefinitionMoietyList read GetMoietyList;
    property hasMoietyList : boolean read GetHasMoietyList;

    // General specifications for this substance.
    property property_List : TFhirSubstanceDefinitionPropertyList read GetProperty_List;
    property hasProperty_List : boolean read GetHasProperty_List;

    // Typed access to General information detailing this substance. (defined for API consistency)
    property referenceInformation : TFhirReference read FReferenceInformation write SetReferenceInformation;
    // General information detailing this substance.
    property referenceInformationElement : TFhirReference read FReferenceInformation write SetReferenceInformation;

    // The molecular weight or weight range (for proteins, polymers or nucleic acids).
    property molecularWeightList : TFhirSubstanceDefinitionMolecularWeightList read GetMolecularWeightList;
    property hasMolecularWeightList : boolean read GetHasMolecularWeightList;

    // Typed access to Structural information. (defined for API consistency)
    property structure : TFhirSubstanceDefinitionStructure read FStructure write SetStructure;
    // Structural information.
    property structureElement : TFhirSubstanceDefinitionStructure read FStructure write SetStructure;

    // Codes associated with the substance.
    property codeList : TFhirSubstanceDefinitionCodeList read GetCodeList;
    property hasCodeList : boolean read GetHasCodeList;

    // Names applicable to this substance.
    property nameList : TFhirSubstanceDefinitionNameList read GetNameList;
    property hasNameList : boolean read GetHasNameList;

    // A link between this substance and another, with details of the relationship.
    property relationshipList : TFhirSubstanceDefinitionRelationshipList read GetRelationshipList;
    property hasRelationshipList : boolean read GetHasRelationshipList;

    // Typed access to Data items specific to nucleic acids. (defined for API consistency)
    property nucleicAcid : TFhirReference read FNucleicAcid write SetNucleicAcid;
    // Data items specific to nucleic acids.
    property nucleicAcidElement : TFhirReference read FNucleicAcid write SetNucleicAcid;

    // Typed access to Data items specific to polymers. (defined for API consistency)
    property polymer : TFhirReference read FPolymer write SetPolymer;
    // Data items specific to polymers.
    property polymerElement : TFhirReference read FPolymer write SetPolymer;

    // Typed access to Data items specific to proteins. (defined for API consistency)
    property protein : TFhirReference read FProtein write SetProtein;
    // Data items specific to proteins.
    property proteinElement : TFhirReference read FProtein write SetProtein;

    // Typed access to Material or taxonomic/anatomical source for the substance. (defined for API consistency)
    property sourceMaterial : TFhirSubstanceDefinitionSourceMaterial read FSourceMaterial write SetSourceMaterial;
    // Material or taxonomic/anatomical source for the substance.
    property sourceMaterialElement : TFhirSubstanceDefinitionSourceMaterial read FSourceMaterial write SetSourceMaterial;

  end;

  TFhirSubstanceDefinitionListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirSubstanceDefinitionList;
    function GetCurrent : TFhirSubstanceDefinition;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirSubstanceDefinitionList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirSubstanceDefinition read GetCurrent;
  end;

  TFhirSubstanceDefinitionList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirSubstanceDefinition;
    procedure SetItemN(index : Integer; value : TFhirSubstanceDefinition);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirSubstanceDefinitionList; overload;
    function Clone : TFhirSubstanceDefinitionList; overload;
    function GetEnumerator : TFhirSubstanceDefinitionListEnumerator;
    
    //  Add a FhirSubstanceDefinition to the end of the list.
    function Append : TFhirSubstanceDefinition;
    
    // Add an already existing FhirSubstanceDefinition to the end of the list.
    function AddItem(value : TFhirSubstanceDefinition) : TFhirSubstanceDefinition; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirSubstanceDefinition) : Integer;
    
    // Insert FhirSubstanceDefinition before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirSubstanceDefinition;
    
    // Insert an existing FhirSubstanceDefinition before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirSubstanceDefinition);
    
    // Get the iIndexth FhirSubstanceDefinition. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirSubstanceDefinition);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirSubstanceDefinition;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirSubstanceDefinitions[index : Integer] : TFhirSubstanceDefinition read GetItemN write SetItemN; default;
  End;

{$ENDIF FHIR_SUBSTANCEDEFINITION}
{$IFDEF FHIR_SUBSTANCENUCLEICACID}
  // Subunits are listed in order of decreasing length; sequences of the same length will be ordered by molecular weight; subunits that have identical sequences will be repeated multiple times.
  TFhirSubstanceNucleicAcidSubunit = class (TFhirBackboneElement)
  protected
    FSubunit : TFhirInteger;
    FSequence : TFhirString;
    FLength : TFhirInteger;
    FSequenceAttachment : TFhirAttachment;
    FFivePrime : TFhirCodeableConcept;
    FThreePrime : TFhirCodeableConcept;
    FlinkageList : TFhirSubstanceNucleicAcidSubunitLinkageList;
    FsugarList : TFhirSubstanceNucleicAcidSubunitSugarList;
    procedure SetSubunit(value : TFhirInteger);
    function GetSubunitST : String;
    procedure SetSubunitST(value : String);
    procedure SetSequence(value : TFhirString);
    function GetSequenceST : String;
    procedure SetSequenceST(value : String);
    procedure SetLength(value : TFhirInteger);
    function GetLengthST : String;
    procedure SetLengthST(value : String);
    procedure SetSequenceAttachment(value : TFhirAttachment);
    procedure SetFivePrime(value : TFhirCodeableConcept);
    procedure SetThreePrime(value : TFhirCodeableConcept);
    function GetLinkageList : TFhirSubstanceNucleicAcidSubunitLinkageList;
    function GetHasLinkageList : Boolean;
    function GetSugarList : TFhirSubstanceNucleicAcidSubunitSugarList;
    function GetHasSugarList : Boolean;
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirSubstanceNucleicAcidSubunit; overload;
    function Clone : TFhirSubstanceNucleicAcidSubunit; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to Index of linear sequences of nucleic acids in order of decreasing length. Sequences of the same length will be ordered by molecular weight. Subunits that have identical sequences will be repeated and have sequential subscripts.
    property subunit : String read GetSubunitST write SetSubunitST;
    // Index of linear sequences of nucleic acids in order of decreasing length. Sequences of the same length will be ordered by molecular weight. Subunits that have identical sequences will be repeated and have sequential subscripts.
    property subunitElement : TFhirInteger read FSubunit write SetSubunit;

    // Typed access to Actual nucleotide sequence notation from 5' to 3' end using standard single letter codes. In addition to the base sequence, sugar and type of phosphate or non-phosphate linkage should also be captured.
    property sequence : String read GetSequenceST write SetSequenceST;
    // Actual nucleotide sequence notation from 5' to 3' end using standard single letter codes. In addition to the base sequence, sugar and type of phosphate or non-phosphate linkage should also be captured.
    property sequenceElement : TFhirString read FSequence write SetSequence;

    // Typed access to The length of the sequence shall be captured.
    property length : String read GetLengthST write SetLengthST;
    // The length of the sequence shall be captured.
    property lengthElement : TFhirInteger read FLength write SetLength;

    // Typed access to (TBC). (defined for API consistency)
    property sequenceAttachment : TFhirAttachment read FSequenceAttachment write SetSequenceAttachment;
    // (TBC).
    property sequenceAttachmentElement : TFhirAttachment read FSequenceAttachment write SetSequenceAttachment;

    // Typed access to The nucleotide present at the 5’ terminal shall be specified based on a controlled vocabulary. Since the sequence is represented from the 5' to the 3' end, the 5’ prime nucleotide is the letter at the first position in the sequence. A separate representation would be redundant. (defined for API consistency)
    property fivePrime : TFhirCodeableConcept read FFivePrime write SetFivePrime;
    // The nucleotide present at the 5’ terminal shall be specified based on a controlled vocabulary. Since the sequence is represented from the 5' to the 3' end, the 5’ prime nucleotide is the letter at the first position in the sequence. A separate representation would be redundant.
    property fivePrimeElement : TFhirCodeableConcept read FFivePrime write SetFivePrime;

    // Typed access to The nucleotide present at the 3’ terminal shall be specified based on a controlled vocabulary. Since the sequence is represented from the 5' to the 3' end, the 5’ prime nucleotide is the letter at the last position in the sequence. A separate representation would be redundant. (defined for API consistency)
    property threePrime : TFhirCodeableConcept read FThreePrime write SetThreePrime;
    // The nucleotide present at the 3’ terminal shall be specified based on a controlled vocabulary. Since the sequence is represented from the 5' to the 3' end, the 5’ prime nucleotide is the letter at the last position in the sequence. A separate representation would be redundant.
    property threePrimeElement : TFhirCodeableConcept read FThreePrime write SetThreePrime;

    // The linkages between sugar residues will also be captured.
    property linkageList : TFhirSubstanceNucleicAcidSubunitLinkageList read GetLinkageList;
    property hasLinkageList : boolean read GetHasLinkageList;

    // 5.3.6.8.1 Sugar ID (Mandatory).
    property sugarList : TFhirSubstanceNucleicAcidSubunitSugarList read GetSugarList;
    property hasSugarList : boolean read GetHasSugarList;

  end;

  TFhirSubstanceNucleicAcidSubunitListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirSubstanceNucleicAcidSubunitList;
    function GetCurrent : TFhirSubstanceNucleicAcidSubunit;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirSubstanceNucleicAcidSubunitList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirSubstanceNucleicAcidSubunit read GetCurrent;
  end;

  TFhirSubstanceNucleicAcidSubunitList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirSubstanceNucleicAcidSubunit;
    procedure SetItemN(index : Integer; value : TFhirSubstanceNucleicAcidSubunit);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirSubstanceNucleicAcidSubunitList; overload;
    function Clone : TFhirSubstanceNucleicAcidSubunitList; overload;
    function GetEnumerator : TFhirSubstanceNucleicAcidSubunitListEnumerator;
    
    //  Add a FhirSubstanceNucleicAcidSubunit to the end of the list.
    function Append : TFhirSubstanceNucleicAcidSubunit;
    
    // Add an already existing FhirSubstanceNucleicAcidSubunit to the end of the list.
    function AddItem(value : TFhirSubstanceNucleicAcidSubunit) : TFhirSubstanceNucleicAcidSubunit; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirSubstanceNucleicAcidSubunit) : Integer;
    
    // Insert FhirSubstanceNucleicAcidSubunit before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirSubstanceNucleicAcidSubunit;
    
    // Insert an existing FhirSubstanceNucleicAcidSubunit before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirSubstanceNucleicAcidSubunit);
    
    // Get the iIndexth FhirSubstanceNucleicAcidSubunit. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirSubstanceNucleicAcidSubunit);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirSubstanceNucleicAcidSubunit;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirSubstanceNucleicAcidSubunits[index : Integer] : TFhirSubstanceNucleicAcidSubunit read GetItemN write SetItemN; default;
  End;

  // The linkages between sugar residues will also be captured.
  TFhirSubstanceNucleicAcidSubunitLinkage = class (TFhirBackboneElement)
  protected
    FConnectivity : TFhirString;
    FIdentifier : TFhirIdentifier;
    FName : TFhirString;
    FResidueSite : TFhirString;
    procedure SetConnectivity(value : TFhirString);
    function GetConnectivityST : String;
    procedure SetConnectivityST(value : String);
    procedure SetIdentifier(value : TFhirIdentifier);
    procedure SetName(value : TFhirString);
    function GetNameST : String;
    procedure SetNameST(value : String);
    procedure SetResidueSite(value : TFhirString);
    function GetResidueSiteST : String;
    procedure SetResidueSiteST(value : String);
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirSubstanceNucleicAcidSubunitLinkage; overload;
    function Clone : TFhirSubstanceNucleicAcidSubunitLinkage; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to The entity that links the sugar residues together should also be captured for nearly all naturally occurring nucleic acid the linkage is a phosphate group. For many synthetic oligonucleotides phosphorothioate linkages are often seen. Linkage connectivity is assumed to be 3’-5’. If the linkage is either 3’-3’ or 5’-5’ this should be specified.
    property connectivity : String read GetConnectivityST write SetConnectivityST;
    // The entity that links the sugar residues together should also be captured for nearly all naturally occurring nucleic acid the linkage is a phosphate group. For many synthetic oligonucleotides phosphorothioate linkages are often seen. Linkage connectivity is assumed to be 3’-5’. If the linkage is either 3’-3’ or 5’-5’ this should be specified.
    property connectivityElement : TFhirString read FConnectivity write SetConnectivity;

    // Typed access to Each linkage will be registered as a fragment and have an ID. (defined for API consistency)
    property identifier : TFhirIdentifier read FIdentifier write SetIdentifier;
    // Each linkage will be registered as a fragment and have an ID.
    property identifierElement : TFhirIdentifier read FIdentifier write SetIdentifier;

    // Typed access to Each linkage will be registered as a fragment and have at least one name. A single name shall be assigned to each linkage.
    property name : String read GetNameST write SetNameST;
    // Each linkage will be registered as a fragment and have at least one name. A single name shall be assigned to each linkage.
    property nameElement : TFhirString read FName write SetName;

    // Typed access to Residues shall be captured as described in 5.3.6.8.3.
    property residueSite : String read GetResidueSiteST write SetResidueSiteST;
    // Residues shall be captured as described in 5.3.6.8.3.
    property residueSiteElement : TFhirString read FResidueSite write SetResidueSite;

  end;

  TFhirSubstanceNucleicAcidSubunitLinkageListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirSubstanceNucleicAcidSubunitLinkageList;
    function GetCurrent : TFhirSubstanceNucleicAcidSubunitLinkage;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirSubstanceNucleicAcidSubunitLinkageList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirSubstanceNucleicAcidSubunitLinkage read GetCurrent;
  end;

  TFhirSubstanceNucleicAcidSubunitLinkageList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirSubstanceNucleicAcidSubunitLinkage;
    procedure SetItemN(index : Integer; value : TFhirSubstanceNucleicAcidSubunitLinkage);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirSubstanceNucleicAcidSubunitLinkageList; overload;
    function Clone : TFhirSubstanceNucleicAcidSubunitLinkageList; overload;
    function GetEnumerator : TFhirSubstanceNucleicAcidSubunitLinkageListEnumerator;
    
    //  Add a FhirSubstanceNucleicAcidSubunitLinkage to the end of the list.
    function Append : TFhirSubstanceNucleicAcidSubunitLinkage;
    
    // Add an already existing FhirSubstanceNucleicAcidSubunitLinkage to the end of the list.
    function AddItem(value : TFhirSubstanceNucleicAcidSubunitLinkage) : TFhirSubstanceNucleicAcidSubunitLinkage; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirSubstanceNucleicAcidSubunitLinkage) : Integer;
    
    // Insert FhirSubstanceNucleicAcidSubunitLinkage before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirSubstanceNucleicAcidSubunitLinkage;
    
    // Insert an existing FhirSubstanceNucleicAcidSubunitLinkage before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirSubstanceNucleicAcidSubunitLinkage);
    
    // Get the iIndexth FhirSubstanceNucleicAcidSubunitLinkage. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirSubstanceNucleicAcidSubunitLinkage);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirSubstanceNucleicAcidSubunitLinkage;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirSubstanceNucleicAcidSubunitLinkages[index : Integer] : TFhirSubstanceNucleicAcidSubunitLinkage read GetItemN write SetItemN; default;
  End;

  // 5.3.6.8.1 Sugar ID (Mandatory).
  TFhirSubstanceNucleicAcidSubunitSugar = class (TFhirBackboneElement)
  protected
    FIdentifier : TFhirIdentifier;
    FName : TFhirString;
    FResidueSite : TFhirString;
    procedure SetIdentifier(value : TFhirIdentifier);
    procedure SetName(value : TFhirString);
    function GetNameST : String;
    procedure SetNameST(value : String);
    procedure SetResidueSite(value : TFhirString);
    function GetResidueSiteST : String;
    procedure SetResidueSiteST(value : String);
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirSubstanceNucleicAcidSubunitSugar; overload;
    function Clone : TFhirSubstanceNucleicAcidSubunitSugar; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to The Substance ID of the sugar or sugar-like component that make up the nucleotide. (defined for API consistency)
    property identifier : TFhirIdentifier read FIdentifier write SetIdentifier;
    // The Substance ID of the sugar or sugar-like component that make up the nucleotide.
    property identifierElement : TFhirIdentifier read FIdentifier write SetIdentifier;

    // Typed access to The name of the sugar or sugar-like component that make up the nucleotide.
    property name : String read GetNameST write SetNameST;
    // The name of the sugar or sugar-like component that make up the nucleotide.
    property nameElement : TFhirString read FName write SetName;

    // Typed access to The residues that contain a given sugar will be captured. The order of given residues will be captured in the 5‘-3‘direction consistent with the base sequences listed above.
    property residueSite : String read GetResidueSiteST write SetResidueSiteST;
    // The residues that contain a given sugar will be captured. The order of given residues will be captured in the 5‘-3‘direction consistent with the base sequences listed above.
    property residueSiteElement : TFhirString read FResidueSite write SetResidueSite;

  end;

  TFhirSubstanceNucleicAcidSubunitSugarListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirSubstanceNucleicAcidSubunitSugarList;
    function GetCurrent : TFhirSubstanceNucleicAcidSubunitSugar;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirSubstanceNucleicAcidSubunitSugarList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirSubstanceNucleicAcidSubunitSugar read GetCurrent;
  end;

  TFhirSubstanceNucleicAcidSubunitSugarList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirSubstanceNucleicAcidSubunitSugar;
    procedure SetItemN(index : Integer; value : TFhirSubstanceNucleicAcidSubunitSugar);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirSubstanceNucleicAcidSubunitSugarList; overload;
    function Clone : TFhirSubstanceNucleicAcidSubunitSugarList; overload;
    function GetEnumerator : TFhirSubstanceNucleicAcidSubunitSugarListEnumerator;
    
    //  Add a FhirSubstanceNucleicAcidSubunitSugar to the end of the list.
    function Append : TFhirSubstanceNucleicAcidSubunitSugar;
    
    // Add an already existing FhirSubstanceNucleicAcidSubunitSugar to the end of the list.
    function AddItem(value : TFhirSubstanceNucleicAcidSubunitSugar) : TFhirSubstanceNucleicAcidSubunitSugar; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirSubstanceNucleicAcidSubunitSugar) : Integer;
    
    // Insert FhirSubstanceNucleicAcidSubunitSugar before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirSubstanceNucleicAcidSubunitSugar;
    
    // Insert an existing FhirSubstanceNucleicAcidSubunitSugar before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirSubstanceNucleicAcidSubunitSugar);
    
    // Get the iIndexth FhirSubstanceNucleicAcidSubunitSugar. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirSubstanceNucleicAcidSubunitSugar);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirSubstanceNucleicAcidSubunitSugar;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirSubstanceNucleicAcidSubunitSugars[index : Integer] : TFhirSubstanceNucleicAcidSubunitSugar read GetItemN write SetItemN; default;
  End;

  // Nucleic acids are defined by three distinct elements: the base, sugar and linkage. Individual substance/moiety IDs will be created for each of these elements. The nucleotide sequence will be always entered in the 5’-3’ direction.
  TFhirSubstanceNucleicAcid = class (TFhirDomainResource)
  protected
    FSequenceType : TFhirCodeableConcept;
    FNumberOfSubunits : TFhirInteger;
    FAreaOfHybridisation : TFhirString;
    FOligoNucleotideType : TFhirCodeableConcept;
    FsubunitList : TFhirSubstanceNucleicAcidSubunitList;
    procedure SetSequenceType(value : TFhirCodeableConcept);
    procedure SetNumberOfSubunits(value : TFhirInteger);
    function GetNumberOfSubunitsST : String;
    procedure SetNumberOfSubunitsST(value : String);
    procedure SetAreaOfHybridisation(value : TFhirString);
    function GetAreaOfHybridisationST : String;
    procedure SetAreaOfHybridisationST(value : String);
    procedure SetOligoNucleotideType(value : TFhirCodeableConcept);
    function GetSubunitList : TFhirSubstanceNucleicAcidSubunitList;
    function GetHasSubunitList : Boolean;
  
    function GetResourceType : TFhirResourceType; override;
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirSubstanceNucleicAcid; overload;
    function Clone : TFhirSubstanceNucleicAcid; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to The type of the sequence shall be specified based on a controlled vocabulary. (defined for API consistency)
    property sequenceType : TFhirCodeableConcept read FSequenceType write SetSequenceType;
    // The type of the sequence shall be specified based on a controlled vocabulary.
    property sequenceTypeElement : TFhirCodeableConcept read FSequenceType write SetSequenceType;

    // Typed access to The number of linear sequences of nucleotides linked through phosphodiester bonds shall be described. Subunits would be strands of nucleic acids that are tightly associated typically through Watson-Crick base pairing. NOTE: If not specified in the reference source, the assumption is that there is 1 subunit.
    property numberOfSubunits : String read GetNumberOfSubunitsST write SetNumberOfSubunitsST;
    // The number of linear sequences of nucleotides linked through phosphodiester bonds shall be described. Subunits would be strands of nucleic acids that are tightly associated typically through Watson-Crick base pairing. NOTE: If not specified in the reference source, the assumption is that there is 1 subunit.
    property numberOfSubunitsElement : TFhirInteger read FNumberOfSubunits write SetNumberOfSubunits;

    // Typed access to The area of hybridisation shall be described if applicable for double stranded RNA or DNA. The number associated with the subunit followed by the number associated to the residue shall be specified in increasing order. The underscore “” shall be used as separator as follows: “Subunitnumber Residue”.
    property areaOfHybridisation : String read GetAreaOfHybridisationST write SetAreaOfHybridisationST;
    // The area of hybridisation shall be described if applicable for double stranded RNA or DNA. The number associated with the subunit followed by the number associated to the residue shall be specified in increasing order. The underscore “” shall be used as separator as follows: “Subunitnumber Residue”.
    property areaOfHybridisationElement : TFhirString read FAreaOfHybridisation write SetAreaOfHybridisation;

    // Typed access to (TBC). (defined for API consistency)
    property oligoNucleotideType : TFhirCodeableConcept read FOligoNucleotideType write SetOligoNucleotideType;
    // (TBC).
    property oligoNucleotideTypeElement : TFhirCodeableConcept read FOligoNucleotideType write SetOligoNucleotideType;

    // Subunits are listed in order of decreasing length; sequences of the same length will be ordered by molecular weight; subunits that have identical sequences will be repeated multiple times.
    property subunitList : TFhirSubstanceNucleicAcidSubunitList read GetSubunitList;
    property hasSubunitList : boolean read GetHasSubunitList;

  end;

  TFhirSubstanceNucleicAcidListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirSubstanceNucleicAcidList;
    function GetCurrent : TFhirSubstanceNucleicAcid;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirSubstanceNucleicAcidList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirSubstanceNucleicAcid read GetCurrent;
  end;

  TFhirSubstanceNucleicAcidList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirSubstanceNucleicAcid;
    procedure SetItemN(index : Integer; value : TFhirSubstanceNucleicAcid);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirSubstanceNucleicAcidList; overload;
    function Clone : TFhirSubstanceNucleicAcidList; overload;
    function GetEnumerator : TFhirSubstanceNucleicAcidListEnumerator;
    
    //  Add a FhirSubstanceNucleicAcid to the end of the list.
    function Append : TFhirSubstanceNucleicAcid;
    
    // Add an already existing FhirSubstanceNucleicAcid to the end of the list.
    function AddItem(value : TFhirSubstanceNucleicAcid) : TFhirSubstanceNucleicAcid; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirSubstanceNucleicAcid) : Integer;
    
    // Insert FhirSubstanceNucleicAcid before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirSubstanceNucleicAcid;
    
    // Insert an existing FhirSubstanceNucleicAcid before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirSubstanceNucleicAcid);
    
    // Get the iIndexth FhirSubstanceNucleicAcid. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirSubstanceNucleicAcid);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirSubstanceNucleicAcid;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirSubstanceNucleicAcids[index : Integer] : TFhirSubstanceNucleicAcid read GetItemN write SetItemN; default;
  End;

{$ENDIF FHIR_SUBSTANCENUCLEICACID}
{$IFDEF FHIR_SUBSTANCEPOLYMER}
  // Todo.
  TFhirSubstancePolymerMonomerSet = class (TFhirBackboneElement)
  protected
    FRatioType : TFhirCodeableConcept;
    FstartingMaterialList : TFhirSubstancePolymerMonomerSetStartingMaterialList;
    procedure SetRatioType(value : TFhirCodeableConcept);
    function GetStartingMaterialList : TFhirSubstancePolymerMonomerSetStartingMaterialList;
    function GetHasStartingMaterialList : Boolean;
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirSubstancePolymerMonomerSet; overload;
    function Clone : TFhirSubstancePolymerMonomerSet; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to Captures the type of ratio to the entire polymer, e.g. Monomer/Polymer ratio, SRU/Polymer Ratio. (defined for API consistency)
    property ratioType : TFhirCodeableConcept read FRatioType write SetRatioType;
    // Captures the type of ratio to the entire polymer, e.g. Monomer/Polymer ratio, SRU/Polymer Ratio.
    property ratioTypeElement : TFhirCodeableConcept read FRatioType write SetRatioType;

    // The starting materials - monomer(s) used in the synthesis of the polymer.
    property startingMaterialList : TFhirSubstancePolymerMonomerSetStartingMaterialList read GetStartingMaterialList;
    property hasStartingMaterialList : boolean read GetHasStartingMaterialList;

  end;

  TFhirSubstancePolymerMonomerSetListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirSubstancePolymerMonomerSetList;
    function GetCurrent : TFhirSubstancePolymerMonomerSet;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirSubstancePolymerMonomerSetList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirSubstancePolymerMonomerSet read GetCurrent;
  end;

  TFhirSubstancePolymerMonomerSetList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirSubstancePolymerMonomerSet;
    procedure SetItemN(index : Integer; value : TFhirSubstancePolymerMonomerSet);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirSubstancePolymerMonomerSetList; overload;
    function Clone : TFhirSubstancePolymerMonomerSetList; overload;
    function GetEnumerator : TFhirSubstancePolymerMonomerSetListEnumerator;
    
    //  Add a FhirSubstancePolymerMonomerSet to the end of the list.
    function Append : TFhirSubstancePolymerMonomerSet;
    
    // Add an already existing FhirSubstancePolymerMonomerSet to the end of the list.
    function AddItem(value : TFhirSubstancePolymerMonomerSet) : TFhirSubstancePolymerMonomerSet; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirSubstancePolymerMonomerSet) : Integer;
    
    // Insert FhirSubstancePolymerMonomerSet before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirSubstancePolymerMonomerSet;
    
    // Insert an existing FhirSubstancePolymerMonomerSet before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirSubstancePolymerMonomerSet);
    
    // Get the iIndexth FhirSubstancePolymerMonomerSet. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirSubstancePolymerMonomerSet);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirSubstancePolymerMonomerSet;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirSubstancePolymerMonomerSets[index : Integer] : TFhirSubstancePolymerMonomerSet read GetItemN write SetItemN; default;
  End;

  // The starting materials - monomer(s) used in the synthesis of the polymer.
  TFhirSubstancePolymerMonomerSetStartingMaterial = class (TFhirBackboneElement)
  protected
    FCode : TFhirCodeableConcept;
    FCategory : TFhirCodeableConcept;
    FIsDefining : TFhirBoolean;
    FAmount : TFhirQuantity;
    procedure SetCode(value : TFhirCodeableConcept);
    procedure SetCategory(value : TFhirCodeableConcept);
    procedure SetIsDefining(value : TFhirBoolean);
    function GetIsDefiningST : Boolean;
    procedure SetIsDefiningST(value : Boolean);
    procedure SetAmount(value : TFhirQuantity);
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirSubstancePolymerMonomerSetStartingMaterial; overload;
    function Clone : TFhirSubstancePolymerMonomerSetStartingMaterial; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to The type of substance for this starting material. (defined for API consistency)
    property code : TFhirCodeableConcept read FCode write SetCode;
    // The type of substance for this starting material.
    property codeElement : TFhirCodeableConcept read FCode write SetCode;

    // Typed access to Substance high level category, e.g. chemical substance. (defined for API consistency)
    property category : TFhirCodeableConcept read FCategory write SetCategory;
    // Substance high level category, e.g. chemical substance.
    property categoryElement : TFhirCodeableConcept read FCategory write SetCategory;

    // Typed access to Used to specify whether the attribute described is a defining element for the unique identification of the polymer.
    property isDefining : Boolean read GetIsDefiningST write SetIsDefiningST;
    // Used to specify whether the attribute described is a defining element for the unique identification of the polymer.
    property isDefiningElement : TFhirBoolean read FIsDefining write SetIsDefining;

    // Typed access to A percentage. (defined for API consistency)
    property amount : TFhirQuantity read FAmount write SetAmount;
    // A percentage.
    property amountElement : TFhirQuantity read FAmount write SetAmount;

  end;

  TFhirSubstancePolymerMonomerSetStartingMaterialListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirSubstancePolymerMonomerSetStartingMaterialList;
    function GetCurrent : TFhirSubstancePolymerMonomerSetStartingMaterial;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirSubstancePolymerMonomerSetStartingMaterialList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirSubstancePolymerMonomerSetStartingMaterial read GetCurrent;
  end;

  TFhirSubstancePolymerMonomerSetStartingMaterialList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirSubstancePolymerMonomerSetStartingMaterial;
    procedure SetItemN(index : Integer; value : TFhirSubstancePolymerMonomerSetStartingMaterial);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirSubstancePolymerMonomerSetStartingMaterialList; overload;
    function Clone : TFhirSubstancePolymerMonomerSetStartingMaterialList; overload;
    function GetEnumerator : TFhirSubstancePolymerMonomerSetStartingMaterialListEnumerator;
    
    //  Add a FhirSubstancePolymerMonomerSetStartingMaterial to the end of the list.
    function Append : TFhirSubstancePolymerMonomerSetStartingMaterial;
    
    // Add an already existing FhirSubstancePolymerMonomerSetStartingMaterial to the end of the list.
    function AddItem(value : TFhirSubstancePolymerMonomerSetStartingMaterial) : TFhirSubstancePolymerMonomerSetStartingMaterial; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirSubstancePolymerMonomerSetStartingMaterial) : Integer;
    
    // Insert FhirSubstancePolymerMonomerSetStartingMaterial before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirSubstancePolymerMonomerSetStartingMaterial;
    
    // Insert an existing FhirSubstancePolymerMonomerSetStartingMaterial before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirSubstancePolymerMonomerSetStartingMaterial);
    
    // Get the iIndexth FhirSubstancePolymerMonomerSetStartingMaterial. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirSubstancePolymerMonomerSetStartingMaterial);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirSubstancePolymerMonomerSetStartingMaterial;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirSubstancePolymerMonomerSetStartingMaterials[index : Integer] : TFhirSubstancePolymerMonomerSetStartingMaterial read GetItemN write SetItemN; default;
  End;

  // Specifies and quantifies the repeated units and their configuration.
  TFhirSubstancePolymerRepeat = class (TFhirBackboneElement)
  protected
    FAverageMolecularFormula : TFhirString;
    FRepeatUnitAmountType : TFhirCodeableConcept;
    FrepeatUnitList : TFhirSubstancePolymerRepeatRepeatUnitList;
    procedure SetAverageMolecularFormula(value : TFhirString);
    function GetAverageMolecularFormulaST : String;
    procedure SetAverageMolecularFormulaST(value : String);
    procedure SetRepeatUnitAmountType(value : TFhirCodeableConcept);
    function GetRepeatUnitList : TFhirSubstancePolymerRepeatRepeatUnitList;
    function GetHasRepeatUnitList : Boolean;
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirSubstancePolymerRepeat; overload;
    function Clone : TFhirSubstancePolymerRepeat; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to A representation of an (average) molecular formula from a polymer.
    property averageMolecularFormula : String read GetAverageMolecularFormulaST write SetAverageMolecularFormulaST;
    // A representation of an (average) molecular formula from a polymer.
    property averageMolecularFormulaElement : TFhirString read FAverageMolecularFormula write SetAverageMolecularFormula;

    // Typed access to How the quantitative amount of Structural Repeat Units is captured (e.g. Exact, Numeric, Average). (defined for API consistency)
    property repeatUnitAmountType : TFhirCodeableConcept read FRepeatUnitAmountType write SetRepeatUnitAmountType;
    // How the quantitative amount of Structural Repeat Units is captured (e.g. Exact, Numeric, Average).
    property repeatUnitAmountTypeElement : TFhirCodeableConcept read FRepeatUnitAmountType write SetRepeatUnitAmountType;

    // An SRU - Structural Repeat Unit.
    property repeatUnitList : TFhirSubstancePolymerRepeatRepeatUnitList read GetRepeatUnitList;
    property hasRepeatUnitList : boolean read GetHasRepeatUnitList;

  end;

  TFhirSubstancePolymerRepeatListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirSubstancePolymerRepeatList;
    function GetCurrent : TFhirSubstancePolymerRepeat;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirSubstancePolymerRepeatList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirSubstancePolymerRepeat read GetCurrent;
  end;

  TFhirSubstancePolymerRepeatList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirSubstancePolymerRepeat;
    procedure SetItemN(index : Integer; value : TFhirSubstancePolymerRepeat);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirSubstancePolymerRepeatList; overload;
    function Clone : TFhirSubstancePolymerRepeatList; overload;
    function GetEnumerator : TFhirSubstancePolymerRepeatListEnumerator;
    
    //  Add a FhirSubstancePolymerRepeat to the end of the list.
    function Append : TFhirSubstancePolymerRepeat;
    
    // Add an already existing FhirSubstancePolymerRepeat to the end of the list.
    function AddItem(value : TFhirSubstancePolymerRepeat) : TFhirSubstancePolymerRepeat; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirSubstancePolymerRepeat) : Integer;
    
    // Insert FhirSubstancePolymerRepeat before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirSubstancePolymerRepeat;
    
    // Insert an existing FhirSubstancePolymerRepeat before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirSubstancePolymerRepeat);
    
    // Get the iIndexth FhirSubstancePolymerRepeat. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirSubstancePolymerRepeat);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirSubstancePolymerRepeat;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirSubstancePolymerRepeats[index : Integer] : TFhirSubstancePolymerRepeat read GetItemN write SetItemN; default;
  End;

  // An SRU - Structural Repeat Unit.
  TFhirSubstancePolymerRepeatRepeatUnit = class (TFhirBackboneElement)
  protected
    FUnit_ : TFhirString;
    FOrientation : TFhirCodeableConcept;
    FAmount : TFhirInteger;
    FdegreeOfPolymerisationList : TFhirSubstancePolymerRepeatRepeatUnitDegreeOfPolymerisationList;
    FstructuralRepresentationList : TFhirSubstancePolymerRepeatRepeatUnitStructuralRepresentationList;
    procedure SetUnit_(value : TFhirString);
    function GetUnit_ST : String;
    procedure SetUnit_ST(value : String);
    procedure SetOrientation(value : TFhirCodeableConcept);
    procedure SetAmount(value : TFhirInteger);
    function GetAmountST : String;
    procedure SetAmountST(value : String);
    function GetDegreeOfPolymerisationList : TFhirSubstancePolymerRepeatRepeatUnitDegreeOfPolymerisationList;
    function GetHasDegreeOfPolymerisationList : Boolean;
    function GetStructuralRepresentationList : TFhirSubstancePolymerRepeatRepeatUnitStructuralRepresentationList;
    function GetHasStructuralRepresentationList : Boolean;
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirSubstancePolymerRepeatRepeatUnit; overload;
    function Clone : TFhirSubstancePolymerRepeatRepeatUnit; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to Structural repeat units are essential elements for defining polymers.
    property unit_ : String read GetUnit_ST write SetUnit_ST;
    // Structural repeat units are essential elements for defining polymers.
    property unit_Element : TFhirString read FUnit_ write SetUnit_;

    // Typed access to The orientation of the polymerisation, e.g. head-tail, head-head, random. (defined for API consistency)
    property orientation : TFhirCodeableConcept read FOrientation write SetOrientation;
    // The orientation of the polymerisation, e.g. head-tail, head-head, random.
    property orientationElement : TFhirCodeableConcept read FOrientation write SetOrientation;

    // Typed access to Number of repeats of this unit.
    property amount : String read GetAmountST write SetAmountST;
    // Number of repeats of this unit.
    property amountElement : TFhirInteger read FAmount write SetAmount;

    // Applies to homopolymer and block co-polymers where the degree of polymerisation within a block can be described.
    property degreeOfPolymerisationList : TFhirSubstancePolymerRepeatRepeatUnitDegreeOfPolymerisationList read GetDegreeOfPolymerisationList;
    property hasDegreeOfPolymerisationList : boolean read GetHasDegreeOfPolymerisationList;

    // A graphical structure for this SRU.
    property structuralRepresentationList : TFhirSubstancePolymerRepeatRepeatUnitStructuralRepresentationList read GetStructuralRepresentationList;
    property hasStructuralRepresentationList : boolean read GetHasStructuralRepresentationList;

  end;

  TFhirSubstancePolymerRepeatRepeatUnitListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirSubstancePolymerRepeatRepeatUnitList;
    function GetCurrent : TFhirSubstancePolymerRepeatRepeatUnit;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirSubstancePolymerRepeatRepeatUnitList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirSubstancePolymerRepeatRepeatUnit read GetCurrent;
  end;

  TFhirSubstancePolymerRepeatRepeatUnitList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirSubstancePolymerRepeatRepeatUnit;
    procedure SetItemN(index : Integer; value : TFhirSubstancePolymerRepeatRepeatUnit);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirSubstancePolymerRepeatRepeatUnitList; overload;
    function Clone : TFhirSubstancePolymerRepeatRepeatUnitList; overload;
    function GetEnumerator : TFhirSubstancePolymerRepeatRepeatUnitListEnumerator;
    
    //  Add a FhirSubstancePolymerRepeatRepeatUnit to the end of the list.
    function Append : TFhirSubstancePolymerRepeatRepeatUnit;
    
    // Add an already existing FhirSubstancePolymerRepeatRepeatUnit to the end of the list.
    function AddItem(value : TFhirSubstancePolymerRepeatRepeatUnit) : TFhirSubstancePolymerRepeatRepeatUnit; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirSubstancePolymerRepeatRepeatUnit) : Integer;
    
    // Insert FhirSubstancePolymerRepeatRepeatUnit before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirSubstancePolymerRepeatRepeatUnit;
    
    // Insert an existing FhirSubstancePolymerRepeatRepeatUnit before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirSubstancePolymerRepeatRepeatUnit);
    
    // Get the iIndexth FhirSubstancePolymerRepeatRepeatUnit. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirSubstancePolymerRepeatRepeatUnit);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirSubstancePolymerRepeatRepeatUnit;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirSubstancePolymerRepeatRepeatUnits[index : Integer] : TFhirSubstancePolymerRepeatRepeatUnit read GetItemN write SetItemN; default;
  End;

  // Applies to homopolymer and block co-polymers where the degree of polymerisation within a block can be described.
  TFhirSubstancePolymerRepeatRepeatUnitDegreeOfPolymerisation = class (TFhirBackboneElement)
  protected
    FType_ : TFhirCodeableConcept;
    FAverage : TFhirInteger;
    FLow : TFhirInteger;
    FHigh : TFhirInteger;
    procedure SetType_(value : TFhirCodeableConcept);
    procedure SetAverage(value : TFhirInteger);
    function GetAverageST : String;
    procedure SetAverageST(value : String);
    procedure SetLow(value : TFhirInteger);
    function GetLowST : String;
    procedure SetLowST(value : String);
    procedure SetHigh(value : TFhirInteger);
    function GetHighST : String;
    procedure SetHighST(value : String);
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirSubstancePolymerRepeatRepeatUnitDegreeOfPolymerisation; overload;
    function Clone : TFhirSubstancePolymerRepeatRepeatUnitDegreeOfPolymerisation; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to The type of the degree of polymerisation shall be described, e.g. SRU/Polymer Ratio. (defined for API consistency)
    property type_ : TFhirCodeableConcept read FType_ write SetType_;
    // The type of the degree of polymerisation shall be described, e.g. SRU/Polymer Ratio.
    property type_Element : TFhirCodeableConcept read FType_ write SetType_;

    // Typed access to An average amount of polymerisation.
    property average : String read GetAverageST write SetAverageST;
    // An average amount of polymerisation.
    property averageElement : TFhirInteger read FAverage write SetAverage;

    // Typed access to A low expected limit of the amount.
    property low : String read GetLowST write SetLowST;
    // A low expected limit of the amount.
    property lowElement : TFhirInteger read FLow write SetLow;

    // Typed access to A high expected limit of the amount.
    property high : String read GetHighST write SetHighST;
    // A high expected limit of the amount.
    property highElement : TFhirInteger read FHigh write SetHigh;

  end;

  TFhirSubstancePolymerRepeatRepeatUnitDegreeOfPolymerisationListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirSubstancePolymerRepeatRepeatUnitDegreeOfPolymerisationList;
    function GetCurrent : TFhirSubstancePolymerRepeatRepeatUnitDegreeOfPolymerisation;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirSubstancePolymerRepeatRepeatUnitDegreeOfPolymerisationList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirSubstancePolymerRepeatRepeatUnitDegreeOfPolymerisation read GetCurrent;
  end;

  TFhirSubstancePolymerRepeatRepeatUnitDegreeOfPolymerisationList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirSubstancePolymerRepeatRepeatUnitDegreeOfPolymerisation;
    procedure SetItemN(index : Integer; value : TFhirSubstancePolymerRepeatRepeatUnitDegreeOfPolymerisation);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirSubstancePolymerRepeatRepeatUnitDegreeOfPolymerisationList; overload;
    function Clone : TFhirSubstancePolymerRepeatRepeatUnitDegreeOfPolymerisationList; overload;
    function GetEnumerator : TFhirSubstancePolymerRepeatRepeatUnitDegreeOfPolymerisationListEnumerator;
    
    //  Add a FhirSubstancePolymerRepeatRepeatUnitDegreeOfPolymerisation to the end of the list.
    function Append : TFhirSubstancePolymerRepeatRepeatUnitDegreeOfPolymerisation;
    
    // Add an already existing FhirSubstancePolymerRepeatRepeatUnitDegreeOfPolymerisation to the end of the list.
    function AddItem(value : TFhirSubstancePolymerRepeatRepeatUnitDegreeOfPolymerisation) : TFhirSubstancePolymerRepeatRepeatUnitDegreeOfPolymerisation; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirSubstancePolymerRepeatRepeatUnitDegreeOfPolymerisation) : Integer;
    
    // Insert FhirSubstancePolymerRepeatRepeatUnitDegreeOfPolymerisation before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirSubstancePolymerRepeatRepeatUnitDegreeOfPolymerisation;
    
    // Insert an existing FhirSubstancePolymerRepeatRepeatUnitDegreeOfPolymerisation before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirSubstancePolymerRepeatRepeatUnitDegreeOfPolymerisation);
    
    // Get the iIndexth FhirSubstancePolymerRepeatRepeatUnitDegreeOfPolymerisation. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirSubstancePolymerRepeatRepeatUnitDegreeOfPolymerisation);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirSubstancePolymerRepeatRepeatUnitDegreeOfPolymerisation;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirSubstancePolymerRepeatRepeatUnitDegreeOfPolymerisations[index : Integer] : TFhirSubstancePolymerRepeatRepeatUnitDegreeOfPolymerisation read GetItemN write SetItemN; default;
  End;

  // A graphical structure for this SRU.
  TFhirSubstancePolymerRepeatRepeatUnitStructuralRepresentation = class (TFhirBackboneElement)
  protected
    FType_ : TFhirCodeableConcept;
    FRepresentation : TFhirString;
    FFormat : TFhirCodeableConcept;
    FAttachment : TFhirAttachment;
    procedure SetType_(value : TFhirCodeableConcept);
    procedure SetRepresentation(value : TFhirString);
    function GetRepresentationST : String;
    procedure SetRepresentationST(value : String);
    procedure SetFormat(value : TFhirCodeableConcept);
    procedure SetAttachment(value : TFhirAttachment);
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirSubstancePolymerRepeatRepeatUnitStructuralRepresentation; overload;
    function Clone : TFhirSubstancePolymerRepeatRepeatUnitStructuralRepresentation; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to The type of structure (e.g. Full, Partial, Representative). (defined for API consistency)
    property type_ : TFhirCodeableConcept read FType_ write SetType_;
    // The type of structure (e.g. Full, Partial, Representative).
    property type_Element : TFhirCodeableConcept read FType_ write SetType_;

    // Typed access to The structural representation as text string in a standard format e.g. InChI, SMILES, MOLFILE, CDX, SDF, PDB, mmCIF.
    property representation : String read GetRepresentationST write SetRepresentationST;
    // The structural representation as text string in a standard format e.g. InChI, SMILES, MOLFILE, CDX, SDF, PDB, mmCIF.
    property representationElement : TFhirString read FRepresentation write SetRepresentation;

    // Typed access to The format of the representation e.g. InChI, SMILES, MOLFILE, CDX, SDF, PDB, mmCIF. (defined for API consistency)
    property format : TFhirCodeableConcept read FFormat write SetFormat;
    // The format of the representation e.g. InChI, SMILES, MOLFILE, CDX, SDF, PDB, mmCIF.
    property formatElement : TFhirCodeableConcept read FFormat write SetFormat;

    // Typed access to An attached file with the structural representation. (defined for API consistency)
    property attachment : TFhirAttachment read FAttachment write SetAttachment;
    // An attached file with the structural representation.
    property attachmentElement : TFhirAttachment read FAttachment write SetAttachment;

  end;

  TFhirSubstancePolymerRepeatRepeatUnitStructuralRepresentationListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirSubstancePolymerRepeatRepeatUnitStructuralRepresentationList;
    function GetCurrent : TFhirSubstancePolymerRepeatRepeatUnitStructuralRepresentation;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirSubstancePolymerRepeatRepeatUnitStructuralRepresentationList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirSubstancePolymerRepeatRepeatUnitStructuralRepresentation read GetCurrent;
  end;

  TFhirSubstancePolymerRepeatRepeatUnitStructuralRepresentationList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirSubstancePolymerRepeatRepeatUnitStructuralRepresentation;
    procedure SetItemN(index : Integer; value : TFhirSubstancePolymerRepeatRepeatUnitStructuralRepresentation);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirSubstancePolymerRepeatRepeatUnitStructuralRepresentationList; overload;
    function Clone : TFhirSubstancePolymerRepeatRepeatUnitStructuralRepresentationList; overload;
    function GetEnumerator : TFhirSubstancePolymerRepeatRepeatUnitStructuralRepresentationListEnumerator;
    
    //  Add a FhirSubstancePolymerRepeatRepeatUnitStructuralRepresentation to the end of the list.
    function Append : TFhirSubstancePolymerRepeatRepeatUnitStructuralRepresentation;
    
    // Add an already existing FhirSubstancePolymerRepeatRepeatUnitStructuralRepresentation to the end of the list.
    function AddItem(value : TFhirSubstancePolymerRepeatRepeatUnitStructuralRepresentation) : TFhirSubstancePolymerRepeatRepeatUnitStructuralRepresentation; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirSubstancePolymerRepeatRepeatUnitStructuralRepresentation) : Integer;
    
    // Insert FhirSubstancePolymerRepeatRepeatUnitStructuralRepresentation before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirSubstancePolymerRepeatRepeatUnitStructuralRepresentation;
    
    // Insert an existing FhirSubstancePolymerRepeatRepeatUnitStructuralRepresentation before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirSubstancePolymerRepeatRepeatUnitStructuralRepresentation);
    
    // Get the iIndexth FhirSubstancePolymerRepeatRepeatUnitStructuralRepresentation. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirSubstancePolymerRepeatRepeatUnitStructuralRepresentation);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirSubstancePolymerRepeatRepeatUnitStructuralRepresentation;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirSubstancePolymerRepeatRepeatUnitStructuralRepresentations[index : Integer] : TFhirSubstancePolymerRepeatRepeatUnitStructuralRepresentation read GetItemN write SetItemN; default;
  End;

  // Properties of a substance specific to it being a polymer.
  TFhirSubstancePolymer = class (TFhirDomainResource)
  protected
    FIdentifier : TFhirIdentifier;
    FClass_ : TFhirCodeableConcept;
    FGeometry : TFhirCodeableConcept;
    FcopolymerConnectivityList : TFhirCodeableConceptList;
    FModification : TFhirString;
    FmonomerSetList : TFhirSubstancePolymerMonomerSetList;
    Frepeat_List : TFhirSubstancePolymerRepeatList;
    procedure SetIdentifier(value : TFhirIdentifier);
    procedure SetClass_(value : TFhirCodeableConcept);
    procedure SetGeometry(value : TFhirCodeableConcept);
    function GetCopolymerConnectivityList : TFhirCodeableConceptList;
    function GetHasCopolymerConnectivityList : Boolean;
    procedure SetModification(value : TFhirString);
    function GetModificationST : String;
    procedure SetModificationST(value : String);
    function GetMonomerSetList : TFhirSubstancePolymerMonomerSetList;
    function GetHasMonomerSetList : Boolean;
    function GetRepeat_List : TFhirSubstancePolymerRepeatList;
    function GetHasRepeat_List : Boolean;
  
    function GetResourceType : TFhirResourceType; override;
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirSubstancePolymer; overload;
    function Clone : TFhirSubstancePolymer; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to A business idenfier for this polymer, but typically this is handled by a SubstanceDefinition identifier. (defined for API consistency)
    property identifier : TFhirIdentifier read FIdentifier write SetIdentifier;
    // A business idenfier for this polymer, but typically this is handled by a SubstanceDefinition identifier.
    property identifierElement : TFhirIdentifier read FIdentifier write SetIdentifier;

    // Typed access to Overall type of the polymer. (defined for API consistency)
    property class_ : TFhirCodeableConcept read FClass_ write SetClass_;
    // Overall type of the polymer.
    property class_Element : TFhirCodeableConcept read FClass_ write SetClass_;

    // Typed access to Polymer geometry, e.g. linear, branched, cross-linked, network or dendritic. (defined for API consistency)
    property geometry : TFhirCodeableConcept read FGeometry write SetGeometry;
    // Polymer geometry, e.g. linear, branched, cross-linked, network or dendritic.
    property geometryElement : TFhirCodeableConcept read FGeometry write SetGeometry;

    // Descrtibes the copolymer sequence type (polymer connectivity).
    property copolymerConnectivityList : TFhirCodeableConceptList read GetCopolymerConnectivityList;
    property hasCopolymerConnectivityList : boolean read GetHasCopolymerConnectivityList;

    // Typed access to Todo - this is intended to connect to a repeating full modification structure, also used by Protein and Nucleic Acid . String is just a placeholder.
    property modification : String read GetModificationST write SetModificationST;
    // Todo - this is intended to connect to a repeating full modification structure, also used by Protein and Nucleic Acid . String is just a placeholder.
    property modificationElement : TFhirString read FModification write SetModification;

    // Todo.
    property monomerSetList : TFhirSubstancePolymerMonomerSetList read GetMonomerSetList;
    property hasMonomerSetList : boolean read GetHasMonomerSetList;

    // Specifies and quantifies the repeated units and their configuration.
    property repeat_List : TFhirSubstancePolymerRepeatList read GetRepeat_List;
    property hasRepeat_List : boolean read GetHasRepeat_List;

  end;

  TFhirSubstancePolymerListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirSubstancePolymerList;
    function GetCurrent : TFhirSubstancePolymer;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirSubstancePolymerList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirSubstancePolymer read GetCurrent;
  end;

  TFhirSubstancePolymerList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirSubstancePolymer;
    procedure SetItemN(index : Integer; value : TFhirSubstancePolymer);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirSubstancePolymerList; overload;
    function Clone : TFhirSubstancePolymerList; overload;
    function GetEnumerator : TFhirSubstancePolymerListEnumerator;
    
    //  Add a FhirSubstancePolymer to the end of the list.
    function Append : TFhirSubstancePolymer;
    
    // Add an already existing FhirSubstancePolymer to the end of the list.
    function AddItem(value : TFhirSubstancePolymer) : TFhirSubstancePolymer; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirSubstancePolymer) : Integer;
    
    // Insert FhirSubstancePolymer before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirSubstancePolymer;
    
    // Insert an existing FhirSubstancePolymer before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirSubstancePolymer);
    
    // Get the iIndexth FhirSubstancePolymer. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirSubstancePolymer);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirSubstancePolymer;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirSubstancePolymers[index : Integer] : TFhirSubstancePolymer read GetItemN write SetItemN; default;
  End;

{$ENDIF FHIR_SUBSTANCEPOLYMER}
{$IFDEF FHIR_SUBSTANCEPROTEIN}
  // This subclause refers to the description of each subunit constituting the SubstanceProtein. A subunit is a linear sequence of amino acids linked through peptide bonds. The Subunit information shall be provided when the finished SubstanceProtein is a complex of multiple sequences; subunits are not used to delineate domains within a single sequence. Subunits are listed in order of decreasing length; sequences of the same length will be ordered by decreasing molecular weight; subunits that have identical sequences will be repeated multiple times.
  TFhirSubstanceProteinSubunit = class (TFhirBackboneElement)
  protected
    FSubunit : TFhirInteger;
    FSequence : TFhirString;
    FLength : TFhirInteger;
    FSequenceAttachment : TFhirAttachment;
    FNTerminalModificationId : TFhirIdentifier;
    FNTerminalModification : TFhirString;
    FCTerminalModificationId : TFhirIdentifier;
    FCTerminalModification : TFhirString;
    procedure SetSubunit(value : TFhirInteger);
    function GetSubunitST : String;
    procedure SetSubunitST(value : String);
    procedure SetSequence(value : TFhirString);
    function GetSequenceST : String;
    procedure SetSequenceST(value : String);
    procedure SetLength(value : TFhirInteger);
    function GetLengthST : String;
    procedure SetLengthST(value : String);
    procedure SetSequenceAttachment(value : TFhirAttachment);
    procedure SetNTerminalModificationId(value : TFhirIdentifier);
    procedure SetNTerminalModification(value : TFhirString);
    function GetNTerminalModificationST : String;
    procedure SetNTerminalModificationST(value : String);
    procedure SetCTerminalModificationId(value : TFhirIdentifier);
    procedure SetCTerminalModification(value : TFhirString);
    function GetCTerminalModificationST : String;
    procedure SetCTerminalModificationST(value : String);
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirSubstanceProteinSubunit; overload;
    function Clone : TFhirSubstanceProteinSubunit; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to Index of primary sequences of amino acids linked through peptide bonds in order of decreasing length. Sequences of the same length will be ordered by molecular weight. Subunits that have identical sequences will be repeated and have sequential subscripts.
    property subunit : String read GetSubunitST write SetSubunitST;
    // Index of primary sequences of amino acids linked through peptide bonds in order of decreasing length. Sequences of the same length will be ordered by molecular weight. Subunits that have identical sequences will be repeated and have sequential subscripts.
    property subunitElement : TFhirInteger read FSubunit write SetSubunit;

    // Typed access to The sequence information shall be provided enumerating the amino acids from N- to C-terminal end using standard single-letter amino acid codes. Uppercase shall be used for L-amino acids and lowercase for D-amino acids. Transcribed SubstanceProteins will always be described using the translated sequence; for synthetic peptide containing amino acids that are not represented with a single letter code an X should be used within the sequence. The modified amino acids will be distinguished by their position in the sequence.
    property sequence : String read GetSequenceST write SetSequenceST;
    // The sequence information shall be provided enumerating the amino acids from N- to C-terminal end using standard single-letter amino acid codes. Uppercase shall be used for L-amino acids and lowercase for D-amino acids. Transcribed SubstanceProteins will always be described using the translated sequence; for synthetic peptide containing amino acids that are not represented with a single letter code an X should be used within the sequence. The modified amino acids will be distinguished by their position in the sequence.
    property sequenceElement : TFhirString read FSequence write SetSequence;

    // Typed access to Length of linear sequences of amino acids contained in the subunit.
    property length : String read GetLengthST write SetLengthST;
    // Length of linear sequences of amino acids contained in the subunit.
    property lengthElement : TFhirInteger read FLength write SetLength;

    // Typed access to The sequence information shall be provided enumerating the amino acids from N- to C-terminal end using standard single-letter amino acid codes. Uppercase shall be used for L-amino acids and lowercase for D-amino acids. Transcribed SubstanceProteins will always be described using the translated sequence; for synthetic peptide containing amino acids that are not represented with a single letter code an X should be used within the sequence. The modified amino acids will be distinguished by their position in the sequence. (defined for API consistency)
    property sequenceAttachment : TFhirAttachment read FSequenceAttachment write SetSequenceAttachment;
    // The sequence information shall be provided enumerating the amino acids from N- to C-terminal end using standard single-letter amino acid codes. Uppercase shall be used for L-amino acids and lowercase for D-amino acids. Transcribed SubstanceProteins will always be described using the translated sequence; for synthetic peptide containing amino acids that are not represented with a single letter code an X should be used within the sequence. The modified amino acids will be distinguished by their position in the sequence.
    property sequenceAttachmentElement : TFhirAttachment read FSequenceAttachment write SetSequenceAttachment;

    // Typed access to Unique identifier for molecular fragment modification based on the ISO 11238 Substance ID. (defined for API consistency)
    property nTerminalModificationId : TFhirIdentifier read FNTerminalModificationId write SetNTerminalModificationId;
    // Unique identifier for molecular fragment modification based on the ISO 11238 Substance ID.
    property nTerminalModificationIdElement : TFhirIdentifier read FNTerminalModificationId write SetNTerminalModificationId;

    // Typed access to The name of the fragment modified at the N-terminal of the SubstanceProtein shall be specified.
    property nTerminalModification : String read GetNTerminalModificationST write SetNTerminalModificationST;
    // The name of the fragment modified at the N-terminal of the SubstanceProtein shall be specified.
    property nTerminalModificationElement : TFhirString read FNTerminalModification write SetNTerminalModification;

    // Typed access to Unique identifier for molecular fragment modification based on the ISO 11238 Substance ID. (defined for API consistency)
    property cTerminalModificationId : TFhirIdentifier read FCTerminalModificationId write SetCTerminalModificationId;
    // Unique identifier for molecular fragment modification based on the ISO 11238 Substance ID.
    property cTerminalModificationIdElement : TFhirIdentifier read FCTerminalModificationId write SetCTerminalModificationId;

    // Typed access to The modification at the C-terminal shall be specified.
    property cTerminalModification : String read GetCTerminalModificationST write SetCTerminalModificationST;
    // The modification at the C-terminal shall be specified.
    property cTerminalModificationElement : TFhirString read FCTerminalModification write SetCTerminalModification;

  end;

  TFhirSubstanceProteinSubunitListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirSubstanceProteinSubunitList;
    function GetCurrent : TFhirSubstanceProteinSubunit;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirSubstanceProteinSubunitList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirSubstanceProteinSubunit read GetCurrent;
  end;

  TFhirSubstanceProteinSubunitList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirSubstanceProteinSubunit;
    procedure SetItemN(index : Integer; value : TFhirSubstanceProteinSubunit);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirSubstanceProteinSubunitList; overload;
    function Clone : TFhirSubstanceProteinSubunitList; overload;
    function GetEnumerator : TFhirSubstanceProteinSubunitListEnumerator;
    
    //  Add a FhirSubstanceProteinSubunit to the end of the list.
    function Append : TFhirSubstanceProteinSubunit;
    
    // Add an already existing FhirSubstanceProteinSubunit to the end of the list.
    function AddItem(value : TFhirSubstanceProteinSubunit) : TFhirSubstanceProteinSubunit; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirSubstanceProteinSubunit) : Integer;
    
    // Insert FhirSubstanceProteinSubunit before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirSubstanceProteinSubunit;
    
    // Insert an existing FhirSubstanceProteinSubunit before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirSubstanceProteinSubunit);
    
    // Get the iIndexth FhirSubstanceProteinSubunit. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirSubstanceProteinSubunit);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirSubstanceProteinSubunit;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirSubstanceProteinSubunits[index : Integer] : TFhirSubstanceProteinSubunit read GetItemN write SetItemN; default;
  End;

  // A SubstanceProtein is defined as a single unit of a linear amino acid sequence, or a combination of subunits that are either covalently linked or have a defined invariant stoichiometric relationship. This includes all synthetic, recombinant and purified SubstanceProteins of defined sequence, whether the use is therapeutic or prophylactic. This set of elements will be used to describe albumins, coagulation factors, cytokines, growth factors, peptide/SubstanceProtein hormones, enzymes, toxins, toxoids, recombinant vaccines, and immunomodulators.
  TFhirSubstanceProtein = class (TFhirDomainResource)
  protected
    FSequenceType : TFhirCodeableConcept;
    FNumberOfSubunits : TFhirInteger;
    FdisulfideLinkageList : TFhirStringList;
    FsubunitList : TFhirSubstanceProteinSubunitList;
    procedure SetSequenceType(value : TFhirCodeableConcept);
    procedure SetNumberOfSubunits(value : TFhirInteger);
    function GetNumberOfSubunitsST : String;
    procedure SetNumberOfSubunitsST(value : String);
    function GetDisulfideLinkageList : TFhirStringList;
    function GetHasDisulfideLinkageList : Boolean;
    function GetSubunitList : TFhirSubstanceProteinSubunitList;
    function GetHasSubunitList : Boolean;
  
    function GetResourceType : TFhirResourceType; override;
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirSubstanceProtein; overload;
    function Clone : TFhirSubstanceProtein; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to The SubstanceProtein descriptive elements will only be used when a complete or partial amino acid sequence is available or derivable from a nucleic acid sequence. (defined for API consistency)
    property sequenceType : TFhirCodeableConcept read FSequenceType write SetSequenceType;
    // The SubstanceProtein descriptive elements will only be used when a complete or partial amino acid sequence is available or derivable from a nucleic acid sequence.
    property sequenceTypeElement : TFhirCodeableConcept read FSequenceType write SetSequenceType;

    // Typed access to Number of linear sequences of amino acids linked through peptide bonds. The number of subunits constituting the SubstanceProtein shall be described. It is possible that the number of subunits can be variable.
    property numberOfSubunits : String read GetNumberOfSubunitsST write SetNumberOfSubunitsST;
    // Number of linear sequences of amino acids linked through peptide bonds. The number of subunits constituting the SubstanceProtein shall be described. It is possible that the number of subunits can be variable.
    property numberOfSubunitsElement : TFhirInteger read FNumberOfSubunits write SetNumberOfSubunits;

    // The disulphide bond between two cysteine residues either on the same subunit or on two different subunits shall be described. The position of the disulfide bonds in the SubstanceProtein shall be listed in increasing order of subunit number and position within subunit followed by the abbreviation of the amino acids involved. The disulfide linkage positions shall actually contain the amino acid Cysteine at the respective positions.
    property disulfideLinkageList : TFhirStringList read GetDisulfideLinkageList;
    property hasDisulfideLinkageList : boolean read GetHasDisulfideLinkageList;

    // This subclause refers to the description of each subunit constituting the SubstanceProtein. A subunit is a linear sequence of amino acids linked through peptide bonds. The Subunit information shall be provided when the finished SubstanceProtein is a complex of multiple sequences; subunits are not used to delineate domains within a single sequence. Subunits are listed in order of decreasing length; sequences of the same length will be ordered by decreasing molecular weight; subunits that have identical sequences will be repeated multiple times.
    property subunitList : TFhirSubstanceProteinSubunitList read GetSubunitList;
    property hasSubunitList : boolean read GetHasSubunitList;

  end;

  TFhirSubstanceProteinListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirSubstanceProteinList;
    function GetCurrent : TFhirSubstanceProtein;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirSubstanceProteinList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirSubstanceProtein read GetCurrent;
  end;

  TFhirSubstanceProteinList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirSubstanceProtein;
    procedure SetItemN(index : Integer; value : TFhirSubstanceProtein);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirSubstanceProteinList; overload;
    function Clone : TFhirSubstanceProteinList; overload;
    function GetEnumerator : TFhirSubstanceProteinListEnumerator;
    
    //  Add a FhirSubstanceProtein to the end of the list.
    function Append : TFhirSubstanceProtein;
    
    // Add an already existing FhirSubstanceProtein to the end of the list.
    function AddItem(value : TFhirSubstanceProtein) : TFhirSubstanceProtein; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirSubstanceProtein) : Integer;
    
    // Insert FhirSubstanceProtein before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirSubstanceProtein;
    
    // Insert an existing FhirSubstanceProtein before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirSubstanceProtein);
    
    // Get the iIndexth FhirSubstanceProtein. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirSubstanceProtein);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirSubstanceProtein;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirSubstanceProteins[index : Integer] : TFhirSubstanceProtein read GetItemN write SetItemN; default;
  End;

{$ENDIF FHIR_SUBSTANCEPROTEIN}
{$IFDEF FHIR_SUBSTANCEREFERENCEINFORMATION}
  // Todo.
  TFhirSubstanceReferenceInformationGene = class (TFhirBackboneElement)
  protected
    FGeneSequenceOrigin : TFhirCodeableConcept;
    FGene : TFhirCodeableConcept;
    FsourceList : TFhirReferenceList;
    procedure SetGeneSequenceOrigin(value : TFhirCodeableConcept);
    procedure SetGene(value : TFhirCodeableConcept);
    function GetSourceList : TFhirReferenceList;
    function GetHasSourceList : Boolean;
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirSubstanceReferenceInformationGene; overload;
    function Clone : TFhirSubstanceReferenceInformationGene; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to Todo. (defined for API consistency)
    property geneSequenceOrigin : TFhirCodeableConcept read FGeneSequenceOrigin write SetGeneSequenceOrigin;
    // Todo.
    property geneSequenceOriginElement : TFhirCodeableConcept read FGeneSequenceOrigin write SetGeneSequenceOrigin;

    // Typed access to Todo. (defined for API consistency)
    property gene : TFhirCodeableConcept read FGene write SetGene;
    // Todo.
    property geneElement : TFhirCodeableConcept read FGene write SetGene;

    // Todo.
    property sourceList : TFhirReferenceList read GetSourceList;
    property hasSourceList : boolean read GetHasSourceList;

  end;

  TFhirSubstanceReferenceInformationGeneListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirSubstanceReferenceInformationGeneList;
    function GetCurrent : TFhirSubstanceReferenceInformationGene;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirSubstanceReferenceInformationGeneList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirSubstanceReferenceInformationGene read GetCurrent;
  end;

  TFhirSubstanceReferenceInformationGeneList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirSubstanceReferenceInformationGene;
    procedure SetItemN(index : Integer; value : TFhirSubstanceReferenceInformationGene);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirSubstanceReferenceInformationGeneList; overload;
    function Clone : TFhirSubstanceReferenceInformationGeneList; overload;
    function GetEnumerator : TFhirSubstanceReferenceInformationGeneListEnumerator;
    
    //  Add a FhirSubstanceReferenceInformationGene to the end of the list.
    function Append : TFhirSubstanceReferenceInformationGene;
    
    // Add an already existing FhirSubstanceReferenceInformationGene to the end of the list.
    function AddItem(value : TFhirSubstanceReferenceInformationGene) : TFhirSubstanceReferenceInformationGene; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirSubstanceReferenceInformationGene) : Integer;
    
    // Insert FhirSubstanceReferenceInformationGene before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirSubstanceReferenceInformationGene;
    
    // Insert an existing FhirSubstanceReferenceInformationGene before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirSubstanceReferenceInformationGene);
    
    // Get the iIndexth FhirSubstanceReferenceInformationGene. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirSubstanceReferenceInformationGene);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirSubstanceReferenceInformationGene;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirSubstanceReferenceInformationGenes[index : Integer] : TFhirSubstanceReferenceInformationGene read GetItemN write SetItemN; default;
  End;

  // Todo.
  TFhirSubstanceReferenceInformationGeneElement = class (TFhirBackboneElement)
  protected
    FType_ : TFhirCodeableConcept;
    FElement : TFhirIdentifier;
    FsourceList : TFhirReferenceList;
    procedure SetType_(value : TFhirCodeableConcept);
    procedure SetElement(value : TFhirIdentifier);
    function GetSourceList : TFhirReferenceList;
    function GetHasSourceList : Boolean;
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirSubstanceReferenceInformationGeneElement; overload;
    function Clone : TFhirSubstanceReferenceInformationGeneElement; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to Todo. (defined for API consistency)
    property type_ : TFhirCodeableConcept read FType_ write SetType_;
    // Todo.
    property type_Element : TFhirCodeableConcept read FType_ write SetType_;

    // Typed access to Todo. (defined for API consistency)
    property element : TFhirIdentifier read FElement write SetElement;
    // Todo.
    property elementElement : TFhirIdentifier read FElement write SetElement;

    // Todo.
    property sourceList : TFhirReferenceList read GetSourceList;
    property hasSourceList : boolean read GetHasSourceList;

  end;

  TFhirSubstanceReferenceInformationGeneElementListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirSubstanceReferenceInformationGeneElementList;
    function GetCurrent : TFhirSubstanceReferenceInformationGeneElement;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirSubstanceReferenceInformationGeneElementList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirSubstanceReferenceInformationGeneElement read GetCurrent;
  end;

  TFhirSubstanceReferenceInformationGeneElementList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirSubstanceReferenceInformationGeneElement;
    procedure SetItemN(index : Integer; value : TFhirSubstanceReferenceInformationGeneElement);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirSubstanceReferenceInformationGeneElementList; overload;
    function Clone : TFhirSubstanceReferenceInformationGeneElementList; overload;
    function GetEnumerator : TFhirSubstanceReferenceInformationGeneElementListEnumerator;
    
    //  Add a FhirSubstanceReferenceInformationGeneElement to the end of the list.
    function Append : TFhirSubstanceReferenceInformationGeneElement;
    
    // Add an already existing FhirSubstanceReferenceInformationGeneElement to the end of the list.
    function AddItem(value : TFhirSubstanceReferenceInformationGeneElement) : TFhirSubstanceReferenceInformationGeneElement; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirSubstanceReferenceInformationGeneElement) : Integer;
    
    // Insert FhirSubstanceReferenceInformationGeneElement before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirSubstanceReferenceInformationGeneElement;
    
    // Insert an existing FhirSubstanceReferenceInformationGeneElement before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirSubstanceReferenceInformationGeneElement);
    
    // Get the iIndexth FhirSubstanceReferenceInformationGeneElement. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirSubstanceReferenceInformationGeneElement);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirSubstanceReferenceInformationGeneElement;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirSubstanceReferenceInformationGeneElements[index : Integer] : TFhirSubstanceReferenceInformationGeneElement read GetItemN write SetItemN; default;
  End;

  // Todo.
  TFhirSubstanceReferenceInformationTarget = class (TFhirBackboneElement)
  protected
    FTarget : TFhirIdentifier;
    FType_ : TFhirCodeableConcept;
    FInteraction : TFhirCodeableConcept;
    FOrganism : TFhirCodeableConcept;
    FOrganismType : TFhirCodeableConcept;
    FAmount : TFhirDataType;
    FAmountType : TFhirCodeableConcept;
    FsourceList : TFhirReferenceList;
    procedure SetTarget(value : TFhirIdentifier);
    procedure SetType_(value : TFhirCodeableConcept);
    procedure SetInteraction(value : TFhirCodeableConcept);
    procedure SetOrganism(value : TFhirCodeableConcept);
    procedure SetOrganismType(value : TFhirCodeableConcept);
    procedure SetAmount(value : TFhirDataType);
    procedure SetAmountType(value : TFhirCodeableConcept);
    function GetSourceList : TFhirReferenceList;
    function GetHasSourceList : Boolean;
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirSubstanceReferenceInformationTarget; overload;
    function Clone : TFhirSubstanceReferenceInformationTarget; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to Todo. (defined for API consistency)
    property target : TFhirIdentifier read FTarget write SetTarget;
    // Todo.
    property targetElement : TFhirIdentifier read FTarget write SetTarget;

    // Typed access to Todo. (defined for API consistency)
    property type_ : TFhirCodeableConcept read FType_ write SetType_;
    // Todo.
    property type_Element : TFhirCodeableConcept read FType_ write SetType_;

    // Typed access to Todo. (defined for API consistency)
    property interaction : TFhirCodeableConcept read FInteraction write SetInteraction;
    // Todo.
    property interactionElement : TFhirCodeableConcept read FInteraction write SetInteraction;

    // Typed access to Todo. (defined for API consistency)
    property organism : TFhirCodeableConcept read FOrganism write SetOrganism;
    // Todo.
    property organismElement : TFhirCodeableConcept read FOrganism write SetOrganism;

    // Typed access to Todo. (defined for API consistency)
    property organismType : TFhirCodeableConcept read FOrganismType write SetOrganismType;
    // Todo.
    property organismTypeElement : TFhirCodeableConcept read FOrganismType write SetOrganismType;

    // Typed access to Todo. (defined for API consistency)
    property amount : TFhirDataType read FAmount write SetAmount;
    // Todo.
    property amountElement : TFhirDataType read FAmount write SetAmount;

    // Typed access to Todo. (defined for API consistency)
    property amountType : TFhirCodeableConcept read FAmountType write SetAmountType;
    // Todo.
    property amountTypeElement : TFhirCodeableConcept read FAmountType write SetAmountType;

    // Todo.
    property sourceList : TFhirReferenceList read GetSourceList;
    property hasSourceList : boolean read GetHasSourceList;

  end;

  TFhirSubstanceReferenceInformationTargetListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirSubstanceReferenceInformationTargetList;
    function GetCurrent : TFhirSubstanceReferenceInformationTarget;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirSubstanceReferenceInformationTargetList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirSubstanceReferenceInformationTarget read GetCurrent;
  end;

  TFhirSubstanceReferenceInformationTargetList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirSubstanceReferenceInformationTarget;
    procedure SetItemN(index : Integer; value : TFhirSubstanceReferenceInformationTarget);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirSubstanceReferenceInformationTargetList; overload;
    function Clone : TFhirSubstanceReferenceInformationTargetList; overload;
    function GetEnumerator : TFhirSubstanceReferenceInformationTargetListEnumerator;
    
    //  Add a FhirSubstanceReferenceInformationTarget to the end of the list.
    function Append : TFhirSubstanceReferenceInformationTarget;
    
    // Add an already existing FhirSubstanceReferenceInformationTarget to the end of the list.
    function AddItem(value : TFhirSubstanceReferenceInformationTarget) : TFhirSubstanceReferenceInformationTarget; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirSubstanceReferenceInformationTarget) : Integer;
    
    // Insert FhirSubstanceReferenceInformationTarget before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirSubstanceReferenceInformationTarget;
    
    // Insert an existing FhirSubstanceReferenceInformationTarget before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirSubstanceReferenceInformationTarget);
    
    // Get the iIndexth FhirSubstanceReferenceInformationTarget. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirSubstanceReferenceInformationTarget);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirSubstanceReferenceInformationTarget;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirSubstanceReferenceInformationTargets[index : Integer] : TFhirSubstanceReferenceInformationTarget read GetItemN write SetItemN; default;
  End;

  // Todo.
  TFhirSubstanceReferenceInformation = class (TFhirDomainResource)
  protected
    FComment : TFhirString;
    FgeneList : TFhirSubstanceReferenceInformationGeneList;
    FgeneElementList : TFhirSubstanceReferenceInformationGeneElementList;
    FtargetList : TFhirSubstanceReferenceInformationTargetList;
    procedure SetComment(value : TFhirString);
    function GetCommentST : String;
    procedure SetCommentST(value : String);
    function GetGeneList : TFhirSubstanceReferenceInformationGeneList;
    function GetHasGeneList : Boolean;
    function GetGeneElementList : TFhirSubstanceReferenceInformationGeneElementList;
    function GetHasGeneElementList : Boolean;
    function GetTargetList : TFhirSubstanceReferenceInformationTargetList;
    function GetHasTargetList : Boolean;
  
    function GetResourceType : TFhirResourceType; override;
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirSubstanceReferenceInformation; overload;
    function Clone : TFhirSubstanceReferenceInformation; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to Todo.
    property comment : String read GetCommentST write SetCommentST;
    // Todo.
    property commentElement : TFhirString read FComment write SetComment;

    // Todo.
    property geneList : TFhirSubstanceReferenceInformationGeneList read GetGeneList;
    property hasGeneList : boolean read GetHasGeneList;

    // Todo.
    property geneElementList : TFhirSubstanceReferenceInformationGeneElementList read GetGeneElementList;
    property hasGeneElementList : boolean read GetHasGeneElementList;

    // Todo.
    property targetList : TFhirSubstanceReferenceInformationTargetList read GetTargetList;
    property hasTargetList : boolean read GetHasTargetList;

  end;

  TFhirSubstanceReferenceInformationListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirSubstanceReferenceInformationList;
    function GetCurrent : TFhirSubstanceReferenceInformation;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirSubstanceReferenceInformationList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirSubstanceReferenceInformation read GetCurrent;
  end;

  TFhirSubstanceReferenceInformationList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirSubstanceReferenceInformation;
    procedure SetItemN(index : Integer; value : TFhirSubstanceReferenceInformation);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirSubstanceReferenceInformationList; overload;
    function Clone : TFhirSubstanceReferenceInformationList; overload;
    function GetEnumerator : TFhirSubstanceReferenceInformationListEnumerator;
    
    //  Add a FhirSubstanceReferenceInformation to the end of the list.
    function Append : TFhirSubstanceReferenceInformation;
    
    // Add an already existing FhirSubstanceReferenceInformation to the end of the list.
    function AddItem(value : TFhirSubstanceReferenceInformation) : TFhirSubstanceReferenceInformation; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirSubstanceReferenceInformation) : Integer;
    
    // Insert FhirSubstanceReferenceInformation before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirSubstanceReferenceInformation;
    
    // Insert an existing FhirSubstanceReferenceInformation before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirSubstanceReferenceInformation);
    
    // Get the iIndexth FhirSubstanceReferenceInformation. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirSubstanceReferenceInformation);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirSubstanceReferenceInformation;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirSubstanceReferenceInformations[index : Integer] : TFhirSubstanceReferenceInformation read GetItemN write SetItemN; default;
  End;

{$ENDIF FHIR_SUBSTANCEREFERENCEINFORMATION}
{$IFDEF FHIR_SUBSTANCESOURCEMATERIAL}
  // Many complex materials are fractions of parts of plants, animals, or minerals. Fraction elements are often necessary to define both Substances and Specified Group 1 Substances. For substances derived from Plants, fraction information will be captured at the Substance information level ( . Oils, Juices and Exudates). Additional information for Extracts, such as extraction solvent composition, will be captured at the Specified Substance Group 1 information level. For plasma-derived products fraction information will be captured at the Substance and the Specified Substance Group 1 levels.
  TFhirSubstanceSourceMaterialFractionDescription = class (TFhirBackboneElement)
  protected
    FFraction : TFhirString;
    FMaterialType : TFhirCodeableConcept;
    procedure SetFraction(value : TFhirString);
    function GetFractionST : String;
    procedure SetFractionST(value : String);
    procedure SetMaterialType(value : TFhirCodeableConcept);
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirSubstanceSourceMaterialFractionDescription; overload;
    function Clone : TFhirSubstanceSourceMaterialFractionDescription; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to This element is capturing information about the fraction of a plant part, or human plasma for fractionation.
    property fraction : String read GetFractionST write SetFractionST;
    // This element is capturing information about the fraction of a plant part, or human plasma for fractionation.
    property fractionElement : TFhirString read FFraction write SetFraction;

    // Typed access to The specific type of the material constituting the component. For Herbal preparations the particulars of the extracts (liquid/dry) is described in Specified Substance Group 1. (defined for API consistency)
    property materialType : TFhirCodeableConcept read FMaterialType write SetMaterialType;
    // The specific type of the material constituting the component. For Herbal preparations the particulars of the extracts (liquid/dry) is described in Specified Substance Group 1.
    property materialTypeElement : TFhirCodeableConcept read FMaterialType write SetMaterialType;

  end;

  TFhirSubstanceSourceMaterialFractionDescriptionListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirSubstanceSourceMaterialFractionDescriptionList;
    function GetCurrent : TFhirSubstanceSourceMaterialFractionDescription;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirSubstanceSourceMaterialFractionDescriptionList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirSubstanceSourceMaterialFractionDescription read GetCurrent;
  end;

  TFhirSubstanceSourceMaterialFractionDescriptionList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirSubstanceSourceMaterialFractionDescription;
    procedure SetItemN(index : Integer; value : TFhirSubstanceSourceMaterialFractionDescription);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirSubstanceSourceMaterialFractionDescriptionList; overload;
    function Clone : TFhirSubstanceSourceMaterialFractionDescriptionList; overload;
    function GetEnumerator : TFhirSubstanceSourceMaterialFractionDescriptionListEnumerator;
    
    //  Add a FhirSubstanceSourceMaterialFractionDescription to the end of the list.
    function Append : TFhirSubstanceSourceMaterialFractionDescription;
    
    // Add an already existing FhirSubstanceSourceMaterialFractionDescription to the end of the list.
    function AddItem(value : TFhirSubstanceSourceMaterialFractionDescription) : TFhirSubstanceSourceMaterialFractionDescription; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirSubstanceSourceMaterialFractionDescription) : Integer;
    
    // Insert FhirSubstanceSourceMaterialFractionDescription before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirSubstanceSourceMaterialFractionDescription;
    
    // Insert an existing FhirSubstanceSourceMaterialFractionDescription before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirSubstanceSourceMaterialFractionDescription);
    
    // Get the iIndexth FhirSubstanceSourceMaterialFractionDescription. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirSubstanceSourceMaterialFractionDescription);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirSubstanceSourceMaterialFractionDescription;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirSubstanceSourceMaterialFractionDescriptions[index : Integer] : TFhirSubstanceSourceMaterialFractionDescription read GetItemN write SetItemN; default;
  End;

  // This subclause describes the organism which the substance is derived from. For vaccines, the parent organism shall be specified based on these subclause elements. As an example, full taxonomy will be described for the Substance Name: ., Leaf.
  TFhirSubstanceSourceMaterialOrganism = class (TFhirBackboneElement)
  protected
    FFamily : TFhirCodeableConcept;
    FGenus : TFhirCodeableConcept;
    FSpecies : TFhirCodeableConcept;
    FIntraspecificType : TFhirCodeableConcept;
    FIntraspecificDescription : TFhirString;
    FauthorList : TFhirSubstanceSourceMaterialOrganismAuthorList;
    FHybrid : TFhirSubstanceSourceMaterialOrganismHybrid;
    FOrganismGeneral : TFhirSubstanceSourceMaterialOrganismOrganismGeneral;
    procedure SetFamily(value : TFhirCodeableConcept);
    procedure SetGenus(value : TFhirCodeableConcept);
    procedure SetSpecies(value : TFhirCodeableConcept);
    procedure SetIntraspecificType(value : TFhirCodeableConcept);
    procedure SetIntraspecificDescription(value : TFhirString);
    function GetIntraspecificDescriptionST : String;
    procedure SetIntraspecificDescriptionST(value : String);
    function GetAuthorList : TFhirSubstanceSourceMaterialOrganismAuthorList;
    function GetHasAuthorList : Boolean;
    procedure SetHybrid(value : TFhirSubstanceSourceMaterialOrganismHybrid);
    procedure SetOrganismGeneral(value : TFhirSubstanceSourceMaterialOrganismOrganismGeneral);
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirSubstanceSourceMaterialOrganism; overload;
    function Clone : TFhirSubstanceSourceMaterialOrganism; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to The family of an organism shall be specified. (defined for API consistency)
    property family : TFhirCodeableConcept read FFamily write SetFamily;
    // The family of an organism shall be specified.
    property familyElement : TFhirCodeableConcept read FFamily write SetFamily;

    // Typed access to The genus of an organism shall be specified; refers to the Latin epithet of the genus element of the plant/animal scientific name; it is present in names for genera, species and infraspecies. (defined for API consistency)
    property genus : TFhirCodeableConcept read FGenus write SetGenus;
    // The genus of an organism shall be specified; refers to the Latin epithet of the genus element of the plant/animal scientific name; it is present in names for genera, species and infraspecies.
    property genusElement : TFhirCodeableConcept read FGenus write SetGenus;

    // Typed access to The species of an organism shall be specified; refers to the Latin epithet of the species of the plant/animal; it is present in names for species and infraspecies. (defined for API consistency)
    property species : TFhirCodeableConcept read FSpecies write SetSpecies;
    // The species of an organism shall be specified; refers to the Latin epithet of the species of the plant/animal; it is present in names for species and infraspecies.
    property speciesElement : TFhirCodeableConcept read FSpecies write SetSpecies;

    // Typed access to The Intraspecific type of an organism shall be specified. (defined for API consistency)
    property intraspecificType : TFhirCodeableConcept read FIntraspecificType write SetIntraspecificType;
    // The Intraspecific type of an organism shall be specified.
    property intraspecificTypeElement : TFhirCodeableConcept read FIntraspecificType write SetIntraspecificType;

    // Typed access to The intraspecific description of an organism shall be specified based on a controlled vocabulary. For Influenza Vaccine, the intraspecific description shall contain the syntax of the antigen in line with the WHO convention.
    property intraspecificDescription : String read GetIntraspecificDescriptionST write SetIntraspecificDescriptionST;
    // The intraspecific description of an organism shall be specified based on a controlled vocabulary. For Influenza Vaccine, the intraspecific description shall contain the syntax of the antigen in line with the WHO convention.
    property intraspecificDescriptionElement : TFhirString read FIntraspecificDescription write SetIntraspecificDescription;

    // 4.9.13.6.1 Author type (Conditional).
    property authorList : TFhirSubstanceSourceMaterialOrganismAuthorList read GetAuthorList;
    property hasAuthorList : boolean read GetHasAuthorList;

    // Typed access to 4.9.13.8.1 Hybrid species maternal organism ID (Optional). (defined for API consistency)
    property hybrid : TFhirSubstanceSourceMaterialOrganismHybrid read FHybrid write SetHybrid;
    // 4.9.13.8.1 Hybrid species maternal organism ID (Optional).
    property hybridElement : TFhirSubstanceSourceMaterialOrganismHybrid read FHybrid write SetHybrid;

    // Typed access to 4.9.13.7.1 Kingdom (Conditional). (defined for API consistency)
    property organismGeneral : TFhirSubstanceSourceMaterialOrganismOrganismGeneral read FOrganismGeneral write SetOrganismGeneral;
    // 4.9.13.7.1 Kingdom (Conditional).
    property organismGeneralElement : TFhirSubstanceSourceMaterialOrganismOrganismGeneral read FOrganismGeneral write SetOrganismGeneral;

  end;

  TFhirSubstanceSourceMaterialOrganismListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirSubstanceSourceMaterialOrganismList;
    function GetCurrent : TFhirSubstanceSourceMaterialOrganism;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirSubstanceSourceMaterialOrganismList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirSubstanceSourceMaterialOrganism read GetCurrent;
  end;

  TFhirSubstanceSourceMaterialOrganismList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirSubstanceSourceMaterialOrganism;
    procedure SetItemN(index : Integer; value : TFhirSubstanceSourceMaterialOrganism);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirSubstanceSourceMaterialOrganismList; overload;
    function Clone : TFhirSubstanceSourceMaterialOrganismList; overload;
    function GetEnumerator : TFhirSubstanceSourceMaterialOrganismListEnumerator;
    
    //  Add a FhirSubstanceSourceMaterialOrganism to the end of the list.
    function Append : TFhirSubstanceSourceMaterialOrganism;
    
    // Add an already existing FhirSubstanceSourceMaterialOrganism to the end of the list.
    function AddItem(value : TFhirSubstanceSourceMaterialOrganism) : TFhirSubstanceSourceMaterialOrganism; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirSubstanceSourceMaterialOrganism) : Integer;
    
    // Insert FhirSubstanceSourceMaterialOrganism before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirSubstanceSourceMaterialOrganism;
    
    // Insert an existing FhirSubstanceSourceMaterialOrganism before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirSubstanceSourceMaterialOrganism);
    
    // Get the iIndexth FhirSubstanceSourceMaterialOrganism. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirSubstanceSourceMaterialOrganism);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirSubstanceSourceMaterialOrganism;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirSubstanceSourceMaterialOrganisms[index : Integer] : TFhirSubstanceSourceMaterialOrganism read GetItemN write SetItemN; default;
  End;

  // 4.9.13.6.1 Author type (Conditional).
  TFhirSubstanceSourceMaterialOrganismAuthor = class (TFhirBackboneElement)
  protected
    FAuthorType : TFhirCodeableConcept;
    FAuthorDescription : TFhirString;
    procedure SetAuthorType(value : TFhirCodeableConcept);
    procedure SetAuthorDescription(value : TFhirString);
    function GetAuthorDescriptionST : String;
    procedure SetAuthorDescriptionST(value : String);
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirSubstanceSourceMaterialOrganismAuthor; overload;
    function Clone : TFhirSubstanceSourceMaterialOrganismAuthor; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to The type of author of an organism species shall be specified. The parenthetical author of an organism species refers to the first author who published the plant/animal name (of any rank). The primary author of an organism species refers to the first author(s), who validly published the plant/animal name. (defined for API consistency)
    property authorType : TFhirCodeableConcept read FAuthorType write SetAuthorType;
    // The type of author of an organism species shall be specified. The parenthetical author of an organism species refers to the first author who published the plant/animal name (of any rank). The primary author of an organism species refers to the first author(s), who validly published the plant/animal name.
    property authorTypeElement : TFhirCodeableConcept read FAuthorType write SetAuthorType;

    // Typed access to The author of an organism species shall be specified. The author year of an organism shall also be specified when applicable; refers to the year in which the first author(s) published the infraspecific plant/animal name (of any rank).
    property authorDescription : String read GetAuthorDescriptionST write SetAuthorDescriptionST;
    // The author of an organism species shall be specified. The author year of an organism shall also be specified when applicable; refers to the year in which the first author(s) published the infraspecific plant/animal name (of any rank).
    property authorDescriptionElement : TFhirString read FAuthorDescription write SetAuthorDescription;

  end;

  TFhirSubstanceSourceMaterialOrganismAuthorListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirSubstanceSourceMaterialOrganismAuthorList;
    function GetCurrent : TFhirSubstanceSourceMaterialOrganismAuthor;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirSubstanceSourceMaterialOrganismAuthorList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirSubstanceSourceMaterialOrganismAuthor read GetCurrent;
  end;

  TFhirSubstanceSourceMaterialOrganismAuthorList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirSubstanceSourceMaterialOrganismAuthor;
    procedure SetItemN(index : Integer; value : TFhirSubstanceSourceMaterialOrganismAuthor);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirSubstanceSourceMaterialOrganismAuthorList; overload;
    function Clone : TFhirSubstanceSourceMaterialOrganismAuthorList; overload;
    function GetEnumerator : TFhirSubstanceSourceMaterialOrganismAuthorListEnumerator;
    
    //  Add a FhirSubstanceSourceMaterialOrganismAuthor to the end of the list.
    function Append : TFhirSubstanceSourceMaterialOrganismAuthor;
    
    // Add an already existing FhirSubstanceSourceMaterialOrganismAuthor to the end of the list.
    function AddItem(value : TFhirSubstanceSourceMaterialOrganismAuthor) : TFhirSubstanceSourceMaterialOrganismAuthor; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirSubstanceSourceMaterialOrganismAuthor) : Integer;
    
    // Insert FhirSubstanceSourceMaterialOrganismAuthor before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirSubstanceSourceMaterialOrganismAuthor;
    
    // Insert an existing FhirSubstanceSourceMaterialOrganismAuthor before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirSubstanceSourceMaterialOrganismAuthor);
    
    // Get the iIndexth FhirSubstanceSourceMaterialOrganismAuthor. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirSubstanceSourceMaterialOrganismAuthor);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirSubstanceSourceMaterialOrganismAuthor;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirSubstanceSourceMaterialOrganismAuthors[index : Integer] : TFhirSubstanceSourceMaterialOrganismAuthor read GetItemN write SetItemN; default;
  End;

  // 4.9.13.8.1 Hybrid species maternal organism ID (Optional).
  TFhirSubstanceSourceMaterialOrganismHybrid = class (TFhirBackboneElement)
  protected
    FMaternalOrganismId : TFhirString;
    FMaternalOrganismName : TFhirString;
    FPaternalOrganismId : TFhirString;
    FPaternalOrganismName : TFhirString;
    FHybridType : TFhirCodeableConcept;
    procedure SetMaternalOrganismId(value : TFhirString);
    function GetMaternalOrganismIdST : String;
    procedure SetMaternalOrganismIdST(value : String);
    procedure SetMaternalOrganismName(value : TFhirString);
    function GetMaternalOrganismNameST : String;
    procedure SetMaternalOrganismNameST(value : String);
    procedure SetPaternalOrganismId(value : TFhirString);
    function GetPaternalOrganismIdST : String;
    procedure SetPaternalOrganismIdST(value : String);
    procedure SetPaternalOrganismName(value : TFhirString);
    function GetPaternalOrganismNameST : String;
    procedure SetPaternalOrganismNameST(value : String);
    procedure SetHybridType(value : TFhirCodeableConcept);
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirSubstanceSourceMaterialOrganismHybrid; overload;
    function Clone : TFhirSubstanceSourceMaterialOrganismHybrid; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to The identifier of the maternal species constituting the hybrid organism shall be specified based on a controlled vocabulary. For plants, the parents aren’t always known, and it is unlikely that it will be known which is maternal and which is paternal.
    property maternalOrganismId : String read GetMaternalOrganismIdST write SetMaternalOrganismIdST;
    // The identifier of the maternal species constituting the hybrid organism shall be specified based on a controlled vocabulary. For plants, the parents aren’t always known, and it is unlikely that it will be known which is maternal and which is paternal.
    property maternalOrganismIdElement : TFhirString read FMaternalOrganismId write SetMaternalOrganismId;

    // Typed access to The name of the maternal species constituting the hybrid organism shall be specified. For plants, the parents aren’t always known, and it is unlikely that it will be known which is maternal and which is paternal.
    property maternalOrganismName : String read GetMaternalOrganismNameST write SetMaternalOrganismNameST;
    // The name of the maternal species constituting the hybrid organism shall be specified. For plants, the parents aren’t always known, and it is unlikely that it will be known which is maternal and which is paternal.
    property maternalOrganismNameElement : TFhirString read FMaternalOrganismName write SetMaternalOrganismName;

    // Typed access to The identifier of the paternal species constituting the hybrid organism shall be specified based on a controlled vocabulary.
    property paternalOrganismId : String read GetPaternalOrganismIdST write SetPaternalOrganismIdST;
    // The identifier of the paternal species constituting the hybrid organism shall be specified based on a controlled vocabulary.
    property paternalOrganismIdElement : TFhirString read FPaternalOrganismId write SetPaternalOrganismId;

    // Typed access to The name of the paternal species constituting the hybrid organism shall be specified.
    property paternalOrganismName : String read GetPaternalOrganismNameST write SetPaternalOrganismNameST;
    // The name of the paternal species constituting the hybrid organism shall be specified.
    property paternalOrganismNameElement : TFhirString read FPaternalOrganismName write SetPaternalOrganismName;

    // Typed access to The hybrid type of an organism shall be specified. (defined for API consistency)
    property hybridType : TFhirCodeableConcept read FHybridType write SetHybridType;
    // The hybrid type of an organism shall be specified.
    property hybridTypeElement : TFhirCodeableConcept read FHybridType write SetHybridType;

  end;

  TFhirSubstanceSourceMaterialOrganismHybridListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirSubstanceSourceMaterialOrganismHybridList;
    function GetCurrent : TFhirSubstanceSourceMaterialOrganismHybrid;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirSubstanceSourceMaterialOrganismHybridList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirSubstanceSourceMaterialOrganismHybrid read GetCurrent;
  end;

  TFhirSubstanceSourceMaterialOrganismHybridList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirSubstanceSourceMaterialOrganismHybrid;
    procedure SetItemN(index : Integer; value : TFhirSubstanceSourceMaterialOrganismHybrid);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirSubstanceSourceMaterialOrganismHybridList; overload;
    function Clone : TFhirSubstanceSourceMaterialOrganismHybridList; overload;
    function GetEnumerator : TFhirSubstanceSourceMaterialOrganismHybridListEnumerator;
    
    //  Add a FhirSubstanceSourceMaterialOrganismHybrid to the end of the list.
    function Append : TFhirSubstanceSourceMaterialOrganismHybrid;
    
    // Add an already existing FhirSubstanceSourceMaterialOrganismHybrid to the end of the list.
    function AddItem(value : TFhirSubstanceSourceMaterialOrganismHybrid) : TFhirSubstanceSourceMaterialOrganismHybrid; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirSubstanceSourceMaterialOrganismHybrid) : Integer;
    
    // Insert FhirSubstanceSourceMaterialOrganismHybrid before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirSubstanceSourceMaterialOrganismHybrid;
    
    // Insert an existing FhirSubstanceSourceMaterialOrganismHybrid before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirSubstanceSourceMaterialOrganismHybrid);
    
    // Get the iIndexth FhirSubstanceSourceMaterialOrganismHybrid. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirSubstanceSourceMaterialOrganismHybrid);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirSubstanceSourceMaterialOrganismHybrid;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirSubstanceSourceMaterialOrganismHybrids[index : Integer] : TFhirSubstanceSourceMaterialOrganismHybrid read GetItemN write SetItemN; default;
  End;

  // 4.9.13.7.1 Kingdom (Conditional).
  TFhirSubstanceSourceMaterialOrganismOrganismGeneral = class (TFhirBackboneElement)
  protected
    FKingdom : TFhirCodeableConcept;
    FPhylum : TFhirCodeableConcept;
    FClass_ : TFhirCodeableConcept;
    FOrder : TFhirCodeableConcept;
    procedure SetKingdom(value : TFhirCodeableConcept);
    procedure SetPhylum(value : TFhirCodeableConcept);
    procedure SetClass_(value : TFhirCodeableConcept);
    procedure SetOrder(value : TFhirCodeableConcept);
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirSubstanceSourceMaterialOrganismOrganismGeneral; overload;
    function Clone : TFhirSubstanceSourceMaterialOrganismOrganismGeneral; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to The kingdom of an organism shall be specified. (defined for API consistency)
    property kingdom : TFhirCodeableConcept read FKingdom write SetKingdom;
    // The kingdom of an organism shall be specified.
    property kingdomElement : TFhirCodeableConcept read FKingdom write SetKingdom;

    // Typed access to The phylum of an organism shall be specified. (defined for API consistency)
    property phylum : TFhirCodeableConcept read FPhylum write SetPhylum;
    // The phylum of an organism shall be specified.
    property phylumElement : TFhirCodeableConcept read FPhylum write SetPhylum;

    // Typed access to The class of an organism shall be specified. (defined for API consistency)
    property class_ : TFhirCodeableConcept read FClass_ write SetClass_;
    // The class of an organism shall be specified.
    property class_Element : TFhirCodeableConcept read FClass_ write SetClass_;

    // Typed access to The order of an organism shall be specified,. (defined for API consistency)
    property order : TFhirCodeableConcept read FOrder write SetOrder;
    // The order of an organism shall be specified,.
    property orderElement : TFhirCodeableConcept read FOrder write SetOrder;

  end;

  TFhirSubstanceSourceMaterialOrganismOrganismGeneralListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirSubstanceSourceMaterialOrganismOrganismGeneralList;
    function GetCurrent : TFhirSubstanceSourceMaterialOrganismOrganismGeneral;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirSubstanceSourceMaterialOrganismOrganismGeneralList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirSubstanceSourceMaterialOrganismOrganismGeneral read GetCurrent;
  end;

  TFhirSubstanceSourceMaterialOrganismOrganismGeneralList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirSubstanceSourceMaterialOrganismOrganismGeneral;
    procedure SetItemN(index : Integer; value : TFhirSubstanceSourceMaterialOrganismOrganismGeneral);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirSubstanceSourceMaterialOrganismOrganismGeneralList; overload;
    function Clone : TFhirSubstanceSourceMaterialOrganismOrganismGeneralList; overload;
    function GetEnumerator : TFhirSubstanceSourceMaterialOrganismOrganismGeneralListEnumerator;
    
    //  Add a FhirSubstanceSourceMaterialOrganismOrganismGeneral to the end of the list.
    function Append : TFhirSubstanceSourceMaterialOrganismOrganismGeneral;
    
    // Add an already existing FhirSubstanceSourceMaterialOrganismOrganismGeneral to the end of the list.
    function AddItem(value : TFhirSubstanceSourceMaterialOrganismOrganismGeneral) : TFhirSubstanceSourceMaterialOrganismOrganismGeneral; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirSubstanceSourceMaterialOrganismOrganismGeneral) : Integer;
    
    // Insert FhirSubstanceSourceMaterialOrganismOrganismGeneral before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirSubstanceSourceMaterialOrganismOrganismGeneral;
    
    // Insert an existing FhirSubstanceSourceMaterialOrganismOrganismGeneral before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirSubstanceSourceMaterialOrganismOrganismGeneral);
    
    // Get the iIndexth FhirSubstanceSourceMaterialOrganismOrganismGeneral. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirSubstanceSourceMaterialOrganismOrganismGeneral);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirSubstanceSourceMaterialOrganismOrganismGeneral;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirSubstanceSourceMaterialOrganismOrganismGenerals[index : Integer] : TFhirSubstanceSourceMaterialOrganismOrganismGeneral read GetItemN write SetItemN; default;
  End;

  // To do.
  TFhirSubstanceSourceMaterialPartDescription = class (TFhirBackboneElement)
  protected
    FPart : TFhirCodeableConcept;
    FPartLocation : TFhirCodeableConcept;
    procedure SetPart(value : TFhirCodeableConcept);
    procedure SetPartLocation(value : TFhirCodeableConcept);
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirSubstanceSourceMaterialPartDescription; overload;
    function Clone : TFhirSubstanceSourceMaterialPartDescription; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to Entity of anatomical origin of source material within an organism. (defined for API consistency)
    property part : TFhirCodeableConcept read FPart write SetPart;
    // Entity of anatomical origin of source material within an organism.
    property partElement : TFhirCodeableConcept read FPart write SetPart;

    // Typed access to The detailed anatomic location when the part can be extracted from different anatomical locations of the organism. Multiple alternative locations may apply. (defined for API consistency)
    property partLocation : TFhirCodeableConcept read FPartLocation write SetPartLocation;
    // The detailed anatomic location when the part can be extracted from different anatomical locations of the organism. Multiple alternative locations may apply.
    property partLocationElement : TFhirCodeableConcept read FPartLocation write SetPartLocation;

  end;

  TFhirSubstanceSourceMaterialPartDescriptionListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirSubstanceSourceMaterialPartDescriptionList;
    function GetCurrent : TFhirSubstanceSourceMaterialPartDescription;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirSubstanceSourceMaterialPartDescriptionList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirSubstanceSourceMaterialPartDescription read GetCurrent;
  end;

  TFhirSubstanceSourceMaterialPartDescriptionList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirSubstanceSourceMaterialPartDescription;
    procedure SetItemN(index : Integer; value : TFhirSubstanceSourceMaterialPartDescription);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirSubstanceSourceMaterialPartDescriptionList; overload;
    function Clone : TFhirSubstanceSourceMaterialPartDescriptionList; overload;
    function GetEnumerator : TFhirSubstanceSourceMaterialPartDescriptionListEnumerator;
    
    //  Add a FhirSubstanceSourceMaterialPartDescription to the end of the list.
    function Append : TFhirSubstanceSourceMaterialPartDescription;
    
    // Add an already existing FhirSubstanceSourceMaterialPartDescription to the end of the list.
    function AddItem(value : TFhirSubstanceSourceMaterialPartDescription) : TFhirSubstanceSourceMaterialPartDescription; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirSubstanceSourceMaterialPartDescription) : Integer;
    
    // Insert FhirSubstanceSourceMaterialPartDescription before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirSubstanceSourceMaterialPartDescription;
    
    // Insert an existing FhirSubstanceSourceMaterialPartDescription before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirSubstanceSourceMaterialPartDescription);
    
    // Get the iIndexth FhirSubstanceSourceMaterialPartDescription. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirSubstanceSourceMaterialPartDescription);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirSubstanceSourceMaterialPartDescription;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirSubstanceSourceMaterialPartDescriptions[index : Integer] : TFhirSubstanceSourceMaterialPartDescription read GetItemN write SetItemN; default;
  End;

  // Source material shall capture information on the taxonomic and anatomical origins as well as the fraction of a material that can result in or can be modified to form a substance. This set of data elements shall be used to define polymer substances isolated from biological matrices. Taxonomic and anatomical origins shall be described using a controlled vocabulary as required. This information is captured for naturally derived polymers ( . starch) and structurally diverse substances. For Organisms belonging to the Kingdom Plantae the Substance level defines the fresh material of a single species or infraspecies, the Herbal Drug and the Herbal preparation. For Herbal preparations, the fraction information will be captured at the Substance information level and additional information for herbal extracts will be captured at the Specified Substance Group 1 information level. See for further explanation the Substance Class: Structurally Diverse and the herbal annex.
  TFhirSubstanceSourceMaterial = class (TFhirDomainResource)
  protected
    FSourceMaterialClass : TFhirCodeableConcept;
    FSourceMaterialType : TFhirCodeableConcept;
    FSourceMaterialState : TFhirCodeableConcept;
    FOrganismId : TFhirIdentifier;
    FOrganismName : TFhirString;
    FparentSubstanceIdList : TFhirIdentifierList;
    FparentSubstanceNameList : TFhirStringList;
    FcountryOfOriginList : TFhirCodeableConceptList;
    FgeographicalLocationList : TFhirStringList;
    FDevelopmentStage : TFhirCodeableConcept;
    FfractionDescriptionList : TFhirSubstanceSourceMaterialFractionDescriptionList;
    FOrganism : TFhirSubstanceSourceMaterialOrganism;
    FpartDescriptionList : TFhirSubstanceSourceMaterialPartDescriptionList;
    procedure SetSourceMaterialClass(value : TFhirCodeableConcept);
    procedure SetSourceMaterialType(value : TFhirCodeableConcept);
    procedure SetSourceMaterialState(value : TFhirCodeableConcept);
    procedure SetOrganismId(value : TFhirIdentifier);
    procedure SetOrganismName(value : TFhirString);
    function GetOrganismNameST : String;
    procedure SetOrganismNameST(value : String);
    function GetParentSubstanceIdList : TFhirIdentifierList;
    function GetHasParentSubstanceIdList : Boolean;
    function GetParentSubstanceNameList : TFhirStringList;
    function GetHasParentSubstanceNameList : Boolean;
    function GetCountryOfOriginList : TFhirCodeableConceptList;
    function GetHasCountryOfOriginList : Boolean;
    function GetGeographicalLocationList : TFhirStringList;
    function GetHasGeographicalLocationList : Boolean;
    procedure SetDevelopmentStage(value : TFhirCodeableConcept);
    function GetFractionDescriptionList : TFhirSubstanceSourceMaterialFractionDescriptionList;
    function GetHasFractionDescriptionList : Boolean;
    procedure SetOrganism(value : TFhirSubstanceSourceMaterialOrganism);
    function GetPartDescriptionList : TFhirSubstanceSourceMaterialPartDescriptionList;
    function GetHasPartDescriptionList : Boolean;
  
    function GetResourceType : TFhirResourceType; override;
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirSubstanceSourceMaterial; overload;
    function Clone : TFhirSubstanceSourceMaterial; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to General high level classification of the source material specific to the origin of the material. (defined for API consistency)
    property sourceMaterialClass : TFhirCodeableConcept read FSourceMaterialClass write SetSourceMaterialClass;
    // General high level classification of the source material specific to the origin of the material.
    property sourceMaterialClassElement : TFhirCodeableConcept read FSourceMaterialClass write SetSourceMaterialClass;

    // Typed access to The type of the source material shall be specified based on a controlled vocabulary. For vaccines, this subclause refers to the class of infectious agent. (defined for API consistency)
    property sourceMaterialType : TFhirCodeableConcept read FSourceMaterialType write SetSourceMaterialType;
    // The type of the source material shall be specified based on a controlled vocabulary. For vaccines, this subclause refers to the class of infectious agent.
    property sourceMaterialTypeElement : TFhirCodeableConcept read FSourceMaterialType write SetSourceMaterialType;

    // Typed access to The state of the source material when extracted. (defined for API consistency)
    property sourceMaterialState : TFhirCodeableConcept read FSourceMaterialState write SetSourceMaterialState;
    // The state of the source material when extracted.
    property sourceMaterialStateElement : TFhirCodeableConcept read FSourceMaterialState write SetSourceMaterialState;

    // Typed access to The unique identifier associated with the source material parent organism shall be specified. (defined for API consistency)
    property organismId : TFhirIdentifier read FOrganismId write SetOrganismId;
    // The unique identifier associated with the source material parent organism shall be specified.
    property organismIdElement : TFhirIdentifier read FOrganismId write SetOrganismId;

    // Typed access to The organism accepted Scientific name shall be provided based on the organism taxonomy.
    property organismName : String read GetOrganismNameST write SetOrganismNameST;
    // The organism accepted Scientific name shall be provided based on the organism taxonomy.
    property organismNameElement : TFhirString read FOrganismName write SetOrganismName;

    // The parent of the herbal drug Ginkgo biloba, Leaf is the substance ID of the substance (fresh) of Ginkgo biloba L. or Ginkgo biloba L. (Whole plant).
    property parentSubstanceIdList : TFhirIdentifierList read GetParentSubstanceIdList;
    property hasParentSubstanceIdList : boolean read GetHasParentSubstanceIdList;

    // The parent substance of the Herbal Drug, or Herbal preparation.
    property parentSubstanceNameList : TFhirStringList read GetParentSubstanceNameList;
    property hasParentSubstanceNameList : boolean read GetHasParentSubstanceNameList;

    // The country where the plant material is harvested or the countries where the plasma is sourced from as laid down in accordance with the Plasma Master File. For “Plasma-derived substances” the attribute country of origin provides information about the countries used for the manufacturing of the Cryopoor plama or Crioprecipitate.
    property countryOfOriginList : TFhirCodeableConceptList read GetCountryOfOriginList;
    property hasCountryOfOriginList : boolean read GetHasCountryOfOriginList;

    // The place/region where the plant is harvested or the places/regions where the animal source material has its habitat.
    property geographicalLocationList : TFhirStringList read GetGeographicalLocationList;
    property hasGeographicalLocationList : boolean read GetHasGeographicalLocationList;

    // Typed access to Stage of life for animals, plants, insects and microorganisms. This information shall be provided only when the substance is significantly different in these stages (e.g. foetal bovine serum). (defined for API consistency)
    property developmentStage : TFhirCodeableConcept read FDevelopmentStage write SetDevelopmentStage;
    // Stage of life for animals, plants, insects and microorganisms. This information shall be provided only when the substance is significantly different in these stages (e.g. foetal bovine serum).
    property developmentStageElement : TFhirCodeableConcept read FDevelopmentStage write SetDevelopmentStage;

    // Many complex materials are fractions of parts of plants, animals, or minerals. Fraction elements are often necessary to define both Substances and Specified Group 1 Substances. For substances derived from Plants, fraction information will be captured at the Substance information level ( . Oils, Juices and Exudates). Additional information for Extracts, such as extraction solvent composition, will be captured at the Specified Substance Group 1 information level. For plasma-derived products fraction information will be captured at the Substance and the Specified Substance Group 1 levels.
    property fractionDescriptionList : TFhirSubstanceSourceMaterialFractionDescriptionList read GetFractionDescriptionList;
    property hasFractionDescriptionList : boolean read GetHasFractionDescriptionList;

    // Typed access to This subclause describes the organism which the substance is derived from. For vaccines, the parent organism shall be specified based on these subclause elements. As an example, full taxonomy will be described for the Substance Name: ., Leaf. (defined for API consistency)
    property organism : TFhirSubstanceSourceMaterialOrganism read FOrganism write SetOrganism;
    // This subclause describes the organism which the substance is derived from. For vaccines, the parent organism shall be specified based on these subclause elements. As an example, full taxonomy will be described for the Substance Name: ., Leaf.
    property organismElement : TFhirSubstanceSourceMaterialOrganism read FOrganism write SetOrganism;

    // To do.
    property partDescriptionList : TFhirSubstanceSourceMaterialPartDescriptionList read GetPartDescriptionList;
    property hasPartDescriptionList : boolean read GetHasPartDescriptionList;

  end;

  TFhirSubstanceSourceMaterialListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirSubstanceSourceMaterialList;
    function GetCurrent : TFhirSubstanceSourceMaterial;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirSubstanceSourceMaterialList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirSubstanceSourceMaterial read GetCurrent;
  end;

  TFhirSubstanceSourceMaterialList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirSubstanceSourceMaterial;
    procedure SetItemN(index : Integer; value : TFhirSubstanceSourceMaterial);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirSubstanceSourceMaterialList; overload;
    function Clone : TFhirSubstanceSourceMaterialList; overload;
    function GetEnumerator : TFhirSubstanceSourceMaterialListEnumerator;
    
    //  Add a FhirSubstanceSourceMaterial to the end of the list.
    function Append : TFhirSubstanceSourceMaterial;
    
    // Add an already existing FhirSubstanceSourceMaterial to the end of the list.
    function AddItem(value : TFhirSubstanceSourceMaterial) : TFhirSubstanceSourceMaterial; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirSubstanceSourceMaterial) : Integer;
    
    // Insert FhirSubstanceSourceMaterial before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirSubstanceSourceMaterial;
    
    // Insert an existing FhirSubstanceSourceMaterial before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirSubstanceSourceMaterial);
    
    // Get the iIndexth FhirSubstanceSourceMaterial. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirSubstanceSourceMaterial);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirSubstanceSourceMaterial;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirSubstanceSourceMaterials[index : Integer] : TFhirSubstanceSourceMaterial read GetItemN write SetItemN; default;
  End;

{$ENDIF FHIR_SUBSTANCESOURCEMATERIAL}



implementation

uses
  fhir5_utilities;



{$IFDEF FHIR_ADMINISTRABLEPRODUCTDEFINITION}
{ TFhirAdministrableProductDefinitionProperty }

constructor TFhirAdministrableProductDefinitionProperty.Create;
begin
  inherited;
end;

destructor TFhirAdministrableProductDefinitionProperty.Destroy;
begin
  FType_.free;
  FValue.free;
  FStatus.free;
  inherited;
end;

procedure TFhirAdministrableProductDefinitionProperty.Assign(oSource : TFslObject);
begin
  inherited;
  type_ := TFhirAdministrableProductDefinitionProperty(oSource).type_.Clone;
  value := TFhirAdministrableProductDefinitionProperty(oSource).value.Clone;
  status := TFhirAdministrableProductDefinitionProperty(oSource).status.Clone;
end;

procedure TFhirAdministrableProductDefinitionProperty.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'type') Then
     list.add(self.link, 'type', FType_.Link);
  if (child_name = 'value[x]') or (child_name = 'value') Then
     list.add(self.link, 'value[x]', FValue.Link);
  if (child_name = 'status') Then
     list.add(self.link, 'status', FStatus.Link);
end;

procedure TFhirAdministrableProductDefinitionProperty.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'type', 'CodeableConcept', false, TFhirCodeableConcept, FType_.Link));
  oList.add(TFHIRProperty.create(self, 'value[x]', 'CodeableConcept|Quantity|date|boolean|Attachment', false, TFhirDataType, FValue.Link));
  oList.add(TFHIRProperty.create(self, 'status', 'CodeableConcept', false, TFhirCodeableConcept, FStatus.Link));
end;

function TFhirAdministrableProductDefinitionProperty.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'type') then
  begin
    Type_ := propValue as TFhirCodeableConcept;
    result := propValue;
  end
  else if (isMatchingName(propName, 'value', ['CodeableConcept', 'Quantity', 'Date', 'Boolean', 'Attachment'])) then
  begin
    Value := propValue as TFhirDataType;
    result := propValue;
  end
  else if (propName = 'status') then
  begin
    Status := propValue as TFhirCodeableConcept;
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirAdministrableProductDefinitionProperty.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirAdministrableProductDefinitionProperty.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'type') then result := TFhirCodeableConcept.create()
  else if (isMatchingName(propName, 'value', ['CodeableConcept', 'Quantity', 'Date', 'Boolean', 'Attachment'])) then raise EFHIRException.create('Cannot make property Value')
  else if (propName = 'status') then result := TFhirCodeableConcept.create()
  else result := inherited createPropertyValue(propName);
end;

function TFhirAdministrableProductDefinitionProperty.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'type') then result := 'CodeableConcept'
  else if (propName = 'value[x]') then result := 'CodeableConcept|Quantity|date|boolean|Attachment'
  else if (propName = 'status') then result := 'CodeableConcept'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirAdministrableProductDefinitionProperty.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'type') then Type_Element := nil
  else if (isMatchingName(propName, 'value', ['CodeableConcept', 'Quantity', 'Date', 'Boolean', 'Attachment'])) then ValueElement := nil
  else if (propName = 'status') then StatusElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirAdministrableProductDefinitionProperty.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'type') then Type_Element := new as TFhirCodeableConcept
  else if (isMatchingName(propName, 'value', ['CodeableConcept', 'Quantity', 'Date', 'Boolean', 'Attachment'])) then ValueElement := new as TFhirDataType
  else if (propName = 'status') then StatusElement := new as TFhirCodeableConcept
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirAdministrableProductDefinitionProperty.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirAdministrableProductDefinitionProperty.fhirType : string;
begin
  result := 'AdministrableProductDefinition.property';
end;

function TFhirAdministrableProductDefinitionProperty.Link : TFhirAdministrableProductDefinitionProperty;
begin
  result := TFhirAdministrableProductDefinitionProperty(inherited Link);
end;

function TFhirAdministrableProductDefinitionProperty.Clone : TFhirAdministrableProductDefinitionProperty;
begin
  result := TFhirAdministrableProductDefinitionProperty(inherited Clone);
end;

function TFhirAdministrableProductDefinitionProperty.equals(other : TObject) : boolean; 
var
  o : TFhirAdministrableProductDefinitionProperty;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirAdministrableProductDefinitionProperty)) then
    result := false
  else
  begin
    o := TFhirAdministrableProductDefinitionProperty(other);
    result := compareDeep(type_Element, o.type_Element, true) and compareDeep(valueElement, o.valueElement, true) and 
      compareDeep(statusElement, o.statusElement, true);
  end;
end;

function TFhirAdministrableProductDefinitionProperty.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FType_) and isEmptyProp(FValue) and isEmptyProp(FStatus);
end;

procedure TFhirAdministrableProductDefinitionProperty.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('type');
  fields.add('value[x]');
  fields.add('status');
end;

function TFhirAdministrableProductDefinitionProperty.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
end;

procedure TFhirAdministrableProductDefinitionProperty.SetType_(value : TFhirCodeableConcept);
begin
  FType_.free;
  FType_ := value;
end;

procedure TFhirAdministrableProductDefinitionProperty.SetValue(value : TFhirDataType);
begin
  FValue.free;
  FValue := value;
end;

procedure TFhirAdministrableProductDefinitionProperty.SetStatus(value : TFhirCodeableConcept);
begin
  FStatus.free;
  FStatus := value;
end;

{ TFhirAdministrableProductDefinitionPropertyListEnumerator }

constructor TFhirAdministrableProductDefinitionPropertyListEnumerator.Create(list : TFhirAdministrableProductDefinitionPropertyList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirAdministrableProductDefinitionPropertyListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirAdministrableProductDefinitionPropertyListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirAdministrableProductDefinitionPropertyListEnumerator.GetCurrent : TFhirAdministrableProductDefinitionProperty;
begin
  Result := FList[FIndex];
end;

function TFhirAdministrableProductDefinitionPropertyListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirAdministrableProductDefinitionPropertyList }

function TFhirAdministrableProductDefinitionPropertyList.AddItem(value: TFhirAdministrableProductDefinitionProperty): TFhirAdministrableProductDefinitionProperty;
begin
  assert(value.ClassName = 'TFhirAdministrableProductDefinitionProperty', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirAdministrableProductDefinitionProperty');
  add(value);
  result := value;
end;

function TFhirAdministrableProductDefinitionPropertyList.Append: TFhirAdministrableProductDefinitionProperty;
begin
  result := TFhirAdministrableProductDefinitionProperty.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirAdministrableProductDefinitionPropertyList.ClearItems;
begin
  Clear;
end;

function TFhirAdministrableProductDefinitionPropertyList.GetEnumerator : TFhirAdministrableProductDefinitionPropertyListEnumerator;
begin
  result := TFhirAdministrableProductDefinitionPropertyListEnumerator.Create(self.link);
end;

function TFhirAdministrableProductDefinitionPropertyList.Clone: TFhirAdministrableProductDefinitionPropertyList;
begin
  result := TFhirAdministrableProductDefinitionPropertyList(inherited Clone);
end;

function TFhirAdministrableProductDefinitionPropertyList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirAdministrableProductDefinitionPropertyList.GetItemN(index: Integer): TFhirAdministrableProductDefinitionProperty;
begin
  result := TFhirAdministrableProductDefinitionProperty(ObjectByIndex[index]);
end;

function TFhirAdministrableProductDefinitionPropertyList.ItemClass: TFslObjectClass;
begin
  result := TFhirAdministrableProductDefinitionProperty;
end;
function TFhirAdministrableProductDefinitionPropertyList.IndexOf(value: TFhirAdministrableProductDefinitionProperty): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirAdministrableProductDefinitionPropertyList.Insert(index: Integer): TFhirAdministrableProductDefinitionProperty;
begin
  result := TFhirAdministrableProductDefinitionProperty.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirAdministrableProductDefinitionPropertyList.InsertItem(index: Integer; value: TFhirAdministrableProductDefinitionProperty);
begin
  assert(value is TFhirAdministrableProductDefinitionProperty);
  Inherited Insert(index, value);
end;

function TFhirAdministrableProductDefinitionPropertyList.Item(index: Integer): TFhirAdministrableProductDefinitionProperty;
begin
  result := TFhirAdministrableProductDefinitionProperty(ObjectByIndex[index]);
end;

function TFhirAdministrableProductDefinitionPropertyList.Link: TFhirAdministrableProductDefinitionPropertyList;
begin
  result := TFhirAdministrableProductDefinitionPropertyList(inherited Link);
end;

procedure TFhirAdministrableProductDefinitionPropertyList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirAdministrableProductDefinitionPropertyList.SetItemByIndex(index: Integer; value: TFhirAdministrableProductDefinitionProperty);
begin
  assert(value is TFhirAdministrableProductDefinitionProperty);
  FhirAdministrableProductDefinitionProperties[index] := value;
end;

procedure TFhirAdministrableProductDefinitionPropertyList.SetItemN(index: Integer; value: TFhirAdministrableProductDefinitionProperty);
begin
  assert(value is TFhirAdministrableProductDefinitionProperty);
  ObjectByIndex[index] := value;
end;

{ TFhirAdministrableProductDefinitionRouteOfAdministration }

constructor TFhirAdministrableProductDefinitionRouteOfAdministration.Create;
begin
  inherited;
end;

destructor TFhirAdministrableProductDefinitionRouteOfAdministration.Destroy;
begin
  FCode.free;
  FFirstDose.free;
  FMaxSingleDose.free;
  FMaxDosePerDay.free;
  FMaxDosePerTreatmentPeriod.free;
  FMaxTreatmentPeriod.free;
  FTargetSpeciesList.Free;
  inherited;
end;

procedure TFhirAdministrableProductDefinitionRouteOfAdministration.Assign(oSource : TFslObject);
begin
  inherited;
  code := TFhirAdministrableProductDefinitionRouteOfAdministration(oSource).code.Clone;
  firstDose := TFhirAdministrableProductDefinitionRouteOfAdministration(oSource).firstDose.Clone;
  maxSingleDose := TFhirAdministrableProductDefinitionRouteOfAdministration(oSource).maxSingleDose.Clone;
  maxDosePerDay := TFhirAdministrableProductDefinitionRouteOfAdministration(oSource).maxDosePerDay.Clone;
  maxDosePerTreatmentPeriod := TFhirAdministrableProductDefinitionRouteOfAdministration(oSource).maxDosePerTreatmentPeriod.Clone;
  maxTreatmentPeriod := TFhirAdministrableProductDefinitionRouteOfAdministration(oSource).maxTreatmentPeriod.Clone;
  if (TFhirAdministrableProductDefinitionRouteOfAdministration(oSource).FTargetSpeciesList = nil) then
  begin
    FTargetSpeciesList.free;
    FTargetSpeciesList := nil;
  end
  else
  begin
    if FTargetSpeciesList = nil then
      FTargetSpeciesList := TFhirAdministrableProductDefinitionRouteOfAdministrationTargetSpeciesList.Create;
    FTargetSpeciesList.Assign(TFhirAdministrableProductDefinitionRouteOfAdministration(oSource).FTargetSpeciesList);
  end;
end;

procedure TFhirAdministrableProductDefinitionRouteOfAdministration.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'code') Then
     list.add(self.link, 'code', FCode.Link);
  if (child_name = 'firstDose') Then
     list.add(self.link, 'firstDose', FFirstDose.Link);
  if (child_name = 'maxSingleDose') Then
     list.add(self.link, 'maxSingleDose', FMaxSingleDose.Link);
  if (child_name = 'maxDosePerDay') Then
     list.add(self.link, 'maxDosePerDay', FMaxDosePerDay.Link);
  if (child_name = 'maxDosePerTreatmentPeriod') Then
     list.add(self.link, 'maxDosePerTreatmentPeriod', FMaxDosePerTreatmentPeriod.Link);
  if (child_name = 'maxTreatmentPeriod') Then
     list.add(self.link, 'maxTreatmentPeriod', FMaxTreatmentPeriod.Link);
  if (child_name = 'targetSpecies') Then
    list.addAll(self, 'targetSpecies', FTargetSpeciesList);
end;

procedure TFhirAdministrableProductDefinitionRouteOfAdministration.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'code', 'CodeableConcept', false, TFhirCodeableConcept, FCode.Link));
  oList.add(TFHIRProperty.create(self, 'firstDose', 'Quantity', false, TFhirQuantity, FFirstDose.Link));
  oList.add(TFHIRProperty.create(self, 'maxSingleDose', 'Quantity', false, TFhirQuantity, FMaxSingleDose.Link));
  oList.add(TFHIRProperty.create(self, 'maxDosePerDay', 'Quantity', false, TFhirQuantity, FMaxDosePerDay.Link));
  oList.add(TFHIRProperty.create(self, 'maxDosePerTreatmentPeriod', 'Ratio', false, TFhirRatio, FMaxDosePerTreatmentPeriod.Link));
  oList.add(TFHIRProperty.create(self, 'maxTreatmentPeriod', 'Duration', false, TFhirDuration, FMaxTreatmentPeriod.Link));
  oList.add(TFHIRProperty.create(self, 'targetSpecies', 'BackboneElement', true, TFhirAdministrableProductDefinitionRouteOfAdministrationTargetSpecies, FTargetSpeciesList.Link));
end;

function TFhirAdministrableProductDefinitionRouteOfAdministration.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'code') then
  begin
    Code := propValue as TFhirCodeableConcept;
    result := propValue;
  end
  else if (propName = 'firstDose') then
  begin
    FirstDose := propValue as TFhirQuantity;
    result := propValue;
  end
  else if (propName = 'maxSingleDose') then
  begin
    MaxSingleDose := propValue as TFhirQuantity;
    result := propValue;
  end
  else if (propName = 'maxDosePerDay') then
  begin
    MaxDosePerDay := propValue as TFhirQuantity;
    result := propValue;
  end
  else if (propName = 'maxDosePerTreatmentPeriod') then
  begin
    MaxDosePerTreatmentPeriod := propValue as TFhirRatio;
    result := propValue;
  end
  else if (propName = 'maxTreatmentPeriod') then
  begin
    MaxTreatmentPeriod := propValue as TFhirDuration;
    result := propValue;
  end
  else if (propName = 'targetSpecies') then
  begin
    TargetSpeciesList.add(propValue as TFhirAdministrableProductDefinitionRouteOfAdministrationTargetSpecies);
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirAdministrableProductDefinitionRouteOfAdministration.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'targetSpecies') then TargetSpeciesList.insertItem(index, propValue as TFhirAdministrableProductDefinitionRouteOfAdministrationTargetSpecies)
  else inherited;
end;

function TFhirAdministrableProductDefinitionRouteOfAdministration.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'code') then result := TFhirCodeableConcept.create()
  else if (propName = 'firstDose') then result := TFhirQuantity.create()
  else if (propName = 'maxSingleDose') then result := TFhirQuantity.create()
  else if (propName = 'maxDosePerDay') then result := TFhirQuantity.create()
  else if (propName = 'maxDosePerTreatmentPeriod') then result := TFhirRatio.create()
  else if (propName = 'maxTreatmentPeriod') then result := TFhirDuration.create()
  else if (propName = 'targetSpecies') then result := TargetSpeciesList.new()
  else result := inherited createPropertyValue(propName);
end;

function TFhirAdministrableProductDefinitionRouteOfAdministration.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'code') then result := 'CodeableConcept'
  else if (propName = 'firstDose') then result := 'Quantity'
  else if (propName = 'maxSingleDose') then result := 'Quantity'
  else if (propName = 'maxDosePerDay') then result := 'Quantity'
  else if (propName = 'maxDosePerTreatmentPeriod') then result := 'Ratio'
  else if (propName = 'maxTreatmentPeriod') then result := 'Duration'
  else if (propName = 'targetSpecies') then result := 'BackboneElement'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirAdministrableProductDefinitionRouteOfAdministration.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'code') then CodeElement := nil
  else if (propName = 'firstDose') then FirstDoseElement := nil
  else if (propName = 'maxSingleDose') then MaxSingleDoseElement := nil
  else if (propName = 'maxDosePerDay') then MaxDosePerDayElement := nil
  else if (propName = 'maxDosePerTreatmentPeriod') then MaxDosePerTreatmentPeriodElement := nil
  else if (propName = 'maxTreatmentPeriod') then MaxTreatmentPeriodElement := nil
  else if (propName = 'targetSpecies') then deletePropertyValue('targetSpecies', TargetSpeciesList, value)
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirAdministrableProductDefinitionRouteOfAdministration.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'code') then CodeElement := new as TFhirCodeableConcept
  else if (propName = 'firstDose') then FirstDoseElement := new as TFhirQuantity
  else if (propName = 'maxSingleDose') then MaxSingleDoseElement := new as TFhirQuantity
  else if (propName = 'maxDosePerDay') then MaxDosePerDayElement := new as TFhirQuantity
  else if (propName = 'maxDosePerTreatmentPeriod') then MaxDosePerTreatmentPeriodElement := new as TFhirRatio
  else if (propName = 'maxTreatmentPeriod') then MaxTreatmentPeriodElement := new as TFhirDuration
  else if (propName = 'targetSpecies') then replacePropertyValue('targetSpecies', TargetSpeciesList, existing, new)
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirAdministrableProductDefinitionRouteOfAdministration.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'targetSpecies') then TargetSpeciesList.move(source, destination)
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirAdministrableProductDefinitionRouteOfAdministration.fhirType : string;
begin
  result := 'AdministrableProductDefinition.routeOfAdministration';
end;

function TFhirAdministrableProductDefinitionRouteOfAdministration.Link : TFhirAdministrableProductDefinitionRouteOfAdministration;
begin
  result := TFhirAdministrableProductDefinitionRouteOfAdministration(inherited Link);
end;

function TFhirAdministrableProductDefinitionRouteOfAdministration.Clone : TFhirAdministrableProductDefinitionRouteOfAdministration;
begin
  result := TFhirAdministrableProductDefinitionRouteOfAdministration(inherited Clone);
end;

function TFhirAdministrableProductDefinitionRouteOfAdministration.equals(other : TObject) : boolean; 
var
  o : TFhirAdministrableProductDefinitionRouteOfAdministration;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirAdministrableProductDefinitionRouteOfAdministration)) then
    result := false
  else
  begin
    o := TFhirAdministrableProductDefinitionRouteOfAdministration(other);
    result := compareDeep(codeElement, o.codeElement, true) and compareDeep(firstDoseElement, o.firstDoseElement, true) and 
      compareDeep(maxSingleDoseElement, o.maxSingleDoseElement, true) and compareDeep(maxDosePerDayElement, o.maxDosePerDayElement, true) and 
      compareDeep(maxDosePerTreatmentPeriodElement, o.maxDosePerTreatmentPeriodElement, true) and 
      compareDeep(maxTreatmentPeriodElement, o.maxTreatmentPeriodElement, true) and 
      compareDeep(targetSpeciesList, o.targetSpeciesList, true);
  end;
end;

function TFhirAdministrableProductDefinitionRouteOfAdministration.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FCode) and isEmptyProp(FFirstDose) and isEmptyProp(FMaxSingleDose) and isEmptyProp(FMaxDosePerDay) and isEmptyProp(FMaxDosePerTreatmentPeriod) and isEmptyProp(FMaxTreatmentPeriod) and isEmptyProp(FtargetSpeciesList);
end;

procedure TFhirAdministrableProductDefinitionRouteOfAdministration.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('code');
  fields.add('firstDose');
  fields.add('maxSingleDose');
  fields.add('maxDosePerDay');
  fields.add('maxDosePerTreatmentPeriod');
  fields.add('maxTreatmentPeriod');
  fields.add('targetSpecies');
end;

function TFhirAdministrableProductDefinitionRouteOfAdministration.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
  inc(result, FTargetSpeciesList.sizeInBytes(magic));
end;

procedure TFhirAdministrableProductDefinitionRouteOfAdministration.SetCode(value : TFhirCodeableConcept);
begin
  FCode.free;
  FCode := value;
end;

procedure TFhirAdministrableProductDefinitionRouteOfAdministration.SetFirstDose(value : TFhirQuantity);
begin
  FFirstDose.free;
  FFirstDose := value;
end;

procedure TFhirAdministrableProductDefinitionRouteOfAdministration.SetMaxSingleDose(value : TFhirQuantity);
begin
  FMaxSingleDose.free;
  FMaxSingleDose := value;
end;

procedure TFhirAdministrableProductDefinitionRouteOfAdministration.SetMaxDosePerDay(value : TFhirQuantity);
begin
  FMaxDosePerDay.free;
  FMaxDosePerDay := value;
end;

procedure TFhirAdministrableProductDefinitionRouteOfAdministration.SetMaxDosePerTreatmentPeriod(value : TFhirRatio);
begin
  FMaxDosePerTreatmentPeriod.free;
  FMaxDosePerTreatmentPeriod := value;
end;

procedure TFhirAdministrableProductDefinitionRouteOfAdministration.SetMaxTreatmentPeriod(value : TFhirDuration);
begin
  FMaxTreatmentPeriod.free;
  FMaxTreatmentPeriod := value;
end;

function TFhirAdministrableProductDefinitionRouteOfAdministration.GetTargetSpeciesList : TFhirAdministrableProductDefinitionRouteOfAdministrationTargetSpeciesList;
begin
  if FTargetSpeciesList = nil then
    FTargetSpeciesList := TFhirAdministrableProductDefinitionRouteOfAdministrationTargetSpeciesList.Create;
  result := FTargetSpeciesList;
end;

function TFhirAdministrableProductDefinitionRouteOfAdministration.GetHasTargetSpeciesList : boolean;
begin
  result := (FTargetSpeciesList <> nil) and (FTargetSpeciesList.count > 0);
end;

{ TFhirAdministrableProductDefinitionRouteOfAdministrationListEnumerator }

constructor TFhirAdministrableProductDefinitionRouteOfAdministrationListEnumerator.Create(list : TFhirAdministrableProductDefinitionRouteOfAdministrationList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirAdministrableProductDefinitionRouteOfAdministrationListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirAdministrableProductDefinitionRouteOfAdministrationListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirAdministrableProductDefinitionRouteOfAdministrationListEnumerator.GetCurrent : TFhirAdministrableProductDefinitionRouteOfAdministration;
begin
  Result := FList[FIndex];
end;

function TFhirAdministrableProductDefinitionRouteOfAdministrationListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirAdministrableProductDefinitionRouteOfAdministrationList }

function TFhirAdministrableProductDefinitionRouteOfAdministrationList.AddItem(value: TFhirAdministrableProductDefinitionRouteOfAdministration): TFhirAdministrableProductDefinitionRouteOfAdministration;
begin
  assert(value.ClassName = 'TFhirAdministrableProductDefinitionRouteOfAdministration', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirAdministrableProductDefinitionRouteOfAdministration');
  add(value);
  result := value;
end;

function TFhirAdministrableProductDefinitionRouteOfAdministrationList.Append: TFhirAdministrableProductDefinitionRouteOfAdministration;
begin
  result := TFhirAdministrableProductDefinitionRouteOfAdministration.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirAdministrableProductDefinitionRouteOfAdministrationList.ClearItems;
begin
  Clear;
end;

function TFhirAdministrableProductDefinitionRouteOfAdministrationList.GetEnumerator : TFhirAdministrableProductDefinitionRouteOfAdministrationListEnumerator;
begin
  result := TFhirAdministrableProductDefinitionRouteOfAdministrationListEnumerator.Create(self.link);
end;

function TFhirAdministrableProductDefinitionRouteOfAdministrationList.Clone: TFhirAdministrableProductDefinitionRouteOfAdministrationList;
begin
  result := TFhirAdministrableProductDefinitionRouteOfAdministrationList(inherited Clone);
end;

function TFhirAdministrableProductDefinitionRouteOfAdministrationList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirAdministrableProductDefinitionRouteOfAdministrationList.GetItemN(index: Integer): TFhirAdministrableProductDefinitionRouteOfAdministration;
begin
  result := TFhirAdministrableProductDefinitionRouteOfAdministration(ObjectByIndex[index]);
end;

function TFhirAdministrableProductDefinitionRouteOfAdministrationList.ItemClass: TFslObjectClass;
begin
  result := TFhirAdministrableProductDefinitionRouteOfAdministration;
end;
function TFhirAdministrableProductDefinitionRouteOfAdministrationList.IndexOf(value: TFhirAdministrableProductDefinitionRouteOfAdministration): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirAdministrableProductDefinitionRouteOfAdministrationList.Insert(index: Integer): TFhirAdministrableProductDefinitionRouteOfAdministration;
begin
  result := TFhirAdministrableProductDefinitionRouteOfAdministration.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirAdministrableProductDefinitionRouteOfAdministrationList.InsertItem(index: Integer; value: TFhirAdministrableProductDefinitionRouteOfAdministration);
begin
  assert(value is TFhirAdministrableProductDefinitionRouteOfAdministration);
  Inherited Insert(index, value);
end;

function TFhirAdministrableProductDefinitionRouteOfAdministrationList.Item(index: Integer): TFhirAdministrableProductDefinitionRouteOfAdministration;
begin
  result := TFhirAdministrableProductDefinitionRouteOfAdministration(ObjectByIndex[index]);
end;

function TFhirAdministrableProductDefinitionRouteOfAdministrationList.Link: TFhirAdministrableProductDefinitionRouteOfAdministrationList;
begin
  result := TFhirAdministrableProductDefinitionRouteOfAdministrationList(inherited Link);
end;

procedure TFhirAdministrableProductDefinitionRouteOfAdministrationList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirAdministrableProductDefinitionRouteOfAdministrationList.SetItemByIndex(index: Integer; value: TFhirAdministrableProductDefinitionRouteOfAdministration);
begin
  assert(value is TFhirAdministrableProductDefinitionRouteOfAdministration);
  FhirAdministrableProductDefinitionRouteOfAdministrations[index] := value;
end;

procedure TFhirAdministrableProductDefinitionRouteOfAdministrationList.SetItemN(index: Integer; value: TFhirAdministrableProductDefinitionRouteOfAdministration);
begin
  assert(value is TFhirAdministrableProductDefinitionRouteOfAdministration);
  ObjectByIndex[index] := value;
end;

{ TFhirAdministrableProductDefinitionRouteOfAdministrationTargetSpecies }

constructor TFhirAdministrableProductDefinitionRouteOfAdministrationTargetSpecies.Create;
begin
  inherited;
end;

destructor TFhirAdministrableProductDefinitionRouteOfAdministrationTargetSpecies.Destroy;
begin
  FCode.free;
  FWithdrawalPeriodList.Free;
  inherited;
end;

procedure TFhirAdministrableProductDefinitionRouteOfAdministrationTargetSpecies.Assign(oSource : TFslObject);
begin
  inherited;
  code := TFhirAdministrableProductDefinitionRouteOfAdministrationTargetSpecies(oSource).code.Clone;
  if (TFhirAdministrableProductDefinitionRouteOfAdministrationTargetSpecies(oSource).FWithdrawalPeriodList = nil) then
  begin
    FWithdrawalPeriodList.free;
    FWithdrawalPeriodList := nil;
  end
  else
  begin
    if FWithdrawalPeriodList = nil then
      FWithdrawalPeriodList := TFhirAdministrableProductDefinitionRouteOfAdministrationTargetSpeciesWithdrawalPeriodList.Create;
    FWithdrawalPeriodList.Assign(TFhirAdministrableProductDefinitionRouteOfAdministrationTargetSpecies(oSource).FWithdrawalPeriodList);
  end;
end;

procedure TFhirAdministrableProductDefinitionRouteOfAdministrationTargetSpecies.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'code') Then
     list.add(self.link, 'code', FCode.Link);
  if (child_name = 'withdrawalPeriod') Then
    list.addAll(self, 'withdrawalPeriod', FWithdrawalPeriodList);
end;

procedure TFhirAdministrableProductDefinitionRouteOfAdministrationTargetSpecies.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'code', 'CodeableConcept', false, TFhirCodeableConcept, FCode.Link));
  oList.add(TFHIRProperty.create(self, 'withdrawalPeriod', 'BackboneElement', true, TFhirAdministrableProductDefinitionRouteOfAdministrationTargetSpeciesWithdrawalPeriod, FWithdrawalPeriodList.Link));
end;

function TFhirAdministrableProductDefinitionRouteOfAdministrationTargetSpecies.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'code') then
  begin
    Code := propValue as TFhirCodeableConcept;
    result := propValue;
  end
  else if (propName = 'withdrawalPeriod') then
  begin
    WithdrawalPeriodList.add(propValue as TFhirAdministrableProductDefinitionRouteOfAdministrationTargetSpeciesWithdrawalPeriod);
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirAdministrableProductDefinitionRouteOfAdministrationTargetSpecies.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'withdrawalPeriod') then WithdrawalPeriodList.insertItem(index, propValue as TFhirAdministrableProductDefinitionRouteOfAdministrationTargetSpeciesWithdrawalPeriod)
  else inherited;
end;

function TFhirAdministrableProductDefinitionRouteOfAdministrationTargetSpecies.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'code') then result := TFhirCodeableConcept.create()
  else if (propName = 'withdrawalPeriod') then result := WithdrawalPeriodList.new()
  else result := inherited createPropertyValue(propName);
end;

function TFhirAdministrableProductDefinitionRouteOfAdministrationTargetSpecies.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'code') then result := 'CodeableConcept'
  else if (propName = 'withdrawalPeriod') then result := 'BackboneElement'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirAdministrableProductDefinitionRouteOfAdministrationTargetSpecies.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'code') then CodeElement := nil
  else if (propName = 'withdrawalPeriod') then deletePropertyValue('withdrawalPeriod', WithdrawalPeriodList, value)
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirAdministrableProductDefinitionRouteOfAdministrationTargetSpecies.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'code') then CodeElement := new as TFhirCodeableConcept
  else if (propName = 'withdrawalPeriod') then replacePropertyValue('withdrawalPeriod', WithdrawalPeriodList, existing, new)
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirAdministrableProductDefinitionRouteOfAdministrationTargetSpecies.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'withdrawalPeriod') then WithdrawalPeriodList.move(source, destination)
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirAdministrableProductDefinitionRouteOfAdministrationTargetSpecies.fhirType : string;
begin
  result := 'AdministrableProductDefinition.routeOfAdministration.targetSpecies';
end;

function TFhirAdministrableProductDefinitionRouteOfAdministrationTargetSpecies.Link : TFhirAdministrableProductDefinitionRouteOfAdministrationTargetSpecies;
begin
  result := TFhirAdministrableProductDefinitionRouteOfAdministrationTargetSpecies(inherited Link);
end;

function TFhirAdministrableProductDefinitionRouteOfAdministrationTargetSpecies.Clone : TFhirAdministrableProductDefinitionRouteOfAdministrationTargetSpecies;
begin
  result := TFhirAdministrableProductDefinitionRouteOfAdministrationTargetSpecies(inherited Clone);
end;

function TFhirAdministrableProductDefinitionRouteOfAdministrationTargetSpecies.equals(other : TObject) : boolean; 
var
  o : TFhirAdministrableProductDefinitionRouteOfAdministrationTargetSpecies;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirAdministrableProductDefinitionRouteOfAdministrationTargetSpecies)) then
    result := false
  else
  begin
    o := TFhirAdministrableProductDefinitionRouteOfAdministrationTargetSpecies(other);
    result := compareDeep(codeElement, o.codeElement, true) and compareDeep(withdrawalPeriodList, o.withdrawalPeriodList, true);
  end;
end;

function TFhirAdministrableProductDefinitionRouteOfAdministrationTargetSpecies.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FCode) and isEmptyProp(FwithdrawalPeriodList);
end;

procedure TFhirAdministrableProductDefinitionRouteOfAdministrationTargetSpecies.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('code');
  fields.add('withdrawalPeriod');
end;

function TFhirAdministrableProductDefinitionRouteOfAdministrationTargetSpecies.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
  inc(result, FWithdrawalPeriodList.sizeInBytes(magic));
end;

procedure TFhirAdministrableProductDefinitionRouteOfAdministrationTargetSpecies.SetCode(value : TFhirCodeableConcept);
begin
  FCode.free;
  FCode := value;
end;

function TFhirAdministrableProductDefinitionRouteOfAdministrationTargetSpecies.GetWithdrawalPeriodList : TFhirAdministrableProductDefinitionRouteOfAdministrationTargetSpeciesWithdrawalPeriodList;
begin
  if FWithdrawalPeriodList = nil then
    FWithdrawalPeriodList := TFhirAdministrableProductDefinitionRouteOfAdministrationTargetSpeciesWithdrawalPeriodList.Create;
  result := FWithdrawalPeriodList;
end;

function TFhirAdministrableProductDefinitionRouteOfAdministrationTargetSpecies.GetHasWithdrawalPeriodList : boolean;
begin
  result := (FWithdrawalPeriodList <> nil) and (FWithdrawalPeriodList.count > 0);
end;

{ TFhirAdministrableProductDefinitionRouteOfAdministrationTargetSpeciesListEnumerator }

constructor TFhirAdministrableProductDefinitionRouteOfAdministrationTargetSpeciesListEnumerator.Create(list : TFhirAdministrableProductDefinitionRouteOfAdministrationTargetSpeciesList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirAdministrableProductDefinitionRouteOfAdministrationTargetSpeciesListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirAdministrableProductDefinitionRouteOfAdministrationTargetSpeciesListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirAdministrableProductDefinitionRouteOfAdministrationTargetSpeciesListEnumerator.GetCurrent : TFhirAdministrableProductDefinitionRouteOfAdministrationTargetSpecies;
begin
  Result := FList[FIndex];
end;

function TFhirAdministrableProductDefinitionRouteOfAdministrationTargetSpeciesListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirAdministrableProductDefinitionRouteOfAdministrationTargetSpeciesList }

function TFhirAdministrableProductDefinitionRouteOfAdministrationTargetSpeciesList.AddItem(value: TFhirAdministrableProductDefinitionRouteOfAdministrationTargetSpecies): TFhirAdministrableProductDefinitionRouteOfAdministrationTargetSpecies;
begin
  assert(value.ClassName = 'TFhirAdministrableProductDefinitionRouteOfAdministrationTargetSpecies', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirAdministrableProductDefinitionRouteOfAdministrationTargetSpecies');
  add(value);
  result := value;
end;

function TFhirAdministrableProductDefinitionRouteOfAdministrationTargetSpeciesList.Append: TFhirAdministrableProductDefinitionRouteOfAdministrationTargetSpecies;
begin
  result := TFhirAdministrableProductDefinitionRouteOfAdministrationTargetSpecies.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirAdministrableProductDefinitionRouteOfAdministrationTargetSpeciesList.ClearItems;
begin
  Clear;
end;

function TFhirAdministrableProductDefinitionRouteOfAdministrationTargetSpeciesList.GetEnumerator : TFhirAdministrableProductDefinitionRouteOfAdministrationTargetSpeciesListEnumerator;
begin
  result := TFhirAdministrableProductDefinitionRouteOfAdministrationTargetSpeciesListEnumerator.Create(self.link);
end;

function TFhirAdministrableProductDefinitionRouteOfAdministrationTargetSpeciesList.Clone: TFhirAdministrableProductDefinitionRouteOfAdministrationTargetSpeciesList;
begin
  result := TFhirAdministrableProductDefinitionRouteOfAdministrationTargetSpeciesList(inherited Clone);
end;

function TFhirAdministrableProductDefinitionRouteOfAdministrationTargetSpeciesList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirAdministrableProductDefinitionRouteOfAdministrationTargetSpeciesList.GetItemN(index: Integer): TFhirAdministrableProductDefinitionRouteOfAdministrationTargetSpecies;
begin
  result := TFhirAdministrableProductDefinitionRouteOfAdministrationTargetSpecies(ObjectByIndex[index]);
end;

function TFhirAdministrableProductDefinitionRouteOfAdministrationTargetSpeciesList.ItemClass: TFslObjectClass;
begin
  result := TFhirAdministrableProductDefinitionRouteOfAdministrationTargetSpecies;
end;
function TFhirAdministrableProductDefinitionRouteOfAdministrationTargetSpeciesList.IndexOf(value: TFhirAdministrableProductDefinitionRouteOfAdministrationTargetSpecies): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirAdministrableProductDefinitionRouteOfAdministrationTargetSpeciesList.Insert(index: Integer): TFhirAdministrableProductDefinitionRouteOfAdministrationTargetSpecies;
begin
  result := TFhirAdministrableProductDefinitionRouteOfAdministrationTargetSpecies.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirAdministrableProductDefinitionRouteOfAdministrationTargetSpeciesList.InsertItem(index: Integer; value: TFhirAdministrableProductDefinitionRouteOfAdministrationTargetSpecies);
begin
  assert(value is TFhirAdministrableProductDefinitionRouteOfAdministrationTargetSpecies);
  Inherited Insert(index, value);
end;

function TFhirAdministrableProductDefinitionRouteOfAdministrationTargetSpeciesList.Item(index: Integer): TFhirAdministrableProductDefinitionRouteOfAdministrationTargetSpecies;
begin
  result := TFhirAdministrableProductDefinitionRouteOfAdministrationTargetSpecies(ObjectByIndex[index]);
end;

function TFhirAdministrableProductDefinitionRouteOfAdministrationTargetSpeciesList.Link: TFhirAdministrableProductDefinitionRouteOfAdministrationTargetSpeciesList;
begin
  result := TFhirAdministrableProductDefinitionRouteOfAdministrationTargetSpeciesList(inherited Link);
end;

procedure TFhirAdministrableProductDefinitionRouteOfAdministrationTargetSpeciesList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirAdministrableProductDefinitionRouteOfAdministrationTargetSpeciesList.SetItemByIndex(index: Integer; value: TFhirAdministrableProductDefinitionRouteOfAdministrationTargetSpecies);
begin
  assert(value is TFhirAdministrableProductDefinitionRouteOfAdministrationTargetSpecies);
  FhirAdministrableProductDefinitionRouteOfAdministrationTargetSpecies[index] := value;
end;

procedure TFhirAdministrableProductDefinitionRouteOfAdministrationTargetSpeciesList.SetItemN(index: Integer; value: TFhirAdministrableProductDefinitionRouteOfAdministrationTargetSpecies);
begin
  assert(value is TFhirAdministrableProductDefinitionRouteOfAdministrationTargetSpecies);
  ObjectByIndex[index] := value;
end;

{ TFhirAdministrableProductDefinitionRouteOfAdministrationTargetSpeciesWithdrawalPeriod }

constructor TFhirAdministrableProductDefinitionRouteOfAdministrationTargetSpeciesWithdrawalPeriod.Create;
begin
  inherited;
end;

destructor TFhirAdministrableProductDefinitionRouteOfAdministrationTargetSpeciesWithdrawalPeriod.Destroy;
begin
  FTissue.free;
  FValue.free;
  FSupportingInformation.free;
  inherited;
end;

procedure TFhirAdministrableProductDefinitionRouteOfAdministrationTargetSpeciesWithdrawalPeriod.Assign(oSource : TFslObject);
begin
  inherited;
  tissue := TFhirAdministrableProductDefinitionRouteOfAdministrationTargetSpeciesWithdrawalPeriod(oSource).tissue.Clone;
  value := TFhirAdministrableProductDefinitionRouteOfAdministrationTargetSpeciesWithdrawalPeriod(oSource).value.Clone;
  supportingInformationElement := TFhirAdministrableProductDefinitionRouteOfAdministrationTargetSpeciesWithdrawalPeriod(oSource).supportingInformationElement.Clone;
end;

procedure TFhirAdministrableProductDefinitionRouteOfAdministrationTargetSpeciesWithdrawalPeriod.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'tissue') Then
     list.add(self.link, 'tissue', FTissue.Link);
  if (child_name = 'value') Then
     list.add(self.link, 'value', FValue.Link);
  if (child_name = 'supportingInformation') Then
     list.add(self.link, 'supportingInformation', FSupportingInformation.Link);
end;

procedure TFhirAdministrableProductDefinitionRouteOfAdministrationTargetSpeciesWithdrawalPeriod.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'tissue', 'CodeableConcept', false, TFhirCodeableConcept, FTissue.Link));
  oList.add(TFHIRProperty.create(self, 'value', 'Quantity', false, TFhirQuantity, FValue.Link));
  oList.add(TFHIRProperty.create(self, 'supportingInformation', 'string', false, TFhirString, FSupportingInformation.Link));
end;

function TFhirAdministrableProductDefinitionRouteOfAdministrationTargetSpeciesWithdrawalPeriod.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'tissue') then
  begin
    Tissue := propValue as TFhirCodeableConcept;
    result := propValue;
  end
  else if (propName = 'value') then
  begin
    Value := propValue as TFhirQuantity;
    result := propValue;
  end
  else if (propName = 'supportingInformation') then
  begin
    SupportingInformationElement := asString(propValue);
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirAdministrableProductDefinitionRouteOfAdministrationTargetSpeciesWithdrawalPeriod.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirAdministrableProductDefinitionRouteOfAdministrationTargetSpeciesWithdrawalPeriod.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'tissue') then result := TFhirCodeableConcept.create()
  else if (propName = 'value') then result := TFhirQuantity.create()
  else if (propName = 'supportingInformation') then result := TFhirString.create()
  else result := inherited createPropertyValue(propName);
end;

function TFhirAdministrableProductDefinitionRouteOfAdministrationTargetSpeciesWithdrawalPeriod.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'tissue') then result := 'CodeableConcept'
  else if (propName = 'value') then result := 'Quantity'
  else if (propName = 'supportingInformation') then result := 'string'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirAdministrableProductDefinitionRouteOfAdministrationTargetSpeciesWithdrawalPeriod.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'tissue') then TissueElement := nil
  else if (propName = 'value') then ValueElement := nil
  else if (propName = 'supportingInformation') then SupportingInformationElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirAdministrableProductDefinitionRouteOfAdministrationTargetSpeciesWithdrawalPeriod.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'tissue') then TissueElement := new as TFhirCodeableConcept
  else if (propName = 'value') then ValueElement := new as TFhirQuantity
  else if (propName = 'supportingInformation') then SupportingInformationElement := asString(new)
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirAdministrableProductDefinitionRouteOfAdministrationTargetSpeciesWithdrawalPeriod.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirAdministrableProductDefinitionRouteOfAdministrationTargetSpeciesWithdrawalPeriod.fhirType : string;
begin
  result := 'AdministrableProductDefinition.routeOfAdministration.targetSpecies.withdrawalPeriod';
end;

function TFhirAdministrableProductDefinitionRouteOfAdministrationTargetSpeciesWithdrawalPeriod.Link : TFhirAdministrableProductDefinitionRouteOfAdministrationTargetSpeciesWithdrawalPeriod;
begin
  result := TFhirAdministrableProductDefinitionRouteOfAdministrationTargetSpeciesWithdrawalPeriod(inherited Link);
end;

function TFhirAdministrableProductDefinitionRouteOfAdministrationTargetSpeciesWithdrawalPeriod.Clone : TFhirAdministrableProductDefinitionRouteOfAdministrationTargetSpeciesWithdrawalPeriod;
begin
  result := TFhirAdministrableProductDefinitionRouteOfAdministrationTargetSpeciesWithdrawalPeriod(inherited Clone);
end;

function TFhirAdministrableProductDefinitionRouteOfAdministrationTargetSpeciesWithdrawalPeriod.equals(other : TObject) : boolean; 
var
  o : TFhirAdministrableProductDefinitionRouteOfAdministrationTargetSpeciesWithdrawalPeriod;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirAdministrableProductDefinitionRouteOfAdministrationTargetSpeciesWithdrawalPeriod)) then
    result := false
  else
  begin
    o := TFhirAdministrableProductDefinitionRouteOfAdministrationTargetSpeciesWithdrawalPeriod(other);
    result := compareDeep(tissueElement, o.tissueElement, true) and compareDeep(valueElement, o.valueElement, true) and 
      compareDeep(supportingInformationElement, o.supportingInformationElement, true);
  end;
end;

function TFhirAdministrableProductDefinitionRouteOfAdministrationTargetSpeciesWithdrawalPeriod.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FTissue) and isEmptyProp(FValue) and isEmptyProp(FSupportingInformation);
end;

procedure TFhirAdministrableProductDefinitionRouteOfAdministrationTargetSpeciesWithdrawalPeriod.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('tissue');
  fields.add('value');
  fields.add('supportingInformation');
end;

function TFhirAdministrableProductDefinitionRouteOfAdministrationTargetSpeciesWithdrawalPeriod.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
end;

procedure TFhirAdministrableProductDefinitionRouteOfAdministrationTargetSpeciesWithdrawalPeriod.SetTissue(value : TFhirCodeableConcept);
begin
  FTissue.free;
  FTissue := value;
end;

procedure TFhirAdministrableProductDefinitionRouteOfAdministrationTargetSpeciesWithdrawalPeriod.SetValue(value : TFhirQuantity);
begin
  FValue.free;
  FValue := value;
end;

procedure TFhirAdministrableProductDefinitionRouteOfAdministrationTargetSpeciesWithdrawalPeriod.SetSupportingInformation(value : TFhirString);
begin
  FSupportingInformation.free;
  FSupportingInformation := value;
end;

function TFhirAdministrableProductDefinitionRouteOfAdministrationTargetSpeciesWithdrawalPeriod.GetSupportingInformationST : String;
begin
  if FSupportingInformation = nil then
    result := ''
  else
    result := FSupportingInformation.value;
end;

procedure TFhirAdministrableProductDefinitionRouteOfAdministrationTargetSpeciesWithdrawalPeriod.SetSupportingInformationST(value : String);
begin
  if value <> '' then
  begin
    if FSupportingInformation = nil then
      FSupportingInformation := TFhirString.create;
    FSupportingInformation.value := value
  end
  else if FSupportingInformation <> nil then
    FSupportingInformation.value := '';
end;

{ TFhirAdministrableProductDefinitionRouteOfAdministrationTargetSpeciesWithdrawalPeriodListEnumerator }

constructor TFhirAdministrableProductDefinitionRouteOfAdministrationTargetSpeciesWithdrawalPeriodListEnumerator.Create(list : TFhirAdministrableProductDefinitionRouteOfAdministrationTargetSpeciesWithdrawalPeriodList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirAdministrableProductDefinitionRouteOfAdministrationTargetSpeciesWithdrawalPeriodListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirAdministrableProductDefinitionRouteOfAdministrationTargetSpeciesWithdrawalPeriodListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirAdministrableProductDefinitionRouteOfAdministrationTargetSpeciesWithdrawalPeriodListEnumerator.GetCurrent : TFhirAdministrableProductDefinitionRouteOfAdministrationTargetSpeciesWithdrawalPeriod;
begin
  Result := FList[FIndex];
end;

function TFhirAdministrableProductDefinitionRouteOfAdministrationTargetSpeciesWithdrawalPeriodListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirAdministrableProductDefinitionRouteOfAdministrationTargetSpeciesWithdrawalPeriodList }

function TFhirAdministrableProductDefinitionRouteOfAdministrationTargetSpeciesWithdrawalPeriodList.AddItem(value: TFhirAdministrableProductDefinitionRouteOfAdministrationTargetSpeciesWithdrawalPeriod): TFhirAdministrableProductDefinitionRouteOfAdministrationTargetSpeciesWithdrawalPeriod;
begin
  assert(value.ClassName = 'TFhirAdministrableProductDefinitionRouteOfAdministrationTargetSpeciesWithdrawalPeriod', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirAdministrableProductDefinitionRouteOfAdministrationTargetSpeciesWithdrawalPeriod');
  add(value);
  result := value;
end;

function TFhirAdministrableProductDefinitionRouteOfAdministrationTargetSpeciesWithdrawalPeriodList.Append: TFhirAdministrableProductDefinitionRouteOfAdministrationTargetSpeciesWithdrawalPeriod;
begin
  result := TFhirAdministrableProductDefinitionRouteOfAdministrationTargetSpeciesWithdrawalPeriod.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirAdministrableProductDefinitionRouteOfAdministrationTargetSpeciesWithdrawalPeriodList.ClearItems;
begin
  Clear;
end;

function TFhirAdministrableProductDefinitionRouteOfAdministrationTargetSpeciesWithdrawalPeriodList.GetEnumerator : TFhirAdministrableProductDefinitionRouteOfAdministrationTargetSpeciesWithdrawalPeriodListEnumerator;
begin
  result := TFhirAdministrableProductDefinitionRouteOfAdministrationTargetSpeciesWithdrawalPeriodListEnumerator.Create(self.link);
end;

function TFhirAdministrableProductDefinitionRouteOfAdministrationTargetSpeciesWithdrawalPeriodList.Clone: TFhirAdministrableProductDefinitionRouteOfAdministrationTargetSpeciesWithdrawalPeriodList;
begin
  result := TFhirAdministrableProductDefinitionRouteOfAdministrationTargetSpeciesWithdrawalPeriodList(inherited Clone);
end;

function TFhirAdministrableProductDefinitionRouteOfAdministrationTargetSpeciesWithdrawalPeriodList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirAdministrableProductDefinitionRouteOfAdministrationTargetSpeciesWithdrawalPeriodList.GetItemN(index: Integer): TFhirAdministrableProductDefinitionRouteOfAdministrationTargetSpeciesWithdrawalPeriod;
begin
  result := TFhirAdministrableProductDefinitionRouteOfAdministrationTargetSpeciesWithdrawalPeriod(ObjectByIndex[index]);
end;

function TFhirAdministrableProductDefinitionRouteOfAdministrationTargetSpeciesWithdrawalPeriodList.ItemClass: TFslObjectClass;
begin
  result := TFhirAdministrableProductDefinitionRouteOfAdministrationTargetSpeciesWithdrawalPeriod;
end;
function TFhirAdministrableProductDefinitionRouteOfAdministrationTargetSpeciesWithdrawalPeriodList.IndexOf(value: TFhirAdministrableProductDefinitionRouteOfAdministrationTargetSpeciesWithdrawalPeriod): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirAdministrableProductDefinitionRouteOfAdministrationTargetSpeciesWithdrawalPeriodList.Insert(index: Integer): TFhirAdministrableProductDefinitionRouteOfAdministrationTargetSpeciesWithdrawalPeriod;
begin
  result := TFhirAdministrableProductDefinitionRouteOfAdministrationTargetSpeciesWithdrawalPeriod.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirAdministrableProductDefinitionRouteOfAdministrationTargetSpeciesWithdrawalPeriodList.InsertItem(index: Integer; value: TFhirAdministrableProductDefinitionRouteOfAdministrationTargetSpeciesWithdrawalPeriod);
begin
  assert(value is TFhirAdministrableProductDefinitionRouteOfAdministrationTargetSpeciesWithdrawalPeriod);
  Inherited Insert(index, value);
end;

function TFhirAdministrableProductDefinitionRouteOfAdministrationTargetSpeciesWithdrawalPeriodList.Item(index: Integer): TFhirAdministrableProductDefinitionRouteOfAdministrationTargetSpeciesWithdrawalPeriod;
begin
  result := TFhirAdministrableProductDefinitionRouteOfAdministrationTargetSpeciesWithdrawalPeriod(ObjectByIndex[index]);
end;

function TFhirAdministrableProductDefinitionRouteOfAdministrationTargetSpeciesWithdrawalPeriodList.Link: TFhirAdministrableProductDefinitionRouteOfAdministrationTargetSpeciesWithdrawalPeriodList;
begin
  result := TFhirAdministrableProductDefinitionRouteOfAdministrationTargetSpeciesWithdrawalPeriodList(inherited Link);
end;

procedure TFhirAdministrableProductDefinitionRouteOfAdministrationTargetSpeciesWithdrawalPeriodList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirAdministrableProductDefinitionRouteOfAdministrationTargetSpeciesWithdrawalPeriodList.SetItemByIndex(index: Integer; value: TFhirAdministrableProductDefinitionRouteOfAdministrationTargetSpeciesWithdrawalPeriod);
begin
  assert(value is TFhirAdministrableProductDefinitionRouteOfAdministrationTargetSpeciesWithdrawalPeriod);
  FhirAdministrableProductDefinitionRouteOfAdministrationTargetSpeciesWithdrawalPeriods[index] := value;
end;

procedure TFhirAdministrableProductDefinitionRouteOfAdministrationTargetSpeciesWithdrawalPeriodList.SetItemN(index: Integer; value: TFhirAdministrableProductDefinitionRouteOfAdministrationTargetSpeciesWithdrawalPeriod);
begin
  assert(value is TFhirAdministrableProductDefinitionRouteOfAdministrationTargetSpeciesWithdrawalPeriod);
  ObjectByIndex[index] := value;
end;

{ TFhirAdministrableProductDefinition }

constructor TFhirAdministrableProductDefinition.Create;
begin
  inherited;
end;

destructor TFhirAdministrableProductDefinition.Destroy;
begin
  FIdentifierList.Free;
  FStatus.free;
  FFormOfList.Free;
  FAdministrableDoseForm.free;
  FUnitOfPresentation.free;
  FProducedFromList.Free;
  FIngredientList.Free;
  FDevice.free;
  FProperty_List.Free;
  FRouteOfAdministrationList.Free;
  inherited;
end;

procedure TFhirAdministrableProductDefinition.Assign(oSource : TFslObject);
begin
  inherited;
  if (TFhirAdministrableProductDefinition(oSource).FIdentifierList = nil) then
  begin
    FIdentifierList.free;
    FIdentifierList := nil;
  end
  else
  begin
    if FIdentifierList = nil then
      FIdentifierList := TFhirIdentifierList.Create;
    FIdentifierList.Assign(TFhirAdministrableProductDefinition(oSource).FIdentifierList);
  end;
  statusElement := TFhirAdministrableProductDefinition(oSource).statusElement.Clone;
  if (TFhirAdministrableProductDefinition(oSource).FFormOfList = nil) then
  begin
    FFormOfList.free;
    FFormOfList := nil;
  end
  else
  begin
    if FFormOfList = nil then
      FFormOfList := TFhirReferenceList.Create;
    FFormOfList.Assign(TFhirAdministrableProductDefinition(oSource).FFormOfList);
  end;
  administrableDoseForm := TFhirAdministrableProductDefinition(oSource).administrableDoseForm.Clone;
  unitOfPresentation := TFhirAdministrableProductDefinition(oSource).unitOfPresentation.Clone;
  if (TFhirAdministrableProductDefinition(oSource).FProducedFromList = nil) then
  begin
    FProducedFromList.free;
    FProducedFromList := nil;
  end
  else
  begin
    if FProducedFromList = nil then
      FProducedFromList := TFhirReferenceList.Create;
    FProducedFromList.Assign(TFhirAdministrableProductDefinition(oSource).FProducedFromList);
  end;
  if (TFhirAdministrableProductDefinition(oSource).FIngredientList = nil) then
  begin
    FIngredientList.free;
    FIngredientList := nil;
  end
  else
  begin
    if FIngredientList = nil then
      FIngredientList := TFhirCodeableConceptList.Create;
    FIngredientList.Assign(TFhirAdministrableProductDefinition(oSource).FIngredientList);
  end;
  device := TFhirAdministrableProductDefinition(oSource).device.Clone;
  if (TFhirAdministrableProductDefinition(oSource).FProperty_List = nil) then
  begin
    FProperty_List.free;
    FProperty_List := nil;
  end
  else
  begin
    if FProperty_List = nil then
      FProperty_List := TFhirAdministrableProductDefinitionPropertyList.Create;
    FProperty_List.Assign(TFhirAdministrableProductDefinition(oSource).FProperty_List);
  end;
  if (TFhirAdministrableProductDefinition(oSource).FRouteOfAdministrationList = nil) then
  begin
    FRouteOfAdministrationList.free;
    FRouteOfAdministrationList := nil;
  end
  else
  begin
    if FRouteOfAdministrationList = nil then
      FRouteOfAdministrationList := TFhirAdministrableProductDefinitionRouteOfAdministrationList.Create;
    FRouteOfAdministrationList.Assign(TFhirAdministrableProductDefinition(oSource).FRouteOfAdministrationList);
  end;
end;

function TFhirAdministrableProductDefinition.GetResourceType : TFhirResourceType;
begin
  result := frtAdministrableProductDefinition;
end;

procedure TFhirAdministrableProductDefinition.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'identifier') Then
    list.addAll(self, 'identifier', FIdentifierList);
  if (child_name = 'status') Then
     list.add(self.link, 'status', FStatus.Link);
  if (child_name = 'formOf') Then
    list.addAll(self, 'formOf', FFormOfList);
  if (child_name = 'administrableDoseForm') Then
     list.add(self.link, 'administrableDoseForm', FAdministrableDoseForm.Link);
  if (child_name = 'unitOfPresentation') Then
     list.add(self.link, 'unitOfPresentation', FUnitOfPresentation.Link);
  if (child_name = 'producedFrom') Then
    list.addAll(self, 'producedFrom', FProducedFromList);
  if (child_name = 'ingredient') Then
    list.addAll(self, 'ingredient', FIngredientList);
  if (child_name = 'device') Then
     list.add(self.link, 'device', FDevice.Link);
  if (child_name = 'property') Then
    list.addAll(self, 'property', FProperty_List);
  if (child_name = 'routeOfAdministration') Then
    list.addAll(self, 'routeOfAdministration', FRouteOfAdministrationList);
end;

procedure TFhirAdministrableProductDefinition.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'identifier', 'Identifier', true, TFhirIdentifier, FIdentifierList.Link));
  oList.add(TFHIRProperty.create(self, 'status', 'code', false, TFhirEnum, FStatus.Link));
  oList.add(TFHIRProperty.create(self, 'formOf', 'Reference', true, TFhirReference, FFormOfList.Link));
  oList.add(TFHIRProperty.create(self, 'administrableDoseForm', 'CodeableConcept', false, TFhirCodeableConcept, FAdministrableDoseForm.Link));
  oList.add(TFHIRProperty.create(self, 'unitOfPresentation', 'CodeableConcept', false, TFhirCodeableConcept, FUnitOfPresentation.Link));
  oList.add(TFHIRProperty.create(self, 'producedFrom', 'Reference', true, TFhirReference, FProducedFromList.Link));
  oList.add(TFHIRProperty.create(self, 'ingredient', 'CodeableConcept', true, TFhirCodeableConcept, FIngredientList.Link));
  oList.add(TFHIRProperty.create(self, 'device', 'Reference', false, TFhirReference, FDevice.Link));
  oList.add(TFHIRProperty.create(self, 'property', 'BackboneElement', true, TFhirAdministrableProductDefinitionProperty, FProperty_List.Link));
  oList.add(TFHIRProperty.create(self, 'routeOfAdministration', 'BackboneElement', true, TFhirAdministrableProductDefinitionRouteOfAdministration, FRouteOfAdministrationList.Link));
end;

function TFhirAdministrableProductDefinition.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'identifier') then
  begin
    IdentifierList.add(propValue as TFhirIdentifier);
    result := propValue;
  end
  else if (propName = 'status') then
  begin
    StatusElement := asEnum(SYSTEMS_TFhirPublicationStatusEnum, CODES_TFhirPublicationStatusEnum, propValue);
    result := propValue;
  end
  else if (propName = 'formOf') then
  begin
    FormOfList.add(propValue as TFhirReference);
    result := propValue;
  end
  else if (propName = 'administrableDoseForm') then
  begin
    AdministrableDoseForm := propValue as TFhirCodeableConcept;
    result := propValue;
  end
  else if (propName = 'unitOfPresentation') then
  begin
    UnitOfPresentation := propValue as TFhirCodeableConcept;
    result := propValue;
  end
  else if (propName = 'producedFrom') then
  begin
    ProducedFromList.add(propValue as TFhirReference);
    result := propValue;
  end
  else if (propName = 'ingredient') then
  begin
    IngredientList.add(propValue as TFhirCodeableConcept);
    result := propValue;
  end
  else if (propName = 'device') then
  begin
    Device := propValue as TFhirReference;
    result := propValue;
  end
  else if (propName = 'property') then
  begin
    Property_List.add(propValue as TFhirAdministrableProductDefinitionProperty);
    result := propValue;
  end
  else if (propName = 'routeOfAdministration') then
  begin
    RouteOfAdministrationList.add(propValue as TFhirAdministrableProductDefinitionRouteOfAdministration);
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirAdministrableProductDefinition.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'identifier') then IdentifierList.insertItem(index, propValue as TFhirIdentifier)
  else if (propName = 'formOf') then FormOfList.insertItem(index, propValue as TFhirReference)
  else if (propName = 'producedFrom') then ProducedFromList.insertItem(index, propValue as TFhirReference)
  else if (propName = 'ingredient') then IngredientList.insertItem(index, propValue as TFhirCodeableConcept)
  else if (propName = 'property') then Property_List.insertItem(index, propValue as TFhirAdministrableProductDefinitionProperty)
  else if (propName = 'routeOfAdministration') then RouteOfAdministrationList.insertItem(index, propValue as TFhirAdministrableProductDefinitionRouteOfAdministration)
  else inherited;
end;

function TFhirAdministrableProductDefinition.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'identifier') then result := IdentifierList.new()
  else if (propName = 'status') then result := TFhirEnum.create(SYSTEMS_TFhirPublicationStatusEnum[PublicationStatusNull], CODES_TFhirPublicationStatusEnum[PublicationStatusNull]) 
  else if (propName = 'formOf') then result := FormOfList.new()
  else if (propName = 'administrableDoseForm') then result := TFhirCodeableConcept.create()
  else if (propName = 'unitOfPresentation') then result := TFhirCodeableConcept.create()
  else if (propName = 'producedFrom') then result := ProducedFromList.new()
  else if (propName = 'ingredient') then result := IngredientList.new()
  else if (propName = 'device') then result := TFhirReference.create()
  else if (propName = 'property') then result := Property_List.new()
  else if (propName = 'routeOfAdministration') then result := RouteOfAdministrationList.new()
  else result := inherited createPropertyValue(propName);
end;

function TFhirAdministrableProductDefinition.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'identifier') then result := 'Identifier'
  else if (propName = 'status') then result := 'code'
  else if (propName = 'formOf') then result := 'Reference'
  else if (propName = 'administrableDoseForm') then result := 'CodeableConcept'
  else if (propName = 'unitOfPresentation') then result := 'CodeableConcept'
  else if (propName = 'producedFrom') then result := 'Reference'
  else if (propName = 'ingredient') then result := 'CodeableConcept'
  else if (propName = 'device') then result := 'Reference'
  else if (propName = 'property') then result := 'BackboneElement'
  else if (propName = 'routeOfAdministration') then result := 'BackboneElement'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirAdministrableProductDefinition.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'identifier') then deletePropertyValue('identifier', IdentifierList, value)
  else if (propName = 'status') then StatusElement := nil
  else if (propName = 'formOf') then deletePropertyValue('formOf', FormOfList, value)
  else if (propName = 'administrableDoseForm') then AdministrableDoseFormElement := nil
  else if (propName = 'unitOfPresentation') then UnitOfPresentationElement := nil
  else if (propName = 'producedFrom') then deletePropertyValue('producedFrom', ProducedFromList, value)
  else if (propName = 'ingredient') then deletePropertyValue('ingredient', IngredientList, value)
  else if (propName = 'device') then DeviceElement := nil
  else if (propName = 'property') then deletePropertyValue('property', Property_List, value)
  else if (propName = 'routeOfAdministration') then deletePropertyValue('routeOfAdministration', RouteOfAdministrationList, value)
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirAdministrableProductDefinition.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'identifier') then replacePropertyValue('identifier', IdentifierList, existing, new)
  else if (propName = 'status') then StatusElement := asEnum(SYSTEMS_TFhirPublicationStatusEnum, CODES_TFhirPublicationStatusEnum, new)
  else if (propName = 'formOf') then replacePropertyValue('formOf', FormOfList, existing, new)
  else if (propName = 'administrableDoseForm') then AdministrableDoseFormElement := new as TFhirCodeableConcept
  else if (propName = 'unitOfPresentation') then UnitOfPresentationElement := new as TFhirCodeableConcept
  else if (propName = 'producedFrom') then replacePropertyValue('producedFrom', ProducedFromList, existing, new)
  else if (propName = 'ingredient') then replacePropertyValue('ingredient', IngredientList, existing, new)
  else if (propName = 'device') then DeviceElement := new as TFhirReference
  else if (propName = 'property') then replacePropertyValue('property', Property_List, existing, new)
  else if (propName = 'routeOfAdministration') then replacePropertyValue('routeOfAdministration', RouteOfAdministrationList, existing, new)
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirAdministrableProductDefinition.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'identifier') then IdentifierList.move(source, destination)
  else if (propName = 'formOf') then FormOfList.move(source, destination)
  else if (propName = 'producedFrom') then ProducedFromList.move(source, destination)
  else if (propName = 'ingredient') then IngredientList.move(source, destination)
  else if (propName = 'property') then Property_List.move(source, destination)
  else if (propName = 'routeOfAdministration') then RouteOfAdministrationList.move(source, destination)
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirAdministrableProductDefinition.fhirType : string;
begin
  result := 'AdministrableProductDefinition';
end;

function TFhirAdministrableProductDefinition.Link : TFhirAdministrableProductDefinition;
begin
  result := TFhirAdministrableProductDefinition(inherited Link);
end;

function TFhirAdministrableProductDefinition.Clone : TFhirAdministrableProductDefinition;
begin
  result := TFhirAdministrableProductDefinition(inherited Clone);
end;

function TFhirAdministrableProductDefinition.equals(other : TObject) : boolean; 
var
  o : TFhirAdministrableProductDefinition;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirAdministrableProductDefinition)) then
    result := false
  else
  begin
    o := TFhirAdministrableProductDefinition(other);
    result := compareDeep(identifierList, o.identifierList, true) and compareDeep(statusElement, o.statusElement, true) and 
      compareDeep(formOfList, o.formOfList, true) and compareDeep(administrableDoseFormElement, o.administrableDoseFormElement, true) and 
      compareDeep(unitOfPresentationElement, o.unitOfPresentationElement, true) and 
      compareDeep(producedFromList, o.producedFromList, true) and compareDeep(ingredientList, o.ingredientList, true) and 
      compareDeep(deviceElement, o.deviceElement, true) and compareDeep(property_List, o.property_List, true) and 
      compareDeep(routeOfAdministrationList, o.routeOfAdministrationList, true);
  end;
end;

function TFhirAdministrableProductDefinition.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FidentifierList) and isEmptyProp(FStatus) and isEmptyProp(FformOfList) and isEmptyProp(FAdministrableDoseForm) and isEmptyProp(FUnitOfPresentation) and isEmptyProp(FproducedFromList) and isEmptyProp(FingredientList) and isEmptyProp(FDevice) and isEmptyProp(Fproperty_List) and isEmptyProp(FrouteOfAdministrationList);
end;

procedure TFhirAdministrableProductDefinition.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('identifier');
  fields.add('status');
  fields.add('formOf');
  fields.add('administrableDoseForm');
  fields.add('unitOfPresentation');
  fields.add('producedFrom');
  fields.add('ingredient');
  fields.add('device');
  fields.add('property');
  fields.add('routeOfAdministration');
end;

function TFhirAdministrableProductDefinition.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
  inc(result, FIdentifierList.sizeInBytes(magic));
  inc(result, FFormOfList.sizeInBytes(magic));
  inc(result, FProducedFromList.sizeInBytes(magic));
  inc(result, FIngredientList.sizeInBytes(magic));
  inc(result, FProperty_List.sizeInBytes(magic));
  inc(result, FRouteOfAdministrationList.sizeInBytes(magic));
end;

function TFhirAdministrableProductDefinition.GetIdentifierList : TFhirIdentifierList;
begin
  if FIdentifierList = nil then
    FIdentifierList := TFhirIdentifierList.Create;
  result := FIdentifierList;
end;

function TFhirAdministrableProductDefinition.GetHasIdentifierList : boolean;
begin
  result := (FIdentifierList <> nil) and (FIdentifierList.count > 0);
end;

procedure TFhirAdministrableProductDefinition.SetStatus(value : TFhirEnum);
begin
  FStatus.free;
  FStatus := value;
end;

function TFhirAdministrableProductDefinition.GetStatusST : TFhirPublicationStatusEnum;
begin
  if FStatus = nil then
    result := TFhirPublicationStatusEnum(0)
  else
    result := TFhirPublicationStatusEnum(StringArrayIndexOfSensitive(CODES_TFhirPublicationStatusEnum, FStatus.value));
end;

procedure TFhirAdministrableProductDefinition.SetStatusST(value : TFhirPublicationStatusEnum);
begin
  if ord(value) = 0 then
    StatusElement := nil
  else
    StatusElement := TFhirEnum.create(SYSTEMS_TFhirPublicationStatusEnum[value], CODES_TFhirPublicationStatusEnum[value]);
end;

function TFhirAdministrableProductDefinition.GetFormOfList : TFhirReferenceList;
begin
  if FFormOfList = nil then
    FFormOfList := TFhirReferenceList.Create;
  result := FFormOfList;
end;

function TFhirAdministrableProductDefinition.GetHasFormOfList : boolean;
begin
  result := (FFormOfList <> nil) and (FFormOfList.count > 0);
end;

procedure TFhirAdministrableProductDefinition.SetAdministrableDoseForm(value : TFhirCodeableConcept);
begin
  FAdministrableDoseForm.free;
  FAdministrableDoseForm := value;
end;

procedure TFhirAdministrableProductDefinition.SetUnitOfPresentation(value : TFhirCodeableConcept);
begin
  FUnitOfPresentation.free;
  FUnitOfPresentation := value;
end;

function TFhirAdministrableProductDefinition.GetProducedFromList : TFhirReferenceList;
begin
  if FProducedFromList = nil then
    FProducedFromList := TFhirReferenceList.Create;
  result := FProducedFromList;
end;

function TFhirAdministrableProductDefinition.GetHasProducedFromList : boolean;
begin
  result := (FProducedFromList <> nil) and (FProducedFromList.count > 0);
end;

function TFhirAdministrableProductDefinition.GetIngredientList : TFhirCodeableConceptList;
begin
  if FIngredientList = nil then
    FIngredientList := TFhirCodeableConceptList.Create;
  result := FIngredientList;
end;

function TFhirAdministrableProductDefinition.GetHasIngredientList : boolean;
begin
  result := (FIngredientList <> nil) and (FIngredientList.count > 0);
end;

procedure TFhirAdministrableProductDefinition.SetDevice(value : TFhirReference);
begin
  FDevice.free;
  FDevice := value;
end;

function TFhirAdministrableProductDefinition.GetProperty_List : TFhirAdministrableProductDefinitionPropertyList;
begin
  if FProperty_List = nil then
    FProperty_List := TFhirAdministrableProductDefinitionPropertyList.Create;
  result := FProperty_List;
end;

function TFhirAdministrableProductDefinition.GetHasProperty_List : boolean;
begin
  result := (FProperty_List <> nil) and (FProperty_List.count > 0);
end;

function TFhirAdministrableProductDefinition.GetRouteOfAdministrationList : TFhirAdministrableProductDefinitionRouteOfAdministrationList;
begin
  if FRouteOfAdministrationList = nil then
    FRouteOfAdministrationList := TFhirAdministrableProductDefinitionRouteOfAdministrationList.Create;
  result := FRouteOfAdministrationList;
end;

function TFhirAdministrableProductDefinition.GetHasRouteOfAdministrationList : boolean;
begin
  result := (FRouteOfAdministrationList <> nil) and (FRouteOfAdministrationList.count > 0);
end;

{ TFhirAdministrableProductDefinitionListEnumerator }

constructor TFhirAdministrableProductDefinitionListEnumerator.Create(list : TFhirAdministrableProductDefinitionList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirAdministrableProductDefinitionListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirAdministrableProductDefinitionListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirAdministrableProductDefinitionListEnumerator.GetCurrent : TFhirAdministrableProductDefinition;
begin
  Result := FList[FIndex];
end;

function TFhirAdministrableProductDefinitionListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirAdministrableProductDefinitionList }

function TFhirAdministrableProductDefinitionList.AddItem(value: TFhirAdministrableProductDefinition): TFhirAdministrableProductDefinition;
begin
  assert(value.ClassName = 'TFhirAdministrableProductDefinition', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirAdministrableProductDefinition');
  add(value);
  result := value;
end;

function TFhirAdministrableProductDefinitionList.Append: TFhirAdministrableProductDefinition;
begin
  result := TFhirAdministrableProductDefinition.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirAdministrableProductDefinitionList.ClearItems;
begin
  Clear;
end;

function TFhirAdministrableProductDefinitionList.GetEnumerator : TFhirAdministrableProductDefinitionListEnumerator;
begin
  result := TFhirAdministrableProductDefinitionListEnumerator.Create(self.link);
end;

function TFhirAdministrableProductDefinitionList.Clone: TFhirAdministrableProductDefinitionList;
begin
  result := TFhirAdministrableProductDefinitionList(inherited Clone);
end;

function TFhirAdministrableProductDefinitionList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirAdministrableProductDefinitionList.GetItemN(index: Integer): TFhirAdministrableProductDefinition;
begin
  result := TFhirAdministrableProductDefinition(ObjectByIndex[index]);
end;

function TFhirAdministrableProductDefinitionList.ItemClass: TFslObjectClass;
begin
  result := TFhirAdministrableProductDefinition;
end;
function TFhirAdministrableProductDefinitionList.IndexOf(value: TFhirAdministrableProductDefinition): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirAdministrableProductDefinitionList.Insert(index: Integer): TFhirAdministrableProductDefinition;
begin
  result := TFhirAdministrableProductDefinition.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirAdministrableProductDefinitionList.InsertItem(index: Integer; value: TFhirAdministrableProductDefinition);
begin
  assert(value is TFhirAdministrableProductDefinition);
  Inherited Insert(index, value);
end;

function TFhirAdministrableProductDefinitionList.Item(index: Integer): TFhirAdministrableProductDefinition;
begin
  result := TFhirAdministrableProductDefinition(ObjectByIndex[index]);
end;

function TFhirAdministrableProductDefinitionList.Link: TFhirAdministrableProductDefinitionList;
begin
  result := TFhirAdministrableProductDefinitionList(inherited Link);
end;

procedure TFhirAdministrableProductDefinitionList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirAdministrableProductDefinitionList.SetItemByIndex(index: Integer; value: TFhirAdministrableProductDefinition);
begin
  assert(value is TFhirAdministrableProductDefinition);
  FhirAdministrableProductDefinitions[index] := value;
end;

procedure TFhirAdministrableProductDefinitionList.SetItemN(index: Integer; value: TFhirAdministrableProductDefinition);
begin
  assert(value is TFhirAdministrableProductDefinition);
  ObjectByIndex[index] := value;
end;

{$ENDIF FHIR_ADMINISTRABLEPRODUCTDEFINITION}
{$IFDEF FHIR_FORMULARYITEM}
{ TFhirFormularyItem }

constructor TFhirFormularyItem.Create;
begin
  inherited;
end;

destructor TFhirFormularyItem.Destroy;
begin
  FIdentifierList.Free;
  FCode.free;
  FStatus.free;
  inherited;
end;

procedure TFhirFormularyItem.Assign(oSource : TFslObject);
begin
  inherited;
  if (TFhirFormularyItem(oSource).FIdentifierList = nil) then
  begin
    FIdentifierList.free;
    FIdentifierList := nil;
  end
  else
  begin
    if FIdentifierList = nil then
      FIdentifierList := TFhirIdentifierList.Create;
    FIdentifierList.Assign(TFhirFormularyItem(oSource).FIdentifierList);
  end;
  code := TFhirFormularyItem(oSource).code.Clone;
  statusElement := TFhirFormularyItem(oSource).statusElement.Clone;
end;

function TFhirFormularyItem.GetResourceType : TFhirResourceType;
begin
  result := frtFormularyItem;
end;

procedure TFhirFormularyItem.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'identifier') Then
    list.addAll(self, 'identifier', FIdentifierList);
  if (child_name = 'code') Then
     list.add(self.link, 'code', FCode.Link);
  if (child_name = 'status') Then
     list.add(self.link, 'status', FStatus.Link);
end;

procedure TFhirFormularyItem.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'identifier', 'Identifier', true, TFhirIdentifier, FIdentifierList.Link));
  oList.add(TFHIRProperty.create(self, 'code', 'CodeableConcept', false, TFhirCodeableConcept, FCode.Link));
  oList.add(TFHIRProperty.create(self, 'status', 'code', false, TFhirEnum, FStatus.Link));
end;

function TFhirFormularyItem.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'identifier') then
  begin
    IdentifierList.add(propValue as TFhirIdentifier);
    result := propValue;
  end
  else if (propName = 'code') then
  begin
    Code := propValue as TFhirCodeableConcept;
    result := propValue;
  end
  else if (propName = 'status') then
  begin
    StatusElement := asEnum(SYSTEMS_TFhirFormularyItemStatusCodesEnum, CODES_TFhirFormularyItemStatusCodesEnum, propValue);
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirFormularyItem.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'identifier') then IdentifierList.insertItem(index, propValue as TFhirIdentifier)
  else inherited;
end;

function TFhirFormularyItem.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'identifier') then result := IdentifierList.new()
  else if (propName = 'code') then result := TFhirCodeableConcept.create()
  else if (propName = 'status') then result := TFhirEnum.create(SYSTEMS_TFhirFormularyItemStatusCodesEnum[FormularyItemStatusCodesNull], CODES_TFhirFormularyItemStatusCodesEnum[FormularyItemStatusCodesNull]) 
  else result := inherited createPropertyValue(propName);
end;

function TFhirFormularyItem.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'identifier') then result := 'Identifier'
  else if (propName = 'code') then result := 'CodeableConcept'
  else if (propName = 'status') then result := 'code'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirFormularyItem.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'identifier') then deletePropertyValue('identifier', IdentifierList, value)
  else if (propName = 'code') then CodeElement := nil
  else if (propName = 'status') then StatusElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirFormularyItem.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'identifier') then replacePropertyValue('identifier', IdentifierList, existing, new)
  else if (propName = 'code') then CodeElement := new as TFhirCodeableConcept
  else if (propName = 'status') then StatusElement := asEnum(SYSTEMS_TFhirFormularyItemStatusCodesEnum, CODES_TFhirFormularyItemStatusCodesEnum, new)
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirFormularyItem.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'identifier') then IdentifierList.move(source, destination)
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirFormularyItem.fhirType : string;
begin
  result := 'FormularyItem';
end;

function TFhirFormularyItem.Link : TFhirFormularyItem;
begin
  result := TFhirFormularyItem(inherited Link);
end;

function TFhirFormularyItem.Clone : TFhirFormularyItem;
begin
  result := TFhirFormularyItem(inherited Clone);
end;

function TFhirFormularyItem.equals(other : TObject) : boolean; 
var
  o : TFhirFormularyItem;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirFormularyItem)) then
    result := false
  else
  begin
    o := TFhirFormularyItem(other);
    result := compareDeep(identifierList, o.identifierList, true) and compareDeep(codeElement, o.codeElement, true) and 
      compareDeep(statusElement, o.statusElement, true);
  end;
end;

function TFhirFormularyItem.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FidentifierList) and isEmptyProp(FCode) and isEmptyProp(FStatus);
end;

procedure TFhirFormularyItem.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('identifier');
  fields.add('code');
  fields.add('status');
end;

function TFhirFormularyItem.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
  inc(result, FIdentifierList.sizeInBytes(magic));
end;

function TFhirFormularyItem.GetIdentifierList : TFhirIdentifierList;
begin
  if FIdentifierList = nil then
    FIdentifierList := TFhirIdentifierList.Create;
  result := FIdentifierList;
end;

function TFhirFormularyItem.GetHasIdentifierList : boolean;
begin
  result := (FIdentifierList <> nil) and (FIdentifierList.count > 0);
end;

procedure TFhirFormularyItem.SetCode(value : TFhirCodeableConcept);
begin
  FCode.free;
  FCode := value;
end;

procedure TFhirFormularyItem.SetStatus(value : TFhirEnum);
begin
  FStatus.free;
  FStatus := value;
end;

function TFhirFormularyItem.GetStatusST : TFhirFormularyItemStatusCodesEnum;
begin
  if FStatus = nil then
    result := TFhirFormularyItemStatusCodesEnum(0)
  else
    result := TFhirFormularyItemStatusCodesEnum(StringArrayIndexOfSensitive(CODES_TFhirFormularyItemStatusCodesEnum, FStatus.value));
end;

procedure TFhirFormularyItem.SetStatusST(value : TFhirFormularyItemStatusCodesEnum);
begin
  if ord(value) = 0 then
    StatusElement := nil
  else
    StatusElement := TFhirEnum.create(SYSTEMS_TFhirFormularyItemStatusCodesEnum[value], CODES_TFhirFormularyItemStatusCodesEnum[value]);
end;

{ TFhirFormularyItemListEnumerator }

constructor TFhirFormularyItemListEnumerator.Create(list : TFhirFormularyItemList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirFormularyItemListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirFormularyItemListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirFormularyItemListEnumerator.GetCurrent : TFhirFormularyItem;
begin
  Result := FList[FIndex];
end;

function TFhirFormularyItemListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirFormularyItemList }

function TFhirFormularyItemList.AddItem(value: TFhirFormularyItem): TFhirFormularyItem;
begin
  assert(value.ClassName = 'TFhirFormularyItem', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirFormularyItem');
  add(value);
  result := value;
end;

function TFhirFormularyItemList.Append: TFhirFormularyItem;
begin
  result := TFhirFormularyItem.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirFormularyItemList.ClearItems;
begin
  Clear;
end;

function TFhirFormularyItemList.GetEnumerator : TFhirFormularyItemListEnumerator;
begin
  result := TFhirFormularyItemListEnumerator.Create(self.link);
end;

function TFhirFormularyItemList.Clone: TFhirFormularyItemList;
begin
  result := TFhirFormularyItemList(inherited Clone);
end;

function TFhirFormularyItemList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirFormularyItemList.GetItemN(index: Integer): TFhirFormularyItem;
begin
  result := TFhirFormularyItem(ObjectByIndex[index]);
end;

function TFhirFormularyItemList.ItemClass: TFslObjectClass;
begin
  result := TFhirFormularyItem;
end;
function TFhirFormularyItemList.IndexOf(value: TFhirFormularyItem): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirFormularyItemList.Insert(index: Integer): TFhirFormularyItem;
begin
  result := TFhirFormularyItem.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirFormularyItemList.InsertItem(index: Integer; value: TFhirFormularyItem);
begin
  assert(value is TFhirFormularyItem);
  Inherited Insert(index, value);
end;

function TFhirFormularyItemList.Item(index: Integer): TFhirFormularyItem;
begin
  result := TFhirFormularyItem(ObjectByIndex[index]);
end;

function TFhirFormularyItemList.Link: TFhirFormularyItemList;
begin
  result := TFhirFormularyItemList(inherited Link);
end;

procedure TFhirFormularyItemList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirFormularyItemList.SetItemByIndex(index: Integer; value: TFhirFormularyItem);
begin
  assert(value is TFhirFormularyItem);
  FhirFormularyItems[index] := value;
end;

procedure TFhirFormularyItemList.SetItemN(index: Integer; value: TFhirFormularyItem);
begin
  assert(value is TFhirFormularyItem);
  ObjectByIndex[index] := value;
end;

{$ENDIF FHIR_FORMULARYITEM}
{$IFDEF FHIR_INGREDIENT}
{ TFhirIngredientManufacturer }

constructor TFhirIngredientManufacturer.Create;
begin
  inherited;
end;

destructor TFhirIngredientManufacturer.Destroy;
begin
  FRole.free;
  FManufacturer.free;
  inherited;
end;

procedure TFhirIngredientManufacturer.Assign(oSource : TFslObject);
begin
  inherited;
  roleElement := TFhirIngredientManufacturer(oSource).roleElement.Clone;
  manufacturer := TFhirIngredientManufacturer(oSource).manufacturer.Clone;
end;

procedure TFhirIngredientManufacturer.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'role') Then
     list.add(self.link, 'role', FRole.Link);
  if (child_name = 'manufacturer') Then
     list.add(self.link, 'manufacturer', FManufacturer.Link);
end;

procedure TFhirIngredientManufacturer.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'role', 'code', false, TFhirEnum, FRole.Link));
  oList.add(TFHIRProperty.create(self, 'manufacturer', 'Reference', false, TFhirReference, FManufacturer.Link));
end;

function TFhirIngredientManufacturer.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'role') then
  begin
    RoleElement := asEnum(SYSTEMS_TFhirIngredientManufacturerRoleEnum, CODES_TFhirIngredientManufacturerRoleEnum, propValue);
    result := propValue;
  end
  else if (propName = 'manufacturer') then
  begin
    Manufacturer := propValue as TFhirReference;
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirIngredientManufacturer.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirIngredientManufacturer.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'role') then result := TFhirEnum.create(SYSTEMS_TFhirIngredientManufacturerRoleEnum[IngredientManufacturerRoleNull], CODES_TFhirIngredientManufacturerRoleEnum[IngredientManufacturerRoleNull]) 
  else if (propName = 'manufacturer') then result := TFhirReference.create()
  else result := inherited createPropertyValue(propName);
end;

function TFhirIngredientManufacturer.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'role') then result := 'code'
  else if (propName = 'manufacturer') then result := 'Reference'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirIngredientManufacturer.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'role') then RoleElement := nil
  else if (propName = 'manufacturer') then ManufacturerElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirIngredientManufacturer.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'role') then RoleElement := asEnum(SYSTEMS_TFhirIngredientManufacturerRoleEnum, CODES_TFhirIngredientManufacturerRoleEnum, new)
  else if (propName = 'manufacturer') then ManufacturerElement := new as TFhirReference
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirIngredientManufacturer.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirIngredientManufacturer.fhirType : string;
begin
  result := 'Ingredient.manufacturer';
end;

function TFhirIngredientManufacturer.Link : TFhirIngredientManufacturer;
begin
  result := TFhirIngredientManufacturer(inherited Link);
end;

function TFhirIngredientManufacturer.Clone : TFhirIngredientManufacturer;
begin
  result := TFhirIngredientManufacturer(inherited Clone);
end;

function TFhirIngredientManufacturer.equals(other : TObject) : boolean; 
var
  o : TFhirIngredientManufacturer;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirIngredientManufacturer)) then
    result := false
  else
  begin
    o := TFhirIngredientManufacturer(other);
    result := compareDeep(roleElement, o.roleElement, true) and compareDeep(manufacturerElement, o.manufacturerElement, true);
  end;
end;

function TFhirIngredientManufacturer.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FRole) and isEmptyProp(FManufacturer);
end;

procedure TFhirIngredientManufacturer.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('role');
  fields.add('manufacturer');
end;

function TFhirIngredientManufacturer.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
end;

procedure TFhirIngredientManufacturer.SetRole(value : TFhirEnum);
begin
  FRole.free;
  FRole := value;
end;

function TFhirIngredientManufacturer.GetRoleST : TFhirIngredientManufacturerRoleEnum;
begin
  if FRole = nil then
    result := TFhirIngredientManufacturerRoleEnum(0)
  else
    result := TFhirIngredientManufacturerRoleEnum(StringArrayIndexOfSensitive(CODES_TFhirIngredientManufacturerRoleEnum, FRole.value));
end;

procedure TFhirIngredientManufacturer.SetRoleST(value : TFhirIngredientManufacturerRoleEnum);
begin
  if ord(value) = 0 then
    RoleElement := nil
  else
    RoleElement := TFhirEnum.create(SYSTEMS_TFhirIngredientManufacturerRoleEnum[value], CODES_TFhirIngredientManufacturerRoleEnum[value]);
end;

procedure TFhirIngredientManufacturer.SetManufacturer(value : TFhirReference);
begin
  FManufacturer.free;
  FManufacturer := value;
end;

{ TFhirIngredientManufacturerListEnumerator }

constructor TFhirIngredientManufacturerListEnumerator.Create(list : TFhirIngredientManufacturerList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirIngredientManufacturerListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirIngredientManufacturerListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirIngredientManufacturerListEnumerator.GetCurrent : TFhirIngredientManufacturer;
begin
  Result := FList[FIndex];
end;

function TFhirIngredientManufacturerListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirIngredientManufacturerList }

function TFhirIngredientManufacturerList.AddItem(value: TFhirIngredientManufacturer): TFhirIngredientManufacturer;
begin
  assert(value.ClassName = 'TFhirIngredientManufacturer', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirIngredientManufacturer');
  add(value);
  result := value;
end;

function TFhirIngredientManufacturerList.Append: TFhirIngredientManufacturer;
begin
  result := TFhirIngredientManufacturer.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirIngredientManufacturerList.ClearItems;
begin
  Clear;
end;

function TFhirIngredientManufacturerList.GetEnumerator : TFhirIngredientManufacturerListEnumerator;
begin
  result := TFhirIngredientManufacturerListEnumerator.Create(self.link);
end;

function TFhirIngredientManufacturerList.Clone: TFhirIngredientManufacturerList;
begin
  result := TFhirIngredientManufacturerList(inherited Clone);
end;

function TFhirIngredientManufacturerList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirIngredientManufacturerList.GetItemN(index: Integer): TFhirIngredientManufacturer;
begin
  result := TFhirIngredientManufacturer(ObjectByIndex[index]);
end;

function TFhirIngredientManufacturerList.ItemClass: TFslObjectClass;
begin
  result := TFhirIngredientManufacturer;
end;
function TFhirIngredientManufacturerList.IndexOf(value: TFhirIngredientManufacturer): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirIngredientManufacturerList.Insert(index: Integer): TFhirIngredientManufacturer;
begin
  result := TFhirIngredientManufacturer.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirIngredientManufacturerList.InsertItem(index: Integer; value: TFhirIngredientManufacturer);
begin
  assert(value is TFhirIngredientManufacturer);
  Inherited Insert(index, value);
end;

function TFhirIngredientManufacturerList.Item(index: Integer): TFhirIngredientManufacturer;
begin
  result := TFhirIngredientManufacturer(ObjectByIndex[index]);
end;

function TFhirIngredientManufacturerList.Link: TFhirIngredientManufacturerList;
begin
  result := TFhirIngredientManufacturerList(inherited Link);
end;

procedure TFhirIngredientManufacturerList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirIngredientManufacturerList.SetItemByIndex(index: Integer; value: TFhirIngredientManufacturer);
begin
  assert(value is TFhirIngredientManufacturer);
  FhirIngredientManufacturers[index] := value;
end;

procedure TFhirIngredientManufacturerList.SetItemN(index: Integer; value: TFhirIngredientManufacturer);
begin
  assert(value is TFhirIngredientManufacturer);
  ObjectByIndex[index] := value;
end;

{ TFhirIngredientSubstance }

constructor TFhirIngredientSubstance.Create;
begin
  inherited;
end;

destructor TFhirIngredientSubstance.Destroy;
begin
  FCode.free;
  FStrengthList.Free;
  inherited;
end;

procedure TFhirIngredientSubstance.Assign(oSource : TFslObject);
begin
  inherited;
  code := TFhirIngredientSubstance(oSource).code.Clone;
  if (TFhirIngredientSubstance(oSource).FStrengthList = nil) then
  begin
    FStrengthList.free;
    FStrengthList := nil;
  end
  else
  begin
    if FStrengthList = nil then
      FStrengthList := TFhirIngredientSubstanceStrengthList.Create;
    FStrengthList.Assign(TFhirIngredientSubstance(oSource).FStrengthList);
  end;
end;

procedure TFhirIngredientSubstance.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'code') Then
     list.add(self.link, 'code', FCode.Link);
  if (child_name = 'strength') Then
    list.addAll(self, 'strength', FStrengthList);
end;

procedure TFhirIngredientSubstance.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'code', 'CodeableReference', false, TFhirCodeableReference, FCode.Link));
  oList.add(TFHIRProperty.create(self, 'strength', 'BackboneElement', true, TFhirIngredientSubstanceStrength, FStrengthList.Link));
end;

function TFhirIngredientSubstance.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'code') then
  begin
    Code := propValue as TFhirCodeableReference;
    result := propValue;
  end
  else if (propName = 'strength') then
  begin
    StrengthList.add(propValue as TFhirIngredientSubstanceStrength);
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirIngredientSubstance.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'strength') then StrengthList.insertItem(index, propValue as TFhirIngredientSubstanceStrength)
  else inherited;
end;

function TFhirIngredientSubstance.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'code') then result := TFhirCodeableReference.create()
  else if (propName = 'strength') then result := StrengthList.new()
  else result := inherited createPropertyValue(propName);
end;

function TFhirIngredientSubstance.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'code') then result := 'CodeableReference'
  else if (propName = 'strength') then result := 'BackboneElement'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirIngredientSubstance.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'code') then CodeElement := nil
  else if (propName = 'strength') then deletePropertyValue('strength', StrengthList, value)
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirIngredientSubstance.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'code') then CodeElement := new as TFhirCodeableReference
  else if (propName = 'strength') then replacePropertyValue('strength', StrengthList, existing, new)
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirIngredientSubstance.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'strength') then StrengthList.move(source, destination)
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirIngredientSubstance.fhirType : string;
begin
  result := 'Ingredient.substance';
end;

function TFhirIngredientSubstance.Link : TFhirIngredientSubstance;
begin
  result := TFhirIngredientSubstance(inherited Link);
end;

function TFhirIngredientSubstance.Clone : TFhirIngredientSubstance;
begin
  result := TFhirIngredientSubstance(inherited Clone);
end;

function TFhirIngredientSubstance.equals(other : TObject) : boolean; 
var
  o : TFhirIngredientSubstance;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirIngredientSubstance)) then
    result := false
  else
  begin
    o := TFhirIngredientSubstance(other);
    result := compareDeep(codeElement, o.codeElement, true) and compareDeep(strengthList, o.strengthList, true);
  end;
end;

function TFhirIngredientSubstance.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FCode) and isEmptyProp(FstrengthList);
end;

procedure TFhirIngredientSubstance.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('code');
  fields.add('strength');
end;

function TFhirIngredientSubstance.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
  inc(result, FStrengthList.sizeInBytes(magic));
end;

procedure TFhirIngredientSubstance.SetCode(value : TFhirCodeableReference);
begin
  FCode.free;
  FCode := value;
end;

function TFhirIngredientSubstance.GetStrengthList : TFhirIngredientSubstanceStrengthList;
begin
  if FStrengthList = nil then
    FStrengthList := TFhirIngredientSubstanceStrengthList.Create;
  result := FStrengthList;
end;

function TFhirIngredientSubstance.GetHasStrengthList : boolean;
begin
  result := (FStrengthList <> nil) and (FStrengthList.count > 0);
end;

{ TFhirIngredientSubstanceListEnumerator }

constructor TFhirIngredientSubstanceListEnumerator.Create(list : TFhirIngredientSubstanceList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirIngredientSubstanceListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirIngredientSubstanceListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirIngredientSubstanceListEnumerator.GetCurrent : TFhirIngredientSubstance;
begin
  Result := FList[FIndex];
end;

function TFhirIngredientSubstanceListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirIngredientSubstanceList }

function TFhirIngredientSubstanceList.AddItem(value: TFhirIngredientSubstance): TFhirIngredientSubstance;
begin
  assert(value.ClassName = 'TFhirIngredientSubstance', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirIngredientSubstance');
  add(value);
  result := value;
end;

function TFhirIngredientSubstanceList.Append: TFhirIngredientSubstance;
begin
  result := TFhirIngredientSubstance.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirIngredientSubstanceList.ClearItems;
begin
  Clear;
end;

function TFhirIngredientSubstanceList.GetEnumerator : TFhirIngredientSubstanceListEnumerator;
begin
  result := TFhirIngredientSubstanceListEnumerator.Create(self.link);
end;

function TFhirIngredientSubstanceList.Clone: TFhirIngredientSubstanceList;
begin
  result := TFhirIngredientSubstanceList(inherited Clone);
end;

function TFhirIngredientSubstanceList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirIngredientSubstanceList.GetItemN(index: Integer): TFhirIngredientSubstance;
begin
  result := TFhirIngredientSubstance(ObjectByIndex[index]);
end;

function TFhirIngredientSubstanceList.ItemClass: TFslObjectClass;
begin
  result := TFhirIngredientSubstance;
end;
function TFhirIngredientSubstanceList.IndexOf(value: TFhirIngredientSubstance): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirIngredientSubstanceList.Insert(index: Integer): TFhirIngredientSubstance;
begin
  result := TFhirIngredientSubstance.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirIngredientSubstanceList.InsertItem(index: Integer; value: TFhirIngredientSubstance);
begin
  assert(value is TFhirIngredientSubstance);
  Inherited Insert(index, value);
end;

function TFhirIngredientSubstanceList.Item(index: Integer): TFhirIngredientSubstance;
begin
  result := TFhirIngredientSubstance(ObjectByIndex[index]);
end;

function TFhirIngredientSubstanceList.Link: TFhirIngredientSubstanceList;
begin
  result := TFhirIngredientSubstanceList(inherited Link);
end;

procedure TFhirIngredientSubstanceList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirIngredientSubstanceList.SetItemByIndex(index: Integer; value: TFhirIngredientSubstance);
begin
  assert(value is TFhirIngredientSubstance);
  FhirIngredientSubstances[index] := value;
end;

procedure TFhirIngredientSubstanceList.SetItemN(index: Integer; value: TFhirIngredientSubstance);
begin
  assert(value is TFhirIngredientSubstance);
  ObjectByIndex[index] := value;
end;

{ TFhirIngredientSubstanceStrength }

constructor TFhirIngredientSubstanceStrength.Create;
begin
  inherited;
end;

destructor TFhirIngredientSubstanceStrength.Destroy;
begin
  FPresentation.free;
  FTextPresentation.free;
  FConcentration.free;
  FTextConcentration.free;
  FBasis.free;
  FMeasurementPoint.free;
  FCountryList.Free;
  FReferenceStrengthList.Free;
  inherited;
end;

procedure TFhirIngredientSubstanceStrength.Assign(oSource : TFslObject);
begin
  inherited;
  presentation := TFhirIngredientSubstanceStrength(oSource).presentation.Clone;
  textPresentationElement := TFhirIngredientSubstanceStrength(oSource).textPresentationElement.Clone;
  concentration := TFhirIngredientSubstanceStrength(oSource).concentration.Clone;
  textConcentrationElement := TFhirIngredientSubstanceStrength(oSource).textConcentrationElement.Clone;
  basis := TFhirIngredientSubstanceStrength(oSource).basis.Clone;
  measurementPointElement := TFhirIngredientSubstanceStrength(oSource).measurementPointElement.Clone;
  if (TFhirIngredientSubstanceStrength(oSource).FCountryList = nil) then
  begin
    FCountryList.free;
    FCountryList := nil;
  end
  else
  begin
    if FCountryList = nil then
      FCountryList := TFhirCodeableConceptList.Create;
    FCountryList.Assign(TFhirIngredientSubstanceStrength(oSource).FCountryList);
  end;
  if (TFhirIngredientSubstanceStrength(oSource).FReferenceStrengthList = nil) then
  begin
    FReferenceStrengthList.free;
    FReferenceStrengthList := nil;
  end
  else
  begin
    if FReferenceStrengthList = nil then
      FReferenceStrengthList := TFhirIngredientSubstanceStrengthReferenceStrengthList.Create;
    FReferenceStrengthList.Assign(TFhirIngredientSubstanceStrength(oSource).FReferenceStrengthList);
  end;
end;

procedure TFhirIngredientSubstanceStrength.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'presentation[x]') or (child_name = 'presentation') Then
     list.add(self.link, 'presentation[x]', FPresentation.Link);
  if (child_name = 'textPresentation') Then
     list.add(self.link, 'textPresentation', FTextPresentation.Link);
  if (child_name = 'concentration[x]') or (child_name = 'concentration') Then
     list.add(self.link, 'concentration[x]', FConcentration.Link);
  if (child_name = 'textConcentration') Then
     list.add(self.link, 'textConcentration', FTextConcentration.Link);
  if (child_name = 'basis') Then
     list.add(self.link, 'basis', FBasis.Link);
  if (child_name = 'measurementPoint') Then
     list.add(self.link, 'measurementPoint', FMeasurementPoint.Link);
  if (child_name = 'country') Then
    list.addAll(self, 'country', FCountryList);
  if (child_name = 'referenceStrength') Then
    list.addAll(self, 'referenceStrength', FReferenceStrengthList);
end;

procedure TFhirIngredientSubstanceStrength.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'presentation[x]', 'Ratio|RatioRange|CodeableConcept|Quantity', false, TFhirDataType, FPresentation.Link));
  oList.add(TFHIRProperty.create(self, 'textPresentation', 'string', false, TFhirString, FTextPresentation.Link));
  oList.add(TFHIRProperty.create(self, 'concentration[x]', 'Ratio|RatioRange|CodeableConcept|Quantity', false, TFhirDataType, FConcentration.Link));
  oList.add(TFHIRProperty.create(self, 'textConcentration', 'string', false, TFhirString, FTextConcentration.Link));
  oList.add(TFHIRProperty.create(self, 'basis', 'CodeableConcept', false, TFhirCodeableConcept, FBasis.Link));
  oList.add(TFHIRProperty.create(self, 'measurementPoint', 'string', false, TFhirString, FMeasurementPoint.Link));
  oList.add(TFHIRProperty.create(self, 'country', 'CodeableConcept', true, TFhirCodeableConcept, FCountryList.Link));
  oList.add(TFHIRProperty.create(self, 'referenceStrength', 'BackboneElement', true, TFhirIngredientSubstanceStrengthReferenceStrength, FReferenceStrengthList.Link));
end;

function TFhirIngredientSubstanceStrength.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (isMatchingName(propName, 'presentation', ['Ratio', 'RatioRange', 'CodeableConcept', 'Quantity'])) then
  begin
    Presentation := propValue as TFhirDataType;
    result := propValue;
  end
  else if (propName = 'textPresentation') then
  begin
    TextPresentationElement := asString(propValue);
    result := propValue;
  end
  else if (isMatchingName(propName, 'concentration', ['Ratio', 'RatioRange', 'CodeableConcept', 'Quantity'])) then
  begin
    Concentration := propValue as TFhirDataType;
    result := propValue;
  end
  else if (propName = 'textConcentration') then
  begin
    TextConcentrationElement := asString(propValue);
    result := propValue;
  end
  else if (propName = 'basis') then
  begin
    Basis := propValue as TFhirCodeableConcept;
    result := propValue;
  end
  else if (propName = 'measurementPoint') then
  begin
    MeasurementPointElement := asString(propValue);
    result := propValue;
  end
  else if (propName = 'country') then
  begin
    CountryList.add(propValue as TFhirCodeableConcept);
    result := propValue;
  end
  else if (propName = 'referenceStrength') then
  begin
    ReferenceStrengthList.add(propValue as TFhirIngredientSubstanceStrengthReferenceStrength);
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirIngredientSubstanceStrength.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'country') then CountryList.insertItem(index, propValue as TFhirCodeableConcept)
  else if (propName = 'referenceStrength') then ReferenceStrengthList.insertItem(index, propValue as TFhirIngredientSubstanceStrengthReferenceStrength)
  else inherited;
end;

function TFhirIngredientSubstanceStrength.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (isMatchingName(propName, 'presentation', ['Ratio', 'RatioRange', 'CodeableConcept', 'Quantity'])) then raise EFHIRException.create('Cannot make property Presentation')
  else if (propName = 'textPresentation') then result := TFhirString.create()
  else if (isMatchingName(propName, 'concentration', ['Ratio', 'RatioRange', 'CodeableConcept', 'Quantity'])) then raise EFHIRException.create('Cannot make property Concentration')
  else if (propName = 'textConcentration') then result := TFhirString.create()
  else if (propName = 'basis') then result := TFhirCodeableConcept.create()
  else if (propName = 'measurementPoint') then result := TFhirString.create()
  else if (propName = 'country') then result := CountryList.new()
  else if (propName = 'referenceStrength') then result := ReferenceStrengthList.new()
  else result := inherited createPropertyValue(propName);
end;

function TFhirIngredientSubstanceStrength.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'presentation[x]') then result := 'Ratio|RatioRange|CodeableConcept|Quantity'
  else if (propName = 'textPresentation') then result := 'string'
  else if (propName = 'concentration[x]') then result := 'Ratio|RatioRange|CodeableConcept|Quantity'
  else if (propName = 'textConcentration') then result := 'string'
  else if (propName = 'basis') then result := 'CodeableConcept'
  else if (propName = 'measurementPoint') then result := 'string'
  else if (propName = 'country') then result := 'CodeableConcept'
  else if (propName = 'referenceStrength') then result := 'BackboneElement'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirIngredientSubstanceStrength.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (isMatchingName(propName, 'presentation', ['Ratio', 'RatioRange', 'CodeableConcept', 'Quantity'])) then PresentationElement := nil
  else if (propName = 'textPresentation') then TextPresentationElement := nil
  else if (isMatchingName(propName, 'concentration', ['Ratio', 'RatioRange', 'CodeableConcept', 'Quantity'])) then ConcentrationElement := nil
  else if (propName = 'textConcentration') then TextConcentrationElement := nil
  else if (propName = 'basis') then BasisElement := nil
  else if (propName = 'measurementPoint') then MeasurementPointElement := nil
  else if (propName = 'country') then deletePropertyValue('country', CountryList, value)
  else if (propName = 'referenceStrength') then deletePropertyValue('referenceStrength', ReferenceStrengthList, value)
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirIngredientSubstanceStrength.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (isMatchingName(propName, 'presentation', ['Ratio', 'RatioRange', 'CodeableConcept', 'Quantity'])) then PresentationElement := new as TFhirDataType
  else if (propName = 'textPresentation') then TextPresentationElement := asString(new)
  else if (isMatchingName(propName, 'concentration', ['Ratio', 'RatioRange', 'CodeableConcept', 'Quantity'])) then ConcentrationElement := new as TFhirDataType
  else if (propName = 'textConcentration') then TextConcentrationElement := asString(new)
  else if (propName = 'basis') then BasisElement := new as TFhirCodeableConcept
  else if (propName = 'measurementPoint') then MeasurementPointElement := asString(new)
  else if (propName = 'country') then replacePropertyValue('country', CountryList, existing, new)
  else if (propName = 'referenceStrength') then replacePropertyValue('referenceStrength', ReferenceStrengthList, existing, new)
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirIngredientSubstanceStrength.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'country') then CountryList.move(source, destination)
  else if (propName = 'referenceStrength') then ReferenceStrengthList.move(source, destination)
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirIngredientSubstanceStrength.fhirType : string;
begin
  result := 'Ingredient.substance.strength';
end;

function TFhirIngredientSubstanceStrength.Link : TFhirIngredientSubstanceStrength;
begin
  result := TFhirIngredientSubstanceStrength(inherited Link);
end;

function TFhirIngredientSubstanceStrength.Clone : TFhirIngredientSubstanceStrength;
begin
  result := TFhirIngredientSubstanceStrength(inherited Clone);
end;

function TFhirIngredientSubstanceStrength.equals(other : TObject) : boolean; 
var
  o : TFhirIngredientSubstanceStrength;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirIngredientSubstanceStrength)) then
    result := false
  else
  begin
    o := TFhirIngredientSubstanceStrength(other);
    result := compareDeep(presentationElement, o.presentationElement, true) and 
      compareDeep(textPresentationElement, o.textPresentationElement, true) and compareDeep(concentrationElement, o.concentrationElement, true) and 
      compareDeep(textConcentrationElement, o.textConcentrationElement, true) and compareDeep(basisElement, o.basisElement, true) and 
      compareDeep(measurementPointElement, o.measurementPointElement, true) and compareDeep(countryList, o.countryList, true) and 
      compareDeep(referenceStrengthList, o.referenceStrengthList, true);
  end;
end;

function TFhirIngredientSubstanceStrength.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FPresentation) and isEmptyProp(FTextPresentation) and isEmptyProp(FConcentration) and isEmptyProp(FTextConcentration) and isEmptyProp(FBasis) and isEmptyProp(FMeasurementPoint) and isEmptyProp(FcountryList) and isEmptyProp(FreferenceStrengthList);
end;

procedure TFhirIngredientSubstanceStrength.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('presentation[x]');
  fields.add('textPresentation');
  fields.add('concentration[x]');
  fields.add('textConcentration');
  fields.add('basis');
  fields.add('measurementPoint');
  fields.add('country');
  fields.add('referenceStrength');
end;

function TFhirIngredientSubstanceStrength.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
  inc(result, FCountryList.sizeInBytes(magic));
  inc(result, FReferenceStrengthList.sizeInBytes(magic));
end;

procedure TFhirIngredientSubstanceStrength.SetPresentation(value : TFhirDataType);
begin
  FPresentation.free;
  FPresentation := value;
end;

procedure TFhirIngredientSubstanceStrength.SetTextPresentation(value : TFhirString);
begin
  FTextPresentation.free;
  FTextPresentation := value;
end;

function TFhirIngredientSubstanceStrength.GetTextPresentationST : String;
begin
  if FTextPresentation = nil then
    result := ''
  else
    result := FTextPresentation.value;
end;

procedure TFhirIngredientSubstanceStrength.SetTextPresentationST(value : String);
begin
  if value <> '' then
  begin
    if FTextPresentation = nil then
      FTextPresentation := TFhirString.create;
    FTextPresentation.value := value
  end
  else if FTextPresentation <> nil then
    FTextPresentation.value := '';
end;

procedure TFhirIngredientSubstanceStrength.SetConcentration(value : TFhirDataType);
begin
  FConcentration.free;
  FConcentration := value;
end;

procedure TFhirIngredientSubstanceStrength.SetTextConcentration(value : TFhirString);
begin
  FTextConcentration.free;
  FTextConcentration := value;
end;

function TFhirIngredientSubstanceStrength.GetTextConcentrationST : String;
begin
  if FTextConcentration = nil then
    result := ''
  else
    result := FTextConcentration.value;
end;

procedure TFhirIngredientSubstanceStrength.SetTextConcentrationST(value : String);
begin
  if value <> '' then
  begin
    if FTextConcentration = nil then
      FTextConcentration := TFhirString.create;
    FTextConcentration.value := value
  end
  else if FTextConcentration <> nil then
    FTextConcentration.value := '';
end;

procedure TFhirIngredientSubstanceStrength.SetBasis(value : TFhirCodeableConcept);
begin
  FBasis.free;
  FBasis := value;
end;

procedure TFhirIngredientSubstanceStrength.SetMeasurementPoint(value : TFhirString);
begin
  FMeasurementPoint.free;
  FMeasurementPoint := value;
end;

function TFhirIngredientSubstanceStrength.GetMeasurementPointST : String;
begin
  if FMeasurementPoint = nil then
    result := ''
  else
    result := FMeasurementPoint.value;
end;

procedure TFhirIngredientSubstanceStrength.SetMeasurementPointST(value : String);
begin
  if value <> '' then
  begin
    if FMeasurementPoint = nil then
      FMeasurementPoint := TFhirString.create;
    FMeasurementPoint.value := value
  end
  else if FMeasurementPoint <> nil then
    FMeasurementPoint.value := '';
end;

function TFhirIngredientSubstanceStrength.GetCountryList : TFhirCodeableConceptList;
begin
  if FCountryList = nil then
    FCountryList := TFhirCodeableConceptList.Create;
  result := FCountryList;
end;

function TFhirIngredientSubstanceStrength.GetHasCountryList : boolean;
begin
  result := (FCountryList <> nil) and (FCountryList.count > 0);
end;

function TFhirIngredientSubstanceStrength.GetReferenceStrengthList : TFhirIngredientSubstanceStrengthReferenceStrengthList;
begin
  if FReferenceStrengthList = nil then
    FReferenceStrengthList := TFhirIngredientSubstanceStrengthReferenceStrengthList.Create;
  result := FReferenceStrengthList;
end;

function TFhirIngredientSubstanceStrength.GetHasReferenceStrengthList : boolean;
begin
  result := (FReferenceStrengthList <> nil) and (FReferenceStrengthList.count > 0);
end;

{ TFhirIngredientSubstanceStrengthListEnumerator }

constructor TFhirIngredientSubstanceStrengthListEnumerator.Create(list : TFhirIngredientSubstanceStrengthList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirIngredientSubstanceStrengthListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirIngredientSubstanceStrengthListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirIngredientSubstanceStrengthListEnumerator.GetCurrent : TFhirIngredientSubstanceStrength;
begin
  Result := FList[FIndex];
end;

function TFhirIngredientSubstanceStrengthListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirIngredientSubstanceStrengthList }

function TFhirIngredientSubstanceStrengthList.AddItem(value: TFhirIngredientSubstanceStrength): TFhirIngredientSubstanceStrength;
begin
  assert(value.ClassName = 'TFhirIngredientSubstanceStrength', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirIngredientSubstanceStrength');
  add(value);
  result := value;
end;

function TFhirIngredientSubstanceStrengthList.Append: TFhirIngredientSubstanceStrength;
begin
  result := TFhirIngredientSubstanceStrength.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirIngredientSubstanceStrengthList.ClearItems;
begin
  Clear;
end;

function TFhirIngredientSubstanceStrengthList.GetEnumerator : TFhirIngredientSubstanceStrengthListEnumerator;
begin
  result := TFhirIngredientSubstanceStrengthListEnumerator.Create(self.link);
end;

function TFhirIngredientSubstanceStrengthList.Clone: TFhirIngredientSubstanceStrengthList;
begin
  result := TFhirIngredientSubstanceStrengthList(inherited Clone);
end;

function TFhirIngredientSubstanceStrengthList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirIngredientSubstanceStrengthList.GetItemN(index: Integer): TFhirIngredientSubstanceStrength;
begin
  result := TFhirIngredientSubstanceStrength(ObjectByIndex[index]);
end;

function TFhirIngredientSubstanceStrengthList.ItemClass: TFslObjectClass;
begin
  result := TFhirIngredientSubstanceStrength;
end;
function TFhirIngredientSubstanceStrengthList.IndexOf(value: TFhirIngredientSubstanceStrength): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirIngredientSubstanceStrengthList.Insert(index: Integer): TFhirIngredientSubstanceStrength;
begin
  result := TFhirIngredientSubstanceStrength.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirIngredientSubstanceStrengthList.InsertItem(index: Integer; value: TFhirIngredientSubstanceStrength);
begin
  assert(value is TFhirIngredientSubstanceStrength);
  Inherited Insert(index, value);
end;

function TFhirIngredientSubstanceStrengthList.Item(index: Integer): TFhirIngredientSubstanceStrength;
begin
  result := TFhirIngredientSubstanceStrength(ObjectByIndex[index]);
end;

function TFhirIngredientSubstanceStrengthList.Link: TFhirIngredientSubstanceStrengthList;
begin
  result := TFhirIngredientSubstanceStrengthList(inherited Link);
end;

procedure TFhirIngredientSubstanceStrengthList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirIngredientSubstanceStrengthList.SetItemByIndex(index: Integer; value: TFhirIngredientSubstanceStrength);
begin
  assert(value is TFhirIngredientSubstanceStrength);
  FhirIngredientSubstanceStrengths[index] := value;
end;

procedure TFhirIngredientSubstanceStrengthList.SetItemN(index: Integer; value: TFhirIngredientSubstanceStrength);
begin
  assert(value is TFhirIngredientSubstanceStrength);
  ObjectByIndex[index] := value;
end;

{ TFhirIngredientSubstanceStrengthReferenceStrength }

constructor TFhirIngredientSubstanceStrengthReferenceStrength.Create;
begin
  inherited;
end;

destructor TFhirIngredientSubstanceStrengthReferenceStrength.Destroy;
begin
  FSubstance.free;
  FStrength.free;
  FMeasurementPoint.free;
  FCountryList.Free;
  inherited;
end;

procedure TFhirIngredientSubstanceStrengthReferenceStrength.Assign(oSource : TFslObject);
begin
  inherited;
  substance := TFhirIngredientSubstanceStrengthReferenceStrength(oSource).substance.Clone;
  strength := TFhirIngredientSubstanceStrengthReferenceStrength(oSource).strength.Clone;
  measurementPointElement := TFhirIngredientSubstanceStrengthReferenceStrength(oSource).measurementPointElement.Clone;
  if (TFhirIngredientSubstanceStrengthReferenceStrength(oSource).FCountryList = nil) then
  begin
    FCountryList.free;
    FCountryList := nil;
  end
  else
  begin
    if FCountryList = nil then
      FCountryList := TFhirCodeableConceptList.Create;
    FCountryList.Assign(TFhirIngredientSubstanceStrengthReferenceStrength(oSource).FCountryList);
  end;
end;

procedure TFhirIngredientSubstanceStrengthReferenceStrength.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'substance') Then
     list.add(self.link, 'substance', FSubstance.Link);
  if (child_name = 'strength[x]') or (child_name = 'strength') Then
     list.add(self.link, 'strength[x]', FStrength.Link);
  if (child_name = 'measurementPoint') Then
     list.add(self.link, 'measurementPoint', FMeasurementPoint.Link);
  if (child_name = 'country') Then
    list.addAll(self, 'country', FCountryList);
end;

procedure TFhirIngredientSubstanceStrengthReferenceStrength.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'substance', 'CodeableReference', false, TFhirCodeableReference, FSubstance.Link));
  oList.add(TFHIRProperty.create(self, 'strength[x]', 'Ratio|RatioRange|Quantity', false, TFhirDataType, FStrength.Link));
  oList.add(TFHIRProperty.create(self, 'measurementPoint', 'string', false, TFhirString, FMeasurementPoint.Link));
  oList.add(TFHIRProperty.create(self, 'country', 'CodeableConcept', true, TFhirCodeableConcept, FCountryList.Link));
end;

function TFhirIngredientSubstanceStrengthReferenceStrength.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'substance') then
  begin
    Substance := propValue as TFhirCodeableReference;
    result := propValue;
  end
  else if (isMatchingName(propName, 'strength', ['Ratio', 'RatioRange', 'Quantity'])) then
  begin
    Strength := propValue as TFhirDataType;
    result := propValue;
  end
  else if (propName = 'measurementPoint') then
  begin
    MeasurementPointElement := asString(propValue);
    result := propValue;
  end
  else if (propName = 'country') then
  begin
    CountryList.add(propValue as TFhirCodeableConcept);
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirIngredientSubstanceStrengthReferenceStrength.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'country') then CountryList.insertItem(index, propValue as TFhirCodeableConcept)
  else inherited;
end;

function TFhirIngredientSubstanceStrengthReferenceStrength.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'substance') then result := TFhirCodeableReference.create()
  else if (isMatchingName(propName, 'strength', ['Ratio', 'RatioRange', 'Quantity'])) then raise EFHIRException.create('Cannot make property Strength')
  else if (propName = 'measurementPoint') then result := TFhirString.create()
  else if (propName = 'country') then result := CountryList.new()
  else result := inherited createPropertyValue(propName);
end;

function TFhirIngredientSubstanceStrengthReferenceStrength.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'substance') then result := 'CodeableReference'
  else if (propName = 'strength[x]') then result := 'Ratio|RatioRange|Quantity'
  else if (propName = 'measurementPoint') then result := 'string'
  else if (propName = 'country') then result := 'CodeableConcept'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirIngredientSubstanceStrengthReferenceStrength.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'substance') then SubstanceElement := nil
  else if (isMatchingName(propName, 'strength', ['Ratio', 'RatioRange', 'Quantity'])) then StrengthElement := nil
  else if (propName = 'measurementPoint') then MeasurementPointElement := nil
  else if (propName = 'country') then deletePropertyValue('country', CountryList, value)
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirIngredientSubstanceStrengthReferenceStrength.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'substance') then SubstanceElement := new as TFhirCodeableReference
  else if (isMatchingName(propName, 'strength', ['Ratio', 'RatioRange', 'Quantity'])) then StrengthElement := new as TFhirDataType
  else if (propName = 'measurementPoint') then MeasurementPointElement := asString(new)
  else if (propName = 'country') then replacePropertyValue('country', CountryList, existing, new)
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirIngredientSubstanceStrengthReferenceStrength.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'country') then CountryList.move(source, destination)
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirIngredientSubstanceStrengthReferenceStrength.fhirType : string;
begin
  result := 'Ingredient.substance.strength.referenceStrength';
end;

function TFhirIngredientSubstanceStrengthReferenceStrength.Link : TFhirIngredientSubstanceStrengthReferenceStrength;
begin
  result := TFhirIngredientSubstanceStrengthReferenceStrength(inherited Link);
end;

function TFhirIngredientSubstanceStrengthReferenceStrength.Clone : TFhirIngredientSubstanceStrengthReferenceStrength;
begin
  result := TFhirIngredientSubstanceStrengthReferenceStrength(inherited Clone);
end;

function TFhirIngredientSubstanceStrengthReferenceStrength.equals(other : TObject) : boolean; 
var
  o : TFhirIngredientSubstanceStrengthReferenceStrength;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirIngredientSubstanceStrengthReferenceStrength)) then
    result := false
  else
  begin
    o := TFhirIngredientSubstanceStrengthReferenceStrength(other);
    result := compareDeep(substanceElement, o.substanceElement, true) and compareDeep(strengthElement, o.strengthElement, true) and 
      compareDeep(measurementPointElement, o.measurementPointElement, true) and compareDeep(countryList, o.countryList, true);
  end;
end;

function TFhirIngredientSubstanceStrengthReferenceStrength.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FSubstance) and isEmptyProp(FStrength) and isEmptyProp(FMeasurementPoint) and isEmptyProp(FcountryList);
end;

procedure TFhirIngredientSubstanceStrengthReferenceStrength.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('substance');
  fields.add('strength[x]');
  fields.add('measurementPoint');
  fields.add('country');
end;

function TFhirIngredientSubstanceStrengthReferenceStrength.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
  inc(result, FCountryList.sizeInBytes(magic));
end;

procedure TFhirIngredientSubstanceStrengthReferenceStrength.SetSubstance(value : TFhirCodeableReference);
begin
  FSubstance.free;
  FSubstance := value;
end;

procedure TFhirIngredientSubstanceStrengthReferenceStrength.SetStrength(value : TFhirDataType);
begin
  FStrength.free;
  FStrength := value;
end;

procedure TFhirIngredientSubstanceStrengthReferenceStrength.SetMeasurementPoint(value : TFhirString);
begin
  FMeasurementPoint.free;
  FMeasurementPoint := value;
end;

function TFhirIngredientSubstanceStrengthReferenceStrength.GetMeasurementPointST : String;
begin
  if FMeasurementPoint = nil then
    result := ''
  else
    result := FMeasurementPoint.value;
end;

procedure TFhirIngredientSubstanceStrengthReferenceStrength.SetMeasurementPointST(value : String);
begin
  if value <> '' then
  begin
    if FMeasurementPoint = nil then
      FMeasurementPoint := TFhirString.create;
    FMeasurementPoint.value := value
  end
  else if FMeasurementPoint <> nil then
    FMeasurementPoint.value := '';
end;

function TFhirIngredientSubstanceStrengthReferenceStrength.GetCountryList : TFhirCodeableConceptList;
begin
  if FCountryList = nil then
    FCountryList := TFhirCodeableConceptList.Create;
  result := FCountryList;
end;

function TFhirIngredientSubstanceStrengthReferenceStrength.GetHasCountryList : boolean;
begin
  result := (FCountryList <> nil) and (FCountryList.count > 0);
end;

{ TFhirIngredientSubstanceStrengthReferenceStrengthListEnumerator }

constructor TFhirIngredientSubstanceStrengthReferenceStrengthListEnumerator.Create(list : TFhirIngredientSubstanceStrengthReferenceStrengthList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirIngredientSubstanceStrengthReferenceStrengthListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirIngredientSubstanceStrengthReferenceStrengthListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirIngredientSubstanceStrengthReferenceStrengthListEnumerator.GetCurrent : TFhirIngredientSubstanceStrengthReferenceStrength;
begin
  Result := FList[FIndex];
end;

function TFhirIngredientSubstanceStrengthReferenceStrengthListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirIngredientSubstanceStrengthReferenceStrengthList }

function TFhirIngredientSubstanceStrengthReferenceStrengthList.AddItem(value: TFhirIngredientSubstanceStrengthReferenceStrength): TFhirIngredientSubstanceStrengthReferenceStrength;
begin
  assert(value.ClassName = 'TFhirIngredientSubstanceStrengthReferenceStrength', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirIngredientSubstanceStrengthReferenceStrength');
  add(value);
  result := value;
end;

function TFhirIngredientSubstanceStrengthReferenceStrengthList.Append: TFhirIngredientSubstanceStrengthReferenceStrength;
begin
  result := TFhirIngredientSubstanceStrengthReferenceStrength.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirIngredientSubstanceStrengthReferenceStrengthList.ClearItems;
begin
  Clear;
end;

function TFhirIngredientSubstanceStrengthReferenceStrengthList.GetEnumerator : TFhirIngredientSubstanceStrengthReferenceStrengthListEnumerator;
begin
  result := TFhirIngredientSubstanceStrengthReferenceStrengthListEnumerator.Create(self.link);
end;

function TFhirIngredientSubstanceStrengthReferenceStrengthList.Clone: TFhirIngredientSubstanceStrengthReferenceStrengthList;
begin
  result := TFhirIngredientSubstanceStrengthReferenceStrengthList(inherited Clone);
end;

function TFhirIngredientSubstanceStrengthReferenceStrengthList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirIngredientSubstanceStrengthReferenceStrengthList.GetItemN(index: Integer): TFhirIngredientSubstanceStrengthReferenceStrength;
begin
  result := TFhirIngredientSubstanceStrengthReferenceStrength(ObjectByIndex[index]);
end;

function TFhirIngredientSubstanceStrengthReferenceStrengthList.ItemClass: TFslObjectClass;
begin
  result := TFhirIngredientSubstanceStrengthReferenceStrength;
end;
function TFhirIngredientSubstanceStrengthReferenceStrengthList.IndexOf(value: TFhirIngredientSubstanceStrengthReferenceStrength): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirIngredientSubstanceStrengthReferenceStrengthList.Insert(index: Integer): TFhirIngredientSubstanceStrengthReferenceStrength;
begin
  result := TFhirIngredientSubstanceStrengthReferenceStrength.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirIngredientSubstanceStrengthReferenceStrengthList.InsertItem(index: Integer; value: TFhirIngredientSubstanceStrengthReferenceStrength);
begin
  assert(value is TFhirIngredientSubstanceStrengthReferenceStrength);
  Inherited Insert(index, value);
end;

function TFhirIngredientSubstanceStrengthReferenceStrengthList.Item(index: Integer): TFhirIngredientSubstanceStrengthReferenceStrength;
begin
  result := TFhirIngredientSubstanceStrengthReferenceStrength(ObjectByIndex[index]);
end;

function TFhirIngredientSubstanceStrengthReferenceStrengthList.Link: TFhirIngredientSubstanceStrengthReferenceStrengthList;
begin
  result := TFhirIngredientSubstanceStrengthReferenceStrengthList(inherited Link);
end;

procedure TFhirIngredientSubstanceStrengthReferenceStrengthList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirIngredientSubstanceStrengthReferenceStrengthList.SetItemByIndex(index: Integer; value: TFhirIngredientSubstanceStrengthReferenceStrength);
begin
  assert(value is TFhirIngredientSubstanceStrengthReferenceStrength);
  FhirIngredientSubstanceStrengthReferenceStrengths[index] := value;
end;

procedure TFhirIngredientSubstanceStrengthReferenceStrengthList.SetItemN(index: Integer; value: TFhirIngredientSubstanceStrengthReferenceStrength);
begin
  assert(value is TFhirIngredientSubstanceStrengthReferenceStrength);
  ObjectByIndex[index] := value;
end;

{ TFhirIngredient }

constructor TFhirIngredient.Create;
begin
  inherited;
end;

destructor TFhirIngredient.Destroy;
begin
  FIdentifier.free;
  FStatus.free;
  FFor_List.Free;
  FRole.free;
  FFunction_List.Free;
  FGroup.free;
  FAllergenicIndicator.free;
  FManufacturerList.Free;
  FSubstance.free;
  inherited;
end;

procedure TFhirIngredient.Assign(oSource : TFslObject);
begin
  inherited;
  identifier := TFhirIngredient(oSource).identifier.Clone;
  statusElement := TFhirIngredient(oSource).statusElement.Clone;
  if (TFhirIngredient(oSource).FFor_List = nil) then
  begin
    FFor_List.free;
    FFor_List := nil;
  end
  else
  begin
    if FFor_List = nil then
      FFor_List := TFhirReferenceList.Create;
    FFor_List.Assign(TFhirIngredient(oSource).FFor_List);
  end;
  role := TFhirIngredient(oSource).role.Clone;
  if (TFhirIngredient(oSource).FFunction_List = nil) then
  begin
    FFunction_List.free;
    FFunction_List := nil;
  end
  else
  begin
    if FFunction_List = nil then
      FFunction_List := TFhirCodeableConceptList.Create;
    FFunction_List.Assign(TFhirIngredient(oSource).FFunction_List);
  end;
  group := TFhirIngredient(oSource).group.Clone;
  allergenicIndicatorElement := TFhirIngredient(oSource).allergenicIndicatorElement.Clone;
  if (TFhirIngredient(oSource).FManufacturerList = nil) then
  begin
    FManufacturerList.free;
    FManufacturerList := nil;
  end
  else
  begin
    if FManufacturerList = nil then
      FManufacturerList := TFhirIngredientManufacturerList.Create;
    FManufacturerList.Assign(TFhirIngredient(oSource).FManufacturerList);
  end;
  substance := TFhirIngredient(oSource).substance.Clone;
end;

function TFhirIngredient.GetResourceType : TFhirResourceType;
begin
  result := frtIngredient;
end;

procedure TFhirIngredient.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'identifier') Then
     list.add(self.link, 'identifier', FIdentifier.Link);
  if (child_name = 'status') Then
     list.add(self.link, 'status', FStatus.Link);
  if (child_name = 'for') Then
    list.addAll(self, 'for', FFor_List);
  if (child_name = 'role') Then
     list.add(self.link, 'role', FRole.Link);
  if (child_name = 'function') Then
    list.addAll(self, 'function', FFunction_List);
  if (child_name = 'group') Then
     list.add(self.link, 'group', FGroup.Link);
  if (child_name = 'allergenicIndicator') Then
     list.add(self.link, 'allergenicIndicator', FAllergenicIndicator.Link);
  if (child_name = 'manufacturer') Then
    list.addAll(self, 'manufacturer', FManufacturerList);
  if (child_name = 'substance') Then
     list.add(self.link, 'substance', FSubstance.Link);
end;

procedure TFhirIngredient.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'identifier', 'Identifier', false, TFhirIdentifier, FIdentifier.Link));
  oList.add(TFHIRProperty.create(self, 'status', 'code', false, TFhirEnum, FStatus.Link));
  oList.add(TFHIRProperty.create(self, 'for', 'Reference', true, TFhirReference, FFor_List.Link));
  oList.add(TFHIRProperty.create(self, 'role', 'CodeableConcept', false, TFhirCodeableConcept, FRole.Link));
  oList.add(TFHIRProperty.create(self, 'function', 'CodeableConcept', true, TFhirCodeableConcept, FFunction_List.Link));
  oList.add(TFHIRProperty.create(self, 'group', 'CodeableConcept', false, TFhirCodeableConcept, FGroup.Link));
  oList.add(TFHIRProperty.create(self, 'allergenicIndicator', 'boolean', false, TFhirBoolean, FAllergenicIndicator.Link));
  oList.add(TFHIRProperty.create(self, 'manufacturer', 'BackboneElement', true, TFhirIngredientManufacturer, FManufacturerList.Link));
  oList.add(TFHIRProperty.create(self, 'substance', 'BackboneElement', false, TFhirIngredientSubstance, FSubstance.Link));
end;

function TFhirIngredient.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'identifier') then
  begin
    Identifier := propValue as TFhirIdentifier;
    result := propValue;
  end
  else if (propName = 'status') then
  begin
    StatusElement := asEnum(SYSTEMS_TFhirPublicationStatusEnum, CODES_TFhirPublicationStatusEnum, propValue);
    result := propValue;
  end
  else if (propName = 'for') then
  begin
    For_List.add(propValue as TFhirReference);
    result := propValue;
  end
  else if (propName = 'role') then
  begin
    Role := propValue as TFhirCodeableConcept;
    result := propValue;
  end
  else if (propName = 'function') then
  begin
    Function_List.add(propValue as TFhirCodeableConcept);
    result := propValue;
  end
  else if (propName = 'group') then
  begin
    Group := propValue as TFhirCodeableConcept;
    result := propValue;
  end
  else if (propName = 'allergenicIndicator') then
  begin
    AllergenicIndicatorElement := asBoolean(propValue);
    result := propValue;
  end
  else if (propName = 'manufacturer') then
  begin
    ManufacturerList.add(propValue as TFhirIngredientManufacturer);
    result := propValue;
  end
  else if (propName = 'substance') then
  begin
    Substance := propValue as TFhirIngredientSubstance;
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirIngredient.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'for') then For_List.insertItem(index, propValue as TFhirReference)
  else if (propName = 'function') then Function_List.insertItem(index, propValue as TFhirCodeableConcept)
  else if (propName = 'manufacturer') then ManufacturerList.insertItem(index, propValue as TFhirIngredientManufacturer)
  else inherited;
end;

function TFhirIngredient.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'identifier') then result := TFhirIdentifier.create()
  else if (propName = 'status') then result := TFhirEnum.create(SYSTEMS_TFhirPublicationStatusEnum[PublicationStatusNull], CODES_TFhirPublicationStatusEnum[PublicationStatusNull]) 
  else if (propName = 'for') then result := For_List.new()
  else if (propName = 'role') then result := TFhirCodeableConcept.create()
  else if (propName = 'function') then result := Function_List.new()
  else if (propName = 'group') then result := TFhirCodeableConcept.create()
  else if (propName = 'allergenicIndicator') then result := TFhirBoolean.create()
  else if (propName = 'manufacturer') then result := ManufacturerList.new()
  else if (propName = 'substance') then result := TFhirIngredientSubstance.create()
  else result := inherited createPropertyValue(propName);
end;

function TFhirIngredient.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'identifier') then result := 'Identifier'
  else if (propName = 'status') then result := 'code'
  else if (propName = 'for') then result := 'Reference'
  else if (propName = 'role') then result := 'CodeableConcept'
  else if (propName = 'function') then result := 'CodeableConcept'
  else if (propName = 'group') then result := 'CodeableConcept'
  else if (propName = 'allergenicIndicator') then result := 'boolean'
  else if (propName = 'manufacturer') then result := 'BackboneElement'
  else if (propName = 'substance') then result := 'BackboneElement'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirIngredient.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'identifier') then IdentifierElement := nil
  else if (propName = 'status') then StatusElement := nil
  else if (propName = 'for') then deletePropertyValue('for', For_List, value)
  else if (propName = 'role') then RoleElement := nil
  else if (propName = 'function') then deletePropertyValue('function', Function_List, value)
  else if (propName = 'group') then GroupElement := nil
  else if (propName = 'allergenicIndicator') then AllergenicIndicatorElement := nil
  else if (propName = 'manufacturer') then deletePropertyValue('manufacturer', ManufacturerList, value)
  else if (propName = 'substance') then SubstanceElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirIngredient.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'identifier') then IdentifierElement := new as TFhirIdentifier
  else if (propName = 'status') then StatusElement := asEnum(SYSTEMS_TFhirPublicationStatusEnum, CODES_TFhirPublicationStatusEnum, new)
  else if (propName = 'for') then replacePropertyValue('for', For_List, existing, new)
  else if (propName = 'role') then RoleElement := new as TFhirCodeableConcept
  else if (propName = 'function') then replacePropertyValue('function', Function_List, existing, new)
  else if (propName = 'group') then GroupElement := new as TFhirCodeableConcept
  else if (propName = 'allergenicIndicator') then AllergenicIndicatorElement := asBoolean(new)
  else if (propName = 'manufacturer') then replacePropertyValue('manufacturer', ManufacturerList, existing, new)
  else if (propName = 'substance') then SubstanceElement := new as TFhirIngredientSubstance
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirIngredient.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'for') then For_List.move(source, destination)
  else if (propName = 'function') then Function_List.move(source, destination)
  else if (propName = 'manufacturer') then ManufacturerList.move(source, destination)
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirIngredient.fhirType : string;
begin
  result := 'Ingredient';
end;

function TFhirIngredient.Link : TFhirIngredient;
begin
  result := TFhirIngredient(inherited Link);
end;

function TFhirIngredient.Clone : TFhirIngredient;
begin
  result := TFhirIngredient(inherited Clone);
end;

function TFhirIngredient.equals(other : TObject) : boolean; 
var
  o : TFhirIngredient;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirIngredient)) then
    result := false
  else
  begin
    o := TFhirIngredient(other);
    result := compareDeep(identifierElement, o.identifierElement, true) and compareDeep(statusElement, o.statusElement, true) and 
      compareDeep(for_List, o.for_List, true) and compareDeep(roleElement, o.roleElement, true) and 
      compareDeep(function_List, o.function_List, true) and compareDeep(groupElement, o.groupElement, true) and 
      compareDeep(allergenicIndicatorElement, o.allergenicIndicatorElement, true) and 
      compareDeep(manufacturerList, o.manufacturerList, true) and compareDeep(substanceElement, o.substanceElement, true);
  end;
end;

function TFhirIngredient.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FIdentifier) and isEmptyProp(FStatus) and isEmptyProp(Ffor_List) and isEmptyProp(FRole) and isEmptyProp(Ffunction_List) and isEmptyProp(FGroup) and isEmptyProp(FAllergenicIndicator) and isEmptyProp(FmanufacturerList) and isEmptyProp(FSubstance);
end;

procedure TFhirIngredient.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('identifier');
  fields.add('status');
  fields.add('for');
  fields.add('role');
  fields.add('function');
  fields.add('group');
  fields.add('allergenicIndicator');
  fields.add('manufacturer');
  fields.add('substance');
end;

function TFhirIngredient.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
  inc(result, FFor_List.sizeInBytes(magic));
  inc(result, FFunction_List.sizeInBytes(magic));
  inc(result, FManufacturerList.sizeInBytes(magic));
end;

procedure TFhirIngredient.SetIdentifier(value : TFhirIdentifier);
begin
  FIdentifier.free;
  FIdentifier := value;
end;

procedure TFhirIngredient.SetStatus(value : TFhirEnum);
begin
  FStatus.free;
  FStatus := value;
end;

function TFhirIngredient.GetStatusST : TFhirPublicationStatusEnum;
begin
  if FStatus = nil then
    result := TFhirPublicationStatusEnum(0)
  else
    result := TFhirPublicationStatusEnum(StringArrayIndexOfSensitive(CODES_TFhirPublicationStatusEnum, FStatus.value));
end;

procedure TFhirIngredient.SetStatusST(value : TFhirPublicationStatusEnum);
begin
  if ord(value) = 0 then
    StatusElement := nil
  else
    StatusElement := TFhirEnum.create(SYSTEMS_TFhirPublicationStatusEnum[value], CODES_TFhirPublicationStatusEnum[value]);
end;

function TFhirIngredient.GetFor_List : TFhirReferenceList;
begin
  if FFor_List = nil then
    FFor_List := TFhirReferenceList.Create;
  result := FFor_List;
end;

function TFhirIngredient.GetHasFor_List : boolean;
begin
  result := (FFor_List <> nil) and (FFor_List.count > 0);
end;

procedure TFhirIngredient.SetRole(value : TFhirCodeableConcept);
begin
  FRole.free;
  FRole := value;
end;

function TFhirIngredient.GetFunction_List : TFhirCodeableConceptList;
begin
  if FFunction_List = nil then
    FFunction_List := TFhirCodeableConceptList.Create;
  result := FFunction_List;
end;

function TFhirIngredient.GetHasFunction_List : boolean;
begin
  result := (FFunction_List <> nil) and (FFunction_List.count > 0);
end;

procedure TFhirIngredient.SetGroup(value : TFhirCodeableConcept);
begin
  FGroup.free;
  FGroup := value;
end;

procedure TFhirIngredient.SetAllergenicIndicator(value : TFhirBoolean);
begin
  FAllergenicIndicator.free;
  FAllergenicIndicator := value;
end;

function TFhirIngredient.GetAllergenicIndicatorST : Boolean;
begin
  if FAllergenicIndicator = nil then
    result := false
  else
    result := FAllergenicIndicator.value;
end;

procedure TFhirIngredient.SetAllergenicIndicatorST(value : Boolean);
begin
  if FAllergenicIndicator = nil then
    FAllergenicIndicator := TFhirBoolean.create;
  FAllergenicIndicator.value := value
end;

function TFhirIngredient.GetManufacturerList : TFhirIngredientManufacturerList;
begin
  if FManufacturerList = nil then
    FManufacturerList := TFhirIngredientManufacturerList.Create;
  result := FManufacturerList;
end;

function TFhirIngredient.GetHasManufacturerList : boolean;
begin
  result := (FManufacturerList <> nil) and (FManufacturerList.count > 0);
end;

procedure TFhirIngredient.SetSubstance(value : TFhirIngredientSubstance);
begin
  FSubstance.free;
  FSubstance := value;
end;

{ TFhirIngredientListEnumerator }

constructor TFhirIngredientListEnumerator.Create(list : TFhirIngredientList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirIngredientListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirIngredientListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirIngredientListEnumerator.GetCurrent : TFhirIngredient;
begin
  Result := FList[FIndex];
end;

function TFhirIngredientListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirIngredientList }

function TFhirIngredientList.AddItem(value: TFhirIngredient): TFhirIngredient;
begin
  assert(value.ClassName = 'TFhirIngredient', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirIngredient');
  add(value);
  result := value;
end;

function TFhirIngredientList.Append: TFhirIngredient;
begin
  result := TFhirIngredient.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirIngredientList.ClearItems;
begin
  Clear;
end;

function TFhirIngredientList.GetEnumerator : TFhirIngredientListEnumerator;
begin
  result := TFhirIngredientListEnumerator.Create(self.link);
end;

function TFhirIngredientList.Clone: TFhirIngredientList;
begin
  result := TFhirIngredientList(inherited Clone);
end;

function TFhirIngredientList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirIngredientList.GetItemN(index: Integer): TFhirIngredient;
begin
  result := TFhirIngredient(ObjectByIndex[index]);
end;

function TFhirIngredientList.ItemClass: TFslObjectClass;
begin
  result := TFhirIngredient;
end;
function TFhirIngredientList.IndexOf(value: TFhirIngredient): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirIngredientList.Insert(index: Integer): TFhirIngredient;
begin
  result := TFhirIngredient.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirIngredientList.InsertItem(index: Integer; value: TFhirIngredient);
begin
  assert(value is TFhirIngredient);
  Inherited Insert(index, value);
end;

function TFhirIngredientList.Item(index: Integer): TFhirIngredient;
begin
  result := TFhirIngredient(ObjectByIndex[index]);
end;

function TFhirIngredientList.Link: TFhirIngredientList;
begin
  result := TFhirIngredientList(inherited Link);
end;

procedure TFhirIngredientList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirIngredientList.SetItemByIndex(index: Integer; value: TFhirIngredient);
begin
  assert(value is TFhirIngredient);
  FhirIngredients[index] := value;
end;

procedure TFhirIngredientList.SetItemN(index: Integer; value: TFhirIngredient);
begin
  assert(value is TFhirIngredient);
  ObjectByIndex[index] := value;
end;

{$ENDIF FHIR_INGREDIENT}
{$IFDEF FHIR_MANUFACTUREDITEMDEFINITION}
{ TFhirManufacturedItemDefinitionProperty }

constructor TFhirManufacturedItemDefinitionProperty.Create;
begin
  inherited;
end;

destructor TFhirManufacturedItemDefinitionProperty.Destroy;
begin
  FType_.free;
  FValue.free;
  inherited;
end;

procedure TFhirManufacturedItemDefinitionProperty.Assign(oSource : TFslObject);
begin
  inherited;
  type_ := TFhirManufacturedItemDefinitionProperty(oSource).type_.Clone;
  value := TFhirManufacturedItemDefinitionProperty(oSource).value.Clone;
end;

procedure TFhirManufacturedItemDefinitionProperty.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'type') Then
     list.add(self.link, 'type', FType_.Link);
  if (child_name = 'value[x]') or (child_name = 'value') Then
     list.add(self.link, 'value[x]', FValue.Link);
end;

procedure TFhirManufacturedItemDefinitionProperty.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'type', 'CodeableConcept', false, TFhirCodeableConcept, FType_.Link));
  oList.add(TFHIRProperty.create(self, 'value[x]', 'CodeableConcept|Quantity|date|boolean|Attachment', false, TFhirDataType, FValue.Link));
end;

function TFhirManufacturedItemDefinitionProperty.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'type') then
  begin
    Type_ := propValue as TFhirCodeableConcept;
    result := propValue;
  end
  else if (isMatchingName(propName, 'value', ['CodeableConcept', 'Quantity', 'Date', 'Boolean', 'Attachment'])) then
  begin
    Value := propValue as TFhirDataType;
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirManufacturedItemDefinitionProperty.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirManufacturedItemDefinitionProperty.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'type') then result := TFhirCodeableConcept.create()
  else if (isMatchingName(propName, 'value', ['CodeableConcept', 'Quantity', 'Date', 'Boolean', 'Attachment'])) then raise EFHIRException.create('Cannot make property Value')
  else result := inherited createPropertyValue(propName);
end;

function TFhirManufacturedItemDefinitionProperty.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'type') then result := 'CodeableConcept'
  else if (propName = 'value[x]') then result := 'CodeableConcept|Quantity|date|boolean|Attachment'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirManufacturedItemDefinitionProperty.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'type') then Type_Element := nil
  else if (isMatchingName(propName, 'value', ['CodeableConcept', 'Quantity', 'Date', 'Boolean', 'Attachment'])) then ValueElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirManufacturedItemDefinitionProperty.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'type') then Type_Element := new as TFhirCodeableConcept
  else if (isMatchingName(propName, 'value', ['CodeableConcept', 'Quantity', 'Date', 'Boolean', 'Attachment'])) then ValueElement := new as TFhirDataType
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirManufacturedItemDefinitionProperty.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirManufacturedItemDefinitionProperty.fhirType : string;
begin
  result := 'ManufacturedItemDefinition.property';
end;

function TFhirManufacturedItemDefinitionProperty.Link : TFhirManufacturedItemDefinitionProperty;
begin
  result := TFhirManufacturedItemDefinitionProperty(inherited Link);
end;

function TFhirManufacturedItemDefinitionProperty.Clone : TFhirManufacturedItemDefinitionProperty;
begin
  result := TFhirManufacturedItemDefinitionProperty(inherited Clone);
end;

function TFhirManufacturedItemDefinitionProperty.equals(other : TObject) : boolean; 
var
  o : TFhirManufacturedItemDefinitionProperty;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirManufacturedItemDefinitionProperty)) then
    result := false
  else
  begin
    o := TFhirManufacturedItemDefinitionProperty(other);
    result := compareDeep(type_Element, o.type_Element, true) and compareDeep(valueElement, o.valueElement, true);
  end;
end;

function TFhirManufacturedItemDefinitionProperty.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FType_) and isEmptyProp(FValue);
end;

procedure TFhirManufacturedItemDefinitionProperty.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('type');
  fields.add('value[x]');
end;

function TFhirManufacturedItemDefinitionProperty.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
end;

procedure TFhirManufacturedItemDefinitionProperty.SetType_(value : TFhirCodeableConcept);
begin
  FType_.free;
  FType_ := value;
end;

procedure TFhirManufacturedItemDefinitionProperty.SetValue(value : TFhirDataType);
begin
  FValue.free;
  FValue := value;
end;

{ TFhirManufacturedItemDefinitionPropertyListEnumerator }

constructor TFhirManufacturedItemDefinitionPropertyListEnumerator.Create(list : TFhirManufacturedItemDefinitionPropertyList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirManufacturedItemDefinitionPropertyListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirManufacturedItemDefinitionPropertyListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirManufacturedItemDefinitionPropertyListEnumerator.GetCurrent : TFhirManufacturedItemDefinitionProperty;
begin
  Result := FList[FIndex];
end;

function TFhirManufacturedItemDefinitionPropertyListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirManufacturedItemDefinitionPropertyList }

function TFhirManufacturedItemDefinitionPropertyList.AddItem(value: TFhirManufacturedItemDefinitionProperty): TFhirManufacturedItemDefinitionProperty;
begin
  assert(value.ClassName = 'TFhirManufacturedItemDefinitionProperty', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirManufacturedItemDefinitionProperty');
  add(value);
  result := value;
end;

function TFhirManufacturedItemDefinitionPropertyList.Append: TFhirManufacturedItemDefinitionProperty;
begin
  result := TFhirManufacturedItemDefinitionProperty.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirManufacturedItemDefinitionPropertyList.ClearItems;
begin
  Clear;
end;

function TFhirManufacturedItemDefinitionPropertyList.GetEnumerator : TFhirManufacturedItemDefinitionPropertyListEnumerator;
begin
  result := TFhirManufacturedItemDefinitionPropertyListEnumerator.Create(self.link);
end;

function TFhirManufacturedItemDefinitionPropertyList.Clone: TFhirManufacturedItemDefinitionPropertyList;
begin
  result := TFhirManufacturedItemDefinitionPropertyList(inherited Clone);
end;

function TFhirManufacturedItemDefinitionPropertyList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirManufacturedItemDefinitionPropertyList.GetItemN(index: Integer): TFhirManufacturedItemDefinitionProperty;
begin
  result := TFhirManufacturedItemDefinitionProperty(ObjectByIndex[index]);
end;

function TFhirManufacturedItemDefinitionPropertyList.ItemClass: TFslObjectClass;
begin
  result := TFhirManufacturedItemDefinitionProperty;
end;
function TFhirManufacturedItemDefinitionPropertyList.IndexOf(value: TFhirManufacturedItemDefinitionProperty): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirManufacturedItemDefinitionPropertyList.Insert(index: Integer): TFhirManufacturedItemDefinitionProperty;
begin
  result := TFhirManufacturedItemDefinitionProperty.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirManufacturedItemDefinitionPropertyList.InsertItem(index: Integer; value: TFhirManufacturedItemDefinitionProperty);
begin
  assert(value is TFhirManufacturedItemDefinitionProperty);
  Inherited Insert(index, value);
end;

function TFhirManufacturedItemDefinitionPropertyList.Item(index: Integer): TFhirManufacturedItemDefinitionProperty;
begin
  result := TFhirManufacturedItemDefinitionProperty(ObjectByIndex[index]);
end;

function TFhirManufacturedItemDefinitionPropertyList.Link: TFhirManufacturedItemDefinitionPropertyList;
begin
  result := TFhirManufacturedItemDefinitionPropertyList(inherited Link);
end;

procedure TFhirManufacturedItemDefinitionPropertyList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirManufacturedItemDefinitionPropertyList.SetItemByIndex(index: Integer; value: TFhirManufacturedItemDefinitionProperty);
begin
  assert(value is TFhirManufacturedItemDefinitionProperty);
  FhirManufacturedItemDefinitionProperties[index] := value;
end;

procedure TFhirManufacturedItemDefinitionPropertyList.SetItemN(index: Integer; value: TFhirManufacturedItemDefinitionProperty);
begin
  assert(value is TFhirManufacturedItemDefinitionProperty);
  ObjectByIndex[index] := value;
end;

{ TFhirManufacturedItemDefinitionComponent }

constructor TFhirManufacturedItemDefinitionComponent.Create;
begin
  inherited;
end;

destructor TFhirManufacturedItemDefinitionComponent.Destroy;
begin
  FType_.free;
  FFunction_List.Free;
  FAmountList.Free;
  FConstituentList.Free;
  FProperty_List.Free;
  FComponentList.Free;
  inherited;
end;

procedure TFhirManufacturedItemDefinitionComponent.Assign(oSource : TFslObject);
begin
  inherited;
  type_ := TFhirManufacturedItemDefinitionComponent(oSource).type_.Clone;
  if (TFhirManufacturedItemDefinitionComponent(oSource).FFunction_List = nil) then
  begin
    FFunction_List.free;
    FFunction_List := nil;
  end
  else
  begin
    if FFunction_List = nil then
      FFunction_List := TFhirCodeableConceptList.Create;
    FFunction_List.Assign(TFhirManufacturedItemDefinitionComponent(oSource).FFunction_List);
  end;
  if (TFhirManufacturedItemDefinitionComponent(oSource).FAmountList = nil) then
  begin
    FAmountList.free;
    FAmountList := nil;
  end
  else
  begin
    if FAmountList = nil then
      FAmountList := TFhirQuantityList.Create;
    FAmountList.Assign(TFhirManufacturedItemDefinitionComponent(oSource).FAmountList);
  end;
  if (TFhirManufacturedItemDefinitionComponent(oSource).FConstituentList = nil) then
  begin
    FConstituentList.free;
    FConstituentList := nil;
  end
  else
  begin
    if FConstituentList = nil then
      FConstituentList := TFhirManufacturedItemDefinitionComponentConstituentList.Create;
    FConstituentList.Assign(TFhirManufacturedItemDefinitionComponent(oSource).FConstituentList);
  end;
  if (TFhirManufacturedItemDefinitionComponent(oSource).FProperty_List = nil) then
  begin
    FProperty_List.free;
    FProperty_List := nil;
  end
  else
  begin
    if FProperty_List = nil then
      FProperty_List := TFhirManufacturedItemDefinitionPropertyList.Create;
    FProperty_List.Assign(TFhirManufacturedItemDefinitionComponent(oSource).FProperty_List);
  end;
  if (TFhirManufacturedItemDefinitionComponent(oSource).FComponentList = nil) then
  begin
    FComponentList.free;
    FComponentList := nil;
  end
  else
  begin
    if FComponentList = nil then
      FComponentList := TFhirManufacturedItemDefinitionComponentList.Create;
    FComponentList.Assign(TFhirManufacturedItemDefinitionComponent(oSource).FComponentList);
  end;
end;

procedure TFhirManufacturedItemDefinitionComponent.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'type') Then
     list.add(self.link, 'type', FType_.Link);
  if (child_name = 'function') Then
    list.addAll(self, 'function', FFunction_List);
  if (child_name = 'amount') Then
    list.addAll(self, 'amount', FAmountList);
  if (child_name = 'constituent') Then
    list.addAll(self, 'constituent', FConstituentList);
  if (child_name = 'property') Then
    list.addAll(self, 'property', FProperty_List);
  if (child_name = 'component') Then
    list.addAll(self, 'component', FComponentList);
end;

procedure TFhirManufacturedItemDefinitionComponent.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'type', 'CodeableConcept', false, TFhirCodeableConcept, FType_.Link));
  oList.add(TFHIRProperty.create(self, 'function', 'CodeableConcept', true, TFhirCodeableConcept, FFunction_List.Link));
  oList.add(TFHIRProperty.create(self, 'amount', 'Quantity', true, TFhirQuantity, FAmountList.Link));
  oList.add(TFHIRProperty.create(self, 'constituent', 'BackboneElement', true, TFhirManufacturedItemDefinitionComponentConstituent, FConstituentList.Link));
  oList.add(TFHIRProperty.create(self, 'property', '', true, TFhirManufacturedItemDefinitionProperty, FProperty_List.Link));
  oList.add(TFHIRProperty.create(self, 'component', '', true, TFhirManufacturedItemDefinitionComponent, FComponentList.Link));
end;

function TFhirManufacturedItemDefinitionComponent.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'type') then
  begin
    Type_ := propValue as TFhirCodeableConcept;
    result := propValue;
  end
  else if (propName = 'function') then
  begin
    Function_List.add(propValue as TFhirCodeableConcept);
    result := propValue;
  end
  else if (propName = 'amount') then
  begin
    AmountList.add(propValue as TFhirQuantity);
    result := propValue;
  end
  else if (propName = 'constituent') then
  begin
    ConstituentList.add(propValue as TFhirManufacturedItemDefinitionComponentConstituent);
    result := propValue;
  end
  else if (propName = 'property') then
  begin
    Property_List.add(propValue as TFhirManufacturedItemDefinitionProperty);
    result := propValue;
  end
  else if (propName = 'component') then
  begin
    ComponentList.add(propValue as TFhirManufacturedItemDefinitionComponent);
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirManufacturedItemDefinitionComponent.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'function') then Function_List.insertItem(index, propValue as TFhirCodeableConcept)
  else if (propName = 'amount') then AmountList.insertItem(index, propValue as TFhirQuantity)
  else if (propName = 'constituent') then ConstituentList.insertItem(index, propValue as TFhirManufacturedItemDefinitionComponentConstituent)
  else if (propName = 'property') then Property_List.insertItem(index, propValue as TFhirManufacturedItemDefinitionProperty)
  else if (propName = 'component') then ComponentList.insertItem(index, propValue as TFhirManufacturedItemDefinitionComponent)
  else inherited;
end;

function TFhirManufacturedItemDefinitionComponent.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'type') then result := TFhirCodeableConcept.create()
  else if (propName = 'function') then result := Function_List.new()
  else if (propName = 'amount') then result := AmountList.new()
  else if (propName = 'constituent') then result := ConstituentList.new()
  else if (propName = 'property') then result := Property_List.new()
  else if (propName = 'component') then result := ComponentList.new()
  else result := inherited createPropertyValue(propName);
end;

function TFhirManufacturedItemDefinitionComponent.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'type') then result := 'CodeableConcept'
  else if (propName = 'function') then result := 'CodeableConcept'
  else if (propName = 'amount') then result := 'Quantity'
  else if (propName = 'constituent') then result := 'BackboneElement'
  else if (propName = 'property') then result := ''
  else if (propName = 'component') then result := ''
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirManufacturedItemDefinitionComponent.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'type') then Type_Element := nil
  else if (propName = 'function') then deletePropertyValue('function', Function_List, value)
  else if (propName = 'amount') then deletePropertyValue('amount', AmountList, value)
  else if (propName = 'constituent') then deletePropertyValue('constituent', ConstituentList, value)
  else if (propName = 'property') then deletePropertyValue('property', Property_List, value)
  else if (propName = 'component') then deletePropertyValue('component', ComponentList, value)
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirManufacturedItemDefinitionComponent.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'type') then Type_Element := new as TFhirCodeableConcept
  else if (propName = 'function') then replacePropertyValue('function', Function_List, existing, new)
  else if (propName = 'amount') then replacePropertyValue('amount', AmountList, existing, new)
  else if (propName = 'constituent') then replacePropertyValue('constituent', ConstituentList, existing, new)
  else if (propName = 'property') then replacePropertyValue('property', Property_List, existing, new)
  else if (propName = 'component') then replacePropertyValue('component', ComponentList, existing, new)
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirManufacturedItemDefinitionComponent.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'function') then Function_List.move(source, destination)
  else if (propName = 'amount') then AmountList.move(source, destination)
  else if (propName = 'constituent') then ConstituentList.move(source, destination)
  else if (propName = 'property') then Property_List.move(source, destination)
  else if (propName = 'component') then ComponentList.move(source, destination)
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirManufacturedItemDefinitionComponent.fhirType : string;
begin
  result := 'ManufacturedItemDefinition.component';
end;

function TFhirManufacturedItemDefinitionComponent.Link : TFhirManufacturedItemDefinitionComponent;
begin
  result := TFhirManufacturedItemDefinitionComponent(inherited Link);
end;

function TFhirManufacturedItemDefinitionComponent.Clone : TFhirManufacturedItemDefinitionComponent;
begin
  result := TFhirManufacturedItemDefinitionComponent(inherited Clone);
end;

function TFhirManufacturedItemDefinitionComponent.equals(other : TObject) : boolean; 
var
  o : TFhirManufacturedItemDefinitionComponent;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirManufacturedItemDefinitionComponent)) then
    result := false
  else
  begin
    o := TFhirManufacturedItemDefinitionComponent(other);
    result := compareDeep(type_Element, o.type_Element, true) and compareDeep(function_List, o.function_List, true) and 
      compareDeep(amountList, o.amountList, true) and compareDeep(constituentList, o.constituentList, true) and 
      compareDeep(property_List, o.property_List, true) and compareDeep(componentList, o.componentList, true);
  end;
end;

function TFhirManufacturedItemDefinitionComponent.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FType_) and isEmptyProp(Ffunction_List) and isEmptyProp(FamountList) and isEmptyProp(FconstituentList) and isEmptyProp(Fproperty_List) and isEmptyProp(FcomponentList);
end;

procedure TFhirManufacturedItemDefinitionComponent.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('type');
  fields.add('function');
  fields.add('amount');
  fields.add('constituent');
  fields.add('property');
  fields.add('component');
end;

function TFhirManufacturedItemDefinitionComponent.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
  inc(result, FFunction_List.sizeInBytes(magic));
  inc(result, FAmountList.sizeInBytes(magic));
  inc(result, FConstituentList.sizeInBytes(magic));
  inc(result, FProperty_List.sizeInBytes(magic));
  inc(result, FComponentList.sizeInBytes(magic));
end;

procedure TFhirManufacturedItemDefinitionComponent.SetType_(value : TFhirCodeableConcept);
begin
  FType_.free;
  FType_ := value;
end;

function TFhirManufacturedItemDefinitionComponent.GetFunction_List : TFhirCodeableConceptList;
begin
  if FFunction_List = nil then
    FFunction_List := TFhirCodeableConceptList.Create;
  result := FFunction_List;
end;

function TFhirManufacturedItemDefinitionComponent.GetHasFunction_List : boolean;
begin
  result := (FFunction_List <> nil) and (FFunction_List.count > 0);
end;

function TFhirManufacturedItemDefinitionComponent.GetAmountList : TFhirQuantityList;
begin
  if FAmountList = nil then
    FAmountList := TFhirQuantityList.Create;
  result := FAmountList;
end;

function TFhirManufacturedItemDefinitionComponent.GetHasAmountList : boolean;
begin
  result := (FAmountList <> nil) and (FAmountList.count > 0);
end;

function TFhirManufacturedItemDefinitionComponent.GetConstituentList : TFhirManufacturedItemDefinitionComponentConstituentList;
begin
  if FConstituentList = nil then
    FConstituentList := TFhirManufacturedItemDefinitionComponentConstituentList.Create;
  result := FConstituentList;
end;

function TFhirManufacturedItemDefinitionComponent.GetHasConstituentList : boolean;
begin
  result := (FConstituentList <> nil) and (FConstituentList.count > 0);
end;

function TFhirManufacturedItemDefinitionComponent.GetProperty_List : TFhirManufacturedItemDefinitionPropertyList;
begin
  if FProperty_List = nil then
    FProperty_List := TFhirManufacturedItemDefinitionPropertyList.Create;
  result := FProperty_List;
end;

function TFhirManufacturedItemDefinitionComponent.GetHasProperty_List : boolean;
begin
  result := (FProperty_List <> nil) and (FProperty_List.count > 0);
end;

function TFhirManufacturedItemDefinitionComponent.GetComponentList : TFhirManufacturedItemDefinitionComponentList;
begin
  if FComponentList = nil then
    FComponentList := TFhirManufacturedItemDefinitionComponentList.Create;
  result := FComponentList;
end;

function TFhirManufacturedItemDefinitionComponent.GetHasComponentList : boolean;
begin
  result := (FComponentList <> nil) and (FComponentList.count > 0);
end;

{ TFhirManufacturedItemDefinitionComponentListEnumerator }

constructor TFhirManufacturedItemDefinitionComponentListEnumerator.Create(list : TFhirManufacturedItemDefinitionComponentList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirManufacturedItemDefinitionComponentListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirManufacturedItemDefinitionComponentListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirManufacturedItemDefinitionComponentListEnumerator.GetCurrent : TFhirManufacturedItemDefinitionComponent;
begin
  Result := FList[FIndex];
end;

function TFhirManufacturedItemDefinitionComponentListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirManufacturedItemDefinitionComponentList }

function TFhirManufacturedItemDefinitionComponentList.AddItem(value: TFhirManufacturedItemDefinitionComponent): TFhirManufacturedItemDefinitionComponent;
begin
  assert(value.ClassName = 'TFhirManufacturedItemDefinitionComponent', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirManufacturedItemDefinitionComponent');
  add(value);
  result := value;
end;

function TFhirManufacturedItemDefinitionComponentList.Append: TFhirManufacturedItemDefinitionComponent;
begin
  result := TFhirManufacturedItemDefinitionComponent.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirManufacturedItemDefinitionComponentList.ClearItems;
begin
  Clear;
end;

function TFhirManufacturedItemDefinitionComponentList.GetEnumerator : TFhirManufacturedItemDefinitionComponentListEnumerator;
begin
  result := TFhirManufacturedItemDefinitionComponentListEnumerator.Create(self.link);
end;

function TFhirManufacturedItemDefinitionComponentList.Clone: TFhirManufacturedItemDefinitionComponentList;
begin
  result := TFhirManufacturedItemDefinitionComponentList(inherited Clone);
end;

function TFhirManufacturedItemDefinitionComponentList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirManufacturedItemDefinitionComponentList.GetItemN(index: Integer): TFhirManufacturedItemDefinitionComponent;
begin
  result := TFhirManufacturedItemDefinitionComponent(ObjectByIndex[index]);
end;

function TFhirManufacturedItemDefinitionComponentList.ItemClass: TFslObjectClass;
begin
  result := TFhirManufacturedItemDefinitionComponent;
end;
function TFhirManufacturedItemDefinitionComponentList.IndexOf(value: TFhirManufacturedItemDefinitionComponent): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirManufacturedItemDefinitionComponentList.Insert(index: Integer): TFhirManufacturedItemDefinitionComponent;
begin
  result := TFhirManufacturedItemDefinitionComponent.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirManufacturedItemDefinitionComponentList.InsertItem(index: Integer; value: TFhirManufacturedItemDefinitionComponent);
begin
  assert(value is TFhirManufacturedItemDefinitionComponent);
  Inherited Insert(index, value);
end;

function TFhirManufacturedItemDefinitionComponentList.Item(index: Integer): TFhirManufacturedItemDefinitionComponent;
begin
  result := TFhirManufacturedItemDefinitionComponent(ObjectByIndex[index]);
end;

function TFhirManufacturedItemDefinitionComponentList.Link: TFhirManufacturedItemDefinitionComponentList;
begin
  result := TFhirManufacturedItemDefinitionComponentList(inherited Link);
end;

procedure TFhirManufacturedItemDefinitionComponentList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirManufacturedItemDefinitionComponentList.SetItemByIndex(index: Integer; value: TFhirManufacturedItemDefinitionComponent);
begin
  assert(value is TFhirManufacturedItemDefinitionComponent);
  FhirManufacturedItemDefinitionComponents[index] := value;
end;

procedure TFhirManufacturedItemDefinitionComponentList.SetItemN(index: Integer; value: TFhirManufacturedItemDefinitionComponent);
begin
  assert(value is TFhirManufacturedItemDefinitionComponent);
  ObjectByIndex[index] := value;
end;

{ TFhirManufacturedItemDefinitionComponentConstituent }

constructor TFhirManufacturedItemDefinitionComponentConstituent.Create;
begin
  inherited;
end;

destructor TFhirManufacturedItemDefinitionComponentConstituent.Destroy;
begin
  FAmountList.Free;
  FLocationList.Free;
  FFunction_List.Free;
  FLocationForIngredientList.Free;
  inherited;
end;

procedure TFhirManufacturedItemDefinitionComponentConstituent.Assign(oSource : TFslObject);
begin
  inherited;
  if (TFhirManufacturedItemDefinitionComponentConstituent(oSource).FAmountList = nil) then
  begin
    FAmountList.free;
    FAmountList := nil;
  end
  else
  begin
    if FAmountList = nil then
      FAmountList := TFhirQuantityList.Create;
    FAmountList.Assign(TFhirManufacturedItemDefinitionComponentConstituent(oSource).FAmountList);
  end;
  if (TFhirManufacturedItemDefinitionComponentConstituent(oSource).FLocationList = nil) then
  begin
    FLocationList.free;
    FLocationList := nil;
  end
  else
  begin
    if FLocationList = nil then
      FLocationList := TFhirCodeableConceptList.Create;
    FLocationList.Assign(TFhirManufacturedItemDefinitionComponentConstituent(oSource).FLocationList);
  end;
  if (TFhirManufacturedItemDefinitionComponentConstituent(oSource).FFunction_List = nil) then
  begin
    FFunction_List.free;
    FFunction_List := nil;
  end
  else
  begin
    if FFunction_List = nil then
      FFunction_List := TFhirCodeableConceptList.Create;
    FFunction_List.Assign(TFhirManufacturedItemDefinitionComponentConstituent(oSource).FFunction_List);
  end;
  if (TFhirManufacturedItemDefinitionComponentConstituent(oSource).FLocationForIngredientList = nil) then
  begin
    FLocationForIngredientList.free;
    FLocationForIngredientList := nil;
  end
  else
  begin
    if FLocationForIngredientList = nil then
      FLocationForIngredientList := TFhirCodeableReferenceList.Create;
    FLocationForIngredientList.Assign(TFhirManufacturedItemDefinitionComponentConstituent(oSource).FLocationForIngredientList);
  end;
end;

procedure TFhirManufacturedItemDefinitionComponentConstituent.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'amount') Then
    list.addAll(self, 'amount', FAmountList);
  if (child_name = 'location') Then
    list.addAll(self, 'location', FLocationList);
  if (child_name = 'function') Then
    list.addAll(self, 'function', FFunction_List);
  if (child_name = 'locationForIngredient') Then
    list.addAll(self, 'locationForIngredient', FLocationForIngredientList);
end;

procedure TFhirManufacturedItemDefinitionComponentConstituent.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'amount', 'Quantity', true, TFhirQuantity, FAmountList.Link));
  oList.add(TFHIRProperty.create(self, 'location', 'CodeableConcept', true, TFhirCodeableConcept, FLocationList.Link));
  oList.add(TFHIRProperty.create(self, 'function', 'CodeableConcept', true, TFhirCodeableConcept, FFunction_List.Link));
  oList.add(TFHIRProperty.create(self, 'locationForIngredient', 'CodeableReference', true, TFhirCodeableReference, FLocationForIngredientList.Link));
end;

function TFhirManufacturedItemDefinitionComponentConstituent.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'amount') then
  begin
    AmountList.add(propValue as TFhirQuantity);
    result := propValue;
  end
  else if (propName = 'location') then
  begin
    LocationList.add(propValue as TFhirCodeableConcept);
    result := propValue;
  end
  else if (propName = 'function') then
  begin
    Function_List.add(propValue as TFhirCodeableConcept);
    result := propValue;
  end
  else if (propName = 'locationForIngredient') then
  begin
    LocationForIngredientList.add(propValue as TFhirCodeableReference);
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirManufacturedItemDefinitionComponentConstituent.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'amount') then AmountList.insertItem(index, propValue as TFhirQuantity)
  else if (propName = 'location') then LocationList.insertItem(index, propValue as TFhirCodeableConcept)
  else if (propName = 'function') then Function_List.insertItem(index, propValue as TFhirCodeableConcept)
  else if (propName = 'locationForIngredient') then LocationForIngredientList.insertItem(index, propValue as TFhirCodeableReference)
  else inherited;
end;

function TFhirManufacturedItemDefinitionComponentConstituent.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'amount') then result := AmountList.new()
  else if (propName = 'location') then result := LocationList.new()
  else if (propName = 'function') then result := Function_List.new()
  else if (propName = 'locationForIngredient') then result := LocationForIngredientList.new()
  else result := inherited createPropertyValue(propName);
end;

function TFhirManufacturedItemDefinitionComponentConstituent.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'amount') then result := 'Quantity'
  else if (propName = 'location') then result := 'CodeableConcept'
  else if (propName = 'function') then result := 'CodeableConcept'
  else if (propName = 'locationForIngredient') then result := 'CodeableReference'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirManufacturedItemDefinitionComponentConstituent.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'amount') then deletePropertyValue('amount', AmountList, value)
  else if (propName = 'location') then deletePropertyValue('location', LocationList, value)
  else if (propName = 'function') then deletePropertyValue('function', Function_List, value)
  else if (propName = 'locationForIngredient') then deletePropertyValue('locationForIngredient', LocationForIngredientList, value)
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirManufacturedItemDefinitionComponentConstituent.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'amount') then replacePropertyValue('amount', AmountList, existing, new)
  else if (propName = 'location') then replacePropertyValue('location', LocationList, existing, new)
  else if (propName = 'function') then replacePropertyValue('function', Function_List, existing, new)
  else if (propName = 'locationForIngredient') then replacePropertyValue('locationForIngredient', LocationForIngredientList, existing, new)
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirManufacturedItemDefinitionComponentConstituent.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'amount') then AmountList.move(source, destination)
  else if (propName = 'location') then LocationList.move(source, destination)
  else if (propName = 'function') then Function_List.move(source, destination)
  else if (propName = 'locationForIngredient') then LocationForIngredientList.move(source, destination)
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirManufacturedItemDefinitionComponentConstituent.fhirType : string;
begin
  result := 'ManufacturedItemDefinition.component.constituent';
end;

function TFhirManufacturedItemDefinitionComponentConstituent.Link : TFhirManufacturedItemDefinitionComponentConstituent;
begin
  result := TFhirManufacturedItemDefinitionComponentConstituent(inherited Link);
end;

function TFhirManufacturedItemDefinitionComponentConstituent.Clone : TFhirManufacturedItemDefinitionComponentConstituent;
begin
  result := TFhirManufacturedItemDefinitionComponentConstituent(inherited Clone);
end;

function TFhirManufacturedItemDefinitionComponentConstituent.equals(other : TObject) : boolean; 
var
  o : TFhirManufacturedItemDefinitionComponentConstituent;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirManufacturedItemDefinitionComponentConstituent)) then
    result := false
  else
  begin
    o := TFhirManufacturedItemDefinitionComponentConstituent(other);
    result := compareDeep(amountList, o.amountList, true) and compareDeep(locationList, o.locationList, true) and 
      compareDeep(function_List, o.function_List, true) and compareDeep(locationForIngredientList, o.locationForIngredientList, true);
  end;
end;

function TFhirManufacturedItemDefinitionComponentConstituent.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FamountList) and isEmptyProp(FlocationList) and isEmptyProp(Ffunction_List) and isEmptyProp(FlocationForIngredientList);
end;

procedure TFhirManufacturedItemDefinitionComponentConstituent.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('amount');
  fields.add('location');
  fields.add('function');
  fields.add('locationForIngredient');
end;

function TFhirManufacturedItemDefinitionComponentConstituent.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
  inc(result, FAmountList.sizeInBytes(magic));
  inc(result, FLocationList.sizeInBytes(magic));
  inc(result, FFunction_List.sizeInBytes(magic));
  inc(result, FLocationForIngredientList.sizeInBytes(magic));
end;

function TFhirManufacturedItemDefinitionComponentConstituent.GetAmountList : TFhirQuantityList;
begin
  if FAmountList = nil then
    FAmountList := TFhirQuantityList.Create;
  result := FAmountList;
end;

function TFhirManufacturedItemDefinitionComponentConstituent.GetHasAmountList : boolean;
begin
  result := (FAmountList <> nil) and (FAmountList.count > 0);
end;

function TFhirManufacturedItemDefinitionComponentConstituent.GetLocationList : TFhirCodeableConceptList;
begin
  if FLocationList = nil then
    FLocationList := TFhirCodeableConceptList.Create;
  result := FLocationList;
end;

function TFhirManufacturedItemDefinitionComponentConstituent.GetHasLocationList : boolean;
begin
  result := (FLocationList <> nil) and (FLocationList.count > 0);
end;

function TFhirManufacturedItemDefinitionComponentConstituent.GetFunction_List : TFhirCodeableConceptList;
begin
  if FFunction_List = nil then
    FFunction_List := TFhirCodeableConceptList.Create;
  result := FFunction_List;
end;

function TFhirManufacturedItemDefinitionComponentConstituent.GetHasFunction_List : boolean;
begin
  result := (FFunction_List <> nil) and (FFunction_List.count > 0);
end;

function TFhirManufacturedItemDefinitionComponentConstituent.GetLocationForIngredientList : TFhirCodeableReferenceList;
begin
  if FLocationForIngredientList = nil then
    FLocationForIngredientList := TFhirCodeableReferenceList.Create;
  result := FLocationForIngredientList;
end;

function TFhirManufacturedItemDefinitionComponentConstituent.GetHasLocationForIngredientList : boolean;
begin
  result := (FLocationForIngredientList <> nil) and (FLocationForIngredientList.count > 0);
end;

{ TFhirManufacturedItemDefinitionComponentConstituentListEnumerator }

constructor TFhirManufacturedItemDefinitionComponentConstituentListEnumerator.Create(list : TFhirManufacturedItemDefinitionComponentConstituentList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirManufacturedItemDefinitionComponentConstituentListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirManufacturedItemDefinitionComponentConstituentListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirManufacturedItemDefinitionComponentConstituentListEnumerator.GetCurrent : TFhirManufacturedItemDefinitionComponentConstituent;
begin
  Result := FList[FIndex];
end;

function TFhirManufacturedItemDefinitionComponentConstituentListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirManufacturedItemDefinitionComponentConstituentList }

function TFhirManufacturedItemDefinitionComponentConstituentList.AddItem(value: TFhirManufacturedItemDefinitionComponentConstituent): TFhirManufacturedItemDefinitionComponentConstituent;
begin
  assert(value.ClassName = 'TFhirManufacturedItemDefinitionComponentConstituent', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirManufacturedItemDefinitionComponentConstituent');
  add(value);
  result := value;
end;

function TFhirManufacturedItemDefinitionComponentConstituentList.Append: TFhirManufacturedItemDefinitionComponentConstituent;
begin
  result := TFhirManufacturedItemDefinitionComponentConstituent.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirManufacturedItemDefinitionComponentConstituentList.ClearItems;
begin
  Clear;
end;

function TFhirManufacturedItemDefinitionComponentConstituentList.GetEnumerator : TFhirManufacturedItemDefinitionComponentConstituentListEnumerator;
begin
  result := TFhirManufacturedItemDefinitionComponentConstituentListEnumerator.Create(self.link);
end;

function TFhirManufacturedItemDefinitionComponentConstituentList.Clone: TFhirManufacturedItemDefinitionComponentConstituentList;
begin
  result := TFhirManufacturedItemDefinitionComponentConstituentList(inherited Clone);
end;

function TFhirManufacturedItemDefinitionComponentConstituentList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirManufacturedItemDefinitionComponentConstituentList.GetItemN(index: Integer): TFhirManufacturedItemDefinitionComponentConstituent;
begin
  result := TFhirManufacturedItemDefinitionComponentConstituent(ObjectByIndex[index]);
end;

function TFhirManufacturedItemDefinitionComponentConstituentList.ItemClass: TFslObjectClass;
begin
  result := TFhirManufacturedItemDefinitionComponentConstituent;
end;
function TFhirManufacturedItemDefinitionComponentConstituentList.IndexOf(value: TFhirManufacturedItemDefinitionComponentConstituent): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirManufacturedItemDefinitionComponentConstituentList.Insert(index: Integer): TFhirManufacturedItemDefinitionComponentConstituent;
begin
  result := TFhirManufacturedItemDefinitionComponentConstituent.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirManufacturedItemDefinitionComponentConstituentList.InsertItem(index: Integer; value: TFhirManufacturedItemDefinitionComponentConstituent);
begin
  assert(value is TFhirManufacturedItemDefinitionComponentConstituent);
  Inherited Insert(index, value);
end;

function TFhirManufacturedItemDefinitionComponentConstituentList.Item(index: Integer): TFhirManufacturedItemDefinitionComponentConstituent;
begin
  result := TFhirManufacturedItemDefinitionComponentConstituent(ObjectByIndex[index]);
end;

function TFhirManufacturedItemDefinitionComponentConstituentList.Link: TFhirManufacturedItemDefinitionComponentConstituentList;
begin
  result := TFhirManufacturedItemDefinitionComponentConstituentList(inherited Link);
end;

procedure TFhirManufacturedItemDefinitionComponentConstituentList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirManufacturedItemDefinitionComponentConstituentList.SetItemByIndex(index: Integer; value: TFhirManufacturedItemDefinitionComponentConstituent);
begin
  assert(value is TFhirManufacturedItemDefinitionComponentConstituent);
  FhirManufacturedItemDefinitionComponentConstituents[index] := value;
end;

procedure TFhirManufacturedItemDefinitionComponentConstituentList.SetItemN(index: Integer; value: TFhirManufacturedItemDefinitionComponentConstituent);
begin
  assert(value is TFhirManufacturedItemDefinitionComponentConstituent);
  ObjectByIndex[index] := value;
end;

{ TFhirManufacturedItemDefinition }

constructor TFhirManufacturedItemDefinition.Create;
begin
  inherited;
end;

destructor TFhirManufacturedItemDefinition.Destroy;
begin
  FIdentifierList.Free;
  FStatus.free;
  FName.free;
  FManufacturedDoseForm.free;
  FUnitOfPresentation.free;
  FManufacturerList.Free;
  FMarketingStatusList.Free;
  FIngredientList.Free;
  FProperty_List.Free;
  FComponentList.Free;
  inherited;
end;

procedure TFhirManufacturedItemDefinition.Assign(oSource : TFslObject);
begin
  inherited;
  if (TFhirManufacturedItemDefinition(oSource).FIdentifierList = nil) then
  begin
    FIdentifierList.free;
    FIdentifierList := nil;
  end
  else
  begin
    if FIdentifierList = nil then
      FIdentifierList := TFhirIdentifierList.Create;
    FIdentifierList.Assign(TFhirManufacturedItemDefinition(oSource).FIdentifierList);
  end;
  statusElement := TFhirManufacturedItemDefinition(oSource).statusElement.Clone;
  nameElement := TFhirManufacturedItemDefinition(oSource).nameElement.Clone;
  manufacturedDoseForm := TFhirManufacturedItemDefinition(oSource).manufacturedDoseForm.Clone;
  unitOfPresentation := TFhirManufacturedItemDefinition(oSource).unitOfPresentation.Clone;
  if (TFhirManufacturedItemDefinition(oSource).FManufacturerList = nil) then
  begin
    FManufacturerList.free;
    FManufacturerList := nil;
  end
  else
  begin
    if FManufacturerList = nil then
      FManufacturerList := TFhirReferenceList.Create;
    FManufacturerList.Assign(TFhirManufacturedItemDefinition(oSource).FManufacturerList);
  end;
  if (TFhirManufacturedItemDefinition(oSource).FMarketingStatusList = nil) then
  begin
    FMarketingStatusList.free;
    FMarketingStatusList := nil;
  end
  else
  begin
    if FMarketingStatusList = nil then
      FMarketingStatusList := TFhirMarketingStatusList.Create;
    FMarketingStatusList.Assign(TFhirManufacturedItemDefinition(oSource).FMarketingStatusList);
  end;
  if (TFhirManufacturedItemDefinition(oSource).FIngredientList = nil) then
  begin
    FIngredientList.free;
    FIngredientList := nil;
  end
  else
  begin
    if FIngredientList = nil then
      FIngredientList := TFhirCodeableConceptList.Create;
    FIngredientList.Assign(TFhirManufacturedItemDefinition(oSource).FIngredientList);
  end;
  if (TFhirManufacturedItemDefinition(oSource).FProperty_List = nil) then
  begin
    FProperty_List.free;
    FProperty_List := nil;
  end
  else
  begin
    if FProperty_List = nil then
      FProperty_List := TFhirManufacturedItemDefinitionPropertyList.Create;
    FProperty_List.Assign(TFhirManufacturedItemDefinition(oSource).FProperty_List);
  end;
  if (TFhirManufacturedItemDefinition(oSource).FComponentList = nil) then
  begin
    FComponentList.free;
    FComponentList := nil;
  end
  else
  begin
    if FComponentList = nil then
      FComponentList := TFhirManufacturedItemDefinitionComponentList.Create;
    FComponentList.Assign(TFhirManufacturedItemDefinition(oSource).FComponentList);
  end;
end;

function TFhirManufacturedItemDefinition.GetResourceType : TFhirResourceType;
begin
  result := frtManufacturedItemDefinition;
end;

procedure TFhirManufacturedItemDefinition.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'identifier') Then
    list.addAll(self, 'identifier', FIdentifierList);
  if (child_name = 'status') Then
     list.add(self.link, 'status', FStatus.Link);
  if (child_name = 'name') Then
     list.add(self.link, 'name', FName.Link);
  if (child_name = 'manufacturedDoseForm') Then
     list.add(self.link, 'manufacturedDoseForm', FManufacturedDoseForm.Link);
  if (child_name = 'unitOfPresentation') Then
     list.add(self.link, 'unitOfPresentation', FUnitOfPresentation.Link);
  if (child_name = 'manufacturer') Then
    list.addAll(self, 'manufacturer', FManufacturerList);
  if (child_name = 'marketingStatus') Then
    list.addAll(self, 'marketingStatus', FMarketingStatusList);
  if (child_name = 'ingredient') Then
    list.addAll(self, 'ingredient', FIngredientList);
  if (child_name = 'property') Then
    list.addAll(self, 'property', FProperty_List);
  if (child_name = 'component') Then
    list.addAll(self, 'component', FComponentList);
end;

procedure TFhirManufacturedItemDefinition.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'identifier', 'Identifier', true, TFhirIdentifier, FIdentifierList.Link));
  oList.add(TFHIRProperty.create(self, 'status', 'code', false, TFhirEnum, FStatus.Link));
  oList.add(TFHIRProperty.create(self, 'name', 'string', false, TFhirString, FName.Link));
  oList.add(TFHIRProperty.create(self, 'manufacturedDoseForm', 'CodeableConcept', false, TFhirCodeableConcept, FManufacturedDoseForm.Link));
  oList.add(TFHIRProperty.create(self, 'unitOfPresentation', 'CodeableConcept', false, TFhirCodeableConcept, FUnitOfPresentation.Link));
  oList.add(TFHIRProperty.create(self, 'manufacturer', 'Reference', true, TFhirReference, FManufacturerList.Link));
  oList.add(TFHIRProperty.create(self, 'marketingStatus', 'MarketingStatus', true, TFhirMarketingStatus, FMarketingStatusList.Link));
  oList.add(TFHIRProperty.create(self, 'ingredient', 'CodeableConcept', true, TFhirCodeableConcept, FIngredientList.Link));
  oList.add(TFHIRProperty.create(self, 'property', 'BackboneElement', true, TFhirManufacturedItemDefinitionProperty, FProperty_List.Link));
  oList.add(TFHIRProperty.create(self, 'component', 'BackboneElement', true, TFhirManufacturedItemDefinitionComponent, FComponentList.Link));
end;

function TFhirManufacturedItemDefinition.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'identifier') then
  begin
    IdentifierList.add(propValue as TFhirIdentifier);
    result := propValue;
  end
  else if (propName = 'status') then
  begin
    StatusElement := asEnum(SYSTEMS_TFhirPublicationStatusEnum, CODES_TFhirPublicationStatusEnum, propValue);
    result := propValue;
  end
  else if (propName = 'name') then
  begin
    NameElement := asString(propValue);
    result := propValue;
  end
  else if (propName = 'manufacturedDoseForm') then
  begin
    ManufacturedDoseForm := propValue as TFhirCodeableConcept;
    result := propValue;
  end
  else if (propName = 'unitOfPresentation') then
  begin
    UnitOfPresentation := propValue as TFhirCodeableConcept;
    result := propValue;
  end
  else if (propName = 'manufacturer') then
  begin
    ManufacturerList.add(propValue as TFhirReference);
    result := propValue;
  end
  else if (propName = 'marketingStatus') then
  begin
    MarketingStatusList.add(propValue as TFhirMarketingStatus);
    result := propValue;
  end
  else if (propName = 'ingredient') then
  begin
    IngredientList.add(propValue as TFhirCodeableConcept);
    result := propValue;
  end
  else if (propName = 'property') then
  begin
    Property_List.add(propValue as TFhirManufacturedItemDefinitionProperty);
    result := propValue;
  end
  else if (propName = 'component') then
  begin
    ComponentList.add(propValue as TFhirManufacturedItemDefinitionComponent);
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirManufacturedItemDefinition.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'identifier') then IdentifierList.insertItem(index, propValue as TFhirIdentifier)
  else if (propName = 'manufacturer') then ManufacturerList.insertItem(index, propValue as TFhirReference)
  else if (propName = 'marketingStatus') then MarketingStatusList.insertItem(index, propValue as TFhirMarketingStatus)
  else if (propName = 'ingredient') then IngredientList.insertItem(index, propValue as TFhirCodeableConcept)
  else if (propName = 'property') then Property_List.insertItem(index, propValue as TFhirManufacturedItemDefinitionProperty)
  else if (propName = 'component') then ComponentList.insertItem(index, propValue as TFhirManufacturedItemDefinitionComponent)
  else inherited;
end;

function TFhirManufacturedItemDefinition.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'identifier') then result := IdentifierList.new()
  else if (propName = 'status') then result := TFhirEnum.create(SYSTEMS_TFhirPublicationStatusEnum[PublicationStatusNull], CODES_TFhirPublicationStatusEnum[PublicationStatusNull]) 
  else if (propName = 'name') then result := TFhirString.create()
  else if (propName = 'manufacturedDoseForm') then result := TFhirCodeableConcept.create()
  else if (propName = 'unitOfPresentation') then result := TFhirCodeableConcept.create()
  else if (propName = 'manufacturer') then result := ManufacturerList.new()
  else if (propName = 'marketingStatus') then result := MarketingStatusList.new()
  else if (propName = 'ingredient') then result := IngredientList.new()
  else if (propName = 'property') then result := Property_List.new()
  else if (propName = 'component') then result := ComponentList.new()
  else result := inherited createPropertyValue(propName);
end;

function TFhirManufacturedItemDefinition.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'identifier') then result := 'Identifier'
  else if (propName = 'status') then result := 'code'
  else if (propName = 'name') then result := 'string'
  else if (propName = 'manufacturedDoseForm') then result := 'CodeableConcept'
  else if (propName = 'unitOfPresentation') then result := 'CodeableConcept'
  else if (propName = 'manufacturer') then result := 'Reference'
  else if (propName = 'marketingStatus') then result := 'MarketingStatus'
  else if (propName = 'ingredient') then result := 'CodeableConcept'
  else if (propName = 'property') then result := 'BackboneElement'
  else if (propName = 'component') then result := 'BackboneElement'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirManufacturedItemDefinition.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'identifier') then deletePropertyValue('identifier', IdentifierList, value)
  else if (propName = 'status') then StatusElement := nil
  else if (propName = 'name') then NameElement := nil
  else if (propName = 'manufacturedDoseForm') then ManufacturedDoseFormElement := nil
  else if (propName = 'unitOfPresentation') then UnitOfPresentationElement := nil
  else if (propName = 'manufacturer') then deletePropertyValue('manufacturer', ManufacturerList, value)
  else if (propName = 'marketingStatus') then deletePropertyValue('marketingStatus', MarketingStatusList, value)
  else if (propName = 'ingredient') then deletePropertyValue('ingredient', IngredientList, value)
  else if (propName = 'property') then deletePropertyValue('property', Property_List, value)
  else if (propName = 'component') then deletePropertyValue('component', ComponentList, value)
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirManufacturedItemDefinition.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'identifier') then replacePropertyValue('identifier', IdentifierList, existing, new)
  else if (propName = 'status') then StatusElement := asEnum(SYSTEMS_TFhirPublicationStatusEnum, CODES_TFhirPublicationStatusEnum, new)
  else if (propName = 'name') then NameElement := asString(new)
  else if (propName = 'manufacturedDoseForm') then ManufacturedDoseFormElement := new as TFhirCodeableConcept
  else if (propName = 'unitOfPresentation') then UnitOfPresentationElement := new as TFhirCodeableConcept
  else if (propName = 'manufacturer') then replacePropertyValue('manufacturer', ManufacturerList, existing, new)
  else if (propName = 'marketingStatus') then replacePropertyValue('marketingStatus', MarketingStatusList, existing, new)
  else if (propName = 'ingredient') then replacePropertyValue('ingredient', IngredientList, existing, new)
  else if (propName = 'property') then replacePropertyValue('property', Property_List, existing, new)
  else if (propName = 'component') then replacePropertyValue('component', ComponentList, existing, new)
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirManufacturedItemDefinition.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'identifier') then IdentifierList.move(source, destination)
  else if (propName = 'manufacturer') then ManufacturerList.move(source, destination)
  else if (propName = 'marketingStatus') then MarketingStatusList.move(source, destination)
  else if (propName = 'ingredient') then IngredientList.move(source, destination)
  else if (propName = 'property') then Property_List.move(source, destination)
  else if (propName = 'component') then ComponentList.move(source, destination)
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirManufacturedItemDefinition.fhirType : string;
begin
  result := 'ManufacturedItemDefinition';
end;

function TFhirManufacturedItemDefinition.Link : TFhirManufacturedItemDefinition;
begin
  result := TFhirManufacturedItemDefinition(inherited Link);
end;

function TFhirManufacturedItemDefinition.Clone : TFhirManufacturedItemDefinition;
begin
  result := TFhirManufacturedItemDefinition(inherited Clone);
end;

function TFhirManufacturedItemDefinition.equals(other : TObject) : boolean; 
var
  o : TFhirManufacturedItemDefinition;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirManufacturedItemDefinition)) then
    result := false
  else
  begin
    o := TFhirManufacturedItemDefinition(other);
    result := compareDeep(identifierList, o.identifierList, true) and compareDeep(statusElement, o.statusElement, true) and 
      compareDeep(nameElement, o.nameElement, true) and compareDeep(manufacturedDoseFormElement, o.manufacturedDoseFormElement, true) and 
      compareDeep(unitOfPresentationElement, o.unitOfPresentationElement, true) and 
      compareDeep(manufacturerList, o.manufacturerList, true) and compareDeep(marketingStatusList, o.marketingStatusList, true) and 
      compareDeep(ingredientList, o.ingredientList, true) and compareDeep(property_List, o.property_List, true) and 
      compareDeep(componentList, o.componentList, true);
  end;
end;

function TFhirManufacturedItemDefinition.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FidentifierList) and isEmptyProp(FStatus) and isEmptyProp(FName) and isEmptyProp(FManufacturedDoseForm) and isEmptyProp(FUnitOfPresentation) and isEmptyProp(FmanufacturerList) and isEmptyProp(FmarketingStatusList) and isEmptyProp(FingredientList) and isEmptyProp(Fproperty_List) and isEmptyProp(FcomponentList);
end;

procedure TFhirManufacturedItemDefinition.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('identifier');
  fields.add('status');
  fields.add('name');
  fields.add('manufacturedDoseForm');
  fields.add('unitOfPresentation');
  fields.add('manufacturer');
  fields.add('marketingStatus');
  fields.add('ingredient');
  fields.add('property');
  fields.add('component');
end;

function TFhirManufacturedItemDefinition.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
  inc(result, FIdentifierList.sizeInBytes(magic));
  inc(result, FManufacturerList.sizeInBytes(magic));
  inc(result, FMarketingStatusList.sizeInBytes(magic));
  inc(result, FIngredientList.sizeInBytes(magic));
  inc(result, FProperty_List.sizeInBytes(magic));
  inc(result, FComponentList.sizeInBytes(magic));
end;

function TFhirManufacturedItemDefinition.GetIdentifierList : TFhirIdentifierList;
begin
  if FIdentifierList = nil then
    FIdentifierList := TFhirIdentifierList.Create;
  result := FIdentifierList;
end;

function TFhirManufacturedItemDefinition.GetHasIdentifierList : boolean;
begin
  result := (FIdentifierList <> nil) and (FIdentifierList.count > 0);
end;

procedure TFhirManufacturedItemDefinition.SetStatus(value : TFhirEnum);
begin
  FStatus.free;
  FStatus := value;
end;

function TFhirManufacturedItemDefinition.GetStatusST : TFhirPublicationStatusEnum;
begin
  if FStatus = nil then
    result := TFhirPublicationStatusEnum(0)
  else
    result := TFhirPublicationStatusEnum(StringArrayIndexOfSensitive(CODES_TFhirPublicationStatusEnum, FStatus.value));
end;

procedure TFhirManufacturedItemDefinition.SetStatusST(value : TFhirPublicationStatusEnum);
begin
  if ord(value) = 0 then
    StatusElement := nil
  else
    StatusElement := TFhirEnum.create(SYSTEMS_TFhirPublicationStatusEnum[value], CODES_TFhirPublicationStatusEnum[value]);
end;

procedure TFhirManufacturedItemDefinition.SetName(value : TFhirString);
begin
  FName.free;
  FName := value;
end;

function TFhirManufacturedItemDefinition.GetNameST : String;
begin
  if FName = nil then
    result := ''
  else
    result := FName.value;
end;

procedure TFhirManufacturedItemDefinition.SetNameST(value : String);
begin
  if value <> '' then
  begin
    if FName = nil then
      FName := TFhirString.create;
    FName.value := value
  end
  else if FName <> nil then
    FName.value := '';
end;

procedure TFhirManufacturedItemDefinition.SetManufacturedDoseForm(value : TFhirCodeableConcept);
begin
  FManufacturedDoseForm.free;
  FManufacturedDoseForm := value;
end;

procedure TFhirManufacturedItemDefinition.SetUnitOfPresentation(value : TFhirCodeableConcept);
begin
  FUnitOfPresentation.free;
  FUnitOfPresentation := value;
end;

function TFhirManufacturedItemDefinition.GetManufacturerList : TFhirReferenceList;
begin
  if FManufacturerList = nil then
    FManufacturerList := TFhirReferenceList.Create;
  result := FManufacturerList;
end;

function TFhirManufacturedItemDefinition.GetHasManufacturerList : boolean;
begin
  result := (FManufacturerList <> nil) and (FManufacturerList.count > 0);
end;

function TFhirManufacturedItemDefinition.GetMarketingStatusList : TFhirMarketingStatusList;
begin
  if FMarketingStatusList = nil then
    FMarketingStatusList := TFhirMarketingStatusList.Create;
  result := FMarketingStatusList;
end;

function TFhirManufacturedItemDefinition.GetHasMarketingStatusList : boolean;
begin
  result := (FMarketingStatusList <> nil) and (FMarketingStatusList.count > 0);
end;

function TFhirManufacturedItemDefinition.GetIngredientList : TFhirCodeableConceptList;
begin
  if FIngredientList = nil then
    FIngredientList := TFhirCodeableConceptList.Create;
  result := FIngredientList;
end;

function TFhirManufacturedItemDefinition.GetHasIngredientList : boolean;
begin
  result := (FIngredientList <> nil) and (FIngredientList.count > 0);
end;

function TFhirManufacturedItemDefinition.GetProperty_List : TFhirManufacturedItemDefinitionPropertyList;
begin
  if FProperty_List = nil then
    FProperty_List := TFhirManufacturedItemDefinitionPropertyList.Create;
  result := FProperty_List;
end;

function TFhirManufacturedItemDefinition.GetHasProperty_List : boolean;
begin
  result := (FProperty_List <> nil) and (FProperty_List.count > 0);
end;

function TFhirManufacturedItemDefinition.GetComponentList : TFhirManufacturedItemDefinitionComponentList;
begin
  if FComponentList = nil then
    FComponentList := TFhirManufacturedItemDefinitionComponentList.Create;
  result := FComponentList;
end;

function TFhirManufacturedItemDefinition.GetHasComponentList : boolean;
begin
  result := (FComponentList <> nil) and (FComponentList.count > 0);
end;

{ TFhirManufacturedItemDefinitionListEnumerator }

constructor TFhirManufacturedItemDefinitionListEnumerator.Create(list : TFhirManufacturedItemDefinitionList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirManufacturedItemDefinitionListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirManufacturedItemDefinitionListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirManufacturedItemDefinitionListEnumerator.GetCurrent : TFhirManufacturedItemDefinition;
begin
  Result := FList[FIndex];
end;

function TFhirManufacturedItemDefinitionListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirManufacturedItemDefinitionList }

function TFhirManufacturedItemDefinitionList.AddItem(value: TFhirManufacturedItemDefinition): TFhirManufacturedItemDefinition;
begin
  assert(value.ClassName = 'TFhirManufacturedItemDefinition', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirManufacturedItemDefinition');
  add(value);
  result := value;
end;

function TFhirManufacturedItemDefinitionList.Append: TFhirManufacturedItemDefinition;
begin
  result := TFhirManufacturedItemDefinition.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirManufacturedItemDefinitionList.ClearItems;
begin
  Clear;
end;

function TFhirManufacturedItemDefinitionList.GetEnumerator : TFhirManufacturedItemDefinitionListEnumerator;
begin
  result := TFhirManufacturedItemDefinitionListEnumerator.Create(self.link);
end;

function TFhirManufacturedItemDefinitionList.Clone: TFhirManufacturedItemDefinitionList;
begin
  result := TFhirManufacturedItemDefinitionList(inherited Clone);
end;

function TFhirManufacturedItemDefinitionList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirManufacturedItemDefinitionList.GetItemN(index: Integer): TFhirManufacturedItemDefinition;
begin
  result := TFhirManufacturedItemDefinition(ObjectByIndex[index]);
end;

function TFhirManufacturedItemDefinitionList.ItemClass: TFslObjectClass;
begin
  result := TFhirManufacturedItemDefinition;
end;
function TFhirManufacturedItemDefinitionList.IndexOf(value: TFhirManufacturedItemDefinition): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirManufacturedItemDefinitionList.Insert(index: Integer): TFhirManufacturedItemDefinition;
begin
  result := TFhirManufacturedItemDefinition.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirManufacturedItemDefinitionList.InsertItem(index: Integer; value: TFhirManufacturedItemDefinition);
begin
  assert(value is TFhirManufacturedItemDefinition);
  Inherited Insert(index, value);
end;

function TFhirManufacturedItemDefinitionList.Item(index: Integer): TFhirManufacturedItemDefinition;
begin
  result := TFhirManufacturedItemDefinition(ObjectByIndex[index]);
end;

function TFhirManufacturedItemDefinitionList.Link: TFhirManufacturedItemDefinitionList;
begin
  result := TFhirManufacturedItemDefinitionList(inherited Link);
end;

procedure TFhirManufacturedItemDefinitionList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirManufacturedItemDefinitionList.SetItemByIndex(index: Integer; value: TFhirManufacturedItemDefinition);
begin
  assert(value is TFhirManufacturedItemDefinition);
  FhirManufacturedItemDefinitions[index] := value;
end;

procedure TFhirManufacturedItemDefinitionList.SetItemN(index: Integer; value: TFhirManufacturedItemDefinition);
begin
  assert(value is TFhirManufacturedItemDefinition);
  ObjectByIndex[index] := value;
end;

{$ENDIF FHIR_MANUFACTUREDITEMDEFINITION}
{$IFDEF FHIR_MEDICATION}
{ TFhirMedicationIngredient }

constructor TFhirMedicationIngredient.Create;
begin
  inherited;
end;

destructor TFhirMedicationIngredient.Destroy;
begin
  FItem.free;
  FIsActive.free;
  FStrength.free;
  inherited;
end;

procedure TFhirMedicationIngredient.Assign(oSource : TFslObject);
begin
  inherited;
  item := TFhirMedicationIngredient(oSource).item.Clone;
  isActiveElement := TFhirMedicationIngredient(oSource).isActiveElement.Clone;
  strength := TFhirMedicationIngredient(oSource).strength.Clone;
end;

procedure TFhirMedicationIngredient.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'item') Then
     list.add(self.link, 'item', FItem.Link);
  if (child_name = 'isActive') Then
     list.add(self.link, 'isActive', FIsActive.Link);
  if (child_name = 'strength[x]') or (child_name = 'strength') Then
     list.add(self.link, 'strength[x]', FStrength.Link);
end;

procedure TFhirMedicationIngredient.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'item', 'CodeableReference', false, TFhirCodeableReference, FItem.Link));
  oList.add(TFHIRProperty.create(self, 'isActive', 'boolean', false, TFhirBoolean, FIsActive.Link));
  oList.add(TFHIRProperty.create(self, 'strength[x]', 'Ratio|CodeableConcept|Quantity', false, TFhirDataType, FStrength.Link));
end;

function TFhirMedicationIngredient.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'item') then
  begin
    Item := propValue as TFhirCodeableReference;
    result := propValue;
  end
  else if (propName = 'isActive') then
  begin
    IsActiveElement := asBoolean(propValue);
    result := propValue;
  end
  else if (isMatchingName(propName, 'strength', ['Ratio', 'CodeableConcept', 'Quantity'])) then
  begin
    Strength := propValue as TFhirDataType;
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirMedicationIngredient.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirMedicationIngredient.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'item') then result := TFhirCodeableReference.create()
  else if (propName = 'isActive') then result := TFhirBoolean.create()
  else if (isMatchingName(propName, 'strength', ['Ratio', 'CodeableConcept', 'Quantity'])) then raise EFHIRException.create('Cannot make property Strength')
  else result := inherited createPropertyValue(propName);
end;

function TFhirMedicationIngredient.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'item') then result := 'CodeableReference'
  else if (propName = 'isActive') then result := 'boolean'
  else if (propName = 'strength[x]') then result := 'Ratio|CodeableConcept|Quantity'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirMedicationIngredient.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'item') then ItemElement := nil
  else if (propName = 'isActive') then IsActiveElement := nil
  else if (isMatchingName(propName, 'strength', ['Ratio', 'CodeableConcept', 'Quantity'])) then StrengthElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirMedicationIngredient.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'item') then ItemElement := new as TFhirCodeableReference
  else if (propName = 'isActive') then IsActiveElement := asBoolean(new)
  else if (isMatchingName(propName, 'strength', ['Ratio', 'CodeableConcept', 'Quantity'])) then StrengthElement := new as TFhirDataType
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirMedicationIngredient.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirMedicationIngredient.fhirType : string;
begin
  result := 'Medication.ingredient';
end;

function TFhirMedicationIngredient.Link : TFhirMedicationIngredient;
begin
  result := TFhirMedicationIngredient(inherited Link);
end;

function TFhirMedicationIngredient.Clone : TFhirMedicationIngredient;
begin
  result := TFhirMedicationIngredient(inherited Clone);
end;

function TFhirMedicationIngredient.equals(other : TObject) : boolean; 
var
  o : TFhirMedicationIngredient;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirMedicationIngredient)) then
    result := false
  else
  begin
    o := TFhirMedicationIngredient(other);
    result := compareDeep(itemElement, o.itemElement, true) and compareDeep(isActiveElement, o.isActiveElement, true) and 
      compareDeep(strengthElement, o.strengthElement, true);
  end;
end;

function TFhirMedicationIngredient.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FItem) and isEmptyProp(FIsActive) and isEmptyProp(FStrength);
end;

procedure TFhirMedicationIngredient.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('item');
  fields.add('isActive');
  fields.add('strength[x]');
end;

function TFhirMedicationIngredient.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
end;

procedure TFhirMedicationIngredient.SetItem(value : TFhirCodeableReference);
begin
  FItem.free;
  FItem := value;
end;

procedure TFhirMedicationIngredient.SetIsActive(value : TFhirBoolean);
begin
  FIsActive.free;
  FIsActive := value;
end;

function TFhirMedicationIngredient.GetIsActiveST : Boolean;
begin
  if FIsActive = nil then
    result := false
  else
    result := FIsActive.value;
end;

procedure TFhirMedicationIngredient.SetIsActiveST(value : Boolean);
begin
  if FIsActive = nil then
    FIsActive := TFhirBoolean.create;
  FIsActive.value := value
end;

procedure TFhirMedicationIngredient.SetStrength(value : TFhirDataType);
begin
  FStrength.free;
  FStrength := value;
end;

{ TFhirMedicationIngredientListEnumerator }

constructor TFhirMedicationIngredientListEnumerator.Create(list : TFhirMedicationIngredientList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirMedicationIngredientListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirMedicationIngredientListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirMedicationIngredientListEnumerator.GetCurrent : TFhirMedicationIngredient;
begin
  Result := FList[FIndex];
end;

function TFhirMedicationIngredientListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirMedicationIngredientList }

function TFhirMedicationIngredientList.AddItem(value: TFhirMedicationIngredient): TFhirMedicationIngredient;
begin
  assert(value.ClassName = 'TFhirMedicationIngredient', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirMedicationIngredient');
  add(value);
  result := value;
end;

function TFhirMedicationIngredientList.Append: TFhirMedicationIngredient;
begin
  result := TFhirMedicationIngredient.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirMedicationIngredientList.ClearItems;
begin
  Clear;
end;

function TFhirMedicationIngredientList.GetEnumerator : TFhirMedicationIngredientListEnumerator;
begin
  result := TFhirMedicationIngredientListEnumerator.Create(self.link);
end;

function TFhirMedicationIngredientList.Clone: TFhirMedicationIngredientList;
begin
  result := TFhirMedicationIngredientList(inherited Clone);
end;

function TFhirMedicationIngredientList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirMedicationIngredientList.GetItemN(index: Integer): TFhirMedicationIngredient;
begin
  result := TFhirMedicationIngredient(ObjectByIndex[index]);
end;

function TFhirMedicationIngredientList.ItemClass: TFslObjectClass;
begin
  result := TFhirMedicationIngredient;
end;
function TFhirMedicationIngredientList.IndexOf(value: TFhirMedicationIngredient): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirMedicationIngredientList.Insert(index: Integer): TFhirMedicationIngredient;
begin
  result := TFhirMedicationIngredient.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirMedicationIngredientList.InsertItem(index: Integer; value: TFhirMedicationIngredient);
begin
  assert(value is TFhirMedicationIngredient);
  Inherited Insert(index, value);
end;

function TFhirMedicationIngredientList.Item(index: Integer): TFhirMedicationIngredient;
begin
  result := TFhirMedicationIngredient(ObjectByIndex[index]);
end;

function TFhirMedicationIngredientList.Link: TFhirMedicationIngredientList;
begin
  result := TFhirMedicationIngredientList(inherited Link);
end;

procedure TFhirMedicationIngredientList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirMedicationIngredientList.SetItemByIndex(index: Integer; value: TFhirMedicationIngredient);
begin
  assert(value is TFhirMedicationIngredient);
  FhirMedicationIngredients[index] := value;
end;

procedure TFhirMedicationIngredientList.SetItemN(index: Integer; value: TFhirMedicationIngredient);
begin
  assert(value is TFhirMedicationIngredient);
  ObjectByIndex[index] := value;
end;

{ TFhirMedicationBatch }

constructor TFhirMedicationBatch.Create;
begin
  inherited;
end;

destructor TFhirMedicationBatch.Destroy;
begin
  FLotNumber.free;
  FExpirationDate.free;
  inherited;
end;

procedure TFhirMedicationBatch.Assign(oSource : TFslObject);
begin
  inherited;
  lotNumberElement := TFhirMedicationBatch(oSource).lotNumberElement.Clone;
  expirationDateElement := TFhirMedicationBatch(oSource).expirationDateElement.Clone;
end;

procedure TFhirMedicationBatch.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'lotNumber') Then
     list.add(self.link, 'lotNumber', FLotNumber.Link);
  if (child_name = 'expirationDate') Then
     list.add(self.link, 'expirationDate', FExpirationDate.Link);
end;

procedure TFhirMedicationBatch.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'lotNumber', 'string', false, TFhirString, FLotNumber.Link));
  oList.add(TFHIRProperty.create(self, 'expirationDate', 'dateTime', false, TFhirDateTime, FExpirationDate.Link));
end;

function TFhirMedicationBatch.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'lotNumber') then
  begin
    LotNumberElement := asString(propValue);
    result := propValue;
  end
  else if (propName = 'expirationDate') then
  begin
    ExpirationDateElement := asDateTime(propValue);
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirMedicationBatch.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirMedicationBatch.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'lotNumber') then result := TFhirString.create()
  else if (propName = 'expirationDate') then result := TFhirDateTime.create()
  else result := inherited createPropertyValue(propName);
end;

function TFhirMedicationBatch.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'lotNumber') then result := 'string'
  else if (propName = 'expirationDate') then result := 'dateTime'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirMedicationBatch.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'lotNumber') then LotNumberElement := nil
  else if (propName = 'expirationDate') then ExpirationDateElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirMedicationBatch.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'lotNumber') then LotNumberElement := asString(new)
  else if (propName = 'expirationDate') then ExpirationDateElement := asDateTime(new)
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirMedicationBatch.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirMedicationBatch.fhirType : string;
begin
  result := 'Medication.batch';
end;

function TFhirMedicationBatch.Link : TFhirMedicationBatch;
begin
  result := TFhirMedicationBatch(inherited Link);
end;

function TFhirMedicationBatch.Clone : TFhirMedicationBatch;
begin
  result := TFhirMedicationBatch(inherited Clone);
end;

function TFhirMedicationBatch.equals(other : TObject) : boolean; 
var
  o : TFhirMedicationBatch;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirMedicationBatch)) then
    result := false
  else
  begin
    o := TFhirMedicationBatch(other);
    result := compareDeep(lotNumberElement, o.lotNumberElement, true) and compareDeep(expirationDateElement, o.expirationDateElement, true);
  end;
end;

function TFhirMedicationBatch.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FLotNumber) and isEmptyProp(FExpirationDate);
end;

procedure TFhirMedicationBatch.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('lotNumber');
  fields.add('expirationDate');
end;

function TFhirMedicationBatch.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
end;

procedure TFhirMedicationBatch.SetLotNumber(value : TFhirString);
begin
  FLotNumber.free;
  FLotNumber := value;
end;

function TFhirMedicationBatch.GetLotNumberST : String;
begin
  if FLotNumber = nil then
    result := ''
  else
    result := FLotNumber.value;
end;

procedure TFhirMedicationBatch.SetLotNumberST(value : String);
begin
  if value <> '' then
  begin
    if FLotNumber = nil then
      FLotNumber := TFhirString.create;
    FLotNumber.value := value
  end
  else if FLotNumber <> nil then
    FLotNumber.value := '';
end;

procedure TFhirMedicationBatch.SetExpirationDate(value : TFhirDateTime);
begin
  FExpirationDate.free;
  FExpirationDate := value;
end;

function TFhirMedicationBatch.GetExpirationDateST : TFslDateTime;
begin
  if FExpirationDate = nil then
    result := TFslDateTime.makeNull
  else
    result := FExpirationDate.value;
end;

procedure TFhirMedicationBatch.SetExpirationDateST(value : TFslDateTime);
begin
  if FExpirationDate = nil then
    FExpirationDate := TFhirDateTime.create;
  FExpirationDate.value := value
end;

{ TFhirMedicationBatchListEnumerator }

constructor TFhirMedicationBatchListEnumerator.Create(list : TFhirMedicationBatchList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirMedicationBatchListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirMedicationBatchListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirMedicationBatchListEnumerator.GetCurrent : TFhirMedicationBatch;
begin
  Result := FList[FIndex];
end;

function TFhirMedicationBatchListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirMedicationBatchList }

function TFhirMedicationBatchList.AddItem(value: TFhirMedicationBatch): TFhirMedicationBatch;
begin
  assert(value.ClassName = 'TFhirMedicationBatch', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirMedicationBatch');
  add(value);
  result := value;
end;

function TFhirMedicationBatchList.Append: TFhirMedicationBatch;
begin
  result := TFhirMedicationBatch.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirMedicationBatchList.ClearItems;
begin
  Clear;
end;

function TFhirMedicationBatchList.GetEnumerator : TFhirMedicationBatchListEnumerator;
begin
  result := TFhirMedicationBatchListEnumerator.Create(self.link);
end;

function TFhirMedicationBatchList.Clone: TFhirMedicationBatchList;
begin
  result := TFhirMedicationBatchList(inherited Clone);
end;

function TFhirMedicationBatchList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirMedicationBatchList.GetItemN(index: Integer): TFhirMedicationBatch;
begin
  result := TFhirMedicationBatch(ObjectByIndex[index]);
end;

function TFhirMedicationBatchList.ItemClass: TFslObjectClass;
begin
  result := TFhirMedicationBatch;
end;
function TFhirMedicationBatchList.IndexOf(value: TFhirMedicationBatch): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirMedicationBatchList.Insert(index: Integer): TFhirMedicationBatch;
begin
  result := TFhirMedicationBatch.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirMedicationBatchList.InsertItem(index: Integer; value: TFhirMedicationBatch);
begin
  assert(value is TFhirMedicationBatch);
  Inherited Insert(index, value);
end;

function TFhirMedicationBatchList.Item(index: Integer): TFhirMedicationBatch;
begin
  result := TFhirMedicationBatch(ObjectByIndex[index]);
end;

function TFhirMedicationBatchList.Link: TFhirMedicationBatchList;
begin
  result := TFhirMedicationBatchList(inherited Link);
end;

procedure TFhirMedicationBatchList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirMedicationBatchList.SetItemByIndex(index: Integer; value: TFhirMedicationBatch);
begin
  assert(value is TFhirMedicationBatch);
  FhirMedicationBatches[index] := value;
end;

procedure TFhirMedicationBatchList.SetItemN(index: Integer; value: TFhirMedicationBatch);
begin
  assert(value is TFhirMedicationBatch);
  ObjectByIndex[index] := value;
end;

{ TFhirMedication }

constructor TFhirMedication.Create;
begin
  inherited;
end;

destructor TFhirMedication.Destroy;
begin
  FIdentifierList.Free;
  FCode.free;
  FStatus.free;
  FMarketingAuthorizationHolder.free;
  FDoseForm.free;
  FTotalVolume.free;
  FIngredientList.Free;
  FBatch.free;
  inherited;
end;

procedure TFhirMedication.Assign(oSource : TFslObject);
begin
  inherited;
  if (TFhirMedication(oSource).FIdentifierList = nil) then
  begin
    FIdentifierList.free;
    FIdentifierList := nil;
  end
  else
  begin
    if FIdentifierList = nil then
      FIdentifierList := TFhirIdentifierList.Create;
    FIdentifierList.Assign(TFhirMedication(oSource).FIdentifierList);
  end;
  code := TFhirMedication(oSource).code.Clone;
  statusElement := TFhirMedication(oSource).statusElement.Clone;
  marketingAuthorizationHolder := TFhirMedication(oSource).marketingAuthorizationHolder.Clone;
  doseForm := TFhirMedication(oSource).doseForm.Clone;
  totalVolume := TFhirMedication(oSource).totalVolume.Clone;
  if (TFhirMedication(oSource).FIngredientList = nil) then
  begin
    FIngredientList.free;
    FIngredientList := nil;
  end
  else
  begin
    if FIngredientList = nil then
      FIngredientList := TFhirMedicationIngredientList.Create;
    FIngredientList.Assign(TFhirMedication(oSource).FIngredientList);
  end;
  batch := TFhirMedication(oSource).batch.Clone;
end;

function TFhirMedication.GetResourceType : TFhirResourceType;
begin
  result := frtMedication;
end;

procedure TFhirMedication.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'identifier') Then
    list.addAll(self, 'identifier', FIdentifierList);
  if (child_name = 'code') Then
     list.add(self.link, 'code', FCode.Link);
  if (child_name = 'status') Then
     list.add(self.link, 'status', FStatus.Link);
  if (child_name = 'marketingAuthorizationHolder') Then
     list.add(self.link, 'marketingAuthorizationHolder', FMarketingAuthorizationHolder.Link);
  if (child_name = 'doseForm') Then
     list.add(self.link, 'doseForm', FDoseForm.Link);
  if (child_name = 'totalVolume') Then
     list.add(self.link, 'totalVolume', FTotalVolume.Link);
  if (child_name = 'ingredient') Then
    list.addAll(self, 'ingredient', FIngredientList);
  if (child_name = 'batch') Then
     list.add(self.link, 'batch', FBatch.Link);
end;

procedure TFhirMedication.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'identifier', 'Identifier', true, TFhirIdentifier, FIdentifierList.Link));
  oList.add(TFHIRProperty.create(self, 'code', 'CodeableConcept', false, TFhirCodeableConcept, FCode.Link));
  oList.add(TFHIRProperty.create(self, 'status', 'code', false, TFhirEnum, FStatus.Link));
  oList.add(TFHIRProperty.create(self, 'marketingAuthorizationHolder', 'Reference', false, TFhirReference, FMarketingAuthorizationHolder.Link));
  oList.add(TFHIRProperty.create(self, 'doseForm', 'CodeableConcept', false, TFhirCodeableConcept, FDoseForm.Link));
  oList.add(TFHIRProperty.create(self, 'totalVolume', 'Ratio', false, TFhirRatio, FTotalVolume.Link));
  oList.add(TFHIRProperty.create(self, 'ingredient', 'BackboneElement', true, TFhirMedicationIngredient, FIngredientList.Link));
  oList.add(TFHIRProperty.create(self, 'batch', 'BackboneElement', false, TFhirMedicationBatch, FBatch.Link));
end;

function TFhirMedication.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'identifier') then
  begin
    IdentifierList.add(propValue as TFhirIdentifier);
    result := propValue;
  end
  else if (propName = 'code') then
  begin
    Code := propValue as TFhirCodeableConcept;
    result := propValue;
  end
  else if (propName = 'status') then
  begin
    StatusElement := asEnum(SYSTEMS_TFhirMedicationStatusCodesEnum, CODES_TFhirMedicationStatusCodesEnum, propValue);
    result := propValue;
  end
  else if (propName = 'marketingAuthorizationHolder') then
  begin
    MarketingAuthorizationHolder := propValue as TFhirReference;
    result := propValue;
  end
  else if (propName = 'doseForm') then
  begin
    DoseForm := propValue as TFhirCodeableConcept;
    result := propValue;
  end
  else if (propName = 'totalVolume') then
  begin
    TotalVolume := propValue as TFhirRatio;
    result := propValue;
  end
  else if (propName = 'ingredient') then
  begin
    IngredientList.add(propValue as TFhirMedicationIngredient);
    result := propValue;
  end
  else if (propName = 'batch') then
  begin
    Batch := propValue as TFhirMedicationBatch;
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirMedication.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'identifier') then IdentifierList.insertItem(index, propValue as TFhirIdentifier)
  else if (propName = 'ingredient') then IngredientList.insertItem(index, propValue as TFhirMedicationIngredient)
  else inherited;
end;

function TFhirMedication.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'identifier') then result := IdentifierList.new()
  else if (propName = 'code') then result := TFhirCodeableConcept.create()
  else if (propName = 'status') then result := TFhirEnum.create(SYSTEMS_TFhirMedicationStatusCodesEnum[MedicationStatusCodesNull], CODES_TFhirMedicationStatusCodesEnum[MedicationStatusCodesNull]) 
  else if (propName = 'marketingAuthorizationHolder') then result := TFhirReference.create()
  else if (propName = 'doseForm') then result := TFhirCodeableConcept.create()
  else if (propName = 'totalVolume') then result := TFhirRatio.create()
  else if (propName = 'ingredient') then result := IngredientList.new()
  else if (propName = 'batch') then result := TFhirMedicationBatch.create()
  else result := inherited createPropertyValue(propName);
end;

function TFhirMedication.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'identifier') then result := 'Identifier'
  else if (propName = 'code') then result := 'CodeableConcept'
  else if (propName = 'status') then result := 'code'
  else if (propName = 'marketingAuthorizationHolder') then result := 'Reference'
  else if (propName = 'doseForm') then result := 'CodeableConcept'
  else if (propName = 'totalVolume') then result := 'Ratio'
  else if (propName = 'ingredient') then result := 'BackboneElement'
  else if (propName = 'batch') then result := 'BackboneElement'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirMedication.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'identifier') then deletePropertyValue('identifier', IdentifierList, value)
  else if (propName = 'code') then CodeElement := nil
  else if (propName = 'status') then StatusElement := nil
  else if (propName = 'marketingAuthorizationHolder') then MarketingAuthorizationHolderElement := nil
  else if (propName = 'doseForm') then DoseFormElement := nil
  else if (propName = 'totalVolume') then TotalVolumeElement := nil
  else if (propName = 'ingredient') then deletePropertyValue('ingredient', IngredientList, value)
  else if (propName = 'batch') then BatchElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirMedication.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'identifier') then replacePropertyValue('identifier', IdentifierList, existing, new)
  else if (propName = 'code') then CodeElement := new as TFhirCodeableConcept
  else if (propName = 'status') then StatusElement := asEnum(SYSTEMS_TFhirMedicationStatusCodesEnum, CODES_TFhirMedicationStatusCodesEnum, new)
  else if (propName = 'marketingAuthorizationHolder') then MarketingAuthorizationHolderElement := new as TFhirReference
  else if (propName = 'doseForm') then DoseFormElement := new as TFhirCodeableConcept
  else if (propName = 'totalVolume') then TotalVolumeElement := new as TFhirRatio
  else if (propName = 'ingredient') then replacePropertyValue('ingredient', IngredientList, existing, new)
  else if (propName = 'batch') then BatchElement := new as TFhirMedicationBatch
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirMedication.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'identifier') then IdentifierList.move(source, destination)
  else if (propName = 'ingredient') then IngredientList.move(source, destination)
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirMedication.fhirType : string;
begin
  result := 'Medication';
end;

function TFhirMedication.Link : TFhirMedication;
begin
  result := TFhirMedication(inherited Link);
end;

function TFhirMedication.Clone : TFhirMedication;
begin
  result := TFhirMedication(inherited Clone);
end;

function TFhirMedication.equals(other : TObject) : boolean; 
var
  o : TFhirMedication;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirMedication)) then
    result := false
  else
  begin
    o := TFhirMedication(other);
    result := compareDeep(identifierList, o.identifierList, true) and compareDeep(codeElement, o.codeElement, true) and 
      compareDeep(statusElement, o.statusElement, true) and compareDeep(marketingAuthorizationHolderElement, o.marketingAuthorizationHolderElement, true) and 
      compareDeep(doseFormElement, o.doseFormElement, true) and compareDeep(totalVolumeElement, o.totalVolumeElement, true) and 
      compareDeep(ingredientList, o.ingredientList, true) and compareDeep(batchElement, o.batchElement, true);
  end;
end;

function TFhirMedication.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FidentifierList) and isEmptyProp(FCode) and isEmptyProp(FStatus) and isEmptyProp(FMarketingAuthorizationHolder) and isEmptyProp(FDoseForm) and isEmptyProp(FTotalVolume) and isEmptyProp(FingredientList) and isEmptyProp(FBatch);
end;

procedure TFhirMedication.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('identifier');
  fields.add('code');
  fields.add('status');
  fields.add('marketingAuthorizationHolder');
  fields.add('doseForm');
  fields.add('totalVolume');
  fields.add('ingredient');
  fields.add('batch');
end;

function TFhirMedication.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
  inc(result, FIdentifierList.sizeInBytes(magic));
  inc(result, FIngredientList.sizeInBytes(magic));
end;

function TFhirMedication.GetIdentifierList : TFhirIdentifierList;
begin
  if FIdentifierList = nil then
    FIdentifierList := TFhirIdentifierList.Create;
  result := FIdentifierList;
end;

function TFhirMedication.GetHasIdentifierList : boolean;
begin
  result := (FIdentifierList <> nil) and (FIdentifierList.count > 0);
end;

procedure TFhirMedication.SetCode(value : TFhirCodeableConcept);
begin
  FCode.free;
  FCode := value;
end;

procedure TFhirMedication.SetStatus(value : TFhirEnum);
begin
  FStatus.free;
  FStatus := value;
end;

function TFhirMedication.GetStatusST : TFhirMedicationStatusCodesEnum;
begin
  if FStatus = nil then
    result := TFhirMedicationStatusCodesEnum(0)
  else
    result := TFhirMedicationStatusCodesEnum(StringArrayIndexOfSensitive(CODES_TFhirMedicationStatusCodesEnum, FStatus.value));
end;

procedure TFhirMedication.SetStatusST(value : TFhirMedicationStatusCodesEnum);
begin
  if ord(value) = 0 then
    StatusElement := nil
  else
    StatusElement := TFhirEnum.create(SYSTEMS_TFhirMedicationStatusCodesEnum[value], CODES_TFhirMedicationStatusCodesEnum[value]);
end;

procedure TFhirMedication.SetMarketingAuthorizationHolder(value : TFhirReference);
begin
  FMarketingAuthorizationHolder.free;
  FMarketingAuthorizationHolder := value;
end;

procedure TFhirMedication.SetDoseForm(value : TFhirCodeableConcept);
begin
  FDoseForm.free;
  FDoseForm := value;
end;

procedure TFhirMedication.SetTotalVolume(value : TFhirRatio);
begin
  FTotalVolume.free;
  FTotalVolume := value;
end;

function TFhirMedication.GetIngredientList : TFhirMedicationIngredientList;
begin
  if FIngredientList = nil then
    FIngredientList := TFhirMedicationIngredientList.Create;
  result := FIngredientList;
end;

function TFhirMedication.GetHasIngredientList : boolean;
begin
  result := (FIngredientList <> nil) and (FIngredientList.count > 0);
end;

procedure TFhirMedication.SetBatch(value : TFhirMedicationBatch);
begin
  FBatch.free;
  FBatch := value;
end;

{ TFhirMedicationListEnumerator }

constructor TFhirMedicationListEnumerator.Create(list : TFhirMedicationList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirMedicationListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirMedicationListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirMedicationListEnumerator.GetCurrent : TFhirMedication;
begin
  Result := FList[FIndex];
end;

function TFhirMedicationListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirMedicationList }

function TFhirMedicationList.AddItem(value: TFhirMedication): TFhirMedication;
begin
  assert(value.ClassName = 'TFhirMedication', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirMedication');
  add(value);
  result := value;
end;

function TFhirMedicationList.Append: TFhirMedication;
begin
  result := TFhirMedication.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirMedicationList.ClearItems;
begin
  Clear;
end;

function TFhirMedicationList.GetEnumerator : TFhirMedicationListEnumerator;
begin
  result := TFhirMedicationListEnumerator.Create(self.link);
end;

function TFhirMedicationList.Clone: TFhirMedicationList;
begin
  result := TFhirMedicationList(inherited Clone);
end;

function TFhirMedicationList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirMedicationList.GetItemN(index: Integer): TFhirMedication;
begin
  result := TFhirMedication(ObjectByIndex[index]);
end;

function TFhirMedicationList.ItemClass: TFslObjectClass;
begin
  result := TFhirMedication;
end;
function TFhirMedicationList.IndexOf(value: TFhirMedication): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirMedicationList.Insert(index: Integer): TFhirMedication;
begin
  result := TFhirMedication.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirMedicationList.InsertItem(index: Integer; value: TFhirMedication);
begin
  assert(value is TFhirMedication);
  Inherited Insert(index, value);
end;

function TFhirMedicationList.Item(index: Integer): TFhirMedication;
begin
  result := TFhirMedication(ObjectByIndex[index]);
end;

function TFhirMedicationList.Link: TFhirMedicationList;
begin
  result := TFhirMedicationList(inherited Link);
end;

procedure TFhirMedicationList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirMedicationList.SetItemByIndex(index: Integer; value: TFhirMedication);
begin
  assert(value is TFhirMedication);
  FhirMedications[index] := value;
end;

procedure TFhirMedicationList.SetItemN(index: Integer; value: TFhirMedication);
begin
  assert(value is TFhirMedication);
  ObjectByIndex[index] := value;
end;

{$ENDIF FHIR_MEDICATION}
{$IFDEF FHIR_MEDICATIONKNOWLEDGE}
{ TFhirMedicationKnowledgeRelatedMedicationKnowledge }

constructor TFhirMedicationKnowledgeRelatedMedicationKnowledge.Create;
begin
  inherited;
end;

destructor TFhirMedicationKnowledgeRelatedMedicationKnowledge.Destroy;
begin
  FType_.free;
  FReferenceList.Free;
  inherited;
end;

procedure TFhirMedicationKnowledgeRelatedMedicationKnowledge.Assign(oSource : TFslObject);
begin
  inherited;
  type_ := TFhirMedicationKnowledgeRelatedMedicationKnowledge(oSource).type_.Clone;
  if (TFhirMedicationKnowledgeRelatedMedicationKnowledge(oSource).FReferenceList = nil) then
  begin
    FReferenceList.free;
    FReferenceList := nil;
  end
  else
  begin
    if FReferenceList = nil then
      FReferenceList := TFhirReferenceList.Create;
    FReferenceList.Assign(TFhirMedicationKnowledgeRelatedMedicationKnowledge(oSource).FReferenceList);
  end;
end;

procedure TFhirMedicationKnowledgeRelatedMedicationKnowledge.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'type') Then
     list.add(self.link, 'type', FType_.Link);
  if (child_name = 'reference') Then
    list.addAll(self, 'reference', FReferenceList);
end;

procedure TFhirMedicationKnowledgeRelatedMedicationKnowledge.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'type', 'CodeableConcept', false, TFhirCodeableConcept, FType_.Link));
  oList.add(TFHIRProperty.create(self, 'reference', 'Reference', true, TFhirReference, FReferenceList.Link));
end;

function TFhirMedicationKnowledgeRelatedMedicationKnowledge.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'type') then
  begin
    Type_ := propValue as TFhirCodeableConcept;
    result := propValue;
  end
  else if (propName = 'reference') then
  begin
    ReferenceList.add(propValue as TFhirReference);
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirMedicationKnowledgeRelatedMedicationKnowledge.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'reference') then ReferenceList.insertItem(index, propValue as TFhirReference)
  else inherited;
end;

function TFhirMedicationKnowledgeRelatedMedicationKnowledge.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'type') then result := TFhirCodeableConcept.create()
  else if (propName = 'reference') then result := ReferenceList.new()
  else result := inherited createPropertyValue(propName);
end;

function TFhirMedicationKnowledgeRelatedMedicationKnowledge.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'type') then result := 'CodeableConcept'
  else if (propName = 'reference') then result := 'Reference'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirMedicationKnowledgeRelatedMedicationKnowledge.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'type') then Type_Element := nil
  else if (propName = 'reference') then deletePropertyValue('reference', ReferenceList, value)
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirMedicationKnowledgeRelatedMedicationKnowledge.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'type') then Type_Element := new as TFhirCodeableConcept
  else if (propName = 'reference') then replacePropertyValue('reference', ReferenceList, existing, new)
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirMedicationKnowledgeRelatedMedicationKnowledge.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'reference') then ReferenceList.move(source, destination)
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirMedicationKnowledgeRelatedMedicationKnowledge.fhirType : string;
begin
  result := 'MedicationKnowledge.relatedMedicationKnowledge';
end;

function TFhirMedicationKnowledgeRelatedMedicationKnowledge.Link : TFhirMedicationKnowledgeRelatedMedicationKnowledge;
begin
  result := TFhirMedicationKnowledgeRelatedMedicationKnowledge(inherited Link);
end;

function TFhirMedicationKnowledgeRelatedMedicationKnowledge.Clone : TFhirMedicationKnowledgeRelatedMedicationKnowledge;
begin
  result := TFhirMedicationKnowledgeRelatedMedicationKnowledge(inherited Clone);
end;

function TFhirMedicationKnowledgeRelatedMedicationKnowledge.equals(other : TObject) : boolean; 
var
  o : TFhirMedicationKnowledgeRelatedMedicationKnowledge;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirMedicationKnowledgeRelatedMedicationKnowledge)) then
    result := false
  else
  begin
    o := TFhirMedicationKnowledgeRelatedMedicationKnowledge(other);
    result := compareDeep(type_Element, o.type_Element, true) and compareDeep(referenceList, o.referenceList, true);
  end;
end;

function TFhirMedicationKnowledgeRelatedMedicationKnowledge.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FType_) and isEmptyProp(FreferenceList);
end;

procedure TFhirMedicationKnowledgeRelatedMedicationKnowledge.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('type');
  fields.add('reference');
end;

function TFhirMedicationKnowledgeRelatedMedicationKnowledge.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
  inc(result, FReferenceList.sizeInBytes(magic));
end;

procedure TFhirMedicationKnowledgeRelatedMedicationKnowledge.SetType_(value : TFhirCodeableConcept);
begin
  FType_.free;
  FType_ := value;
end;

function TFhirMedicationKnowledgeRelatedMedicationKnowledge.GetReferenceList : TFhirReferenceList;
begin
  if FReferenceList = nil then
    FReferenceList := TFhirReferenceList.Create;
  result := FReferenceList;
end;

function TFhirMedicationKnowledgeRelatedMedicationKnowledge.GetHasReferenceList : boolean;
begin
  result := (FReferenceList <> nil) and (FReferenceList.count > 0);
end;

{ TFhirMedicationKnowledgeRelatedMedicationKnowledgeListEnumerator }

constructor TFhirMedicationKnowledgeRelatedMedicationKnowledgeListEnumerator.Create(list : TFhirMedicationKnowledgeRelatedMedicationKnowledgeList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirMedicationKnowledgeRelatedMedicationKnowledgeListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirMedicationKnowledgeRelatedMedicationKnowledgeListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirMedicationKnowledgeRelatedMedicationKnowledgeListEnumerator.GetCurrent : TFhirMedicationKnowledgeRelatedMedicationKnowledge;
begin
  Result := FList[FIndex];
end;

function TFhirMedicationKnowledgeRelatedMedicationKnowledgeListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirMedicationKnowledgeRelatedMedicationKnowledgeList }

function TFhirMedicationKnowledgeRelatedMedicationKnowledgeList.AddItem(value: TFhirMedicationKnowledgeRelatedMedicationKnowledge): TFhirMedicationKnowledgeRelatedMedicationKnowledge;
begin
  assert(value.ClassName = 'TFhirMedicationKnowledgeRelatedMedicationKnowledge', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirMedicationKnowledgeRelatedMedicationKnowledge');
  add(value);
  result := value;
end;

function TFhirMedicationKnowledgeRelatedMedicationKnowledgeList.Append: TFhirMedicationKnowledgeRelatedMedicationKnowledge;
begin
  result := TFhirMedicationKnowledgeRelatedMedicationKnowledge.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirMedicationKnowledgeRelatedMedicationKnowledgeList.ClearItems;
begin
  Clear;
end;

function TFhirMedicationKnowledgeRelatedMedicationKnowledgeList.GetEnumerator : TFhirMedicationKnowledgeRelatedMedicationKnowledgeListEnumerator;
begin
  result := TFhirMedicationKnowledgeRelatedMedicationKnowledgeListEnumerator.Create(self.link);
end;

function TFhirMedicationKnowledgeRelatedMedicationKnowledgeList.Clone: TFhirMedicationKnowledgeRelatedMedicationKnowledgeList;
begin
  result := TFhirMedicationKnowledgeRelatedMedicationKnowledgeList(inherited Clone);
end;

function TFhirMedicationKnowledgeRelatedMedicationKnowledgeList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirMedicationKnowledgeRelatedMedicationKnowledgeList.GetItemN(index: Integer): TFhirMedicationKnowledgeRelatedMedicationKnowledge;
begin
  result := TFhirMedicationKnowledgeRelatedMedicationKnowledge(ObjectByIndex[index]);
end;

function TFhirMedicationKnowledgeRelatedMedicationKnowledgeList.ItemClass: TFslObjectClass;
begin
  result := TFhirMedicationKnowledgeRelatedMedicationKnowledge;
end;
function TFhirMedicationKnowledgeRelatedMedicationKnowledgeList.IndexOf(value: TFhirMedicationKnowledgeRelatedMedicationKnowledge): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirMedicationKnowledgeRelatedMedicationKnowledgeList.Insert(index: Integer): TFhirMedicationKnowledgeRelatedMedicationKnowledge;
begin
  result := TFhirMedicationKnowledgeRelatedMedicationKnowledge.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirMedicationKnowledgeRelatedMedicationKnowledgeList.InsertItem(index: Integer; value: TFhirMedicationKnowledgeRelatedMedicationKnowledge);
begin
  assert(value is TFhirMedicationKnowledgeRelatedMedicationKnowledge);
  Inherited Insert(index, value);
end;

function TFhirMedicationKnowledgeRelatedMedicationKnowledgeList.Item(index: Integer): TFhirMedicationKnowledgeRelatedMedicationKnowledge;
begin
  result := TFhirMedicationKnowledgeRelatedMedicationKnowledge(ObjectByIndex[index]);
end;

function TFhirMedicationKnowledgeRelatedMedicationKnowledgeList.Link: TFhirMedicationKnowledgeRelatedMedicationKnowledgeList;
begin
  result := TFhirMedicationKnowledgeRelatedMedicationKnowledgeList(inherited Link);
end;

procedure TFhirMedicationKnowledgeRelatedMedicationKnowledgeList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirMedicationKnowledgeRelatedMedicationKnowledgeList.SetItemByIndex(index: Integer; value: TFhirMedicationKnowledgeRelatedMedicationKnowledge);
begin
  assert(value is TFhirMedicationKnowledgeRelatedMedicationKnowledge);
  FhirMedicationKnowledgeRelatedMedicationKnowledges[index] := value;
end;

procedure TFhirMedicationKnowledgeRelatedMedicationKnowledgeList.SetItemN(index: Integer; value: TFhirMedicationKnowledgeRelatedMedicationKnowledge);
begin
  assert(value is TFhirMedicationKnowledgeRelatedMedicationKnowledge);
  ObjectByIndex[index] := value;
end;

{ TFhirMedicationKnowledgeMonograph }

constructor TFhirMedicationKnowledgeMonograph.Create;
begin
  inherited;
end;

destructor TFhirMedicationKnowledgeMonograph.Destroy;
begin
  FType_.free;
  FSource.free;
  inherited;
end;

procedure TFhirMedicationKnowledgeMonograph.Assign(oSource : TFslObject);
begin
  inherited;
  type_ := TFhirMedicationKnowledgeMonograph(oSource).type_.Clone;
  source := TFhirMedicationKnowledgeMonograph(oSource).source.Clone;
end;

procedure TFhirMedicationKnowledgeMonograph.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'type') Then
     list.add(self.link, 'type', FType_.Link);
  if (child_name = 'source') Then
     list.add(self.link, 'source', FSource.Link);
end;

procedure TFhirMedicationKnowledgeMonograph.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'type', 'CodeableConcept', false, TFhirCodeableConcept, FType_.Link));
  oList.add(TFHIRProperty.create(self, 'source', 'Reference', false, TFhirReference, FSource.Link));
end;

function TFhirMedicationKnowledgeMonograph.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'type') then
  begin
    Type_ := propValue as TFhirCodeableConcept;
    result := propValue;
  end
  else if (propName = 'source') then
  begin
    Source := propValue as TFhirReference;
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirMedicationKnowledgeMonograph.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirMedicationKnowledgeMonograph.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'type') then result := TFhirCodeableConcept.create()
  else if (propName = 'source') then result := TFhirReference.create()
  else result := inherited createPropertyValue(propName);
end;

function TFhirMedicationKnowledgeMonograph.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'type') then result := 'CodeableConcept'
  else if (propName = 'source') then result := 'Reference'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirMedicationKnowledgeMonograph.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'type') then Type_Element := nil
  else if (propName = 'source') then SourceElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirMedicationKnowledgeMonograph.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'type') then Type_Element := new as TFhirCodeableConcept
  else if (propName = 'source') then SourceElement := new as TFhirReference
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirMedicationKnowledgeMonograph.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirMedicationKnowledgeMonograph.fhirType : string;
begin
  result := 'MedicationKnowledge.monograph';
end;

function TFhirMedicationKnowledgeMonograph.Link : TFhirMedicationKnowledgeMonograph;
begin
  result := TFhirMedicationKnowledgeMonograph(inherited Link);
end;

function TFhirMedicationKnowledgeMonograph.Clone : TFhirMedicationKnowledgeMonograph;
begin
  result := TFhirMedicationKnowledgeMonograph(inherited Clone);
end;

function TFhirMedicationKnowledgeMonograph.equals(other : TObject) : boolean; 
var
  o : TFhirMedicationKnowledgeMonograph;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirMedicationKnowledgeMonograph)) then
    result := false
  else
  begin
    o := TFhirMedicationKnowledgeMonograph(other);
    result := compareDeep(type_Element, o.type_Element, true) and compareDeep(sourceElement, o.sourceElement, true);
  end;
end;

function TFhirMedicationKnowledgeMonograph.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FType_) and isEmptyProp(FSource);
end;

procedure TFhirMedicationKnowledgeMonograph.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('type');
  fields.add('source');
end;

function TFhirMedicationKnowledgeMonograph.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
end;

procedure TFhirMedicationKnowledgeMonograph.SetType_(value : TFhirCodeableConcept);
begin
  FType_.free;
  FType_ := value;
end;

procedure TFhirMedicationKnowledgeMonograph.SetSource(value : TFhirReference);
begin
  FSource.free;
  FSource := value;
end;

{ TFhirMedicationKnowledgeMonographListEnumerator }

constructor TFhirMedicationKnowledgeMonographListEnumerator.Create(list : TFhirMedicationKnowledgeMonographList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirMedicationKnowledgeMonographListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirMedicationKnowledgeMonographListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirMedicationKnowledgeMonographListEnumerator.GetCurrent : TFhirMedicationKnowledgeMonograph;
begin
  Result := FList[FIndex];
end;

function TFhirMedicationKnowledgeMonographListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirMedicationKnowledgeMonographList }

function TFhirMedicationKnowledgeMonographList.AddItem(value: TFhirMedicationKnowledgeMonograph): TFhirMedicationKnowledgeMonograph;
begin
  assert(value.ClassName = 'TFhirMedicationKnowledgeMonograph', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirMedicationKnowledgeMonograph');
  add(value);
  result := value;
end;

function TFhirMedicationKnowledgeMonographList.Append: TFhirMedicationKnowledgeMonograph;
begin
  result := TFhirMedicationKnowledgeMonograph.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirMedicationKnowledgeMonographList.ClearItems;
begin
  Clear;
end;

function TFhirMedicationKnowledgeMonographList.GetEnumerator : TFhirMedicationKnowledgeMonographListEnumerator;
begin
  result := TFhirMedicationKnowledgeMonographListEnumerator.Create(self.link);
end;

function TFhirMedicationKnowledgeMonographList.Clone: TFhirMedicationKnowledgeMonographList;
begin
  result := TFhirMedicationKnowledgeMonographList(inherited Clone);
end;

function TFhirMedicationKnowledgeMonographList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirMedicationKnowledgeMonographList.GetItemN(index: Integer): TFhirMedicationKnowledgeMonograph;
begin
  result := TFhirMedicationKnowledgeMonograph(ObjectByIndex[index]);
end;

function TFhirMedicationKnowledgeMonographList.ItemClass: TFslObjectClass;
begin
  result := TFhirMedicationKnowledgeMonograph;
end;
function TFhirMedicationKnowledgeMonographList.IndexOf(value: TFhirMedicationKnowledgeMonograph): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirMedicationKnowledgeMonographList.Insert(index: Integer): TFhirMedicationKnowledgeMonograph;
begin
  result := TFhirMedicationKnowledgeMonograph.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirMedicationKnowledgeMonographList.InsertItem(index: Integer; value: TFhirMedicationKnowledgeMonograph);
begin
  assert(value is TFhirMedicationKnowledgeMonograph);
  Inherited Insert(index, value);
end;

function TFhirMedicationKnowledgeMonographList.Item(index: Integer): TFhirMedicationKnowledgeMonograph;
begin
  result := TFhirMedicationKnowledgeMonograph(ObjectByIndex[index]);
end;

function TFhirMedicationKnowledgeMonographList.Link: TFhirMedicationKnowledgeMonographList;
begin
  result := TFhirMedicationKnowledgeMonographList(inherited Link);
end;

procedure TFhirMedicationKnowledgeMonographList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirMedicationKnowledgeMonographList.SetItemByIndex(index: Integer; value: TFhirMedicationKnowledgeMonograph);
begin
  assert(value is TFhirMedicationKnowledgeMonograph);
  FhirMedicationKnowledgeMonographs[index] := value;
end;

procedure TFhirMedicationKnowledgeMonographList.SetItemN(index: Integer; value: TFhirMedicationKnowledgeMonograph);
begin
  assert(value is TFhirMedicationKnowledgeMonograph);
  ObjectByIndex[index] := value;
end;

{ TFhirMedicationKnowledgeCost }

constructor TFhirMedicationKnowledgeCost.Create;
begin
  inherited;
end;

destructor TFhirMedicationKnowledgeCost.Destroy;
begin
  FEffectiveDateList.Free;
  FType_.free;
  FSource.free;
  FCost.free;
  inherited;
end;

procedure TFhirMedicationKnowledgeCost.Assign(oSource : TFslObject);
begin
  inherited;
  if (TFhirMedicationKnowledgeCost(oSource).FEffectiveDateList = nil) then
  begin
    FEffectiveDateList.free;
    FEffectiveDateList := nil;
  end
  else
  begin
    if FEffectiveDateList = nil then
      FEffectiveDateList := TFhirPeriodList.Create;
    FEffectiveDateList.Assign(TFhirMedicationKnowledgeCost(oSource).FEffectiveDateList);
  end;
  type_ := TFhirMedicationKnowledgeCost(oSource).type_.Clone;
  sourceElement := TFhirMedicationKnowledgeCost(oSource).sourceElement.Clone;
  cost := TFhirMedicationKnowledgeCost(oSource).cost.Clone;
end;

procedure TFhirMedicationKnowledgeCost.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'effectiveDate') Then
    list.addAll(self, 'effectiveDate', FEffectiveDateList);
  if (child_name = 'type') Then
     list.add(self.link, 'type', FType_.Link);
  if (child_name = 'source') Then
     list.add(self.link, 'source', FSource.Link);
  if (child_name = 'cost[x]') or (child_name = 'cost') Then
     list.add(self.link, 'cost[x]', FCost.Link);
end;

procedure TFhirMedicationKnowledgeCost.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'effectiveDate', 'Period', true, TFhirPeriod, FEffectiveDateList.Link));
  oList.add(TFHIRProperty.create(self, 'type', 'CodeableConcept', false, TFhirCodeableConcept, FType_.Link));
  oList.add(TFHIRProperty.create(self, 'source', 'string', false, TFhirString, FSource.Link));
  oList.add(TFHIRProperty.create(self, 'cost[x]', 'Money|CodeableConcept', false, TFhirDataType, FCost.Link));
end;

function TFhirMedicationKnowledgeCost.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'effectiveDate') then
  begin
    EffectiveDateList.add(propValue as TFhirPeriod);
    result := propValue;
  end
  else if (propName = 'type') then
  begin
    Type_ := propValue as TFhirCodeableConcept;
    result := propValue;
  end
  else if (propName = 'source') then
  begin
    SourceElement := asString(propValue);
    result := propValue;
  end
  else if (isMatchingName(propName, 'cost', ['Money', 'CodeableConcept'])) then
  begin
    Cost := propValue as TFhirDataType;
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirMedicationKnowledgeCost.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'effectiveDate') then EffectiveDateList.insertItem(index, propValue as TFhirPeriod)
  else inherited;
end;

function TFhirMedicationKnowledgeCost.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'effectiveDate') then result := EffectiveDateList.new()
  else if (propName = 'type') then result := TFhirCodeableConcept.create()
  else if (propName = 'source') then result := TFhirString.create()
  else if (isMatchingName(propName, 'cost', ['Money', 'CodeableConcept'])) then raise EFHIRException.create('Cannot make property Cost')
  else result := inherited createPropertyValue(propName);
end;

function TFhirMedicationKnowledgeCost.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'effectiveDate') then result := 'Period'
  else if (propName = 'type') then result := 'CodeableConcept'
  else if (propName = 'source') then result := 'string'
  else if (propName = 'cost[x]') then result := 'Money|CodeableConcept'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirMedicationKnowledgeCost.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'effectiveDate') then deletePropertyValue('effectiveDate', EffectiveDateList, value)
  else if (propName = 'type') then Type_Element := nil
  else if (propName = 'source') then SourceElement := nil
  else if (isMatchingName(propName, 'cost', ['Money', 'CodeableConcept'])) then CostElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirMedicationKnowledgeCost.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'effectiveDate') then replacePropertyValue('effectiveDate', EffectiveDateList, existing, new)
  else if (propName = 'type') then Type_Element := new as TFhirCodeableConcept
  else if (propName = 'source') then SourceElement := asString(new)
  else if (isMatchingName(propName, 'cost', ['Money', 'CodeableConcept'])) then CostElement := new as TFhirDataType
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirMedicationKnowledgeCost.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'effectiveDate') then EffectiveDateList.move(source, destination)
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirMedicationKnowledgeCost.fhirType : string;
begin
  result := 'MedicationKnowledge.cost';
end;

function TFhirMedicationKnowledgeCost.Link : TFhirMedicationKnowledgeCost;
begin
  result := TFhirMedicationKnowledgeCost(inherited Link);
end;

function TFhirMedicationKnowledgeCost.Clone : TFhirMedicationKnowledgeCost;
begin
  result := TFhirMedicationKnowledgeCost(inherited Clone);
end;

function TFhirMedicationKnowledgeCost.equals(other : TObject) : boolean; 
var
  o : TFhirMedicationKnowledgeCost;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirMedicationKnowledgeCost)) then
    result := false
  else
  begin
    o := TFhirMedicationKnowledgeCost(other);
    result := compareDeep(effectiveDateList, o.effectiveDateList, true) and compareDeep(type_Element, o.type_Element, true) and 
      compareDeep(sourceElement, o.sourceElement, true) and compareDeep(costElement, o.costElement, true);
  end;
end;

function TFhirMedicationKnowledgeCost.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FeffectiveDateList) and isEmptyProp(FType_) and isEmptyProp(FSource) and isEmptyProp(FCost);
end;

procedure TFhirMedicationKnowledgeCost.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('effectiveDate');
  fields.add('type');
  fields.add('source');
  fields.add('cost[x]');
end;

function TFhirMedicationKnowledgeCost.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
  inc(result, FEffectiveDateList.sizeInBytes(magic));
end;

function TFhirMedicationKnowledgeCost.GetEffectiveDateList : TFhirPeriodList;
begin
  if FEffectiveDateList = nil then
    FEffectiveDateList := TFhirPeriodList.Create;
  result := FEffectiveDateList;
end;

function TFhirMedicationKnowledgeCost.GetHasEffectiveDateList : boolean;
begin
  result := (FEffectiveDateList <> nil) and (FEffectiveDateList.count > 0);
end;

procedure TFhirMedicationKnowledgeCost.SetType_(value : TFhirCodeableConcept);
begin
  FType_.free;
  FType_ := value;
end;

procedure TFhirMedicationKnowledgeCost.SetSource(value : TFhirString);
begin
  FSource.free;
  FSource := value;
end;

function TFhirMedicationKnowledgeCost.GetSourceST : String;
begin
  if FSource = nil then
    result := ''
  else
    result := FSource.value;
end;

procedure TFhirMedicationKnowledgeCost.SetSourceST(value : String);
begin
  if value <> '' then
  begin
    if FSource = nil then
      FSource := TFhirString.create;
    FSource.value := value
  end
  else if FSource <> nil then
    FSource.value := '';
end;

procedure TFhirMedicationKnowledgeCost.SetCost(value : TFhirDataType);
begin
  FCost.free;
  FCost := value;
end;

{ TFhirMedicationKnowledgeCostListEnumerator }

constructor TFhirMedicationKnowledgeCostListEnumerator.Create(list : TFhirMedicationKnowledgeCostList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirMedicationKnowledgeCostListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirMedicationKnowledgeCostListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirMedicationKnowledgeCostListEnumerator.GetCurrent : TFhirMedicationKnowledgeCost;
begin
  Result := FList[FIndex];
end;

function TFhirMedicationKnowledgeCostListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirMedicationKnowledgeCostList }

function TFhirMedicationKnowledgeCostList.AddItem(value: TFhirMedicationKnowledgeCost): TFhirMedicationKnowledgeCost;
begin
  assert(value.ClassName = 'TFhirMedicationKnowledgeCost', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirMedicationKnowledgeCost');
  add(value);
  result := value;
end;

function TFhirMedicationKnowledgeCostList.Append: TFhirMedicationKnowledgeCost;
begin
  result := TFhirMedicationKnowledgeCost.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirMedicationKnowledgeCostList.ClearItems;
begin
  Clear;
end;

function TFhirMedicationKnowledgeCostList.GetEnumerator : TFhirMedicationKnowledgeCostListEnumerator;
begin
  result := TFhirMedicationKnowledgeCostListEnumerator.Create(self.link);
end;

function TFhirMedicationKnowledgeCostList.Clone: TFhirMedicationKnowledgeCostList;
begin
  result := TFhirMedicationKnowledgeCostList(inherited Clone);
end;

function TFhirMedicationKnowledgeCostList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirMedicationKnowledgeCostList.GetItemN(index: Integer): TFhirMedicationKnowledgeCost;
begin
  result := TFhirMedicationKnowledgeCost(ObjectByIndex[index]);
end;

function TFhirMedicationKnowledgeCostList.ItemClass: TFslObjectClass;
begin
  result := TFhirMedicationKnowledgeCost;
end;
function TFhirMedicationKnowledgeCostList.IndexOf(value: TFhirMedicationKnowledgeCost): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirMedicationKnowledgeCostList.Insert(index: Integer): TFhirMedicationKnowledgeCost;
begin
  result := TFhirMedicationKnowledgeCost.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirMedicationKnowledgeCostList.InsertItem(index: Integer; value: TFhirMedicationKnowledgeCost);
begin
  assert(value is TFhirMedicationKnowledgeCost);
  Inherited Insert(index, value);
end;

function TFhirMedicationKnowledgeCostList.Item(index: Integer): TFhirMedicationKnowledgeCost;
begin
  result := TFhirMedicationKnowledgeCost(ObjectByIndex[index]);
end;

function TFhirMedicationKnowledgeCostList.Link: TFhirMedicationKnowledgeCostList;
begin
  result := TFhirMedicationKnowledgeCostList(inherited Link);
end;

procedure TFhirMedicationKnowledgeCostList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirMedicationKnowledgeCostList.SetItemByIndex(index: Integer; value: TFhirMedicationKnowledgeCost);
begin
  assert(value is TFhirMedicationKnowledgeCost);
  FhirMedicationKnowledgeCosts[index] := value;
end;

procedure TFhirMedicationKnowledgeCostList.SetItemN(index: Integer; value: TFhirMedicationKnowledgeCost);
begin
  assert(value is TFhirMedicationKnowledgeCost);
  ObjectByIndex[index] := value;
end;

{ TFhirMedicationKnowledgeMonitoringProgram }

constructor TFhirMedicationKnowledgeMonitoringProgram.Create;
begin
  inherited;
end;

destructor TFhirMedicationKnowledgeMonitoringProgram.Destroy;
begin
  FType_.free;
  FName.free;
  inherited;
end;

procedure TFhirMedicationKnowledgeMonitoringProgram.Assign(oSource : TFslObject);
begin
  inherited;
  type_ := TFhirMedicationKnowledgeMonitoringProgram(oSource).type_.Clone;
  nameElement := TFhirMedicationKnowledgeMonitoringProgram(oSource).nameElement.Clone;
end;

procedure TFhirMedicationKnowledgeMonitoringProgram.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'type') Then
     list.add(self.link, 'type', FType_.Link);
  if (child_name = 'name') Then
     list.add(self.link, 'name', FName.Link);
end;

procedure TFhirMedicationKnowledgeMonitoringProgram.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'type', 'CodeableConcept', false, TFhirCodeableConcept, FType_.Link));
  oList.add(TFHIRProperty.create(self, 'name', 'string', false, TFhirString, FName.Link));
end;

function TFhirMedicationKnowledgeMonitoringProgram.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'type') then
  begin
    Type_ := propValue as TFhirCodeableConcept;
    result := propValue;
  end
  else if (propName = 'name') then
  begin
    NameElement := asString(propValue);
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirMedicationKnowledgeMonitoringProgram.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirMedicationKnowledgeMonitoringProgram.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'type') then result := TFhirCodeableConcept.create()
  else if (propName = 'name') then result := TFhirString.create()
  else result := inherited createPropertyValue(propName);
end;

function TFhirMedicationKnowledgeMonitoringProgram.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'type') then result := 'CodeableConcept'
  else if (propName = 'name') then result := 'string'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirMedicationKnowledgeMonitoringProgram.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'type') then Type_Element := nil
  else if (propName = 'name') then NameElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirMedicationKnowledgeMonitoringProgram.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'type') then Type_Element := new as TFhirCodeableConcept
  else if (propName = 'name') then NameElement := asString(new)
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirMedicationKnowledgeMonitoringProgram.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirMedicationKnowledgeMonitoringProgram.fhirType : string;
begin
  result := 'MedicationKnowledge.monitoringProgram';
end;

function TFhirMedicationKnowledgeMonitoringProgram.Link : TFhirMedicationKnowledgeMonitoringProgram;
begin
  result := TFhirMedicationKnowledgeMonitoringProgram(inherited Link);
end;

function TFhirMedicationKnowledgeMonitoringProgram.Clone : TFhirMedicationKnowledgeMonitoringProgram;
begin
  result := TFhirMedicationKnowledgeMonitoringProgram(inherited Clone);
end;

function TFhirMedicationKnowledgeMonitoringProgram.equals(other : TObject) : boolean; 
var
  o : TFhirMedicationKnowledgeMonitoringProgram;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirMedicationKnowledgeMonitoringProgram)) then
    result := false
  else
  begin
    o := TFhirMedicationKnowledgeMonitoringProgram(other);
    result := compareDeep(type_Element, o.type_Element, true) and compareDeep(nameElement, o.nameElement, true);
  end;
end;

function TFhirMedicationKnowledgeMonitoringProgram.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FType_) and isEmptyProp(FName);
end;

procedure TFhirMedicationKnowledgeMonitoringProgram.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('type');
  fields.add('name');
end;

function TFhirMedicationKnowledgeMonitoringProgram.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
end;

procedure TFhirMedicationKnowledgeMonitoringProgram.SetType_(value : TFhirCodeableConcept);
begin
  FType_.free;
  FType_ := value;
end;

procedure TFhirMedicationKnowledgeMonitoringProgram.SetName(value : TFhirString);
begin
  FName.free;
  FName := value;
end;

function TFhirMedicationKnowledgeMonitoringProgram.GetNameST : String;
begin
  if FName = nil then
    result := ''
  else
    result := FName.value;
end;

procedure TFhirMedicationKnowledgeMonitoringProgram.SetNameST(value : String);
begin
  if value <> '' then
  begin
    if FName = nil then
      FName := TFhirString.create;
    FName.value := value
  end
  else if FName <> nil then
    FName.value := '';
end;

{ TFhirMedicationKnowledgeMonitoringProgramListEnumerator }

constructor TFhirMedicationKnowledgeMonitoringProgramListEnumerator.Create(list : TFhirMedicationKnowledgeMonitoringProgramList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirMedicationKnowledgeMonitoringProgramListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirMedicationKnowledgeMonitoringProgramListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirMedicationKnowledgeMonitoringProgramListEnumerator.GetCurrent : TFhirMedicationKnowledgeMonitoringProgram;
begin
  Result := FList[FIndex];
end;

function TFhirMedicationKnowledgeMonitoringProgramListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirMedicationKnowledgeMonitoringProgramList }

function TFhirMedicationKnowledgeMonitoringProgramList.AddItem(value: TFhirMedicationKnowledgeMonitoringProgram): TFhirMedicationKnowledgeMonitoringProgram;
begin
  assert(value.ClassName = 'TFhirMedicationKnowledgeMonitoringProgram', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirMedicationKnowledgeMonitoringProgram');
  add(value);
  result := value;
end;

function TFhirMedicationKnowledgeMonitoringProgramList.Append: TFhirMedicationKnowledgeMonitoringProgram;
begin
  result := TFhirMedicationKnowledgeMonitoringProgram.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirMedicationKnowledgeMonitoringProgramList.ClearItems;
begin
  Clear;
end;

function TFhirMedicationKnowledgeMonitoringProgramList.GetEnumerator : TFhirMedicationKnowledgeMonitoringProgramListEnumerator;
begin
  result := TFhirMedicationKnowledgeMonitoringProgramListEnumerator.Create(self.link);
end;

function TFhirMedicationKnowledgeMonitoringProgramList.Clone: TFhirMedicationKnowledgeMonitoringProgramList;
begin
  result := TFhirMedicationKnowledgeMonitoringProgramList(inherited Clone);
end;

function TFhirMedicationKnowledgeMonitoringProgramList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirMedicationKnowledgeMonitoringProgramList.GetItemN(index: Integer): TFhirMedicationKnowledgeMonitoringProgram;
begin
  result := TFhirMedicationKnowledgeMonitoringProgram(ObjectByIndex[index]);
end;

function TFhirMedicationKnowledgeMonitoringProgramList.ItemClass: TFslObjectClass;
begin
  result := TFhirMedicationKnowledgeMonitoringProgram;
end;
function TFhirMedicationKnowledgeMonitoringProgramList.IndexOf(value: TFhirMedicationKnowledgeMonitoringProgram): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirMedicationKnowledgeMonitoringProgramList.Insert(index: Integer): TFhirMedicationKnowledgeMonitoringProgram;
begin
  result := TFhirMedicationKnowledgeMonitoringProgram.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirMedicationKnowledgeMonitoringProgramList.InsertItem(index: Integer; value: TFhirMedicationKnowledgeMonitoringProgram);
begin
  assert(value is TFhirMedicationKnowledgeMonitoringProgram);
  Inherited Insert(index, value);
end;

function TFhirMedicationKnowledgeMonitoringProgramList.Item(index: Integer): TFhirMedicationKnowledgeMonitoringProgram;
begin
  result := TFhirMedicationKnowledgeMonitoringProgram(ObjectByIndex[index]);
end;

function TFhirMedicationKnowledgeMonitoringProgramList.Link: TFhirMedicationKnowledgeMonitoringProgramList;
begin
  result := TFhirMedicationKnowledgeMonitoringProgramList(inherited Link);
end;

procedure TFhirMedicationKnowledgeMonitoringProgramList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirMedicationKnowledgeMonitoringProgramList.SetItemByIndex(index: Integer; value: TFhirMedicationKnowledgeMonitoringProgram);
begin
  assert(value is TFhirMedicationKnowledgeMonitoringProgram);
  FhirMedicationKnowledgeMonitoringPrograms[index] := value;
end;

procedure TFhirMedicationKnowledgeMonitoringProgramList.SetItemN(index: Integer; value: TFhirMedicationKnowledgeMonitoringProgram);
begin
  assert(value is TFhirMedicationKnowledgeMonitoringProgram);
  ObjectByIndex[index] := value;
end;

{ TFhirMedicationKnowledgeIndicationGuideline }

constructor TFhirMedicationKnowledgeIndicationGuideline.Create;
begin
  inherited;
end;

destructor TFhirMedicationKnowledgeIndicationGuideline.Destroy;
begin
  FIndicationList.Free;
  FDosingGuidelineList.Free;
  inherited;
end;

procedure TFhirMedicationKnowledgeIndicationGuideline.Assign(oSource : TFslObject);
begin
  inherited;
  if (TFhirMedicationKnowledgeIndicationGuideline(oSource).FIndicationList = nil) then
  begin
    FIndicationList.free;
    FIndicationList := nil;
  end
  else
  begin
    if FIndicationList = nil then
      FIndicationList := TFhirCodeableReferenceList.Create;
    FIndicationList.Assign(TFhirMedicationKnowledgeIndicationGuideline(oSource).FIndicationList);
  end;
  if (TFhirMedicationKnowledgeIndicationGuideline(oSource).FDosingGuidelineList = nil) then
  begin
    FDosingGuidelineList.free;
    FDosingGuidelineList := nil;
  end
  else
  begin
    if FDosingGuidelineList = nil then
      FDosingGuidelineList := TFhirMedicationKnowledgeIndicationGuidelineDosingGuidelineList.Create;
    FDosingGuidelineList.Assign(TFhirMedicationKnowledgeIndicationGuideline(oSource).FDosingGuidelineList);
  end;
end;

procedure TFhirMedicationKnowledgeIndicationGuideline.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'indication') Then
    list.addAll(self, 'indication', FIndicationList);
  if (child_name = 'dosingGuideline') Then
    list.addAll(self, 'dosingGuideline', FDosingGuidelineList);
end;

procedure TFhirMedicationKnowledgeIndicationGuideline.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'indication', 'CodeableReference', true, TFhirCodeableReference, FIndicationList.Link));
  oList.add(TFHIRProperty.create(self, 'dosingGuideline', 'BackboneElement', true, TFhirMedicationKnowledgeIndicationGuidelineDosingGuideline, FDosingGuidelineList.Link));
end;

function TFhirMedicationKnowledgeIndicationGuideline.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'indication') then
  begin
    IndicationList.add(propValue as TFhirCodeableReference);
    result := propValue;
  end
  else if (propName = 'dosingGuideline') then
  begin
    DosingGuidelineList.add(propValue as TFhirMedicationKnowledgeIndicationGuidelineDosingGuideline);
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirMedicationKnowledgeIndicationGuideline.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'indication') then IndicationList.insertItem(index, propValue as TFhirCodeableReference)
  else if (propName = 'dosingGuideline') then DosingGuidelineList.insertItem(index, propValue as TFhirMedicationKnowledgeIndicationGuidelineDosingGuideline)
  else inherited;
end;

function TFhirMedicationKnowledgeIndicationGuideline.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'indication') then result := IndicationList.new()
  else if (propName = 'dosingGuideline') then result := DosingGuidelineList.new()
  else result := inherited createPropertyValue(propName);
end;

function TFhirMedicationKnowledgeIndicationGuideline.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'indication') then result := 'CodeableReference'
  else if (propName = 'dosingGuideline') then result := 'BackboneElement'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirMedicationKnowledgeIndicationGuideline.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'indication') then deletePropertyValue('indication', IndicationList, value)
  else if (propName = 'dosingGuideline') then deletePropertyValue('dosingGuideline', DosingGuidelineList, value)
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirMedicationKnowledgeIndicationGuideline.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'indication') then replacePropertyValue('indication', IndicationList, existing, new)
  else if (propName = 'dosingGuideline') then replacePropertyValue('dosingGuideline', DosingGuidelineList, existing, new)
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirMedicationKnowledgeIndicationGuideline.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'indication') then IndicationList.move(source, destination)
  else if (propName = 'dosingGuideline') then DosingGuidelineList.move(source, destination)
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirMedicationKnowledgeIndicationGuideline.fhirType : string;
begin
  result := 'MedicationKnowledge.indicationGuideline';
end;

function TFhirMedicationKnowledgeIndicationGuideline.Link : TFhirMedicationKnowledgeIndicationGuideline;
begin
  result := TFhirMedicationKnowledgeIndicationGuideline(inherited Link);
end;

function TFhirMedicationKnowledgeIndicationGuideline.Clone : TFhirMedicationKnowledgeIndicationGuideline;
begin
  result := TFhirMedicationKnowledgeIndicationGuideline(inherited Clone);
end;

function TFhirMedicationKnowledgeIndicationGuideline.equals(other : TObject) : boolean; 
var
  o : TFhirMedicationKnowledgeIndicationGuideline;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirMedicationKnowledgeIndicationGuideline)) then
    result := false
  else
  begin
    o := TFhirMedicationKnowledgeIndicationGuideline(other);
    result := compareDeep(indicationList, o.indicationList, true) and compareDeep(dosingGuidelineList, o.dosingGuidelineList, true);
  end;
end;

function TFhirMedicationKnowledgeIndicationGuideline.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FindicationList) and isEmptyProp(FdosingGuidelineList);
end;

procedure TFhirMedicationKnowledgeIndicationGuideline.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('indication');
  fields.add('dosingGuideline');
end;

function TFhirMedicationKnowledgeIndicationGuideline.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
  inc(result, FIndicationList.sizeInBytes(magic));
  inc(result, FDosingGuidelineList.sizeInBytes(magic));
end;

function TFhirMedicationKnowledgeIndicationGuideline.GetIndicationList : TFhirCodeableReferenceList;
begin
  if FIndicationList = nil then
    FIndicationList := TFhirCodeableReferenceList.Create;
  result := FIndicationList;
end;

function TFhirMedicationKnowledgeIndicationGuideline.GetHasIndicationList : boolean;
begin
  result := (FIndicationList <> nil) and (FIndicationList.count > 0);
end;

function TFhirMedicationKnowledgeIndicationGuideline.GetDosingGuidelineList : TFhirMedicationKnowledgeIndicationGuidelineDosingGuidelineList;
begin
  if FDosingGuidelineList = nil then
    FDosingGuidelineList := TFhirMedicationKnowledgeIndicationGuidelineDosingGuidelineList.Create;
  result := FDosingGuidelineList;
end;

function TFhirMedicationKnowledgeIndicationGuideline.GetHasDosingGuidelineList : boolean;
begin
  result := (FDosingGuidelineList <> nil) and (FDosingGuidelineList.count > 0);
end;

{ TFhirMedicationKnowledgeIndicationGuidelineListEnumerator }

constructor TFhirMedicationKnowledgeIndicationGuidelineListEnumerator.Create(list : TFhirMedicationKnowledgeIndicationGuidelineList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirMedicationKnowledgeIndicationGuidelineListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirMedicationKnowledgeIndicationGuidelineListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirMedicationKnowledgeIndicationGuidelineListEnumerator.GetCurrent : TFhirMedicationKnowledgeIndicationGuideline;
begin
  Result := FList[FIndex];
end;

function TFhirMedicationKnowledgeIndicationGuidelineListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirMedicationKnowledgeIndicationGuidelineList }

function TFhirMedicationKnowledgeIndicationGuidelineList.AddItem(value: TFhirMedicationKnowledgeIndicationGuideline): TFhirMedicationKnowledgeIndicationGuideline;
begin
  assert(value.ClassName = 'TFhirMedicationKnowledgeIndicationGuideline', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirMedicationKnowledgeIndicationGuideline');
  add(value);
  result := value;
end;

function TFhirMedicationKnowledgeIndicationGuidelineList.Append: TFhirMedicationKnowledgeIndicationGuideline;
begin
  result := TFhirMedicationKnowledgeIndicationGuideline.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirMedicationKnowledgeIndicationGuidelineList.ClearItems;
begin
  Clear;
end;

function TFhirMedicationKnowledgeIndicationGuidelineList.GetEnumerator : TFhirMedicationKnowledgeIndicationGuidelineListEnumerator;
begin
  result := TFhirMedicationKnowledgeIndicationGuidelineListEnumerator.Create(self.link);
end;

function TFhirMedicationKnowledgeIndicationGuidelineList.Clone: TFhirMedicationKnowledgeIndicationGuidelineList;
begin
  result := TFhirMedicationKnowledgeIndicationGuidelineList(inherited Clone);
end;

function TFhirMedicationKnowledgeIndicationGuidelineList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirMedicationKnowledgeIndicationGuidelineList.GetItemN(index: Integer): TFhirMedicationKnowledgeIndicationGuideline;
begin
  result := TFhirMedicationKnowledgeIndicationGuideline(ObjectByIndex[index]);
end;

function TFhirMedicationKnowledgeIndicationGuidelineList.ItemClass: TFslObjectClass;
begin
  result := TFhirMedicationKnowledgeIndicationGuideline;
end;
function TFhirMedicationKnowledgeIndicationGuidelineList.IndexOf(value: TFhirMedicationKnowledgeIndicationGuideline): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirMedicationKnowledgeIndicationGuidelineList.Insert(index: Integer): TFhirMedicationKnowledgeIndicationGuideline;
begin
  result := TFhirMedicationKnowledgeIndicationGuideline.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirMedicationKnowledgeIndicationGuidelineList.InsertItem(index: Integer; value: TFhirMedicationKnowledgeIndicationGuideline);
begin
  assert(value is TFhirMedicationKnowledgeIndicationGuideline);
  Inherited Insert(index, value);
end;

function TFhirMedicationKnowledgeIndicationGuidelineList.Item(index: Integer): TFhirMedicationKnowledgeIndicationGuideline;
begin
  result := TFhirMedicationKnowledgeIndicationGuideline(ObjectByIndex[index]);
end;

function TFhirMedicationKnowledgeIndicationGuidelineList.Link: TFhirMedicationKnowledgeIndicationGuidelineList;
begin
  result := TFhirMedicationKnowledgeIndicationGuidelineList(inherited Link);
end;

procedure TFhirMedicationKnowledgeIndicationGuidelineList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirMedicationKnowledgeIndicationGuidelineList.SetItemByIndex(index: Integer; value: TFhirMedicationKnowledgeIndicationGuideline);
begin
  assert(value is TFhirMedicationKnowledgeIndicationGuideline);
  FhirMedicationKnowledgeIndicationGuidelines[index] := value;
end;

procedure TFhirMedicationKnowledgeIndicationGuidelineList.SetItemN(index: Integer; value: TFhirMedicationKnowledgeIndicationGuideline);
begin
  assert(value is TFhirMedicationKnowledgeIndicationGuideline);
  ObjectByIndex[index] := value;
end;

{ TFhirMedicationKnowledgeIndicationGuidelineDosingGuideline }

constructor TFhirMedicationKnowledgeIndicationGuidelineDosingGuideline.Create;
begin
  inherited;
end;

destructor TFhirMedicationKnowledgeIndicationGuidelineDosingGuideline.Destroy;
begin
  FTreatmentIntent.free;
  FDosageList.Free;
  FAdministrationTreatment.free;
  FPatientCharacteristicList.Free;
  inherited;
end;

procedure TFhirMedicationKnowledgeIndicationGuidelineDosingGuideline.Assign(oSource : TFslObject);
begin
  inherited;
  treatmentIntent := TFhirMedicationKnowledgeIndicationGuidelineDosingGuideline(oSource).treatmentIntent.Clone;
  if (TFhirMedicationKnowledgeIndicationGuidelineDosingGuideline(oSource).FDosageList = nil) then
  begin
    FDosageList.free;
    FDosageList := nil;
  end
  else
  begin
    if FDosageList = nil then
      FDosageList := TFhirMedicationKnowledgeIndicationGuidelineDosingGuidelineDosageList.Create;
    FDosageList.Assign(TFhirMedicationKnowledgeIndicationGuidelineDosingGuideline(oSource).FDosageList);
  end;
  administrationTreatment := TFhirMedicationKnowledgeIndicationGuidelineDosingGuideline(oSource).administrationTreatment.Clone;
  if (TFhirMedicationKnowledgeIndicationGuidelineDosingGuideline(oSource).FPatientCharacteristicList = nil) then
  begin
    FPatientCharacteristicList.free;
    FPatientCharacteristicList := nil;
  end
  else
  begin
    if FPatientCharacteristicList = nil then
      FPatientCharacteristicList := TFhirMedicationKnowledgeIndicationGuidelineDosingGuidelinePatientCharacteristicList.Create;
    FPatientCharacteristicList.Assign(TFhirMedicationKnowledgeIndicationGuidelineDosingGuideline(oSource).FPatientCharacteristicList);
  end;
end;

procedure TFhirMedicationKnowledgeIndicationGuidelineDosingGuideline.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'treatmentIntent') Then
     list.add(self.link, 'treatmentIntent', FTreatmentIntent.Link);
  if (child_name = 'dosage') Then
    list.addAll(self, 'dosage', FDosageList);
  if (child_name = 'administrationTreatment') Then
     list.add(self.link, 'administrationTreatment', FAdministrationTreatment.Link);
  if (child_name = 'patientCharacteristic') Then
    list.addAll(self, 'patientCharacteristic', FPatientCharacteristicList);
end;

procedure TFhirMedicationKnowledgeIndicationGuidelineDosingGuideline.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'treatmentIntent', 'CodeableConcept', false, TFhirCodeableConcept, FTreatmentIntent.Link));
  oList.add(TFHIRProperty.create(self, 'dosage', 'BackboneElement', true, TFhirMedicationKnowledgeIndicationGuidelineDosingGuidelineDosage, FDosageList.Link));
  oList.add(TFHIRProperty.create(self, 'administrationTreatment', 'CodeableConcept', false, TFhirCodeableConcept, FAdministrationTreatment.Link));
  oList.add(TFHIRProperty.create(self, 'patientCharacteristic', 'BackboneElement', true, TFhirMedicationKnowledgeIndicationGuidelineDosingGuidelinePatientCharacteristic, FPatientCharacteristicList.Link));
end;

function TFhirMedicationKnowledgeIndicationGuidelineDosingGuideline.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'treatmentIntent') then
  begin
    TreatmentIntent := propValue as TFhirCodeableConcept;
    result := propValue;
  end
  else if (propName = 'dosage') then
  begin
    DosageList.add(propValue as TFhirMedicationKnowledgeIndicationGuidelineDosingGuidelineDosage);
    result := propValue;
  end
  else if (propName = 'administrationTreatment') then
  begin
    AdministrationTreatment := propValue as TFhirCodeableConcept;
    result := propValue;
  end
  else if (propName = 'patientCharacteristic') then
  begin
    PatientCharacteristicList.add(propValue as TFhirMedicationKnowledgeIndicationGuidelineDosingGuidelinePatientCharacteristic);
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirMedicationKnowledgeIndicationGuidelineDosingGuideline.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'dosage') then DosageList.insertItem(index, propValue as TFhirMedicationKnowledgeIndicationGuidelineDosingGuidelineDosage)
  else if (propName = 'patientCharacteristic') then PatientCharacteristicList.insertItem(index, propValue as TFhirMedicationKnowledgeIndicationGuidelineDosingGuidelinePatientCharacteristic)
  else inherited;
end;

function TFhirMedicationKnowledgeIndicationGuidelineDosingGuideline.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'treatmentIntent') then result := TFhirCodeableConcept.create()
  else if (propName = 'dosage') then result := DosageList.new()
  else if (propName = 'administrationTreatment') then result := TFhirCodeableConcept.create()
  else if (propName = 'patientCharacteristic') then result := PatientCharacteristicList.new()
  else result := inherited createPropertyValue(propName);
end;

function TFhirMedicationKnowledgeIndicationGuidelineDosingGuideline.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'treatmentIntent') then result := 'CodeableConcept'
  else if (propName = 'dosage') then result := 'BackboneElement'
  else if (propName = 'administrationTreatment') then result := 'CodeableConcept'
  else if (propName = 'patientCharacteristic') then result := 'BackboneElement'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirMedicationKnowledgeIndicationGuidelineDosingGuideline.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'treatmentIntent') then TreatmentIntentElement := nil
  else if (propName = 'dosage') then deletePropertyValue('dosage', DosageList, value)
  else if (propName = 'administrationTreatment') then AdministrationTreatmentElement := nil
  else if (propName = 'patientCharacteristic') then deletePropertyValue('patientCharacteristic', PatientCharacteristicList, value)
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirMedicationKnowledgeIndicationGuidelineDosingGuideline.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'treatmentIntent') then TreatmentIntentElement := new as TFhirCodeableConcept
  else if (propName = 'dosage') then replacePropertyValue('dosage', DosageList, existing, new)
  else if (propName = 'administrationTreatment') then AdministrationTreatmentElement := new as TFhirCodeableConcept
  else if (propName = 'patientCharacteristic') then replacePropertyValue('patientCharacteristic', PatientCharacteristicList, existing, new)
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirMedicationKnowledgeIndicationGuidelineDosingGuideline.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'dosage') then DosageList.move(source, destination)
  else if (propName = 'patientCharacteristic') then PatientCharacteristicList.move(source, destination)
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirMedicationKnowledgeIndicationGuidelineDosingGuideline.fhirType : string;
begin
  result := 'MedicationKnowledge.indicationGuideline.dosingGuideline';
end;

function TFhirMedicationKnowledgeIndicationGuidelineDosingGuideline.Link : TFhirMedicationKnowledgeIndicationGuidelineDosingGuideline;
begin
  result := TFhirMedicationKnowledgeIndicationGuidelineDosingGuideline(inherited Link);
end;

function TFhirMedicationKnowledgeIndicationGuidelineDosingGuideline.Clone : TFhirMedicationKnowledgeIndicationGuidelineDosingGuideline;
begin
  result := TFhirMedicationKnowledgeIndicationGuidelineDosingGuideline(inherited Clone);
end;

function TFhirMedicationKnowledgeIndicationGuidelineDosingGuideline.equals(other : TObject) : boolean; 
var
  o : TFhirMedicationKnowledgeIndicationGuidelineDosingGuideline;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirMedicationKnowledgeIndicationGuidelineDosingGuideline)) then
    result := false
  else
  begin
    o := TFhirMedicationKnowledgeIndicationGuidelineDosingGuideline(other);
    result := compareDeep(treatmentIntentElement, o.treatmentIntentElement, true) and 
      compareDeep(dosageList, o.dosageList, true) and compareDeep(administrationTreatmentElement, o.administrationTreatmentElement, true) and 
      compareDeep(patientCharacteristicList, o.patientCharacteristicList, true);
  end;
end;

function TFhirMedicationKnowledgeIndicationGuidelineDosingGuideline.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FTreatmentIntent) and isEmptyProp(FdosageList) and isEmptyProp(FAdministrationTreatment) and isEmptyProp(FpatientCharacteristicList);
end;

procedure TFhirMedicationKnowledgeIndicationGuidelineDosingGuideline.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('treatmentIntent');
  fields.add('dosage');
  fields.add('administrationTreatment');
  fields.add('patientCharacteristic');
end;

function TFhirMedicationKnowledgeIndicationGuidelineDosingGuideline.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
  inc(result, FDosageList.sizeInBytes(magic));
  inc(result, FPatientCharacteristicList.sizeInBytes(magic));
end;

procedure TFhirMedicationKnowledgeIndicationGuidelineDosingGuideline.SetTreatmentIntent(value : TFhirCodeableConcept);
begin
  FTreatmentIntent.free;
  FTreatmentIntent := value;
end;

function TFhirMedicationKnowledgeIndicationGuidelineDosingGuideline.GetDosageList : TFhirMedicationKnowledgeIndicationGuidelineDosingGuidelineDosageList;
begin
  if FDosageList = nil then
    FDosageList := TFhirMedicationKnowledgeIndicationGuidelineDosingGuidelineDosageList.Create;
  result := FDosageList;
end;

function TFhirMedicationKnowledgeIndicationGuidelineDosingGuideline.GetHasDosageList : boolean;
begin
  result := (FDosageList <> nil) and (FDosageList.count > 0);
end;

procedure TFhirMedicationKnowledgeIndicationGuidelineDosingGuideline.SetAdministrationTreatment(value : TFhirCodeableConcept);
begin
  FAdministrationTreatment.free;
  FAdministrationTreatment := value;
end;

function TFhirMedicationKnowledgeIndicationGuidelineDosingGuideline.GetPatientCharacteristicList : TFhirMedicationKnowledgeIndicationGuidelineDosingGuidelinePatientCharacteristicList;
begin
  if FPatientCharacteristicList = nil then
    FPatientCharacteristicList := TFhirMedicationKnowledgeIndicationGuidelineDosingGuidelinePatientCharacteristicList.Create;
  result := FPatientCharacteristicList;
end;

function TFhirMedicationKnowledgeIndicationGuidelineDosingGuideline.GetHasPatientCharacteristicList : boolean;
begin
  result := (FPatientCharacteristicList <> nil) and (FPatientCharacteristicList.count > 0);
end;

{ TFhirMedicationKnowledgeIndicationGuidelineDosingGuidelineListEnumerator }

constructor TFhirMedicationKnowledgeIndicationGuidelineDosingGuidelineListEnumerator.Create(list : TFhirMedicationKnowledgeIndicationGuidelineDosingGuidelineList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirMedicationKnowledgeIndicationGuidelineDosingGuidelineListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirMedicationKnowledgeIndicationGuidelineDosingGuidelineListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirMedicationKnowledgeIndicationGuidelineDosingGuidelineListEnumerator.GetCurrent : TFhirMedicationKnowledgeIndicationGuidelineDosingGuideline;
begin
  Result := FList[FIndex];
end;

function TFhirMedicationKnowledgeIndicationGuidelineDosingGuidelineListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirMedicationKnowledgeIndicationGuidelineDosingGuidelineList }

function TFhirMedicationKnowledgeIndicationGuidelineDosingGuidelineList.AddItem(value: TFhirMedicationKnowledgeIndicationGuidelineDosingGuideline): TFhirMedicationKnowledgeIndicationGuidelineDosingGuideline;
begin
  assert(value.ClassName = 'TFhirMedicationKnowledgeIndicationGuidelineDosingGuideline', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirMedicationKnowledgeIndicationGuidelineDosingGuideline');
  add(value);
  result := value;
end;

function TFhirMedicationKnowledgeIndicationGuidelineDosingGuidelineList.Append: TFhirMedicationKnowledgeIndicationGuidelineDosingGuideline;
begin
  result := TFhirMedicationKnowledgeIndicationGuidelineDosingGuideline.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirMedicationKnowledgeIndicationGuidelineDosingGuidelineList.ClearItems;
begin
  Clear;
end;

function TFhirMedicationKnowledgeIndicationGuidelineDosingGuidelineList.GetEnumerator : TFhirMedicationKnowledgeIndicationGuidelineDosingGuidelineListEnumerator;
begin
  result := TFhirMedicationKnowledgeIndicationGuidelineDosingGuidelineListEnumerator.Create(self.link);
end;

function TFhirMedicationKnowledgeIndicationGuidelineDosingGuidelineList.Clone: TFhirMedicationKnowledgeIndicationGuidelineDosingGuidelineList;
begin
  result := TFhirMedicationKnowledgeIndicationGuidelineDosingGuidelineList(inherited Clone);
end;

function TFhirMedicationKnowledgeIndicationGuidelineDosingGuidelineList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirMedicationKnowledgeIndicationGuidelineDosingGuidelineList.GetItemN(index: Integer): TFhirMedicationKnowledgeIndicationGuidelineDosingGuideline;
begin
  result := TFhirMedicationKnowledgeIndicationGuidelineDosingGuideline(ObjectByIndex[index]);
end;

function TFhirMedicationKnowledgeIndicationGuidelineDosingGuidelineList.ItemClass: TFslObjectClass;
begin
  result := TFhirMedicationKnowledgeIndicationGuidelineDosingGuideline;
end;
function TFhirMedicationKnowledgeIndicationGuidelineDosingGuidelineList.IndexOf(value: TFhirMedicationKnowledgeIndicationGuidelineDosingGuideline): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirMedicationKnowledgeIndicationGuidelineDosingGuidelineList.Insert(index: Integer): TFhirMedicationKnowledgeIndicationGuidelineDosingGuideline;
begin
  result := TFhirMedicationKnowledgeIndicationGuidelineDosingGuideline.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirMedicationKnowledgeIndicationGuidelineDosingGuidelineList.InsertItem(index: Integer; value: TFhirMedicationKnowledgeIndicationGuidelineDosingGuideline);
begin
  assert(value is TFhirMedicationKnowledgeIndicationGuidelineDosingGuideline);
  Inherited Insert(index, value);
end;

function TFhirMedicationKnowledgeIndicationGuidelineDosingGuidelineList.Item(index: Integer): TFhirMedicationKnowledgeIndicationGuidelineDosingGuideline;
begin
  result := TFhirMedicationKnowledgeIndicationGuidelineDosingGuideline(ObjectByIndex[index]);
end;

function TFhirMedicationKnowledgeIndicationGuidelineDosingGuidelineList.Link: TFhirMedicationKnowledgeIndicationGuidelineDosingGuidelineList;
begin
  result := TFhirMedicationKnowledgeIndicationGuidelineDosingGuidelineList(inherited Link);
end;

procedure TFhirMedicationKnowledgeIndicationGuidelineDosingGuidelineList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirMedicationKnowledgeIndicationGuidelineDosingGuidelineList.SetItemByIndex(index: Integer; value: TFhirMedicationKnowledgeIndicationGuidelineDosingGuideline);
begin
  assert(value is TFhirMedicationKnowledgeIndicationGuidelineDosingGuideline);
  FhirMedicationKnowledgeIndicationGuidelineDosingGuidelines[index] := value;
end;

procedure TFhirMedicationKnowledgeIndicationGuidelineDosingGuidelineList.SetItemN(index: Integer; value: TFhirMedicationKnowledgeIndicationGuidelineDosingGuideline);
begin
  assert(value is TFhirMedicationKnowledgeIndicationGuidelineDosingGuideline);
  ObjectByIndex[index] := value;
end;

{ TFhirMedicationKnowledgeIndicationGuidelineDosingGuidelineDosage }

constructor TFhirMedicationKnowledgeIndicationGuidelineDosingGuidelineDosage.Create;
begin
  inherited;
end;

destructor TFhirMedicationKnowledgeIndicationGuidelineDosingGuidelineDosage.Destroy;
begin
  FType_.free;
  FDosageList.Free;
  inherited;
end;

procedure TFhirMedicationKnowledgeIndicationGuidelineDosingGuidelineDosage.Assign(oSource : TFslObject);
begin
  inherited;
  type_ := TFhirMedicationKnowledgeIndicationGuidelineDosingGuidelineDosage(oSource).type_.Clone;
  if (TFhirMedicationKnowledgeIndicationGuidelineDosingGuidelineDosage(oSource).FDosageList = nil) then
  begin
    FDosageList.free;
    FDosageList := nil;
  end
  else
  begin
    if FDosageList = nil then
      FDosageList := TFhirDosageList.Create;
    FDosageList.Assign(TFhirMedicationKnowledgeIndicationGuidelineDosingGuidelineDosage(oSource).FDosageList);
  end;
end;

procedure TFhirMedicationKnowledgeIndicationGuidelineDosingGuidelineDosage.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'type') Then
     list.add(self.link, 'type', FType_.Link);
  if (child_name = 'dosage') Then
    list.addAll(self, 'dosage', FDosageList);
end;

procedure TFhirMedicationKnowledgeIndicationGuidelineDosingGuidelineDosage.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'type', 'CodeableConcept', false, TFhirCodeableConcept, FType_.Link));
  oList.add(TFHIRProperty.create(self, 'dosage', 'Dosage', true, TFhirDosage, FDosageList.Link));
end;

function TFhirMedicationKnowledgeIndicationGuidelineDosingGuidelineDosage.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'type') then
  begin
    Type_ := propValue as TFhirCodeableConcept;
    result := propValue;
  end
  else if (propName = 'dosage') then
  begin
    DosageList.add(propValue as TFhirDosage);
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirMedicationKnowledgeIndicationGuidelineDosingGuidelineDosage.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'dosage') then DosageList.insertItem(index, propValue as TFhirDosage)
  else inherited;
end;

function TFhirMedicationKnowledgeIndicationGuidelineDosingGuidelineDosage.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'type') then result := TFhirCodeableConcept.create()
  else if (propName = 'dosage') then result := DosageList.new()
  else result := inherited createPropertyValue(propName);
end;

function TFhirMedicationKnowledgeIndicationGuidelineDosingGuidelineDosage.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'type') then result := 'CodeableConcept'
  else if (propName = 'dosage') then result := 'Dosage'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirMedicationKnowledgeIndicationGuidelineDosingGuidelineDosage.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'type') then Type_Element := nil
  else if (propName = 'dosage') then deletePropertyValue('dosage', DosageList, value)
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirMedicationKnowledgeIndicationGuidelineDosingGuidelineDosage.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'type') then Type_Element := new as TFhirCodeableConcept
  else if (propName = 'dosage') then replacePropertyValue('dosage', DosageList, existing, new)
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirMedicationKnowledgeIndicationGuidelineDosingGuidelineDosage.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'dosage') then DosageList.move(source, destination)
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirMedicationKnowledgeIndicationGuidelineDosingGuidelineDosage.fhirType : string;
begin
  result := 'MedicationKnowledge.indicationGuideline.dosingGuideline.dosage';
end;

function TFhirMedicationKnowledgeIndicationGuidelineDosingGuidelineDosage.Link : TFhirMedicationKnowledgeIndicationGuidelineDosingGuidelineDosage;
begin
  result := TFhirMedicationKnowledgeIndicationGuidelineDosingGuidelineDosage(inherited Link);
end;

function TFhirMedicationKnowledgeIndicationGuidelineDosingGuidelineDosage.Clone : TFhirMedicationKnowledgeIndicationGuidelineDosingGuidelineDosage;
begin
  result := TFhirMedicationKnowledgeIndicationGuidelineDosingGuidelineDosage(inherited Clone);
end;

function TFhirMedicationKnowledgeIndicationGuidelineDosingGuidelineDosage.equals(other : TObject) : boolean; 
var
  o : TFhirMedicationKnowledgeIndicationGuidelineDosingGuidelineDosage;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirMedicationKnowledgeIndicationGuidelineDosingGuidelineDosage)) then
    result := false
  else
  begin
    o := TFhirMedicationKnowledgeIndicationGuidelineDosingGuidelineDosage(other);
    result := compareDeep(type_Element, o.type_Element, true) and compareDeep(dosageList, o.dosageList, true);
  end;
end;

function TFhirMedicationKnowledgeIndicationGuidelineDosingGuidelineDosage.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FType_) and isEmptyProp(FdosageList);
end;

procedure TFhirMedicationKnowledgeIndicationGuidelineDosingGuidelineDosage.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('type');
  fields.add('dosage');
end;

function TFhirMedicationKnowledgeIndicationGuidelineDosingGuidelineDosage.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
  inc(result, FDosageList.sizeInBytes(magic));
end;

procedure TFhirMedicationKnowledgeIndicationGuidelineDosingGuidelineDosage.SetType_(value : TFhirCodeableConcept);
begin
  FType_.free;
  FType_ := value;
end;

function TFhirMedicationKnowledgeIndicationGuidelineDosingGuidelineDosage.GetDosageList : TFhirDosageList;
begin
  if FDosageList = nil then
    FDosageList := TFhirDosageList.Create;
  result := FDosageList;
end;

function TFhirMedicationKnowledgeIndicationGuidelineDosingGuidelineDosage.GetHasDosageList : boolean;
begin
  result := (FDosageList <> nil) and (FDosageList.count > 0);
end;

{ TFhirMedicationKnowledgeIndicationGuidelineDosingGuidelineDosageListEnumerator }

constructor TFhirMedicationKnowledgeIndicationGuidelineDosingGuidelineDosageListEnumerator.Create(list : TFhirMedicationKnowledgeIndicationGuidelineDosingGuidelineDosageList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirMedicationKnowledgeIndicationGuidelineDosingGuidelineDosageListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirMedicationKnowledgeIndicationGuidelineDosingGuidelineDosageListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirMedicationKnowledgeIndicationGuidelineDosingGuidelineDosageListEnumerator.GetCurrent : TFhirMedicationKnowledgeIndicationGuidelineDosingGuidelineDosage;
begin
  Result := FList[FIndex];
end;

function TFhirMedicationKnowledgeIndicationGuidelineDosingGuidelineDosageListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirMedicationKnowledgeIndicationGuidelineDosingGuidelineDosageList }

function TFhirMedicationKnowledgeIndicationGuidelineDosingGuidelineDosageList.AddItem(value: TFhirMedicationKnowledgeIndicationGuidelineDosingGuidelineDosage): TFhirMedicationKnowledgeIndicationGuidelineDosingGuidelineDosage;
begin
  assert(value.ClassName = 'TFhirMedicationKnowledgeIndicationGuidelineDosingGuidelineDosage', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirMedicationKnowledgeIndicationGuidelineDosingGuidelineDosage');
  add(value);
  result := value;
end;

function TFhirMedicationKnowledgeIndicationGuidelineDosingGuidelineDosageList.Append: TFhirMedicationKnowledgeIndicationGuidelineDosingGuidelineDosage;
begin
  result := TFhirMedicationKnowledgeIndicationGuidelineDosingGuidelineDosage.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirMedicationKnowledgeIndicationGuidelineDosingGuidelineDosageList.ClearItems;
begin
  Clear;
end;

function TFhirMedicationKnowledgeIndicationGuidelineDosingGuidelineDosageList.GetEnumerator : TFhirMedicationKnowledgeIndicationGuidelineDosingGuidelineDosageListEnumerator;
begin
  result := TFhirMedicationKnowledgeIndicationGuidelineDosingGuidelineDosageListEnumerator.Create(self.link);
end;

function TFhirMedicationKnowledgeIndicationGuidelineDosingGuidelineDosageList.Clone: TFhirMedicationKnowledgeIndicationGuidelineDosingGuidelineDosageList;
begin
  result := TFhirMedicationKnowledgeIndicationGuidelineDosingGuidelineDosageList(inherited Clone);
end;

function TFhirMedicationKnowledgeIndicationGuidelineDosingGuidelineDosageList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirMedicationKnowledgeIndicationGuidelineDosingGuidelineDosageList.GetItemN(index: Integer): TFhirMedicationKnowledgeIndicationGuidelineDosingGuidelineDosage;
begin
  result := TFhirMedicationKnowledgeIndicationGuidelineDosingGuidelineDosage(ObjectByIndex[index]);
end;

function TFhirMedicationKnowledgeIndicationGuidelineDosingGuidelineDosageList.ItemClass: TFslObjectClass;
begin
  result := TFhirMedicationKnowledgeIndicationGuidelineDosingGuidelineDosage;
end;
function TFhirMedicationKnowledgeIndicationGuidelineDosingGuidelineDosageList.IndexOf(value: TFhirMedicationKnowledgeIndicationGuidelineDosingGuidelineDosage): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirMedicationKnowledgeIndicationGuidelineDosingGuidelineDosageList.Insert(index: Integer): TFhirMedicationKnowledgeIndicationGuidelineDosingGuidelineDosage;
begin
  result := TFhirMedicationKnowledgeIndicationGuidelineDosingGuidelineDosage.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirMedicationKnowledgeIndicationGuidelineDosingGuidelineDosageList.InsertItem(index: Integer; value: TFhirMedicationKnowledgeIndicationGuidelineDosingGuidelineDosage);
begin
  assert(value is TFhirMedicationKnowledgeIndicationGuidelineDosingGuidelineDosage);
  Inherited Insert(index, value);
end;

function TFhirMedicationKnowledgeIndicationGuidelineDosingGuidelineDosageList.Item(index: Integer): TFhirMedicationKnowledgeIndicationGuidelineDosingGuidelineDosage;
begin
  result := TFhirMedicationKnowledgeIndicationGuidelineDosingGuidelineDosage(ObjectByIndex[index]);
end;

function TFhirMedicationKnowledgeIndicationGuidelineDosingGuidelineDosageList.Link: TFhirMedicationKnowledgeIndicationGuidelineDosingGuidelineDosageList;
begin
  result := TFhirMedicationKnowledgeIndicationGuidelineDosingGuidelineDosageList(inherited Link);
end;

procedure TFhirMedicationKnowledgeIndicationGuidelineDosingGuidelineDosageList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirMedicationKnowledgeIndicationGuidelineDosingGuidelineDosageList.SetItemByIndex(index: Integer; value: TFhirMedicationKnowledgeIndicationGuidelineDosingGuidelineDosage);
begin
  assert(value is TFhirMedicationKnowledgeIndicationGuidelineDosingGuidelineDosage);
  FhirMedicationKnowledgeIndicationGuidelineDosingGuidelineDosages[index] := value;
end;

procedure TFhirMedicationKnowledgeIndicationGuidelineDosingGuidelineDosageList.SetItemN(index: Integer; value: TFhirMedicationKnowledgeIndicationGuidelineDosingGuidelineDosage);
begin
  assert(value is TFhirMedicationKnowledgeIndicationGuidelineDosingGuidelineDosage);
  ObjectByIndex[index] := value;
end;

{ TFhirMedicationKnowledgeIndicationGuidelineDosingGuidelinePatientCharacteristic }

constructor TFhirMedicationKnowledgeIndicationGuidelineDosingGuidelinePatientCharacteristic.Create;
begin
  inherited;
end;

destructor TFhirMedicationKnowledgeIndicationGuidelineDosingGuidelinePatientCharacteristic.Destroy;
begin
  FType_.free;
  FValue.free;
  inherited;
end;

procedure TFhirMedicationKnowledgeIndicationGuidelineDosingGuidelinePatientCharacteristic.Assign(oSource : TFslObject);
begin
  inherited;
  type_ := TFhirMedicationKnowledgeIndicationGuidelineDosingGuidelinePatientCharacteristic(oSource).type_.Clone;
  value := TFhirMedicationKnowledgeIndicationGuidelineDosingGuidelinePatientCharacteristic(oSource).value.Clone;
end;

procedure TFhirMedicationKnowledgeIndicationGuidelineDosingGuidelinePatientCharacteristic.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'type') Then
     list.add(self.link, 'type', FType_.Link);
  if (child_name = 'value[x]') or (child_name = 'value') Then
     list.add(self.link, 'value[x]', FValue.Link);
end;

procedure TFhirMedicationKnowledgeIndicationGuidelineDosingGuidelinePatientCharacteristic.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'type', 'CodeableConcept', false, TFhirCodeableConcept, FType_.Link));
  oList.add(TFHIRProperty.create(self, 'value[x]', 'CodeableConcept|Quantity|Range', false, TFhirDataType, FValue.Link));
end;

function TFhirMedicationKnowledgeIndicationGuidelineDosingGuidelinePatientCharacteristic.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'type') then
  begin
    Type_ := propValue as TFhirCodeableConcept;
    result := propValue;
  end
  else if (isMatchingName(propName, 'value', ['CodeableConcept', 'Quantity', 'Range'])) then
  begin
    Value := propValue as TFhirDataType;
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirMedicationKnowledgeIndicationGuidelineDosingGuidelinePatientCharacteristic.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirMedicationKnowledgeIndicationGuidelineDosingGuidelinePatientCharacteristic.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'type') then result := TFhirCodeableConcept.create()
  else if (isMatchingName(propName, 'value', ['CodeableConcept', 'Quantity', 'Range'])) then raise EFHIRException.create('Cannot make property Value')
  else result := inherited createPropertyValue(propName);
end;

function TFhirMedicationKnowledgeIndicationGuidelineDosingGuidelinePatientCharacteristic.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'type') then result := 'CodeableConcept'
  else if (propName = 'value[x]') then result := 'CodeableConcept|Quantity|Range'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirMedicationKnowledgeIndicationGuidelineDosingGuidelinePatientCharacteristic.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'type') then Type_Element := nil
  else if (isMatchingName(propName, 'value', ['CodeableConcept', 'Quantity', 'Range'])) then ValueElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirMedicationKnowledgeIndicationGuidelineDosingGuidelinePatientCharacteristic.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'type') then Type_Element := new as TFhirCodeableConcept
  else if (isMatchingName(propName, 'value', ['CodeableConcept', 'Quantity', 'Range'])) then ValueElement := new as TFhirDataType
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirMedicationKnowledgeIndicationGuidelineDosingGuidelinePatientCharacteristic.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirMedicationKnowledgeIndicationGuidelineDosingGuidelinePatientCharacteristic.fhirType : string;
begin
  result := 'MedicationKnowledge.indicationGuideline.dosingGuideline.patientCharacteristic';
end;

function TFhirMedicationKnowledgeIndicationGuidelineDosingGuidelinePatientCharacteristic.Link : TFhirMedicationKnowledgeIndicationGuidelineDosingGuidelinePatientCharacteristic;
begin
  result := TFhirMedicationKnowledgeIndicationGuidelineDosingGuidelinePatientCharacteristic(inherited Link);
end;

function TFhirMedicationKnowledgeIndicationGuidelineDosingGuidelinePatientCharacteristic.Clone : TFhirMedicationKnowledgeIndicationGuidelineDosingGuidelinePatientCharacteristic;
begin
  result := TFhirMedicationKnowledgeIndicationGuidelineDosingGuidelinePatientCharacteristic(inherited Clone);
end;

function TFhirMedicationKnowledgeIndicationGuidelineDosingGuidelinePatientCharacteristic.equals(other : TObject) : boolean; 
var
  o : TFhirMedicationKnowledgeIndicationGuidelineDosingGuidelinePatientCharacteristic;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirMedicationKnowledgeIndicationGuidelineDosingGuidelinePatientCharacteristic)) then
    result := false
  else
  begin
    o := TFhirMedicationKnowledgeIndicationGuidelineDosingGuidelinePatientCharacteristic(other);
    result := compareDeep(type_Element, o.type_Element, true) and compareDeep(valueElement, o.valueElement, true);
  end;
end;

function TFhirMedicationKnowledgeIndicationGuidelineDosingGuidelinePatientCharacteristic.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FType_) and isEmptyProp(FValue);
end;

procedure TFhirMedicationKnowledgeIndicationGuidelineDosingGuidelinePatientCharacteristic.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('type');
  fields.add('value[x]');
end;

function TFhirMedicationKnowledgeIndicationGuidelineDosingGuidelinePatientCharacteristic.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
end;

procedure TFhirMedicationKnowledgeIndicationGuidelineDosingGuidelinePatientCharacteristic.SetType_(value : TFhirCodeableConcept);
begin
  FType_.free;
  FType_ := value;
end;

procedure TFhirMedicationKnowledgeIndicationGuidelineDosingGuidelinePatientCharacteristic.SetValue(value : TFhirDataType);
begin
  FValue.free;
  FValue := value;
end;

{ TFhirMedicationKnowledgeIndicationGuidelineDosingGuidelinePatientCharacteristicListEnumerator }

constructor TFhirMedicationKnowledgeIndicationGuidelineDosingGuidelinePatientCharacteristicListEnumerator.Create(list : TFhirMedicationKnowledgeIndicationGuidelineDosingGuidelinePatientCharacteristicList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirMedicationKnowledgeIndicationGuidelineDosingGuidelinePatientCharacteristicListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirMedicationKnowledgeIndicationGuidelineDosingGuidelinePatientCharacteristicListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirMedicationKnowledgeIndicationGuidelineDosingGuidelinePatientCharacteristicListEnumerator.GetCurrent : TFhirMedicationKnowledgeIndicationGuidelineDosingGuidelinePatientCharacteristic;
begin
  Result := FList[FIndex];
end;

function TFhirMedicationKnowledgeIndicationGuidelineDosingGuidelinePatientCharacteristicListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirMedicationKnowledgeIndicationGuidelineDosingGuidelinePatientCharacteristicList }

function TFhirMedicationKnowledgeIndicationGuidelineDosingGuidelinePatientCharacteristicList.AddItem(value: TFhirMedicationKnowledgeIndicationGuidelineDosingGuidelinePatientCharacteristic): TFhirMedicationKnowledgeIndicationGuidelineDosingGuidelinePatientCharacteristic;
begin
  assert(value.ClassName = 'TFhirMedicationKnowledgeIndicationGuidelineDosingGuidelinePatientCharacteristic', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirMedicationKnowledgeIndicationGuidelineDosingGuidelinePatientCharacteristic');
  add(value);
  result := value;
end;

function TFhirMedicationKnowledgeIndicationGuidelineDosingGuidelinePatientCharacteristicList.Append: TFhirMedicationKnowledgeIndicationGuidelineDosingGuidelinePatientCharacteristic;
begin
  result := TFhirMedicationKnowledgeIndicationGuidelineDosingGuidelinePatientCharacteristic.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirMedicationKnowledgeIndicationGuidelineDosingGuidelinePatientCharacteristicList.ClearItems;
begin
  Clear;
end;

function TFhirMedicationKnowledgeIndicationGuidelineDosingGuidelinePatientCharacteristicList.GetEnumerator : TFhirMedicationKnowledgeIndicationGuidelineDosingGuidelinePatientCharacteristicListEnumerator;
begin
  result := TFhirMedicationKnowledgeIndicationGuidelineDosingGuidelinePatientCharacteristicListEnumerator.Create(self.link);
end;

function TFhirMedicationKnowledgeIndicationGuidelineDosingGuidelinePatientCharacteristicList.Clone: TFhirMedicationKnowledgeIndicationGuidelineDosingGuidelinePatientCharacteristicList;
begin
  result := TFhirMedicationKnowledgeIndicationGuidelineDosingGuidelinePatientCharacteristicList(inherited Clone);
end;

function TFhirMedicationKnowledgeIndicationGuidelineDosingGuidelinePatientCharacteristicList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirMedicationKnowledgeIndicationGuidelineDosingGuidelinePatientCharacteristicList.GetItemN(index: Integer): TFhirMedicationKnowledgeIndicationGuidelineDosingGuidelinePatientCharacteristic;
begin
  result := TFhirMedicationKnowledgeIndicationGuidelineDosingGuidelinePatientCharacteristic(ObjectByIndex[index]);
end;

function TFhirMedicationKnowledgeIndicationGuidelineDosingGuidelinePatientCharacteristicList.ItemClass: TFslObjectClass;
begin
  result := TFhirMedicationKnowledgeIndicationGuidelineDosingGuidelinePatientCharacteristic;
end;
function TFhirMedicationKnowledgeIndicationGuidelineDosingGuidelinePatientCharacteristicList.IndexOf(value: TFhirMedicationKnowledgeIndicationGuidelineDosingGuidelinePatientCharacteristic): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirMedicationKnowledgeIndicationGuidelineDosingGuidelinePatientCharacteristicList.Insert(index: Integer): TFhirMedicationKnowledgeIndicationGuidelineDosingGuidelinePatientCharacteristic;
begin
  result := TFhirMedicationKnowledgeIndicationGuidelineDosingGuidelinePatientCharacteristic.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirMedicationKnowledgeIndicationGuidelineDosingGuidelinePatientCharacteristicList.InsertItem(index: Integer; value: TFhirMedicationKnowledgeIndicationGuidelineDosingGuidelinePatientCharacteristic);
begin
  assert(value is TFhirMedicationKnowledgeIndicationGuidelineDosingGuidelinePatientCharacteristic);
  Inherited Insert(index, value);
end;

function TFhirMedicationKnowledgeIndicationGuidelineDosingGuidelinePatientCharacteristicList.Item(index: Integer): TFhirMedicationKnowledgeIndicationGuidelineDosingGuidelinePatientCharacteristic;
begin
  result := TFhirMedicationKnowledgeIndicationGuidelineDosingGuidelinePatientCharacteristic(ObjectByIndex[index]);
end;

function TFhirMedicationKnowledgeIndicationGuidelineDosingGuidelinePatientCharacteristicList.Link: TFhirMedicationKnowledgeIndicationGuidelineDosingGuidelinePatientCharacteristicList;
begin
  result := TFhirMedicationKnowledgeIndicationGuidelineDosingGuidelinePatientCharacteristicList(inherited Link);
end;

procedure TFhirMedicationKnowledgeIndicationGuidelineDosingGuidelinePatientCharacteristicList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirMedicationKnowledgeIndicationGuidelineDosingGuidelinePatientCharacteristicList.SetItemByIndex(index: Integer; value: TFhirMedicationKnowledgeIndicationGuidelineDosingGuidelinePatientCharacteristic);
begin
  assert(value is TFhirMedicationKnowledgeIndicationGuidelineDosingGuidelinePatientCharacteristic);
  FhirMedicationKnowledgeIndicationGuidelineDosingGuidelinePatientCharacteristics[index] := value;
end;

procedure TFhirMedicationKnowledgeIndicationGuidelineDosingGuidelinePatientCharacteristicList.SetItemN(index: Integer; value: TFhirMedicationKnowledgeIndicationGuidelineDosingGuidelinePatientCharacteristic);
begin
  assert(value is TFhirMedicationKnowledgeIndicationGuidelineDosingGuidelinePatientCharacteristic);
  ObjectByIndex[index] := value;
end;

{ TFhirMedicationKnowledgeMedicineClassification }

constructor TFhirMedicationKnowledgeMedicineClassification.Create;
begin
  inherited;
end;

destructor TFhirMedicationKnowledgeMedicineClassification.Destroy;
begin
  FType_.free;
  FSource.free;
  FClassificationList.Free;
  inherited;
end;

procedure TFhirMedicationKnowledgeMedicineClassification.Assign(oSource : TFslObject);
begin
  inherited;
  type_ := TFhirMedicationKnowledgeMedicineClassification(oSource).type_.Clone;
  source := TFhirMedicationKnowledgeMedicineClassification(oSource).source.Clone;
  if (TFhirMedicationKnowledgeMedicineClassification(oSource).FClassificationList = nil) then
  begin
    FClassificationList.free;
    FClassificationList := nil;
  end
  else
  begin
    if FClassificationList = nil then
      FClassificationList := TFhirCodeableConceptList.Create;
    FClassificationList.Assign(TFhirMedicationKnowledgeMedicineClassification(oSource).FClassificationList);
  end;
end;

procedure TFhirMedicationKnowledgeMedicineClassification.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'type') Then
     list.add(self.link, 'type', FType_.Link);
  if (child_name = 'source[x]') or (child_name = 'source') Then
     list.add(self.link, 'source[x]', FSource.Link);
  if (child_name = 'classification') Then
    list.addAll(self, 'classification', FClassificationList);
end;

procedure TFhirMedicationKnowledgeMedicineClassification.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'type', 'CodeableConcept', false, TFhirCodeableConcept, FType_.Link));
  oList.add(TFHIRProperty.create(self, 'source[x]', 'string|uri', false, TFhirDataType, FSource.Link));
  oList.add(TFHIRProperty.create(self, 'classification', 'CodeableConcept', true, TFhirCodeableConcept, FClassificationList.Link));
end;

function TFhirMedicationKnowledgeMedicineClassification.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'type') then
  begin
    Type_ := propValue as TFhirCodeableConcept;
    result := propValue;
  end
  else if (isMatchingName(propName, 'source', ['String', 'Uri'])) then
  begin
    Source := propValue as TFhirDataType;
    result := propValue;
  end
  else if (propName = 'classification') then
  begin
    ClassificationList.add(propValue as TFhirCodeableConcept);
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirMedicationKnowledgeMedicineClassification.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'classification') then ClassificationList.insertItem(index, propValue as TFhirCodeableConcept)
  else inherited;
end;

function TFhirMedicationKnowledgeMedicineClassification.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'type') then result := TFhirCodeableConcept.create()
  else if (isMatchingName(propName, 'source', ['String', 'Uri'])) then raise EFHIRException.create('Cannot make property Source')
  else if (propName = 'classification') then result := ClassificationList.new()
  else result := inherited createPropertyValue(propName);
end;

function TFhirMedicationKnowledgeMedicineClassification.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'type') then result := 'CodeableConcept'
  else if (propName = 'source[x]') then result := 'string|uri'
  else if (propName = 'classification') then result := 'CodeableConcept'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirMedicationKnowledgeMedicineClassification.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'type') then Type_Element := nil
  else if (isMatchingName(propName, 'source', ['String', 'Uri'])) then SourceElement := nil
  else if (propName = 'classification') then deletePropertyValue('classification', ClassificationList, value)
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirMedicationKnowledgeMedicineClassification.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'type') then Type_Element := new as TFhirCodeableConcept
  else if (isMatchingName(propName, 'source', ['String', 'Uri'])) then SourceElement := new as TFhirDataType
  else if (propName = 'classification') then replacePropertyValue('classification', ClassificationList, existing, new)
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirMedicationKnowledgeMedicineClassification.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'classification') then ClassificationList.move(source, destination)
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirMedicationKnowledgeMedicineClassification.fhirType : string;
begin
  result := 'MedicationKnowledge.medicineClassification';
end;

function TFhirMedicationKnowledgeMedicineClassification.Link : TFhirMedicationKnowledgeMedicineClassification;
begin
  result := TFhirMedicationKnowledgeMedicineClassification(inherited Link);
end;

function TFhirMedicationKnowledgeMedicineClassification.Clone : TFhirMedicationKnowledgeMedicineClassification;
begin
  result := TFhirMedicationKnowledgeMedicineClassification(inherited Clone);
end;

function TFhirMedicationKnowledgeMedicineClassification.equals(other : TObject) : boolean; 
var
  o : TFhirMedicationKnowledgeMedicineClassification;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirMedicationKnowledgeMedicineClassification)) then
    result := false
  else
  begin
    o := TFhirMedicationKnowledgeMedicineClassification(other);
    result := compareDeep(type_Element, o.type_Element, true) and compareDeep(sourceElement, o.sourceElement, true) and 
      compareDeep(classificationList, o.classificationList, true);
  end;
end;

function TFhirMedicationKnowledgeMedicineClassification.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FType_) and isEmptyProp(FSource) and isEmptyProp(FclassificationList);
end;

procedure TFhirMedicationKnowledgeMedicineClassification.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('type');
  fields.add('source[x]');
  fields.add('classification');
end;

function TFhirMedicationKnowledgeMedicineClassification.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
  inc(result, FClassificationList.sizeInBytes(magic));
end;

procedure TFhirMedicationKnowledgeMedicineClassification.SetType_(value : TFhirCodeableConcept);
begin
  FType_.free;
  FType_ := value;
end;

procedure TFhirMedicationKnowledgeMedicineClassification.SetSource(value : TFhirDataType);
begin
  FSource.free;
  FSource := value;
end;

function TFhirMedicationKnowledgeMedicineClassification.GetClassificationList : TFhirCodeableConceptList;
begin
  if FClassificationList = nil then
    FClassificationList := TFhirCodeableConceptList.Create;
  result := FClassificationList;
end;

function TFhirMedicationKnowledgeMedicineClassification.GetHasClassificationList : boolean;
begin
  result := (FClassificationList <> nil) and (FClassificationList.count > 0);
end;

{ TFhirMedicationKnowledgeMedicineClassificationListEnumerator }

constructor TFhirMedicationKnowledgeMedicineClassificationListEnumerator.Create(list : TFhirMedicationKnowledgeMedicineClassificationList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirMedicationKnowledgeMedicineClassificationListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirMedicationKnowledgeMedicineClassificationListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirMedicationKnowledgeMedicineClassificationListEnumerator.GetCurrent : TFhirMedicationKnowledgeMedicineClassification;
begin
  Result := FList[FIndex];
end;

function TFhirMedicationKnowledgeMedicineClassificationListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirMedicationKnowledgeMedicineClassificationList }

function TFhirMedicationKnowledgeMedicineClassificationList.AddItem(value: TFhirMedicationKnowledgeMedicineClassification): TFhirMedicationKnowledgeMedicineClassification;
begin
  assert(value.ClassName = 'TFhirMedicationKnowledgeMedicineClassification', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirMedicationKnowledgeMedicineClassification');
  add(value);
  result := value;
end;

function TFhirMedicationKnowledgeMedicineClassificationList.Append: TFhirMedicationKnowledgeMedicineClassification;
begin
  result := TFhirMedicationKnowledgeMedicineClassification.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirMedicationKnowledgeMedicineClassificationList.ClearItems;
begin
  Clear;
end;

function TFhirMedicationKnowledgeMedicineClassificationList.GetEnumerator : TFhirMedicationKnowledgeMedicineClassificationListEnumerator;
begin
  result := TFhirMedicationKnowledgeMedicineClassificationListEnumerator.Create(self.link);
end;

function TFhirMedicationKnowledgeMedicineClassificationList.Clone: TFhirMedicationKnowledgeMedicineClassificationList;
begin
  result := TFhirMedicationKnowledgeMedicineClassificationList(inherited Clone);
end;

function TFhirMedicationKnowledgeMedicineClassificationList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirMedicationKnowledgeMedicineClassificationList.GetItemN(index: Integer): TFhirMedicationKnowledgeMedicineClassification;
begin
  result := TFhirMedicationKnowledgeMedicineClassification(ObjectByIndex[index]);
end;

function TFhirMedicationKnowledgeMedicineClassificationList.ItemClass: TFslObjectClass;
begin
  result := TFhirMedicationKnowledgeMedicineClassification;
end;
function TFhirMedicationKnowledgeMedicineClassificationList.IndexOf(value: TFhirMedicationKnowledgeMedicineClassification): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirMedicationKnowledgeMedicineClassificationList.Insert(index: Integer): TFhirMedicationKnowledgeMedicineClassification;
begin
  result := TFhirMedicationKnowledgeMedicineClassification.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirMedicationKnowledgeMedicineClassificationList.InsertItem(index: Integer; value: TFhirMedicationKnowledgeMedicineClassification);
begin
  assert(value is TFhirMedicationKnowledgeMedicineClassification);
  Inherited Insert(index, value);
end;

function TFhirMedicationKnowledgeMedicineClassificationList.Item(index: Integer): TFhirMedicationKnowledgeMedicineClassification;
begin
  result := TFhirMedicationKnowledgeMedicineClassification(ObjectByIndex[index]);
end;

function TFhirMedicationKnowledgeMedicineClassificationList.Link: TFhirMedicationKnowledgeMedicineClassificationList;
begin
  result := TFhirMedicationKnowledgeMedicineClassificationList(inherited Link);
end;

procedure TFhirMedicationKnowledgeMedicineClassificationList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirMedicationKnowledgeMedicineClassificationList.SetItemByIndex(index: Integer; value: TFhirMedicationKnowledgeMedicineClassification);
begin
  assert(value is TFhirMedicationKnowledgeMedicineClassification);
  FhirMedicationKnowledgeMedicineClassifications[index] := value;
end;

procedure TFhirMedicationKnowledgeMedicineClassificationList.SetItemN(index: Integer; value: TFhirMedicationKnowledgeMedicineClassification);
begin
  assert(value is TFhirMedicationKnowledgeMedicineClassification);
  ObjectByIndex[index] := value;
end;

{ TFhirMedicationKnowledgePackaging }

constructor TFhirMedicationKnowledgePackaging.Create;
begin
  inherited;
end;

destructor TFhirMedicationKnowledgePackaging.Destroy;
begin
  FCostList.Free;
  FPackagedProduct.free;
  inherited;
end;

procedure TFhirMedicationKnowledgePackaging.Assign(oSource : TFslObject);
begin
  inherited;
  if (TFhirMedicationKnowledgePackaging(oSource).FCostList = nil) then
  begin
    FCostList.free;
    FCostList := nil;
  end
  else
  begin
    if FCostList = nil then
      FCostList := TFhirMedicationKnowledgeCostList.Create;
    FCostList.Assign(TFhirMedicationKnowledgePackaging(oSource).FCostList);
  end;
  packagedProduct := TFhirMedicationKnowledgePackaging(oSource).packagedProduct.Clone;
end;

procedure TFhirMedicationKnowledgePackaging.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'cost') Then
    list.addAll(self, 'cost', FCostList);
  if (child_name = 'packagedProduct') Then
     list.add(self.link, 'packagedProduct', FPackagedProduct.Link);
end;

procedure TFhirMedicationKnowledgePackaging.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'cost', '', true, TFhirMedicationKnowledgeCost, FCostList.Link));
  oList.add(TFHIRProperty.create(self, 'packagedProduct', 'Reference', false, TFhirReference, FPackagedProduct.Link));
end;

function TFhirMedicationKnowledgePackaging.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'cost') then
  begin
    CostList.add(propValue as TFhirMedicationKnowledgeCost);
    result := propValue;
  end
  else if (propName = 'packagedProduct') then
  begin
    PackagedProduct := propValue as TFhirReference;
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirMedicationKnowledgePackaging.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'cost') then CostList.insertItem(index, propValue as TFhirMedicationKnowledgeCost)
  else inherited;
end;

function TFhirMedicationKnowledgePackaging.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'cost') then result := CostList.new()
  else if (propName = 'packagedProduct') then result := TFhirReference.create()
  else result := inherited createPropertyValue(propName);
end;

function TFhirMedicationKnowledgePackaging.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'cost') then result := ''
  else if (propName = 'packagedProduct') then result := 'Reference'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirMedicationKnowledgePackaging.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'cost') then deletePropertyValue('cost', CostList, value)
  else if (propName = 'packagedProduct') then PackagedProductElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirMedicationKnowledgePackaging.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'cost') then replacePropertyValue('cost', CostList, existing, new)
  else if (propName = 'packagedProduct') then PackagedProductElement := new as TFhirReference
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirMedicationKnowledgePackaging.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'cost') then CostList.move(source, destination)
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirMedicationKnowledgePackaging.fhirType : string;
begin
  result := 'MedicationKnowledge.packaging';
end;

function TFhirMedicationKnowledgePackaging.Link : TFhirMedicationKnowledgePackaging;
begin
  result := TFhirMedicationKnowledgePackaging(inherited Link);
end;

function TFhirMedicationKnowledgePackaging.Clone : TFhirMedicationKnowledgePackaging;
begin
  result := TFhirMedicationKnowledgePackaging(inherited Clone);
end;

function TFhirMedicationKnowledgePackaging.equals(other : TObject) : boolean; 
var
  o : TFhirMedicationKnowledgePackaging;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirMedicationKnowledgePackaging)) then
    result := false
  else
  begin
    o := TFhirMedicationKnowledgePackaging(other);
    result := compareDeep(costList, o.costList, true) and compareDeep(packagedProductElement, o.packagedProductElement, true);
  end;
end;

function TFhirMedicationKnowledgePackaging.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FcostList) and isEmptyProp(FPackagedProduct);
end;

procedure TFhirMedicationKnowledgePackaging.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('cost');
  fields.add('packagedProduct');
end;

function TFhirMedicationKnowledgePackaging.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
  inc(result, FCostList.sizeInBytes(magic));
end;

function TFhirMedicationKnowledgePackaging.GetCostList : TFhirMedicationKnowledgeCostList;
begin
  if FCostList = nil then
    FCostList := TFhirMedicationKnowledgeCostList.Create;
  result := FCostList;
end;

function TFhirMedicationKnowledgePackaging.GetHasCostList : boolean;
begin
  result := (FCostList <> nil) and (FCostList.count > 0);
end;

procedure TFhirMedicationKnowledgePackaging.SetPackagedProduct(value : TFhirReference);
begin
  FPackagedProduct.free;
  FPackagedProduct := value;
end;

{ TFhirMedicationKnowledgePackagingListEnumerator }

constructor TFhirMedicationKnowledgePackagingListEnumerator.Create(list : TFhirMedicationKnowledgePackagingList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirMedicationKnowledgePackagingListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirMedicationKnowledgePackagingListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirMedicationKnowledgePackagingListEnumerator.GetCurrent : TFhirMedicationKnowledgePackaging;
begin
  Result := FList[FIndex];
end;

function TFhirMedicationKnowledgePackagingListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirMedicationKnowledgePackagingList }

function TFhirMedicationKnowledgePackagingList.AddItem(value: TFhirMedicationKnowledgePackaging): TFhirMedicationKnowledgePackaging;
begin
  assert(value.ClassName = 'TFhirMedicationKnowledgePackaging', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirMedicationKnowledgePackaging');
  add(value);
  result := value;
end;

function TFhirMedicationKnowledgePackagingList.Append: TFhirMedicationKnowledgePackaging;
begin
  result := TFhirMedicationKnowledgePackaging.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirMedicationKnowledgePackagingList.ClearItems;
begin
  Clear;
end;

function TFhirMedicationKnowledgePackagingList.GetEnumerator : TFhirMedicationKnowledgePackagingListEnumerator;
begin
  result := TFhirMedicationKnowledgePackagingListEnumerator.Create(self.link);
end;

function TFhirMedicationKnowledgePackagingList.Clone: TFhirMedicationKnowledgePackagingList;
begin
  result := TFhirMedicationKnowledgePackagingList(inherited Clone);
end;

function TFhirMedicationKnowledgePackagingList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirMedicationKnowledgePackagingList.GetItemN(index: Integer): TFhirMedicationKnowledgePackaging;
begin
  result := TFhirMedicationKnowledgePackaging(ObjectByIndex[index]);
end;

function TFhirMedicationKnowledgePackagingList.ItemClass: TFslObjectClass;
begin
  result := TFhirMedicationKnowledgePackaging;
end;
function TFhirMedicationKnowledgePackagingList.IndexOf(value: TFhirMedicationKnowledgePackaging): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirMedicationKnowledgePackagingList.Insert(index: Integer): TFhirMedicationKnowledgePackaging;
begin
  result := TFhirMedicationKnowledgePackaging.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirMedicationKnowledgePackagingList.InsertItem(index: Integer; value: TFhirMedicationKnowledgePackaging);
begin
  assert(value is TFhirMedicationKnowledgePackaging);
  Inherited Insert(index, value);
end;

function TFhirMedicationKnowledgePackagingList.Item(index: Integer): TFhirMedicationKnowledgePackaging;
begin
  result := TFhirMedicationKnowledgePackaging(ObjectByIndex[index]);
end;

function TFhirMedicationKnowledgePackagingList.Link: TFhirMedicationKnowledgePackagingList;
begin
  result := TFhirMedicationKnowledgePackagingList(inherited Link);
end;

procedure TFhirMedicationKnowledgePackagingList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirMedicationKnowledgePackagingList.SetItemByIndex(index: Integer; value: TFhirMedicationKnowledgePackaging);
begin
  assert(value is TFhirMedicationKnowledgePackaging);
  FhirMedicationKnowledgePackagings[index] := value;
end;

procedure TFhirMedicationKnowledgePackagingList.SetItemN(index: Integer; value: TFhirMedicationKnowledgePackaging);
begin
  assert(value is TFhirMedicationKnowledgePackaging);
  ObjectByIndex[index] := value;
end;

{ TFhirMedicationKnowledgeStorageGuideline }

constructor TFhirMedicationKnowledgeStorageGuideline.Create;
begin
  inherited;
end;

destructor TFhirMedicationKnowledgeStorageGuideline.Destroy;
begin
  FReference.free;
  FNoteList.Free;
  FStabilityDuration.free;
  FEnvironmentalSettingList.Free;
  inherited;
end;

procedure TFhirMedicationKnowledgeStorageGuideline.Assign(oSource : TFslObject);
begin
  inherited;
  referenceElement := TFhirMedicationKnowledgeStorageGuideline(oSource).referenceElement.Clone;
  if (TFhirMedicationKnowledgeStorageGuideline(oSource).FNoteList = nil) then
  begin
    FNoteList.free;
    FNoteList := nil;
  end
  else
  begin
    if FNoteList = nil then
      FNoteList := TFhirAnnotationList.Create;
    FNoteList.Assign(TFhirMedicationKnowledgeStorageGuideline(oSource).FNoteList);
  end;
  stabilityDuration := TFhirMedicationKnowledgeStorageGuideline(oSource).stabilityDuration.Clone;
  if (TFhirMedicationKnowledgeStorageGuideline(oSource).FEnvironmentalSettingList = nil) then
  begin
    FEnvironmentalSettingList.free;
    FEnvironmentalSettingList := nil;
  end
  else
  begin
    if FEnvironmentalSettingList = nil then
      FEnvironmentalSettingList := TFhirMedicationKnowledgeStorageGuidelineEnvironmentalSettingList.Create;
    FEnvironmentalSettingList.Assign(TFhirMedicationKnowledgeStorageGuideline(oSource).FEnvironmentalSettingList);
  end;
end;

procedure TFhirMedicationKnowledgeStorageGuideline.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'reference') Then
     list.add(self.link, 'reference', FReference.Link);
  if (child_name = 'note') Then
    list.addAll(self, 'note', FNoteList);
  if (child_name = 'stabilityDuration') Then
     list.add(self.link, 'stabilityDuration', FStabilityDuration.Link);
  if (child_name = 'environmentalSetting') Then
    list.addAll(self, 'environmentalSetting', FEnvironmentalSettingList);
end;

procedure TFhirMedicationKnowledgeStorageGuideline.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'reference', 'uri', false, TFhirUri, FReference.Link));
  oList.add(TFHIRProperty.create(self, 'note', 'Annotation', true, TFhirAnnotation, FNoteList.Link));
  oList.add(TFHIRProperty.create(self, 'stabilityDuration', 'Duration', false, TFhirDuration, FStabilityDuration.Link));
  oList.add(TFHIRProperty.create(self, 'environmentalSetting', 'BackboneElement', true, TFhirMedicationKnowledgeStorageGuidelineEnvironmentalSetting, FEnvironmentalSettingList.Link));
end;

function TFhirMedicationKnowledgeStorageGuideline.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'reference') then
  begin
    ReferenceElement := asUri(propValue);
    result := propValue;
  end
  else if (propName = 'note') then
  begin
    NoteList.add(propValue as TFhirAnnotation);
    result := propValue;
  end
  else if (propName = 'stabilityDuration') then
  begin
    StabilityDuration := propValue as TFhirDuration;
    result := propValue;
  end
  else if (propName = 'environmentalSetting') then
  begin
    EnvironmentalSettingList.add(propValue as TFhirMedicationKnowledgeStorageGuidelineEnvironmentalSetting);
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirMedicationKnowledgeStorageGuideline.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'note') then NoteList.insertItem(index, propValue as TFhirAnnotation)
  else if (propName = 'environmentalSetting') then EnvironmentalSettingList.insertItem(index, propValue as TFhirMedicationKnowledgeStorageGuidelineEnvironmentalSetting)
  else inherited;
end;

function TFhirMedicationKnowledgeStorageGuideline.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'reference') then result := TFhirUri.create()
  else if (propName = 'note') then result := NoteList.new()
  else if (propName = 'stabilityDuration') then result := TFhirDuration.create()
  else if (propName = 'environmentalSetting') then result := EnvironmentalSettingList.new()
  else result := inherited createPropertyValue(propName);
end;

function TFhirMedicationKnowledgeStorageGuideline.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'reference') then result := 'uri'
  else if (propName = 'note') then result := 'Annotation'
  else if (propName = 'stabilityDuration') then result := 'Duration'
  else if (propName = 'environmentalSetting') then result := 'BackboneElement'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirMedicationKnowledgeStorageGuideline.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'reference') then ReferenceElement := nil
  else if (propName = 'note') then deletePropertyValue('note', NoteList, value)
  else if (propName = 'stabilityDuration') then StabilityDurationElement := nil
  else if (propName = 'environmentalSetting') then deletePropertyValue('environmentalSetting', EnvironmentalSettingList, value)
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirMedicationKnowledgeStorageGuideline.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'reference') then ReferenceElement := asUri(new)
  else if (propName = 'note') then replacePropertyValue('note', NoteList, existing, new)
  else if (propName = 'stabilityDuration') then StabilityDurationElement := new as TFhirDuration
  else if (propName = 'environmentalSetting') then replacePropertyValue('environmentalSetting', EnvironmentalSettingList, existing, new)
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirMedicationKnowledgeStorageGuideline.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'note') then NoteList.move(source, destination)
  else if (propName = 'environmentalSetting') then EnvironmentalSettingList.move(source, destination)
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirMedicationKnowledgeStorageGuideline.fhirType : string;
begin
  result := 'MedicationKnowledge.storageGuideline';
end;

function TFhirMedicationKnowledgeStorageGuideline.Link : TFhirMedicationKnowledgeStorageGuideline;
begin
  result := TFhirMedicationKnowledgeStorageGuideline(inherited Link);
end;

function TFhirMedicationKnowledgeStorageGuideline.Clone : TFhirMedicationKnowledgeStorageGuideline;
begin
  result := TFhirMedicationKnowledgeStorageGuideline(inherited Clone);
end;

function TFhirMedicationKnowledgeStorageGuideline.equals(other : TObject) : boolean; 
var
  o : TFhirMedicationKnowledgeStorageGuideline;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirMedicationKnowledgeStorageGuideline)) then
    result := false
  else
  begin
    o := TFhirMedicationKnowledgeStorageGuideline(other);
    result := compareDeep(referenceElement, o.referenceElement, true) and compareDeep(noteList, o.noteList, true) and 
      compareDeep(stabilityDurationElement, o.stabilityDurationElement, true) and compareDeep(environmentalSettingList, o.environmentalSettingList, true);
  end;
end;

function TFhirMedicationKnowledgeStorageGuideline.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FReference) and isEmptyProp(FnoteList) and isEmptyProp(FStabilityDuration) and isEmptyProp(FenvironmentalSettingList);
end;

procedure TFhirMedicationKnowledgeStorageGuideline.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('reference');
  fields.add('note');
  fields.add('stabilityDuration');
  fields.add('environmentalSetting');
end;

function TFhirMedicationKnowledgeStorageGuideline.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
  inc(result, FNoteList.sizeInBytes(magic));
  inc(result, FEnvironmentalSettingList.sizeInBytes(magic));
end;

procedure TFhirMedicationKnowledgeStorageGuideline.SetReference(value : TFhirUri);
begin
  FReference.free;
  FReference := value;
end;

function TFhirMedicationKnowledgeStorageGuideline.GetReferenceST : String;
begin
  if FReference = nil then
    result := ''
  else
    result := FReference.value;
end;

procedure TFhirMedicationKnowledgeStorageGuideline.SetReferenceST(value : String);
begin
  if value <> '' then
  begin
    if FReference = nil then
      FReference := TFhirUri.create;
    FReference.value := value
  end
  else if FReference <> nil then
    FReference.value := '';
end;

function TFhirMedicationKnowledgeStorageGuideline.GetNoteList : TFhirAnnotationList;
begin
  if FNoteList = nil then
    FNoteList := TFhirAnnotationList.Create;
  result := FNoteList;
end;

function TFhirMedicationKnowledgeStorageGuideline.GetHasNoteList : boolean;
begin
  result := (FNoteList <> nil) and (FNoteList.count > 0);
end;

procedure TFhirMedicationKnowledgeStorageGuideline.SetStabilityDuration(value : TFhirDuration);
begin
  FStabilityDuration.free;
  FStabilityDuration := value;
end;

function TFhirMedicationKnowledgeStorageGuideline.GetEnvironmentalSettingList : TFhirMedicationKnowledgeStorageGuidelineEnvironmentalSettingList;
begin
  if FEnvironmentalSettingList = nil then
    FEnvironmentalSettingList := TFhirMedicationKnowledgeStorageGuidelineEnvironmentalSettingList.Create;
  result := FEnvironmentalSettingList;
end;

function TFhirMedicationKnowledgeStorageGuideline.GetHasEnvironmentalSettingList : boolean;
begin
  result := (FEnvironmentalSettingList <> nil) and (FEnvironmentalSettingList.count > 0);
end;

{ TFhirMedicationKnowledgeStorageGuidelineListEnumerator }

constructor TFhirMedicationKnowledgeStorageGuidelineListEnumerator.Create(list : TFhirMedicationKnowledgeStorageGuidelineList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirMedicationKnowledgeStorageGuidelineListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirMedicationKnowledgeStorageGuidelineListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirMedicationKnowledgeStorageGuidelineListEnumerator.GetCurrent : TFhirMedicationKnowledgeStorageGuideline;
begin
  Result := FList[FIndex];
end;

function TFhirMedicationKnowledgeStorageGuidelineListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirMedicationKnowledgeStorageGuidelineList }

function TFhirMedicationKnowledgeStorageGuidelineList.AddItem(value: TFhirMedicationKnowledgeStorageGuideline): TFhirMedicationKnowledgeStorageGuideline;
begin
  assert(value.ClassName = 'TFhirMedicationKnowledgeStorageGuideline', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirMedicationKnowledgeStorageGuideline');
  add(value);
  result := value;
end;

function TFhirMedicationKnowledgeStorageGuidelineList.Append: TFhirMedicationKnowledgeStorageGuideline;
begin
  result := TFhirMedicationKnowledgeStorageGuideline.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirMedicationKnowledgeStorageGuidelineList.ClearItems;
begin
  Clear;
end;

function TFhirMedicationKnowledgeStorageGuidelineList.GetEnumerator : TFhirMedicationKnowledgeStorageGuidelineListEnumerator;
begin
  result := TFhirMedicationKnowledgeStorageGuidelineListEnumerator.Create(self.link);
end;

function TFhirMedicationKnowledgeStorageGuidelineList.Clone: TFhirMedicationKnowledgeStorageGuidelineList;
begin
  result := TFhirMedicationKnowledgeStorageGuidelineList(inherited Clone);
end;

function TFhirMedicationKnowledgeStorageGuidelineList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirMedicationKnowledgeStorageGuidelineList.GetItemN(index: Integer): TFhirMedicationKnowledgeStorageGuideline;
begin
  result := TFhirMedicationKnowledgeStorageGuideline(ObjectByIndex[index]);
end;

function TFhirMedicationKnowledgeStorageGuidelineList.ItemClass: TFslObjectClass;
begin
  result := TFhirMedicationKnowledgeStorageGuideline;
end;
function TFhirMedicationKnowledgeStorageGuidelineList.IndexOf(value: TFhirMedicationKnowledgeStorageGuideline): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirMedicationKnowledgeStorageGuidelineList.Insert(index: Integer): TFhirMedicationKnowledgeStorageGuideline;
begin
  result := TFhirMedicationKnowledgeStorageGuideline.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirMedicationKnowledgeStorageGuidelineList.InsertItem(index: Integer; value: TFhirMedicationKnowledgeStorageGuideline);
begin
  assert(value is TFhirMedicationKnowledgeStorageGuideline);
  Inherited Insert(index, value);
end;

function TFhirMedicationKnowledgeStorageGuidelineList.Item(index: Integer): TFhirMedicationKnowledgeStorageGuideline;
begin
  result := TFhirMedicationKnowledgeStorageGuideline(ObjectByIndex[index]);
end;

function TFhirMedicationKnowledgeStorageGuidelineList.Link: TFhirMedicationKnowledgeStorageGuidelineList;
begin
  result := TFhirMedicationKnowledgeStorageGuidelineList(inherited Link);
end;

procedure TFhirMedicationKnowledgeStorageGuidelineList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirMedicationKnowledgeStorageGuidelineList.SetItemByIndex(index: Integer; value: TFhirMedicationKnowledgeStorageGuideline);
begin
  assert(value is TFhirMedicationKnowledgeStorageGuideline);
  FhirMedicationKnowledgeStorageGuidelines[index] := value;
end;

procedure TFhirMedicationKnowledgeStorageGuidelineList.SetItemN(index: Integer; value: TFhirMedicationKnowledgeStorageGuideline);
begin
  assert(value is TFhirMedicationKnowledgeStorageGuideline);
  ObjectByIndex[index] := value;
end;

{ TFhirMedicationKnowledgeStorageGuidelineEnvironmentalSetting }

constructor TFhirMedicationKnowledgeStorageGuidelineEnvironmentalSetting.Create;
begin
  inherited;
end;

destructor TFhirMedicationKnowledgeStorageGuidelineEnvironmentalSetting.Destroy;
begin
  FType_.free;
  FValue.free;
  inherited;
end;

procedure TFhirMedicationKnowledgeStorageGuidelineEnvironmentalSetting.Assign(oSource : TFslObject);
begin
  inherited;
  type_ := TFhirMedicationKnowledgeStorageGuidelineEnvironmentalSetting(oSource).type_.Clone;
  value := TFhirMedicationKnowledgeStorageGuidelineEnvironmentalSetting(oSource).value.Clone;
end;

procedure TFhirMedicationKnowledgeStorageGuidelineEnvironmentalSetting.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'type') Then
     list.add(self.link, 'type', FType_.Link);
  if (child_name = 'value[x]') or (child_name = 'value') Then
     list.add(self.link, 'value[x]', FValue.Link);
end;

procedure TFhirMedicationKnowledgeStorageGuidelineEnvironmentalSetting.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'type', 'CodeableConcept', false, TFhirCodeableConcept, FType_.Link));
  oList.add(TFHIRProperty.create(self, 'value[x]', 'Quantity|Range|CodeableConcept', false, TFhirDataType, FValue.Link));
end;

function TFhirMedicationKnowledgeStorageGuidelineEnvironmentalSetting.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'type') then
  begin
    Type_ := propValue as TFhirCodeableConcept;
    result := propValue;
  end
  else if (isMatchingName(propName, 'value', ['Quantity', 'Range', 'CodeableConcept'])) then
  begin
    Value := propValue as TFhirDataType;
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirMedicationKnowledgeStorageGuidelineEnvironmentalSetting.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirMedicationKnowledgeStorageGuidelineEnvironmentalSetting.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'type') then result := TFhirCodeableConcept.create()
  else if (isMatchingName(propName, 'value', ['Quantity', 'Range', 'CodeableConcept'])) then raise EFHIRException.create('Cannot make property Value')
  else result := inherited createPropertyValue(propName);
end;

function TFhirMedicationKnowledgeStorageGuidelineEnvironmentalSetting.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'type') then result := 'CodeableConcept'
  else if (propName = 'value[x]') then result := 'Quantity|Range|CodeableConcept'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirMedicationKnowledgeStorageGuidelineEnvironmentalSetting.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'type') then Type_Element := nil
  else if (isMatchingName(propName, 'value', ['Quantity', 'Range', 'CodeableConcept'])) then ValueElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirMedicationKnowledgeStorageGuidelineEnvironmentalSetting.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'type') then Type_Element := new as TFhirCodeableConcept
  else if (isMatchingName(propName, 'value', ['Quantity', 'Range', 'CodeableConcept'])) then ValueElement := new as TFhirDataType
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirMedicationKnowledgeStorageGuidelineEnvironmentalSetting.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirMedicationKnowledgeStorageGuidelineEnvironmentalSetting.fhirType : string;
begin
  result := 'MedicationKnowledge.storageGuideline.environmentalSetting';
end;

function TFhirMedicationKnowledgeStorageGuidelineEnvironmentalSetting.Link : TFhirMedicationKnowledgeStorageGuidelineEnvironmentalSetting;
begin
  result := TFhirMedicationKnowledgeStorageGuidelineEnvironmentalSetting(inherited Link);
end;

function TFhirMedicationKnowledgeStorageGuidelineEnvironmentalSetting.Clone : TFhirMedicationKnowledgeStorageGuidelineEnvironmentalSetting;
begin
  result := TFhirMedicationKnowledgeStorageGuidelineEnvironmentalSetting(inherited Clone);
end;

function TFhirMedicationKnowledgeStorageGuidelineEnvironmentalSetting.equals(other : TObject) : boolean; 
var
  o : TFhirMedicationKnowledgeStorageGuidelineEnvironmentalSetting;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirMedicationKnowledgeStorageGuidelineEnvironmentalSetting)) then
    result := false
  else
  begin
    o := TFhirMedicationKnowledgeStorageGuidelineEnvironmentalSetting(other);
    result := compareDeep(type_Element, o.type_Element, true) and compareDeep(valueElement, o.valueElement, true);
  end;
end;

function TFhirMedicationKnowledgeStorageGuidelineEnvironmentalSetting.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FType_) and isEmptyProp(FValue);
end;

procedure TFhirMedicationKnowledgeStorageGuidelineEnvironmentalSetting.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('type');
  fields.add('value[x]');
end;

function TFhirMedicationKnowledgeStorageGuidelineEnvironmentalSetting.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
end;

procedure TFhirMedicationKnowledgeStorageGuidelineEnvironmentalSetting.SetType_(value : TFhirCodeableConcept);
begin
  FType_.free;
  FType_ := value;
end;

procedure TFhirMedicationKnowledgeStorageGuidelineEnvironmentalSetting.SetValue(value : TFhirDataType);
begin
  FValue.free;
  FValue := value;
end;

{ TFhirMedicationKnowledgeStorageGuidelineEnvironmentalSettingListEnumerator }

constructor TFhirMedicationKnowledgeStorageGuidelineEnvironmentalSettingListEnumerator.Create(list : TFhirMedicationKnowledgeStorageGuidelineEnvironmentalSettingList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirMedicationKnowledgeStorageGuidelineEnvironmentalSettingListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirMedicationKnowledgeStorageGuidelineEnvironmentalSettingListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirMedicationKnowledgeStorageGuidelineEnvironmentalSettingListEnumerator.GetCurrent : TFhirMedicationKnowledgeStorageGuidelineEnvironmentalSetting;
begin
  Result := FList[FIndex];
end;

function TFhirMedicationKnowledgeStorageGuidelineEnvironmentalSettingListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirMedicationKnowledgeStorageGuidelineEnvironmentalSettingList }

function TFhirMedicationKnowledgeStorageGuidelineEnvironmentalSettingList.AddItem(value: TFhirMedicationKnowledgeStorageGuidelineEnvironmentalSetting): TFhirMedicationKnowledgeStorageGuidelineEnvironmentalSetting;
begin
  assert(value.ClassName = 'TFhirMedicationKnowledgeStorageGuidelineEnvironmentalSetting', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirMedicationKnowledgeStorageGuidelineEnvironmentalSetting');
  add(value);
  result := value;
end;

function TFhirMedicationKnowledgeStorageGuidelineEnvironmentalSettingList.Append: TFhirMedicationKnowledgeStorageGuidelineEnvironmentalSetting;
begin
  result := TFhirMedicationKnowledgeStorageGuidelineEnvironmentalSetting.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirMedicationKnowledgeStorageGuidelineEnvironmentalSettingList.ClearItems;
begin
  Clear;
end;

function TFhirMedicationKnowledgeStorageGuidelineEnvironmentalSettingList.GetEnumerator : TFhirMedicationKnowledgeStorageGuidelineEnvironmentalSettingListEnumerator;
begin
  result := TFhirMedicationKnowledgeStorageGuidelineEnvironmentalSettingListEnumerator.Create(self.link);
end;

function TFhirMedicationKnowledgeStorageGuidelineEnvironmentalSettingList.Clone: TFhirMedicationKnowledgeStorageGuidelineEnvironmentalSettingList;
begin
  result := TFhirMedicationKnowledgeStorageGuidelineEnvironmentalSettingList(inherited Clone);
end;

function TFhirMedicationKnowledgeStorageGuidelineEnvironmentalSettingList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirMedicationKnowledgeStorageGuidelineEnvironmentalSettingList.GetItemN(index: Integer): TFhirMedicationKnowledgeStorageGuidelineEnvironmentalSetting;
begin
  result := TFhirMedicationKnowledgeStorageGuidelineEnvironmentalSetting(ObjectByIndex[index]);
end;

function TFhirMedicationKnowledgeStorageGuidelineEnvironmentalSettingList.ItemClass: TFslObjectClass;
begin
  result := TFhirMedicationKnowledgeStorageGuidelineEnvironmentalSetting;
end;
function TFhirMedicationKnowledgeStorageGuidelineEnvironmentalSettingList.IndexOf(value: TFhirMedicationKnowledgeStorageGuidelineEnvironmentalSetting): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirMedicationKnowledgeStorageGuidelineEnvironmentalSettingList.Insert(index: Integer): TFhirMedicationKnowledgeStorageGuidelineEnvironmentalSetting;
begin
  result := TFhirMedicationKnowledgeStorageGuidelineEnvironmentalSetting.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirMedicationKnowledgeStorageGuidelineEnvironmentalSettingList.InsertItem(index: Integer; value: TFhirMedicationKnowledgeStorageGuidelineEnvironmentalSetting);
begin
  assert(value is TFhirMedicationKnowledgeStorageGuidelineEnvironmentalSetting);
  Inherited Insert(index, value);
end;

function TFhirMedicationKnowledgeStorageGuidelineEnvironmentalSettingList.Item(index: Integer): TFhirMedicationKnowledgeStorageGuidelineEnvironmentalSetting;
begin
  result := TFhirMedicationKnowledgeStorageGuidelineEnvironmentalSetting(ObjectByIndex[index]);
end;

function TFhirMedicationKnowledgeStorageGuidelineEnvironmentalSettingList.Link: TFhirMedicationKnowledgeStorageGuidelineEnvironmentalSettingList;
begin
  result := TFhirMedicationKnowledgeStorageGuidelineEnvironmentalSettingList(inherited Link);
end;

procedure TFhirMedicationKnowledgeStorageGuidelineEnvironmentalSettingList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirMedicationKnowledgeStorageGuidelineEnvironmentalSettingList.SetItemByIndex(index: Integer; value: TFhirMedicationKnowledgeStorageGuidelineEnvironmentalSetting);
begin
  assert(value is TFhirMedicationKnowledgeStorageGuidelineEnvironmentalSetting);
  FhirMedicationKnowledgeStorageGuidelineEnvironmentalSettings[index] := value;
end;

procedure TFhirMedicationKnowledgeStorageGuidelineEnvironmentalSettingList.SetItemN(index: Integer; value: TFhirMedicationKnowledgeStorageGuidelineEnvironmentalSetting);
begin
  assert(value is TFhirMedicationKnowledgeStorageGuidelineEnvironmentalSetting);
  ObjectByIndex[index] := value;
end;

{ TFhirMedicationKnowledgeRegulatory }

constructor TFhirMedicationKnowledgeRegulatory.Create;
begin
  inherited;
end;

destructor TFhirMedicationKnowledgeRegulatory.Destroy;
begin
  FRegulatoryAuthority.free;
  FSubstitutionList.Free;
  FScheduleList.Free;
  FMaxDispense.free;
  inherited;
end;

procedure TFhirMedicationKnowledgeRegulatory.Assign(oSource : TFslObject);
begin
  inherited;
  regulatoryAuthority := TFhirMedicationKnowledgeRegulatory(oSource).regulatoryAuthority.Clone;
  if (TFhirMedicationKnowledgeRegulatory(oSource).FSubstitutionList = nil) then
  begin
    FSubstitutionList.free;
    FSubstitutionList := nil;
  end
  else
  begin
    if FSubstitutionList = nil then
      FSubstitutionList := TFhirMedicationKnowledgeRegulatorySubstitutionList.Create;
    FSubstitutionList.Assign(TFhirMedicationKnowledgeRegulatory(oSource).FSubstitutionList);
  end;
  if (TFhirMedicationKnowledgeRegulatory(oSource).FScheduleList = nil) then
  begin
    FScheduleList.free;
    FScheduleList := nil;
  end
  else
  begin
    if FScheduleList = nil then
      FScheduleList := TFhirCodeableConceptList.Create;
    FScheduleList.Assign(TFhirMedicationKnowledgeRegulatory(oSource).FScheduleList);
  end;
  maxDispense := TFhirMedicationKnowledgeRegulatory(oSource).maxDispense.Clone;
end;

procedure TFhirMedicationKnowledgeRegulatory.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'regulatoryAuthority') Then
     list.add(self.link, 'regulatoryAuthority', FRegulatoryAuthority.Link);
  if (child_name = 'substitution') Then
    list.addAll(self, 'substitution', FSubstitutionList);
  if (child_name = 'schedule') Then
    list.addAll(self, 'schedule', FScheduleList);
  if (child_name = 'maxDispense') Then
     list.add(self.link, 'maxDispense', FMaxDispense.Link);
end;

procedure TFhirMedicationKnowledgeRegulatory.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'regulatoryAuthority', 'Reference', false, TFhirReference, FRegulatoryAuthority.Link));
  oList.add(TFHIRProperty.create(self, 'substitution', 'BackboneElement', true, TFhirMedicationKnowledgeRegulatorySubstitution, FSubstitutionList.Link));
  oList.add(TFHIRProperty.create(self, 'schedule', 'CodeableConcept', true, TFhirCodeableConcept, FScheduleList.Link));
  oList.add(TFHIRProperty.create(self, 'maxDispense', 'BackboneElement', false, TFhirMedicationKnowledgeRegulatoryMaxDispense, FMaxDispense.Link));
end;

function TFhirMedicationKnowledgeRegulatory.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'regulatoryAuthority') then
  begin
    RegulatoryAuthority := propValue as TFhirReference;
    result := propValue;
  end
  else if (propName = 'substitution') then
  begin
    SubstitutionList.add(propValue as TFhirMedicationKnowledgeRegulatorySubstitution);
    result := propValue;
  end
  else if (propName = 'schedule') then
  begin
    ScheduleList.add(propValue as TFhirCodeableConcept);
    result := propValue;
  end
  else if (propName = 'maxDispense') then
  begin
    MaxDispense := propValue as TFhirMedicationKnowledgeRegulatoryMaxDispense;
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirMedicationKnowledgeRegulatory.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'substitution') then SubstitutionList.insertItem(index, propValue as TFhirMedicationKnowledgeRegulatorySubstitution)
  else if (propName = 'schedule') then ScheduleList.insertItem(index, propValue as TFhirCodeableConcept)
  else inherited;
end;

function TFhirMedicationKnowledgeRegulatory.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'regulatoryAuthority') then result := TFhirReference.create()
  else if (propName = 'substitution') then result := SubstitutionList.new()
  else if (propName = 'schedule') then result := ScheduleList.new()
  else if (propName = 'maxDispense') then result := TFhirMedicationKnowledgeRegulatoryMaxDispense.create()
  else result := inherited createPropertyValue(propName);
end;

function TFhirMedicationKnowledgeRegulatory.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'regulatoryAuthority') then result := 'Reference'
  else if (propName = 'substitution') then result := 'BackboneElement'
  else if (propName = 'schedule') then result := 'CodeableConcept'
  else if (propName = 'maxDispense') then result := 'BackboneElement'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirMedicationKnowledgeRegulatory.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'regulatoryAuthority') then RegulatoryAuthorityElement := nil
  else if (propName = 'substitution') then deletePropertyValue('substitution', SubstitutionList, value)
  else if (propName = 'schedule') then deletePropertyValue('schedule', ScheduleList, value)
  else if (propName = 'maxDispense') then MaxDispenseElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirMedicationKnowledgeRegulatory.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'regulatoryAuthority') then RegulatoryAuthorityElement := new as TFhirReference
  else if (propName = 'substitution') then replacePropertyValue('substitution', SubstitutionList, existing, new)
  else if (propName = 'schedule') then replacePropertyValue('schedule', ScheduleList, existing, new)
  else if (propName = 'maxDispense') then MaxDispenseElement := new as TFhirMedicationKnowledgeRegulatoryMaxDispense
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirMedicationKnowledgeRegulatory.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'substitution') then SubstitutionList.move(source, destination)
  else if (propName = 'schedule') then ScheduleList.move(source, destination)
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirMedicationKnowledgeRegulatory.fhirType : string;
begin
  result := 'MedicationKnowledge.regulatory';
end;

function TFhirMedicationKnowledgeRegulatory.Link : TFhirMedicationKnowledgeRegulatory;
begin
  result := TFhirMedicationKnowledgeRegulatory(inherited Link);
end;

function TFhirMedicationKnowledgeRegulatory.Clone : TFhirMedicationKnowledgeRegulatory;
begin
  result := TFhirMedicationKnowledgeRegulatory(inherited Clone);
end;

function TFhirMedicationKnowledgeRegulatory.equals(other : TObject) : boolean; 
var
  o : TFhirMedicationKnowledgeRegulatory;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirMedicationKnowledgeRegulatory)) then
    result := false
  else
  begin
    o := TFhirMedicationKnowledgeRegulatory(other);
    result := compareDeep(regulatoryAuthorityElement, o.regulatoryAuthorityElement, true) and 
      compareDeep(substitutionList, o.substitutionList, true) and compareDeep(scheduleList, o.scheduleList, true) and 
      compareDeep(maxDispenseElement, o.maxDispenseElement, true);
  end;
end;

function TFhirMedicationKnowledgeRegulatory.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FRegulatoryAuthority) and isEmptyProp(FsubstitutionList) and isEmptyProp(FscheduleList) and isEmptyProp(FMaxDispense);
end;

procedure TFhirMedicationKnowledgeRegulatory.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('regulatoryAuthority');
  fields.add('substitution');
  fields.add('schedule');
  fields.add('maxDispense');
end;

function TFhirMedicationKnowledgeRegulatory.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
  inc(result, FSubstitutionList.sizeInBytes(magic));
  inc(result, FScheduleList.sizeInBytes(magic));
end;

procedure TFhirMedicationKnowledgeRegulatory.SetRegulatoryAuthority(value : TFhirReference);
begin
  FRegulatoryAuthority.free;
  FRegulatoryAuthority := value;
end;

function TFhirMedicationKnowledgeRegulatory.GetSubstitutionList : TFhirMedicationKnowledgeRegulatorySubstitutionList;
begin
  if FSubstitutionList = nil then
    FSubstitutionList := TFhirMedicationKnowledgeRegulatorySubstitutionList.Create;
  result := FSubstitutionList;
end;

function TFhirMedicationKnowledgeRegulatory.GetHasSubstitutionList : boolean;
begin
  result := (FSubstitutionList <> nil) and (FSubstitutionList.count > 0);
end;

function TFhirMedicationKnowledgeRegulatory.GetScheduleList : TFhirCodeableConceptList;
begin
  if FScheduleList = nil then
    FScheduleList := TFhirCodeableConceptList.Create;
  result := FScheduleList;
end;

function TFhirMedicationKnowledgeRegulatory.GetHasScheduleList : boolean;
begin
  result := (FScheduleList <> nil) and (FScheduleList.count > 0);
end;

procedure TFhirMedicationKnowledgeRegulatory.SetMaxDispense(value : TFhirMedicationKnowledgeRegulatoryMaxDispense);
begin
  FMaxDispense.free;
  FMaxDispense := value;
end;

{ TFhirMedicationKnowledgeRegulatoryListEnumerator }

constructor TFhirMedicationKnowledgeRegulatoryListEnumerator.Create(list : TFhirMedicationKnowledgeRegulatoryList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirMedicationKnowledgeRegulatoryListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirMedicationKnowledgeRegulatoryListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirMedicationKnowledgeRegulatoryListEnumerator.GetCurrent : TFhirMedicationKnowledgeRegulatory;
begin
  Result := FList[FIndex];
end;

function TFhirMedicationKnowledgeRegulatoryListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirMedicationKnowledgeRegulatoryList }

function TFhirMedicationKnowledgeRegulatoryList.AddItem(value: TFhirMedicationKnowledgeRegulatory): TFhirMedicationKnowledgeRegulatory;
begin
  assert(value.ClassName = 'TFhirMedicationKnowledgeRegulatory', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirMedicationKnowledgeRegulatory');
  add(value);
  result := value;
end;

function TFhirMedicationKnowledgeRegulatoryList.Append: TFhirMedicationKnowledgeRegulatory;
begin
  result := TFhirMedicationKnowledgeRegulatory.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirMedicationKnowledgeRegulatoryList.ClearItems;
begin
  Clear;
end;

function TFhirMedicationKnowledgeRegulatoryList.GetEnumerator : TFhirMedicationKnowledgeRegulatoryListEnumerator;
begin
  result := TFhirMedicationKnowledgeRegulatoryListEnumerator.Create(self.link);
end;

function TFhirMedicationKnowledgeRegulatoryList.Clone: TFhirMedicationKnowledgeRegulatoryList;
begin
  result := TFhirMedicationKnowledgeRegulatoryList(inherited Clone);
end;

function TFhirMedicationKnowledgeRegulatoryList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirMedicationKnowledgeRegulatoryList.GetItemN(index: Integer): TFhirMedicationKnowledgeRegulatory;
begin
  result := TFhirMedicationKnowledgeRegulatory(ObjectByIndex[index]);
end;

function TFhirMedicationKnowledgeRegulatoryList.ItemClass: TFslObjectClass;
begin
  result := TFhirMedicationKnowledgeRegulatory;
end;
function TFhirMedicationKnowledgeRegulatoryList.IndexOf(value: TFhirMedicationKnowledgeRegulatory): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirMedicationKnowledgeRegulatoryList.Insert(index: Integer): TFhirMedicationKnowledgeRegulatory;
begin
  result := TFhirMedicationKnowledgeRegulatory.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirMedicationKnowledgeRegulatoryList.InsertItem(index: Integer; value: TFhirMedicationKnowledgeRegulatory);
begin
  assert(value is TFhirMedicationKnowledgeRegulatory);
  Inherited Insert(index, value);
end;

function TFhirMedicationKnowledgeRegulatoryList.Item(index: Integer): TFhirMedicationKnowledgeRegulatory;
begin
  result := TFhirMedicationKnowledgeRegulatory(ObjectByIndex[index]);
end;

function TFhirMedicationKnowledgeRegulatoryList.Link: TFhirMedicationKnowledgeRegulatoryList;
begin
  result := TFhirMedicationKnowledgeRegulatoryList(inherited Link);
end;

procedure TFhirMedicationKnowledgeRegulatoryList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirMedicationKnowledgeRegulatoryList.SetItemByIndex(index: Integer; value: TFhirMedicationKnowledgeRegulatory);
begin
  assert(value is TFhirMedicationKnowledgeRegulatory);
  FhirMedicationKnowledgeRegulatories[index] := value;
end;

procedure TFhirMedicationKnowledgeRegulatoryList.SetItemN(index: Integer; value: TFhirMedicationKnowledgeRegulatory);
begin
  assert(value is TFhirMedicationKnowledgeRegulatory);
  ObjectByIndex[index] := value;
end;

{ TFhirMedicationKnowledgeRegulatorySubstitution }

constructor TFhirMedicationKnowledgeRegulatorySubstitution.Create;
begin
  inherited;
end;

destructor TFhirMedicationKnowledgeRegulatorySubstitution.Destroy;
begin
  FType_.free;
  FAllowed.free;
  inherited;
end;

procedure TFhirMedicationKnowledgeRegulatorySubstitution.Assign(oSource : TFslObject);
begin
  inherited;
  type_ := TFhirMedicationKnowledgeRegulatorySubstitution(oSource).type_.Clone;
  allowedElement := TFhirMedicationKnowledgeRegulatorySubstitution(oSource).allowedElement.Clone;
end;

procedure TFhirMedicationKnowledgeRegulatorySubstitution.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'type') Then
     list.add(self.link, 'type', FType_.Link);
  if (child_name = 'allowed') Then
     list.add(self.link, 'allowed', FAllowed.Link);
end;

procedure TFhirMedicationKnowledgeRegulatorySubstitution.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'type', 'CodeableConcept', false, TFhirCodeableConcept, FType_.Link));
  oList.add(TFHIRProperty.create(self, 'allowed', 'boolean', false, TFhirBoolean, FAllowed.Link));
end;

function TFhirMedicationKnowledgeRegulatorySubstitution.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'type') then
  begin
    Type_ := propValue as TFhirCodeableConcept;
    result := propValue;
  end
  else if (propName = 'allowed') then
  begin
    AllowedElement := asBoolean(propValue);
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirMedicationKnowledgeRegulatorySubstitution.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirMedicationKnowledgeRegulatorySubstitution.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'type') then result := TFhirCodeableConcept.create()
  else if (propName = 'allowed') then result := TFhirBoolean.create()
  else result := inherited createPropertyValue(propName);
end;

function TFhirMedicationKnowledgeRegulatorySubstitution.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'type') then result := 'CodeableConcept'
  else if (propName = 'allowed') then result := 'boolean'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirMedicationKnowledgeRegulatorySubstitution.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'type') then Type_Element := nil
  else if (propName = 'allowed') then AllowedElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirMedicationKnowledgeRegulatorySubstitution.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'type') then Type_Element := new as TFhirCodeableConcept
  else if (propName = 'allowed') then AllowedElement := asBoolean(new)
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirMedicationKnowledgeRegulatorySubstitution.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirMedicationKnowledgeRegulatorySubstitution.fhirType : string;
begin
  result := 'MedicationKnowledge.regulatory.substitution';
end;

function TFhirMedicationKnowledgeRegulatorySubstitution.Link : TFhirMedicationKnowledgeRegulatorySubstitution;
begin
  result := TFhirMedicationKnowledgeRegulatorySubstitution(inherited Link);
end;

function TFhirMedicationKnowledgeRegulatorySubstitution.Clone : TFhirMedicationKnowledgeRegulatorySubstitution;
begin
  result := TFhirMedicationKnowledgeRegulatorySubstitution(inherited Clone);
end;

function TFhirMedicationKnowledgeRegulatorySubstitution.equals(other : TObject) : boolean; 
var
  o : TFhirMedicationKnowledgeRegulatorySubstitution;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirMedicationKnowledgeRegulatorySubstitution)) then
    result := false
  else
  begin
    o := TFhirMedicationKnowledgeRegulatorySubstitution(other);
    result := compareDeep(type_Element, o.type_Element, true) and compareDeep(allowedElement, o.allowedElement, true);
  end;
end;

function TFhirMedicationKnowledgeRegulatorySubstitution.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FType_) and isEmptyProp(FAllowed);
end;

procedure TFhirMedicationKnowledgeRegulatorySubstitution.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('type');
  fields.add('allowed');
end;

function TFhirMedicationKnowledgeRegulatorySubstitution.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
end;

procedure TFhirMedicationKnowledgeRegulatorySubstitution.SetType_(value : TFhirCodeableConcept);
begin
  FType_.free;
  FType_ := value;
end;

procedure TFhirMedicationKnowledgeRegulatorySubstitution.SetAllowed(value : TFhirBoolean);
begin
  FAllowed.free;
  FAllowed := value;
end;

function TFhirMedicationKnowledgeRegulatorySubstitution.GetAllowedST : Boolean;
begin
  if FAllowed = nil then
    result := false
  else
    result := FAllowed.value;
end;

procedure TFhirMedicationKnowledgeRegulatorySubstitution.SetAllowedST(value : Boolean);
begin
  if FAllowed = nil then
    FAllowed := TFhirBoolean.create;
  FAllowed.value := value
end;

{ TFhirMedicationKnowledgeRegulatorySubstitutionListEnumerator }

constructor TFhirMedicationKnowledgeRegulatorySubstitutionListEnumerator.Create(list : TFhirMedicationKnowledgeRegulatorySubstitutionList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirMedicationKnowledgeRegulatorySubstitutionListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirMedicationKnowledgeRegulatorySubstitutionListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirMedicationKnowledgeRegulatorySubstitutionListEnumerator.GetCurrent : TFhirMedicationKnowledgeRegulatorySubstitution;
begin
  Result := FList[FIndex];
end;

function TFhirMedicationKnowledgeRegulatorySubstitutionListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirMedicationKnowledgeRegulatorySubstitutionList }

function TFhirMedicationKnowledgeRegulatorySubstitutionList.AddItem(value: TFhirMedicationKnowledgeRegulatorySubstitution): TFhirMedicationKnowledgeRegulatorySubstitution;
begin
  assert(value.ClassName = 'TFhirMedicationKnowledgeRegulatorySubstitution', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirMedicationKnowledgeRegulatorySubstitution');
  add(value);
  result := value;
end;

function TFhirMedicationKnowledgeRegulatorySubstitutionList.Append: TFhirMedicationKnowledgeRegulatorySubstitution;
begin
  result := TFhirMedicationKnowledgeRegulatorySubstitution.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirMedicationKnowledgeRegulatorySubstitutionList.ClearItems;
begin
  Clear;
end;

function TFhirMedicationKnowledgeRegulatorySubstitutionList.GetEnumerator : TFhirMedicationKnowledgeRegulatorySubstitutionListEnumerator;
begin
  result := TFhirMedicationKnowledgeRegulatorySubstitutionListEnumerator.Create(self.link);
end;

function TFhirMedicationKnowledgeRegulatorySubstitutionList.Clone: TFhirMedicationKnowledgeRegulatorySubstitutionList;
begin
  result := TFhirMedicationKnowledgeRegulatorySubstitutionList(inherited Clone);
end;

function TFhirMedicationKnowledgeRegulatorySubstitutionList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirMedicationKnowledgeRegulatorySubstitutionList.GetItemN(index: Integer): TFhirMedicationKnowledgeRegulatorySubstitution;
begin
  result := TFhirMedicationKnowledgeRegulatorySubstitution(ObjectByIndex[index]);
end;

function TFhirMedicationKnowledgeRegulatorySubstitutionList.ItemClass: TFslObjectClass;
begin
  result := TFhirMedicationKnowledgeRegulatorySubstitution;
end;
function TFhirMedicationKnowledgeRegulatorySubstitutionList.IndexOf(value: TFhirMedicationKnowledgeRegulatorySubstitution): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirMedicationKnowledgeRegulatorySubstitutionList.Insert(index: Integer): TFhirMedicationKnowledgeRegulatorySubstitution;
begin
  result := TFhirMedicationKnowledgeRegulatorySubstitution.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirMedicationKnowledgeRegulatorySubstitutionList.InsertItem(index: Integer; value: TFhirMedicationKnowledgeRegulatorySubstitution);
begin
  assert(value is TFhirMedicationKnowledgeRegulatorySubstitution);
  Inherited Insert(index, value);
end;

function TFhirMedicationKnowledgeRegulatorySubstitutionList.Item(index: Integer): TFhirMedicationKnowledgeRegulatorySubstitution;
begin
  result := TFhirMedicationKnowledgeRegulatorySubstitution(ObjectByIndex[index]);
end;

function TFhirMedicationKnowledgeRegulatorySubstitutionList.Link: TFhirMedicationKnowledgeRegulatorySubstitutionList;
begin
  result := TFhirMedicationKnowledgeRegulatorySubstitutionList(inherited Link);
end;

procedure TFhirMedicationKnowledgeRegulatorySubstitutionList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirMedicationKnowledgeRegulatorySubstitutionList.SetItemByIndex(index: Integer; value: TFhirMedicationKnowledgeRegulatorySubstitution);
begin
  assert(value is TFhirMedicationKnowledgeRegulatorySubstitution);
  FhirMedicationKnowledgeRegulatorySubstitutions[index] := value;
end;

procedure TFhirMedicationKnowledgeRegulatorySubstitutionList.SetItemN(index: Integer; value: TFhirMedicationKnowledgeRegulatorySubstitution);
begin
  assert(value is TFhirMedicationKnowledgeRegulatorySubstitution);
  ObjectByIndex[index] := value;
end;

{ TFhirMedicationKnowledgeRegulatoryMaxDispense }

constructor TFhirMedicationKnowledgeRegulatoryMaxDispense.Create;
begin
  inherited;
end;

destructor TFhirMedicationKnowledgeRegulatoryMaxDispense.Destroy;
begin
  FQuantity.free;
  FPeriod.free;
  inherited;
end;

procedure TFhirMedicationKnowledgeRegulatoryMaxDispense.Assign(oSource : TFslObject);
begin
  inherited;
  quantity := TFhirMedicationKnowledgeRegulatoryMaxDispense(oSource).quantity.Clone;
  period := TFhirMedicationKnowledgeRegulatoryMaxDispense(oSource).period.Clone;
end;

procedure TFhirMedicationKnowledgeRegulatoryMaxDispense.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'quantity') Then
     list.add(self.link, 'quantity', FQuantity.Link);
  if (child_name = 'period') Then
     list.add(self.link, 'period', FPeriod.Link);
end;

procedure TFhirMedicationKnowledgeRegulatoryMaxDispense.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'quantity', 'Quantity', false, TFhirQuantity, FQuantity.Link));
  oList.add(TFHIRProperty.create(self, 'period', 'Duration', false, TFhirDuration, FPeriod.Link));
end;

function TFhirMedicationKnowledgeRegulatoryMaxDispense.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'quantity') then
  begin
    Quantity := propValue as TFhirQuantity;
    result := propValue;
  end
  else if (propName = 'period') then
  begin
    Period := propValue as TFhirDuration;
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirMedicationKnowledgeRegulatoryMaxDispense.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirMedicationKnowledgeRegulatoryMaxDispense.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'quantity') then result := TFhirQuantity.create()
  else if (propName = 'period') then result := TFhirDuration.create()
  else result := inherited createPropertyValue(propName);
end;

function TFhirMedicationKnowledgeRegulatoryMaxDispense.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'quantity') then result := 'Quantity'
  else if (propName = 'period') then result := 'Duration'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirMedicationKnowledgeRegulatoryMaxDispense.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'quantity') then QuantityElement := nil
  else if (propName = 'period') then PeriodElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirMedicationKnowledgeRegulatoryMaxDispense.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'quantity') then QuantityElement := new as TFhirQuantity
  else if (propName = 'period') then PeriodElement := new as TFhirDuration
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirMedicationKnowledgeRegulatoryMaxDispense.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirMedicationKnowledgeRegulatoryMaxDispense.fhirType : string;
begin
  result := 'MedicationKnowledge.regulatory.maxDispense';
end;

function TFhirMedicationKnowledgeRegulatoryMaxDispense.Link : TFhirMedicationKnowledgeRegulatoryMaxDispense;
begin
  result := TFhirMedicationKnowledgeRegulatoryMaxDispense(inherited Link);
end;

function TFhirMedicationKnowledgeRegulatoryMaxDispense.Clone : TFhirMedicationKnowledgeRegulatoryMaxDispense;
begin
  result := TFhirMedicationKnowledgeRegulatoryMaxDispense(inherited Clone);
end;

function TFhirMedicationKnowledgeRegulatoryMaxDispense.equals(other : TObject) : boolean; 
var
  o : TFhirMedicationKnowledgeRegulatoryMaxDispense;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirMedicationKnowledgeRegulatoryMaxDispense)) then
    result := false
  else
  begin
    o := TFhirMedicationKnowledgeRegulatoryMaxDispense(other);
    result := compareDeep(quantityElement, o.quantityElement, true) and compareDeep(periodElement, o.periodElement, true);
  end;
end;

function TFhirMedicationKnowledgeRegulatoryMaxDispense.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FQuantity) and isEmptyProp(FPeriod);
end;

procedure TFhirMedicationKnowledgeRegulatoryMaxDispense.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('quantity');
  fields.add('period');
end;

function TFhirMedicationKnowledgeRegulatoryMaxDispense.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
end;

procedure TFhirMedicationKnowledgeRegulatoryMaxDispense.SetQuantity(value : TFhirQuantity);
begin
  FQuantity.free;
  FQuantity := value;
end;

procedure TFhirMedicationKnowledgeRegulatoryMaxDispense.SetPeriod(value : TFhirDuration);
begin
  FPeriod.free;
  FPeriod := value;
end;

{ TFhirMedicationKnowledgeRegulatoryMaxDispenseListEnumerator }

constructor TFhirMedicationKnowledgeRegulatoryMaxDispenseListEnumerator.Create(list : TFhirMedicationKnowledgeRegulatoryMaxDispenseList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirMedicationKnowledgeRegulatoryMaxDispenseListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirMedicationKnowledgeRegulatoryMaxDispenseListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirMedicationKnowledgeRegulatoryMaxDispenseListEnumerator.GetCurrent : TFhirMedicationKnowledgeRegulatoryMaxDispense;
begin
  Result := FList[FIndex];
end;

function TFhirMedicationKnowledgeRegulatoryMaxDispenseListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirMedicationKnowledgeRegulatoryMaxDispenseList }

function TFhirMedicationKnowledgeRegulatoryMaxDispenseList.AddItem(value: TFhirMedicationKnowledgeRegulatoryMaxDispense): TFhirMedicationKnowledgeRegulatoryMaxDispense;
begin
  assert(value.ClassName = 'TFhirMedicationKnowledgeRegulatoryMaxDispense', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirMedicationKnowledgeRegulatoryMaxDispense');
  add(value);
  result := value;
end;

function TFhirMedicationKnowledgeRegulatoryMaxDispenseList.Append: TFhirMedicationKnowledgeRegulatoryMaxDispense;
begin
  result := TFhirMedicationKnowledgeRegulatoryMaxDispense.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirMedicationKnowledgeRegulatoryMaxDispenseList.ClearItems;
begin
  Clear;
end;

function TFhirMedicationKnowledgeRegulatoryMaxDispenseList.GetEnumerator : TFhirMedicationKnowledgeRegulatoryMaxDispenseListEnumerator;
begin
  result := TFhirMedicationKnowledgeRegulatoryMaxDispenseListEnumerator.Create(self.link);
end;

function TFhirMedicationKnowledgeRegulatoryMaxDispenseList.Clone: TFhirMedicationKnowledgeRegulatoryMaxDispenseList;
begin
  result := TFhirMedicationKnowledgeRegulatoryMaxDispenseList(inherited Clone);
end;

function TFhirMedicationKnowledgeRegulatoryMaxDispenseList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirMedicationKnowledgeRegulatoryMaxDispenseList.GetItemN(index: Integer): TFhirMedicationKnowledgeRegulatoryMaxDispense;
begin
  result := TFhirMedicationKnowledgeRegulatoryMaxDispense(ObjectByIndex[index]);
end;

function TFhirMedicationKnowledgeRegulatoryMaxDispenseList.ItemClass: TFslObjectClass;
begin
  result := TFhirMedicationKnowledgeRegulatoryMaxDispense;
end;
function TFhirMedicationKnowledgeRegulatoryMaxDispenseList.IndexOf(value: TFhirMedicationKnowledgeRegulatoryMaxDispense): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirMedicationKnowledgeRegulatoryMaxDispenseList.Insert(index: Integer): TFhirMedicationKnowledgeRegulatoryMaxDispense;
begin
  result := TFhirMedicationKnowledgeRegulatoryMaxDispense.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirMedicationKnowledgeRegulatoryMaxDispenseList.InsertItem(index: Integer; value: TFhirMedicationKnowledgeRegulatoryMaxDispense);
begin
  assert(value is TFhirMedicationKnowledgeRegulatoryMaxDispense);
  Inherited Insert(index, value);
end;

function TFhirMedicationKnowledgeRegulatoryMaxDispenseList.Item(index: Integer): TFhirMedicationKnowledgeRegulatoryMaxDispense;
begin
  result := TFhirMedicationKnowledgeRegulatoryMaxDispense(ObjectByIndex[index]);
end;

function TFhirMedicationKnowledgeRegulatoryMaxDispenseList.Link: TFhirMedicationKnowledgeRegulatoryMaxDispenseList;
begin
  result := TFhirMedicationKnowledgeRegulatoryMaxDispenseList(inherited Link);
end;

procedure TFhirMedicationKnowledgeRegulatoryMaxDispenseList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirMedicationKnowledgeRegulatoryMaxDispenseList.SetItemByIndex(index: Integer; value: TFhirMedicationKnowledgeRegulatoryMaxDispense);
begin
  assert(value is TFhirMedicationKnowledgeRegulatoryMaxDispense);
  FhirMedicationKnowledgeRegulatoryMaxDispenses[index] := value;
end;

procedure TFhirMedicationKnowledgeRegulatoryMaxDispenseList.SetItemN(index: Integer; value: TFhirMedicationKnowledgeRegulatoryMaxDispense);
begin
  assert(value is TFhirMedicationKnowledgeRegulatoryMaxDispense);
  ObjectByIndex[index] := value;
end;

{ TFhirMedicationKnowledgeDefinitional }

constructor TFhirMedicationKnowledgeDefinitional.Create;
begin
  inherited;
end;

destructor TFhirMedicationKnowledgeDefinitional.Destroy;
begin
  FDefinitionList.Free;
  FDoseForm.free;
  FIntendedRouteList.Free;
  FIngredientList.Free;
  FDrugCharacteristicList.Free;
  inherited;
end;

procedure TFhirMedicationKnowledgeDefinitional.Assign(oSource : TFslObject);
begin
  inherited;
  if (TFhirMedicationKnowledgeDefinitional(oSource).FDefinitionList = nil) then
  begin
    FDefinitionList.free;
    FDefinitionList := nil;
  end
  else
  begin
    if FDefinitionList = nil then
      FDefinitionList := TFhirReferenceList.Create;
    FDefinitionList.Assign(TFhirMedicationKnowledgeDefinitional(oSource).FDefinitionList);
  end;
  doseForm := TFhirMedicationKnowledgeDefinitional(oSource).doseForm.Clone;
  if (TFhirMedicationKnowledgeDefinitional(oSource).FIntendedRouteList = nil) then
  begin
    FIntendedRouteList.free;
    FIntendedRouteList := nil;
  end
  else
  begin
    if FIntendedRouteList = nil then
      FIntendedRouteList := TFhirCodeableConceptList.Create;
    FIntendedRouteList.Assign(TFhirMedicationKnowledgeDefinitional(oSource).FIntendedRouteList);
  end;
  if (TFhirMedicationKnowledgeDefinitional(oSource).FIngredientList = nil) then
  begin
    FIngredientList.free;
    FIngredientList := nil;
  end
  else
  begin
    if FIngredientList = nil then
      FIngredientList := TFhirMedicationKnowledgeDefinitionalIngredientList.Create;
    FIngredientList.Assign(TFhirMedicationKnowledgeDefinitional(oSource).FIngredientList);
  end;
  if (TFhirMedicationKnowledgeDefinitional(oSource).FDrugCharacteristicList = nil) then
  begin
    FDrugCharacteristicList.free;
    FDrugCharacteristicList := nil;
  end
  else
  begin
    if FDrugCharacteristicList = nil then
      FDrugCharacteristicList := TFhirMedicationKnowledgeDefinitionalDrugCharacteristicList.Create;
    FDrugCharacteristicList.Assign(TFhirMedicationKnowledgeDefinitional(oSource).FDrugCharacteristicList);
  end;
end;

procedure TFhirMedicationKnowledgeDefinitional.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'definition') Then
    list.addAll(self, 'definition', FDefinitionList);
  if (child_name = 'doseForm') Then
     list.add(self.link, 'doseForm', FDoseForm.Link);
  if (child_name = 'intendedRoute') Then
    list.addAll(self, 'intendedRoute', FIntendedRouteList);
  if (child_name = 'ingredient') Then
    list.addAll(self, 'ingredient', FIngredientList);
  if (child_name = 'drugCharacteristic') Then
    list.addAll(self, 'drugCharacteristic', FDrugCharacteristicList);
end;

procedure TFhirMedicationKnowledgeDefinitional.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'definition', 'Reference', true, TFhirReference, FDefinitionList.Link));
  oList.add(TFHIRProperty.create(self, 'doseForm', 'CodeableConcept', false, TFhirCodeableConcept, FDoseForm.Link));
  oList.add(TFHIRProperty.create(self, 'intendedRoute', 'CodeableConcept', true, TFhirCodeableConcept, FIntendedRouteList.Link));
  oList.add(TFHIRProperty.create(self, 'ingredient', 'BackboneElement', true, TFhirMedicationKnowledgeDefinitionalIngredient, FIngredientList.Link));
  oList.add(TFHIRProperty.create(self, 'drugCharacteristic', 'BackboneElement', true, TFhirMedicationKnowledgeDefinitionalDrugCharacteristic, FDrugCharacteristicList.Link));
end;

function TFhirMedicationKnowledgeDefinitional.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'definition') then
  begin
    DefinitionList.add(propValue as TFhirReference);
    result := propValue;
  end
  else if (propName = 'doseForm') then
  begin
    DoseForm := propValue as TFhirCodeableConcept;
    result := propValue;
  end
  else if (propName = 'intendedRoute') then
  begin
    IntendedRouteList.add(propValue as TFhirCodeableConcept);
    result := propValue;
  end
  else if (propName = 'ingredient') then
  begin
    IngredientList.add(propValue as TFhirMedicationKnowledgeDefinitionalIngredient);
    result := propValue;
  end
  else if (propName = 'drugCharacteristic') then
  begin
    DrugCharacteristicList.add(propValue as TFhirMedicationKnowledgeDefinitionalDrugCharacteristic);
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirMedicationKnowledgeDefinitional.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'definition') then DefinitionList.insertItem(index, propValue as TFhirReference)
  else if (propName = 'intendedRoute') then IntendedRouteList.insertItem(index, propValue as TFhirCodeableConcept)
  else if (propName = 'ingredient') then IngredientList.insertItem(index, propValue as TFhirMedicationKnowledgeDefinitionalIngredient)
  else if (propName = 'drugCharacteristic') then DrugCharacteristicList.insertItem(index, propValue as TFhirMedicationKnowledgeDefinitionalDrugCharacteristic)
  else inherited;
end;

function TFhirMedicationKnowledgeDefinitional.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'definition') then result := DefinitionList.new()
  else if (propName = 'doseForm') then result := TFhirCodeableConcept.create()
  else if (propName = 'intendedRoute') then result := IntendedRouteList.new()
  else if (propName = 'ingredient') then result := IngredientList.new()
  else if (propName = 'drugCharacteristic') then result := DrugCharacteristicList.new()
  else result := inherited createPropertyValue(propName);
end;

function TFhirMedicationKnowledgeDefinitional.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'definition') then result := 'Reference'
  else if (propName = 'doseForm') then result := 'CodeableConcept'
  else if (propName = 'intendedRoute') then result := 'CodeableConcept'
  else if (propName = 'ingredient') then result := 'BackboneElement'
  else if (propName = 'drugCharacteristic') then result := 'BackboneElement'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirMedicationKnowledgeDefinitional.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'definition') then deletePropertyValue('definition', DefinitionList, value)
  else if (propName = 'doseForm') then DoseFormElement := nil
  else if (propName = 'intendedRoute') then deletePropertyValue('intendedRoute', IntendedRouteList, value)
  else if (propName = 'ingredient') then deletePropertyValue('ingredient', IngredientList, value)
  else if (propName = 'drugCharacteristic') then deletePropertyValue('drugCharacteristic', DrugCharacteristicList, value)
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirMedicationKnowledgeDefinitional.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'definition') then replacePropertyValue('definition', DefinitionList, existing, new)
  else if (propName = 'doseForm') then DoseFormElement := new as TFhirCodeableConcept
  else if (propName = 'intendedRoute') then replacePropertyValue('intendedRoute', IntendedRouteList, existing, new)
  else if (propName = 'ingredient') then replacePropertyValue('ingredient', IngredientList, existing, new)
  else if (propName = 'drugCharacteristic') then replacePropertyValue('drugCharacteristic', DrugCharacteristicList, existing, new)
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirMedicationKnowledgeDefinitional.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'definition') then DefinitionList.move(source, destination)
  else if (propName = 'intendedRoute') then IntendedRouteList.move(source, destination)
  else if (propName = 'ingredient') then IngredientList.move(source, destination)
  else if (propName = 'drugCharacteristic') then DrugCharacteristicList.move(source, destination)
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirMedicationKnowledgeDefinitional.fhirType : string;
begin
  result := 'MedicationKnowledge.definitional';
end;

function TFhirMedicationKnowledgeDefinitional.Link : TFhirMedicationKnowledgeDefinitional;
begin
  result := TFhirMedicationKnowledgeDefinitional(inherited Link);
end;

function TFhirMedicationKnowledgeDefinitional.Clone : TFhirMedicationKnowledgeDefinitional;
begin
  result := TFhirMedicationKnowledgeDefinitional(inherited Clone);
end;

function TFhirMedicationKnowledgeDefinitional.equals(other : TObject) : boolean; 
var
  o : TFhirMedicationKnowledgeDefinitional;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirMedicationKnowledgeDefinitional)) then
    result := false
  else
  begin
    o := TFhirMedicationKnowledgeDefinitional(other);
    result := compareDeep(definitionList, o.definitionList, true) and compareDeep(doseFormElement, o.doseFormElement, true) and 
      compareDeep(intendedRouteList, o.intendedRouteList, true) and compareDeep(ingredientList, o.ingredientList, true) and 
      compareDeep(drugCharacteristicList, o.drugCharacteristicList, true);
  end;
end;

function TFhirMedicationKnowledgeDefinitional.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FdefinitionList) and isEmptyProp(FDoseForm) and isEmptyProp(FintendedRouteList) and isEmptyProp(FingredientList) and isEmptyProp(FdrugCharacteristicList);
end;

procedure TFhirMedicationKnowledgeDefinitional.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('definition');
  fields.add('doseForm');
  fields.add('intendedRoute');
  fields.add('ingredient');
  fields.add('drugCharacteristic');
end;

function TFhirMedicationKnowledgeDefinitional.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
  inc(result, FDefinitionList.sizeInBytes(magic));
  inc(result, FIntendedRouteList.sizeInBytes(magic));
  inc(result, FIngredientList.sizeInBytes(magic));
  inc(result, FDrugCharacteristicList.sizeInBytes(magic));
end;

function TFhirMedicationKnowledgeDefinitional.GetDefinitionList : TFhirReferenceList;
begin
  if FDefinitionList = nil then
    FDefinitionList := TFhirReferenceList.Create;
  result := FDefinitionList;
end;

function TFhirMedicationKnowledgeDefinitional.GetHasDefinitionList : boolean;
begin
  result := (FDefinitionList <> nil) and (FDefinitionList.count > 0);
end;

procedure TFhirMedicationKnowledgeDefinitional.SetDoseForm(value : TFhirCodeableConcept);
begin
  FDoseForm.free;
  FDoseForm := value;
end;

function TFhirMedicationKnowledgeDefinitional.GetIntendedRouteList : TFhirCodeableConceptList;
begin
  if FIntendedRouteList = nil then
    FIntendedRouteList := TFhirCodeableConceptList.Create;
  result := FIntendedRouteList;
end;

function TFhirMedicationKnowledgeDefinitional.GetHasIntendedRouteList : boolean;
begin
  result := (FIntendedRouteList <> nil) and (FIntendedRouteList.count > 0);
end;

function TFhirMedicationKnowledgeDefinitional.GetIngredientList : TFhirMedicationKnowledgeDefinitionalIngredientList;
begin
  if FIngredientList = nil then
    FIngredientList := TFhirMedicationKnowledgeDefinitionalIngredientList.Create;
  result := FIngredientList;
end;

function TFhirMedicationKnowledgeDefinitional.GetHasIngredientList : boolean;
begin
  result := (FIngredientList <> nil) and (FIngredientList.count > 0);
end;

function TFhirMedicationKnowledgeDefinitional.GetDrugCharacteristicList : TFhirMedicationKnowledgeDefinitionalDrugCharacteristicList;
begin
  if FDrugCharacteristicList = nil then
    FDrugCharacteristicList := TFhirMedicationKnowledgeDefinitionalDrugCharacteristicList.Create;
  result := FDrugCharacteristicList;
end;

function TFhirMedicationKnowledgeDefinitional.GetHasDrugCharacteristicList : boolean;
begin
  result := (FDrugCharacteristicList <> nil) and (FDrugCharacteristicList.count > 0);
end;

{ TFhirMedicationKnowledgeDefinitionalListEnumerator }

constructor TFhirMedicationKnowledgeDefinitionalListEnumerator.Create(list : TFhirMedicationKnowledgeDefinitionalList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirMedicationKnowledgeDefinitionalListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirMedicationKnowledgeDefinitionalListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirMedicationKnowledgeDefinitionalListEnumerator.GetCurrent : TFhirMedicationKnowledgeDefinitional;
begin
  Result := FList[FIndex];
end;

function TFhirMedicationKnowledgeDefinitionalListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirMedicationKnowledgeDefinitionalList }

function TFhirMedicationKnowledgeDefinitionalList.AddItem(value: TFhirMedicationKnowledgeDefinitional): TFhirMedicationKnowledgeDefinitional;
begin
  assert(value.ClassName = 'TFhirMedicationKnowledgeDefinitional', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirMedicationKnowledgeDefinitional');
  add(value);
  result := value;
end;

function TFhirMedicationKnowledgeDefinitionalList.Append: TFhirMedicationKnowledgeDefinitional;
begin
  result := TFhirMedicationKnowledgeDefinitional.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirMedicationKnowledgeDefinitionalList.ClearItems;
begin
  Clear;
end;

function TFhirMedicationKnowledgeDefinitionalList.GetEnumerator : TFhirMedicationKnowledgeDefinitionalListEnumerator;
begin
  result := TFhirMedicationKnowledgeDefinitionalListEnumerator.Create(self.link);
end;

function TFhirMedicationKnowledgeDefinitionalList.Clone: TFhirMedicationKnowledgeDefinitionalList;
begin
  result := TFhirMedicationKnowledgeDefinitionalList(inherited Clone);
end;

function TFhirMedicationKnowledgeDefinitionalList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirMedicationKnowledgeDefinitionalList.GetItemN(index: Integer): TFhirMedicationKnowledgeDefinitional;
begin
  result := TFhirMedicationKnowledgeDefinitional(ObjectByIndex[index]);
end;

function TFhirMedicationKnowledgeDefinitionalList.ItemClass: TFslObjectClass;
begin
  result := TFhirMedicationKnowledgeDefinitional;
end;
function TFhirMedicationKnowledgeDefinitionalList.IndexOf(value: TFhirMedicationKnowledgeDefinitional): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirMedicationKnowledgeDefinitionalList.Insert(index: Integer): TFhirMedicationKnowledgeDefinitional;
begin
  result := TFhirMedicationKnowledgeDefinitional.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirMedicationKnowledgeDefinitionalList.InsertItem(index: Integer; value: TFhirMedicationKnowledgeDefinitional);
begin
  assert(value is TFhirMedicationKnowledgeDefinitional);
  Inherited Insert(index, value);
end;

function TFhirMedicationKnowledgeDefinitionalList.Item(index: Integer): TFhirMedicationKnowledgeDefinitional;
begin
  result := TFhirMedicationKnowledgeDefinitional(ObjectByIndex[index]);
end;

function TFhirMedicationKnowledgeDefinitionalList.Link: TFhirMedicationKnowledgeDefinitionalList;
begin
  result := TFhirMedicationKnowledgeDefinitionalList(inherited Link);
end;

procedure TFhirMedicationKnowledgeDefinitionalList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirMedicationKnowledgeDefinitionalList.SetItemByIndex(index: Integer; value: TFhirMedicationKnowledgeDefinitional);
begin
  assert(value is TFhirMedicationKnowledgeDefinitional);
  FhirMedicationKnowledgeDefinitionals[index] := value;
end;

procedure TFhirMedicationKnowledgeDefinitionalList.SetItemN(index: Integer; value: TFhirMedicationKnowledgeDefinitional);
begin
  assert(value is TFhirMedicationKnowledgeDefinitional);
  ObjectByIndex[index] := value;
end;

{ TFhirMedicationKnowledgeDefinitionalIngredient }

constructor TFhirMedicationKnowledgeDefinitionalIngredient.Create;
begin
  inherited;
end;

destructor TFhirMedicationKnowledgeDefinitionalIngredient.Destroy;
begin
  FItem.free;
  FType_.free;
  FStrength.free;
  inherited;
end;

procedure TFhirMedicationKnowledgeDefinitionalIngredient.Assign(oSource : TFslObject);
begin
  inherited;
  item := TFhirMedicationKnowledgeDefinitionalIngredient(oSource).item.Clone;
  type_ := TFhirMedicationKnowledgeDefinitionalIngredient(oSource).type_.Clone;
  strength := TFhirMedicationKnowledgeDefinitionalIngredient(oSource).strength.Clone;
end;

procedure TFhirMedicationKnowledgeDefinitionalIngredient.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'item') Then
     list.add(self.link, 'item', FItem.Link);
  if (child_name = 'type') Then
     list.add(self.link, 'type', FType_.Link);
  if (child_name = 'strength[x]') or (child_name = 'strength') Then
     list.add(self.link, 'strength[x]', FStrength.Link);
end;

procedure TFhirMedicationKnowledgeDefinitionalIngredient.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'item', 'CodeableReference', false, TFhirCodeableReference, FItem.Link));
  oList.add(TFHIRProperty.create(self, 'type', 'CodeableConcept', false, TFhirCodeableConcept, FType_.Link));
  oList.add(TFHIRProperty.create(self, 'strength[x]', 'Ratio|CodeableConcept|Quantity', false, TFhirDataType, FStrength.Link));
end;

function TFhirMedicationKnowledgeDefinitionalIngredient.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'item') then
  begin
    Item := propValue as TFhirCodeableReference;
    result := propValue;
  end
  else if (propName = 'type') then
  begin
    Type_ := propValue as TFhirCodeableConcept;
    result := propValue;
  end
  else if (isMatchingName(propName, 'strength', ['Ratio', 'CodeableConcept', 'Quantity'])) then
  begin
    Strength := propValue as TFhirDataType;
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirMedicationKnowledgeDefinitionalIngredient.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirMedicationKnowledgeDefinitionalIngredient.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'item') then result := TFhirCodeableReference.create()
  else if (propName = 'type') then result := TFhirCodeableConcept.create()
  else if (isMatchingName(propName, 'strength', ['Ratio', 'CodeableConcept', 'Quantity'])) then raise EFHIRException.create('Cannot make property Strength')
  else result := inherited createPropertyValue(propName);
end;

function TFhirMedicationKnowledgeDefinitionalIngredient.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'item') then result := 'CodeableReference'
  else if (propName = 'type') then result := 'CodeableConcept'
  else if (propName = 'strength[x]') then result := 'Ratio|CodeableConcept|Quantity'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirMedicationKnowledgeDefinitionalIngredient.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'item') then ItemElement := nil
  else if (propName = 'type') then Type_Element := nil
  else if (isMatchingName(propName, 'strength', ['Ratio', 'CodeableConcept', 'Quantity'])) then StrengthElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirMedicationKnowledgeDefinitionalIngredient.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'item') then ItemElement := new as TFhirCodeableReference
  else if (propName = 'type') then Type_Element := new as TFhirCodeableConcept
  else if (isMatchingName(propName, 'strength', ['Ratio', 'CodeableConcept', 'Quantity'])) then StrengthElement := new as TFhirDataType
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirMedicationKnowledgeDefinitionalIngredient.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirMedicationKnowledgeDefinitionalIngredient.fhirType : string;
begin
  result := 'MedicationKnowledge.definitional.ingredient';
end;

function TFhirMedicationKnowledgeDefinitionalIngredient.Link : TFhirMedicationKnowledgeDefinitionalIngredient;
begin
  result := TFhirMedicationKnowledgeDefinitionalIngredient(inherited Link);
end;

function TFhirMedicationKnowledgeDefinitionalIngredient.Clone : TFhirMedicationKnowledgeDefinitionalIngredient;
begin
  result := TFhirMedicationKnowledgeDefinitionalIngredient(inherited Clone);
end;

function TFhirMedicationKnowledgeDefinitionalIngredient.equals(other : TObject) : boolean; 
var
  o : TFhirMedicationKnowledgeDefinitionalIngredient;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirMedicationKnowledgeDefinitionalIngredient)) then
    result := false
  else
  begin
    o := TFhirMedicationKnowledgeDefinitionalIngredient(other);
    result := compareDeep(itemElement, o.itemElement, true) and compareDeep(type_Element, o.type_Element, true) and 
      compareDeep(strengthElement, o.strengthElement, true);
  end;
end;

function TFhirMedicationKnowledgeDefinitionalIngredient.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FItem) and isEmptyProp(FType_) and isEmptyProp(FStrength);
end;

procedure TFhirMedicationKnowledgeDefinitionalIngredient.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('item');
  fields.add('type');
  fields.add('strength[x]');
end;

function TFhirMedicationKnowledgeDefinitionalIngredient.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
end;

procedure TFhirMedicationKnowledgeDefinitionalIngredient.SetItem(value : TFhirCodeableReference);
begin
  FItem.free;
  FItem := value;
end;

procedure TFhirMedicationKnowledgeDefinitionalIngredient.SetType_(value : TFhirCodeableConcept);
begin
  FType_.free;
  FType_ := value;
end;

procedure TFhirMedicationKnowledgeDefinitionalIngredient.SetStrength(value : TFhirDataType);
begin
  FStrength.free;
  FStrength := value;
end;

{ TFhirMedicationKnowledgeDefinitionalIngredientListEnumerator }

constructor TFhirMedicationKnowledgeDefinitionalIngredientListEnumerator.Create(list : TFhirMedicationKnowledgeDefinitionalIngredientList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirMedicationKnowledgeDefinitionalIngredientListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirMedicationKnowledgeDefinitionalIngredientListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirMedicationKnowledgeDefinitionalIngredientListEnumerator.GetCurrent : TFhirMedicationKnowledgeDefinitionalIngredient;
begin
  Result := FList[FIndex];
end;

function TFhirMedicationKnowledgeDefinitionalIngredientListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirMedicationKnowledgeDefinitionalIngredientList }

function TFhirMedicationKnowledgeDefinitionalIngredientList.AddItem(value: TFhirMedicationKnowledgeDefinitionalIngredient): TFhirMedicationKnowledgeDefinitionalIngredient;
begin
  assert(value.ClassName = 'TFhirMedicationKnowledgeDefinitionalIngredient', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirMedicationKnowledgeDefinitionalIngredient');
  add(value);
  result := value;
end;

function TFhirMedicationKnowledgeDefinitionalIngredientList.Append: TFhirMedicationKnowledgeDefinitionalIngredient;
begin
  result := TFhirMedicationKnowledgeDefinitionalIngredient.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirMedicationKnowledgeDefinitionalIngredientList.ClearItems;
begin
  Clear;
end;

function TFhirMedicationKnowledgeDefinitionalIngredientList.GetEnumerator : TFhirMedicationKnowledgeDefinitionalIngredientListEnumerator;
begin
  result := TFhirMedicationKnowledgeDefinitionalIngredientListEnumerator.Create(self.link);
end;

function TFhirMedicationKnowledgeDefinitionalIngredientList.Clone: TFhirMedicationKnowledgeDefinitionalIngredientList;
begin
  result := TFhirMedicationKnowledgeDefinitionalIngredientList(inherited Clone);
end;

function TFhirMedicationKnowledgeDefinitionalIngredientList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirMedicationKnowledgeDefinitionalIngredientList.GetItemN(index: Integer): TFhirMedicationKnowledgeDefinitionalIngredient;
begin
  result := TFhirMedicationKnowledgeDefinitionalIngredient(ObjectByIndex[index]);
end;

function TFhirMedicationKnowledgeDefinitionalIngredientList.ItemClass: TFslObjectClass;
begin
  result := TFhirMedicationKnowledgeDefinitionalIngredient;
end;
function TFhirMedicationKnowledgeDefinitionalIngredientList.IndexOf(value: TFhirMedicationKnowledgeDefinitionalIngredient): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirMedicationKnowledgeDefinitionalIngredientList.Insert(index: Integer): TFhirMedicationKnowledgeDefinitionalIngredient;
begin
  result := TFhirMedicationKnowledgeDefinitionalIngredient.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirMedicationKnowledgeDefinitionalIngredientList.InsertItem(index: Integer; value: TFhirMedicationKnowledgeDefinitionalIngredient);
begin
  assert(value is TFhirMedicationKnowledgeDefinitionalIngredient);
  Inherited Insert(index, value);
end;

function TFhirMedicationKnowledgeDefinitionalIngredientList.Item(index: Integer): TFhirMedicationKnowledgeDefinitionalIngredient;
begin
  result := TFhirMedicationKnowledgeDefinitionalIngredient(ObjectByIndex[index]);
end;

function TFhirMedicationKnowledgeDefinitionalIngredientList.Link: TFhirMedicationKnowledgeDefinitionalIngredientList;
begin
  result := TFhirMedicationKnowledgeDefinitionalIngredientList(inherited Link);
end;

procedure TFhirMedicationKnowledgeDefinitionalIngredientList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirMedicationKnowledgeDefinitionalIngredientList.SetItemByIndex(index: Integer; value: TFhirMedicationKnowledgeDefinitionalIngredient);
begin
  assert(value is TFhirMedicationKnowledgeDefinitionalIngredient);
  FhirMedicationKnowledgeDefinitionalIngredients[index] := value;
end;

procedure TFhirMedicationKnowledgeDefinitionalIngredientList.SetItemN(index: Integer; value: TFhirMedicationKnowledgeDefinitionalIngredient);
begin
  assert(value is TFhirMedicationKnowledgeDefinitionalIngredient);
  ObjectByIndex[index] := value;
end;

{ TFhirMedicationKnowledgeDefinitionalDrugCharacteristic }

constructor TFhirMedicationKnowledgeDefinitionalDrugCharacteristic.Create;
begin
  inherited;
end;

destructor TFhirMedicationKnowledgeDefinitionalDrugCharacteristic.Destroy;
begin
  FType_.free;
  FValue.free;
  inherited;
end;

procedure TFhirMedicationKnowledgeDefinitionalDrugCharacteristic.Assign(oSource : TFslObject);
begin
  inherited;
  type_ := TFhirMedicationKnowledgeDefinitionalDrugCharacteristic(oSource).type_.Clone;
  value := TFhirMedicationKnowledgeDefinitionalDrugCharacteristic(oSource).value.Clone;
end;

procedure TFhirMedicationKnowledgeDefinitionalDrugCharacteristic.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'type') Then
     list.add(self.link, 'type', FType_.Link);
  if (child_name = 'value[x]') or (child_name = 'value') Then
     list.add(self.link, 'value[x]', FValue.Link);
end;

procedure TFhirMedicationKnowledgeDefinitionalDrugCharacteristic.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'type', 'CodeableConcept', false, TFhirCodeableConcept, FType_.Link));
  oList.add(TFHIRProperty.create(self, 'value[x]', 'CodeableConcept|string|Quantity|base64Binary|Attachment', false, TFhirDataType, FValue.Link));
end;

function TFhirMedicationKnowledgeDefinitionalDrugCharacteristic.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'type') then
  begin
    Type_ := propValue as TFhirCodeableConcept;
    result := propValue;
  end
  else if (isMatchingName(propName, 'value', ['CodeableConcept', 'String', 'Quantity', 'Base64Binary', 'Attachment'])) then
  begin
    Value := propValue as TFhirDataType;
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirMedicationKnowledgeDefinitionalDrugCharacteristic.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirMedicationKnowledgeDefinitionalDrugCharacteristic.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'type') then result := TFhirCodeableConcept.create()
  else if (isMatchingName(propName, 'value', ['CodeableConcept', 'String', 'Quantity', 'Base64Binary', 'Attachment'])) then raise EFHIRException.create('Cannot make property Value')
  else result := inherited createPropertyValue(propName);
end;

function TFhirMedicationKnowledgeDefinitionalDrugCharacteristic.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'type') then result := 'CodeableConcept'
  else if (propName = 'value[x]') then result := 'CodeableConcept|string|Quantity|base64Binary|Attachment'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirMedicationKnowledgeDefinitionalDrugCharacteristic.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'type') then Type_Element := nil
  else if (isMatchingName(propName, 'value', ['CodeableConcept', 'String', 'Quantity', 'Base64Binary', 'Attachment'])) then ValueElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirMedicationKnowledgeDefinitionalDrugCharacteristic.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'type') then Type_Element := new as TFhirCodeableConcept
  else if (isMatchingName(propName, 'value', ['CodeableConcept', 'String', 'Quantity', 'Base64Binary', 'Attachment'])) then ValueElement := new as TFhirDataType
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirMedicationKnowledgeDefinitionalDrugCharacteristic.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirMedicationKnowledgeDefinitionalDrugCharacteristic.fhirType : string;
begin
  result := 'MedicationKnowledge.definitional.drugCharacteristic';
end;

function TFhirMedicationKnowledgeDefinitionalDrugCharacteristic.Link : TFhirMedicationKnowledgeDefinitionalDrugCharacteristic;
begin
  result := TFhirMedicationKnowledgeDefinitionalDrugCharacteristic(inherited Link);
end;

function TFhirMedicationKnowledgeDefinitionalDrugCharacteristic.Clone : TFhirMedicationKnowledgeDefinitionalDrugCharacteristic;
begin
  result := TFhirMedicationKnowledgeDefinitionalDrugCharacteristic(inherited Clone);
end;

function TFhirMedicationKnowledgeDefinitionalDrugCharacteristic.equals(other : TObject) : boolean; 
var
  o : TFhirMedicationKnowledgeDefinitionalDrugCharacteristic;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirMedicationKnowledgeDefinitionalDrugCharacteristic)) then
    result := false
  else
  begin
    o := TFhirMedicationKnowledgeDefinitionalDrugCharacteristic(other);
    result := compareDeep(type_Element, o.type_Element, true) and compareDeep(valueElement, o.valueElement, true);
  end;
end;

function TFhirMedicationKnowledgeDefinitionalDrugCharacteristic.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FType_) and isEmptyProp(FValue);
end;

procedure TFhirMedicationKnowledgeDefinitionalDrugCharacteristic.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('type');
  fields.add('value[x]');
end;

function TFhirMedicationKnowledgeDefinitionalDrugCharacteristic.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
end;

procedure TFhirMedicationKnowledgeDefinitionalDrugCharacteristic.SetType_(value : TFhirCodeableConcept);
begin
  FType_.free;
  FType_ := value;
end;

procedure TFhirMedicationKnowledgeDefinitionalDrugCharacteristic.SetValue(value : TFhirDataType);
begin
  FValue.free;
  FValue := value;
end;

{ TFhirMedicationKnowledgeDefinitionalDrugCharacteristicListEnumerator }

constructor TFhirMedicationKnowledgeDefinitionalDrugCharacteristicListEnumerator.Create(list : TFhirMedicationKnowledgeDefinitionalDrugCharacteristicList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirMedicationKnowledgeDefinitionalDrugCharacteristicListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirMedicationKnowledgeDefinitionalDrugCharacteristicListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirMedicationKnowledgeDefinitionalDrugCharacteristicListEnumerator.GetCurrent : TFhirMedicationKnowledgeDefinitionalDrugCharacteristic;
begin
  Result := FList[FIndex];
end;

function TFhirMedicationKnowledgeDefinitionalDrugCharacteristicListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirMedicationKnowledgeDefinitionalDrugCharacteristicList }

function TFhirMedicationKnowledgeDefinitionalDrugCharacteristicList.AddItem(value: TFhirMedicationKnowledgeDefinitionalDrugCharacteristic): TFhirMedicationKnowledgeDefinitionalDrugCharacteristic;
begin
  assert(value.ClassName = 'TFhirMedicationKnowledgeDefinitionalDrugCharacteristic', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirMedicationKnowledgeDefinitionalDrugCharacteristic');
  add(value);
  result := value;
end;

function TFhirMedicationKnowledgeDefinitionalDrugCharacteristicList.Append: TFhirMedicationKnowledgeDefinitionalDrugCharacteristic;
begin
  result := TFhirMedicationKnowledgeDefinitionalDrugCharacteristic.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirMedicationKnowledgeDefinitionalDrugCharacteristicList.ClearItems;
begin
  Clear;
end;

function TFhirMedicationKnowledgeDefinitionalDrugCharacteristicList.GetEnumerator : TFhirMedicationKnowledgeDefinitionalDrugCharacteristicListEnumerator;
begin
  result := TFhirMedicationKnowledgeDefinitionalDrugCharacteristicListEnumerator.Create(self.link);
end;

function TFhirMedicationKnowledgeDefinitionalDrugCharacteristicList.Clone: TFhirMedicationKnowledgeDefinitionalDrugCharacteristicList;
begin
  result := TFhirMedicationKnowledgeDefinitionalDrugCharacteristicList(inherited Clone);
end;

function TFhirMedicationKnowledgeDefinitionalDrugCharacteristicList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirMedicationKnowledgeDefinitionalDrugCharacteristicList.GetItemN(index: Integer): TFhirMedicationKnowledgeDefinitionalDrugCharacteristic;
begin
  result := TFhirMedicationKnowledgeDefinitionalDrugCharacteristic(ObjectByIndex[index]);
end;

function TFhirMedicationKnowledgeDefinitionalDrugCharacteristicList.ItemClass: TFslObjectClass;
begin
  result := TFhirMedicationKnowledgeDefinitionalDrugCharacteristic;
end;
function TFhirMedicationKnowledgeDefinitionalDrugCharacteristicList.IndexOf(value: TFhirMedicationKnowledgeDefinitionalDrugCharacteristic): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirMedicationKnowledgeDefinitionalDrugCharacteristicList.Insert(index: Integer): TFhirMedicationKnowledgeDefinitionalDrugCharacteristic;
begin
  result := TFhirMedicationKnowledgeDefinitionalDrugCharacteristic.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirMedicationKnowledgeDefinitionalDrugCharacteristicList.InsertItem(index: Integer; value: TFhirMedicationKnowledgeDefinitionalDrugCharacteristic);
begin
  assert(value is TFhirMedicationKnowledgeDefinitionalDrugCharacteristic);
  Inherited Insert(index, value);
end;

function TFhirMedicationKnowledgeDefinitionalDrugCharacteristicList.Item(index: Integer): TFhirMedicationKnowledgeDefinitionalDrugCharacteristic;
begin
  result := TFhirMedicationKnowledgeDefinitionalDrugCharacteristic(ObjectByIndex[index]);
end;

function TFhirMedicationKnowledgeDefinitionalDrugCharacteristicList.Link: TFhirMedicationKnowledgeDefinitionalDrugCharacteristicList;
begin
  result := TFhirMedicationKnowledgeDefinitionalDrugCharacteristicList(inherited Link);
end;

procedure TFhirMedicationKnowledgeDefinitionalDrugCharacteristicList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirMedicationKnowledgeDefinitionalDrugCharacteristicList.SetItemByIndex(index: Integer; value: TFhirMedicationKnowledgeDefinitionalDrugCharacteristic);
begin
  assert(value is TFhirMedicationKnowledgeDefinitionalDrugCharacteristic);
  FhirMedicationKnowledgeDefinitionalDrugCharacteristics[index] := value;
end;

procedure TFhirMedicationKnowledgeDefinitionalDrugCharacteristicList.SetItemN(index: Integer; value: TFhirMedicationKnowledgeDefinitionalDrugCharacteristic);
begin
  assert(value is TFhirMedicationKnowledgeDefinitionalDrugCharacteristic);
  ObjectByIndex[index] := value;
end;

{ TFhirMedicationKnowledge }

constructor TFhirMedicationKnowledge.Create;
begin
  inherited;
end;

destructor TFhirMedicationKnowledge.Destroy;
begin
  FCode.free;
  FIntendedJurisdictionList.Free;
  FRelatedMedicationKnowledgeList.Free;
  FAssociatedMedicationList.Free;
  FProductTypeList.Free;
  FMonographList.Free;
  FPreparationInstruction.free;
  FCostList.Free;
  FMonitoringProgramList.Free;
  FIndicationGuidelineList.Free;
  FMedicineClassificationList.Free;
  FPackagingList.Free;
  FClinicalUseIssueList.Free;
  FStorageGuidelineList.Free;
  FRegulatoryList.Free;
  FDefinitional.free;
  inherited;
end;

procedure TFhirMedicationKnowledge.Assign(oSource : TFslObject);
begin
  inherited;
  code := TFhirMedicationKnowledge(oSource).code.Clone;
  if (TFhirMedicationKnowledge(oSource).FIntendedJurisdictionList = nil) then
  begin
    FIntendedJurisdictionList.free;
    FIntendedJurisdictionList := nil;
  end
  else
  begin
    if FIntendedJurisdictionList = nil then
      FIntendedJurisdictionList := TFhirCodeableConceptList.Create;
    FIntendedJurisdictionList.Assign(TFhirMedicationKnowledge(oSource).FIntendedJurisdictionList);
  end;
  if (TFhirMedicationKnowledge(oSource).FRelatedMedicationKnowledgeList = nil) then
  begin
    FRelatedMedicationKnowledgeList.free;
    FRelatedMedicationKnowledgeList := nil;
  end
  else
  begin
    if FRelatedMedicationKnowledgeList = nil then
      FRelatedMedicationKnowledgeList := TFhirMedicationKnowledgeRelatedMedicationKnowledgeList.Create;
    FRelatedMedicationKnowledgeList.Assign(TFhirMedicationKnowledge(oSource).FRelatedMedicationKnowledgeList);
  end;
  if (TFhirMedicationKnowledge(oSource).FAssociatedMedicationList = nil) then
  begin
    FAssociatedMedicationList.free;
    FAssociatedMedicationList := nil;
  end
  else
  begin
    if FAssociatedMedicationList = nil then
      FAssociatedMedicationList := TFhirReferenceList.Create;
    FAssociatedMedicationList.Assign(TFhirMedicationKnowledge(oSource).FAssociatedMedicationList);
  end;
  if (TFhirMedicationKnowledge(oSource).FProductTypeList = nil) then
  begin
    FProductTypeList.free;
    FProductTypeList := nil;
  end
  else
  begin
    if FProductTypeList = nil then
      FProductTypeList := TFhirCodeableConceptList.Create;
    FProductTypeList.Assign(TFhirMedicationKnowledge(oSource).FProductTypeList);
  end;
  if (TFhirMedicationKnowledge(oSource).FMonographList = nil) then
  begin
    FMonographList.free;
    FMonographList := nil;
  end
  else
  begin
    if FMonographList = nil then
      FMonographList := TFhirMedicationKnowledgeMonographList.Create;
    FMonographList.Assign(TFhirMedicationKnowledge(oSource).FMonographList);
  end;
  preparationInstructionElement := TFhirMedicationKnowledge(oSource).preparationInstructionElement.Clone;
  if (TFhirMedicationKnowledge(oSource).FCostList = nil) then
  begin
    FCostList.free;
    FCostList := nil;
  end
  else
  begin
    if FCostList = nil then
      FCostList := TFhirMedicationKnowledgeCostList.Create;
    FCostList.Assign(TFhirMedicationKnowledge(oSource).FCostList);
  end;
  if (TFhirMedicationKnowledge(oSource).FMonitoringProgramList = nil) then
  begin
    FMonitoringProgramList.free;
    FMonitoringProgramList := nil;
  end
  else
  begin
    if FMonitoringProgramList = nil then
      FMonitoringProgramList := TFhirMedicationKnowledgeMonitoringProgramList.Create;
    FMonitoringProgramList.Assign(TFhirMedicationKnowledge(oSource).FMonitoringProgramList);
  end;
  if (TFhirMedicationKnowledge(oSource).FIndicationGuidelineList = nil) then
  begin
    FIndicationGuidelineList.free;
    FIndicationGuidelineList := nil;
  end
  else
  begin
    if FIndicationGuidelineList = nil then
      FIndicationGuidelineList := TFhirMedicationKnowledgeIndicationGuidelineList.Create;
    FIndicationGuidelineList.Assign(TFhirMedicationKnowledge(oSource).FIndicationGuidelineList);
  end;
  if (TFhirMedicationKnowledge(oSource).FMedicineClassificationList = nil) then
  begin
    FMedicineClassificationList.free;
    FMedicineClassificationList := nil;
  end
  else
  begin
    if FMedicineClassificationList = nil then
      FMedicineClassificationList := TFhirMedicationKnowledgeMedicineClassificationList.Create;
    FMedicineClassificationList.Assign(TFhirMedicationKnowledge(oSource).FMedicineClassificationList);
  end;
  if (TFhirMedicationKnowledge(oSource).FPackagingList = nil) then
  begin
    FPackagingList.free;
    FPackagingList := nil;
  end
  else
  begin
    if FPackagingList = nil then
      FPackagingList := TFhirMedicationKnowledgePackagingList.Create;
    FPackagingList.Assign(TFhirMedicationKnowledge(oSource).FPackagingList);
  end;
  if (TFhirMedicationKnowledge(oSource).FClinicalUseIssueList = nil) then
  begin
    FClinicalUseIssueList.free;
    FClinicalUseIssueList := nil;
  end
  else
  begin
    if FClinicalUseIssueList = nil then
      FClinicalUseIssueList := TFhirReferenceList.Create;
    FClinicalUseIssueList.Assign(TFhirMedicationKnowledge(oSource).FClinicalUseIssueList);
  end;
  if (TFhirMedicationKnowledge(oSource).FStorageGuidelineList = nil) then
  begin
    FStorageGuidelineList.free;
    FStorageGuidelineList := nil;
  end
  else
  begin
    if FStorageGuidelineList = nil then
      FStorageGuidelineList := TFhirMedicationKnowledgeStorageGuidelineList.Create;
    FStorageGuidelineList.Assign(TFhirMedicationKnowledge(oSource).FStorageGuidelineList);
  end;
  if (TFhirMedicationKnowledge(oSource).FRegulatoryList = nil) then
  begin
    FRegulatoryList.free;
    FRegulatoryList := nil;
  end
  else
  begin
    if FRegulatoryList = nil then
      FRegulatoryList := TFhirMedicationKnowledgeRegulatoryList.Create;
    FRegulatoryList.Assign(TFhirMedicationKnowledge(oSource).FRegulatoryList);
  end;
  definitional := TFhirMedicationKnowledge(oSource).definitional.Clone;
end;

function TFhirMedicationKnowledge.GetResourceType : TFhirResourceType;
begin
  result := frtMedicationKnowledge;
end;

procedure TFhirMedicationKnowledge.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'code') Then
     list.add(self.link, 'code', FCode.Link);
  if (child_name = 'intendedJurisdiction') Then
    list.addAll(self, 'intendedJurisdiction', FIntendedJurisdictionList);
  if (child_name = 'relatedMedicationKnowledge') Then
    list.addAll(self, 'relatedMedicationKnowledge', FRelatedMedicationKnowledgeList);
  if (child_name = 'associatedMedication') Then
    list.addAll(self, 'associatedMedication', FAssociatedMedicationList);
  if (child_name = 'productType') Then
    list.addAll(self, 'productType', FProductTypeList);
  if (child_name = 'monograph') Then
    list.addAll(self, 'monograph', FMonographList);
  if (child_name = 'preparationInstruction') Then
     list.add(self.link, 'preparationInstruction', FPreparationInstruction.Link);
  if (child_name = 'cost') Then
    list.addAll(self, 'cost', FCostList);
  if (child_name = 'monitoringProgram') Then
    list.addAll(self, 'monitoringProgram', FMonitoringProgramList);
  if (child_name = 'indicationGuideline') Then
    list.addAll(self, 'indicationGuideline', FIndicationGuidelineList);
  if (child_name = 'medicineClassification') Then
    list.addAll(self, 'medicineClassification', FMedicineClassificationList);
  if (child_name = 'packaging') Then
    list.addAll(self, 'packaging', FPackagingList);
  if (child_name = 'clinicalUseIssue') Then
    list.addAll(self, 'clinicalUseIssue', FClinicalUseIssueList);
  if (child_name = 'storageGuideline') Then
    list.addAll(self, 'storageGuideline', FStorageGuidelineList);
  if (child_name = 'regulatory') Then
    list.addAll(self, 'regulatory', FRegulatoryList);
  if (child_name = 'definitional') Then
     list.add(self.link, 'definitional', FDefinitional.Link);
end;

procedure TFhirMedicationKnowledge.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'code', 'CodeableConcept', false, TFhirCodeableConcept, FCode.Link));
  oList.add(TFHIRProperty.create(self, 'intendedJurisdiction', 'CodeableConcept', true, TFhirCodeableConcept, FIntendedJurisdictionList.Link));
  oList.add(TFHIRProperty.create(self, 'relatedMedicationKnowledge', 'BackboneElement', true, TFhirMedicationKnowledgeRelatedMedicationKnowledge, FRelatedMedicationKnowledgeList.Link));
  oList.add(TFHIRProperty.create(self, 'associatedMedication', 'Reference', true, TFhirReference, FAssociatedMedicationList.Link));
  oList.add(TFHIRProperty.create(self, 'productType', 'CodeableConcept', true, TFhirCodeableConcept, FProductTypeList.Link));
  oList.add(TFHIRProperty.create(self, 'monograph', 'BackboneElement', true, TFhirMedicationKnowledgeMonograph, FMonographList.Link));
  oList.add(TFHIRProperty.create(self, 'preparationInstruction', 'markdown', false, TFhirMarkdown, FPreparationInstruction.Link));
  oList.add(TFHIRProperty.create(self, 'cost', 'BackboneElement', true, TFhirMedicationKnowledgeCost, FCostList.Link));
  oList.add(TFHIRProperty.create(self, 'monitoringProgram', 'BackboneElement', true, TFhirMedicationKnowledgeMonitoringProgram, FMonitoringProgramList.Link));
  oList.add(TFHIRProperty.create(self, 'indicationGuideline', 'BackboneElement', true, TFhirMedicationKnowledgeIndicationGuideline, FIndicationGuidelineList.Link));
  oList.add(TFHIRProperty.create(self, 'medicineClassification', 'BackboneElement', true, TFhirMedicationKnowledgeMedicineClassification, FMedicineClassificationList.Link));
  oList.add(TFHIRProperty.create(self, 'packaging', 'BackboneElement', true, TFhirMedicationKnowledgePackaging, FPackagingList.Link));
  oList.add(TFHIRProperty.create(self, 'clinicalUseIssue', 'Reference', true, TFhirReference, FClinicalUseIssueList.Link));
  oList.add(TFHIRProperty.create(self, 'storageGuideline', 'BackboneElement', true, TFhirMedicationKnowledgeStorageGuideline, FStorageGuidelineList.Link));
  oList.add(TFHIRProperty.create(self, 'regulatory', 'BackboneElement', true, TFhirMedicationKnowledgeRegulatory, FRegulatoryList.Link));
  oList.add(TFHIRProperty.create(self, 'definitional', 'BackboneElement', false, TFhirMedicationKnowledgeDefinitional, FDefinitional.Link));
end;

function TFhirMedicationKnowledge.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'code') then
  begin
    Code := propValue as TFhirCodeableConcept;
    result := propValue;
  end
  else if (propName = 'intendedJurisdiction') then
  begin
    IntendedJurisdictionList.add(propValue as TFhirCodeableConcept);
    result := propValue;
  end
  else if (propName = 'relatedMedicationKnowledge') then
  begin
    RelatedMedicationKnowledgeList.add(propValue as TFhirMedicationKnowledgeRelatedMedicationKnowledge);
    result := propValue;
  end
  else if (propName = 'associatedMedication') then
  begin
    AssociatedMedicationList.add(propValue as TFhirReference);
    result := propValue;
  end
  else if (propName = 'productType') then
  begin
    ProductTypeList.add(propValue as TFhirCodeableConcept);
    result := propValue;
  end
  else if (propName = 'monograph') then
  begin
    MonographList.add(propValue as TFhirMedicationKnowledgeMonograph);
    result := propValue;
  end
  else if (propName = 'preparationInstruction') then
  begin
    PreparationInstructionElement := asMarkdown(propValue);
    result := propValue;
  end
  else if (propName = 'cost') then
  begin
    CostList.add(propValue as TFhirMedicationKnowledgeCost);
    result := propValue;
  end
  else if (propName = 'monitoringProgram') then
  begin
    MonitoringProgramList.add(propValue as TFhirMedicationKnowledgeMonitoringProgram);
    result := propValue;
  end
  else if (propName = 'indicationGuideline') then
  begin
    IndicationGuidelineList.add(propValue as TFhirMedicationKnowledgeIndicationGuideline);
    result := propValue;
  end
  else if (propName = 'medicineClassification') then
  begin
    MedicineClassificationList.add(propValue as TFhirMedicationKnowledgeMedicineClassification);
    result := propValue;
  end
  else if (propName = 'packaging') then
  begin
    PackagingList.add(propValue as TFhirMedicationKnowledgePackaging);
    result := propValue;
  end
  else if (propName = 'clinicalUseIssue') then
  begin
    ClinicalUseIssueList.add(propValue as TFhirReference);
    result := propValue;
  end
  else if (propName = 'storageGuideline') then
  begin
    StorageGuidelineList.add(propValue as TFhirMedicationKnowledgeStorageGuideline);
    result := propValue;
  end
  else if (propName = 'regulatory') then
  begin
    RegulatoryList.add(propValue as TFhirMedicationKnowledgeRegulatory);
    result := propValue;
  end
  else if (propName = 'definitional') then
  begin
    Definitional := propValue as TFhirMedicationKnowledgeDefinitional;
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirMedicationKnowledge.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'intendedJurisdiction') then IntendedJurisdictionList.insertItem(index, propValue as TFhirCodeableConcept)
  else if (propName = 'relatedMedicationKnowledge') then RelatedMedicationKnowledgeList.insertItem(index, propValue as TFhirMedicationKnowledgeRelatedMedicationKnowledge)
  else if (propName = 'associatedMedication') then AssociatedMedicationList.insertItem(index, propValue as TFhirReference)
  else if (propName = 'productType') then ProductTypeList.insertItem(index, propValue as TFhirCodeableConcept)
  else if (propName = 'monograph') then MonographList.insertItem(index, propValue as TFhirMedicationKnowledgeMonograph)
  else if (propName = 'cost') then CostList.insertItem(index, propValue as TFhirMedicationKnowledgeCost)
  else if (propName = 'monitoringProgram') then MonitoringProgramList.insertItem(index, propValue as TFhirMedicationKnowledgeMonitoringProgram)
  else if (propName = 'indicationGuideline') then IndicationGuidelineList.insertItem(index, propValue as TFhirMedicationKnowledgeIndicationGuideline)
  else if (propName = 'medicineClassification') then MedicineClassificationList.insertItem(index, propValue as TFhirMedicationKnowledgeMedicineClassification)
  else if (propName = 'packaging') then PackagingList.insertItem(index, propValue as TFhirMedicationKnowledgePackaging)
  else if (propName = 'clinicalUseIssue') then ClinicalUseIssueList.insertItem(index, propValue as TFhirReference)
  else if (propName = 'storageGuideline') then StorageGuidelineList.insertItem(index, propValue as TFhirMedicationKnowledgeStorageGuideline)
  else if (propName = 'regulatory') then RegulatoryList.insertItem(index, propValue as TFhirMedicationKnowledgeRegulatory)
  else inherited;
end;

function TFhirMedicationKnowledge.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'code') then result := TFhirCodeableConcept.create()
  else if (propName = 'intendedJurisdiction') then result := IntendedJurisdictionList.new()
  else if (propName = 'relatedMedicationKnowledge') then result := RelatedMedicationKnowledgeList.new()
  else if (propName = 'associatedMedication') then result := AssociatedMedicationList.new()
  else if (propName = 'productType') then result := ProductTypeList.new()
  else if (propName = 'monograph') then result := MonographList.new()
  else if (propName = 'preparationInstruction') then result := TFhirMarkdown.create()
  else if (propName = 'cost') then result := CostList.new()
  else if (propName = 'monitoringProgram') then result := MonitoringProgramList.new()
  else if (propName = 'indicationGuideline') then result := IndicationGuidelineList.new()
  else if (propName = 'medicineClassification') then result := MedicineClassificationList.new()
  else if (propName = 'packaging') then result := PackagingList.new()
  else if (propName = 'clinicalUseIssue') then result := ClinicalUseIssueList.new()
  else if (propName = 'storageGuideline') then result := StorageGuidelineList.new()
  else if (propName = 'regulatory') then result := RegulatoryList.new()
  else if (propName = 'definitional') then result := TFhirMedicationKnowledgeDefinitional.create()
  else result := inherited createPropertyValue(propName);
end;

function TFhirMedicationKnowledge.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'code') then result := 'CodeableConcept'
  else if (propName = 'intendedJurisdiction') then result := 'CodeableConcept'
  else if (propName = 'relatedMedicationKnowledge') then result := 'BackboneElement'
  else if (propName = 'associatedMedication') then result := 'Reference'
  else if (propName = 'productType') then result := 'CodeableConcept'
  else if (propName = 'monograph') then result := 'BackboneElement'
  else if (propName = 'preparationInstruction') then result := 'markdown'
  else if (propName = 'cost') then result := 'BackboneElement'
  else if (propName = 'monitoringProgram') then result := 'BackboneElement'
  else if (propName = 'indicationGuideline') then result := 'BackboneElement'
  else if (propName = 'medicineClassification') then result := 'BackboneElement'
  else if (propName = 'packaging') then result := 'BackboneElement'
  else if (propName = 'clinicalUseIssue') then result := 'Reference'
  else if (propName = 'storageGuideline') then result := 'BackboneElement'
  else if (propName = 'regulatory') then result := 'BackboneElement'
  else if (propName = 'definitional') then result := 'BackboneElement'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirMedicationKnowledge.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'code') then CodeElement := nil
  else if (propName = 'intendedJurisdiction') then deletePropertyValue('intendedJurisdiction', IntendedJurisdictionList, value)
  else if (propName = 'relatedMedicationKnowledge') then deletePropertyValue('relatedMedicationKnowledge', RelatedMedicationKnowledgeList, value)
  else if (propName = 'associatedMedication') then deletePropertyValue('associatedMedication', AssociatedMedicationList, value)
  else if (propName = 'productType') then deletePropertyValue('productType', ProductTypeList, value)
  else if (propName = 'monograph') then deletePropertyValue('monograph', MonographList, value)
  else if (propName = 'preparationInstruction') then PreparationInstructionElement := nil
  else if (propName = 'cost') then deletePropertyValue('cost', CostList, value)
  else if (propName = 'monitoringProgram') then deletePropertyValue('monitoringProgram', MonitoringProgramList, value)
  else if (propName = 'indicationGuideline') then deletePropertyValue('indicationGuideline', IndicationGuidelineList, value)
  else if (propName = 'medicineClassification') then deletePropertyValue('medicineClassification', MedicineClassificationList, value)
  else if (propName = 'packaging') then deletePropertyValue('packaging', PackagingList, value)
  else if (propName = 'clinicalUseIssue') then deletePropertyValue('clinicalUseIssue', ClinicalUseIssueList, value)
  else if (propName = 'storageGuideline') then deletePropertyValue('storageGuideline', StorageGuidelineList, value)
  else if (propName = 'regulatory') then deletePropertyValue('regulatory', RegulatoryList, value)
  else if (propName = 'definitional') then DefinitionalElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirMedicationKnowledge.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'code') then CodeElement := new as TFhirCodeableConcept
  else if (propName = 'intendedJurisdiction') then replacePropertyValue('intendedJurisdiction', IntendedJurisdictionList, existing, new)
  else if (propName = 'relatedMedicationKnowledge') then replacePropertyValue('relatedMedicationKnowledge', RelatedMedicationKnowledgeList, existing, new)
  else if (propName = 'associatedMedication') then replacePropertyValue('associatedMedication', AssociatedMedicationList, existing, new)
  else if (propName = 'productType') then replacePropertyValue('productType', ProductTypeList, existing, new)
  else if (propName = 'monograph') then replacePropertyValue('monograph', MonographList, existing, new)
  else if (propName = 'preparationInstruction') then PreparationInstructionElement := asMarkdown(new)
  else if (propName = 'cost') then replacePropertyValue('cost', CostList, existing, new)
  else if (propName = 'monitoringProgram') then replacePropertyValue('monitoringProgram', MonitoringProgramList, existing, new)
  else if (propName = 'indicationGuideline') then replacePropertyValue('indicationGuideline', IndicationGuidelineList, existing, new)
  else if (propName = 'medicineClassification') then replacePropertyValue('medicineClassification', MedicineClassificationList, existing, new)
  else if (propName = 'packaging') then replacePropertyValue('packaging', PackagingList, existing, new)
  else if (propName = 'clinicalUseIssue') then replacePropertyValue('clinicalUseIssue', ClinicalUseIssueList, existing, new)
  else if (propName = 'storageGuideline') then replacePropertyValue('storageGuideline', StorageGuidelineList, existing, new)
  else if (propName = 'regulatory') then replacePropertyValue('regulatory', RegulatoryList, existing, new)
  else if (propName = 'definitional') then DefinitionalElement := new as TFhirMedicationKnowledgeDefinitional
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirMedicationKnowledge.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'intendedJurisdiction') then IntendedJurisdictionList.move(source, destination)
  else if (propName = 'relatedMedicationKnowledge') then RelatedMedicationKnowledgeList.move(source, destination)
  else if (propName = 'associatedMedication') then AssociatedMedicationList.move(source, destination)
  else if (propName = 'productType') then ProductTypeList.move(source, destination)
  else if (propName = 'monograph') then MonographList.move(source, destination)
  else if (propName = 'cost') then CostList.move(source, destination)
  else if (propName = 'monitoringProgram') then MonitoringProgramList.move(source, destination)
  else if (propName = 'indicationGuideline') then IndicationGuidelineList.move(source, destination)
  else if (propName = 'medicineClassification') then MedicineClassificationList.move(source, destination)
  else if (propName = 'packaging') then PackagingList.move(source, destination)
  else if (propName = 'clinicalUseIssue') then ClinicalUseIssueList.move(source, destination)
  else if (propName = 'storageGuideline') then StorageGuidelineList.move(source, destination)
  else if (propName = 'regulatory') then RegulatoryList.move(source, destination)
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirMedicationKnowledge.fhirType : string;
begin
  result := 'MedicationKnowledge';
end;

function TFhirMedicationKnowledge.Link : TFhirMedicationKnowledge;
begin
  result := TFhirMedicationKnowledge(inherited Link);
end;

function TFhirMedicationKnowledge.Clone : TFhirMedicationKnowledge;
begin
  result := TFhirMedicationKnowledge(inherited Clone);
end;

function TFhirMedicationKnowledge.equals(other : TObject) : boolean; 
var
  o : TFhirMedicationKnowledge;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirMedicationKnowledge)) then
    result := false
  else
  begin
    o := TFhirMedicationKnowledge(other);
    result := compareDeep(codeElement, o.codeElement, true) and compareDeep(intendedJurisdictionList, o.intendedJurisdictionList, true) and 
      compareDeep(relatedMedicationKnowledgeList, o.relatedMedicationKnowledgeList, true) and 
      compareDeep(associatedMedicationList, o.associatedMedicationList, true) and compareDeep(productTypeList, o.productTypeList, true) and 
      compareDeep(monographList, o.monographList, true) and compareDeep(preparationInstructionElement, o.preparationInstructionElement, true) and 
      compareDeep(costList, o.costList, true) and compareDeep(monitoringProgramList, o.monitoringProgramList, true) and 
      compareDeep(indicationGuidelineList, o.indicationGuidelineList, true) and compareDeep(medicineClassificationList, o.medicineClassificationList, true) and 
      compareDeep(packagingList, o.packagingList, true) and compareDeep(clinicalUseIssueList, o.clinicalUseIssueList, true) and 
      compareDeep(storageGuidelineList, o.storageGuidelineList, true) and compareDeep(regulatoryList, o.regulatoryList, true) and 
      compareDeep(definitionalElement, o.definitionalElement, true);
  end;
end;

function TFhirMedicationKnowledge.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FCode) and isEmptyProp(FintendedJurisdictionList) and isEmptyProp(FrelatedMedicationKnowledgeList) and isEmptyProp(FassociatedMedicationList) and isEmptyProp(FproductTypeList) and isEmptyProp(FmonographList) and isEmptyProp(FPreparationInstruction) and isEmptyProp(FcostList) and isEmptyProp(FmonitoringProgramList) and isEmptyProp(FindicationGuidelineList) and isEmptyProp(FmedicineClassificationList) and isEmptyProp(FpackagingList) and isEmptyProp(FclinicalUseIssueList) and isEmptyProp(FstorageGuidelineList) and isEmptyProp(FregulatoryList) and isEmptyProp(FDefinitional);
end;

procedure TFhirMedicationKnowledge.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('identifier');
  fields.add('code');
  fields.add('status');
  fields.add('author');
  fields.add('intendedJurisdiction');
  fields.add('name');
  fields.add('relatedMedicationKnowledge');
  fields.add('associatedMedication');
  fields.add('productType');
  fields.add('monograph');
  fields.add('preparationInstruction');
  fields.add('cost');
  fields.add('monitoringProgram');
  fields.add('indicationGuideline');
  fields.add('medicineClassification');
  fields.add('packaging');
  fields.add('clinicalUseIssue');
  fields.add('storageGuideline');
  fields.add('regulatory');
  fields.add('definitional');
end;

function TFhirMedicationKnowledge.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
  inc(result, FIntendedJurisdictionList.sizeInBytes(magic));
  inc(result, FRelatedMedicationKnowledgeList.sizeInBytes(magic));
  inc(result, FAssociatedMedicationList.sizeInBytes(magic));
  inc(result, FProductTypeList.sizeInBytes(magic));
  inc(result, FMonographList.sizeInBytes(magic));
  inc(result, FCostList.sizeInBytes(magic));
  inc(result, FMonitoringProgramList.sizeInBytes(magic));
  inc(result, FIndicationGuidelineList.sizeInBytes(magic));
  inc(result, FMedicineClassificationList.sizeInBytes(magic));
  inc(result, FPackagingList.sizeInBytes(magic));
  inc(result, FClinicalUseIssueList.sizeInBytes(magic));
  inc(result, FStorageGuidelineList.sizeInBytes(magic));
  inc(result, FRegulatoryList.sizeInBytes(magic));
end;

function TFhirMedicationKnowledge.GetIdentifierList : TFhirIdentifierList;
begin
  if FIdentifierList = nil then
    FIdentifierList := TFhirIdentifierList.Create;
  result := FIdentifierList;
end;

function TFhirMedicationKnowledge.GetHasIdentifierList : boolean;
begin
  result := (FIdentifierList <> nil) and (FIdentifierList.count > 0);
end;

procedure TFhirMedicationKnowledge.SetCode(value : TFhirCodeableConcept);
begin
  FCode.free;
  FCode := value;
end;

procedure TFhirMedicationKnowledge.SetStatus(value : TFhirEnum);
begin
  FStatus.free;
  FStatus := value;
end;

function TFhirMedicationKnowledge.GetStatusST : TFhirMedicationKnowledgeStatusCodesEnum;
begin
  if FStatus = nil then
    result := TFhirMedicationKnowledgeStatusCodesEnum(0)
  else
    result := TFhirMedicationKnowledgeStatusCodesEnum(StringArrayIndexOfSensitive(CODES_TFhirMedicationKnowledgeStatusCodesEnum, FStatus.value));
end;

procedure TFhirMedicationKnowledge.SetStatusST(value : TFhirMedicationKnowledgeStatusCodesEnum);
begin
  if ord(value) = 0 then
    StatusElement := nil
  else
    StatusElement := TFhirEnum.create(SYSTEMS_TFhirMedicationKnowledgeStatusCodesEnum[value], CODES_TFhirMedicationKnowledgeStatusCodesEnum[value]);
end;

function TFhirMedicationKnowledge.GetAuthor : TFhirContactDetail;
begin
  if FAuthorList = nil then
    result := nil
  else if FAuthorList.count > 0 then
    result := FAuthorList[0]
  else
    result := nil;
end;

procedure TFhirMedicationKnowledge.SetAuthor(value : TFhirContactDetail);
begin
  if FAuthorList = nil then
    FAuthorList := TFhirContactDetailList.create;
  FAuthorList.clear;
  if (value <> nil) then
    FAuthorList.add(value);
end;

function TFhirMedicationKnowledge.GetIntendedJurisdictionList : TFhirCodeableConceptList;
begin
  if FIntendedJurisdictionList = nil then
    FIntendedJurisdictionList := TFhirCodeableConceptList.Create;
  result := FIntendedJurisdictionList;
end;

function TFhirMedicationKnowledge.GetHasIntendedJurisdictionList : boolean;
begin
  result := (FIntendedJurisdictionList <> nil) and (FIntendedJurisdictionList.count > 0);
end;

function TFhirMedicationKnowledge.GetNameList : TFhirStringList;
begin
  result := nil;
end;

function TFhirMedicationKnowledge.GetHasNameList : boolean;
begin
  result := false;
end;

function TFhirMedicationKnowledge.GetRelatedMedicationKnowledgeList : TFhirMedicationKnowledgeRelatedMedicationKnowledgeList;
begin
  if FRelatedMedicationKnowledgeList = nil then
    FRelatedMedicationKnowledgeList := TFhirMedicationKnowledgeRelatedMedicationKnowledgeList.Create;
  result := FRelatedMedicationKnowledgeList;
end;

function TFhirMedicationKnowledge.GetHasRelatedMedicationKnowledgeList : boolean;
begin
  result := (FRelatedMedicationKnowledgeList <> nil) and (FRelatedMedicationKnowledgeList.count > 0);
end;

function TFhirMedicationKnowledge.GetAssociatedMedicationList : TFhirReferenceList;
begin
  if FAssociatedMedicationList = nil then
    FAssociatedMedicationList := TFhirReferenceList.Create;
  result := FAssociatedMedicationList;
end;

function TFhirMedicationKnowledge.GetHasAssociatedMedicationList : boolean;
begin
  result := (FAssociatedMedicationList <> nil) and (FAssociatedMedicationList.count > 0);
end;

function TFhirMedicationKnowledge.GetProductTypeList : TFhirCodeableConceptList;
begin
  if FProductTypeList = nil then
    FProductTypeList := TFhirCodeableConceptList.Create;
  result := FProductTypeList;
end;

function TFhirMedicationKnowledge.GetHasProductTypeList : boolean;
begin
  result := (FProductTypeList <> nil) and (FProductTypeList.count > 0);
end;

function TFhirMedicationKnowledge.GetMonographList : TFhirMedicationKnowledgeMonographList;
begin
  if FMonographList = nil then
    FMonographList := TFhirMedicationKnowledgeMonographList.Create;
  result := FMonographList;
end;

function TFhirMedicationKnowledge.GetHasMonographList : boolean;
begin
  result := (FMonographList <> nil) and (FMonographList.count > 0);
end;

procedure TFhirMedicationKnowledge.SetPreparationInstruction(value : TFhirMarkdown);
begin
  FPreparationInstruction.free;
  FPreparationInstruction := value;
end;

function TFhirMedicationKnowledge.GetPreparationInstructionST : String;
begin
  if FPreparationInstruction = nil then
    result := ''
  else
    result := FPreparationInstruction.value;
end;

procedure TFhirMedicationKnowledge.SetPreparationInstructionST(value : String);
begin
  if value <> '' then
  begin
    if FPreparationInstruction = nil then
      FPreparationInstruction := TFhirMarkdown.create;
    FPreparationInstruction.value := value
  end
  else if FPreparationInstruction <> nil then
    FPreparationInstruction.value := '';
end;

function TFhirMedicationKnowledge.GetCostList : TFhirMedicationKnowledgeCostList;
begin
  if FCostList = nil then
    FCostList := TFhirMedicationKnowledgeCostList.Create;
  result := FCostList;
end;

function TFhirMedicationKnowledge.GetHasCostList : boolean;
begin
  result := (FCostList <> nil) and (FCostList.count > 0);
end;

function TFhirMedicationKnowledge.GetMonitoringProgramList : TFhirMedicationKnowledgeMonitoringProgramList;
begin
  if FMonitoringProgramList = nil then
    FMonitoringProgramList := TFhirMedicationKnowledgeMonitoringProgramList.Create;
  result := FMonitoringProgramList;
end;

function TFhirMedicationKnowledge.GetHasMonitoringProgramList : boolean;
begin
  result := (FMonitoringProgramList <> nil) and (FMonitoringProgramList.count > 0);
end;

function TFhirMedicationKnowledge.GetIndicationGuidelineList : TFhirMedicationKnowledgeIndicationGuidelineList;
begin
  if FIndicationGuidelineList = nil then
    FIndicationGuidelineList := TFhirMedicationKnowledgeIndicationGuidelineList.Create;
  result := FIndicationGuidelineList;
end;

function TFhirMedicationKnowledge.GetHasIndicationGuidelineList : boolean;
begin
  result := (FIndicationGuidelineList <> nil) and (FIndicationGuidelineList.count > 0);
end;

function TFhirMedicationKnowledge.GetMedicineClassificationList : TFhirMedicationKnowledgeMedicineClassificationList;
begin
  if FMedicineClassificationList = nil then
    FMedicineClassificationList := TFhirMedicationKnowledgeMedicineClassificationList.Create;
  result := FMedicineClassificationList;
end;

function TFhirMedicationKnowledge.GetHasMedicineClassificationList : boolean;
begin
  result := (FMedicineClassificationList <> nil) and (FMedicineClassificationList.count > 0);
end;

function TFhirMedicationKnowledge.GetPackagingList : TFhirMedicationKnowledgePackagingList;
begin
  if FPackagingList = nil then
    FPackagingList := TFhirMedicationKnowledgePackagingList.Create;
  result := FPackagingList;
end;

function TFhirMedicationKnowledge.GetHasPackagingList : boolean;
begin
  result := (FPackagingList <> nil) and (FPackagingList.count > 0);
end;

function TFhirMedicationKnowledge.GetClinicalUseIssueList : TFhirReferenceList;
begin
  if FClinicalUseIssueList = nil then
    FClinicalUseIssueList := TFhirReferenceList.Create;
  result := FClinicalUseIssueList;
end;

function TFhirMedicationKnowledge.GetHasClinicalUseIssueList : boolean;
begin
  result := (FClinicalUseIssueList <> nil) and (FClinicalUseIssueList.count > 0);
end;

function TFhirMedicationKnowledge.GetStorageGuidelineList : TFhirMedicationKnowledgeStorageGuidelineList;
begin
  if FStorageGuidelineList = nil then
    FStorageGuidelineList := TFhirMedicationKnowledgeStorageGuidelineList.Create;
  result := FStorageGuidelineList;
end;

function TFhirMedicationKnowledge.GetHasStorageGuidelineList : boolean;
begin
  result := (FStorageGuidelineList <> nil) and (FStorageGuidelineList.count > 0);
end;

function TFhirMedicationKnowledge.GetRegulatoryList : TFhirMedicationKnowledgeRegulatoryList;
begin
  if FRegulatoryList = nil then
    FRegulatoryList := TFhirMedicationKnowledgeRegulatoryList.Create;
  result := FRegulatoryList;
end;

function TFhirMedicationKnowledge.GetHasRegulatoryList : boolean;
begin
  result := (FRegulatoryList <> nil) and (FRegulatoryList.count > 0);
end;

procedure TFhirMedicationKnowledge.SetDefinitional(value : TFhirMedicationKnowledgeDefinitional);
begin
  FDefinitional.free;
  FDefinitional := value;
end;

{ TFhirMedicationKnowledgeListEnumerator }

constructor TFhirMedicationKnowledgeListEnumerator.Create(list : TFhirMedicationKnowledgeList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirMedicationKnowledgeListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirMedicationKnowledgeListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirMedicationKnowledgeListEnumerator.GetCurrent : TFhirMedicationKnowledge;
begin
  Result := FList[FIndex];
end;

function TFhirMedicationKnowledgeListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirMedicationKnowledgeList }

function TFhirMedicationKnowledgeList.AddItem(value: TFhirMedicationKnowledge): TFhirMedicationKnowledge;
begin
  assert(value.ClassName = 'TFhirMedicationKnowledge', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirMedicationKnowledge');
  add(value);
  result := value;
end;

function TFhirMedicationKnowledgeList.Append: TFhirMedicationKnowledge;
begin
  result := TFhirMedicationKnowledge.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirMedicationKnowledgeList.ClearItems;
begin
  Clear;
end;

function TFhirMedicationKnowledgeList.GetEnumerator : TFhirMedicationKnowledgeListEnumerator;
begin
  result := TFhirMedicationKnowledgeListEnumerator.Create(self.link);
end;

function TFhirMedicationKnowledgeList.Clone: TFhirMedicationKnowledgeList;
begin
  result := TFhirMedicationKnowledgeList(inherited Clone);
end;

function TFhirMedicationKnowledgeList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirMedicationKnowledgeList.GetItemN(index: Integer): TFhirMedicationKnowledge;
begin
  result := TFhirMedicationKnowledge(ObjectByIndex[index]);
end;

function TFhirMedicationKnowledgeList.ItemClass: TFslObjectClass;
begin
  result := TFhirMedicationKnowledge;
end;
function TFhirMedicationKnowledgeList.IndexOf(value: TFhirMedicationKnowledge): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirMedicationKnowledgeList.Insert(index: Integer): TFhirMedicationKnowledge;
begin
  result := TFhirMedicationKnowledge.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirMedicationKnowledgeList.InsertItem(index: Integer; value: TFhirMedicationKnowledge);
begin
  assert(value is TFhirMedicationKnowledge);
  Inherited Insert(index, value);
end;

function TFhirMedicationKnowledgeList.Item(index: Integer): TFhirMedicationKnowledge;
begin
  result := TFhirMedicationKnowledge(ObjectByIndex[index]);
end;

function TFhirMedicationKnowledgeList.Link: TFhirMedicationKnowledgeList;
begin
  result := TFhirMedicationKnowledgeList(inherited Link);
end;

procedure TFhirMedicationKnowledgeList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirMedicationKnowledgeList.SetItemByIndex(index: Integer; value: TFhirMedicationKnowledge);
begin
  assert(value is TFhirMedicationKnowledge);
  FhirMedicationKnowledges[index] := value;
end;

procedure TFhirMedicationKnowledgeList.SetItemN(index: Integer; value: TFhirMedicationKnowledge);
begin
  assert(value is TFhirMedicationKnowledge);
  ObjectByIndex[index] := value;
end;

{$ENDIF FHIR_MEDICATIONKNOWLEDGE}
{$IFDEF FHIR_MEDICINALPRODUCTDEFINITION}
{ TFhirMedicinalProductDefinitionContact }

constructor TFhirMedicinalProductDefinitionContact.Create;
begin
  inherited;
end;

destructor TFhirMedicinalProductDefinitionContact.Destroy;
begin
  FType_.free;
  FContact.free;
  inherited;
end;

procedure TFhirMedicinalProductDefinitionContact.Assign(oSource : TFslObject);
begin
  inherited;
  type_ := TFhirMedicinalProductDefinitionContact(oSource).type_.Clone;
  contact := TFhirMedicinalProductDefinitionContact(oSource).contact.Clone;
end;

procedure TFhirMedicinalProductDefinitionContact.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'type') Then
     list.add(self.link, 'type', FType_.Link);
  if (child_name = 'contact') Then
     list.add(self.link, 'contact', FContact.Link);
end;

procedure TFhirMedicinalProductDefinitionContact.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'type', 'CodeableConcept', false, TFhirCodeableConcept, FType_.Link));
  oList.add(TFHIRProperty.create(self, 'contact', 'Reference', false, TFhirReference, FContact.Link));
end;

function TFhirMedicinalProductDefinitionContact.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'type') then
  begin
    Type_ := propValue as TFhirCodeableConcept;
    result := propValue;
  end
  else if (propName = 'contact') then
  begin
    Contact := propValue as TFhirReference;
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirMedicinalProductDefinitionContact.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirMedicinalProductDefinitionContact.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'type') then result := TFhirCodeableConcept.create()
  else if (propName = 'contact') then result := TFhirReference.create()
  else result := inherited createPropertyValue(propName);
end;

function TFhirMedicinalProductDefinitionContact.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'type') then result := 'CodeableConcept'
  else if (propName = 'contact') then result := 'Reference'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirMedicinalProductDefinitionContact.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'type') then Type_Element := nil
  else if (propName = 'contact') then ContactElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirMedicinalProductDefinitionContact.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'type') then Type_Element := new as TFhirCodeableConcept
  else if (propName = 'contact') then ContactElement := new as TFhirReference
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirMedicinalProductDefinitionContact.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirMedicinalProductDefinitionContact.fhirType : string;
begin
  result := 'MedicinalProductDefinition.contact';
end;

function TFhirMedicinalProductDefinitionContact.Link : TFhirMedicinalProductDefinitionContact;
begin
  result := TFhirMedicinalProductDefinitionContact(inherited Link);
end;

function TFhirMedicinalProductDefinitionContact.Clone : TFhirMedicinalProductDefinitionContact;
begin
  result := TFhirMedicinalProductDefinitionContact(inherited Clone);
end;

function TFhirMedicinalProductDefinitionContact.equals(other : TObject) : boolean; 
var
  o : TFhirMedicinalProductDefinitionContact;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirMedicinalProductDefinitionContact)) then
    result := false
  else
  begin
    o := TFhirMedicinalProductDefinitionContact(other);
    result := compareDeep(type_Element, o.type_Element, true) and compareDeep(contactElement, o.contactElement, true);
  end;
end;

function TFhirMedicinalProductDefinitionContact.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FType_) and isEmptyProp(FContact);
end;

procedure TFhirMedicinalProductDefinitionContact.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('type');
  fields.add('contact');
end;

function TFhirMedicinalProductDefinitionContact.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
end;

procedure TFhirMedicinalProductDefinitionContact.SetType_(value : TFhirCodeableConcept);
begin
  FType_.free;
  FType_ := value;
end;

procedure TFhirMedicinalProductDefinitionContact.SetContact(value : TFhirReference);
begin
  FContact.free;
  FContact := value;
end;

{ TFhirMedicinalProductDefinitionContactListEnumerator }

constructor TFhirMedicinalProductDefinitionContactListEnumerator.Create(list : TFhirMedicinalProductDefinitionContactList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirMedicinalProductDefinitionContactListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirMedicinalProductDefinitionContactListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirMedicinalProductDefinitionContactListEnumerator.GetCurrent : TFhirMedicinalProductDefinitionContact;
begin
  Result := FList[FIndex];
end;

function TFhirMedicinalProductDefinitionContactListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirMedicinalProductDefinitionContactList }

function TFhirMedicinalProductDefinitionContactList.AddItem(value: TFhirMedicinalProductDefinitionContact): TFhirMedicinalProductDefinitionContact;
begin
  assert(value.ClassName = 'TFhirMedicinalProductDefinitionContact', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirMedicinalProductDefinitionContact');
  add(value);
  result := value;
end;

function TFhirMedicinalProductDefinitionContactList.Append: TFhirMedicinalProductDefinitionContact;
begin
  result := TFhirMedicinalProductDefinitionContact.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirMedicinalProductDefinitionContactList.ClearItems;
begin
  Clear;
end;

function TFhirMedicinalProductDefinitionContactList.GetEnumerator : TFhirMedicinalProductDefinitionContactListEnumerator;
begin
  result := TFhirMedicinalProductDefinitionContactListEnumerator.Create(self.link);
end;

function TFhirMedicinalProductDefinitionContactList.Clone: TFhirMedicinalProductDefinitionContactList;
begin
  result := TFhirMedicinalProductDefinitionContactList(inherited Clone);
end;

function TFhirMedicinalProductDefinitionContactList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirMedicinalProductDefinitionContactList.GetItemN(index: Integer): TFhirMedicinalProductDefinitionContact;
begin
  result := TFhirMedicinalProductDefinitionContact(ObjectByIndex[index]);
end;

function TFhirMedicinalProductDefinitionContactList.ItemClass: TFslObjectClass;
begin
  result := TFhirMedicinalProductDefinitionContact;
end;
function TFhirMedicinalProductDefinitionContactList.IndexOf(value: TFhirMedicinalProductDefinitionContact): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirMedicinalProductDefinitionContactList.Insert(index: Integer): TFhirMedicinalProductDefinitionContact;
begin
  result := TFhirMedicinalProductDefinitionContact.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirMedicinalProductDefinitionContactList.InsertItem(index: Integer; value: TFhirMedicinalProductDefinitionContact);
begin
  assert(value is TFhirMedicinalProductDefinitionContact);
  Inherited Insert(index, value);
end;

function TFhirMedicinalProductDefinitionContactList.Item(index: Integer): TFhirMedicinalProductDefinitionContact;
begin
  result := TFhirMedicinalProductDefinitionContact(ObjectByIndex[index]);
end;

function TFhirMedicinalProductDefinitionContactList.Link: TFhirMedicinalProductDefinitionContactList;
begin
  result := TFhirMedicinalProductDefinitionContactList(inherited Link);
end;

procedure TFhirMedicinalProductDefinitionContactList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirMedicinalProductDefinitionContactList.SetItemByIndex(index: Integer; value: TFhirMedicinalProductDefinitionContact);
begin
  assert(value is TFhirMedicinalProductDefinitionContact);
  FhirMedicinalProductDefinitionContacts[index] := value;
end;

procedure TFhirMedicinalProductDefinitionContactList.SetItemN(index: Integer; value: TFhirMedicinalProductDefinitionContact);
begin
  assert(value is TFhirMedicinalProductDefinitionContact);
  ObjectByIndex[index] := value;
end;

{ TFhirMedicinalProductDefinitionName }

constructor TFhirMedicinalProductDefinitionName.Create;
begin
  inherited;
end;

destructor TFhirMedicinalProductDefinitionName.Destroy;
begin
  FProductName.free;
  FType_.free;
  FPartList.Free;
  FUsageList.Free;
  inherited;
end;

procedure TFhirMedicinalProductDefinitionName.Assign(oSource : TFslObject);
begin
  inherited;
  productNameElement := TFhirMedicinalProductDefinitionName(oSource).productNameElement.Clone;
  type_ := TFhirMedicinalProductDefinitionName(oSource).type_.Clone;
  if (TFhirMedicinalProductDefinitionName(oSource).FPartList = nil) then
  begin
    FPartList.free;
    FPartList := nil;
  end
  else
  begin
    if FPartList = nil then
      FPartList := TFhirMedicinalProductDefinitionNamePartList.Create;
    FPartList.Assign(TFhirMedicinalProductDefinitionName(oSource).FPartList);
  end;
  if (TFhirMedicinalProductDefinitionName(oSource).FUsageList = nil) then
  begin
    FUsageList.free;
    FUsageList := nil;
  end
  else
  begin
    if FUsageList = nil then
      FUsageList := TFhirMedicinalProductDefinitionNameUsageList.Create;
    FUsageList.Assign(TFhirMedicinalProductDefinitionName(oSource).FUsageList);
  end;
end;

procedure TFhirMedicinalProductDefinitionName.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'productName') Then
     list.add(self.link, 'productName', FProductName.Link);
  if (child_name = 'type') Then
     list.add(self.link, 'type', FType_.Link);
  if (child_name = 'part') Then
    list.addAll(self, 'part', FPartList);
  if (child_name = 'usage') Then
    list.addAll(self, 'usage', FUsageList);
end;

procedure TFhirMedicinalProductDefinitionName.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'productName', 'string', false, TFhirString, FProductName.Link));
  oList.add(TFHIRProperty.create(self, 'type', 'CodeableConcept', false, TFhirCodeableConcept, FType_.Link));
  oList.add(TFHIRProperty.create(self, 'part', 'BackboneElement', true, TFhirMedicinalProductDefinitionNamePart, FPartList.Link));
  oList.add(TFHIRProperty.create(self, 'usage', 'BackboneElement', true, TFhirMedicinalProductDefinitionNameUsage, FUsageList.Link));
end;

function TFhirMedicinalProductDefinitionName.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'productName') then
  begin
    ProductNameElement := asString(propValue);
    result := propValue;
  end
  else if (propName = 'type') then
  begin
    Type_ := propValue as TFhirCodeableConcept;
    result := propValue;
  end
  else if (propName = 'part') then
  begin
    PartList.add(propValue as TFhirMedicinalProductDefinitionNamePart);
    result := propValue;
  end
  else if (propName = 'usage') then
  begin
    UsageList.add(propValue as TFhirMedicinalProductDefinitionNameUsage);
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirMedicinalProductDefinitionName.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'part') then PartList.insertItem(index, propValue as TFhirMedicinalProductDefinitionNamePart)
  else if (propName = 'usage') then UsageList.insertItem(index, propValue as TFhirMedicinalProductDefinitionNameUsage)
  else inherited;
end;

function TFhirMedicinalProductDefinitionName.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'productName') then result := TFhirString.create()
  else if (propName = 'type') then result := TFhirCodeableConcept.create()
  else if (propName = 'part') then result := PartList.new()
  else if (propName = 'usage') then result := UsageList.new()
  else result := inherited createPropertyValue(propName);
end;

function TFhirMedicinalProductDefinitionName.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'productName') then result := 'string'
  else if (propName = 'type') then result := 'CodeableConcept'
  else if (propName = 'part') then result := 'BackboneElement'
  else if (propName = 'usage') then result := 'BackboneElement'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirMedicinalProductDefinitionName.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'productName') then ProductNameElement := nil
  else if (propName = 'type') then Type_Element := nil
  else if (propName = 'part') then deletePropertyValue('part', PartList, value)
  else if (propName = 'usage') then deletePropertyValue('usage', UsageList, value)
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirMedicinalProductDefinitionName.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'productName') then ProductNameElement := asString(new)
  else if (propName = 'type') then Type_Element := new as TFhirCodeableConcept
  else if (propName = 'part') then replacePropertyValue('part', PartList, existing, new)
  else if (propName = 'usage') then replacePropertyValue('usage', UsageList, existing, new)
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirMedicinalProductDefinitionName.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'part') then PartList.move(source, destination)
  else if (propName = 'usage') then UsageList.move(source, destination)
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirMedicinalProductDefinitionName.fhirType : string;
begin
  result := 'MedicinalProductDefinition.name';
end;

function TFhirMedicinalProductDefinitionName.Link : TFhirMedicinalProductDefinitionName;
begin
  result := TFhirMedicinalProductDefinitionName(inherited Link);
end;

function TFhirMedicinalProductDefinitionName.Clone : TFhirMedicinalProductDefinitionName;
begin
  result := TFhirMedicinalProductDefinitionName(inherited Clone);
end;

function TFhirMedicinalProductDefinitionName.equals(other : TObject) : boolean; 
var
  o : TFhirMedicinalProductDefinitionName;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirMedicinalProductDefinitionName)) then
    result := false
  else
  begin
    o := TFhirMedicinalProductDefinitionName(other);
    result := compareDeep(productNameElement, o.productNameElement, true) and compareDeep(type_Element, o.type_Element, true) and 
      compareDeep(partList, o.partList, true) and compareDeep(usageList, o.usageList, true);
  end;
end;

function TFhirMedicinalProductDefinitionName.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FProductName) and isEmptyProp(FType_) and isEmptyProp(FpartList) and isEmptyProp(FusageList);
end;

procedure TFhirMedicinalProductDefinitionName.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('productName');
  fields.add('type');
  fields.add('part');
  fields.add('usage');
end;

function TFhirMedicinalProductDefinitionName.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
  inc(result, FPartList.sizeInBytes(magic));
  inc(result, FUsageList.sizeInBytes(magic));
end;

procedure TFhirMedicinalProductDefinitionName.SetProductName(value : TFhirString);
begin
  FProductName.free;
  FProductName := value;
end;

function TFhirMedicinalProductDefinitionName.GetProductNameST : String;
begin
  if FProductName = nil then
    result := ''
  else
    result := FProductName.value;
end;

procedure TFhirMedicinalProductDefinitionName.SetProductNameST(value : String);
begin
  if value <> '' then
  begin
    if FProductName = nil then
      FProductName := TFhirString.create;
    FProductName.value := value
  end
  else if FProductName <> nil then
    FProductName.value := '';
end;

procedure TFhirMedicinalProductDefinitionName.SetType_(value : TFhirCodeableConcept);
begin
  FType_.free;
  FType_ := value;
end;

function TFhirMedicinalProductDefinitionName.GetPartList : TFhirMedicinalProductDefinitionNamePartList;
begin
  if FPartList = nil then
    FPartList := TFhirMedicinalProductDefinitionNamePartList.Create;
  result := FPartList;
end;

function TFhirMedicinalProductDefinitionName.GetHasPartList : boolean;
begin
  result := (FPartList <> nil) and (FPartList.count > 0);
end;

function TFhirMedicinalProductDefinitionName.GetUsageList : TFhirMedicinalProductDefinitionNameUsageList;
begin
  if FUsageList = nil then
    FUsageList := TFhirMedicinalProductDefinitionNameUsageList.Create;
  result := FUsageList;
end;

function TFhirMedicinalProductDefinitionName.GetHasUsageList : boolean;
begin
  result := (FUsageList <> nil) and (FUsageList.count > 0);
end;

{ TFhirMedicinalProductDefinitionNameListEnumerator }

constructor TFhirMedicinalProductDefinitionNameListEnumerator.Create(list : TFhirMedicinalProductDefinitionNameList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirMedicinalProductDefinitionNameListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirMedicinalProductDefinitionNameListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirMedicinalProductDefinitionNameListEnumerator.GetCurrent : TFhirMedicinalProductDefinitionName;
begin
  Result := FList[FIndex];
end;

function TFhirMedicinalProductDefinitionNameListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirMedicinalProductDefinitionNameList }

function TFhirMedicinalProductDefinitionNameList.AddItem(value: TFhirMedicinalProductDefinitionName): TFhirMedicinalProductDefinitionName;
begin
  assert(value.ClassName = 'TFhirMedicinalProductDefinitionName', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirMedicinalProductDefinitionName');
  add(value);
  result := value;
end;

function TFhirMedicinalProductDefinitionNameList.Append: TFhirMedicinalProductDefinitionName;
begin
  result := TFhirMedicinalProductDefinitionName.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirMedicinalProductDefinitionNameList.ClearItems;
begin
  Clear;
end;

function TFhirMedicinalProductDefinitionNameList.GetEnumerator : TFhirMedicinalProductDefinitionNameListEnumerator;
begin
  result := TFhirMedicinalProductDefinitionNameListEnumerator.Create(self.link);
end;

function TFhirMedicinalProductDefinitionNameList.Clone: TFhirMedicinalProductDefinitionNameList;
begin
  result := TFhirMedicinalProductDefinitionNameList(inherited Clone);
end;

function TFhirMedicinalProductDefinitionNameList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirMedicinalProductDefinitionNameList.GetItemN(index: Integer): TFhirMedicinalProductDefinitionName;
begin
  result := TFhirMedicinalProductDefinitionName(ObjectByIndex[index]);
end;

function TFhirMedicinalProductDefinitionNameList.ItemClass: TFslObjectClass;
begin
  result := TFhirMedicinalProductDefinitionName;
end;
function TFhirMedicinalProductDefinitionNameList.IndexOf(value: TFhirMedicinalProductDefinitionName): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirMedicinalProductDefinitionNameList.Insert(index: Integer): TFhirMedicinalProductDefinitionName;
begin
  result := TFhirMedicinalProductDefinitionName.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirMedicinalProductDefinitionNameList.InsertItem(index: Integer; value: TFhirMedicinalProductDefinitionName);
begin
  assert(value is TFhirMedicinalProductDefinitionName);
  Inherited Insert(index, value);
end;

function TFhirMedicinalProductDefinitionNameList.Item(index: Integer): TFhirMedicinalProductDefinitionName;
begin
  result := TFhirMedicinalProductDefinitionName(ObjectByIndex[index]);
end;

function TFhirMedicinalProductDefinitionNameList.Link: TFhirMedicinalProductDefinitionNameList;
begin
  result := TFhirMedicinalProductDefinitionNameList(inherited Link);
end;

procedure TFhirMedicinalProductDefinitionNameList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirMedicinalProductDefinitionNameList.SetItemByIndex(index: Integer; value: TFhirMedicinalProductDefinitionName);
begin
  assert(value is TFhirMedicinalProductDefinitionName);
  FhirMedicinalProductDefinitionNames[index] := value;
end;

procedure TFhirMedicinalProductDefinitionNameList.SetItemN(index: Integer; value: TFhirMedicinalProductDefinitionName);
begin
  assert(value is TFhirMedicinalProductDefinitionName);
  ObjectByIndex[index] := value;
end;

{ TFhirMedicinalProductDefinitionNamePart }

constructor TFhirMedicinalProductDefinitionNamePart.Create;
begin
  inherited;
end;

destructor TFhirMedicinalProductDefinitionNamePart.Destroy;
begin
  FPart.free;
  FType_.free;
  inherited;
end;

procedure TFhirMedicinalProductDefinitionNamePart.Assign(oSource : TFslObject);
begin
  inherited;
  partElement := TFhirMedicinalProductDefinitionNamePart(oSource).partElement.Clone;
  type_ := TFhirMedicinalProductDefinitionNamePart(oSource).type_.Clone;
end;

procedure TFhirMedicinalProductDefinitionNamePart.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'part') Then
     list.add(self.link, 'part', FPart.Link);
  if (child_name = 'type') Then
     list.add(self.link, 'type', FType_.Link);
end;

procedure TFhirMedicinalProductDefinitionNamePart.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'part', 'string', false, TFhirString, FPart.Link));
  oList.add(TFHIRProperty.create(self, 'type', 'CodeableConcept', false, TFhirCodeableConcept, FType_.Link));
end;

function TFhirMedicinalProductDefinitionNamePart.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'part') then
  begin
    PartElement := asString(propValue);
    result := propValue;
  end
  else if (propName = 'type') then
  begin
    Type_ := propValue as TFhirCodeableConcept;
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirMedicinalProductDefinitionNamePart.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirMedicinalProductDefinitionNamePart.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'part') then result := TFhirString.create()
  else if (propName = 'type') then result := TFhirCodeableConcept.create()
  else result := inherited createPropertyValue(propName);
end;

function TFhirMedicinalProductDefinitionNamePart.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'part') then result := 'string'
  else if (propName = 'type') then result := 'CodeableConcept'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirMedicinalProductDefinitionNamePart.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'part') then PartElement := nil
  else if (propName = 'type') then Type_Element := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirMedicinalProductDefinitionNamePart.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'part') then PartElement := asString(new)
  else if (propName = 'type') then Type_Element := new as TFhirCodeableConcept
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirMedicinalProductDefinitionNamePart.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirMedicinalProductDefinitionNamePart.fhirType : string;
begin
  result := 'MedicinalProductDefinition.name.part';
end;

function TFhirMedicinalProductDefinitionNamePart.Link : TFhirMedicinalProductDefinitionNamePart;
begin
  result := TFhirMedicinalProductDefinitionNamePart(inherited Link);
end;

function TFhirMedicinalProductDefinitionNamePart.Clone : TFhirMedicinalProductDefinitionNamePart;
begin
  result := TFhirMedicinalProductDefinitionNamePart(inherited Clone);
end;

function TFhirMedicinalProductDefinitionNamePart.equals(other : TObject) : boolean; 
var
  o : TFhirMedicinalProductDefinitionNamePart;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirMedicinalProductDefinitionNamePart)) then
    result := false
  else
  begin
    o := TFhirMedicinalProductDefinitionNamePart(other);
    result := compareDeep(partElement, o.partElement, true) and compareDeep(type_Element, o.type_Element, true);
  end;
end;

function TFhirMedicinalProductDefinitionNamePart.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FPart) and isEmptyProp(FType_);
end;

procedure TFhirMedicinalProductDefinitionNamePart.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('part');
  fields.add('type');
end;

function TFhirMedicinalProductDefinitionNamePart.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
end;

procedure TFhirMedicinalProductDefinitionNamePart.SetPart(value : TFhirString);
begin
  FPart.free;
  FPart := value;
end;

function TFhirMedicinalProductDefinitionNamePart.GetPartST : String;
begin
  if FPart = nil then
    result := ''
  else
    result := FPart.value;
end;

procedure TFhirMedicinalProductDefinitionNamePart.SetPartST(value : String);
begin
  if value <> '' then
  begin
    if FPart = nil then
      FPart := TFhirString.create;
    FPart.value := value
  end
  else if FPart <> nil then
    FPart.value := '';
end;

procedure TFhirMedicinalProductDefinitionNamePart.SetType_(value : TFhirCodeableConcept);
begin
  FType_.free;
  FType_ := value;
end;

{ TFhirMedicinalProductDefinitionNamePartListEnumerator }

constructor TFhirMedicinalProductDefinitionNamePartListEnumerator.Create(list : TFhirMedicinalProductDefinitionNamePartList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirMedicinalProductDefinitionNamePartListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirMedicinalProductDefinitionNamePartListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirMedicinalProductDefinitionNamePartListEnumerator.GetCurrent : TFhirMedicinalProductDefinitionNamePart;
begin
  Result := FList[FIndex];
end;

function TFhirMedicinalProductDefinitionNamePartListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirMedicinalProductDefinitionNamePartList }

function TFhirMedicinalProductDefinitionNamePartList.AddItem(value: TFhirMedicinalProductDefinitionNamePart): TFhirMedicinalProductDefinitionNamePart;
begin
  assert(value.ClassName = 'TFhirMedicinalProductDefinitionNamePart', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirMedicinalProductDefinitionNamePart');
  add(value);
  result := value;
end;

function TFhirMedicinalProductDefinitionNamePartList.Append: TFhirMedicinalProductDefinitionNamePart;
begin
  result := TFhirMedicinalProductDefinitionNamePart.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirMedicinalProductDefinitionNamePartList.ClearItems;
begin
  Clear;
end;

function TFhirMedicinalProductDefinitionNamePartList.GetEnumerator : TFhirMedicinalProductDefinitionNamePartListEnumerator;
begin
  result := TFhirMedicinalProductDefinitionNamePartListEnumerator.Create(self.link);
end;

function TFhirMedicinalProductDefinitionNamePartList.Clone: TFhirMedicinalProductDefinitionNamePartList;
begin
  result := TFhirMedicinalProductDefinitionNamePartList(inherited Clone);
end;

function TFhirMedicinalProductDefinitionNamePartList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirMedicinalProductDefinitionNamePartList.GetItemN(index: Integer): TFhirMedicinalProductDefinitionNamePart;
begin
  result := TFhirMedicinalProductDefinitionNamePart(ObjectByIndex[index]);
end;

function TFhirMedicinalProductDefinitionNamePartList.ItemClass: TFslObjectClass;
begin
  result := TFhirMedicinalProductDefinitionNamePart;
end;
function TFhirMedicinalProductDefinitionNamePartList.IndexOf(value: TFhirMedicinalProductDefinitionNamePart): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirMedicinalProductDefinitionNamePartList.Insert(index: Integer): TFhirMedicinalProductDefinitionNamePart;
begin
  result := TFhirMedicinalProductDefinitionNamePart.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirMedicinalProductDefinitionNamePartList.InsertItem(index: Integer; value: TFhirMedicinalProductDefinitionNamePart);
begin
  assert(value is TFhirMedicinalProductDefinitionNamePart);
  Inherited Insert(index, value);
end;

function TFhirMedicinalProductDefinitionNamePartList.Item(index: Integer): TFhirMedicinalProductDefinitionNamePart;
begin
  result := TFhirMedicinalProductDefinitionNamePart(ObjectByIndex[index]);
end;

function TFhirMedicinalProductDefinitionNamePartList.Link: TFhirMedicinalProductDefinitionNamePartList;
begin
  result := TFhirMedicinalProductDefinitionNamePartList(inherited Link);
end;

procedure TFhirMedicinalProductDefinitionNamePartList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirMedicinalProductDefinitionNamePartList.SetItemByIndex(index: Integer; value: TFhirMedicinalProductDefinitionNamePart);
begin
  assert(value is TFhirMedicinalProductDefinitionNamePart);
  FhirMedicinalProductDefinitionNameParts[index] := value;
end;

procedure TFhirMedicinalProductDefinitionNamePartList.SetItemN(index: Integer; value: TFhirMedicinalProductDefinitionNamePart);
begin
  assert(value is TFhirMedicinalProductDefinitionNamePart);
  ObjectByIndex[index] := value;
end;

{ TFhirMedicinalProductDefinitionNameUsage }

constructor TFhirMedicinalProductDefinitionNameUsage.Create;
begin
  inherited;
end;

destructor TFhirMedicinalProductDefinitionNameUsage.Destroy;
begin
  FCountry.free;
  FJurisdiction.free;
  FLanguage.free;
  inherited;
end;

procedure TFhirMedicinalProductDefinitionNameUsage.Assign(oSource : TFslObject);
begin
  inherited;
  country := TFhirMedicinalProductDefinitionNameUsage(oSource).country.Clone;
  jurisdiction := TFhirMedicinalProductDefinitionNameUsage(oSource).jurisdiction.Clone;
  language := TFhirMedicinalProductDefinitionNameUsage(oSource).language.Clone;
end;

procedure TFhirMedicinalProductDefinitionNameUsage.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'country') Then
     list.add(self.link, 'country', FCountry.Link);
  if (child_name = 'jurisdiction') Then
     list.add(self.link, 'jurisdiction', FJurisdiction.Link);
  if (child_name = 'language') Then
     list.add(self.link, 'language', FLanguage.Link);
end;

procedure TFhirMedicinalProductDefinitionNameUsage.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'country', 'CodeableConcept', false, TFhirCodeableConcept, FCountry.Link));
  oList.add(TFHIRProperty.create(self, 'jurisdiction', 'CodeableConcept', false, TFhirCodeableConcept, FJurisdiction.Link));
  oList.add(TFHIRProperty.create(self, 'language', 'CodeableConcept', false, TFhirCodeableConcept, FLanguage.Link));
end;

function TFhirMedicinalProductDefinitionNameUsage.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'country') then
  begin
    Country := propValue as TFhirCodeableConcept;
    result := propValue;
  end
  else if (propName = 'jurisdiction') then
  begin
    Jurisdiction := propValue as TFhirCodeableConcept;
    result := propValue;
  end
  else if (propName = 'language') then
  begin
    Language := propValue as TFhirCodeableConcept;
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirMedicinalProductDefinitionNameUsage.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirMedicinalProductDefinitionNameUsage.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'country') then result := TFhirCodeableConcept.create()
  else if (propName = 'jurisdiction') then result := TFhirCodeableConcept.create()
  else if (propName = 'language') then result := TFhirCodeableConcept.create()
  else result := inherited createPropertyValue(propName);
end;

function TFhirMedicinalProductDefinitionNameUsage.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'country') then result := 'CodeableConcept'
  else if (propName = 'jurisdiction') then result := 'CodeableConcept'
  else if (propName = 'language') then result := 'CodeableConcept'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirMedicinalProductDefinitionNameUsage.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'country') then CountryElement := nil
  else if (propName = 'jurisdiction') then JurisdictionElement := nil
  else if (propName = 'language') then LanguageElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirMedicinalProductDefinitionNameUsage.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'country') then CountryElement := new as TFhirCodeableConcept
  else if (propName = 'jurisdiction') then JurisdictionElement := new as TFhirCodeableConcept
  else if (propName = 'language') then LanguageElement := new as TFhirCodeableConcept
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirMedicinalProductDefinitionNameUsage.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirMedicinalProductDefinitionNameUsage.fhirType : string;
begin
  result := 'MedicinalProductDefinition.name.usage';
end;

function TFhirMedicinalProductDefinitionNameUsage.Link : TFhirMedicinalProductDefinitionNameUsage;
begin
  result := TFhirMedicinalProductDefinitionNameUsage(inherited Link);
end;

function TFhirMedicinalProductDefinitionNameUsage.Clone : TFhirMedicinalProductDefinitionNameUsage;
begin
  result := TFhirMedicinalProductDefinitionNameUsage(inherited Clone);
end;

function TFhirMedicinalProductDefinitionNameUsage.equals(other : TObject) : boolean; 
var
  o : TFhirMedicinalProductDefinitionNameUsage;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirMedicinalProductDefinitionNameUsage)) then
    result := false
  else
  begin
    o := TFhirMedicinalProductDefinitionNameUsage(other);
    result := compareDeep(countryElement, o.countryElement, true) and compareDeep(jurisdictionElement, o.jurisdictionElement, true) and 
      compareDeep(languageElement, o.languageElement, true);
  end;
end;

function TFhirMedicinalProductDefinitionNameUsage.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FCountry) and isEmptyProp(FJurisdiction) and isEmptyProp(FLanguage);
end;

procedure TFhirMedicinalProductDefinitionNameUsage.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('country');
  fields.add('jurisdiction');
  fields.add('language');
end;

function TFhirMedicinalProductDefinitionNameUsage.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
end;

procedure TFhirMedicinalProductDefinitionNameUsage.SetCountry(value : TFhirCodeableConcept);
begin
  FCountry.free;
  FCountry := value;
end;

procedure TFhirMedicinalProductDefinitionNameUsage.SetJurisdiction(value : TFhirCodeableConcept);
begin
  FJurisdiction.free;
  FJurisdiction := value;
end;

procedure TFhirMedicinalProductDefinitionNameUsage.SetLanguage(value : TFhirCodeableConcept);
begin
  FLanguage.free;
  FLanguage := value;
end;

{ TFhirMedicinalProductDefinitionNameUsageListEnumerator }

constructor TFhirMedicinalProductDefinitionNameUsageListEnumerator.Create(list : TFhirMedicinalProductDefinitionNameUsageList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirMedicinalProductDefinitionNameUsageListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirMedicinalProductDefinitionNameUsageListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirMedicinalProductDefinitionNameUsageListEnumerator.GetCurrent : TFhirMedicinalProductDefinitionNameUsage;
begin
  Result := FList[FIndex];
end;

function TFhirMedicinalProductDefinitionNameUsageListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirMedicinalProductDefinitionNameUsageList }

function TFhirMedicinalProductDefinitionNameUsageList.AddItem(value: TFhirMedicinalProductDefinitionNameUsage): TFhirMedicinalProductDefinitionNameUsage;
begin
  assert(value.ClassName = 'TFhirMedicinalProductDefinitionNameUsage', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirMedicinalProductDefinitionNameUsage');
  add(value);
  result := value;
end;

function TFhirMedicinalProductDefinitionNameUsageList.Append: TFhirMedicinalProductDefinitionNameUsage;
begin
  result := TFhirMedicinalProductDefinitionNameUsage.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirMedicinalProductDefinitionNameUsageList.ClearItems;
begin
  Clear;
end;

function TFhirMedicinalProductDefinitionNameUsageList.GetEnumerator : TFhirMedicinalProductDefinitionNameUsageListEnumerator;
begin
  result := TFhirMedicinalProductDefinitionNameUsageListEnumerator.Create(self.link);
end;

function TFhirMedicinalProductDefinitionNameUsageList.Clone: TFhirMedicinalProductDefinitionNameUsageList;
begin
  result := TFhirMedicinalProductDefinitionNameUsageList(inherited Clone);
end;

function TFhirMedicinalProductDefinitionNameUsageList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirMedicinalProductDefinitionNameUsageList.GetItemN(index: Integer): TFhirMedicinalProductDefinitionNameUsage;
begin
  result := TFhirMedicinalProductDefinitionNameUsage(ObjectByIndex[index]);
end;

function TFhirMedicinalProductDefinitionNameUsageList.ItemClass: TFslObjectClass;
begin
  result := TFhirMedicinalProductDefinitionNameUsage;
end;
function TFhirMedicinalProductDefinitionNameUsageList.IndexOf(value: TFhirMedicinalProductDefinitionNameUsage): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirMedicinalProductDefinitionNameUsageList.Insert(index: Integer): TFhirMedicinalProductDefinitionNameUsage;
begin
  result := TFhirMedicinalProductDefinitionNameUsage.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirMedicinalProductDefinitionNameUsageList.InsertItem(index: Integer; value: TFhirMedicinalProductDefinitionNameUsage);
begin
  assert(value is TFhirMedicinalProductDefinitionNameUsage);
  Inherited Insert(index, value);
end;

function TFhirMedicinalProductDefinitionNameUsageList.Item(index: Integer): TFhirMedicinalProductDefinitionNameUsage;
begin
  result := TFhirMedicinalProductDefinitionNameUsage(ObjectByIndex[index]);
end;

function TFhirMedicinalProductDefinitionNameUsageList.Link: TFhirMedicinalProductDefinitionNameUsageList;
begin
  result := TFhirMedicinalProductDefinitionNameUsageList(inherited Link);
end;

procedure TFhirMedicinalProductDefinitionNameUsageList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirMedicinalProductDefinitionNameUsageList.SetItemByIndex(index: Integer; value: TFhirMedicinalProductDefinitionNameUsage);
begin
  assert(value is TFhirMedicinalProductDefinitionNameUsage);
  FhirMedicinalProductDefinitionNameUsages[index] := value;
end;

procedure TFhirMedicinalProductDefinitionNameUsageList.SetItemN(index: Integer; value: TFhirMedicinalProductDefinitionNameUsage);
begin
  assert(value is TFhirMedicinalProductDefinitionNameUsage);
  ObjectByIndex[index] := value;
end;

{ TFhirMedicinalProductDefinitionCrossReference }

constructor TFhirMedicinalProductDefinitionCrossReference.Create;
begin
  inherited;
end;

destructor TFhirMedicinalProductDefinitionCrossReference.Destroy;
begin
  FProduct.free;
  FType_.free;
  inherited;
end;

procedure TFhirMedicinalProductDefinitionCrossReference.Assign(oSource : TFslObject);
begin
  inherited;
  product := TFhirMedicinalProductDefinitionCrossReference(oSource).product.Clone;
  type_ := TFhirMedicinalProductDefinitionCrossReference(oSource).type_.Clone;
end;

procedure TFhirMedicinalProductDefinitionCrossReference.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'product') Then
     list.add(self.link, 'product', FProduct.Link);
  if (child_name = 'type') Then
     list.add(self.link, 'type', FType_.Link);
end;

procedure TFhirMedicinalProductDefinitionCrossReference.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'product', 'CodeableReference', false, TFhirCodeableReference, FProduct.Link));
  oList.add(TFHIRProperty.create(self, 'type', 'CodeableConcept', false, TFhirCodeableConcept, FType_.Link));
end;

function TFhirMedicinalProductDefinitionCrossReference.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'product') then
  begin
    Product := propValue as TFhirCodeableReference;
    result := propValue;
  end
  else if (propName = 'type') then
  begin
    Type_ := propValue as TFhirCodeableConcept;
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirMedicinalProductDefinitionCrossReference.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirMedicinalProductDefinitionCrossReference.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'product') then result := TFhirCodeableReference.create()
  else if (propName = 'type') then result := TFhirCodeableConcept.create()
  else result := inherited createPropertyValue(propName);
end;

function TFhirMedicinalProductDefinitionCrossReference.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'product') then result := 'CodeableReference'
  else if (propName = 'type') then result := 'CodeableConcept'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirMedicinalProductDefinitionCrossReference.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'product') then ProductElement := nil
  else if (propName = 'type') then Type_Element := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirMedicinalProductDefinitionCrossReference.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'product') then ProductElement := new as TFhirCodeableReference
  else if (propName = 'type') then Type_Element := new as TFhirCodeableConcept
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirMedicinalProductDefinitionCrossReference.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirMedicinalProductDefinitionCrossReference.fhirType : string;
begin
  result := 'MedicinalProductDefinition.crossReference';
end;

function TFhirMedicinalProductDefinitionCrossReference.Link : TFhirMedicinalProductDefinitionCrossReference;
begin
  result := TFhirMedicinalProductDefinitionCrossReference(inherited Link);
end;

function TFhirMedicinalProductDefinitionCrossReference.Clone : TFhirMedicinalProductDefinitionCrossReference;
begin
  result := TFhirMedicinalProductDefinitionCrossReference(inherited Clone);
end;

function TFhirMedicinalProductDefinitionCrossReference.equals(other : TObject) : boolean; 
var
  o : TFhirMedicinalProductDefinitionCrossReference;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirMedicinalProductDefinitionCrossReference)) then
    result := false
  else
  begin
    o := TFhirMedicinalProductDefinitionCrossReference(other);
    result := compareDeep(productElement, o.productElement, true) and compareDeep(type_Element, o.type_Element, true);
  end;
end;

function TFhirMedicinalProductDefinitionCrossReference.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FProduct) and isEmptyProp(FType_);
end;

procedure TFhirMedicinalProductDefinitionCrossReference.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('product');
  fields.add('type');
end;

function TFhirMedicinalProductDefinitionCrossReference.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
end;

procedure TFhirMedicinalProductDefinitionCrossReference.SetProduct(value : TFhirCodeableReference);
begin
  FProduct.free;
  FProduct := value;
end;

procedure TFhirMedicinalProductDefinitionCrossReference.SetType_(value : TFhirCodeableConcept);
begin
  FType_.free;
  FType_ := value;
end;

{ TFhirMedicinalProductDefinitionCrossReferenceListEnumerator }

constructor TFhirMedicinalProductDefinitionCrossReferenceListEnumerator.Create(list : TFhirMedicinalProductDefinitionCrossReferenceList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirMedicinalProductDefinitionCrossReferenceListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirMedicinalProductDefinitionCrossReferenceListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirMedicinalProductDefinitionCrossReferenceListEnumerator.GetCurrent : TFhirMedicinalProductDefinitionCrossReference;
begin
  Result := FList[FIndex];
end;

function TFhirMedicinalProductDefinitionCrossReferenceListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirMedicinalProductDefinitionCrossReferenceList }

function TFhirMedicinalProductDefinitionCrossReferenceList.AddItem(value: TFhirMedicinalProductDefinitionCrossReference): TFhirMedicinalProductDefinitionCrossReference;
begin
  assert(value.ClassName = 'TFhirMedicinalProductDefinitionCrossReference', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirMedicinalProductDefinitionCrossReference');
  add(value);
  result := value;
end;

function TFhirMedicinalProductDefinitionCrossReferenceList.Append: TFhirMedicinalProductDefinitionCrossReference;
begin
  result := TFhirMedicinalProductDefinitionCrossReference.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirMedicinalProductDefinitionCrossReferenceList.ClearItems;
begin
  Clear;
end;

function TFhirMedicinalProductDefinitionCrossReferenceList.GetEnumerator : TFhirMedicinalProductDefinitionCrossReferenceListEnumerator;
begin
  result := TFhirMedicinalProductDefinitionCrossReferenceListEnumerator.Create(self.link);
end;

function TFhirMedicinalProductDefinitionCrossReferenceList.Clone: TFhirMedicinalProductDefinitionCrossReferenceList;
begin
  result := TFhirMedicinalProductDefinitionCrossReferenceList(inherited Clone);
end;

function TFhirMedicinalProductDefinitionCrossReferenceList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirMedicinalProductDefinitionCrossReferenceList.GetItemN(index: Integer): TFhirMedicinalProductDefinitionCrossReference;
begin
  result := TFhirMedicinalProductDefinitionCrossReference(ObjectByIndex[index]);
end;

function TFhirMedicinalProductDefinitionCrossReferenceList.ItemClass: TFslObjectClass;
begin
  result := TFhirMedicinalProductDefinitionCrossReference;
end;
function TFhirMedicinalProductDefinitionCrossReferenceList.IndexOf(value: TFhirMedicinalProductDefinitionCrossReference): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirMedicinalProductDefinitionCrossReferenceList.Insert(index: Integer): TFhirMedicinalProductDefinitionCrossReference;
begin
  result := TFhirMedicinalProductDefinitionCrossReference.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirMedicinalProductDefinitionCrossReferenceList.InsertItem(index: Integer; value: TFhirMedicinalProductDefinitionCrossReference);
begin
  assert(value is TFhirMedicinalProductDefinitionCrossReference);
  Inherited Insert(index, value);
end;

function TFhirMedicinalProductDefinitionCrossReferenceList.Item(index: Integer): TFhirMedicinalProductDefinitionCrossReference;
begin
  result := TFhirMedicinalProductDefinitionCrossReference(ObjectByIndex[index]);
end;

function TFhirMedicinalProductDefinitionCrossReferenceList.Link: TFhirMedicinalProductDefinitionCrossReferenceList;
begin
  result := TFhirMedicinalProductDefinitionCrossReferenceList(inherited Link);
end;

procedure TFhirMedicinalProductDefinitionCrossReferenceList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirMedicinalProductDefinitionCrossReferenceList.SetItemByIndex(index: Integer; value: TFhirMedicinalProductDefinitionCrossReference);
begin
  assert(value is TFhirMedicinalProductDefinitionCrossReference);
  FhirMedicinalProductDefinitionCrossReferences[index] := value;
end;

procedure TFhirMedicinalProductDefinitionCrossReferenceList.SetItemN(index: Integer; value: TFhirMedicinalProductDefinitionCrossReference);
begin
  assert(value is TFhirMedicinalProductDefinitionCrossReference);
  ObjectByIndex[index] := value;
end;

{ TFhirMedicinalProductDefinitionOperation }

constructor TFhirMedicinalProductDefinitionOperation.Create;
begin
  inherited;
end;

destructor TFhirMedicinalProductDefinitionOperation.Destroy;
begin
  FType_.free;
  FEffectiveDate.free;
  FOrganizationList.Free;
  FConfidentialityIndicator.free;
  inherited;
end;

procedure TFhirMedicinalProductDefinitionOperation.Assign(oSource : TFslObject);
begin
  inherited;
  type_ := TFhirMedicinalProductDefinitionOperation(oSource).type_.Clone;
  effectiveDate := TFhirMedicinalProductDefinitionOperation(oSource).effectiveDate.Clone;
  if (TFhirMedicinalProductDefinitionOperation(oSource).FOrganizationList = nil) then
  begin
    FOrganizationList.free;
    FOrganizationList := nil;
  end
  else
  begin
    if FOrganizationList = nil then
      FOrganizationList := TFhirReferenceList.Create;
    FOrganizationList.Assign(TFhirMedicinalProductDefinitionOperation(oSource).FOrganizationList);
  end;
  confidentialityIndicator := TFhirMedicinalProductDefinitionOperation(oSource).confidentialityIndicator.Clone;
end;

procedure TFhirMedicinalProductDefinitionOperation.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'type') Then
     list.add(self.link, 'type', FType_.Link);
  if (child_name = 'effectiveDate') Then
     list.add(self.link, 'effectiveDate', FEffectiveDate.Link);
  if (child_name = 'organization') Then
    list.addAll(self, 'organization', FOrganizationList);
  if (child_name = 'confidentialityIndicator') Then
     list.add(self.link, 'confidentialityIndicator', FConfidentialityIndicator.Link);
end;

procedure TFhirMedicinalProductDefinitionOperation.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'type', 'CodeableReference', false, TFhirCodeableReference, FType_.Link));
  oList.add(TFHIRProperty.create(self, 'effectiveDate', 'Period', false, TFhirPeriod, FEffectiveDate.Link));
  oList.add(TFHIRProperty.create(self, 'organization', 'Reference', true, TFhirReference, FOrganizationList.Link));
  oList.add(TFHIRProperty.create(self, 'confidentialityIndicator', 'CodeableConcept', false, TFhirCodeableConcept, FConfidentialityIndicator.Link));
end;

function TFhirMedicinalProductDefinitionOperation.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'type') then
  begin
    Type_ := propValue as TFhirCodeableReference;
    result := propValue;
  end
  else if (propName = 'effectiveDate') then
  begin
    EffectiveDate := propValue as TFhirPeriod;
    result := propValue;
  end
  else if (propName = 'organization') then
  begin
    OrganizationList.add(propValue as TFhirReference);
    result := propValue;
  end
  else if (propName = 'confidentialityIndicator') then
  begin
    ConfidentialityIndicator := propValue as TFhirCodeableConcept;
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirMedicinalProductDefinitionOperation.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'organization') then OrganizationList.insertItem(index, propValue as TFhirReference)
  else inherited;
end;

function TFhirMedicinalProductDefinitionOperation.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'type') then result := TFhirCodeableReference.create()
  else if (propName = 'effectiveDate') then result := TFhirPeriod.create()
  else if (propName = 'organization') then result := OrganizationList.new()
  else if (propName = 'confidentialityIndicator') then result := TFhirCodeableConcept.create()
  else result := inherited createPropertyValue(propName);
end;

function TFhirMedicinalProductDefinitionOperation.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'type') then result := 'CodeableReference'
  else if (propName = 'effectiveDate') then result := 'Period'
  else if (propName = 'organization') then result := 'Reference'
  else if (propName = 'confidentialityIndicator') then result := 'CodeableConcept'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirMedicinalProductDefinitionOperation.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'type') then Type_Element := nil
  else if (propName = 'effectiveDate') then EffectiveDateElement := nil
  else if (propName = 'organization') then deletePropertyValue('organization', OrganizationList, value)
  else if (propName = 'confidentialityIndicator') then ConfidentialityIndicatorElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirMedicinalProductDefinitionOperation.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'type') then Type_Element := new as TFhirCodeableReference
  else if (propName = 'effectiveDate') then EffectiveDateElement := new as TFhirPeriod
  else if (propName = 'organization') then replacePropertyValue('organization', OrganizationList, existing, new)
  else if (propName = 'confidentialityIndicator') then ConfidentialityIndicatorElement := new as TFhirCodeableConcept
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirMedicinalProductDefinitionOperation.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'organization') then OrganizationList.move(source, destination)
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirMedicinalProductDefinitionOperation.fhirType : string;
begin
  result := 'MedicinalProductDefinition.operation';
end;

function TFhirMedicinalProductDefinitionOperation.Link : TFhirMedicinalProductDefinitionOperation;
begin
  result := TFhirMedicinalProductDefinitionOperation(inherited Link);
end;

function TFhirMedicinalProductDefinitionOperation.Clone : TFhirMedicinalProductDefinitionOperation;
begin
  result := TFhirMedicinalProductDefinitionOperation(inherited Clone);
end;

function TFhirMedicinalProductDefinitionOperation.equals(other : TObject) : boolean; 
var
  o : TFhirMedicinalProductDefinitionOperation;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirMedicinalProductDefinitionOperation)) then
    result := false
  else
  begin
    o := TFhirMedicinalProductDefinitionOperation(other);
    result := compareDeep(type_Element, o.type_Element, true) and compareDeep(effectiveDateElement, o.effectiveDateElement, true) and 
      compareDeep(organizationList, o.organizationList, true) and compareDeep(confidentialityIndicatorElement, o.confidentialityIndicatorElement, true);
  end;
end;

function TFhirMedicinalProductDefinitionOperation.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FType_) and isEmptyProp(FEffectiveDate) and isEmptyProp(ForganizationList) and isEmptyProp(FConfidentialityIndicator);
end;

procedure TFhirMedicinalProductDefinitionOperation.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('type');
  fields.add('effectiveDate');
  fields.add('organization');
  fields.add('confidentialityIndicator');
end;

function TFhirMedicinalProductDefinitionOperation.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
  inc(result, FOrganizationList.sizeInBytes(magic));
end;

procedure TFhirMedicinalProductDefinitionOperation.SetType_(value : TFhirCodeableReference);
begin
  FType_.free;
  FType_ := value;
end;

procedure TFhirMedicinalProductDefinitionOperation.SetEffectiveDate(value : TFhirPeriod);
begin
  FEffectiveDate.free;
  FEffectiveDate := value;
end;

function TFhirMedicinalProductDefinitionOperation.GetOrganizationList : TFhirReferenceList;
begin
  if FOrganizationList = nil then
    FOrganizationList := TFhirReferenceList.Create;
  result := FOrganizationList;
end;

function TFhirMedicinalProductDefinitionOperation.GetHasOrganizationList : boolean;
begin
  result := (FOrganizationList <> nil) and (FOrganizationList.count > 0);
end;

procedure TFhirMedicinalProductDefinitionOperation.SetConfidentialityIndicator(value : TFhirCodeableConcept);
begin
  FConfidentialityIndicator.free;
  FConfidentialityIndicator := value;
end;

{ TFhirMedicinalProductDefinitionOperationListEnumerator }

constructor TFhirMedicinalProductDefinitionOperationListEnumerator.Create(list : TFhirMedicinalProductDefinitionOperationList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirMedicinalProductDefinitionOperationListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirMedicinalProductDefinitionOperationListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirMedicinalProductDefinitionOperationListEnumerator.GetCurrent : TFhirMedicinalProductDefinitionOperation;
begin
  Result := FList[FIndex];
end;

function TFhirMedicinalProductDefinitionOperationListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirMedicinalProductDefinitionOperationList }

function TFhirMedicinalProductDefinitionOperationList.AddItem(value: TFhirMedicinalProductDefinitionOperation): TFhirMedicinalProductDefinitionOperation;
begin
  assert(value.ClassName = 'TFhirMedicinalProductDefinitionOperation', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirMedicinalProductDefinitionOperation');
  add(value);
  result := value;
end;

function TFhirMedicinalProductDefinitionOperationList.Append: TFhirMedicinalProductDefinitionOperation;
begin
  result := TFhirMedicinalProductDefinitionOperation.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirMedicinalProductDefinitionOperationList.ClearItems;
begin
  Clear;
end;

function TFhirMedicinalProductDefinitionOperationList.GetEnumerator : TFhirMedicinalProductDefinitionOperationListEnumerator;
begin
  result := TFhirMedicinalProductDefinitionOperationListEnumerator.Create(self.link);
end;

function TFhirMedicinalProductDefinitionOperationList.Clone: TFhirMedicinalProductDefinitionOperationList;
begin
  result := TFhirMedicinalProductDefinitionOperationList(inherited Clone);
end;

function TFhirMedicinalProductDefinitionOperationList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirMedicinalProductDefinitionOperationList.GetItemN(index: Integer): TFhirMedicinalProductDefinitionOperation;
begin
  result := TFhirMedicinalProductDefinitionOperation(ObjectByIndex[index]);
end;

function TFhirMedicinalProductDefinitionOperationList.ItemClass: TFslObjectClass;
begin
  result := TFhirMedicinalProductDefinitionOperation;
end;
function TFhirMedicinalProductDefinitionOperationList.IndexOf(value: TFhirMedicinalProductDefinitionOperation): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirMedicinalProductDefinitionOperationList.Insert(index: Integer): TFhirMedicinalProductDefinitionOperation;
begin
  result := TFhirMedicinalProductDefinitionOperation.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirMedicinalProductDefinitionOperationList.InsertItem(index: Integer; value: TFhirMedicinalProductDefinitionOperation);
begin
  assert(value is TFhirMedicinalProductDefinitionOperation);
  Inherited Insert(index, value);
end;

function TFhirMedicinalProductDefinitionOperationList.Item(index: Integer): TFhirMedicinalProductDefinitionOperation;
begin
  result := TFhirMedicinalProductDefinitionOperation(ObjectByIndex[index]);
end;

function TFhirMedicinalProductDefinitionOperationList.Link: TFhirMedicinalProductDefinitionOperationList;
begin
  result := TFhirMedicinalProductDefinitionOperationList(inherited Link);
end;

procedure TFhirMedicinalProductDefinitionOperationList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirMedicinalProductDefinitionOperationList.SetItemByIndex(index: Integer; value: TFhirMedicinalProductDefinitionOperation);
begin
  assert(value is TFhirMedicinalProductDefinitionOperation);
  FhirMedicinalProductDefinitionOperations[index] := value;
end;

procedure TFhirMedicinalProductDefinitionOperationList.SetItemN(index: Integer; value: TFhirMedicinalProductDefinitionOperation);
begin
  assert(value is TFhirMedicinalProductDefinitionOperation);
  ObjectByIndex[index] := value;
end;

{ TFhirMedicinalProductDefinitionCharacteristic }

constructor TFhirMedicinalProductDefinitionCharacteristic.Create;
begin
  inherited;
end;

destructor TFhirMedicinalProductDefinitionCharacteristic.Destroy;
begin
  FType_.free;
  FValue.free;
  inherited;
end;

procedure TFhirMedicinalProductDefinitionCharacteristic.Assign(oSource : TFslObject);
begin
  inherited;
  type_ := TFhirMedicinalProductDefinitionCharacteristic(oSource).type_.Clone;
  value := TFhirMedicinalProductDefinitionCharacteristic(oSource).value.Clone;
end;

procedure TFhirMedicinalProductDefinitionCharacteristic.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'type') Then
     list.add(self.link, 'type', FType_.Link);
  if (child_name = 'value[x]') or (child_name = 'value') Then
     list.add(self.link, 'value[x]', FValue.Link);
end;

procedure TFhirMedicinalProductDefinitionCharacteristic.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'type', 'CodeableConcept', false, TFhirCodeableConcept, FType_.Link));
  oList.add(TFHIRProperty.create(self, 'value[x]', 'CodeableConcept|string|Quantity|integer|date|boolean|Attachment', false, TFhirDataType, FValue.Link));
end;

function TFhirMedicinalProductDefinitionCharacteristic.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'type') then
  begin
    Type_ := propValue as TFhirCodeableConcept;
    result := propValue;
  end
  else if (isMatchingName(propName, 'value', ['CodeableConcept', 'String', 'Quantity', 'Integer', 'Date', 'Boolean', 'Attachment'])) then
  begin
    Value := propValue as TFhirDataType;
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirMedicinalProductDefinitionCharacteristic.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirMedicinalProductDefinitionCharacteristic.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'type') then result := TFhirCodeableConcept.create()
  else if (isMatchingName(propName, 'value', ['CodeableConcept', 'String', 'Quantity', 'Integer', 'Date', 'Boolean', 'Attachment'])) then raise EFHIRException.create('Cannot make property Value')
  else result := inherited createPropertyValue(propName);
end;

function TFhirMedicinalProductDefinitionCharacteristic.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'type') then result := 'CodeableConcept'
  else if (propName = 'value[x]') then result := 'CodeableConcept|string|Quantity|integer|date|boolean|Attachment'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirMedicinalProductDefinitionCharacteristic.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'type') then Type_Element := nil
  else if (isMatchingName(propName, 'value', ['CodeableConcept', 'String', 'Quantity', 'Integer', 'Date', 'Boolean', 'Attachment'])) then ValueElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirMedicinalProductDefinitionCharacteristic.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'type') then Type_Element := new as TFhirCodeableConcept
  else if (isMatchingName(propName, 'value', ['CodeableConcept', 'String', 'Quantity', 'Integer', 'Date', 'Boolean', 'Attachment'])) then ValueElement := new as TFhirDataType
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirMedicinalProductDefinitionCharacteristic.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirMedicinalProductDefinitionCharacteristic.fhirType : string;
begin
  result := 'MedicinalProductDefinition.characteristic';
end;

function TFhirMedicinalProductDefinitionCharacteristic.Link : TFhirMedicinalProductDefinitionCharacteristic;
begin
  result := TFhirMedicinalProductDefinitionCharacteristic(inherited Link);
end;

function TFhirMedicinalProductDefinitionCharacteristic.Clone : TFhirMedicinalProductDefinitionCharacteristic;
begin
  result := TFhirMedicinalProductDefinitionCharacteristic(inherited Clone);
end;

function TFhirMedicinalProductDefinitionCharacteristic.equals(other : TObject) : boolean; 
var
  o : TFhirMedicinalProductDefinitionCharacteristic;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirMedicinalProductDefinitionCharacteristic)) then
    result := false
  else
  begin
    o := TFhirMedicinalProductDefinitionCharacteristic(other);
    result := compareDeep(type_Element, o.type_Element, true) and compareDeep(valueElement, o.valueElement, true);
  end;
end;

function TFhirMedicinalProductDefinitionCharacteristic.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FType_) and isEmptyProp(FValue);
end;

procedure TFhirMedicinalProductDefinitionCharacteristic.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('type');
  fields.add('value[x]');
end;

function TFhirMedicinalProductDefinitionCharacteristic.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
end;

procedure TFhirMedicinalProductDefinitionCharacteristic.SetType_(value : TFhirCodeableConcept);
begin
  FType_.free;
  FType_ := value;
end;

procedure TFhirMedicinalProductDefinitionCharacteristic.SetValue(value : TFhirDataType);
begin
  FValue.free;
  FValue := value;
end;

{ TFhirMedicinalProductDefinitionCharacteristicListEnumerator }

constructor TFhirMedicinalProductDefinitionCharacteristicListEnumerator.Create(list : TFhirMedicinalProductDefinitionCharacteristicList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirMedicinalProductDefinitionCharacteristicListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirMedicinalProductDefinitionCharacteristicListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirMedicinalProductDefinitionCharacteristicListEnumerator.GetCurrent : TFhirMedicinalProductDefinitionCharacteristic;
begin
  Result := FList[FIndex];
end;

function TFhirMedicinalProductDefinitionCharacteristicListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirMedicinalProductDefinitionCharacteristicList }

function TFhirMedicinalProductDefinitionCharacteristicList.AddItem(value: TFhirMedicinalProductDefinitionCharacteristic): TFhirMedicinalProductDefinitionCharacteristic;
begin
  assert(value.ClassName = 'TFhirMedicinalProductDefinitionCharacteristic', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirMedicinalProductDefinitionCharacteristic');
  add(value);
  result := value;
end;

function TFhirMedicinalProductDefinitionCharacteristicList.Append: TFhirMedicinalProductDefinitionCharacteristic;
begin
  result := TFhirMedicinalProductDefinitionCharacteristic.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirMedicinalProductDefinitionCharacteristicList.ClearItems;
begin
  Clear;
end;

function TFhirMedicinalProductDefinitionCharacteristicList.GetEnumerator : TFhirMedicinalProductDefinitionCharacteristicListEnumerator;
begin
  result := TFhirMedicinalProductDefinitionCharacteristicListEnumerator.Create(self.link);
end;

function TFhirMedicinalProductDefinitionCharacteristicList.Clone: TFhirMedicinalProductDefinitionCharacteristicList;
begin
  result := TFhirMedicinalProductDefinitionCharacteristicList(inherited Clone);
end;

function TFhirMedicinalProductDefinitionCharacteristicList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirMedicinalProductDefinitionCharacteristicList.GetItemN(index: Integer): TFhirMedicinalProductDefinitionCharacteristic;
begin
  result := TFhirMedicinalProductDefinitionCharacteristic(ObjectByIndex[index]);
end;

function TFhirMedicinalProductDefinitionCharacteristicList.ItemClass: TFslObjectClass;
begin
  result := TFhirMedicinalProductDefinitionCharacteristic;
end;
function TFhirMedicinalProductDefinitionCharacteristicList.IndexOf(value: TFhirMedicinalProductDefinitionCharacteristic): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirMedicinalProductDefinitionCharacteristicList.Insert(index: Integer): TFhirMedicinalProductDefinitionCharacteristic;
begin
  result := TFhirMedicinalProductDefinitionCharacteristic.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirMedicinalProductDefinitionCharacteristicList.InsertItem(index: Integer; value: TFhirMedicinalProductDefinitionCharacteristic);
begin
  assert(value is TFhirMedicinalProductDefinitionCharacteristic);
  Inherited Insert(index, value);
end;

function TFhirMedicinalProductDefinitionCharacteristicList.Item(index: Integer): TFhirMedicinalProductDefinitionCharacteristic;
begin
  result := TFhirMedicinalProductDefinitionCharacteristic(ObjectByIndex[index]);
end;

function TFhirMedicinalProductDefinitionCharacteristicList.Link: TFhirMedicinalProductDefinitionCharacteristicList;
begin
  result := TFhirMedicinalProductDefinitionCharacteristicList(inherited Link);
end;

procedure TFhirMedicinalProductDefinitionCharacteristicList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirMedicinalProductDefinitionCharacteristicList.SetItemByIndex(index: Integer; value: TFhirMedicinalProductDefinitionCharacteristic);
begin
  assert(value is TFhirMedicinalProductDefinitionCharacteristic);
  FhirMedicinalProductDefinitionCharacteristics[index] := value;
end;

procedure TFhirMedicinalProductDefinitionCharacteristicList.SetItemN(index: Integer; value: TFhirMedicinalProductDefinitionCharacteristic);
begin
  assert(value is TFhirMedicinalProductDefinitionCharacteristic);
  ObjectByIndex[index] := value;
end;

{ TFhirMedicinalProductDefinition }

constructor TFhirMedicinalProductDefinition.Create;
begin
  inherited;
end;

destructor TFhirMedicinalProductDefinition.Destroy;
begin
  FIdentifierList.Free;
  FType_.free;
  FDomain.free;
  FVersion.free;
  FStatus.free;
  FStatusDate.free;
  FDescription.free;
  FCombinedPharmaceuticalDoseForm.free;
  FRouteList.Free;
  FIndication.free;
  FLegalStatusOfSupply.free;
  FAdditionalMonitoringIndicator.free;
  FSpecialMeasuresList.Free;
  FPediatricUseIndicator.free;
  FClassificationList.Free;
  FMarketingStatusList.Free;
  FPackagedMedicinalProductList.Free;
  FComprisedOfList.Free;
  FIngredientList.Free;
  FImpurityList.Free;
  FAttachedDocumentList.Free;
  FMasterFileList.Free;
  FContactList.Free;
  FClinicalTrialList.Free;
  FCodeList.Free;
  FNameList.Free;
  FCrossReferenceList.Free;
  FOperationList.Free;
  FCharacteristicList.Free;
  inherited;
end;

procedure TFhirMedicinalProductDefinition.Assign(oSource : TFslObject);
begin
  inherited;
  if (TFhirMedicinalProductDefinition(oSource).FIdentifierList = nil) then
  begin
    FIdentifierList.free;
    FIdentifierList := nil;
  end
  else
  begin
    if FIdentifierList = nil then
      FIdentifierList := TFhirIdentifierList.Create;
    FIdentifierList.Assign(TFhirMedicinalProductDefinition(oSource).FIdentifierList);
  end;
  type_ := TFhirMedicinalProductDefinition(oSource).type_.Clone;
  domain := TFhirMedicinalProductDefinition(oSource).domain.Clone;
  versionElement := TFhirMedicinalProductDefinition(oSource).versionElement.Clone;
  status := TFhirMedicinalProductDefinition(oSource).status.Clone;
  statusDateElement := TFhirMedicinalProductDefinition(oSource).statusDateElement.Clone;
  descriptionElement := TFhirMedicinalProductDefinition(oSource).descriptionElement.Clone;
  combinedPharmaceuticalDoseForm := TFhirMedicinalProductDefinition(oSource).combinedPharmaceuticalDoseForm.Clone;
  if (TFhirMedicinalProductDefinition(oSource).FRouteList = nil) then
  begin
    FRouteList.free;
    FRouteList := nil;
  end
  else
  begin
    if FRouteList = nil then
      FRouteList := TFhirCodeableConceptList.Create;
    FRouteList.Assign(TFhirMedicinalProductDefinition(oSource).FRouteList);
  end;
  indicationElement := TFhirMedicinalProductDefinition(oSource).indicationElement.Clone;
  legalStatusOfSupply := TFhirMedicinalProductDefinition(oSource).legalStatusOfSupply.Clone;
  additionalMonitoringIndicator := TFhirMedicinalProductDefinition(oSource).additionalMonitoringIndicator.Clone;
  if (TFhirMedicinalProductDefinition(oSource).FSpecialMeasuresList = nil) then
  begin
    FSpecialMeasuresList.free;
    FSpecialMeasuresList := nil;
  end
  else
  begin
    if FSpecialMeasuresList = nil then
      FSpecialMeasuresList := TFhirCodeableConceptList.Create;
    FSpecialMeasuresList.Assign(TFhirMedicinalProductDefinition(oSource).FSpecialMeasuresList);
  end;
  pediatricUseIndicator := TFhirMedicinalProductDefinition(oSource).pediatricUseIndicator.Clone;
  if (TFhirMedicinalProductDefinition(oSource).FClassificationList = nil) then
  begin
    FClassificationList.free;
    FClassificationList := nil;
  end
  else
  begin
    if FClassificationList = nil then
      FClassificationList := TFhirCodeableConceptList.Create;
    FClassificationList.Assign(TFhirMedicinalProductDefinition(oSource).FClassificationList);
  end;
  if (TFhirMedicinalProductDefinition(oSource).FMarketingStatusList = nil) then
  begin
    FMarketingStatusList.free;
    FMarketingStatusList := nil;
  end
  else
  begin
    if FMarketingStatusList = nil then
      FMarketingStatusList := TFhirMarketingStatusList.Create;
    FMarketingStatusList.Assign(TFhirMedicinalProductDefinition(oSource).FMarketingStatusList);
  end;
  if (TFhirMedicinalProductDefinition(oSource).FPackagedMedicinalProductList = nil) then
  begin
    FPackagedMedicinalProductList.free;
    FPackagedMedicinalProductList := nil;
  end
  else
  begin
    if FPackagedMedicinalProductList = nil then
      FPackagedMedicinalProductList := TFhirCodeableConceptList.Create;
    FPackagedMedicinalProductList.Assign(TFhirMedicinalProductDefinition(oSource).FPackagedMedicinalProductList);
  end;
  if (TFhirMedicinalProductDefinition(oSource).FComprisedOfList = nil) then
  begin
    FComprisedOfList.free;
    FComprisedOfList := nil;
  end
  else
  begin
    if FComprisedOfList = nil then
      FComprisedOfList := TFhirReferenceList.Create;
    FComprisedOfList.Assign(TFhirMedicinalProductDefinition(oSource).FComprisedOfList);
  end;
  if (TFhirMedicinalProductDefinition(oSource).FIngredientList = nil) then
  begin
    FIngredientList.free;
    FIngredientList := nil;
  end
  else
  begin
    if FIngredientList = nil then
      FIngredientList := TFhirCodeableConceptList.Create;
    FIngredientList.Assign(TFhirMedicinalProductDefinition(oSource).FIngredientList);
  end;
  if (TFhirMedicinalProductDefinition(oSource).FImpurityList = nil) then
  begin
    FImpurityList.free;
    FImpurityList := nil;
  end
  else
  begin
    if FImpurityList = nil then
      FImpurityList := TFhirCodeableReferenceList.Create;
    FImpurityList.Assign(TFhirMedicinalProductDefinition(oSource).FImpurityList);
  end;
  if (TFhirMedicinalProductDefinition(oSource).FAttachedDocumentList = nil) then
  begin
    FAttachedDocumentList.free;
    FAttachedDocumentList := nil;
  end
  else
  begin
    if FAttachedDocumentList = nil then
      FAttachedDocumentList := TFhirReferenceList.Create;
    FAttachedDocumentList.Assign(TFhirMedicinalProductDefinition(oSource).FAttachedDocumentList);
  end;
  if (TFhirMedicinalProductDefinition(oSource).FMasterFileList = nil) then
  begin
    FMasterFileList.free;
    FMasterFileList := nil;
  end
  else
  begin
    if FMasterFileList = nil then
      FMasterFileList := TFhirReferenceList.Create;
    FMasterFileList.Assign(TFhirMedicinalProductDefinition(oSource).FMasterFileList);
  end;
  if (TFhirMedicinalProductDefinition(oSource).FContactList = nil) then
  begin
    FContactList.free;
    FContactList := nil;
  end
  else
  begin
    if FContactList = nil then
      FContactList := TFhirMedicinalProductDefinitionContactList.Create;
    FContactList.Assign(TFhirMedicinalProductDefinition(oSource).FContactList);
  end;
  if (TFhirMedicinalProductDefinition(oSource).FClinicalTrialList = nil) then
  begin
    FClinicalTrialList.free;
    FClinicalTrialList := nil;
  end
  else
  begin
    if FClinicalTrialList = nil then
      FClinicalTrialList := TFhirReferenceList.Create;
    FClinicalTrialList.Assign(TFhirMedicinalProductDefinition(oSource).FClinicalTrialList);
  end;
  if (TFhirMedicinalProductDefinition(oSource).FCodeList = nil) then
  begin
    FCodeList.free;
    FCodeList := nil;
  end
  else
  begin
    if FCodeList = nil then
      FCodeList := TFhirCodingList.Create;
    FCodeList.Assign(TFhirMedicinalProductDefinition(oSource).FCodeList);
  end;
  if (TFhirMedicinalProductDefinition(oSource).FNameList = nil) then
  begin
    FNameList.free;
    FNameList := nil;
  end
  else
  begin
    if FNameList = nil then
      FNameList := TFhirMedicinalProductDefinitionNameList.Create;
    FNameList.Assign(TFhirMedicinalProductDefinition(oSource).FNameList);
  end;
  if (TFhirMedicinalProductDefinition(oSource).FCrossReferenceList = nil) then
  begin
    FCrossReferenceList.free;
    FCrossReferenceList := nil;
  end
  else
  begin
    if FCrossReferenceList = nil then
      FCrossReferenceList := TFhirMedicinalProductDefinitionCrossReferenceList.Create;
    FCrossReferenceList.Assign(TFhirMedicinalProductDefinition(oSource).FCrossReferenceList);
  end;
  if (TFhirMedicinalProductDefinition(oSource).FOperationList = nil) then
  begin
    FOperationList.free;
    FOperationList := nil;
  end
  else
  begin
    if FOperationList = nil then
      FOperationList := TFhirMedicinalProductDefinitionOperationList.Create;
    FOperationList.Assign(TFhirMedicinalProductDefinition(oSource).FOperationList);
  end;
  if (TFhirMedicinalProductDefinition(oSource).FCharacteristicList = nil) then
  begin
    FCharacteristicList.free;
    FCharacteristicList := nil;
  end
  else
  begin
    if FCharacteristicList = nil then
      FCharacteristicList := TFhirMedicinalProductDefinitionCharacteristicList.Create;
    FCharacteristicList.Assign(TFhirMedicinalProductDefinition(oSource).FCharacteristicList);
  end;
end;

function TFhirMedicinalProductDefinition.GetResourceType : TFhirResourceType;
begin
  result := frtMedicinalProductDefinition;
end;

procedure TFhirMedicinalProductDefinition.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'identifier') Then
    list.addAll(self, 'identifier', FIdentifierList);
  if (child_name = 'type') Then
     list.add(self.link, 'type', FType_.Link);
  if (child_name = 'domain') Then
     list.add(self.link, 'domain', FDomain.Link);
  if (child_name = 'version') Then
     list.add(self.link, 'version', FVersion.Link);
  if (child_name = 'status') Then
     list.add(self.link, 'status', FStatus.Link);
  if (child_name = 'statusDate') Then
     list.add(self.link, 'statusDate', FStatusDate.Link);
  if (child_name = 'description') Then
     list.add(self.link, 'description', FDescription.Link);
  if (child_name = 'combinedPharmaceuticalDoseForm') Then
     list.add(self.link, 'combinedPharmaceuticalDoseForm', FCombinedPharmaceuticalDoseForm.Link);
  if (child_name = 'route') Then
    list.addAll(self, 'route', FRouteList);
  if (child_name = 'indication') Then
     list.add(self.link, 'indication', FIndication.Link);
  if (child_name = 'legalStatusOfSupply') Then
     list.add(self.link, 'legalStatusOfSupply', FLegalStatusOfSupply.Link);
  if (child_name = 'additionalMonitoringIndicator') Then
     list.add(self.link, 'additionalMonitoringIndicator', FAdditionalMonitoringIndicator.Link);
  if (child_name = 'specialMeasures') Then
    list.addAll(self, 'specialMeasures', FSpecialMeasuresList);
  if (child_name = 'pediatricUseIndicator') Then
     list.add(self.link, 'pediatricUseIndicator', FPediatricUseIndicator.Link);
  if (child_name = 'classification') Then
    list.addAll(self, 'classification', FClassificationList);
  if (child_name = 'marketingStatus') Then
    list.addAll(self, 'marketingStatus', FMarketingStatusList);
  if (child_name = 'packagedMedicinalProduct') Then
    list.addAll(self, 'packagedMedicinalProduct', FPackagedMedicinalProductList);
  if (child_name = 'comprisedOf') Then
    list.addAll(self, 'comprisedOf', FComprisedOfList);
  if (child_name = 'ingredient') Then
    list.addAll(self, 'ingredient', FIngredientList);
  if (child_name = 'impurity') Then
    list.addAll(self, 'impurity', FImpurityList);
  if (child_name = 'attachedDocument') Then
    list.addAll(self, 'attachedDocument', FAttachedDocumentList);
  if (child_name = 'masterFile') Then
    list.addAll(self, 'masterFile', FMasterFileList);
  if (child_name = 'contact') Then
    list.addAll(self, 'contact', FContactList);
  if (child_name = 'clinicalTrial') Then
    list.addAll(self, 'clinicalTrial', FClinicalTrialList);
  if (child_name = 'code') Then
    list.addAll(self, 'code', FCodeList);
  if (child_name = 'name') Then
    list.addAll(self, 'name', FNameList);
  if (child_name = 'crossReference') Then
    list.addAll(self, 'crossReference', FCrossReferenceList);
  if (child_name = 'operation') Then
    list.addAll(self, 'operation', FOperationList);
  if (child_name = 'characteristic') Then
    list.addAll(self, 'characteristic', FCharacteristicList);
end;

procedure TFhirMedicinalProductDefinition.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'identifier', 'Identifier', true, TFhirIdentifier, FIdentifierList.Link));
  oList.add(TFHIRProperty.create(self, 'type', 'CodeableConcept', false, TFhirCodeableConcept, FType_.Link));
  oList.add(TFHIRProperty.create(self, 'domain', 'CodeableConcept', false, TFhirCodeableConcept, FDomain.Link));
  oList.add(TFHIRProperty.create(self, 'version', 'string', false, TFhirString, FVersion.Link));
  oList.add(TFHIRProperty.create(self, 'status', 'CodeableConcept', false, TFhirCodeableConcept, FStatus.Link));
  oList.add(TFHIRProperty.create(self, 'statusDate', 'dateTime', false, TFhirDateTime, FStatusDate.Link));
  oList.add(TFHIRProperty.create(self, 'description', 'markdown', false, TFhirMarkdown, FDescription.Link));
  oList.add(TFHIRProperty.create(self, 'combinedPharmaceuticalDoseForm', 'CodeableConcept', false, TFhirCodeableConcept, FCombinedPharmaceuticalDoseForm.Link));
  oList.add(TFHIRProperty.create(self, 'route', 'CodeableConcept', true, TFhirCodeableConcept, FRouteList.Link));
  oList.add(TFHIRProperty.create(self, 'indication', 'markdown', false, TFhirMarkdown, FIndication.Link));
  oList.add(TFHIRProperty.create(self, 'legalStatusOfSupply', 'CodeableConcept', false, TFhirCodeableConcept, FLegalStatusOfSupply.Link));
  oList.add(TFHIRProperty.create(self, 'additionalMonitoringIndicator', 'CodeableConcept', false, TFhirCodeableConcept, FAdditionalMonitoringIndicator.Link));
  oList.add(TFHIRProperty.create(self, 'specialMeasures', 'CodeableConcept', true, TFhirCodeableConcept, FSpecialMeasuresList.Link));
  oList.add(TFHIRProperty.create(self, 'pediatricUseIndicator', 'CodeableConcept', false, TFhirCodeableConcept, FPediatricUseIndicator.Link));
  oList.add(TFHIRProperty.create(self, 'classification', 'CodeableConcept', true, TFhirCodeableConcept, FClassificationList.Link));
  oList.add(TFHIRProperty.create(self, 'marketingStatus', 'MarketingStatus', true, TFhirMarketingStatus, FMarketingStatusList.Link));
  oList.add(TFHIRProperty.create(self, 'packagedMedicinalProduct', 'CodeableConcept', true, TFhirCodeableConcept, FPackagedMedicinalProductList.Link));
  oList.add(TFHIRProperty.create(self, 'comprisedOf', 'Reference', true, TFhirReference, FComprisedOfList.Link));
  oList.add(TFHIRProperty.create(self, 'ingredient', 'CodeableConcept', true, TFhirCodeableConcept, FIngredientList.Link));
  oList.add(TFHIRProperty.create(self, 'impurity', 'CodeableReference', true, TFhirCodeableReference, FImpurityList.Link));
  oList.add(TFHIRProperty.create(self, 'attachedDocument', 'Reference', true, TFhirReference, FAttachedDocumentList.Link));
  oList.add(TFHIRProperty.create(self, 'masterFile', 'Reference', true, TFhirReference, FMasterFileList.Link));
  oList.add(TFHIRProperty.create(self, 'contact', 'BackboneElement', true, TFhirMedicinalProductDefinitionContact, FContactList.Link));
  oList.add(TFHIRProperty.create(self, 'clinicalTrial', 'Reference', true, TFhirReference, FClinicalTrialList.Link));
  oList.add(TFHIRProperty.create(self, 'code', 'Coding', true, TFhirCoding, FCodeList.Link));
  oList.add(TFHIRProperty.create(self, 'name', 'BackboneElement', true, TFhirMedicinalProductDefinitionName, FNameList.Link));
  oList.add(TFHIRProperty.create(self, 'crossReference', 'BackboneElement', true, TFhirMedicinalProductDefinitionCrossReference, FCrossReferenceList.Link));
  oList.add(TFHIRProperty.create(self, 'operation', 'BackboneElement', true, TFhirMedicinalProductDefinitionOperation, FOperationList.Link));
  oList.add(TFHIRProperty.create(self, 'characteristic', 'BackboneElement', true, TFhirMedicinalProductDefinitionCharacteristic, FCharacteristicList.Link));
end;

function TFhirMedicinalProductDefinition.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'identifier') then
  begin
    IdentifierList.add(propValue as TFhirIdentifier);
    result := propValue;
  end
  else if (propName = 'type') then
  begin
    Type_ := propValue as TFhirCodeableConcept;
    result := propValue;
  end
  else if (propName = 'domain') then
  begin
    Domain := propValue as TFhirCodeableConcept;
    result := propValue;
  end
  else if (propName = 'version') then
  begin
    VersionElement := asString(propValue);
    result := propValue;
  end
  else if (propName = 'status') then
  begin
    Status := propValue as TFhirCodeableConcept;
    result := propValue;
  end
  else if (propName = 'statusDate') then
  begin
    StatusDateElement := asDateTime(propValue);
    result := propValue;
  end
  else if (propName = 'description') then
  begin
    DescriptionElement := asMarkdown(propValue);
    result := propValue;
  end
  else if (propName = 'combinedPharmaceuticalDoseForm') then
  begin
    CombinedPharmaceuticalDoseForm := propValue as TFhirCodeableConcept;
    result := propValue;
  end
  else if (propName = 'route') then
  begin
    RouteList.add(propValue as TFhirCodeableConcept);
    result := propValue;
  end
  else if (propName = 'indication') then
  begin
    IndicationElement := asMarkdown(propValue);
    result := propValue;
  end
  else if (propName = 'legalStatusOfSupply') then
  begin
    LegalStatusOfSupply := propValue as TFhirCodeableConcept;
    result := propValue;
  end
  else if (propName = 'additionalMonitoringIndicator') then
  begin
    AdditionalMonitoringIndicator := propValue as TFhirCodeableConcept;
    result := propValue;
  end
  else if (propName = 'specialMeasures') then
  begin
    SpecialMeasuresList.add(propValue as TFhirCodeableConcept);
    result := propValue;
  end
  else if (propName = 'pediatricUseIndicator') then
  begin
    PediatricUseIndicator := propValue as TFhirCodeableConcept;
    result := propValue;
  end
  else if (propName = 'classification') then
  begin
    ClassificationList.add(propValue as TFhirCodeableConcept);
    result := propValue;
  end
  else if (propName = 'marketingStatus') then
  begin
    MarketingStatusList.add(propValue as TFhirMarketingStatus);
    result := propValue;
  end
  else if (propName = 'packagedMedicinalProduct') then
  begin
    PackagedMedicinalProductList.add(propValue as TFhirCodeableConcept);
    result := propValue;
  end
  else if (propName = 'comprisedOf') then
  begin
    ComprisedOfList.add(propValue as TFhirReference);
    result := propValue;
  end
  else if (propName = 'ingredient') then
  begin
    IngredientList.add(propValue as TFhirCodeableConcept);
    result := propValue;
  end
  else if (propName = 'impurity') then
  begin
    ImpurityList.add(propValue as TFhirCodeableReference);
    result := propValue;
  end
  else if (propName = 'attachedDocument') then
  begin
    AttachedDocumentList.add(propValue as TFhirReference);
    result := propValue;
  end
  else if (propName = 'masterFile') then
  begin
    MasterFileList.add(propValue as TFhirReference);
    result := propValue;
  end
  else if (propName = 'contact') then
  begin
    ContactList.add(propValue as TFhirMedicinalProductDefinitionContact);
    result := propValue;
  end
  else if (propName = 'clinicalTrial') then
  begin
    ClinicalTrialList.add(propValue as TFhirReference);
    result := propValue;
  end
  else if (propName = 'code') then
  begin
    CodeList.add(propValue as TFhirCoding);
    result := propValue;
  end
  else if (propName = 'name') then
  begin
    NameList.add(propValue as TFhirMedicinalProductDefinitionName);
    result := propValue;
  end
  else if (propName = 'crossReference') then
  begin
    CrossReferenceList.add(propValue as TFhirMedicinalProductDefinitionCrossReference);
    result := propValue;
  end
  else if (propName = 'operation') then
  begin
    OperationList.add(propValue as TFhirMedicinalProductDefinitionOperation);
    result := propValue;
  end
  else if (propName = 'characteristic') then
  begin
    CharacteristicList.add(propValue as TFhirMedicinalProductDefinitionCharacteristic);
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirMedicinalProductDefinition.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'identifier') then IdentifierList.insertItem(index, propValue as TFhirIdentifier)
  else if (propName = 'route') then RouteList.insertItem(index, propValue as TFhirCodeableConcept)
  else if (propName = 'specialMeasures') then SpecialMeasuresList.insertItem(index, propValue as TFhirCodeableConcept)
  else if (propName = 'classification') then ClassificationList.insertItem(index, propValue as TFhirCodeableConcept)
  else if (propName = 'marketingStatus') then MarketingStatusList.insertItem(index, propValue as TFhirMarketingStatus)
  else if (propName = 'packagedMedicinalProduct') then PackagedMedicinalProductList.insertItem(index, propValue as TFhirCodeableConcept)
  else if (propName = 'comprisedOf') then ComprisedOfList.insertItem(index, propValue as TFhirReference)
  else if (propName = 'ingredient') then IngredientList.insertItem(index, propValue as TFhirCodeableConcept)
  else if (propName = 'impurity') then ImpurityList.insertItem(index, propValue as TFhirCodeableReference)
  else if (propName = 'attachedDocument') then AttachedDocumentList.insertItem(index, propValue as TFhirReference)
  else if (propName = 'masterFile') then MasterFileList.insertItem(index, propValue as TFhirReference)
  else if (propName = 'contact') then ContactList.insertItem(index, propValue as TFhirMedicinalProductDefinitionContact)
  else if (propName = 'clinicalTrial') then ClinicalTrialList.insertItem(index, propValue as TFhirReference)
  else if (propName = 'code') then CodeList.insertItem(index, propValue as TFhirCoding)
  else if (propName = 'name') then NameList.insertItem(index, propValue as TFhirMedicinalProductDefinitionName)
  else if (propName = 'crossReference') then CrossReferenceList.insertItem(index, propValue as TFhirMedicinalProductDefinitionCrossReference)
  else if (propName = 'operation') then OperationList.insertItem(index, propValue as TFhirMedicinalProductDefinitionOperation)
  else if (propName = 'characteristic') then CharacteristicList.insertItem(index, propValue as TFhirMedicinalProductDefinitionCharacteristic)
  else inherited;
end;

function TFhirMedicinalProductDefinition.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'identifier') then result := IdentifierList.new()
  else if (propName = 'type') then result := TFhirCodeableConcept.create()
  else if (propName = 'domain') then result := TFhirCodeableConcept.create()
  else if (propName = 'version') then result := TFhirString.create()
  else if (propName = 'status') then result := TFhirCodeableConcept.create()
  else if (propName = 'statusDate') then result := TFhirDateTime.create()
  else if (propName = 'description') then result := TFhirMarkdown.create()
  else if (propName = 'combinedPharmaceuticalDoseForm') then result := TFhirCodeableConcept.create()
  else if (propName = 'route') then result := RouteList.new()
  else if (propName = 'indication') then result := TFhirMarkdown.create()
  else if (propName = 'legalStatusOfSupply') then result := TFhirCodeableConcept.create()
  else if (propName = 'additionalMonitoringIndicator') then result := TFhirCodeableConcept.create()
  else if (propName = 'specialMeasures') then result := SpecialMeasuresList.new()
  else if (propName = 'pediatricUseIndicator') then result := TFhirCodeableConcept.create()
  else if (propName = 'classification') then result := ClassificationList.new()
  else if (propName = 'marketingStatus') then result := MarketingStatusList.new()
  else if (propName = 'packagedMedicinalProduct') then result := PackagedMedicinalProductList.new()
  else if (propName = 'comprisedOf') then result := ComprisedOfList.new()
  else if (propName = 'ingredient') then result := IngredientList.new()
  else if (propName = 'impurity') then result := ImpurityList.new()
  else if (propName = 'attachedDocument') then result := AttachedDocumentList.new()
  else if (propName = 'masterFile') then result := MasterFileList.new()
  else if (propName = 'contact') then result := ContactList.new()
  else if (propName = 'clinicalTrial') then result := ClinicalTrialList.new()
  else if (propName = 'code') then result := CodeList.new()
  else if (propName = 'name') then result := NameList.new()
  else if (propName = 'crossReference') then result := CrossReferenceList.new()
  else if (propName = 'operation') then result := OperationList.new()
  else if (propName = 'characteristic') then result := CharacteristicList.new()
  else result := inherited createPropertyValue(propName);
end;

function TFhirMedicinalProductDefinition.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'identifier') then result := 'Identifier'
  else if (propName = 'type') then result := 'CodeableConcept'
  else if (propName = 'domain') then result := 'CodeableConcept'
  else if (propName = 'version') then result := 'string'
  else if (propName = 'status') then result := 'CodeableConcept'
  else if (propName = 'statusDate') then result := 'dateTime'
  else if (propName = 'description') then result := 'markdown'
  else if (propName = 'combinedPharmaceuticalDoseForm') then result := 'CodeableConcept'
  else if (propName = 'route') then result := 'CodeableConcept'
  else if (propName = 'indication') then result := 'markdown'
  else if (propName = 'legalStatusOfSupply') then result := 'CodeableConcept'
  else if (propName = 'additionalMonitoringIndicator') then result := 'CodeableConcept'
  else if (propName = 'specialMeasures') then result := 'CodeableConcept'
  else if (propName = 'pediatricUseIndicator') then result := 'CodeableConcept'
  else if (propName = 'classification') then result := 'CodeableConcept'
  else if (propName = 'marketingStatus') then result := 'MarketingStatus'
  else if (propName = 'packagedMedicinalProduct') then result := 'CodeableConcept'
  else if (propName = 'comprisedOf') then result := 'Reference'
  else if (propName = 'ingredient') then result := 'CodeableConcept'
  else if (propName = 'impurity') then result := 'CodeableReference'
  else if (propName = 'attachedDocument') then result := 'Reference'
  else if (propName = 'masterFile') then result := 'Reference'
  else if (propName = 'contact') then result := 'BackboneElement'
  else if (propName = 'clinicalTrial') then result := 'Reference'
  else if (propName = 'code') then result := 'Coding'
  else if (propName = 'name') then result := 'BackboneElement'
  else if (propName = 'crossReference') then result := 'BackboneElement'
  else if (propName = 'operation') then result := 'BackboneElement'
  else if (propName = 'characteristic') then result := 'BackboneElement'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirMedicinalProductDefinition.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'identifier') then deletePropertyValue('identifier', IdentifierList, value)
  else if (propName = 'type') then Type_Element := nil
  else if (propName = 'domain') then DomainElement := nil
  else if (propName = 'version') then VersionElement := nil
  else if (propName = 'status') then StatusElement := nil
  else if (propName = 'statusDate') then StatusDateElement := nil
  else if (propName = 'description') then DescriptionElement := nil
  else if (propName = 'combinedPharmaceuticalDoseForm') then CombinedPharmaceuticalDoseFormElement := nil
  else if (propName = 'route') then deletePropertyValue('route', RouteList, value)
  else if (propName = 'indication') then IndicationElement := nil
  else if (propName = 'legalStatusOfSupply') then LegalStatusOfSupplyElement := nil
  else if (propName = 'additionalMonitoringIndicator') then AdditionalMonitoringIndicatorElement := nil
  else if (propName = 'specialMeasures') then deletePropertyValue('specialMeasures', SpecialMeasuresList, value)
  else if (propName = 'pediatricUseIndicator') then PediatricUseIndicatorElement := nil
  else if (propName = 'classification') then deletePropertyValue('classification', ClassificationList, value)
  else if (propName = 'marketingStatus') then deletePropertyValue('marketingStatus', MarketingStatusList, value)
  else if (propName = 'packagedMedicinalProduct') then deletePropertyValue('packagedMedicinalProduct', PackagedMedicinalProductList, value)
  else if (propName = 'comprisedOf') then deletePropertyValue('comprisedOf', ComprisedOfList, value)
  else if (propName = 'ingredient') then deletePropertyValue('ingredient', IngredientList, value)
  else if (propName = 'impurity') then deletePropertyValue('impurity', ImpurityList, value)
  else if (propName = 'attachedDocument') then deletePropertyValue('attachedDocument', AttachedDocumentList, value)
  else if (propName = 'masterFile') then deletePropertyValue('masterFile', MasterFileList, value)
  else if (propName = 'contact') then deletePropertyValue('contact', ContactList, value)
  else if (propName = 'clinicalTrial') then deletePropertyValue('clinicalTrial', ClinicalTrialList, value)
  else if (propName = 'code') then deletePropertyValue('code', CodeList, value)
  else if (propName = 'name') then deletePropertyValue('name', NameList, value)
  else if (propName = 'crossReference') then deletePropertyValue('crossReference', CrossReferenceList, value)
  else if (propName = 'operation') then deletePropertyValue('operation', OperationList, value)
  else if (propName = 'characteristic') then deletePropertyValue('characteristic', CharacteristicList, value)
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirMedicinalProductDefinition.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'identifier') then replacePropertyValue('identifier', IdentifierList, existing, new)
  else if (propName = 'type') then Type_Element := new as TFhirCodeableConcept
  else if (propName = 'domain') then DomainElement := new as TFhirCodeableConcept
  else if (propName = 'version') then VersionElement := asString(new)
  else if (propName = 'status') then StatusElement := new as TFhirCodeableConcept
  else if (propName = 'statusDate') then StatusDateElement := asDateTime(new)
  else if (propName = 'description') then DescriptionElement := asMarkdown(new)
  else if (propName = 'combinedPharmaceuticalDoseForm') then CombinedPharmaceuticalDoseFormElement := new as TFhirCodeableConcept
  else if (propName = 'route') then replacePropertyValue('route', RouteList, existing, new)
  else if (propName = 'indication') then IndicationElement := asMarkdown(new)
  else if (propName = 'legalStatusOfSupply') then LegalStatusOfSupplyElement := new as TFhirCodeableConcept
  else if (propName = 'additionalMonitoringIndicator') then AdditionalMonitoringIndicatorElement := new as TFhirCodeableConcept
  else if (propName = 'specialMeasures') then replacePropertyValue('specialMeasures', SpecialMeasuresList, existing, new)
  else if (propName = 'pediatricUseIndicator') then PediatricUseIndicatorElement := new as TFhirCodeableConcept
  else if (propName = 'classification') then replacePropertyValue('classification', ClassificationList, existing, new)
  else if (propName = 'marketingStatus') then replacePropertyValue('marketingStatus', MarketingStatusList, existing, new)
  else if (propName = 'packagedMedicinalProduct') then replacePropertyValue('packagedMedicinalProduct', PackagedMedicinalProductList, existing, new)
  else if (propName = 'comprisedOf') then replacePropertyValue('comprisedOf', ComprisedOfList, existing, new)
  else if (propName = 'ingredient') then replacePropertyValue('ingredient', IngredientList, existing, new)
  else if (propName = 'impurity') then replacePropertyValue('impurity', ImpurityList, existing, new)
  else if (propName = 'attachedDocument') then replacePropertyValue('attachedDocument', AttachedDocumentList, existing, new)
  else if (propName = 'masterFile') then replacePropertyValue('masterFile', MasterFileList, existing, new)
  else if (propName = 'contact') then replacePropertyValue('contact', ContactList, existing, new)
  else if (propName = 'clinicalTrial') then replacePropertyValue('clinicalTrial', ClinicalTrialList, existing, new)
  else if (propName = 'code') then replacePropertyValue('code', CodeList, existing, new)
  else if (propName = 'name') then replacePropertyValue('name', NameList, existing, new)
  else if (propName = 'crossReference') then replacePropertyValue('crossReference', CrossReferenceList, existing, new)
  else if (propName = 'operation') then replacePropertyValue('operation', OperationList, existing, new)
  else if (propName = 'characteristic') then replacePropertyValue('characteristic', CharacteristicList, existing, new)
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirMedicinalProductDefinition.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'identifier') then IdentifierList.move(source, destination)
  else if (propName = 'route') then RouteList.move(source, destination)
  else if (propName = 'specialMeasures') then SpecialMeasuresList.move(source, destination)
  else if (propName = 'classification') then ClassificationList.move(source, destination)
  else if (propName = 'marketingStatus') then MarketingStatusList.move(source, destination)
  else if (propName = 'packagedMedicinalProduct') then PackagedMedicinalProductList.move(source, destination)
  else if (propName = 'comprisedOf') then ComprisedOfList.move(source, destination)
  else if (propName = 'ingredient') then IngredientList.move(source, destination)
  else if (propName = 'impurity') then ImpurityList.move(source, destination)
  else if (propName = 'attachedDocument') then AttachedDocumentList.move(source, destination)
  else if (propName = 'masterFile') then MasterFileList.move(source, destination)
  else if (propName = 'contact') then ContactList.move(source, destination)
  else if (propName = 'clinicalTrial') then ClinicalTrialList.move(source, destination)
  else if (propName = 'code') then CodeList.move(source, destination)
  else if (propName = 'name') then NameList.move(source, destination)
  else if (propName = 'crossReference') then CrossReferenceList.move(source, destination)
  else if (propName = 'operation') then OperationList.move(source, destination)
  else if (propName = 'characteristic') then CharacteristicList.move(source, destination)
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirMedicinalProductDefinition.fhirType : string;
begin
  result := 'MedicinalProductDefinition';
end;

function TFhirMedicinalProductDefinition.Link : TFhirMedicinalProductDefinition;
begin
  result := TFhirMedicinalProductDefinition(inherited Link);
end;

function TFhirMedicinalProductDefinition.Clone : TFhirMedicinalProductDefinition;
begin
  result := TFhirMedicinalProductDefinition(inherited Clone);
end;

function TFhirMedicinalProductDefinition.equals(other : TObject) : boolean; 
var
  o : TFhirMedicinalProductDefinition;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirMedicinalProductDefinition)) then
    result := false
  else
  begin
    o := TFhirMedicinalProductDefinition(other);
    result := compareDeep(identifierList, o.identifierList, true) and compareDeep(type_Element, o.type_Element, true) and 
      compareDeep(domainElement, o.domainElement, true) and compareDeep(versionElement, o.versionElement, true) and 
      compareDeep(statusElement, o.statusElement, true) and compareDeep(statusDateElement, o.statusDateElement, true) and 
      compareDeep(descriptionElement, o.descriptionElement, true) and compareDeep(combinedPharmaceuticalDoseFormElement, o.combinedPharmaceuticalDoseFormElement, true) and 
      compareDeep(routeList, o.routeList, true) and compareDeep(indicationElement, o.indicationElement, true) and 
      compareDeep(legalStatusOfSupplyElement, o.legalStatusOfSupplyElement, true) and 
      compareDeep(additionalMonitoringIndicatorElement, o.additionalMonitoringIndicatorElement, true) and 
      compareDeep(specialMeasuresList, o.specialMeasuresList, true) and compareDeep(pediatricUseIndicatorElement, o.pediatricUseIndicatorElement, true) and 
      compareDeep(classificationList, o.classificationList, true) and compareDeep(marketingStatusList, o.marketingStatusList, true) and 
      compareDeep(packagedMedicinalProductList, o.packagedMedicinalProductList, true) and 
      compareDeep(comprisedOfList, o.comprisedOfList, true) and compareDeep(ingredientList, o.ingredientList, true) and 
      compareDeep(impurityList, o.impurityList, true) and compareDeep(attachedDocumentList, o.attachedDocumentList, true) and 
      compareDeep(masterFileList, o.masterFileList, true) and compareDeep(contactList, o.contactList, true) and 
      compareDeep(clinicalTrialList, o.clinicalTrialList, true) and compareDeep(codeList, o.codeList, true) and 
      compareDeep(nameList, o.nameList, true) and compareDeep(crossReferenceList, o.crossReferenceList, true) and 
      compareDeep(operationList, o.operationList, true) and compareDeep(characteristicList, o.characteristicList, true);
  end;
end;

function TFhirMedicinalProductDefinition.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FidentifierList) and isEmptyProp(FType_) and isEmptyProp(FDomain) and isEmptyProp(FVersion) and isEmptyProp(FStatus) and isEmptyProp(FStatusDate) and isEmptyProp(FDescription) and isEmptyProp(FCombinedPharmaceuticalDoseForm) and isEmptyProp(FrouteList) and isEmptyProp(FIndication) and isEmptyProp(FLegalStatusOfSupply) and isEmptyProp(FAdditionalMonitoringIndicator) and isEmptyProp(FspecialMeasuresList) and isEmptyProp(FPediatricUseIndicator) and isEmptyProp(FclassificationList) and isEmptyProp(FmarketingStatusList) and isEmptyProp(FpackagedMedicinalProductList) and isEmptyProp(FcomprisedOfList) and isEmptyProp(FingredientList) and isEmptyProp(FimpurityList) and isEmptyProp(FattachedDocumentList) and isEmptyProp(FmasterFileList) and isEmptyProp(FcontactList) and isEmptyProp(FclinicalTrialList) and isEmptyProp(FcodeList) and isEmptyProp(FnameList) and isEmptyProp(FcrossReferenceList) and isEmptyProp(FoperationList) and isEmptyProp(FcharacteristicList);
end;

procedure TFhirMedicinalProductDefinition.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('identifier');
  fields.add('type');
  fields.add('domain');
  fields.add('version');
  fields.add('status');
  fields.add('statusDate');
  fields.add('description');
  fields.add('combinedPharmaceuticalDoseForm');
  fields.add('route');
  fields.add('indication');
  fields.add('legalStatusOfSupply');
  fields.add('additionalMonitoringIndicator');
  fields.add('specialMeasures');
  fields.add('pediatricUseIndicator');
  fields.add('classification');
  fields.add('marketingStatus');
  fields.add('packagedMedicinalProduct');
  fields.add('comprisedOf');
  fields.add('ingredient');
  fields.add('impurity');
  fields.add('attachedDocument');
  fields.add('masterFile');
  fields.add('contact');
  fields.add('clinicalTrial');
  fields.add('code');
  fields.add('name');
  fields.add('crossReference');
  fields.add('operation');
  fields.add('characteristic');
end;

function TFhirMedicinalProductDefinition.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
  inc(result, FIdentifierList.sizeInBytes(magic));
  inc(result, FRouteList.sizeInBytes(magic));
  inc(result, FSpecialMeasuresList.sizeInBytes(magic));
  inc(result, FClassificationList.sizeInBytes(magic));
  inc(result, FMarketingStatusList.sizeInBytes(magic));
  inc(result, FPackagedMedicinalProductList.sizeInBytes(magic));
  inc(result, FComprisedOfList.sizeInBytes(magic));
  inc(result, FIngredientList.sizeInBytes(magic));
  inc(result, FImpurityList.sizeInBytes(magic));
  inc(result, FAttachedDocumentList.sizeInBytes(magic));
  inc(result, FMasterFileList.sizeInBytes(magic));
  inc(result, FContactList.sizeInBytes(magic));
  inc(result, FClinicalTrialList.sizeInBytes(magic));
  inc(result, FCodeList.sizeInBytes(magic));
  inc(result, FNameList.sizeInBytes(magic));
  inc(result, FCrossReferenceList.sizeInBytes(magic));
  inc(result, FOperationList.sizeInBytes(magic));
  inc(result, FCharacteristicList.sizeInBytes(magic));
end;

function TFhirMedicinalProductDefinition.GetIdentifierList : TFhirIdentifierList;
begin
  if FIdentifierList = nil then
    FIdentifierList := TFhirIdentifierList.Create;
  result := FIdentifierList;
end;

function TFhirMedicinalProductDefinition.GetHasIdentifierList : boolean;
begin
  result := (FIdentifierList <> nil) and (FIdentifierList.count > 0);
end;

procedure TFhirMedicinalProductDefinition.SetType_(value : TFhirCodeableConcept);
begin
  FType_.free;
  FType_ := value;
end;

procedure TFhirMedicinalProductDefinition.SetDomain(value : TFhirCodeableConcept);
begin
  FDomain.free;
  FDomain := value;
end;

procedure TFhirMedicinalProductDefinition.SetVersion(value : TFhirString);
begin
  FVersion.free;
  FVersion := value;
end;

function TFhirMedicinalProductDefinition.GetVersionST : String;
begin
  if FVersion = nil then
    result := ''
  else
    result := FVersion.value;
end;

procedure TFhirMedicinalProductDefinition.SetVersionST(value : String);
begin
  if value <> '' then
  begin
    if FVersion = nil then
      FVersion := TFhirString.create;
    FVersion.value := value
  end
  else if FVersion <> nil then
    FVersion.value := '';
end;

procedure TFhirMedicinalProductDefinition.SetStatus(value : TFhirCodeableConcept);
begin
  FStatus.free;
  FStatus := value;
end;

procedure TFhirMedicinalProductDefinition.SetStatusDate(value : TFhirDateTime);
begin
  FStatusDate.free;
  FStatusDate := value;
end;

function TFhirMedicinalProductDefinition.GetStatusDateST : TFslDateTime;
begin
  if FStatusDate = nil then
    result := TFslDateTime.makeNull
  else
    result := FStatusDate.value;
end;

procedure TFhirMedicinalProductDefinition.SetStatusDateST(value : TFslDateTime);
begin
  if FStatusDate = nil then
    FStatusDate := TFhirDateTime.create;
  FStatusDate.value := value
end;

procedure TFhirMedicinalProductDefinition.SetDescription(value : TFhirMarkdown);
begin
  FDescription.free;
  FDescription := value;
end;

function TFhirMedicinalProductDefinition.GetDescriptionST : String;
begin
  if FDescription = nil then
    result := ''
  else
    result := FDescription.value;
end;

procedure TFhirMedicinalProductDefinition.SetDescriptionST(value : String);
begin
  if value <> '' then
  begin
    if FDescription = nil then
      FDescription := TFhirMarkdown.create;
    FDescription.value := value
  end
  else if FDescription <> nil then
    FDescription.value := '';
end;

procedure TFhirMedicinalProductDefinition.SetCombinedPharmaceuticalDoseForm(value : TFhirCodeableConcept);
begin
  FCombinedPharmaceuticalDoseForm.free;
  FCombinedPharmaceuticalDoseForm := value;
end;

function TFhirMedicinalProductDefinition.GetRouteList : TFhirCodeableConceptList;
begin
  if FRouteList = nil then
    FRouteList := TFhirCodeableConceptList.Create;
  result := FRouteList;
end;

function TFhirMedicinalProductDefinition.GetHasRouteList : boolean;
begin
  result := (FRouteList <> nil) and (FRouteList.count > 0);
end;

procedure TFhirMedicinalProductDefinition.SetIndication(value : TFhirMarkdown);
begin
  FIndication.free;
  FIndication := value;
end;

function TFhirMedicinalProductDefinition.GetIndicationST : String;
begin
  if FIndication = nil then
    result := ''
  else
    result := FIndication.value;
end;

procedure TFhirMedicinalProductDefinition.SetIndicationST(value : String);
begin
  if value <> '' then
  begin
    if FIndication = nil then
      FIndication := TFhirMarkdown.create;
    FIndication.value := value
  end
  else if FIndication <> nil then
    FIndication.value := '';
end;

procedure TFhirMedicinalProductDefinition.SetLegalStatusOfSupply(value : TFhirCodeableConcept);
begin
  FLegalStatusOfSupply.free;
  FLegalStatusOfSupply := value;
end;

procedure TFhirMedicinalProductDefinition.SetAdditionalMonitoringIndicator(value : TFhirCodeableConcept);
begin
  FAdditionalMonitoringIndicator.free;
  FAdditionalMonitoringIndicator := value;
end;

function TFhirMedicinalProductDefinition.GetSpecialMeasuresList : TFhirCodeableConceptList;
begin
  if FSpecialMeasuresList = nil then
    FSpecialMeasuresList := TFhirCodeableConceptList.Create;
  result := FSpecialMeasuresList;
end;

function TFhirMedicinalProductDefinition.GetHasSpecialMeasuresList : boolean;
begin
  result := (FSpecialMeasuresList <> nil) and (FSpecialMeasuresList.count > 0);
end;

procedure TFhirMedicinalProductDefinition.SetPediatricUseIndicator(value : TFhirCodeableConcept);
begin
  FPediatricUseIndicator.free;
  FPediatricUseIndicator := value;
end;

function TFhirMedicinalProductDefinition.GetClassificationList : TFhirCodeableConceptList;
begin
  if FClassificationList = nil then
    FClassificationList := TFhirCodeableConceptList.Create;
  result := FClassificationList;
end;

function TFhirMedicinalProductDefinition.GetHasClassificationList : boolean;
begin
  result := (FClassificationList <> nil) and (FClassificationList.count > 0);
end;

function TFhirMedicinalProductDefinition.GetMarketingStatusList : TFhirMarketingStatusList;
begin
  if FMarketingStatusList = nil then
    FMarketingStatusList := TFhirMarketingStatusList.Create;
  result := FMarketingStatusList;
end;

function TFhirMedicinalProductDefinition.GetHasMarketingStatusList : boolean;
begin
  result := (FMarketingStatusList <> nil) and (FMarketingStatusList.count > 0);
end;

function TFhirMedicinalProductDefinition.GetPackagedMedicinalProductList : TFhirCodeableConceptList;
begin
  if FPackagedMedicinalProductList = nil then
    FPackagedMedicinalProductList := TFhirCodeableConceptList.Create;
  result := FPackagedMedicinalProductList;
end;

function TFhirMedicinalProductDefinition.GetHasPackagedMedicinalProductList : boolean;
begin
  result := (FPackagedMedicinalProductList <> nil) and (FPackagedMedicinalProductList.count > 0);
end;

function TFhirMedicinalProductDefinition.GetComprisedOfList : TFhirReferenceList;
begin
  if FComprisedOfList = nil then
    FComprisedOfList := TFhirReferenceList.Create;
  result := FComprisedOfList;
end;

function TFhirMedicinalProductDefinition.GetHasComprisedOfList : boolean;
begin
  result := (FComprisedOfList <> nil) and (FComprisedOfList.count > 0);
end;

function TFhirMedicinalProductDefinition.GetIngredientList : TFhirCodeableConceptList;
begin
  if FIngredientList = nil then
    FIngredientList := TFhirCodeableConceptList.Create;
  result := FIngredientList;
end;

function TFhirMedicinalProductDefinition.GetHasIngredientList : boolean;
begin
  result := (FIngredientList <> nil) and (FIngredientList.count > 0);
end;

function TFhirMedicinalProductDefinition.GetImpurityList : TFhirCodeableReferenceList;
begin
  if FImpurityList = nil then
    FImpurityList := TFhirCodeableReferenceList.Create;
  result := FImpurityList;
end;

function TFhirMedicinalProductDefinition.GetHasImpurityList : boolean;
begin
  result := (FImpurityList <> nil) and (FImpurityList.count > 0);
end;

function TFhirMedicinalProductDefinition.GetAttachedDocumentList : TFhirReferenceList;
begin
  if FAttachedDocumentList = nil then
    FAttachedDocumentList := TFhirReferenceList.Create;
  result := FAttachedDocumentList;
end;

function TFhirMedicinalProductDefinition.GetHasAttachedDocumentList : boolean;
begin
  result := (FAttachedDocumentList <> nil) and (FAttachedDocumentList.count > 0);
end;

function TFhirMedicinalProductDefinition.GetMasterFileList : TFhirReferenceList;
begin
  if FMasterFileList = nil then
    FMasterFileList := TFhirReferenceList.Create;
  result := FMasterFileList;
end;

function TFhirMedicinalProductDefinition.GetHasMasterFileList : boolean;
begin
  result := (FMasterFileList <> nil) and (FMasterFileList.count > 0);
end;

function TFhirMedicinalProductDefinition.GetContactList : TFhirMedicinalProductDefinitionContactList;
begin
  if FContactList = nil then
    FContactList := TFhirMedicinalProductDefinitionContactList.Create;
  result := FContactList;
end;

function TFhirMedicinalProductDefinition.GetHasContactList : boolean;
begin
  result := (FContactList <> nil) and (FContactList.count > 0);
end;

function TFhirMedicinalProductDefinition.GetClinicalTrialList : TFhirReferenceList;
begin
  if FClinicalTrialList = nil then
    FClinicalTrialList := TFhirReferenceList.Create;
  result := FClinicalTrialList;
end;

function TFhirMedicinalProductDefinition.GetHasClinicalTrialList : boolean;
begin
  result := (FClinicalTrialList <> nil) and (FClinicalTrialList.count > 0);
end;

function TFhirMedicinalProductDefinition.GetCodeList : TFhirCodingList;
begin
  if FCodeList = nil then
    FCodeList := TFhirCodingList.Create;
  result := FCodeList;
end;

function TFhirMedicinalProductDefinition.GetHasCodeList : boolean;
begin
  result := (FCodeList <> nil) and (FCodeList.count > 0);
end;

function TFhirMedicinalProductDefinition.GetNameList : TFhirMedicinalProductDefinitionNameList;
begin
  if FNameList = nil then
    FNameList := TFhirMedicinalProductDefinitionNameList.Create;
  result := FNameList;
end;

function TFhirMedicinalProductDefinition.GetHasNameList : boolean;
begin
  result := (FNameList <> nil) and (FNameList.count > 0);
end;

function TFhirMedicinalProductDefinition.GetCrossReferenceList : TFhirMedicinalProductDefinitionCrossReferenceList;
begin
  if FCrossReferenceList = nil then
    FCrossReferenceList := TFhirMedicinalProductDefinitionCrossReferenceList.Create;
  result := FCrossReferenceList;
end;

function TFhirMedicinalProductDefinition.GetHasCrossReferenceList : boolean;
begin
  result := (FCrossReferenceList <> nil) and (FCrossReferenceList.count > 0);
end;

function TFhirMedicinalProductDefinition.GetOperationList : TFhirMedicinalProductDefinitionOperationList;
begin
  if FOperationList = nil then
    FOperationList := TFhirMedicinalProductDefinitionOperationList.Create;
  result := FOperationList;
end;

function TFhirMedicinalProductDefinition.GetHasOperationList : boolean;
begin
  result := (FOperationList <> nil) and (FOperationList.count > 0);
end;

function TFhirMedicinalProductDefinition.GetCharacteristicList : TFhirMedicinalProductDefinitionCharacteristicList;
begin
  if FCharacteristicList = nil then
    FCharacteristicList := TFhirMedicinalProductDefinitionCharacteristicList.Create;
  result := FCharacteristicList;
end;

function TFhirMedicinalProductDefinition.GetHasCharacteristicList : boolean;
begin
  result := (FCharacteristicList <> nil) and (FCharacteristicList.count > 0);
end;

{ TFhirMedicinalProductDefinitionListEnumerator }

constructor TFhirMedicinalProductDefinitionListEnumerator.Create(list : TFhirMedicinalProductDefinitionList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirMedicinalProductDefinitionListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirMedicinalProductDefinitionListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirMedicinalProductDefinitionListEnumerator.GetCurrent : TFhirMedicinalProductDefinition;
begin
  Result := FList[FIndex];
end;

function TFhirMedicinalProductDefinitionListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirMedicinalProductDefinitionList }

function TFhirMedicinalProductDefinitionList.AddItem(value: TFhirMedicinalProductDefinition): TFhirMedicinalProductDefinition;
begin
  assert(value.ClassName = 'TFhirMedicinalProductDefinition', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirMedicinalProductDefinition');
  add(value);
  result := value;
end;

function TFhirMedicinalProductDefinitionList.Append: TFhirMedicinalProductDefinition;
begin
  result := TFhirMedicinalProductDefinition.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirMedicinalProductDefinitionList.ClearItems;
begin
  Clear;
end;

function TFhirMedicinalProductDefinitionList.GetEnumerator : TFhirMedicinalProductDefinitionListEnumerator;
begin
  result := TFhirMedicinalProductDefinitionListEnumerator.Create(self.link);
end;

function TFhirMedicinalProductDefinitionList.Clone: TFhirMedicinalProductDefinitionList;
begin
  result := TFhirMedicinalProductDefinitionList(inherited Clone);
end;

function TFhirMedicinalProductDefinitionList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirMedicinalProductDefinitionList.GetItemN(index: Integer): TFhirMedicinalProductDefinition;
begin
  result := TFhirMedicinalProductDefinition(ObjectByIndex[index]);
end;

function TFhirMedicinalProductDefinitionList.ItemClass: TFslObjectClass;
begin
  result := TFhirMedicinalProductDefinition;
end;
function TFhirMedicinalProductDefinitionList.IndexOf(value: TFhirMedicinalProductDefinition): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirMedicinalProductDefinitionList.Insert(index: Integer): TFhirMedicinalProductDefinition;
begin
  result := TFhirMedicinalProductDefinition.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirMedicinalProductDefinitionList.InsertItem(index: Integer; value: TFhirMedicinalProductDefinition);
begin
  assert(value is TFhirMedicinalProductDefinition);
  Inherited Insert(index, value);
end;

function TFhirMedicinalProductDefinitionList.Item(index: Integer): TFhirMedicinalProductDefinition;
begin
  result := TFhirMedicinalProductDefinition(ObjectByIndex[index]);
end;

function TFhirMedicinalProductDefinitionList.Link: TFhirMedicinalProductDefinitionList;
begin
  result := TFhirMedicinalProductDefinitionList(inherited Link);
end;

procedure TFhirMedicinalProductDefinitionList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirMedicinalProductDefinitionList.SetItemByIndex(index: Integer; value: TFhirMedicinalProductDefinition);
begin
  assert(value is TFhirMedicinalProductDefinition);
  FhirMedicinalProductDefinitions[index] := value;
end;

procedure TFhirMedicinalProductDefinitionList.SetItemN(index: Integer; value: TFhirMedicinalProductDefinition);
begin
  assert(value is TFhirMedicinalProductDefinition);
  ObjectByIndex[index] := value;
end;

{$ENDIF FHIR_MEDICINALPRODUCTDEFINITION}
{$IFDEF FHIR_NUTRITIONPRODUCT}
{ TFhirNutritionProductNutrient }

constructor TFhirNutritionProductNutrient.Create;
begin
  inherited;
end;

destructor TFhirNutritionProductNutrient.Destroy;
begin
  FItem.free;
  FAmountList.Free;
  inherited;
end;

procedure TFhirNutritionProductNutrient.Assign(oSource : TFslObject);
begin
  inherited;
  item := TFhirNutritionProductNutrient(oSource).item.Clone;
  if (TFhirNutritionProductNutrient(oSource).FAmountList = nil) then
  begin
    FAmountList.free;
    FAmountList := nil;
  end
  else
  begin
    if FAmountList = nil then
      FAmountList := TFhirRatioList.Create;
    FAmountList.Assign(TFhirNutritionProductNutrient(oSource).FAmountList);
  end;
end;

procedure TFhirNutritionProductNutrient.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'item') Then
     list.add(self.link, 'item', FItem.Link);
  if (child_name = 'amount') Then
    list.addAll(self, 'amount', FAmountList);
end;

procedure TFhirNutritionProductNutrient.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'item', 'CodeableReference', false, TFhirCodeableReference, FItem.Link));
  oList.add(TFHIRProperty.create(self, 'amount', 'Ratio', true, TFhirRatio, FAmountList.Link));
end;

function TFhirNutritionProductNutrient.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'item') then
  begin
    Item := propValue as TFhirCodeableReference;
    result := propValue;
  end
  else if (propName = 'amount') then
  begin
    AmountList.add(propValue as TFhirRatio);
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirNutritionProductNutrient.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'amount') then AmountList.insertItem(index, propValue as TFhirRatio)
  else inherited;
end;

function TFhirNutritionProductNutrient.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'item') then result := TFhirCodeableReference.create()
  else if (propName = 'amount') then result := AmountList.new()
  else result := inherited createPropertyValue(propName);
end;

function TFhirNutritionProductNutrient.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'item') then result := 'CodeableReference'
  else if (propName = 'amount') then result := 'Ratio'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirNutritionProductNutrient.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'item') then ItemElement := nil
  else if (propName = 'amount') then deletePropertyValue('amount', AmountList, value)
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirNutritionProductNutrient.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'item') then ItemElement := new as TFhirCodeableReference
  else if (propName = 'amount') then replacePropertyValue('amount', AmountList, existing, new)
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirNutritionProductNutrient.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'amount') then AmountList.move(source, destination)
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirNutritionProductNutrient.fhirType : string;
begin
  result := 'NutritionProduct.nutrient';
end;

function TFhirNutritionProductNutrient.Link : TFhirNutritionProductNutrient;
begin
  result := TFhirNutritionProductNutrient(inherited Link);
end;

function TFhirNutritionProductNutrient.Clone : TFhirNutritionProductNutrient;
begin
  result := TFhirNutritionProductNutrient(inherited Clone);
end;

function TFhirNutritionProductNutrient.equals(other : TObject) : boolean; 
var
  o : TFhirNutritionProductNutrient;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirNutritionProductNutrient)) then
    result := false
  else
  begin
    o := TFhirNutritionProductNutrient(other);
    result := compareDeep(itemElement, o.itemElement, true) and compareDeep(amountList, o.amountList, true);
  end;
end;

function TFhirNutritionProductNutrient.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FItem) and isEmptyProp(FamountList);
end;

procedure TFhirNutritionProductNutrient.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('item');
  fields.add('amount');
end;

function TFhirNutritionProductNutrient.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
  inc(result, FAmountList.sizeInBytes(magic));
end;

procedure TFhirNutritionProductNutrient.SetItem(value : TFhirCodeableReference);
begin
  FItem.free;
  FItem := value;
end;

function TFhirNutritionProductNutrient.GetAmountList : TFhirRatioList;
begin
  if FAmountList = nil then
    FAmountList := TFhirRatioList.Create;
  result := FAmountList;
end;

function TFhirNutritionProductNutrient.GetHasAmountList : boolean;
begin
  result := (FAmountList <> nil) and (FAmountList.count > 0);
end;

{ TFhirNutritionProductNutrientListEnumerator }

constructor TFhirNutritionProductNutrientListEnumerator.Create(list : TFhirNutritionProductNutrientList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirNutritionProductNutrientListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirNutritionProductNutrientListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirNutritionProductNutrientListEnumerator.GetCurrent : TFhirNutritionProductNutrient;
begin
  Result := FList[FIndex];
end;

function TFhirNutritionProductNutrientListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirNutritionProductNutrientList }

function TFhirNutritionProductNutrientList.AddItem(value: TFhirNutritionProductNutrient): TFhirNutritionProductNutrient;
begin
  assert(value.ClassName = 'TFhirNutritionProductNutrient', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirNutritionProductNutrient');
  add(value);
  result := value;
end;

function TFhirNutritionProductNutrientList.Append: TFhirNutritionProductNutrient;
begin
  result := TFhirNutritionProductNutrient.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirNutritionProductNutrientList.ClearItems;
begin
  Clear;
end;

function TFhirNutritionProductNutrientList.GetEnumerator : TFhirNutritionProductNutrientListEnumerator;
begin
  result := TFhirNutritionProductNutrientListEnumerator.Create(self.link);
end;

function TFhirNutritionProductNutrientList.Clone: TFhirNutritionProductNutrientList;
begin
  result := TFhirNutritionProductNutrientList(inherited Clone);
end;

function TFhirNutritionProductNutrientList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirNutritionProductNutrientList.GetItemN(index: Integer): TFhirNutritionProductNutrient;
begin
  result := TFhirNutritionProductNutrient(ObjectByIndex[index]);
end;

function TFhirNutritionProductNutrientList.ItemClass: TFslObjectClass;
begin
  result := TFhirNutritionProductNutrient;
end;
function TFhirNutritionProductNutrientList.IndexOf(value: TFhirNutritionProductNutrient): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirNutritionProductNutrientList.Insert(index: Integer): TFhirNutritionProductNutrient;
begin
  result := TFhirNutritionProductNutrient.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirNutritionProductNutrientList.InsertItem(index: Integer; value: TFhirNutritionProductNutrient);
begin
  assert(value is TFhirNutritionProductNutrient);
  Inherited Insert(index, value);
end;

function TFhirNutritionProductNutrientList.Item(index: Integer): TFhirNutritionProductNutrient;
begin
  result := TFhirNutritionProductNutrient(ObjectByIndex[index]);
end;

function TFhirNutritionProductNutrientList.Link: TFhirNutritionProductNutrientList;
begin
  result := TFhirNutritionProductNutrientList(inherited Link);
end;

procedure TFhirNutritionProductNutrientList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirNutritionProductNutrientList.SetItemByIndex(index: Integer; value: TFhirNutritionProductNutrient);
begin
  assert(value is TFhirNutritionProductNutrient);
  FhirNutritionProductNutrients[index] := value;
end;

procedure TFhirNutritionProductNutrientList.SetItemN(index: Integer; value: TFhirNutritionProductNutrient);
begin
  assert(value is TFhirNutritionProductNutrient);
  ObjectByIndex[index] := value;
end;

{ TFhirNutritionProductIngredient }

constructor TFhirNutritionProductIngredient.Create;
begin
  inherited;
end;

destructor TFhirNutritionProductIngredient.Destroy;
begin
  FItem.free;
  FAmountList.Free;
  inherited;
end;

procedure TFhirNutritionProductIngredient.Assign(oSource : TFslObject);
begin
  inherited;
  item := TFhirNutritionProductIngredient(oSource).item.Clone;
  if (TFhirNutritionProductIngredient(oSource).FAmountList = nil) then
  begin
    FAmountList.free;
    FAmountList := nil;
  end
  else
  begin
    if FAmountList = nil then
      FAmountList := TFhirRatioList.Create;
    FAmountList.Assign(TFhirNutritionProductIngredient(oSource).FAmountList);
  end;
end;

procedure TFhirNutritionProductIngredient.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'item') Then
     list.add(self.link, 'item', FItem.Link);
  if (child_name = 'amount') Then
    list.addAll(self, 'amount', FAmountList);
end;

procedure TFhirNutritionProductIngredient.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'item', 'CodeableReference', false, TFhirCodeableReference, FItem.Link));
  oList.add(TFHIRProperty.create(self, 'amount', 'Ratio', true, TFhirRatio, FAmountList.Link));
end;

function TFhirNutritionProductIngredient.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'item') then
  begin
    Item := propValue as TFhirCodeableReference;
    result := propValue;
  end
  else if (propName = 'amount') then
  begin
    AmountList.add(propValue as TFhirRatio);
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirNutritionProductIngredient.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'amount') then AmountList.insertItem(index, propValue as TFhirRatio)
  else inherited;
end;

function TFhirNutritionProductIngredient.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'item') then result := TFhirCodeableReference.create()
  else if (propName = 'amount') then result := AmountList.new()
  else result := inherited createPropertyValue(propName);
end;

function TFhirNutritionProductIngredient.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'item') then result := 'CodeableReference'
  else if (propName = 'amount') then result := 'Ratio'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirNutritionProductIngredient.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'item') then ItemElement := nil
  else if (propName = 'amount') then deletePropertyValue('amount', AmountList, value)
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirNutritionProductIngredient.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'item') then ItemElement := new as TFhirCodeableReference
  else if (propName = 'amount') then replacePropertyValue('amount', AmountList, existing, new)
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirNutritionProductIngredient.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'amount') then AmountList.move(source, destination)
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirNutritionProductIngredient.fhirType : string;
begin
  result := 'NutritionProduct.ingredient';
end;

function TFhirNutritionProductIngredient.Link : TFhirNutritionProductIngredient;
begin
  result := TFhirNutritionProductIngredient(inherited Link);
end;

function TFhirNutritionProductIngredient.Clone : TFhirNutritionProductIngredient;
begin
  result := TFhirNutritionProductIngredient(inherited Clone);
end;

function TFhirNutritionProductIngredient.equals(other : TObject) : boolean; 
var
  o : TFhirNutritionProductIngredient;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirNutritionProductIngredient)) then
    result := false
  else
  begin
    o := TFhirNutritionProductIngredient(other);
    result := compareDeep(itemElement, o.itemElement, true) and compareDeep(amountList, o.amountList, true);
  end;
end;

function TFhirNutritionProductIngredient.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FItem) and isEmptyProp(FamountList);
end;

procedure TFhirNutritionProductIngredient.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('item');
  fields.add('amount');
end;

function TFhirNutritionProductIngredient.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
  inc(result, FAmountList.sizeInBytes(magic));
end;

procedure TFhirNutritionProductIngredient.SetItem(value : TFhirCodeableReference);
begin
  FItem.free;
  FItem := value;
end;

function TFhirNutritionProductIngredient.GetAmountList : TFhirRatioList;
begin
  if FAmountList = nil then
    FAmountList := TFhirRatioList.Create;
  result := FAmountList;
end;

function TFhirNutritionProductIngredient.GetHasAmountList : boolean;
begin
  result := (FAmountList <> nil) and (FAmountList.count > 0);
end;

{ TFhirNutritionProductIngredientListEnumerator }

constructor TFhirNutritionProductIngredientListEnumerator.Create(list : TFhirNutritionProductIngredientList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirNutritionProductIngredientListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirNutritionProductIngredientListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirNutritionProductIngredientListEnumerator.GetCurrent : TFhirNutritionProductIngredient;
begin
  Result := FList[FIndex];
end;

function TFhirNutritionProductIngredientListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirNutritionProductIngredientList }

function TFhirNutritionProductIngredientList.AddItem(value: TFhirNutritionProductIngredient): TFhirNutritionProductIngredient;
begin
  assert(value.ClassName = 'TFhirNutritionProductIngredient', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirNutritionProductIngredient');
  add(value);
  result := value;
end;

function TFhirNutritionProductIngredientList.Append: TFhirNutritionProductIngredient;
begin
  result := TFhirNutritionProductIngredient.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirNutritionProductIngredientList.ClearItems;
begin
  Clear;
end;

function TFhirNutritionProductIngredientList.GetEnumerator : TFhirNutritionProductIngredientListEnumerator;
begin
  result := TFhirNutritionProductIngredientListEnumerator.Create(self.link);
end;

function TFhirNutritionProductIngredientList.Clone: TFhirNutritionProductIngredientList;
begin
  result := TFhirNutritionProductIngredientList(inherited Clone);
end;

function TFhirNutritionProductIngredientList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirNutritionProductIngredientList.GetItemN(index: Integer): TFhirNutritionProductIngredient;
begin
  result := TFhirNutritionProductIngredient(ObjectByIndex[index]);
end;

function TFhirNutritionProductIngredientList.ItemClass: TFslObjectClass;
begin
  result := TFhirNutritionProductIngredient;
end;
function TFhirNutritionProductIngredientList.IndexOf(value: TFhirNutritionProductIngredient): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirNutritionProductIngredientList.Insert(index: Integer): TFhirNutritionProductIngredient;
begin
  result := TFhirNutritionProductIngredient.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirNutritionProductIngredientList.InsertItem(index: Integer; value: TFhirNutritionProductIngredient);
begin
  assert(value is TFhirNutritionProductIngredient);
  Inherited Insert(index, value);
end;

function TFhirNutritionProductIngredientList.Item(index: Integer): TFhirNutritionProductIngredient;
begin
  result := TFhirNutritionProductIngredient(ObjectByIndex[index]);
end;

function TFhirNutritionProductIngredientList.Link: TFhirNutritionProductIngredientList;
begin
  result := TFhirNutritionProductIngredientList(inherited Link);
end;

procedure TFhirNutritionProductIngredientList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirNutritionProductIngredientList.SetItemByIndex(index: Integer; value: TFhirNutritionProductIngredient);
begin
  assert(value is TFhirNutritionProductIngredient);
  FhirNutritionProductIngredients[index] := value;
end;

procedure TFhirNutritionProductIngredientList.SetItemN(index: Integer; value: TFhirNutritionProductIngredient);
begin
  assert(value is TFhirNutritionProductIngredient);
  ObjectByIndex[index] := value;
end;

{ TFhirNutritionProductCharacteristic }

constructor TFhirNutritionProductCharacteristic.Create;
begin
  inherited;
end;

destructor TFhirNutritionProductCharacteristic.Destroy;
begin
  FType_.free;
  FValue.free;
  inherited;
end;

procedure TFhirNutritionProductCharacteristic.Assign(oSource : TFslObject);
begin
  inherited;
  type_ := TFhirNutritionProductCharacteristic(oSource).type_.Clone;
  value := TFhirNutritionProductCharacteristic(oSource).value.Clone;
end;

procedure TFhirNutritionProductCharacteristic.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'type') Then
     list.add(self.link, 'type', FType_.Link);
  if (child_name = 'value[x]') or (child_name = 'value') Then
     list.add(self.link, 'value[x]', FValue.Link);
end;

procedure TFhirNutritionProductCharacteristic.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'type', 'CodeableConcept', false, TFhirCodeableConcept, FType_.Link));
  oList.add(TFHIRProperty.create(self, 'value[x]', 'CodeableConcept|string|Quantity|base64Binary|Attachment|boolean', false, TFhirDataType, FValue.Link));
end;

function TFhirNutritionProductCharacteristic.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'type') then
  begin
    Type_ := propValue as TFhirCodeableConcept;
    result := propValue;
  end
  else if (isMatchingName(propName, 'value', ['CodeableConcept', 'String', 'Quantity', 'Base64Binary', 'Attachment', 'Boolean'])) then
  begin
    Value := propValue as TFhirDataType;
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirNutritionProductCharacteristic.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirNutritionProductCharacteristic.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'type') then result := TFhirCodeableConcept.create()
  else if (isMatchingName(propName, 'value', ['CodeableConcept', 'String', 'Quantity', 'Base64Binary', 'Attachment', 'Boolean'])) then raise EFHIRException.create('Cannot make property Value')
  else result := inherited createPropertyValue(propName);
end;

function TFhirNutritionProductCharacteristic.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'type') then result := 'CodeableConcept'
  else if (propName = 'value[x]') then result := 'CodeableConcept|string|Quantity|base64Binary|Attachment|boolean'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirNutritionProductCharacteristic.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'type') then Type_Element := nil
  else if (isMatchingName(propName, 'value', ['CodeableConcept', 'String', 'Quantity', 'Base64Binary', 'Attachment', 'Boolean'])) then ValueElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirNutritionProductCharacteristic.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'type') then Type_Element := new as TFhirCodeableConcept
  else if (isMatchingName(propName, 'value', ['CodeableConcept', 'String', 'Quantity', 'Base64Binary', 'Attachment', 'Boolean'])) then ValueElement := new as TFhirDataType
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirNutritionProductCharacteristic.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirNutritionProductCharacteristic.fhirType : string;
begin
  result := 'NutritionProduct.characteristic';
end;

function TFhirNutritionProductCharacteristic.Link : TFhirNutritionProductCharacteristic;
begin
  result := TFhirNutritionProductCharacteristic(inherited Link);
end;

function TFhirNutritionProductCharacteristic.Clone : TFhirNutritionProductCharacteristic;
begin
  result := TFhirNutritionProductCharacteristic(inherited Clone);
end;

function TFhirNutritionProductCharacteristic.equals(other : TObject) : boolean; 
var
  o : TFhirNutritionProductCharacteristic;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirNutritionProductCharacteristic)) then
    result := false
  else
  begin
    o := TFhirNutritionProductCharacteristic(other);
    result := compareDeep(type_Element, o.type_Element, true) and compareDeep(valueElement, o.valueElement, true);
  end;
end;

function TFhirNutritionProductCharacteristic.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FType_) and isEmptyProp(FValue);
end;

procedure TFhirNutritionProductCharacteristic.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('type');
  fields.add('value[x]');
end;

function TFhirNutritionProductCharacteristic.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
end;

procedure TFhirNutritionProductCharacteristic.SetType_(value : TFhirCodeableConcept);
begin
  FType_.free;
  FType_ := value;
end;

procedure TFhirNutritionProductCharacteristic.SetValue(value : TFhirDataType);
begin
  FValue.free;
  FValue := value;
end;

{ TFhirNutritionProductCharacteristicListEnumerator }

constructor TFhirNutritionProductCharacteristicListEnumerator.Create(list : TFhirNutritionProductCharacteristicList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirNutritionProductCharacteristicListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirNutritionProductCharacteristicListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirNutritionProductCharacteristicListEnumerator.GetCurrent : TFhirNutritionProductCharacteristic;
begin
  Result := FList[FIndex];
end;

function TFhirNutritionProductCharacteristicListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirNutritionProductCharacteristicList }

function TFhirNutritionProductCharacteristicList.AddItem(value: TFhirNutritionProductCharacteristic): TFhirNutritionProductCharacteristic;
begin
  assert(value.ClassName = 'TFhirNutritionProductCharacteristic', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirNutritionProductCharacteristic');
  add(value);
  result := value;
end;

function TFhirNutritionProductCharacteristicList.Append: TFhirNutritionProductCharacteristic;
begin
  result := TFhirNutritionProductCharacteristic.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirNutritionProductCharacteristicList.ClearItems;
begin
  Clear;
end;

function TFhirNutritionProductCharacteristicList.GetEnumerator : TFhirNutritionProductCharacteristicListEnumerator;
begin
  result := TFhirNutritionProductCharacteristicListEnumerator.Create(self.link);
end;

function TFhirNutritionProductCharacteristicList.Clone: TFhirNutritionProductCharacteristicList;
begin
  result := TFhirNutritionProductCharacteristicList(inherited Clone);
end;

function TFhirNutritionProductCharacteristicList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirNutritionProductCharacteristicList.GetItemN(index: Integer): TFhirNutritionProductCharacteristic;
begin
  result := TFhirNutritionProductCharacteristic(ObjectByIndex[index]);
end;

function TFhirNutritionProductCharacteristicList.ItemClass: TFslObjectClass;
begin
  result := TFhirNutritionProductCharacteristic;
end;
function TFhirNutritionProductCharacteristicList.IndexOf(value: TFhirNutritionProductCharacteristic): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirNutritionProductCharacteristicList.Insert(index: Integer): TFhirNutritionProductCharacteristic;
begin
  result := TFhirNutritionProductCharacteristic.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirNutritionProductCharacteristicList.InsertItem(index: Integer; value: TFhirNutritionProductCharacteristic);
begin
  assert(value is TFhirNutritionProductCharacteristic);
  Inherited Insert(index, value);
end;

function TFhirNutritionProductCharacteristicList.Item(index: Integer): TFhirNutritionProductCharacteristic;
begin
  result := TFhirNutritionProductCharacteristic(ObjectByIndex[index]);
end;

function TFhirNutritionProductCharacteristicList.Link: TFhirNutritionProductCharacteristicList;
begin
  result := TFhirNutritionProductCharacteristicList(inherited Link);
end;

procedure TFhirNutritionProductCharacteristicList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirNutritionProductCharacteristicList.SetItemByIndex(index: Integer; value: TFhirNutritionProductCharacteristic);
begin
  assert(value is TFhirNutritionProductCharacteristic);
  FhirNutritionProductCharacteristics[index] := value;
end;

procedure TFhirNutritionProductCharacteristicList.SetItemN(index: Integer; value: TFhirNutritionProductCharacteristic);
begin
  assert(value is TFhirNutritionProductCharacteristic);
  ObjectByIndex[index] := value;
end;

{ TFhirNutritionProductInstance }

constructor TFhirNutritionProductInstance.Create;
begin
  inherited;
end;

destructor TFhirNutritionProductInstance.Destroy;
begin
  FQuantity.free;
  FIdentifierList.Free;
  FName.free;
  FLotNumber.free;
  FExpiry.free;
  FUseBy.free;
  FBiologicalSourceEvent.free;
  inherited;
end;

procedure TFhirNutritionProductInstance.Assign(oSource : TFslObject);
begin
  inherited;
  quantity := TFhirNutritionProductInstance(oSource).quantity.Clone;
  if (TFhirNutritionProductInstance(oSource).FIdentifierList = nil) then
  begin
    FIdentifierList.free;
    FIdentifierList := nil;
  end
  else
  begin
    if FIdentifierList = nil then
      FIdentifierList := TFhirIdentifierList.Create;
    FIdentifierList.Assign(TFhirNutritionProductInstance(oSource).FIdentifierList);
  end;
  nameElement := TFhirNutritionProductInstance(oSource).nameElement.Clone;
  lotNumberElement := TFhirNutritionProductInstance(oSource).lotNumberElement.Clone;
  expiryElement := TFhirNutritionProductInstance(oSource).expiryElement.Clone;
  useByElement := TFhirNutritionProductInstance(oSource).useByElement.Clone;
  biologicalSourceEvent := TFhirNutritionProductInstance(oSource).biologicalSourceEvent.Clone;
end;

procedure TFhirNutritionProductInstance.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'quantity') Then
     list.add(self.link, 'quantity', FQuantity.Link);
  if (child_name = 'identifier') Then
    list.addAll(self, 'identifier', FIdentifierList);
  if (child_name = 'name') Then
     list.add(self.link, 'name', FName.Link);
  if (child_name = 'lotNumber') Then
     list.add(self.link, 'lotNumber', FLotNumber.Link);
  if (child_name = 'expiry') Then
     list.add(self.link, 'expiry', FExpiry.Link);
  if (child_name = 'useBy') Then
     list.add(self.link, 'useBy', FUseBy.Link);
  if (child_name = 'biologicalSourceEvent') Then
     list.add(self.link, 'biologicalSourceEvent', FBiologicalSourceEvent.Link);
end;

procedure TFhirNutritionProductInstance.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'quantity', 'Quantity', false, TFhirQuantity, FQuantity.Link));
  oList.add(TFHIRProperty.create(self, 'identifier', 'Identifier', true, TFhirIdentifier, FIdentifierList.Link));
  oList.add(TFHIRProperty.create(self, 'name', 'string', false, TFhirString, FName.Link));
  oList.add(TFHIRProperty.create(self, 'lotNumber', 'string', false, TFhirString, FLotNumber.Link));
  oList.add(TFHIRProperty.create(self, 'expiry', 'dateTime', false, TFhirDateTime, FExpiry.Link));
  oList.add(TFHIRProperty.create(self, 'useBy', 'dateTime', false, TFhirDateTime, FUseBy.Link));
  oList.add(TFHIRProperty.create(self, 'biologicalSourceEvent', 'Identifier', false, TFhirIdentifier, FBiologicalSourceEvent.Link));
end;

function TFhirNutritionProductInstance.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'quantity') then
  begin
    Quantity := propValue as TFhirQuantity;
    result := propValue;
  end
  else if (propName = 'identifier') then
  begin
    IdentifierList.add(propValue as TFhirIdentifier);
    result := propValue;
  end
  else if (propName = 'name') then
  begin
    NameElement := asString(propValue);
    result := propValue;
  end
  else if (propName = 'lotNumber') then
  begin
    LotNumberElement := asString(propValue);
    result := propValue;
  end
  else if (propName = 'expiry') then
  begin
    ExpiryElement := asDateTime(propValue);
    result := propValue;
  end
  else if (propName = 'useBy') then
  begin
    UseByElement := asDateTime(propValue);
    result := propValue;
  end
  else if (propName = 'biologicalSourceEvent') then
  begin
    BiologicalSourceEvent := propValue as TFhirIdentifier;
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirNutritionProductInstance.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'identifier') then IdentifierList.insertItem(index, propValue as TFhirIdentifier)
  else inherited;
end;

function TFhirNutritionProductInstance.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'quantity') then result := TFhirQuantity.create()
  else if (propName = 'identifier') then result := IdentifierList.new()
  else if (propName = 'name') then result := TFhirString.create()
  else if (propName = 'lotNumber') then result := TFhirString.create()
  else if (propName = 'expiry') then result := TFhirDateTime.create()
  else if (propName = 'useBy') then result := TFhirDateTime.create()
  else if (propName = 'biologicalSourceEvent') then result := TFhirIdentifier.create()
  else result := inherited createPropertyValue(propName);
end;

function TFhirNutritionProductInstance.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'quantity') then result := 'Quantity'
  else if (propName = 'identifier') then result := 'Identifier'
  else if (propName = 'name') then result := 'string'
  else if (propName = 'lotNumber') then result := 'string'
  else if (propName = 'expiry') then result := 'dateTime'
  else if (propName = 'useBy') then result := 'dateTime'
  else if (propName = 'biologicalSourceEvent') then result := 'Identifier'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirNutritionProductInstance.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'quantity') then QuantityElement := nil
  else if (propName = 'identifier') then deletePropertyValue('identifier', IdentifierList, value)
  else if (propName = 'name') then NameElement := nil
  else if (propName = 'lotNumber') then LotNumberElement := nil
  else if (propName = 'expiry') then ExpiryElement := nil
  else if (propName = 'useBy') then UseByElement := nil
  else if (propName = 'biologicalSourceEvent') then BiologicalSourceEventElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirNutritionProductInstance.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'quantity') then QuantityElement := new as TFhirQuantity
  else if (propName = 'identifier') then replacePropertyValue('identifier', IdentifierList, existing, new)
  else if (propName = 'name') then NameElement := asString(new)
  else if (propName = 'lotNumber') then LotNumberElement := asString(new)
  else if (propName = 'expiry') then ExpiryElement := asDateTime(new)
  else if (propName = 'useBy') then UseByElement := asDateTime(new)
  else if (propName = 'biologicalSourceEvent') then BiologicalSourceEventElement := new as TFhirIdentifier
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirNutritionProductInstance.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'identifier') then IdentifierList.move(source, destination)
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirNutritionProductInstance.fhirType : string;
begin
  result := 'NutritionProduct.instance';
end;

function TFhirNutritionProductInstance.Link : TFhirNutritionProductInstance;
begin
  result := TFhirNutritionProductInstance(inherited Link);
end;

function TFhirNutritionProductInstance.Clone : TFhirNutritionProductInstance;
begin
  result := TFhirNutritionProductInstance(inherited Clone);
end;

function TFhirNutritionProductInstance.equals(other : TObject) : boolean; 
var
  o : TFhirNutritionProductInstance;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirNutritionProductInstance)) then
    result := false
  else
  begin
    o := TFhirNutritionProductInstance(other);
    result := compareDeep(quantityElement, o.quantityElement, true) and compareDeep(identifierList, o.identifierList, true) and 
      compareDeep(nameElement, o.nameElement, true) and compareDeep(lotNumberElement, o.lotNumberElement, true) and 
      compareDeep(expiryElement, o.expiryElement, true) and compareDeep(useByElement, o.useByElement, true) and 
      compareDeep(biologicalSourceEventElement, o.biologicalSourceEventElement, true);
  end;
end;

function TFhirNutritionProductInstance.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FQuantity) and isEmptyProp(FidentifierList) and isEmptyProp(FName) and isEmptyProp(FLotNumber) and isEmptyProp(FExpiry) and isEmptyProp(FUseBy) and isEmptyProp(FBiologicalSourceEvent);
end;

procedure TFhirNutritionProductInstance.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('quantity');
  fields.add('identifier');
  fields.add('name');
  fields.add('lotNumber');
  fields.add('expiry');
  fields.add('useBy');
  fields.add('biologicalSourceEvent');
end;

function TFhirNutritionProductInstance.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
  inc(result, FIdentifierList.sizeInBytes(magic));
end;

procedure TFhirNutritionProductInstance.SetQuantity(value : TFhirQuantity);
begin
  FQuantity.free;
  FQuantity := value;
end;

function TFhirNutritionProductInstance.GetIdentifierList : TFhirIdentifierList;
begin
  if FIdentifierList = nil then
    FIdentifierList := TFhirIdentifierList.Create;
  result := FIdentifierList;
end;

function TFhirNutritionProductInstance.GetHasIdentifierList : boolean;
begin
  result := (FIdentifierList <> nil) and (FIdentifierList.count > 0);
end;

procedure TFhirNutritionProductInstance.SetName(value : TFhirString);
begin
  FName.free;
  FName := value;
end;

function TFhirNutritionProductInstance.GetNameST : String;
begin
  if FName = nil then
    result := ''
  else
    result := FName.value;
end;

procedure TFhirNutritionProductInstance.SetNameST(value : String);
begin
  if value <> '' then
  begin
    if FName = nil then
      FName := TFhirString.create;
    FName.value := value
  end
  else if FName <> nil then
    FName.value := '';
end;

procedure TFhirNutritionProductInstance.SetLotNumber(value : TFhirString);
begin
  FLotNumber.free;
  FLotNumber := value;
end;

function TFhirNutritionProductInstance.GetLotNumberST : String;
begin
  if FLotNumber = nil then
    result := ''
  else
    result := FLotNumber.value;
end;

procedure TFhirNutritionProductInstance.SetLotNumberST(value : String);
begin
  if value <> '' then
  begin
    if FLotNumber = nil then
      FLotNumber := TFhirString.create;
    FLotNumber.value := value
  end
  else if FLotNumber <> nil then
    FLotNumber.value := '';
end;

procedure TFhirNutritionProductInstance.SetExpiry(value : TFhirDateTime);
begin
  FExpiry.free;
  FExpiry := value;
end;

function TFhirNutritionProductInstance.GetExpiryST : TFslDateTime;
begin
  if FExpiry = nil then
    result := TFslDateTime.makeNull
  else
    result := FExpiry.value;
end;

procedure TFhirNutritionProductInstance.SetExpiryST(value : TFslDateTime);
begin
  if FExpiry = nil then
    FExpiry := TFhirDateTime.create;
  FExpiry.value := value
end;

procedure TFhirNutritionProductInstance.SetUseBy(value : TFhirDateTime);
begin
  FUseBy.free;
  FUseBy := value;
end;

function TFhirNutritionProductInstance.GetUseByST : TFslDateTime;
begin
  if FUseBy = nil then
    result := TFslDateTime.makeNull
  else
    result := FUseBy.value;
end;

procedure TFhirNutritionProductInstance.SetUseByST(value : TFslDateTime);
begin
  if FUseBy = nil then
    FUseBy := TFhirDateTime.create;
  FUseBy.value := value
end;

procedure TFhirNutritionProductInstance.SetBiologicalSourceEvent(value : TFhirIdentifier);
begin
  FBiologicalSourceEvent.free;
  FBiologicalSourceEvent := value;
end;

{ TFhirNutritionProductInstanceListEnumerator }

constructor TFhirNutritionProductInstanceListEnumerator.Create(list : TFhirNutritionProductInstanceList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirNutritionProductInstanceListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirNutritionProductInstanceListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirNutritionProductInstanceListEnumerator.GetCurrent : TFhirNutritionProductInstance;
begin
  Result := FList[FIndex];
end;

function TFhirNutritionProductInstanceListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirNutritionProductInstanceList }

function TFhirNutritionProductInstanceList.AddItem(value: TFhirNutritionProductInstance): TFhirNutritionProductInstance;
begin
  assert(value.ClassName = 'TFhirNutritionProductInstance', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirNutritionProductInstance');
  add(value);
  result := value;
end;

function TFhirNutritionProductInstanceList.Append: TFhirNutritionProductInstance;
begin
  result := TFhirNutritionProductInstance.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirNutritionProductInstanceList.ClearItems;
begin
  Clear;
end;

function TFhirNutritionProductInstanceList.GetEnumerator : TFhirNutritionProductInstanceListEnumerator;
begin
  result := TFhirNutritionProductInstanceListEnumerator.Create(self.link);
end;

function TFhirNutritionProductInstanceList.Clone: TFhirNutritionProductInstanceList;
begin
  result := TFhirNutritionProductInstanceList(inherited Clone);
end;

function TFhirNutritionProductInstanceList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirNutritionProductInstanceList.GetItemN(index: Integer): TFhirNutritionProductInstance;
begin
  result := TFhirNutritionProductInstance(ObjectByIndex[index]);
end;

function TFhirNutritionProductInstanceList.ItemClass: TFslObjectClass;
begin
  result := TFhirNutritionProductInstance;
end;
function TFhirNutritionProductInstanceList.IndexOf(value: TFhirNutritionProductInstance): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirNutritionProductInstanceList.Insert(index: Integer): TFhirNutritionProductInstance;
begin
  result := TFhirNutritionProductInstance.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirNutritionProductInstanceList.InsertItem(index: Integer; value: TFhirNutritionProductInstance);
begin
  assert(value is TFhirNutritionProductInstance);
  Inherited Insert(index, value);
end;

function TFhirNutritionProductInstanceList.Item(index: Integer): TFhirNutritionProductInstance;
begin
  result := TFhirNutritionProductInstance(ObjectByIndex[index]);
end;

function TFhirNutritionProductInstanceList.Link: TFhirNutritionProductInstanceList;
begin
  result := TFhirNutritionProductInstanceList(inherited Link);
end;

procedure TFhirNutritionProductInstanceList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirNutritionProductInstanceList.SetItemByIndex(index: Integer; value: TFhirNutritionProductInstance);
begin
  assert(value is TFhirNutritionProductInstance);
  FhirNutritionProductInstances[index] := value;
end;

procedure TFhirNutritionProductInstanceList.SetItemN(index: Integer; value: TFhirNutritionProductInstance);
begin
  assert(value is TFhirNutritionProductInstance);
  ObjectByIndex[index] := value;
end;

{ TFhirNutritionProduct }

constructor TFhirNutritionProduct.Create;
begin
  inherited;
end;

destructor TFhirNutritionProduct.Destroy;
begin
  FCode.free;
  FStatus.free;
  FCategoryList.Free;
  FManufacturerList.Free;
  FNutrientList.Free;
  FIngredientList.Free;
  FKnownAllergenList.Free;
  FCharacteristicList.Free;
  FInstanceList.Free;
  FNoteList.Free;
  inherited;
end;

procedure TFhirNutritionProduct.Assign(oSource : TFslObject);
begin
  inherited;
  code := TFhirNutritionProduct(oSource).code.Clone;
  statusElement := TFhirNutritionProduct(oSource).statusElement.Clone;
  if (TFhirNutritionProduct(oSource).FCategoryList = nil) then
  begin
    FCategoryList.free;
    FCategoryList := nil;
  end
  else
  begin
    if FCategoryList = nil then
      FCategoryList := TFhirCodeableConceptList.Create;
    FCategoryList.Assign(TFhirNutritionProduct(oSource).FCategoryList);
  end;
  if (TFhirNutritionProduct(oSource).FManufacturerList = nil) then
  begin
    FManufacturerList.free;
    FManufacturerList := nil;
  end
  else
  begin
    if FManufacturerList = nil then
      FManufacturerList := TFhirReferenceList.Create;
    FManufacturerList.Assign(TFhirNutritionProduct(oSource).FManufacturerList);
  end;
  if (TFhirNutritionProduct(oSource).FNutrientList = nil) then
  begin
    FNutrientList.free;
    FNutrientList := nil;
  end
  else
  begin
    if FNutrientList = nil then
      FNutrientList := TFhirNutritionProductNutrientList.Create;
    FNutrientList.Assign(TFhirNutritionProduct(oSource).FNutrientList);
  end;
  if (TFhirNutritionProduct(oSource).FIngredientList = nil) then
  begin
    FIngredientList.free;
    FIngredientList := nil;
  end
  else
  begin
    if FIngredientList = nil then
      FIngredientList := TFhirNutritionProductIngredientList.Create;
    FIngredientList.Assign(TFhirNutritionProduct(oSource).FIngredientList);
  end;
  if (TFhirNutritionProduct(oSource).FKnownAllergenList = nil) then
  begin
    FKnownAllergenList.free;
    FKnownAllergenList := nil;
  end
  else
  begin
    if FKnownAllergenList = nil then
      FKnownAllergenList := TFhirCodeableReferenceList.Create;
    FKnownAllergenList.Assign(TFhirNutritionProduct(oSource).FKnownAllergenList);
  end;
  if (TFhirNutritionProduct(oSource).FCharacteristicList = nil) then
  begin
    FCharacteristicList.free;
    FCharacteristicList := nil;
  end
  else
  begin
    if FCharacteristicList = nil then
      FCharacteristicList := TFhirNutritionProductCharacteristicList.Create;
    FCharacteristicList.Assign(TFhirNutritionProduct(oSource).FCharacteristicList);
  end;
  if (TFhirNutritionProduct(oSource).FInstanceList = nil) then
  begin
    FInstanceList.free;
    FInstanceList := nil;
  end
  else
  begin
    if FInstanceList = nil then
      FInstanceList := TFhirNutritionProductInstanceList.Create;
    FInstanceList.Assign(TFhirNutritionProduct(oSource).FInstanceList);
  end;
  if (TFhirNutritionProduct(oSource).FNoteList = nil) then
  begin
    FNoteList.free;
    FNoteList := nil;
  end
  else
  begin
    if FNoteList = nil then
      FNoteList := TFhirAnnotationList.Create;
    FNoteList.Assign(TFhirNutritionProduct(oSource).FNoteList);
  end;
end;

function TFhirNutritionProduct.GetResourceType : TFhirResourceType;
begin
  result := frtNutritionProduct;
end;

procedure TFhirNutritionProduct.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'code') Then
     list.add(self.link, 'code', FCode.Link);
  if (child_name = 'status') Then
     list.add(self.link, 'status', FStatus.Link);
  if (child_name = 'category') Then
    list.addAll(self, 'category', FCategoryList);
  if (child_name = 'manufacturer') Then
    list.addAll(self, 'manufacturer', FManufacturerList);
  if (child_name = 'nutrient') Then
    list.addAll(self, 'nutrient', FNutrientList);
  if (child_name = 'ingredient') Then
    list.addAll(self, 'ingredient', FIngredientList);
  if (child_name = 'knownAllergen') Then
    list.addAll(self, 'knownAllergen', FKnownAllergenList);
  if (child_name = 'characteristic') Then
    list.addAll(self, 'characteristic', FCharacteristicList);
  if (child_name = 'instance') Then
    list.addAll(self, 'instance', FInstanceList);
  if (child_name = 'note') Then
    list.addAll(self, 'note', FNoteList);
end;

procedure TFhirNutritionProduct.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'code', 'CodeableConcept', false, TFhirCodeableConcept, FCode.Link));
  oList.add(TFHIRProperty.create(self, 'status', 'code', false, TFhirEnum, FStatus.Link));
  oList.add(TFHIRProperty.create(self, 'category', 'CodeableConcept', true, TFhirCodeableConcept, FCategoryList.Link));
  oList.add(TFHIRProperty.create(self, 'manufacturer', 'Reference', true, TFhirReference, FManufacturerList.Link));
  oList.add(TFHIRProperty.create(self, 'nutrient', 'BackboneElement', true, TFhirNutritionProductNutrient, FNutrientList.Link));
  oList.add(TFHIRProperty.create(self, 'ingredient', 'BackboneElement', true, TFhirNutritionProductIngredient, FIngredientList.Link));
  oList.add(TFHIRProperty.create(self, 'knownAllergen', 'CodeableReference', true, TFhirCodeableReference, FKnownAllergenList.Link));
  oList.add(TFHIRProperty.create(self, 'characteristic', 'BackboneElement', true, TFhirNutritionProductCharacteristic, FCharacteristicList.Link));
  oList.add(TFHIRProperty.create(self, 'instance', 'BackboneElement', true, TFhirNutritionProductInstance, FInstanceList.Link));
  oList.add(TFHIRProperty.create(self, 'note', 'Annotation', true, TFhirAnnotation, FNoteList.Link));
end;

function TFhirNutritionProduct.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'code') then
  begin
    Code := propValue as TFhirCodeableConcept;
    result := propValue;
  end
  else if (propName = 'status') then
  begin
    StatusElement := asEnum(SYSTEMS_TFhirNutritionProductStatusEnum, CODES_TFhirNutritionProductStatusEnum, propValue);
    result := propValue;
  end
  else if (propName = 'category') then
  begin
    CategoryList.add(propValue as TFhirCodeableConcept);
    result := propValue;
  end
  else if (propName = 'manufacturer') then
  begin
    ManufacturerList.add(propValue as TFhirReference);
    result := propValue;
  end
  else if (propName = 'nutrient') then
  begin
    NutrientList.add(propValue as TFhirNutritionProductNutrient);
    result := propValue;
  end
  else if (propName = 'ingredient') then
  begin
    IngredientList.add(propValue as TFhirNutritionProductIngredient);
    result := propValue;
  end
  else if (propName = 'knownAllergen') then
  begin
    KnownAllergenList.add(propValue as TFhirCodeableReference);
    result := propValue;
  end
  else if (propName = 'characteristic') then
  begin
    CharacteristicList.add(propValue as TFhirNutritionProductCharacteristic);
    result := propValue;
  end
  else if (propName = 'instance') then
  begin
    InstanceList.add(propValue as TFhirNutritionProductInstance);
    result := propValue;
  end
  else if (propName = 'note') then
  begin
    NoteList.add(propValue as TFhirAnnotation);
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirNutritionProduct.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'category') then CategoryList.insertItem(index, propValue as TFhirCodeableConcept)
  else if (propName = 'manufacturer') then ManufacturerList.insertItem(index, propValue as TFhirReference)
  else if (propName = 'nutrient') then NutrientList.insertItem(index, propValue as TFhirNutritionProductNutrient)
  else if (propName = 'ingredient') then IngredientList.insertItem(index, propValue as TFhirNutritionProductIngredient)
  else if (propName = 'knownAllergen') then KnownAllergenList.insertItem(index, propValue as TFhirCodeableReference)
  else if (propName = 'characteristic') then CharacteristicList.insertItem(index, propValue as TFhirNutritionProductCharacteristic)
  else if (propName = 'instance') then InstanceList.insertItem(index, propValue as TFhirNutritionProductInstance)
  else if (propName = 'note') then NoteList.insertItem(index, propValue as TFhirAnnotation)
  else inherited;
end;

function TFhirNutritionProduct.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'code') then result := TFhirCodeableConcept.create()
  else if (propName = 'status') then result := TFhirEnum.create(SYSTEMS_TFhirNutritionProductStatusEnum[NutritionProductStatusNull], CODES_TFhirNutritionProductStatusEnum[NutritionProductStatusNull]) 
  else if (propName = 'category') then result := CategoryList.new()
  else if (propName = 'manufacturer') then result := ManufacturerList.new()
  else if (propName = 'nutrient') then result := NutrientList.new()
  else if (propName = 'ingredient') then result := IngredientList.new()
  else if (propName = 'knownAllergen') then result := KnownAllergenList.new()
  else if (propName = 'characteristic') then result := CharacteristicList.new()
  else if (propName = 'instance') then result := InstanceList.new()
  else if (propName = 'note') then result := NoteList.new()
  else result := inherited createPropertyValue(propName);
end;

function TFhirNutritionProduct.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'code') then result := 'CodeableConcept'
  else if (propName = 'status') then result := 'code'
  else if (propName = 'category') then result := 'CodeableConcept'
  else if (propName = 'manufacturer') then result := 'Reference'
  else if (propName = 'nutrient') then result := 'BackboneElement'
  else if (propName = 'ingredient') then result := 'BackboneElement'
  else if (propName = 'knownAllergen') then result := 'CodeableReference'
  else if (propName = 'characteristic') then result := 'BackboneElement'
  else if (propName = 'instance') then result := 'BackboneElement'
  else if (propName = 'note') then result := 'Annotation'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirNutritionProduct.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'code') then CodeElement := nil
  else if (propName = 'status') then StatusElement := nil
  else if (propName = 'category') then deletePropertyValue('category', CategoryList, value)
  else if (propName = 'manufacturer') then deletePropertyValue('manufacturer', ManufacturerList, value)
  else if (propName = 'nutrient') then deletePropertyValue('nutrient', NutrientList, value)
  else if (propName = 'ingredient') then deletePropertyValue('ingredient', IngredientList, value)
  else if (propName = 'knownAllergen') then deletePropertyValue('knownAllergen', KnownAllergenList, value)
  else if (propName = 'characteristic') then deletePropertyValue('characteristic', CharacteristicList, value)
  else if (propName = 'instance') then deletePropertyValue('instance', InstanceList, value)
  else if (propName = 'note') then deletePropertyValue('note', NoteList, value)
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirNutritionProduct.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'code') then CodeElement := new as TFhirCodeableConcept
  else if (propName = 'status') then StatusElement := asEnum(SYSTEMS_TFhirNutritionProductStatusEnum, CODES_TFhirNutritionProductStatusEnum, new)
  else if (propName = 'category') then replacePropertyValue('category', CategoryList, existing, new)
  else if (propName = 'manufacturer') then replacePropertyValue('manufacturer', ManufacturerList, existing, new)
  else if (propName = 'nutrient') then replacePropertyValue('nutrient', NutrientList, existing, new)
  else if (propName = 'ingredient') then replacePropertyValue('ingredient', IngredientList, existing, new)
  else if (propName = 'knownAllergen') then replacePropertyValue('knownAllergen', KnownAllergenList, existing, new)
  else if (propName = 'characteristic') then replacePropertyValue('characteristic', CharacteristicList, existing, new)
  else if (propName = 'instance') then replacePropertyValue('instance', InstanceList, existing, new)
  else if (propName = 'note') then replacePropertyValue('note', NoteList, existing, new)
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirNutritionProduct.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'category') then CategoryList.move(source, destination)
  else if (propName = 'manufacturer') then ManufacturerList.move(source, destination)
  else if (propName = 'nutrient') then NutrientList.move(source, destination)
  else if (propName = 'ingredient') then IngredientList.move(source, destination)
  else if (propName = 'knownAllergen') then KnownAllergenList.move(source, destination)
  else if (propName = 'characteristic') then CharacteristicList.move(source, destination)
  else if (propName = 'instance') then InstanceList.move(source, destination)
  else if (propName = 'note') then NoteList.move(source, destination)
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirNutritionProduct.fhirType : string;
begin
  result := 'NutritionProduct';
end;

function TFhirNutritionProduct.Link : TFhirNutritionProduct;
begin
  result := TFhirNutritionProduct(inherited Link);
end;

function TFhirNutritionProduct.Clone : TFhirNutritionProduct;
begin
  result := TFhirNutritionProduct(inherited Clone);
end;

function TFhirNutritionProduct.equals(other : TObject) : boolean; 
var
  o : TFhirNutritionProduct;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirNutritionProduct)) then
    result := false
  else
  begin
    o := TFhirNutritionProduct(other);
    result := compareDeep(codeElement, o.codeElement, true) and compareDeep(statusElement, o.statusElement, true) and 
      compareDeep(categoryList, o.categoryList, true) and compareDeep(manufacturerList, o.manufacturerList, true) and 
      compareDeep(nutrientList, o.nutrientList, true) and compareDeep(ingredientList, o.ingredientList, true) and 
      compareDeep(knownAllergenList, o.knownAllergenList, true) and compareDeep(characteristicList, o.characteristicList, true) and 
      compareDeep(instanceList, o.instanceList, true) and compareDeep(noteList, o.noteList, true);
  end;
end;

function TFhirNutritionProduct.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FCode) and isEmptyProp(FStatus) and isEmptyProp(FcategoryList) and isEmptyProp(FmanufacturerList) and isEmptyProp(FnutrientList) and isEmptyProp(FingredientList) and isEmptyProp(FknownAllergenList) and isEmptyProp(FcharacteristicList) and isEmptyProp(FinstanceList) and isEmptyProp(FnoteList);
end;

procedure TFhirNutritionProduct.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('code');
  fields.add('status');
  fields.add('category');
  fields.add('manufacturer');
  fields.add('nutrient');
  fields.add('ingredient');
  fields.add('knownAllergen');
  fields.add('characteristic');
  fields.add('instance');
  fields.add('note');
end;

function TFhirNutritionProduct.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
  inc(result, FCategoryList.sizeInBytes(magic));
  inc(result, FManufacturerList.sizeInBytes(magic));
  inc(result, FNutrientList.sizeInBytes(magic));
  inc(result, FIngredientList.sizeInBytes(magic));
  inc(result, FKnownAllergenList.sizeInBytes(magic));
  inc(result, FCharacteristicList.sizeInBytes(magic));
  inc(result, FInstanceList.sizeInBytes(magic));
  inc(result, FNoteList.sizeInBytes(magic));
end;

procedure TFhirNutritionProduct.SetCode(value : TFhirCodeableConcept);
begin
  FCode.free;
  FCode := value;
end;

procedure TFhirNutritionProduct.SetStatus(value : TFhirEnum);
begin
  FStatus.free;
  FStatus := value;
end;

function TFhirNutritionProduct.GetStatusST : TFhirNutritionProductStatusEnum;
begin
  if FStatus = nil then
    result := TFhirNutritionProductStatusEnum(0)
  else
    result := TFhirNutritionProductStatusEnum(StringArrayIndexOfSensitive(CODES_TFhirNutritionProductStatusEnum, FStatus.value));
end;

procedure TFhirNutritionProduct.SetStatusST(value : TFhirNutritionProductStatusEnum);
begin
  if ord(value) = 0 then
    StatusElement := nil
  else
    StatusElement := TFhirEnum.create(SYSTEMS_TFhirNutritionProductStatusEnum[value], CODES_TFhirNutritionProductStatusEnum[value]);
end;

function TFhirNutritionProduct.GetCategoryList : TFhirCodeableConceptList;
begin
  if FCategoryList = nil then
    FCategoryList := TFhirCodeableConceptList.Create;
  result := FCategoryList;
end;

function TFhirNutritionProduct.GetHasCategoryList : boolean;
begin
  result := (FCategoryList <> nil) and (FCategoryList.count > 0);
end;

function TFhirNutritionProduct.GetManufacturerList : TFhirReferenceList;
begin
  if FManufacturerList = nil then
    FManufacturerList := TFhirReferenceList.Create;
  result := FManufacturerList;
end;

function TFhirNutritionProduct.GetHasManufacturerList : boolean;
begin
  result := (FManufacturerList <> nil) and (FManufacturerList.count > 0);
end;

function TFhirNutritionProduct.GetNutrientList : TFhirNutritionProductNutrientList;
begin
  if FNutrientList = nil then
    FNutrientList := TFhirNutritionProductNutrientList.Create;
  result := FNutrientList;
end;

function TFhirNutritionProduct.GetHasNutrientList : boolean;
begin
  result := (FNutrientList <> nil) and (FNutrientList.count > 0);
end;

function TFhirNutritionProduct.GetIngredientList : TFhirNutritionProductIngredientList;
begin
  if FIngredientList = nil then
    FIngredientList := TFhirNutritionProductIngredientList.Create;
  result := FIngredientList;
end;

function TFhirNutritionProduct.GetHasIngredientList : boolean;
begin
  result := (FIngredientList <> nil) and (FIngredientList.count > 0);
end;

function TFhirNutritionProduct.GetKnownAllergenList : TFhirCodeableReferenceList;
begin
  if FKnownAllergenList = nil then
    FKnownAllergenList := TFhirCodeableReferenceList.Create;
  result := FKnownAllergenList;
end;

function TFhirNutritionProduct.GetHasKnownAllergenList : boolean;
begin
  result := (FKnownAllergenList <> nil) and (FKnownAllergenList.count > 0);
end;

function TFhirNutritionProduct.GetCharacteristicList : TFhirNutritionProductCharacteristicList;
begin
  if FCharacteristicList = nil then
    FCharacteristicList := TFhirNutritionProductCharacteristicList.Create;
  result := FCharacteristicList;
end;

function TFhirNutritionProduct.GetHasCharacteristicList : boolean;
begin
  result := (FCharacteristicList <> nil) and (FCharacteristicList.count > 0);
end;

function TFhirNutritionProduct.GetInstanceList : TFhirNutritionProductInstanceList;
begin
  if FInstanceList = nil then
    FInstanceList := TFhirNutritionProductInstanceList.Create;
  result := FInstanceList;
end;

function TFhirNutritionProduct.GetHasInstanceList : boolean;
begin
  result := (FInstanceList <> nil) and (FInstanceList.count > 0);
end;

function TFhirNutritionProduct.GetNoteList : TFhirAnnotationList;
begin
  if FNoteList = nil then
    FNoteList := TFhirAnnotationList.Create;
  result := FNoteList;
end;

function TFhirNutritionProduct.GetHasNoteList : boolean;
begin
  result := (FNoteList <> nil) and (FNoteList.count > 0);
end;

{ TFhirNutritionProductListEnumerator }

constructor TFhirNutritionProductListEnumerator.Create(list : TFhirNutritionProductList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirNutritionProductListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirNutritionProductListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirNutritionProductListEnumerator.GetCurrent : TFhirNutritionProduct;
begin
  Result := FList[FIndex];
end;

function TFhirNutritionProductListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirNutritionProductList }

function TFhirNutritionProductList.AddItem(value: TFhirNutritionProduct): TFhirNutritionProduct;
begin
  assert(value.ClassName = 'TFhirNutritionProduct', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirNutritionProduct');
  add(value);
  result := value;
end;

function TFhirNutritionProductList.Append: TFhirNutritionProduct;
begin
  result := TFhirNutritionProduct.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirNutritionProductList.ClearItems;
begin
  Clear;
end;

function TFhirNutritionProductList.GetEnumerator : TFhirNutritionProductListEnumerator;
begin
  result := TFhirNutritionProductListEnumerator.Create(self.link);
end;

function TFhirNutritionProductList.Clone: TFhirNutritionProductList;
begin
  result := TFhirNutritionProductList(inherited Clone);
end;

function TFhirNutritionProductList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirNutritionProductList.GetItemN(index: Integer): TFhirNutritionProduct;
begin
  result := TFhirNutritionProduct(ObjectByIndex[index]);
end;

function TFhirNutritionProductList.ItemClass: TFslObjectClass;
begin
  result := TFhirNutritionProduct;
end;
function TFhirNutritionProductList.IndexOf(value: TFhirNutritionProduct): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirNutritionProductList.Insert(index: Integer): TFhirNutritionProduct;
begin
  result := TFhirNutritionProduct.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirNutritionProductList.InsertItem(index: Integer; value: TFhirNutritionProduct);
begin
  assert(value is TFhirNutritionProduct);
  Inherited Insert(index, value);
end;

function TFhirNutritionProductList.Item(index: Integer): TFhirNutritionProduct;
begin
  result := TFhirNutritionProduct(ObjectByIndex[index]);
end;

function TFhirNutritionProductList.Link: TFhirNutritionProductList;
begin
  result := TFhirNutritionProductList(inherited Link);
end;

procedure TFhirNutritionProductList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirNutritionProductList.SetItemByIndex(index: Integer; value: TFhirNutritionProduct);
begin
  assert(value is TFhirNutritionProduct);
  FhirNutritionProducts[index] := value;
end;

procedure TFhirNutritionProductList.SetItemN(index: Integer; value: TFhirNutritionProduct);
begin
  assert(value is TFhirNutritionProduct);
  ObjectByIndex[index] := value;
end;

{$ENDIF FHIR_NUTRITIONPRODUCT}
{$IFDEF FHIR_PACKAGEDPRODUCTDEFINITION}
{ TFhirPackagedProductDefinitionLegalStatusOfSupply }

constructor TFhirPackagedProductDefinitionLegalStatusOfSupply.Create;
begin
  inherited;
end;

destructor TFhirPackagedProductDefinitionLegalStatusOfSupply.Destroy;
begin
  FCode.free;
  FJurisdiction.free;
  inherited;
end;

procedure TFhirPackagedProductDefinitionLegalStatusOfSupply.Assign(oSource : TFslObject);
begin
  inherited;
  code := TFhirPackagedProductDefinitionLegalStatusOfSupply(oSource).code.Clone;
  jurisdiction := TFhirPackagedProductDefinitionLegalStatusOfSupply(oSource).jurisdiction.Clone;
end;

procedure TFhirPackagedProductDefinitionLegalStatusOfSupply.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'code') Then
     list.add(self.link, 'code', FCode.Link);
  if (child_name = 'jurisdiction') Then
     list.add(self.link, 'jurisdiction', FJurisdiction.Link);
end;

procedure TFhirPackagedProductDefinitionLegalStatusOfSupply.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'code', 'CodeableConcept', false, TFhirCodeableConcept, FCode.Link));
  oList.add(TFHIRProperty.create(self, 'jurisdiction', 'CodeableConcept', false, TFhirCodeableConcept, FJurisdiction.Link));
end;

function TFhirPackagedProductDefinitionLegalStatusOfSupply.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'code') then
  begin
    Code := propValue as TFhirCodeableConcept;
    result := propValue;
  end
  else if (propName = 'jurisdiction') then
  begin
    Jurisdiction := propValue as TFhirCodeableConcept;
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirPackagedProductDefinitionLegalStatusOfSupply.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirPackagedProductDefinitionLegalStatusOfSupply.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'code') then result := TFhirCodeableConcept.create()
  else if (propName = 'jurisdiction') then result := TFhirCodeableConcept.create()
  else result := inherited createPropertyValue(propName);
end;

function TFhirPackagedProductDefinitionLegalStatusOfSupply.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'code') then result := 'CodeableConcept'
  else if (propName = 'jurisdiction') then result := 'CodeableConcept'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirPackagedProductDefinitionLegalStatusOfSupply.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'code') then CodeElement := nil
  else if (propName = 'jurisdiction') then JurisdictionElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirPackagedProductDefinitionLegalStatusOfSupply.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'code') then CodeElement := new as TFhirCodeableConcept
  else if (propName = 'jurisdiction') then JurisdictionElement := new as TFhirCodeableConcept
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirPackagedProductDefinitionLegalStatusOfSupply.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirPackagedProductDefinitionLegalStatusOfSupply.fhirType : string;
begin
  result := 'PackagedProductDefinition.legalStatusOfSupply';
end;

function TFhirPackagedProductDefinitionLegalStatusOfSupply.Link : TFhirPackagedProductDefinitionLegalStatusOfSupply;
begin
  result := TFhirPackagedProductDefinitionLegalStatusOfSupply(inherited Link);
end;

function TFhirPackagedProductDefinitionLegalStatusOfSupply.Clone : TFhirPackagedProductDefinitionLegalStatusOfSupply;
begin
  result := TFhirPackagedProductDefinitionLegalStatusOfSupply(inherited Clone);
end;

function TFhirPackagedProductDefinitionLegalStatusOfSupply.equals(other : TObject) : boolean; 
var
  o : TFhirPackagedProductDefinitionLegalStatusOfSupply;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirPackagedProductDefinitionLegalStatusOfSupply)) then
    result := false
  else
  begin
    o := TFhirPackagedProductDefinitionLegalStatusOfSupply(other);
    result := compareDeep(codeElement, o.codeElement, true) and compareDeep(jurisdictionElement, o.jurisdictionElement, true);
  end;
end;

function TFhirPackagedProductDefinitionLegalStatusOfSupply.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FCode) and isEmptyProp(FJurisdiction);
end;

procedure TFhirPackagedProductDefinitionLegalStatusOfSupply.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('code');
  fields.add('jurisdiction');
end;

function TFhirPackagedProductDefinitionLegalStatusOfSupply.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
end;

procedure TFhirPackagedProductDefinitionLegalStatusOfSupply.SetCode(value : TFhirCodeableConcept);
begin
  FCode.free;
  FCode := value;
end;

procedure TFhirPackagedProductDefinitionLegalStatusOfSupply.SetJurisdiction(value : TFhirCodeableConcept);
begin
  FJurisdiction.free;
  FJurisdiction := value;
end;

{ TFhirPackagedProductDefinitionLegalStatusOfSupplyListEnumerator }

constructor TFhirPackagedProductDefinitionLegalStatusOfSupplyListEnumerator.Create(list : TFhirPackagedProductDefinitionLegalStatusOfSupplyList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirPackagedProductDefinitionLegalStatusOfSupplyListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirPackagedProductDefinitionLegalStatusOfSupplyListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirPackagedProductDefinitionLegalStatusOfSupplyListEnumerator.GetCurrent : TFhirPackagedProductDefinitionLegalStatusOfSupply;
begin
  Result := FList[FIndex];
end;

function TFhirPackagedProductDefinitionLegalStatusOfSupplyListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirPackagedProductDefinitionLegalStatusOfSupplyList }

function TFhirPackagedProductDefinitionLegalStatusOfSupplyList.AddItem(value: TFhirPackagedProductDefinitionLegalStatusOfSupply): TFhirPackagedProductDefinitionLegalStatusOfSupply;
begin
  assert(value.ClassName = 'TFhirPackagedProductDefinitionLegalStatusOfSupply', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirPackagedProductDefinitionLegalStatusOfSupply');
  add(value);
  result := value;
end;

function TFhirPackagedProductDefinitionLegalStatusOfSupplyList.Append: TFhirPackagedProductDefinitionLegalStatusOfSupply;
begin
  result := TFhirPackagedProductDefinitionLegalStatusOfSupply.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirPackagedProductDefinitionLegalStatusOfSupplyList.ClearItems;
begin
  Clear;
end;

function TFhirPackagedProductDefinitionLegalStatusOfSupplyList.GetEnumerator : TFhirPackagedProductDefinitionLegalStatusOfSupplyListEnumerator;
begin
  result := TFhirPackagedProductDefinitionLegalStatusOfSupplyListEnumerator.Create(self.link);
end;

function TFhirPackagedProductDefinitionLegalStatusOfSupplyList.Clone: TFhirPackagedProductDefinitionLegalStatusOfSupplyList;
begin
  result := TFhirPackagedProductDefinitionLegalStatusOfSupplyList(inherited Clone);
end;

function TFhirPackagedProductDefinitionLegalStatusOfSupplyList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirPackagedProductDefinitionLegalStatusOfSupplyList.GetItemN(index: Integer): TFhirPackagedProductDefinitionLegalStatusOfSupply;
begin
  result := TFhirPackagedProductDefinitionLegalStatusOfSupply(ObjectByIndex[index]);
end;

function TFhirPackagedProductDefinitionLegalStatusOfSupplyList.ItemClass: TFslObjectClass;
begin
  result := TFhirPackagedProductDefinitionLegalStatusOfSupply;
end;
function TFhirPackagedProductDefinitionLegalStatusOfSupplyList.IndexOf(value: TFhirPackagedProductDefinitionLegalStatusOfSupply): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirPackagedProductDefinitionLegalStatusOfSupplyList.Insert(index: Integer): TFhirPackagedProductDefinitionLegalStatusOfSupply;
begin
  result := TFhirPackagedProductDefinitionLegalStatusOfSupply.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirPackagedProductDefinitionLegalStatusOfSupplyList.InsertItem(index: Integer; value: TFhirPackagedProductDefinitionLegalStatusOfSupply);
begin
  assert(value is TFhirPackagedProductDefinitionLegalStatusOfSupply);
  Inherited Insert(index, value);
end;

function TFhirPackagedProductDefinitionLegalStatusOfSupplyList.Item(index: Integer): TFhirPackagedProductDefinitionLegalStatusOfSupply;
begin
  result := TFhirPackagedProductDefinitionLegalStatusOfSupply(ObjectByIndex[index]);
end;

function TFhirPackagedProductDefinitionLegalStatusOfSupplyList.Link: TFhirPackagedProductDefinitionLegalStatusOfSupplyList;
begin
  result := TFhirPackagedProductDefinitionLegalStatusOfSupplyList(inherited Link);
end;

procedure TFhirPackagedProductDefinitionLegalStatusOfSupplyList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirPackagedProductDefinitionLegalStatusOfSupplyList.SetItemByIndex(index: Integer; value: TFhirPackagedProductDefinitionLegalStatusOfSupply);
begin
  assert(value is TFhirPackagedProductDefinitionLegalStatusOfSupply);
  FhirPackagedProductDefinitionLegalStatusOfSupplies[index] := value;
end;

procedure TFhirPackagedProductDefinitionLegalStatusOfSupplyList.SetItemN(index: Integer; value: TFhirPackagedProductDefinitionLegalStatusOfSupply);
begin
  assert(value is TFhirPackagedProductDefinitionLegalStatusOfSupply);
  ObjectByIndex[index] := value;
end;

{ TFhirPackagedProductDefinitionPackaging }

constructor TFhirPackagedProductDefinitionPackaging.Create;
begin
  inherited;
end;

destructor TFhirPackagedProductDefinitionPackaging.Destroy;
begin
  FIdentifierList.Free;
  FType_.free;
  FQuantity.free;
  FMaterialList.Free;
  FAlternateMaterialList.Free;
  FShelfLifeStorageList.Free;
  FManufacturerList.Free;
  FProperty_List.Free;
  FContainedItemList.Free;
  FPackagingList.Free;
  inherited;
end;

procedure TFhirPackagedProductDefinitionPackaging.Assign(oSource : TFslObject);
begin
  inherited;
  if (TFhirPackagedProductDefinitionPackaging(oSource).FIdentifierList = nil) then
  begin
    FIdentifierList.free;
    FIdentifierList := nil;
  end
  else
  begin
    if FIdentifierList = nil then
      FIdentifierList := TFhirIdentifierList.Create;
    FIdentifierList.Assign(TFhirPackagedProductDefinitionPackaging(oSource).FIdentifierList);
  end;
  type_ := TFhirPackagedProductDefinitionPackaging(oSource).type_.Clone;
  quantityElement := TFhirPackagedProductDefinitionPackaging(oSource).quantityElement.Clone;
  if (TFhirPackagedProductDefinitionPackaging(oSource).FMaterialList = nil) then
  begin
    FMaterialList.free;
    FMaterialList := nil;
  end
  else
  begin
    if FMaterialList = nil then
      FMaterialList := TFhirCodeableConceptList.Create;
    FMaterialList.Assign(TFhirPackagedProductDefinitionPackaging(oSource).FMaterialList);
  end;
  if (TFhirPackagedProductDefinitionPackaging(oSource).FAlternateMaterialList = nil) then
  begin
    FAlternateMaterialList.free;
    FAlternateMaterialList := nil;
  end
  else
  begin
    if FAlternateMaterialList = nil then
      FAlternateMaterialList := TFhirCodeableConceptList.Create;
    FAlternateMaterialList.Assign(TFhirPackagedProductDefinitionPackaging(oSource).FAlternateMaterialList);
  end;
  if (TFhirPackagedProductDefinitionPackaging(oSource).FShelfLifeStorageList = nil) then
  begin
    FShelfLifeStorageList.free;
    FShelfLifeStorageList := nil;
  end
  else
  begin
    if FShelfLifeStorageList = nil then
      FShelfLifeStorageList := TFhirProductShelfLifeList.Create;
    FShelfLifeStorageList.Assign(TFhirPackagedProductDefinitionPackaging(oSource).FShelfLifeStorageList);
  end;
  if (TFhirPackagedProductDefinitionPackaging(oSource).FManufacturerList = nil) then
  begin
    FManufacturerList.free;
    FManufacturerList := nil;
  end
  else
  begin
    if FManufacturerList = nil then
      FManufacturerList := TFhirReferenceList.Create;
    FManufacturerList.Assign(TFhirPackagedProductDefinitionPackaging(oSource).FManufacturerList);
  end;
  if (TFhirPackagedProductDefinitionPackaging(oSource).FProperty_List = nil) then
  begin
    FProperty_List.free;
    FProperty_List := nil;
  end
  else
  begin
    if FProperty_List = nil then
      FProperty_List := TFhirPackagedProductDefinitionPackagingPropertyList.Create;
    FProperty_List.Assign(TFhirPackagedProductDefinitionPackaging(oSource).FProperty_List);
  end;
  if (TFhirPackagedProductDefinitionPackaging(oSource).FContainedItemList = nil) then
  begin
    FContainedItemList.free;
    FContainedItemList := nil;
  end
  else
  begin
    if FContainedItemList = nil then
      FContainedItemList := TFhirPackagedProductDefinitionPackagingContainedItemList.Create;
    FContainedItemList.Assign(TFhirPackagedProductDefinitionPackaging(oSource).FContainedItemList);
  end;
  if (TFhirPackagedProductDefinitionPackaging(oSource).FPackagingList = nil) then
  begin
    FPackagingList.free;
    FPackagingList := nil;
  end
  else
  begin
    if FPackagingList = nil then
      FPackagingList := TFhirPackagedProductDefinitionPackagingList.Create;
    FPackagingList.Assign(TFhirPackagedProductDefinitionPackaging(oSource).FPackagingList);
  end;
end;

procedure TFhirPackagedProductDefinitionPackaging.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'identifier') Then
    list.addAll(self, 'identifier', FIdentifierList);
  if (child_name = 'type') Then
     list.add(self.link, 'type', FType_.Link);
  if (child_name = 'quantity') Then
     list.add(self.link, 'quantity', FQuantity.Link);
  if (child_name = 'material') Then
    list.addAll(self, 'material', FMaterialList);
  if (child_name = 'alternateMaterial') Then
    list.addAll(self, 'alternateMaterial', FAlternateMaterialList);
  if (child_name = 'shelfLifeStorage') Then
    list.addAll(self, 'shelfLifeStorage', FShelfLifeStorageList);
  if (child_name = 'manufacturer') Then
    list.addAll(self, 'manufacturer', FManufacturerList);
  if (child_name = 'property') Then
    list.addAll(self, 'property', FProperty_List);
  if (child_name = 'containedItem') Then
    list.addAll(self, 'containedItem', FContainedItemList);
  if (child_name = 'packaging') Then
    list.addAll(self, 'packaging', FPackagingList);
end;

procedure TFhirPackagedProductDefinitionPackaging.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'identifier', 'Identifier', true, TFhirIdentifier, FIdentifierList.Link));
  oList.add(TFHIRProperty.create(self, 'type', 'CodeableConcept', false, TFhirCodeableConcept, FType_.Link));
  oList.add(TFHIRProperty.create(self, 'quantity', 'integer', false, TFhirInteger, FQuantity.Link));
  oList.add(TFHIRProperty.create(self, 'material', 'CodeableConcept', true, TFhirCodeableConcept, FMaterialList.Link));
  oList.add(TFHIRProperty.create(self, 'alternateMaterial', 'CodeableConcept', true, TFhirCodeableConcept, FAlternateMaterialList.Link));
  oList.add(TFHIRProperty.create(self, 'shelfLifeStorage', 'ProductShelfLife', true, TFhirProductShelfLife, FShelfLifeStorageList.Link));
  oList.add(TFHIRProperty.create(self, 'manufacturer', 'Reference', true, TFhirReference, FManufacturerList.Link));
  oList.add(TFHIRProperty.create(self, 'property', 'BackboneElement', true, TFhirPackagedProductDefinitionPackagingProperty, FProperty_List.Link));
  oList.add(TFHIRProperty.create(self, 'containedItem', 'BackboneElement', true, TFhirPackagedProductDefinitionPackagingContainedItem, FContainedItemList.Link));
  oList.add(TFHIRProperty.create(self, 'packaging', '', true, TFhirPackagedProductDefinitionPackaging, FPackagingList.Link));
end;

function TFhirPackagedProductDefinitionPackaging.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'identifier') then
  begin
    IdentifierList.add(propValue as TFhirIdentifier);
    result := propValue;
  end
  else if (propName = 'type') then
  begin
    Type_ := propValue as TFhirCodeableConcept;
    result := propValue;
  end
  else if (propName = 'quantity') then
  begin
    QuantityElement := asInteger(propValue);
    result := propValue;
  end
  else if (propName = 'material') then
  begin
    MaterialList.add(propValue as TFhirCodeableConcept);
    result := propValue;
  end
  else if (propName = 'alternateMaterial') then
  begin
    AlternateMaterialList.add(propValue as TFhirCodeableConcept);
    result := propValue;
  end
  else if (propName = 'shelfLifeStorage') then
  begin
    ShelfLifeStorageList.add(propValue as TFhirProductShelfLife);
    result := propValue;
  end
  else if (propName = 'manufacturer') then
  begin
    ManufacturerList.add(propValue as TFhirReference);
    result := propValue;
  end
  else if (propName = 'property') then
  begin
    Property_List.add(propValue as TFhirPackagedProductDefinitionPackagingProperty);
    result := propValue;
  end
  else if (propName = 'containedItem') then
  begin
    ContainedItemList.add(propValue as TFhirPackagedProductDefinitionPackagingContainedItem);
    result := propValue;
  end
  else if (propName = 'packaging') then
  begin
    PackagingList.add(propValue as TFhirPackagedProductDefinitionPackaging);
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirPackagedProductDefinitionPackaging.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'identifier') then IdentifierList.insertItem(index, propValue as TFhirIdentifier)
  else if (propName = 'material') then MaterialList.insertItem(index, propValue as TFhirCodeableConcept)
  else if (propName = 'alternateMaterial') then AlternateMaterialList.insertItem(index, propValue as TFhirCodeableConcept)
  else if (propName = 'shelfLifeStorage') then ShelfLifeStorageList.insertItem(index, propValue as TFhirProductShelfLife)
  else if (propName = 'manufacturer') then ManufacturerList.insertItem(index, propValue as TFhirReference)
  else if (propName = 'property') then Property_List.insertItem(index, propValue as TFhirPackagedProductDefinitionPackagingProperty)
  else if (propName = 'containedItem') then ContainedItemList.insertItem(index, propValue as TFhirPackagedProductDefinitionPackagingContainedItem)
  else if (propName = 'packaging') then PackagingList.insertItem(index, propValue as TFhirPackagedProductDefinitionPackaging)
  else inherited;
end;

function TFhirPackagedProductDefinitionPackaging.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'identifier') then result := IdentifierList.new()
  else if (propName = 'type') then result := TFhirCodeableConcept.create()
  else if (propName = 'quantity') then result := TFhirInteger.create()
  else if (propName = 'material') then result := MaterialList.new()
  else if (propName = 'alternateMaterial') then result := AlternateMaterialList.new()
  else if (propName = 'shelfLifeStorage') then result := ShelfLifeStorageList.new()
  else if (propName = 'manufacturer') then result := ManufacturerList.new()
  else if (propName = 'property') then result := Property_List.new()
  else if (propName = 'containedItem') then result := ContainedItemList.new()
  else if (propName = 'packaging') then result := PackagingList.new()
  else result := inherited createPropertyValue(propName);
end;

function TFhirPackagedProductDefinitionPackaging.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'identifier') then result := 'Identifier'
  else if (propName = 'type') then result := 'CodeableConcept'
  else if (propName = 'quantity') then result := 'integer'
  else if (propName = 'material') then result := 'CodeableConcept'
  else if (propName = 'alternateMaterial') then result := 'CodeableConcept'
  else if (propName = 'shelfLifeStorage') then result := 'ProductShelfLife'
  else if (propName = 'manufacturer') then result := 'Reference'
  else if (propName = 'property') then result := 'BackboneElement'
  else if (propName = 'containedItem') then result := 'BackboneElement'
  else if (propName = 'packaging') then result := ''
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirPackagedProductDefinitionPackaging.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'identifier') then deletePropertyValue('identifier', IdentifierList, value)
  else if (propName = 'type') then Type_Element := nil
  else if (propName = 'quantity') then QuantityElement := nil
  else if (propName = 'material') then deletePropertyValue('material', MaterialList, value)
  else if (propName = 'alternateMaterial') then deletePropertyValue('alternateMaterial', AlternateMaterialList, value)
  else if (propName = 'shelfLifeStorage') then deletePropertyValue('shelfLifeStorage', ShelfLifeStorageList, value)
  else if (propName = 'manufacturer') then deletePropertyValue('manufacturer', ManufacturerList, value)
  else if (propName = 'property') then deletePropertyValue('property', Property_List, value)
  else if (propName = 'containedItem') then deletePropertyValue('containedItem', ContainedItemList, value)
  else if (propName = 'packaging') then deletePropertyValue('packaging', PackagingList, value)
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirPackagedProductDefinitionPackaging.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'identifier') then replacePropertyValue('identifier', IdentifierList, existing, new)
  else if (propName = 'type') then Type_Element := new as TFhirCodeableConcept
  else if (propName = 'quantity') then QuantityElement := asInteger(new)
  else if (propName = 'material') then replacePropertyValue('material', MaterialList, existing, new)
  else if (propName = 'alternateMaterial') then replacePropertyValue('alternateMaterial', AlternateMaterialList, existing, new)
  else if (propName = 'shelfLifeStorage') then replacePropertyValue('shelfLifeStorage', ShelfLifeStorageList, existing, new)
  else if (propName = 'manufacturer') then replacePropertyValue('manufacturer', ManufacturerList, existing, new)
  else if (propName = 'property') then replacePropertyValue('property', Property_List, existing, new)
  else if (propName = 'containedItem') then replacePropertyValue('containedItem', ContainedItemList, existing, new)
  else if (propName = 'packaging') then replacePropertyValue('packaging', PackagingList, existing, new)
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirPackagedProductDefinitionPackaging.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'identifier') then IdentifierList.move(source, destination)
  else if (propName = 'material') then MaterialList.move(source, destination)
  else if (propName = 'alternateMaterial') then AlternateMaterialList.move(source, destination)
  else if (propName = 'shelfLifeStorage') then ShelfLifeStorageList.move(source, destination)
  else if (propName = 'manufacturer') then ManufacturerList.move(source, destination)
  else if (propName = 'property') then Property_List.move(source, destination)
  else if (propName = 'containedItem') then ContainedItemList.move(source, destination)
  else if (propName = 'packaging') then PackagingList.move(source, destination)
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirPackagedProductDefinitionPackaging.fhirType : string;
begin
  result := 'PackagedProductDefinition.packaging';
end;

function TFhirPackagedProductDefinitionPackaging.Link : TFhirPackagedProductDefinitionPackaging;
begin
  result := TFhirPackagedProductDefinitionPackaging(inherited Link);
end;

function TFhirPackagedProductDefinitionPackaging.Clone : TFhirPackagedProductDefinitionPackaging;
begin
  result := TFhirPackagedProductDefinitionPackaging(inherited Clone);
end;

function TFhirPackagedProductDefinitionPackaging.equals(other : TObject) : boolean; 
var
  o : TFhirPackagedProductDefinitionPackaging;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirPackagedProductDefinitionPackaging)) then
    result := false
  else
  begin
    o := TFhirPackagedProductDefinitionPackaging(other);
    result := compareDeep(identifierList, o.identifierList, true) and compareDeep(type_Element, o.type_Element, true) and 
      compareDeep(quantityElement, o.quantityElement, true) and compareDeep(materialList, o.materialList, true) and 
      compareDeep(alternateMaterialList, o.alternateMaterialList, true) and compareDeep(shelfLifeStorageList, o.shelfLifeStorageList, true) and 
      compareDeep(manufacturerList, o.manufacturerList, true) and compareDeep(property_List, o.property_List, true) and 
      compareDeep(containedItemList, o.containedItemList, true) and compareDeep(packagingList, o.packagingList, true);
  end;
end;

function TFhirPackagedProductDefinitionPackaging.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FidentifierList) and isEmptyProp(FType_) and isEmptyProp(FQuantity) and isEmptyProp(FmaterialList) and isEmptyProp(FalternateMaterialList) and isEmptyProp(FshelfLifeStorageList) and isEmptyProp(FmanufacturerList) and isEmptyProp(Fproperty_List) and isEmptyProp(FcontainedItemList) and isEmptyProp(FpackagingList);
end;

procedure TFhirPackagedProductDefinitionPackaging.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('identifier');
  fields.add('type');
  fields.add('quantity');
  fields.add('material');
  fields.add('alternateMaterial');
  fields.add('shelfLifeStorage');
  fields.add('manufacturer');
  fields.add('property');
  fields.add('containedItem');
  fields.add('packaging');
end;

function TFhirPackagedProductDefinitionPackaging.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
  inc(result, FIdentifierList.sizeInBytes(magic));
  inc(result, FMaterialList.sizeInBytes(magic));
  inc(result, FAlternateMaterialList.sizeInBytes(magic));
  inc(result, FShelfLifeStorageList.sizeInBytes(magic));
  inc(result, FManufacturerList.sizeInBytes(magic));
  inc(result, FProperty_List.sizeInBytes(magic));
  inc(result, FContainedItemList.sizeInBytes(magic));
  inc(result, FPackagingList.sizeInBytes(magic));
end;

function TFhirPackagedProductDefinitionPackaging.GetIdentifierList : TFhirIdentifierList;
begin
  if FIdentifierList = nil then
    FIdentifierList := TFhirIdentifierList.Create;
  result := FIdentifierList;
end;

function TFhirPackagedProductDefinitionPackaging.GetHasIdentifierList : boolean;
begin
  result := (FIdentifierList <> nil) and (FIdentifierList.count > 0);
end;

procedure TFhirPackagedProductDefinitionPackaging.SetType_(value : TFhirCodeableConcept);
begin
  FType_.free;
  FType_ := value;
end;

procedure TFhirPackagedProductDefinitionPackaging.SetQuantity(value : TFhirInteger);
begin
  FQuantity.free;
  FQuantity := value;
end;

function TFhirPackagedProductDefinitionPackaging.GetQuantityST : String;
begin
  if FQuantity = nil then
    result := ''
  else
    result := FQuantity.value;
end;

procedure TFhirPackagedProductDefinitionPackaging.SetQuantityST(value : String);
begin
  if value <> '' then
  begin
    if FQuantity = nil then
      FQuantity := TFhirInteger.create;
    FQuantity.value := value
  end
  else if FQuantity <> nil then
    FQuantity.value := '';
end;

function TFhirPackagedProductDefinitionPackaging.GetMaterialList : TFhirCodeableConceptList;
begin
  if FMaterialList = nil then
    FMaterialList := TFhirCodeableConceptList.Create;
  result := FMaterialList;
end;

function TFhirPackagedProductDefinitionPackaging.GetHasMaterialList : boolean;
begin
  result := (FMaterialList <> nil) and (FMaterialList.count > 0);
end;

function TFhirPackagedProductDefinitionPackaging.GetAlternateMaterialList : TFhirCodeableConceptList;
begin
  if FAlternateMaterialList = nil then
    FAlternateMaterialList := TFhirCodeableConceptList.Create;
  result := FAlternateMaterialList;
end;

function TFhirPackagedProductDefinitionPackaging.GetHasAlternateMaterialList : boolean;
begin
  result := (FAlternateMaterialList <> nil) and (FAlternateMaterialList.count > 0);
end;

function TFhirPackagedProductDefinitionPackaging.GetShelfLifeStorageList : TFhirProductShelfLifeList;
begin
  if FShelfLifeStorageList = nil then
    FShelfLifeStorageList := TFhirProductShelfLifeList.Create;
  result := FShelfLifeStorageList;
end;

function TFhirPackagedProductDefinitionPackaging.GetHasShelfLifeStorageList : boolean;
begin
  result := (FShelfLifeStorageList <> nil) and (FShelfLifeStorageList.count > 0);
end;

function TFhirPackagedProductDefinitionPackaging.GetManufacturerList : TFhirReferenceList;
begin
  if FManufacturerList = nil then
    FManufacturerList := TFhirReferenceList.Create;
  result := FManufacturerList;
end;

function TFhirPackagedProductDefinitionPackaging.GetHasManufacturerList : boolean;
begin
  result := (FManufacturerList <> nil) and (FManufacturerList.count > 0);
end;

function TFhirPackagedProductDefinitionPackaging.GetProperty_List : TFhirPackagedProductDefinitionPackagingPropertyList;
begin
  if FProperty_List = nil then
    FProperty_List := TFhirPackagedProductDefinitionPackagingPropertyList.Create;
  result := FProperty_List;
end;

function TFhirPackagedProductDefinitionPackaging.GetHasProperty_List : boolean;
begin
  result := (FProperty_List <> nil) and (FProperty_List.count > 0);
end;

function TFhirPackagedProductDefinitionPackaging.GetContainedItemList : TFhirPackagedProductDefinitionPackagingContainedItemList;
begin
  if FContainedItemList = nil then
    FContainedItemList := TFhirPackagedProductDefinitionPackagingContainedItemList.Create;
  result := FContainedItemList;
end;

function TFhirPackagedProductDefinitionPackaging.GetHasContainedItemList : boolean;
begin
  result := (FContainedItemList <> nil) and (FContainedItemList.count > 0);
end;

function TFhirPackagedProductDefinitionPackaging.GetPackagingList : TFhirPackagedProductDefinitionPackagingList;
begin
  if FPackagingList = nil then
    FPackagingList := TFhirPackagedProductDefinitionPackagingList.Create;
  result := FPackagingList;
end;

function TFhirPackagedProductDefinitionPackaging.GetHasPackagingList : boolean;
begin
  result := (FPackagingList <> nil) and (FPackagingList.count > 0);
end;

{ TFhirPackagedProductDefinitionPackagingListEnumerator }

constructor TFhirPackagedProductDefinitionPackagingListEnumerator.Create(list : TFhirPackagedProductDefinitionPackagingList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirPackagedProductDefinitionPackagingListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirPackagedProductDefinitionPackagingListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirPackagedProductDefinitionPackagingListEnumerator.GetCurrent : TFhirPackagedProductDefinitionPackaging;
begin
  Result := FList[FIndex];
end;

function TFhirPackagedProductDefinitionPackagingListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirPackagedProductDefinitionPackagingList }

function TFhirPackagedProductDefinitionPackagingList.AddItem(value: TFhirPackagedProductDefinitionPackaging): TFhirPackagedProductDefinitionPackaging;
begin
  assert(value.ClassName = 'TFhirPackagedProductDefinitionPackaging', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirPackagedProductDefinitionPackaging');
  add(value);
  result := value;
end;

function TFhirPackagedProductDefinitionPackagingList.Append: TFhirPackagedProductDefinitionPackaging;
begin
  result := TFhirPackagedProductDefinitionPackaging.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirPackagedProductDefinitionPackagingList.ClearItems;
begin
  Clear;
end;

function TFhirPackagedProductDefinitionPackagingList.GetEnumerator : TFhirPackagedProductDefinitionPackagingListEnumerator;
begin
  result := TFhirPackagedProductDefinitionPackagingListEnumerator.Create(self.link);
end;

function TFhirPackagedProductDefinitionPackagingList.Clone: TFhirPackagedProductDefinitionPackagingList;
begin
  result := TFhirPackagedProductDefinitionPackagingList(inherited Clone);
end;

function TFhirPackagedProductDefinitionPackagingList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirPackagedProductDefinitionPackagingList.GetItemN(index: Integer): TFhirPackagedProductDefinitionPackaging;
begin
  result := TFhirPackagedProductDefinitionPackaging(ObjectByIndex[index]);
end;

function TFhirPackagedProductDefinitionPackagingList.ItemClass: TFslObjectClass;
begin
  result := TFhirPackagedProductDefinitionPackaging;
end;
function TFhirPackagedProductDefinitionPackagingList.IndexOf(value: TFhirPackagedProductDefinitionPackaging): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirPackagedProductDefinitionPackagingList.Insert(index: Integer): TFhirPackagedProductDefinitionPackaging;
begin
  result := TFhirPackagedProductDefinitionPackaging.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirPackagedProductDefinitionPackagingList.InsertItem(index: Integer; value: TFhirPackagedProductDefinitionPackaging);
begin
  assert(value is TFhirPackagedProductDefinitionPackaging);
  Inherited Insert(index, value);
end;

function TFhirPackagedProductDefinitionPackagingList.Item(index: Integer): TFhirPackagedProductDefinitionPackaging;
begin
  result := TFhirPackagedProductDefinitionPackaging(ObjectByIndex[index]);
end;

function TFhirPackagedProductDefinitionPackagingList.Link: TFhirPackagedProductDefinitionPackagingList;
begin
  result := TFhirPackagedProductDefinitionPackagingList(inherited Link);
end;

procedure TFhirPackagedProductDefinitionPackagingList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirPackagedProductDefinitionPackagingList.SetItemByIndex(index: Integer; value: TFhirPackagedProductDefinitionPackaging);
begin
  assert(value is TFhirPackagedProductDefinitionPackaging);
  FhirPackagedProductDefinitionPackagings[index] := value;
end;

procedure TFhirPackagedProductDefinitionPackagingList.SetItemN(index: Integer; value: TFhirPackagedProductDefinitionPackaging);
begin
  assert(value is TFhirPackagedProductDefinitionPackaging);
  ObjectByIndex[index] := value;
end;

{ TFhirPackagedProductDefinitionPackagingProperty }

constructor TFhirPackagedProductDefinitionPackagingProperty.Create;
begin
  inherited;
end;

destructor TFhirPackagedProductDefinitionPackagingProperty.Destroy;
begin
  FType_.free;
  FValue.free;
  inherited;
end;

procedure TFhirPackagedProductDefinitionPackagingProperty.Assign(oSource : TFslObject);
begin
  inherited;
  type_ := TFhirPackagedProductDefinitionPackagingProperty(oSource).type_.Clone;
  value := TFhirPackagedProductDefinitionPackagingProperty(oSource).value.Clone;
end;

procedure TFhirPackagedProductDefinitionPackagingProperty.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'type') Then
     list.add(self.link, 'type', FType_.Link);
  if (child_name = 'value[x]') or (child_name = 'value') Then
     list.add(self.link, 'value[x]', FValue.Link);
end;

procedure TFhirPackagedProductDefinitionPackagingProperty.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'type', 'CodeableConcept', false, TFhirCodeableConcept, FType_.Link));
  oList.add(TFHIRProperty.create(self, 'value[x]', 'CodeableConcept|Quantity|date|boolean|Attachment', false, TFhirDataType, FValue.Link));
end;

function TFhirPackagedProductDefinitionPackagingProperty.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'type') then
  begin
    Type_ := propValue as TFhirCodeableConcept;
    result := propValue;
  end
  else if (isMatchingName(propName, 'value', ['CodeableConcept', 'Quantity', 'Date', 'Boolean', 'Attachment'])) then
  begin
    Value := propValue as TFhirDataType;
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirPackagedProductDefinitionPackagingProperty.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirPackagedProductDefinitionPackagingProperty.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'type') then result := TFhirCodeableConcept.create()
  else if (isMatchingName(propName, 'value', ['CodeableConcept', 'Quantity', 'Date', 'Boolean', 'Attachment'])) then raise EFHIRException.create('Cannot make property Value')
  else result := inherited createPropertyValue(propName);
end;

function TFhirPackagedProductDefinitionPackagingProperty.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'type') then result := 'CodeableConcept'
  else if (propName = 'value[x]') then result := 'CodeableConcept|Quantity|date|boolean|Attachment'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirPackagedProductDefinitionPackagingProperty.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'type') then Type_Element := nil
  else if (isMatchingName(propName, 'value', ['CodeableConcept', 'Quantity', 'Date', 'Boolean', 'Attachment'])) then ValueElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirPackagedProductDefinitionPackagingProperty.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'type') then Type_Element := new as TFhirCodeableConcept
  else if (isMatchingName(propName, 'value', ['CodeableConcept', 'Quantity', 'Date', 'Boolean', 'Attachment'])) then ValueElement := new as TFhirDataType
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirPackagedProductDefinitionPackagingProperty.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirPackagedProductDefinitionPackagingProperty.fhirType : string;
begin
  result := 'PackagedProductDefinition.packaging.property';
end;

function TFhirPackagedProductDefinitionPackagingProperty.Link : TFhirPackagedProductDefinitionPackagingProperty;
begin
  result := TFhirPackagedProductDefinitionPackagingProperty(inherited Link);
end;

function TFhirPackagedProductDefinitionPackagingProperty.Clone : TFhirPackagedProductDefinitionPackagingProperty;
begin
  result := TFhirPackagedProductDefinitionPackagingProperty(inherited Clone);
end;

function TFhirPackagedProductDefinitionPackagingProperty.equals(other : TObject) : boolean; 
var
  o : TFhirPackagedProductDefinitionPackagingProperty;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirPackagedProductDefinitionPackagingProperty)) then
    result := false
  else
  begin
    o := TFhirPackagedProductDefinitionPackagingProperty(other);
    result := compareDeep(type_Element, o.type_Element, true) and compareDeep(valueElement, o.valueElement, true);
  end;
end;

function TFhirPackagedProductDefinitionPackagingProperty.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FType_) and isEmptyProp(FValue);
end;

procedure TFhirPackagedProductDefinitionPackagingProperty.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('type');
  fields.add('value[x]');
end;

function TFhirPackagedProductDefinitionPackagingProperty.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
end;

procedure TFhirPackagedProductDefinitionPackagingProperty.SetType_(value : TFhirCodeableConcept);
begin
  FType_.free;
  FType_ := value;
end;

procedure TFhirPackagedProductDefinitionPackagingProperty.SetValue(value : TFhirDataType);
begin
  FValue.free;
  FValue := value;
end;

{ TFhirPackagedProductDefinitionPackagingPropertyListEnumerator }

constructor TFhirPackagedProductDefinitionPackagingPropertyListEnumerator.Create(list : TFhirPackagedProductDefinitionPackagingPropertyList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirPackagedProductDefinitionPackagingPropertyListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirPackagedProductDefinitionPackagingPropertyListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirPackagedProductDefinitionPackagingPropertyListEnumerator.GetCurrent : TFhirPackagedProductDefinitionPackagingProperty;
begin
  Result := FList[FIndex];
end;

function TFhirPackagedProductDefinitionPackagingPropertyListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirPackagedProductDefinitionPackagingPropertyList }

function TFhirPackagedProductDefinitionPackagingPropertyList.AddItem(value: TFhirPackagedProductDefinitionPackagingProperty): TFhirPackagedProductDefinitionPackagingProperty;
begin
  assert(value.ClassName = 'TFhirPackagedProductDefinitionPackagingProperty', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirPackagedProductDefinitionPackagingProperty');
  add(value);
  result := value;
end;

function TFhirPackagedProductDefinitionPackagingPropertyList.Append: TFhirPackagedProductDefinitionPackagingProperty;
begin
  result := TFhirPackagedProductDefinitionPackagingProperty.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirPackagedProductDefinitionPackagingPropertyList.ClearItems;
begin
  Clear;
end;

function TFhirPackagedProductDefinitionPackagingPropertyList.GetEnumerator : TFhirPackagedProductDefinitionPackagingPropertyListEnumerator;
begin
  result := TFhirPackagedProductDefinitionPackagingPropertyListEnumerator.Create(self.link);
end;

function TFhirPackagedProductDefinitionPackagingPropertyList.Clone: TFhirPackagedProductDefinitionPackagingPropertyList;
begin
  result := TFhirPackagedProductDefinitionPackagingPropertyList(inherited Clone);
end;

function TFhirPackagedProductDefinitionPackagingPropertyList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirPackagedProductDefinitionPackagingPropertyList.GetItemN(index: Integer): TFhirPackagedProductDefinitionPackagingProperty;
begin
  result := TFhirPackagedProductDefinitionPackagingProperty(ObjectByIndex[index]);
end;

function TFhirPackagedProductDefinitionPackagingPropertyList.ItemClass: TFslObjectClass;
begin
  result := TFhirPackagedProductDefinitionPackagingProperty;
end;
function TFhirPackagedProductDefinitionPackagingPropertyList.IndexOf(value: TFhirPackagedProductDefinitionPackagingProperty): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirPackagedProductDefinitionPackagingPropertyList.Insert(index: Integer): TFhirPackagedProductDefinitionPackagingProperty;
begin
  result := TFhirPackagedProductDefinitionPackagingProperty.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirPackagedProductDefinitionPackagingPropertyList.InsertItem(index: Integer; value: TFhirPackagedProductDefinitionPackagingProperty);
begin
  assert(value is TFhirPackagedProductDefinitionPackagingProperty);
  Inherited Insert(index, value);
end;

function TFhirPackagedProductDefinitionPackagingPropertyList.Item(index: Integer): TFhirPackagedProductDefinitionPackagingProperty;
begin
  result := TFhirPackagedProductDefinitionPackagingProperty(ObjectByIndex[index]);
end;

function TFhirPackagedProductDefinitionPackagingPropertyList.Link: TFhirPackagedProductDefinitionPackagingPropertyList;
begin
  result := TFhirPackagedProductDefinitionPackagingPropertyList(inherited Link);
end;

procedure TFhirPackagedProductDefinitionPackagingPropertyList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirPackagedProductDefinitionPackagingPropertyList.SetItemByIndex(index: Integer; value: TFhirPackagedProductDefinitionPackagingProperty);
begin
  assert(value is TFhirPackagedProductDefinitionPackagingProperty);
  FhirPackagedProductDefinitionPackagingProperties[index] := value;
end;

procedure TFhirPackagedProductDefinitionPackagingPropertyList.SetItemN(index: Integer; value: TFhirPackagedProductDefinitionPackagingProperty);
begin
  assert(value is TFhirPackagedProductDefinitionPackagingProperty);
  ObjectByIndex[index] := value;
end;

{ TFhirPackagedProductDefinitionPackagingContainedItem }

constructor TFhirPackagedProductDefinitionPackagingContainedItem.Create;
begin
  inherited;
end;

destructor TFhirPackagedProductDefinitionPackagingContainedItem.Destroy;
begin
  FItem.free;
  FAmount.free;
  inherited;
end;

procedure TFhirPackagedProductDefinitionPackagingContainedItem.Assign(oSource : TFslObject);
begin
  inherited;
  item := TFhirPackagedProductDefinitionPackagingContainedItem(oSource).item.Clone;
  amount := TFhirPackagedProductDefinitionPackagingContainedItem(oSource).amount.Clone;
end;

procedure TFhirPackagedProductDefinitionPackagingContainedItem.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'item') Then
     list.add(self.link, 'item', FItem.Link);
  if (child_name = 'amount') Then
     list.add(self.link, 'amount', FAmount.Link);
end;

procedure TFhirPackagedProductDefinitionPackagingContainedItem.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'item', 'CodeableReference', false, TFhirCodeableReference, FItem.Link));
  oList.add(TFHIRProperty.create(self, 'amount', 'Quantity', false, TFhirQuantity, FAmount.Link));
end;

function TFhirPackagedProductDefinitionPackagingContainedItem.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'item') then
  begin
    Item := propValue as TFhirCodeableReference;
    result := propValue;
  end
  else if (propName = 'amount') then
  begin
    Amount := propValue as TFhirQuantity;
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirPackagedProductDefinitionPackagingContainedItem.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirPackagedProductDefinitionPackagingContainedItem.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'item') then result := TFhirCodeableReference.create()
  else if (propName = 'amount') then result := TFhirQuantity.create()
  else result := inherited createPropertyValue(propName);
end;

function TFhirPackagedProductDefinitionPackagingContainedItem.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'item') then result := 'CodeableReference'
  else if (propName = 'amount') then result := 'Quantity'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirPackagedProductDefinitionPackagingContainedItem.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'item') then ItemElement := nil
  else if (propName = 'amount') then AmountElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirPackagedProductDefinitionPackagingContainedItem.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'item') then ItemElement := new as TFhirCodeableReference
  else if (propName = 'amount') then AmountElement := new as TFhirQuantity
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirPackagedProductDefinitionPackagingContainedItem.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirPackagedProductDefinitionPackagingContainedItem.fhirType : string;
begin
  result := 'PackagedProductDefinition.packaging.containedItem';
end;

function TFhirPackagedProductDefinitionPackagingContainedItem.Link : TFhirPackagedProductDefinitionPackagingContainedItem;
begin
  result := TFhirPackagedProductDefinitionPackagingContainedItem(inherited Link);
end;

function TFhirPackagedProductDefinitionPackagingContainedItem.Clone : TFhirPackagedProductDefinitionPackagingContainedItem;
begin
  result := TFhirPackagedProductDefinitionPackagingContainedItem(inherited Clone);
end;

function TFhirPackagedProductDefinitionPackagingContainedItem.equals(other : TObject) : boolean; 
var
  o : TFhirPackagedProductDefinitionPackagingContainedItem;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirPackagedProductDefinitionPackagingContainedItem)) then
    result := false
  else
  begin
    o := TFhirPackagedProductDefinitionPackagingContainedItem(other);
    result := compareDeep(itemElement, o.itemElement, true) and compareDeep(amountElement, o.amountElement, true);
  end;
end;

function TFhirPackagedProductDefinitionPackagingContainedItem.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FItem) and isEmptyProp(FAmount);
end;

procedure TFhirPackagedProductDefinitionPackagingContainedItem.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('item');
  fields.add('amount');
end;

function TFhirPackagedProductDefinitionPackagingContainedItem.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
end;

procedure TFhirPackagedProductDefinitionPackagingContainedItem.SetItem(value : TFhirCodeableReference);
begin
  FItem.free;
  FItem := value;
end;

procedure TFhirPackagedProductDefinitionPackagingContainedItem.SetAmount(value : TFhirQuantity);
begin
  FAmount.free;
  FAmount := value;
end;

{ TFhirPackagedProductDefinitionPackagingContainedItemListEnumerator }

constructor TFhirPackagedProductDefinitionPackagingContainedItemListEnumerator.Create(list : TFhirPackagedProductDefinitionPackagingContainedItemList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirPackagedProductDefinitionPackagingContainedItemListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirPackagedProductDefinitionPackagingContainedItemListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirPackagedProductDefinitionPackagingContainedItemListEnumerator.GetCurrent : TFhirPackagedProductDefinitionPackagingContainedItem;
begin
  Result := FList[FIndex];
end;

function TFhirPackagedProductDefinitionPackagingContainedItemListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirPackagedProductDefinitionPackagingContainedItemList }

function TFhirPackagedProductDefinitionPackagingContainedItemList.AddItem(value: TFhirPackagedProductDefinitionPackagingContainedItem): TFhirPackagedProductDefinitionPackagingContainedItem;
begin
  assert(value.ClassName = 'TFhirPackagedProductDefinitionPackagingContainedItem', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirPackagedProductDefinitionPackagingContainedItem');
  add(value);
  result := value;
end;

function TFhirPackagedProductDefinitionPackagingContainedItemList.Append: TFhirPackagedProductDefinitionPackagingContainedItem;
begin
  result := TFhirPackagedProductDefinitionPackagingContainedItem.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirPackagedProductDefinitionPackagingContainedItemList.ClearItems;
begin
  Clear;
end;

function TFhirPackagedProductDefinitionPackagingContainedItemList.GetEnumerator : TFhirPackagedProductDefinitionPackagingContainedItemListEnumerator;
begin
  result := TFhirPackagedProductDefinitionPackagingContainedItemListEnumerator.Create(self.link);
end;

function TFhirPackagedProductDefinitionPackagingContainedItemList.Clone: TFhirPackagedProductDefinitionPackagingContainedItemList;
begin
  result := TFhirPackagedProductDefinitionPackagingContainedItemList(inherited Clone);
end;

function TFhirPackagedProductDefinitionPackagingContainedItemList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirPackagedProductDefinitionPackagingContainedItemList.GetItemN(index: Integer): TFhirPackagedProductDefinitionPackagingContainedItem;
begin
  result := TFhirPackagedProductDefinitionPackagingContainedItem(ObjectByIndex[index]);
end;

function TFhirPackagedProductDefinitionPackagingContainedItemList.ItemClass: TFslObjectClass;
begin
  result := TFhirPackagedProductDefinitionPackagingContainedItem;
end;
function TFhirPackagedProductDefinitionPackagingContainedItemList.IndexOf(value: TFhirPackagedProductDefinitionPackagingContainedItem): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirPackagedProductDefinitionPackagingContainedItemList.Insert(index: Integer): TFhirPackagedProductDefinitionPackagingContainedItem;
begin
  result := TFhirPackagedProductDefinitionPackagingContainedItem.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirPackagedProductDefinitionPackagingContainedItemList.InsertItem(index: Integer; value: TFhirPackagedProductDefinitionPackagingContainedItem);
begin
  assert(value is TFhirPackagedProductDefinitionPackagingContainedItem);
  Inherited Insert(index, value);
end;

function TFhirPackagedProductDefinitionPackagingContainedItemList.Item(index: Integer): TFhirPackagedProductDefinitionPackagingContainedItem;
begin
  result := TFhirPackagedProductDefinitionPackagingContainedItem(ObjectByIndex[index]);
end;

function TFhirPackagedProductDefinitionPackagingContainedItemList.Link: TFhirPackagedProductDefinitionPackagingContainedItemList;
begin
  result := TFhirPackagedProductDefinitionPackagingContainedItemList(inherited Link);
end;

procedure TFhirPackagedProductDefinitionPackagingContainedItemList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirPackagedProductDefinitionPackagingContainedItemList.SetItemByIndex(index: Integer; value: TFhirPackagedProductDefinitionPackagingContainedItem);
begin
  assert(value is TFhirPackagedProductDefinitionPackagingContainedItem);
  FhirPackagedProductDefinitionPackagingContainedItems[index] := value;
end;

procedure TFhirPackagedProductDefinitionPackagingContainedItemList.SetItemN(index: Integer; value: TFhirPackagedProductDefinitionPackagingContainedItem);
begin
  assert(value is TFhirPackagedProductDefinitionPackagingContainedItem);
  ObjectByIndex[index] := value;
end;

{ TFhirPackagedProductDefinition }

constructor TFhirPackagedProductDefinition.Create;
begin
  inherited;
end;

destructor TFhirPackagedProductDefinition.Destroy;
begin
  FIdentifierList.Free;
  FName.free;
  FType_.free;
  FPackageForList.Free;
  FStatus.free;
  FStatusDate.free;
  FContainedItemQuantityList.Free;
  FDescription.free;
  FLegalStatusOfSupplyList.Free;
  FMarketingStatusList.Free;
  FCharacteristicList.Free;
  FCopackagedIndicator.free;
  FManufacturerList.Free;
  FAttachedDocumentList.Free;
  FPackaging.free;
  inherited;
end;

procedure TFhirPackagedProductDefinition.Assign(oSource : TFslObject);
begin
  inherited;
  if (TFhirPackagedProductDefinition(oSource).FIdentifierList = nil) then
  begin
    FIdentifierList.free;
    FIdentifierList := nil;
  end
  else
  begin
    if FIdentifierList = nil then
      FIdentifierList := TFhirIdentifierList.Create;
    FIdentifierList.Assign(TFhirPackagedProductDefinition(oSource).FIdentifierList);
  end;
  nameElement := TFhirPackagedProductDefinition(oSource).nameElement.Clone;
  type_ := TFhirPackagedProductDefinition(oSource).type_.Clone;
  if (TFhirPackagedProductDefinition(oSource).FPackageForList = nil) then
  begin
    FPackageForList.free;
    FPackageForList := nil;
  end
  else
  begin
    if FPackageForList = nil then
      FPackageForList := TFhirReferenceList.Create;
    FPackageForList.Assign(TFhirPackagedProductDefinition(oSource).FPackageForList);
  end;
  status := TFhirPackagedProductDefinition(oSource).status.Clone;
  statusDateElement := TFhirPackagedProductDefinition(oSource).statusDateElement.Clone;
  if (TFhirPackagedProductDefinition(oSource).FContainedItemQuantityList = nil) then
  begin
    FContainedItemQuantityList.free;
    FContainedItemQuantityList := nil;
  end
  else
  begin
    if FContainedItemQuantityList = nil then
      FContainedItemQuantityList := TFhirQuantityList.Create;
    FContainedItemQuantityList.Assign(TFhirPackagedProductDefinition(oSource).FContainedItemQuantityList);
  end;
  descriptionElement := TFhirPackagedProductDefinition(oSource).descriptionElement.Clone;
  if (TFhirPackagedProductDefinition(oSource).FLegalStatusOfSupplyList = nil) then
  begin
    FLegalStatusOfSupplyList.free;
    FLegalStatusOfSupplyList := nil;
  end
  else
  begin
    if FLegalStatusOfSupplyList = nil then
      FLegalStatusOfSupplyList := TFhirPackagedProductDefinitionLegalStatusOfSupplyList.Create;
    FLegalStatusOfSupplyList.Assign(TFhirPackagedProductDefinition(oSource).FLegalStatusOfSupplyList);
  end;
  if (TFhirPackagedProductDefinition(oSource).FMarketingStatusList = nil) then
  begin
    FMarketingStatusList.free;
    FMarketingStatusList := nil;
  end
  else
  begin
    if FMarketingStatusList = nil then
      FMarketingStatusList := TFhirMarketingStatusList.Create;
    FMarketingStatusList.Assign(TFhirPackagedProductDefinition(oSource).FMarketingStatusList);
  end;
  if (TFhirPackagedProductDefinition(oSource).FCharacteristicList = nil) then
  begin
    FCharacteristicList.free;
    FCharacteristicList := nil;
  end
  else
  begin
    if FCharacteristicList = nil then
      FCharacteristicList := TFhirCodeableConceptList.Create;
    FCharacteristicList.Assign(TFhirPackagedProductDefinition(oSource).FCharacteristicList);
  end;
  copackagedIndicatorElement := TFhirPackagedProductDefinition(oSource).copackagedIndicatorElement.Clone;
  if (TFhirPackagedProductDefinition(oSource).FManufacturerList = nil) then
  begin
    FManufacturerList.free;
    FManufacturerList := nil;
  end
  else
  begin
    if FManufacturerList = nil then
      FManufacturerList := TFhirReferenceList.Create;
    FManufacturerList.Assign(TFhirPackagedProductDefinition(oSource).FManufacturerList);
  end;
  if (TFhirPackagedProductDefinition(oSource).FAttachedDocumentList = nil) then
  begin
    FAttachedDocumentList.free;
    FAttachedDocumentList := nil;
  end
  else
  begin
    if FAttachedDocumentList = nil then
      FAttachedDocumentList := TFhirReferenceList.Create;
    FAttachedDocumentList.Assign(TFhirPackagedProductDefinition(oSource).FAttachedDocumentList);
  end;
  packaging := TFhirPackagedProductDefinition(oSource).packaging.Clone;
end;

function TFhirPackagedProductDefinition.GetResourceType : TFhirResourceType;
begin
  result := frtPackagedProductDefinition;
end;

procedure TFhirPackagedProductDefinition.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'identifier') Then
    list.addAll(self, 'identifier', FIdentifierList);
  if (child_name = 'name') Then
     list.add(self.link, 'name', FName.Link);
  if (child_name = 'type') Then
     list.add(self.link, 'type', FType_.Link);
  if (child_name = 'packageFor') Then
    list.addAll(self, 'packageFor', FPackageForList);
  if (child_name = 'status') Then
     list.add(self.link, 'status', FStatus.Link);
  if (child_name = 'statusDate') Then
     list.add(self.link, 'statusDate', FStatusDate.Link);
  if (child_name = 'containedItemQuantity') Then
    list.addAll(self, 'containedItemQuantity', FContainedItemQuantityList);
  if (child_name = 'description') Then
     list.add(self.link, 'description', FDescription.Link);
  if (child_name = 'legalStatusOfSupply') Then
    list.addAll(self, 'legalStatusOfSupply', FLegalStatusOfSupplyList);
  if (child_name = 'marketingStatus') Then
    list.addAll(self, 'marketingStatus', FMarketingStatusList);
  if (child_name = 'characteristic') Then
    list.addAll(self, 'characteristic', FCharacteristicList);
  if (child_name = 'copackagedIndicator') Then
     list.add(self.link, 'copackagedIndicator', FCopackagedIndicator.Link);
  if (child_name = 'manufacturer') Then
    list.addAll(self, 'manufacturer', FManufacturerList);
  if (child_name = 'attachedDocument') Then
    list.addAll(self, 'attachedDocument', FAttachedDocumentList);
  if (child_name = 'packaging') Then
     list.add(self.link, 'packaging', FPackaging.Link);
end;

procedure TFhirPackagedProductDefinition.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'identifier', 'Identifier', true, TFhirIdentifier, FIdentifierList.Link));
  oList.add(TFHIRProperty.create(self, 'name', 'string', false, TFhirString, FName.Link));
  oList.add(TFHIRProperty.create(self, 'type', 'CodeableConcept', false, TFhirCodeableConcept, FType_.Link));
  oList.add(TFHIRProperty.create(self, 'packageFor', 'Reference', true, TFhirReference, FPackageForList.Link));
  oList.add(TFHIRProperty.create(self, 'status', 'CodeableConcept', false, TFhirCodeableConcept, FStatus.Link));
  oList.add(TFHIRProperty.create(self, 'statusDate', 'dateTime', false, TFhirDateTime, FStatusDate.Link));
  oList.add(TFHIRProperty.create(self, 'containedItemQuantity', 'Quantity', true, TFhirQuantity, FContainedItemQuantityList.Link));
  oList.add(TFHIRProperty.create(self, 'description', 'markdown', false, TFhirMarkdown, FDescription.Link));
  oList.add(TFHIRProperty.create(self, 'legalStatusOfSupply', 'BackboneElement', true, TFhirPackagedProductDefinitionLegalStatusOfSupply, FLegalStatusOfSupplyList.Link));
  oList.add(TFHIRProperty.create(self, 'marketingStatus', 'MarketingStatus', true, TFhirMarketingStatus, FMarketingStatusList.Link));
  oList.add(TFHIRProperty.create(self, 'characteristic', 'CodeableConcept', true, TFhirCodeableConcept, FCharacteristicList.Link));
  oList.add(TFHIRProperty.create(self, 'copackagedIndicator', 'boolean', false, TFhirBoolean, FCopackagedIndicator.Link));
  oList.add(TFHIRProperty.create(self, 'manufacturer', 'Reference', true, TFhirReference, FManufacturerList.Link));
  oList.add(TFHIRProperty.create(self, 'attachedDocument', 'Reference', true, TFhirReference, FAttachedDocumentList.Link));
  oList.add(TFHIRProperty.create(self, 'packaging', 'BackboneElement', false, TFhirPackagedProductDefinitionPackaging, FPackaging.Link));
end;

function TFhirPackagedProductDefinition.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'identifier') then
  begin
    IdentifierList.add(propValue as TFhirIdentifier);
    result := propValue;
  end
  else if (propName = 'name') then
  begin
    NameElement := asString(propValue);
    result := propValue;
  end
  else if (propName = 'type') then
  begin
    Type_ := propValue as TFhirCodeableConcept;
    result := propValue;
  end
  else if (propName = 'packageFor') then
  begin
    PackageForList.add(propValue as TFhirReference);
    result := propValue;
  end
  else if (propName = 'status') then
  begin
    Status := propValue as TFhirCodeableConcept;
    result := propValue;
  end
  else if (propName = 'statusDate') then
  begin
    StatusDateElement := asDateTime(propValue);
    result := propValue;
  end
  else if (propName = 'containedItemQuantity') then
  begin
    ContainedItemQuantityList.add(propValue as TFhirQuantity);
    result := propValue;
  end
  else if (propName = 'description') then
  begin
    DescriptionElement := asMarkdown(propValue);
    result := propValue;
  end
  else if (propName = 'legalStatusOfSupply') then
  begin
    LegalStatusOfSupplyList.add(propValue as TFhirPackagedProductDefinitionLegalStatusOfSupply);
    result := propValue;
  end
  else if (propName = 'marketingStatus') then
  begin
    MarketingStatusList.add(propValue as TFhirMarketingStatus);
    result := propValue;
  end
  else if (propName = 'characteristic') then
  begin
    CharacteristicList.add(propValue as TFhirCodeableConcept);
    result := propValue;
  end
  else if (propName = 'copackagedIndicator') then
  begin
    CopackagedIndicatorElement := asBoolean(propValue);
    result := propValue;
  end
  else if (propName = 'manufacturer') then
  begin
    ManufacturerList.add(propValue as TFhirReference);
    result := propValue;
  end
  else if (propName = 'attachedDocument') then
  begin
    AttachedDocumentList.add(propValue as TFhirReference);
    result := propValue;
  end
  else if (propName = 'packaging') then
  begin
    Packaging := propValue as TFhirPackagedProductDefinitionPackaging;
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirPackagedProductDefinition.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'identifier') then IdentifierList.insertItem(index, propValue as TFhirIdentifier)
  else if (propName = 'packageFor') then PackageForList.insertItem(index, propValue as TFhirReference)
  else if (propName = 'containedItemQuantity') then ContainedItemQuantityList.insertItem(index, propValue as TFhirQuantity)
  else if (propName = 'legalStatusOfSupply') then LegalStatusOfSupplyList.insertItem(index, propValue as TFhirPackagedProductDefinitionLegalStatusOfSupply)
  else if (propName = 'marketingStatus') then MarketingStatusList.insertItem(index, propValue as TFhirMarketingStatus)
  else if (propName = 'characteristic') then CharacteristicList.insertItem(index, propValue as TFhirCodeableConcept)
  else if (propName = 'manufacturer') then ManufacturerList.insertItem(index, propValue as TFhirReference)
  else if (propName = 'attachedDocument') then AttachedDocumentList.insertItem(index, propValue as TFhirReference)
  else inherited;
end;

function TFhirPackagedProductDefinition.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'identifier') then result := IdentifierList.new()
  else if (propName = 'name') then result := TFhirString.create()
  else if (propName = 'type') then result := TFhirCodeableConcept.create()
  else if (propName = 'packageFor') then result := PackageForList.new()
  else if (propName = 'status') then result := TFhirCodeableConcept.create()
  else if (propName = 'statusDate') then result := TFhirDateTime.create()
  else if (propName = 'containedItemQuantity') then result := ContainedItemQuantityList.new()
  else if (propName = 'description') then result := TFhirMarkdown.create()
  else if (propName = 'legalStatusOfSupply') then result := LegalStatusOfSupplyList.new()
  else if (propName = 'marketingStatus') then result := MarketingStatusList.new()
  else if (propName = 'characteristic') then result := CharacteristicList.new()
  else if (propName = 'copackagedIndicator') then result := TFhirBoolean.create()
  else if (propName = 'manufacturer') then result := ManufacturerList.new()
  else if (propName = 'attachedDocument') then result := AttachedDocumentList.new()
  else if (propName = 'packaging') then result := TFhirPackagedProductDefinitionPackaging.create()
  else result := inherited createPropertyValue(propName);
end;

function TFhirPackagedProductDefinition.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'identifier') then result := 'Identifier'
  else if (propName = 'name') then result := 'string'
  else if (propName = 'type') then result := 'CodeableConcept'
  else if (propName = 'packageFor') then result := 'Reference'
  else if (propName = 'status') then result := 'CodeableConcept'
  else if (propName = 'statusDate') then result := 'dateTime'
  else if (propName = 'containedItemQuantity') then result := 'Quantity'
  else if (propName = 'description') then result := 'markdown'
  else if (propName = 'legalStatusOfSupply') then result := 'BackboneElement'
  else if (propName = 'marketingStatus') then result := 'MarketingStatus'
  else if (propName = 'characteristic') then result := 'CodeableConcept'
  else if (propName = 'copackagedIndicator') then result := 'boolean'
  else if (propName = 'manufacturer') then result := 'Reference'
  else if (propName = 'attachedDocument') then result := 'Reference'
  else if (propName = 'packaging') then result := 'BackboneElement'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirPackagedProductDefinition.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'identifier') then deletePropertyValue('identifier', IdentifierList, value)
  else if (propName = 'name') then NameElement := nil
  else if (propName = 'type') then Type_Element := nil
  else if (propName = 'packageFor') then deletePropertyValue('packageFor', PackageForList, value)
  else if (propName = 'status') then StatusElement := nil
  else if (propName = 'statusDate') then StatusDateElement := nil
  else if (propName = 'containedItemQuantity') then deletePropertyValue('containedItemQuantity', ContainedItemQuantityList, value)
  else if (propName = 'description') then DescriptionElement := nil
  else if (propName = 'legalStatusOfSupply') then deletePropertyValue('legalStatusOfSupply', LegalStatusOfSupplyList, value)
  else if (propName = 'marketingStatus') then deletePropertyValue('marketingStatus', MarketingStatusList, value)
  else if (propName = 'characteristic') then deletePropertyValue('characteristic', CharacteristicList, value)
  else if (propName = 'copackagedIndicator') then CopackagedIndicatorElement := nil
  else if (propName = 'manufacturer') then deletePropertyValue('manufacturer', ManufacturerList, value)
  else if (propName = 'attachedDocument') then deletePropertyValue('attachedDocument', AttachedDocumentList, value)
  else if (propName = 'packaging') then PackagingElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirPackagedProductDefinition.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'identifier') then replacePropertyValue('identifier', IdentifierList, existing, new)
  else if (propName = 'name') then NameElement := asString(new)
  else if (propName = 'type') then Type_Element := new as TFhirCodeableConcept
  else if (propName = 'packageFor') then replacePropertyValue('packageFor', PackageForList, existing, new)
  else if (propName = 'status') then StatusElement := new as TFhirCodeableConcept
  else if (propName = 'statusDate') then StatusDateElement := asDateTime(new)
  else if (propName = 'containedItemQuantity') then replacePropertyValue('containedItemQuantity', ContainedItemQuantityList, existing, new)
  else if (propName = 'description') then DescriptionElement := asMarkdown(new)
  else if (propName = 'legalStatusOfSupply') then replacePropertyValue('legalStatusOfSupply', LegalStatusOfSupplyList, existing, new)
  else if (propName = 'marketingStatus') then replacePropertyValue('marketingStatus', MarketingStatusList, existing, new)
  else if (propName = 'characteristic') then replacePropertyValue('characteristic', CharacteristicList, existing, new)
  else if (propName = 'copackagedIndicator') then CopackagedIndicatorElement := asBoolean(new)
  else if (propName = 'manufacturer') then replacePropertyValue('manufacturer', ManufacturerList, existing, new)
  else if (propName = 'attachedDocument') then replacePropertyValue('attachedDocument', AttachedDocumentList, existing, new)
  else if (propName = 'packaging') then PackagingElement := new as TFhirPackagedProductDefinitionPackaging
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirPackagedProductDefinition.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'identifier') then IdentifierList.move(source, destination)
  else if (propName = 'packageFor') then PackageForList.move(source, destination)
  else if (propName = 'containedItemQuantity') then ContainedItemQuantityList.move(source, destination)
  else if (propName = 'legalStatusOfSupply') then LegalStatusOfSupplyList.move(source, destination)
  else if (propName = 'marketingStatus') then MarketingStatusList.move(source, destination)
  else if (propName = 'characteristic') then CharacteristicList.move(source, destination)
  else if (propName = 'manufacturer') then ManufacturerList.move(source, destination)
  else if (propName = 'attachedDocument') then AttachedDocumentList.move(source, destination)
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirPackagedProductDefinition.fhirType : string;
begin
  result := 'PackagedProductDefinition';
end;

function TFhirPackagedProductDefinition.Link : TFhirPackagedProductDefinition;
begin
  result := TFhirPackagedProductDefinition(inherited Link);
end;

function TFhirPackagedProductDefinition.Clone : TFhirPackagedProductDefinition;
begin
  result := TFhirPackagedProductDefinition(inherited Clone);
end;

function TFhirPackagedProductDefinition.equals(other : TObject) : boolean; 
var
  o : TFhirPackagedProductDefinition;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirPackagedProductDefinition)) then
    result := false
  else
  begin
    o := TFhirPackagedProductDefinition(other);
    result := compareDeep(identifierList, o.identifierList, true) and compareDeep(nameElement, o.nameElement, true) and 
      compareDeep(type_Element, o.type_Element, true) and compareDeep(packageForList, o.packageForList, true) and 
      compareDeep(statusElement, o.statusElement, true) and compareDeep(statusDateElement, o.statusDateElement, true) and 
      compareDeep(containedItemQuantityList, o.containedItemQuantityList, true) and 
      compareDeep(descriptionElement, o.descriptionElement, true) and compareDeep(legalStatusOfSupplyList, o.legalStatusOfSupplyList, true) and 
      compareDeep(marketingStatusList, o.marketingStatusList, true) and compareDeep(characteristicList, o.characteristicList, true) and 
      compareDeep(copackagedIndicatorElement, o.copackagedIndicatorElement, true) and 
      compareDeep(manufacturerList, o.manufacturerList, true) and compareDeep(attachedDocumentList, o.attachedDocumentList, true) and 
      compareDeep(packagingElement, o.packagingElement, true);
  end;
end;

function TFhirPackagedProductDefinition.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FidentifierList) and isEmptyProp(FName) and isEmptyProp(FType_) and isEmptyProp(FpackageForList) and isEmptyProp(FStatus) and isEmptyProp(FStatusDate) and isEmptyProp(FcontainedItemQuantityList) and isEmptyProp(FDescription) and isEmptyProp(FlegalStatusOfSupplyList) and isEmptyProp(FmarketingStatusList) and isEmptyProp(FcharacteristicList) and isEmptyProp(FCopackagedIndicator) and isEmptyProp(FmanufacturerList) and isEmptyProp(FattachedDocumentList) and isEmptyProp(FPackaging);
end;

procedure TFhirPackagedProductDefinition.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('identifier');
  fields.add('name');
  fields.add('type');
  fields.add('packageFor');
  fields.add('status');
  fields.add('statusDate');
  fields.add('containedItemQuantity');
  fields.add('description');
  fields.add('legalStatusOfSupply');
  fields.add('marketingStatus');
  fields.add('characteristic');
  fields.add('copackagedIndicator');
  fields.add('manufacturer');
  fields.add('attachedDocument');
  fields.add('packaging');
end;

function TFhirPackagedProductDefinition.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
  inc(result, FIdentifierList.sizeInBytes(magic));
  inc(result, FPackageForList.sizeInBytes(magic));
  inc(result, FContainedItemQuantityList.sizeInBytes(magic));
  inc(result, FLegalStatusOfSupplyList.sizeInBytes(magic));
  inc(result, FMarketingStatusList.sizeInBytes(magic));
  inc(result, FCharacteristicList.sizeInBytes(magic));
  inc(result, FManufacturerList.sizeInBytes(magic));
  inc(result, FAttachedDocumentList.sizeInBytes(magic));
end;

function TFhirPackagedProductDefinition.GetIdentifierList : TFhirIdentifierList;
begin
  if FIdentifierList = nil then
    FIdentifierList := TFhirIdentifierList.Create;
  result := FIdentifierList;
end;

function TFhirPackagedProductDefinition.GetHasIdentifierList : boolean;
begin
  result := (FIdentifierList <> nil) and (FIdentifierList.count > 0);
end;

procedure TFhirPackagedProductDefinition.SetName(value : TFhirString);
begin
  FName.free;
  FName := value;
end;

function TFhirPackagedProductDefinition.GetNameST : String;
begin
  if FName = nil then
    result := ''
  else
    result := FName.value;
end;

procedure TFhirPackagedProductDefinition.SetNameST(value : String);
begin
  if value <> '' then
  begin
    if FName = nil then
      FName := TFhirString.create;
    FName.value := value
  end
  else if FName <> nil then
    FName.value := '';
end;

procedure TFhirPackagedProductDefinition.SetType_(value : TFhirCodeableConcept);
begin
  FType_.free;
  FType_ := value;
end;

function TFhirPackagedProductDefinition.GetPackageForList : TFhirReferenceList;
begin
  if FPackageForList = nil then
    FPackageForList := TFhirReferenceList.Create;
  result := FPackageForList;
end;

function TFhirPackagedProductDefinition.GetHasPackageForList : boolean;
begin
  result := (FPackageForList <> nil) and (FPackageForList.count > 0);
end;

procedure TFhirPackagedProductDefinition.SetStatus(value : TFhirCodeableConcept);
begin
  FStatus.free;
  FStatus := value;
end;

procedure TFhirPackagedProductDefinition.SetStatusDate(value : TFhirDateTime);
begin
  FStatusDate.free;
  FStatusDate := value;
end;

function TFhirPackagedProductDefinition.GetStatusDateST : TFslDateTime;
begin
  if FStatusDate = nil then
    result := TFslDateTime.makeNull
  else
    result := FStatusDate.value;
end;

procedure TFhirPackagedProductDefinition.SetStatusDateST(value : TFslDateTime);
begin
  if FStatusDate = nil then
    FStatusDate := TFhirDateTime.create;
  FStatusDate.value := value
end;

function TFhirPackagedProductDefinition.GetContainedItemQuantityList : TFhirQuantityList;
begin
  if FContainedItemQuantityList = nil then
    FContainedItemQuantityList := TFhirQuantityList.Create;
  result := FContainedItemQuantityList;
end;

function TFhirPackagedProductDefinition.GetHasContainedItemQuantityList : boolean;
begin
  result := (FContainedItemQuantityList <> nil) and (FContainedItemQuantityList.count > 0);
end;

procedure TFhirPackagedProductDefinition.SetDescription(value : TFhirMarkdown);
begin
  FDescription.free;
  FDescription := value;
end;

function TFhirPackagedProductDefinition.GetDescriptionST : String;
begin
  if FDescription = nil then
    result := ''
  else
    result := FDescription.value;
end;

procedure TFhirPackagedProductDefinition.SetDescriptionST(value : String);
begin
  if value <> '' then
  begin
    if FDescription = nil then
      FDescription := TFhirMarkdown.create;
    FDescription.value := value
  end
  else if FDescription <> nil then
    FDescription.value := '';
end;

function TFhirPackagedProductDefinition.GetLegalStatusOfSupplyList : TFhirPackagedProductDefinitionLegalStatusOfSupplyList;
begin
  if FLegalStatusOfSupplyList = nil then
    FLegalStatusOfSupplyList := TFhirPackagedProductDefinitionLegalStatusOfSupplyList.Create;
  result := FLegalStatusOfSupplyList;
end;

function TFhirPackagedProductDefinition.GetHasLegalStatusOfSupplyList : boolean;
begin
  result := (FLegalStatusOfSupplyList <> nil) and (FLegalStatusOfSupplyList.count > 0);
end;

function TFhirPackagedProductDefinition.GetMarketingStatusList : TFhirMarketingStatusList;
begin
  if FMarketingStatusList = nil then
    FMarketingStatusList := TFhirMarketingStatusList.Create;
  result := FMarketingStatusList;
end;

function TFhirPackagedProductDefinition.GetHasMarketingStatusList : boolean;
begin
  result := (FMarketingStatusList <> nil) and (FMarketingStatusList.count > 0);
end;

function TFhirPackagedProductDefinition.GetCharacteristicList : TFhirCodeableConceptList;
begin
  if FCharacteristicList = nil then
    FCharacteristicList := TFhirCodeableConceptList.Create;
  result := FCharacteristicList;
end;

function TFhirPackagedProductDefinition.GetHasCharacteristicList : boolean;
begin
  result := (FCharacteristicList <> nil) and (FCharacteristicList.count > 0);
end;

procedure TFhirPackagedProductDefinition.SetCopackagedIndicator(value : TFhirBoolean);
begin
  FCopackagedIndicator.free;
  FCopackagedIndicator := value;
end;

function TFhirPackagedProductDefinition.GetCopackagedIndicatorST : Boolean;
begin
  if FCopackagedIndicator = nil then
    result := false
  else
    result := FCopackagedIndicator.value;
end;

procedure TFhirPackagedProductDefinition.SetCopackagedIndicatorST(value : Boolean);
begin
  if FCopackagedIndicator = nil then
    FCopackagedIndicator := TFhirBoolean.create;
  FCopackagedIndicator.value := value
end;

function TFhirPackagedProductDefinition.GetManufacturerList : TFhirReferenceList;
begin
  if FManufacturerList = nil then
    FManufacturerList := TFhirReferenceList.Create;
  result := FManufacturerList;
end;

function TFhirPackagedProductDefinition.GetHasManufacturerList : boolean;
begin
  result := (FManufacturerList <> nil) and (FManufacturerList.count > 0);
end;

function TFhirPackagedProductDefinition.GetAttachedDocumentList : TFhirReferenceList;
begin
  if FAttachedDocumentList = nil then
    FAttachedDocumentList := TFhirReferenceList.Create;
  result := FAttachedDocumentList;
end;

function TFhirPackagedProductDefinition.GetHasAttachedDocumentList : boolean;
begin
  result := (FAttachedDocumentList <> nil) and (FAttachedDocumentList.count > 0);
end;

procedure TFhirPackagedProductDefinition.SetPackaging(value : TFhirPackagedProductDefinitionPackaging);
begin
  FPackaging.free;
  FPackaging := value;
end;

{ TFhirPackagedProductDefinitionListEnumerator }

constructor TFhirPackagedProductDefinitionListEnumerator.Create(list : TFhirPackagedProductDefinitionList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirPackagedProductDefinitionListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirPackagedProductDefinitionListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirPackagedProductDefinitionListEnumerator.GetCurrent : TFhirPackagedProductDefinition;
begin
  Result := FList[FIndex];
end;

function TFhirPackagedProductDefinitionListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirPackagedProductDefinitionList }

function TFhirPackagedProductDefinitionList.AddItem(value: TFhirPackagedProductDefinition): TFhirPackagedProductDefinition;
begin
  assert(value.ClassName = 'TFhirPackagedProductDefinition', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirPackagedProductDefinition');
  add(value);
  result := value;
end;

function TFhirPackagedProductDefinitionList.Append: TFhirPackagedProductDefinition;
begin
  result := TFhirPackagedProductDefinition.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirPackagedProductDefinitionList.ClearItems;
begin
  Clear;
end;

function TFhirPackagedProductDefinitionList.GetEnumerator : TFhirPackagedProductDefinitionListEnumerator;
begin
  result := TFhirPackagedProductDefinitionListEnumerator.Create(self.link);
end;

function TFhirPackagedProductDefinitionList.Clone: TFhirPackagedProductDefinitionList;
begin
  result := TFhirPackagedProductDefinitionList(inherited Clone);
end;

function TFhirPackagedProductDefinitionList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirPackagedProductDefinitionList.GetItemN(index: Integer): TFhirPackagedProductDefinition;
begin
  result := TFhirPackagedProductDefinition(ObjectByIndex[index]);
end;

function TFhirPackagedProductDefinitionList.ItemClass: TFslObjectClass;
begin
  result := TFhirPackagedProductDefinition;
end;
function TFhirPackagedProductDefinitionList.IndexOf(value: TFhirPackagedProductDefinition): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirPackagedProductDefinitionList.Insert(index: Integer): TFhirPackagedProductDefinition;
begin
  result := TFhirPackagedProductDefinition.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirPackagedProductDefinitionList.InsertItem(index: Integer; value: TFhirPackagedProductDefinition);
begin
  assert(value is TFhirPackagedProductDefinition);
  Inherited Insert(index, value);
end;

function TFhirPackagedProductDefinitionList.Item(index: Integer): TFhirPackagedProductDefinition;
begin
  result := TFhirPackagedProductDefinition(ObjectByIndex[index]);
end;

function TFhirPackagedProductDefinitionList.Link: TFhirPackagedProductDefinitionList;
begin
  result := TFhirPackagedProductDefinitionList(inherited Link);
end;

procedure TFhirPackagedProductDefinitionList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirPackagedProductDefinitionList.SetItemByIndex(index: Integer; value: TFhirPackagedProductDefinition);
begin
  assert(value is TFhirPackagedProductDefinition);
  FhirPackagedProductDefinitions[index] := value;
end;

procedure TFhirPackagedProductDefinitionList.SetItemN(index: Integer; value: TFhirPackagedProductDefinition);
begin
  assert(value is TFhirPackagedProductDefinition);
  ObjectByIndex[index] := value;
end;

{$ENDIF FHIR_PACKAGEDPRODUCTDEFINITION}
{$IFDEF FHIR_REGULATEDAUTHORIZATION}
{ TFhirRegulatedAuthorizationCase }

constructor TFhirRegulatedAuthorizationCase.Create;
begin
  inherited;
end;

destructor TFhirRegulatedAuthorizationCase.Destroy;
begin
  FIdentifier.free;
  FType_.free;
  FStatus.free;
  FDate.free;
  FApplicationList.Free;
  inherited;
end;

procedure TFhirRegulatedAuthorizationCase.Assign(oSource : TFslObject);
begin
  inherited;
  identifier := TFhirRegulatedAuthorizationCase(oSource).identifier.Clone;
  type_ := TFhirRegulatedAuthorizationCase(oSource).type_.Clone;
  status := TFhirRegulatedAuthorizationCase(oSource).status.Clone;
  date := TFhirRegulatedAuthorizationCase(oSource).date.Clone;
  if (TFhirRegulatedAuthorizationCase(oSource).FApplicationList = nil) then
  begin
    FApplicationList.free;
    FApplicationList := nil;
  end
  else
  begin
    if FApplicationList = nil then
      FApplicationList := TFhirRegulatedAuthorizationCaseList.Create;
    FApplicationList.Assign(TFhirRegulatedAuthorizationCase(oSource).FApplicationList);
  end;
end;

procedure TFhirRegulatedAuthorizationCase.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'identifier') Then
     list.add(self.link, 'identifier', FIdentifier.Link);
  if (child_name = 'type') Then
     list.add(self.link, 'type', FType_.Link);
  if (child_name = 'status') Then
     list.add(self.link, 'status', FStatus.Link);
  if (child_name = 'date[x]') or (child_name = 'date') Then
     list.add(self.link, 'date[x]', FDate.Link);
  if (child_name = 'application') Then
    list.addAll(self, 'application', FApplicationList);
end;

procedure TFhirRegulatedAuthorizationCase.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'identifier', 'Identifier', false, TFhirIdentifier, FIdentifier.Link));
  oList.add(TFHIRProperty.create(self, 'type', 'CodeableConcept', false, TFhirCodeableConcept, FType_.Link));
  oList.add(TFHIRProperty.create(self, 'status', 'CodeableConcept', false, TFhirCodeableConcept, FStatus.Link));
  oList.add(TFHIRProperty.create(self, 'date[x]', 'Period|dateTime', false, TFhirDataType, FDate.Link));
  oList.add(TFHIRProperty.create(self, 'application', '', true, TFhirRegulatedAuthorizationCase, FApplicationList.Link));
end;

function TFhirRegulatedAuthorizationCase.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'identifier') then
  begin
    Identifier := propValue as TFhirIdentifier;
    result := propValue;
  end
  else if (propName = 'type') then
  begin
    Type_ := propValue as TFhirCodeableConcept;
    result := propValue;
  end
  else if (propName = 'status') then
  begin
    Status := propValue as TFhirCodeableConcept;
    result := propValue;
  end
  else if (isMatchingName(propName, 'date', ['Period', 'DateTime'])) then
  begin
    Date := propValue as TFhirDataType;
    result := propValue;
  end
  else if (propName = 'application') then
  begin
    ApplicationList.add(propValue as TFhirRegulatedAuthorizationCase);
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirRegulatedAuthorizationCase.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'application') then ApplicationList.insertItem(index, propValue as TFhirRegulatedAuthorizationCase)
  else inherited;
end;

function TFhirRegulatedAuthorizationCase.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'identifier') then result := TFhirIdentifier.create()
  else if (propName = 'type') then result := TFhirCodeableConcept.create()
  else if (propName = 'status') then result := TFhirCodeableConcept.create()
  else if (isMatchingName(propName, 'date', ['Period', 'DateTime'])) then raise EFHIRException.create('Cannot make property Date')
  else if (propName = 'application') then result := ApplicationList.new()
  else result := inherited createPropertyValue(propName);
end;

function TFhirRegulatedAuthorizationCase.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'identifier') then result := 'Identifier'
  else if (propName = 'type') then result := 'CodeableConcept'
  else if (propName = 'status') then result := 'CodeableConcept'
  else if (propName = 'date[x]') then result := 'Period|dateTime'
  else if (propName = 'application') then result := ''
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirRegulatedAuthorizationCase.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'identifier') then IdentifierElement := nil
  else if (propName = 'type') then Type_Element := nil
  else if (propName = 'status') then StatusElement := nil
  else if (isMatchingName(propName, 'date', ['Period', 'DateTime'])) then DateElement := nil
  else if (propName = 'application') then deletePropertyValue('application', ApplicationList, value)
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirRegulatedAuthorizationCase.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'identifier') then IdentifierElement := new as TFhirIdentifier
  else if (propName = 'type') then Type_Element := new as TFhirCodeableConcept
  else if (propName = 'status') then StatusElement := new as TFhirCodeableConcept
  else if (isMatchingName(propName, 'date', ['Period', 'DateTime'])) then DateElement := new as TFhirDataType
  else if (propName = 'application') then replacePropertyValue('application', ApplicationList, existing, new)
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirRegulatedAuthorizationCase.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'application') then ApplicationList.move(source, destination)
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirRegulatedAuthorizationCase.fhirType : string;
begin
  result := 'RegulatedAuthorization.case';
end;

function TFhirRegulatedAuthorizationCase.Link : TFhirRegulatedAuthorizationCase;
begin
  result := TFhirRegulatedAuthorizationCase(inherited Link);
end;

function TFhirRegulatedAuthorizationCase.Clone : TFhirRegulatedAuthorizationCase;
begin
  result := TFhirRegulatedAuthorizationCase(inherited Clone);
end;

function TFhirRegulatedAuthorizationCase.equals(other : TObject) : boolean; 
var
  o : TFhirRegulatedAuthorizationCase;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirRegulatedAuthorizationCase)) then
    result := false
  else
  begin
    o := TFhirRegulatedAuthorizationCase(other);
    result := compareDeep(identifierElement, o.identifierElement, true) and compareDeep(type_Element, o.type_Element, true) and 
      compareDeep(statusElement, o.statusElement, true) and compareDeep(dateElement, o.dateElement, true) and 
      compareDeep(applicationList, o.applicationList, true);
  end;
end;

function TFhirRegulatedAuthorizationCase.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FIdentifier) and isEmptyProp(FType_) and isEmptyProp(FStatus) and isEmptyProp(FDate) and isEmptyProp(FapplicationList);
end;

procedure TFhirRegulatedAuthorizationCase.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('identifier');
  fields.add('type');
  fields.add('status');
  fields.add('date[x]');
  fields.add('application');
end;

function TFhirRegulatedAuthorizationCase.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
  inc(result, FApplicationList.sizeInBytes(magic));
end;

procedure TFhirRegulatedAuthorizationCase.SetIdentifier(value : TFhirIdentifier);
begin
  FIdentifier.free;
  FIdentifier := value;
end;

procedure TFhirRegulatedAuthorizationCase.SetType_(value : TFhirCodeableConcept);
begin
  FType_.free;
  FType_ := value;
end;

procedure TFhirRegulatedAuthorizationCase.SetStatus(value : TFhirCodeableConcept);
begin
  FStatus.free;
  FStatus := value;
end;

procedure TFhirRegulatedAuthorizationCase.SetDate(value : TFhirDataType);
begin
  FDate.free;
  FDate := value;
end;

function TFhirRegulatedAuthorizationCase.GetApplicationList : TFhirRegulatedAuthorizationCaseList;
begin
  if FApplicationList = nil then
    FApplicationList := TFhirRegulatedAuthorizationCaseList.Create;
  result := FApplicationList;
end;

function TFhirRegulatedAuthorizationCase.GetHasApplicationList : boolean;
begin
  result := (FApplicationList <> nil) and (FApplicationList.count > 0);
end;

{ TFhirRegulatedAuthorizationCaseListEnumerator }

constructor TFhirRegulatedAuthorizationCaseListEnumerator.Create(list : TFhirRegulatedAuthorizationCaseList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirRegulatedAuthorizationCaseListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirRegulatedAuthorizationCaseListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirRegulatedAuthorizationCaseListEnumerator.GetCurrent : TFhirRegulatedAuthorizationCase;
begin
  Result := FList[FIndex];
end;

function TFhirRegulatedAuthorizationCaseListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirRegulatedAuthorizationCaseList }

function TFhirRegulatedAuthorizationCaseList.AddItem(value: TFhirRegulatedAuthorizationCase): TFhirRegulatedAuthorizationCase;
begin
  assert(value.ClassName = 'TFhirRegulatedAuthorizationCase', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirRegulatedAuthorizationCase');
  add(value);
  result := value;
end;

function TFhirRegulatedAuthorizationCaseList.Append: TFhirRegulatedAuthorizationCase;
begin
  result := TFhirRegulatedAuthorizationCase.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirRegulatedAuthorizationCaseList.ClearItems;
begin
  Clear;
end;

function TFhirRegulatedAuthorizationCaseList.GetEnumerator : TFhirRegulatedAuthorizationCaseListEnumerator;
begin
  result := TFhirRegulatedAuthorizationCaseListEnumerator.Create(self.link);
end;

function TFhirRegulatedAuthorizationCaseList.Clone: TFhirRegulatedAuthorizationCaseList;
begin
  result := TFhirRegulatedAuthorizationCaseList(inherited Clone);
end;

function TFhirRegulatedAuthorizationCaseList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirRegulatedAuthorizationCaseList.GetItemN(index: Integer): TFhirRegulatedAuthorizationCase;
begin
  result := TFhirRegulatedAuthorizationCase(ObjectByIndex[index]);
end;

function TFhirRegulatedAuthorizationCaseList.ItemClass: TFslObjectClass;
begin
  result := TFhirRegulatedAuthorizationCase;
end;
function TFhirRegulatedAuthorizationCaseList.IndexOf(value: TFhirRegulatedAuthorizationCase): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirRegulatedAuthorizationCaseList.Insert(index: Integer): TFhirRegulatedAuthorizationCase;
begin
  result := TFhirRegulatedAuthorizationCase.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirRegulatedAuthorizationCaseList.InsertItem(index: Integer; value: TFhirRegulatedAuthorizationCase);
begin
  assert(value is TFhirRegulatedAuthorizationCase);
  Inherited Insert(index, value);
end;

function TFhirRegulatedAuthorizationCaseList.Item(index: Integer): TFhirRegulatedAuthorizationCase;
begin
  result := TFhirRegulatedAuthorizationCase(ObjectByIndex[index]);
end;

function TFhirRegulatedAuthorizationCaseList.Link: TFhirRegulatedAuthorizationCaseList;
begin
  result := TFhirRegulatedAuthorizationCaseList(inherited Link);
end;

procedure TFhirRegulatedAuthorizationCaseList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirRegulatedAuthorizationCaseList.SetItemByIndex(index: Integer; value: TFhirRegulatedAuthorizationCase);
begin
  assert(value is TFhirRegulatedAuthorizationCase);
  FhirRegulatedAuthorizationCases[index] := value;
end;

procedure TFhirRegulatedAuthorizationCaseList.SetItemN(index: Integer; value: TFhirRegulatedAuthorizationCase);
begin
  assert(value is TFhirRegulatedAuthorizationCase);
  ObjectByIndex[index] := value;
end;

{ TFhirRegulatedAuthorization }

constructor TFhirRegulatedAuthorization.Create;
begin
  inherited;
end;

destructor TFhirRegulatedAuthorization.Destroy;
begin
  FIdentifierList.Free;
  FSubjectList.Free;
  FType_.free;
  FDescription.free;
  FRegionList.Free;
  FStatus.free;
  FStatusDate.free;
  FValidityPeriod.free;
  FIndicationList.Free;
  FIntendedUse.free;
  FBasisList.Free;
  FHolder.free;
  FRegulator.free;
  FAttachedDocumentList.Free;
  FCase_.free;
  inherited;
end;

procedure TFhirRegulatedAuthorization.Assign(oSource : TFslObject);
begin
  inherited;
  if (TFhirRegulatedAuthorization(oSource).FIdentifierList = nil) then
  begin
    FIdentifierList.free;
    FIdentifierList := nil;
  end
  else
  begin
    if FIdentifierList = nil then
      FIdentifierList := TFhirIdentifierList.Create;
    FIdentifierList.Assign(TFhirRegulatedAuthorization(oSource).FIdentifierList);
  end;
  if (TFhirRegulatedAuthorization(oSource).FSubjectList = nil) then
  begin
    FSubjectList.free;
    FSubjectList := nil;
  end
  else
  begin
    if FSubjectList = nil then
      FSubjectList := TFhirReferenceList.Create;
    FSubjectList.Assign(TFhirRegulatedAuthorization(oSource).FSubjectList);
  end;
  type_ := TFhirRegulatedAuthorization(oSource).type_.Clone;
  descriptionElement := TFhirRegulatedAuthorization(oSource).descriptionElement.Clone;
  if (TFhirRegulatedAuthorization(oSource).FRegionList = nil) then
  begin
    FRegionList.free;
    FRegionList := nil;
  end
  else
  begin
    if FRegionList = nil then
      FRegionList := TFhirCodeableConceptList.Create;
    FRegionList.Assign(TFhirRegulatedAuthorization(oSource).FRegionList);
  end;
  status := TFhirRegulatedAuthorization(oSource).status.Clone;
  statusDateElement := TFhirRegulatedAuthorization(oSource).statusDateElement.Clone;
  validityPeriod := TFhirRegulatedAuthorization(oSource).validityPeriod.Clone;
  if (TFhirRegulatedAuthorization(oSource).FIndicationList = nil) then
  begin
    FIndicationList.free;
    FIndicationList := nil;
  end
  else
  begin
    if FIndicationList = nil then
      FIndicationList := TFhirCodeableReferenceList.Create;
    FIndicationList.Assign(TFhirRegulatedAuthorization(oSource).FIndicationList);
  end;
  intendedUse := TFhirRegulatedAuthorization(oSource).intendedUse.Clone;
  if (TFhirRegulatedAuthorization(oSource).FBasisList = nil) then
  begin
    FBasisList.free;
    FBasisList := nil;
  end
  else
  begin
    if FBasisList = nil then
      FBasisList := TFhirCodeableConceptList.Create;
    FBasisList.Assign(TFhirRegulatedAuthorization(oSource).FBasisList);
  end;
  holder := TFhirRegulatedAuthorization(oSource).holder.Clone;
  regulator := TFhirRegulatedAuthorization(oSource).regulator.Clone;
  if (TFhirRegulatedAuthorization(oSource).FAttachedDocumentList = nil) then
  begin
    FAttachedDocumentList.free;
    FAttachedDocumentList := nil;
  end
  else
  begin
    if FAttachedDocumentList = nil then
      FAttachedDocumentList := TFhirReferenceList.Create;
    FAttachedDocumentList.Assign(TFhirRegulatedAuthorization(oSource).FAttachedDocumentList);
  end;
  case_ := TFhirRegulatedAuthorization(oSource).case_.Clone;
end;

function TFhirRegulatedAuthorization.GetResourceType : TFhirResourceType;
begin
  result := frtRegulatedAuthorization;
end;

procedure TFhirRegulatedAuthorization.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'identifier') Then
    list.addAll(self, 'identifier', FIdentifierList);
  if (child_name = 'subject') Then
    list.addAll(self, 'subject', FSubjectList);
  if (child_name = 'type') Then
     list.add(self.link, 'type', FType_.Link);
  if (child_name = 'description') Then
     list.add(self.link, 'description', FDescription.Link);
  if (child_name = 'region') Then
    list.addAll(self, 'region', FRegionList);
  if (child_name = 'status') Then
     list.add(self.link, 'status', FStatus.Link);
  if (child_name = 'statusDate') Then
     list.add(self.link, 'statusDate', FStatusDate.Link);
  if (child_name = 'validityPeriod') Then
     list.add(self.link, 'validityPeriod', FValidityPeriod.Link);
  if (child_name = 'indication') Then
    list.addAll(self, 'indication', FIndicationList);
  if (child_name = 'intendedUse') Then
     list.add(self.link, 'intendedUse', FIntendedUse.Link);
  if (child_name = 'basis') Then
    list.addAll(self, 'basis', FBasisList);
  if (child_name = 'holder') Then
     list.add(self.link, 'holder', FHolder.Link);
  if (child_name = 'regulator') Then
     list.add(self.link, 'regulator', FRegulator.Link);
  if (child_name = 'attachedDocument') Then
    list.addAll(self, 'attachedDocument', FAttachedDocumentList);
  if (child_name = 'case') Then
     list.add(self.link, 'case', FCase_.Link);
end;

procedure TFhirRegulatedAuthorization.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'identifier', 'Identifier', true, TFhirIdentifier, FIdentifierList.Link));
  oList.add(TFHIRProperty.create(self, 'subject', 'Reference', true, TFhirReference, FSubjectList.Link));
  oList.add(TFHIRProperty.create(self, 'type', 'CodeableConcept', false, TFhirCodeableConcept, FType_.Link));
  oList.add(TFHIRProperty.create(self, 'description', 'markdown', false, TFhirMarkdown, FDescription.Link));
  oList.add(TFHIRProperty.create(self, 'region', 'CodeableConcept', true, TFhirCodeableConcept, FRegionList.Link));
  oList.add(TFHIRProperty.create(self, 'status', 'CodeableConcept', false, TFhirCodeableConcept, FStatus.Link));
  oList.add(TFHIRProperty.create(self, 'statusDate', 'dateTime', false, TFhirDateTime, FStatusDate.Link));
  oList.add(TFHIRProperty.create(self, 'validityPeriod', 'Period', false, TFhirPeriod, FValidityPeriod.Link));
  oList.add(TFHIRProperty.create(self, 'indication', 'CodeableReference', true, TFhirCodeableReference, FIndicationList.Link));
  oList.add(TFHIRProperty.create(self, 'intendedUse', 'CodeableConcept', false, TFhirCodeableConcept, FIntendedUse.Link));
  oList.add(TFHIRProperty.create(self, 'basis', 'CodeableConcept', true, TFhirCodeableConcept, FBasisList.Link));
  oList.add(TFHIRProperty.create(self, 'holder', 'Reference', false, TFhirReference, FHolder.Link));
  oList.add(TFHIRProperty.create(self, 'regulator', 'Reference', false, TFhirReference, FRegulator.Link));
  oList.add(TFHIRProperty.create(self, 'attachedDocument', 'Reference', true, TFhirReference, FAttachedDocumentList.Link));
  oList.add(TFHIRProperty.create(self, 'case', 'BackboneElement', false, TFhirRegulatedAuthorizationCase, FCase_.Link));
end;

function TFhirRegulatedAuthorization.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'identifier') then
  begin
    IdentifierList.add(propValue as TFhirIdentifier);
    result := propValue;
  end
  else if (propName = 'subject') then
  begin
    SubjectList.add(propValue as TFhirReference);
    result := propValue;
  end
  else if (propName = 'type') then
  begin
    Type_ := propValue as TFhirCodeableConcept;
    result := propValue;
  end
  else if (propName = 'description') then
  begin
    DescriptionElement := asMarkdown(propValue);
    result := propValue;
  end
  else if (propName = 'region') then
  begin
    RegionList.add(propValue as TFhirCodeableConcept);
    result := propValue;
  end
  else if (propName = 'status') then
  begin
    Status := propValue as TFhirCodeableConcept;
    result := propValue;
  end
  else if (propName = 'statusDate') then
  begin
    StatusDateElement := asDateTime(propValue);
    result := propValue;
  end
  else if (propName = 'validityPeriod') then
  begin
    ValidityPeriod := propValue as TFhirPeriod;
    result := propValue;
  end
  else if (propName = 'indication') then
  begin
    IndicationList.add(propValue as TFhirCodeableReference);
    result := propValue;
  end
  else if (propName = 'intendedUse') then
  begin
    IntendedUse := propValue as TFhirCodeableConcept;
    result := propValue;
  end
  else if (propName = 'basis') then
  begin
    BasisList.add(propValue as TFhirCodeableConcept);
    result := propValue;
  end
  else if (propName = 'holder') then
  begin
    Holder := propValue as TFhirReference;
    result := propValue;
  end
  else if (propName = 'regulator') then
  begin
    Regulator := propValue as TFhirReference;
    result := propValue;
  end
  else if (propName = 'attachedDocument') then
  begin
    AttachedDocumentList.add(propValue as TFhirReference);
    result := propValue;
  end
  else if (propName = 'case') then
  begin
    Case_ := propValue as TFhirRegulatedAuthorizationCase;
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirRegulatedAuthorization.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'identifier') then IdentifierList.insertItem(index, propValue as TFhirIdentifier)
  else if (propName = 'subject') then SubjectList.insertItem(index, propValue as TFhirReference)
  else if (propName = 'region') then RegionList.insertItem(index, propValue as TFhirCodeableConcept)
  else if (propName = 'indication') then IndicationList.insertItem(index, propValue as TFhirCodeableReference)
  else if (propName = 'basis') then BasisList.insertItem(index, propValue as TFhirCodeableConcept)
  else if (propName = 'attachedDocument') then AttachedDocumentList.insertItem(index, propValue as TFhirReference)
  else inherited;
end;

function TFhirRegulatedAuthorization.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'identifier') then result := IdentifierList.new()
  else if (propName = 'subject') then result := SubjectList.new()
  else if (propName = 'type') then result := TFhirCodeableConcept.create()
  else if (propName = 'description') then result := TFhirMarkdown.create()
  else if (propName = 'region') then result := RegionList.new()
  else if (propName = 'status') then result := TFhirCodeableConcept.create()
  else if (propName = 'statusDate') then result := TFhirDateTime.create()
  else if (propName = 'validityPeriod') then result := TFhirPeriod.create()
  else if (propName = 'indication') then result := IndicationList.new()
  else if (propName = 'intendedUse') then result := TFhirCodeableConcept.create()
  else if (propName = 'basis') then result := BasisList.new()
  else if (propName = 'holder') then result := TFhirReference.create()
  else if (propName = 'regulator') then result := TFhirReference.create()
  else if (propName = 'attachedDocument') then result := AttachedDocumentList.new()
  else if (propName = 'case') then result := TFhirRegulatedAuthorizationCase.create()
  else result := inherited createPropertyValue(propName);
end;

function TFhirRegulatedAuthorization.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'identifier') then result := 'Identifier'
  else if (propName = 'subject') then result := 'Reference'
  else if (propName = 'type') then result := 'CodeableConcept'
  else if (propName = 'description') then result := 'markdown'
  else if (propName = 'region') then result := 'CodeableConcept'
  else if (propName = 'status') then result := 'CodeableConcept'
  else if (propName = 'statusDate') then result := 'dateTime'
  else if (propName = 'validityPeriod') then result := 'Period'
  else if (propName = 'indication') then result := 'CodeableReference'
  else if (propName = 'intendedUse') then result := 'CodeableConcept'
  else if (propName = 'basis') then result := 'CodeableConcept'
  else if (propName = 'holder') then result := 'Reference'
  else if (propName = 'regulator') then result := 'Reference'
  else if (propName = 'attachedDocument') then result := 'Reference'
  else if (propName = 'case') then result := 'BackboneElement'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirRegulatedAuthorization.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'identifier') then deletePropertyValue('identifier', IdentifierList, value)
  else if (propName = 'subject') then deletePropertyValue('subject', SubjectList, value)
  else if (propName = 'type') then Type_Element := nil
  else if (propName = 'description') then DescriptionElement := nil
  else if (propName = 'region') then deletePropertyValue('region', RegionList, value)
  else if (propName = 'status') then StatusElement := nil
  else if (propName = 'statusDate') then StatusDateElement := nil
  else if (propName = 'validityPeriod') then ValidityPeriodElement := nil
  else if (propName = 'indication') then deletePropertyValue('indication', IndicationList, value)
  else if (propName = 'intendedUse') then IntendedUseElement := nil
  else if (propName = 'basis') then deletePropertyValue('basis', BasisList, value)
  else if (propName = 'holder') then HolderElement := nil
  else if (propName = 'regulator') then RegulatorElement := nil
  else if (propName = 'attachedDocument') then deletePropertyValue('attachedDocument', AttachedDocumentList, value)
  else if (propName = 'case') then Case_Element := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirRegulatedAuthorization.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'identifier') then replacePropertyValue('identifier', IdentifierList, existing, new)
  else if (propName = 'subject') then replacePropertyValue('subject', SubjectList, existing, new)
  else if (propName = 'type') then Type_Element := new as TFhirCodeableConcept
  else if (propName = 'description') then DescriptionElement := asMarkdown(new)
  else if (propName = 'region') then replacePropertyValue('region', RegionList, existing, new)
  else if (propName = 'status') then StatusElement := new as TFhirCodeableConcept
  else if (propName = 'statusDate') then StatusDateElement := asDateTime(new)
  else if (propName = 'validityPeriod') then ValidityPeriodElement := new as TFhirPeriod
  else if (propName = 'indication') then replacePropertyValue('indication', IndicationList, existing, new)
  else if (propName = 'intendedUse') then IntendedUseElement := new as TFhirCodeableConcept
  else if (propName = 'basis') then replacePropertyValue('basis', BasisList, existing, new)
  else if (propName = 'holder') then HolderElement := new as TFhirReference
  else if (propName = 'regulator') then RegulatorElement := new as TFhirReference
  else if (propName = 'attachedDocument') then replacePropertyValue('attachedDocument', AttachedDocumentList, existing, new)
  else if (propName = 'case') then Case_Element := new as TFhirRegulatedAuthorizationCase
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirRegulatedAuthorization.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'identifier') then IdentifierList.move(source, destination)
  else if (propName = 'subject') then SubjectList.move(source, destination)
  else if (propName = 'region') then RegionList.move(source, destination)
  else if (propName = 'indication') then IndicationList.move(source, destination)
  else if (propName = 'basis') then BasisList.move(source, destination)
  else if (propName = 'attachedDocument') then AttachedDocumentList.move(source, destination)
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirRegulatedAuthorization.fhirType : string;
begin
  result := 'RegulatedAuthorization';
end;

function TFhirRegulatedAuthorization.Link : TFhirRegulatedAuthorization;
begin
  result := TFhirRegulatedAuthorization(inherited Link);
end;

function TFhirRegulatedAuthorization.Clone : TFhirRegulatedAuthorization;
begin
  result := TFhirRegulatedAuthorization(inherited Clone);
end;

function TFhirRegulatedAuthorization.equals(other : TObject) : boolean; 
var
  o : TFhirRegulatedAuthorization;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirRegulatedAuthorization)) then
    result := false
  else
  begin
    o := TFhirRegulatedAuthorization(other);
    result := compareDeep(identifierList, o.identifierList, true) and compareDeep(subjectList, o.subjectList, true) and 
      compareDeep(type_Element, o.type_Element, true) and compareDeep(descriptionElement, o.descriptionElement, true) and 
      compareDeep(regionList, o.regionList, true) and compareDeep(statusElement, o.statusElement, true) and 
      compareDeep(statusDateElement, o.statusDateElement, true) and compareDeep(validityPeriodElement, o.validityPeriodElement, true) and 
      compareDeep(indicationList, o.indicationList, true) and compareDeep(intendedUseElement, o.intendedUseElement, true) and 
      compareDeep(basisList, o.basisList, true) and compareDeep(holderElement, o.holderElement, true) and 
      compareDeep(regulatorElement, o.regulatorElement, true) and compareDeep(attachedDocumentList, o.attachedDocumentList, true) and 
      compareDeep(case_Element, o.case_Element, true);
  end;
end;

function TFhirRegulatedAuthorization.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FidentifierList) and isEmptyProp(FsubjectList) and isEmptyProp(FType_) and isEmptyProp(FDescription) and isEmptyProp(FregionList) and isEmptyProp(FStatus) and isEmptyProp(FStatusDate) and isEmptyProp(FValidityPeriod) and isEmptyProp(FindicationList) and isEmptyProp(FIntendedUse) and isEmptyProp(FbasisList) and isEmptyProp(FHolder) and isEmptyProp(FRegulator) and isEmptyProp(FattachedDocumentList) and isEmptyProp(FCase_);
end;

procedure TFhirRegulatedAuthorization.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('identifier');
  fields.add('subject');
  fields.add('type');
  fields.add('description');
  fields.add('region');
  fields.add('status');
  fields.add('statusDate');
  fields.add('validityPeriod');
  fields.add('indication');
  fields.add('intendedUse');
  fields.add('basis');
  fields.add('holder');
  fields.add('regulator');
  fields.add('attachedDocument');
  fields.add('case');
end;

function TFhirRegulatedAuthorization.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
  inc(result, FIdentifierList.sizeInBytes(magic));
  inc(result, FSubjectList.sizeInBytes(magic));
  inc(result, FRegionList.sizeInBytes(magic));
  inc(result, FIndicationList.sizeInBytes(magic));
  inc(result, FBasisList.sizeInBytes(magic));
  inc(result, FAttachedDocumentList.sizeInBytes(magic));
end;

function TFhirRegulatedAuthorization.GetIdentifierList : TFhirIdentifierList;
begin
  if FIdentifierList = nil then
    FIdentifierList := TFhirIdentifierList.Create;
  result := FIdentifierList;
end;

function TFhirRegulatedAuthorization.GetHasIdentifierList : boolean;
begin
  result := (FIdentifierList <> nil) and (FIdentifierList.count > 0);
end;

function TFhirRegulatedAuthorization.GetSubjectList : TFhirReferenceList;
begin
  if FSubjectList = nil then
    FSubjectList := TFhirReferenceList.Create;
  result := FSubjectList;
end;

function TFhirRegulatedAuthorization.GetHasSubjectList : boolean;
begin
  result := (FSubjectList <> nil) and (FSubjectList.count > 0);
end;

procedure TFhirRegulatedAuthorization.SetType_(value : TFhirCodeableConcept);
begin
  FType_.free;
  FType_ := value;
end;

procedure TFhirRegulatedAuthorization.SetDescription(value : TFhirMarkdown);
begin
  FDescription.free;
  FDescription := value;
end;

function TFhirRegulatedAuthorization.GetDescriptionST : String;
begin
  if FDescription = nil then
    result := ''
  else
    result := FDescription.value;
end;

procedure TFhirRegulatedAuthorization.SetDescriptionST(value : String);
begin
  if value <> '' then
  begin
    if FDescription = nil then
      FDescription := TFhirMarkdown.create;
    FDescription.value := value
  end
  else if FDescription <> nil then
    FDescription.value := '';
end;

function TFhirRegulatedAuthorization.GetRegionList : TFhirCodeableConceptList;
begin
  if FRegionList = nil then
    FRegionList := TFhirCodeableConceptList.Create;
  result := FRegionList;
end;

function TFhirRegulatedAuthorization.GetHasRegionList : boolean;
begin
  result := (FRegionList <> nil) and (FRegionList.count > 0);
end;

procedure TFhirRegulatedAuthorization.SetStatus(value : TFhirCodeableConcept);
begin
  FStatus.free;
  FStatus := value;
end;

procedure TFhirRegulatedAuthorization.SetStatusDate(value : TFhirDateTime);
begin
  FStatusDate.free;
  FStatusDate := value;
end;

function TFhirRegulatedAuthorization.GetStatusDateST : TFslDateTime;
begin
  if FStatusDate = nil then
    result := TFslDateTime.makeNull
  else
    result := FStatusDate.value;
end;

procedure TFhirRegulatedAuthorization.SetStatusDateST(value : TFslDateTime);
begin
  if FStatusDate = nil then
    FStatusDate := TFhirDateTime.create;
  FStatusDate.value := value
end;

procedure TFhirRegulatedAuthorization.SetValidityPeriod(value : TFhirPeriod);
begin
  FValidityPeriod.free;
  FValidityPeriod := value;
end;

function TFhirRegulatedAuthorization.GetIndicationList : TFhirCodeableReferenceList;
begin
  if FIndicationList = nil then
    FIndicationList := TFhirCodeableReferenceList.Create;
  result := FIndicationList;
end;

function TFhirRegulatedAuthorization.GetHasIndicationList : boolean;
begin
  result := (FIndicationList <> nil) and (FIndicationList.count > 0);
end;

procedure TFhirRegulatedAuthorization.SetIntendedUse(value : TFhirCodeableConcept);
begin
  FIntendedUse.free;
  FIntendedUse := value;
end;

function TFhirRegulatedAuthorization.GetBasisList : TFhirCodeableConceptList;
begin
  if FBasisList = nil then
    FBasisList := TFhirCodeableConceptList.Create;
  result := FBasisList;
end;

function TFhirRegulatedAuthorization.GetHasBasisList : boolean;
begin
  result := (FBasisList <> nil) and (FBasisList.count > 0);
end;

procedure TFhirRegulatedAuthorization.SetHolder(value : TFhirReference);
begin
  FHolder.free;
  FHolder := value;
end;

procedure TFhirRegulatedAuthorization.SetRegulator(value : TFhirReference);
begin
  FRegulator.free;
  FRegulator := value;
end;

function TFhirRegulatedAuthorization.GetAttachedDocumentList : TFhirReferenceList;
begin
  if FAttachedDocumentList = nil then
    FAttachedDocumentList := TFhirReferenceList.Create;
  result := FAttachedDocumentList;
end;

function TFhirRegulatedAuthorization.GetHasAttachedDocumentList : boolean;
begin
  result := (FAttachedDocumentList <> nil) and (FAttachedDocumentList.count > 0);
end;

procedure TFhirRegulatedAuthorization.SetCase_(value : TFhirRegulatedAuthorizationCase);
begin
  FCase_.free;
  FCase_ := value;
end;

{ TFhirRegulatedAuthorizationListEnumerator }

constructor TFhirRegulatedAuthorizationListEnumerator.Create(list : TFhirRegulatedAuthorizationList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirRegulatedAuthorizationListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirRegulatedAuthorizationListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirRegulatedAuthorizationListEnumerator.GetCurrent : TFhirRegulatedAuthorization;
begin
  Result := FList[FIndex];
end;

function TFhirRegulatedAuthorizationListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirRegulatedAuthorizationList }

function TFhirRegulatedAuthorizationList.AddItem(value: TFhirRegulatedAuthorization): TFhirRegulatedAuthorization;
begin
  assert(value.ClassName = 'TFhirRegulatedAuthorization', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirRegulatedAuthorization');
  add(value);
  result := value;
end;

function TFhirRegulatedAuthorizationList.Append: TFhirRegulatedAuthorization;
begin
  result := TFhirRegulatedAuthorization.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirRegulatedAuthorizationList.ClearItems;
begin
  Clear;
end;

function TFhirRegulatedAuthorizationList.GetEnumerator : TFhirRegulatedAuthorizationListEnumerator;
begin
  result := TFhirRegulatedAuthorizationListEnumerator.Create(self.link);
end;

function TFhirRegulatedAuthorizationList.Clone: TFhirRegulatedAuthorizationList;
begin
  result := TFhirRegulatedAuthorizationList(inherited Clone);
end;

function TFhirRegulatedAuthorizationList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirRegulatedAuthorizationList.GetItemN(index: Integer): TFhirRegulatedAuthorization;
begin
  result := TFhirRegulatedAuthorization(ObjectByIndex[index]);
end;

function TFhirRegulatedAuthorizationList.ItemClass: TFslObjectClass;
begin
  result := TFhirRegulatedAuthorization;
end;
function TFhirRegulatedAuthorizationList.IndexOf(value: TFhirRegulatedAuthorization): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirRegulatedAuthorizationList.Insert(index: Integer): TFhirRegulatedAuthorization;
begin
  result := TFhirRegulatedAuthorization.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirRegulatedAuthorizationList.InsertItem(index: Integer; value: TFhirRegulatedAuthorization);
begin
  assert(value is TFhirRegulatedAuthorization);
  Inherited Insert(index, value);
end;

function TFhirRegulatedAuthorizationList.Item(index: Integer): TFhirRegulatedAuthorization;
begin
  result := TFhirRegulatedAuthorization(ObjectByIndex[index]);
end;

function TFhirRegulatedAuthorizationList.Link: TFhirRegulatedAuthorizationList;
begin
  result := TFhirRegulatedAuthorizationList(inherited Link);
end;

procedure TFhirRegulatedAuthorizationList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirRegulatedAuthorizationList.SetItemByIndex(index: Integer; value: TFhirRegulatedAuthorization);
begin
  assert(value is TFhirRegulatedAuthorization);
  FhirRegulatedAuthorizations[index] := value;
end;

procedure TFhirRegulatedAuthorizationList.SetItemN(index: Integer; value: TFhirRegulatedAuthorization);
begin
  assert(value is TFhirRegulatedAuthorization);
  ObjectByIndex[index] := value;
end;

{$ENDIF FHIR_REGULATEDAUTHORIZATION}
{$IFDEF FHIR_SUBSTANCE}
{ TFhirSubstanceIngredient }

constructor TFhirSubstanceIngredient.Create;
begin
  inherited;
end;

destructor TFhirSubstanceIngredient.Destroy;
begin
  FQuantity.free;
  FSubstance.free;
  inherited;
end;

procedure TFhirSubstanceIngredient.Assign(oSource : TFslObject);
begin
  inherited;
  quantity := TFhirSubstanceIngredient(oSource).quantity.Clone;
  substance := TFhirSubstanceIngredient(oSource).substance.Clone;
end;

procedure TFhirSubstanceIngredient.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'quantity') Then
     list.add(self.link, 'quantity', FQuantity.Link);
  if (child_name = 'substance[x]') or (child_name = 'substance') Then
     list.add(self.link, 'substance[x]', FSubstance.Link);
end;

procedure TFhirSubstanceIngredient.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'quantity', 'Ratio', false, TFhirRatio, FQuantity.Link));
  oList.add(TFHIRProperty.create(self, 'substance[x]', 'CodeableConcept|Reference', false, TFhirDataType, FSubstance.Link));
end;

function TFhirSubstanceIngredient.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'quantity') then
  begin
    Quantity := propValue as TFhirRatio;
    result := propValue;
  end
  else if (isMatchingName(propName, 'substance', ['CodeableConcept', 'Reference'])) then
  begin
    Substance := propValue as TFhirDataType;
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirSubstanceIngredient.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirSubstanceIngredient.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'quantity') then result := TFhirRatio.create()
  else if (isMatchingName(propName, 'substance', ['CodeableConcept', 'Reference'])) then raise EFHIRException.create('Cannot make property Substance')
  else result := inherited createPropertyValue(propName);
end;

function TFhirSubstanceIngredient.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'quantity') then result := 'Ratio'
  else if (propName = 'substance[x]') then result := 'CodeableConcept|Reference'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirSubstanceIngredient.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'quantity') then QuantityElement := nil
  else if (isMatchingName(propName, 'substance', ['CodeableConcept', 'Reference'])) then SubstanceElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirSubstanceIngredient.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'quantity') then QuantityElement := new as TFhirRatio
  else if (isMatchingName(propName, 'substance', ['CodeableConcept', 'Reference'])) then SubstanceElement := new as TFhirDataType
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirSubstanceIngredient.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirSubstanceIngredient.fhirType : string;
begin
  result := 'Substance.ingredient';
end;

function TFhirSubstanceIngredient.Link : TFhirSubstanceIngredient;
begin
  result := TFhirSubstanceIngredient(inherited Link);
end;

function TFhirSubstanceIngredient.Clone : TFhirSubstanceIngredient;
begin
  result := TFhirSubstanceIngredient(inherited Clone);
end;

function TFhirSubstanceIngredient.equals(other : TObject) : boolean; 
var
  o : TFhirSubstanceIngredient;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirSubstanceIngredient)) then
    result := false
  else
  begin
    o := TFhirSubstanceIngredient(other);
    result := compareDeep(quantityElement, o.quantityElement, true) and compareDeep(substanceElement, o.substanceElement, true);
  end;
end;

function TFhirSubstanceIngredient.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FQuantity) and isEmptyProp(FSubstance);
end;

procedure TFhirSubstanceIngredient.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('quantity');
  fields.add('substance[x]');
end;

function TFhirSubstanceIngredient.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
end;

procedure TFhirSubstanceIngredient.SetQuantity(value : TFhirRatio);
begin
  FQuantity.free;
  FQuantity := value;
end;

procedure TFhirSubstanceIngredient.SetSubstance(value : TFhirDataType);
begin
  FSubstance.free;
  FSubstance := value;
end;

{ TFhirSubstanceIngredientListEnumerator }

constructor TFhirSubstanceIngredientListEnumerator.Create(list : TFhirSubstanceIngredientList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirSubstanceIngredientListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirSubstanceIngredientListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirSubstanceIngredientListEnumerator.GetCurrent : TFhirSubstanceIngredient;
begin
  Result := FList[FIndex];
end;

function TFhirSubstanceIngredientListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirSubstanceIngredientList }

function TFhirSubstanceIngredientList.AddItem(value: TFhirSubstanceIngredient): TFhirSubstanceIngredient;
begin
  assert(value.ClassName = 'TFhirSubstanceIngredient', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirSubstanceIngredient');
  add(value);
  result := value;
end;

function TFhirSubstanceIngredientList.Append: TFhirSubstanceIngredient;
begin
  result := TFhirSubstanceIngredient.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirSubstanceIngredientList.ClearItems;
begin
  Clear;
end;

function TFhirSubstanceIngredientList.GetEnumerator : TFhirSubstanceIngredientListEnumerator;
begin
  result := TFhirSubstanceIngredientListEnumerator.Create(self.link);
end;

function TFhirSubstanceIngredientList.Clone: TFhirSubstanceIngredientList;
begin
  result := TFhirSubstanceIngredientList(inherited Clone);
end;

function TFhirSubstanceIngredientList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirSubstanceIngredientList.GetItemN(index: Integer): TFhirSubstanceIngredient;
begin
  result := TFhirSubstanceIngredient(ObjectByIndex[index]);
end;

function TFhirSubstanceIngredientList.ItemClass: TFslObjectClass;
begin
  result := TFhirSubstanceIngredient;
end;
function TFhirSubstanceIngredientList.IndexOf(value: TFhirSubstanceIngredient): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirSubstanceIngredientList.Insert(index: Integer): TFhirSubstanceIngredient;
begin
  result := TFhirSubstanceIngredient.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirSubstanceIngredientList.InsertItem(index: Integer; value: TFhirSubstanceIngredient);
begin
  assert(value is TFhirSubstanceIngredient);
  Inherited Insert(index, value);
end;

function TFhirSubstanceIngredientList.Item(index: Integer): TFhirSubstanceIngredient;
begin
  result := TFhirSubstanceIngredient(ObjectByIndex[index]);
end;

function TFhirSubstanceIngredientList.Link: TFhirSubstanceIngredientList;
begin
  result := TFhirSubstanceIngredientList(inherited Link);
end;

procedure TFhirSubstanceIngredientList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirSubstanceIngredientList.SetItemByIndex(index: Integer; value: TFhirSubstanceIngredient);
begin
  assert(value is TFhirSubstanceIngredient);
  FhirSubstanceIngredients[index] := value;
end;

procedure TFhirSubstanceIngredientList.SetItemN(index: Integer; value: TFhirSubstanceIngredient);
begin
  assert(value is TFhirSubstanceIngredient);
  ObjectByIndex[index] := value;
end;

{ TFhirSubstance }

constructor TFhirSubstance.Create;
begin
  inherited;
end;

destructor TFhirSubstance.Destroy;
begin
  FIdentifierList.Free;
  FInstance.free;
  FStatus.free;
  FCategoryList.Free;
  FCode.free;
  FDescription.free;
  FExpiry.free;
  FQuantity.free;
  FIngredientList.Free;
  inherited;
end;

procedure TFhirSubstance.Assign(oSource : TFslObject);
begin
  inherited;
  if (TFhirSubstance(oSource).FIdentifierList = nil) then
  begin
    FIdentifierList.free;
    FIdentifierList := nil;
  end
  else
  begin
    if FIdentifierList = nil then
      FIdentifierList := TFhirIdentifierList.Create;
    FIdentifierList.Assign(TFhirSubstance(oSource).FIdentifierList);
  end;
  instanceElement := TFhirSubstance(oSource).instanceElement.Clone;
  statusElement := TFhirSubstance(oSource).statusElement.Clone;
  if (TFhirSubstance(oSource).FCategoryList = nil) then
  begin
    FCategoryList.free;
    FCategoryList := nil;
  end
  else
  begin
    if FCategoryList = nil then
      FCategoryList := TFhirCodeableConceptList.Create;
    FCategoryList.Assign(TFhirSubstance(oSource).FCategoryList);
  end;
  code := TFhirSubstance(oSource).code.Clone;
  descriptionElement := TFhirSubstance(oSource).descriptionElement.Clone;
  expiryElement := TFhirSubstance(oSource).expiryElement.Clone;
  quantity := TFhirSubstance(oSource).quantity.Clone;
  if (TFhirSubstance(oSource).FIngredientList = nil) then
  begin
    FIngredientList.free;
    FIngredientList := nil;
  end
  else
  begin
    if FIngredientList = nil then
      FIngredientList := TFhirSubstanceIngredientList.Create;
    FIngredientList.Assign(TFhirSubstance(oSource).FIngredientList);
  end;
end;

function TFhirSubstance.GetResourceType : TFhirResourceType;
begin
  result := frtSubstance;
end;

procedure TFhirSubstance.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'identifier') Then
    list.addAll(self, 'identifier', FIdentifierList);
  if (child_name = 'instance') Then
     list.add(self.link, 'instance', FInstance.Link);
  if (child_name = 'status') Then
     list.add(self.link, 'status', FStatus.Link);
  if (child_name = 'category') Then
    list.addAll(self, 'category', FCategoryList);
  if (child_name = 'code') Then
     list.add(self.link, 'code', FCode.Link);
  if (child_name = 'description') Then
     list.add(self.link, 'description', FDescription.Link);
  if (child_name = 'expiry') Then
     list.add(self.link, 'expiry', FExpiry.Link);
  if (child_name = 'quantity') Then
     list.add(self.link, 'quantity', FQuantity.Link);
  if (child_name = 'ingredient') Then
    list.addAll(self, 'ingredient', FIngredientList);
end;

procedure TFhirSubstance.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'identifier', 'Identifier', true, TFhirIdentifier, FIdentifierList.Link));
  oList.add(TFHIRProperty.create(self, 'instance', 'boolean', false, TFhirBoolean, FInstance.Link));
  oList.add(TFHIRProperty.create(self, 'status', 'code', false, TFhirEnum, FStatus.Link));
  oList.add(TFHIRProperty.create(self, 'category', 'CodeableConcept', true, TFhirCodeableConcept, FCategoryList.Link));
  oList.add(TFHIRProperty.create(self, 'code', 'CodeableReference', false, TFhirCodeableReference, FCode.Link));
  oList.add(TFHIRProperty.create(self, 'description', 'string', false, TFhirString, FDescription.Link));
  oList.add(TFHIRProperty.create(self, 'expiry', 'dateTime', false, TFhirDateTime, FExpiry.Link));
  oList.add(TFHIRProperty.create(self, 'quantity', 'Quantity', false, TFhirQuantity, FQuantity.Link));
  oList.add(TFHIRProperty.create(self, 'ingredient', 'BackboneElement', true, TFhirSubstanceIngredient, FIngredientList.Link));
end;

function TFhirSubstance.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'identifier') then
  begin
    IdentifierList.add(propValue as TFhirIdentifier);
    result := propValue;
  end
  else if (propName = 'instance') then
  begin
    InstanceElement := asBoolean(propValue);
    result := propValue;
  end
  else if (propName = 'status') then
  begin
    StatusElement := asEnum(SYSTEMS_TFhirFHIRSubstanceStatusEnum, CODES_TFhirFHIRSubstanceStatusEnum, propValue);
    result := propValue;
  end
  else if (propName = 'category') then
  begin
    CategoryList.add(propValue as TFhirCodeableConcept);
    result := propValue;
  end
  else if (propName = 'code') then
  begin
    Code := propValue as TFhirCodeableReference;
    result := propValue;
  end
  else if (propName = 'description') then
  begin
    DescriptionElement := asString(propValue);
    result := propValue;
  end
  else if (propName = 'expiry') then
  begin
    ExpiryElement := asDateTime(propValue);
    result := propValue;
  end
  else if (propName = 'quantity') then
  begin
    Quantity := propValue as TFhirQuantity;
    result := propValue;
  end
  else if (propName = 'ingredient') then
  begin
    IngredientList.add(propValue as TFhirSubstanceIngredient);
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirSubstance.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'identifier') then IdentifierList.insertItem(index, propValue as TFhirIdentifier)
  else if (propName = 'category') then CategoryList.insertItem(index, propValue as TFhirCodeableConcept)
  else if (propName = 'ingredient') then IngredientList.insertItem(index, propValue as TFhirSubstanceIngredient)
  else inherited;
end;

function TFhirSubstance.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'identifier') then result := IdentifierList.new()
  else if (propName = 'instance') then result := TFhirBoolean.create()
  else if (propName = 'status') then result := TFhirEnum.create(SYSTEMS_TFhirFHIRSubstanceStatusEnum[FHIRSubstanceStatusNull], CODES_TFhirFHIRSubstanceStatusEnum[FHIRSubstanceStatusNull]) 
  else if (propName = 'category') then result := CategoryList.new()
  else if (propName = 'code') then result := TFhirCodeableReference.create()
  else if (propName = 'description') then result := TFhirString.create()
  else if (propName = 'expiry') then result := TFhirDateTime.create()
  else if (propName = 'quantity') then result := TFhirQuantity.create()
  else if (propName = 'ingredient') then result := IngredientList.new()
  else result := inherited createPropertyValue(propName);
end;

function TFhirSubstance.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'identifier') then result := 'Identifier'
  else if (propName = 'instance') then result := 'boolean'
  else if (propName = 'status') then result := 'code'
  else if (propName = 'category') then result := 'CodeableConcept'
  else if (propName = 'code') then result := 'CodeableReference'
  else if (propName = 'description') then result := 'string'
  else if (propName = 'expiry') then result := 'dateTime'
  else if (propName = 'quantity') then result := 'Quantity'
  else if (propName = 'ingredient') then result := 'BackboneElement'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirSubstance.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'identifier') then deletePropertyValue('identifier', IdentifierList, value)
  else if (propName = 'instance') then InstanceElement := nil
  else if (propName = 'status') then StatusElement := nil
  else if (propName = 'category') then deletePropertyValue('category', CategoryList, value)
  else if (propName = 'code') then CodeElement := nil
  else if (propName = 'description') then DescriptionElement := nil
  else if (propName = 'expiry') then ExpiryElement := nil
  else if (propName = 'quantity') then QuantityElement := nil
  else if (propName = 'ingredient') then deletePropertyValue('ingredient', IngredientList, value)
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirSubstance.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'identifier') then replacePropertyValue('identifier', IdentifierList, existing, new)
  else if (propName = 'instance') then InstanceElement := asBoolean(new)
  else if (propName = 'status') then StatusElement := asEnum(SYSTEMS_TFhirFHIRSubstanceStatusEnum, CODES_TFhirFHIRSubstanceStatusEnum, new)
  else if (propName = 'category') then replacePropertyValue('category', CategoryList, existing, new)
  else if (propName = 'code') then CodeElement := new as TFhirCodeableReference
  else if (propName = 'description') then DescriptionElement := asString(new)
  else if (propName = 'expiry') then ExpiryElement := asDateTime(new)
  else if (propName = 'quantity') then QuantityElement := new as TFhirQuantity
  else if (propName = 'ingredient') then replacePropertyValue('ingredient', IngredientList, existing, new)
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirSubstance.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'identifier') then IdentifierList.move(source, destination)
  else if (propName = 'category') then CategoryList.move(source, destination)
  else if (propName = 'ingredient') then IngredientList.move(source, destination)
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirSubstance.fhirType : string;
begin
  result := 'Substance';
end;

function TFhirSubstance.Link : TFhirSubstance;
begin
  result := TFhirSubstance(inherited Link);
end;

function TFhirSubstance.Clone : TFhirSubstance;
begin
  result := TFhirSubstance(inherited Clone);
end;

function TFhirSubstance.equals(other : TObject) : boolean; 
var
  o : TFhirSubstance;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirSubstance)) then
    result := false
  else
  begin
    o := TFhirSubstance(other);
    result := compareDeep(identifierList, o.identifierList, true) and compareDeep(instanceElement, o.instanceElement, true) and 
      compareDeep(statusElement, o.statusElement, true) and compareDeep(categoryList, o.categoryList, true) and 
      compareDeep(codeElement, o.codeElement, true) and compareDeep(descriptionElement, o.descriptionElement, true) and 
      compareDeep(expiryElement, o.expiryElement, true) and compareDeep(quantityElement, o.quantityElement, true) and 
      compareDeep(ingredientList, o.ingredientList, true);
  end;
end;

function TFhirSubstance.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FidentifierList) and isEmptyProp(FInstance) and isEmptyProp(FStatus) and isEmptyProp(FcategoryList) and isEmptyProp(FCode) and isEmptyProp(FDescription) and isEmptyProp(FExpiry) and isEmptyProp(FQuantity) and isEmptyProp(FingredientList);
end;

procedure TFhirSubstance.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('identifier');
  fields.add('instance');
  fields.add('status');
  fields.add('category');
  fields.add('code');
  fields.add('description');
  fields.add('expiry');
  fields.add('quantity');
  fields.add('ingredient');
end;

function TFhirSubstance.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
  inc(result, FIdentifierList.sizeInBytes(magic));
  inc(result, FCategoryList.sizeInBytes(magic));
  inc(result, FIngredientList.sizeInBytes(magic));
end;

function TFhirSubstance.GetIdentifierList : TFhirIdentifierList;
begin
  if FIdentifierList = nil then
    FIdentifierList := TFhirIdentifierList.Create;
  result := FIdentifierList;
end;

function TFhirSubstance.GetHasIdentifierList : boolean;
begin
  result := (FIdentifierList <> nil) and (FIdentifierList.count > 0);
end;

procedure TFhirSubstance.SetInstance(value : TFhirBoolean);
begin
  FInstance.free;
  FInstance := value;
end;

function TFhirSubstance.GetInstanceST : Boolean;
begin
  if FInstance = nil then
    result := false
  else
    result := FInstance.value;
end;

procedure TFhirSubstance.SetInstanceST(value : Boolean);
begin
  if FInstance = nil then
    FInstance := TFhirBoolean.create;
  FInstance.value := value
end;

procedure TFhirSubstance.SetStatus(value : TFhirEnum);
begin
  FStatus.free;
  FStatus := value;
end;

function TFhirSubstance.GetStatusST : TFhirFHIRSubstanceStatusEnum;
begin
  if FStatus = nil then
    result := TFhirFHIRSubstanceStatusEnum(0)
  else
    result := TFhirFHIRSubstanceStatusEnum(StringArrayIndexOfSensitive(CODES_TFhirFHIRSubstanceStatusEnum, FStatus.value));
end;

procedure TFhirSubstance.SetStatusST(value : TFhirFHIRSubstanceStatusEnum);
begin
  if ord(value) = 0 then
    StatusElement := nil
  else
    StatusElement := TFhirEnum.create(SYSTEMS_TFhirFHIRSubstanceStatusEnum[value], CODES_TFhirFHIRSubstanceStatusEnum[value]);
end;

function TFhirSubstance.GetCategoryList : TFhirCodeableConceptList;
begin
  if FCategoryList = nil then
    FCategoryList := TFhirCodeableConceptList.Create;
  result := FCategoryList;
end;

function TFhirSubstance.GetHasCategoryList : boolean;
begin
  result := (FCategoryList <> nil) and (FCategoryList.count > 0);
end;

procedure TFhirSubstance.SetCode(value : TFhirCodeableReference);
begin
  FCode.free;
  FCode := value;
end;

procedure TFhirSubstance.SetDescription(value : TFhirString);
begin
  FDescription.free;
  FDescription := value;
end;

function TFhirSubstance.GetDescriptionST : String;
begin
  if FDescription = nil then
    result := ''
  else
    result := FDescription.value;
end;

procedure TFhirSubstance.SetDescriptionST(value : String);
begin
  if value <> '' then
  begin
    if FDescription = nil then
      FDescription := TFhirString.create;
    FDescription.value := value
  end
  else if FDescription <> nil then
    FDescription.value := '';
end;

procedure TFhirSubstance.SetExpiry(value : TFhirDateTime);
begin
  FExpiry.free;
  FExpiry := value;
end;

function TFhirSubstance.GetExpiryST : TFslDateTime;
begin
  if FExpiry = nil then
    result := TFslDateTime.makeNull
  else
    result := FExpiry.value;
end;

procedure TFhirSubstance.SetExpiryST(value : TFslDateTime);
begin
  if FExpiry = nil then
    FExpiry := TFhirDateTime.create;
  FExpiry.value := value
end;

procedure TFhirSubstance.SetQuantity(value : TFhirQuantity);
begin
  FQuantity.free;
  FQuantity := value;
end;

function TFhirSubstance.GetIngredientList : TFhirSubstanceIngredientList;
begin
  if FIngredientList = nil then
    FIngredientList := TFhirSubstanceIngredientList.Create;
  result := FIngredientList;
end;

function TFhirSubstance.GetHasIngredientList : boolean;
begin
  result := (FIngredientList <> nil) and (FIngredientList.count > 0);
end;

{ TFhirSubstanceListEnumerator }

constructor TFhirSubstanceListEnumerator.Create(list : TFhirSubstanceList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirSubstanceListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirSubstanceListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirSubstanceListEnumerator.GetCurrent : TFhirSubstance;
begin
  Result := FList[FIndex];
end;

function TFhirSubstanceListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirSubstanceList }

function TFhirSubstanceList.AddItem(value: TFhirSubstance): TFhirSubstance;
begin
  assert(value.ClassName = 'TFhirSubstance', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirSubstance');
  add(value);
  result := value;
end;

function TFhirSubstanceList.Append: TFhirSubstance;
begin
  result := TFhirSubstance.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirSubstanceList.ClearItems;
begin
  Clear;
end;

function TFhirSubstanceList.GetEnumerator : TFhirSubstanceListEnumerator;
begin
  result := TFhirSubstanceListEnumerator.Create(self.link);
end;

function TFhirSubstanceList.Clone: TFhirSubstanceList;
begin
  result := TFhirSubstanceList(inherited Clone);
end;

function TFhirSubstanceList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirSubstanceList.GetItemN(index: Integer): TFhirSubstance;
begin
  result := TFhirSubstance(ObjectByIndex[index]);
end;

function TFhirSubstanceList.ItemClass: TFslObjectClass;
begin
  result := TFhirSubstance;
end;
function TFhirSubstanceList.IndexOf(value: TFhirSubstance): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirSubstanceList.Insert(index: Integer): TFhirSubstance;
begin
  result := TFhirSubstance.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirSubstanceList.InsertItem(index: Integer; value: TFhirSubstance);
begin
  assert(value is TFhirSubstance);
  Inherited Insert(index, value);
end;

function TFhirSubstanceList.Item(index: Integer): TFhirSubstance;
begin
  result := TFhirSubstance(ObjectByIndex[index]);
end;

function TFhirSubstanceList.Link: TFhirSubstanceList;
begin
  result := TFhirSubstanceList(inherited Link);
end;

procedure TFhirSubstanceList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirSubstanceList.SetItemByIndex(index: Integer; value: TFhirSubstance);
begin
  assert(value is TFhirSubstance);
  FhirSubstances[index] := value;
end;

procedure TFhirSubstanceList.SetItemN(index: Integer; value: TFhirSubstance);
begin
  assert(value is TFhirSubstance);
  ObjectByIndex[index] := value;
end;

{$ENDIF FHIR_SUBSTANCE}
{$IFDEF FHIR_SUBSTANCEDEFINITION}
{ TFhirSubstanceDefinitionMoiety }

constructor TFhirSubstanceDefinitionMoiety.Create;
begin
  inherited;
end;

destructor TFhirSubstanceDefinitionMoiety.Destroy;
begin
  FRole.free;
  FIdentifier.free;
  FName.free;
  FStereochemistry.free;
  FOpticalActivity.free;
  FMolecularFormula.free;
  FAmount.free;
  FMeasurementType.free;
  inherited;
end;

procedure TFhirSubstanceDefinitionMoiety.Assign(oSource : TFslObject);
begin
  inherited;
  role := TFhirSubstanceDefinitionMoiety(oSource).role.Clone;
  identifier := TFhirSubstanceDefinitionMoiety(oSource).identifier.Clone;
  nameElement := TFhirSubstanceDefinitionMoiety(oSource).nameElement.Clone;
  stereochemistry := TFhirSubstanceDefinitionMoiety(oSource).stereochemistry.Clone;
  opticalActivity := TFhirSubstanceDefinitionMoiety(oSource).opticalActivity.Clone;
  molecularFormulaElement := TFhirSubstanceDefinitionMoiety(oSource).molecularFormulaElement.Clone;
  amount := TFhirSubstanceDefinitionMoiety(oSource).amount.Clone;
  measurementType := TFhirSubstanceDefinitionMoiety(oSource).measurementType.Clone;
end;

procedure TFhirSubstanceDefinitionMoiety.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'role') Then
     list.add(self.link, 'role', FRole.Link);
  if (child_name = 'identifier') Then
     list.add(self.link, 'identifier', FIdentifier.Link);
  if (child_name = 'name') Then
     list.add(self.link, 'name', FName.Link);
  if (child_name = 'stereochemistry') Then
     list.add(self.link, 'stereochemistry', FStereochemistry.Link);
  if (child_name = 'opticalActivity') Then
     list.add(self.link, 'opticalActivity', FOpticalActivity.Link);
  if (child_name = 'molecularFormula') Then
     list.add(self.link, 'molecularFormula', FMolecularFormula.Link);
  if (child_name = 'amount[x]') or (child_name = 'amount') Then
     list.add(self.link, 'amount[x]', FAmount.Link);
  if (child_name = 'measurementType') Then
     list.add(self.link, 'measurementType', FMeasurementType.Link);
end;

procedure TFhirSubstanceDefinitionMoiety.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'role', 'CodeableConcept', false, TFhirCodeableConcept, FRole.Link));
  oList.add(TFHIRProperty.create(self, 'identifier', 'Identifier', false, TFhirIdentifier, FIdentifier.Link));
  oList.add(TFHIRProperty.create(self, 'name', 'string', false, TFhirString, FName.Link));
  oList.add(TFHIRProperty.create(self, 'stereochemistry', 'CodeableConcept', false, TFhirCodeableConcept, FStereochemistry.Link));
  oList.add(TFHIRProperty.create(self, 'opticalActivity', 'CodeableConcept', false, TFhirCodeableConcept, FOpticalActivity.Link));
  oList.add(TFHIRProperty.create(self, 'molecularFormula', 'string', false, TFhirString, FMolecularFormula.Link));
  oList.add(TFHIRProperty.create(self, 'amount[x]', 'Quantity|string', false, TFhirDataType, FAmount.Link));
  oList.add(TFHIRProperty.create(self, 'measurementType', 'CodeableConcept', false, TFhirCodeableConcept, FMeasurementType.Link));
end;

function TFhirSubstanceDefinitionMoiety.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'role') then
  begin
    Role := propValue as TFhirCodeableConcept;
    result := propValue;
  end
  else if (propName = 'identifier') then
  begin
    Identifier := propValue as TFhirIdentifier;
    result := propValue;
  end
  else if (propName = 'name') then
  begin
    NameElement := asString(propValue);
    result := propValue;
  end
  else if (propName = 'stereochemistry') then
  begin
    Stereochemistry := propValue as TFhirCodeableConcept;
    result := propValue;
  end
  else if (propName = 'opticalActivity') then
  begin
    OpticalActivity := propValue as TFhirCodeableConcept;
    result := propValue;
  end
  else if (propName = 'molecularFormula') then
  begin
    MolecularFormulaElement := asString(propValue);
    result := propValue;
  end
  else if (isMatchingName(propName, 'amount', ['Quantity', 'String'])) then
  begin
    Amount := propValue as TFhirDataType;
    result := propValue;
  end
  else if (propName = 'measurementType') then
  begin
    MeasurementType := propValue as TFhirCodeableConcept;
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirSubstanceDefinitionMoiety.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirSubstanceDefinitionMoiety.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'role') then result := TFhirCodeableConcept.create()
  else if (propName = 'identifier') then result := TFhirIdentifier.create()
  else if (propName = 'name') then result := TFhirString.create()
  else if (propName = 'stereochemistry') then result := TFhirCodeableConcept.create()
  else if (propName = 'opticalActivity') then result := TFhirCodeableConcept.create()
  else if (propName = 'molecularFormula') then result := TFhirString.create()
  else if (isMatchingName(propName, 'amount', ['Quantity', 'String'])) then raise EFHIRException.create('Cannot make property Amount')
  else if (propName = 'measurementType') then result := TFhirCodeableConcept.create()
  else result := inherited createPropertyValue(propName);
end;

function TFhirSubstanceDefinitionMoiety.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'role') then result := 'CodeableConcept'
  else if (propName = 'identifier') then result := 'Identifier'
  else if (propName = 'name') then result := 'string'
  else if (propName = 'stereochemistry') then result := 'CodeableConcept'
  else if (propName = 'opticalActivity') then result := 'CodeableConcept'
  else if (propName = 'molecularFormula') then result := 'string'
  else if (propName = 'amount[x]') then result := 'Quantity|string'
  else if (propName = 'measurementType') then result := 'CodeableConcept'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirSubstanceDefinitionMoiety.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'role') then RoleElement := nil
  else if (propName = 'identifier') then IdentifierElement := nil
  else if (propName = 'name') then NameElement := nil
  else if (propName = 'stereochemistry') then StereochemistryElement := nil
  else if (propName = 'opticalActivity') then OpticalActivityElement := nil
  else if (propName = 'molecularFormula') then MolecularFormulaElement := nil
  else if (isMatchingName(propName, 'amount', ['Quantity', 'String'])) then AmountElement := nil
  else if (propName = 'measurementType') then MeasurementTypeElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirSubstanceDefinitionMoiety.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'role') then RoleElement := new as TFhirCodeableConcept
  else if (propName = 'identifier') then IdentifierElement := new as TFhirIdentifier
  else if (propName = 'name') then NameElement := asString(new)
  else if (propName = 'stereochemistry') then StereochemistryElement := new as TFhirCodeableConcept
  else if (propName = 'opticalActivity') then OpticalActivityElement := new as TFhirCodeableConcept
  else if (propName = 'molecularFormula') then MolecularFormulaElement := asString(new)
  else if (isMatchingName(propName, 'amount', ['Quantity', 'String'])) then AmountElement := new as TFhirDataType
  else if (propName = 'measurementType') then MeasurementTypeElement := new as TFhirCodeableConcept
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirSubstanceDefinitionMoiety.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirSubstanceDefinitionMoiety.fhirType : string;
begin
  result := 'SubstanceDefinition.moiety';
end;

function TFhirSubstanceDefinitionMoiety.Link : TFhirSubstanceDefinitionMoiety;
begin
  result := TFhirSubstanceDefinitionMoiety(inherited Link);
end;

function TFhirSubstanceDefinitionMoiety.Clone : TFhirSubstanceDefinitionMoiety;
begin
  result := TFhirSubstanceDefinitionMoiety(inherited Clone);
end;

function TFhirSubstanceDefinitionMoiety.equals(other : TObject) : boolean; 
var
  o : TFhirSubstanceDefinitionMoiety;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirSubstanceDefinitionMoiety)) then
    result := false
  else
  begin
    o := TFhirSubstanceDefinitionMoiety(other);
    result := compareDeep(roleElement, o.roleElement, true) and compareDeep(identifierElement, o.identifierElement, true) and 
      compareDeep(nameElement, o.nameElement, true) and compareDeep(stereochemistryElement, o.stereochemistryElement, true) and 
      compareDeep(opticalActivityElement, o.opticalActivityElement, true) and compareDeep(molecularFormulaElement, o.molecularFormulaElement, true) and 
      compareDeep(amountElement, o.amountElement, true) and compareDeep(measurementTypeElement, o.measurementTypeElement, true);
  end;
end;

function TFhirSubstanceDefinitionMoiety.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FRole) and isEmptyProp(FIdentifier) and isEmptyProp(FName) and isEmptyProp(FStereochemistry) and isEmptyProp(FOpticalActivity) and isEmptyProp(FMolecularFormula) and isEmptyProp(FAmount) and isEmptyProp(FMeasurementType);
end;

procedure TFhirSubstanceDefinitionMoiety.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('role');
  fields.add('identifier');
  fields.add('name');
  fields.add('stereochemistry');
  fields.add('opticalActivity');
  fields.add('molecularFormula');
  fields.add('amount[x]');
  fields.add('measurementType');
end;

function TFhirSubstanceDefinitionMoiety.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
end;

procedure TFhirSubstanceDefinitionMoiety.SetRole(value : TFhirCodeableConcept);
begin
  FRole.free;
  FRole := value;
end;

procedure TFhirSubstanceDefinitionMoiety.SetIdentifier(value : TFhirIdentifier);
begin
  FIdentifier.free;
  FIdentifier := value;
end;

procedure TFhirSubstanceDefinitionMoiety.SetName(value : TFhirString);
begin
  FName.free;
  FName := value;
end;

function TFhirSubstanceDefinitionMoiety.GetNameST : String;
begin
  if FName = nil then
    result := ''
  else
    result := FName.value;
end;

procedure TFhirSubstanceDefinitionMoiety.SetNameST(value : String);
begin
  if value <> '' then
  begin
    if FName = nil then
      FName := TFhirString.create;
    FName.value := value
  end
  else if FName <> nil then
    FName.value := '';
end;

procedure TFhirSubstanceDefinitionMoiety.SetStereochemistry(value : TFhirCodeableConcept);
begin
  FStereochemistry.free;
  FStereochemistry := value;
end;

procedure TFhirSubstanceDefinitionMoiety.SetOpticalActivity(value : TFhirCodeableConcept);
begin
  FOpticalActivity.free;
  FOpticalActivity := value;
end;

procedure TFhirSubstanceDefinitionMoiety.SetMolecularFormula(value : TFhirString);
begin
  FMolecularFormula.free;
  FMolecularFormula := value;
end;

function TFhirSubstanceDefinitionMoiety.GetMolecularFormulaST : String;
begin
  if FMolecularFormula = nil then
    result := ''
  else
    result := FMolecularFormula.value;
end;

procedure TFhirSubstanceDefinitionMoiety.SetMolecularFormulaST(value : String);
begin
  if value <> '' then
  begin
    if FMolecularFormula = nil then
      FMolecularFormula := TFhirString.create;
    FMolecularFormula.value := value
  end
  else if FMolecularFormula <> nil then
    FMolecularFormula.value := '';
end;

procedure TFhirSubstanceDefinitionMoiety.SetAmount(value : TFhirDataType);
begin
  FAmount.free;
  FAmount := value;
end;

procedure TFhirSubstanceDefinitionMoiety.SetMeasurementType(value : TFhirCodeableConcept);
begin
  FMeasurementType.free;
  FMeasurementType := value;
end;

{ TFhirSubstanceDefinitionMoietyListEnumerator }

constructor TFhirSubstanceDefinitionMoietyListEnumerator.Create(list : TFhirSubstanceDefinitionMoietyList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirSubstanceDefinitionMoietyListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirSubstanceDefinitionMoietyListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirSubstanceDefinitionMoietyListEnumerator.GetCurrent : TFhirSubstanceDefinitionMoiety;
begin
  Result := FList[FIndex];
end;

function TFhirSubstanceDefinitionMoietyListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirSubstanceDefinitionMoietyList }

function TFhirSubstanceDefinitionMoietyList.AddItem(value: TFhirSubstanceDefinitionMoiety): TFhirSubstanceDefinitionMoiety;
begin
  assert(value.ClassName = 'TFhirSubstanceDefinitionMoiety', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirSubstanceDefinitionMoiety');
  add(value);
  result := value;
end;

function TFhirSubstanceDefinitionMoietyList.Append: TFhirSubstanceDefinitionMoiety;
begin
  result := TFhirSubstanceDefinitionMoiety.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirSubstanceDefinitionMoietyList.ClearItems;
begin
  Clear;
end;

function TFhirSubstanceDefinitionMoietyList.GetEnumerator : TFhirSubstanceDefinitionMoietyListEnumerator;
begin
  result := TFhirSubstanceDefinitionMoietyListEnumerator.Create(self.link);
end;

function TFhirSubstanceDefinitionMoietyList.Clone: TFhirSubstanceDefinitionMoietyList;
begin
  result := TFhirSubstanceDefinitionMoietyList(inherited Clone);
end;

function TFhirSubstanceDefinitionMoietyList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirSubstanceDefinitionMoietyList.GetItemN(index: Integer): TFhirSubstanceDefinitionMoiety;
begin
  result := TFhirSubstanceDefinitionMoiety(ObjectByIndex[index]);
end;

function TFhirSubstanceDefinitionMoietyList.ItemClass: TFslObjectClass;
begin
  result := TFhirSubstanceDefinitionMoiety;
end;
function TFhirSubstanceDefinitionMoietyList.IndexOf(value: TFhirSubstanceDefinitionMoiety): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirSubstanceDefinitionMoietyList.Insert(index: Integer): TFhirSubstanceDefinitionMoiety;
begin
  result := TFhirSubstanceDefinitionMoiety.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirSubstanceDefinitionMoietyList.InsertItem(index: Integer; value: TFhirSubstanceDefinitionMoiety);
begin
  assert(value is TFhirSubstanceDefinitionMoiety);
  Inherited Insert(index, value);
end;

function TFhirSubstanceDefinitionMoietyList.Item(index: Integer): TFhirSubstanceDefinitionMoiety;
begin
  result := TFhirSubstanceDefinitionMoiety(ObjectByIndex[index]);
end;

function TFhirSubstanceDefinitionMoietyList.Link: TFhirSubstanceDefinitionMoietyList;
begin
  result := TFhirSubstanceDefinitionMoietyList(inherited Link);
end;

procedure TFhirSubstanceDefinitionMoietyList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirSubstanceDefinitionMoietyList.SetItemByIndex(index: Integer; value: TFhirSubstanceDefinitionMoiety);
begin
  assert(value is TFhirSubstanceDefinitionMoiety);
  FhirSubstanceDefinitionMoieties[index] := value;
end;

procedure TFhirSubstanceDefinitionMoietyList.SetItemN(index: Integer; value: TFhirSubstanceDefinitionMoiety);
begin
  assert(value is TFhirSubstanceDefinitionMoiety);
  ObjectByIndex[index] := value;
end;

{ TFhirSubstanceDefinitionProperty }

constructor TFhirSubstanceDefinitionProperty.Create;
begin
  inherited;
end;

destructor TFhirSubstanceDefinitionProperty.Destroy;
begin
  FType_.free;
  FValue.free;
  inherited;
end;

procedure TFhirSubstanceDefinitionProperty.Assign(oSource : TFslObject);
begin
  inherited;
  type_ := TFhirSubstanceDefinitionProperty(oSource).type_.Clone;
  value := TFhirSubstanceDefinitionProperty(oSource).value.Clone;
end;

procedure TFhirSubstanceDefinitionProperty.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'type') Then
     list.add(self.link, 'type', FType_.Link);
  if (child_name = 'value[x]') or (child_name = 'value') Then
     list.add(self.link, 'value[x]', FValue.Link);
end;

procedure TFhirSubstanceDefinitionProperty.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'type', 'CodeableConcept', false, TFhirCodeableConcept, FType_.Link));
  oList.add(TFHIRProperty.create(self, 'value[x]', 'CodeableConcept|Quantity|date|boolean|Attachment', false, TFhirDataType, FValue.Link));
end;

function TFhirSubstanceDefinitionProperty.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'type') then
  begin
    Type_ := propValue as TFhirCodeableConcept;
    result := propValue;
  end
  else if (isMatchingName(propName, 'value', ['CodeableConcept', 'Quantity', 'Date', 'Boolean', 'Attachment'])) then
  begin
    Value := propValue as TFhirDataType;
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirSubstanceDefinitionProperty.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirSubstanceDefinitionProperty.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'type') then result := TFhirCodeableConcept.create()
  else if (isMatchingName(propName, 'value', ['CodeableConcept', 'Quantity', 'Date', 'Boolean', 'Attachment'])) then raise EFHIRException.create('Cannot make property Value')
  else result := inherited createPropertyValue(propName);
end;

function TFhirSubstanceDefinitionProperty.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'type') then result := 'CodeableConcept'
  else if (propName = 'value[x]') then result := 'CodeableConcept|Quantity|date|boolean|Attachment'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirSubstanceDefinitionProperty.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'type') then Type_Element := nil
  else if (isMatchingName(propName, 'value', ['CodeableConcept', 'Quantity', 'Date', 'Boolean', 'Attachment'])) then ValueElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirSubstanceDefinitionProperty.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'type') then Type_Element := new as TFhirCodeableConcept
  else if (isMatchingName(propName, 'value', ['CodeableConcept', 'Quantity', 'Date', 'Boolean', 'Attachment'])) then ValueElement := new as TFhirDataType
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirSubstanceDefinitionProperty.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirSubstanceDefinitionProperty.fhirType : string;
begin
  result := 'SubstanceDefinition.property';
end;

function TFhirSubstanceDefinitionProperty.Link : TFhirSubstanceDefinitionProperty;
begin
  result := TFhirSubstanceDefinitionProperty(inherited Link);
end;

function TFhirSubstanceDefinitionProperty.Clone : TFhirSubstanceDefinitionProperty;
begin
  result := TFhirSubstanceDefinitionProperty(inherited Clone);
end;

function TFhirSubstanceDefinitionProperty.equals(other : TObject) : boolean; 
var
  o : TFhirSubstanceDefinitionProperty;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirSubstanceDefinitionProperty)) then
    result := false
  else
  begin
    o := TFhirSubstanceDefinitionProperty(other);
    result := compareDeep(type_Element, o.type_Element, true) and compareDeep(valueElement, o.valueElement, true);
  end;
end;

function TFhirSubstanceDefinitionProperty.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FType_) and isEmptyProp(FValue);
end;

procedure TFhirSubstanceDefinitionProperty.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('type');
  fields.add('value[x]');
end;

function TFhirSubstanceDefinitionProperty.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
end;

procedure TFhirSubstanceDefinitionProperty.SetType_(value : TFhirCodeableConcept);
begin
  FType_.free;
  FType_ := value;
end;

procedure TFhirSubstanceDefinitionProperty.SetValue(value : TFhirDataType);
begin
  FValue.free;
  FValue := value;
end;

{ TFhirSubstanceDefinitionPropertyListEnumerator }

constructor TFhirSubstanceDefinitionPropertyListEnumerator.Create(list : TFhirSubstanceDefinitionPropertyList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirSubstanceDefinitionPropertyListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirSubstanceDefinitionPropertyListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirSubstanceDefinitionPropertyListEnumerator.GetCurrent : TFhirSubstanceDefinitionProperty;
begin
  Result := FList[FIndex];
end;

function TFhirSubstanceDefinitionPropertyListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirSubstanceDefinitionPropertyList }

function TFhirSubstanceDefinitionPropertyList.AddItem(value: TFhirSubstanceDefinitionProperty): TFhirSubstanceDefinitionProperty;
begin
  assert(value.ClassName = 'TFhirSubstanceDefinitionProperty', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirSubstanceDefinitionProperty');
  add(value);
  result := value;
end;

function TFhirSubstanceDefinitionPropertyList.Append: TFhirSubstanceDefinitionProperty;
begin
  result := TFhirSubstanceDefinitionProperty.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirSubstanceDefinitionPropertyList.ClearItems;
begin
  Clear;
end;

function TFhirSubstanceDefinitionPropertyList.GetEnumerator : TFhirSubstanceDefinitionPropertyListEnumerator;
begin
  result := TFhirSubstanceDefinitionPropertyListEnumerator.Create(self.link);
end;

function TFhirSubstanceDefinitionPropertyList.Clone: TFhirSubstanceDefinitionPropertyList;
begin
  result := TFhirSubstanceDefinitionPropertyList(inherited Clone);
end;

function TFhirSubstanceDefinitionPropertyList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirSubstanceDefinitionPropertyList.GetItemN(index: Integer): TFhirSubstanceDefinitionProperty;
begin
  result := TFhirSubstanceDefinitionProperty(ObjectByIndex[index]);
end;

function TFhirSubstanceDefinitionPropertyList.ItemClass: TFslObjectClass;
begin
  result := TFhirSubstanceDefinitionProperty;
end;
function TFhirSubstanceDefinitionPropertyList.IndexOf(value: TFhirSubstanceDefinitionProperty): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirSubstanceDefinitionPropertyList.Insert(index: Integer): TFhirSubstanceDefinitionProperty;
begin
  result := TFhirSubstanceDefinitionProperty.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirSubstanceDefinitionPropertyList.InsertItem(index: Integer; value: TFhirSubstanceDefinitionProperty);
begin
  assert(value is TFhirSubstanceDefinitionProperty);
  Inherited Insert(index, value);
end;

function TFhirSubstanceDefinitionPropertyList.Item(index: Integer): TFhirSubstanceDefinitionProperty;
begin
  result := TFhirSubstanceDefinitionProperty(ObjectByIndex[index]);
end;

function TFhirSubstanceDefinitionPropertyList.Link: TFhirSubstanceDefinitionPropertyList;
begin
  result := TFhirSubstanceDefinitionPropertyList(inherited Link);
end;

procedure TFhirSubstanceDefinitionPropertyList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirSubstanceDefinitionPropertyList.SetItemByIndex(index: Integer; value: TFhirSubstanceDefinitionProperty);
begin
  assert(value is TFhirSubstanceDefinitionProperty);
  FhirSubstanceDefinitionProperties[index] := value;
end;

procedure TFhirSubstanceDefinitionPropertyList.SetItemN(index: Integer; value: TFhirSubstanceDefinitionProperty);
begin
  assert(value is TFhirSubstanceDefinitionProperty);
  ObjectByIndex[index] := value;
end;

{ TFhirSubstanceDefinitionMolecularWeight }

constructor TFhirSubstanceDefinitionMolecularWeight.Create;
begin
  inherited;
end;

destructor TFhirSubstanceDefinitionMolecularWeight.Destroy;
begin
  FMethod.free;
  FType_.free;
  FAmount.free;
  inherited;
end;

procedure TFhirSubstanceDefinitionMolecularWeight.Assign(oSource : TFslObject);
begin
  inherited;
  method := TFhirSubstanceDefinitionMolecularWeight(oSource).method.Clone;
  type_ := TFhirSubstanceDefinitionMolecularWeight(oSource).type_.Clone;
  amount := TFhirSubstanceDefinitionMolecularWeight(oSource).amount.Clone;
end;

procedure TFhirSubstanceDefinitionMolecularWeight.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'method') Then
     list.add(self.link, 'method', FMethod.Link);
  if (child_name = 'type') Then
     list.add(self.link, 'type', FType_.Link);
  if (child_name = 'amount') Then
     list.add(self.link, 'amount', FAmount.Link);
end;

procedure TFhirSubstanceDefinitionMolecularWeight.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'method', 'CodeableConcept', false, TFhirCodeableConcept, FMethod.Link));
  oList.add(TFHIRProperty.create(self, 'type', 'CodeableConcept', false, TFhirCodeableConcept, FType_.Link));
  oList.add(TFHIRProperty.create(self, 'amount', 'Quantity', false, TFhirQuantity, FAmount.Link));
end;

function TFhirSubstanceDefinitionMolecularWeight.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'method') then
  begin
    Method := propValue as TFhirCodeableConcept;
    result := propValue;
  end
  else if (propName = 'type') then
  begin
    Type_ := propValue as TFhirCodeableConcept;
    result := propValue;
  end
  else if (propName = 'amount') then
  begin
    Amount := propValue as TFhirQuantity;
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirSubstanceDefinitionMolecularWeight.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirSubstanceDefinitionMolecularWeight.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'method') then result := TFhirCodeableConcept.create()
  else if (propName = 'type') then result := TFhirCodeableConcept.create()
  else if (propName = 'amount') then result := TFhirQuantity.create()
  else result := inherited createPropertyValue(propName);
end;

function TFhirSubstanceDefinitionMolecularWeight.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'method') then result := 'CodeableConcept'
  else if (propName = 'type') then result := 'CodeableConcept'
  else if (propName = 'amount') then result := 'Quantity'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirSubstanceDefinitionMolecularWeight.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'method') then MethodElement := nil
  else if (propName = 'type') then Type_Element := nil
  else if (propName = 'amount') then AmountElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirSubstanceDefinitionMolecularWeight.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'method') then MethodElement := new as TFhirCodeableConcept
  else if (propName = 'type') then Type_Element := new as TFhirCodeableConcept
  else if (propName = 'amount') then AmountElement := new as TFhirQuantity
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirSubstanceDefinitionMolecularWeight.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirSubstanceDefinitionMolecularWeight.fhirType : string;
begin
  result := 'SubstanceDefinition.molecularWeight';
end;

function TFhirSubstanceDefinitionMolecularWeight.Link : TFhirSubstanceDefinitionMolecularWeight;
begin
  result := TFhirSubstanceDefinitionMolecularWeight(inherited Link);
end;

function TFhirSubstanceDefinitionMolecularWeight.Clone : TFhirSubstanceDefinitionMolecularWeight;
begin
  result := TFhirSubstanceDefinitionMolecularWeight(inherited Clone);
end;

function TFhirSubstanceDefinitionMolecularWeight.equals(other : TObject) : boolean; 
var
  o : TFhirSubstanceDefinitionMolecularWeight;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirSubstanceDefinitionMolecularWeight)) then
    result := false
  else
  begin
    o := TFhirSubstanceDefinitionMolecularWeight(other);
    result := compareDeep(methodElement, o.methodElement, true) and compareDeep(type_Element, o.type_Element, true) and 
      compareDeep(amountElement, o.amountElement, true);
  end;
end;

function TFhirSubstanceDefinitionMolecularWeight.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FMethod) and isEmptyProp(FType_) and isEmptyProp(FAmount);
end;

procedure TFhirSubstanceDefinitionMolecularWeight.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('method');
  fields.add('type');
  fields.add('amount');
end;

function TFhirSubstanceDefinitionMolecularWeight.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
end;

procedure TFhirSubstanceDefinitionMolecularWeight.SetMethod(value : TFhirCodeableConcept);
begin
  FMethod.free;
  FMethod := value;
end;

procedure TFhirSubstanceDefinitionMolecularWeight.SetType_(value : TFhirCodeableConcept);
begin
  FType_.free;
  FType_ := value;
end;

procedure TFhirSubstanceDefinitionMolecularWeight.SetAmount(value : TFhirQuantity);
begin
  FAmount.free;
  FAmount := value;
end;

{ TFhirSubstanceDefinitionMolecularWeightListEnumerator }

constructor TFhirSubstanceDefinitionMolecularWeightListEnumerator.Create(list : TFhirSubstanceDefinitionMolecularWeightList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirSubstanceDefinitionMolecularWeightListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirSubstanceDefinitionMolecularWeightListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirSubstanceDefinitionMolecularWeightListEnumerator.GetCurrent : TFhirSubstanceDefinitionMolecularWeight;
begin
  Result := FList[FIndex];
end;

function TFhirSubstanceDefinitionMolecularWeightListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirSubstanceDefinitionMolecularWeightList }

function TFhirSubstanceDefinitionMolecularWeightList.AddItem(value: TFhirSubstanceDefinitionMolecularWeight): TFhirSubstanceDefinitionMolecularWeight;
begin
  assert(value.ClassName = 'TFhirSubstanceDefinitionMolecularWeight', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirSubstanceDefinitionMolecularWeight');
  add(value);
  result := value;
end;

function TFhirSubstanceDefinitionMolecularWeightList.Append: TFhirSubstanceDefinitionMolecularWeight;
begin
  result := TFhirSubstanceDefinitionMolecularWeight.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirSubstanceDefinitionMolecularWeightList.ClearItems;
begin
  Clear;
end;

function TFhirSubstanceDefinitionMolecularWeightList.GetEnumerator : TFhirSubstanceDefinitionMolecularWeightListEnumerator;
begin
  result := TFhirSubstanceDefinitionMolecularWeightListEnumerator.Create(self.link);
end;

function TFhirSubstanceDefinitionMolecularWeightList.Clone: TFhirSubstanceDefinitionMolecularWeightList;
begin
  result := TFhirSubstanceDefinitionMolecularWeightList(inherited Clone);
end;

function TFhirSubstanceDefinitionMolecularWeightList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirSubstanceDefinitionMolecularWeightList.GetItemN(index: Integer): TFhirSubstanceDefinitionMolecularWeight;
begin
  result := TFhirSubstanceDefinitionMolecularWeight(ObjectByIndex[index]);
end;

function TFhirSubstanceDefinitionMolecularWeightList.ItemClass: TFslObjectClass;
begin
  result := TFhirSubstanceDefinitionMolecularWeight;
end;
function TFhirSubstanceDefinitionMolecularWeightList.IndexOf(value: TFhirSubstanceDefinitionMolecularWeight): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirSubstanceDefinitionMolecularWeightList.Insert(index: Integer): TFhirSubstanceDefinitionMolecularWeight;
begin
  result := TFhirSubstanceDefinitionMolecularWeight.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirSubstanceDefinitionMolecularWeightList.InsertItem(index: Integer; value: TFhirSubstanceDefinitionMolecularWeight);
begin
  assert(value is TFhirSubstanceDefinitionMolecularWeight);
  Inherited Insert(index, value);
end;

function TFhirSubstanceDefinitionMolecularWeightList.Item(index: Integer): TFhirSubstanceDefinitionMolecularWeight;
begin
  result := TFhirSubstanceDefinitionMolecularWeight(ObjectByIndex[index]);
end;

function TFhirSubstanceDefinitionMolecularWeightList.Link: TFhirSubstanceDefinitionMolecularWeightList;
begin
  result := TFhirSubstanceDefinitionMolecularWeightList(inherited Link);
end;

procedure TFhirSubstanceDefinitionMolecularWeightList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirSubstanceDefinitionMolecularWeightList.SetItemByIndex(index: Integer; value: TFhirSubstanceDefinitionMolecularWeight);
begin
  assert(value is TFhirSubstanceDefinitionMolecularWeight);
  FhirSubstanceDefinitionMolecularWeights[index] := value;
end;

procedure TFhirSubstanceDefinitionMolecularWeightList.SetItemN(index: Integer; value: TFhirSubstanceDefinitionMolecularWeight);
begin
  assert(value is TFhirSubstanceDefinitionMolecularWeight);
  ObjectByIndex[index] := value;
end;

{ TFhirSubstanceDefinitionStructure }

constructor TFhirSubstanceDefinitionStructure.Create;
begin
  inherited;
end;

destructor TFhirSubstanceDefinitionStructure.Destroy;
begin
  FStereochemistry.free;
  FOpticalActivity.free;
  FMolecularFormula.free;
  FMolecularFormulaByMoiety.free;
  FMolecularWeight.free;
  FTechniqueList.Free;
  FSourceDocumentList.Free;
  FRepresentationList.Free;
  inherited;
end;

procedure TFhirSubstanceDefinitionStructure.Assign(oSource : TFslObject);
begin
  inherited;
  stereochemistry := TFhirSubstanceDefinitionStructure(oSource).stereochemistry.Clone;
  opticalActivity := TFhirSubstanceDefinitionStructure(oSource).opticalActivity.Clone;
  molecularFormulaElement := TFhirSubstanceDefinitionStructure(oSource).molecularFormulaElement.Clone;
  molecularFormulaByMoietyElement := TFhirSubstanceDefinitionStructure(oSource).molecularFormulaByMoietyElement.Clone;
  molecularWeight := TFhirSubstanceDefinitionStructure(oSource).molecularWeight.Clone;
  if (TFhirSubstanceDefinitionStructure(oSource).FTechniqueList = nil) then
  begin
    FTechniqueList.free;
    FTechniqueList := nil;
  end
  else
  begin
    if FTechniqueList = nil then
      FTechniqueList := TFhirCodeableConceptList.Create;
    FTechniqueList.Assign(TFhirSubstanceDefinitionStructure(oSource).FTechniqueList);
  end;
  if (TFhirSubstanceDefinitionStructure(oSource).FSourceDocumentList = nil) then
  begin
    FSourceDocumentList.free;
    FSourceDocumentList := nil;
  end
  else
  begin
    if FSourceDocumentList = nil then
      FSourceDocumentList := TFhirReferenceList.Create;
    FSourceDocumentList.Assign(TFhirSubstanceDefinitionStructure(oSource).FSourceDocumentList);
  end;
  if (TFhirSubstanceDefinitionStructure(oSource).FRepresentationList = nil) then
  begin
    FRepresentationList.free;
    FRepresentationList := nil;
  end
  else
  begin
    if FRepresentationList = nil then
      FRepresentationList := TFhirSubstanceDefinitionStructureRepresentationList.Create;
    FRepresentationList.Assign(TFhirSubstanceDefinitionStructure(oSource).FRepresentationList);
  end;
end;

procedure TFhirSubstanceDefinitionStructure.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'stereochemistry') Then
     list.add(self.link, 'stereochemistry', FStereochemistry.Link);
  if (child_name = 'opticalActivity') Then
     list.add(self.link, 'opticalActivity', FOpticalActivity.Link);
  if (child_name = 'molecularFormula') Then
     list.add(self.link, 'molecularFormula', FMolecularFormula.Link);
  if (child_name = 'molecularFormulaByMoiety') Then
     list.add(self.link, 'molecularFormulaByMoiety', FMolecularFormulaByMoiety.Link);
  if (child_name = 'molecularWeight') Then
     list.add(self.link, 'molecularWeight', FMolecularWeight.Link);
  if (child_name = 'technique') Then
    list.addAll(self, 'technique', FTechniqueList);
  if (child_name = 'sourceDocument') Then
    list.addAll(self, 'sourceDocument', FSourceDocumentList);
  if (child_name = 'representation') Then
    list.addAll(self, 'representation', FRepresentationList);
end;

procedure TFhirSubstanceDefinitionStructure.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'stereochemistry', 'CodeableConcept', false, TFhirCodeableConcept, FStereochemistry.Link));
  oList.add(TFHIRProperty.create(self, 'opticalActivity', 'CodeableConcept', false, TFhirCodeableConcept, FOpticalActivity.Link));
  oList.add(TFHIRProperty.create(self, 'molecularFormula', 'string', false, TFhirString, FMolecularFormula.Link));
  oList.add(TFHIRProperty.create(self, 'molecularFormulaByMoiety', 'string', false, TFhirString, FMolecularFormulaByMoiety.Link));
  oList.add(TFHIRProperty.create(self, 'molecularWeight', '', false, TFhirSubstanceDefinitionMolecularWeight, FMolecularWeight.Link));
  oList.add(TFHIRProperty.create(self, 'technique', 'CodeableConcept', true, TFhirCodeableConcept, FTechniqueList.Link));
  oList.add(TFHIRProperty.create(self, 'sourceDocument', 'Reference', true, TFhirReference, FSourceDocumentList.Link));
  oList.add(TFHIRProperty.create(self, 'representation', 'BackboneElement', true, TFhirSubstanceDefinitionStructureRepresentation, FRepresentationList.Link));
end;

function TFhirSubstanceDefinitionStructure.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'stereochemistry') then
  begin
    Stereochemistry := propValue as TFhirCodeableConcept;
    result := propValue;
  end
  else if (propName = 'opticalActivity') then
  begin
    OpticalActivity := propValue as TFhirCodeableConcept;
    result := propValue;
  end
  else if (propName = 'molecularFormula') then
  begin
    MolecularFormulaElement := asString(propValue);
    result := propValue;
  end
  else if (propName = 'molecularFormulaByMoiety') then
  begin
    MolecularFormulaByMoietyElement := asString(propValue);
    result := propValue;
  end
  else if (propName = 'molecularWeight') then
  begin
    MolecularWeight := propValue as TFhirSubstanceDefinitionMolecularWeight;
    result := propValue;
  end
  else if (propName = 'technique') then
  begin
    TechniqueList.add(propValue as TFhirCodeableConcept);
    result := propValue;
  end
  else if (propName = 'sourceDocument') then
  begin
    SourceDocumentList.add(propValue as TFhirReference);
    result := propValue;
  end
  else if (propName = 'representation') then
  begin
    RepresentationList.add(propValue as TFhirSubstanceDefinitionStructureRepresentation);
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirSubstanceDefinitionStructure.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'technique') then TechniqueList.insertItem(index, propValue as TFhirCodeableConcept)
  else if (propName = 'sourceDocument') then SourceDocumentList.insertItem(index, propValue as TFhirReference)
  else if (propName = 'representation') then RepresentationList.insertItem(index, propValue as TFhirSubstanceDefinitionStructureRepresentation)
  else inherited;
end;

function TFhirSubstanceDefinitionStructure.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'stereochemistry') then result := TFhirCodeableConcept.create()
  else if (propName = 'opticalActivity') then result := TFhirCodeableConcept.create()
  else if (propName = 'molecularFormula') then result := TFhirString.create()
  else if (propName = 'molecularFormulaByMoiety') then result := TFhirString.create()
  else if (propName = 'molecularWeight') then result := TFhirSubstanceDefinitionMolecularWeight.create()
  else if (propName = 'technique') then result := TechniqueList.new()
  else if (propName = 'sourceDocument') then result := SourceDocumentList.new()
  else if (propName = 'representation') then result := RepresentationList.new()
  else result := inherited createPropertyValue(propName);
end;

function TFhirSubstanceDefinitionStructure.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'stereochemistry') then result := 'CodeableConcept'
  else if (propName = 'opticalActivity') then result := 'CodeableConcept'
  else if (propName = 'molecularFormula') then result := 'string'
  else if (propName = 'molecularFormulaByMoiety') then result := 'string'
  else if (propName = 'molecularWeight') then result := ''
  else if (propName = 'technique') then result := 'CodeableConcept'
  else if (propName = 'sourceDocument') then result := 'Reference'
  else if (propName = 'representation') then result := 'BackboneElement'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirSubstanceDefinitionStructure.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'stereochemistry') then StereochemistryElement := nil
  else if (propName = 'opticalActivity') then OpticalActivityElement := nil
  else if (propName = 'molecularFormula') then MolecularFormulaElement := nil
  else if (propName = 'molecularFormulaByMoiety') then MolecularFormulaByMoietyElement := nil
  else if (propName = 'molecularWeight') then MolecularWeightElement := nil
  else if (propName = 'technique') then deletePropertyValue('technique', TechniqueList, value)
  else if (propName = 'sourceDocument') then deletePropertyValue('sourceDocument', SourceDocumentList, value)
  else if (propName = 'representation') then deletePropertyValue('representation', RepresentationList, value)
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirSubstanceDefinitionStructure.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'stereochemistry') then StereochemistryElement := new as TFhirCodeableConcept
  else if (propName = 'opticalActivity') then OpticalActivityElement := new as TFhirCodeableConcept
  else if (propName = 'molecularFormula') then MolecularFormulaElement := asString(new)
  else if (propName = 'molecularFormulaByMoiety') then MolecularFormulaByMoietyElement := asString(new)
  else if (propName = 'molecularWeight') then MolecularWeightElement := new as TFhirSubstanceDefinitionMolecularWeight
  else if (propName = 'technique') then replacePropertyValue('technique', TechniqueList, existing, new)
  else if (propName = 'sourceDocument') then replacePropertyValue('sourceDocument', SourceDocumentList, existing, new)
  else if (propName = 'representation') then replacePropertyValue('representation', RepresentationList, existing, new)
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirSubstanceDefinitionStructure.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'technique') then TechniqueList.move(source, destination)
  else if (propName = 'sourceDocument') then SourceDocumentList.move(source, destination)
  else if (propName = 'representation') then RepresentationList.move(source, destination)
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirSubstanceDefinitionStructure.fhirType : string;
begin
  result := 'SubstanceDefinition.structure';
end;

function TFhirSubstanceDefinitionStructure.Link : TFhirSubstanceDefinitionStructure;
begin
  result := TFhirSubstanceDefinitionStructure(inherited Link);
end;

function TFhirSubstanceDefinitionStructure.Clone : TFhirSubstanceDefinitionStructure;
begin
  result := TFhirSubstanceDefinitionStructure(inherited Clone);
end;

function TFhirSubstanceDefinitionStructure.equals(other : TObject) : boolean; 
var
  o : TFhirSubstanceDefinitionStructure;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirSubstanceDefinitionStructure)) then
    result := false
  else
  begin
    o := TFhirSubstanceDefinitionStructure(other);
    result := compareDeep(stereochemistryElement, o.stereochemistryElement, true) and 
      compareDeep(opticalActivityElement, o.opticalActivityElement, true) and compareDeep(molecularFormulaElement, o.molecularFormulaElement, true) and 
      compareDeep(molecularFormulaByMoietyElement, o.molecularFormulaByMoietyElement, true) and 
      compareDeep(molecularWeightElement, o.molecularWeightElement, true) and compareDeep(techniqueList, o.techniqueList, true) and 
      compareDeep(sourceDocumentList, o.sourceDocumentList, true) and compareDeep(representationList, o.representationList, true);
  end;
end;

function TFhirSubstanceDefinitionStructure.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FStereochemistry) and isEmptyProp(FOpticalActivity) and isEmptyProp(FMolecularFormula) and isEmptyProp(FMolecularFormulaByMoiety) and isEmptyProp(FMolecularWeight) and isEmptyProp(FtechniqueList) and isEmptyProp(FsourceDocumentList) and isEmptyProp(FrepresentationList);
end;

procedure TFhirSubstanceDefinitionStructure.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('stereochemistry');
  fields.add('opticalActivity');
  fields.add('molecularFormula');
  fields.add('molecularFormulaByMoiety');
  fields.add('molecularWeight');
  fields.add('technique');
  fields.add('sourceDocument');
  fields.add('representation');
end;

function TFhirSubstanceDefinitionStructure.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
  inc(result, FTechniqueList.sizeInBytes(magic));
  inc(result, FSourceDocumentList.sizeInBytes(magic));
  inc(result, FRepresentationList.sizeInBytes(magic));
end;

procedure TFhirSubstanceDefinitionStructure.SetStereochemistry(value : TFhirCodeableConcept);
begin
  FStereochemistry.free;
  FStereochemistry := value;
end;

procedure TFhirSubstanceDefinitionStructure.SetOpticalActivity(value : TFhirCodeableConcept);
begin
  FOpticalActivity.free;
  FOpticalActivity := value;
end;

procedure TFhirSubstanceDefinitionStructure.SetMolecularFormula(value : TFhirString);
begin
  FMolecularFormula.free;
  FMolecularFormula := value;
end;

function TFhirSubstanceDefinitionStructure.GetMolecularFormulaST : String;
begin
  if FMolecularFormula = nil then
    result := ''
  else
    result := FMolecularFormula.value;
end;

procedure TFhirSubstanceDefinitionStructure.SetMolecularFormulaST(value : String);
begin
  if value <> '' then
  begin
    if FMolecularFormula = nil then
      FMolecularFormula := TFhirString.create;
    FMolecularFormula.value := value
  end
  else if FMolecularFormula <> nil then
    FMolecularFormula.value := '';
end;

procedure TFhirSubstanceDefinitionStructure.SetMolecularFormulaByMoiety(value : TFhirString);
begin
  FMolecularFormulaByMoiety.free;
  FMolecularFormulaByMoiety := value;
end;

function TFhirSubstanceDefinitionStructure.GetMolecularFormulaByMoietyST : String;
begin
  if FMolecularFormulaByMoiety = nil then
    result := ''
  else
    result := FMolecularFormulaByMoiety.value;
end;

procedure TFhirSubstanceDefinitionStructure.SetMolecularFormulaByMoietyST(value : String);
begin
  if value <> '' then
  begin
    if FMolecularFormulaByMoiety = nil then
      FMolecularFormulaByMoiety := TFhirString.create;
    FMolecularFormulaByMoiety.value := value
  end
  else if FMolecularFormulaByMoiety <> nil then
    FMolecularFormulaByMoiety.value := '';
end;

procedure TFhirSubstanceDefinitionStructure.SetMolecularWeight(value : TFhirSubstanceDefinitionMolecularWeight);
begin
  FMolecularWeight.free;
  FMolecularWeight := value;
end;

function TFhirSubstanceDefinitionStructure.GetTechniqueList : TFhirCodeableConceptList;
begin
  if FTechniqueList = nil then
    FTechniqueList := TFhirCodeableConceptList.Create;
  result := FTechniqueList;
end;

function TFhirSubstanceDefinitionStructure.GetHasTechniqueList : boolean;
begin
  result := (FTechniqueList <> nil) and (FTechniqueList.count > 0);
end;

function TFhirSubstanceDefinitionStructure.GetSourceDocumentList : TFhirReferenceList;
begin
  if FSourceDocumentList = nil then
    FSourceDocumentList := TFhirReferenceList.Create;
  result := FSourceDocumentList;
end;

function TFhirSubstanceDefinitionStructure.GetHasSourceDocumentList : boolean;
begin
  result := (FSourceDocumentList <> nil) and (FSourceDocumentList.count > 0);
end;

function TFhirSubstanceDefinitionStructure.GetRepresentationList : TFhirSubstanceDefinitionStructureRepresentationList;
begin
  if FRepresentationList = nil then
    FRepresentationList := TFhirSubstanceDefinitionStructureRepresentationList.Create;
  result := FRepresentationList;
end;

function TFhirSubstanceDefinitionStructure.GetHasRepresentationList : boolean;
begin
  result := (FRepresentationList <> nil) and (FRepresentationList.count > 0);
end;

{ TFhirSubstanceDefinitionStructureListEnumerator }

constructor TFhirSubstanceDefinitionStructureListEnumerator.Create(list : TFhirSubstanceDefinitionStructureList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirSubstanceDefinitionStructureListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirSubstanceDefinitionStructureListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirSubstanceDefinitionStructureListEnumerator.GetCurrent : TFhirSubstanceDefinitionStructure;
begin
  Result := FList[FIndex];
end;

function TFhirSubstanceDefinitionStructureListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirSubstanceDefinitionStructureList }

function TFhirSubstanceDefinitionStructureList.AddItem(value: TFhirSubstanceDefinitionStructure): TFhirSubstanceDefinitionStructure;
begin
  assert(value.ClassName = 'TFhirSubstanceDefinitionStructure', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirSubstanceDefinitionStructure');
  add(value);
  result := value;
end;

function TFhirSubstanceDefinitionStructureList.Append: TFhirSubstanceDefinitionStructure;
begin
  result := TFhirSubstanceDefinitionStructure.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirSubstanceDefinitionStructureList.ClearItems;
begin
  Clear;
end;

function TFhirSubstanceDefinitionStructureList.GetEnumerator : TFhirSubstanceDefinitionStructureListEnumerator;
begin
  result := TFhirSubstanceDefinitionStructureListEnumerator.Create(self.link);
end;

function TFhirSubstanceDefinitionStructureList.Clone: TFhirSubstanceDefinitionStructureList;
begin
  result := TFhirSubstanceDefinitionStructureList(inherited Clone);
end;

function TFhirSubstanceDefinitionStructureList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirSubstanceDefinitionStructureList.GetItemN(index: Integer): TFhirSubstanceDefinitionStructure;
begin
  result := TFhirSubstanceDefinitionStructure(ObjectByIndex[index]);
end;

function TFhirSubstanceDefinitionStructureList.ItemClass: TFslObjectClass;
begin
  result := TFhirSubstanceDefinitionStructure;
end;
function TFhirSubstanceDefinitionStructureList.IndexOf(value: TFhirSubstanceDefinitionStructure): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirSubstanceDefinitionStructureList.Insert(index: Integer): TFhirSubstanceDefinitionStructure;
begin
  result := TFhirSubstanceDefinitionStructure.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirSubstanceDefinitionStructureList.InsertItem(index: Integer; value: TFhirSubstanceDefinitionStructure);
begin
  assert(value is TFhirSubstanceDefinitionStructure);
  Inherited Insert(index, value);
end;

function TFhirSubstanceDefinitionStructureList.Item(index: Integer): TFhirSubstanceDefinitionStructure;
begin
  result := TFhirSubstanceDefinitionStructure(ObjectByIndex[index]);
end;

function TFhirSubstanceDefinitionStructureList.Link: TFhirSubstanceDefinitionStructureList;
begin
  result := TFhirSubstanceDefinitionStructureList(inherited Link);
end;

procedure TFhirSubstanceDefinitionStructureList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirSubstanceDefinitionStructureList.SetItemByIndex(index: Integer; value: TFhirSubstanceDefinitionStructure);
begin
  assert(value is TFhirSubstanceDefinitionStructure);
  FhirSubstanceDefinitionStructures[index] := value;
end;

procedure TFhirSubstanceDefinitionStructureList.SetItemN(index: Integer; value: TFhirSubstanceDefinitionStructure);
begin
  assert(value is TFhirSubstanceDefinitionStructure);
  ObjectByIndex[index] := value;
end;

{ TFhirSubstanceDefinitionStructureRepresentation }

constructor TFhirSubstanceDefinitionStructureRepresentation.Create;
begin
  inherited;
end;

destructor TFhirSubstanceDefinitionStructureRepresentation.Destroy;
begin
  FType_.free;
  FRepresentation.free;
  FFormat.free;
  FDocument.free;
  inherited;
end;

procedure TFhirSubstanceDefinitionStructureRepresentation.Assign(oSource : TFslObject);
begin
  inherited;
  type_ := TFhirSubstanceDefinitionStructureRepresentation(oSource).type_.Clone;
  representationElement := TFhirSubstanceDefinitionStructureRepresentation(oSource).representationElement.Clone;
  format := TFhirSubstanceDefinitionStructureRepresentation(oSource).format.Clone;
  document := TFhirSubstanceDefinitionStructureRepresentation(oSource).document.Clone;
end;

procedure TFhirSubstanceDefinitionStructureRepresentation.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'type') Then
     list.add(self.link, 'type', FType_.Link);
  if (child_name = 'representation') Then
     list.add(self.link, 'representation', FRepresentation.Link);
  if (child_name = 'format') Then
     list.add(self.link, 'format', FFormat.Link);
  if (child_name = 'document') Then
     list.add(self.link, 'document', FDocument.Link);
end;

procedure TFhirSubstanceDefinitionStructureRepresentation.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'type', 'CodeableConcept', false, TFhirCodeableConcept, FType_.Link));
  oList.add(TFHIRProperty.create(self, 'representation', 'string', false, TFhirString, FRepresentation.Link));
  oList.add(TFHIRProperty.create(self, 'format', 'CodeableConcept', false, TFhirCodeableConcept, FFormat.Link));
  oList.add(TFHIRProperty.create(self, 'document', 'Reference', false, TFhirReference, FDocument.Link));
end;

function TFhirSubstanceDefinitionStructureRepresentation.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'type') then
  begin
    Type_ := propValue as TFhirCodeableConcept;
    result := propValue;
  end
  else if (propName = 'representation') then
  begin
    RepresentationElement := asString(propValue);
    result := propValue;
  end
  else if (propName = 'format') then
  begin
    Format := propValue as TFhirCodeableConcept;
    result := propValue;
  end
  else if (propName = 'document') then
  begin
    Document := propValue as TFhirReference;
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirSubstanceDefinitionStructureRepresentation.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirSubstanceDefinitionStructureRepresentation.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'type') then result := TFhirCodeableConcept.create()
  else if (propName = 'representation') then result := TFhirString.create()
  else if (propName = 'format') then result := TFhirCodeableConcept.create()
  else if (propName = 'document') then result := TFhirReference.create()
  else result := inherited createPropertyValue(propName);
end;

function TFhirSubstanceDefinitionStructureRepresentation.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'type') then result := 'CodeableConcept'
  else if (propName = 'representation') then result := 'string'
  else if (propName = 'format') then result := 'CodeableConcept'
  else if (propName = 'document') then result := 'Reference'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirSubstanceDefinitionStructureRepresentation.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'type') then Type_Element := nil
  else if (propName = 'representation') then RepresentationElement := nil
  else if (propName = 'format') then FormatElement := nil
  else if (propName = 'document') then DocumentElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirSubstanceDefinitionStructureRepresentation.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'type') then Type_Element := new as TFhirCodeableConcept
  else if (propName = 'representation') then RepresentationElement := asString(new)
  else if (propName = 'format') then FormatElement := new as TFhirCodeableConcept
  else if (propName = 'document') then DocumentElement := new as TFhirReference
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirSubstanceDefinitionStructureRepresentation.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirSubstanceDefinitionStructureRepresentation.fhirType : string;
begin
  result := 'SubstanceDefinition.structure.representation';
end;

function TFhirSubstanceDefinitionStructureRepresentation.Link : TFhirSubstanceDefinitionStructureRepresentation;
begin
  result := TFhirSubstanceDefinitionStructureRepresentation(inherited Link);
end;

function TFhirSubstanceDefinitionStructureRepresentation.Clone : TFhirSubstanceDefinitionStructureRepresentation;
begin
  result := TFhirSubstanceDefinitionStructureRepresentation(inherited Clone);
end;

function TFhirSubstanceDefinitionStructureRepresentation.equals(other : TObject) : boolean; 
var
  o : TFhirSubstanceDefinitionStructureRepresentation;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirSubstanceDefinitionStructureRepresentation)) then
    result := false
  else
  begin
    o := TFhirSubstanceDefinitionStructureRepresentation(other);
    result := compareDeep(type_Element, o.type_Element, true) and compareDeep(representationElement, o.representationElement, true) and 
      compareDeep(formatElement, o.formatElement, true) and compareDeep(documentElement, o.documentElement, true);
  end;
end;

function TFhirSubstanceDefinitionStructureRepresentation.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FType_) and isEmptyProp(FRepresentation) and isEmptyProp(FFormat) and isEmptyProp(FDocument);
end;

procedure TFhirSubstanceDefinitionStructureRepresentation.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('type');
  fields.add('representation');
  fields.add('format');
  fields.add('document');
end;

function TFhirSubstanceDefinitionStructureRepresentation.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
end;

procedure TFhirSubstanceDefinitionStructureRepresentation.SetType_(value : TFhirCodeableConcept);
begin
  FType_.free;
  FType_ := value;
end;

procedure TFhirSubstanceDefinitionStructureRepresentation.SetRepresentation(value : TFhirString);
begin
  FRepresentation.free;
  FRepresentation := value;
end;

function TFhirSubstanceDefinitionStructureRepresentation.GetRepresentationST : String;
begin
  if FRepresentation = nil then
    result := ''
  else
    result := FRepresentation.value;
end;

procedure TFhirSubstanceDefinitionStructureRepresentation.SetRepresentationST(value : String);
begin
  if value <> '' then
  begin
    if FRepresentation = nil then
      FRepresentation := TFhirString.create;
    FRepresentation.value := value
  end
  else if FRepresentation <> nil then
    FRepresentation.value := '';
end;

procedure TFhirSubstanceDefinitionStructureRepresentation.SetFormat(value : TFhirCodeableConcept);
begin
  FFormat.free;
  FFormat := value;
end;

procedure TFhirSubstanceDefinitionStructureRepresentation.SetDocument(value : TFhirReference);
begin
  FDocument.free;
  FDocument := value;
end;

{ TFhirSubstanceDefinitionStructureRepresentationListEnumerator }

constructor TFhirSubstanceDefinitionStructureRepresentationListEnumerator.Create(list : TFhirSubstanceDefinitionStructureRepresentationList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirSubstanceDefinitionStructureRepresentationListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirSubstanceDefinitionStructureRepresentationListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirSubstanceDefinitionStructureRepresentationListEnumerator.GetCurrent : TFhirSubstanceDefinitionStructureRepresentation;
begin
  Result := FList[FIndex];
end;

function TFhirSubstanceDefinitionStructureRepresentationListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirSubstanceDefinitionStructureRepresentationList }

function TFhirSubstanceDefinitionStructureRepresentationList.AddItem(value: TFhirSubstanceDefinitionStructureRepresentation): TFhirSubstanceDefinitionStructureRepresentation;
begin
  assert(value.ClassName = 'TFhirSubstanceDefinitionStructureRepresentation', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirSubstanceDefinitionStructureRepresentation');
  add(value);
  result := value;
end;

function TFhirSubstanceDefinitionStructureRepresentationList.Append: TFhirSubstanceDefinitionStructureRepresentation;
begin
  result := TFhirSubstanceDefinitionStructureRepresentation.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirSubstanceDefinitionStructureRepresentationList.ClearItems;
begin
  Clear;
end;

function TFhirSubstanceDefinitionStructureRepresentationList.GetEnumerator : TFhirSubstanceDefinitionStructureRepresentationListEnumerator;
begin
  result := TFhirSubstanceDefinitionStructureRepresentationListEnumerator.Create(self.link);
end;

function TFhirSubstanceDefinitionStructureRepresentationList.Clone: TFhirSubstanceDefinitionStructureRepresentationList;
begin
  result := TFhirSubstanceDefinitionStructureRepresentationList(inherited Clone);
end;

function TFhirSubstanceDefinitionStructureRepresentationList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirSubstanceDefinitionStructureRepresentationList.GetItemN(index: Integer): TFhirSubstanceDefinitionStructureRepresentation;
begin
  result := TFhirSubstanceDefinitionStructureRepresentation(ObjectByIndex[index]);
end;

function TFhirSubstanceDefinitionStructureRepresentationList.ItemClass: TFslObjectClass;
begin
  result := TFhirSubstanceDefinitionStructureRepresentation;
end;
function TFhirSubstanceDefinitionStructureRepresentationList.IndexOf(value: TFhirSubstanceDefinitionStructureRepresentation): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirSubstanceDefinitionStructureRepresentationList.Insert(index: Integer): TFhirSubstanceDefinitionStructureRepresentation;
begin
  result := TFhirSubstanceDefinitionStructureRepresentation.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirSubstanceDefinitionStructureRepresentationList.InsertItem(index: Integer; value: TFhirSubstanceDefinitionStructureRepresentation);
begin
  assert(value is TFhirSubstanceDefinitionStructureRepresentation);
  Inherited Insert(index, value);
end;

function TFhirSubstanceDefinitionStructureRepresentationList.Item(index: Integer): TFhirSubstanceDefinitionStructureRepresentation;
begin
  result := TFhirSubstanceDefinitionStructureRepresentation(ObjectByIndex[index]);
end;

function TFhirSubstanceDefinitionStructureRepresentationList.Link: TFhirSubstanceDefinitionStructureRepresentationList;
begin
  result := TFhirSubstanceDefinitionStructureRepresentationList(inherited Link);
end;

procedure TFhirSubstanceDefinitionStructureRepresentationList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirSubstanceDefinitionStructureRepresentationList.SetItemByIndex(index: Integer; value: TFhirSubstanceDefinitionStructureRepresentation);
begin
  assert(value is TFhirSubstanceDefinitionStructureRepresentation);
  FhirSubstanceDefinitionStructureRepresentations[index] := value;
end;

procedure TFhirSubstanceDefinitionStructureRepresentationList.SetItemN(index: Integer; value: TFhirSubstanceDefinitionStructureRepresentation);
begin
  assert(value is TFhirSubstanceDefinitionStructureRepresentation);
  ObjectByIndex[index] := value;
end;

{ TFhirSubstanceDefinitionCode }

constructor TFhirSubstanceDefinitionCode.Create;
begin
  inherited;
end;

destructor TFhirSubstanceDefinitionCode.Destroy;
begin
  FCode.free;
  FStatus.free;
  FStatusDate.free;
  FNoteList.Free;
  FSourceList.Free;
  inherited;
end;

procedure TFhirSubstanceDefinitionCode.Assign(oSource : TFslObject);
begin
  inherited;
  code := TFhirSubstanceDefinitionCode(oSource).code.Clone;
  status := TFhirSubstanceDefinitionCode(oSource).status.Clone;
  statusDateElement := TFhirSubstanceDefinitionCode(oSource).statusDateElement.Clone;
  if (TFhirSubstanceDefinitionCode(oSource).FNoteList = nil) then
  begin
    FNoteList.free;
    FNoteList := nil;
  end
  else
  begin
    if FNoteList = nil then
      FNoteList := TFhirAnnotationList.Create;
    FNoteList.Assign(TFhirSubstanceDefinitionCode(oSource).FNoteList);
  end;
  if (TFhirSubstanceDefinitionCode(oSource).FSourceList = nil) then
  begin
    FSourceList.free;
    FSourceList := nil;
  end
  else
  begin
    if FSourceList = nil then
      FSourceList := TFhirReferenceList.Create;
    FSourceList.Assign(TFhirSubstanceDefinitionCode(oSource).FSourceList);
  end;
end;

procedure TFhirSubstanceDefinitionCode.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'code') Then
     list.add(self.link, 'code', FCode.Link);
  if (child_name = 'status') Then
     list.add(self.link, 'status', FStatus.Link);
  if (child_name = 'statusDate') Then
     list.add(self.link, 'statusDate', FStatusDate.Link);
  if (child_name = 'note') Then
    list.addAll(self, 'note', FNoteList);
  if (child_name = 'source') Then
    list.addAll(self, 'source', FSourceList);
end;

procedure TFhirSubstanceDefinitionCode.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'code', 'CodeableConcept', false, TFhirCodeableConcept, FCode.Link));
  oList.add(TFHIRProperty.create(self, 'status', 'CodeableConcept', false, TFhirCodeableConcept, FStatus.Link));
  oList.add(TFHIRProperty.create(self, 'statusDate', 'dateTime', false, TFhirDateTime, FStatusDate.Link));
  oList.add(TFHIRProperty.create(self, 'note', 'Annotation', true, TFhirAnnotation, FNoteList.Link));
  oList.add(TFHIRProperty.create(self, 'source', 'Reference', true, TFhirReference, FSourceList.Link));
end;

function TFhirSubstanceDefinitionCode.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'code') then
  begin
    Code := propValue as TFhirCodeableConcept;
    result := propValue;
  end
  else if (propName = 'status') then
  begin
    Status := propValue as TFhirCodeableConcept;
    result := propValue;
  end
  else if (propName = 'statusDate') then
  begin
    StatusDateElement := asDateTime(propValue);
    result := propValue;
  end
  else if (propName = 'note') then
  begin
    NoteList.add(propValue as TFhirAnnotation);
    result := propValue;
  end
  else if (propName = 'source') then
  begin
    SourceList.add(propValue as TFhirReference);
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirSubstanceDefinitionCode.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'note') then NoteList.insertItem(index, propValue as TFhirAnnotation)
  else if (propName = 'source') then SourceList.insertItem(index, propValue as TFhirReference)
  else inherited;
end;

function TFhirSubstanceDefinitionCode.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'code') then result := TFhirCodeableConcept.create()
  else if (propName = 'status') then result := TFhirCodeableConcept.create()
  else if (propName = 'statusDate') then result := TFhirDateTime.create()
  else if (propName = 'note') then result := NoteList.new()
  else if (propName = 'source') then result := SourceList.new()
  else result := inherited createPropertyValue(propName);
end;

function TFhirSubstanceDefinitionCode.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'code') then result := 'CodeableConcept'
  else if (propName = 'status') then result := 'CodeableConcept'
  else if (propName = 'statusDate') then result := 'dateTime'
  else if (propName = 'note') then result := 'Annotation'
  else if (propName = 'source') then result := 'Reference'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirSubstanceDefinitionCode.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'code') then CodeElement := nil
  else if (propName = 'status') then StatusElement := nil
  else if (propName = 'statusDate') then StatusDateElement := nil
  else if (propName = 'note') then deletePropertyValue('note', NoteList, value)
  else if (propName = 'source') then deletePropertyValue('source', SourceList, value)
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirSubstanceDefinitionCode.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'code') then CodeElement := new as TFhirCodeableConcept
  else if (propName = 'status') then StatusElement := new as TFhirCodeableConcept
  else if (propName = 'statusDate') then StatusDateElement := asDateTime(new)
  else if (propName = 'note') then replacePropertyValue('note', NoteList, existing, new)
  else if (propName = 'source') then replacePropertyValue('source', SourceList, existing, new)
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirSubstanceDefinitionCode.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'note') then NoteList.move(source, destination)
  else if (propName = 'source') then SourceList.move(source, destination)
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirSubstanceDefinitionCode.fhirType : string;
begin
  result := 'SubstanceDefinition.code';
end;

function TFhirSubstanceDefinitionCode.Link : TFhirSubstanceDefinitionCode;
begin
  result := TFhirSubstanceDefinitionCode(inherited Link);
end;

function TFhirSubstanceDefinitionCode.Clone : TFhirSubstanceDefinitionCode;
begin
  result := TFhirSubstanceDefinitionCode(inherited Clone);
end;

function TFhirSubstanceDefinitionCode.equals(other : TObject) : boolean; 
var
  o : TFhirSubstanceDefinitionCode;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirSubstanceDefinitionCode)) then
    result := false
  else
  begin
    o := TFhirSubstanceDefinitionCode(other);
    result := compareDeep(codeElement, o.codeElement, true) and compareDeep(statusElement, o.statusElement, true) and 
      compareDeep(statusDateElement, o.statusDateElement, true) and compareDeep(noteList, o.noteList, true) and 
      compareDeep(sourceList, o.sourceList, true);
  end;
end;

function TFhirSubstanceDefinitionCode.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FCode) and isEmptyProp(FStatus) and isEmptyProp(FStatusDate) and isEmptyProp(FnoteList) and isEmptyProp(FsourceList);
end;

procedure TFhirSubstanceDefinitionCode.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('code');
  fields.add('status');
  fields.add('statusDate');
  fields.add('note');
  fields.add('source');
end;

function TFhirSubstanceDefinitionCode.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
  inc(result, FNoteList.sizeInBytes(magic));
  inc(result, FSourceList.sizeInBytes(magic));
end;

procedure TFhirSubstanceDefinitionCode.SetCode(value : TFhirCodeableConcept);
begin
  FCode.free;
  FCode := value;
end;

procedure TFhirSubstanceDefinitionCode.SetStatus(value : TFhirCodeableConcept);
begin
  FStatus.free;
  FStatus := value;
end;

procedure TFhirSubstanceDefinitionCode.SetStatusDate(value : TFhirDateTime);
begin
  FStatusDate.free;
  FStatusDate := value;
end;

function TFhirSubstanceDefinitionCode.GetStatusDateST : TFslDateTime;
begin
  if FStatusDate = nil then
    result := TFslDateTime.makeNull
  else
    result := FStatusDate.value;
end;

procedure TFhirSubstanceDefinitionCode.SetStatusDateST(value : TFslDateTime);
begin
  if FStatusDate = nil then
    FStatusDate := TFhirDateTime.create;
  FStatusDate.value := value
end;

function TFhirSubstanceDefinitionCode.GetNoteList : TFhirAnnotationList;
begin
  if FNoteList = nil then
    FNoteList := TFhirAnnotationList.Create;
  result := FNoteList;
end;

function TFhirSubstanceDefinitionCode.GetHasNoteList : boolean;
begin
  result := (FNoteList <> nil) and (FNoteList.count > 0);
end;

function TFhirSubstanceDefinitionCode.GetSourceList : TFhirReferenceList;
begin
  if FSourceList = nil then
    FSourceList := TFhirReferenceList.Create;
  result := FSourceList;
end;

function TFhirSubstanceDefinitionCode.GetHasSourceList : boolean;
begin
  result := (FSourceList <> nil) and (FSourceList.count > 0);
end;

{ TFhirSubstanceDefinitionCodeListEnumerator }

constructor TFhirSubstanceDefinitionCodeListEnumerator.Create(list : TFhirSubstanceDefinitionCodeList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirSubstanceDefinitionCodeListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirSubstanceDefinitionCodeListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirSubstanceDefinitionCodeListEnumerator.GetCurrent : TFhirSubstanceDefinitionCode;
begin
  Result := FList[FIndex];
end;

function TFhirSubstanceDefinitionCodeListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirSubstanceDefinitionCodeList }

function TFhirSubstanceDefinitionCodeList.AddItem(value: TFhirSubstanceDefinitionCode): TFhirSubstanceDefinitionCode;
begin
  assert(value.ClassName = 'TFhirSubstanceDefinitionCode', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirSubstanceDefinitionCode');
  add(value);
  result := value;
end;

function TFhirSubstanceDefinitionCodeList.Append: TFhirSubstanceDefinitionCode;
begin
  result := TFhirSubstanceDefinitionCode.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirSubstanceDefinitionCodeList.ClearItems;
begin
  Clear;
end;

function TFhirSubstanceDefinitionCodeList.GetEnumerator : TFhirSubstanceDefinitionCodeListEnumerator;
begin
  result := TFhirSubstanceDefinitionCodeListEnumerator.Create(self.link);
end;

function TFhirSubstanceDefinitionCodeList.Clone: TFhirSubstanceDefinitionCodeList;
begin
  result := TFhirSubstanceDefinitionCodeList(inherited Clone);
end;

function TFhirSubstanceDefinitionCodeList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirSubstanceDefinitionCodeList.GetItemN(index: Integer): TFhirSubstanceDefinitionCode;
begin
  result := TFhirSubstanceDefinitionCode(ObjectByIndex[index]);
end;

function TFhirSubstanceDefinitionCodeList.ItemClass: TFslObjectClass;
begin
  result := TFhirSubstanceDefinitionCode;
end;
function TFhirSubstanceDefinitionCodeList.IndexOf(value: TFhirSubstanceDefinitionCode): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirSubstanceDefinitionCodeList.Insert(index: Integer): TFhirSubstanceDefinitionCode;
begin
  result := TFhirSubstanceDefinitionCode.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirSubstanceDefinitionCodeList.InsertItem(index: Integer; value: TFhirSubstanceDefinitionCode);
begin
  assert(value is TFhirSubstanceDefinitionCode);
  Inherited Insert(index, value);
end;

function TFhirSubstanceDefinitionCodeList.Item(index: Integer): TFhirSubstanceDefinitionCode;
begin
  result := TFhirSubstanceDefinitionCode(ObjectByIndex[index]);
end;

function TFhirSubstanceDefinitionCodeList.Link: TFhirSubstanceDefinitionCodeList;
begin
  result := TFhirSubstanceDefinitionCodeList(inherited Link);
end;

procedure TFhirSubstanceDefinitionCodeList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirSubstanceDefinitionCodeList.SetItemByIndex(index: Integer; value: TFhirSubstanceDefinitionCode);
begin
  assert(value is TFhirSubstanceDefinitionCode);
  FhirSubstanceDefinitionCodes[index] := value;
end;

procedure TFhirSubstanceDefinitionCodeList.SetItemN(index: Integer; value: TFhirSubstanceDefinitionCode);
begin
  assert(value is TFhirSubstanceDefinitionCode);
  ObjectByIndex[index] := value;
end;

{ TFhirSubstanceDefinitionName }

constructor TFhirSubstanceDefinitionName.Create;
begin
  inherited;
end;

destructor TFhirSubstanceDefinitionName.Destroy;
begin
  FName.free;
  FType_.free;
  FStatus.free;
  FPreferred.free;
  FLanguageList.Free;
  FDomainList.Free;
  FJurisdictionList.Free;
  FSynonymList.Free;
  FTranslationList.Free;
  FOfficialList.Free;
  FSourceList.Free;
  inherited;
end;

procedure TFhirSubstanceDefinitionName.Assign(oSource : TFslObject);
begin
  inherited;
  nameElement := TFhirSubstanceDefinitionName(oSource).nameElement.Clone;
  type_ := TFhirSubstanceDefinitionName(oSource).type_.Clone;
  status := TFhirSubstanceDefinitionName(oSource).status.Clone;
  preferredElement := TFhirSubstanceDefinitionName(oSource).preferredElement.Clone;
  if (TFhirSubstanceDefinitionName(oSource).FLanguageList = nil) then
  begin
    FLanguageList.free;
    FLanguageList := nil;
  end
  else
  begin
    if FLanguageList = nil then
      FLanguageList := TFhirCodeableConceptList.Create;
    FLanguageList.Assign(TFhirSubstanceDefinitionName(oSource).FLanguageList);
  end;
  if (TFhirSubstanceDefinitionName(oSource).FDomainList = nil) then
  begin
    FDomainList.free;
    FDomainList := nil;
  end
  else
  begin
    if FDomainList = nil then
      FDomainList := TFhirCodeableConceptList.Create;
    FDomainList.Assign(TFhirSubstanceDefinitionName(oSource).FDomainList);
  end;
  if (TFhirSubstanceDefinitionName(oSource).FJurisdictionList = nil) then
  begin
    FJurisdictionList.free;
    FJurisdictionList := nil;
  end
  else
  begin
    if FJurisdictionList = nil then
      FJurisdictionList := TFhirCodeableConceptList.Create;
    FJurisdictionList.Assign(TFhirSubstanceDefinitionName(oSource).FJurisdictionList);
  end;
  if (TFhirSubstanceDefinitionName(oSource).FSynonymList = nil) then
  begin
    FSynonymList.free;
    FSynonymList := nil;
  end
  else
  begin
    if FSynonymList = nil then
      FSynonymList := TFhirSubstanceDefinitionNameList.Create;
    FSynonymList.Assign(TFhirSubstanceDefinitionName(oSource).FSynonymList);
  end;
  if (TFhirSubstanceDefinitionName(oSource).FTranslationList = nil) then
  begin
    FTranslationList.free;
    FTranslationList := nil;
  end
  else
  begin
    if FTranslationList = nil then
      FTranslationList := TFhirSubstanceDefinitionNameList.Create;
    FTranslationList.Assign(TFhirSubstanceDefinitionName(oSource).FTranslationList);
  end;
  if (TFhirSubstanceDefinitionName(oSource).FOfficialList = nil) then
  begin
    FOfficialList.free;
    FOfficialList := nil;
  end
  else
  begin
    if FOfficialList = nil then
      FOfficialList := TFhirSubstanceDefinitionNameOfficialList.Create;
    FOfficialList.Assign(TFhirSubstanceDefinitionName(oSource).FOfficialList);
  end;
  if (TFhirSubstanceDefinitionName(oSource).FSourceList = nil) then
  begin
    FSourceList.free;
    FSourceList := nil;
  end
  else
  begin
    if FSourceList = nil then
      FSourceList := TFhirReferenceList.Create;
    FSourceList.Assign(TFhirSubstanceDefinitionName(oSource).FSourceList);
  end;
end;

procedure TFhirSubstanceDefinitionName.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'name') Then
     list.add(self.link, 'name', FName.Link);
  if (child_name = 'type') Then
     list.add(self.link, 'type', FType_.Link);
  if (child_name = 'status') Then
     list.add(self.link, 'status', FStatus.Link);
  if (child_name = 'preferred') Then
     list.add(self.link, 'preferred', FPreferred.Link);
  if (child_name = 'language') Then
    list.addAll(self, 'language', FLanguageList);
  if (child_name = 'domain') Then
    list.addAll(self, 'domain', FDomainList);
  if (child_name = 'jurisdiction') Then
    list.addAll(self, 'jurisdiction', FJurisdictionList);
  if (child_name = 'synonym') Then
    list.addAll(self, 'synonym', FSynonymList);
  if (child_name = 'translation') Then
    list.addAll(self, 'translation', FTranslationList);
  if (child_name = 'official') Then
    list.addAll(self, 'official', FOfficialList);
  if (child_name = 'source') Then
    list.addAll(self, 'source', FSourceList);
end;

procedure TFhirSubstanceDefinitionName.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'name', 'string', false, TFhirString, FName.Link));
  oList.add(TFHIRProperty.create(self, 'type', 'CodeableConcept', false, TFhirCodeableConcept, FType_.Link));
  oList.add(TFHIRProperty.create(self, 'status', 'CodeableConcept', false, TFhirCodeableConcept, FStatus.Link));
  oList.add(TFHIRProperty.create(self, 'preferred', 'boolean', false, TFhirBoolean, FPreferred.Link));
  oList.add(TFHIRProperty.create(self, 'language', 'CodeableConcept', true, TFhirCodeableConcept, FLanguageList.Link));
  oList.add(TFHIRProperty.create(self, 'domain', 'CodeableConcept', true, TFhirCodeableConcept, FDomainList.Link));
  oList.add(TFHIRProperty.create(self, 'jurisdiction', 'CodeableConcept', true, TFhirCodeableConcept, FJurisdictionList.Link));
  oList.add(TFHIRProperty.create(self, 'synonym', '', true, TFhirSubstanceDefinitionName, FSynonymList.Link));
  oList.add(TFHIRProperty.create(self, 'translation', '', true, TFhirSubstanceDefinitionName, FTranslationList.Link));
  oList.add(TFHIRProperty.create(self, 'official', 'BackboneElement', true, TFhirSubstanceDefinitionNameOfficial, FOfficialList.Link));
  oList.add(TFHIRProperty.create(self, 'source', 'Reference', true, TFhirReference, FSourceList.Link));
end;

function TFhirSubstanceDefinitionName.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'name') then
  begin
    NameElement := asString(propValue);
    result := propValue;
  end
  else if (propName = 'type') then
  begin
    Type_ := propValue as TFhirCodeableConcept;
    result := propValue;
  end
  else if (propName = 'status') then
  begin
    Status := propValue as TFhirCodeableConcept;
    result := propValue;
  end
  else if (propName = 'preferred') then
  begin
    PreferredElement := asBoolean(propValue);
    result := propValue;
  end
  else if (propName = 'language') then
  begin
    LanguageList.add(propValue as TFhirCodeableConcept);
    result := propValue;
  end
  else if (propName = 'domain') then
  begin
    DomainList.add(propValue as TFhirCodeableConcept);
    result := propValue;
  end
  else if (propName = 'jurisdiction') then
  begin
    JurisdictionList.add(propValue as TFhirCodeableConcept);
    result := propValue;
  end
  else if (propName = 'synonym') then
  begin
    SynonymList.add(propValue as TFhirSubstanceDefinitionName);
    result := propValue;
  end
  else if (propName = 'translation') then
  begin
    TranslationList.add(propValue as TFhirSubstanceDefinitionName);
    result := propValue;
  end
  else if (propName = 'official') then
  begin
    OfficialList.add(propValue as TFhirSubstanceDefinitionNameOfficial);
    result := propValue;
  end
  else if (propName = 'source') then
  begin
    SourceList.add(propValue as TFhirReference);
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirSubstanceDefinitionName.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'language') then LanguageList.insertItem(index, propValue as TFhirCodeableConcept)
  else if (propName = 'domain') then DomainList.insertItem(index, propValue as TFhirCodeableConcept)
  else if (propName = 'jurisdiction') then JurisdictionList.insertItem(index, propValue as TFhirCodeableConcept)
  else if (propName = 'synonym') then SynonymList.insertItem(index, propValue as TFhirSubstanceDefinitionName)
  else if (propName = 'translation') then TranslationList.insertItem(index, propValue as TFhirSubstanceDefinitionName)
  else if (propName = 'official') then OfficialList.insertItem(index, propValue as TFhirSubstanceDefinitionNameOfficial)
  else if (propName = 'source') then SourceList.insertItem(index, propValue as TFhirReference)
  else inherited;
end;

function TFhirSubstanceDefinitionName.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'name') then result := TFhirString.create()
  else if (propName = 'type') then result := TFhirCodeableConcept.create()
  else if (propName = 'status') then result := TFhirCodeableConcept.create()
  else if (propName = 'preferred') then result := TFhirBoolean.create()
  else if (propName = 'language') then result := LanguageList.new()
  else if (propName = 'domain') then result := DomainList.new()
  else if (propName = 'jurisdiction') then result := JurisdictionList.new()
  else if (propName = 'synonym') then result := SynonymList.new()
  else if (propName = 'translation') then result := TranslationList.new()
  else if (propName = 'official') then result := OfficialList.new()
  else if (propName = 'source') then result := SourceList.new()
  else result := inherited createPropertyValue(propName);
end;

function TFhirSubstanceDefinitionName.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'name') then result := 'string'
  else if (propName = 'type') then result := 'CodeableConcept'
  else if (propName = 'status') then result := 'CodeableConcept'
  else if (propName = 'preferred') then result := 'boolean'
  else if (propName = 'language') then result := 'CodeableConcept'
  else if (propName = 'domain') then result := 'CodeableConcept'
  else if (propName = 'jurisdiction') then result := 'CodeableConcept'
  else if (propName = 'synonym') then result := ''
  else if (propName = 'translation') then result := ''
  else if (propName = 'official') then result := 'BackboneElement'
  else if (propName = 'source') then result := 'Reference'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirSubstanceDefinitionName.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'name') then NameElement := nil
  else if (propName = 'type') then Type_Element := nil
  else if (propName = 'status') then StatusElement := nil
  else if (propName = 'preferred') then PreferredElement := nil
  else if (propName = 'language') then deletePropertyValue('language', LanguageList, value)
  else if (propName = 'domain') then deletePropertyValue('domain', DomainList, value)
  else if (propName = 'jurisdiction') then deletePropertyValue('jurisdiction', JurisdictionList, value)
  else if (propName = 'synonym') then deletePropertyValue('synonym', SynonymList, value)
  else if (propName = 'translation') then deletePropertyValue('translation', TranslationList, value)
  else if (propName = 'official') then deletePropertyValue('official', OfficialList, value)
  else if (propName = 'source') then deletePropertyValue('source', SourceList, value)
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirSubstanceDefinitionName.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'name') then NameElement := asString(new)
  else if (propName = 'type') then Type_Element := new as TFhirCodeableConcept
  else if (propName = 'status') then StatusElement := new as TFhirCodeableConcept
  else if (propName = 'preferred') then PreferredElement := asBoolean(new)
  else if (propName = 'language') then replacePropertyValue('language', LanguageList, existing, new)
  else if (propName = 'domain') then replacePropertyValue('domain', DomainList, existing, new)
  else if (propName = 'jurisdiction') then replacePropertyValue('jurisdiction', JurisdictionList, existing, new)
  else if (propName = 'synonym') then replacePropertyValue('synonym', SynonymList, existing, new)
  else if (propName = 'translation') then replacePropertyValue('translation', TranslationList, existing, new)
  else if (propName = 'official') then replacePropertyValue('official', OfficialList, existing, new)
  else if (propName = 'source') then replacePropertyValue('source', SourceList, existing, new)
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirSubstanceDefinitionName.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'language') then LanguageList.move(source, destination)
  else if (propName = 'domain') then DomainList.move(source, destination)
  else if (propName = 'jurisdiction') then JurisdictionList.move(source, destination)
  else if (propName = 'synonym') then SynonymList.move(source, destination)
  else if (propName = 'translation') then TranslationList.move(source, destination)
  else if (propName = 'official') then OfficialList.move(source, destination)
  else if (propName = 'source') then SourceList.move(source, destination)
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirSubstanceDefinitionName.fhirType : string;
begin
  result := 'SubstanceDefinition.name';
end;

function TFhirSubstanceDefinitionName.Link : TFhirSubstanceDefinitionName;
begin
  result := TFhirSubstanceDefinitionName(inherited Link);
end;

function TFhirSubstanceDefinitionName.Clone : TFhirSubstanceDefinitionName;
begin
  result := TFhirSubstanceDefinitionName(inherited Clone);
end;

function TFhirSubstanceDefinitionName.equals(other : TObject) : boolean; 
var
  o : TFhirSubstanceDefinitionName;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirSubstanceDefinitionName)) then
    result := false
  else
  begin
    o := TFhirSubstanceDefinitionName(other);
    result := compareDeep(nameElement, o.nameElement, true) and compareDeep(type_Element, o.type_Element, true) and 
      compareDeep(statusElement, o.statusElement, true) and compareDeep(preferredElement, o.preferredElement, true) and 
      compareDeep(languageList, o.languageList, true) and compareDeep(domainList, o.domainList, true) and 
      compareDeep(jurisdictionList, o.jurisdictionList, true) and compareDeep(synonymList, o.synonymList, true) and 
      compareDeep(translationList, o.translationList, true) and compareDeep(officialList, o.officialList, true) and 
      compareDeep(sourceList, o.sourceList, true);
  end;
end;

function TFhirSubstanceDefinitionName.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FName) and isEmptyProp(FType_) and isEmptyProp(FStatus) and isEmptyProp(FPreferred) and isEmptyProp(FlanguageList) and isEmptyProp(FdomainList) and isEmptyProp(FjurisdictionList) and isEmptyProp(FsynonymList) and isEmptyProp(FtranslationList) and isEmptyProp(FofficialList) and isEmptyProp(FsourceList);
end;

procedure TFhirSubstanceDefinitionName.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('name');
  fields.add('type');
  fields.add('status');
  fields.add('preferred');
  fields.add('language');
  fields.add('domain');
  fields.add('jurisdiction');
  fields.add('synonym');
  fields.add('translation');
  fields.add('official');
  fields.add('source');
end;

function TFhirSubstanceDefinitionName.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
  inc(result, FLanguageList.sizeInBytes(magic));
  inc(result, FDomainList.sizeInBytes(magic));
  inc(result, FJurisdictionList.sizeInBytes(magic));
  inc(result, FSynonymList.sizeInBytes(magic));
  inc(result, FTranslationList.sizeInBytes(magic));
  inc(result, FOfficialList.sizeInBytes(magic));
  inc(result, FSourceList.sizeInBytes(magic));
end;

procedure TFhirSubstanceDefinitionName.SetName(value : TFhirString);
begin
  FName.free;
  FName := value;
end;

function TFhirSubstanceDefinitionName.GetNameST : String;
begin
  if FName = nil then
    result := ''
  else
    result := FName.value;
end;

procedure TFhirSubstanceDefinitionName.SetNameST(value : String);
begin
  if value <> '' then
  begin
    if FName = nil then
      FName := TFhirString.create;
    FName.value := value
  end
  else if FName <> nil then
    FName.value := '';
end;

procedure TFhirSubstanceDefinitionName.SetType_(value : TFhirCodeableConcept);
begin
  FType_.free;
  FType_ := value;
end;

procedure TFhirSubstanceDefinitionName.SetStatus(value : TFhirCodeableConcept);
begin
  FStatus.free;
  FStatus := value;
end;

procedure TFhirSubstanceDefinitionName.SetPreferred(value : TFhirBoolean);
begin
  FPreferred.free;
  FPreferred := value;
end;

function TFhirSubstanceDefinitionName.GetPreferredST : Boolean;
begin
  if FPreferred = nil then
    result := false
  else
    result := FPreferred.value;
end;

procedure TFhirSubstanceDefinitionName.SetPreferredST(value : Boolean);
begin
  if FPreferred = nil then
    FPreferred := TFhirBoolean.create;
  FPreferred.value := value
end;

function TFhirSubstanceDefinitionName.GetLanguageList : TFhirCodeableConceptList;
begin
  if FLanguageList = nil then
    FLanguageList := TFhirCodeableConceptList.Create;
  result := FLanguageList;
end;

function TFhirSubstanceDefinitionName.GetHasLanguageList : boolean;
begin
  result := (FLanguageList <> nil) and (FLanguageList.count > 0);
end;

function TFhirSubstanceDefinitionName.GetDomainList : TFhirCodeableConceptList;
begin
  if FDomainList = nil then
    FDomainList := TFhirCodeableConceptList.Create;
  result := FDomainList;
end;

function TFhirSubstanceDefinitionName.GetHasDomainList : boolean;
begin
  result := (FDomainList <> nil) and (FDomainList.count > 0);
end;

function TFhirSubstanceDefinitionName.GetJurisdictionList : TFhirCodeableConceptList;
begin
  if FJurisdictionList = nil then
    FJurisdictionList := TFhirCodeableConceptList.Create;
  result := FJurisdictionList;
end;

function TFhirSubstanceDefinitionName.GetHasJurisdictionList : boolean;
begin
  result := (FJurisdictionList <> nil) and (FJurisdictionList.count > 0);
end;

function TFhirSubstanceDefinitionName.GetSynonymList : TFhirSubstanceDefinitionNameList;
begin
  if FSynonymList = nil then
    FSynonymList := TFhirSubstanceDefinitionNameList.Create;
  result := FSynonymList;
end;

function TFhirSubstanceDefinitionName.GetHasSynonymList : boolean;
begin
  result := (FSynonymList <> nil) and (FSynonymList.count > 0);
end;

function TFhirSubstanceDefinitionName.GetTranslationList : TFhirSubstanceDefinitionNameList;
begin
  if FTranslationList = nil then
    FTranslationList := TFhirSubstanceDefinitionNameList.Create;
  result := FTranslationList;
end;

function TFhirSubstanceDefinitionName.GetHasTranslationList : boolean;
begin
  result := (FTranslationList <> nil) and (FTranslationList.count > 0);
end;

function TFhirSubstanceDefinitionName.GetOfficialList : TFhirSubstanceDefinitionNameOfficialList;
begin
  if FOfficialList = nil then
    FOfficialList := TFhirSubstanceDefinitionNameOfficialList.Create;
  result := FOfficialList;
end;

function TFhirSubstanceDefinitionName.GetHasOfficialList : boolean;
begin
  result := (FOfficialList <> nil) and (FOfficialList.count > 0);
end;

function TFhirSubstanceDefinitionName.GetSourceList : TFhirReferenceList;
begin
  if FSourceList = nil then
    FSourceList := TFhirReferenceList.Create;
  result := FSourceList;
end;

function TFhirSubstanceDefinitionName.GetHasSourceList : boolean;
begin
  result := (FSourceList <> nil) and (FSourceList.count > 0);
end;

{ TFhirSubstanceDefinitionNameListEnumerator }

constructor TFhirSubstanceDefinitionNameListEnumerator.Create(list : TFhirSubstanceDefinitionNameList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirSubstanceDefinitionNameListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirSubstanceDefinitionNameListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirSubstanceDefinitionNameListEnumerator.GetCurrent : TFhirSubstanceDefinitionName;
begin
  Result := FList[FIndex];
end;

function TFhirSubstanceDefinitionNameListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirSubstanceDefinitionNameList }

function TFhirSubstanceDefinitionNameList.AddItem(value: TFhirSubstanceDefinitionName): TFhirSubstanceDefinitionName;
begin
  assert(value.ClassName = 'TFhirSubstanceDefinitionName', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirSubstanceDefinitionName');
  add(value);
  result := value;
end;

function TFhirSubstanceDefinitionNameList.Append: TFhirSubstanceDefinitionName;
begin
  result := TFhirSubstanceDefinitionName.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirSubstanceDefinitionNameList.ClearItems;
begin
  Clear;
end;

function TFhirSubstanceDefinitionNameList.GetEnumerator : TFhirSubstanceDefinitionNameListEnumerator;
begin
  result := TFhirSubstanceDefinitionNameListEnumerator.Create(self.link);
end;

function TFhirSubstanceDefinitionNameList.Clone: TFhirSubstanceDefinitionNameList;
begin
  result := TFhirSubstanceDefinitionNameList(inherited Clone);
end;

function TFhirSubstanceDefinitionNameList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirSubstanceDefinitionNameList.GetItemN(index: Integer): TFhirSubstanceDefinitionName;
begin
  result := TFhirSubstanceDefinitionName(ObjectByIndex[index]);
end;

function TFhirSubstanceDefinitionNameList.ItemClass: TFslObjectClass;
begin
  result := TFhirSubstanceDefinitionName;
end;
function TFhirSubstanceDefinitionNameList.IndexOf(value: TFhirSubstanceDefinitionName): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirSubstanceDefinitionNameList.Insert(index: Integer): TFhirSubstanceDefinitionName;
begin
  result := TFhirSubstanceDefinitionName.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirSubstanceDefinitionNameList.InsertItem(index: Integer; value: TFhirSubstanceDefinitionName);
begin
  assert(value is TFhirSubstanceDefinitionName);
  Inherited Insert(index, value);
end;

function TFhirSubstanceDefinitionNameList.Item(index: Integer): TFhirSubstanceDefinitionName;
begin
  result := TFhirSubstanceDefinitionName(ObjectByIndex[index]);
end;

function TFhirSubstanceDefinitionNameList.Link: TFhirSubstanceDefinitionNameList;
begin
  result := TFhirSubstanceDefinitionNameList(inherited Link);
end;

procedure TFhirSubstanceDefinitionNameList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirSubstanceDefinitionNameList.SetItemByIndex(index: Integer; value: TFhirSubstanceDefinitionName);
begin
  assert(value is TFhirSubstanceDefinitionName);
  FhirSubstanceDefinitionNames[index] := value;
end;

procedure TFhirSubstanceDefinitionNameList.SetItemN(index: Integer; value: TFhirSubstanceDefinitionName);
begin
  assert(value is TFhirSubstanceDefinitionName);
  ObjectByIndex[index] := value;
end;

{ TFhirSubstanceDefinitionNameOfficial }

constructor TFhirSubstanceDefinitionNameOfficial.Create;
begin
  inherited;
end;

destructor TFhirSubstanceDefinitionNameOfficial.Destroy;
begin
  FAuthority.free;
  FStatus.free;
  FDate.free;
  inherited;
end;

procedure TFhirSubstanceDefinitionNameOfficial.Assign(oSource : TFslObject);
begin
  inherited;
  authority := TFhirSubstanceDefinitionNameOfficial(oSource).authority.Clone;
  status := TFhirSubstanceDefinitionNameOfficial(oSource).status.Clone;
  dateElement := TFhirSubstanceDefinitionNameOfficial(oSource).dateElement.Clone;
end;

procedure TFhirSubstanceDefinitionNameOfficial.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'authority') Then
     list.add(self.link, 'authority', FAuthority.Link);
  if (child_name = 'status') Then
     list.add(self.link, 'status', FStatus.Link);
  if (child_name = 'date') Then
     list.add(self.link, 'date', FDate.Link);
end;

procedure TFhirSubstanceDefinitionNameOfficial.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'authority', 'CodeableConcept', false, TFhirCodeableConcept, FAuthority.Link));
  oList.add(TFHIRProperty.create(self, 'status', 'CodeableConcept', false, TFhirCodeableConcept, FStatus.Link));
  oList.add(TFHIRProperty.create(self, 'date', 'dateTime', false, TFhirDateTime, FDate.Link));
end;

function TFhirSubstanceDefinitionNameOfficial.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'authority') then
  begin
    Authority := propValue as TFhirCodeableConcept;
    result := propValue;
  end
  else if (propName = 'status') then
  begin
    Status := propValue as TFhirCodeableConcept;
    result := propValue;
  end
  else if (propName = 'date') then
  begin
    DateElement := asDateTime(propValue);
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirSubstanceDefinitionNameOfficial.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirSubstanceDefinitionNameOfficial.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'authority') then result := TFhirCodeableConcept.create()
  else if (propName = 'status') then result := TFhirCodeableConcept.create()
  else if (propName = 'date') then result := TFhirDateTime.create()
  else result := inherited createPropertyValue(propName);
end;

function TFhirSubstanceDefinitionNameOfficial.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'authority') then result := 'CodeableConcept'
  else if (propName = 'status') then result := 'CodeableConcept'
  else if (propName = 'date') then result := 'dateTime'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirSubstanceDefinitionNameOfficial.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'authority') then AuthorityElement := nil
  else if (propName = 'status') then StatusElement := nil
  else if (propName = 'date') then DateElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirSubstanceDefinitionNameOfficial.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'authority') then AuthorityElement := new as TFhirCodeableConcept
  else if (propName = 'status') then StatusElement := new as TFhirCodeableConcept
  else if (propName = 'date') then DateElement := asDateTime(new)
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirSubstanceDefinitionNameOfficial.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirSubstanceDefinitionNameOfficial.fhirType : string;
begin
  result := 'SubstanceDefinition.name.official';
end;

function TFhirSubstanceDefinitionNameOfficial.Link : TFhirSubstanceDefinitionNameOfficial;
begin
  result := TFhirSubstanceDefinitionNameOfficial(inherited Link);
end;

function TFhirSubstanceDefinitionNameOfficial.Clone : TFhirSubstanceDefinitionNameOfficial;
begin
  result := TFhirSubstanceDefinitionNameOfficial(inherited Clone);
end;

function TFhirSubstanceDefinitionNameOfficial.equals(other : TObject) : boolean; 
var
  o : TFhirSubstanceDefinitionNameOfficial;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirSubstanceDefinitionNameOfficial)) then
    result := false
  else
  begin
    o := TFhirSubstanceDefinitionNameOfficial(other);
    result := compareDeep(authorityElement, o.authorityElement, true) and compareDeep(statusElement, o.statusElement, true) and 
      compareDeep(dateElement, o.dateElement, true);
  end;
end;

function TFhirSubstanceDefinitionNameOfficial.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FAuthority) and isEmptyProp(FStatus) and isEmptyProp(FDate);
end;

procedure TFhirSubstanceDefinitionNameOfficial.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('authority');
  fields.add('status');
  fields.add('date');
end;

function TFhirSubstanceDefinitionNameOfficial.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
end;

procedure TFhirSubstanceDefinitionNameOfficial.SetAuthority(value : TFhirCodeableConcept);
begin
  FAuthority.free;
  FAuthority := value;
end;

procedure TFhirSubstanceDefinitionNameOfficial.SetStatus(value : TFhirCodeableConcept);
begin
  FStatus.free;
  FStatus := value;
end;

procedure TFhirSubstanceDefinitionNameOfficial.SetDate(value : TFhirDateTime);
begin
  FDate.free;
  FDate := value;
end;

function TFhirSubstanceDefinitionNameOfficial.GetDateST : TFslDateTime;
begin
  if FDate = nil then
    result := TFslDateTime.makeNull
  else
    result := FDate.value;
end;

procedure TFhirSubstanceDefinitionNameOfficial.SetDateST(value : TFslDateTime);
begin
  if FDate = nil then
    FDate := TFhirDateTime.create;
  FDate.value := value
end;

{ TFhirSubstanceDefinitionNameOfficialListEnumerator }

constructor TFhirSubstanceDefinitionNameOfficialListEnumerator.Create(list : TFhirSubstanceDefinitionNameOfficialList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirSubstanceDefinitionNameOfficialListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirSubstanceDefinitionNameOfficialListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirSubstanceDefinitionNameOfficialListEnumerator.GetCurrent : TFhirSubstanceDefinitionNameOfficial;
begin
  Result := FList[FIndex];
end;

function TFhirSubstanceDefinitionNameOfficialListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirSubstanceDefinitionNameOfficialList }

function TFhirSubstanceDefinitionNameOfficialList.AddItem(value: TFhirSubstanceDefinitionNameOfficial): TFhirSubstanceDefinitionNameOfficial;
begin
  assert(value.ClassName = 'TFhirSubstanceDefinitionNameOfficial', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirSubstanceDefinitionNameOfficial');
  add(value);
  result := value;
end;

function TFhirSubstanceDefinitionNameOfficialList.Append: TFhirSubstanceDefinitionNameOfficial;
begin
  result := TFhirSubstanceDefinitionNameOfficial.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirSubstanceDefinitionNameOfficialList.ClearItems;
begin
  Clear;
end;

function TFhirSubstanceDefinitionNameOfficialList.GetEnumerator : TFhirSubstanceDefinitionNameOfficialListEnumerator;
begin
  result := TFhirSubstanceDefinitionNameOfficialListEnumerator.Create(self.link);
end;

function TFhirSubstanceDefinitionNameOfficialList.Clone: TFhirSubstanceDefinitionNameOfficialList;
begin
  result := TFhirSubstanceDefinitionNameOfficialList(inherited Clone);
end;

function TFhirSubstanceDefinitionNameOfficialList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirSubstanceDefinitionNameOfficialList.GetItemN(index: Integer): TFhirSubstanceDefinitionNameOfficial;
begin
  result := TFhirSubstanceDefinitionNameOfficial(ObjectByIndex[index]);
end;

function TFhirSubstanceDefinitionNameOfficialList.ItemClass: TFslObjectClass;
begin
  result := TFhirSubstanceDefinitionNameOfficial;
end;
function TFhirSubstanceDefinitionNameOfficialList.IndexOf(value: TFhirSubstanceDefinitionNameOfficial): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirSubstanceDefinitionNameOfficialList.Insert(index: Integer): TFhirSubstanceDefinitionNameOfficial;
begin
  result := TFhirSubstanceDefinitionNameOfficial.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirSubstanceDefinitionNameOfficialList.InsertItem(index: Integer; value: TFhirSubstanceDefinitionNameOfficial);
begin
  assert(value is TFhirSubstanceDefinitionNameOfficial);
  Inherited Insert(index, value);
end;

function TFhirSubstanceDefinitionNameOfficialList.Item(index: Integer): TFhirSubstanceDefinitionNameOfficial;
begin
  result := TFhirSubstanceDefinitionNameOfficial(ObjectByIndex[index]);
end;

function TFhirSubstanceDefinitionNameOfficialList.Link: TFhirSubstanceDefinitionNameOfficialList;
begin
  result := TFhirSubstanceDefinitionNameOfficialList(inherited Link);
end;

procedure TFhirSubstanceDefinitionNameOfficialList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirSubstanceDefinitionNameOfficialList.SetItemByIndex(index: Integer; value: TFhirSubstanceDefinitionNameOfficial);
begin
  assert(value is TFhirSubstanceDefinitionNameOfficial);
  FhirSubstanceDefinitionNameOfficials[index] := value;
end;

procedure TFhirSubstanceDefinitionNameOfficialList.SetItemN(index: Integer; value: TFhirSubstanceDefinitionNameOfficial);
begin
  assert(value is TFhirSubstanceDefinitionNameOfficial);
  ObjectByIndex[index] := value;
end;

{ TFhirSubstanceDefinitionRelationship }

constructor TFhirSubstanceDefinitionRelationship.Create;
begin
  inherited;
end;

destructor TFhirSubstanceDefinitionRelationship.Destroy;
begin
  FSubstanceDefinition.free;
  FType_.free;
  FIsDefining.free;
  FAmount.free;
  FRatioHighLimitAmount.free;
  FComparator.free;
  FSourceList.Free;
  inherited;
end;

procedure TFhirSubstanceDefinitionRelationship.Assign(oSource : TFslObject);
begin
  inherited;
  substanceDefinition := TFhirSubstanceDefinitionRelationship(oSource).substanceDefinition.Clone;
  type_ := TFhirSubstanceDefinitionRelationship(oSource).type_.Clone;
  isDefiningElement := TFhirSubstanceDefinitionRelationship(oSource).isDefiningElement.Clone;
  amount := TFhirSubstanceDefinitionRelationship(oSource).amount.Clone;
  ratioHighLimitAmount := TFhirSubstanceDefinitionRelationship(oSource).ratioHighLimitAmount.Clone;
  comparator := TFhirSubstanceDefinitionRelationship(oSource).comparator.Clone;
  if (TFhirSubstanceDefinitionRelationship(oSource).FSourceList = nil) then
  begin
    FSourceList.free;
    FSourceList := nil;
  end
  else
  begin
    if FSourceList = nil then
      FSourceList := TFhirReferenceList.Create;
    FSourceList.Assign(TFhirSubstanceDefinitionRelationship(oSource).FSourceList);
  end;
end;

procedure TFhirSubstanceDefinitionRelationship.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'substanceDefinition[x]') or (child_name = 'substanceDefinition') Then
     list.add(self.link, 'substanceDefinition[x]', FSubstanceDefinition.Link);
  if (child_name = 'type') Then
     list.add(self.link, 'type', FType_.Link);
  if (child_name = 'isDefining') Then
     list.add(self.link, 'isDefining', FIsDefining.Link);
  if (child_name = 'amount[x]') or (child_name = 'amount') Then
     list.add(self.link, 'amount[x]', FAmount.Link);
  if (child_name = 'ratioHighLimitAmount') Then
     list.add(self.link, 'ratioHighLimitAmount', FRatioHighLimitAmount.Link);
  if (child_name = 'comparator') Then
     list.add(self.link, 'comparator', FComparator.Link);
  if (child_name = 'source') Then
    list.addAll(self, 'source', FSourceList);
end;

procedure TFhirSubstanceDefinitionRelationship.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'substanceDefinition[x]', 'Reference|CodeableConcept', false, TFhirDataType, FSubstanceDefinition.Link));
  oList.add(TFHIRProperty.create(self, 'type', 'CodeableConcept', false, TFhirCodeableConcept, FType_.Link));
  oList.add(TFHIRProperty.create(self, 'isDefining', 'boolean', false, TFhirBoolean, FIsDefining.Link));
  oList.add(TFHIRProperty.create(self, 'amount[x]', 'Quantity|Ratio|string', false, TFhirDataType, FAmount.Link));
  oList.add(TFHIRProperty.create(self, 'ratioHighLimitAmount', 'Ratio', false, TFhirRatio, FRatioHighLimitAmount.Link));
  oList.add(TFHIRProperty.create(self, 'comparator', 'CodeableConcept', false, TFhirCodeableConcept, FComparator.Link));
  oList.add(TFHIRProperty.create(self, 'source', 'Reference', true, TFhirReference, FSourceList.Link));
end;

function TFhirSubstanceDefinitionRelationship.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (isMatchingName(propName, 'substanceDefinition', ['Reference', 'CodeableConcept'])) then
  begin
    SubstanceDefinition := propValue as TFhirDataType;
    result := propValue;
  end
  else if (propName = 'type') then
  begin
    Type_ := propValue as TFhirCodeableConcept;
    result := propValue;
  end
  else if (propName = 'isDefining') then
  begin
    IsDefiningElement := asBoolean(propValue);
    result := propValue;
  end
  else if (isMatchingName(propName, 'amount', ['Quantity', 'Ratio', 'String'])) then
  begin
    Amount := propValue as TFhirDataType;
    result := propValue;
  end
  else if (propName = 'ratioHighLimitAmount') then
  begin
    RatioHighLimitAmount := propValue as TFhirRatio;
    result := propValue;
  end
  else if (propName = 'comparator') then
  begin
    Comparator := propValue as TFhirCodeableConcept;
    result := propValue;
  end
  else if (propName = 'source') then
  begin
    SourceList.add(propValue as TFhirReference);
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirSubstanceDefinitionRelationship.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'source') then SourceList.insertItem(index, propValue as TFhirReference)
  else inherited;
end;

function TFhirSubstanceDefinitionRelationship.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (isMatchingName(propName, 'substanceDefinition', ['Reference', 'CodeableConcept'])) then raise EFHIRException.create('Cannot make property SubstanceDefinition')
  else if (propName = 'type') then result := TFhirCodeableConcept.create()
  else if (propName = 'isDefining') then result := TFhirBoolean.create()
  else if (isMatchingName(propName, 'amount', ['Quantity', 'Ratio', 'String'])) then raise EFHIRException.create('Cannot make property Amount')
  else if (propName = 'ratioHighLimitAmount') then result := TFhirRatio.create()
  else if (propName = 'comparator') then result := TFhirCodeableConcept.create()
  else if (propName = 'source') then result := SourceList.new()
  else result := inherited createPropertyValue(propName);
end;

function TFhirSubstanceDefinitionRelationship.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'substanceDefinition[x]') then result := 'Reference|CodeableConcept'
  else if (propName = 'type') then result := 'CodeableConcept'
  else if (propName = 'isDefining') then result := 'boolean'
  else if (propName = 'amount[x]') then result := 'Quantity|Ratio|string'
  else if (propName = 'ratioHighLimitAmount') then result := 'Ratio'
  else if (propName = 'comparator') then result := 'CodeableConcept'
  else if (propName = 'source') then result := 'Reference'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirSubstanceDefinitionRelationship.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (isMatchingName(propName, 'substanceDefinition', ['Reference', 'CodeableConcept'])) then SubstanceDefinitionElement := nil
  else if (propName = 'type') then Type_Element := nil
  else if (propName = 'isDefining') then IsDefiningElement := nil
  else if (isMatchingName(propName, 'amount', ['Quantity', 'Ratio', 'String'])) then AmountElement := nil
  else if (propName = 'ratioHighLimitAmount') then RatioHighLimitAmountElement := nil
  else if (propName = 'comparator') then ComparatorElement := nil
  else if (propName = 'source') then deletePropertyValue('source', SourceList, value)
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirSubstanceDefinitionRelationship.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (isMatchingName(propName, 'substanceDefinition', ['Reference', 'CodeableConcept'])) then SubstanceDefinitionElement := new as TFhirDataType
  else if (propName = 'type') then Type_Element := new as TFhirCodeableConcept
  else if (propName = 'isDefining') then IsDefiningElement := asBoolean(new)
  else if (isMatchingName(propName, 'amount', ['Quantity', 'Ratio', 'String'])) then AmountElement := new as TFhirDataType
  else if (propName = 'ratioHighLimitAmount') then RatioHighLimitAmountElement := new as TFhirRatio
  else if (propName = 'comparator') then ComparatorElement := new as TFhirCodeableConcept
  else if (propName = 'source') then replacePropertyValue('source', SourceList, existing, new)
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirSubstanceDefinitionRelationship.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'source') then SourceList.move(source, destination)
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirSubstanceDefinitionRelationship.fhirType : string;
begin
  result := 'SubstanceDefinition.relationship';
end;

function TFhirSubstanceDefinitionRelationship.Link : TFhirSubstanceDefinitionRelationship;
begin
  result := TFhirSubstanceDefinitionRelationship(inherited Link);
end;

function TFhirSubstanceDefinitionRelationship.Clone : TFhirSubstanceDefinitionRelationship;
begin
  result := TFhirSubstanceDefinitionRelationship(inherited Clone);
end;

function TFhirSubstanceDefinitionRelationship.equals(other : TObject) : boolean; 
var
  o : TFhirSubstanceDefinitionRelationship;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirSubstanceDefinitionRelationship)) then
    result := false
  else
  begin
    o := TFhirSubstanceDefinitionRelationship(other);
    result := compareDeep(substanceDefinitionElement, o.substanceDefinitionElement, true) and 
      compareDeep(type_Element, o.type_Element, true) and compareDeep(isDefiningElement, o.isDefiningElement, true) and 
      compareDeep(amountElement, o.amountElement, true) and compareDeep(ratioHighLimitAmountElement, o.ratioHighLimitAmountElement, true) and 
      compareDeep(comparatorElement, o.comparatorElement, true) and compareDeep(sourceList, o.sourceList, true);
  end;
end;

function TFhirSubstanceDefinitionRelationship.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FSubstanceDefinition) and isEmptyProp(FType_) and isEmptyProp(FIsDefining) and isEmptyProp(FAmount) and isEmptyProp(FRatioHighLimitAmount) and isEmptyProp(FComparator) and isEmptyProp(FsourceList);
end;

procedure TFhirSubstanceDefinitionRelationship.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('substanceDefinition[x]');
  fields.add('type');
  fields.add('isDefining');
  fields.add('amount[x]');
  fields.add('ratioHighLimitAmount');
  fields.add('comparator');
  fields.add('source');
end;

function TFhirSubstanceDefinitionRelationship.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
  inc(result, FSourceList.sizeInBytes(magic));
end;

procedure TFhirSubstanceDefinitionRelationship.SetSubstanceDefinition(value : TFhirDataType);
begin
  FSubstanceDefinition.free;
  FSubstanceDefinition := value;
end;

procedure TFhirSubstanceDefinitionRelationship.SetType_(value : TFhirCodeableConcept);
begin
  FType_.free;
  FType_ := value;
end;

procedure TFhirSubstanceDefinitionRelationship.SetIsDefining(value : TFhirBoolean);
begin
  FIsDefining.free;
  FIsDefining := value;
end;

function TFhirSubstanceDefinitionRelationship.GetIsDefiningST : Boolean;
begin
  if FIsDefining = nil then
    result := false
  else
    result := FIsDefining.value;
end;

procedure TFhirSubstanceDefinitionRelationship.SetIsDefiningST(value : Boolean);
begin
  if FIsDefining = nil then
    FIsDefining := TFhirBoolean.create;
  FIsDefining.value := value
end;

procedure TFhirSubstanceDefinitionRelationship.SetAmount(value : TFhirDataType);
begin
  FAmount.free;
  FAmount := value;
end;

procedure TFhirSubstanceDefinitionRelationship.SetRatioHighLimitAmount(value : TFhirRatio);
begin
  FRatioHighLimitAmount.free;
  FRatioHighLimitAmount := value;
end;

procedure TFhirSubstanceDefinitionRelationship.SetComparator(value : TFhirCodeableConcept);
begin
  FComparator.free;
  FComparator := value;
end;

function TFhirSubstanceDefinitionRelationship.GetSourceList : TFhirReferenceList;
begin
  if FSourceList = nil then
    FSourceList := TFhirReferenceList.Create;
  result := FSourceList;
end;

function TFhirSubstanceDefinitionRelationship.GetHasSourceList : boolean;
begin
  result := (FSourceList <> nil) and (FSourceList.count > 0);
end;

{ TFhirSubstanceDefinitionRelationshipListEnumerator }

constructor TFhirSubstanceDefinitionRelationshipListEnumerator.Create(list : TFhirSubstanceDefinitionRelationshipList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirSubstanceDefinitionRelationshipListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirSubstanceDefinitionRelationshipListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirSubstanceDefinitionRelationshipListEnumerator.GetCurrent : TFhirSubstanceDefinitionRelationship;
begin
  Result := FList[FIndex];
end;

function TFhirSubstanceDefinitionRelationshipListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirSubstanceDefinitionRelationshipList }

function TFhirSubstanceDefinitionRelationshipList.AddItem(value: TFhirSubstanceDefinitionRelationship): TFhirSubstanceDefinitionRelationship;
begin
  assert(value.ClassName = 'TFhirSubstanceDefinitionRelationship', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirSubstanceDefinitionRelationship');
  add(value);
  result := value;
end;

function TFhirSubstanceDefinitionRelationshipList.Append: TFhirSubstanceDefinitionRelationship;
begin
  result := TFhirSubstanceDefinitionRelationship.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirSubstanceDefinitionRelationshipList.ClearItems;
begin
  Clear;
end;

function TFhirSubstanceDefinitionRelationshipList.GetEnumerator : TFhirSubstanceDefinitionRelationshipListEnumerator;
begin
  result := TFhirSubstanceDefinitionRelationshipListEnumerator.Create(self.link);
end;

function TFhirSubstanceDefinitionRelationshipList.Clone: TFhirSubstanceDefinitionRelationshipList;
begin
  result := TFhirSubstanceDefinitionRelationshipList(inherited Clone);
end;

function TFhirSubstanceDefinitionRelationshipList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirSubstanceDefinitionRelationshipList.GetItemN(index: Integer): TFhirSubstanceDefinitionRelationship;
begin
  result := TFhirSubstanceDefinitionRelationship(ObjectByIndex[index]);
end;

function TFhirSubstanceDefinitionRelationshipList.ItemClass: TFslObjectClass;
begin
  result := TFhirSubstanceDefinitionRelationship;
end;
function TFhirSubstanceDefinitionRelationshipList.IndexOf(value: TFhirSubstanceDefinitionRelationship): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirSubstanceDefinitionRelationshipList.Insert(index: Integer): TFhirSubstanceDefinitionRelationship;
begin
  result := TFhirSubstanceDefinitionRelationship.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirSubstanceDefinitionRelationshipList.InsertItem(index: Integer; value: TFhirSubstanceDefinitionRelationship);
begin
  assert(value is TFhirSubstanceDefinitionRelationship);
  Inherited Insert(index, value);
end;

function TFhirSubstanceDefinitionRelationshipList.Item(index: Integer): TFhirSubstanceDefinitionRelationship;
begin
  result := TFhirSubstanceDefinitionRelationship(ObjectByIndex[index]);
end;

function TFhirSubstanceDefinitionRelationshipList.Link: TFhirSubstanceDefinitionRelationshipList;
begin
  result := TFhirSubstanceDefinitionRelationshipList(inherited Link);
end;

procedure TFhirSubstanceDefinitionRelationshipList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirSubstanceDefinitionRelationshipList.SetItemByIndex(index: Integer; value: TFhirSubstanceDefinitionRelationship);
begin
  assert(value is TFhirSubstanceDefinitionRelationship);
  FhirSubstanceDefinitionRelationships[index] := value;
end;

procedure TFhirSubstanceDefinitionRelationshipList.SetItemN(index: Integer; value: TFhirSubstanceDefinitionRelationship);
begin
  assert(value is TFhirSubstanceDefinitionRelationship);
  ObjectByIndex[index] := value;
end;

{ TFhirSubstanceDefinitionSourceMaterial }

constructor TFhirSubstanceDefinitionSourceMaterial.Create;
begin
  inherited;
end;

destructor TFhirSubstanceDefinitionSourceMaterial.Destroy;
begin
  FType_.free;
  FGenus.free;
  FSpecies.free;
  FPart.free;
  FCountryOfOriginList.Free;
  inherited;
end;

procedure TFhirSubstanceDefinitionSourceMaterial.Assign(oSource : TFslObject);
begin
  inherited;
  type_ := TFhirSubstanceDefinitionSourceMaterial(oSource).type_.Clone;
  genus := TFhirSubstanceDefinitionSourceMaterial(oSource).genus.Clone;
  species := TFhirSubstanceDefinitionSourceMaterial(oSource).species.Clone;
  part := TFhirSubstanceDefinitionSourceMaterial(oSource).part.Clone;
  if (TFhirSubstanceDefinitionSourceMaterial(oSource).FCountryOfOriginList = nil) then
  begin
    FCountryOfOriginList.free;
    FCountryOfOriginList := nil;
  end
  else
  begin
    if FCountryOfOriginList = nil then
      FCountryOfOriginList := TFhirCodeableConceptList.Create;
    FCountryOfOriginList.Assign(TFhirSubstanceDefinitionSourceMaterial(oSource).FCountryOfOriginList);
  end;
end;

procedure TFhirSubstanceDefinitionSourceMaterial.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'type') Then
     list.add(self.link, 'type', FType_.Link);
  if (child_name = 'genus') Then
     list.add(self.link, 'genus', FGenus.Link);
  if (child_name = 'species') Then
     list.add(self.link, 'species', FSpecies.Link);
  if (child_name = 'part') Then
     list.add(self.link, 'part', FPart.Link);
  if (child_name = 'countryOfOrigin') Then
    list.addAll(self, 'countryOfOrigin', FCountryOfOriginList);
end;

procedure TFhirSubstanceDefinitionSourceMaterial.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'type', 'CodeableConcept', false, TFhirCodeableConcept, FType_.Link));
  oList.add(TFHIRProperty.create(self, 'genus', 'CodeableConcept', false, TFhirCodeableConcept, FGenus.Link));
  oList.add(TFHIRProperty.create(self, 'species', 'CodeableConcept', false, TFhirCodeableConcept, FSpecies.Link));
  oList.add(TFHIRProperty.create(self, 'part', 'CodeableConcept', false, TFhirCodeableConcept, FPart.Link));
  oList.add(TFHIRProperty.create(self, 'countryOfOrigin', 'CodeableConcept', true, TFhirCodeableConcept, FCountryOfOriginList.Link));
end;

function TFhirSubstanceDefinitionSourceMaterial.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'type') then
  begin
    Type_ := propValue as TFhirCodeableConcept;
    result := propValue;
  end
  else if (propName = 'genus') then
  begin
    Genus := propValue as TFhirCodeableConcept;
    result := propValue;
  end
  else if (propName = 'species') then
  begin
    Species := propValue as TFhirCodeableConcept;
    result := propValue;
  end
  else if (propName = 'part') then
  begin
    Part := propValue as TFhirCodeableConcept;
    result := propValue;
  end
  else if (propName = 'countryOfOrigin') then
  begin
    CountryOfOriginList.add(propValue as TFhirCodeableConcept);
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirSubstanceDefinitionSourceMaterial.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'countryOfOrigin') then CountryOfOriginList.insertItem(index, propValue as TFhirCodeableConcept)
  else inherited;
end;

function TFhirSubstanceDefinitionSourceMaterial.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'type') then result := TFhirCodeableConcept.create()
  else if (propName = 'genus') then result := TFhirCodeableConcept.create()
  else if (propName = 'species') then result := TFhirCodeableConcept.create()
  else if (propName = 'part') then result := TFhirCodeableConcept.create()
  else if (propName = 'countryOfOrigin') then result := CountryOfOriginList.new()
  else result := inherited createPropertyValue(propName);
end;

function TFhirSubstanceDefinitionSourceMaterial.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'type') then result := 'CodeableConcept'
  else if (propName = 'genus') then result := 'CodeableConcept'
  else if (propName = 'species') then result := 'CodeableConcept'
  else if (propName = 'part') then result := 'CodeableConcept'
  else if (propName = 'countryOfOrigin') then result := 'CodeableConcept'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirSubstanceDefinitionSourceMaterial.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'type') then Type_Element := nil
  else if (propName = 'genus') then GenusElement := nil
  else if (propName = 'species') then SpeciesElement := nil
  else if (propName = 'part') then PartElement := nil
  else if (propName = 'countryOfOrigin') then deletePropertyValue('countryOfOrigin', CountryOfOriginList, value)
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirSubstanceDefinitionSourceMaterial.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'type') then Type_Element := new as TFhirCodeableConcept
  else if (propName = 'genus') then GenusElement := new as TFhirCodeableConcept
  else if (propName = 'species') then SpeciesElement := new as TFhirCodeableConcept
  else if (propName = 'part') then PartElement := new as TFhirCodeableConcept
  else if (propName = 'countryOfOrigin') then replacePropertyValue('countryOfOrigin', CountryOfOriginList, existing, new)
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirSubstanceDefinitionSourceMaterial.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'countryOfOrigin') then CountryOfOriginList.move(source, destination)
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirSubstanceDefinitionSourceMaterial.fhirType : string;
begin
  result := 'SubstanceDefinition.sourceMaterial';
end;

function TFhirSubstanceDefinitionSourceMaterial.Link : TFhirSubstanceDefinitionSourceMaterial;
begin
  result := TFhirSubstanceDefinitionSourceMaterial(inherited Link);
end;

function TFhirSubstanceDefinitionSourceMaterial.Clone : TFhirSubstanceDefinitionSourceMaterial;
begin
  result := TFhirSubstanceDefinitionSourceMaterial(inherited Clone);
end;

function TFhirSubstanceDefinitionSourceMaterial.equals(other : TObject) : boolean; 
var
  o : TFhirSubstanceDefinitionSourceMaterial;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirSubstanceDefinitionSourceMaterial)) then
    result := false
  else
  begin
    o := TFhirSubstanceDefinitionSourceMaterial(other);
    result := compareDeep(type_Element, o.type_Element, true) and compareDeep(genusElement, o.genusElement, true) and 
      compareDeep(speciesElement, o.speciesElement, true) and compareDeep(partElement, o.partElement, true) and 
      compareDeep(countryOfOriginList, o.countryOfOriginList, true);
  end;
end;

function TFhirSubstanceDefinitionSourceMaterial.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FType_) and isEmptyProp(FGenus) and isEmptyProp(FSpecies) and isEmptyProp(FPart) and isEmptyProp(FcountryOfOriginList);
end;

procedure TFhirSubstanceDefinitionSourceMaterial.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('type');
  fields.add('genus');
  fields.add('species');
  fields.add('part');
  fields.add('countryOfOrigin');
end;

function TFhirSubstanceDefinitionSourceMaterial.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
  inc(result, FCountryOfOriginList.sizeInBytes(magic));
end;

procedure TFhirSubstanceDefinitionSourceMaterial.SetType_(value : TFhirCodeableConcept);
begin
  FType_.free;
  FType_ := value;
end;

procedure TFhirSubstanceDefinitionSourceMaterial.SetGenus(value : TFhirCodeableConcept);
begin
  FGenus.free;
  FGenus := value;
end;

procedure TFhirSubstanceDefinitionSourceMaterial.SetSpecies(value : TFhirCodeableConcept);
begin
  FSpecies.free;
  FSpecies := value;
end;

procedure TFhirSubstanceDefinitionSourceMaterial.SetPart(value : TFhirCodeableConcept);
begin
  FPart.free;
  FPart := value;
end;

function TFhirSubstanceDefinitionSourceMaterial.GetCountryOfOriginList : TFhirCodeableConceptList;
begin
  if FCountryOfOriginList = nil then
    FCountryOfOriginList := TFhirCodeableConceptList.Create;
  result := FCountryOfOriginList;
end;

function TFhirSubstanceDefinitionSourceMaterial.GetHasCountryOfOriginList : boolean;
begin
  result := (FCountryOfOriginList <> nil) and (FCountryOfOriginList.count > 0);
end;

{ TFhirSubstanceDefinitionSourceMaterialListEnumerator }

constructor TFhirSubstanceDefinitionSourceMaterialListEnumerator.Create(list : TFhirSubstanceDefinitionSourceMaterialList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirSubstanceDefinitionSourceMaterialListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirSubstanceDefinitionSourceMaterialListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirSubstanceDefinitionSourceMaterialListEnumerator.GetCurrent : TFhirSubstanceDefinitionSourceMaterial;
begin
  Result := FList[FIndex];
end;

function TFhirSubstanceDefinitionSourceMaterialListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirSubstanceDefinitionSourceMaterialList }

function TFhirSubstanceDefinitionSourceMaterialList.AddItem(value: TFhirSubstanceDefinitionSourceMaterial): TFhirSubstanceDefinitionSourceMaterial;
begin
  assert(value.ClassName = 'TFhirSubstanceDefinitionSourceMaterial', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirSubstanceDefinitionSourceMaterial');
  add(value);
  result := value;
end;

function TFhirSubstanceDefinitionSourceMaterialList.Append: TFhirSubstanceDefinitionSourceMaterial;
begin
  result := TFhirSubstanceDefinitionSourceMaterial.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirSubstanceDefinitionSourceMaterialList.ClearItems;
begin
  Clear;
end;

function TFhirSubstanceDefinitionSourceMaterialList.GetEnumerator : TFhirSubstanceDefinitionSourceMaterialListEnumerator;
begin
  result := TFhirSubstanceDefinitionSourceMaterialListEnumerator.Create(self.link);
end;

function TFhirSubstanceDefinitionSourceMaterialList.Clone: TFhirSubstanceDefinitionSourceMaterialList;
begin
  result := TFhirSubstanceDefinitionSourceMaterialList(inherited Clone);
end;

function TFhirSubstanceDefinitionSourceMaterialList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirSubstanceDefinitionSourceMaterialList.GetItemN(index: Integer): TFhirSubstanceDefinitionSourceMaterial;
begin
  result := TFhirSubstanceDefinitionSourceMaterial(ObjectByIndex[index]);
end;

function TFhirSubstanceDefinitionSourceMaterialList.ItemClass: TFslObjectClass;
begin
  result := TFhirSubstanceDefinitionSourceMaterial;
end;
function TFhirSubstanceDefinitionSourceMaterialList.IndexOf(value: TFhirSubstanceDefinitionSourceMaterial): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirSubstanceDefinitionSourceMaterialList.Insert(index: Integer): TFhirSubstanceDefinitionSourceMaterial;
begin
  result := TFhirSubstanceDefinitionSourceMaterial.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirSubstanceDefinitionSourceMaterialList.InsertItem(index: Integer; value: TFhirSubstanceDefinitionSourceMaterial);
begin
  assert(value is TFhirSubstanceDefinitionSourceMaterial);
  Inherited Insert(index, value);
end;

function TFhirSubstanceDefinitionSourceMaterialList.Item(index: Integer): TFhirSubstanceDefinitionSourceMaterial;
begin
  result := TFhirSubstanceDefinitionSourceMaterial(ObjectByIndex[index]);
end;

function TFhirSubstanceDefinitionSourceMaterialList.Link: TFhirSubstanceDefinitionSourceMaterialList;
begin
  result := TFhirSubstanceDefinitionSourceMaterialList(inherited Link);
end;

procedure TFhirSubstanceDefinitionSourceMaterialList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirSubstanceDefinitionSourceMaterialList.SetItemByIndex(index: Integer; value: TFhirSubstanceDefinitionSourceMaterial);
begin
  assert(value is TFhirSubstanceDefinitionSourceMaterial);
  FhirSubstanceDefinitionSourceMaterials[index] := value;
end;

procedure TFhirSubstanceDefinitionSourceMaterialList.SetItemN(index: Integer; value: TFhirSubstanceDefinitionSourceMaterial);
begin
  assert(value is TFhirSubstanceDefinitionSourceMaterial);
  ObjectByIndex[index] := value;
end;

{ TFhirSubstanceDefinition }

constructor TFhirSubstanceDefinition.Create;
begin
  inherited;
end;

destructor TFhirSubstanceDefinition.Destroy;
begin
  FIdentifierList.Free;
  FVersion.free;
  FStatus.free;
  FClassificationList.Free;
  FDomain.free;
  FGradeList.Free;
  FDescription.free;
  FInformationSourceList.Free;
  FNoteList.Free;
  FManufacturerList.Free;
  FSupplierList.Free;
  FMoietyList.Free;
  FProperty_List.Free;
  FReferenceInformation.free;
  FMolecularWeightList.Free;
  FStructure.free;
  FCodeList.Free;
  FNameList.Free;
  FRelationshipList.Free;
  FNucleicAcid.free;
  FPolymer.free;
  FProtein.free;
  FSourceMaterial.free;
  inherited;
end;

procedure TFhirSubstanceDefinition.Assign(oSource : TFslObject);
begin
  inherited;
  if (TFhirSubstanceDefinition(oSource).FIdentifierList = nil) then
  begin
    FIdentifierList.free;
    FIdentifierList := nil;
  end
  else
  begin
    if FIdentifierList = nil then
      FIdentifierList := TFhirIdentifierList.Create;
    FIdentifierList.Assign(TFhirSubstanceDefinition(oSource).FIdentifierList);
  end;
  versionElement := TFhirSubstanceDefinition(oSource).versionElement.Clone;
  status := TFhirSubstanceDefinition(oSource).status.Clone;
  if (TFhirSubstanceDefinition(oSource).FClassificationList = nil) then
  begin
    FClassificationList.free;
    FClassificationList := nil;
  end
  else
  begin
    if FClassificationList = nil then
      FClassificationList := TFhirCodeableConceptList.Create;
    FClassificationList.Assign(TFhirSubstanceDefinition(oSource).FClassificationList);
  end;
  domain := TFhirSubstanceDefinition(oSource).domain.Clone;
  if (TFhirSubstanceDefinition(oSource).FGradeList = nil) then
  begin
    FGradeList.free;
    FGradeList := nil;
  end
  else
  begin
    if FGradeList = nil then
      FGradeList := TFhirCodeableConceptList.Create;
    FGradeList.Assign(TFhirSubstanceDefinition(oSource).FGradeList);
  end;
  descriptionElement := TFhirSubstanceDefinition(oSource).descriptionElement.Clone;
  if (TFhirSubstanceDefinition(oSource).FInformationSourceList = nil) then
  begin
    FInformationSourceList.free;
    FInformationSourceList := nil;
  end
  else
  begin
    if FInformationSourceList = nil then
      FInformationSourceList := TFhirReferenceList.Create;
    FInformationSourceList.Assign(TFhirSubstanceDefinition(oSource).FInformationSourceList);
  end;
  if (TFhirSubstanceDefinition(oSource).FNoteList = nil) then
  begin
    FNoteList.free;
    FNoteList := nil;
  end
  else
  begin
    if FNoteList = nil then
      FNoteList := TFhirAnnotationList.Create;
    FNoteList.Assign(TFhirSubstanceDefinition(oSource).FNoteList);
  end;
  if (TFhirSubstanceDefinition(oSource).FManufacturerList = nil) then
  begin
    FManufacturerList.free;
    FManufacturerList := nil;
  end
  else
  begin
    if FManufacturerList = nil then
      FManufacturerList := TFhirReferenceList.Create;
    FManufacturerList.Assign(TFhirSubstanceDefinition(oSource).FManufacturerList);
  end;
  if (TFhirSubstanceDefinition(oSource).FSupplierList = nil) then
  begin
    FSupplierList.free;
    FSupplierList := nil;
  end
  else
  begin
    if FSupplierList = nil then
      FSupplierList := TFhirReferenceList.Create;
    FSupplierList.Assign(TFhirSubstanceDefinition(oSource).FSupplierList);
  end;
  if (TFhirSubstanceDefinition(oSource).FMoietyList = nil) then
  begin
    FMoietyList.free;
    FMoietyList := nil;
  end
  else
  begin
    if FMoietyList = nil then
      FMoietyList := TFhirSubstanceDefinitionMoietyList.Create;
    FMoietyList.Assign(TFhirSubstanceDefinition(oSource).FMoietyList);
  end;
  if (TFhirSubstanceDefinition(oSource).FProperty_List = nil) then
  begin
    FProperty_List.free;
    FProperty_List := nil;
  end
  else
  begin
    if FProperty_List = nil then
      FProperty_List := TFhirSubstanceDefinitionPropertyList.Create;
    FProperty_List.Assign(TFhirSubstanceDefinition(oSource).FProperty_List);
  end;
  referenceInformation := TFhirSubstanceDefinition(oSource).referenceInformation.Clone;
  if (TFhirSubstanceDefinition(oSource).FMolecularWeightList = nil) then
  begin
    FMolecularWeightList.free;
    FMolecularWeightList := nil;
  end
  else
  begin
    if FMolecularWeightList = nil then
      FMolecularWeightList := TFhirSubstanceDefinitionMolecularWeightList.Create;
    FMolecularWeightList.Assign(TFhirSubstanceDefinition(oSource).FMolecularWeightList);
  end;
  structure := TFhirSubstanceDefinition(oSource).structure.Clone;
  if (TFhirSubstanceDefinition(oSource).FCodeList = nil) then
  begin
    FCodeList.free;
    FCodeList := nil;
  end
  else
  begin
    if FCodeList = nil then
      FCodeList := TFhirSubstanceDefinitionCodeList.Create;
    FCodeList.Assign(TFhirSubstanceDefinition(oSource).FCodeList);
  end;
  if (TFhirSubstanceDefinition(oSource).FNameList = nil) then
  begin
    FNameList.free;
    FNameList := nil;
  end
  else
  begin
    if FNameList = nil then
      FNameList := TFhirSubstanceDefinitionNameList.Create;
    FNameList.Assign(TFhirSubstanceDefinition(oSource).FNameList);
  end;
  if (TFhirSubstanceDefinition(oSource).FRelationshipList = nil) then
  begin
    FRelationshipList.free;
    FRelationshipList := nil;
  end
  else
  begin
    if FRelationshipList = nil then
      FRelationshipList := TFhirSubstanceDefinitionRelationshipList.Create;
    FRelationshipList.Assign(TFhirSubstanceDefinition(oSource).FRelationshipList);
  end;
  nucleicAcid := TFhirSubstanceDefinition(oSource).nucleicAcid.Clone;
  polymer := TFhirSubstanceDefinition(oSource).polymer.Clone;
  protein := TFhirSubstanceDefinition(oSource).protein.Clone;
  sourceMaterial := TFhirSubstanceDefinition(oSource).sourceMaterial.Clone;
end;

function TFhirSubstanceDefinition.GetResourceType : TFhirResourceType;
begin
  result := frtSubstanceDefinition;
end;

procedure TFhirSubstanceDefinition.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'identifier') Then
    list.addAll(self, 'identifier', FIdentifierList);
  if (child_name = 'version') Then
     list.add(self.link, 'version', FVersion.Link);
  if (child_name = 'status') Then
     list.add(self.link, 'status', FStatus.Link);
  if (child_name = 'classification') Then
    list.addAll(self, 'classification', FClassificationList);
  if (child_name = 'domain') Then
     list.add(self.link, 'domain', FDomain.Link);
  if (child_name = 'grade') Then
    list.addAll(self, 'grade', FGradeList);
  if (child_name = 'description') Then
     list.add(self.link, 'description', FDescription.Link);
  if (child_name = 'informationSource') Then
    list.addAll(self, 'informationSource', FInformationSourceList);
  if (child_name = 'note') Then
    list.addAll(self, 'note', FNoteList);
  if (child_name = 'manufacturer') Then
    list.addAll(self, 'manufacturer', FManufacturerList);
  if (child_name = 'supplier') Then
    list.addAll(self, 'supplier', FSupplierList);
  if (child_name = 'moiety') Then
    list.addAll(self, 'moiety', FMoietyList);
  if (child_name = 'property') Then
    list.addAll(self, 'property', FProperty_List);
  if (child_name = 'referenceInformation') Then
     list.add(self.link, 'referenceInformation', FReferenceInformation.Link);
  if (child_name = 'molecularWeight') Then
    list.addAll(self, 'molecularWeight', FMolecularWeightList);
  if (child_name = 'structure') Then
     list.add(self.link, 'structure', FStructure.Link);
  if (child_name = 'code') Then
    list.addAll(self, 'code', FCodeList);
  if (child_name = 'name') Then
    list.addAll(self, 'name', FNameList);
  if (child_name = 'relationship') Then
    list.addAll(self, 'relationship', FRelationshipList);
  if (child_name = 'nucleicAcid') Then
     list.add(self.link, 'nucleicAcid', FNucleicAcid.Link);
  if (child_name = 'polymer') Then
     list.add(self.link, 'polymer', FPolymer.Link);
  if (child_name = 'protein') Then
     list.add(self.link, 'protein', FProtein.Link);
  if (child_name = 'sourceMaterial') Then
     list.add(self.link, 'sourceMaterial', FSourceMaterial.Link);
end;

procedure TFhirSubstanceDefinition.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'identifier', 'Identifier', true, TFhirIdentifier, FIdentifierList.Link));
  oList.add(TFHIRProperty.create(self, 'version', 'string', false, TFhirString, FVersion.Link));
  oList.add(TFHIRProperty.create(self, 'status', 'CodeableConcept', false, TFhirCodeableConcept, FStatus.Link));
  oList.add(TFHIRProperty.create(self, 'classification', 'CodeableConcept', true, TFhirCodeableConcept, FClassificationList.Link));
  oList.add(TFHIRProperty.create(self, 'domain', 'CodeableConcept', false, TFhirCodeableConcept, FDomain.Link));
  oList.add(TFHIRProperty.create(self, 'grade', 'CodeableConcept', true, TFhirCodeableConcept, FGradeList.Link));
  oList.add(TFHIRProperty.create(self, 'description', 'markdown', false, TFhirMarkdown, FDescription.Link));
  oList.add(TFHIRProperty.create(self, 'informationSource', 'Reference', true, TFhirReference, FInformationSourceList.Link));
  oList.add(TFHIRProperty.create(self, 'note', 'Annotation', true, TFhirAnnotation, FNoteList.Link));
  oList.add(TFHIRProperty.create(self, 'manufacturer', 'Reference', true, TFhirReference, FManufacturerList.Link));
  oList.add(TFHIRProperty.create(self, 'supplier', 'Reference', true, TFhirReference, FSupplierList.Link));
  oList.add(TFHIRProperty.create(self, 'moiety', 'BackboneElement', true, TFhirSubstanceDefinitionMoiety, FMoietyList.Link));
  oList.add(TFHIRProperty.create(self, 'property', 'BackboneElement', true, TFhirSubstanceDefinitionProperty, FProperty_List.Link));
  oList.add(TFHIRProperty.create(self, 'referenceInformation', 'Reference', false, TFhirReference, FReferenceInformation.Link));
  oList.add(TFHIRProperty.create(self, 'molecularWeight', 'BackboneElement', true, TFhirSubstanceDefinitionMolecularWeight, FMolecularWeightList.Link));
  oList.add(TFHIRProperty.create(self, 'structure', 'BackboneElement', false, TFhirSubstanceDefinitionStructure, FStructure.Link));
  oList.add(TFHIRProperty.create(self, 'code', 'BackboneElement', true, TFhirSubstanceDefinitionCode, FCodeList.Link));
  oList.add(TFHIRProperty.create(self, 'name', 'BackboneElement', true, TFhirSubstanceDefinitionName, FNameList.Link));
  oList.add(TFHIRProperty.create(self, 'relationship', 'BackboneElement', true, TFhirSubstanceDefinitionRelationship, FRelationshipList.Link));
  oList.add(TFHIRProperty.create(self, 'nucleicAcid', 'Reference', false, TFhirReference, FNucleicAcid.Link));
  oList.add(TFHIRProperty.create(self, 'polymer', 'Reference', false, TFhirReference, FPolymer.Link));
  oList.add(TFHIRProperty.create(self, 'protein', 'Reference', false, TFhirReference, FProtein.Link));
  oList.add(TFHIRProperty.create(self, 'sourceMaterial', 'BackboneElement', false, TFhirSubstanceDefinitionSourceMaterial, FSourceMaterial.Link));
end;

function TFhirSubstanceDefinition.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'identifier') then
  begin
    IdentifierList.add(propValue as TFhirIdentifier);
    result := propValue;
  end
  else if (propName = 'version') then
  begin
    VersionElement := asString(propValue);
    result := propValue;
  end
  else if (propName = 'status') then
  begin
    Status := propValue as TFhirCodeableConcept;
    result := propValue;
  end
  else if (propName = 'classification') then
  begin
    ClassificationList.add(propValue as TFhirCodeableConcept);
    result := propValue;
  end
  else if (propName = 'domain') then
  begin
    Domain := propValue as TFhirCodeableConcept;
    result := propValue;
  end
  else if (propName = 'grade') then
  begin
    GradeList.add(propValue as TFhirCodeableConcept);
    result := propValue;
  end
  else if (propName = 'description') then
  begin
    DescriptionElement := asMarkdown(propValue);
    result := propValue;
  end
  else if (propName = 'informationSource') then
  begin
    InformationSourceList.add(propValue as TFhirReference);
    result := propValue;
  end
  else if (propName = 'note') then
  begin
    NoteList.add(propValue as TFhirAnnotation);
    result := propValue;
  end
  else if (propName = 'manufacturer') then
  begin
    ManufacturerList.add(propValue as TFhirReference);
    result := propValue;
  end
  else if (propName = 'supplier') then
  begin
    SupplierList.add(propValue as TFhirReference);
    result := propValue;
  end
  else if (propName = 'moiety') then
  begin
    MoietyList.add(propValue as TFhirSubstanceDefinitionMoiety);
    result := propValue;
  end
  else if (propName = 'property') then
  begin
    Property_List.add(propValue as TFhirSubstanceDefinitionProperty);
    result := propValue;
  end
  else if (propName = 'referenceInformation') then
  begin
    ReferenceInformation := propValue as TFhirReference;
    result := propValue;
  end
  else if (propName = 'molecularWeight') then
  begin
    MolecularWeightList.add(propValue as TFhirSubstanceDefinitionMolecularWeight);
    result := propValue;
  end
  else if (propName = 'structure') then
  begin
    Structure := propValue as TFhirSubstanceDefinitionStructure;
    result := propValue;
  end
  else if (propName = 'code') then
  begin
    CodeList.add(propValue as TFhirSubstanceDefinitionCode);
    result := propValue;
  end
  else if (propName = 'name') then
  begin
    NameList.add(propValue as TFhirSubstanceDefinitionName);
    result := propValue;
  end
  else if (propName = 'relationship') then
  begin
    RelationshipList.add(propValue as TFhirSubstanceDefinitionRelationship);
    result := propValue;
  end
  else if (propName = 'nucleicAcid') then
  begin
    NucleicAcid := propValue as TFhirReference;
    result := propValue;
  end
  else if (propName = 'polymer') then
  begin
    Polymer := propValue as TFhirReference;
    result := propValue;
  end
  else if (propName = 'protein') then
  begin
    Protein := propValue as TFhirReference;
    result := propValue;
  end
  else if (propName = 'sourceMaterial') then
  begin
    SourceMaterial := propValue as TFhirSubstanceDefinitionSourceMaterial;
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirSubstanceDefinition.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'identifier') then IdentifierList.insertItem(index, propValue as TFhirIdentifier)
  else if (propName = 'classification') then ClassificationList.insertItem(index, propValue as TFhirCodeableConcept)
  else if (propName = 'grade') then GradeList.insertItem(index, propValue as TFhirCodeableConcept)
  else if (propName = 'informationSource') then InformationSourceList.insertItem(index, propValue as TFhirReference)
  else if (propName = 'note') then NoteList.insertItem(index, propValue as TFhirAnnotation)
  else if (propName = 'manufacturer') then ManufacturerList.insertItem(index, propValue as TFhirReference)
  else if (propName = 'supplier') then SupplierList.insertItem(index, propValue as TFhirReference)
  else if (propName = 'moiety') then MoietyList.insertItem(index, propValue as TFhirSubstanceDefinitionMoiety)
  else if (propName = 'property') then Property_List.insertItem(index, propValue as TFhirSubstanceDefinitionProperty)
  else if (propName = 'molecularWeight') then MolecularWeightList.insertItem(index, propValue as TFhirSubstanceDefinitionMolecularWeight)
  else if (propName = 'code') then CodeList.insertItem(index, propValue as TFhirSubstanceDefinitionCode)
  else if (propName = 'name') then NameList.insertItem(index, propValue as TFhirSubstanceDefinitionName)
  else if (propName = 'relationship') then RelationshipList.insertItem(index, propValue as TFhirSubstanceDefinitionRelationship)
  else inherited;
end;

function TFhirSubstanceDefinition.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'identifier') then result := IdentifierList.new()
  else if (propName = 'version') then result := TFhirString.create()
  else if (propName = 'status') then result := TFhirCodeableConcept.create()
  else if (propName = 'classification') then result := ClassificationList.new()
  else if (propName = 'domain') then result := TFhirCodeableConcept.create()
  else if (propName = 'grade') then result := GradeList.new()
  else if (propName = 'description') then result := TFhirMarkdown.create()
  else if (propName = 'informationSource') then result := InformationSourceList.new()
  else if (propName = 'note') then result := NoteList.new()
  else if (propName = 'manufacturer') then result := ManufacturerList.new()
  else if (propName = 'supplier') then result := SupplierList.new()
  else if (propName = 'moiety') then result := MoietyList.new()
  else if (propName = 'property') then result := Property_List.new()
  else if (propName = 'referenceInformation') then result := TFhirReference.create()
  else if (propName = 'molecularWeight') then result := MolecularWeightList.new()
  else if (propName = 'structure') then result := TFhirSubstanceDefinitionStructure.create()
  else if (propName = 'code') then result := CodeList.new()
  else if (propName = 'name') then result := NameList.new()
  else if (propName = 'relationship') then result := RelationshipList.new()
  else if (propName = 'nucleicAcid') then result := TFhirReference.create()
  else if (propName = 'polymer') then result := TFhirReference.create()
  else if (propName = 'protein') then result := TFhirReference.create()
  else if (propName = 'sourceMaterial') then result := TFhirSubstanceDefinitionSourceMaterial.create()
  else result := inherited createPropertyValue(propName);
end;

function TFhirSubstanceDefinition.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'identifier') then result := 'Identifier'
  else if (propName = 'version') then result := 'string'
  else if (propName = 'status') then result := 'CodeableConcept'
  else if (propName = 'classification') then result := 'CodeableConcept'
  else if (propName = 'domain') then result := 'CodeableConcept'
  else if (propName = 'grade') then result := 'CodeableConcept'
  else if (propName = 'description') then result := 'markdown'
  else if (propName = 'informationSource') then result := 'Reference'
  else if (propName = 'note') then result := 'Annotation'
  else if (propName = 'manufacturer') then result := 'Reference'
  else if (propName = 'supplier') then result := 'Reference'
  else if (propName = 'moiety') then result := 'BackboneElement'
  else if (propName = 'property') then result := 'BackboneElement'
  else if (propName = 'referenceInformation') then result := 'Reference'
  else if (propName = 'molecularWeight') then result := 'BackboneElement'
  else if (propName = 'structure') then result := 'BackboneElement'
  else if (propName = 'code') then result := 'BackboneElement'
  else if (propName = 'name') then result := 'BackboneElement'
  else if (propName = 'relationship') then result := 'BackboneElement'
  else if (propName = 'nucleicAcid') then result := 'Reference'
  else if (propName = 'polymer') then result := 'Reference'
  else if (propName = 'protein') then result := 'Reference'
  else if (propName = 'sourceMaterial') then result := 'BackboneElement'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirSubstanceDefinition.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'identifier') then deletePropertyValue('identifier', IdentifierList, value)
  else if (propName = 'version') then VersionElement := nil
  else if (propName = 'status') then StatusElement := nil
  else if (propName = 'classification') then deletePropertyValue('classification', ClassificationList, value)
  else if (propName = 'domain') then DomainElement := nil
  else if (propName = 'grade') then deletePropertyValue('grade', GradeList, value)
  else if (propName = 'description') then DescriptionElement := nil
  else if (propName = 'informationSource') then deletePropertyValue('informationSource', InformationSourceList, value)
  else if (propName = 'note') then deletePropertyValue('note', NoteList, value)
  else if (propName = 'manufacturer') then deletePropertyValue('manufacturer', ManufacturerList, value)
  else if (propName = 'supplier') then deletePropertyValue('supplier', SupplierList, value)
  else if (propName = 'moiety') then deletePropertyValue('moiety', MoietyList, value)
  else if (propName = 'property') then deletePropertyValue('property', Property_List, value)
  else if (propName = 'referenceInformation') then ReferenceInformationElement := nil
  else if (propName = 'molecularWeight') then deletePropertyValue('molecularWeight', MolecularWeightList, value)
  else if (propName = 'structure') then StructureElement := nil
  else if (propName = 'code') then deletePropertyValue('code', CodeList, value)
  else if (propName = 'name') then deletePropertyValue('name', NameList, value)
  else if (propName = 'relationship') then deletePropertyValue('relationship', RelationshipList, value)
  else if (propName = 'nucleicAcid') then NucleicAcidElement := nil
  else if (propName = 'polymer') then PolymerElement := nil
  else if (propName = 'protein') then ProteinElement := nil
  else if (propName = 'sourceMaterial') then SourceMaterialElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirSubstanceDefinition.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'identifier') then replacePropertyValue('identifier', IdentifierList, existing, new)
  else if (propName = 'version') then VersionElement := asString(new)
  else if (propName = 'status') then StatusElement := new as TFhirCodeableConcept
  else if (propName = 'classification') then replacePropertyValue('classification', ClassificationList, existing, new)
  else if (propName = 'domain') then DomainElement := new as TFhirCodeableConcept
  else if (propName = 'grade') then replacePropertyValue('grade', GradeList, existing, new)
  else if (propName = 'description') then DescriptionElement := asMarkdown(new)
  else if (propName = 'informationSource') then replacePropertyValue('informationSource', InformationSourceList, existing, new)
  else if (propName = 'note') then replacePropertyValue('note', NoteList, existing, new)
  else if (propName = 'manufacturer') then replacePropertyValue('manufacturer', ManufacturerList, existing, new)
  else if (propName = 'supplier') then replacePropertyValue('supplier', SupplierList, existing, new)
  else if (propName = 'moiety') then replacePropertyValue('moiety', MoietyList, existing, new)
  else if (propName = 'property') then replacePropertyValue('property', Property_List, existing, new)
  else if (propName = 'referenceInformation') then ReferenceInformationElement := new as TFhirReference
  else if (propName = 'molecularWeight') then replacePropertyValue('molecularWeight', MolecularWeightList, existing, new)
  else if (propName = 'structure') then StructureElement := new as TFhirSubstanceDefinitionStructure
  else if (propName = 'code') then replacePropertyValue('code', CodeList, existing, new)
  else if (propName = 'name') then replacePropertyValue('name', NameList, existing, new)
  else if (propName = 'relationship') then replacePropertyValue('relationship', RelationshipList, existing, new)
  else if (propName = 'nucleicAcid') then NucleicAcidElement := new as TFhirReference
  else if (propName = 'polymer') then PolymerElement := new as TFhirReference
  else if (propName = 'protein') then ProteinElement := new as TFhirReference
  else if (propName = 'sourceMaterial') then SourceMaterialElement := new as TFhirSubstanceDefinitionSourceMaterial
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirSubstanceDefinition.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'identifier') then IdentifierList.move(source, destination)
  else if (propName = 'classification') then ClassificationList.move(source, destination)
  else if (propName = 'grade') then GradeList.move(source, destination)
  else if (propName = 'informationSource') then InformationSourceList.move(source, destination)
  else if (propName = 'note') then NoteList.move(source, destination)
  else if (propName = 'manufacturer') then ManufacturerList.move(source, destination)
  else if (propName = 'supplier') then SupplierList.move(source, destination)
  else if (propName = 'moiety') then MoietyList.move(source, destination)
  else if (propName = 'property') then Property_List.move(source, destination)
  else if (propName = 'molecularWeight') then MolecularWeightList.move(source, destination)
  else if (propName = 'code') then CodeList.move(source, destination)
  else if (propName = 'name') then NameList.move(source, destination)
  else if (propName = 'relationship') then RelationshipList.move(source, destination)
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirSubstanceDefinition.fhirType : string;
begin
  result := 'SubstanceDefinition';
end;

function TFhirSubstanceDefinition.Link : TFhirSubstanceDefinition;
begin
  result := TFhirSubstanceDefinition(inherited Link);
end;

function TFhirSubstanceDefinition.Clone : TFhirSubstanceDefinition;
begin
  result := TFhirSubstanceDefinition(inherited Clone);
end;

function TFhirSubstanceDefinition.equals(other : TObject) : boolean; 
var
  o : TFhirSubstanceDefinition;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirSubstanceDefinition)) then
    result := false
  else
  begin
    o := TFhirSubstanceDefinition(other);
    result := compareDeep(identifierList, o.identifierList, true) and compareDeep(versionElement, o.versionElement, true) and 
      compareDeep(statusElement, o.statusElement, true) and compareDeep(classificationList, o.classificationList, true) and 
      compareDeep(domainElement, o.domainElement, true) and compareDeep(gradeList, o.gradeList, true) and 
      compareDeep(descriptionElement, o.descriptionElement, true) and compareDeep(informationSourceList, o.informationSourceList, true) and 
      compareDeep(noteList, o.noteList, true) and compareDeep(manufacturerList, o.manufacturerList, true) and 
      compareDeep(supplierList, o.supplierList, true) and compareDeep(moietyList, o.moietyList, true) and 
      compareDeep(property_List, o.property_List, true) and compareDeep(referenceInformationElement, o.referenceInformationElement, true) and 
      compareDeep(molecularWeightList, o.molecularWeightList, true) and compareDeep(structureElement, o.structureElement, true) and 
      compareDeep(codeList, o.codeList, true) and compareDeep(nameList, o.nameList, true) and 
      compareDeep(relationshipList, o.relationshipList, true) and compareDeep(nucleicAcidElement, o.nucleicAcidElement, true) and 
      compareDeep(polymerElement, o.polymerElement, true) and compareDeep(proteinElement, o.proteinElement, true) and 
      compareDeep(sourceMaterialElement, o.sourceMaterialElement, true);
  end;
end;

function TFhirSubstanceDefinition.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FidentifierList) and isEmptyProp(FVersion) and isEmptyProp(FStatus) and isEmptyProp(FclassificationList) and isEmptyProp(FDomain) and isEmptyProp(FgradeList) and isEmptyProp(FDescription) and isEmptyProp(FinformationSourceList) and isEmptyProp(FnoteList) and isEmptyProp(FmanufacturerList) and isEmptyProp(FsupplierList) and isEmptyProp(FmoietyList) and isEmptyProp(Fproperty_List) and isEmptyProp(FReferenceInformation) and isEmptyProp(FmolecularWeightList) and isEmptyProp(FStructure) and isEmptyProp(FcodeList) and isEmptyProp(FnameList) and isEmptyProp(FrelationshipList) and isEmptyProp(FNucleicAcid) and isEmptyProp(FPolymer) and isEmptyProp(FProtein) and isEmptyProp(FSourceMaterial);
end;

procedure TFhirSubstanceDefinition.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('identifier');
  fields.add('version');
  fields.add('status');
  fields.add('classification');
  fields.add('domain');
  fields.add('grade');
  fields.add('description');
  fields.add('informationSource');
  fields.add('note');
  fields.add('manufacturer');
  fields.add('supplier');
  fields.add('moiety');
  fields.add('property');
  fields.add('referenceInformation');
  fields.add('molecularWeight');
  fields.add('structure');
  fields.add('code');
  fields.add('name');
  fields.add('relationship');
  fields.add('nucleicAcid');
  fields.add('polymer');
  fields.add('protein');
  fields.add('sourceMaterial');
end;

function TFhirSubstanceDefinition.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
  inc(result, FIdentifierList.sizeInBytes(magic));
  inc(result, FClassificationList.sizeInBytes(magic));
  inc(result, FGradeList.sizeInBytes(magic));
  inc(result, FInformationSourceList.sizeInBytes(magic));
  inc(result, FNoteList.sizeInBytes(magic));
  inc(result, FManufacturerList.sizeInBytes(magic));
  inc(result, FSupplierList.sizeInBytes(magic));
  inc(result, FMoietyList.sizeInBytes(magic));
  inc(result, FProperty_List.sizeInBytes(magic));
  inc(result, FMolecularWeightList.sizeInBytes(magic));
  inc(result, FCodeList.sizeInBytes(magic));
  inc(result, FNameList.sizeInBytes(magic));
  inc(result, FRelationshipList.sizeInBytes(magic));
end;

function TFhirSubstanceDefinition.GetIdentifierList : TFhirIdentifierList;
begin
  if FIdentifierList = nil then
    FIdentifierList := TFhirIdentifierList.Create;
  result := FIdentifierList;
end;

function TFhirSubstanceDefinition.GetHasIdentifierList : boolean;
begin
  result := (FIdentifierList <> nil) and (FIdentifierList.count > 0);
end;

procedure TFhirSubstanceDefinition.SetVersion(value : TFhirString);
begin
  FVersion.free;
  FVersion := value;
end;

function TFhirSubstanceDefinition.GetVersionST : String;
begin
  if FVersion = nil then
    result := ''
  else
    result := FVersion.value;
end;

procedure TFhirSubstanceDefinition.SetVersionST(value : String);
begin
  if value <> '' then
  begin
    if FVersion = nil then
      FVersion := TFhirString.create;
    FVersion.value := value
  end
  else if FVersion <> nil then
    FVersion.value := '';
end;

procedure TFhirSubstanceDefinition.SetStatus(value : TFhirCodeableConcept);
begin
  FStatus.free;
  FStatus := value;
end;

function TFhirSubstanceDefinition.GetClassificationList : TFhirCodeableConceptList;
begin
  if FClassificationList = nil then
    FClassificationList := TFhirCodeableConceptList.Create;
  result := FClassificationList;
end;

function TFhirSubstanceDefinition.GetHasClassificationList : boolean;
begin
  result := (FClassificationList <> nil) and (FClassificationList.count > 0);
end;

procedure TFhirSubstanceDefinition.SetDomain(value : TFhirCodeableConcept);
begin
  FDomain.free;
  FDomain := value;
end;

function TFhirSubstanceDefinition.GetGradeList : TFhirCodeableConceptList;
begin
  if FGradeList = nil then
    FGradeList := TFhirCodeableConceptList.Create;
  result := FGradeList;
end;

function TFhirSubstanceDefinition.GetHasGradeList : boolean;
begin
  result := (FGradeList <> nil) and (FGradeList.count > 0);
end;

procedure TFhirSubstanceDefinition.SetDescription(value : TFhirMarkdown);
begin
  FDescription.free;
  FDescription := value;
end;

function TFhirSubstanceDefinition.GetDescriptionST : String;
begin
  if FDescription = nil then
    result := ''
  else
    result := FDescription.value;
end;

procedure TFhirSubstanceDefinition.SetDescriptionST(value : String);
begin
  if value <> '' then
  begin
    if FDescription = nil then
      FDescription := TFhirMarkdown.create;
    FDescription.value := value
  end
  else if FDescription <> nil then
    FDescription.value := '';
end;

function TFhirSubstanceDefinition.GetInformationSourceList : TFhirReferenceList;
begin
  if FInformationSourceList = nil then
    FInformationSourceList := TFhirReferenceList.Create;
  result := FInformationSourceList;
end;

function TFhirSubstanceDefinition.GetHasInformationSourceList : boolean;
begin
  result := (FInformationSourceList <> nil) and (FInformationSourceList.count > 0);
end;

function TFhirSubstanceDefinition.GetNoteList : TFhirAnnotationList;
begin
  if FNoteList = nil then
    FNoteList := TFhirAnnotationList.Create;
  result := FNoteList;
end;

function TFhirSubstanceDefinition.GetHasNoteList : boolean;
begin
  result := (FNoteList <> nil) and (FNoteList.count > 0);
end;

function TFhirSubstanceDefinition.GetManufacturerList : TFhirReferenceList;
begin
  if FManufacturerList = nil then
    FManufacturerList := TFhirReferenceList.Create;
  result := FManufacturerList;
end;

function TFhirSubstanceDefinition.GetHasManufacturerList : boolean;
begin
  result := (FManufacturerList <> nil) and (FManufacturerList.count > 0);
end;

function TFhirSubstanceDefinition.GetSupplierList : TFhirReferenceList;
begin
  if FSupplierList = nil then
    FSupplierList := TFhirReferenceList.Create;
  result := FSupplierList;
end;

function TFhirSubstanceDefinition.GetHasSupplierList : boolean;
begin
  result := (FSupplierList <> nil) and (FSupplierList.count > 0);
end;

function TFhirSubstanceDefinition.GetMoietyList : TFhirSubstanceDefinitionMoietyList;
begin
  if FMoietyList = nil then
    FMoietyList := TFhirSubstanceDefinitionMoietyList.Create;
  result := FMoietyList;
end;

function TFhirSubstanceDefinition.GetHasMoietyList : boolean;
begin
  result := (FMoietyList <> nil) and (FMoietyList.count > 0);
end;

function TFhirSubstanceDefinition.GetProperty_List : TFhirSubstanceDefinitionPropertyList;
begin
  if FProperty_List = nil then
    FProperty_List := TFhirSubstanceDefinitionPropertyList.Create;
  result := FProperty_List;
end;

function TFhirSubstanceDefinition.GetHasProperty_List : boolean;
begin
  result := (FProperty_List <> nil) and (FProperty_List.count > 0);
end;

procedure TFhirSubstanceDefinition.SetReferenceInformation(value : TFhirReference);
begin
  FReferenceInformation.free;
  FReferenceInformation := value;
end;

function TFhirSubstanceDefinition.GetMolecularWeightList : TFhirSubstanceDefinitionMolecularWeightList;
begin
  if FMolecularWeightList = nil then
    FMolecularWeightList := TFhirSubstanceDefinitionMolecularWeightList.Create;
  result := FMolecularWeightList;
end;

function TFhirSubstanceDefinition.GetHasMolecularWeightList : boolean;
begin
  result := (FMolecularWeightList <> nil) and (FMolecularWeightList.count > 0);
end;

procedure TFhirSubstanceDefinition.SetStructure(value : TFhirSubstanceDefinitionStructure);
begin
  FStructure.free;
  FStructure := value;
end;

function TFhirSubstanceDefinition.GetCodeList : TFhirSubstanceDefinitionCodeList;
begin
  if FCodeList = nil then
    FCodeList := TFhirSubstanceDefinitionCodeList.Create;
  result := FCodeList;
end;

function TFhirSubstanceDefinition.GetHasCodeList : boolean;
begin
  result := (FCodeList <> nil) and (FCodeList.count > 0);
end;

function TFhirSubstanceDefinition.GetNameList : TFhirSubstanceDefinitionNameList;
begin
  if FNameList = nil then
    FNameList := TFhirSubstanceDefinitionNameList.Create;
  result := FNameList;
end;

function TFhirSubstanceDefinition.GetHasNameList : boolean;
begin
  result := (FNameList <> nil) and (FNameList.count > 0);
end;

function TFhirSubstanceDefinition.GetRelationshipList : TFhirSubstanceDefinitionRelationshipList;
begin
  if FRelationshipList = nil then
    FRelationshipList := TFhirSubstanceDefinitionRelationshipList.Create;
  result := FRelationshipList;
end;

function TFhirSubstanceDefinition.GetHasRelationshipList : boolean;
begin
  result := (FRelationshipList <> nil) and (FRelationshipList.count > 0);
end;

procedure TFhirSubstanceDefinition.SetNucleicAcid(value : TFhirReference);
begin
  FNucleicAcid.free;
  FNucleicAcid := value;
end;

procedure TFhirSubstanceDefinition.SetPolymer(value : TFhirReference);
begin
  FPolymer.free;
  FPolymer := value;
end;

procedure TFhirSubstanceDefinition.SetProtein(value : TFhirReference);
begin
  FProtein.free;
  FProtein := value;
end;

procedure TFhirSubstanceDefinition.SetSourceMaterial(value : TFhirSubstanceDefinitionSourceMaterial);
begin
  FSourceMaterial.free;
  FSourceMaterial := value;
end;

{ TFhirSubstanceDefinitionListEnumerator }

constructor TFhirSubstanceDefinitionListEnumerator.Create(list : TFhirSubstanceDefinitionList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirSubstanceDefinitionListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirSubstanceDefinitionListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirSubstanceDefinitionListEnumerator.GetCurrent : TFhirSubstanceDefinition;
begin
  Result := FList[FIndex];
end;

function TFhirSubstanceDefinitionListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirSubstanceDefinitionList }

function TFhirSubstanceDefinitionList.AddItem(value: TFhirSubstanceDefinition): TFhirSubstanceDefinition;
begin
  assert(value.ClassName = 'TFhirSubstanceDefinition', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirSubstanceDefinition');
  add(value);
  result := value;
end;

function TFhirSubstanceDefinitionList.Append: TFhirSubstanceDefinition;
begin
  result := TFhirSubstanceDefinition.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirSubstanceDefinitionList.ClearItems;
begin
  Clear;
end;

function TFhirSubstanceDefinitionList.GetEnumerator : TFhirSubstanceDefinitionListEnumerator;
begin
  result := TFhirSubstanceDefinitionListEnumerator.Create(self.link);
end;

function TFhirSubstanceDefinitionList.Clone: TFhirSubstanceDefinitionList;
begin
  result := TFhirSubstanceDefinitionList(inherited Clone);
end;

function TFhirSubstanceDefinitionList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirSubstanceDefinitionList.GetItemN(index: Integer): TFhirSubstanceDefinition;
begin
  result := TFhirSubstanceDefinition(ObjectByIndex[index]);
end;

function TFhirSubstanceDefinitionList.ItemClass: TFslObjectClass;
begin
  result := TFhirSubstanceDefinition;
end;
function TFhirSubstanceDefinitionList.IndexOf(value: TFhirSubstanceDefinition): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirSubstanceDefinitionList.Insert(index: Integer): TFhirSubstanceDefinition;
begin
  result := TFhirSubstanceDefinition.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirSubstanceDefinitionList.InsertItem(index: Integer; value: TFhirSubstanceDefinition);
begin
  assert(value is TFhirSubstanceDefinition);
  Inherited Insert(index, value);
end;

function TFhirSubstanceDefinitionList.Item(index: Integer): TFhirSubstanceDefinition;
begin
  result := TFhirSubstanceDefinition(ObjectByIndex[index]);
end;

function TFhirSubstanceDefinitionList.Link: TFhirSubstanceDefinitionList;
begin
  result := TFhirSubstanceDefinitionList(inherited Link);
end;

procedure TFhirSubstanceDefinitionList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirSubstanceDefinitionList.SetItemByIndex(index: Integer; value: TFhirSubstanceDefinition);
begin
  assert(value is TFhirSubstanceDefinition);
  FhirSubstanceDefinitions[index] := value;
end;

procedure TFhirSubstanceDefinitionList.SetItemN(index: Integer; value: TFhirSubstanceDefinition);
begin
  assert(value is TFhirSubstanceDefinition);
  ObjectByIndex[index] := value;
end;

{$ENDIF FHIR_SUBSTANCEDEFINITION}
{$IFDEF FHIR_SUBSTANCENUCLEICACID}
{ TFhirSubstanceNucleicAcidSubunit }

constructor TFhirSubstanceNucleicAcidSubunit.Create;
begin
  inherited;
end;

destructor TFhirSubstanceNucleicAcidSubunit.Destroy;
begin
  FSubunit.free;
  FSequence.free;
  FLength.free;
  FSequenceAttachment.free;
  FFivePrime.free;
  FThreePrime.free;
  FLinkageList.Free;
  FSugarList.Free;
  inherited;
end;

procedure TFhirSubstanceNucleicAcidSubunit.Assign(oSource : TFslObject);
begin
  inherited;
  subunitElement := TFhirSubstanceNucleicAcidSubunit(oSource).subunitElement.Clone;
  sequenceElement := TFhirSubstanceNucleicAcidSubunit(oSource).sequenceElement.Clone;
  lengthElement := TFhirSubstanceNucleicAcidSubunit(oSource).lengthElement.Clone;
  sequenceAttachment := TFhirSubstanceNucleicAcidSubunit(oSource).sequenceAttachment.Clone;
  fivePrime := TFhirSubstanceNucleicAcidSubunit(oSource).fivePrime.Clone;
  threePrime := TFhirSubstanceNucleicAcidSubunit(oSource).threePrime.Clone;
  if (TFhirSubstanceNucleicAcidSubunit(oSource).FLinkageList = nil) then
  begin
    FLinkageList.free;
    FLinkageList := nil;
  end
  else
  begin
    if FLinkageList = nil then
      FLinkageList := TFhirSubstanceNucleicAcidSubunitLinkageList.Create;
    FLinkageList.Assign(TFhirSubstanceNucleicAcidSubunit(oSource).FLinkageList);
  end;
  if (TFhirSubstanceNucleicAcidSubunit(oSource).FSugarList = nil) then
  begin
    FSugarList.free;
    FSugarList := nil;
  end
  else
  begin
    if FSugarList = nil then
      FSugarList := TFhirSubstanceNucleicAcidSubunitSugarList.Create;
    FSugarList.Assign(TFhirSubstanceNucleicAcidSubunit(oSource).FSugarList);
  end;
end;

procedure TFhirSubstanceNucleicAcidSubunit.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'subunit') Then
     list.add(self.link, 'subunit', FSubunit.Link);
  if (child_name = 'sequence') Then
     list.add(self.link, 'sequence', FSequence.Link);
  if (child_name = 'length') Then
     list.add(self.link, 'length', FLength.Link);
  if (child_name = 'sequenceAttachment') Then
     list.add(self.link, 'sequenceAttachment', FSequenceAttachment.Link);
  if (child_name = 'fivePrime') Then
     list.add(self.link, 'fivePrime', FFivePrime.Link);
  if (child_name = 'threePrime') Then
     list.add(self.link, 'threePrime', FThreePrime.Link);
  if (child_name = 'linkage') Then
    list.addAll(self, 'linkage', FLinkageList);
  if (child_name = 'sugar') Then
    list.addAll(self, 'sugar', FSugarList);
end;

procedure TFhirSubstanceNucleicAcidSubunit.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'subunit', 'integer', false, TFhirInteger, FSubunit.Link));
  oList.add(TFHIRProperty.create(self, 'sequence', 'string', false, TFhirString, FSequence.Link));
  oList.add(TFHIRProperty.create(self, 'length', 'integer', false, TFhirInteger, FLength.Link));
  oList.add(TFHIRProperty.create(self, 'sequenceAttachment', 'Attachment', false, TFhirAttachment, FSequenceAttachment.Link));
  oList.add(TFHIRProperty.create(self, 'fivePrime', 'CodeableConcept', false, TFhirCodeableConcept, FFivePrime.Link));
  oList.add(TFHIRProperty.create(self, 'threePrime', 'CodeableConcept', false, TFhirCodeableConcept, FThreePrime.Link));
  oList.add(TFHIRProperty.create(self, 'linkage', 'BackboneElement', true, TFhirSubstanceNucleicAcidSubunitLinkage, FLinkageList.Link));
  oList.add(TFHIRProperty.create(self, 'sugar', 'BackboneElement', true, TFhirSubstanceNucleicAcidSubunitSugar, FSugarList.Link));
end;

function TFhirSubstanceNucleicAcidSubunit.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'subunit') then
  begin
    SubunitElement := asInteger(propValue);
    result := propValue;
  end
  else if (propName = 'sequence') then
  begin
    SequenceElement := asString(propValue);
    result := propValue;
  end
  else if (propName = 'length') then
  begin
    LengthElement := asInteger(propValue);
    result := propValue;
  end
  else if (propName = 'sequenceAttachment') then
  begin
    SequenceAttachment := propValue as TFhirAttachment;
    result := propValue;
  end
  else if (propName = 'fivePrime') then
  begin
    FivePrime := propValue as TFhirCodeableConcept;
    result := propValue;
  end
  else if (propName = 'threePrime') then
  begin
    ThreePrime := propValue as TFhirCodeableConcept;
    result := propValue;
  end
  else if (propName = 'linkage') then
  begin
    LinkageList.add(propValue as TFhirSubstanceNucleicAcidSubunitLinkage);
    result := propValue;
  end
  else if (propName = 'sugar') then
  begin
    SugarList.add(propValue as TFhirSubstanceNucleicAcidSubunitSugar);
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirSubstanceNucleicAcidSubunit.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'linkage') then LinkageList.insertItem(index, propValue as TFhirSubstanceNucleicAcidSubunitLinkage)
  else if (propName = 'sugar') then SugarList.insertItem(index, propValue as TFhirSubstanceNucleicAcidSubunitSugar)
  else inherited;
end;

function TFhirSubstanceNucleicAcidSubunit.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'subunit') then result := TFhirInteger.create()
  else if (propName = 'sequence') then result := TFhirString.create()
  else if (propName = 'length') then result := TFhirInteger.create()
  else if (propName = 'sequenceAttachment') then result := TFhirAttachment.create()
  else if (propName = 'fivePrime') then result := TFhirCodeableConcept.create()
  else if (propName = 'threePrime') then result := TFhirCodeableConcept.create()
  else if (propName = 'linkage') then result := LinkageList.new()
  else if (propName = 'sugar') then result := SugarList.new()
  else result := inherited createPropertyValue(propName);
end;

function TFhirSubstanceNucleicAcidSubunit.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'subunit') then result := 'integer'
  else if (propName = 'sequence') then result := 'string'
  else if (propName = 'length') then result := 'integer'
  else if (propName = 'sequenceAttachment') then result := 'Attachment'
  else if (propName = 'fivePrime') then result := 'CodeableConcept'
  else if (propName = 'threePrime') then result := 'CodeableConcept'
  else if (propName = 'linkage') then result := 'BackboneElement'
  else if (propName = 'sugar') then result := 'BackboneElement'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirSubstanceNucleicAcidSubunit.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'subunit') then SubunitElement := nil
  else if (propName = 'sequence') then SequenceElement := nil
  else if (propName = 'length') then LengthElement := nil
  else if (propName = 'sequenceAttachment') then SequenceAttachmentElement := nil
  else if (propName = 'fivePrime') then FivePrimeElement := nil
  else if (propName = 'threePrime') then ThreePrimeElement := nil
  else if (propName = 'linkage') then deletePropertyValue('linkage', LinkageList, value)
  else if (propName = 'sugar') then deletePropertyValue('sugar', SugarList, value)
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirSubstanceNucleicAcidSubunit.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'subunit') then SubunitElement := asInteger(new)
  else if (propName = 'sequence') then SequenceElement := asString(new)
  else if (propName = 'length') then LengthElement := asInteger(new)
  else if (propName = 'sequenceAttachment') then SequenceAttachmentElement := new as TFhirAttachment
  else if (propName = 'fivePrime') then FivePrimeElement := new as TFhirCodeableConcept
  else if (propName = 'threePrime') then ThreePrimeElement := new as TFhirCodeableConcept
  else if (propName = 'linkage') then replacePropertyValue('linkage', LinkageList, existing, new)
  else if (propName = 'sugar') then replacePropertyValue('sugar', SugarList, existing, new)
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirSubstanceNucleicAcidSubunit.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'linkage') then LinkageList.move(source, destination)
  else if (propName = 'sugar') then SugarList.move(source, destination)
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirSubstanceNucleicAcidSubunit.fhirType : string;
begin
  result := 'SubstanceNucleicAcid.subunit';
end;

function TFhirSubstanceNucleicAcidSubunit.Link : TFhirSubstanceNucleicAcidSubunit;
begin
  result := TFhirSubstanceNucleicAcidSubunit(inherited Link);
end;

function TFhirSubstanceNucleicAcidSubunit.Clone : TFhirSubstanceNucleicAcidSubunit;
begin
  result := TFhirSubstanceNucleicAcidSubunit(inherited Clone);
end;

function TFhirSubstanceNucleicAcidSubunit.equals(other : TObject) : boolean; 
var
  o : TFhirSubstanceNucleicAcidSubunit;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirSubstanceNucleicAcidSubunit)) then
    result := false
  else
  begin
    o := TFhirSubstanceNucleicAcidSubunit(other);
    result := compareDeep(subunitElement, o.subunitElement, true) and compareDeep(sequenceElement, o.sequenceElement, true) and 
      compareDeep(lengthElement, o.lengthElement, true) and compareDeep(sequenceAttachmentElement, o.sequenceAttachmentElement, true) and 
      compareDeep(fivePrimeElement, o.fivePrimeElement, true) and compareDeep(threePrimeElement, o.threePrimeElement, true) and 
      compareDeep(linkageList, o.linkageList, true) and compareDeep(sugarList, o.sugarList, true);
  end;
end;

function TFhirSubstanceNucleicAcidSubunit.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FSubunit) and isEmptyProp(FSequence) and isEmptyProp(FLength) and isEmptyProp(FSequenceAttachment) and isEmptyProp(FFivePrime) and isEmptyProp(FThreePrime) and isEmptyProp(FlinkageList) and isEmptyProp(FsugarList);
end;

procedure TFhirSubstanceNucleicAcidSubunit.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('subunit');
  fields.add('sequence');
  fields.add('length');
  fields.add('sequenceAttachment');
  fields.add('fivePrime');
  fields.add('threePrime');
  fields.add('linkage');
  fields.add('sugar');
end;

function TFhirSubstanceNucleicAcidSubunit.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
  inc(result, FLinkageList.sizeInBytes(magic));
  inc(result, FSugarList.sizeInBytes(magic));
end;

procedure TFhirSubstanceNucleicAcidSubunit.SetSubunit(value : TFhirInteger);
begin
  FSubunit.free;
  FSubunit := value;
end;

function TFhirSubstanceNucleicAcidSubunit.GetSubunitST : String;
begin
  if FSubunit = nil then
    result := ''
  else
    result := FSubunit.value;
end;

procedure TFhirSubstanceNucleicAcidSubunit.SetSubunitST(value : String);
begin
  if value <> '' then
  begin
    if FSubunit = nil then
      FSubunit := TFhirInteger.create;
    FSubunit.value := value
  end
  else if FSubunit <> nil then
    FSubunit.value := '';
end;

procedure TFhirSubstanceNucleicAcidSubunit.SetSequence(value : TFhirString);
begin
  FSequence.free;
  FSequence := value;
end;

function TFhirSubstanceNucleicAcidSubunit.GetSequenceST : String;
begin
  if FSequence = nil then
    result := ''
  else
    result := FSequence.value;
end;

procedure TFhirSubstanceNucleicAcidSubunit.SetSequenceST(value : String);
begin
  if value <> '' then
  begin
    if FSequence = nil then
      FSequence := TFhirString.create;
    FSequence.value := value
  end
  else if FSequence <> nil then
    FSequence.value := '';
end;

procedure TFhirSubstanceNucleicAcidSubunit.SetLength(value : TFhirInteger);
begin
  FLength.free;
  FLength := value;
end;

function TFhirSubstanceNucleicAcidSubunit.GetLengthST : String;
begin
  if FLength = nil then
    result := ''
  else
    result := FLength.value;
end;

procedure TFhirSubstanceNucleicAcidSubunit.SetLengthST(value : String);
begin
  if value <> '' then
  begin
    if FLength = nil then
      FLength := TFhirInteger.create;
    FLength.value := value
  end
  else if FLength <> nil then
    FLength.value := '';
end;

procedure TFhirSubstanceNucleicAcidSubunit.SetSequenceAttachment(value : TFhirAttachment);
begin
  FSequenceAttachment.free;
  FSequenceAttachment := value;
end;

procedure TFhirSubstanceNucleicAcidSubunit.SetFivePrime(value : TFhirCodeableConcept);
begin
  FFivePrime.free;
  FFivePrime := value;
end;

procedure TFhirSubstanceNucleicAcidSubunit.SetThreePrime(value : TFhirCodeableConcept);
begin
  FThreePrime.free;
  FThreePrime := value;
end;

function TFhirSubstanceNucleicAcidSubunit.GetLinkageList : TFhirSubstanceNucleicAcidSubunitLinkageList;
begin
  if FLinkageList = nil then
    FLinkageList := TFhirSubstanceNucleicAcidSubunitLinkageList.Create;
  result := FLinkageList;
end;

function TFhirSubstanceNucleicAcidSubunit.GetHasLinkageList : boolean;
begin
  result := (FLinkageList <> nil) and (FLinkageList.count > 0);
end;

function TFhirSubstanceNucleicAcidSubunit.GetSugarList : TFhirSubstanceNucleicAcidSubunitSugarList;
begin
  if FSugarList = nil then
    FSugarList := TFhirSubstanceNucleicAcidSubunitSugarList.Create;
  result := FSugarList;
end;

function TFhirSubstanceNucleicAcidSubunit.GetHasSugarList : boolean;
begin
  result := (FSugarList <> nil) and (FSugarList.count > 0);
end;

{ TFhirSubstanceNucleicAcidSubunitListEnumerator }

constructor TFhirSubstanceNucleicAcidSubunitListEnumerator.Create(list : TFhirSubstanceNucleicAcidSubunitList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirSubstanceNucleicAcidSubunitListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirSubstanceNucleicAcidSubunitListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirSubstanceNucleicAcidSubunitListEnumerator.GetCurrent : TFhirSubstanceNucleicAcidSubunit;
begin
  Result := FList[FIndex];
end;

function TFhirSubstanceNucleicAcidSubunitListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirSubstanceNucleicAcidSubunitList }

function TFhirSubstanceNucleicAcidSubunitList.AddItem(value: TFhirSubstanceNucleicAcidSubunit): TFhirSubstanceNucleicAcidSubunit;
begin
  assert(value.ClassName = 'TFhirSubstanceNucleicAcidSubunit', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirSubstanceNucleicAcidSubunit');
  add(value);
  result := value;
end;

function TFhirSubstanceNucleicAcidSubunitList.Append: TFhirSubstanceNucleicAcidSubunit;
begin
  result := TFhirSubstanceNucleicAcidSubunit.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirSubstanceNucleicAcidSubunitList.ClearItems;
begin
  Clear;
end;

function TFhirSubstanceNucleicAcidSubunitList.GetEnumerator : TFhirSubstanceNucleicAcidSubunitListEnumerator;
begin
  result := TFhirSubstanceNucleicAcidSubunitListEnumerator.Create(self.link);
end;

function TFhirSubstanceNucleicAcidSubunitList.Clone: TFhirSubstanceNucleicAcidSubunitList;
begin
  result := TFhirSubstanceNucleicAcidSubunitList(inherited Clone);
end;

function TFhirSubstanceNucleicAcidSubunitList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirSubstanceNucleicAcidSubunitList.GetItemN(index: Integer): TFhirSubstanceNucleicAcidSubunit;
begin
  result := TFhirSubstanceNucleicAcidSubunit(ObjectByIndex[index]);
end;

function TFhirSubstanceNucleicAcidSubunitList.ItemClass: TFslObjectClass;
begin
  result := TFhirSubstanceNucleicAcidSubunit;
end;
function TFhirSubstanceNucleicAcidSubunitList.IndexOf(value: TFhirSubstanceNucleicAcidSubunit): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirSubstanceNucleicAcidSubunitList.Insert(index: Integer): TFhirSubstanceNucleicAcidSubunit;
begin
  result := TFhirSubstanceNucleicAcidSubunit.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirSubstanceNucleicAcidSubunitList.InsertItem(index: Integer; value: TFhirSubstanceNucleicAcidSubunit);
begin
  assert(value is TFhirSubstanceNucleicAcidSubunit);
  Inherited Insert(index, value);
end;

function TFhirSubstanceNucleicAcidSubunitList.Item(index: Integer): TFhirSubstanceNucleicAcidSubunit;
begin
  result := TFhirSubstanceNucleicAcidSubunit(ObjectByIndex[index]);
end;

function TFhirSubstanceNucleicAcidSubunitList.Link: TFhirSubstanceNucleicAcidSubunitList;
begin
  result := TFhirSubstanceNucleicAcidSubunitList(inherited Link);
end;

procedure TFhirSubstanceNucleicAcidSubunitList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirSubstanceNucleicAcidSubunitList.SetItemByIndex(index: Integer; value: TFhirSubstanceNucleicAcidSubunit);
begin
  assert(value is TFhirSubstanceNucleicAcidSubunit);
  FhirSubstanceNucleicAcidSubunits[index] := value;
end;

procedure TFhirSubstanceNucleicAcidSubunitList.SetItemN(index: Integer; value: TFhirSubstanceNucleicAcidSubunit);
begin
  assert(value is TFhirSubstanceNucleicAcidSubunit);
  ObjectByIndex[index] := value;
end;

{ TFhirSubstanceNucleicAcidSubunitLinkage }

constructor TFhirSubstanceNucleicAcidSubunitLinkage.Create;
begin
  inherited;
end;

destructor TFhirSubstanceNucleicAcidSubunitLinkage.Destroy;
begin
  FConnectivity.free;
  FIdentifier.free;
  FName.free;
  FResidueSite.free;
  inherited;
end;

procedure TFhirSubstanceNucleicAcidSubunitLinkage.Assign(oSource : TFslObject);
begin
  inherited;
  connectivityElement := TFhirSubstanceNucleicAcidSubunitLinkage(oSource).connectivityElement.Clone;
  identifier := TFhirSubstanceNucleicAcidSubunitLinkage(oSource).identifier.Clone;
  nameElement := TFhirSubstanceNucleicAcidSubunitLinkage(oSource).nameElement.Clone;
  residueSiteElement := TFhirSubstanceNucleicAcidSubunitLinkage(oSource).residueSiteElement.Clone;
end;

procedure TFhirSubstanceNucleicAcidSubunitLinkage.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'connectivity') Then
     list.add(self.link, 'connectivity', FConnectivity.Link);
  if (child_name = 'identifier') Then
     list.add(self.link, 'identifier', FIdentifier.Link);
  if (child_name = 'name') Then
     list.add(self.link, 'name', FName.Link);
  if (child_name = 'residueSite') Then
     list.add(self.link, 'residueSite', FResidueSite.Link);
end;

procedure TFhirSubstanceNucleicAcidSubunitLinkage.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'connectivity', 'string', false, TFhirString, FConnectivity.Link));
  oList.add(TFHIRProperty.create(self, 'identifier', 'Identifier', false, TFhirIdentifier, FIdentifier.Link));
  oList.add(TFHIRProperty.create(self, 'name', 'string', false, TFhirString, FName.Link));
  oList.add(TFHIRProperty.create(self, 'residueSite', 'string', false, TFhirString, FResidueSite.Link));
end;

function TFhirSubstanceNucleicAcidSubunitLinkage.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'connectivity') then
  begin
    ConnectivityElement := asString(propValue);
    result := propValue;
  end
  else if (propName = 'identifier') then
  begin
    Identifier := propValue as TFhirIdentifier;
    result := propValue;
  end
  else if (propName = 'name') then
  begin
    NameElement := asString(propValue);
    result := propValue;
  end
  else if (propName = 'residueSite') then
  begin
    ResidueSiteElement := asString(propValue);
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirSubstanceNucleicAcidSubunitLinkage.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirSubstanceNucleicAcidSubunitLinkage.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'connectivity') then result := TFhirString.create()
  else if (propName = 'identifier') then result := TFhirIdentifier.create()
  else if (propName = 'name') then result := TFhirString.create()
  else if (propName = 'residueSite') then result := TFhirString.create()
  else result := inherited createPropertyValue(propName);
end;

function TFhirSubstanceNucleicAcidSubunitLinkage.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'connectivity') then result := 'string'
  else if (propName = 'identifier') then result := 'Identifier'
  else if (propName = 'name') then result := 'string'
  else if (propName = 'residueSite') then result := 'string'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirSubstanceNucleicAcidSubunitLinkage.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'connectivity') then ConnectivityElement := nil
  else if (propName = 'identifier') then IdentifierElement := nil
  else if (propName = 'name') then NameElement := nil
  else if (propName = 'residueSite') then ResidueSiteElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirSubstanceNucleicAcidSubunitLinkage.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'connectivity') then ConnectivityElement := asString(new)
  else if (propName = 'identifier') then IdentifierElement := new as TFhirIdentifier
  else if (propName = 'name') then NameElement := asString(new)
  else if (propName = 'residueSite') then ResidueSiteElement := asString(new)
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirSubstanceNucleicAcidSubunitLinkage.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirSubstanceNucleicAcidSubunitLinkage.fhirType : string;
begin
  result := 'SubstanceNucleicAcid.subunit.linkage';
end;

function TFhirSubstanceNucleicAcidSubunitLinkage.Link : TFhirSubstanceNucleicAcidSubunitLinkage;
begin
  result := TFhirSubstanceNucleicAcidSubunitLinkage(inherited Link);
end;

function TFhirSubstanceNucleicAcidSubunitLinkage.Clone : TFhirSubstanceNucleicAcidSubunitLinkage;
begin
  result := TFhirSubstanceNucleicAcidSubunitLinkage(inherited Clone);
end;

function TFhirSubstanceNucleicAcidSubunitLinkage.equals(other : TObject) : boolean; 
var
  o : TFhirSubstanceNucleicAcidSubunitLinkage;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirSubstanceNucleicAcidSubunitLinkage)) then
    result := false
  else
  begin
    o := TFhirSubstanceNucleicAcidSubunitLinkage(other);
    result := compareDeep(connectivityElement, o.connectivityElement, true) and 
      compareDeep(identifierElement, o.identifierElement, true) and compareDeep(nameElement, o.nameElement, true) and 
      compareDeep(residueSiteElement, o.residueSiteElement, true);
  end;
end;

function TFhirSubstanceNucleicAcidSubunitLinkage.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FConnectivity) and isEmptyProp(FIdentifier) and isEmptyProp(FName) and isEmptyProp(FResidueSite);
end;

procedure TFhirSubstanceNucleicAcidSubunitLinkage.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('connectivity');
  fields.add('identifier');
  fields.add('name');
  fields.add('residueSite');
end;

function TFhirSubstanceNucleicAcidSubunitLinkage.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
end;

procedure TFhirSubstanceNucleicAcidSubunitLinkage.SetConnectivity(value : TFhirString);
begin
  FConnectivity.free;
  FConnectivity := value;
end;

function TFhirSubstanceNucleicAcidSubunitLinkage.GetConnectivityST : String;
begin
  if FConnectivity = nil then
    result := ''
  else
    result := FConnectivity.value;
end;

procedure TFhirSubstanceNucleicAcidSubunitLinkage.SetConnectivityST(value : String);
begin
  if value <> '' then
  begin
    if FConnectivity = nil then
      FConnectivity := TFhirString.create;
    FConnectivity.value := value
  end
  else if FConnectivity <> nil then
    FConnectivity.value := '';
end;

procedure TFhirSubstanceNucleicAcidSubunitLinkage.SetIdentifier(value : TFhirIdentifier);
begin
  FIdentifier.free;
  FIdentifier := value;
end;

procedure TFhirSubstanceNucleicAcidSubunitLinkage.SetName(value : TFhirString);
begin
  FName.free;
  FName := value;
end;

function TFhirSubstanceNucleicAcidSubunitLinkage.GetNameST : String;
begin
  if FName = nil then
    result := ''
  else
    result := FName.value;
end;

procedure TFhirSubstanceNucleicAcidSubunitLinkage.SetNameST(value : String);
begin
  if value <> '' then
  begin
    if FName = nil then
      FName := TFhirString.create;
    FName.value := value
  end
  else if FName <> nil then
    FName.value := '';
end;

procedure TFhirSubstanceNucleicAcidSubunitLinkage.SetResidueSite(value : TFhirString);
begin
  FResidueSite.free;
  FResidueSite := value;
end;

function TFhirSubstanceNucleicAcidSubunitLinkage.GetResidueSiteST : String;
begin
  if FResidueSite = nil then
    result := ''
  else
    result := FResidueSite.value;
end;

procedure TFhirSubstanceNucleicAcidSubunitLinkage.SetResidueSiteST(value : String);
begin
  if value <> '' then
  begin
    if FResidueSite = nil then
      FResidueSite := TFhirString.create;
    FResidueSite.value := value
  end
  else if FResidueSite <> nil then
    FResidueSite.value := '';
end;

{ TFhirSubstanceNucleicAcidSubunitLinkageListEnumerator }

constructor TFhirSubstanceNucleicAcidSubunitLinkageListEnumerator.Create(list : TFhirSubstanceNucleicAcidSubunitLinkageList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirSubstanceNucleicAcidSubunitLinkageListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirSubstanceNucleicAcidSubunitLinkageListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirSubstanceNucleicAcidSubunitLinkageListEnumerator.GetCurrent : TFhirSubstanceNucleicAcidSubunitLinkage;
begin
  Result := FList[FIndex];
end;

function TFhirSubstanceNucleicAcidSubunitLinkageListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirSubstanceNucleicAcidSubunitLinkageList }

function TFhirSubstanceNucleicAcidSubunitLinkageList.AddItem(value: TFhirSubstanceNucleicAcidSubunitLinkage): TFhirSubstanceNucleicAcidSubunitLinkage;
begin
  assert(value.ClassName = 'TFhirSubstanceNucleicAcidSubunitLinkage', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirSubstanceNucleicAcidSubunitLinkage');
  add(value);
  result := value;
end;

function TFhirSubstanceNucleicAcidSubunitLinkageList.Append: TFhirSubstanceNucleicAcidSubunitLinkage;
begin
  result := TFhirSubstanceNucleicAcidSubunitLinkage.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirSubstanceNucleicAcidSubunitLinkageList.ClearItems;
begin
  Clear;
end;

function TFhirSubstanceNucleicAcidSubunitLinkageList.GetEnumerator : TFhirSubstanceNucleicAcidSubunitLinkageListEnumerator;
begin
  result := TFhirSubstanceNucleicAcidSubunitLinkageListEnumerator.Create(self.link);
end;

function TFhirSubstanceNucleicAcidSubunitLinkageList.Clone: TFhirSubstanceNucleicAcidSubunitLinkageList;
begin
  result := TFhirSubstanceNucleicAcidSubunitLinkageList(inherited Clone);
end;

function TFhirSubstanceNucleicAcidSubunitLinkageList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirSubstanceNucleicAcidSubunitLinkageList.GetItemN(index: Integer): TFhirSubstanceNucleicAcidSubunitLinkage;
begin
  result := TFhirSubstanceNucleicAcidSubunitLinkage(ObjectByIndex[index]);
end;

function TFhirSubstanceNucleicAcidSubunitLinkageList.ItemClass: TFslObjectClass;
begin
  result := TFhirSubstanceNucleicAcidSubunitLinkage;
end;
function TFhirSubstanceNucleicAcidSubunitLinkageList.IndexOf(value: TFhirSubstanceNucleicAcidSubunitLinkage): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirSubstanceNucleicAcidSubunitLinkageList.Insert(index: Integer): TFhirSubstanceNucleicAcidSubunitLinkage;
begin
  result := TFhirSubstanceNucleicAcidSubunitLinkage.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirSubstanceNucleicAcidSubunitLinkageList.InsertItem(index: Integer; value: TFhirSubstanceNucleicAcidSubunitLinkage);
begin
  assert(value is TFhirSubstanceNucleicAcidSubunitLinkage);
  Inherited Insert(index, value);
end;

function TFhirSubstanceNucleicAcidSubunitLinkageList.Item(index: Integer): TFhirSubstanceNucleicAcidSubunitLinkage;
begin
  result := TFhirSubstanceNucleicAcidSubunitLinkage(ObjectByIndex[index]);
end;

function TFhirSubstanceNucleicAcidSubunitLinkageList.Link: TFhirSubstanceNucleicAcidSubunitLinkageList;
begin
  result := TFhirSubstanceNucleicAcidSubunitLinkageList(inherited Link);
end;

procedure TFhirSubstanceNucleicAcidSubunitLinkageList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirSubstanceNucleicAcidSubunitLinkageList.SetItemByIndex(index: Integer; value: TFhirSubstanceNucleicAcidSubunitLinkage);
begin
  assert(value is TFhirSubstanceNucleicAcidSubunitLinkage);
  FhirSubstanceNucleicAcidSubunitLinkages[index] := value;
end;

procedure TFhirSubstanceNucleicAcidSubunitLinkageList.SetItemN(index: Integer; value: TFhirSubstanceNucleicAcidSubunitLinkage);
begin
  assert(value is TFhirSubstanceNucleicAcidSubunitLinkage);
  ObjectByIndex[index] := value;
end;

{ TFhirSubstanceNucleicAcidSubunitSugar }

constructor TFhirSubstanceNucleicAcidSubunitSugar.Create;
begin
  inherited;
end;

destructor TFhirSubstanceNucleicAcidSubunitSugar.Destroy;
begin
  FIdentifier.free;
  FName.free;
  FResidueSite.free;
  inherited;
end;

procedure TFhirSubstanceNucleicAcidSubunitSugar.Assign(oSource : TFslObject);
begin
  inherited;
  identifier := TFhirSubstanceNucleicAcidSubunitSugar(oSource).identifier.Clone;
  nameElement := TFhirSubstanceNucleicAcidSubunitSugar(oSource).nameElement.Clone;
  residueSiteElement := TFhirSubstanceNucleicAcidSubunitSugar(oSource).residueSiteElement.Clone;
end;

procedure TFhirSubstanceNucleicAcidSubunitSugar.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'identifier') Then
     list.add(self.link, 'identifier', FIdentifier.Link);
  if (child_name = 'name') Then
     list.add(self.link, 'name', FName.Link);
  if (child_name = 'residueSite') Then
     list.add(self.link, 'residueSite', FResidueSite.Link);
end;

procedure TFhirSubstanceNucleicAcidSubunitSugar.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'identifier', 'Identifier', false, TFhirIdentifier, FIdentifier.Link));
  oList.add(TFHIRProperty.create(self, 'name', 'string', false, TFhirString, FName.Link));
  oList.add(TFHIRProperty.create(self, 'residueSite', 'string', false, TFhirString, FResidueSite.Link));
end;

function TFhirSubstanceNucleicAcidSubunitSugar.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'identifier') then
  begin
    Identifier := propValue as TFhirIdentifier;
    result := propValue;
  end
  else if (propName = 'name') then
  begin
    NameElement := asString(propValue);
    result := propValue;
  end
  else if (propName = 'residueSite') then
  begin
    ResidueSiteElement := asString(propValue);
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirSubstanceNucleicAcidSubunitSugar.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirSubstanceNucleicAcidSubunitSugar.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'identifier') then result := TFhirIdentifier.create()
  else if (propName = 'name') then result := TFhirString.create()
  else if (propName = 'residueSite') then result := TFhirString.create()
  else result := inherited createPropertyValue(propName);
end;

function TFhirSubstanceNucleicAcidSubunitSugar.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'identifier') then result := 'Identifier'
  else if (propName = 'name') then result := 'string'
  else if (propName = 'residueSite') then result := 'string'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirSubstanceNucleicAcidSubunitSugar.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'identifier') then IdentifierElement := nil
  else if (propName = 'name') then NameElement := nil
  else if (propName = 'residueSite') then ResidueSiteElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirSubstanceNucleicAcidSubunitSugar.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'identifier') then IdentifierElement := new as TFhirIdentifier
  else if (propName = 'name') then NameElement := asString(new)
  else if (propName = 'residueSite') then ResidueSiteElement := asString(new)
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirSubstanceNucleicAcidSubunitSugar.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirSubstanceNucleicAcidSubunitSugar.fhirType : string;
begin
  result := 'SubstanceNucleicAcid.subunit.sugar';
end;

function TFhirSubstanceNucleicAcidSubunitSugar.Link : TFhirSubstanceNucleicAcidSubunitSugar;
begin
  result := TFhirSubstanceNucleicAcidSubunitSugar(inherited Link);
end;

function TFhirSubstanceNucleicAcidSubunitSugar.Clone : TFhirSubstanceNucleicAcidSubunitSugar;
begin
  result := TFhirSubstanceNucleicAcidSubunitSugar(inherited Clone);
end;

function TFhirSubstanceNucleicAcidSubunitSugar.equals(other : TObject) : boolean; 
var
  o : TFhirSubstanceNucleicAcidSubunitSugar;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirSubstanceNucleicAcidSubunitSugar)) then
    result := false
  else
  begin
    o := TFhirSubstanceNucleicAcidSubunitSugar(other);
    result := compareDeep(identifierElement, o.identifierElement, true) and compareDeep(nameElement, o.nameElement, true) and 
      compareDeep(residueSiteElement, o.residueSiteElement, true);
  end;
end;

function TFhirSubstanceNucleicAcidSubunitSugar.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FIdentifier) and isEmptyProp(FName) and isEmptyProp(FResidueSite);
end;

procedure TFhirSubstanceNucleicAcidSubunitSugar.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('identifier');
  fields.add('name');
  fields.add('residueSite');
end;

function TFhirSubstanceNucleicAcidSubunitSugar.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
end;

procedure TFhirSubstanceNucleicAcidSubunitSugar.SetIdentifier(value : TFhirIdentifier);
begin
  FIdentifier.free;
  FIdentifier := value;
end;

procedure TFhirSubstanceNucleicAcidSubunitSugar.SetName(value : TFhirString);
begin
  FName.free;
  FName := value;
end;

function TFhirSubstanceNucleicAcidSubunitSugar.GetNameST : String;
begin
  if FName = nil then
    result := ''
  else
    result := FName.value;
end;

procedure TFhirSubstanceNucleicAcidSubunitSugar.SetNameST(value : String);
begin
  if value <> '' then
  begin
    if FName = nil then
      FName := TFhirString.create;
    FName.value := value
  end
  else if FName <> nil then
    FName.value := '';
end;

procedure TFhirSubstanceNucleicAcidSubunitSugar.SetResidueSite(value : TFhirString);
begin
  FResidueSite.free;
  FResidueSite := value;
end;

function TFhirSubstanceNucleicAcidSubunitSugar.GetResidueSiteST : String;
begin
  if FResidueSite = nil then
    result := ''
  else
    result := FResidueSite.value;
end;

procedure TFhirSubstanceNucleicAcidSubunitSugar.SetResidueSiteST(value : String);
begin
  if value <> '' then
  begin
    if FResidueSite = nil then
      FResidueSite := TFhirString.create;
    FResidueSite.value := value
  end
  else if FResidueSite <> nil then
    FResidueSite.value := '';
end;

{ TFhirSubstanceNucleicAcidSubunitSugarListEnumerator }

constructor TFhirSubstanceNucleicAcidSubunitSugarListEnumerator.Create(list : TFhirSubstanceNucleicAcidSubunitSugarList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirSubstanceNucleicAcidSubunitSugarListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirSubstanceNucleicAcidSubunitSugarListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirSubstanceNucleicAcidSubunitSugarListEnumerator.GetCurrent : TFhirSubstanceNucleicAcidSubunitSugar;
begin
  Result := FList[FIndex];
end;

function TFhirSubstanceNucleicAcidSubunitSugarListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirSubstanceNucleicAcidSubunitSugarList }

function TFhirSubstanceNucleicAcidSubunitSugarList.AddItem(value: TFhirSubstanceNucleicAcidSubunitSugar): TFhirSubstanceNucleicAcidSubunitSugar;
begin
  assert(value.ClassName = 'TFhirSubstanceNucleicAcidSubunitSugar', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirSubstanceNucleicAcidSubunitSugar');
  add(value);
  result := value;
end;

function TFhirSubstanceNucleicAcidSubunitSugarList.Append: TFhirSubstanceNucleicAcidSubunitSugar;
begin
  result := TFhirSubstanceNucleicAcidSubunitSugar.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirSubstanceNucleicAcidSubunitSugarList.ClearItems;
begin
  Clear;
end;

function TFhirSubstanceNucleicAcidSubunitSugarList.GetEnumerator : TFhirSubstanceNucleicAcidSubunitSugarListEnumerator;
begin
  result := TFhirSubstanceNucleicAcidSubunitSugarListEnumerator.Create(self.link);
end;

function TFhirSubstanceNucleicAcidSubunitSugarList.Clone: TFhirSubstanceNucleicAcidSubunitSugarList;
begin
  result := TFhirSubstanceNucleicAcidSubunitSugarList(inherited Clone);
end;

function TFhirSubstanceNucleicAcidSubunitSugarList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirSubstanceNucleicAcidSubunitSugarList.GetItemN(index: Integer): TFhirSubstanceNucleicAcidSubunitSugar;
begin
  result := TFhirSubstanceNucleicAcidSubunitSugar(ObjectByIndex[index]);
end;

function TFhirSubstanceNucleicAcidSubunitSugarList.ItemClass: TFslObjectClass;
begin
  result := TFhirSubstanceNucleicAcidSubunitSugar;
end;
function TFhirSubstanceNucleicAcidSubunitSugarList.IndexOf(value: TFhirSubstanceNucleicAcidSubunitSugar): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirSubstanceNucleicAcidSubunitSugarList.Insert(index: Integer): TFhirSubstanceNucleicAcidSubunitSugar;
begin
  result := TFhirSubstanceNucleicAcidSubunitSugar.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirSubstanceNucleicAcidSubunitSugarList.InsertItem(index: Integer; value: TFhirSubstanceNucleicAcidSubunitSugar);
begin
  assert(value is TFhirSubstanceNucleicAcidSubunitSugar);
  Inherited Insert(index, value);
end;

function TFhirSubstanceNucleicAcidSubunitSugarList.Item(index: Integer): TFhirSubstanceNucleicAcidSubunitSugar;
begin
  result := TFhirSubstanceNucleicAcidSubunitSugar(ObjectByIndex[index]);
end;

function TFhirSubstanceNucleicAcidSubunitSugarList.Link: TFhirSubstanceNucleicAcidSubunitSugarList;
begin
  result := TFhirSubstanceNucleicAcidSubunitSugarList(inherited Link);
end;

procedure TFhirSubstanceNucleicAcidSubunitSugarList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirSubstanceNucleicAcidSubunitSugarList.SetItemByIndex(index: Integer; value: TFhirSubstanceNucleicAcidSubunitSugar);
begin
  assert(value is TFhirSubstanceNucleicAcidSubunitSugar);
  FhirSubstanceNucleicAcidSubunitSugars[index] := value;
end;

procedure TFhirSubstanceNucleicAcidSubunitSugarList.SetItemN(index: Integer; value: TFhirSubstanceNucleicAcidSubunitSugar);
begin
  assert(value is TFhirSubstanceNucleicAcidSubunitSugar);
  ObjectByIndex[index] := value;
end;

{ TFhirSubstanceNucleicAcid }

constructor TFhirSubstanceNucleicAcid.Create;
begin
  inherited;
end;

destructor TFhirSubstanceNucleicAcid.Destroy;
begin
  FSequenceType.free;
  FNumberOfSubunits.free;
  FAreaOfHybridisation.free;
  FOligoNucleotideType.free;
  FSubunitList.Free;
  inherited;
end;

procedure TFhirSubstanceNucleicAcid.Assign(oSource : TFslObject);
begin
  inherited;
  sequenceType := TFhirSubstanceNucleicAcid(oSource).sequenceType.Clone;
  numberOfSubunitsElement := TFhirSubstanceNucleicAcid(oSource).numberOfSubunitsElement.Clone;
  areaOfHybridisationElement := TFhirSubstanceNucleicAcid(oSource).areaOfHybridisationElement.Clone;
  oligoNucleotideType := TFhirSubstanceNucleicAcid(oSource).oligoNucleotideType.Clone;
  if (TFhirSubstanceNucleicAcid(oSource).FSubunitList = nil) then
  begin
    FSubunitList.free;
    FSubunitList := nil;
  end
  else
  begin
    if FSubunitList = nil then
      FSubunitList := TFhirSubstanceNucleicAcidSubunitList.Create;
    FSubunitList.Assign(TFhirSubstanceNucleicAcid(oSource).FSubunitList);
  end;
end;

function TFhirSubstanceNucleicAcid.GetResourceType : TFhirResourceType;
begin
  result := frtSubstanceNucleicAcid;
end;

procedure TFhirSubstanceNucleicAcid.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'sequenceType') Then
     list.add(self.link, 'sequenceType', FSequenceType.Link);
  if (child_name = 'numberOfSubunits') Then
     list.add(self.link, 'numberOfSubunits', FNumberOfSubunits.Link);
  if (child_name = 'areaOfHybridisation') Then
     list.add(self.link, 'areaOfHybridisation', FAreaOfHybridisation.Link);
  if (child_name = 'oligoNucleotideType') Then
     list.add(self.link, 'oligoNucleotideType', FOligoNucleotideType.Link);
  if (child_name = 'subunit') Then
    list.addAll(self, 'subunit', FSubunitList);
end;

procedure TFhirSubstanceNucleicAcid.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'sequenceType', 'CodeableConcept', false, TFhirCodeableConcept, FSequenceType.Link));
  oList.add(TFHIRProperty.create(self, 'numberOfSubunits', 'integer', false, TFhirInteger, FNumberOfSubunits.Link));
  oList.add(TFHIRProperty.create(self, 'areaOfHybridisation', 'string', false, TFhirString, FAreaOfHybridisation.Link));
  oList.add(TFHIRProperty.create(self, 'oligoNucleotideType', 'CodeableConcept', false, TFhirCodeableConcept, FOligoNucleotideType.Link));
  oList.add(TFHIRProperty.create(self, 'subunit', 'BackboneElement', true, TFhirSubstanceNucleicAcidSubunit, FSubunitList.Link));
end;

function TFhirSubstanceNucleicAcid.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'sequenceType') then
  begin
    SequenceType := propValue as TFhirCodeableConcept;
    result := propValue;
  end
  else if (propName = 'numberOfSubunits') then
  begin
    NumberOfSubunitsElement := asInteger(propValue);
    result := propValue;
  end
  else if (propName = 'areaOfHybridisation') then
  begin
    AreaOfHybridisationElement := asString(propValue);
    result := propValue;
  end
  else if (propName = 'oligoNucleotideType') then
  begin
    OligoNucleotideType := propValue as TFhirCodeableConcept;
    result := propValue;
  end
  else if (propName = 'subunit') then
  begin
    SubunitList.add(propValue as TFhirSubstanceNucleicAcidSubunit);
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirSubstanceNucleicAcid.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'subunit') then SubunitList.insertItem(index, propValue as TFhirSubstanceNucleicAcidSubunit)
  else inherited;
end;

function TFhirSubstanceNucleicAcid.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'sequenceType') then result := TFhirCodeableConcept.create()
  else if (propName = 'numberOfSubunits') then result := TFhirInteger.create()
  else if (propName = 'areaOfHybridisation') then result := TFhirString.create()
  else if (propName = 'oligoNucleotideType') then result := TFhirCodeableConcept.create()
  else if (propName = 'subunit') then result := SubunitList.new()
  else result := inherited createPropertyValue(propName);
end;

function TFhirSubstanceNucleicAcid.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'sequenceType') then result := 'CodeableConcept'
  else if (propName = 'numberOfSubunits') then result := 'integer'
  else if (propName = 'areaOfHybridisation') then result := 'string'
  else if (propName = 'oligoNucleotideType') then result := 'CodeableConcept'
  else if (propName = 'subunit') then result := 'BackboneElement'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirSubstanceNucleicAcid.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'sequenceType') then SequenceTypeElement := nil
  else if (propName = 'numberOfSubunits') then NumberOfSubunitsElement := nil
  else if (propName = 'areaOfHybridisation') then AreaOfHybridisationElement := nil
  else if (propName = 'oligoNucleotideType') then OligoNucleotideTypeElement := nil
  else if (propName = 'subunit') then deletePropertyValue('subunit', SubunitList, value)
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirSubstanceNucleicAcid.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'sequenceType') then SequenceTypeElement := new as TFhirCodeableConcept
  else if (propName = 'numberOfSubunits') then NumberOfSubunitsElement := asInteger(new)
  else if (propName = 'areaOfHybridisation') then AreaOfHybridisationElement := asString(new)
  else if (propName = 'oligoNucleotideType') then OligoNucleotideTypeElement := new as TFhirCodeableConcept
  else if (propName = 'subunit') then replacePropertyValue('subunit', SubunitList, existing, new)
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirSubstanceNucleicAcid.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'subunit') then SubunitList.move(source, destination)
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirSubstanceNucleicAcid.fhirType : string;
begin
  result := 'SubstanceNucleicAcid';
end;

function TFhirSubstanceNucleicAcid.Link : TFhirSubstanceNucleicAcid;
begin
  result := TFhirSubstanceNucleicAcid(inherited Link);
end;

function TFhirSubstanceNucleicAcid.Clone : TFhirSubstanceNucleicAcid;
begin
  result := TFhirSubstanceNucleicAcid(inherited Clone);
end;

function TFhirSubstanceNucleicAcid.equals(other : TObject) : boolean; 
var
  o : TFhirSubstanceNucleicAcid;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirSubstanceNucleicAcid)) then
    result := false
  else
  begin
    o := TFhirSubstanceNucleicAcid(other);
    result := compareDeep(sequenceTypeElement, o.sequenceTypeElement, true) and 
      compareDeep(numberOfSubunitsElement, o.numberOfSubunitsElement, true) and compareDeep(areaOfHybridisationElement, o.areaOfHybridisationElement, true) and 
      compareDeep(oligoNucleotideTypeElement, o.oligoNucleotideTypeElement, true) and 
      compareDeep(subunitList, o.subunitList, true);
  end;
end;

function TFhirSubstanceNucleicAcid.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FSequenceType) and isEmptyProp(FNumberOfSubunits) and isEmptyProp(FAreaOfHybridisation) and isEmptyProp(FOligoNucleotideType) and isEmptyProp(FsubunitList);
end;

procedure TFhirSubstanceNucleicAcid.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('sequenceType');
  fields.add('numberOfSubunits');
  fields.add('areaOfHybridisation');
  fields.add('oligoNucleotideType');
  fields.add('subunit');
end;

function TFhirSubstanceNucleicAcid.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
  inc(result, FSubunitList.sizeInBytes(magic));
end;

procedure TFhirSubstanceNucleicAcid.SetSequenceType(value : TFhirCodeableConcept);
begin
  FSequenceType.free;
  FSequenceType := value;
end;

procedure TFhirSubstanceNucleicAcid.SetNumberOfSubunits(value : TFhirInteger);
begin
  FNumberOfSubunits.free;
  FNumberOfSubunits := value;
end;

function TFhirSubstanceNucleicAcid.GetNumberOfSubunitsST : String;
begin
  if FNumberOfSubunits = nil then
    result := ''
  else
    result := FNumberOfSubunits.value;
end;

procedure TFhirSubstanceNucleicAcid.SetNumberOfSubunitsST(value : String);
begin
  if value <> '' then
  begin
    if FNumberOfSubunits = nil then
      FNumberOfSubunits := TFhirInteger.create;
    FNumberOfSubunits.value := value
  end
  else if FNumberOfSubunits <> nil then
    FNumberOfSubunits.value := '';
end;

procedure TFhirSubstanceNucleicAcid.SetAreaOfHybridisation(value : TFhirString);
begin
  FAreaOfHybridisation.free;
  FAreaOfHybridisation := value;
end;

function TFhirSubstanceNucleicAcid.GetAreaOfHybridisationST : String;
begin
  if FAreaOfHybridisation = nil then
    result := ''
  else
    result := FAreaOfHybridisation.value;
end;

procedure TFhirSubstanceNucleicAcid.SetAreaOfHybridisationST(value : String);
begin
  if value <> '' then
  begin
    if FAreaOfHybridisation = nil then
      FAreaOfHybridisation := TFhirString.create;
    FAreaOfHybridisation.value := value
  end
  else if FAreaOfHybridisation <> nil then
    FAreaOfHybridisation.value := '';
end;

procedure TFhirSubstanceNucleicAcid.SetOligoNucleotideType(value : TFhirCodeableConcept);
begin
  FOligoNucleotideType.free;
  FOligoNucleotideType := value;
end;

function TFhirSubstanceNucleicAcid.GetSubunitList : TFhirSubstanceNucleicAcidSubunitList;
begin
  if FSubunitList = nil then
    FSubunitList := TFhirSubstanceNucleicAcidSubunitList.Create;
  result := FSubunitList;
end;

function TFhirSubstanceNucleicAcid.GetHasSubunitList : boolean;
begin
  result := (FSubunitList <> nil) and (FSubunitList.count > 0);
end;

{ TFhirSubstanceNucleicAcidListEnumerator }

constructor TFhirSubstanceNucleicAcidListEnumerator.Create(list : TFhirSubstanceNucleicAcidList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirSubstanceNucleicAcidListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirSubstanceNucleicAcidListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirSubstanceNucleicAcidListEnumerator.GetCurrent : TFhirSubstanceNucleicAcid;
begin
  Result := FList[FIndex];
end;

function TFhirSubstanceNucleicAcidListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirSubstanceNucleicAcidList }

function TFhirSubstanceNucleicAcidList.AddItem(value: TFhirSubstanceNucleicAcid): TFhirSubstanceNucleicAcid;
begin
  assert(value.ClassName = 'TFhirSubstanceNucleicAcid', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirSubstanceNucleicAcid');
  add(value);
  result := value;
end;

function TFhirSubstanceNucleicAcidList.Append: TFhirSubstanceNucleicAcid;
begin
  result := TFhirSubstanceNucleicAcid.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirSubstanceNucleicAcidList.ClearItems;
begin
  Clear;
end;

function TFhirSubstanceNucleicAcidList.GetEnumerator : TFhirSubstanceNucleicAcidListEnumerator;
begin
  result := TFhirSubstanceNucleicAcidListEnumerator.Create(self.link);
end;

function TFhirSubstanceNucleicAcidList.Clone: TFhirSubstanceNucleicAcidList;
begin
  result := TFhirSubstanceNucleicAcidList(inherited Clone);
end;

function TFhirSubstanceNucleicAcidList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirSubstanceNucleicAcidList.GetItemN(index: Integer): TFhirSubstanceNucleicAcid;
begin
  result := TFhirSubstanceNucleicAcid(ObjectByIndex[index]);
end;

function TFhirSubstanceNucleicAcidList.ItemClass: TFslObjectClass;
begin
  result := TFhirSubstanceNucleicAcid;
end;
function TFhirSubstanceNucleicAcidList.IndexOf(value: TFhirSubstanceNucleicAcid): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirSubstanceNucleicAcidList.Insert(index: Integer): TFhirSubstanceNucleicAcid;
begin
  result := TFhirSubstanceNucleicAcid.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirSubstanceNucleicAcidList.InsertItem(index: Integer; value: TFhirSubstanceNucleicAcid);
begin
  assert(value is TFhirSubstanceNucleicAcid);
  Inherited Insert(index, value);
end;

function TFhirSubstanceNucleicAcidList.Item(index: Integer): TFhirSubstanceNucleicAcid;
begin
  result := TFhirSubstanceNucleicAcid(ObjectByIndex[index]);
end;

function TFhirSubstanceNucleicAcidList.Link: TFhirSubstanceNucleicAcidList;
begin
  result := TFhirSubstanceNucleicAcidList(inherited Link);
end;

procedure TFhirSubstanceNucleicAcidList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirSubstanceNucleicAcidList.SetItemByIndex(index: Integer; value: TFhirSubstanceNucleicAcid);
begin
  assert(value is TFhirSubstanceNucleicAcid);
  FhirSubstanceNucleicAcids[index] := value;
end;

procedure TFhirSubstanceNucleicAcidList.SetItemN(index: Integer; value: TFhirSubstanceNucleicAcid);
begin
  assert(value is TFhirSubstanceNucleicAcid);
  ObjectByIndex[index] := value;
end;

{$ENDIF FHIR_SUBSTANCENUCLEICACID}
{$IFDEF FHIR_SUBSTANCEPOLYMER}
{ TFhirSubstancePolymerMonomerSet }

constructor TFhirSubstancePolymerMonomerSet.Create;
begin
  inherited;
end;

destructor TFhirSubstancePolymerMonomerSet.Destroy;
begin
  FRatioType.free;
  FStartingMaterialList.Free;
  inherited;
end;

procedure TFhirSubstancePolymerMonomerSet.Assign(oSource : TFslObject);
begin
  inherited;
  ratioType := TFhirSubstancePolymerMonomerSet(oSource).ratioType.Clone;
  if (TFhirSubstancePolymerMonomerSet(oSource).FStartingMaterialList = nil) then
  begin
    FStartingMaterialList.free;
    FStartingMaterialList := nil;
  end
  else
  begin
    if FStartingMaterialList = nil then
      FStartingMaterialList := TFhirSubstancePolymerMonomerSetStartingMaterialList.Create;
    FStartingMaterialList.Assign(TFhirSubstancePolymerMonomerSet(oSource).FStartingMaterialList);
  end;
end;

procedure TFhirSubstancePolymerMonomerSet.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'ratioType') Then
     list.add(self.link, 'ratioType', FRatioType.Link);
  if (child_name = 'startingMaterial') Then
    list.addAll(self, 'startingMaterial', FStartingMaterialList);
end;

procedure TFhirSubstancePolymerMonomerSet.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'ratioType', 'CodeableConcept', false, TFhirCodeableConcept, FRatioType.Link));
  oList.add(TFHIRProperty.create(self, 'startingMaterial', 'BackboneElement', true, TFhirSubstancePolymerMonomerSetStartingMaterial, FStartingMaterialList.Link));
end;

function TFhirSubstancePolymerMonomerSet.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'ratioType') then
  begin
    RatioType := propValue as TFhirCodeableConcept;
    result := propValue;
  end
  else if (propName = 'startingMaterial') then
  begin
    StartingMaterialList.add(propValue as TFhirSubstancePolymerMonomerSetStartingMaterial);
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirSubstancePolymerMonomerSet.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'startingMaterial') then StartingMaterialList.insertItem(index, propValue as TFhirSubstancePolymerMonomerSetStartingMaterial)
  else inherited;
end;

function TFhirSubstancePolymerMonomerSet.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'ratioType') then result := TFhirCodeableConcept.create()
  else if (propName = 'startingMaterial') then result := StartingMaterialList.new()
  else result := inherited createPropertyValue(propName);
end;

function TFhirSubstancePolymerMonomerSet.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'ratioType') then result := 'CodeableConcept'
  else if (propName = 'startingMaterial') then result := 'BackboneElement'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirSubstancePolymerMonomerSet.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'ratioType') then RatioTypeElement := nil
  else if (propName = 'startingMaterial') then deletePropertyValue('startingMaterial', StartingMaterialList, value)
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirSubstancePolymerMonomerSet.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'ratioType') then RatioTypeElement := new as TFhirCodeableConcept
  else if (propName = 'startingMaterial') then replacePropertyValue('startingMaterial', StartingMaterialList, existing, new)
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirSubstancePolymerMonomerSet.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'startingMaterial') then StartingMaterialList.move(source, destination)
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirSubstancePolymerMonomerSet.fhirType : string;
begin
  result := 'SubstancePolymer.monomerSet';
end;

function TFhirSubstancePolymerMonomerSet.Link : TFhirSubstancePolymerMonomerSet;
begin
  result := TFhirSubstancePolymerMonomerSet(inherited Link);
end;

function TFhirSubstancePolymerMonomerSet.Clone : TFhirSubstancePolymerMonomerSet;
begin
  result := TFhirSubstancePolymerMonomerSet(inherited Clone);
end;

function TFhirSubstancePolymerMonomerSet.equals(other : TObject) : boolean; 
var
  o : TFhirSubstancePolymerMonomerSet;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirSubstancePolymerMonomerSet)) then
    result := false
  else
  begin
    o := TFhirSubstancePolymerMonomerSet(other);
    result := compareDeep(ratioTypeElement, o.ratioTypeElement, true) and compareDeep(startingMaterialList, o.startingMaterialList, true);
  end;
end;

function TFhirSubstancePolymerMonomerSet.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FRatioType) and isEmptyProp(FstartingMaterialList);
end;

procedure TFhirSubstancePolymerMonomerSet.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('ratioType');
  fields.add('startingMaterial');
end;

function TFhirSubstancePolymerMonomerSet.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
  inc(result, FStartingMaterialList.sizeInBytes(magic));
end;

procedure TFhirSubstancePolymerMonomerSet.SetRatioType(value : TFhirCodeableConcept);
begin
  FRatioType.free;
  FRatioType := value;
end;

function TFhirSubstancePolymerMonomerSet.GetStartingMaterialList : TFhirSubstancePolymerMonomerSetStartingMaterialList;
begin
  if FStartingMaterialList = nil then
    FStartingMaterialList := TFhirSubstancePolymerMonomerSetStartingMaterialList.Create;
  result := FStartingMaterialList;
end;

function TFhirSubstancePolymerMonomerSet.GetHasStartingMaterialList : boolean;
begin
  result := (FStartingMaterialList <> nil) and (FStartingMaterialList.count > 0);
end;

{ TFhirSubstancePolymerMonomerSetListEnumerator }

constructor TFhirSubstancePolymerMonomerSetListEnumerator.Create(list : TFhirSubstancePolymerMonomerSetList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirSubstancePolymerMonomerSetListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirSubstancePolymerMonomerSetListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirSubstancePolymerMonomerSetListEnumerator.GetCurrent : TFhirSubstancePolymerMonomerSet;
begin
  Result := FList[FIndex];
end;

function TFhirSubstancePolymerMonomerSetListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirSubstancePolymerMonomerSetList }

function TFhirSubstancePolymerMonomerSetList.AddItem(value: TFhirSubstancePolymerMonomerSet): TFhirSubstancePolymerMonomerSet;
begin
  assert(value.ClassName = 'TFhirSubstancePolymerMonomerSet', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirSubstancePolymerMonomerSet');
  add(value);
  result := value;
end;

function TFhirSubstancePolymerMonomerSetList.Append: TFhirSubstancePolymerMonomerSet;
begin
  result := TFhirSubstancePolymerMonomerSet.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirSubstancePolymerMonomerSetList.ClearItems;
begin
  Clear;
end;

function TFhirSubstancePolymerMonomerSetList.GetEnumerator : TFhirSubstancePolymerMonomerSetListEnumerator;
begin
  result := TFhirSubstancePolymerMonomerSetListEnumerator.Create(self.link);
end;

function TFhirSubstancePolymerMonomerSetList.Clone: TFhirSubstancePolymerMonomerSetList;
begin
  result := TFhirSubstancePolymerMonomerSetList(inherited Clone);
end;

function TFhirSubstancePolymerMonomerSetList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirSubstancePolymerMonomerSetList.GetItemN(index: Integer): TFhirSubstancePolymerMonomerSet;
begin
  result := TFhirSubstancePolymerMonomerSet(ObjectByIndex[index]);
end;

function TFhirSubstancePolymerMonomerSetList.ItemClass: TFslObjectClass;
begin
  result := TFhirSubstancePolymerMonomerSet;
end;
function TFhirSubstancePolymerMonomerSetList.IndexOf(value: TFhirSubstancePolymerMonomerSet): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirSubstancePolymerMonomerSetList.Insert(index: Integer): TFhirSubstancePolymerMonomerSet;
begin
  result := TFhirSubstancePolymerMonomerSet.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirSubstancePolymerMonomerSetList.InsertItem(index: Integer; value: TFhirSubstancePolymerMonomerSet);
begin
  assert(value is TFhirSubstancePolymerMonomerSet);
  Inherited Insert(index, value);
end;

function TFhirSubstancePolymerMonomerSetList.Item(index: Integer): TFhirSubstancePolymerMonomerSet;
begin
  result := TFhirSubstancePolymerMonomerSet(ObjectByIndex[index]);
end;

function TFhirSubstancePolymerMonomerSetList.Link: TFhirSubstancePolymerMonomerSetList;
begin
  result := TFhirSubstancePolymerMonomerSetList(inherited Link);
end;

procedure TFhirSubstancePolymerMonomerSetList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirSubstancePolymerMonomerSetList.SetItemByIndex(index: Integer; value: TFhirSubstancePolymerMonomerSet);
begin
  assert(value is TFhirSubstancePolymerMonomerSet);
  FhirSubstancePolymerMonomerSets[index] := value;
end;

procedure TFhirSubstancePolymerMonomerSetList.SetItemN(index: Integer; value: TFhirSubstancePolymerMonomerSet);
begin
  assert(value is TFhirSubstancePolymerMonomerSet);
  ObjectByIndex[index] := value;
end;

{ TFhirSubstancePolymerMonomerSetStartingMaterial }

constructor TFhirSubstancePolymerMonomerSetStartingMaterial.Create;
begin
  inherited;
end;

destructor TFhirSubstancePolymerMonomerSetStartingMaterial.Destroy;
begin
  FCode.free;
  FCategory.free;
  FIsDefining.free;
  FAmount.free;
  inherited;
end;

procedure TFhirSubstancePolymerMonomerSetStartingMaterial.Assign(oSource : TFslObject);
begin
  inherited;
  code := TFhirSubstancePolymerMonomerSetStartingMaterial(oSource).code.Clone;
  category := TFhirSubstancePolymerMonomerSetStartingMaterial(oSource).category.Clone;
  isDefiningElement := TFhirSubstancePolymerMonomerSetStartingMaterial(oSource).isDefiningElement.Clone;
  amount := TFhirSubstancePolymerMonomerSetStartingMaterial(oSource).amount.Clone;
end;

procedure TFhirSubstancePolymerMonomerSetStartingMaterial.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'code') Then
     list.add(self.link, 'code', FCode.Link);
  if (child_name = 'category') Then
     list.add(self.link, 'category', FCategory.Link);
  if (child_name = 'isDefining') Then
     list.add(self.link, 'isDefining', FIsDefining.Link);
  if (child_name = 'amount') Then
     list.add(self.link, 'amount', FAmount.Link);
end;

procedure TFhirSubstancePolymerMonomerSetStartingMaterial.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'code', 'CodeableConcept', false, TFhirCodeableConcept, FCode.Link));
  oList.add(TFHIRProperty.create(self, 'category', 'CodeableConcept', false, TFhirCodeableConcept, FCategory.Link));
  oList.add(TFHIRProperty.create(self, 'isDefining', 'boolean', false, TFhirBoolean, FIsDefining.Link));
  oList.add(TFHIRProperty.create(self, 'amount', 'Quantity', false, TFhirQuantity, FAmount.Link));
end;

function TFhirSubstancePolymerMonomerSetStartingMaterial.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'code') then
  begin
    Code := propValue as TFhirCodeableConcept;
    result := propValue;
  end
  else if (propName = 'category') then
  begin
    Category := propValue as TFhirCodeableConcept;
    result := propValue;
  end
  else if (propName = 'isDefining') then
  begin
    IsDefiningElement := asBoolean(propValue);
    result := propValue;
  end
  else if (propName = 'amount') then
  begin
    Amount := propValue as TFhirQuantity;
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirSubstancePolymerMonomerSetStartingMaterial.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirSubstancePolymerMonomerSetStartingMaterial.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'code') then result := TFhirCodeableConcept.create()
  else if (propName = 'category') then result := TFhirCodeableConcept.create()
  else if (propName = 'isDefining') then result := TFhirBoolean.create()
  else if (propName = 'amount') then result := TFhirQuantity.create()
  else result := inherited createPropertyValue(propName);
end;

function TFhirSubstancePolymerMonomerSetStartingMaterial.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'code') then result := 'CodeableConcept'
  else if (propName = 'category') then result := 'CodeableConcept'
  else if (propName = 'isDefining') then result := 'boolean'
  else if (propName = 'amount') then result := 'Quantity'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirSubstancePolymerMonomerSetStartingMaterial.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'code') then CodeElement := nil
  else if (propName = 'category') then CategoryElement := nil
  else if (propName = 'isDefining') then IsDefiningElement := nil
  else if (propName = 'amount') then AmountElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirSubstancePolymerMonomerSetStartingMaterial.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'code') then CodeElement := new as TFhirCodeableConcept
  else if (propName = 'category') then CategoryElement := new as TFhirCodeableConcept
  else if (propName = 'isDefining') then IsDefiningElement := asBoolean(new)
  else if (propName = 'amount') then AmountElement := new as TFhirQuantity
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirSubstancePolymerMonomerSetStartingMaterial.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirSubstancePolymerMonomerSetStartingMaterial.fhirType : string;
begin
  result := 'SubstancePolymer.monomerSet.startingMaterial';
end;

function TFhirSubstancePolymerMonomerSetStartingMaterial.Link : TFhirSubstancePolymerMonomerSetStartingMaterial;
begin
  result := TFhirSubstancePolymerMonomerSetStartingMaterial(inherited Link);
end;

function TFhirSubstancePolymerMonomerSetStartingMaterial.Clone : TFhirSubstancePolymerMonomerSetStartingMaterial;
begin
  result := TFhirSubstancePolymerMonomerSetStartingMaterial(inherited Clone);
end;

function TFhirSubstancePolymerMonomerSetStartingMaterial.equals(other : TObject) : boolean; 
var
  o : TFhirSubstancePolymerMonomerSetStartingMaterial;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirSubstancePolymerMonomerSetStartingMaterial)) then
    result := false
  else
  begin
    o := TFhirSubstancePolymerMonomerSetStartingMaterial(other);
    result := compareDeep(codeElement, o.codeElement, true) and compareDeep(categoryElement, o.categoryElement, true) and 
      compareDeep(isDefiningElement, o.isDefiningElement, true) and compareDeep(amountElement, o.amountElement, true);
  end;
end;

function TFhirSubstancePolymerMonomerSetStartingMaterial.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FCode) and isEmptyProp(FCategory) and isEmptyProp(FIsDefining) and isEmptyProp(FAmount);
end;

procedure TFhirSubstancePolymerMonomerSetStartingMaterial.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('code');
  fields.add('category');
  fields.add('isDefining');
  fields.add('amount');
end;

function TFhirSubstancePolymerMonomerSetStartingMaterial.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
end;

procedure TFhirSubstancePolymerMonomerSetStartingMaterial.SetCode(value : TFhirCodeableConcept);
begin
  FCode.free;
  FCode := value;
end;

procedure TFhirSubstancePolymerMonomerSetStartingMaterial.SetCategory(value : TFhirCodeableConcept);
begin
  FCategory.free;
  FCategory := value;
end;

procedure TFhirSubstancePolymerMonomerSetStartingMaterial.SetIsDefining(value : TFhirBoolean);
begin
  FIsDefining.free;
  FIsDefining := value;
end;

function TFhirSubstancePolymerMonomerSetStartingMaterial.GetIsDefiningST : Boolean;
begin
  if FIsDefining = nil then
    result := false
  else
    result := FIsDefining.value;
end;

procedure TFhirSubstancePolymerMonomerSetStartingMaterial.SetIsDefiningST(value : Boolean);
begin
  if FIsDefining = nil then
    FIsDefining := TFhirBoolean.create;
  FIsDefining.value := value
end;

procedure TFhirSubstancePolymerMonomerSetStartingMaterial.SetAmount(value : TFhirQuantity);
begin
  FAmount.free;
  FAmount := value;
end;

{ TFhirSubstancePolymerMonomerSetStartingMaterialListEnumerator }

constructor TFhirSubstancePolymerMonomerSetStartingMaterialListEnumerator.Create(list : TFhirSubstancePolymerMonomerSetStartingMaterialList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirSubstancePolymerMonomerSetStartingMaterialListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirSubstancePolymerMonomerSetStartingMaterialListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirSubstancePolymerMonomerSetStartingMaterialListEnumerator.GetCurrent : TFhirSubstancePolymerMonomerSetStartingMaterial;
begin
  Result := FList[FIndex];
end;

function TFhirSubstancePolymerMonomerSetStartingMaterialListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirSubstancePolymerMonomerSetStartingMaterialList }

function TFhirSubstancePolymerMonomerSetStartingMaterialList.AddItem(value: TFhirSubstancePolymerMonomerSetStartingMaterial): TFhirSubstancePolymerMonomerSetStartingMaterial;
begin
  assert(value.ClassName = 'TFhirSubstancePolymerMonomerSetStartingMaterial', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirSubstancePolymerMonomerSetStartingMaterial');
  add(value);
  result := value;
end;

function TFhirSubstancePolymerMonomerSetStartingMaterialList.Append: TFhirSubstancePolymerMonomerSetStartingMaterial;
begin
  result := TFhirSubstancePolymerMonomerSetStartingMaterial.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirSubstancePolymerMonomerSetStartingMaterialList.ClearItems;
begin
  Clear;
end;

function TFhirSubstancePolymerMonomerSetStartingMaterialList.GetEnumerator : TFhirSubstancePolymerMonomerSetStartingMaterialListEnumerator;
begin
  result := TFhirSubstancePolymerMonomerSetStartingMaterialListEnumerator.Create(self.link);
end;

function TFhirSubstancePolymerMonomerSetStartingMaterialList.Clone: TFhirSubstancePolymerMonomerSetStartingMaterialList;
begin
  result := TFhirSubstancePolymerMonomerSetStartingMaterialList(inherited Clone);
end;

function TFhirSubstancePolymerMonomerSetStartingMaterialList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirSubstancePolymerMonomerSetStartingMaterialList.GetItemN(index: Integer): TFhirSubstancePolymerMonomerSetStartingMaterial;
begin
  result := TFhirSubstancePolymerMonomerSetStartingMaterial(ObjectByIndex[index]);
end;

function TFhirSubstancePolymerMonomerSetStartingMaterialList.ItemClass: TFslObjectClass;
begin
  result := TFhirSubstancePolymerMonomerSetStartingMaterial;
end;
function TFhirSubstancePolymerMonomerSetStartingMaterialList.IndexOf(value: TFhirSubstancePolymerMonomerSetStartingMaterial): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirSubstancePolymerMonomerSetStartingMaterialList.Insert(index: Integer): TFhirSubstancePolymerMonomerSetStartingMaterial;
begin
  result := TFhirSubstancePolymerMonomerSetStartingMaterial.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirSubstancePolymerMonomerSetStartingMaterialList.InsertItem(index: Integer; value: TFhirSubstancePolymerMonomerSetStartingMaterial);
begin
  assert(value is TFhirSubstancePolymerMonomerSetStartingMaterial);
  Inherited Insert(index, value);
end;

function TFhirSubstancePolymerMonomerSetStartingMaterialList.Item(index: Integer): TFhirSubstancePolymerMonomerSetStartingMaterial;
begin
  result := TFhirSubstancePolymerMonomerSetStartingMaterial(ObjectByIndex[index]);
end;

function TFhirSubstancePolymerMonomerSetStartingMaterialList.Link: TFhirSubstancePolymerMonomerSetStartingMaterialList;
begin
  result := TFhirSubstancePolymerMonomerSetStartingMaterialList(inherited Link);
end;

procedure TFhirSubstancePolymerMonomerSetStartingMaterialList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirSubstancePolymerMonomerSetStartingMaterialList.SetItemByIndex(index: Integer; value: TFhirSubstancePolymerMonomerSetStartingMaterial);
begin
  assert(value is TFhirSubstancePolymerMonomerSetStartingMaterial);
  FhirSubstancePolymerMonomerSetStartingMaterials[index] := value;
end;

procedure TFhirSubstancePolymerMonomerSetStartingMaterialList.SetItemN(index: Integer; value: TFhirSubstancePolymerMonomerSetStartingMaterial);
begin
  assert(value is TFhirSubstancePolymerMonomerSetStartingMaterial);
  ObjectByIndex[index] := value;
end;

{ TFhirSubstancePolymerRepeat }

constructor TFhirSubstancePolymerRepeat.Create;
begin
  inherited;
end;

destructor TFhirSubstancePolymerRepeat.Destroy;
begin
  FAverageMolecularFormula.free;
  FRepeatUnitAmountType.free;
  FRepeatUnitList.Free;
  inherited;
end;

procedure TFhirSubstancePolymerRepeat.Assign(oSource : TFslObject);
begin
  inherited;
  averageMolecularFormulaElement := TFhirSubstancePolymerRepeat(oSource).averageMolecularFormulaElement.Clone;
  repeatUnitAmountType := TFhirSubstancePolymerRepeat(oSource).repeatUnitAmountType.Clone;
  if (TFhirSubstancePolymerRepeat(oSource).FRepeatUnitList = nil) then
  begin
    FRepeatUnitList.free;
    FRepeatUnitList := nil;
  end
  else
  begin
    if FRepeatUnitList = nil then
      FRepeatUnitList := TFhirSubstancePolymerRepeatRepeatUnitList.Create;
    FRepeatUnitList.Assign(TFhirSubstancePolymerRepeat(oSource).FRepeatUnitList);
  end;
end;

procedure TFhirSubstancePolymerRepeat.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'averageMolecularFormula') Then
     list.add(self.link, 'averageMolecularFormula', FAverageMolecularFormula.Link);
  if (child_name = 'repeatUnitAmountType') Then
     list.add(self.link, 'repeatUnitAmountType', FRepeatUnitAmountType.Link);
  if (child_name = 'repeatUnit') Then
    list.addAll(self, 'repeatUnit', FRepeatUnitList);
end;

procedure TFhirSubstancePolymerRepeat.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'averageMolecularFormula', 'string', false, TFhirString, FAverageMolecularFormula.Link));
  oList.add(TFHIRProperty.create(self, 'repeatUnitAmountType', 'CodeableConcept', false, TFhirCodeableConcept, FRepeatUnitAmountType.Link));
  oList.add(TFHIRProperty.create(self, 'repeatUnit', 'BackboneElement', true, TFhirSubstancePolymerRepeatRepeatUnit, FRepeatUnitList.Link));
end;

function TFhirSubstancePolymerRepeat.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'averageMolecularFormula') then
  begin
    AverageMolecularFormulaElement := asString(propValue);
    result := propValue;
  end
  else if (propName = 'repeatUnitAmountType') then
  begin
    RepeatUnitAmountType := propValue as TFhirCodeableConcept;
    result := propValue;
  end
  else if (propName = 'repeatUnit') then
  begin
    RepeatUnitList.add(propValue as TFhirSubstancePolymerRepeatRepeatUnit);
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirSubstancePolymerRepeat.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'repeatUnit') then RepeatUnitList.insertItem(index, propValue as TFhirSubstancePolymerRepeatRepeatUnit)
  else inherited;
end;

function TFhirSubstancePolymerRepeat.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'averageMolecularFormula') then result := TFhirString.create()
  else if (propName = 'repeatUnitAmountType') then result := TFhirCodeableConcept.create()
  else if (propName = 'repeatUnit') then result := RepeatUnitList.new()
  else result := inherited createPropertyValue(propName);
end;

function TFhirSubstancePolymerRepeat.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'averageMolecularFormula') then result := 'string'
  else if (propName = 'repeatUnitAmountType') then result := 'CodeableConcept'
  else if (propName = 'repeatUnit') then result := 'BackboneElement'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirSubstancePolymerRepeat.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'averageMolecularFormula') then AverageMolecularFormulaElement := nil
  else if (propName = 'repeatUnitAmountType') then RepeatUnitAmountTypeElement := nil
  else if (propName = 'repeatUnit') then deletePropertyValue('repeatUnit', RepeatUnitList, value)
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirSubstancePolymerRepeat.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'averageMolecularFormula') then AverageMolecularFormulaElement := asString(new)
  else if (propName = 'repeatUnitAmountType') then RepeatUnitAmountTypeElement := new as TFhirCodeableConcept
  else if (propName = 'repeatUnit') then replacePropertyValue('repeatUnit', RepeatUnitList, existing, new)
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirSubstancePolymerRepeat.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'repeatUnit') then RepeatUnitList.move(source, destination)
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirSubstancePolymerRepeat.fhirType : string;
begin
  result := 'SubstancePolymer.repeat';
end;

function TFhirSubstancePolymerRepeat.Link : TFhirSubstancePolymerRepeat;
begin
  result := TFhirSubstancePolymerRepeat(inherited Link);
end;

function TFhirSubstancePolymerRepeat.Clone : TFhirSubstancePolymerRepeat;
begin
  result := TFhirSubstancePolymerRepeat(inherited Clone);
end;

function TFhirSubstancePolymerRepeat.equals(other : TObject) : boolean; 
var
  o : TFhirSubstancePolymerRepeat;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirSubstancePolymerRepeat)) then
    result := false
  else
  begin
    o := TFhirSubstancePolymerRepeat(other);
    result := compareDeep(averageMolecularFormulaElement, o.averageMolecularFormulaElement, true) and 
      compareDeep(repeatUnitAmountTypeElement, o.repeatUnitAmountTypeElement, true) and 
      compareDeep(repeatUnitList, o.repeatUnitList, true);
  end;
end;

function TFhirSubstancePolymerRepeat.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FAverageMolecularFormula) and isEmptyProp(FRepeatUnitAmountType) and isEmptyProp(FrepeatUnitList);
end;

procedure TFhirSubstancePolymerRepeat.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('averageMolecularFormula');
  fields.add('repeatUnitAmountType');
  fields.add('repeatUnit');
end;

function TFhirSubstancePolymerRepeat.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
  inc(result, FRepeatUnitList.sizeInBytes(magic));
end;

procedure TFhirSubstancePolymerRepeat.SetAverageMolecularFormula(value : TFhirString);
begin
  FAverageMolecularFormula.free;
  FAverageMolecularFormula := value;
end;

function TFhirSubstancePolymerRepeat.GetAverageMolecularFormulaST : String;
begin
  if FAverageMolecularFormula = nil then
    result := ''
  else
    result := FAverageMolecularFormula.value;
end;

procedure TFhirSubstancePolymerRepeat.SetAverageMolecularFormulaST(value : String);
begin
  if value <> '' then
  begin
    if FAverageMolecularFormula = nil then
      FAverageMolecularFormula := TFhirString.create;
    FAverageMolecularFormula.value := value
  end
  else if FAverageMolecularFormula <> nil then
    FAverageMolecularFormula.value := '';
end;

procedure TFhirSubstancePolymerRepeat.SetRepeatUnitAmountType(value : TFhirCodeableConcept);
begin
  FRepeatUnitAmountType.free;
  FRepeatUnitAmountType := value;
end;

function TFhirSubstancePolymerRepeat.GetRepeatUnitList : TFhirSubstancePolymerRepeatRepeatUnitList;
begin
  if FRepeatUnitList = nil then
    FRepeatUnitList := TFhirSubstancePolymerRepeatRepeatUnitList.Create;
  result := FRepeatUnitList;
end;

function TFhirSubstancePolymerRepeat.GetHasRepeatUnitList : boolean;
begin
  result := (FRepeatUnitList <> nil) and (FRepeatUnitList.count > 0);
end;

{ TFhirSubstancePolymerRepeatListEnumerator }

constructor TFhirSubstancePolymerRepeatListEnumerator.Create(list : TFhirSubstancePolymerRepeatList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirSubstancePolymerRepeatListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirSubstancePolymerRepeatListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirSubstancePolymerRepeatListEnumerator.GetCurrent : TFhirSubstancePolymerRepeat;
begin
  Result := FList[FIndex];
end;

function TFhirSubstancePolymerRepeatListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirSubstancePolymerRepeatList }

function TFhirSubstancePolymerRepeatList.AddItem(value: TFhirSubstancePolymerRepeat): TFhirSubstancePolymerRepeat;
begin
  assert(value.ClassName = 'TFhirSubstancePolymerRepeat', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirSubstancePolymerRepeat');
  add(value);
  result := value;
end;

function TFhirSubstancePolymerRepeatList.Append: TFhirSubstancePolymerRepeat;
begin
  result := TFhirSubstancePolymerRepeat.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirSubstancePolymerRepeatList.ClearItems;
begin
  Clear;
end;

function TFhirSubstancePolymerRepeatList.GetEnumerator : TFhirSubstancePolymerRepeatListEnumerator;
begin
  result := TFhirSubstancePolymerRepeatListEnumerator.Create(self.link);
end;

function TFhirSubstancePolymerRepeatList.Clone: TFhirSubstancePolymerRepeatList;
begin
  result := TFhirSubstancePolymerRepeatList(inherited Clone);
end;

function TFhirSubstancePolymerRepeatList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirSubstancePolymerRepeatList.GetItemN(index: Integer): TFhirSubstancePolymerRepeat;
begin
  result := TFhirSubstancePolymerRepeat(ObjectByIndex[index]);
end;

function TFhirSubstancePolymerRepeatList.ItemClass: TFslObjectClass;
begin
  result := TFhirSubstancePolymerRepeat;
end;
function TFhirSubstancePolymerRepeatList.IndexOf(value: TFhirSubstancePolymerRepeat): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirSubstancePolymerRepeatList.Insert(index: Integer): TFhirSubstancePolymerRepeat;
begin
  result := TFhirSubstancePolymerRepeat.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirSubstancePolymerRepeatList.InsertItem(index: Integer; value: TFhirSubstancePolymerRepeat);
begin
  assert(value is TFhirSubstancePolymerRepeat);
  Inherited Insert(index, value);
end;

function TFhirSubstancePolymerRepeatList.Item(index: Integer): TFhirSubstancePolymerRepeat;
begin
  result := TFhirSubstancePolymerRepeat(ObjectByIndex[index]);
end;

function TFhirSubstancePolymerRepeatList.Link: TFhirSubstancePolymerRepeatList;
begin
  result := TFhirSubstancePolymerRepeatList(inherited Link);
end;

procedure TFhirSubstancePolymerRepeatList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirSubstancePolymerRepeatList.SetItemByIndex(index: Integer; value: TFhirSubstancePolymerRepeat);
begin
  assert(value is TFhirSubstancePolymerRepeat);
  FhirSubstancePolymerRepeats[index] := value;
end;

procedure TFhirSubstancePolymerRepeatList.SetItemN(index: Integer; value: TFhirSubstancePolymerRepeat);
begin
  assert(value is TFhirSubstancePolymerRepeat);
  ObjectByIndex[index] := value;
end;

{ TFhirSubstancePolymerRepeatRepeatUnit }

constructor TFhirSubstancePolymerRepeatRepeatUnit.Create;
begin
  inherited;
end;

destructor TFhirSubstancePolymerRepeatRepeatUnit.Destroy;
begin
  FUnit_.free;
  FOrientation.free;
  FAmount.free;
  FDegreeOfPolymerisationList.Free;
  FStructuralRepresentationList.Free;
  inherited;
end;

procedure TFhirSubstancePolymerRepeatRepeatUnit.Assign(oSource : TFslObject);
begin
  inherited;
  unit_Element := TFhirSubstancePolymerRepeatRepeatUnit(oSource).unit_Element.Clone;
  orientation := TFhirSubstancePolymerRepeatRepeatUnit(oSource).orientation.Clone;
  amountElement := TFhirSubstancePolymerRepeatRepeatUnit(oSource).amountElement.Clone;
  if (TFhirSubstancePolymerRepeatRepeatUnit(oSource).FDegreeOfPolymerisationList = nil) then
  begin
    FDegreeOfPolymerisationList.free;
    FDegreeOfPolymerisationList := nil;
  end
  else
  begin
    if FDegreeOfPolymerisationList = nil then
      FDegreeOfPolymerisationList := TFhirSubstancePolymerRepeatRepeatUnitDegreeOfPolymerisationList.Create;
    FDegreeOfPolymerisationList.Assign(TFhirSubstancePolymerRepeatRepeatUnit(oSource).FDegreeOfPolymerisationList);
  end;
  if (TFhirSubstancePolymerRepeatRepeatUnit(oSource).FStructuralRepresentationList = nil) then
  begin
    FStructuralRepresentationList.free;
    FStructuralRepresentationList := nil;
  end
  else
  begin
    if FStructuralRepresentationList = nil then
      FStructuralRepresentationList := TFhirSubstancePolymerRepeatRepeatUnitStructuralRepresentationList.Create;
    FStructuralRepresentationList.Assign(TFhirSubstancePolymerRepeatRepeatUnit(oSource).FStructuralRepresentationList);
  end;
end;

procedure TFhirSubstancePolymerRepeatRepeatUnit.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'unit') Then
     list.add(self.link, 'unit', FUnit_.Link);
  if (child_name = 'orientation') Then
     list.add(self.link, 'orientation', FOrientation.Link);
  if (child_name = 'amount') Then
     list.add(self.link, 'amount', FAmount.Link);
  if (child_name = 'degreeOfPolymerisation') Then
    list.addAll(self, 'degreeOfPolymerisation', FDegreeOfPolymerisationList);
  if (child_name = 'structuralRepresentation') Then
    list.addAll(self, 'structuralRepresentation', FStructuralRepresentationList);
end;

procedure TFhirSubstancePolymerRepeatRepeatUnit.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'unit', 'string', false, TFhirString, FUnit_.Link));
  oList.add(TFHIRProperty.create(self, 'orientation', 'CodeableConcept', false, TFhirCodeableConcept, FOrientation.Link));
  oList.add(TFHIRProperty.create(self, 'amount', 'integer', false, TFhirInteger, FAmount.Link));
  oList.add(TFHIRProperty.create(self, 'degreeOfPolymerisation', 'BackboneElement', true, TFhirSubstancePolymerRepeatRepeatUnitDegreeOfPolymerisation, FDegreeOfPolymerisationList.Link));
  oList.add(TFHIRProperty.create(self, 'structuralRepresentation', 'BackboneElement', true, TFhirSubstancePolymerRepeatRepeatUnitStructuralRepresentation, FStructuralRepresentationList.Link));
end;

function TFhirSubstancePolymerRepeatRepeatUnit.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'unit') then
  begin
    Unit_Element := asString(propValue);
    result := propValue;
  end
  else if (propName = 'orientation') then
  begin
    Orientation := propValue as TFhirCodeableConcept;
    result := propValue;
  end
  else if (propName = 'amount') then
  begin
    AmountElement := asInteger(propValue);
    result := propValue;
  end
  else if (propName = 'degreeOfPolymerisation') then
  begin
    DegreeOfPolymerisationList.add(propValue as TFhirSubstancePolymerRepeatRepeatUnitDegreeOfPolymerisation);
    result := propValue;
  end
  else if (propName = 'structuralRepresentation') then
  begin
    StructuralRepresentationList.add(propValue as TFhirSubstancePolymerRepeatRepeatUnitStructuralRepresentation);
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirSubstancePolymerRepeatRepeatUnit.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'degreeOfPolymerisation') then DegreeOfPolymerisationList.insertItem(index, propValue as TFhirSubstancePolymerRepeatRepeatUnitDegreeOfPolymerisation)
  else if (propName = 'structuralRepresentation') then StructuralRepresentationList.insertItem(index, propValue as TFhirSubstancePolymerRepeatRepeatUnitStructuralRepresentation)
  else inherited;
end;

function TFhirSubstancePolymerRepeatRepeatUnit.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'unit') then result := TFhirString.create()
  else if (propName = 'orientation') then result := TFhirCodeableConcept.create()
  else if (propName = 'amount') then result := TFhirInteger.create()
  else if (propName = 'degreeOfPolymerisation') then result := DegreeOfPolymerisationList.new()
  else if (propName = 'structuralRepresentation') then result := StructuralRepresentationList.new()
  else result := inherited createPropertyValue(propName);
end;

function TFhirSubstancePolymerRepeatRepeatUnit.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'unit') then result := 'string'
  else if (propName = 'orientation') then result := 'CodeableConcept'
  else if (propName = 'amount') then result := 'integer'
  else if (propName = 'degreeOfPolymerisation') then result := 'BackboneElement'
  else if (propName = 'structuralRepresentation') then result := 'BackboneElement'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirSubstancePolymerRepeatRepeatUnit.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'unit') then Unit_Element := nil
  else if (propName = 'orientation') then OrientationElement := nil
  else if (propName = 'amount') then AmountElement := nil
  else if (propName = 'degreeOfPolymerisation') then deletePropertyValue('degreeOfPolymerisation', DegreeOfPolymerisationList, value)
  else if (propName = 'structuralRepresentation') then deletePropertyValue('structuralRepresentation', StructuralRepresentationList, value)
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirSubstancePolymerRepeatRepeatUnit.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'unit') then Unit_Element := asString(new)
  else if (propName = 'orientation') then OrientationElement := new as TFhirCodeableConcept
  else if (propName = 'amount') then AmountElement := asInteger(new)
  else if (propName = 'degreeOfPolymerisation') then replacePropertyValue('degreeOfPolymerisation', DegreeOfPolymerisationList, existing, new)
  else if (propName = 'structuralRepresentation') then replacePropertyValue('structuralRepresentation', StructuralRepresentationList, existing, new)
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirSubstancePolymerRepeatRepeatUnit.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'degreeOfPolymerisation') then DegreeOfPolymerisationList.move(source, destination)
  else if (propName = 'structuralRepresentation') then StructuralRepresentationList.move(source, destination)
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirSubstancePolymerRepeatRepeatUnit.fhirType : string;
begin
  result := 'SubstancePolymer.repeat.repeatUnit';
end;

function TFhirSubstancePolymerRepeatRepeatUnit.Link : TFhirSubstancePolymerRepeatRepeatUnit;
begin
  result := TFhirSubstancePolymerRepeatRepeatUnit(inherited Link);
end;

function TFhirSubstancePolymerRepeatRepeatUnit.Clone : TFhirSubstancePolymerRepeatRepeatUnit;
begin
  result := TFhirSubstancePolymerRepeatRepeatUnit(inherited Clone);
end;

function TFhirSubstancePolymerRepeatRepeatUnit.equals(other : TObject) : boolean; 
var
  o : TFhirSubstancePolymerRepeatRepeatUnit;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirSubstancePolymerRepeatRepeatUnit)) then
    result := false
  else
  begin
    o := TFhirSubstancePolymerRepeatRepeatUnit(other);
    result := compareDeep(unit_Element, o.unit_Element, true) and compareDeep(orientationElement, o.orientationElement, true) and 
      compareDeep(amountElement, o.amountElement, true) and compareDeep(degreeOfPolymerisationList, o.degreeOfPolymerisationList, true) and 
      compareDeep(structuralRepresentationList, o.structuralRepresentationList, true);
  end;
end;

function TFhirSubstancePolymerRepeatRepeatUnit.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FUnit_) and isEmptyProp(FOrientation) and isEmptyProp(FAmount) and isEmptyProp(FdegreeOfPolymerisationList) and isEmptyProp(FstructuralRepresentationList);
end;

procedure TFhirSubstancePolymerRepeatRepeatUnit.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('unit');
  fields.add('orientation');
  fields.add('amount');
  fields.add('degreeOfPolymerisation');
  fields.add('structuralRepresentation');
end;

function TFhirSubstancePolymerRepeatRepeatUnit.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
  inc(result, FDegreeOfPolymerisationList.sizeInBytes(magic));
  inc(result, FStructuralRepresentationList.sizeInBytes(magic));
end;

procedure TFhirSubstancePolymerRepeatRepeatUnit.SetUnit_(value : TFhirString);
begin
  FUnit_.free;
  FUnit_ := value;
end;

function TFhirSubstancePolymerRepeatRepeatUnit.GetUnit_ST : String;
begin
  if FUnit_ = nil then
    result := ''
  else
    result := FUnit_.value;
end;

procedure TFhirSubstancePolymerRepeatRepeatUnit.SetUnit_ST(value : String);
begin
  if value <> '' then
  begin
    if FUnit_ = nil then
      FUnit_ := TFhirString.create;
    FUnit_.value := value
  end
  else if FUnit_ <> nil then
    FUnit_.value := '';
end;

procedure TFhirSubstancePolymerRepeatRepeatUnit.SetOrientation(value : TFhirCodeableConcept);
begin
  FOrientation.free;
  FOrientation := value;
end;

procedure TFhirSubstancePolymerRepeatRepeatUnit.SetAmount(value : TFhirInteger);
begin
  FAmount.free;
  FAmount := value;
end;

function TFhirSubstancePolymerRepeatRepeatUnit.GetAmountST : String;
begin
  if FAmount = nil then
    result := ''
  else
    result := FAmount.value;
end;

procedure TFhirSubstancePolymerRepeatRepeatUnit.SetAmountST(value : String);
begin
  if value <> '' then
  begin
    if FAmount = nil then
      FAmount := TFhirInteger.create;
    FAmount.value := value
  end
  else if FAmount <> nil then
    FAmount.value := '';
end;

function TFhirSubstancePolymerRepeatRepeatUnit.GetDegreeOfPolymerisationList : TFhirSubstancePolymerRepeatRepeatUnitDegreeOfPolymerisationList;
begin
  if FDegreeOfPolymerisationList = nil then
    FDegreeOfPolymerisationList := TFhirSubstancePolymerRepeatRepeatUnitDegreeOfPolymerisationList.Create;
  result := FDegreeOfPolymerisationList;
end;

function TFhirSubstancePolymerRepeatRepeatUnit.GetHasDegreeOfPolymerisationList : boolean;
begin
  result := (FDegreeOfPolymerisationList <> nil) and (FDegreeOfPolymerisationList.count > 0);
end;

function TFhirSubstancePolymerRepeatRepeatUnit.GetStructuralRepresentationList : TFhirSubstancePolymerRepeatRepeatUnitStructuralRepresentationList;
begin
  if FStructuralRepresentationList = nil then
    FStructuralRepresentationList := TFhirSubstancePolymerRepeatRepeatUnitStructuralRepresentationList.Create;
  result := FStructuralRepresentationList;
end;

function TFhirSubstancePolymerRepeatRepeatUnit.GetHasStructuralRepresentationList : boolean;
begin
  result := (FStructuralRepresentationList <> nil) and (FStructuralRepresentationList.count > 0);
end;

{ TFhirSubstancePolymerRepeatRepeatUnitListEnumerator }

constructor TFhirSubstancePolymerRepeatRepeatUnitListEnumerator.Create(list : TFhirSubstancePolymerRepeatRepeatUnitList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirSubstancePolymerRepeatRepeatUnitListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirSubstancePolymerRepeatRepeatUnitListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirSubstancePolymerRepeatRepeatUnitListEnumerator.GetCurrent : TFhirSubstancePolymerRepeatRepeatUnit;
begin
  Result := FList[FIndex];
end;

function TFhirSubstancePolymerRepeatRepeatUnitListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirSubstancePolymerRepeatRepeatUnitList }

function TFhirSubstancePolymerRepeatRepeatUnitList.AddItem(value: TFhirSubstancePolymerRepeatRepeatUnit): TFhirSubstancePolymerRepeatRepeatUnit;
begin
  assert(value.ClassName = 'TFhirSubstancePolymerRepeatRepeatUnit', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirSubstancePolymerRepeatRepeatUnit');
  add(value);
  result := value;
end;

function TFhirSubstancePolymerRepeatRepeatUnitList.Append: TFhirSubstancePolymerRepeatRepeatUnit;
begin
  result := TFhirSubstancePolymerRepeatRepeatUnit.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirSubstancePolymerRepeatRepeatUnitList.ClearItems;
begin
  Clear;
end;

function TFhirSubstancePolymerRepeatRepeatUnitList.GetEnumerator : TFhirSubstancePolymerRepeatRepeatUnitListEnumerator;
begin
  result := TFhirSubstancePolymerRepeatRepeatUnitListEnumerator.Create(self.link);
end;

function TFhirSubstancePolymerRepeatRepeatUnitList.Clone: TFhirSubstancePolymerRepeatRepeatUnitList;
begin
  result := TFhirSubstancePolymerRepeatRepeatUnitList(inherited Clone);
end;

function TFhirSubstancePolymerRepeatRepeatUnitList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirSubstancePolymerRepeatRepeatUnitList.GetItemN(index: Integer): TFhirSubstancePolymerRepeatRepeatUnit;
begin
  result := TFhirSubstancePolymerRepeatRepeatUnit(ObjectByIndex[index]);
end;

function TFhirSubstancePolymerRepeatRepeatUnitList.ItemClass: TFslObjectClass;
begin
  result := TFhirSubstancePolymerRepeatRepeatUnit;
end;
function TFhirSubstancePolymerRepeatRepeatUnitList.IndexOf(value: TFhirSubstancePolymerRepeatRepeatUnit): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirSubstancePolymerRepeatRepeatUnitList.Insert(index: Integer): TFhirSubstancePolymerRepeatRepeatUnit;
begin
  result := TFhirSubstancePolymerRepeatRepeatUnit.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirSubstancePolymerRepeatRepeatUnitList.InsertItem(index: Integer; value: TFhirSubstancePolymerRepeatRepeatUnit);
begin
  assert(value is TFhirSubstancePolymerRepeatRepeatUnit);
  Inherited Insert(index, value);
end;

function TFhirSubstancePolymerRepeatRepeatUnitList.Item(index: Integer): TFhirSubstancePolymerRepeatRepeatUnit;
begin
  result := TFhirSubstancePolymerRepeatRepeatUnit(ObjectByIndex[index]);
end;

function TFhirSubstancePolymerRepeatRepeatUnitList.Link: TFhirSubstancePolymerRepeatRepeatUnitList;
begin
  result := TFhirSubstancePolymerRepeatRepeatUnitList(inherited Link);
end;

procedure TFhirSubstancePolymerRepeatRepeatUnitList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirSubstancePolymerRepeatRepeatUnitList.SetItemByIndex(index: Integer; value: TFhirSubstancePolymerRepeatRepeatUnit);
begin
  assert(value is TFhirSubstancePolymerRepeatRepeatUnit);
  FhirSubstancePolymerRepeatRepeatUnits[index] := value;
end;

procedure TFhirSubstancePolymerRepeatRepeatUnitList.SetItemN(index: Integer; value: TFhirSubstancePolymerRepeatRepeatUnit);
begin
  assert(value is TFhirSubstancePolymerRepeatRepeatUnit);
  ObjectByIndex[index] := value;
end;

{ TFhirSubstancePolymerRepeatRepeatUnitDegreeOfPolymerisation }

constructor TFhirSubstancePolymerRepeatRepeatUnitDegreeOfPolymerisation.Create;
begin
  inherited;
end;

destructor TFhirSubstancePolymerRepeatRepeatUnitDegreeOfPolymerisation.Destroy;
begin
  FType_.free;
  FAverage.free;
  FLow.free;
  FHigh.free;
  inherited;
end;

procedure TFhirSubstancePolymerRepeatRepeatUnitDegreeOfPolymerisation.Assign(oSource : TFslObject);
begin
  inherited;
  type_ := TFhirSubstancePolymerRepeatRepeatUnitDegreeOfPolymerisation(oSource).type_.Clone;
  averageElement := TFhirSubstancePolymerRepeatRepeatUnitDegreeOfPolymerisation(oSource).averageElement.Clone;
  lowElement := TFhirSubstancePolymerRepeatRepeatUnitDegreeOfPolymerisation(oSource).lowElement.Clone;
  highElement := TFhirSubstancePolymerRepeatRepeatUnitDegreeOfPolymerisation(oSource).highElement.Clone;
end;

procedure TFhirSubstancePolymerRepeatRepeatUnitDegreeOfPolymerisation.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'type') Then
     list.add(self.link, 'type', FType_.Link);
  if (child_name = 'average') Then
     list.add(self.link, 'average', FAverage.Link);
  if (child_name = 'low') Then
     list.add(self.link, 'low', FLow.Link);
  if (child_name = 'high') Then
     list.add(self.link, 'high', FHigh.Link);
end;

procedure TFhirSubstancePolymerRepeatRepeatUnitDegreeOfPolymerisation.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'type', 'CodeableConcept', false, TFhirCodeableConcept, FType_.Link));
  oList.add(TFHIRProperty.create(self, 'average', 'integer', false, TFhirInteger, FAverage.Link));
  oList.add(TFHIRProperty.create(self, 'low', 'integer', false, TFhirInteger, FLow.Link));
  oList.add(TFHIRProperty.create(self, 'high', 'integer', false, TFhirInteger, FHigh.Link));
end;

function TFhirSubstancePolymerRepeatRepeatUnitDegreeOfPolymerisation.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'type') then
  begin
    Type_ := propValue as TFhirCodeableConcept;
    result := propValue;
  end
  else if (propName = 'average') then
  begin
    AverageElement := asInteger(propValue);
    result := propValue;
  end
  else if (propName = 'low') then
  begin
    LowElement := asInteger(propValue);
    result := propValue;
  end
  else if (propName = 'high') then
  begin
    HighElement := asInteger(propValue);
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirSubstancePolymerRepeatRepeatUnitDegreeOfPolymerisation.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirSubstancePolymerRepeatRepeatUnitDegreeOfPolymerisation.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'type') then result := TFhirCodeableConcept.create()
  else if (propName = 'average') then result := TFhirInteger.create()
  else if (propName = 'low') then result := TFhirInteger.create()
  else if (propName = 'high') then result := TFhirInteger.create()
  else result := inherited createPropertyValue(propName);
end;

function TFhirSubstancePolymerRepeatRepeatUnitDegreeOfPolymerisation.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'type') then result := 'CodeableConcept'
  else if (propName = 'average') then result := 'integer'
  else if (propName = 'low') then result := 'integer'
  else if (propName = 'high') then result := 'integer'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirSubstancePolymerRepeatRepeatUnitDegreeOfPolymerisation.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'type') then Type_Element := nil
  else if (propName = 'average') then AverageElement := nil
  else if (propName = 'low') then LowElement := nil
  else if (propName = 'high') then HighElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirSubstancePolymerRepeatRepeatUnitDegreeOfPolymerisation.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'type') then Type_Element := new as TFhirCodeableConcept
  else if (propName = 'average') then AverageElement := asInteger(new)
  else if (propName = 'low') then LowElement := asInteger(new)
  else if (propName = 'high') then HighElement := asInteger(new)
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirSubstancePolymerRepeatRepeatUnitDegreeOfPolymerisation.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirSubstancePolymerRepeatRepeatUnitDegreeOfPolymerisation.fhirType : string;
begin
  result := 'SubstancePolymer.repeat.repeatUnit.degreeOfPolymerisation';
end;

function TFhirSubstancePolymerRepeatRepeatUnitDegreeOfPolymerisation.Link : TFhirSubstancePolymerRepeatRepeatUnitDegreeOfPolymerisation;
begin
  result := TFhirSubstancePolymerRepeatRepeatUnitDegreeOfPolymerisation(inherited Link);
end;

function TFhirSubstancePolymerRepeatRepeatUnitDegreeOfPolymerisation.Clone : TFhirSubstancePolymerRepeatRepeatUnitDegreeOfPolymerisation;
begin
  result := TFhirSubstancePolymerRepeatRepeatUnitDegreeOfPolymerisation(inherited Clone);
end;

function TFhirSubstancePolymerRepeatRepeatUnitDegreeOfPolymerisation.equals(other : TObject) : boolean; 
var
  o : TFhirSubstancePolymerRepeatRepeatUnitDegreeOfPolymerisation;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirSubstancePolymerRepeatRepeatUnitDegreeOfPolymerisation)) then
    result := false
  else
  begin
    o := TFhirSubstancePolymerRepeatRepeatUnitDegreeOfPolymerisation(other);
    result := compareDeep(type_Element, o.type_Element, true) and compareDeep(averageElement, o.averageElement, true) and 
      compareDeep(lowElement, o.lowElement, true) and compareDeep(highElement, o.highElement, true);
  end;
end;

function TFhirSubstancePolymerRepeatRepeatUnitDegreeOfPolymerisation.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FType_) and isEmptyProp(FAverage) and isEmptyProp(FLow) and isEmptyProp(FHigh);
end;

procedure TFhirSubstancePolymerRepeatRepeatUnitDegreeOfPolymerisation.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('type');
  fields.add('average');
  fields.add('low');
  fields.add('high');
end;

function TFhirSubstancePolymerRepeatRepeatUnitDegreeOfPolymerisation.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
end;

procedure TFhirSubstancePolymerRepeatRepeatUnitDegreeOfPolymerisation.SetType_(value : TFhirCodeableConcept);
begin
  FType_.free;
  FType_ := value;
end;

procedure TFhirSubstancePolymerRepeatRepeatUnitDegreeOfPolymerisation.SetAverage(value : TFhirInteger);
begin
  FAverage.free;
  FAverage := value;
end;

function TFhirSubstancePolymerRepeatRepeatUnitDegreeOfPolymerisation.GetAverageST : String;
begin
  if FAverage = nil then
    result := ''
  else
    result := FAverage.value;
end;

procedure TFhirSubstancePolymerRepeatRepeatUnitDegreeOfPolymerisation.SetAverageST(value : String);
begin
  if value <> '' then
  begin
    if FAverage = nil then
      FAverage := TFhirInteger.create;
    FAverage.value := value
  end
  else if FAverage <> nil then
    FAverage.value := '';
end;

procedure TFhirSubstancePolymerRepeatRepeatUnitDegreeOfPolymerisation.SetLow(value : TFhirInteger);
begin
  FLow.free;
  FLow := value;
end;

function TFhirSubstancePolymerRepeatRepeatUnitDegreeOfPolymerisation.GetLowST : String;
begin
  if FLow = nil then
    result := ''
  else
    result := FLow.value;
end;

procedure TFhirSubstancePolymerRepeatRepeatUnitDegreeOfPolymerisation.SetLowST(value : String);
begin
  if value <> '' then
  begin
    if FLow = nil then
      FLow := TFhirInteger.create;
    FLow.value := value
  end
  else if FLow <> nil then
    FLow.value := '';
end;

procedure TFhirSubstancePolymerRepeatRepeatUnitDegreeOfPolymerisation.SetHigh(value : TFhirInteger);
begin
  FHigh.free;
  FHigh := value;
end;

function TFhirSubstancePolymerRepeatRepeatUnitDegreeOfPolymerisation.GetHighST : String;
begin
  if FHigh = nil then
    result := ''
  else
    result := FHigh.value;
end;

procedure TFhirSubstancePolymerRepeatRepeatUnitDegreeOfPolymerisation.SetHighST(value : String);
begin
  if value <> '' then
  begin
    if FHigh = nil then
      FHigh := TFhirInteger.create;
    FHigh.value := value
  end
  else if FHigh <> nil then
    FHigh.value := '';
end;

{ TFhirSubstancePolymerRepeatRepeatUnitDegreeOfPolymerisationListEnumerator }

constructor TFhirSubstancePolymerRepeatRepeatUnitDegreeOfPolymerisationListEnumerator.Create(list : TFhirSubstancePolymerRepeatRepeatUnitDegreeOfPolymerisationList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirSubstancePolymerRepeatRepeatUnitDegreeOfPolymerisationListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirSubstancePolymerRepeatRepeatUnitDegreeOfPolymerisationListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirSubstancePolymerRepeatRepeatUnitDegreeOfPolymerisationListEnumerator.GetCurrent : TFhirSubstancePolymerRepeatRepeatUnitDegreeOfPolymerisation;
begin
  Result := FList[FIndex];
end;

function TFhirSubstancePolymerRepeatRepeatUnitDegreeOfPolymerisationListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirSubstancePolymerRepeatRepeatUnitDegreeOfPolymerisationList }

function TFhirSubstancePolymerRepeatRepeatUnitDegreeOfPolymerisationList.AddItem(value: TFhirSubstancePolymerRepeatRepeatUnitDegreeOfPolymerisation): TFhirSubstancePolymerRepeatRepeatUnitDegreeOfPolymerisation;
begin
  assert(value.ClassName = 'TFhirSubstancePolymerRepeatRepeatUnitDegreeOfPolymerisation', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirSubstancePolymerRepeatRepeatUnitDegreeOfPolymerisation');
  add(value);
  result := value;
end;

function TFhirSubstancePolymerRepeatRepeatUnitDegreeOfPolymerisationList.Append: TFhirSubstancePolymerRepeatRepeatUnitDegreeOfPolymerisation;
begin
  result := TFhirSubstancePolymerRepeatRepeatUnitDegreeOfPolymerisation.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirSubstancePolymerRepeatRepeatUnitDegreeOfPolymerisationList.ClearItems;
begin
  Clear;
end;

function TFhirSubstancePolymerRepeatRepeatUnitDegreeOfPolymerisationList.GetEnumerator : TFhirSubstancePolymerRepeatRepeatUnitDegreeOfPolymerisationListEnumerator;
begin
  result := TFhirSubstancePolymerRepeatRepeatUnitDegreeOfPolymerisationListEnumerator.Create(self.link);
end;

function TFhirSubstancePolymerRepeatRepeatUnitDegreeOfPolymerisationList.Clone: TFhirSubstancePolymerRepeatRepeatUnitDegreeOfPolymerisationList;
begin
  result := TFhirSubstancePolymerRepeatRepeatUnitDegreeOfPolymerisationList(inherited Clone);
end;

function TFhirSubstancePolymerRepeatRepeatUnitDegreeOfPolymerisationList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirSubstancePolymerRepeatRepeatUnitDegreeOfPolymerisationList.GetItemN(index: Integer): TFhirSubstancePolymerRepeatRepeatUnitDegreeOfPolymerisation;
begin
  result := TFhirSubstancePolymerRepeatRepeatUnitDegreeOfPolymerisation(ObjectByIndex[index]);
end;

function TFhirSubstancePolymerRepeatRepeatUnitDegreeOfPolymerisationList.ItemClass: TFslObjectClass;
begin
  result := TFhirSubstancePolymerRepeatRepeatUnitDegreeOfPolymerisation;
end;
function TFhirSubstancePolymerRepeatRepeatUnitDegreeOfPolymerisationList.IndexOf(value: TFhirSubstancePolymerRepeatRepeatUnitDegreeOfPolymerisation): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirSubstancePolymerRepeatRepeatUnitDegreeOfPolymerisationList.Insert(index: Integer): TFhirSubstancePolymerRepeatRepeatUnitDegreeOfPolymerisation;
begin
  result := TFhirSubstancePolymerRepeatRepeatUnitDegreeOfPolymerisation.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirSubstancePolymerRepeatRepeatUnitDegreeOfPolymerisationList.InsertItem(index: Integer; value: TFhirSubstancePolymerRepeatRepeatUnitDegreeOfPolymerisation);
begin
  assert(value is TFhirSubstancePolymerRepeatRepeatUnitDegreeOfPolymerisation);
  Inherited Insert(index, value);
end;

function TFhirSubstancePolymerRepeatRepeatUnitDegreeOfPolymerisationList.Item(index: Integer): TFhirSubstancePolymerRepeatRepeatUnitDegreeOfPolymerisation;
begin
  result := TFhirSubstancePolymerRepeatRepeatUnitDegreeOfPolymerisation(ObjectByIndex[index]);
end;

function TFhirSubstancePolymerRepeatRepeatUnitDegreeOfPolymerisationList.Link: TFhirSubstancePolymerRepeatRepeatUnitDegreeOfPolymerisationList;
begin
  result := TFhirSubstancePolymerRepeatRepeatUnitDegreeOfPolymerisationList(inherited Link);
end;

procedure TFhirSubstancePolymerRepeatRepeatUnitDegreeOfPolymerisationList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirSubstancePolymerRepeatRepeatUnitDegreeOfPolymerisationList.SetItemByIndex(index: Integer; value: TFhirSubstancePolymerRepeatRepeatUnitDegreeOfPolymerisation);
begin
  assert(value is TFhirSubstancePolymerRepeatRepeatUnitDegreeOfPolymerisation);
  FhirSubstancePolymerRepeatRepeatUnitDegreeOfPolymerisations[index] := value;
end;

procedure TFhirSubstancePolymerRepeatRepeatUnitDegreeOfPolymerisationList.SetItemN(index: Integer; value: TFhirSubstancePolymerRepeatRepeatUnitDegreeOfPolymerisation);
begin
  assert(value is TFhirSubstancePolymerRepeatRepeatUnitDegreeOfPolymerisation);
  ObjectByIndex[index] := value;
end;

{ TFhirSubstancePolymerRepeatRepeatUnitStructuralRepresentation }

constructor TFhirSubstancePolymerRepeatRepeatUnitStructuralRepresentation.Create;
begin
  inherited;
end;

destructor TFhirSubstancePolymerRepeatRepeatUnitStructuralRepresentation.Destroy;
begin
  FType_.free;
  FRepresentation.free;
  FFormat.free;
  FAttachment.free;
  inherited;
end;

procedure TFhirSubstancePolymerRepeatRepeatUnitStructuralRepresentation.Assign(oSource : TFslObject);
begin
  inherited;
  type_ := TFhirSubstancePolymerRepeatRepeatUnitStructuralRepresentation(oSource).type_.Clone;
  representationElement := TFhirSubstancePolymerRepeatRepeatUnitStructuralRepresentation(oSource).representationElement.Clone;
  format := TFhirSubstancePolymerRepeatRepeatUnitStructuralRepresentation(oSource).format.Clone;
  attachment := TFhirSubstancePolymerRepeatRepeatUnitStructuralRepresentation(oSource).attachment.Clone;
end;

procedure TFhirSubstancePolymerRepeatRepeatUnitStructuralRepresentation.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'type') Then
     list.add(self.link, 'type', FType_.Link);
  if (child_name = 'representation') Then
     list.add(self.link, 'representation', FRepresentation.Link);
  if (child_name = 'format') Then
     list.add(self.link, 'format', FFormat.Link);
  if (child_name = 'attachment') Then
     list.add(self.link, 'attachment', FAttachment.Link);
end;

procedure TFhirSubstancePolymerRepeatRepeatUnitStructuralRepresentation.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'type', 'CodeableConcept', false, TFhirCodeableConcept, FType_.Link));
  oList.add(TFHIRProperty.create(self, 'representation', 'string', false, TFhirString, FRepresentation.Link));
  oList.add(TFHIRProperty.create(self, 'format', 'CodeableConcept', false, TFhirCodeableConcept, FFormat.Link));
  oList.add(TFHIRProperty.create(self, 'attachment', 'Attachment', false, TFhirAttachment, FAttachment.Link));
end;

function TFhirSubstancePolymerRepeatRepeatUnitStructuralRepresentation.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'type') then
  begin
    Type_ := propValue as TFhirCodeableConcept;
    result := propValue;
  end
  else if (propName = 'representation') then
  begin
    RepresentationElement := asString(propValue);
    result := propValue;
  end
  else if (propName = 'format') then
  begin
    Format := propValue as TFhirCodeableConcept;
    result := propValue;
  end
  else if (propName = 'attachment') then
  begin
    Attachment := propValue as TFhirAttachment;
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirSubstancePolymerRepeatRepeatUnitStructuralRepresentation.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirSubstancePolymerRepeatRepeatUnitStructuralRepresentation.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'type') then result := TFhirCodeableConcept.create()
  else if (propName = 'representation') then result := TFhirString.create()
  else if (propName = 'format') then result := TFhirCodeableConcept.create()
  else if (propName = 'attachment') then result := TFhirAttachment.create()
  else result := inherited createPropertyValue(propName);
end;

function TFhirSubstancePolymerRepeatRepeatUnitStructuralRepresentation.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'type') then result := 'CodeableConcept'
  else if (propName = 'representation') then result := 'string'
  else if (propName = 'format') then result := 'CodeableConcept'
  else if (propName = 'attachment') then result := 'Attachment'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirSubstancePolymerRepeatRepeatUnitStructuralRepresentation.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'type') then Type_Element := nil
  else if (propName = 'representation') then RepresentationElement := nil
  else if (propName = 'format') then FormatElement := nil
  else if (propName = 'attachment') then AttachmentElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirSubstancePolymerRepeatRepeatUnitStructuralRepresentation.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'type') then Type_Element := new as TFhirCodeableConcept
  else if (propName = 'representation') then RepresentationElement := asString(new)
  else if (propName = 'format') then FormatElement := new as TFhirCodeableConcept
  else if (propName = 'attachment') then AttachmentElement := new as TFhirAttachment
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirSubstancePolymerRepeatRepeatUnitStructuralRepresentation.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirSubstancePolymerRepeatRepeatUnitStructuralRepresentation.fhirType : string;
begin
  result := 'SubstancePolymer.repeat.repeatUnit.structuralRepresentation';
end;

function TFhirSubstancePolymerRepeatRepeatUnitStructuralRepresentation.Link : TFhirSubstancePolymerRepeatRepeatUnitStructuralRepresentation;
begin
  result := TFhirSubstancePolymerRepeatRepeatUnitStructuralRepresentation(inherited Link);
end;

function TFhirSubstancePolymerRepeatRepeatUnitStructuralRepresentation.Clone : TFhirSubstancePolymerRepeatRepeatUnitStructuralRepresentation;
begin
  result := TFhirSubstancePolymerRepeatRepeatUnitStructuralRepresentation(inherited Clone);
end;

function TFhirSubstancePolymerRepeatRepeatUnitStructuralRepresentation.equals(other : TObject) : boolean; 
var
  o : TFhirSubstancePolymerRepeatRepeatUnitStructuralRepresentation;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirSubstancePolymerRepeatRepeatUnitStructuralRepresentation)) then
    result := false
  else
  begin
    o := TFhirSubstancePolymerRepeatRepeatUnitStructuralRepresentation(other);
    result := compareDeep(type_Element, o.type_Element, true) and compareDeep(representationElement, o.representationElement, true) and 
      compareDeep(formatElement, o.formatElement, true) and compareDeep(attachmentElement, o.attachmentElement, true);
  end;
end;

function TFhirSubstancePolymerRepeatRepeatUnitStructuralRepresentation.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FType_) and isEmptyProp(FRepresentation) and isEmptyProp(FFormat) and isEmptyProp(FAttachment);
end;

procedure TFhirSubstancePolymerRepeatRepeatUnitStructuralRepresentation.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('type');
  fields.add('representation');
  fields.add('format');
  fields.add('attachment');
end;

function TFhirSubstancePolymerRepeatRepeatUnitStructuralRepresentation.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
end;

procedure TFhirSubstancePolymerRepeatRepeatUnitStructuralRepresentation.SetType_(value : TFhirCodeableConcept);
begin
  FType_.free;
  FType_ := value;
end;

procedure TFhirSubstancePolymerRepeatRepeatUnitStructuralRepresentation.SetRepresentation(value : TFhirString);
begin
  FRepresentation.free;
  FRepresentation := value;
end;

function TFhirSubstancePolymerRepeatRepeatUnitStructuralRepresentation.GetRepresentationST : String;
begin
  if FRepresentation = nil then
    result := ''
  else
    result := FRepresentation.value;
end;

procedure TFhirSubstancePolymerRepeatRepeatUnitStructuralRepresentation.SetRepresentationST(value : String);
begin
  if value <> '' then
  begin
    if FRepresentation = nil then
      FRepresentation := TFhirString.create;
    FRepresentation.value := value
  end
  else if FRepresentation <> nil then
    FRepresentation.value := '';
end;

procedure TFhirSubstancePolymerRepeatRepeatUnitStructuralRepresentation.SetFormat(value : TFhirCodeableConcept);
begin
  FFormat.free;
  FFormat := value;
end;

procedure TFhirSubstancePolymerRepeatRepeatUnitStructuralRepresentation.SetAttachment(value : TFhirAttachment);
begin
  FAttachment.free;
  FAttachment := value;
end;

{ TFhirSubstancePolymerRepeatRepeatUnitStructuralRepresentationListEnumerator }

constructor TFhirSubstancePolymerRepeatRepeatUnitStructuralRepresentationListEnumerator.Create(list : TFhirSubstancePolymerRepeatRepeatUnitStructuralRepresentationList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirSubstancePolymerRepeatRepeatUnitStructuralRepresentationListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirSubstancePolymerRepeatRepeatUnitStructuralRepresentationListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirSubstancePolymerRepeatRepeatUnitStructuralRepresentationListEnumerator.GetCurrent : TFhirSubstancePolymerRepeatRepeatUnitStructuralRepresentation;
begin
  Result := FList[FIndex];
end;

function TFhirSubstancePolymerRepeatRepeatUnitStructuralRepresentationListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirSubstancePolymerRepeatRepeatUnitStructuralRepresentationList }

function TFhirSubstancePolymerRepeatRepeatUnitStructuralRepresentationList.AddItem(value: TFhirSubstancePolymerRepeatRepeatUnitStructuralRepresentation): TFhirSubstancePolymerRepeatRepeatUnitStructuralRepresentation;
begin
  assert(value.ClassName = 'TFhirSubstancePolymerRepeatRepeatUnitStructuralRepresentation', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirSubstancePolymerRepeatRepeatUnitStructuralRepresentation');
  add(value);
  result := value;
end;

function TFhirSubstancePolymerRepeatRepeatUnitStructuralRepresentationList.Append: TFhirSubstancePolymerRepeatRepeatUnitStructuralRepresentation;
begin
  result := TFhirSubstancePolymerRepeatRepeatUnitStructuralRepresentation.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirSubstancePolymerRepeatRepeatUnitStructuralRepresentationList.ClearItems;
begin
  Clear;
end;

function TFhirSubstancePolymerRepeatRepeatUnitStructuralRepresentationList.GetEnumerator : TFhirSubstancePolymerRepeatRepeatUnitStructuralRepresentationListEnumerator;
begin
  result := TFhirSubstancePolymerRepeatRepeatUnitStructuralRepresentationListEnumerator.Create(self.link);
end;

function TFhirSubstancePolymerRepeatRepeatUnitStructuralRepresentationList.Clone: TFhirSubstancePolymerRepeatRepeatUnitStructuralRepresentationList;
begin
  result := TFhirSubstancePolymerRepeatRepeatUnitStructuralRepresentationList(inherited Clone);
end;

function TFhirSubstancePolymerRepeatRepeatUnitStructuralRepresentationList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirSubstancePolymerRepeatRepeatUnitStructuralRepresentationList.GetItemN(index: Integer): TFhirSubstancePolymerRepeatRepeatUnitStructuralRepresentation;
begin
  result := TFhirSubstancePolymerRepeatRepeatUnitStructuralRepresentation(ObjectByIndex[index]);
end;

function TFhirSubstancePolymerRepeatRepeatUnitStructuralRepresentationList.ItemClass: TFslObjectClass;
begin
  result := TFhirSubstancePolymerRepeatRepeatUnitStructuralRepresentation;
end;
function TFhirSubstancePolymerRepeatRepeatUnitStructuralRepresentationList.IndexOf(value: TFhirSubstancePolymerRepeatRepeatUnitStructuralRepresentation): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirSubstancePolymerRepeatRepeatUnitStructuralRepresentationList.Insert(index: Integer): TFhirSubstancePolymerRepeatRepeatUnitStructuralRepresentation;
begin
  result := TFhirSubstancePolymerRepeatRepeatUnitStructuralRepresentation.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirSubstancePolymerRepeatRepeatUnitStructuralRepresentationList.InsertItem(index: Integer; value: TFhirSubstancePolymerRepeatRepeatUnitStructuralRepresentation);
begin
  assert(value is TFhirSubstancePolymerRepeatRepeatUnitStructuralRepresentation);
  Inherited Insert(index, value);
end;

function TFhirSubstancePolymerRepeatRepeatUnitStructuralRepresentationList.Item(index: Integer): TFhirSubstancePolymerRepeatRepeatUnitStructuralRepresentation;
begin
  result := TFhirSubstancePolymerRepeatRepeatUnitStructuralRepresentation(ObjectByIndex[index]);
end;

function TFhirSubstancePolymerRepeatRepeatUnitStructuralRepresentationList.Link: TFhirSubstancePolymerRepeatRepeatUnitStructuralRepresentationList;
begin
  result := TFhirSubstancePolymerRepeatRepeatUnitStructuralRepresentationList(inherited Link);
end;

procedure TFhirSubstancePolymerRepeatRepeatUnitStructuralRepresentationList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirSubstancePolymerRepeatRepeatUnitStructuralRepresentationList.SetItemByIndex(index: Integer; value: TFhirSubstancePolymerRepeatRepeatUnitStructuralRepresentation);
begin
  assert(value is TFhirSubstancePolymerRepeatRepeatUnitStructuralRepresentation);
  FhirSubstancePolymerRepeatRepeatUnitStructuralRepresentations[index] := value;
end;

procedure TFhirSubstancePolymerRepeatRepeatUnitStructuralRepresentationList.SetItemN(index: Integer; value: TFhirSubstancePolymerRepeatRepeatUnitStructuralRepresentation);
begin
  assert(value is TFhirSubstancePolymerRepeatRepeatUnitStructuralRepresentation);
  ObjectByIndex[index] := value;
end;

{ TFhirSubstancePolymer }

constructor TFhirSubstancePolymer.Create;
begin
  inherited;
end;

destructor TFhirSubstancePolymer.Destroy;
begin
  FIdentifier.free;
  FClass_.free;
  FGeometry.free;
  FCopolymerConnectivityList.Free;
  FModification.free;
  FMonomerSetList.Free;
  FRepeat_List.Free;
  inherited;
end;

procedure TFhirSubstancePolymer.Assign(oSource : TFslObject);
begin
  inherited;
  identifier := TFhirSubstancePolymer(oSource).identifier.Clone;
  class_ := TFhirSubstancePolymer(oSource).class_.Clone;
  geometry := TFhirSubstancePolymer(oSource).geometry.Clone;
  if (TFhirSubstancePolymer(oSource).FCopolymerConnectivityList = nil) then
  begin
    FCopolymerConnectivityList.free;
    FCopolymerConnectivityList := nil;
  end
  else
  begin
    if FCopolymerConnectivityList = nil then
      FCopolymerConnectivityList := TFhirCodeableConceptList.Create;
    FCopolymerConnectivityList.Assign(TFhirSubstancePolymer(oSource).FCopolymerConnectivityList);
  end;
  modificationElement := TFhirSubstancePolymer(oSource).modificationElement.Clone;
  if (TFhirSubstancePolymer(oSource).FMonomerSetList = nil) then
  begin
    FMonomerSetList.free;
    FMonomerSetList := nil;
  end
  else
  begin
    if FMonomerSetList = nil then
      FMonomerSetList := TFhirSubstancePolymerMonomerSetList.Create;
    FMonomerSetList.Assign(TFhirSubstancePolymer(oSource).FMonomerSetList);
  end;
  if (TFhirSubstancePolymer(oSource).FRepeat_List = nil) then
  begin
    FRepeat_List.free;
    FRepeat_List := nil;
  end
  else
  begin
    if FRepeat_List = nil then
      FRepeat_List := TFhirSubstancePolymerRepeatList.Create;
    FRepeat_List.Assign(TFhirSubstancePolymer(oSource).FRepeat_List);
  end;
end;

function TFhirSubstancePolymer.GetResourceType : TFhirResourceType;
begin
  result := frtSubstancePolymer;
end;

procedure TFhirSubstancePolymer.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'identifier') Then
     list.add(self.link, 'identifier', FIdentifier.Link);
  if (child_name = 'class') Then
     list.add(self.link, 'class', FClass_.Link);
  if (child_name = 'geometry') Then
     list.add(self.link, 'geometry', FGeometry.Link);
  if (child_name = 'copolymerConnectivity') Then
    list.addAll(self, 'copolymerConnectivity', FCopolymerConnectivityList);
  if (child_name = 'modification') Then
     list.add(self.link, 'modification', FModification.Link);
  if (child_name = 'monomerSet') Then
    list.addAll(self, 'monomerSet', FMonomerSetList);
  if (child_name = 'repeat') Then
    list.addAll(self, 'repeat', FRepeat_List);
end;

procedure TFhirSubstancePolymer.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'identifier', 'Identifier', false, TFhirIdentifier, FIdentifier.Link));
  oList.add(TFHIRProperty.create(self, 'class', 'CodeableConcept', false, TFhirCodeableConcept, FClass_.Link));
  oList.add(TFHIRProperty.create(self, 'geometry', 'CodeableConcept', false, TFhirCodeableConcept, FGeometry.Link));
  oList.add(TFHIRProperty.create(self, 'copolymerConnectivity', 'CodeableConcept', true, TFhirCodeableConcept, FCopolymerConnectivityList.Link));
  oList.add(TFHIRProperty.create(self, 'modification', 'string', false, TFhirString, FModification.Link));
  oList.add(TFHIRProperty.create(self, 'monomerSet', 'BackboneElement', true, TFhirSubstancePolymerMonomerSet, FMonomerSetList.Link));
  oList.add(TFHIRProperty.create(self, 'repeat', 'BackboneElement', true, TFhirSubstancePolymerRepeat, FRepeat_List.Link));
end;

function TFhirSubstancePolymer.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'identifier') then
  begin
    Identifier := propValue as TFhirIdentifier;
    result := propValue;
  end
  else if (propName = 'class') then
  begin
    Class_ := propValue as TFhirCodeableConcept;
    result := propValue;
  end
  else if (propName = 'geometry') then
  begin
    Geometry := propValue as TFhirCodeableConcept;
    result := propValue;
  end
  else if (propName = 'copolymerConnectivity') then
  begin
    CopolymerConnectivityList.add(propValue as TFhirCodeableConcept);
    result := propValue;
  end
  else if (propName = 'modification') then
  begin
    ModificationElement := asString(propValue);
    result := propValue;
  end
  else if (propName = 'monomerSet') then
  begin
    MonomerSetList.add(propValue as TFhirSubstancePolymerMonomerSet);
    result := propValue;
  end
  else if (propName = 'repeat') then
  begin
    Repeat_List.add(propValue as TFhirSubstancePolymerRepeat);
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirSubstancePolymer.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'copolymerConnectivity') then CopolymerConnectivityList.insertItem(index, propValue as TFhirCodeableConcept)
  else if (propName = 'monomerSet') then MonomerSetList.insertItem(index, propValue as TFhirSubstancePolymerMonomerSet)
  else if (propName = 'repeat') then Repeat_List.insertItem(index, propValue as TFhirSubstancePolymerRepeat)
  else inherited;
end;

function TFhirSubstancePolymer.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'identifier') then result := TFhirIdentifier.create()
  else if (propName = 'class') then result := TFhirCodeableConcept.create()
  else if (propName = 'geometry') then result := TFhirCodeableConcept.create()
  else if (propName = 'copolymerConnectivity') then result := CopolymerConnectivityList.new()
  else if (propName = 'modification') then result := TFhirString.create()
  else if (propName = 'monomerSet') then result := MonomerSetList.new()
  else if (propName = 'repeat') then result := Repeat_List.new()
  else result := inherited createPropertyValue(propName);
end;

function TFhirSubstancePolymer.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'identifier') then result := 'Identifier'
  else if (propName = 'class') then result := 'CodeableConcept'
  else if (propName = 'geometry') then result := 'CodeableConcept'
  else if (propName = 'copolymerConnectivity') then result := 'CodeableConcept'
  else if (propName = 'modification') then result := 'string'
  else if (propName = 'monomerSet') then result := 'BackboneElement'
  else if (propName = 'repeat') then result := 'BackboneElement'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirSubstancePolymer.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'identifier') then IdentifierElement := nil
  else if (propName = 'class') then Class_Element := nil
  else if (propName = 'geometry') then GeometryElement := nil
  else if (propName = 'copolymerConnectivity') then deletePropertyValue('copolymerConnectivity', CopolymerConnectivityList, value)
  else if (propName = 'modification') then ModificationElement := nil
  else if (propName = 'monomerSet') then deletePropertyValue('monomerSet', MonomerSetList, value)
  else if (propName = 'repeat') then deletePropertyValue('repeat', Repeat_List, value)
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirSubstancePolymer.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'identifier') then IdentifierElement := new as TFhirIdentifier
  else if (propName = 'class') then Class_Element := new as TFhirCodeableConcept
  else if (propName = 'geometry') then GeometryElement := new as TFhirCodeableConcept
  else if (propName = 'copolymerConnectivity') then replacePropertyValue('copolymerConnectivity', CopolymerConnectivityList, existing, new)
  else if (propName = 'modification') then ModificationElement := asString(new)
  else if (propName = 'monomerSet') then replacePropertyValue('monomerSet', MonomerSetList, existing, new)
  else if (propName = 'repeat') then replacePropertyValue('repeat', Repeat_List, existing, new)
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirSubstancePolymer.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'copolymerConnectivity') then CopolymerConnectivityList.move(source, destination)
  else if (propName = 'monomerSet') then MonomerSetList.move(source, destination)
  else if (propName = 'repeat') then Repeat_List.move(source, destination)
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirSubstancePolymer.fhirType : string;
begin
  result := 'SubstancePolymer';
end;

function TFhirSubstancePolymer.Link : TFhirSubstancePolymer;
begin
  result := TFhirSubstancePolymer(inherited Link);
end;

function TFhirSubstancePolymer.Clone : TFhirSubstancePolymer;
begin
  result := TFhirSubstancePolymer(inherited Clone);
end;

function TFhirSubstancePolymer.equals(other : TObject) : boolean; 
var
  o : TFhirSubstancePolymer;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirSubstancePolymer)) then
    result := false
  else
  begin
    o := TFhirSubstancePolymer(other);
    result := compareDeep(identifierElement, o.identifierElement, true) and compareDeep(class_Element, o.class_Element, true) and 
      compareDeep(geometryElement, o.geometryElement, true) and compareDeep(copolymerConnectivityList, o.copolymerConnectivityList, true) and 
      compareDeep(modificationElement, o.modificationElement, true) and compareDeep(monomerSetList, o.monomerSetList, true) and 
      compareDeep(repeat_List, o.repeat_List, true);
  end;
end;

function TFhirSubstancePolymer.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FIdentifier) and isEmptyProp(FClass_) and isEmptyProp(FGeometry) and isEmptyProp(FcopolymerConnectivityList) and isEmptyProp(FModification) and isEmptyProp(FmonomerSetList) and isEmptyProp(Frepeat_List);
end;

procedure TFhirSubstancePolymer.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('identifier');
  fields.add('class');
  fields.add('geometry');
  fields.add('copolymerConnectivity');
  fields.add('modification');
  fields.add('monomerSet');
  fields.add('repeat');
end;

function TFhirSubstancePolymer.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
  inc(result, FCopolymerConnectivityList.sizeInBytes(magic));
  inc(result, FMonomerSetList.sizeInBytes(magic));
  inc(result, FRepeat_List.sizeInBytes(magic));
end;

procedure TFhirSubstancePolymer.SetIdentifier(value : TFhirIdentifier);
begin
  FIdentifier.free;
  FIdentifier := value;
end;

procedure TFhirSubstancePolymer.SetClass_(value : TFhirCodeableConcept);
begin
  FClass_.free;
  FClass_ := value;
end;

procedure TFhirSubstancePolymer.SetGeometry(value : TFhirCodeableConcept);
begin
  FGeometry.free;
  FGeometry := value;
end;

function TFhirSubstancePolymer.GetCopolymerConnectivityList : TFhirCodeableConceptList;
begin
  if FCopolymerConnectivityList = nil then
    FCopolymerConnectivityList := TFhirCodeableConceptList.Create;
  result := FCopolymerConnectivityList;
end;

function TFhirSubstancePolymer.GetHasCopolymerConnectivityList : boolean;
begin
  result := (FCopolymerConnectivityList <> nil) and (FCopolymerConnectivityList.count > 0);
end;

procedure TFhirSubstancePolymer.SetModification(value : TFhirString);
begin
  FModification.free;
  FModification := value;
end;

function TFhirSubstancePolymer.GetModificationST : String;
begin
  if FModification = nil then
    result := ''
  else
    result := FModification.value;
end;

procedure TFhirSubstancePolymer.SetModificationST(value : String);
begin
  if value <> '' then
  begin
    if FModification = nil then
      FModification := TFhirString.create;
    FModification.value := value
  end
  else if FModification <> nil then
    FModification.value := '';
end;

function TFhirSubstancePolymer.GetMonomerSetList : TFhirSubstancePolymerMonomerSetList;
begin
  if FMonomerSetList = nil then
    FMonomerSetList := TFhirSubstancePolymerMonomerSetList.Create;
  result := FMonomerSetList;
end;

function TFhirSubstancePolymer.GetHasMonomerSetList : boolean;
begin
  result := (FMonomerSetList <> nil) and (FMonomerSetList.count > 0);
end;

function TFhirSubstancePolymer.GetRepeat_List : TFhirSubstancePolymerRepeatList;
begin
  if FRepeat_List = nil then
    FRepeat_List := TFhirSubstancePolymerRepeatList.Create;
  result := FRepeat_List;
end;

function TFhirSubstancePolymer.GetHasRepeat_List : boolean;
begin
  result := (FRepeat_List <> nil) and (FRepeat_List.count > 0);
end;

{ TFhirSubstancePolymerListEnumerator }

constructor TFhirSubstancePolymerListEnumerator.Create(list : TFhirSubstancePolymerList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirSubstancePolymerListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirSubstancePolymerListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirSubstancePolymerListEnumerator.GetCurrent : TFhirSubstancePolymer;
begin
  Result := FList[FIndex];
end;

function TFhirSubstancePolymerListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirSubstancePolymerList }

function TFhirSubstancePolymerList.AddItem(value: TFhirSubstancePolymer): TFhirSubstancePolymer;
begin
  assert(value.ClassName = 'TFhirSubstancePolymer', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirSubstancePolymer');
  add(value);
  result := value;
end;

function TFhirSubstancePolymerList.Append: TFhirSubstancePolymer;
begin
  result := TFhirSubstancePolymer.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirSubstancePolymerList.ClearItems;
begin
  Clear;
end;

function TFhirSubstancePolymerList.GetEnumerator : TFhirSubstancePolymerListEnumerator;
begin
  result := TFhirSubstancePolymerListEnumerator.Create(self.link);
end;

function TFhirSubstancePolymerList.Clone: TFhirSubstancePolymerList;
begin
  result := TFhirSubstancePolymerList(inherited Clone);
end;

function TFhirSubstancePolymerList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirSubstancePolymerList.GetItemN(index: Integer): TFhirSubstancePolymer;
begin
  result := TFhirSubstancePolymer(ObjectByIndex[index]);
end;

function TFhirSubstancePolymerList.ItemClass: TFslObjectClass;
begin
  result := TFhirSubstancePolymer;
end;
function TFhirSubstancePolymerList.IndexOf(value: TFhirSubstancePolymer): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirSubstancePolymerList.Insert(index: Integer): TFhirSubstancePolymer;
begin
  result := TFhirSubstancePolymer.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirSubstancePolymerList.InsertItem(index: Integer; value: TFhirSubstancePolymer);
begin
  assert(value is TFhirSubstancePolymer);
  Inherited Insert(index, value);
end;

function TFhirSubstancePolymerList.Item(index: Integer): TFhirSubstancePolymer;
begin
  result := TFhirSubstancePolymer(ObjectByIndex[index]);
end;

function TFhirSubstancePolymerList.Link: TFhirSubstancePolymerList;
begin
  result := TFhirSubstancePolymerList(inherited Link);
end;

procedure TFhirSubstancePolymerList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirSubstancePolymerList.SetItemByIndex(index: Integer; value: TFhirSubstancePolymer);
begin
  assert(value is TFhirSubstancePolymer);
  FhirSubstancePolymers[index] := value;
end;

procedure TFhirSubstancePolymerList.SetItemN(index: Integer; value: TFhirSubstancePolymer);
begin
  assert(value is TFhirSubstancePolymer);
  ObjectByIndex[index] := value;
end;

{$ENDIF FHIR_SUBSTANCEPOLYMER}
{$IFDEF FHIR_SUBSTANCEPROTEIN}
{ TFhirSubstanceProteinSubunit }

constructor TFhirSubstanceProteinSubunit.Create;
begin
  inherited;
end;

destructor TFhirSubstanceProteinSubunit.Destroy;
begin
  FSubunit.free;
  FSequence.free;
  FLength.free;
  FSequenceAttachment.free;
  FNTerminalModificationId.free;
  FNTerminalModification.free;
  FCTerminalModificationId.free;
  FCTerminalModification.free;
  inherited;
end;

procedure TFhirSubstanceProteinSubunit.Assign(oSource : TFslObject);
begin
  inherited;
  subunitElement := TFhirSubstanceProteinSubunit(oSource).subunitElement.Clone;
  sequenceElement := TFhirSubstanceProteinSubunit(oSource).sequenceElement.Clone;
  lengthElement := TFhirSubstanceProteinSubunit(oSource).lengthElement.Clone;
  sequenceAttachment := TFhirSubstanceProteinSubunit(oSource).sequenceAttachment.Clone;
  nTerminalModificationId := TFhirSubstanceProteinSubunit(oSource).nTerminalModificationId.Clone;
  nTerminalModificationElement := TFhirSubstanceProteinSubunit(oSource).nTerminalModificationElement.Clone;
  cTerminalModificationId := TFhirSubstanceProteinSubunit(oSource).cTerminalModificationId.Clone;
  cTerminalModificationElement := TFhirSubstanceProteinSubunit(oSource).cTerminalModificationElement.Clone;
end;

procedure TFhirSubstanceProteinSubunit.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'subunit') Then
     list.add(self.link, 'subunit', FSubunit.Link);
  if (child_name = 'sequence') Then
     list.add(self.link, 'sequence', FSequence.Link);
  if (child_name = 'length') Then
     list.add(self.link, 'length', FLength.Link);
  if (child_name = 'sequenceAttachment') Then
     list.add(self.link, 'sequenceAttachment', FSequenceAttachment.Link);
  if (child_name = 'nTerminalModificationId') Then
     list.add(self.link, 'nTerminalModificationId', FNTerminalModificationId.Link);
  if (child_name = 'nTerminalModification') Then
     list.add(self.link, 'nTerminalModification', FNTerminalModification.Link);
  if (child_name = 'cTerminalModificationId') Then
     list.add(self.link, 'cTerminalModificationId', FCTerminalModificationId.Link);
  if (child_name = 'cTerminalModification') Then
     list.add(self.link, 'cTerminalModification', FCTerminalModification.Link);
end;

procedure TFhirSubstanceProteinSubunit.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'subunit', 'integer', false, TFhirInteger, FSubunit.Link));
  oList.add(TFHIRProperty.create(self, 'sequence', 'string', false, TFhirString, FSequence.Link));
  oList.add(TFHIRProperty.create(self, 'length', 'integer', false, TFhirInteger, FLength.Link));
  oList.add(TFHIRProperty.create(self, 'sequenceAttachment', 'Attachment', false, TFhirAttachment, FSequenceAttachment.Link));
  oList.add(TFHIRProperty.create(self, 'nTerminalModificationId', 'Identifier', false, TFhirIdentifier, FNTerminalModificationId.Link));
  oList.add(TFHIRProperty.create(self, 'nTerminalModification', 'string', false, TFhirString, FNTerminalModification.Link));
  oList.add(TFHIRProperty.create(self, 'cTerminalModificationId', 'Identifier', false, TFhirIdentifier, FCTerminalModificationId.Link));
  oList.add(TFHIRProperty.create(self, 'cTerminalModification', 'string', false, TFhirString, FCTerminalModification.Link));
end;

function TFhirSubstanceProteinSubunit.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'subunit') then
  begin
    SubunitElement := asInteger(propValue);
    result := propValue;
  end
  else if (propName = 'sequence') then
  begin
    SequenceElement := asString(propValue);
    result := propValue;
  end
  else if (propName = 'length') then
  begin
    LengthElement := asInteger(propValue);
    result := propValue;
  end
  else if (propName = 'sequenceAttachment') then
  begin
    SequenceAttachment := propValue as TFhirAttachment;
    result := propValue;
  end
  else if (propName = 'nTerminalModificationId') then
  begin
    NTerminalModificationId := propValue as TFhirIdentifier;
    result := propValue;
  end
  else if (propName = 'nTerminalModification') then
  begin
    NTerminalModificationElement := asString(propValue);
    result := propValue;
  end
  else if (propName = 'cTerminalModificationId') then
  begin
    CTerminalModificationId := propValue as TFhirIdentifier;
    result := propValue;
  end
  else if (propName = 'cTerminalModification') then
  begin
    CTerminalModificationElement := asString(propValue);
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirSubstanceProteinSubunit.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirSubstanceProteinSubunit.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'subunit') then result := TFhirInteger.create()
  else if (propName = 'sequence') then result := TFhirString.create()
  else if (propName = 'length') then result := TFhirInteger.create()
  else if (propName = 'sequenceAttachment') then result := TFhirAttachment.create()
  else if (propName = 'nTerminalModificationId') then result := TFhirIdentifier.create()
  else if (propName = 'nTerminalModification') then result := TFhirString.create()
  else if (propName = 'cTerminalModificationId') then result := TFhirIdentifier.create()
  else if (propName = 'cTerminalModification') then result := TFhirString.create()
  else result := inherited createPropertyValue(propName);
end;

function TFhirSubstanceProteinSubunit.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'subunit') then result := 'integer'
  else if (propName = 'sequence') then result := 'string'
  else if (propName = 'length') then result := 'integer'
  else if (propName = 'sequenceAttachment') then result := 'Attachment'
  else if (propName = 'nTerminalModificationId') then result := 'Identifier'
  else if (propName = 'nTerminalModification') then result := 'string'
  else if (propName = 'cTerminalModificationId') then result := 'Identifier'
  else if (propName = 'cTerminalModification') then result := 'string'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirSubstanceProteinSubunit.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'subunit') then SubunitElement := nil
  else if (propName = 'sequence') then SequenceElement := nil
  else if (propName = 'length') then LengthElement := nil
  else if (propName = 'sequenceAttachment') then SequenceAttachmentElement := nil
  else if (propName = 'nTerminalModificationId') then NTerminalModificationIdElement := nil
  else if (propName = 'nTerminalModification') then NTerminalModificationElement := nil
  else if (propName = 'cTerminalModificationId') then CTerminalModificationIdElement := nil
  else if (propName = 'cTerminalModification') then CTerminalModificationElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirSubstanceProteinSubunit.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'subunit') then SubunitElement := asInteger(new)
  else if (propName = 'sequence') then SequenceElement := asString(new)
  else if (propName = 'length') then LengthElement := asInteger(new)
  else if (propName = 'sequenceAttachment') then SequenceAttachmentElement := new as TFhirAttachment
  else if (propName = 'nTerminalModificationId') then NTerminalModificationIdElement := new as TFhirIdentifier
  else if (propName = 'nTerminalModification') then NTerminalModificationElement := asString(new)
  else if (propName = 'cTerminalModificationId') then CTerminalModificationIdElement := new as TFhirIdentifier
  else if (propName = 'cTerminalModification') then CTerminalModificationElement := asString(new)
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirSubstanceProteinSubunit.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirSubstanceProteinSubunit.fhirType : string;
begin
  result := 'SubstanceProtein.subunit';
end;

function TFhirSubstanceProteinSubunit.Link : TFhirSubstanceProteinSubunit;
begin
  result := TFhirSubstanceProteinSubunit(inherited Link);
end;

function TFhirSubstanceProteinSubunit.Clone : TFhirSubstanceProteinSubunit;
begin
  result := TFhirSubstanceProteinSubunit(inherited Clone);
end;

function TFhirSubstanceProteinSubunit.equals(other : TObject) : boolean; 
var
  o : TFhirSubstanceProteinSubunit;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirSubstanceProteinSubunit)) then
    result := false
  else
  begin
    o := TFhirSubstanceProteinSubunit(other);
    result := compareDeep(subunitElement, o.subunitElement, true) and compareDeep(sequenceElement, o.sequenceElement, true) and 
      compareDeep(lengthElement, o.lengthElement, true) and compareDeep(sequenceAttachmentElement, o.sequenceAttachmentElement, true) and 
      compareDeep(nTerminalModificationIdElement, o.nTerminalModificationIdElement, true) and 
      compareDeep(nTerminalModificationElement, o.nTerminalModificationElement, true) and 
      compareDeep(cTerminalModificationIdElement, o.cTerminalModificationIdElement, true) and 
      compareDeep(cTerminalModificationElement, o.cTerminalModificationElement, true);
  end;
end;

function TFhirSubstanceProteinSubunit.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FSubunit) and isEmptyProp(FSequence) and isEmptyProp(FLength) and isEmptyProp(FSequenceAttachment) and isEmptyProp(FNTerminalModificationId) and isEmptyProp(FNTerminalModification) and isEmptyProp(FCTerminalModificationId) and isEmptyProp(FCTerminalModification);
end;

procedure TFhirSubstanceProteinSubunit.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('subunit');
  fields.add('sequence');
  fields.add('length');
  fields.add('sequenceAttachment');
  fields.add('nTerminalModificationId');
  fields.add('nTerminalModification');
  fields.add('cTerminalModificationId');
  fields.add('cTerminalModification');
end;

function TFhirSubstanceProteinSubunit.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
end;

procedure TFhirSubstanceProteinSubunit.SetSubunit(value : TFhirInteger);
begin
  FSubunit.free;
  FSubunit := value;
end;

function TFhirSubstanceProteinSubunit.GetSubunitST : String;
begin
  if FSubunit = nil then
    result := ''
  else
    result := FSubunit.value;
end;

procedure TFhirSubstanceProteinSubunit.SetSubunitST(value : String);
begin
  if value <> '' then
  begin
    if FSubunit = nil then
      FSubunit := TFhirInteger.create;
    FSubunit.value := value
  end
  else if FSubunit <> nil then
    FSubunit.value := '';
end;

procedure TFhirSubstanceProteinSubunit.SetSequence(value : TFhirString);
begin
  FSequence.free;
  FSequence := value;
end;

function TFhirSubstanceProteinSubunit.GetSequenceST : String;
begin
  if FSequence = nil then
    result := ''
  else
    result := FSequence.value;
end;

procedure TFhirSubstanceProteinSubunit.SetSequenceST(value : String);
begin
  if value <> '' then
  begin
    if FSequence = nil then
      FSequence := TFhirString.create;
    FSequence.value := value
  end
  else if FSequence <> nil then
    FSequence.value := '';
end;

procedure TFhirSubstanceProteinSubunit.SetLength(value : TFhirInteger);
begin
  FLength.free;
  FLength := value;
end;

function TFhirSubstanceProteinSubunit.GetLengthST : String;
begin
  if FLength = nil then
    result := ''
  else
    result := FLength.value;
end;

procedure TFhirSubstanceProteinSubunit.SetLengthST(value : String);
begin
  if value <> '' then
  begin
    if FLength = nil then
      FLength := TFhirInteger.create;
    FLength.value := value
  end
  else if FLength <> nil then
    FLength.value := '';
end;

procedure TFhirSubstanceProteinSubunit.SetSequenceAttachment(value : TFhirAttachment);
begin
  FSequenceAttachment.free;
  FSequenceAttachment := value;
end;

procedure TFhirSubstanceProteinSubunit.SetNTerminalModificationId(value : TFhirIdentifier);
begin
  FNTerminalModificationId.free;
  FNTerminalModificationId := value;
end;

procedure TFhirSubstanceProteinSubunit.SetNTerminalModification(value : TFhirString);
begin
  FNTerminalModification.free;
  FNTerminalModification := value;
end;

function TFhirSubstanceProteinSubunit.GetNTerminalModificationST : String;
begin
  if FNTerminalModification = nil then
    result := ''
  else
    result := FNTerminalModification.value;
end;

procedure TFhirSubstanceProteinSubunit.SetNTerminalModificationST(value : String);
begin
  if value <> '' then
  begin
    if FNTerminalModification = nil then
      FNTerminalModification := TFhirString.create;
    FNTerminalModification.value := value
  end
  else if FNTerminalModification <> nil then
    FNTerminalModification.value := '';
end;

procedure TFhirSubstanceProteinSubunit.SetCTerminalModificationId(value : TFhirIdentifier);
begin
  FCTerminalModificationId.free;
  FCTerminalModificationId := value;
end;

procedure TFhirSubstanceProteinSubunit.SetCTerminalModification(value : TFhirString);
begin
  FCTerminalModification.free;
  FCTerminalModification := value;
end;

function TFhirSubstanceProteinSubunit.GetCTerminalModificationST : String;
begin
  if FCTerminalModification = nil then
    result := ''
  else
    result := FCTerminalModification.value;
end;

procedure TFhirSubstanceProteinSubunit.SetCTerminalModificationST(value : String);
begin
  if value <> '' then
  begin
    if FCTerminalModification = nil then
      FCTerminalModification := TFhirString.create;
    FCTerminalModification.value := value
  end
  else if FCTerminalModification <> nil then
    FCTerminalModification.value := '';
end;

{ TFhirSubstanceProteinSubunitListEnumerator }

constructor TFhirSubstanceProteinSubunitListEnumerator.Create(list : TFhirSubstanceProteinSubunitList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirSubstanceProteinSubunitListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirSubstanceProteinSubunitListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirSubstanceProteinSubunitListEnumerator.GetCurrent : TFhirSubstanceProteinSubunit;
begin
  Result := FList[FIndex];
end;

function TFhirSubstanceProteinSubunitListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirSubstanceProteinSubunitList }

function TFhirSubstanceProteinSubunitList.AddItem(value: TFhirSubstanceProteinSubunit): TFhirSubstanceProteinSubunit;
begin
  assert(value.ClassName = 'TFhirSubstanceProteinSubunit', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirSubstanceProteinSubunit');
  add(value);
  result := value;
end;

function TFhirSubstanceProteinSubunitList.Append: TFhirSubstanceProteinSubunit;
begin
  result := TFhirSubstanceProteinSubunit.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirSubstanceProteinSubunitList.ClearItems;
begin
  Clear;
end;

function TFhirSubstanceProteinSubunitList.GetEnumerator : TFhirSubstanceProteinSubunitListEnumerator;
begin
  result := TFhirSubstanceProteinSubunitListEnumerator.Create(self.link);
end;

function TFhirSubstanceProteinSubunitList.Clone: TFhirSubstanceProteinSubunitList;
begin
  result := TFhirSubstanceProteinSubunitList(inherited Clone);
end;

function TFhirSubstanceProteinSubunitList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirSubstanceProteinSubunitList.GetItemN(index: Integer): TFhirSubstanceProteinSubunit;
begin
  result := TFhirSubstanceProteinSubunit(ObjectByIndex[index]);
end;

function TFhirSubstanceProteinSubunitList.ItemClass: TFslObjectClass;
begin
  result := TFhirSubstanceProteinSubunit;
end;
function TFhirSubstanceProteinSubunitList.IndexOf(value: TFhirSubstanceProteinSubunit): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirSubstanceProteinSubunitList.Insert(index: Integer): TFhirSubstanceProteinSubunit;
begin
  result := TFhirSubstanceProteinSubunit.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirSubstanceProteinSubunitList.InsertItem(index: Integer; value: TFhirSubstanceProteinSubunit);
begin
  assert(value is TFhirSubstanceProteinSubunit);
  Inherited Insert(index, value);
end;

function TFhirSubstanceProteinSubunitList.Item(index: Integer): TFhirSubstanceProteinSubunit;
begin
  result := TFhirSubstanceProteinSubunit(ObjectByIndex[index]);
end;

function TFhirSubstanceProteinSubunitList.Link: TFhirSubstanceProteinSubunitList;
begin
  result := TFhirSubstanceProteinSubunitList(inherited Link);
end;

procedure TFhirSubstanceProteinSubunitList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirSubstanceProteinSubunitList.SetItemByIndex(index: Integer; value: TFhirSubstanceProteinSubunit);
begin
  assert(value is TFhirSubstanceProteinSubunit);
  FhirSubstanceProteinSubunits[index] := value;
end;

procedure TFhirSubstanceProteinSubunitList.SetItemN(index: Integer; value: TFhirSubstanceProteinSubunit);
begin
  assert(value is TFhirSubstanceProteinSubunit);
  ObjectByIndex[index] := value;
end;

{ TFhirSubstanceProtein }

constructor TFhirSubstanceProtein.Create;
begin
  inherited;
end;

destructor TFhirSubstanceProtein.Destroy;
begin
  FSequenceType.free;
  FNumberOfSubunits.free;
  FDisulfideLinkageList.Free;
  FSubunitList.Free;
  inherited;
end;

procedure TFhirSubstanceProtein.Assign(oSource : TFslObject);
begin
  inherited;
  sequenceType := TFhirSubstanceProtein(oSource).sequenceType.Clone;
  numberOfSubunitsElement := TFhirSubstanceProtein(oSource).numberOfSubunitsElement.Clone;
  if (TFhirSubstanceProtein(oSource).FDisulfideLinkageList = nil) then
  begin
    FDisulfideLinkageList.free;
    FDisulfideLinkageList := nil;
  end
  else
  begin
    if FDisulfideLinkageList = nil then
      FDisulfideLinkageList := TFhirStringList.Create;
    FDisulfideLinkageList.Assign(TFhirSubstanceProtein(oSource).FDisulfideLinkageList);
  end;
  if (TFhirSubstanceProtein(oSource).FSubunitList = nil) then
  begin
    FSubunitList.free;
    FSubunitList := nil;
  end
  else
  begin
    if FSubunitList = nil then
      FSubunitList := TFhirSubstanceProteinSubunitList.Create;
    FSubunitList.Assign(TFhirSubstanceProtein(oSource).FSubunitList);
  end;
end;

function TFhirSubstanceProtein.GetResourceType : TFhirResourceType;
begin
  result := frtSubstanceProtein;
end;

procedure TFhirSubstanceProtein.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'sequenceType') Then
     list.add(self.link, 'sequenceType', FSequenceType.Link);
  if (child_name = 'numberOfSubunits') Then
     list.add(self.link, 'numberOfSubunits', FNumberOfSubunits.Link);
  if (child_name = 'disulfideLinkage') Then
    list.addAll(self, 'disulfideLinkage', FDisulfideLinkageList);
  if (child_name = 'subunit') Then
    list.addAll(self, 'subunit', FSubunitList);
end;

procedure TFhirSubstanceProtein.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'sequenceType', 'CodeableConcept', false, TFhirCodeableConcept, FSequenceType.Link));
  oList.add(TFHIRProperty.create(self, 'numberOfSubunits', 'integer', false, TFhirInteger, FNumberOfSubunits.Link));
  oList.add(TFHIRProperty.create(self, 'disulfideLinkage', 'string', true, TFhirString, FDisulfideLinkageList.Link));
  oList.add(TFHIRProperty.create(self, 'subunit', 'BackboneElement', true, TFhirSubstanceProteinSubunit, FSubunitList.Link));
end;

function TFhirSubstanceProtein.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'sequenceType') then
  begin
    SequenceType := propValue as TFhirCodeableConcept;
    result := propValue;
  end
  else if (propName = 'numberOfSubunits') then
  begin
    NumberOfSubunitsElement := asInteger(propValue);
    result := propValue;
  end
  else if (propName = 'disulfideLinkage') then
  begin
    DisulfideLinkageList.add(asString(propValue)){2};     result := propValue;

  end
  else if (propName = 'subunit') then
  begin
    SubunitList.add(propValue as TFhirSubstanceProteinSubunit);
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirSubstanceProtein.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'disulfideLinkage') then DisulfideLinkageList.insertItem(index, asString(propValue))
  else if (propName = 'subunit') then SubunitList.insertItem(index, propValue as TFhirSubstanceProteinSubunit)
  else inherited;
end;

function TFhirSubstanceProtein.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'sequenceType') then result := TFhirCodeableConcept.create()
  else if (propName = 'numberOfSubunits') then result := TFhirInteger.create()
  else if (propName = 'disulfideLinkage') then result := DisulfideLinkageList.new()
  else if (propName = 'subunit') then result := SubunitList.new()
  else result := inherited createPropertyValue(propName);
end;

function TFhirSubstanceProtein.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'sequenceType') then result := 'CodeableConcept'
  else if (propName = 'numberOfSubunits') then result := 'integer'
  else if (propName = 'disulfideLinkage') then result := 'string'
  else if (propName = 'subunit') then result := 'BackboneElement'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirSubstanceProtein.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'sequenceType') then SequenceTypeElement := nil
  else if (propName = 'numberOfSubunits') then NumberOfSubunitsElement := nil
  else if (propName = 'disulfideLinkage') then deletePropertyValue('disulfideLinkage', DisulfideLinkageList, value)
  else if (propName = 'subunit') then deletePropertyValue('subunit', SubunitList, value)
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirSubstanceProtein.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'sequenceType') then SequenceTypeElement := new as TFhirCodeableConcept
  else if (propName = 'numberOfSubunits') then NumberOfSubunitsElement := asInteger(new)
  else if (propName = 'disulfideLinkage') then replacePropertyValue('disulfideLinkage', DisulfideLinkageList, existing, new)
  else if (propName = 'subunit') then replacePropertyValue('subunit', SubunitList, existing, new)
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirSubstanceProtein.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'disulfideLinkage') then DisulfideLinkageList.move(source, destination)
  else if (propName = 'subunit') then SubunitList.move(source, destination)
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirSubstanceProtein.fhirType : string;
begin
  result := 'SubstanceProtein';
end;

function TFhirSubstanceProtein.Link : TFhirSubstanceProtein;
begin
  result := TFhirSubstanceProtein(inherited Link);
end;

function TFhirSubstanceProtein.Clone : TFhirSubstanceProtein;
begin
  result := TFhirSubstanceProtein(inherited Clone);
end;

function TFhirSubstanceProtein.equals(other : TObject) : boolean; 
var
  o : TFhirSubstanceProtein;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirSubstanceProtein)) then
    result := false
  else
  begin
    o := TFhirSubstanceProtein(other);
    result := compareDeep(sequenceTypeElement, o.sequenceTypeElement, true) and 
      compareDeep(numberOfSubunitsElement, o.numberOfSubunitsElement, true) and compareDeep(disulfideLinkageList, o.disulfideLinkageList, true) and 
      compareDeep(subunitList, o.subunitList, true);
  end;
end;

function TFhirSubstanceProtein.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FSequenceType) and isEmptyProp(FNumberOfSubunits) and isEmptyProp(FdisulfideLinkageList) and isEmptyProp(FsubunitList);
end;

procedure TFhirSubstanceProtein.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('sequenceType');
  fields.add('numberOfSubunits');
  fields.add('disulfideLinkage');
  fields.add('subunit');
end;

function TFhirSubstanceProtein.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
  inc(result, FDisulfideLinkageList.sizeInBytes(magic));
  inc(result, FSubunitList.sizeInBytes(magic));
end;

procedure TFhirSubstanceProtein.SetSequenceType(value : TFhirCodeableConcept);
begin
  FSequenceType.free;
  FSequenceType := value;
end;

procedure TFhirSubstanceProtein.SetNumberOfSubunits(value : TFhirInteger);
begin
  FNumberOfSubunits.free;
  FNumberOfSubunits := value;
end;

function TFhirSubstanceProtein.GetNumberOfSubunitsST : String;
begin
  if FNumberOfSubunits = nil then
    result := ''
  else
    result := FNumberOfSubunits.value;
end;

procedure TFhirSubstanceProtein.SetNumberOfSubunitsST(value : String);
begin
  if value <> '' then
  begin
    if FNumberOfSubunits = nil then
      FNumberOfSubunits := TFhirInteger.create;
    FNumberOfSubunits.value := value
  end
  else if FNumberOfSubunits <> nil then
    FNumberOfSubunits.value := '';
end;

function TFhirSubstanceProtein.GetDisulfideLinkageList : TFhirStringList;
begin
  if FDisulfideLinkageList = nil then
    FDisulfideLinkageList := TFhirStringList.Create;
  result := FDisulfideLinkageList;
end;

function TFhirSubstanceProtein.GetHasDisulfideLinkageList : boolean;
begin
  result := (FDisulfideLinkageList <> nil) and (FDisulfideLinkageList.count > 0);
end;

function TFhirSubstanceProtein.GetSubunitList : TFhirSubstanceProteinSubunitList;
begin
  if FSubunitList = nil then
    FSubunitList := TFhirSubstanceProteinSubunitList.Create;
  result := FSubunitList;
end;

function TFhirSubstanceProtein.GetHasSubunitList : boolean;
begin
  result := (FSubunitList <> nil) and (FSubunitList.count > 0);
end;

{ TFhirSubstanceProteinListEnumerator }

constructor TFhirSubstanceProteinListEnumerator.Create(list : TFhirSubstanceProteinList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirSubstanceProteinListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirSubstanceProteinListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirSubstanceProteinListEnumerator.GetCurrent : TFhirSubstanceProtein;
begin
  Result := FList[FIndex];
end;

function TFhirSubstanceProteinListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirSubstanceProteinList }

function TFhirSubstanceProteinList.AddItem(value: TFhirSubstanceProtein): TFhirSubstanceProtein;
begin
  assert(value.ClassName = 'TFhirSubstanceProtein', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirSubstanceProtein');
  add(value);
  result := value;
end;

function TFhirSubstanceProteinList.Append: TFhirSubstanceProtein;
begin
  result := TFhirSubstanceProtein.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirSubstanceProteinList.ClearItems;
begin
  Clear;
end;

function TFhirSubstanceProteinList.GetEnumerator : TFhirSubstanceProteinListEnumerator;
begin
  result := TFhirSubstanceProteinListEnumerator.Create(self.link);
end;

function TFhirSubstanceProteinList.Clone: TFhirSubstanceProteinList;
begin
  result := TFhirSubstanceProteinList(inherited Clone);
end;

function TFhirSubstanceProteinList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirSubstanceProteinList.GetItemN(index: Integer): TFhirSubstanceProtein;
begin
  result := TFhirSubstanceProtein(ObjectByIndex[index]);
end;

function TFhirSubstanceProteinList.ItemClass: TFslObjectClass;
begin
  result := TFhirSubstanceProtein;
end;
function TFhirSubstanceProteinList.IndexOf(value: TFhirSubstanceProtein): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirSubstanceProteinList.Insert(index: Integer): TFhirSubstanceProtein;
begin
  result := TFhirSubstanceProtein.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirSubstanceProteinList.InsertItem(index: Integer; value: TFhirSubstanceProtein);
begin
  assert(value is TFhirSubstanceProtein);
  Inherited Insert(index, value);
end;

function TFhirSubstanceProteinList.Item(index: Integer): TFhirSubstanceProtein;
begin
  result := TFhirSubstanceProtein(ObjectByIndex[index]);
end;

function TFhirSubstanceProteinList.Link: TFhirSubstanceProteinList;
begin
  result := TFhirSubstanceProteinList(inherited Link);
end;

procedure TFhirSubstanceProteinList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirSubstanceProteinList.SetItemByIndex(index: Integer; value: TFhirSubstanceProtein);
begin
  assert(value is TFhirSubstanceProtein);
  FhirSubstanceProteins[index] := value;
end;

procedure TFhirSubstanceProteinList.SetItemN(index: Integer; value: TFhirSubstanceProtein);
begin
  assert(value is TFhirSubstanceProtein);
  ObjectByIndex[index] := value;
end;

{$ENDIF FHIR_SUBSTANCEPROTEIN}
{$IFDEF FHIR_SUBSTANCEREFERENCEINFORMATION}
{ TFhirSubstanceReferenceInformationGene }

constructor TFhirSubstanceReferenceInformationGene.Create;
begin
  inherited;
end;

destructor TFhirSubstanceReferenceInformationGene.Destroy;
begin
  FGeneSequenceOrigin.free;
  FGene.free;
  FSourceList.Free;
  inherited;
end;

procedure TFhirSubstanceReferenceInformationGene.Assign(oSource : TFslObject);
begin
  inherited;
  geneSequenceOrigin := TFhirSubstanceReferenceInformationGene(oSource).geneSequenceOrigin.Clone;
  gene := TFhirSubstanceReferenceInformationGene(oSource).gene.Clone;
  if (TFhirSubstanceReferenceInformationGene(oSource).FSourceList = nil) then
  begin
    FSourceList.free;
    FSourceList := nil;
  end
  else
  begin
    if FSourceList = nil then
      FSourceList := TFhirReferenceList.Create;
    FSourceList.Assign(TFhirSubstanceReferenceInformationGene(oSource).FSourceList);
  end;
end;

procedure TFhirSubstanceReferenceInformationGene.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'geneSequenceOrigin') Then
     list.add(self.link, 'geneSequenceOrigin', FGeneSequenceOrigin.Link);
  if (child_name = 'gene') Then
     list.add(self.link, 'gene', FGene.Link);
  if (child_name = 'source') Then
    list.addAll(self, 'source', FSourceList);
end;

procedure TFhirSubstanceReferenceInformationGene.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'geneSequenceOrigin', 'CodeableConcept', false, TFhirCodeableConcept, FGeneSequenceOrigin.Link));
  oList.add(TFHIRProperty.create(self, 'gene', 'CodeableConcept', false, TFhirCodeableConcept, FGene.Link));
  oList.add(TFHIRProperty.create(self, 'source', 'Reference', true, TFhirReference, FSourceList.Link));
end;

function TFhirSubstanceReferenceInformationGene.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'geneSequenceOrigin') then
  begin
    GeneSequenceOrigin := propValue as TFhirCodeableConcept;
    result := propValue;
  end
  else if (propName = 'gene') then
  begin
    Gene := propValue as TFhirCodeableConcept;
    result := propValue;
  end
  else if (propName = 'source') then
  begin
    SourceList.add(propValue as TFhirReference);
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirSubstanceReferenceInformationGene.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'source') then SourceList.insertItem(index, propValue as TFhirReference)
  else inherited;
end;

function TFhirSubstanceReferenceInformationGene.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'geneSequenceOrigin') then result := TFhirCodeableConcept.create()
  else if (propName = 'gene') then result := TFhirCodeableConcept.create()
  else if (propName = 'source') then result := SourceList.new()
  else result := inherited createPropertyValue(propName);
end;

function TFhirSubstanceReferenceInformationGene.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'geneSequenceOrigin') then result := 'CodeableConcept'
  else if (propName = 'gene') then result := 'CodeableConcept'
  else if (propName = 'source') then result := 'Reference'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirSubstanceReferenceInformationGene.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'geneSequenceOrigin') then GeneSequenceOriginElement := nil
  else if (propName = 'gene') then GeneElement := nil
  else if (propName = 'source') then deletePropertyValue('source', SourceList, value)
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirSubstanceReferenceInformationGene.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'geneSequenceOrigin') then GeneSequenceOriginElement := new as TFhirCodeableConcept
  else if (propName = 'gene') then GeneElement := new as TFhirCodeableConcept
  else if (propName = 'source') then replacePropertyValue('source', SourceList, existing, new)
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirSubstanceReferenceInformationGene.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'source') then SourceList.move(source, destination)
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirSubstanceReferenceInformationGene.fhirType : string;
begin
  result := 'SubstanceReferenceInformation.gene';
end;

function TFhirSubstanceReferenceInformationGene.Link : TFhirSubstanceReferenceInformationGene;
begin
  result := TFhirSubstanceReferenceInformationGene(inherited Link);
end;

function TFhirSubstanceReferenceInformationGene.Clone : TFhirSubstanceReferenceInformationGene;
begin
  result := TFhirSubstanceReferenceInformationGene(inherited Clone);
end;

function TFhirSubstanceReferenceInformationGene.equals(other : TObject) : boolean; 
var
  o : TFhirSubstanceReferenceInformationGene;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirSubstanceReferenceInformationGene)) then
    result := false
  else
  begin
    o := TFhirSubstanceReferenceInformationGene(other);
    result := compareDeep(geneSequenceOriginElement, o.geneSequenceOriginElement, true) and 
      compareDeep(geneElement, o.geneElement, true) and compareDeep(sourceList, o.sourceList, true);
  end;
end;

function TFhirSubstanceReferenceInformationGene.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FGeneSequenceOrigin) and isEmptyProp(FGene) and isEmptyProp(FsourceList);
end;

procedure TFhirSubstanceReferenceInformationGene.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('geneSequenceOrigin');
  fields.add('gene');
  fields.add('source');
end;

function TFhirSubstanceReferenceInformationGene.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
  inc(result, FSourceList.sizeInBytes(magic));
end;

procedure TFhirSubstanceReferenceInformationGene.SetGeneSequenceOrigin(value : TFhirCodeableConcept);
begin
  FGeneSequenceOrigin.free;
  FGeneSequenceOrigin := value;
end;

procedure TFhirSubstanceReferenceInformationGene.SetGene(value : TFhirCodeableConcept);
begin
  FGene.free;
  FGene := value;
end;

function TFhirSubstanceReferenceInformationGene.GetSourceList : TFhirReferenceList;
begin
  if FSourceList = nil then
    FSourceList := TFhirReferenceList.Create;
  result := FSourceList;
end;

function TFhirSubstanceReferenceInformationGene.GetHasSourceList : boolean;
begin
  result := (FSourceList <> nil) and (FSourceList.count > 0);
end;

{ TFhirSubstanceReferenceInformationGeneListEnumerator }

constructor TFhirSubstanceReferenceInformationGeneListEnumerator.Create(list : TFhirSubstanceReferenceInformationGeneList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirSubstanceReferenceInformationGeneListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirSubstanceReferenceInformationGeneListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirSubstanceReferenceInformationGeneListEnumerator.GetCurrent : TFhirSubstanceReferenceInformationGene;
begin
  Result := FList[FIndex];
end;

function TFhirSubstanceReferenceInformationGeneListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirSubstanceReferenceInformationGeneList }

function TFhirSubstanceReferenceInformationGeneList.AddItem(value: TFhirSubstanceReferenceInformationGene): TFhirSubstanceReferenceInformationGene;
begin
  assert(value.ClassName = 'TFhirSubstanceReferenceInformationGene', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirSubstanceReferenceInformationGene');
  add(value);
  result := value;
end;

function TFhirSubstanceReferenceInformationGeneList.Append: TFhirSubstanceReferenceInformationGene;
begin
  result := TFhirSubstanceReferenceInformationGene.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirSubstanceReferenceInformationGeneList.ClearItems;
begin
  Clear;
end;

function TFhirSubstanceReferenceInformationGeneList.GetEnumerator : TFhirSubstanceReferenceInformationGeneListEnumerator;
begin
  result := TFhirSubstanceReferenceInformationGeneListEnumerator.Create(self.link);
end;

function TFhirSubstanceReferenceInformationGeneList.Clone: TFhirSubstanceReferenceInformationGeneList;
begin
  result := TFhirSubstanceReferenceInformationGeneList(inherited Clone);
end;

function TFhirSubstanceReferenceInformationGeneList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirSubstanceReferenceInformationGeneList.GetItemN(index: Integer): TFhirSubstanceReferenceInformationGene;
begin
  result := TFhirSubstanceReferenceInformationGene(ObjectByIndex[index]);
end;

function TFhirSubstanceReferenceInformationGeneList.ItemClass: TFslObjectClass;
begin
  result := TFhirSubstanceReferenceInformationGene;
end;
function TFhirSubstanceReferenceInformationGeneList.IndexOf(value: TFhirSubstanceReferenceInformationGene): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirSubstanceReferenceInformationGeneList.Insert(index: Integer): TFhirSubstanceReferenceInformationGene;
begin
  result := TFhirSubstanceReferenceInformationGene.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirSubstanceReferenceInformationGeneList.InsertItem(index: Integer; value: TFhirSubstanceReferenceInformationGene);
begin
  assert(value is TFhirSubstanceReferenceInformationGene);
  Inherited Insert(index, value);
end;

function TFhirSubstanceReferenceInformationGeneList.Item(index: Integer): TFhirSubstanceReferenceInformationGene;
begin
  result := TFhirSubstanceReferenceInformationGene(ObjectByIndex[index]);
end;

function TFhirSubstanceReferenceInformationGeneList.Link: TFhirSubstanceReferenceInformationGeneList;
begin
  result := TFhirSubstanceReferenceInformationGeneList(inherited Link);
end;

procedure TFhirSubstanceReferenceInformationGeneList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirSubstanceReferenceInformationGeneList.SetItemByIndex(index: Integer; value: TFhirSubstanceReferenceInformationGene);
begin
  assert(value is TFhirSubstanceReferenceInformationGene);
  FhirSubstanceReferenceInformationGenes[index] := value;
end;

procedure TFhirSubstanceReferenceInformationGeneList.SetItemN(index: Integer; value: TFhirSubstanceReferenceInformationGene);
begin
  assert(value is TFhirSubstanceReferenceInformationGene);
  ObjectByIndex[index] := value;
end;

{ TFhirSubstanceReferenceInformationGeneElement }

constructor TFhirSubstanceReferenceInformationGeneElement.Create;
begin
  inherited;
end;

destructor TFhirSubstanceReferenceInformationGeneElement.Destroy;
begin
  FType_.free;
  FElement.free;
  FSourceList.Free;
  inherited;
end;

procedure TFhirSubstanceReferenceInformationGeneElement.Assign(oSource : TFslObject);
begin
  inherited;
  type_ := TFhirSubstanceReferenceInformationGeneElement(oSource).type_.Clone;
  element := TFhirSubstanceReferenceInformationGeneElement(oSource).element.Clone;
  if (TFhirSubstanceReferenceInformationGeneElement(oSource).FSourceList = nil) then
  begin
    FSourceList.free;
    FSourceList := nil;
  end
  else
  begin
    if FSourceList = nil then
      FSourceList := TFhirReferenceList.Create;
    FSourceList.Assign(TFhirSubstanceReferenceInformationGeneElement(oSource).FSourceList);
  end;
end;

procedure TFhirSubstanceReferenceInformationGeneElement.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'type') Then
     list.add(self.link, 'type', FType_.Link);
  if (child_name = 'element') Then
     list.add(self.link, 'element', FElement.Link);
  if (child_name = 'source') Then
    list.addAll(self, 'source', FSourceList);
end;

procedure TFhirSubstanceReferenceInformationGeneElement.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'type', 'CodeableConcept', false, TFhirCodeableConcept, FType_.Link));
  oList.add(TFHIRProperty.create(self, 'element', 'Identifier', false, TFhirIdentifier, FElement.Link));
  oList.add(TFHIRProperty.create(self, 'source', 'Reference', true, TFhirReference, FSourceList.Link));
end;

function TFhirSubstanceReferenceInformationGeneElement.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'type') then
  begin
    Type_ := propValue as TFhirCodeableConcept;
    result := propValue;
  end
  else if (propName = 'element') then
  begin
    Element := propValue as TFhirIdentifier;
    result := propValue;
  end
  else if (propName = 'source') then
  begin
    SourceList.add(propValue as TFhirReference);
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirSubstanceReferenceInformationGeneElement.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'source') then SourceList.insertItem(index, propValue as TFhirReference)
  else inherited;
end;

function TFhirSubstanceReferenceInformationGeneElement.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'type') then result := TFhirCodeableConcept.create()
  else if (propName = 'element') then result := TFhirIdentifier.create()
  else if (propName = 'source') then result := SourceList.new()
  else result := inherited createPropertyValue(propName);
end;

function TFhirSubstanceReferenceInformationGeneElement.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'type') then result := 'CodeableConcept'
  else if (propName = 'element') then result := 'Identifier'
  else if (propName = 'source') then result := 'Reference'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirSubstanceReferenceInformationGeneElement.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'type') then Type_Element := nil
  else if (propName = 'element') then ElementElement := nil
  else if (propName = 'source') then deletePropertyValue('source', SourceList, value)
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirSubstanceReferenceInformationGeneElement.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'type') then Type_Element := new as TFhirCodeableConcept
  else if (propName = 'element') then ElementElement := new as TFhirIdentifier
  else if (propName = 'source') then replacePropertyValue('source', SourceList, existing, new)
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirSubstanceReferenceInformationGeneElement.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'source') then SourceList.move(source, destination)
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirSubstanceReferenceInformationGeneElement.fhirType : string;
begin
  result := 'SubstanceReferenceInformation.geneElement';
end;

function TFhirSubstanceReferenceInformationGeneElement.Link : TFhirSubstanceReferenceInformationGeneElement;
begin
  result := TFhirSubstanceReferenceInformationGeneElement(inherited Link);
end;

function TFhirSubstanceReferenceInformationGeneElement.Clone : TFhirSubstanceReferenceInformationGeneElement;
begin
  result := TFhirSubstanceReferenceInformationGeneElement(inherited Clone);
end;

function TFhirSubstanceReferenceInformationGeneElement.equals(other : TObject) : boolean; 
var
  o : TFhirSubstanceReferenceInformationGeneElement;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirSubstanceReferenceInformationGeneElement)) then
    result := false
  else
  begin
    o := TFhirSubstanceReferenceInformationGeneElement(other);
    result := compareDeep(type_Element, o.type_Element, true) and compareDeep(elementElement, o.elementElement, true) and 
      compareDeep(sourceList, o.sourceList, true);
  end;
end;

function TFhirSubstanceReferenceInformationGeneElement.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FType_) and isEmptyProp(FElement) and isEmptyProp(FsourceList);
end;

procedure TFhirSubstanceReferenceInformationGeneElement.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('type');
  fields.add('element');
  fields.add('source');
end;

function TFhirSubstanceReferenceInformationGeneElement.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
  inc(result, FSourceList.sizeInBytes(magic));
end;

procedure TFhirSubstanceReferenceInformationGeneElement.SetType_(value : TFhirCodeableConcept);
begin
  FType_.free;
  FType_ := value;
end;

procedure TFhirSubstanceReferenceInformationGeneElement.SetElement(value : TFhirIdentifier);
begin
  FElement.free;
  FElement := value;
end;

function TFhirSubstanceReferenceInformationGeneElement.GetSourceList : TFhirReferenceList;
begin
  if FSourceList = nil then
    FSourceList := TFhirReferenceList.Create;
  result := FSourceList;
end;

function TFhirSubstanceReferenceInformationGeneElement.GetHasSourceList : boolean;
begin
  result := (FSourceList <> nil) and (FSourceList.count > 0);
end;

{ TFhirSubstanceReferenceInformationGeneElementListEnumerator }

constructor TFhirSubstanceReferenceInformationGeneElementListEnumerator.Create(list : TFhirSubstanceReferenceInformationGeneElementList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirSubstanceReferenceInformationGeneElementListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirSubstanceReferenceInformationGeneElementListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirSubstanceReferenceInformationGeneElementListEnumerator.GetCurrent : TFhirSubstanceReferenceInformationGeneElement;
begin
  Result := FList[FIndex];
end;

function TFhirSubstanceReferenceInformationGeneElementListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirSubstanceReferenceInformationGeneElementList }

function TFhirSubstanceReferenceInformationGeneElementList.AddItem(value: TFhirSubstanceReferenceInformationGeneElement): TFhirSubstanceReferenceInformationGeneElement;
begin
  assert(value.ClassName = 'TFhirSubstanceReferenceInformationGeneElement', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirSubstanceReferenceInformationGeneElement');
  add(value);
  result := value;
end;

function TFhirSubstanceReferenceInformationGeneElementList.Append: TFhirSubstanceReferenceInformationGeneElement;
begin
  result := TFhirSubstanceReferenceInformationGeneElement.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirSubstanceReferenceInformationGeneElementList.ClearItems;
begin
  Clear;
end;

function TFhirSubstanceReferenceInformationGeneElementList.GetEnumerator : TFhirSubstanceReferenceInformationGeneElementListEnumerator;
begin
  result := TFhirSubstanceReferenceInformationGeneElementListEnumerator.Create(self.link);
end;

function TFhirSubstanceReferenceInformationGeneElementList.Clone: TFhirSubstanceReferenceInformationGeneElementList;
begin
  result := TFhirSubstanceReferenceInformationGeneElementList(inherited Clone);
end;

function TFhirSubstanceReferenceInformationGeneElementList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirSubstanceReferenceInformationGeneElementList.GetItemN(index: Integer): TFhirSubstanceReferenceInformationGeneElement;
begin
  result := TFhirSubstanceReferenceInformationGeneElement(ObjectByIndex[index]);
end;

function TFhirSubstanceReferenceInformationGeneElementList.ItemClass: TFslObjectClass;
begin
  result := TFhirSubstanceReferenceInformationGeneElement;
end;
function TFhirSubstanceReferenceInformationGeneElementList.IndexOf(value: TFhirSubstanceReferenceInformationGeneElement): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirSubstanceReferenceInformationGeneElementList.Insert(index: Integer): TFhirSubstanceReferenceInformationGeneElement;
begin
  result := TFhirSubstanceReferenceInformationGeneElement.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirSubstanceReferenceInformationGeneElementList.InsertItem(index: Integer; value: TFhirSubstanceReferenceInformationGeneElement);
begin
  assert(value is TFhirSubstanceReferenceInformationGeneElement);
  Inherited Insert(index, value);
end;

function TFhirSubstanceReferenceInformationGeneElementList.Item(index: Integer): TFhirSubstanceReferenceInformationGeneElement;
begin
  result := TFhirSubstanceReferenceInformationGeneElement(ObjectByIndex[index]);
end;

function TFhirSubstanceReferenceInformationGeneElementList.Link: TFhirSubstanceReferenceInformationGeneElementList;
begin
  result := TFhirSubstanceReferenceInformationGeneElementList(inherited Link);
end;

procedure TFhirSubstanceReferenceInformationGeneElementList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirSubstanceReferenceInformationGeneElementList.SetItemByIndex(index: Integer; value: TFhirSubstanceReferenceInformationGeneElement);
begin
  assert(value is TFhirSubstanceReferenceInformationGeneElement);
  FhirSubstanceReferenceInformationGeneElements[index] := value;
end;

procedure TFhirSubstanceReferenceInformationGeneElementList.SetItemN(index: Integer; value: TFhirSubstanceReferenceInformationGeneElement);
begin
  assert(value is TFhirSubstanceReferenceInformationGeneElement);
  ObjectByIndex[index] := value;
end;

{ TFhirSubstanceReferenceInformationTarget }

constructor TFhirSubstanceReferenceInformationTarget.Create;
begin
  inherited;
end;

destructor TFhirSubstanceReferenceInformationTarget.Destroy;
begin
  FTarget.free;
  FType_.free;
  FInteraction.free;
  FOrganism.free;
  FOrganismType.free;
  FAmount.free;
  FAmountType.free;
  FSourceList.Free;
  inherited;
end;

procedure TFhirSubstanceReferenceInformationTarget.Assign(oSource : TFslObject);
begin
  inherited;
  target := TFhirSubstanceReferenceInformationTarget(oSource).target.Clone;
  type_ := TFhirSubstanceReferenceInformationTarget(oSource).type_.Clone;
  interaction := TFhirSubstanceReferenceInformationTarget(oSource).interaction.Clone;
  organism := TFhirSubstanceReferenceInformationTarget(oSource).organism.Clone;
  organismType := TFhirSubstanceReferenceInformationTarget(oSource).organismType.Clone;
  amount := TFhirSubstanceReferenceInformationTarget(oSource).amount.Clone;
  amountType := TFhirSubstanceReferenceInformationTarget(oSource).amountType.Clone;
  if (TFhirSubstanceReferenceInformationTarget(oSource).FSourceList = nil) then
  begin
    FSourceList.free;
    FSourceList := nil;
  end
  else
  begin
    if FSourceList = nil then
      FSourceList := TFhirReferenceList.Create;
    FSourceList.Assign(TFhirSubstanceReferenceInformationTarget(oSource).FSourceList);
  end;
end;

procedure TFhirSubstanceReferenceInformationTarget.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'target') Then
     list.add(self.link, 'target', FTarget.Link);
  if (child_name = 'type') Then
     list.add(self.link, 'type', FType_.Link);
  if (child_name = 'interaction') Then
     list.add(self.link, 'interaction', FInteraction.Link);
  if (child_name = 'organism') Then
     list.add(self.link, 'organism', FOrganism.Link);
  if (child_name = 'organismType') Then
     list.add(self.link, 'organismType', FOrganismType.Link);
  if (child_name = 'amount[x]') or (child_name = 'amount') Then
     list.add(self.link, 'amount[x]', FAmount.Link);
  if (child_name = 'amountType') Then
     list.add(self.link, 'amountType', FAmountType.Link);
  if (child_name = 'source') Then
    list.addAll(self, 'source', FSourceList);
end;

procedure TFhirSubstanceReferenceInformationTarget.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'target', 'Identifier', false, TFhirIdentifier, FTarget.Link));
  oList.add(TFHIRProperty.create(self, 'type', 'CodeableConcept', false, TFhirCodeableConcept, FType_.Link));
  oList.add(TFHIRProperty.create(self, 'interaction', 'CodeableConcept', false, TFhirCodeableConcept, FInteraction.Link));
  oList.add(TFHIRProperty.create(self, 'organism', 'CodeableConcept', false, TFhirCodeableConcept, FOrganism.Link));
  oList.add(TFHIRProperty.create(self, 'organismType', 'CodeableConcept', false, TFhirCodeableConcept, FOrganismType.Link));
  oList.add(TFHIRProperty.create(self, 'amount[x]', 'Quantity|Range|string', false, TFhirDataType, FAmount.Link));
  oList.add(TFHIRProperty.create(self, 'amountType', 'CodeableConcept', false, TFhirCodeableConcept, FAmountType.Link));
  oList.add(TFHIRProperty.create(self, 'source', 'Reference', true, TFhirReference, FSourceList.Link));
end;

function TFhirSubstanceReferenceInformationTarget.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'target') then
  begin
    Target := propValue as TFhirIdentifier;
    result := propValue;
  end
  else if (propName = 'type') then
  begin
    Type_ := propValue as TFhirCodeableConcept;
    result := propValue;
  end
  else if (propName = 'interaction') then
  begin
    Interaction := propValue as TFhirCodeableConcept;
    result := propValue;
  end
  else if (propName = 'organism') then
  begin
    Organism := propValue as TFhirCodeableConcept;
    result := propValue;
  end
  else if (propName = 'organismType') then
  begin
    OrganismType := propValue as TFhirCodeableConcept;
    result := propValue;
  end
  else if (isMatchingName(propName, 'amount', ['Quantity', 'Range', 'String'])) then
  begin
    Amount := propValue as TFhirDataType;
    result := propValue;
  end
  else if (propName = 'amountType') then
  begin
    AmountType := propValue as TFhirCodeableConcept;
    result := propValue;
  end
  else if (propName = 'source') then
  begin
    SourceList.add(propValue as TFhirReference);
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirSubstanceReferenceInformationTarget.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'source') then SourceList.insertItem(index, propValue as TFhirReference)
  else inherited;
end;

function TFhirSubstanceReferenceInformationTarget.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'target') then result := TFhirIdentifier.create()
  else if (propName = 'type') then result := TFhirCodeableConcept.create()
  else if (propName = 'interaction') then result := TFhirCodeableConcept.create()
  else if (propName = 'organism') then result := TFhirCodeableConcept.create()
  else if (propName = 'organismType') then result := TFhirCodeableConcept.create()
  else if (isMatchingName(propName, 'amount', ['Quantity', 'Range', 'String'])) then raise EFHIRException.create('Cannot make property Amount')
  else if (propName = 'amountType') then result := TFhirCodeableConcept.create()
  else if (propName = 'source') then result := SourceList.new()
  else result := inherited createPropertyValue(propName);
end;

function TFhirSubstanceReferenceInformationTarget.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'target') then result := 'Identifier'
  else if (propName = 'type') then result := 'CodeableConcept'
  else if (propName = 'interaction') then result := 'CodeableConcept'
  else if (propName = 'organism') then result := 'CodeableConcept'
  else if (propName = 'organismType') then result := 'CodeableConcept'
  else if (propName = 'amount[x]') then result := 'Quantity|Range|string'
  else if (propName = 'amountType') then result := 'CodeableConcept'
  else if (propName = 'source') then result := 'Reference'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirSubstanceReferenceInformationTarget.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'target') then TargetElement := nil
  else if (propName = 'type') then Type_Element := nil
  else if (propName = 'interaction') then InteractionElement := nil
  else if (propName = 'organism') then OrganismElement := nil
  else if (propName = 'organismType') then OrganismTypeElement := nil
  else if (isMatchingName(propName, 'amount', ['Quantity', 'Range', 'String'])) then AmountElement := nil
  else if (propName = 'amountType') then AmountTypeElement := nil
  else if (propName = 'source') then deletePropertyValue('source', SourceList, value)
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirSubstanceReferenceInformationTarget.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'target') then TargetElement := new as TFhirIdentifier
  else if (propName = 'type') then Type_Element := new as TFhirCodeableConcept
  else if (propName = 'interaction') then InteractionElement := new as TFhirCodeableConcept
  else if (propName = 'organism') then OrganismElement := new as TFhirCodeableConcept
  else if (propName = 'organismType') then OrganismTypeElement := new as TFhirCodeableConcept
  else if (isMatchingName(propName, 'amount', ['Quantity', 'Range', 'String'])) then AmountElement := new as TFhirDataType
  else if (propName = 'amountType') then AmountTypeElement := new as TFhirCodeableConcept
  else if (propName = 'source') then replacePropertyValue('source', SourceList, existing, new)
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirSubstanceReferenceInformationTarget.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'source') then SourceList.move(source, destination)
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirSubstanceReferenceInformationTarget.fhirType : string;
begin
  result := 'SubstanceReferenceInformation.target';
end;

function TFhirSubstanceReferenceInformationTarget.Link : TFhirSubstanceReferenceInformationTarget;
begin
  result := TFhirSubstanceReferenceInformationTarget(inherited Link);
end;

function TFhirSubstanceReferenceInformationTarget.Clone : TFhirSubstanceReferenceInformationTarget;
begin
  result := TFhirSubstanceReferenceInformationTarget(inherited Clone);
end;

function TFhirSubstanceReferenceInformationTarget.equals(other : TObject) : boolean; 
var
  o : TFhirSubstanceReferenceInformationTarget;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirSubstanceReferenceInformationTarget)) then
    result := false
  else
  begin
    o := TFhirSubstanceReferenceInformationTarget(other);
    result := compareDeep(targetElement, o.targetElement, true) and compareDeep(type_Element, o.type_Element, true) and 
      compareDeep(interactionElement, o.interactionElement, true) and compareDeep(organismElement, o.organismElement, true) and 
      compareDeep(organismTypeElement, o.organismTypeElement, true) and compareDeep(amountElement, o.amountElement, true) and 
      compareDeep(amountTypeElement, o.amountTypeElement, true) and compareDeep(sourceList, o.sourceList, true);
  end;
end;

function TFhirSubstanceReferenceInformationTarget.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FTarget) and isEmptyProp(FType_) and isEmptyProp(FInteraction) and isEmptyProp(FOrganism) and isEmptyProp(FOrganismType) and isEmptyProp(FAmount) and isEmptyProp(FAmountType) and isEmptyProp(FsourceList);
end;

procedure TFhirSubstanceReferenceInformationTarget.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('target');
  fields.add('type');
  fields.add('interaction');
  fields.add('organism');
  fields.add('organismType');
  fields.add('amount[x]');
  fields.add('amountType');
  fields.add('source');
end;

function TFhirSubstanceReferenceInformationTarget.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
  inc(result, FSourceList.sizeInBytes(magic));
end;

procedure TFhirSubstanceReferenceInformationTarget.SetTarget(value : TFhirIdentifier);
begin
  FTarget.free;
  FTarget := value;
end;

procedure TFhirSubstanceReferenceInformationTarget.SetType_(value : TFhirCodeableConcept);
begin
  FType_.free;
  FType_ := value;
end;

procedure TFhirSubstanceReferenceInformationTarget.SetInteraction(value : TFhirCodeableConcept);
begin
  FInteraction.free;
  FInteraction := value;
end;

procedure TFhirSubstanceReferenceInformationTarget.SetOrganism(value : TFhirCodeableConcept);
begin
  FOrganism.free;
  FOrganism := value;
end;

procedure TFhirSubstanceReferenceInformationTarget.SetOrganismType(value : TFhirCodeableConcept);
begin
  FOrganismType.free;
  FOrganismType := value;
end;

procedure TFhirSubstanceReferenceInformationTarget.SetAmount(value : TFhirDataType);
begin
  FAmount.free;
  FAmount := value;
end;

procedure TFhirSubstanceReferenceInformationTarget.SetAmountType(value : TFhirCodeableConcept);
begin
  FAmountType.free;
  FAmountType := value;
end;

function TFhirSubstanceReferenceInformationTarget.GetSourceList : TFhirReferenceList;
begin
  if FSourceList = nil then
    FSourceList := TFhirReferenceList.Create;
  result := FSourceList;
end;

function TFhirSubstanceReferenceInformationTarget.GetHasSourceList : boolean;
begin
  result := (FSourceList <> nil) and (FSourceList.count > 0);
end;

{ TFhirSubstanceReferenceInformationTargetListEnumerator }

constructor TFhirSubstanceReferenceInformationTargetListEnumerator.Create(list : TFhirSubstanceReferenceInformationTargetList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirSubstanceReferenceInformationTargetListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirSubstanceReferenceInformationTargetListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirSubstanceReferenceInformationTargetListEnumerator.GetCurrent : TFhirSubstanceReferenceInformationTarget;
begin
  Result := FList[FIndex];
end;

function TFhirSubstanceReferenceInformationTargetListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirSubstanceReferenceInformationTargetList }

function TFhirSubstanceReferenceInformationTargetList.AddItem(value: TFhirSubstanceReferenceInformationTarget): TFhirSubstanceReferenceInformationTarget;
begin
  assert(value.ClassName = 'TFhirSubstanceReferenceInformationTarget', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirSubstanceReferenceInformationTarget');
  add(value);
  result := value;
end;

function TFhirSubstanceReferenceInformationTargetList.Append: TFhirSubstanceReferenceInformationTarget;
begin
  result := TFhirSubstanceReferenceInformationTarget.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirSubstanceReferenceInformationTargetList.ClearItems;
begin
  Clear;
end;

function TFhirSubstanceReferenceInformationTargetList.GetEnumerator : TFhirSubstanceReferenceInformationTargetListEnumerator;
begin
  result := TFhirSubstanceReferenceInformationTargetListEnumerator.Create(self.link);
end;

function TFhirSubstanceReferenceInformationTargetList.Clone: TFhirSubstanceReferenceInformationTargetList;
begin
  result := TFhirSubstanceReferenceInformationTargetList(inherited Clone);
end;

function TFhirSubstanceReferenceInformationTargetList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirSubstanceReferenceInformationTargetList.GetItemN(index: Integer): TFhirSubstanceReferenceInformationTarget;
begin
  result := TFhirSubstanceReferenceInformationTarget(ObjectByIndex[index]);
end;

function TFhirSubstanceReferenceInformationTargetList.ItemClass: TFslObjectClass;
begin
  result := TFhirSubstanceReferenceInformationTarget;
end;
function TFhirSubstanceReferenceInformationTargetList.IndexOf(value: TFhirSubstanceReferenceInformationTarget): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirSubstanceReferenceInformationTargetList.Insert(index: Integer): TFhirSubstanceReferenceInformationTarget;
begin
  result := TFhirSubstanceReferenceInformationTarget.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirSubstanceReferenceInformationTargetList.InsertItem(index: Integer; value: TFhirSubstanceReferenceInformationTarget);
begin
  assert(value is TFhirSubstanceReferenceInformationTarget);
  Inherited Insert(index, value);
end;

function TFhirSubstanceReferenceInformationTargetList.Item(index: Integer): TFhirSubstanceReferenceInformationTarget;
begin
  result := TFhirSubstanceReferenceInformationTarget(ObjectByIndex[index]);
end;

function TFhirSubstanceReferenceInformationTargetList.Link: TFhirSubstanceReferenceInformationTargetList;
begin
  result := TFhirSubstanceReferenceInformationTargetList(inherited Link);
end;

procedure TFhirSubstanceReferenceInformationTargetList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirSubstanceReferenceInformationTargetList.SetItemByIndex(index: Integer; value: TFhirSubstanceReferenceInformationTarget);
begin
  assert(value is TFhirSubstanceReferenceInformationTarget);
  FhirSubstanceReferenceInformationTargets[index] := value;
end;

procedure TFhirSubstanceReferenceInformationTargetList.SetItemN(index: Integer; value: TFhirSubstanceReferenceInformationTarget);
begin
  assert(value is TFhirSubstanceReferenceInformationTarget);
  ObjectByIndex[index] := value;
end;

{ TFhirSubstanceReferenceInformation }

constructor TFhirSubstanceReferenceInformation.Create;
begin
  inherited;
end;

destructor TFhirSubstanceReferenceInformation.Destroy;
begin
  FComment.free;
  FGeneList.Free;
  FGeneElementList.Free;
  FTargetList.Free;
  inherited;
end;

procedure TFhirSubstanceReferenceInformation.Assign(oSource : TFslObject);
begin
  inherited;
  commentElement := TFhirSubstanceReferenceInformation(oSource).commentElement.Clone;
  if (TFhirSubstanceReferenceInformation(oSource).FGeneList = nil) then
  begin
    FGeneList.free;
    FGeneList := nil;
  end
  else
  begin
    if FGeneList = nil then
      FGeneList := TFhirSubstanceReferenceInformationGeneList.Create;
    FGeneList.Assign(TFhirSubstanceReferenceInformation(oSource).FGeneList);
  end;
  if (TFhirSubstanceReferenceInformation(oSource).FGeneElementList = nil) then
  begin
    FGeneElementList.free;
    FGeneElementList := nil;
  end
  else
  begin
    if FGeneElementList = nil then
      FGeneElementList := TFhirSubstanceReferenceInformationGeneElementList.Create;
    FGeneElementList.Assign(TFhirSubstanceReferenceInformation(oSource).FGeneElementList);
  end;
  if (TFhirSubstanceReferenceInformation(oSource).FTargetList = nil) then
  begin
    FTargetList.free;
    FTargetList := nil;
  end
  else
  begin
    if FTargetList = nil then
      FTargetList := TFhirSubstanceReferenceInformationTargetList.Create;
    FTargetList.Assign(TFhirSubstanceReferenceInformation(oSource).FTargetList);
  end;
end;

function TFhirSubstanceReferenceInformation.GetResourceType : TFhirResourceType;
begin
  result := frtSubstanceReferenceInformation;
end;

procedure TFhirSubstanceReferenceInformation.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'comment') Then
     list.add(self.link, 'comment', FComment.Link);
  if (child_name = 'gene') Then
    list.addAll(self, 'gene', FGeneList);
  if (child_name = 'geneElement') Then
    list.addAll(self, 'geneElement', FGeneElementList);
  if (child_name = 'target') Then
    list.addAll(self, 'target', FTargetList);
end;

procedure TFhirSubstanceReferenceInformation.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'comment', 'string', false, TFhirString, FComment.Link));
  oList.add(TFHIRProperty.create(self, 'gene', 'BackboneElement', true, TFhirSubstanceReferenceInformationGene, FGeneList.Link));
  oList.add(TFHIRProperty.create(self, 'geneElement', 'BackboneElement', true, TFhirSubstanceReferenceInformationGeneElement, FGeneElementList.Link));
  oList.add(TFHIRProperty.create(self, 'target', 'BackboneElement', true, TFhirSubstanceReferenceInformationTarget, FTargetList.Link));
end;

function TFhirSubstanceReferenceInformation.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'comment') then
  begin
    CommentElement := asString(propValue);
    result := propValue;
  end
  else if (propName = 'gene') then
  begin
    GeneList.add(propValue as TFhirSubstanceReferenceInformationGene);
    result := propValue;
  end
  else if (propName = 'geneElement') then
  begin
    GeneElementList.add(propValue as TFhirSubstanceReferenceInformationGeneElement);
    result := propValue;
  end
  else if (propName = 'target') then
  begin
    TargetList.add(propValue as TFhirSubstanceReferenceInformationTarget);
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirSubstanceReferenceInformation.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'gene') then GeneList.insertItem(index, propValue as TFhirSubstanceReferenceInformationGene)
  else if (propName = 'geneElement') then GeneElementList.insertItem(index, propValue as TFhirSubstanceReferenceInformationGeneElement)
  else if (propName = 'target') then TargetList.insertItem(index, propValue as TFhirSubstanceReferenceInformationTarget)
  else inherited;
end;

function TFhirSubstanceReferenceInformation.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'comment') then result := TFhirString.create()
  else if (propName = 'gene') then result := GeneList.new()
  else if (propName = 'geneElement') then result := GeneElementList.new()
  else if (propName = 'target') then result := TargetList.new()
  else result := inherited createPropertyValue(propName);
end;

function TFhirSubstanceReferenceInformation.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'comment') then result := 'string'
  else if (propName = 'gene') then result := 'BackboneElement'
  else if (propName = 'geneElement') then result := 'BackboneElement'
  else if (propName = 'target') then result := 'BackboneElement'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirSubstanceReferenceInformation.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'comment') then CommentElement := nil
  else if (propName = 'gene') then deletePropertyValue('gene', GeneList, value)
  else if (propName = 'geneElement') then deletePropertyValue('geneElement', GeneElementList, value)
  else if (propName = 'target') then deletePropertyValue('target', TargetList, value)
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirSubstanceReferenceInformation.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'comment') then CommentElement := asString(new)
  else if (propName = 'gene') then replacePropertyValue('gene', GeneList, existing, new)
  else if (propName = 'geneElement') then replacePropertyValue('geneElement', GeneElementList, existing, new)
  else if (propName = 'target') then replacePropertyValue('target', TargetList, existing, new)
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirSubstanceReferenceInformation.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'gene') then GeneList.move(source, destination)
  else if (propName = 'geneElement') then GeneElementList.move(source, destination)
  else if (propName = 'target') then TargetList.move(source, destination)
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirSubstanceReferenceInformation.fhirType : string;
begin
  result := 'SubstanceReferenceInformation';
end;

function TFhirSubstanceReferenceInformation.Link : TFhirSubstanceReferenceInformation;
begin
  result := TFhirSubstanceReferenceInformation(inherited Link);
end;

function TFhirSubstanceReferenceInformation.Clone : TFhirSubstanceReferenceInformation;
begin
  result := TFhirSubstanceReferenceInformation(inherited Clone);
end;

function TFhirSubstanceReferenceInformation.equals(other : TObject) : boolean; 
var
  o : TFhirSubstanceReferenceInformation;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirSubstanceReferenceInformation)) then
    result := false
  else
  begin
    o := TFhirSubstanceReferenceInformation(other);
    result := compareDeep(commentElement, o.commentElement, true) and compareDeep(geneList, o.geneList, true) and 
      compareDeep(geneElementList, o.geneElementList, true) and compareDeep(targetList, o.targetList, true);
  end;
end;

function TFhirSubstanceReferenceInformation.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FComment) and isEmptyProp(FgeneList) and isEmptyProp(FgeneElementList) and isEmptyProp(FtargetList);
end;

procedure TFhirSubstanceReferenceInformation.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('comment');
  fields.add('gene');
  fields.add('geneElement');
  fields.add('target');
end;

function TFhirSubstanceReferenceInformation.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
  inc(result, FGeneList.sizeInBytes(magic));
  inc(result, FGeneElementList.sizeInBytes(magic));
  inc(result, FTargetList.sizeInBytes(magic));
end;

procedure TFhirSubstanceReferenceInformation.SetComment(value : TFhirString);
begin
  FComment.free;
  FComment := value;
end;

function TFhirSubstanceReferenceInformation.GetCommentST : String;
begin
  if FComment = nil then
    result := ''
  else
    result := FComment.value;
end;

procedure TFhirSubstanceReferenceInformation.SetCommentST(value : String);
begin
  if value <> '' then
  begin
    if FComment = nil then
      FComment := TFhirString.create;
    FComment.value := value
  end
  else if FComment <> nil then
    FComment.value := '';
end;

function TFhirSubstanceReferenceInformation.GetGeneList : TFhirSubstanceReferenceInformationGeneList;
begin
  if FGeneList = nil then
    FGeneList := TFhirSubstanceReferenceInformationGeneList.Create;
  result := FGeneList;
end;

function TFhirSubstanceReferenceInformation.GetHasGeneList : boolean;
begin
  result := (FGeneList <> nil) and (FGeneList.count > 0);
end;

function TFhirSubstanceReferenceInformation.GetGeneElementList : TFhirSubstanceReferenceInformationGeneElementList;
begin
  if FGeneElementList = nil then
    FGeneElementList := TFhirSubstanceReferenceInformationGeneElementList.Create;
  result := FGeneElementList;
end;

function TFhirSubstanceReferenceInformation.GetHasGeneElementList : boolean;
begin
  result := (FGeneElementList <> nil) and (FGeneElementList.count > 0);
end;

function TFhirSubstanceReferenceInformation.GetTargetList : TFhirSubstanceReferenceInformationTargetList;
begin
  if FTargetList = nil then
    FTargetList := TFhirSubstanceReferenceInformationTargetList.Create;
  result := FTargetList;
end;

function TFhirSubstanceReferenceInformation.GetHasTargetList : boolean;
begin
  result := (FTargetList <> nil) and (FTargetList.count > 0);
end;

{ TFhirSubstanceReferenceInformationListEnumerator }

constructor TFhirSubstanceReferenceInformationListEnumerator.Create(list : TFhirSubstanceReferenceInformationList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirSubstanceReferenceInformationListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirSubstanceReferenceInformationListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirSubstanceReferenceInformationListEnumerator.GetCurrent : TFhirSubstanceReferenceInformation;
begin
  Result := FList[FIndex];
end;

function TFhirSubstanceReferenceInformationListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirSubstanceReferenceInformationList }

function TFhirSubstanceReferenceInformationList.AddItem(value: TFhirSubstanceReferenceInformation): TFhirSubstanceReferenceInformation;
begin
  assert(value.ClassName = 'TFhirSubstanceReferenceInformation', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirSubstanceReferenceInformation');
  add(value);
  result := value;
end;

function TFhirSubstanceReferenceInformationList.Append: TFhirSubstanceReferenceInformation;
begin
  result := TFhirSubstanceReferenceInformation.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirSubstanceReferenceInformationList.ClearItems;
begin
  Clear;
end;

function TFhirSubstanceReferenceInformationList.GetEnumerator : TFhirSubstanceReferenceInformationListEnumerator;
begin
  result := TFhirSubstanceReferenceInformationListEnumerator.Create(self.link);
end;

function TFhirSubstanceReferenceInformationList.Clone: TFhirSubstanceReferenceInformationList;
begin
  result := TFhirSubstanceReferenceInformationList(inherited Clone);
end;

function TFhirSubstanceReferenceInformationList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirSubstanceReferenceInformationList.GetItemN(index: Integer): TFhirSubstanceReferenceInformation;
begin
  result := TFhirSubstanceReferenceInformation(ObjectByIndex[index]);
end;

function TFhirSubstanceReferenceInformationList.ItemClass: TFslObjectClass;
begin
  result := TFhirSubstanceReferenceInformation;
end;
function TFhirSubstanceReferenceInformationList.IndexOf(value: TFhirSubstanceReferenceInformation): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirSubstanceReferenceInformationList.Insert(index: Integer): TFhirSubstanceReferenceInformation;
begin
  result := TFhirSubstanceReferenceInformation.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirSubstanceReferenceInformationList.InsertItem(index: Integer; value: TFhirSubstanceReferenceInformation);
begin
  assert(value is TFhirSubstanceReferenceInformation);
  Inherited Insert(index, value);
end;

function TFhirSubstanceReferenceInformationList.Item(index: Integer): TFhirSubstanceReferenceInformation;
begin
  result := TFhirSubstanceReferenceInformation(ObjectByIndex[index]);
end;

function TFhirSubstanceReferenceInformationList.Link: TFhirSubstanceReferenceInformationList;
begin
  result := TFhirSubstanceReferenceInformationList(inherited Link);
end;

procedure TFhirSubstanceReferenceInformationList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirSubstanceReferenceInformationList.SetItemByIndex(index: Integer; value: TFhirSubstanceReferenceInformation);
begin
  assert(value is TFhirSubstanceReferenceInformation);
  FhirSubstanceReferenceInformations[index] := value;
end;

procedure TFhirSubstanceReferenceInformationList.SetItemN(index: Integer; value: TFhirSubstanceReferenceInformation);
begin
  assert(value is TFhirSubstanceReferenceInformation);
  ObjectByIndex[index] := value;
end;

{$ENDIF FHIR_SUBSTANCEREFERENCEINFORMATION}
{$IFDEF FHIR_SUBSTANCESOURCEMATERIAL}
{ TFhirSubstanceSourceMaterialFractionDescription }

constructor TFhirSubstanceSourceMaterialFractionDescription.Create;
begin
  inherited;
end;

destructor TFhirSubstanceSourceMaterialFractionDescription.Destroy;
begin
  FFraction.free;
  FMaterialType.free;
  inherited;
end;

procedure TFhirSubstanceSourceMaterialFractionDescription.Assign(oSource : TFslObject);
begin
  inherited;
  fractionElement := TFhirSubstanceSourceMaterialFractionDescription(oSource).fractionElement.Clone;
  materialType := TFhirSubstanceSourceMaterialFractionDescription(oSource).materialType.Clone;
end;

procedure TFhirSubstanceSourceMaterialFractionDescription.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'fraction') Then
     list.add(self.link, 'fraction', FFraction.Link);
  if (child_name = 'materialType') Then
     list.add(self.link, 'materialType', FMaterialType.Link);
end;

procedure TFhirSubstanceSourceMaterialFractionDescription.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'fraction', 'string', false, TFhirString, FFraction.Link));
  oList.add(TFHIRProperty.create(self, 'materialType', 'CodeableConcept', false, TFhirCodeableConcept, FMaterialType.Link));
end;

function TFhirSubstanceSourceMaterialFractionDescription.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'fraction') then
  begin
    FractionElement := asString(propValue);
    result := propValue;
  end
  else if (propName = 'materialType') then
  begin
    MaterialType := propValue as TFhirCodeableConcept;
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirSubstanceSourceMaterialFractionDescription.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirSubstanceSourceMaterialFractionDescription.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'fraction') then result := TFhirString.create()
  else if (propName = 'materialType') then result := TFhirCodeableConcept.create()
  else result := inherited createPropertyValue(propName);
end;

function TFhirSubstanceSourceMaterialFractionDescription.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'fraction') then result := 'string'
  else if (propName = 'materialType') then result := 'CodeableConcept'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirSubstanceSourceMaterialFractionDescription.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'fraction') then FractionElement := nil
  else if (propName = 'materialType') then MaterialTypeElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirSubstanceSourceMaterialFractionDescription.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'fraction') then FractionElement := asString(new)
  else if (propName = 'materialType') then MaterialTypeElement := new as TFhirCodeableConcept
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirSubstanceSourceMaterialFractionDescription.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirSubstanceSourceMaterialFractionDescription.fhirType : string;
begin
  result := 'SubstanceSourceMaterial.fractionDescription';
end;

function TFhirSubstanceSourceMaterialFractionDescription.Link : TFhirSubstanceSourceMaterialFractionDescription;
begin
  result := TFhirSubstanceSourceMaterialFractionDescription(inherited Link);
end;

function TFhirSubstanceSourceMaterialFractionDescription.Clone : TFhirSubstanceSourceMaterialFractionDescription;
begin
  result := TFhirSubstanceSourceMaterialFractionDescription(inherited Clone);
end;

function TFhirSubstanceSourceMaterialFractionDescription.equals(other : TObject) : boolean; 
var
  o : TFhirSubstanceSourceMaterialFractionDescription;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirSubstanceSourceMaterialFractionDescription)) then
    result := false
  else
  begin
    o := TFhirSubstanceSourceMaterialFractionDescription(other);
    result := compareDeep(fractionElement, o.fractionElement, true) and compareDeep(materialTypeElement, o.materialTypeElement, true);
  end;
end;

function TFhirSubstanceSourceMaterialFractionDescription.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FFraction) and isEmptyProp(FMaterialType);
end;

procedure TFhirSubstanceSourceMaterialFractionDescription.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('fraction');
  fields.add('materialType');
end;

function TFhirSubstanceSourceMaterialFractionDescription.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
end;

procedure TFhirSubstanceSourceMaterialFractionDescription.SetFraction(value : TFhirString);
begin
  FFraction.free;
  FFraction := value;
end;

function TFhirSubstanceSourceMaterialFractionDescription.GetFractionST : String;
begin
  if FFraction = nil then
    result := ''
  else
    result := FFraction.value;
end;

procedure TFhirSubstanceSourceMaterialFractionDescription.SetFractionST(value : String);
begin
  if value <> '' then
  begin
    if FFraction = nil then
      FFraction := TFhirString.create;
    FFraction.value := value
  end
  else if FFraction <> nil then
    FFraction.value := '';
end;

procedure TFhirSubstanceSourceMaterialFractionDescription.SetMaterialType(value : TFhirCodeableConcept);
begin
  FMaterialType.free;
  FMaterialType := value;
end;

{ TFhirSubstanceSourceMaterialFractionDescriptionListEnumerator }

constructor TFhirSubstanceSourceMaterialFractionDescriptionListEnumerator.Create(list : TFhirSubstanceSourceMaterialFractionDescriptionList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirSubstanceSourceMaterialFractionDescriptionListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirSubstanceSourceMaterialFractionDescriptionListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirSubstanceSourceMaterialFractionDescriptionListEnumerator.GetCurrent : TFhirSubstanceSourceMaterialFractionDescription;
begin
  Result := FList[FIndex];
end;

function TFhirSubstanceSourceMaterialFractionDescriptionListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirSubstanceSourceMaterialFractionDescriptionList }

function TFhirSubstanceSourceMaterialFractionDescriptionList.AddItem(value: TFhirSubstanceSourceMaterialFractionDescription): TFhirSubstanceSourceMaterialFractionDescription;
begin
  assert(value.ClassName = 'TFhirSubstanceSourceMaterialFractionDescription', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirSubstanceSourceMaterialFractionDescription');
  add(value);
  result := value;
end;

function TFhirSubstanceSourceMaterialFractionDescriptionList.Append: TFhirSubstanceSourceMaterialFractionDescription;
begin
  result := TFhirSubstanceSourceMaterialFractionDescription.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirSubstanceSourceMaterialFractionDescriptionList.ClearItems;
begin
  Clear;
end;

function TFhirSubstanceSourceMaterialFractionDescriptionList.GetEnumerator : TFhirSubstanceSourceMaterialFractionDescriptionListEnumerator;
begin
  result := TFhirSubstanceSourceMaterialFractionDescriptionListEnumerator.Create(self.link);
end;

function TFhirSubstanceSourceMaterialFractionDescriptionList.Clone: TFhirSubstanceSourceMaterialFractionDescriptionList;
begin
  result := TFhirSubstanceSourceMaterialFractionDescriptionList(inherited Clone);
end;

function TFhirSubstanceSourceMaterialFractionDescriptionList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirSubstanceSourceMaterialFractionDescriptionList.GetItemN(index: Integer): TFhirSubstanceSourceMaterialFractionDescription;
begin
  result := TFhirSubstanceSourceMaterialFractionDescription(ObjectByIndex[index]);
end;

function TFhirSubstanceSourceMaterialFractionDescriptionList.ItemClass: TFslObjectClass;
begin
  result := TFhirSubstanceSourceMaterialFractionDescription;
end;
function TFhirSubstanceSourceMaterialFractionDescriptionList.IndexOf(value: TFhirSubstanceSourceMaterialFractionDescription): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirSubstanceSourceMaterialFractionDescriptionList.Insert(index: Integer): TFhirSubstanceSourceMaterialFractionDescription;
begin
  result := TFhirSubstanceSourceMaterialFractionDescription.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirSubstanceSourceMaterialFractionDescriptionList.InsertItem(index: Integer; value: TFhirSubstanceSourceMaterialFractionDescription);
begin
  assert(value is TFhirSubstanceSourceMaterialFractionDescription);
  Inherited Insert(index, value);
end;

function TFhirSubstanceSourceMaterialFractionDescriptionList.Item(index: Integer): TFhirSubstanceSourceMaterialFractionDescription;
begin
  result := TFhirSubstanceSourceMaterialFractionDescription(ObjectByIndex[index]);
end;

function TFhirSubstanceSourceMaterialFractionDescriptionList.Link: TFhirSubstanceSourceMaterialFractionDescriptionList;
begin
  result := TFhirSubstanceSourceMaterialFractionDescriptionList(inherited Link);
end;

procedure TFhirSubstanceSourceMaterialFractionDescriptionList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirSubstanceSourceMaterialFractionDescriptionList.SetItemByIndex(index: Integer; value: TFhirSubstanceSourceMaterialFractionDescription);
begin
  assert(value is TFhirSubstanceSourceMaterialFractionDescription);
  FhirSubstanceSourceMaterialFractionDescriptions[index] := value;
end;

procedure TFhirSubstanceSourceMaterialFractionDescriptionList.SetItemN(index: Integer; value: TFhirSubstanceSourceMaterialFractionDescription);
begin
  assert(value is TFhirSubstanceSourceMaterialFractionDescription);
  ObjectByIndex[index] := value;
end;

{ TFhirSubstanceSourceMaterialOrganism }

constructor TFhirSubstanceSourceMaterialOrganism.Create;
begin
  inherited;
end;

destructor TFhirSubstanceSourceMaterialOrganism.Destroy;
begin
  FFamily.free;
  FGenus.free;
  FSpecies.free;
  FIntraspecificType.free;
  FIntraspecificDescription.free;
  FAuthorList.Free;
  FHybrid.free;
  FOrganismGeneral.free;
  inherited;
end;

procedure TFhirSubstanceSourceMaterialOrganism.Assign(oSource : TFslObject);
begin
  inherited;
  family := TFhirSubstanceSourceMaterialOrganism(oSource).family.Clone;
  genus := TFhirSubstanceSourceMaterialOrganism(oSource).genus.Clone;
  species := TFhirSubstanceSourceMaterialOrganism(oSource).species.Clone;
  intraspecificType := TFhirSubstanceSourceMaterialOrganism(oSource).intraspecificType.Clone;
  intraspecificDescriptionElement := TFhirSubstanceSourceMaterialOrganism(oSource).intraspecificDescriptionElement.Clone;
  if (TFhirSubstanceSourceMaterialOrganism(oSource).FAuthorList = nil) then
  begin
    FAuthorList.free;
    FAuthorList := nil;
  end
  else
  begin
    if FAuthorList = nil then
      FAuthorList := TFhirSubstanceSourceMaterialOrganismAuthorList.Create;
    FAuthorList.Assign(TFhirSubstanceSourceMaterialOrganism(oSource).FAuthorList);
  end;
  hybrid := TFhirSubstanceSourceMaterialOrganism(oSource).hybrid.Clone;
  organismGeneral := TFhirSubstanceSourceMaterialOrganism(oSource).organismGeneral.Clone;
end;

procedure TFhirSubstanceSourceMaterialOrganism.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'family') Then
     list.add(self.link, 'family', FFamily.Link);
  if (child_name = 'genus') Then
     list.add(self.link, 'genus', FGenus.Link);
  if (child_name = 'species') Then
     list.add(self.link, 'species', FSpecies.Link);
  if (child_name = 'intraspecificType') Then
     list.add(self.link, 'intraspecificType', FIntraspecificType.Link);
  if (child_name = 'intraspecificDescription') Then
     list.add(self.link, 'intraspecificDescription', FIntraspecificDescription.Link);
  if (child_name = 'author') Then
    list.addAll(self, 'author', FAuthorList);
  if (child_name = 'hybrid') Then
     list.add(self.link, 'hybrid', FHybrid.Link);
  if (child_name = 'organismGeneral') Then
     list.add(self.link, 'organismGeneral', FOrganismGeneral.Link);
end;

procedure TFhirSubstanceSourceMaterialOrganism.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'family', 'CodeableConcept', false, TFhirCodeableConcept, FFamily.Link));
  oList.add(TFHIRProperty.create(self, 'genus', 'CodeableConcept', false, TFhirCodeableConcept, FGenus.Link));
  oList.add(TFHIRProperty.create(self, 'species', 'CodeableConcept', false, TFhirCodeableConcept, FSpecies.Link));
  oList.add(TFHIRProperty.create(self, 'intraspecificType', 'CodeableConcept', false, TFhirCodeableConcept, FIntraspecificType.Link));
  oList.add(TFHIRProperty.create(self, 'intraspecificDescription', 'string', false, TFhirString, FIntraspecificDescription.Link));
  oList.add(TFHIRProperty.create(self, 'author', 'BackboneElement', true, TFhirSubstanceSourceMaterialOrganismAuthor, FAuthorList.Link));
  oList.add(TFHIRProperty.create(self, 'hybrid', 'BackboneElement', false, TFhirSubstanceSourceMaterialOrganismHybrid, FHybrid.Link));
  oList.add(TFHIRProperty.create(self, 'organismGeneral', 'BackboneElement', false, TFhirSubstanceSourceMaterialOrganismOrganismGeneral, FOrganismGeneral.Link));
end;

function TFhirSubstanceSourceMaterialOrganism.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'family') then
  begin
    Family := propValue as TFhirCodeableConcept;
    result := propValue;
  end
  else if (propName = 'genus') then
  begin
    Genus := propValue as TFhirCodeableConcept;
    result := propValue;
  end
  else if (propName = 'species') then
  begin
    Species := propValue as TFhirCodeableConcept;
    result := propValue;
  end
  else if (propName = 'intraspecificType') then
  begin
    IntraspecificType := propValue as TFhirCodeableConcept;
    result := propValue;
  end
  else if (propName = 'intraspecificDescription') then
  begin
    IntraspecificDescriptionElement := asString(propValue);
    result := propValue;
  end
  else if (propName = 'author') then
  begin
    AuthorList.add(propValue as TFhirSubstanceSourceMaterialOrganismAuthor);
    result := propValue;
  end
  else if (propName = 'hybrid') then
  begin
    Hybrid := propValue as TFhirSubstanceSourceMaterialOrganismHybrid;
    result := propValue;
  end
  else if (propName = 'organismGeneral') then
  begin
    OrganismGeneral := propValue as TFhirSubstanceSourceMaterialOrganismOrganismGeneral;
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirSubstanceSourceMaterialOrganism.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'author') then AuthorList.insertItem(index, propValue as TFhirSubstanceSourceMaterialOrganismAuthor)
  else inherited;
end;

function TFhirSubstanceSourceMaterialOrganism.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'family') then result := TFhirCodeableConcept.create()
  else if (propName = 'genus') then result := TFhirCodeableConcept.create()
  else if (propName = 'species') then result := TFhirCodeableConcept.create()
  else if (propName = 'intraspecificType') then result := TFhirCodeableConcept.create()
  else if (propName = 'intraspecificDescription') then result := TFhirString.create()
  else if (propName = 'author') then result := AuthorList.new()
  else if (propName = 'hybrid') then result := TFhirSubstanceSourceMaterialOrganismHybrid.create()
  else if (propName = 'organismGeneral') then result := TFhirSubstanceSourceMaterialOrganismOrganismGeneral.create()
  else result := inherited createPropertyValue(propName);
end;

function TFhirSubstanceSourceMaterialOrganism.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'family') then result := 'CodeableConcept'
  else if (propName = 'genus') then result := 'CodeableConcept'
  else if (propName = 'species') then result := 'CodeableConcept'
  else if (propName = 'intraspecificType') then result := 'CodeableConcept'
  else if (propName = 'intraspecificDescription') then result := 'string'
  else if (propName = 'author') then result := 'BackboneElement'
  else if (propName = 'hybrid') then result := 'BackboneElement'
  else if (propName = 'organismGeneral') then result := 'BackboneElement'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirSubstanceSourceMaterialOrganism.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'family') then FamilyElement := nil
  else if (propName = 'genus') then GenusElement := nil
  else if (propName = 'species') then SpeciesElement := nil
  else if (propName = 'intraspecificType') then IntraspecificTypeElement := nil
  else if (propName = 'intraspecificDescription') then IntraspecificDescriptionElement := nil
  else if (propName = 'author') then deletePropertyValue('author', AuthorList, value)
  else if (propName = 'hybrid') then HybridElement := nil
  else if (propName = 'organismGeneral') then OrganismGeneralElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirSubstanceSourceMaterialOrganism.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'family') then FamilyElement := new as TFhirCodeableConcept
  else if (propName = 'genus') then GenusElement := new as TFhirCodeableConcept
  else if (propName = 'species') then SpeciesElement := new as TFhirCodeableConcept
  else if (propName = 'intraspecificType') then IntraspecificTypeElement := new as TFhirCodeableConcept
  else if (propName = 'intraspecificDescription') then IntraspecificDescriptionElement := asString(new)
  else if (propName = 'author') then replacePropertyValue('author', AuthorList, existing, new)
  else if (propName = 'hybrid') then HybridElement := new as TFhirSubstanceSourceMaterialOrganismHybrid
  else if (propName = 'organismGeneral') then OrganismGeneralElement := new as TFhirSubstanceSourceMaterialOrganismOrganismGeneral
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirSubstanceSourceMaterialOrganism.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'author') then AuthorList.move(source, destination)
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirSubstanceSourceMaterialOrganism.fhirType : string;
begin
  result := 'SubstanceSourceMaterial.organism';
end;

function TFhirSubstanceSourceMaterialOrganism.Link : TFhirSubstanceSourceMaterialOrganism;
begin
  result := TFhirSubstanceSourceMaterialOrganism(inherited Link);
end;

function TFhirSubstanceSourceMaterialOrganism.Clone : TFhirSubstanceSourceMaterialOrganism;
begin
  result := TFhirSubstanceSourceMaterialOrganism(inherited Clone);
end;

function TFhirSubstanceSourceMaterialOrganism.equals(other : TObject) : boolean; 
var
  o : TFhirSubstanceSourceMaterialOrganism;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirSubstanceSourceMaterialOrganism)) then
    result := false
  else
  begin
    o := TFhirSubstanceSourceMaterialOrganism(other);
    result := compareDeep(familyElement, o.familyElement, true) and compareDeep(genusElement, o.genusElement, true) and 
      compareDeep(speciesElement, o.speciesElement, true) and compareDeep(intraspecificTypeElement, o.intraspecificTypeElement, true) and 
      compareDeep(intraspecificDescriptionElement, o.intraspecificDescriptionElement, true) and 
      compareDeep(authorList, o.authorList, true) and compareDeep(hybridElement, o.hybridElement, true) and 
      compareDeep(organismGeneralElement, o.organismGeneralElement, true);
  end;
end;

function TFhirSubstanceSourceMaterialOrganism.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FFamily) and isEmptyProp(FGenus) and isEmptyProp(FSpecies) and isEmptyProp(FIntraspecificType) and isEmptyProp(FIntraspecificDescription) and isEmptyProp(FauthorList) and isEmptyProp(FHybrid) and isEmptyProp(FOrganismGeneral);
end;

procedure TFhirSubstanceSourceMaterialOrganism.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('family');
  fields.add('genus');
  fields.add('species');
  fields.add('intraspecificType');
  fields.add('intraspecificDescription');
  fields.add('author');
  fields.add('hybrid');
  fields.add('organismGeneral');
end;

function TFhirSubstanceSourceMaterialOrganism.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
  inc(result, FAuthorList.sizeInBytes(magic));
end;

procedure TFhirSubstanceSourceMaterialOrganism.SetFamily(value : TFhirCodeableConcept);
begin
  FFamily.free;
  FFamily := value;
end;

procedure TFhirSubstanceSourceMaterialOrganism.SetGenus(value : TFhirCodeableConcept);
begin
  FGenus.free;
  FGenus := value;
end;

procedure TFhirSubstanceSourceMaterialOrganism.SetSpecies(value : TFhirCodeableConcept);
begin
  FSpecies.free;
  FSpecies := value;
end;

procedure TFhirSubstanceSourceMaterialOrganism.SetIntraspecificType(value : TFhirCodeableConcept);
begin
  FIntraspecificType.free;
  FIntraspecificType := value;
end;

procedure TFhirSubstanceSourceMaterialOrganism.SetIntraspecificDescription(value : TFhirString);
begin
  FIntraspecificDescription.free;
  FIntraspecificDescription := value;
end;

function TFhirSubstanceSourceMaterialOrganism.GetIntraspecificDescriptionST : String;
begin
  if FIntraspecificDescription = nil then
    result := ''
  else
    result := FIntraspecificDescription.value;
end;

procedure TFhirSubstanceSourceMaterialOrganism.SetIntraspecificDescriptionST(value : String);
begin
  if value <> '' then
  begin
    if FIntraspecificDescription = nil then
      FIntraspecificDescription := TFhirString.create;
    FIntraspecificDescription.value := value
  end
  else if FIntraspecificDescription <> nil then
    FIntraspecificDescription.value := '';
end;

function TFhirSubstanceSourceMaterialOrganism.GetAuthorList : TFhirSubstanceSourceMaterialOrganismAuthorList;
begin
  if FAuthorList = nil then
    FAuthorList := TFhirSubstanceSourceMaterialOrganismAuthorList.Create;
  result := FAuthorList;
end;

function TFhirSubstanceSourceMaterialOrganism.GetHasAuthorList : boolean;
begin
  result := (FAuthorList <> nil) and (FAuthorList.count > 0);
end;

procedure TFhirSubstanceSourceMaterialOrganism.SetHybrid(value : TFhirSubstanceSourceMaterialOrganismHybrid);
begin
  FHybrid.free;
  FHybrid := value;
end;

procedure TFhirSubstanceSourceMaterialOrganism.SetOrganismGeneral(value : TFhirSubstanceSourceMaterialOrganismOrganismGeneral);
begin
  FOrganismGeneral.free;
  FOrganismGeneral := value;
end;

{ TFhirSubstanceSourceMaterialOrganismListEnumerator }

constructor TFhirSubstanceSourceMaterialOrganismListEnumerator.Create(list : TFhirSubstanceSourceMaterialOrganismList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirSubstanceSourceMaterialOrganismListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirSubstanceSourceMaterialOrganismListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirSubstanceSourceMaterialOrganismListEnumerator.GetCurrent : TFhirSubstanceSourceMaterialOrganism;
begin
  Result := FList[FIndex];
end;

function TFhirSubstanceSourceMaterialOrganismListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirSubstanceSourceMaterialOrganismList }

function TFhirSubstanceSourceMaterialOrganismList.AddItem(value: TFhirSubstanceSourceMaterialOrganism): TFhirSubstanceSourceMaterialOrganism;
begin
  assert(value.ClassName = 'TFhirSubstanceSourceMaterialOrganism', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirSubstanceSourceMaterialOrganism');
  add(value);
  result := value;
end;

function TFhirSubstanceSourceMaterialOrganismList.Append: TFhirSubstanceSourceMaterialOrganism;
begin
  result := TFhirSubstanceSourceMaterialOrganism.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirSubstanceSourceMaterialOrganismList.ClearItems;
begin
  Clear;
end;

function TFhirSubstanceSourceMaterialOrganismList.GetEnumerator : TFhirSubstanceSourceMaterialOrganismListEnumerator;
begin
  result := TFhirSubstanceSourceMaterialOrganismListEnumerator.Create(self.link);
end;

function TFhirSubstanceSourceMaterialOrganismList.Clone: TFhirSubstanceSourceMaterialOrganismList;
begin
  result := TFhirSubstanceSourceMaterialOrganismList(inherited Clone);
end;

function TFhirSubstanceSourceMaterialOrganismList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirSubstanceSourceMaterialOrganismList.GetItemN(index: Integer): TFhirSubstanceSourceMaterialOrganism;
begin
  result := TFhirSubstanceSourceMaterialOrganism(ObjectByIndex[index]);
end;

function TFhirSubstanceSourceMaterialOrganismList.ItemClass: TFslObjectClass;
begin
  result := TFhirSubstanceSourceMaterialOrganism;
end;
function TFhirSubstanceSourceMaterialOrganismList.IndexOf(value: TFhirSubstanceSourceMaterialOrganism): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirSubstanceSourceMaterialOrganismList.Insert(index: Integer): TFhirSubstanceSourceMaterialOrganism;
begin
  result := TFhirSubstanceSourceMaterialOrganism.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirSubstanceSourceMaterialOrganismList.InsertItem(index: Integer; value: TFhirSubstanceSourceMaterialOrganism);
begin
  assert(value is TFhirSubstanceSourceMaterialOrganism);
  Inherited Insert(index, value);
end;

function TFhirSubstanceSourceMaterialOrganismList.Item(index: Integer): TFhirSubstanceSourceMaterialOrganism;
begin
  result := TFhirSubstanceSourceMaterialOrganism(ObjectByIndex[index]);
end;

function TFhirSubstanceSourceMaterialOrganismList.Link: TFhirSubstanceSourceMaterialOrganismList;
begin
  result := TFhirSubstanceSourceMaterialOrganismList(inherited Link);
end;

procedure TFhirSubstanceSourceMaterialOrganismList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirSubstanceSourceMaterialOrganismList.SetItemByIndex(index: Integer; value: TFhirSubstanceSourceMaterialOrganism);
begin
  assert(value is TFhirSubstanceSourceMaterialOrganism);
  FhirSubstanceSourceMaterialOrganisms[index] := value;
end;

procedure TFhirSubstanceSourceMaterialOrganismList.SetItemN(index: Integer; value: TFhirSubstanceSourceMaterialOrganism);
begin
  assert(value is TFhirSubstanceSourceMaterialOrganism);
  ObjectByIndex[index] := value;
end;

{ TFhirSubstanceSourceMaterialOrganismAuthor }

constructor TFhirSubstanceSourceMaterialOrganismAuthor.Create;
begin
  inherited;
end;

destructor TFhirSubstanceSourceMaterialOrganismAuthor.Destroy;
begin
  FAuthorType.free;
  FAuthorDescription.free;
  inherited;
end;

procedure TFhirSubstanceSourceMaterialOrganismAuthor.Assign(oSource : TFslObject);
begin
  inherited;
  authorType := TFhirSubstanceSourceMaterialOrganismAuthor(oSource).authorType.Clone;
  authorDescriptionElement := TFhirSubstanceSourceMaterialOrganismAuthor(oSource).authorDescriptionElement.Clone;
end;

procedure TFhirSubstanceSourceMaterialOrganismAuthor.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'authorType') Then
     list.add(self.link, 'authorType', FAuthorType.Link);
  if (child_name = 'authorDescription') Then
     list.add(self.link, 'authorDescription', FAuthorDescription.Link);
end;

procedure TFhirSubstanceSourceMaterialOrganismAuthor.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'authorType', 'CodeableConcept', false, TFhirCodeableConcept, FAuthorType.Link));
  oList.add(TFHIRProperty.create(self, 'authorDescription', 'string', false, TFhirString, FAuthorDescription.Link));
end;

function TFhirSubstanceSourceMaterialOrganismAuthor.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'authorType') then
  begin
    AuthorType := propValue as TFhirCodeableConcept;
    result := propValue;
  end
  else if (propName = 'authorDescription') then
  begin
    AuthorDescriptionElement := asString(propValue);
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirSubstanceSourceMaterialOrganismAuthor.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirSubstanceSourceMaterialOrganismAuthor.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'authorType') then result := TFhirCodeableConcept.create()
  else if (propName = 'authorDescription') then result := TFhirString.create()
  else result := inherited createPropertyValue(propName);
end;

function TFhirSubstanceSourceMaterialOrganismAuthor.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'authorType') then result := 'CodeableConcept'
  else if (propName = 'authorDescription') then result := 'string'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirSubstanceSourceMaterialOrganismAuthor.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'authorType') then AuthorTypeElement := nil
  else if (propName = 'authorDescription') then AuthorDescriptionElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirSubstanceSourceMaterialOrganismAuthor.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'authorType') then AuthorTypeElement := new as TFhirCodeableConcept
  else if (propName = 'authorDescription') then AuthorDescriptionElement := asString(new)
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirSubstanceSourceMaterialOrganismAuthor.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirSubstanceSourceMaterialOrganismAuthor.fhirType : string;
begin
  result := 'SubstanceSourceMaterial.organism.author';
end;

function TFhirSubstanceSourceMaterialOrganismAuthor.Link : TFhirSubstanceSourceMaterialOrganismAuthor;
begin
  result := TFhirSubstanceSourceMaterialOrganismAuthor(inherited Link);
end;

function TFhirSubstanceSourceMaterialOrganismAuthor.Clone : TFhirSubstanceSourceMaterialOrganismAuthor;
begin
  result := TFhirSubstanceSourceMaterialOrganismAuthor(inherited Clone);
end;

function TFhirSubstanceSourceMaterialOrganismAuthor.equals(other : TObject) : boolean; 
var
  o : TFhirSubstanceSourceMaterialOrganismAuthor;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirSubstanceSourceMaterialOrganismAuthor)) then
    result := false
  else
  begin
    o := TFhirSubstanceSourceMaterialOrganismAuthor(other);
    result := compareDeep(authorTypeElement, o.authorTypeElement, true) and compareDeep(authorDescriptionElement, o.authorDescriptionElement, true);
  end;
end;

function TFhirSubstanceSourceMaterialOrganismAuthor.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FAuthorType) and isEmptyProp(FAuthorDescription);
end;

procedure TFhirSubstanceSourceMaterialOrganismAuthor.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('authorType');
  fields.add('authorDescription');
end;

function TFhirSubstanceSourceMaterialOrganismAuthor.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
end;

procedure TFhirSubstanceSourceMaterialOrganismAuthor.SetAuthorType(value : TFhirCodeableConcept);
begin
  FAuthorType.free;
  FAuthorType := value;
end;

procedure TFhirSubstanceSourceMaterialOrganismAuthor.SetAuthorDescription(value : TFhirString);
begin
  FAuthorDescription.free;
  FAuthorDescription := value;
end;

function TFhirSubstanceSourceMaterialOrganismAuthor.GetAuthorDescriptionST : String;
begin
  if FAuthorDescription = nil then
    result := ''
  else
    result := FAuthorDescription.value;
end;

procedure TFhirSubstanceSourceMaterialOrganismAuthor.SetAuthorDescriptionST(value : String);
begin
  if value <> '' then
  begin
    if FAuthorDescription = nil then
      FAuthorDescription := TFhirString.create;
    FAuthorDescription.value := value
  end
  else if FAuthorDescription <> nil then
    FAuthorDescription.value := '';
end;

{ TFhirSubstanceSourceMaterialOrganismAuthorListEnumerator }

constructor TFhirSubstanceSourceMaterialOrganismAuthorListEnumerator.Create(list : TFhirSubstanceSourceMaterialOrganismAuthorList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirSubstanceSourceMaterialOrganismAuthorListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirSubstanceSourceMaterialOrganismAuthorListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirSubstanceSourceMaterialOrganismAuthorListEnumerator.GetCurrent : TFhirSubstanceSourceMaterialOrganismAuthor;
begin
  Result := FList[FIndex];
end;

function TFhirSubstanceSourceMaterialOrganismAuthorListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirSubstanceSourceMaterialOrganismAuthorList }

function TFhirSubstanceSourceMaterialOrganismAuthorList.AddItem(value: TFhirSubstanceSourceMaterialOrganismAuthor): TFhirSubstanceSourceMaterialOrganismAuthor;
begin
  assert(value.ClassName = 'TFhirSubstanceSourceMaterialOrganismAuthor', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirSubstanceSourceMaterialOrganismAuthor');
  add(value);
  result := value;
end;

function TFhirSubstanceSourceMaterialOrganismAuthorList.Append: TFhirSubstanceSourceMaterialOrganismAuthor;
begin
  result := TFhirSubstanceSourceMaterialOrganismAuthor.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirSubstanceSourceMaterialOrganismAuthorList.ClearItems;
begin
  Clear;
end;

function TFhirSubstanceSourceMaterialOrganismAuthorList.GetEnumerator : TFhirSubstanceSourceMaterialOrganismAuthorListEnumerator;
begin
  result := TFhirSubstanceSourceMaterialOrganismAuthorListEnumerator.Create(self.link);
end;

function TFhirSubstanceSourceMaterialOrganismAuthorList.Clone: TFhirSubstanceSourceMaterialOrganismAuthorList;
begin
  result := TFhirSubstanceSourceMaterialOrganismAuthorList(inherited Clone);
end;

function TFhirSubstanceSourceMaterialOrganismAuthorList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirSubstanceSourceMaterialOrganismAuthorList.GetItemN(index: Integer): TFhirSubstanceSourceMaterialOrganismAuthor;
begin
  result := TFhirSubstanceSourceMaterialOrganismAuthor(ObjectByIndex[index]);
end;

function TFhirSubstanceSourceMaterialOrganismAuthorList.ItemClass: TFslObjectClass;
begin
  result := TFhirSubstanceSourceMaterialOrganismAuthor;
end;
function TFhirSubstanceSourceMaterialOrganismAuthorList.IndexOf(value: TFhirSubstanceSourceMaterialOrganismAuthor): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirSubstanceSourceMaterialOrganismAuthorList.Insert(index: Integer): TFhirSubstanceSourceMaterialOrganismAuthor;
begin
  result := TFhirSubstanceSourceMaterialOrganismAuthor.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirSubstanceSourceMaterialOrganismAuthorList.InsertItem(index: Integer; value: TFhirSubstanceSourceMaterialOrganismAuthor);
begin
  assert(value is TFhirSubstanceSourceMaterialOrganismAuthor);
  Inherited Insert(index, value);
end;

function TFhirSubstanceSourceMaterialOrganismAuthorList.Item(index: Integer): TFhirSubstanceSourceMaterialOrganismAuthor;
begin
  result := TFhirSubstanceSourceMaterialOrganismAuthor(ObjectByIndex[index]);
end;

function TFhirSubstanceSourceMaterialOrganismAuthorList.Link: TFhirSubstanceSourceMaterialOrganismAuthorList;
begin
  result := TFhirSubstanceSourceMaterialOrganismAuthorList(inherited Link);
end;

procedure TFhirSubstanceSourceMaterialOrganismAuthorList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirSubstanceSourceMaterialOrganismAuthorList.SetItemByIndex(index: Integer; value: TFhirSubstanceSourceMaterialOrganismAuthor);
begin
  assert(value is TFhirSubstanceSourceMaterialOrganismAuthor);
  FhirSubstanceSourceMaterialOrganismAuthors[index] := value;
end;

procedure TFhirSubstanceSourceMaterialOrganismAuthorList.SetItemN(index: Integer; value: TFhirSubstanceSourceMaterialOrganismAuthor);
begin
  assert(value is TFhirSubstanceSourceMaterialOrganismAuthor);
  ObjectByIndex[index] := value;
end;

{ TFhirSubstanceSourceMaterialOrganismHybrid }

constructor TFhirSubstanceSourceMaterialOrganismHybrid.Create;
begin
  inherited;
end;

destructor TFhirSubstanceSourceMaterialOrganismHybrid.Destroy;
begin
  FMaternalOrganismId.free;
  FMaternalOrganismName.free;
  FPaternalOrganismId.free;
  FPaternalOrganismName.free;
  FHybridType.free;
  inherited;
end;

procedure TFhirSubstanceSourceMaterialOrganismHybrid.Assign(oSource : TFslObject);
begin
  inherited;
  maternalOrganismIdElement := TFhirSubstanceSourceMaterialOrganismHybrid(oSource).maternalOrganismIdElement.Clone;
  maternalOrganismNameElement := TFhirSubstanceSourceMaterialOrganismHybrid(oSource).maternalOrganismNameElement.Clone;
  paternalOrganismIdElement := TFhirSubstanceSourceMaterialOrganismHybrid(oSource).paternalOrganismIdElement.Clone;
  paternalOrganismNameElement := TFhirSubstanceSourceMaterialOrganismHybrid(oSource).paternalOrganismNameElement.Clone;
  hybridType := TFhirSubstanceSourceMaterialOrganismHybrid(oSource).hybridType.Clone;
end;

procedure TFhirSubstanceSourceMaterialOrganismHybrid.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'maternalOrganismId') Then
     list.add(self.link, 'maternalOrganismId', FMaternalOrganismId.Link);
  if (child_name = 'maternalOrganismName') Then
     list.add(self.link, 'maternalOrganismName', FMaternalOrganismName.Link);
  if (child_name = 'paternalOrganismId') Then
     list.add(self.link, 'paternalOrganismId', FPaternalOrganismId.Link);
  if (child_name = 'paternalOrganismName') Then
     list.add(self.link, 'paternalOrganismName', FPaternalOrganismName.Link);
  if (child_name = 'hybridType') Then
     list.add(self.link, 'hybridType', FHybridType.Link);
end;

procedure TFhirSubstanceSourceMaterialOrganismHybrid.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'maternalOrganismId', 'string', false, TFhirString, FMaternalOrganismId.Link));
  oList.add(TFHIRProperty.create(self, 'maternalOrganismName', 'string', false, TFhirString, FMaternalOrganismName.Link));
  oList.add(TFHIRProperty.create(self, 'paternalOrganismId', 'string', false, TFhirString, FPaternalOrganismId.Link));
  oList.add(TFHIRProperty.create(self, 'paternalOrganismName', 'string', false, TFhirString, FPaternalOrganismName.Link));
  oList.add(TFHIRProperty.create(self, 'hybridType', 'CodeableConcept', false, TFhirCodeableConcept, FHybridType.Link));
end;

function TFhirSubstanceSourceMaterialOrganismHybrid.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'maternalOrganismId') then
  begin
    MaternalOrganismIdElement := asString(propValue);
    result := propValue;
  end
  else if (propName = 'maternalOrganismName') then
  begin
    MaternalOrganismNameElement := asString(propValue);
    result := propValue;
  end
  else if (propName = 'paternalOrganismId') then
  begin
    PaternalOrganismIdElement := asString(propValue);
    result := propValue;
  end
  else if (propName = 'paternalOrganismName') then
  begin
    PaternalOrganismNameElement := asString(propValue);
    result := propValue;
  end
  else if (propName = 'hybridType') then
  begin
    HybridType := propValue as TFhirCodeableConcept;
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirSubstanceSourceMaterialOrganismHybrid.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirSubstanceSourceMaterialOrganismHybrid.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'maternalOrganismId') then result := TFhirString.create()
  else if (propName = 'maternalOrganismName') then result := TFhirString.create()
  else if (propName = 'paternalOrganismId') then result := TFhirString.create()
  else if (propName = 'paternalOrganismName') then result := TFhirString.create()
  else if (propName = 'hybridType') then result := TFhirCodeableConcept.create()
  else result := inherited createPropertyValue(propName);
end;

function TFhirSubstanceSourceMaterialOrganismHybrid.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'maternalOrganismId') then result := 'string'
  else if (propName = 'maternalOrganismName') then result := 'string'
  else if (propName = 'paternalOrganismId') then result := 'string'
  else if (propName = 'paternalOrganismName') then result := 'string'
  else if (propName = 'hybridType') then result := 'CodeableConcept'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirSubstanceSourceMaterialOrganismHybrid.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'maternalOrganismId') then MaternalOrganismIdElement := nil
  else if (propName = 'maternalOrganismName') then MaternalOrganismNameElement := nil
  else if (propName = 'paternalOrganismId') then PaternalOrganismIdElement := nil
  else if (propName = 'paternalOrganismName') then PaternalOrganismNameElement := nil
  else if (propName = 'hybridType') then HybridTypeElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirSubstanceSourceMaterialOrganismHybrid.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'maternalOrganismId') then MaternalOrganismIdElement := asString(new)
  else if (propName = 'maternalOrganismName') then MaternalOrganismNameElement := asString(new)
  else if (propName = 'paternalOrganismId') then PaternalOrganismIdElement := asString(new)
  else if (propName = 'paternalOrganismName') then PaternalOrganismNameElement := asString(new)
  else if (propName = 'hybridType') then HybridTypeElement := new as TFhirCodeableConcept
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirSubstanceSourceMaterialOrganismHybrid.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirSubstanceSourceMaterialOrganismHybrid.fhirType : string;
begin
  result := 'SubstanceSourceMaterial.organism.hybrid';
end;

function TFhirSubstanceSourceMaterialOrganismHybrid.Link : TFhirSubstanceSourceMaterialOrganismHybrid;
begin
  result := TFhirSubstanceSourceMaterialOrganismHybrid(inherited Link);
end;

function TFhirSubstanceSourceMaterialOrganismHybrid.Clone : TFhirSubstanceSourceMaterialOrganismHybrid;
begin
  result := TFhirSubstanceSourceMaterialOrganismHybrid(inherited Clone);
end;

function TFhirSubstanceSourceMaterialOrganismHybrid.equals(other : TObject) : boolean; 
var
  o : TFhirSubstanceSourceMaterialOrganismHybrid;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirSubstanceSourceMaterialOrganismHybrid)) then
    result := false
  else
  begin
    o := TFhirSubstanceSourceMaterialOrganismHybrid(other);
    result := compareDeep(maternalOrganismIdElement, o.maternalOrganismIdElement, true) and 
      compareDeep(maternalOrganismNameElement, o.maternalOrganismNameElement, true) and 
      compareDeep(paternalOrganismIdElement, o.paternalOrganismIdElement, true) and 
      compareDeep(paternalOrganismNameElement, o.paternalOrganismNameElement, true) and 
      compareDeep(hybridTypeElement, o.hybridTypeElement, true);
  end;
end;

function TFhirSubstanceSourceMaterialOrganismHybrid.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FMaternalOrganismId) and isEmptyProp(FMaternalOrganismName) and isEmptyProp(FPaternalOrganismId) and isEmptyProp(FPaternalOrganismName) and isEmptyProp(FHybridType);
end;

procedure TFhirSubstanceSourceMaterialOrganismHybrid.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('maternalOrganismId');
  fields.add('maternalOrganismName');
  fields.add('paternalOrganismId');
  fields.add('paternalOrganismName');
  fields.add('hybridType');
end;

function TFhirSubstanceSourceMaterialOrganismHybrid.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
end;

procedure TFhirSubstanceSourceMaterialOrganismHybrid.SetMaternalOrganismId(value : TFhirString);
begin
  FMaternalOrganismId.free;
  FMaternalOrganismId := value;
end;

function TFhirSubstanceSourceMaterialOrganismHybrid.GetMaternalOrganismIdST : String;
begin
  if FMaternalOrganismId = nil then
    result := ''
  else
    result := FMaternalOrganismId.value;
end;

procedure TFhirSubstanceSourceMaterialOrganismHybrid.SetMaternalOrganismIdST(value : String);
begin
  if value <> '' then
  begin
    if FMaternalOrganismId = nil then
      FMaternalOrganismId := TFhirString.create;
    FMaternalOrganismId.value := value
  end
  else if FMaternalOrganismId <> nil then
    FMaternalOrganismId.value := '';
end;

procedure TFhirSubstanceSourceMaterialOrganismHybrid.SetMaternalOrganismName(value : TFhirString);
begin
  FMaternalOrganismName.free;
  FMaternalOrganismName := value;
end;

function TFhirSubstanceSourceMaterialOrganismHybrid.GetMaternalOrganismNameST : String;
begin
  if FMaternalOrganismName = nil then
    result := ''
  else
    result := FMaternalOrganismName.value;
end;

procedure TFhirSubstanceSourceMaterialOrganismHybrid.SetMaternalOrganismNameST(value : String);
begin
  if value <> '' then
  begin
    if FMaternalOrganismName = nil then
      FMaternalOrganismName := TFhirString.create;
    FMaternalOrganismName.value := value
  end
  else if FMaternalOrganismName <> nil then
    FMaternalOrganismName.value := '';
end;

procedure TFhirSubstanceSourceMaterialOrganismHybrid.SetPaternalOrganismId(value : TFhirString);
begin
  FPaternalOrganismId.free;
  FPaternalOrganismId := value;
end;

function TFhirSubstanceSourceMaterialOrganismHybrid.GetPaternalOrganismIdST : String;
begin
  if FPaternalOrganismId = nil then
    result := ''
  else
    result := FPaternalOrganismId.value;
end;

procedure TFhirSubstanceSourceMaterialOrganismHybrid.SetPaternalOrganismIdST(value : String);
begin
  if value <> '' then
  begin
    if FPaternalOrganismId = nil then
      FPaternalOrganismId := TFhirString.create;
    FPaternalOrganismId.value := value
  end
  else if FPaternalOrganismId <> nil then
    FPaternalOrganismId.value := '';
end;

procedure TFhirSubstanceSourceMaterialOrganismHybrid.SetPaternalOrganismName(value : TFhirString);
begin
  FPaternalOrganismName.free;
  FPaternalOrganismName := value;
end;

function TFhirSubstanceSourceMaterialOrganismHybrid.GetPaternalOrganismNameST : String;
begin
  if FPaternalOrganismName = nil then
    result := ''
  else
    result := FPaternalOrganismName.value;
end;

procedure TFhirSubstanceSourceMaterialOrganismHybrid.SetPaternalOrganismNameST(value : String);
begin
  if value <> '' then
  begin
    if FPaternalOrganismName = nil then
      FPaternalOrganismName := TFhirString.create;
    FPaternalOrganismName.value := value
  end
  else if FPaternalOrganismName <> nil then
    FPaternalOrganismName.value := '';
end;

procedure TFhirSubstanceSourceMaterialOrganismHybrid.SetHybridType(value : TFhirCodeableConcept);
begin
  FHybridType.free;
  FHybridType := value;
end;

{ TFhirSubstanceSourceMaterialOrganismHybridListEnumerator }

constructor TFhirSubstanceSourceMaterialOrganismHybridListEnumerator.Create(list : TFhirSubstanceSourceMaterialOrganismHybridList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirSubstanceSourceMaterialOrganismHybridListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirSubstanceSourceMaterialOrganismHybridListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirSubstanceSourceMaterialOrganismHybridListEnumerator.GetCurrent : TFhirSubstanceSourceMaterialOrganismHybrid;
begin
  Result := FList[FIndex];
end;

function TFhirSubstanceSourceMaterialOrganismHybridListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirSubstanceSourceMaterialOrganismHybridList }

function TFhirSubstanceSourceMaterialOrganismHybridList.AddItem(value: TFhirSubstanceSourceMaterialOrganismHybrid): TFhirSubstanceSourceMaterialOrganismHybrid;
begin
  assert(value.ClassName = 'TFhirSubstanceSourceMaterialOrganismHybrid', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirSubstanceSourceMaterialOrganismHybrid');
  add(value);
  result := value;
end;

function TFhirSubstanceSourceMaterialOrganismHybridList.Append: TFhirSubstanceSourceMaterialOrganismHybrid;
begin
  result := TFhirSubstanceSourceMaterialOrganismHybrid.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirSubstanceSourceMaterialOrganismHybridList.ClearItems;
begin
  Clear;
end;

function TFhirSubstanceSourceMaterialOrganismHybridList.GetEnumerator : TFhirSubstanceSourceMaterialOrganismHybridListEnumerator;
begin
  result := TFhirSubstanceSourceMaterialOrganismHybridListEnumerator.Create(self.link);
end;

function TFhirSubstanceSourceMaterialOrganismHybridList.Clone: TFhirSubstanceSourceMaterialOrganismHybridList;
begin
  result := TFhirSubstanceSourceMaterialOrganismHybridList(inherited Clone);
end;

function TFhirSubstanceSourceMaterialOrganismHybridList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirSubstanceSourceMaterialOrganismHybridList.GetItemN(index: Integer): TFhirSubstanceSourceMaterialOrganismHybrid;
begin
  result := TFhirSubstanceSourceMaterialOrganismHybrid(ObjectByIndex[index]);
end;

function TFhirSubstanceSourceMaterialOrganismHybridList.ItemClass: TFslObjectClass;
begin
  result := TFhirSubstanceSourceMaterialOrganismHybrid;
end;
function TFhirSubstanceSourceMaterialOrganismHybridList.IndexOf(value: TFhirSubstanceSourceMaterialOrganismHybrid): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirSubstanceSourceMaterialOrganismHybridList.Insert(index: Integer): TFhirSubstanceSourceMaterialOrganismHybrid;
begin
  result := TFhirSubstanceSourceMaterialOrganismHybrid.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirSubstanceSourceMaterialOrganismHybridList.InsertItem(index: Integer; value: TFhirSubstanceSourceMaterialOrganismHybrid);
begin
  assert(value is TFhirSubstanceSourceMaterialOrganismHybrid);
  Inherited Insert(index, value);
end;

function TFhirSubstanceSourceMaterialOrganismHybridList.Item(index: Integer): TFhirSubstanceSourceMaterialOrganismHybrid;
begin
  result := TFhirSubstanceSourceMaterialOrganismHybrid(ObjectByIndex[index]);
end;

function TFhirSubstanceSourceMaterialOrganismHybridList.Link: TFhirSubstanceSourceMaterialOrganismHybridList;
begin
  result := TFhirSubstanceSourceMaterialOrganismHybridList(inherited Link);
end;

procedure TFhirSubstanceSourceMaterialOrganismHybridList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirSubstanceSourceMaterialOrganismHybridList.SetItemByIndex(index: Integer; value: TFhirSubstanceSourceMaterialOrganismHybrid);
begin
  assert(value is TFhirSubstanceSourceMaterialOrganismHybrid);
  FhirSubstanceSourceMaterialOrganismHybrids[index] := value;
end;

procedure TFhirSubstanceSourceMaterialOrganismHybridList.SetItemN(index: Integer; value: TFhirSubstanceSourceMaterialOrganismHybrid);
begin
  assert(value is TFhirSubstanceSourceMaterialOrganismHybrid);
  ObjectByIndex[index] := value;
end;

{ TFhirSubstanceSourceMaterialOrganismOrganismGeneral }

constructor TFhirSubstanceSourceMaterialOrganismOrganismGeneral.Create;
begin
  inherited;
end;

destructor TFhirSubstanceSourceMaterialOrganismOrganismGeneral.Destroy;
begin
  FKingdom.free;
  FPhylum.free;
  FClass_.free;
  FOrder.free;
  inherited;
end;

procedure TFhirSubstanceSourceMaterialOrganismOrganismGeneral.Assign(oSource : TFslObject);
begin
  inherited;
  kingdom := TFhirSubstanceSourceMaterialOrganismOrganismGeneral(oSource).kingdom.Clone;
  phylum := TFhirSubstanceSourceMaterialOrganismOrganismGeneral(oSource).phylum.Clone;
  class_ := TFhirSubstanceSourceMaterialOrganismOrganismGeneral(oSource).class_.Clone;
  order := TFhirSubstanceSourceMaterialOrganismOrganismGeneral(oSource).order.Clone;
end;

procedure TFhirSubstanceSourceMaterialOrganismOrganismGeneral.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'kingdom') Then
     list.add(self.link, 'kingdom', FKingdom.Link);
  if (child_name = 'phylum') Then
     list.add(self.link, 'phylum', FPhylum.Link);
  if (child_name = 'class') Then
     list.add(self.link, 'class', FClass_.Link);
  if (child_name = 'order') Then
     list.add(self.link, 'order', FOrder.Link);
end;

procedure TFhirSubstanceSourceMaterialOrganismOrganismGeneral.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'kingdom', 'CodeableConcept', false, TFhirCodeableConcept, FKingdom.Link));
  oList.add(TFHIRProperty.create(self, 'phylum', 'CodeableConcept', false, TFhirCodeableConcept, FPhylum.Link));
  oList.add(TFHIRProperty.create(self, 'class', 'CodeableConcept', false, TFhirCodeableConcept, FClass_.Link));
  oList.add(TFHIRProperty.create(self, 'order', 'CodeableConcept', false, TFhirCodeableConcept, FOrder.Link));
end;

function TFhirSubstanceSourceMaterialOrganismOrganismGeneral.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'kingdom') then
  begin
    Kingdom := propValue as TFhirCodeableConcept;
    result := propValue;
  end
  else if (propName = 'phylum') then
  begin
    Phylum := propValue as TFhirCodeableConcept;
    result := propValue;
  end
  else if (propName = 'class') then
  begin
    Class_ := propValue as TFhirCodeableConcept;
    result := propValue;
  end
  else if (propName = 'order') then
  begin
    Order := propValue as TFhirCodeableConcept;
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirSubstanceSourceMaterialOrganismOrganismGeneral.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirSubstanceSourceMaterialOrganismOrganismGeneral.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'kingdom') then result := TFhirCodeableConcept.create()
  else if (propName = 'phylum') then result := TFhirCodeableConcept.create()
  else if (propName = 'class') then result := TFhirCodeableConcept.create()
  else if (propName = 'order') then result := TFhirCodeableConcept.create()
  else result := inherited createPropertyValue(propName);
end;

function TFhirSubstanceSourceMaterialOrganismOrganismGeneral.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'kingdom') then result := 'CodeableConcept'
  else if (propName = 'phylum') then result := 'CodeableConcept'
  else if (propName = 'class') then result := 'CodeableConcept'
  else if (propName = 'order') then result := 'CodeableConcept'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirSubstanceSourceMaterialOrganismOrganismGeneral.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'kingdom') then KingdomElement := nil
  else if (propName = 'phylum') then PhylumElement := nil
  else if (propName = 'class') then Class_Element := nil
  else if (propName = 'order') then OrderElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirSubstanceSourceMaterialOrganismOrganismGeneral.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'kingdom') then KingdomElement := new as TFhirCodeableConcept
  else if (propName = 'phylum') then PhylumElement := new as TFhirCodeableConcept
  else if (propName = 'class') then Class_Element := new as TFhirCodeableConcept
  else if (propName = 'order') then OrderElement := new as TFhirCodeableConcept
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirSubstanceSourceMaterialOrganismOrganismGeneral.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirSubstanceSourceMaterialOrganismOrganismGeneral.fhirType : string;
begin
  result := 'SubstanceSourceMaterial.organism.organismGeneral';
end;

function TFhirSubstanceSourceMaterialOrganismOrganismGeneral.Link : TFhirSubstanceSourceMaterialOrganismOrganismGeneral;
begin
  result := TFhirSubstanceSourceMaterialOrganismOrganismGeneral(inherited Link);
end;

function TFhirSubstanceSourceMaterialOrganismOrganismGeneral.Clone : TFhirSubstanceSourceMaterialOrganismOrganismGeneral;
begin
  result := TFhirSubstanceSourceMaterialOrganismOrganismGeneral(inherited Clone);
end;

function TFhirSubstanceSourceMaterialOrganismOrganismGeneral.equals(other : TObject) : boolean; 
var
  o : TFhirSubstanceSourceMaterialOrganismOrganismGeneral;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirSubstanceSourceMaterialOrganismOrganismGeneral)) then
    result := false
  else
  begin
    o := TFhirSubstanceSourceMaterialOrganismOrganismGeneral(other);
    result := compareDeep(kingdomElement, o.kingdomElement, true) and compareDeep(phylumElement, o.phylumElement, true) and 
      compareDeep(class_Element, o.class_Element, true) and compareDeep(orderElement, o.orderElement, true);
  end;
end;

function TFhirSubstanceSourceMaterialOrganismOrganismGeneral.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FKingdom) and isEmptyProp(FPhylum) and isEmptyProp(FClass_) and isEmptyProp(FOrder);
end;

procedure TFhirSubstanceSourceMaterialOrganismOrganismGeneral.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('kingdom');
  fields.add('phylum');
  fields.add('class');
  fields.add('order');
end;

function TFhirSubstanceSourceMaterialOrganismOrganismGeneral.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
end;

procedure TFhirSubstanceSourceMaterialOrganismOrganismGeneral.SetKingdom(value : TFhirCodeableConcept);
begin
  FKingdom.free;
  FKingdom := value;
end;

procedure TFhirSubstanceSourceMaterialOrganismOrganismGeneral.SetPhylum(value : TFhirCodeableConcept);
begin
  FPhylum.free;
  FPhylum := value;
end;

procedure TFhirSubstanceSourceMaterialOrganismOrganismGeneral.SetClass_(value : TFhirCodeableConcept);
begin
  FClass_.free;
  FClass_ := value;
end;

procedure TFhirSubstanceSourceMaterialOrganismOrganismGeneral.SetOrder(value : TFhirCodeableConcept);
begin
  FOrder.free;
  FOrder := value;
end;

{ TFhirSubstanceSourceMaterialOrganismOrganismGeneralListEnumerator }

constructor TFhirSubstanceSourceMaterialOrganismOrganismGeneralListEnumerator.Create(list : TFhirSubstanceSourceMaterialOrganismOrganismGeneralList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirSubstanceSourceMaterialOrganismOrganismGeneralListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirSubstanceSourceMaterialOrganismOrganismGeneralListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirSubstanceSourceMaterialOrganismOrganismGeneralListEnumerator.GetCurrent : TFhirSubstanceSourceMaterialOrganismOrganismGeneral;
begin
  Result := FList[FIndex];
end;

function TFhirSubstanceSourceMaterialOrganismOrganismGeneralListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirSubstanceSourceMaterialOrganismOrganismGeneralList }

function TFhirSubstanceSourceMaterialOrganismOrganismGeneralList.AddItem(value: TFhirSubstanceSourceMaterialOrganismOrganismGeneral): TFhirSubstanceSourceMaterialOrganismOrganismGeneral;
begin
  assert(value.ClassName = 'TFhirSubstanceSourceMaterialOrganismOrganismGeneral', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirSubstanceSourceMaterialOrganismOrganismGeneral');
  add(value);
  result := value;
end;

function TFhirSubstanceSourceMaterialOrganismOrganismGeneralList.Append: TFhirSubstanceSourceMaterialOrganismOrganismGeneral;
begin
  result := TFhirSubstanceSourceMaterialOrganismOrganismGeneral.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirSubstanceSourceMaterialOrganismOrganismGeneralList.ClearItems;
begin
  Clear;
end;

function TFhirSubstanceSourceMaterialOrganismOrganismGeneralList.GetEnumerator : TFhirSubstanceSourceMaterialOrganismOrganismGeneralListEnumerator;
begin
  result := TFhirSubstanceSourceMaterialOrganismOrganismGeneralListEnumerator.Create(self.link);
end;

function TFhirSubstanceSourceMaterialOrganismOrganismGeneralList.Clone: TFhirSubstanceSourceMaterialOrganismOrganismGeneralList;
begin
  result := TFhirSubstanceSourceMaterialOrganismOrganismGeneralList(inherited Clone);
end;

function TFhirSubstanceSourceMaterialOrganismOrganismGeneralList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirSubstanceSourceMaterialOrganismOrganismGeneralList.GetItemN(index: Integer): TFhirSubstanceSourceMaterialOrganismOrganismGeneral;
begin
  result := TFhirSubstanceSourceMaterialOrganismOrganismGeneral(ObjectByIndex[index]);
end;

function TFhirSubstanceSourceMaterialOrganismOrganismGeneralList.ItemClass: TFslObjectClass;
begin
  result := TFhirSubstanceSourceMaterialOrganismOrganismGeneral;
end;
function TFhirSubstanceSourceMaterialOrganismOrganismGeneralList.IndexOf(value: TFhirSubstanceSourceMaterialOrganismOrganismGeneral): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirSubstanceSourceMaterialOrganismOrganismGeneralList.Insert(index: Integer): TFhirSubstanceSourceMaterialOrganismOrganismGeneral;
begin
  result := TFhirSubstanceSourceMaterialOrganismOrganismGeneral.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirSubstanceSourceMaterialOrganismOrganismGeneralList.InsertItem(index: Integer; value: TFhirSubstanceSourceMaterialOrganismOrganismGeneral);
begin
  assert(value is TFhirSubstanceSourceMaterialOrganismOrganismGeneral);
  Inherited Insert(index, value);
end;

function TFhirSubstanceSourceMaterialOrganismOrganismGeneralList.Item(index: Integer): TFhirSubstanceSourceMaterialOrganismOrganismGeneral;
begin
  result := TFhirSubstanceSourceMaterialOrganismOrganismGeneral(ObjectByIndex[index]);
end;

function TFhirSubstanceSourceMaterialOrganismOrganismGeneralList.Link: TFhirSubstanceSourceMaterialOrganismOrganismGeneralList;
begin
  result := TFhirSubstanceSourceMaterialOrganismOrganismGeneralList(inherited Link);
end;

procedure TFhirSubstanceSourceMaterialOrganismOrganismGeneralList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirSubstanceSourceMaterialOrganismOrganismGeneralList.SetItemByIndex(index: Integer; value: TFhirSubstanceSourceMaterialOrganismOrganismGeneral);
begin
  assert(value is TFhirSubstanceSourceMaterialOrganismOrganismGeneral);
  FhirSubstanceSourceMaterialOrganismOrganismGenerals[index] := value;
end;

procedure TFhirSubstanceSourceMaterialOrganismOrganismGeneralList.SetItemN(index: Integer; value: TFhirSubstanceSourceMaterialOrganismOrganismGeneral);
begin
  assert(value is TFhirSubstanceSourceMaterialOrganismOrganismGeneral);
  ObjectByIndex[index] := value;
end;

{ TFhirSubstanceSourceMaterialPartDescription }

constructor TFhirSubstanceSourceMaterialPartDescription.Create;
begin
  inherited;
end;

destructor TFhirSubstanceSourceMaterialPartDescription.Destroy;
begin
  FPart.free;
  FPartLocation.free;
  inherited;
end;

procedure TFhirSubstanceSourceMaterialPartDescription.Assign(oSource : TFslObject);
begin
  inherited;
  part := TFhirSubstanceSourceMaterialPartDescription(oSource).part.Clone;
  partLocation := TFhirSubstanceSourceMaterialPartDescription(oSource).partLocation.Clone;
end;

procedure TFhirSubstanceSourceMaterialPartDescription.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'part') Then
     list.add(self.link, 'part', FPart.Link);
  if (child_name = 'partLocation') Then
     list.add(self.link, 'partLocation', FPartLocation.Link);
end;

procedure TFhirSubstanceSourceMaterialPartDescription.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'part', 'CodeableConcept', false, TFhirCodeableConcept, FPart.Link));
  oList.add(TFHIRProperty.create(self, 'partLocation', 'CodeableConcept', false, TFhirCodeableConcept, FPartLocation.Link));
end;

function TFhirSubstanceSourceMaterialPartDescription.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'part') then
  begin
    Part := propValue as TFhirCodeableConcept;
    result := propValue;
  end
  else if (propName = 'partLocation') then
  begin
    PartLocation := propValue as TFhirCodeableConcept;
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirSubstanceSourceMaterialPartDescription.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirSubstanceSourceMaterialPartDescription.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'part') then result := TFhirCodeableConcept.create()
  else if (propName = 'partLocation') then result := TFhirCodeableConcept.create()
  else result := inherited createPropertyValue(propName);
end;

function TFhirSubstanceSourceMaterialPartDescription.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'part') then result := 'CodeableConcept'
  else if (propName = 'partLocation') then result := 'CodeableConcept'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirSubstanceSourceMaterialPartDescription.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'part') then PartElement := nil
  else if (propName = 'partLocation') then PartLocationElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirSubstanceSourceMaterialPartDescription.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'part') then PartElement := new as TFhirCodeableConcept
  else if (propName = 'partLocation') then PartLocationElement := new as TFhirCodeableConcept
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirSubstanceSourceMaterialPartDescription.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirSubstanceSourceMaterialPartDescription.fhirType : string;
begin
  result := 'SubstanceSourceMaterial.partDescription';
end;

function TFhirSubstanceSourceMaterialPartDescription.Link : TFhirSubstanceSourceMaterialPartDescription;
begin
  result := TFhirSubstanceSourceMaterialPartDescription(inherited Link);
end;

function TFhirSubstanceSourceMaterialPartDescription.Clone : TFhirSubstanceSourceMaterialPartDescription;
begin
  result := TFhirSubstanceSourceMaterialPartDescription(inherited Clone);
end;

function TFhirSubstanceSourceMaterialPartDescription.equals(other : TObject) : boolean; 
var
  o : TFhirSubstanceSourceMaterialPartDescription;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirSubstanceSourceMaterialPartDescription)) then
    result := false
  else
  begin
    o := TFhirSubstanceSourceMaterialPartDescription(other);
    result := compareDeep(partElement, o.partElement, true) and compareDeep(partLocationElement, o.partLocationElement, true);
  end;
end;

function TFhirSubstanceSourceMaterialPartDescription.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FPart) and isEmptyProp(FPartLocation);
end;

procedure TFhirSubstanceSourceMaterialPartDescription.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('part');
  fields.add('partLocation');
end;

function TFhirSubstanceSourceMaterialPartDescription.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
end;

procedure TFhirSubstanceSourceMaterialPartDescription.SetPart(value : TFhirCodeableConcept);
begin
  FPart.free;
  FPart := value;
end;

procedure TFhirSubstanceSourceMaterialPartDescription.SetPartLocation(value : TFhirCodeableConcept);
begin
  FPartLocation.free;
  FPartLocation := value;
end;

{ TFhirSubstanceSourceMaterialPartDescriptionListEnumerator }

constructor TFhirSubstanceSourceMaterialPartDescriptionListEnumerator.Create(list : TFhirSubstanceSourceMaterialPartDescriptionList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirSubstanceSourceMaterialPartDescriptionListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirSubstanceSourceMaterialPartDescriptionListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirSubstanceSourceMaterialPartDescriptionListEnumerator.GetCurrent : TFhirSubstanceSourceMaterialPartDescription;
begin
  Result := FList[FIndex];
end;

function TFhirSubstanceSourceMaterialPartDescriptionListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirSubstanceSourceMaterialPartDescriptionList }

function TFhirSubstanceSourceMaterialPartDescriptionList.AddItem(value: TFhirSubstanceSourceMaterialPartDescription): TFhirSubstanceSourceMaterialPartDescription;
begin
  assert(value.ClassName = 'TFhirSubstanceSourceMaterialPartDescription', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirSubstanceSourceMaterialPartDescription');
  add(value);
  result := value;
end;

function TFhirSubstanceSourceMaterialPartDescriptionList.Append: TFhirSubstanceSourceMaterialPartDescription;
begin
  result := TFhirSubstanceSourceMaterialPartDescription.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirSubstanceSourceMaterialPartDescriptionList.ClearItems;
begin
  Clear;
end;

function TFhirSubstanceSourceMaterialPartDescriptionList.GetEnumerator : TFhirSubstanceSourceMaterialPartDescriptionListEnumerator;
begin
  result := TFhirSubstanceSourceMaterialPartDescriptionListEnumerator.Create(self.link);
end;

function TFhirSubstanceSourceMaterialPartDescriptionList.Clone: TFhirSubstanceSourceMaterialPartDescriptionList;
begin
  result := TFhirSubstanceSourceMaterialPartDescriptionList(inherited Clone);
end;

function TFhirSubstanceSourceMaterialPartDescriptionList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirSubstanceSourceMaterialPartDescriptionList.GetItemN(index: Integer): TFhirSubstanceSourceMaterialPartDescription;
begin
  result := TFhirSubstanceSourceMaterialPartDescription(ObjectByIndex[index]);
end;

function TFhirSubstanceSourceMaterialPartDescriptionList.ItemClass: TFslObjectClass;
begin
  result := TFhirSubstanceSourceMaterialPartDescription;
end;
function TFhirSubstanceSourceMaterialPartDescriptionList.IndexOf(value: TFhirSubstanceSourceMaterialPartDescription): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirSubstanceSourceMaterialPartDescriptionList.Insert(index: Integer): TFhirSubstanceSourceMaterialPartDescription;
begin
  result := TFhirSubstanceSourceMaterialPartDescription.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirSubstanceSourceMaterialPartDescriptionList.InsertItem(index: Integer; value: TFhirSubstanceSourceMaterialPartDescription);
begin
  assert(value is TFhirSubstanceSourceMaterialPartDescription);
  Inherited Insert(index, value);
end;

function TFhirSubstanceSourceMaterialPartDescriptionList.Item(index: Integer): TFhirSubstanceSourceMaterialPartDescription;
begin
  result := TFhirSubstanceSourceMaterialPartDescription(ObjectByIndex[index]);
end;

function TFhirSubstanceSourceMaterialPartDescriptionList.Link: TFhirSubstanceSourceMaterialPartDescriptionList;
begin
  result := TFhirSubstanceSourceMaterialPartDescriptionList(inherited Link);
end;

procedure TFhirSubstanceSourceMaterialPartDescriptionList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirSubstanceSourceMaterialPartDescriptionList.SetItemByIndex(index: Integer; value: TFhirSubstanceSourceMaterialPartDescription);
begin
  assert(value is TFhirSubstanceSourceMaterialPartDescription);
  FhirSubstanceSourceMaterialPartDescriptions[index] := value;
end;

procedure TFhirSubstanceSourceMaterialPartDescriptionList.SetItemN(index: Integer; value: TFhirSubstanceSourceMaterialPartDescription);
begin
  assert(value is TFhirSubstanceSourceMaterialPartDescription);
  ObjectByIndex[index] := value;
end;

{ TFhirSubstanceSourceMaterial }

constructor TFhirSubstanceSourceMaterial.Create;
begin
  inherited;
end;

destructor TFhirSubstanceSourceMaterial.Destroy;
begin
  FSourceMaterialClass.free;
  FSourceMaterialType.free;
  FSourceMaterialState.free;
  FOrganismId.free;
  FOrganismName.free;
  FParentSubstanceIdList.Free;
  FParentSubstanceNameList.Free;
  FCountryOfOriginList.Free;
  FGeographicalLocationList.Free;
  FDevelopmentStage.free;
  FFractionDescriptionList.Free;
  FOrganism.free;
  FPartDescriptionList.Free;
  inherited;
end;

procedure TFhirSubstanceSourceMaterial.Assign(oSource : TFslObject);
begin
  inherited;
  sourceMaterialClass := TFhirSubstanceSourceMaterial(oSource).sourceMaterialClass.Clone;
  sourceMaterialType := TFhirSubstanceSourceMaterial(oSource).sourceMaterialType.Clone;
  sourceMaterialState := TFhirSubstanceSourceMaterial(oSource).sourceMaterialState.Clone;
  organismId := TFhirSubstanceSourceMaterial(oSource).organismId.Clone;
  organismNameElement := TFhirSubstanceSourceMaterial(oSource).organismNameElement.Clone;
  if (TFhirSubstanceSourceMaterial(oSource).FParentSubstanceIdList = nil) then
  begin
    FParentSubstanceIdList.free;
    FParentSubstanceIdList := nil;
  end
  else
  begin
    if FParentSubstanceIdList = nil then
      FParentSubstanceIdList := TFhirIdentifierList.Create;
    FParentSubstanceIdList.Assign(TFhirSubstanceSourceMaterial(oSource).FParentSubstanceIdList);
  end;
  if (TFhirSubstanceSourceMaterial(oSource).FParentSubstanceNameList = nil) then
  begin
    FParentSubstanceNameList.free;
    FParentSubstanceNameList := nil;
  end
  else
  begin
    if FParentSubstanceNameList = nil then
      FParentSubstanceNameList := TFhirStringList.Create;
    FParentSubstanceNameList.Assign(TFhirSubstanceSourceMaterial(oSource).FParentSubstanceNameList);
  end;
  if (TFhirSubstanceSourceMaterial(oSource).FCountryOfOriginList = nil) then
  begin
    FCountryOfOriginList.free;
    FCountryOfOriginList := nil;
  end
  else
  begin
    if FCountryOfOriginList = nil then
      FCountryOfOriginList := TFhirCodeableConceptList.Create;
    FCountryOfOriginList.Assign(TFhirSubstanceSourceMaterial(oSource).FCountryOfOriginList);
  end;
  if (TFhirSubstanceSourceMaterial(oSource).FGeographicalLocationList = nil) then
  begin
    FGeographicalLocationList.free;
    FGeographicalLocationList := nil;
  end
  else
  begin
    if FGeographicalLocationList = nil then
      FGeographicalLocationList := TFhirStringList.Create;
    FGeographicalLocationList.Assign(TFhirSubstanceSourceMaterial(oSource).FGeographicalLocationList);
  end;
  developmentStage := TFhirSubstanceSourceMaterial(oSource).developmentStage.Clone;
  if (TFhirSubstanceSourceMaterial(oSource).FFractionDescriptionList = nil) then
  begin
    FFractionDescriptionList.free;
    FFractionDescriptionList := nil;
  end
  else
  begin
    if FFractionDescriptionList = nil then
      FFractionDescriptionList := TFhirSubstanceSourceMaterialFractionDescriptionList.Create;
    FFractionDescriptionList.Assign(TFhirSubstanceSourceMaterial(oSource).FFractionDescriptionList);
  end;
  organism := TFhirSubstanceSourceMaterial(oSource).organism.Clone;
  if (TFhirSubstanceSourceMaterial(oSource).FPartDescriptionList = nil) then
  begin
    FPartDescriptionList.free;
    FPartDescriptionList := nil;
  end
  else
  begin
    if FPartDescriptionList = nil then
      FPartDescriptionList := TFhirSubstanceSourceMaterialPartDescriptionList.Create;
    FPartDescriptionList.Assign(TFhirSubstanceSourceMaterial(oSource).FPartDescriptionList);
  end;
end;

function TFhirSubstanceSourceMaterial.GetResourceType : TFhirResourceType;
begin
  result := frtSubstanceSourceMaterial;
end;

procedure TFhirSubstanceSourceMaterial.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'sourceMaterialClass') Then
     list.add(self.link, 'sourceMaterialClass', FSourceMaterialClass.Link);
  if (child_name = 'sourceMaterialType') Then
     list.add(self.link, 'sourceMaterialType', FSourceMaterialType.Link);
  if (child_name = 'sourceMaterialState') Then
     list.add(self.link, 'sourceMaterialState', FSourceMaterialState.Link);
  if (child_name = 'organismId') Then
     list.add(self.link, 'organismId', FOrganismId.Link);
  if (child_name = 'organismName') Then
     list.add(self.link, 'organismName', FOrganismName.Link);
  if (child_name = 'parentSubstanceId') Then
    list.addAll(self, 'parentSubstanceId', FParentSubstanceIdList);
  if (child_name = 'parentSubstanceName') Then
    list.addAll(self, 'parentSubstanceName', FParentSubstanceNameList);
  if (child_name = 'countryOfOrigin') Then
    list.addAll(self, 'countryOfOrigin', FCountryOfOriginList);
  if (child_name = 'geographicalLocation') Then
    list.addAll(self, 'geographicalLocation', FGeographicalLocationList);
  if (child_name = 'developmentStage') Then
     list.add(self.link, 'developmentStage', FDevelopmentStage.Link);
  if (child_name = 'fractionDescription') Then
    list.addAll(self, 'fractionDescription', FFractionDescriptionList);
  if (child_name = 'organism') Then
     list.add(self.link, 'organism', FOrganism.Link);
  if (child_name = 'partDescription') Then
    list.addAll(self, 'partDescription', FPartDescriptionList);
end;

procedure TFhirSubstanceSourceMaterial.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'sourceMaterialClass', 'CodeableConcept', false, TFhirCodeableConcept, FSourceMaterialClass.Link));
  oList.add(TFHIRProperty.create(self, 'sourceMaterialType', 'CodeableConcept', false, TFhirCodeableConcept, FSourceMaterialType.Link));
  oList.add(TFHIRProperty.create(self, 'sourceMaterialState', 'CodeableConcept', false, TFhirCodeableConcept, FSourceMaterialState.Link));
  oList.add(TFHIRProperty.create(self, 'organismId', 'Identifier', false, TFhirIdentifier, FOrganismId.Link));
  oList.add(TFHIRProperty.create(self, 'organismName', 'string', false, TFhirString, FOrganismName.Link));
  oList.add(TFHIRProperty.create(self, 'parentSubstanceId', 'Identifier', true, TFhirIdentifier, FParentSubstanceIdList.Link));
  oList.add(TFHIRProperty.create(self, 'parentSubstanceName', 'string', true, TFhirString, FParentSubstanceNameList.Link));
  oList.add(TFHIRProperty.create(self, 'countryOfOrigin', 'CodeableConcept', true, TFhirCodeableConcept, FCountryOfOriginList.Link));
  oList.add(TFHIRProperty.create(self, 'geographicalLocation', 'string', true, TFhirString, FGeographicalLocationList.Link));
  oList.add(TFHIRProperty.create(self, 'developmentStage', 'CodeableConcept', false, TFhirCodeableConcept, FDevelopmentStage.Link));
  oList.add(TFHIRProperty.create(self, 'fractionDescription', 'BackboneElement', true, TFhirSubstanceSourceMaterialFractionDescription, FFractionDescriptionList.Link));
  oList.add(TFHIRProperty.create(self, 'organism', 'BackboneElement', false, TFhirSubstanceSourceMaterialOrganism, FOrganism.Link));
  oList.add(TFHIRProperty.create(self, 'partDescription', 'BackboneElement', true, TFhirSubstanceSourceMaterialPartDescription, FPartDescriptionList.Link));
end;

function TFhirSubstanceSourceMaterial.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'sourceMaterialClass') then
  begin
    SourceMaterialClass := propValue as TFhirCodeableConcept;
    result := propValue;
  end
  else if (propName = 'sourceMaterialType') then
  begin
    SourceMaterialType := propValue as TFhirCodeableConcept;
    result := propValue;
  end
  else if (propName = 'sourceMaterialState') then
  begin
    SourceMaterialState := propValue as TFhirCodeableConcept;
    result := propValue;
  end
  else if (propName = 'organismId') then
  begin
    OrganismId := propValue as TFhirIdentifier;
    result := propValue;
  end
  else if (propName = 'organismName') then
  begin
    OrganismNameElement := asString(propValue);
    result := propValue;
  end
  else if (propName = 'parentSubstanceId') then
  begin
    ParentSubstanceIdList.add(propValue as TFhirIdentifier);
    result := propValue;
  end
  else if (propName = 'parentSubstanceName') then
  begin
    ParentSubstanceNameList.add(asString(propValue)){2};     result := propValue;

  end
  else if (propName = 'countryOfOrigin') then
  begin
    CountryOfOriginList.add(propValue as TFhirCodeableConcept);
    result := propValue;
  end
  else if (propName = 'geographicalLocation') then
  begin
    GeographicalLocationList.add(asString(propValue)){2};     result := propValue;

  end
  else if (propName = 'developmentStage') then
  begin
    DevelopmentStage := propValue as TFhirCodeableConcept;
    result := propValue;
  end
  else if (propName = 'fractionDescription') then
  begin
    FractionDescriptionList.add(propValue as TFhirSubstanceSourceMaterialFractionDescription);
    result := propValue;
  end
  else if (propName = 'organism') then
  begin
    Organism := propValue as TFhirSubstanceSourceMaterialOrganism;
    result := propValue;
  end
  else if (propName = 'partDescription') then
  begin
    PartDescriptionList.add(propValue as TFhirSubstanceSourceMaterialPartDescription);
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirSubstanceSourceMaterial.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'parentSubstanceId') then ParentSubstanceIdList.insertItem(index, propValue as TFhirIdentifier)
  else if (propName = 'parentSubstanceName') then ParentSubstanceNameList.insertItem(index, asString(propValue))
  else if (propName = 'countryOfOrigin') then CountryOfOriginList.insertItem(index, propValue as TFhirCodeableConcept)
  else if (propName = 'geographicalLocation') then GeographicalLocationList.insertItem(index, asString(propValue))
  else if (propName = 'fractionDescription') then FractionDescriptionList.insertItem(index, propValue as TFhirSubstanceSourceMaterialFractionDescription)
  else if (propName = 'partDescription') then PartDescriptionList.insertItem(index, propValue as TFhirSubstanceSourceMaterialPartDescription)
  else inherited;
end;

function TFhirSubstanceSourceMaterial.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'sourceMaterialClass') then result := TFhirCodeableConcept.create()
  else if (propName = 'sourceMaterialType') then result := TFhirCodeableConcept.create()
  else if (propName = 'sourceMaterialState') then result := TFhirCodeableConcept.create()
  else if (propName = 'organismId') then result := TFhirIdentifier.create()
  else if (propName = 'organismName') then result := TFhirString.create()
  else if (propName = 'parentSubstanceId') then result := ParentSubstanceIdList.new()
  else if (propName = 'parentSubstanceName') then result := ParentSubstanceNameList.new()
  else if (propName = 'countryOfOrigin') then result := CountryOfOriginList.new()
  else if (propName = 'geographicalLocation') then result := GeographicalLocationList.new()
  else if (propName = 'developmentStage') then result := TFhirCodeableConcept.create()
  else if (propName = 'fractionDescription') then result := FractionDescriptionList.new()
  else if (propName = 'organism') then result := TFhirSubstanceSourceMaterialOrganism.create()
  else if (propName = 'partDescription') then result := PartDescriptionList.new()
  else result := inherited createPropertyValue(propName);
end;

function TFhirSubstanceSourceMaterial.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'sourceMaterialClass') then result := 'CodeableConcept'
  else if (propName = 'sourceMaterialType') then result := 'CodeableConcept'
  else if (propName = 'sourceMaterialState') then result := 'CodeableConcept'
  else if (propName = 'organismId') then result := 'Identifier'
  else if (propName = 'organismName') then result := 'string'
  else if (propName = 'parentSubstanceId') then result := 'Identifier'
  else if (propName = 'parentSubstanceName') then result := 'string'
  else if (propName = 'countryOfOrigin') then result := 'CodeableConcept'
  else if (propName = 'geographicalLocation') then result := 'string'
  else if (propName = 'developmentStage') then result := 'CodeableConcept'
  else if (propName = 'fractionDescription') then result := 'BackboneElement'
  else if (propName = 'organism') then result := 'BackboneElement'
  else if (propName = 'partDescription') then result := 'BackboneElement'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirSubstanceSourceMaterial.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'sourceMaterialClass') then SourceMaterialClassElement := nil
  else if (propName = 'sourceMaterialType') then SourceMaterialTypeElement := nil
  else if (propName = 'sourceMaterialState') then SourceMaterialStateElement := nil
  else if (propName = 'organismId') then OrganismIdElement := nil
  else if (propName = 'organismName') then OrganismNameElement := nil
  else if (propName = 'parentSubstanceId') then deletePropertyValue('parentSubstanceId', ParentSubstanceIdList, value)
  else if (propName = 'parentSubstanceName') then deletePropertyValue('parentSubstanceName', ParentSubstanceNameList, value)
  else if (propName = 'countryOfOrigin') then deletePropertyValue('countryOfOrigin', CountryOfOriginList, value)
  else if (propName = 'geographicalLocation') then deletePropertyValue('geographicalLocation', GeographicalLocationList, value)
  else if (propName = 'developmentStage') then DevelopmentStageElement := nil
  else if (propName = 'fractionDescription') then deletePropertyValue('fractionDescription', FractionDescriptionList, value)
  else if (propName = 'organism') then OrganismElement := nil
  else if (propName = 'partDescription') then deletePropertyValue('partDescription', PartDescriptionList, value)
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirSubstanceSourceMaterial.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'sourceMaterialClass') then SourceMaterialClassElement := new as TFhirCodeableConcept
  else if (propName = 'sourceMaterialType') then SourceMaterialTypeElement := new as TFhirCodeableConcept
  else if (propName = 'sourceMaterialState') then SourceMaterialStateElement := new as TFhirCodeableConcept
  else if (propName = 'organismId') then OrganismIdElement := new as TFhirIdentifier
  else if (propName = 'organismName') then OrganismNameElement := asString(new)
  else if (propName = 'parentSubstanceId') then replacePropertyValue('parentSubstanceId', ParentSubstanceIdList, existing, new)
  else if (propName = 'parentSubstanceName') then replacePropertyValue('parentSubstanceName', ParentSubstanceNameList, existing, new)
  else if (propName = 'countryOfOrigin') then replacePropertyValue('countryOfOrigin', CountryOfOriginList, existing, new)
  else if (propName = 'geographicalLocation') then replacePropertyValue('geographicalLocation', GeographicalLocationList, existing, new)
  else if (propName = 'developmentStage') then DevelopmentStageElement := new as TFhirCodeableConcept
  else if (propName = 'fractionDescription') then replacePropertyValue('fractionDescription', FractionDescriptionList, existing, new)
  else if (propName = 'organism') then OrganismElement := new as TFhirSubstanceSourceMaterialOrganism
  else if (propName = 'partDescription') then replacePropertyValue('partDescription', PartDescriptionList, existing, new)
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirSubstanceSourceMaterial.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'parentSubstanceId') then ParentSubstanceIdList.move(source, destination)
  else if (propName = 'parentSubstanceName') then ParentSubstanceNameList.move(source, destination)
  else if (propName = 'countryOfOrigin') then CountryOfOriginList.move(source, destination)
  else if (propName = 'geographicalLocation') then GeographicalLocationList.move(source, destination)
  else if (propName = 'fractionDescription') then FractionDescriptionList.move(source, destination)
  else if (propName = 'partDescription') then PartDescriptionList.move(source, destination)
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirSubstanceSourceMaterial.fhirType : string;
begin
  result := 'SubstanceSourceMaterial';
end;

function TFhirSubstanceSourceMaterial.Link : TFhirSubstanceSourceMaterial;
begin
  result := TFhirSubstanceSourceMaterial(inherited Link);
end;

function TFhirSubstanceSourceMaterial.Clone : TFhirSubstanceSourceMaterial;
begin
  result := TFhirSubstanceSourceMaterial(inherited Clone);
end;

function TFhirSubstanceSourceMaterial.equals(other : TObject) : boolean; 
var
  o : TFhirSubstanceSourceMaterial;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirSubstanceSourceMaterial)) then
    result := false
  else
  begin
    o := TFhirSubstanceSourceMaterial(other);
    result := compareDeep(sourceMaterialClassElement, o.sourceMaterialClassElement, true) and 
      compareDeep(sourceMaterialTypeElement, o.sourceMaterialTypeElement, true) and 
      compareDeep(sourceMaterialStateElement, o.sourceMaterialStateElement, true) and 
      compareDeep(organismIdElement, o.organismIdElement, true) and compareDeep(organismNameElement, o.organismNameElement, true) and 
      compareDeep(parentSubstanceIdList, o.parentSubstanceIdList, true) and compareDeep(parentSubstanceNameList, o.parentSubstanceNameList, true) and 
      compareDeep(countryOfOriginList, o.countryOfOriginList, true) and compareDeep(geographicalLocationList, o.geographicalLocationList, true) and 
      compareDeep(developmentStageElement, o.developmentStageElement, true) and compareDeep(fractionDescriptionList, o.fractionDescriptionList, true) and 
      compareDeep(organismElement, o.organismElement, true) and compareDeep(partDescriptionList, o.partDescriptionList, true);
  end;
end;

function TFhirSubstanceSourceMaterial.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FSourceMaterialClass) and isEmptyProp(FSourceMaterialType) and isEmptyProp(FSourceMaterialState) and isEmptyProp(FOrganismId) and isEmptyProp(FOrganismName) and isEmptyProp(FparentSubstanceIdList) and isEmptyProp(FparentSubstanceNameList) and isEmptyProp(FcountryOfOriginList) and isEmptyProp(FgeographicalLocationList) and isEmptyProp(FDevelopmentStage) and isEmptyProp(FfractionDescriptionList) and isEmptyProp(FOrganism) and isEmptyProp(FpartDescriptionList);
end;

procedure TFhirSubstanceSourceMaterial.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('sourceMaterialClass');
  fields.add('sourceMaterialType');
  fields.add('sourceMaterialState');
  fields.add('organismId');
  fields.add('organismName');
  fields.add('parentSubstanceId');
  fields.add('parentSubstanceName');
  fields.add('countryOfOrigin');
  fields.add('geographicalLocation');
  fields.add('developmentStage');
  fields.add('fractionDescription');
  fields.add('organism');
  fields.add('partDescription');
end;

function TFhirSubstanceSourceMaterial.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
  inc(result, FParentSubstanceIdList.sizeInBytes(magic));
  inc(result, FParentSubstanceNameList.sizeInBytes(magic));
  inc(result, FCountryOfOriginList.sizeInBytes(magic));
  inc(result, FGeographicalLocationList.sizeInBytes(magic));
  inc(result, FFractionDescriptionList.sizeInBytes(magic));
  inc(result, FPartDescriptionList.sizeInBytes(magic));
end;

procedure TFhirSubstanceSourceMaterial.SetSourceMaterialClass(value : TFhirCodeableConcept);
begin
  FSourceMaterialClass.free;
  FSourceMaterialClass := value;
end;

procedure TFhirSubstanceSourceMaterial.SetSourceMaterialType(value : TFhirCodeableConcept);
begin
  FSourceMaterialType.free;
  FSourceMaterialType := value;
end;

procedure TFhirSubstanceSourceMaterial.SetSourceMaterialState(value : TFhirCodeableConcept);
begin
  FSourceMaterialState.free;
  FSourceMaterialState := value;
end;

procedure TFhirSubstanceSourceMaterial.SetOrganismId(value : TFhirIdentifier);
begin
  FOrganismId.free;
  FOrganismId := value;
end;

procedure TFhirSubstanceSourceMaterial.SetOrganismName(value : TFhirString);
begin
  FOrganismName.free;
  FOrganismName := value;
end;

function TFhirSubstanceSourceMaterial.GetOrganismNameST : String;
begin
  if FOrganismName = nil then
    result := ''
  else
    result := FOrganismName.value;
end;

procedure TFhirSubstanceSourceMaterial.SetOrganismNameST(value : String);
begin
  if value <> '' then
  begin
    if FOrganismName = nil then
      FOrganismName := TFhirString.create;
    FOrganismName.value := value
  end
  else if FOrganismName <> nil then
    FOrganismName.value := '';
end;

function TFhirSubstanceSourceMaterial.GetParentSubstanceIdList : TFhirIdentifierList;
begin
  if FParentSubstanceIdList = nil then
    FParentSubstanceIdList := TFhirIdentifierList.Create;
  result := FParentSubstanceIdList;
end;

function TFhirSubstanceSourceMaterial.GetHasParentSubstanceIdList : boolean;
begin
  result := (FParentSubstanceIdList <> nil) and (FParentSubstanceIdList.count > 0);
end;

function TFhirSubstanceSourceMaterial.GetParentSubstanceNameList : TFhirStringList;
begin
  if FParentSubstanceNameList = nil then
    FParentSubstanceNameList := TFhirStringList.Create;
  result := FParentSubstanceNameList;
end;

function TFhirSubstanceSourceMaterial.GetHasParentSubstanceNameList : boolean;
begin
  result := (FParentSubstanceNameList <> nil) and (FParentSubstanceNameList.count > 0);
end;

function TFhirSubstanceSourceMaterial.GetCountryOfOriginList : TFhirCodeableConceptList;
begin
  if FCountryOfOriginList = nil then
    FCountryOfOriginList := TFhirCodeableConceptList.Create;
  result := FCountryOfOriginList;
end;

function TFhirSubstanceSourceMaterial.GetHasCountryOfOriginList : boolean;
begin
  result := (FCountryOfOriginList <> nil) and (FCountryOfOriginList.count > 0);
end;

function TFhirSubstanceSourceMaterial.GetGeographicalLocationList : TFhirStringList;
begin
  if FGeographicalLocationList = nil then
    FGeographicalLocationList := TFhirStringList.Create;
  result := FGeographicalLocationList;
end;

function TFhirSubstanceSourceMaterial.GetHasGeographicalLocationList : boolean;
begin
  result := (FGeographicalLocationList <> nil) and (FGeographicalLocationList.count > 0);
end;

procedure TFhirSubstanceSourceMaterial.SetDevelopmentStage(value : TFhirCodeableConcept);
begin
  FDevelopmentStage.free;
  FDevelopmentStage := value;
end;

function TFhirSubstanceSourceMaterial.GetFractionDescriptionList : TFhirSubstanceSourceMaterialFractionDescriptionList;
begin
  if FFractionDescriptionList = nil then
    FFractionDescriptionList := TFhirSubstanceSourceMaterialFractionDescriptionList.Create;
  result := FFractionDescriptionList;
end;

function TFhirSubstanceSourceMaterial.GetHasFractionDescriptionList : boolean;
begin
  result := (FFractionDescriptionList <> nil) and (FFractionDescriptionList.count > 0);
end;

procedure TFhirSubstanceSourceMaterial.SetOrganism(value : TFhirSubstanceSourceMaterialOrganism);
begin
  FOrganism.free;
  FOrganism := value;
end;

function TFhirSubstanceSourceMaterial.GetPartDescriptionList : TFhirSubstanceSourceMaterialPartDescriptionList;
begin
  if FPartDescriptionList = nil then
    FPartDescriptionList := TFhirSubstanceSourceMaterialPartDescriptionList.Create;
  result := FPartDescriptionList;
end;

function TFhirSubstanceSourceMaterial.GetHasPartDescriptionList : boolean;
begin
  result := (FPartDescriptionList <> nil) and (FPartDescriptionList.count > 0);
end;

{ TFhirSubstanceSourceMaterialListEnumerator }

constructor TFhirSubstanceSourceMaterialListEnumerator.Create(list : TFhirSubstanceSourceMaterialList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirSubstanceSourceMaterialListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirSubstanceSourceMaterialListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirSubstanceSourceMaterialListEnumerator.GetCurrent : TFhirSubstanceSourceMaterial;
begin
  Result := FList[FIndex];
end;

function TFhirSubstanceSourceMaterialListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirSubstanceSourceMaterialList }

function TFhirSubstanceSourceMaterialList.AddItem(value: TFhirSubstanceSourceMaterial): TFhirSubstanceSourceMaterial;
begin
  assert(value.ClassName = 'TFhirSubstanceSourceMaterial', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirSubstanceSourceMaterial');
  add(value);
  result := value;
end;

function TFhirSubstanceSourceMaterialList.Append: TFhirSubstanceSourceMaterial;
begin
  result := TFhirSubstanceSourceMaterial.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirSubstanceSourceMaterialList.ClearItems;
begin
  Clear;
end;

function TFhirSubstanceSourceMaterialList.GetEnumerator : TFhirSubstanceSourceMaterialListEnumerator;
begin
  result := TFhirSubstanceSourceMaterialListEnumerator.Create(self.link);
end;

function TFhirSubstanceSourceMaterialList.Clone: TFhirSubstanceSourceMaterialList;
begin
  result := TFhirSubstanceSourceMaterialList(inherited Clone);
end;

function TFhirSubstanceSourceMaterialList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirSubstanceSourceMaterialList.GetItemN(index: Integer): TFhirSubstanceSourceMaterial;
begin
  result := TFhirSubstanceSourceMaterial(ObjectByIndex[index]);
end;

function TFhirSubstanceSourceMaterialList.ItemClass: TFslObjectClass;
begin
  result := TFhirSubstanceSourceMaterial;
end;
function TFhirSubstanceSourceMaterialList.IndexOf(value: TFhirSubstanceSourceMaterial): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirSubstanceSourceMaterialList.Insert(index: Integer): TFhirSubstanceSourceMaterial;
begin
  result := TFhirSubstanceSourceMaterial.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirSubstanceSourceMaterialList.InsertItem(index: Integer; value: TFhirSubstanceSourceMaterial);
begin
  assert(value is TFhirSubstanceSourceMaterial);
  Inherited Insert(index, value);
end;

function TFhirSubstanceSourceMaterialList.Item(index: Integer): TFhirSubstanceSourceMaterial;
begin
  result := TFhirSubstanceSourceMaterial(ObjectByIndex[index]);
end;

function TFhirSubstanceSourceMaterialList.Link: TFhirSubstanceSourceMaterialList;
begin
  result := TFhirSubstanceSourceMaterialList(inherited Link);
end;

procedure TFhirSubstanceSourceMaterialList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirSubstanceSourceMaterialList.SetItemByIndex(index: Integer; value: TFhirSubstanceSourceMaterial);
begin
  assert(value is TFhirSubstanceSourceMaterial);
  FhirSubstanceSourceMaterials[index] := value;
end;

procedure TFhirSubstanceSourceMaterialList.SetItemN(index: Integer; value: TFhirSubstanceSourceMaterial);
begin
  assert(value is TFhirSubstanceSourceMaterial);
  ObjectByIndex[index] := value;
end;

{$ENDIF FHIR_SUBSTANCESOURCEMATERIAL}


end.

