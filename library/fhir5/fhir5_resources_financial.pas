unit fhir5_resources_financial;

{
  Copyright (c) 2011+, HL7 and Health Intersections Pty Ltd (http://www.healthintersections.com.au)
  All rights reserved.
  
  Redistribution and use in source and binary forms, with or without modification, 
  are permitted provided that the following conditions are met:
  
   * Redistributions of source code must retain the above copyright notice, this 
     list of conditions and the following disclaimer.
   * Redistributions in binary form must reproduce the above copyright notice, 
     this list of conditions and the following disclaimer in the documentation 
     and/or other materials provided with the distribution.
   * Neither the name of HL7 nor the names of its contributors may be used to 
     endorse or promote products derived from this software without specific 
     prior written permission.
  
  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND 
  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED 
  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. 
  IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, 
  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT 
  NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR 
  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, 
  WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) 
  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE 
  POSSIBILITY OF SUCH DAMAGE.
  
}

{$I fhir.inc}
{$I fhir5.inc}

interface

// Generated on Wed, May 12, 2021 17:44+1000 for FHIR v4.6.0



uses
  SysUtils, Classes, 
  fsl_base, fsl_utilities, fsl_stream, 
  fhir_objects, fhir_utilities,  
  fhir5_base, fhir5_enums, fhir5_types, fhir5_resources_base, fhir5_resources_canonical;



type
{$IFDEF FHIR_ACCOUNT}
  TFhirAccountCoverage = class;
  TFhirAccountCoverageList = class;
  TFhirAccountGuarantor = class;
  TFhirAccountGuarantorList = class;
  TFhirAccount = class;
  TFhirAccountList = class;
{$ENDIF FHIR_ACCOUNT}
{$IFDEF FHIR_CHARGEITEM}
  TFhirChargeItemPerformer = class;
  TFhirChargeItemPerformerList = class;
  TFhirChargeItem = class;
  TFhirChargeItemList = class;
{$ENDIF FHIR_CHARGEITEM}
{$IFDEF FHIR_CHARGEITEMDEFINITION}
  TFhirChargeItemDefinitionApplicability = class;
  TFhirChargeItemDefinitionApplicabilityList = class;
  TFhirChargeItemDefinitionPropertyGroup = class;
  TFhirChargeItemDefinitionPropertyGroupList = class;
  TFhirChargeItemDefinitionPropertyGroupPriceComponent = class;
  TFhirChargeItemDefinitionPropertyGroupPriceComponentList = class;
  TFhirChargeItemDefinition = class;
  TFhirChargeItemDefinitionList = class;
{$ENDIF FHIR_CHARGEITEMDEFINITION}
{$IFDEF FHIR_CITATION}
  TFhirCitationClassification = class;
  TFhirCitationClassificationList = class;
  TFhirCitationStatusDate = class;
  TFhirCitationStatusDateList = class;
  TFhirCitationRelatesTo = class;
  TFhirCitationRelatesToList = class;
  TFhirCitationCitedArtifact = class;
  TFhirCitationCitedArtifactList = class;
  TFhirCitationCitedArtifactVersion = class;
  TFhirCitationCitedArtifactVersionList = class;
  TFhirCitationCitedArtifactStatusDate = class;
  TFhirCitationCitedArtifactStatusDateList = class;
  TFhirCitationCitedArtifactTitle = class;
  TFhirCitationCitedArtifactTitleList = class;
  TFhirCitationCitedArtifactAbstract = class;
  TFhirCitationCitedArtifactAbstractList = class;
  TFhirCitationCitedArtifactPart = class;
  TFhirCitationCitedArtifactPartList = class;
  TFhirCitationCitedArtifactRelatesTo = class;
  TFhirCitationCitedArtifactRelatesToList = class;
  TFhirCitationCitedArtifactPublicationForm = class;
  TFhirCitationCitedArtifactPublicationFormList = class;
  TFhirCitationCitedArtifactPublicationFormPublishedIn = class;
  TFhirCitationCitedArtifactPublicationFormPublishedInList = class;
  TFhirCitationCitedArtifactPublicationFormPeriodicRelease = class;
  TFhirCitationCitedArtifactPublicationFormPeriodicReleaseList = class;
  TFhirCitationCitedArtifactPublicationFormPeriodicReleaseDateOfPublication = class;
  TFhirCitationCitedArtifactPublicationFormPeriodicReleaseDateOfPublicationList = class;
  TFhirCitationCitedArtifactWebLocation = class;
  TFhirCitationCitedArtifactWebLocationList = class;
  TFhirCitationCitedArtifactClassification = class;
  TFhirCitationCitedArtifactClassificationList = class;
  TFhirCitationCitedArtifactClassificationWhoClassified = class;
  TFhirCitationCitedArtifactClassificationWhoClassifiedList = class;
  TFhirCitationCitedArtifactContributorship = class;
  TFhirCitationCitedArtifactContributorshipList = class;
  TFhirCitationCitedArtifactContributorshipEntry = class;
  TFhirCitationCitedArtifactContributorshipEntryList = class;
  TFhirCitationCitedArtifactContributorshipEntryAffiliationInfo = class;
  TFhirCitationCitedArtifactContributorshipEntryAffiliationInfoList = class;
  TFhirCitationCitedArtifactContributorshipEntryContributionInstance = class;
  TFhirCitationCitedArtifactContributorshipEntryContributionInstanceList = class;
  TFhirCitationCitedArtifactContributorshipSummary = class;
  TFhirCitationCitedArtifactContributorshipSummaryList = class;
  TFhirCitation = class;
  TFhirCitationList = class;
{$ENDIF FHIR_CITATION}
{$IFDEF FHIR_CLAIM}
  TFhirClaimRelated = class;
  TFhirClaimRelatedList = class;
  TFhirClaimPayee = class;
  TFhirClaimPayeeList = class;
  TFhirClaimCareTeam = class;
  TFhirClaimCareTeamList = class;
  TFhirClaimSupportingInfo = class;
  TFhirClaimSupportingInfoList = class;
  TFhirClaimDiagnosis = class;
  TFhirClaimDiagnosisList = class;
  TFhirClaimProcedure = class;
  TFhirClaimProcedureList = class;
  TFhirClaimInsurance = class;
  TFhirClaimInsuranceList = class;
  TFhirClaimAccident = class;
  TFhirClaimAccidentList = class;
  TFhirClaimItem = class;
  TFhirClaimItemList = class;
  TFhirClaimItemDetail = class;
  TFhirClaimItemDetailList = class;
  TFhirClaimItemDetailSubDetail = class;
  TFhirClaimItemDetailSubDetailList = class;
  TFhirClaim = class;
  TFhirClaimList = class;
{$ENDIF FHIR_CLAIM}
{$IFDEF FHIR_CLAIMRESPONSE}
  TFhirClaimResponseItem = class;
  TFhirClaimResponseItemList = class;
  TFhirClaimResponseItemAdjudication = class;
  TFhirClaimResponseItemAdjudicationList = class;
  TFhirClaimResponseItemDetail = class;
  TFhirClaimResponseItemDetailList = class;
  TFhirClaimResponseItemDetailSubDetail = class;
  TFhirClaimResponseItemDetailSubDetailList = class;
  TFhirClaimResponseAddItem = class;
  TFhirClaimResponseAddItemList = class;
  TFhirClaimResponseAddItemDetail = class;
  TFhirClaimResponseAddItemDetailList = class;
  TFhirClaimResponseAddItemDetailSubDetail = class;
  TFhirClaimResponseAddItemDetailSubDetailList = class;
  TFhirClaimResponseTotal = class;
  TFhirClaimResponseTotalList = class;
  TFhirClaimResponsePayment = class;
  TFhirClaimResponsePaymentList = class;
  TFhirClaimResponseProcessNote = class;
  TFhirClaimResponseProcessNoteList = class;
  TFhirClaimResponseInsurance = class;
  TFhirClaimResponseInsuranceList = class;
  TFhirClaimResponseError = class;
  TFhirClaimResponseErrorList = class;
  TFhirClaimResponse = class;
  TFhirClaimResponseList = class;
{$ENDIF FHIR_CLAIMRESPONSE}
{$IFDEF FHIR_COVERAGE}
  TFhirCoverageClass = class;
  TFhirCoverageClassList = class;
  TFhirCoverageCostToBeneficiary = class;
  TFhirCoverageCostToBeneficiaryList = class;
  TFhirCoverageCostToBeneficiaryException = class;
  TFhirCoverageCostToBeneficiaryExceptionList = class;
  TFhirCoverage = class;
  TFhirCoverageList = class;
{$ENDIF FHIR_COVERAGE}
{$IFDEF FHIR_COVERAGEELIGIBILITYREQUEST}
  TFhirCoverageEligibilityRequestSupportingInfo = class;
  TFhirCoverageEligibilityRequestSupportingInfoList = class;
  TFhirCoverageEligibilityRequestInsurance = class;
  TFhirCoverageEligibilityRequestInsuranceList = class;
  TFhirCoverageEligibilityRequestItem = class;
  TFhirCoverageEligibilityRequestItemList = class;
  TFhirCoverageEligibilityRequestItemDiagnosis = class;
  TFhirCoverageEligibilityRequestItemDiagnosisList = class;
  TFhirCoverageEligibilityRequest = class;
  TFhirCoverageEligibilityRequestList = class;
{$ENDIF FHIR_COVERAGEELIGIBILITYREQUEST}
{$IFDEF FHIR_COVERAGEELIGIBILITYRESPONSE}
  TFhirCoverageEligibilityResponseInsurance = class;
  TFhirCoverageEligibilityResponseInsuranceList = class;
  TFhirCoverageEligibilityResponseInsuranceItem = class;
  TFhirCoverageEligibilityResponseInsuranceItemList = class;
  TFhirCoverageEligibilityResponseInsuranceItemBenefit = class;
  TFhirCoverageEligibilityResponseInsuranceItemBenefitList = class;
  TFhirCoverageEligibilityResponseError = class;
  TFhirCoverageEligibilityResponseErrorList = class;
  TFhirCoverageEligibilityResponse = class;
  TFhirCoverageEligibilityResponseList = class;
{$ENDIF FHIR_COVERAGEELIGIBILITYRESPONSE}
{$IFDEF FHIR_ENROLLMENTREQUEST}
  TFhirEnrollmentRequest = class;
  TFhirEnrollmentRequestList = class;
{$ENDIF FHIR_ENROLLMENTREQUEST}
{$IFDEF FHIR_ENROLLMENTRESPONSE}
  TFhirEnrollmentResponse = class;
  TFhirEnrollmentResponseList = class;
{$ENDIF FHIR_ENROLLMENTRESPONSE}
{$IFDEF FHIR_EXPLANATIONOFBENEFIT}
  TFhirExplanationOfBenefitRelated = class;
  TFhirExplanationOfBenefitRelatedList = class;
  TFhirExplanationOfBenefitPayee = class;
  TFhirExplanationOfBenefitPayeeList = class;
  TFhirExplanationOfBenefitCareTeam = class;
  TFhirExplanationOfBenefitCareTeamList = class;
  TFhirExplanationOfBenefitSupportingInfo = class;
  TFhirExplanationOfBenefitSupportingInfoList = class;
  TFhirExplanationOfBenefitDiagnosis = class;
  TFhirExplanationOfBenefitDiagnosisList = class;
  TFhirExplanationOfBenefitProcedure = class;
  TFhirExplanationOfBenefitProcedureList = class;
  TFhirExplanationOfBenefitInsurance = class;
  TFhirExplanationOfBenefitInsuranceList = class;
  TFhirExplanationOfBenefitAccident = class;
  TFhirExplanationOfBenefitAccidentList = class;
  TFhirExplanationOfBenefitItem = class;
  TFhirExplanationOfBenefitItemList = class;
  TFhirExplanationOfBenefitItemAdjudication = class;
  TFhirExplanationOfBenefitItemAdjudicationList = class;
  TFhirExplanationOfBenefitItemDetail = class;
  TFhirExplanationOfBenefitItemDetailList = class;
  TFhirExplanationOfBenefitItemDetailSubDetail = class;
  TFhirExplanationOfBenefitItemDetailSubDetailList = class;
  TFhirExplanationOfBenefitAddItem = class;
  TFhirExplanationOfBenefitAddItemList = class;
  TFhirExplanationOfBenefitAddItemDetail = class;
  TFhirExplanationOfBenefitAddItemDetailList = class;
  TFhirExplanationOfBenefitAddItemDetailSubDetail = class;
  TFhirExplanationOfBenefitAddItemDetailSubDetailList = class;
  TFhirExplanationOfBenefitTotal = class;
  TFhirExplanationOfBenefitTotalList = class;
  TFhirExplanationOfBenefitPayment = class;
  TFhirExplanationOfBenefitPaymentList = class;
  TFhirExplanationOfBenefitProcessNote = class;
  TFhirExplanationOfBenefitProcessNoteList = class;
  TFhirExplanationOfBenefitBenefitBalance = class;
  TFhirExplanationOfBenefitBenefitBalanceList = class;
  TFhirExplanationOfBenefitBenefitBalanceFinancial = class;
  TFhirExplanationOfBenefitBenefitBalanceFinancialList = class;
  TFhirExplanationOfBenefit = class;
  TFhirExplanationOfBenefitList = class;
{$ENDIF FHIR_EXPLANATIONOFBENEFIT}
{$IFDEF FHIR_INSURANCEPLAN}
  TFhirInsurancePlanContact = class;
  TFhirInsurancePlanContactList = class;
  TFhirInsurancePlanCoverage = class;
  TFhirInsurancePlanCoverageList = class;
  TFhirInsurancePlanCoverageBenefit = class;
  TFhirInsurancePlanCoverageBenefitList = class;
  TFhirInsurancePlanCoverageBenefitLimit = class;
  TFhirInsurancePlanCoverageBenefitLimitList = class;
  TFhirInsurancePlanPlan = class;
  TFhirInsurancePlanPlanList = class;
  TFhirInsurancePlanPlanGeneralCost = class;
  TFhirInsurancePlanPlanGeneralCostList = class;
  TFhirInsurancePlanPlanSpecificCost = class;
  TFhirInsurancePlanPlanSpecificCostList = class;
  TFhirInsurancePlanPlanSpecificCostBenefit = class;
  TFhirInsurancePlanPlanSpecificCostBenefitList = class;
  TFhirInsurancePlanPlanSpecificCostBenefitCost = class;
  TFhirInsurancePlanPlanSpecificCostBenefitCostList = class;
  TFhirInsurancePlan = class;
  TFhirInsurancePlanList = class;
{$ENDIF FHIR_INSURANCEPLAN}
{$IFDEF FHIR_INVOICE}
  TFhirInvoiceParticipant = class;
  TFhirInvoiceParticipantList = class;
  TFhirInvoiceLineItem = class;
  TFhirInvoiceLineItemList = class;
  TFhirInvoiceLineItemPriceComponent = class;
  TFhirInvoiceLineItemPriceComponentList = class;
  TFhirInvoice = class;
  TFhirInvoiceList = class;
{$ENDIF FHIR_INVOICE}
{$IFDEF FHIR_PAYMENTNOTICE}
  TFhirPaymentNotice = class;
  TFhirPaymentNoticeList = class;
{$ENDIF FHIR_PAYMENTNOTICE}
{$IFDEF FHIR_PAYMENTRECONCILIATION}
  TFhirPaymentReconciliationDetail = class;
  TFhirPaymentReconciliationDetailList = class;
  TFhirPaymentReconciliationProcessNote = class;
  TFhirPaymentReconciliationProcessNoteList = class;
  TFhirPaymentReconciliation = class;
  TFhirPaymentReconciliationList = class;
{$ENDIF FHIR_PAYMENTRECONCILIATION}




{$IFDEF FHIR_ACCOUNT}
  // The party(s) that are responsible for covering the payment of this account, and what order should they be applied to the account.
  TFhirAccountCoverage = class (TFhirBackboneElement)
  protected
    FCoverage : TFhirReference;
    FPriority : TFhirPositiveInt;
    procedure SetCoverage(value : TFhirReference);
    procedure SetPriority(value : TFhirPositiveInt);
    function GetPriorityST : String;
    procedure SetPriorityST(value : String);
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirAccountCoverage; overload;
    function Clone : TFhirAccountCoverage; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to The party(s) that contribute to payment (or part of) of the charges applied to this account (including self-pay).  A coverage may only be responsible for specific types of charges, and the sequence of the coverages in the account could be important when processing billing. (defined for API consistency)
    property coverage : TFhirReference read FCoverage write SetCoverage;
    // The party(s) that contribute to payment (or part of) of the charges applied to this account (including self-pay).  A coverage may only be responsible for specific types of charges, and the sequence of the coverages in the account could be important when processing billing.
    property coverageElement : TFhirReference read FCoverage write SetCoverage;

    // Typed access to The priority of the coverage in the context of this account.
    property priority : String read GetPriorityST write SetPriorityST;
    // The priority of the coverage in the context of this account.
    property priorityElement : TFhirPositiveInt read FPriority write SetPriority;

  end;

  TFhirAccountCoverageListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirAccountCoverageList;
    function GetCurrent : TFhirAccountCoverage;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirAccountCoverageList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirAccountCoverage read GetCurrent;
  end;

  TFhirAccountCoverageList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirAccountCoverage;
    procedure SetItemN(index : Integer; value : TFhirAccountCoverage);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirAccountCoverageList; overload;
    function Clone : TFhirAccountCoverageList; overload;
    function GetEnumerator : TFhirAccountCoverageListEnumerator;
    
    //  Add a FhirAccountCoverage to the end of the list.
    function Append : TFhirAccountCoverage;
    
    // Add an already existing FhirAccountCoverage to the end of the list.
    procedure AddItem(value : TFhirAccountCoverage); overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirAccountCoverage) : Integer;
    
    // Insert FhirAccountCoverage before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirAccountCoverage;
    
    // Insert an existing FhirAccountCoverage before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirAccountCoverage);
    
    // Get the iIndexth FhirAccountCoverage. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirAccountCoverage);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirAccountCoverage;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirAccountCoverages[index : Integer] : TFhirAccountCoverage read GetItemN write SetItemN; default;
  End;

  // The parties responsible for balancing the account if other payment options fall short.
  TFhirAccountGuarantor = class (TFhirBackboneElement)
  protected
    FParty : TFhirReference;
    FOnHold : TFhirBoolean;
    FPeriod : TFhirPeriod;
    procedure SetParty(value : TFhirReference);
    procedure SetOnHold(value : TFhirBoolean);
    function GetOnHoldST : Boolean;
    procedure SetOnHoldST(value : Boolean);
    procedure SetPeriod(value : TFhirPeriod);
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirAccountGuarantor; overload;
    function Clone : TFhirAccountGuarantor; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to The entity who is responsible. (defined for API consistency)
    property party : TFhirReference read FParty write SetParty;
    // The entity who is responsible.
    property partyElement : TFhirReference read FParty write SetParty;

    // Typed access to A guarantor may be placed on credit hold or otherwise have their role temporarily suspended.
    property onHold : Boolean read GetOnHoldST write SetOnHoldST;
    // A guarantor may be placed on credit hold or otherwise have their role temporarily suspended.
    property onHoldElement : TFhirBoolean read FOnHold write SetOnHold;

    // Typed access to The timeframe during which the guarantor accepts responsibility for the account. (defined for API consistency)
    property period : TFhirPeriod read FPeriod write SetPeriod;
    // The timeframe during which the guarantor accepts responsibility for the account.
    property periodElement : TFhirPeriod read FPeriod write SetPeriod;

  end;

  TFhirAccountGuarantorListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirAccountGuarantorList;
    function GetCurrent : TFhirAccountGuarantor;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirAccountGuarantorList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirAccountGuarantor read GetCurrent;
  end;

  TFhirAccountGuarantorList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirAccountGuarantor;
    procedure SetItemN(index : Integer; value : TFhirAccountGuarantor);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirAccountGuarantorList; overload;
    function Clone : TFhirAccountGuarantorList; overload;
    function GetEnumerator : TFhirAccountGuarantorListEnumerator;
    
    //  Add a FhirAccountGuarantor to the end of the list.
    function Append : TFhirAccountGuarantor;
    
    // Add an already existing FhirAccountGuarantor to the end of the list.
    procedure AddItem(value : TFhirAccountGuarantor); overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirAccountGuarantor) : Integer;
    
    // Insert FhirAccountGuarantor before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirAccountGuarantor;
    
    // Insert an existing FhirAccountGuarantor before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirAccountGuarantor);
    
    // Get the iIndexth FhirAccountGuarantor. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirAccountGuarantor);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirAccountGuarantor;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirAccountGuarantors[index : Integer] : TFhirAccountGuarantor read GetItemN write SetItemN; default;
  End;

  // A financial tool for tracking value accrued for a particular purpose.  In the healthcare field, used to track charges for a patient, cost centers, etc.
  TFhirAccount = class (TFhirDomainResource)
  protected
    FidentifierList : TFhirIdentifierList;
    FStatus : TFhirEnum;
    FType_ : TFhirCodeableConcept;
    FName : TFhirString;
    FsubjectList : TFhirReferenceList;
    FServicePeriod : TFhirPeriod;
    FcoverageList : TFhirAccountCoverageList;
    FOwner : TFhirReference;
    FDescription : TFhirString;
    FguarantorList : TFhirAccountGuarantorList;
    FPartOf : TFhirReference;
    function GetIdentifierList : TFhirIdentifierList;
    function GetHasIdentifierList : Boolean;
    procedure SetStatus(value : TFhirEnum);
    function GetStatusST : TFhirAccountStatusEnum;
    procedure SetStatusST(value : TFhirAccountStatusEnum);
    procedure SetType_(value : TFhirCodeableConcept);
    procedure SetName(value : TFhirString);
    function GetNameST : String;
    procedure SetNameST(value : String);
    function GetSubjectList : TFhirReferenceList;
    function GetHasSubjectList : Boolean;
    procedure SetServicePeriod(value : TFhirPeriod);
    function GetCoverageList : TFhirAccountCoverageList;
    function GetHasCoverageList : Boolean;
    procedure SetOwner(value : TFhirReference);
    procedure SetDescription(value : TFhirString);
    function GetDescriptionST : String;
    procedure SetDescriptionST(value : String);
    function GetGuarantorList : TFhirAccountGuarantorList;
    function GetHasGuarantorList : Boolean;
    procedure SetPartOf(value : TFhirReference);
  
    function GetResourceType : TFhirResourceType; override;
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirAccount; overload;
    function Clone : TFhirAccount; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Unique identifier used to reference the account.  Might or might not be intended for human use (e.g. credit card number).
    property identifierList : TFhirIdentifierList read GetIdentifierList;
    property hasIdentifierList : boolean read GetHasIdentifierList;

    // Indicates whether the account is presently used/usable or not.
    property status : TFhirAccountStatusEnum read GetStatusST write SetStatusST;
    property statusElement : TFhirEnum read FStatus write SetStatus;

    // Typed access to Categorizes the account for reporting and searching purposes. (defined for API consistency)
    property type_ : TFhirCodeableConcept read FType_ write SetType_;
    // Categorizes the account for reporting and searching purposes.
    property type_Element : TFhirCodeableConcept read FType_ write SetType_;

    // Typed access to Name used for the account when displaying it to humans in reports, etc.
    property name : String read GetNameST write SetNameST;
    // Name used for the account when displaying it to humans in reports, etc.
    property nameElement : TFhirString read FName write SetName;

    // Identifies the entity which incurs the expenses. While the immediate recipients of services or goods might be entities related to the subject, the expenses were ultimately incurred by the subject of the Account.
    property subjectList : TFhirReferenceList read GetSubjectList;
    property hasSubjectList : boolean read GetHasSubjectList;

    // Typed access to The date range of services associated with this account. (defined for API consistency)
    property servicePeriod : TFhirPeriod read FServicePeriod write SetServicePeriod;
    // The date range of services associated with this account.
    property servicePeriodElement : TFhirPeriod read FServicePeriod write SetServicePeriod;

    // The party(s) that are responsible for covering the payment of this account, and what order should they be applied to the account.
    property coverageList : TFhirAccountCoverageList read GetCoverageList;
    property hasCoverageList : boolean read GetHasCoverageList;

    // Typed access to Indicates the service area, hospital, department, etc. with responsibility for managing the Account. (defined for API consistency)
    property owner : TFhirReference read FOwner write SetOwner;
    // Indicates the service area, hospital, department, etc. with responsibility for managing the Account.
    property ownerElement : TFhirReference read FOwner write SetOwner;

    // Typed access to Provides additional information about what the account tracks and how it is used.
    property description : String read GetDescriptionST write SetDescriptionST;
    // Provides additional information about what the account tracks and how it is used.
    property descriptionElement : TFhirString read FDescription write SetDescription;

    // The parties responsible for balancing the account if other payment options fall short.
    property guarantorList : TFhirAccountGuarantorList read GetGuarantorList;
    property hasGuarantorList : boolean read GetHasGuarantorList;

    // Typed access to Reference to a parent Account. (defined for API consistency)
    property partOf : TFhirReference read FPartOf write SetPartOf;
    // Reference to a parent Account.
    property partOfElement : TFhirReference read FPartOf write SetPartOf;

  end;

  TFhirAccountListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirAccountList;
    function GetCurrent : TFhirAccount;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirAccountList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirAccount read GetCurrent;
  end;

  TFhirAccountList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirAccount;
    procedure SetItemN(index : Integer; value : TFhirAccount);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirAccountList; overload;
    function Clone : TFhirAccountList; overload;
    function GetEnumerator : TFhirAccountListEnumerator;
    
    //  Add a FhirAccount to the end of the list.
    function Append : TFhirAccount;
    
    // Add an already existing FhirAccount to the end of the list.
    procedure AddItem(value : TFhirAccount); overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirAccount) : Integer;
    
    // Insert FhirAccount before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirAccount;
    
    // Insert an existing FhirAccount before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirAccount);
    
    // Get the iIndexth FhirAccount. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirAccount);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirAccount;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirAccounts[index : Integer] : TFhirAccount read GetItemN write SetItemN; default;
  End;

{$ENDIF FHIR_ACCOUNT}
{$IFDEF FHIR_CHARGEITEM}
  // Indicates who or what performed or participated in the charged service.
  TFhirChargeItemPerformer = class (TFhirBackboneElement)
  protected
    FFunction_ : TFhirCodeableConcept;
    FActor : TFhirReference;
    procedure SetFunction_(value : TFhirCodeableConcept);
    procedure SetActor(value : TFhirReference);
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirChargeItemPerformer; overload;
    function Clone : TFhirChargeItemPerformer; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to Describes the type of performance or participation(e.g. primary surgeon, anesthesiologiest, etc.). (defined for API consistency)
    property function_ : TFhirCodeableConcept read FFunction_ write SetFunction_;
    // Describes the type of performance or participation(e.g. primary surgeon, anesthesiologiest, etc.).
    property function_Element : TFhirCodeableConcept read FFunction_ write SetFunction_;

    // Typed access to The device, practitioner, etc. who performed or participated in the service. (defined for API consistency)
    property actor : TFhirReference read FActor write SetActor;
    // The device, practitioner, etc. who performed or participated in the service.
    property actorElement : TFhirReference read FActor write SetActor;

  end;

  TFhirChargeItemPerformerListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirChargeItemPerformerList;
    function GetCurrent : TFhirChargeItemPerformer;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirChargeItemPerformerList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirChargeItemPerformer read GetCurrent;
  end;

  TFhirChargeItemPerformerList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirChargeItemPerformer;
    procedure SetItemN(index : Integer; value : TFhirChargeItemPerformer);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirChargeItemPerformerList; overload;
    function Clone : TFhirChargeItemPerformerList; overload;
    function GetEnumerator : TFhirChargeItemPerformerListEnumerator;
    
    //  Add a FhirChargeItemPerformer to the end of the list.
    function Append : TFhirChargeItemPerformer;
    
    // Add an already existing FhirChargeItemPerformer to the end of the list.
    procedure AddItem(value : TFhirChargeItemPerformer); overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirChargeItemPerformer) : Integer;
    
    // Insert FhirChargeItemPerformer before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirChargeItemPerformer;
    
    // Insert an existing FhirChargeItemPerformer before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirChargeItemPerformer);
    
    // Get the iIndexth FhirChargeItemPerformer. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirChargeItemPerformer);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirChargeItemPerformer;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirChargeItemPerformers[index : Integer] : TFhirChargeItemPerformer read GetItemN write SetItemN; default;
  End;

  // The resource ChargeItem describes the provision of healthcare provider products for a certain patient, therefore referring not only to the product, but containing in addition details of the provision, like date, time, amounts and participating organizations and persons. Main Usage of the ChargeItem is to enable the billing process and internal cost allocation.
  TFhirChargeItem = class (TFhirDomainResource)
  protected
    FidentifierList : TFhirIdentifierList;
    FdefinitionUriList : TFhirUriList;
    FdefinitionCanonicalList : TFhirCanonicalList;
    FStatus : TFhirEnum;
    FpartOfList : TFhirReferenceList;
    FCode : TFhirCodeableConcept;
    FSubject : TFhirReference;
    FContext : TFhirReference;
    FOccurrence : TFhirDataType;
    FperformerList : TFhirChargeItemPerformerList;
    FPerformingOrganization : TFhirReference;
    FRequestingOrganization : TFhirReference;
    FCostCenter : TFhirReference;
    FQuantity : TFhirQuantity;
    FbodysiteList : TFhirCodeableConceptList;
    FFactorOverride : TFhirDecimal;
    FPriceOverride : TFhirMoney;
    FOverrideReason : TFhirString;
    FEnterer : TFhirReference;
    FEnteredDate : TFhirDateTime;
    FreasonList : TFhirCodeableConceptList;
    FserviceList : TFhirReferenceList;
    FProduct : TFhirDataType;
    FaccountList : TFhirReferenceList;
    FnoteList : TFhirAnnotationList;
    FsupportingInformationList : TFhirReferenceList;
    function GetIdentifierList : TFhirIdentifierList;
    function GetHasIdentifierList : Boolean;
    function GetDefinitionUriList : TFhirUriList;
    function GetHasDefinitionUriList : Boolean;
    function GetDefinitionCanonicalList : TFhirCanonicalList;
    function GetHasDefinitionCanonicalList : Boolean;
    procedure SetStatus(value : TFhirEnum);
    function GetStatusST : TFhirChargeItemStatusEnum;
    procedure SetStatusST(value : TFhirChargeItemStatusEnum);
    function GetPartOfList : TFhirReferenceList;
    function GetHasPartOfList : Boolean;
    procedure SetCode(value : TFhirCodeableConcept);
    procedure SetSubject(value : TFhirReference);
    procedure SetContext(value : TFhirReference);
    procedure SetOccurrence(value : TFhirDataType);
    function GetPerformerList : TFhirChargeItemPerformerList;
    function GetHasPerformerList : Boolean;
    procedure SetPerformingOrganization(value : TFhirReference);
    procedure SetRequestingOrganization(value : TFhirReference);
    procedure SetCostCenter(value : TFhirReference);
    procedure SetQuantity(value : TFhirQuantity);
    function GetBodysiteList : TFhirCodeableConceptList;
    function GetHasBodysiteList : Boolean;
    procedure SetFactorOverride(value : TFhirDecimal);
    function GetFactorOverrideST : String;
    procedure SetFactorOverrideST(value : String);
    procedure SetPriceOverride(value : TFhirMoney);
    procedure SetOverrideReason(value : TFhirString);
    function GetOverrideReasonST : String;
    procedure SetOverrideReasonST(value : String);
    procedure SetEnterer(value : TFhirReference);
    procedure SetEnteredDate(value : TFhirDateTime);
    function GetEnteredDateST : TFslDateTime;
    procedure SetEnteredDateST(value : TFslDateTime);
    function GetReasonList : TFhirCodeableConceptList;
    function GetHasReasonList : Boolean;
    function GetServiceList : TFhirReferenceList;
    function GetHasServiceList : Boolean;
    procedure SetProduct(value : TFhirDataType);
    function GetAccountList : TFhirReferenceList;
    function GetHasAccountList : Boolean;
    function GetNoteList : TFhirAnnotationList;
    function GetHasNoteList : Boolean;
    function GetSupportingInformationList : TFhirReferenceList;
    function GetHasSupportingInformationList : Boolean;
  
    function GetResourceType : TFhirResourceType; override;
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirChargeItem; overload;
    function Clone : TFhirChargeItem; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Identifiers assigned to this event performer or other systems.
    property identifierList : TFhirIdentifierList read GetIdentifierList;
    property hasIdentifierList : boolean read GetHasIdentifierList;

    // References the (external) source of pricing information, rules of application for the code this ChargeItem uses.
    property definitionUriList : TFhirUriList read GetDefinitionUriList;
    property hasDefinitionUriList : boolean read GetHasDefinitionUriList;

    // References the source of pricing information, rules of application for the code this ChargeItem uses.
    property definitionCanonicalList : TFhirCanonicalList read GetDefinitionCanonicalList;
    property hasDefinitionCanonicalList : boolean read GetHasDefinitionCanonicalList;

    // The current state of the ChargeItem.
    property status : TFhirChargeItemStatusEnum read GetStatusST write SetStatusST;
    property statusElement : TFhirEnum read FStatus write SetStatus;

    // ChargeItems can be grouped to larger ChargeItems covering the whole set.
    property partOfList : TFhirReferenceList read GetPartOfList;
    property hasPartOfList : boolean read GetHasPartOfList;

    // Typed access to A code that identifies the charge, like a billing code. (defined for API consistency)
    property code : TFhirCodeableConcept read FCode write SetCode;
    // A code that identifies the charge, like a billing code.
    property codeElement : TFhirCodeableConcept read FCode write SetCode;

    // Typed access to The individual or set of individuals the action is being or was performed on. (defined for API consistency)
    property subject : TFhirReference read FSubject write SetSubject;
    // The individual or set of individuals the action is being or was performed on.
    property subjectElement : TFhirReference read FSubject write SetSubject;

    // Typed access to The encounter or episode of care that establishes the context for this event. (defined for API consistency)
    property context : TFhirReference read FContext write SetContext;
    // The encounter or episode of care that establishes the context for this event.
    property contextElement : TFhirReference read FContext write SetContext;

    // Typed access to Date/time(s) or duration when the charged service was applied. (defined for API consistency)
    property occurrence : TFhirDataType read FOccurrence write SetOccurrence;
    // Date/time(s) or duration when the charged service was applied.
    property occurrenceElement : TFhirDataType read FOccurrence write SetOccurrence;

    // Indicates who or what performed or participated in the charged service.
    property performerList : TFhirChargeItemPerformerList read GetPerformerList;
    property hasPerformerList : boolean read GetHasPerformerList;

    // Typed access to The organization requesting the service. (defined for API consistency)
    property performingOrganization : TFhirReference read FPerformingOrganization write SetPerformingOrganization;
    // The organization requesting the service.
    property performingOrganizationElement : TFhirReference read FPerformingOrganization write SetPerformingOrganization;

    // Typed access to The organization performing the service. (defined for API consistency)
    property requestingOrganization : TFhirReference read FRequestingOrganization write SetRequestingOrganization;
    // The organization performing the service.
    property requestingOrganizationElement : TFhirReference read FRequestingOrganization write SetRequestingOrganization;

    // Typed access to The financial cost center permits the tracking of charge attribution. (defined for API consistency)
    property costCenter : TFhirReference read FCostCenter write SetCostCenter;
    // The financial cost center permits the tracking of charge attribution.
    property costCenterElement : TFhirReference read FCostCenter write SetCostCenter;

    // Typed access to Quantity of which the charge item has been serviced. (defined for API consistency)
    property quantity : TFhirQuantity read FQuantity write SetQuantity;
    // Quantity of which the charge item has been serviced.
    property quantityElement : TFhirQuantity read FQuantity write SetQuantity;

    // The anatomical location where the related service has been applied.
    property bodysiteList : TFhirCodeableConceptList read GetBodysiteList;
    property hasBodysiteList : boolean read GetHasBodysiteList;

    // Typed access to Factor overriding the factor determined by the rules associated with the code.
    property factorOverride : String read GetFactorOverrideST write SetFactorOverrideST;
    // Factor overriding the factor determined by the rules associated with the code.
    property factorOverrideElement : TFhirDecimal read FFactorOverride write SetFactorOverride;

    // Typed access to Total price of the charge overriding the list price associated with the code. (defined for API consistency)
    property priceOverride : TFhirMoney read FPriceOverride write SetPriceOverride;
    // Total price of the charge overriding the list price associated with the code.
    property priceOverrideElement : TFhirMoney read FPriceOverride write SetPriceOverride;

    // Typed access to If the list price or the rule-based factor associated with the code is overridden, this attribute can capture a text to indicate the  reason for this action.
    property overrideReason : String read GetOverrideReasonST write SetOverrideReasonST;
    // If the list price or the rule-based factor associated with the code is overridden, this attribute can capture a text to indicate the  reason for this action.
    property overrideReasonElement : TFhirString read FOverrideReason write SetOverrideReason;

    // Typed access to The device, practitioner, etc. who entered the charge item. (defined for API consistency)
    property enterer : TFhirReference read FEnterer write SetEnterer;
    // The device, practitioner, etc. who entered the charge item.
    property entererElement : TFhirReference read FEnterer write SetEnterer;

    // Typed access to Date the charge item was entered.
    property enteredDate : TFslDateTime read GetEnteredDateST write SetEnteredDateST;
    // Date the charge item was entered.
    property enteredDateElement : TFhirDateTime read FEnteredDate write SetEnteredDate;

    // Describes why the event occurred in coded or textual form.
    property reasonList : TFhirCodeableConceptList read GetReasonList;
    property hasReasonList : boolean read GetHasReasonList;

    // Indicated the rendered service that caused this charge.
    property serviceList : TFhirReferenceList read GetServiceList;
    property hasServiceList : boolean read GetHasServiceList;

    // Typed access to Identifies the device, food, drug or other product being charged either by type code or reference to an instance. (defined for API consistency)
    property product : TFhirDataType read FProduct write SetProduct;
    // Identifies the device, food, drug or other product being charged either by type code or reference to an instance.
    property productElement : TFhirDataType read FProduct write SetProduct;

    // Account into which this ChargeItems belongs.
    property accountList : TFhirReferenceList read GetAccountList;
    property hasAccountList : boolean read GetHasAccountList;

    // Comments made about the event by the performer, subject or other participants.
    property noteList : TFhirAnnotationList read GetNoteList;
    property hasNoteList : boolean read GetHasNoteList;

    // Further information supporting this charge.
    property supportingInformationList : TFhirReferenceList read GetSupportingInformationList;
    property hasSupportingInformationList : boolean read GetHasSupportingInformationList;

  end;

  TFhirChargeItemListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirChargeItemList;
    function GetCurrent : TFhirChargeItem;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirChargeItemList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirChargeItem read GetCurrent;
  end;

  TFhirChargeItemList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirChargeItem;
    procedure SetItemN(index : Integer; value : TFhirChargeItem);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirChargeItemList; overload;
    function Clone : TFhirChargeItemList; overload;
    function GetEnumerator : TFhirChargeItemListEnumerator;
    
    //  Add a FhirChargeItem to the end of the list.
    function Append : TFhirChargeItem;
    
    // Add an already existing FhirChargeItem to the end of the list.
    procedure AddItem(value : TFhirChargeItem); overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirChargeItem) : Integer;
    
    // Insert FhirChargeItem before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirChargeItem;
    
    // Insert an existing FhirChargeItem before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirChargeItem);
    
    // Get the iIndexth FhirChargeItem. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirChargeItem);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirChargeItem;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirChargeItems[index : Integer] : TFhirChargeItem read GetItemN write SetItemN; default;
  End;

{$ENDIF FHIR_CHARGEITEM}
{$IFDEF FHIR_CHARGEITEMDEFINITION}
  // Expressions that describe applicability criteria for the billing code.
  TFhirChargeItemDefinitionApplicability = class (TFhirBackboneElement)
  protected
    FDescription : TFhirString;
    FLanguage : TFhirString;
    FExpression : TFhirString;
    procedure SetDescription(value : TFhirString);
    function GetDescriptionST : String;
    procedure SetDescriptionST(value : String);
    procedure SetLanguage(value : TFhirString);
    function GetLanguageST : String;
    procedure SetLanguageST(value : String);
    procedure SetExpression(value : TFhirString);
    function GetExpressionST : String;
    procedure SetExpressionST(value : String);
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirChargeItemDefinitionApplicability; overload;
    function Clone : TFhirChargeItemDefinitionApplicability; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to A brief, natural language description of the condition that effectively communicates the intended semantics.
    property description : String read GetDescriptionST write SetDescriptionST;
    // A brief, natural language description of the condition that effectively communicates the intended semantics.
    property descriptionElement : TFhirString read FDescription write SetDescription;

    // Typed access to The media type of the language for the expression, e.g. "text/cql" for Clinical Query Language expressions or "text/fhirpath" for FHIRPath expressions.
    property language : String read GetLanguageST write SetLanguageST;
    // The media type of the language for the expression, e.g. "text/cql" for Clinical Query Language expressions or "text/fhirpath" for FHIRPath expressions.
    property languageElement : TFhirString read FLanguage write SetLanguage;

    // Typed access to An expression that returns true or false, indicating whether the condition is satisfied. When using FHIRPath expressions, the %context environment variable must be replaced at runtime with the ChargeItem resource to which this definition is applied.
    property expression : String read GetExpressionST write SetExpressionST;
    // An expression that returns true or false, indicating whether the condition is satisfied. When using FHIRPath expressions, the %context environment variable must be replaced at runtime with the ChargeItem resource to which this definition is applied.
    property expressionElement : TFhirString read FExpression write SetExpression;

  end;

  TFhirChargeItemDefinitionApplicabilityListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirChargeItemDefinitionApplicabilityList;
    function GetCurrent : TFhirChargeItemDefinitionApplicability;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirChargeItemDefinitionApplicabilityList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirChargeItemDefinitionApplicability read GetCurrent;
  end;

  TFhirChargeItemDefinitionApplicabilityList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirChargeItemDefinitionApplicability;
    procedure SetItemN(index : Integer; value : TFhirChargeItemDefinitionApplicability);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirChargeItemDefinitionApplicabilityList; overload;
    function Clone : TFhirChargeItemDefinitionApplicabilityList; overload;
    function GetEnumerator : TFhirChargeItemDefinitionApplicabilityListEnumerator;
    
    //  Add a FhirChargeItemDefinitionApplicability to the end of the list.
    function Append : TFhirChargeItemDefinitionApplicability;
    
    // Add an already existing FhirChargeItemDefinitionApplicability to the end of the list.
    procedure AddItem(value : TFhirChargeItemDefinitionApplicability); overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirChargeItemDefinitionApplicability) : Integer;
    
    // Insert FhirChargeItemDefinitionApplicability before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirChargeItemDefinitionApplicability;
    
    // Insert an existing FhirChargeItemDefinitionApplicability before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirChargeItemDefinitionApplicability);
    
    // Get the iIndexth FhirChargeItemDefinitionApplicability. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirChargeItemDefinitionApplicability);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirChargeItemDefinitionApplicability;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirChargeItemDefinitionApplicabilities[index : Integer] : TFhirChargeItemDefinitionApplicability read GetItemN write SetItemN; default;
  End;

  // Group of properties which are applicable under the same conditions. If no applicability rules are established for the group, then all properties always apply.
  TFhirChargeItemDefinitionPropertyGroup = class (TFhirBackboneElement)
  protected
    FapplicabilityList : TFhirChargeItemDefinitionApplicabilityList;
    FpriceComponentList : TFhirChargeItemDefinitionPropertyGroupPriceComponentList;
    function GetApplicabilityList : TFhirChargeItemDefinitionApplicabilityList;
    function GetHasApplicabilityList : Boolean;
    function GetPriceComponentList : TFhirChargeItemDefinitionPropertyGroupPriceComponentList;
    function GetHasPriceComponentList : Boolean;
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirChargeItemDefinitionPropertyGroup; overload;
    function Clone : TFhirChargeItemDefinitionPropertyGroup; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Expressions that describe applicability criteria for the priceComponent.
    property applicabilityList : TFhirChargeItemDefinitionApplicabilityList read GetApplicabilityList;
    property hasApplicabilityList : boolean read GetHasApplicabilityList;

    // The price for a ChargeItem may be calculated as a base price with surcharges/deductions that apply in certain conditions. A ChargeItemDefinition resource that defines the prices, factors and conditions that apply to a billing code is currently under development. The priceComponent element can be used to offer transparency to the recipient of the Invoice of how the prices have been calculated.
    property priceComponentList : TFhirChargeItemDefinitionPropertyGroupPriceComponentList read GetPriceComponentList;
    property hasPriceComponentList : boolean read GetHasPriceComponentList;

  end;

  TFhirChargeItemDefinitionPropertyGroupListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirChargeItemDefinitionPropertyGroupList;
    function GetCurrent : TFhirChargeItemDefinitionPropertyGroup;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirChargeItemDefinitionPropertyGroupList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirChargeItemDefinitionPropertyGroup read GetCurrent;
  end;

  TFhirChargeItemDefinitionPropertyGroupList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirChargeItemDefinitionPropertyGroup;
    procedure SetItemN(index : Integer; value : TFhirChargeItemDefinitionPropertyGroup);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirChargeItemDefinitionPropertyGroupList; overload;
    function Clone : TFhirChargeItemDefinitionPropertyGroupList; overload;
    function GetEnumerator : TFhirChargeItemDefinitionPropertyGroupListEnumerator;
    
    //  Add a FhirChargeItemDefinitionPropertyGroup to the end of the list.
    function Append : TFhirChargeItemDefinitionPropertyGroup;
    
    // Add an already existing FhirChargeItemDefinitionPropertyGroup to the end of the list.
    procedure AddItem(value : TFhirChargeItemDefinitionPropertyGroup); overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirChargeItemDefinitionPropertyGroup) : Integer;
    
    // Insert FhirChargeItemDefinitionPropertyGroup before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirChargeItemDefinitionPropertyGroup;
    
    // Insert an existing FhirChargeItemDefinitionPropertyGroup before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirChargeItemDefinitionPropertyGroup);
    
    // Get the iIndexth FhirChargeItemDefinitionPropertyGroup. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirChargeItemDefinitionPropertyGroup);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirChargeItemDefinitionPropertyGroup;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirChargeItemDefinitionPropertyGroups[index : Integer] : TFhirChargeItemDefinitionPropertyGroup read GetItemN write SetItemN; default;
  End;

  // The price for a ChargeItem may be calculated as a base price with surcharges/deductions that apply in certain conditions. A ChargeItemDefinition resource that defines the prices, factors and conditions that apply to a billing code is currently under development. The priceComponent element can be used to offer transparency to the recipient of the Invoice of how the prices have been calculated.
  TFhirChargeItemDefinitionPropertyGroupPriceComponent = class (TFhirBackboneElement)
  protected
    FType_ : TFhirEnum;
    FCode : TFhirCodeableConcept;
    FFactor : TFhirDecimal;
    FAmount : TFhirMoney;
    procedure SetType_(value : TFhirEnum);
    function GetType_ST : TFhirInvoicePriceComponentTypeEnum;
    procedure SetType_ST(value : TFhirInvoicePriceComponentTypeEnum);
    procedure SetCode(value : TFhirCodeableConcept);
    procedure SetFactor(value : TFhirDecimal);
    function GetFactorST : String;
    procedure SetFactorST(value : String);
    procedure SetAmount(value : TFhirMoney);
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirChargeItemDefinitionPropertyGroupPriceComponent; overload;
    function Clone : TFhirChargeItemDefinitionPropertyGroupPriceComponent; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // This code identifies the type of the component.
    property type_ : TFhirInvoicePriceComponentTypeEnum read GetType_ST write SetType_ST;
    property type_Element : TFhirEnum read FType_ write SetType_;

    // Typed access to A code that identifies the component. Codes may be used to differentiate between kinds of taxes, surcharges, discounts etc. (defined for API consistency)
    property code : TFhirCodeableConcept read FCode write SetCode;
    // A code that identifies the component. Codes may be used to differentiate between kinds of taxes, surcharges, discounts etc.
    property codeElement : TFhirCodeableConcept read FCode write SetCode;

    // Typed access to The factor that has been applied on the base price for calculating this component.
    property factor : String read GetFactorST write SetFactorST;
    // The factor that has been applied on the base price for calculating this component.
    property factorElement : TFhirDecimal read FFactor write SetFactor;

    // Typed access to The amount calculated for this component. (defined for API consistency)
    property amount : TFhirMoney read FAmount write SetAmount;
    // The amount calculated for this component.
    property amountElement : TFhirMoney read FAmount write SetAmount;

  end;

  TFhirChargeItemDefinitionPropertyGroupPriceComponentListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirChargeItemDefinitionPropertyGroupPriceComponentList;
    function GetCurrent : TFhirChargeItemDefinitionPropertyGroupPriceComponent;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirChargeItemDefinitionPropertyGroupPriceComponentList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirChargeItemDefinitionPropertyGroupPriceComponent read GetCurrent;
  end;

  TFhirChargeItemDefinitionPropertyGroupPriceComponentList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirChargeItemDefinitionPropertyGroupPriceComponent;
    procedure SetItemN(index : Integer; value : TFhirChargeItemDefinitionPropertyGroupPriceComponent);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirChargeItemDefinitionPropertyGroupPriceComponentList; overload;
    function Clone : TFhirChargeItemDefinitionPropertyGroupPriceComponentList; overload;
    function GetEnumerator : TFhirChargeItemDefinitionPropertyGroupPriceComponentListEnumerator;
    
    //  Add a FhirChargeItemDefinitionPropertyGroupPriceComponent to the end of the list.
    function Append : TFhirChargeItemDefinitionPropertyGroupPriceComponent;
    
    // Add an already existing FhirChargeItemDefinitionPropertyGroupPriceComponent to the end of the list.
    procedure AddItem(value : TFhirChargeItemDefinitionPropertyGroupPriceComponent); overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirChargeItemDefinitionPropertyGroupPriceComponent) : Integer;
    
    // Insert FhirChargeItemDefinitionPropertyGroupPriceComponent before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirChargeItemDefinitionPropertyGroupPriceComponent;
    
    // Insert an existing FhirChargeItemDefinitionPropertyGroupPriceComponent before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirChargeItemDefinitionPropertyGroupPriceComponent);
    
    // Get the iIndexth FhirChargeItemDefinitionPropertyGroupPriceComponent. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirChargeItemDefinitionPropertyGroupPriceComponent);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirChargeItemDefinitionPropertyGroupPriceComponent;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirChargeItemDefinitionPropertyGroupPriceComponents[index : Integer] : TFhirChargeItemDefinitionPropertyGroupPriceComponent read GetItemN write SetItemN; default;
  End;

  // The ChargeItemDefinition resource provides the properties that apply to the (billing) codes necessary to calculate costs and prices. The properties may differ largely depending on type and realm, therefore this resource gives only a rough structure and requires profiling for each type of billing code system.
  TFhirChargeItemDefinition = class (TFhirMetadataResource)
  protected
    FderivedFromUriList : TFhirUriList;
    FpartOfList : TFhirCanonicalList;
    FreplacesList : TFhirCanonicalList;
    FCode : TFhirCodeableConcept;
    FinstanceList : TFhirReferenceList;
    FapplicabilityList : TFhirChargeItemDefinitionApplicabilityList;
    FpropertyGroupList : TFhirChargeItemDefinitionPropertyGroupList;
    procedure SetUrl(value : TFhirUri);
    function GetUrlST : String;
    procedure SetUrlST(value : String);
    function GetIdentifierList : TFhirIdentifierList;
    function GetHasIdentifierList : Boolean;
    procedure SetVersion(value : TFhirString);
    function GetVersionST : String;
    procedure SetVersionST(value : String);
    procedure SetTitle(value : TFhirString);
    function GetTitleST : String;
    procedure SetTitleST(value : String);
    function GetDerivedFromUriList : TFhirUriList;
    function GetHasDerivedFromUriList : Boolean;
    function GetPartOfList : TFhirCanonicalList;
    function GetHasPartOfList : Boolean;
    function GetReplacesList : TFhirCanonicalList;
    function GetHasReplacesList : Boolean;
    procedure SetStatus(value : TFhirEnum);
    function GetStatusST : TFhirPublicationStatusEnum;
    procedure SetStatusST(value : TFhirPublicationStatusEnum);
    procedure SetExperimental(value : TFhirBoolean);
    function GetExperimentalST : Boolean;
    procedure SetExperimentalST(value : Boolean);
    procedure SetDate(value : TFhirDateTime);
    function GetDateST : TFslDateTime;
    procedure SetDateST(value : TFslDateTime);
    procedure SetPublisher(value : TFhirString);
    function GetPublisherST : String;
    procedure SetPublisherST(value : String);
    function GetContactList : TFhirContactDetailList;
    function GetHasContactList : Boolean;
    procedure SetDescription(value : TFhirMarkdown);
    function GetDescriptionST : String;
    procedure SetDescriptionST(value : String);
    function GetUseContextList : TFhirUsageContextList;
    function GetHasUseContextList : Boolean;
    function GetJurisdictionList : TFhirCodeableConceptList;
    function GetHasJurisdictionList : Boolean;
    procedure SetCopyright(value : TFhirMarkdown);
    function GetCopyrightST : String;
    procedure SetCopyrightST(value : String);
    procedure SetApprovalDate(value : TFhirDate);
    function GetApprovalDateST : TFslDateTime;
    procedure SetApprovalDateST(value : TFslDateTime);
    procedure SetLastReviewDate(value : TFhirDate);
    function GetLastReviewDateST : TFslDateTime;
    procedure SetLastReviewDateST(value : TFslDateTime);
    procedure SetEffectivePeriod(value : TFhirPeriod);
    procedure SetCode(value : TFhirCodeableConcept);
    function GetInstanceList : TFhirReferenceList;
    function GetHasInstanceList : Boolean;
    function GetApplicabilityList : TFhirChargeItemDefinitionApplicabilityList;
    function GetHasApplicabilityList : Boolean;
    function GetPropertyGroupList : TFhirChargeItemDefinitionPropertyGroupList;
    function GetHasPropertyGroupList : Boolean;
  
    function GetResourceType : TFhirResourceType; override;
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirChargeItemDefinition; overload;
    function Clone : TFhirChargeItemDefinition; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to An absolute URI that is used to identify this charge item definition when it is referenced in a specification, model, design or an instance; also called its canonical identifier. This SHOULD be globally unique and SHOULD be a literal address at which at which an authoritative instance of this charge item definition is (or will be) published. This URL can be the target of a canonical reference. It SHALL remain the same when the charge item definition is stored on different servers.
    property url : String read GetUrlST write SetUrlST;
    // An absolute URI that is used to identify this charge item definition when it is referenced in a specification, model, design or an instance; also called its canonical identifier. This SHOULD be globally unique and SHOULD be a literal address at which at which an authoritative instance of this charge item definition is (or will be) published. This URL can be the target of a canonical reference. It SHALL remain the same when the charge item definition is stored on different servers.
    property urlElement : TFhirUri read FUrl write SetUrl;

    // A formal identifier that is used to identify this charge item definition when it is represented in other formats, or referenced in a specification, model, design or an instance.
    property identifierList : TFhirIdentifierList read GetIdentifierList;
    property hasIdentifierList : boolean read GetHasIdentifierList;

    // Typed access to The identifier that is used to identify this version of the charge item definition when it is referenced in a specification, model, design or instance. This is an arbitrary value managed by the charge item definition author and is not expected to be globally unique. For example, it might be a timestamp (e.g. yyyymmdd) if a managed version is not available. There is also no expectation that versions can be placed in a lexicographical sequence. To provide a version consistent with the Decision Support Service specification, use the format Major.Minor.Revision (e.g. 1.0.0). For more information on versioning knowledge assets, refer to the Decision Support Service specification. Note that a version is required for non-experimental active assets.
    property version : String read GetVersionST write SetVersionST;
    // The identifier that is used to identify this version of the charge item definition when it is referenced in a specification, model, design or instance. This is an arbitrary value managed by the charge item definition author and is not expected to be globally unique. For example, it might be a timestamp (e.g. yyyymmdd) if a managed version is not available. There is also no expectation that versions can be placed in a lexicographical sequence. To provide a version consistent with the Decision Support Service specification, use the format Major.Minor.Revision (e.g. 1.0.0). For more information on versioning knowledge assets, refer to the Decision Support Service specification. Note that a version is required for non-experimental active assets.
    property versionElement : TFhirString read FVersion write SetVersion;

    // Typed access to A short, descriptive, user-friendly title for the charge item definition.
    property title : String read GetTitleST write SetTitleST;
    // A short, descriptive, user-friendly title for the charge item definition.
    property titleElement : TFhirString read FTitle write SetTitle;

    // The URL pointing to an externally-defined charge item definition that is adhered to in whole or in part by this definition.
    property derivedFromUriList : TFhirUriList read GetDerivedFromUriList;
    property hasDerivedFromUriList : boolean read GetHasDerivedFromUriList;

    // A larger definition of which this particular definition is a component or step.
    property partOfList : TFhirCanonicalList read GetPartOfList;
    property hasPartOfList : boolean read GetHasPartOfList;

    // As new versions of a protocol or guideline are defined, allows identification of what versions are replaced by a new instance.
    property replacesList : TFhirCanonicalList read GetReplacesList;
    property hasReplacesList : boolean read GetHasReplacesList;

    // The current state of the ChargeItemDefinition.
    property status : TFhirPublicationStatusEnum read GetStatusST write SetStatusST;
    property statusElement : TFhirEnum read FStatus write SetStatus;

    // Typed access to A Boolean value to indicate that this charge item definition is authored for testing purposes (or education/evaluation/marketing) and is not intended to be used for genuine usage.
    property experimental : Boolean read GetExperimentalST write SetExperimentalST;
    // A Boolean value to indicate that this charge item definition is authored for testing purposes (or education/evaluation/marketing) and is not intended to be used for genuine usage.
    property experimentalElement : TFhirBoolean read FExperimental write SetExperimental;

    // Typed access to The date  (and optionally time) when the charge item definition was published. The date must change when the business version changes and it must change if the status code changes. In addition, it should change when the substantive content of the charge item definition changes.
    property date : TFslDateTime read GetDateST write SetDateST;
    // The date  (and optionally time) when the charge item definition was published. The date must change when the business version changes and it must change if the status code changes. In addition, it should change when the substantive content of the charge item definition changes.
    property dateElement : TFhirDateTime read FDate write SetDate;

    // Typed access to The name of the organization or individual that published the charge item definition.
    property publisher : String read GetPublisherST write SetPublisherST;
    // The name of the organization or individual that published the charge item definition.
    property publisherElement : TFhirString read FPublisher write SetPublisher;

    // Contact details to assist a user in finding and communicating with the publisher.
    property contactList : TFhirContactDetailList read GetContactList;
    property hasContactList : boolean read GetHasContactList;

    // Typed access to A free text natural language description of the charge item definition from a consumer's perspective.
    property description : String read GetDescriptionST write SetDescriptionST;
    // A free text natural language description of the charge item definition from a consumer's perspective.
    property descriptionElement : TFhirMarkdown read FDescription write SetDescription;

    // The content was developed with a focus and intent of supporting the contexts that are listed. These contexts may be general categories (gender, age, ...) or may be references to specific programs (insurance plans, studies, ...) and may be used to assist with indexing and searching for appropriate charge item definition instances.
    property useContextList : TFhirUsageContextList read GetUseContextList;
    property hasUseContextList : boolean read GetHasUseContextList;

    // A legal or geographic region in which the charge item definition is intended to be used.
    property jurisdictionList : TFhirCodeableConceptList read GetJurisdictionList;
    property hasJurisdictionList : boolean read GetHasJurisdictionList;

    // Typed access to A copyright statement relating to the charge item definition and/or its contents. Copyright statements are generally legal restrictions on the use and publishing of the charge item definition.
    property copyright : String read GetCopyrightST write SetCopyrightST;
    // A copyright statement relating to the charge item definition and/or its contents. Copyright statements are generally legal restrictions on the use and publishing of the charge item definition.
    property copyrightElement : TFhirMarkdown read FCopyright write SetCopyright;

    // Typed access to The date on which the resource content was approved by the publisher. Approval happens once when the content is officially approved for usage.
    property approvalDate : TFslDateTime read GetApprovalDateST write SetApprovalDateST;
    // The date on which the resource content was approved by the publisher. Approval happens once when the content is officially approved for usage.
    property approvalDateElement : TFhirDate read FApprovalDate write SetApprovalDate;

    // Typed access to The date on which the resource content was last reviewed. Review happens periodically after approval but does not change the original approval date.
    property lastReviewDate : TFslDateTime read GetLastReviewDateST write SetLastReviewDateST;
    // The date on which the resource content was last reviewed. Review happens periodically after approval but does not change the original approval date.
    property lastReviewDateElement : TFhirDate read FLastReviewDate write SetLastReviewDate;

    // Typed access to The period during which the charge item definition content was or is planned to be in active use. (defined for API consistency)
    property effectivePeriod : TFhirPeriod read FEffectivePeriod write SetEffectivePeriod;
    // The period during which the charge item definition content was or is planned to be in active use.
    property effectivePeriodElement : TFhirPeriod read FEffectivePeriod write SetEffectivePeriod;

    // Typed access to The defined billing details in this resource pertain to the given billing code. (defined for API consistency)
    property code : TFhirCodeableConcept read FCode write SetCode;
    // The defined billing details in this resource pertain to the given billing code.
    property codeElement : TFhirCodeableConcept read FCode write SetCode;

    // The defined billing details in this resource pertain to the given product instance(s).
    property instanceList : TFhirReferenceList read GetInstanceList;
    property hasInstanceList : boolean read GetHasInstanceList;

    // Expressions that describe applicability criteria for the billing code.
    property applicabilityList : TFhirChargeItemDefinitionApplicabilityList read GetApplicabilityList;
    property hasApplicabilityList : boolean read GetHasApplicabilityList;

    // Group of properties which are applicable under the same conditions. If no applicability rules are established for the group, then all properties always apply.
    property propertyGroupList : TFhirChargeItemDefinitionPropertyGroupList read GetPropertyGroupList;
    property hasPropertyGroupList : boolean read GetHasPropertyGroupList;

  end;

  TFhirChargeItemDefinitionListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirChargeItemDefinitionList;
    function GetCurrent : TFhirChargeItemDefinition;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirChargeItemDefinitionList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirChargeItemDefinition read GetCurrent;
  end;

  TFhirChargeItemDefinitionList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirChargeItemDefinition;
    procedure SetItemN(index : Integer; value : TFhirChargeItemDefinition);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirChargeItemDefinitionList; overload;
    function Clone : TFhirChargeItemDefinitionList; overload;
    function GetEnumerator : TFhirChargeItemDefinitionListEnumerator;
    
    //  Add a FhirChargeItemDefinition to the end of the list.
    function Append : TFhirChargeItemDefinition;
    
    // Add an already existing FhirChargeItemDefinition to the end of the list.
    procedure AddItem(value : TFhirChargeItemDefinition); overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirChargeItemDefinition) : Integer;
    
    // Insert FhirChargeItemDefinition before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirChargeItemDefinition;
    
    // Insert an existing FhirChargeItemDefinition before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirChargeItemDefinition);
    
    // Get the iIndexth FhirChargeItemDefinition. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirChargeItemDefinition);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirChargeItemDefinition;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirChargeItemDefinitions[index : Integer] : TFhirChargeItemDefinition read GetItemN write SetItemN; default;
  End;

{$ENDIF FHIR_CHARGEITEMDEFINITION}
{$IFDEF FHIR_CITATION}
  // The assignment to an organizing scheme.
  TFhirCitationClassification = class (TFhirBackboneElement)
  protected
    FType_ : TFhirCodeableConcept;
    FclassifierList : TFhirCodeableConceptList;
    procedure SetType_(value : TFhirCodeableConcept);
    function GetClassifierList : TFhirCodeableConceptList;
    function GetHasClassifierList : Boolean;
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirCitationClassification; overload;
    function Clone : TFhirCitationClassification; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to The kind of classifier (e.g. publication type, keyword). (defined for API consistency)
    property type_ : TFhirCodeableConcept read FType_ write SetType_;
    // The kind of classifier (e.g. publication type, keyword).
    property type_Element : TFhirCodeableConcept read FType_ write SetType_;

    // The specific classification value.
    property classifierList : TFhirCodeableConceptList read GetClassifierList;
    property hasClassifierList : boolean read GetHasClassifierList;

  end;

  TFhirCitationClassificationListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirCitationClassificationList;
    function GetCurrent : TFhirCitationClassification;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirCitationClassificationList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirCitationClassification read GetCurrent;
  end;

  TFhirCitationClassificationList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirCitationClassification;
    procedure SetItemN(index : Integer; value : TFhirCitationClassification);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirCitationClassificationList; overload;
    function Clone : TFhirCitationClassificationList; overload;
    function GetEnumerator : TFhirCitationClassificationListEnumerator;
    
    //  Add a FhirCitationClassification to the end of the list.
    function Append : TFhirCitationClassification;
    
    // Add an already existing FhirCitationClassification to the end of the list.
    procedure AddItem(value : TFhirCitationClassification); overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirCitationClassification) : Integer;
    
    // Insert FhirCitationClassification before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirCitationClassification;
    
    // Insert an existing FhirCitationClassification before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirCitationClassification);
    
    // Get the iIndexth FhirCitationClassification. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirCitationClassification);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirCitationClassification;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirCitationClassifications[index : Integer] : TFhirCitationClassification read GetItemN write SetItemN; default;
  End;

  // An effective date or period for a status of the citation.
  TFhirCitationStatusDate = class (TFhirBackboneElement)
  protected
    FActivity : TFhirCodeableConcept;
    FActual : TFhirBoolean;
    FPeriod : TFhirPeriod;
    procedure SetActivity(value : TFhirCodeableConcept);
    procedure SetActual(value : TFhirBoolean);
    function GetActualST : Boolean;
    procedure SetActualST(value : Boolean);
    procedure SetPeriod(value : TFhirPeriod);
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirCitationStatusDate; overload;
    function Clone : TFhirCitationStatusDate; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to Classification of the status. (defined for API consistency)
    property activity : TFhirCodeableConcept read FActivity write SetActivity;
    // Classification of the status.
    property activityElement : TFhirCodeableConcept read FActivity write SetActivity;

    // Typed access to Either occurred or expected.
    property actual : Boolean read GetActualST write SetActualST;
    // Either occurred or expected.
    property actualElement : TFhirBoolean read FActual write SetActual;

    // Typed access to When the status started and/or ended. (defined for API consistency)
    property period : TFhirPeriod read FPeriod write SetPeriod;
    // When the status started and/or ended.
    property periodElement : TFhirPeriod read FPeriod write SetPeriod;

  end;

  TFhirCitationStatusDateListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirCitationStatusDateList;
    function GetCurrent : TFhirCitationStatusDate;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirCitationStatusDateList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirCitationStatusDate read GetCurrent;
  end;

  TFhirCitationStatusDateList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirCitationStatusDate;
    procedure SetItemN(index : Integer; value : TFhirCitationStatusDate);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirCitationStatusDateList; overload;
    function Clone : TFhirCitationStatusDateList; overload;
    function GetEnumerator : TFhirCitationStatusDateListEnumerator;
    
    //  Add a FhirCitationStatusDate to the end of the list.
    function Append : TFhirCitationStatusDate;
    
    // Add an already existing FhirCitationStatusDate to the end of the list.
    procedure AddItem(value : TFhirCitationStatusDate); overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirCitationStatusDate) : Integer;
    
    // Insert FhirCitationStatusDate before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirCitationStatusDate;
    
    // Insert an existing FhirCitationStatusDate before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirCitationStatusDate);
    
    // Get the iIndexth FhirCitationStatusDate. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirCitationStatusDate);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirCitationStatusDate;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirCitationStatusDates[index : Integer] : TFhirCitationStatusDate read GetItemN write SetItemN; default;
  End;

  // Artifact related to the Citation Resource.
  TFhirCitationRelatesTo = class (TFhirBackboneElement)
  protected
    FRelationshipType : TFhirCodeableConcept;
    FtargetClassifierList : TFhirCodeableConceptList;
    FTarget : TFhirDataType;
    procedure SetRelationshipType(value : TFhirCodeableConcept);
    function GetTargetClassifierList : TFhirCodeableConceptList;
    function GetHasTargetClassifierList : Boolean;
    procedure SetTarget(value : TFhirDataType);
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirCitationRelatesTo; overload;
    function Clone : TFhirCitationRelatesTo; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to How the Citation resource relates to the target artifact. (defined for API consistency)
    property relationshipType : TFhirCodeableConcept read FRelationshipType write SetRelationshipType;
    // How the Citation resource relates to the target artifact.
    property relationshipTypeElement : TFhirCodeableConcept read FRelationshipType write SetRelationshipType;

    // The clasification of the related artifact.
    property targetClassifierList : TFhirCodeableConceptList read GetTargetClassifierList;
    property hasTargetClassifierList : boolean read GetHasTargetClassifierList;

    // Typed access to The article or artifact that the Citation Resource is related to. (defined for API consistency)
    property target : TFhirDataType read FTarget write SetTarget;
    // The article or artifact that the Citation Resource is related to.
    property targetElement : TFhirDataType read FTarget write SetTarget;

  end;

  TFhirCitationRelatesToListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirCitationRelatesToList;
    function GetCurrent : TFhirCitationRelatesTo;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirCitationRelatesToList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirCitationRelatesTo read GetCurrent;
  end;

  TFhirCitationRelatesToList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirCitationRelatesTo;
    procedure SetItemN(index : Integer; value : TFhirCitationRelatesTo);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirCitationRelatesToList; overload;
    function Clone : TFhirCitationRelatesToList; overload;
    function GetEnumerator : TFhirCitationRelatesToListEnumerator;
    
    //  Add a FhirCitationRelatesTo to the end of the list.
    function Append : TFhirCitationRelatesTo;
    
    // Add an already existing FhirCitationRelatesTo to the end of the list.
    procedure AddItem(value : TFhirCitationRelatesTo); overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirCitationRelatesTo) : Integer;
    
    // Insert FhirCitationRelatesTo before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirCitationRelatesTo;
    
    // Insert an existing FhirCitationRelatesTo before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirCitationRelatesTo);
    
    // Get the iIndexth FhirCitationRelatesTo. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirCitationRelatesTo);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirCitationRelatesTo;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirCitationRelatesTos[index : Integer] : TFhirCitationRelatesTo read GetItemN write SetItemN; default;
  End;

  // The article or artifact being described.
  TFhirCitationCitedArtifact = class (TFhirBackboneElement)
  protected
    FidentifierList : TFhirIdentifierList;
    FrelatedIdentifierList : TFhirIdentifierList;
    FDateAccessed : TFhirDateTime;
    FVersion : TFhirCitationCitedArtifactVersion;
    FcurrentStateList : TFhirCodeableConceptList;
    FstatusDateList : TFhirCitationCitedArtifactStatusDateList;
    FtitleList : TFhirCitationCitedArtifactTitleList;
    FabstractList : TFhirCitationCitedArtifactAbstractList;
    FPart : TFhirCitationCitedArtifactPart;
    FrelatesToList : TFhirCitationCitedArtifactRelatesToList;
    FpublicationFormList : TFhirCitationCitedArtifactPublicationFormList;
    FwebLocationList : TFhirCitationCitedArtifactWebLocationList;
    FclassificationList : TFhirCitationCitedArtifactClassificationList;
    FContributorship : TFhirCitationCitedArtifactContributorship;
    FnoteList : TFhirAnnotationList;
    function GetIdentifierList : TFhirIdentifierList;
    function GetHasIdentifierList : Boolean;
    function GetRelatedIdentifierList : TFhirIdentifierList;
    function GetHasRelatedIdentifierList : Boolean;
    procedure SetDateAccessed(value : TFhirDateTime);
    function GetDateAccessedST : TFslDateTime;
    procedure SetDateAccessedST(value : TFslDateTime);
    procedure SetVersion(value : TFhirCitationCitedArtifactVersion);
    function GetCurrentStateList : TFhirCodeableConceptList;
    function GetHasCurrentStateList : Boolean;
    function GetStatusDateList : TFhirCitationCitedArtifactStatusDateList;
    function GetHasStatusDateList : Boolean;
    function GetTitleList : TFhirCitationCitedArtifactTitleList;
    function GetHasTitleList : Boolean;
    function GetAbstractList : TFhirCitationCitedArtifactAbstractList;
    function GetHasAbstractList : Boolean;
    procedure SetPart(value : TFhirCitationCitedArtifactPart);
    function GetRelatesToList : TFhirCitationCitedArtifactRelatesToList;
    function GetHasRelatesToList : Boolean;
    function GetPublicationFormList : TFhirCitationCitedArtifactPublicationFormList;
    function GetHasPublicationFormList : Boolean;
    function GetWebLocationList : TFhirCitationCitedArtifactWebLocationList;
    function GetHasWebLocationList : Boolean;
    function GetClassificationList : TFhirCitationCitedArtifactClassificationList;
    function GetHasClassificationList : Boolean;
    procedure SetContributorship(value : TFhirCitationCitedArtifactContributorship);
    function GetNoteList : TFhirAnnotationList;
    function GetHasNoteList : Boolean;
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirCitationCitedArtifact; overload;
    function Clone : TFhirCitationCitedArtifact; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // A formal identifier that is used to identify this citation when it is represented in other formats, or referenced in a specification, model, design or an instance.
    property identifierList : TFhirIdentifierList read GetIdentifierList;
    property hasIdentifierList : boolean read GetHasIdentifierList;

    // A formal identifier that is used to identify things closely related to this citation.
    property relatedIdentifierList : TFhirIdentifierList read GetRelatedIdentifierList;
    property hasRelatedIdentifierList : boolean read GetHasRelatedIdentifierList;

    // Typed access to When the cited artifact was accessed.
    property dateAccessed : TFslDateTime read GetDateAccessedST write SetDateAccessedST;
    // When the cited artifact was accessed.
    property dateAccessedElement : TFhirDateTime read FDateAccessed write SetDateAccessed;

    // Typed access to The defined version of the cited artifact. (defined for API consistency)
    property version : TFhirCitationCitedArtifactVersion read FVersion write SetVersion;
    // The defined version of the cited artifact.
    property versionElement : TFhirCitationCitedArtifactVersion read FVersion write SetVersion;

    // The status of the cited artifact.
    property currentStateList : TFhirCodeableConceptList read GetCurrentStateList;
    property hasCurrentStateList : boolean read GetHasCurrentStateList;

    // An effective date or period for a status of the cited artifact.
    property statusDateList : TFhirCitationCitedArtifactStatusDateList read GetStatusDateList;
    property hasStatusDateList : boolean read GetHasStatusDateList;

    // The title details of the article or artifact.
    property titleList : TFhirCitationCitedArtifactTitleList read GetTitleList;
    property hasTitleList : boolean read GetHasTitleList;

    // Summary of the article or artifact.
    property abstractList : TFhirCitationCitedArtifactAbstractList read GetAbstractList;
    property hasAbstractList : boolean read GetHasAbstractList;

    // Typed access to The component of the article or artifact. (defined for API consistency)
    property part : TFhirCitationCitedArtifactPart read FPart write SetPart;
    // The component of the article or artifact.
    property partElement : TFhirCitationCitedArtifactPart read FPart write SetPart;

    // The artifact related to the cited artifact.
    property relatesToList : TFhirCitationCitedArtifactRelatesToList read GetRelatesToList;
    property hasRelatesToList : boolean read GetHasRelatesToList;

    // If multiple, used to represent alternative forms of the article that are not separate citations.
    property publicationFormList : TFhirCitationCitedArtifactPublicationFormList read GetPublicationFormList;
    property hasPublicationFormList : boolean read GetHasPublicationFormList;

    // Used for any URL for the article or artifact cited.
    property webLocationList : TFhirCitationCitedArtifactWebLocationList read GetWebLocationList;
    property hasWebLocationList : boolean read GetHasWebLocationList;

    // The assignment to an organizing scheme.
    property classificationList : TFhirCitationCitedArtifactClassificationList read GetClassificationList;
    property hasClassificationList : boolean read GetHasClassificationList;

    // Typed access to This element is used to list authors and other contributors, their contact information, specific contributions, and summary statements. (defined for API consistency)
    property contributorship : TFhirCitationCitedArtifactContributorship read FContributorship write SetContributorship;
    // This element is used to list authors and other contributors, their contact information, specific contributions, and summary statements.
    property contributorshipElement : TFhirCitationCitedArtifactContributorship read FContributorship write SetContributorship;

    // Any additional information or content for the article or artifact.
    property noteList : TFhirAnnotationList read GetNoteList;
    property hasNoteList : boolean read GetHasNoteList;

  end;

  TFhirCitationCitedArtifactListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirCitationCitedArtifactList;
    function GetCurrent : TFhirCitationCitedArtifact;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirCitationCitedArtifactList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirCitationCitedArtifact read GetCurrent;
  end;

  TFhirCitationCitedArtifactList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirCitationCitedArtifact;
    procedure SetItemN(index : Integer; value : TFhirCitationCitedArtifact);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirCitationCitedArtifactList; overload;
    function Clone : TFhirCitationCitedArtifactList; overload;
    function GetEnumerator : TFhirCitationCitedArtifactListEnumerator;
    
    //  Add a FhirCitationCitedArtifact to the end of the list.
    function Append : TFhirCitationCitedArtifact;
    
    // Add an already existing FhirCitationCitedArtifact to the end of the list.
    procedure AddItem(value : TFhirCitationCitedArtifact); overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirCitationCitedArtifact) : Integer;
    
    // Insert FhirCitationCitedArtifact before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirCitationCitedArtifact;
    
    // Insert an existing FhirCitationCitedArtifact before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirCitationCitedArtifact);
    
    // Get the iIndexth FhirCitationCitedArtifact. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirCitationCitedArtifact);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirCitationCitedArtifact;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirCitationCitedArtifacts[index : Integer] : TFhirCitationCitedArtifact read GetItemN write SetItemN; default;
  End;

  // The defined version of the cited artifact.
  TFhirCitationCitedArtifactVersion = class (TFhirBackboneElement)
  protected
    FValue : TFhirString;
    FBaseCitation : TFhirReference;
    procedure SetValue(value : TFhirString);
    function GetValueST : String;
    procedure SetValueST(value : String);
    procedure SetBaseCitation(value : TFhirReference);
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirCitationCitedArtifactVersion; overload;
    function Clone : TFhirCitationCitedArtifactVersion; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to The version number or other version identifier.
    property value : String read GetValueST write SetValueST;
    // The version number or other version identifier.
    property valueElement : TFhirString read FValue write SetValue;

    // Typed access to Citation for the main version of the cited artifact. (defined for API consistency)
    property baseCitation : TFhirReference read FBaseCitation write SetBaseCitation;
    // Citation for the main version of the cited artifact.
    property baseCitationElement : TFhirReference read FBaseCitation write SetBaseCitation;

  end;

  TFhirCitationCitedArtifactVersionListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirCitationCitedArtifactVersionList;
    function GetCurrent : TFhirCitationCitedArtifactVersion;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirCitationCitedArtifactVersionList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirCitationCitedArtifactVersion read GetCurrent;
  end;

  TFhirCitationCitedArtifactVersionList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirCitationCitedArtifactVersion;
    procedure SetItemN(index : Integer; value : TFhirCitationCitedArtifactVersion);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirCitationCitedArtifactVersionList; overload;
    function Clone : TFhirCitationCitedArtifactVersionList; overload;
    function GetEnumerator : TFhirCitationCitedArtifactVersionListEnumerator;
    
    //  Add a FhirCitationCitedArtifactVersion to the end of the list.
    function Append : TFhirCitationCitedArtifactVersion;
    
    // Add an already existing FhirCitationCitedArtifactVersion to the end of the list.
    procedure AddItem(value : TFhirCitationCitedArtifactVersion); overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirCitationCitedArtifactVersion) : Integer;
    
    // Insert FhirCitationCitedArtifactVersion before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirCitationCitedArtifactVersion;
    
    // Insert an existing FhirCitationCitedArtifactVersion before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirCitationCitedArtifactVersion);
    
    // Get the iIndexth FhirCitationCitedArtifactVersion. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirCitationCitedArtifactVersion);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirCitationCitedArtifactVersion;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirCitationCitedArtifactVersions[index : Integer] : TFhirCitationCitedArtifactVersion read GetItemN write SetItemN; default;
  End;

  // An effective date or period for a status of the cited artifact.
  TFhirCitationCitedArtifactStatusDate = class (TFhirBackboneElement)
  protected
    FActivity : TFhirCodeableConcept;
    FActual : TFhirBoolean;
    FPeriod : TFhirPeriod;
    procedure SetActivity(value : TFhirCodeableConcept);
    procedure SetActual(value : TFhirBoolean);
    function GetActualST : Boolean;
    procedure SetActualST(value : Boolean);
    procedure SetPeriod(value : TFhirPeriod);
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirCitationCitedArtifactStatusDate; overload;
    function Clone : TFhirCitationCitedArtifactStatusDate; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to Classification of the status. (defined for API consistency)
    property activity : TFhirCodeableConcept read FActivity write SetActivity;
    // Classification of the status.
    property activityElement : TFhirCodeableConcept read FActivity write SetActivity;

    // Typed access to Either occurred or expected.
    property actual : Boolean read GetActualST write SetActualST;
    // Either occurred or expected.
    property actualElement : TFhirBoolean read FActual write SetActual;

    // Typed access to When the status started and/or ended. (defined for API consistency)
    property period : TFhirPeriod read FPeriod write SetPeriod;
    // When the status started and/or ended.
    property periodElement : TFhirPeriod read FPeriod write SetPeriod;

  end;

  TFhirCitationCitedArtifactStatusDateListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirCitationCitedArtifactStatusDateList;
    function GetCurrent : TFhirCitationCitedArtifactStatusDate;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirCitationCitedArtifactStatusDateList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirCitationCitedArtifactStatusDate read GetCurrent;
  end;

  TFhirCitationCitedArtifactStatusDateList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirCitationCitedArtifactStatusDate;
    procedure SetItemN(index : Integer; value : TFhirCitationCitedArtifactStatusDate);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirCitationCitedArtifactStatusDateList; overload;
    function Clone : TFhirCitationCitedArtifactStatusDateList; overload;
    function GetEnumerator : TFhirCitationCitedArtifactStatusDateListEnumerator;
    
    //  Add a FhirCitationCitedArtifactStatusDate to the end of the list.
    function Append : TFhirCitationCitedArtifactStatusDate;
    
    // Add an already existing FhirCitationCitedArtifactStatusDate to the end of the list.
    procedure AddItem(value : TFhirCitationCitedArtifactStatusDate); overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirCitationCitedArtifactStatusDate) : Integer;
    
    // Insert FhirCitationCitedArtifactStatusDate before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirCitationCitedArtifactStatusDate;
    
    // Insert an existing FhirCitationCitedArtifactStatusDate before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirCitationCitedArtifactStatusDate);
    
    // Get the iIndexth FhirCitationCitedArtifactStatusDate. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirCitationCitedArtifactStatusDate);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirCitationCitedArtifactStatusDate;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirCitationCitedArtifactStatusDates[index : Integer] : TFhirCitationCitedArtifactStatusDate read GetItemN write SetItemN; default;
  End;

  // The title details of the article or artifact.
  TFhirCitationCitedArtifactTitle = class (TFhirBackboneElement)
  protected
    FType_ : TFhirCodeableConcept;
    FLanguage : TFhirCodeableConcept;
    FText : TFhirMarkdown;
    procedure SetType_(value : TFhirCodeableConcept);
    procedure SetLanguage(value : TFhirCodeableConcept);
    procedure SetText(value : TFhirMarkdown);
    function GetTextST : String;
    procedure SetTextST(value : String);
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirCitationCitedArtifactTitle; overload;
    function Clone : TFhirCitationCitedArtifactTitle; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to Used to express the reason or specific aspect for the title. (defined for API consistency)
    property type_ : TFhirCodeableConcept read FType_ write SetType_;
    // Used to express the reason or specific aspect for the title.
    property type_Element : TFhirCodeableConcept read FType_ write SetType_;

    // Typed access to Used to express the specific language. (defined for API consistency)
    property language : TFhirCodeableConcept read FLanguage write SetLanguage;
    // Used to express the specific language.
    property languageElement : TFhirCodeableConcept read FLanguage write SetLanguage;

    // Typed access to The title of the article or artifact.
    property text : String read GetTextST write SetTextST;
    // The title of the article or artifact.
    property textElement : TFhirMarkdown read FText write SetText;

  end;

  TFhirCitationCitedArtifactTitleListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirCitationCitedArtifactTitleList;
    function GetCurrent : TFhirCitationCitedArtifactTitle;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirCitationCitedArtifactTitleList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirCitationCitedArtifactTitle read GetCurrent;
  end;

  TFhirCitationCitedArtifactTitleList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirCitationCitedArtifactTitle;
    procedure SetItemN(index : Integer; value : TFhirCitationCitedArtifactTitle);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirCitationCitedArtifactTitleList; overload;
    function Clone : TFhirCitationCitedArtifactTitleList; overload;
    function GetEnumerator : TFhirCitationCitedArtifactTitleListEnumerator;
    
    //  Add a FhirCitationCitedArtifactTitle to the end of the list.
    function Append : TFhirCitationCitedArtifactTitle;
    
    // Add an already existing FhirCitationCitedArtifactTitle to the end of the list.
    procedure AddItem(value : TFhirCitationCitedArtifactTitle); overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirCitationCitedArtifactTitle) : Integer;
    
    // Insert FhirCitationCitedArtifactTitle before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirCitationCitedArtifactTitle;
    
    // Insert an existing FhirCitationCitedArtifactTitle before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirCitationCitedArtifactTitle);
    
    // Get the iIndexth FhirCitationCitedArtifactTitle. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirCitationCitedArtifactTitle);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirCitationCitedArtifactTitle;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirCitationCitedArtifactTitles[index : Integer] : TFhirCitationCitedArtifactTitle read GetItemN write SetItemN; default;
  End;

  // Summary of the article or artifact.
  TFhirCitationCitedArtifactAbstract = class (TFhirBackboneElement)
  protected
    FType_ : TFhirCodeableConcept;
    FLanguage : TFhirCodeableConcept;
    FText : TFhirMarkdown;
    FCopyright : TFhirMarkdown;
    procedure SetType_(value : TFhirCodeableConcept);
    procedure SetLanguage(value : TFhirCodeableConcept);
    procedure SetText(value : TFhirMarkdown);
    function GetTextST : String;
    procedure SetTextST(value : String);
    procedure SetCopyright(value : TFhirMarkdown);
    function GetCopyrightST : String;
    procedure SetCopyrightST(value : String);
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirCitationCitedArtifactAbstract; overload;
    function Clone : TFhirCitationCitedArtifactAbstract; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to Used to express the reason or specific aspect for the abstract. (defined for API consistency)
    property type_ : TFhirCodeableConcept read FType_ write SetType_;
    // Used to express the reason or specific aspect for the abstract.
    property type_Element : TFhirCodeableConcept read FType_ write SetType_;

    // Typed access to Used to express the specific language. (defined for API consistency)
    property language : TFhirCodeableConcept read FLanguage write SetLanguage;
    // Used to express the specific language.
    property languageElement : TFhirCodeableConcept read FLanguage write SetLanguage;

    // Typed access to Abstract content.
    property text : String read GetTextST write SetTextST;
    // Abstract content.
    property textElement : TFhirMarkdown read FText write SetText;

    // Typed access to Copyright notice for the abstract.
    property copyright : String read GetCopyrightST write SetCopyrightST;
    // Copyright notice for the abstract.
    property copyrightElement : TFhirMarkdown read FCopyright write SetCopyright;

  end;

  TFhirCitationCitedArtifactAbstractListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirCitationCitedArtifactAbstractList;
    function GetCurrent : TFhirCitationCitedArtifactAbstract;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirCitationCitedArtifactAbstractList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirCitationCitedArtifactAbstract read GetCurrent;
  end;

  TFhirCitationCitedArtifactAbstractList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirCitationCitedArtifactAbstract;
    procedure SetItemN(index : Integer; value : TFhirCitationCitedArtifactAbstract);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirCitationCitedArtifactAbstractList; overload;
    function Clone : TFhirCitationCitedArtifactAbstractList; overload;
    function GetEnumerator : TFhirCitationCitedArtifactAbstractListEnumerator;
    
    //  Add a FhirCitationCitedArtifactAbstract to the end of the list.
    function Append : TFhirCitationCitedArtifactAbstract;
    
    // Add an already existing FhirCitationCitedArtifactAbstract to the end of the list.
    procedure AddItem(value : TFhirCitationCitedArtifactAbstract); overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirCitationCitedArtifactAbstract) : Integer;
    
    // Insert FhirCitationCitedArtifactAbstract before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirCitationCitedArtifactAbstract;
    
    // Insert an existing FhirCitationCitedArtifactAbstract before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirCitationCitedArtifactAbstract);
    
    // Get the iIndexth FhirCitationCitedArtifactAbstract. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirCitationCitedArtifactAbstract);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirCitationCitedArtifactAbstract;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirCitationCitedArtifactAbstracts[index : Integer] : TFhirCitationCitedArtifactAbstract read GetItemN write SetItemN; default;
  End;

  // The component of the article or artifact.
  TFhirCitationCitedArtifactPart = class (TFhirBackboneElement)
  protected
    FType_ : TFhirCodeableConcept;
    FValue : TFhirString;
    FBaseCitation : TFhirReference;
    procedure SetType_(value : TFhirCodeableConcept);
    procedure SetValue(value : TFhirString);
    function GetValueST : String;
    procedure SetValueST(value : String);
    procedure SetBaseCitation(value : TFhirReference);
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirCitationCitedArtifactPart; overload;
    function Clone : TFhirCitationCitedArtifactPart; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to The kind of component. (defined for API consistency)
    property type_ : TFhirCodeableConcept read FType_ write SetType_;
    // The kind of component.
    property type_Element : TFhirCodeableConcept read FType_ write SetType_;

    // Typed access to The specification of the component.
    property value : String read GetValueST write SetValueST;
    // The specification of the component.
    property valueElement : TFhirString read FValue write SetValue;

    // Typed access to The citation for the full article or artifact. (defined for API consistency)
    property baseCitation : TFhirReference read FBaseCitation write SetBaseCitation;
    // The citation for the full article or artifact.
    property baseCitationElement : TFhirReference read FBaseCitation write SetBaseCitation;

  end;

  TFhirCitationCitedArtifactPartListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirCitationCitedArtifactPartList;
    function GetCurrent : TFhirCitationCitedArtifactPart;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirCitationCitedArtifactPartList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirCitationCitedArtifactPart read GetCurrent;
  end;

  TFhirCitationCitedArtifactPartList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirCitationCitedArtifactPart;
    procedure SetItemN(index : Integer; value : TFhirCitationCitedArtifactPart);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirCitationCitedArtifactPartList; overload;
    function Clone : TFhirCitationCitedArtifactPartList; overload;
    function GetEnumerator : TFhirCitationCitedArtifactPartListEnumerator;
    
    //  Add a FhirCitationCitedArtifactPart to the end of the list.
    function Append : TFhirCitationCitedArtifactPart;
    
    // Add an already existing FhirCitationCitedArtifactPart to the end of the list.
    procedure AddItem(value : TFhirCitationCitedArtifactPart); overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirCitationCitedArtifactPart) : Integer;
    
    // Insert FhirCitationCitedArtifactPart before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirCitationCitedArtifactPart;
    
    // Insert an existing FhirCitationCitedArtifactPart before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirCitationCitedArtifactPart);
    
    // Get the iIndexth FhirCitationCitedArtifactPart. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirCitationCitedArtifactPart);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirCitationCitedArtifactPart;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirCitationCitedArtifactParts[index : Integer] : TFhirCitationCitedArtifactPart read GetItemN write SetItemN; default;
  End;

  // The artifact related to the cited artifact.
  TFhirCitationCitedArtifactRelatesTo = class (TFhirBackboneElement)
  protected
    FRelationshipType : TFhirCodeableConcept;
    FtargetClassifierList : TFhirCodeableConceptList;
    FTarget : TFhirDataType;
    procedure SetRelationshipType(value : TFhirCodeableConcept);
    function GetTargetClassifierList : TFhirCodeableConceptList;
    function GetHasTargetClassifierList : Boolean;
    procedure SetTarget(value : TFhirDataType);
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirCitationCitedArtifactRelatesTo; overload;
    function Clone : TFhirCitationCitedArtifactRelatesTo; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to How the cited artifact resource relates to the target artifact. (defined for API consistency)
    property relationshipType : TFhirCodeableConcept read FRelationshipType write SetRelationshipType;
    // How the cited artifact resource relates to the target artifact.
    property relationshipTypeElement : TFhirCodeableConcept read FRelationshipType write SetRelationshipType;

    // The clasification of the related artifact.
    property targetClassifierList : TFhirCodeableConceptList read GetTargetClassifierList;
    property hasTargetClassifierList : boolean read GetHasTargetClassifierList;

    // Typed access to The article or artifact that the cited artifact is related to. (defined for API consistency)
    property target : TFhirDataType read FTarget write SetTarget;
    // The article or artifact that the cited artifact is related to.
    property targetElement : TFhirDataType read FTarget write SetTarget;

  end;

  TFhirCitationCitedArtifactRelatesToListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirCitationCitedArtifactRelatesToList;
    function GetCurrent : TFhirCitationCitedArtifactRelatesTo;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirCitationCitedArtifactRelatesToList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirCitationCitedArtifactRelatesTo read GetCurrent;
  end;

  TFhirCitationCitedArtifactRelatesToList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirCitationCitedArtifactRelatesTo;
    procedure SetItemN(index : Integer; value : TFhirCitationCitedArtifactRelatesTo);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirCitationCitedArtifactRelatesToList; overload;
    function Clone : TFhirCitationCitedArtifactRelatesToList; overload;
    function GetEnumerator : TFhirCitationCitedArtifactRelatesToListEnumerator;
    
    //  Add a FhirCitationCitedArtifactRelatesTo to the end of the list.
    function Append : TFhirCitationCitedArtifactRelatesTo;
    
    // Add an already existing FhirCitationCitedArtifactRelatesTo to the end of the list.
    procedure AddItem(value : TFhirCitationCitedArtifactRelatesTo); overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirCitationCitedArtifactRelatesTo) : Integer;
    
    // Insert FhirCitationCitedArtifactRelatesTo before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirCitationCitedArtifactRelatesTo;
    
    // Insert an existing FhirCitationCitedArtifactRelatesTo before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirCitationCitedArtifactRelatesTo);
    
    // Get the iIndexth FhirCitationCitedArtifactRelatesTo. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirCitationCitedArtifactRelatesTo);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirCitationCitedArtifactRelatesTo;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirCitationCitedArtifactRelatesTos[index : Integer] : TFhirCitationCitedArtifactRelatesTo read GetItemN write SetItemN; default;
  End;

  // If multiple, used to represent alternative forms of the article that are not separate citations.
  TFhirCitationCitedArtifactPublicationForm = class (TFhirBackboneElement)
  protected
    FPublishedIn : TFhirCitationCitedArtifactPublicationFormPublishedIn;
    FPeriodicRelease : TFhirCitationCitedArtifactPublicationFormPeriodicRelease;
    FArticleDate : TFhirDateTime;
    FLastRevisionDate : TFhirDateTime;
    FlanguageList : TFhirCodeableConceptList;
    FAccessionNumber : TFhirString;
    FPageString : TFhirString;
    FFirstPage : TFhirString;
    FLastPage : TFhirString;
    FPageCount : TFhirString;
    FCopyright : TFhirMarkdown;
    procedure SetPublishedIn(value : TFhirCitationCitedArtifactPublicationFormPublishedIn);
    procedure SetPeriodicRelease(value : TFhirCitationCitedArtifactPublicationFormPeriodicRelease);
    procedure SetArticleDate(value : TFhirDateTime);
    function GetArticleDateST : TFslDateTime;
    procedure SetArticleDateST(value : TFslDateTime);
    procedure SetLastRevisionDate(value : TFhirDateTime);
    function GetLastRevisionDateST : TFslDateTime;
    procedure SetLastRevisionDateST(value : TFslDateTime);
    function GetLanguageList : TFhirCodeableConceptList;
    function GetHasLanguageList : Boolean;
    procedure SetAccessionNumber(value : TFhirString);
    function GetAccessionNumberST : String;
    procedure SetAccessionNumberST(value : String);
    procedure SetPageString(value : TFhirString);
    function GetPageStringST : String;
    procedure SetPageStringST(value : String);
    procedure SetFirstPage(value : TFhirString);
    function GetFirstPageST : String;
    procedure SetFirstPageST(value : String);
    procedure SetLastPage(value : TFhirString);
    function GetLastPageST : String;
    procedure SetLastPageST(value : String);
    procedure SetPageCount(value : TFhirString);
    function GetPageCountST : String;
    procedure SetPageCountST(value : String);
    procedure SetCopyright(value : TFhirMarkdown);
    function GetCopyrightST : String;
    procedure SetCopyrightST(value : String);
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirCitationCitedArtifactPublicationForm; overload;
    function Clone : TFhirCitationCitedArtifactPublicationForm; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to The collection the cited article or artifact is published in. (defined for API consistency)
    property publishedIn : TFhirCitationCitedArtifactPublicationFormPublishedIn read FPublishedIn write SetPublishedIn;
    // The collection the cited article or artifact is published in.
    property publishedInElement : TFhirCitationCitedArtifactPublicationFormPublishedIn read FPublishedIn write SetPublishedIn;

    // Typed access to The specific issue in which the cited article resides. (defined for API consistency)
    property periodicRelease : TFhirCitationCitedArtifactPublicationFormPeriodicRelease read FPeriodicRelease write SetPeriodicRelease;
    // The specific issue in which the cited article resides.
    property periodicReleaseElement : TFhirCitationCitedArtifactPublicationFormPeriodicRelease read FPeriodicRelease write SetPeriodicRelease;

    // Typed access to The date the article was added to the database, or the date the article was released (which may differ from the journal issue publication date).
    property articleDate : TFslDateTime read GetArticleDateST write SetArticleDateST;
    // The date the article was added to the database, or the date the article was released (which may differ from the journal issue publication date).
    property articleDateElement : TFhirDateTime read FArticleDate write SetArticleDate;

    // Typed access to The date the article was last revised or updated in the database.
    property lastRevisionDate : TFslDateTime read GetLastRevisionDateST write SetLastRevisionDateST;
    // The date the article was last revised or updated in the database.
    property lastRevisionDateElement : TFhirDateTime read FLastRevisionDate write SetLastRevisionDate;

    // Language in which this form of the article is published.
    property languageList : TFhirCodeableConceptList read GetLanguageList;
    property hasLanguageList : boolean read GetHasLanguageList;

    // Typed access to Entry number or identifier for inclusion in a database.
    property accessionNumber : String read GetAccessionNumberST write SetAccessionNumberST;
    // Entry number or identifier for inclusion in a database.
    property accessionNumberElement : TFhirString read FAccessionNumber write SetAccessionNumber;

    // Typed access to Used for full display of pagination.
    property pageString : String read GetPageStringST write SetPageStringST;
    // Used for full display of pagination.
    property pageStringElement : TFhirString read FPageString write SetPageString;

    // Typed access to Used for isolated representation of first page.
    property firstPage : String read GetFirstPageST write SetFirstPageST;
    // Used for isolated representation of first page.
    property firstPageElement : TFhirString read FFirstPage write SetFirstPage;

    // Typed access to Used for isolated representation of last page.
    property lastPage : String read GetLastPageST write SetLastPageST;
    // Used for isolated representation of last page.
    property lastPageElement : TFhirString read FLastPage write SetLastPage;

    // Typed access to Actual or approximate number of pages or screens.
    property pageCount : String read GetPageCountST write SetPageCountST;
    // Actual or approximate number of pages or screens.
    property pageCountElement : TFhirString read FPageCount write SetPageCount;

    // Typed access to Copyright notice for the full article or artifact.
    property copyright : String read GetCopyrightST write SetCopyrightST;
    // Copyright notice for the full article or artifact.
    property copyrightElement : TFhirMarkdown read FCopyright write SetCopyright;

  end;

  TFhirCitationCitedArtifactPublicationFormListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirCitationCitedArtifactPublicationFormList;
    function GetCurrent : TFhirCitationCitedArtifactPublicationForm;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirCitationCitedArtifactPublicationFormList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirCitationCitedArtifactPublicationForm read GetCurrent;
  end;

  TFhirCitationCitedArtifactPublicationFormList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirCitationCitedArtifactPublicationForm;
    procedure SetItemN(index : Integer; value : TFhirCitationCitedArtifactPublicationForm);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirCitationCitedArtifactPublicationFormList; overload;
    function Clone : TFhirCitationCitedArtifactPublicationFormList; overload;
    function GetEnumerator : TFhirCitationCitedArtifactPublicationFormListEnumerator;
    
    //  Add a FhirCitationCitedArtifactPublicationForm to the end of the list.
    function Append : TFhirCitationCitedArtifactPublicationForm;
    
    // Add an already existing FhirCitationCitedArtifactPublicationForm to the end of the list.
    procedure AddItem(value : TFhirCitationCitedArtifactPublicationForm); overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirCitationCitedArtifactPublicationForm) : Integer;
    
    // Insert FhirCitationCitedArtifactPublicationForm before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirCitationCitedArtifactPublicationForm;
    
    // Insert an existing FhirCitationCitedArtifactPublicationForm before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirCitationCitedArtifactPublicationForm);
    
    // Get the iIndexth FhirCitationCitedArtifactPublicationForm. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirCitationCitedArtifactPublicationForm);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirCitationCitedArtifactPublicationForm;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirCitationCitedArtifactPublicationForms[index : Integer] : TFhirCitationCitedArtifactPublicationForm read GetItemN write SetItemN; default;
  End;

  // The collection the cited article or artifact is published in.
  TFhirCitationCitedArtifactPublicationFormPublishedIn = class (TFhirBackboneElement)
  protected
    FType_ : TFhirCodeableConcept;
    FidentifierList : TFhirIdentifierList;
    FTitle : TFhirString;
    FPublisher : TFhirReference;
    FPublisherLocation : TFhirString;
    procedure SetType_(value : TFhirCodeableConcept);
    function GetIdentifierList : TFhirIdentifierList;
    function GetHasIdentifierList : Boolean;
    procedure SetTitle(value : TFhirString);
    function GetTitleST : String;
    procedure SetTitleST(value : String);
    procedure SetPublisher(value : TFhirReference);
    procedure SetPublisherLocation(value : TFhirString);
    function GetPublisherLocationST : String;
    procedure SetPublisherLocationST(value : String);
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirCitationCitedArtifactPublicationFormPublishedIn; overload;
    function Clone : TFhirCitationCitedArtifactPublicationFormPublishedIn; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to Kind of container (e.g. Periodical, database, or book). (defined for API consistency)
    property type_ : TFhirCodeableConcept read FType_ write SetType_;
    // Kind of container (e.g. Periodical, database, or book).
    property type_Element : TFhirCodeableConcept read FType_ write SetType_;

    // Journal identifiers include ISSN, ISO Abbreviation and NLMuniqueID; Book identifiers include ISBN.
    property identifierList : TFhirIdentifierList read GetIdentifierList;
    property hasIdentifierList : boolean read GetHasIdentifierList;

    // Typed access to Name of the database or title of the book or journal.
    property title : String read GetTitleST write SetTitleST;
    // Name of the database or title of the book or journal.
    property titleElement : TFhirString read FTitle write SetTitle;

    // Typed access to Name of the publisher. (defined for API consistency)
    property publisher : TFhirReference read FPublisher write SetPublisher;
    // Name of the publisher.
    property publisherElement : TFhirReference read FPublisher write SetPublisher;

    // Typed access to Geographic location of the publisher.
    property publisherLocation : String read GetPublisherLocationST write SetPublisherLocationST;
    // Geographic location of the publisher.
    property publisherLocationElement : TFhirString read FPublisherLocation write SetPublisherLocation;

  end;

  TFhirCitationCitedArtifactPublicationFormPublishedInListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirCitationCitedArtifactPublicationFormPublishedInList;
    function GetCurrent : TFhirCitationCitedArtifactPublicationFormPublishedIn;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirCitationCitedArtifactPublicationFormPublishedInList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirCitationCitedArtifactPublicationFormPublishedIn read GetCurrent;
  end;

  TFhirCitationCitedArtifactPublicationFormPublishedInList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirCitationCitedArtifactPublicationFormPublishedIn;
    procedure SetItemN(index : Integer; value : TFhirCitationCitedArtifactPublicationFormPublishedIn);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirCitationCitedArtifactPublicationFormPublishedInList; overload;
    function Clone : TFhirCitationCitedArtifactPublicationFormPublishedInList; overload;
    function GetEnumerator : TFhirCitationCitedArtifactPublicationFormPublishedInListEnumerator;
    
    //  Add a FhirCitationCitedArtifactPublicationFormPublishedIn to the end of the list.
    function Append : TFhirCitationCitedArtifactPublicationFormPublishedIn;
    
    // Add an already existing FhirCitationCitedArtifactPublicationFormPublishedIn to the end of the list.
    procedure AddItem(value : TFhirCitationCitedArtifactPublicationFormPublishedIn); overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirCitationCitedArtifactPublicationFormPublishedIn) : Integer;
    
    // Insert FhirCitationCitedArtifactPublicationFormPublishedIn before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirCitationCitedArtifactPublicationFormPublishedIn;
    
    // Insert an existing FhirCitationCitedArtifactPublicationFormPublishedIn before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirCitationCitedArtifactPublicationFormPublishedIn);
    
    // Get the iIndexth FhirCitationCitedArtifactPublicationFormPublishedIn. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirCitationCitedArtifactPublicationFormPublishedIn);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirCitationCitedArtifactPublicationFormPublishedIn;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirCitationCitedArtifactPublicationFormPublishedIns[index : Integer] : TFhirCitationCitedArtifactPublicationFormPublishedIn read GetItemN write SetItemN; default;
  End;

  // The specific issue in which the cited article resides.
  TFhirCitationCitedArtifactPublicationFormPeriodicRelease = class (TFhirBackboneElement)
  protected
    FCitedMedium : TFhirCodeableConcept;
    FVolume : TFhirString;
    FIssue : TFhirString;
    FDateOfPublication : TFhirCitationCitedArtifactPublicationFormPeriodicReleaseDateOfPublication;
    procedure SetCitedMedium(value : TFhirCodeableConcept);
    procedure SetVolume(value : TFhirString);
    function GetVolumeST : String;
    procedure SetVolumeST(value : String);
    procedure SetIssue(value : TFhirString);
    function GetIssueST : String;
    procedure SetIssueST(value : String);
    procedure SetDateOfPublication(value : TFhirCitationCitedArtifactPublicationFormPeriodicReleaseDateOfPublication);
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirCitationCitedArtifactPublicationFormPeriodicRelease; overload;
    function Clone : TFhirCitationCitedArtifactPublicationFormPeriodicRelease; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to Describes the form of the medium cited. Common codes are "Internet" or "Print". (defined for API consistency)
    property citedMedium : TFhirCodeableConcept read FCitedMedium write SetCitedMedium;
    // Describes the form of the medium cited. Common codes are "Internet" or "Print".
    property citedMediumElement : TFhirCodeableConcept read FCitedMedium write SetCitedMedium;

    // Typed access to Volume number of journal in which the article is published.
    property volume : String read GetVolumeST write SetVolumeST;
    // Volume number of journal in which the article is published.
    property volumeElement : TFhirString read FVolume write SetVolume;

    // Typed access to Issue, part or supplement of journal in which the article is published.
    property issue : String read GetIssueST write SetIssueST;
    // Issue, part or supplement of journal in which the article is published.
    property issueElement : TFhirString read FIssue write SetIssue;

    // Typed access to Defining the date on which the issue of the journal was published. (defined for API consistency)
    property dateOfPublication : TFhirCitationCitedArtifactPublicationFormPeriodicReleaseDateOfPublication read FDateOfPublication write SetDateOfPublication;
    // Defining the date on which the issue of the journal was published.
    property dateOfPublicationElement : TFhirCitationCitedArtifactPublicationFormPeriodicReleaseDateOfPublication read FDateOfPublication write SetDateOfPublication;

  end;

  TFhirCitationCitedArtifactPublicationFormPeriodicReleaseListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirCitationCitedArtifactPublicationFormPeriodicReleaseList;
    function GetCurrent : TFhirCitationCitedArtifactPublicationFormPeriodicRelease;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirCitationCitedArtifactPublicationFormPeriodicReleaseList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirCitationCitedArtifactPublicationFormPeriodicRelease read GetCurrent;
  end;

  TFhirCitationCitedArtifactPublicationFormPeriodicReleaseList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirCitationCitedArtifactPublicationFormPeriodicRelease;
    procedure SetItemN(index : Integer; value : TFhirCitationCitedArtifactPublicationFormPeriodicRelease);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirCitationCitedArtifactPublicationFormPeriodicReleaseList; overload;
    function Clone : TFhirCitationCitedArtifactPublicationFormPeriodicReleaseList; overload;
    function GetEnumerator : TFhirCitationCitedArtifactPublicationFormPeriodicReleaseListEnumerator;
    
    //  Add a FhirCitationCitedArtifactPublicationFormPeriodicRelease to the end of the list.
    function Append : TFhirCitationCitedArtifactPublicationFormPeriodicRelease;
    
    // Add an already existing FhirCitationCitedArtifactPublicationFormPeriodicRelease to the end of the list.
    procedure AddItem(value : TFhirCitationCitedArtifactPublicationFormPeriodicRelease); overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirCitationCitedArtifactPublicationFormPeriodicRelease) : Integer;
    
    // Insert FhirCitationCitedArtifactPublicationFormPeriodicRelease before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirCitationCitedArtifactPublicationFormPeriodicRelease;
    
    // Insert an existing FhirCitationCitedArtifactPublicationFormPeriodicRelease before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirCitationCitedArtifactPublicationFormPeriodicRelease);
    
    // Get the iIndexth FhirCitationCitedArtifactPublicationFormPeriodicRelease. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirCitationCitedArtifactPublicationFormPeriodicRelease);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirCitationCitedArtifactPublicationFormPeriodicRelease;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirCitationCitedArtifactPublicationFormPeriodicReleases[index : Integer] : TFhirCitationCitedArtifactPublicationFormPeriodicRelease read GetItemN write SetItemN; default;
  End;

  // Defining the date on which the issue of the journal was published.
  TFhirCitationCitedArtifactPublicationFormPeriodicReleaseDateOfPublication = class (TFhirBackboneElement)
  protected
    FDate : TFhirDate;
    FYear : TFhirString;
    FMonth : TFhirString;
    FDay : TFhirString;
    FSeason : TFhirString;
    FText : TFhirString;
    procedure SetDate(value : TFhirDate);
    function GetDateST : TFslDateTime;
    procedure SetDateST(value : TFslDateTime);
    procedure SetYear(value : TFhirString);
    function GetYearST : String;
    procedure SetYearST(value : String);
    procedure SetMonth(value : TFhirString);
    function GetMonthST : String;
    procedure SetMonthST(value : String);
    procedure SetDay(value : TFhirString);
    function GetDayST : String;
    procedure SetDayST(value : String);
    procedure SetSeason(value : TFhirString);
    function GetSeasonST : String;
    procedure SetSeasonST(value : String);
    procedure SetText(value : TFhirString);
    function GetTextST : String;
    procedure SetTextST(value : String);
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirCitationCitedArtifactPublicationFormPeriodicReleaseDateOfPublication; overload;
    function Clone : TFhirCitationCitedArtifactPublicationFormPeriodicReleaseDateOfPublication; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to Date on which the issue of the journal was published.
    property date : TFslDateTime read GetDateST write SetDateST;
    // Date on which the issue of the journal was published.
    property dateElement : TFhirDate read FDate write SetDate;

    // Typed access to Year on which the issue of the journal was published.
    property year : String read GetYearST write SetYearST;
    // Year on which the issue of the journal was published.
    property yearElement : TFhirString read FYear write SetYear;

    // Typed access to Month on which the issue of the journal was published.
    property month : String read GetMonthST write SetMonthST;
    // Month on which the issue of the journal was published.
    property monthElement : TFhirString read FMonth write SetMonth;

    // Typed access to Day on which the issue of the journal was published.
    property day : String read GetDayST write SetDayST;
    // Day on which the issue of the journal was published.
    property dayElement : TFhirString read FDay write SetDay;

    // Typed access to Spring, Summer, Fall/Autumn, Winter.
    property season : String read GetSeasonST write SetSeasonST;
    // Spring, Summer, Fall/Autumn, Winter.
    property seasonElement : TFhirString read FSeason write SetSeason;

    // Typed access to Text representation of the date of which the issue of the journal was published.
    property text : String read GetTextST write SetTextST;
    // Text representation of the date of which the issue of the journal was published.
    property textElement : TFhirString read FText write SetText;

  end;

  TFhirCitationCitedArtifactPublicationFormPeriodicReleaseDateOfPublicationListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirCitationCitedArtifactPublicationFormPeriodicReleaseDateOfPublicationList;
    function GetCurrent : TFhirCitationCitedArtifactPublicationFormPeriodicReleaseDateOfPublication;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirCitationCitedArtifactPublicationFormPeriodicReleaseDateOfPublicationList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirCitationCitedArtifactPublicationFormPeriodicReleaseDateOfPublication read GetCurrent;
  end;

  TFhirCitationCitedArtifactPublicationFormPeriodicReleaseDateOfPublicationList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirCitationCitedArtifactPublicationFormPeriodicReleaseDateOfPublication;
    procedure SetItemN(index : Integer; value : TFhirCitationCitedArtifactPublicationFormPeriodicReleaseDateOfPublication);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirCitationCitedArtifactPublicationFormPeriodicReleaseDateOfPublicationList; overload;
    function Clone : TFhirCitationCitedArtifactPublicationFormPeriodicReleaseDateOfPublicationList; overload;
    function GetEnumerator : TFhirCitationCitedArtifactPublicationFormPeriodicReleaseDateOfPublicationListEnumerator;
    
    //  Add a FhirCitationCitedArtifactPublicationFormPeriodicReleaseDateOfPublication to the end of the list.
    function Append : TFhirCitationCitedArtifactPublicationFormPeriodicReleaseDateOfPublication;
    
    // Add an already existing FhirCitationCitedArtifactPublicationFormPeriodicReleaseDateOfPublication to the end of the list.
    procedure AddItem(value : TFhirCitationCitedArtifactPublicationFormPeriodicReleaseDateOfPublication); overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirCitationCitedArtifactPublicationFormPeriodicReleaseDateOfPublication) : Integer;
    
    // Insert FhirCitationCitedArtifactPublicationFormPeriodicReleaseDateOfPublication before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirCitationCitedArtifactPublicationFormPeriodicReleaseDateOfPublication;
    
    // Insert an existing FhirCitationCitedArtifactPublicationFormPeriodicReleaseDateOfPublication before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirCitationCitedArtifactPublicationFormPeriodicReleaseDateOfPublication);
    
    // Get the iIndexth FhirCitationCitedArtifactPublicationFormPeriodicReleaseDateOfPublication. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirCitationCitedArtifactPublicationFormPeriodicReleaseDateOfPublication);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirCitationCitedArtifactPublicationFormPeriodicReleaseDateOfPublication;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirCitationCitedArtifactPublicationFormPeriodicReleaseDateOfPublications[index : Integer] : TFhirCitationCitedArtifactPublicationFormPeriodicReleaseDateOfPublication read GetItemN write SetItemN; default;
  End;

  // Used for any URL for the article or artifact cited.
  TFhirCitationCitedArtifactWebLocation = class (TFhirBackboneElement)
  protected
    FType_ : TFhirCodeableConcept;
    FUrl : TFhirUri;
    procedure SetType_(value : TFhirCodeableConcept);
    procedure SetUrl(value : TFhirUri);
    function GetUrlST : String;
    procedure SetUrlST(value : String);
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirCitationCitedArtifactWebLocation; overload;
    function Clone : TFhirCitationCitedArtifactWebLocation; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to Code the reason for different URLs, e.g. abstract and full-text. (defined for API consistency)
    property type_ : TFhirCodeableConcept read FType_ write SetType_;
    // Code the reason for different URLs, e.g. abstract and full-text.
    property type_Element : TFhirCodeableConcept read FType_ write SetType_;

    // Typed access to The specific URL.
    property url : String read GetUrlST write SetUrlST;
    // The specific URL.
    property urlElement : TFhirUri read FUrl write SetUrl;

  end;

  TFhirCitationCitedArtifactWebLocationListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirCitationCitedArtifactWebLocationList;
    function GetCurrent : TFhirCitationCitedArtifactWebLocation;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirCitationCitedArtifactWebLocationList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirCitationCitedArtifactWebLocation read GetCurrent;
  end;

  TFhirCitationCitedArtifactWebLocationList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirCitationCitedArtifactWebLocation;
    procedure SetItemN(index : Integer; value : TFhirCitationCitedArtifactWebLocation);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirCitationCitedArtifactWebLocationList; overload;
    function Clone : TFhirCitationCitedArtifactWebLocationList; overload;
    function GetEnumerator : TFhirCitationCitedArtifactWebLocationListEnumerator;
    
    //  Add a FhirCitationCitedArtifactWebLocation to the end of the list.
    function Append : TFhirCitationCitedArtifactWebLocation;
    
    // Add an already existing FhirCitationCitedArtifactWebLocation to the end of the list.
    procedure AddItem(value : TFhirCitationCitedArtifactWebLocation); overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirCitationCitedArtifactWebLocation) : Integer;
    
    // Insert FhirCitationCitedArtifactWebLocation before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirCitationCitedArtifactWebLocation;
    
    // Insert an existing FhirCitationCitedArtifactWebLocation before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirCitationCitedArtifactWebLocation);
    
    // Get the iIndexth FhirCitationCitedArtifactWebLocation. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirCitationCitedArtifactWebLocation);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirCitationCitedArtifactWebLocation;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirCitationCitedArtifactWebLocations[index : Integer] : TFhirCitationCitedArtifactWebLocation read GetItemN write SetItemN; default;
  End;

  // The assignment to an organizing scheme.
  TFhirCitationCitedArtifactClassification = class (TFhirBackboneElement)
  protected
    FType_ : TFhirCodeableConcept;
    FclassifierList : TFhirCodeableConceptList;
    FWhoClassified : TFhirCitationCitedArtifactClassificationWhoClassified;
    procedure SetType_(value : TFhirCodeableConcept);
    function GetClassifierList : TFhirCodeableConceptList;
    function GetHasClassifierList : Boolean;
    procedure SetWhoClassified(value : TFhirCitationCitedArtifactClassificationWhoClassified);
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirCitationCitedArtifactClassification; overload;
    function Clone : TFhirCitationCitedArtifactClassification; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to The kind of classifier (e.g. publication type, keyword). (defined for API consistency)
    property type_ : TFhirCodeableConcept read FType_ write SetType_;
    // The kind of classifier (e.g. publication type, keyword).
    property type_Element : TFhirCodeableConcept read FType_ write SetType_;

    // The specific classification value.
    property classifierList : TFhirCodeableConceptList read GetClassifierList;
    property hasClassifierList : boolean read GetHasClassifierList;

    // Typed access to Provenance and copyright of classification. (defined for API consistency)
    property whoClassified : TFhirCitationCitedArtifactClassificationWhoClassified read FWhoClassified write SetWhoClassified;
    // Provenance and copyright of classification.
    property whoClassifiedElement : TFhirCitationCitedArtifactClassificationWhoClassified read FWhoClassified write SetWhoClassified;

  end;

  TFhirCitationCitedArtifactClassificationListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirCitationCitedArtifactClassificationList;
    function GetCurrent : TFhirCitationCitedArtifactClassification;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirCitationCitedArtifactClassificationList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirCitationCitedArtifactClassification read GetCurrent;
  end;

  TFhirCitationCitedArtifactClassificationList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirCitationCitedArtifactClassification;
    procedure SetItemN(index : Integer; value : TFhirCitationCitedArtifactClassification);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirCitationCitedArtifactClassificationList; overload;
    function Clone : TFhirCitationCitedArtifactClassificationList; overload;
    function GetEnumerator : TFhirCitationCitedArtifactClassificationListEnumerator;
    
    //  Add a FhirCitationCitedArtifactClassification to the end of the list.
    function Append : TFhirCitationCitedArtifactClassification;
    
    // Add an already existing FhirCitationCitedArtifactClassification to the end of the list.
    procedure AddItem(value : TFhirCitationCitedArtifactClassification); overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirCitationCitedArtifactClassification) : Integer;
    
    // Insert FhirCitationCitedArtifactClassification before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirCitationCitedArtifactClassification;
    
    // Insert an existing FhirCitationCitedArtifactClassification before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirCitationCitedArtifactClassification);
    
    // Get the iIndexth FhirCitationCitedArtifactClassification. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirCitationCitedArtifactClassification);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirCitationCitedArtifactClassification;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirCitationCitedArtifactClassifications[index : Integer] : TFhirCitationCitedArtifactClassification read GetItemN write SetItemN; default;
  End;

  // Provenance and copyright of classification.
  TFhirCitationCitedArtifactClassificationWhoClassified = class (TFhirBackboneElement)
  protected
    FPerson : TFhirReference;
    FOrganization : TFhirReference;
    FPublisher : TFhirReference;
    FClassifierCopyright : TFhirString;
    FFreeToShare : TFhirBoolean;
    procedure SetPerson(value : TFhirReference);
    procedure SetOrganization(value : TFhirReference);
    procedure SetPublisher(value : TFhirReference);
    procedure SetClassifierCopyright(value : TFhirString);
    function GetClassifierCopyrightST : String;
    procedure SetClassifierCopyrightST(value : String);
    procedure SetFreeToShare(value : TFhirBoolean);
    function GetFreeToShareST : Boolean;
    procedure SetFreeToShareST(value : Boolean);
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirCitationCitedArtifactClassificationWhoClassified; overload;
    function Clone : TFhirCitationCitedArtifactClassificationWhoClassified; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to Person who created the classification. (defined for API consistency)
    property person : TFhirReference read FPerson write SetPerson;
    // Person who created the classification.
    property personElement : TFhirReference read FPerson write SetPerson;

    // Typed access to Organization who created the classification. (defined for API consistency)
    property organization : TFhirReference read FOrganization write SetOrganization;
    // Organization who created the classification.
    property organizationElement : TFhirReference read FOrganization write SetOrganization;

    // Typed access to The publisher of the classification, not the publisher of the article or artifact being cited. (defined for API consistency)
    property publisher : TFhirReference read FPublisher write SetPublisher;
    // The publisher of the classification, not the publisher of the article or artifact being cited.
    property publisherElement : TFhirReference read FPublisher write SetPublisher;

    // Typed access to Rights management statement for the classification.
    property classifierCopyright : String read GetClassifierCopyrightST write SetClassifierCopyrightST;
    // Rights management statement for the classification.
    property classifierCopyrightElement : TFhirString read FClassifierCopyright write SetClassifierCopyright;

    // Typed access to Acceptable to re-use the classification.
    property freeToShare : Boolean read GetFreeToShareST write SetFreeToShareST;
    // Acceptable to re-use the classification.
    property freeToShareElement : TFhirBoolean read FFreeToShare write SetFreeToShare;

  end;

  TFhirCitationCitedArtifactClassificationWhoClassifiedListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirCitationCitedArtifactClassificationWhoClassifiedList;
    function GetCurrent : TFhirCitationCitedArtifactClassificationWhoClassified;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirCitationCitedArtifactClassificationWhoClassifiedList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirCitationCitedArtifactClassificationWhoClassified read GetCurrent;
  end;

  TFhirCitationCitedArtifactClassificationWhoClassifiedList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirCitationCitedArtifactClassificationWhoClassified;
    procedure SetItemN(index : Integer; value : TFhirCitationCitedArtifactClassificationWhoClassified);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirCitationCitedArtifactClassificationWhoClassifiedList; overload;
    function Clone : TFhirCitationCitedArtifactClassificationWhoClassifiedList; overload;
    function GetEnumerator : TFhirCitationCitedArtifactClassificationWhoClassifiedListEnumerator;
    
    //  Add a FhirCitationCitedArtifactClassificationWhoClassified to the end of the list.
    function Append : TFhirCitationCitedArtifactClassificationWhoClassified;
    
    // Add an already existing FhirCitationCitedArtifactClassificationWhoClassified to the end of the list.
    procedure AddItem(value : TFhirCitationCitedArtifactClassificationWhoClassified); overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirCitationCitedArtifactClassificationWhoClassified) : Integer;
    
    // Insert FhirCitationCitedArtifactClassificationWhoClassified before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirCitationCitedArtifactClassificationWhoClassified;
    
    // Insert an existing FhirCitationCitedArtifactClassificationWhoClassified before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirCitationCitedArtifactClassificationWhoClassified);
    
    // Get the iIndexth FhirCitationCitedArtifactClassificationWhoClassified. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirCitationCitedArtifactClassificationWhoClassified);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirCitationCitedArtifactClassificationWhoClassified;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirCitationCitedArtifactClassificationWhoClassifieds[index : Integer] : TFhirCitationCitedArtifactClassificationWhoClassified read GetItemN write SetItemN; default;
  End;

  // This element is used to list authors and other contributors, their contact information, specific contributions, and summary statements.
  TFhirCitationCitedArtifactContributorship = class (TFhirBackboneElement)
  protected
    FComplete : TFhirBoolean;
    FentryList : TFhirCitationCitedArtifactContributorshipEntryList;
    FsummaryList : TFhirCitationCitedArtifactContributorshipSummaryList;
    procedure SetComplete(value : TFhirBoolean);
    function GetCompleteST : Boolean;
    procedure SetCompleteST(value : Boolean);
    function GetEntryList : TFhirCitationCitedArtifactContributorshipEntryList;
    function GetHasEntryList : Boolean;
    function GetSummaryList : TFhirCitationCitedArtifactContributorshipSummaryList;
    function GetHasSummaryList : Boolean;
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirCitationCitedArtifactContributorship; overload;
    function Clone : TFhirCitationCitedArtifactContributorship; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to Indicates if the list includes all authors and/or contributors.
    property complete : Boolean read GetCompleteST write SetCompleteST;
    // Indicates if the list includes all authors and/or contributors.
    property completeElement : TFhirBoolean read FComplete write SetComplete;

    // An individual entity named in the author list or contributor list.
    property entryList : TFhirCitationCitedArtifactContributorshipEntryList read GetEntryList;
    property hasEntryList : boolean read GetHasEntryList;

    // Used to record a display of the author/contributor list without separate coding for each list member.
    property summaryList : TFhirCitationCitedArtifactContributorshipSummaryList read GetSummaryList;
    property hasSummaryList : boolean read GetHasSummaryList;

  end;

  TFhirCitationCitedArtifactContributorshipListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirCitationCitedArtifactContributorshipList;
    function GetCurrent : TFhirCitationCitedArtifactContributorship;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirCitationCitedArtifactContributorshipList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirCitationCitedArtifactContributorship read GetCurrent;
  end;

  TFhirCitationCitedArtifactContributorshipList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirCitationCitedArtifactContributorship;
    procedure SetItemN(index : Integer; value : TFhirCitationCitedArtifactContributorship);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirCitationCitedArtifactContributorshipList; overload;
    function Clone : TFhirCitationCitedArtifactContributorshipList; overload;
    function GetEnumerator : TFhirCitationCitedArtifactContributorshipListEnumerator;
    
    //  Add a FhirCitationCitedArtifactContributorship to the end of the list.
    function Append : TFhirCitationCitedArtifactContributorship;
    
    // Add an already existing FhirCitationCitedArtifactContributorship to the end of the list.
    procedure AddItem(value : TFhirCitationCitedArtifactContributorship); overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirCitationCitedArtifactContributorship) : Integer;
    
    // Insert FhirCitationCitedArtifactContributorship before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirCitationCitedArtifactContributorship;
    
    // Insert an existing FhirCitationCitedArtifactContributorship before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirCitationCitedArtifactContributorship);
    
    // Get the iIndexth FhirCitationCitedArtifactContributorship. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirCitationCitedArtifactContributorship);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirCitationCitedArtifactContributorship;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirCitationCitedArtifactContributorships[index : Integer] : TFhirCitationCitedArtifactContributorship read GetItemN write SetItemN; default;
  End;

  // An individual entity named in the author list or contributor list.
  TFhirCitationCitedArtifactContributorshipEntry = class (TFhirBackboneElement)
  protected
    FName : TFhirHumanName;
    FInitials : TFhirString;
    FCollectiveName : TFhirString;
    FidentifierList : TFhirIdentifierList;
    FaffiliationInfoList : TFhirCitationCitedArtifactContributorshipEntryAffiliationInfoList;
    FaddressList : TFhirAddressList;
    FtelecomList : TFhirContactPointList;
    FcontributionTypeList : TFhirCodeableConceptList;
    FRole : TFhirCodeableConcept;
    FcontributionInstanceList : TFhirCitationCitedArtifactContributorshipEntryContributionInstanceList;
    FCorrespondingContact : TFhirBoolean;
    FListOrder : TFhirPositiveInt;
    procedure SetName(value : TFhirHumanName);
    procedure SetInitials(value : TFhirString);
    function GetInitialsST : String;
    procedure SetInitialsST(value : String);
    procedure SetCollectiveName(value : TFhirString);
    function GetCollectiveNameST : String;
    procedure SetCollectiveNameST(value : String);
    function GetIdentifierList : TFhirIdentifierList;
    function GetHasIdentifierList : Boolean;
    function GetAffiliationInfoList : TFhirCitationCitedArtifactContributorshipEntryAffiliationInfoList;
    function GetHasAffiliationInfoList : Boolean;
    function GetAddressList : TFhirAddressList;
    function GetHasAddressList : Boolean;
    function GetTelecomList : TFhirContactPointList;
    function GetHasTelecomList : Boolean;
    function GetContributionTypeList : TFhirCodeableConceptList;
    function GetHasContributionTypeList : Boolean;
    procedure SetRole(value : TFhirCodeableConcept);
    function GetContributionInstanceList : TFhirCitationCitedArtifactContributorshipEntryContributionInstanceList;
    function GetHasContributionInstanceList : Boolean;
    procedure SetCorrespondingContact(value : TFhirBoolean);
    function GetCorrespondingContactST : Boolean;
    procedure SetCorrespondingContactST(value : Boolean);
    procedure SetListOrder(value : TFhirPositiveInt);
    function GetListOrderST : String;
    procedure SetListOrderST(value : String);
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirCitationCitedArtifactContributorshipEntry; overload;
    function Clone : TFhirCitationCitedArtifactContributorshipEntry; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to A name associated with the individual. (defined for API consistency)
    property name : TFhirHumanName read FName write SetName;
    // A name associated with the individual.
    property nameElement : TFhirHumanName read FName write SetName;

    // Typed access to Initials for forename.
    property initials : String read GetInitialsST write SetInitialsST;
    // Initials for forename.
    property initialsElement : TFhirString read FInitials write SetInitials;

    // Typed access to Used for collective or corporate name as an author.
    property collectiveName : String read GetCollectiveNameST write SetCollectiveNameST;
    // Used for collective or corporate name as an author.
    property collectiveNameElement : TFhirString read FCollectiveName write SetCollectiveName;

    // Unique person identifier.
    property identifierList : TFhirIdentifierList read GetIdentifierList;
    property hasIdentifierList : boolean read GetHasIdentifierList;

    // Organization affiliated with the entity.
    property affiliationInfoList : TFhirCitationCitedArtifactContributorshipEntryAffiliationInfoList read GetAffiliationInfoList;
    property hasAffiliationInfoList : boolean read GetHasAffiliationInfoList;

    // Physical mailing address for the author or contributor.
    property addressList : TFhirAddressList read GetAddressList;
    property hasAddressList : boolean read GetHasAddressList;

    // Email or telephone contact methods for the author or contributor.
    property telecomList : TFhirContactPointList read GetTelecomList;
    property hasTelecomList : boolean read GetHasTelecomList;

    // This element identifies the specific nature of an individuals contribution with respect to the cited work.
    property contributionTypeList : TFhirCodeableConceptList read GetContributionTypeList;
    property hasContributionTypeList : boolean read GetHasContributionTypeList;

    // Typed access to The role of the contributor (e.g. author, editor, reviewer). (defined for API consistency)
    property role : TFhirCodeableConcept read FRole write SetRole;
    // The role of the contributor (e.g. author, editor, reviewer).
    property roleElement : TFhirCodeableConcept read FRole write SetRole;

    // Contributions with accounting for time or number.
    property contributionInstanceList : TFhirCitationCitedArtifactContributorshipEntryContributionInstanceList read GetContributionInstanceList;
    property hasContributionInstanceList : boolean read GetHasContributionInstanceList;

    // Typed access to Indication of which contributor is the corresponding contributor for the role.
    property correspondingContact : Boolean read GetCorrespondingContactST write SetCorrespondingContactST;
    // Indication of which contributor is the corresponding contributor for the role.
    property correspondingContactElement : TFhirBoolean read FCorrespondingContact write SetCorrespondingContact;

    // Typed access to Used to code order of authors.
    property listOrder : String read GetListOrderST write SetListOrderST;
    // Used to code order of authors.
    property listOrderElement : TFhirPositiveInt read FListOrder write SetListOrder;

  end;

  TFhirCitationCitedArtifactContributorshipEntryListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirCitationCitedArtifactContributorshipEntryList;
    function GetCurrent : TFhirCitationCitedArtifactContributorshipEntry;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirCitationCitedArtifactContributorshipEntryList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirCitationCitedArtifactContributorshipEntry read GetCurrent;
  end;

  TFhirCitationCitedArtifactContributorshipEntryList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirCitationCitedArtifactContributorshipEntry;
    procedure SetItemN(index : Integer; value : TFhirCitationCitedArtifactContributorshipEntry);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirCitationCitedArtifactContributorshipEntryList; overload;
    function Clone : TFhirCitationCitedArtifactContributorshipEntryList; overload;
    function GetEnumerator : TFhirCitationCitedArtifactContributorshipEntryListEnumerator;
    
    //  Add a FhirCitationCitedArtifactContributorshipEntry to the end of the list.
    function Append : TFhirCitationCitedArtifactContributorshipEntry;
    
    // Add an already existing FhirCitationCitedArtifactContributorshipEntry to the end of the list.
    procedure AddItem(value : TFhirCitationCitedArtifactContributorshipEntry); overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirCitationCitedArtifactContributorshipEntry) : Integer;
    
    // Insert FhirCitationCitedArtifactContributorshipEntry before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirCitationCitedArtifactContributorshipEntry;
    
    // Insert an existing FhirCitationCitedArtifactContributorshipEntry before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirCitationCitedArtifactContributorshipEntry);
    
    // Get the iIndexth FhirCitationCitedArtifactContributorshipEntry. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirCitationCitedArtifactContributorshipEntry);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirCitationCitedArtifactContributorshipEntry;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirCitationCitedArtifactContributorshipEntries[index : Integer] : TFhirCitationCitedArtifactContributorshipEntry read GetItemN write SetItemN; default;
  End;

  // Organization affiliated with the entity.
  TFhirCitationCitedArtifactContributorshipEntryAffiliationInfo = class (TFhirBackboneElement)
  protected
    FAffiliation : TFhirString;
    FRole : TFhirString;
    FidentifierList : TFhirIdentifierList;
    procedure SetAffiliation(value : TFhirString);
    function GetAffiliationST : String;
    procedure SetAffiliationST(value : String);
    procedure SetRole(value : TFhirString);
    function GetRoleST : String;
    procedure SetRoleST(value : String);
    function GetIdentifierList : TFhirIdentifierList;
    function GetHasIdentifierList : Boolean;
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirCitationCitedArtifactContributorshipEntryAffiliationInfo; overload;
    function Clone : TFhirCitationCitedArtifactContributorshipEntryAffiliationInfo; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to Display for the organization.
    property affiliation : String read GetAffiliationST write SetAffiliationST;
    // Display for the organization.
    property affiliationElement : TFhirString read FAffiliation write SetAffiliation;

    // Typed access to Role within the organization, such as professional title.
    property role : String read GetRoleST write SetRoleST;
    // Role within the organization, such as professional title.
    property roleElement : TFhirString read FRole write SetRole;

    // Identifier for the organization.
    property identifierList : TFhirIdentifierList read GetIdentifierList;
    property hasIdentifierList : boolean read GetHasIdentifierList;

  end;

  TFhirCitationCitedArtifactContributorshipEntryAffiliationInfoListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirCitationCitedArtifactContributorshipEntryAffiliationInfoList;
    function GetCurrent : TFhirCitationCitedArtifactContributorshipEntryAffiliationInfo;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirCitationCitedArtifactContributorshipEntryAffiliationInfoList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirCitationCitedArtifactContributorshipEntryAffiliationInfo read GetCurrent;
  end;

  TFhirCitationCitedArtifactContributorshipEntryAffiliationInfoList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirCitationCitedArtifactContributorshipEntryAffiliationInfo;
    procedure SetItemN(index : Integer; value : TFhirCitationCitedArtifactContributorshipEntryAffiliationInfo);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirCitationCitedArtifactContributorshipEntryAffiliationInfoList; overload;
    function Clone : TFhirCitationCitedArtifactContributorshipEntryAffiliationInfoList; overload;
    function GetEnumerator : TFhirCitationCitedArtifactContributorshipEntryAffiliationInfoListEnumerator;
    
    //  Add a FhirCitationCitedArtifactContributorshipEntryAffiliationInfo to the end of the list.
    function Append : TFhirCitationCitedArtifactContributorshipEntryAffiliationInfo;
    
    // Add an already existing FhirCitationCitedArtifactContributorshipEntryAffiliationInfo to the end of the list.
    procedure AddItem(value : TFhirCitationCitedArtifactContributorshipEntryAffiliationInfo); overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirCitationCitedArtifactContributorshipEntryAffiliationInfo) : Integer;
    
    // Insert FhirCitationCitedArtifactContributorshipEntryAffiliationInfo before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirCitationCitedArtifactContributorshipEntryAffiliationInfo;
    
    // Insert an existing FhirCitationCitedArtifactContributorshipEntryAffiliationInfo before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirCitationCitedArtifactContributorshipEntryAffiliationInfo);
    
    // Get the iIndexth FhirCitationCitedArtifactContributorshipEntryAffiliationInfo. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirCitationCitedArtifactContributorshipEntryAffiliationInfo);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirCitationCitedArtifactContributorshipEntryAffiliationInfo;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirCitationCitedArtifactContributorshipEntryAffiliationInfos[index : Integer] : TFhirCitationCitedArtifactContributorshipEntryAffiliationInfo read GetItemN write SetItemN; default;
  End;

  // Contributions with accounting for time or number.
  TFhirCitationCitedArtifactContributorshipEntryContributionInstance = class (TFhirBackboneElement)
  protected
    FType_ : TFhirCodeableConcept;
    FTime : TFhirDateTime;
    procedure SetType_(value : TFhirCodeableConcept);
    procedure SetTime(value : TFhirDateTime);
    function GetTimeST : TFslDateTime;
    procedure SetTimeST(value : TFslDateTime);
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirCitationCitedArtifactContributorshipEntryContributionInstance; overload;
    function Clone : TFhirCitationCitedArtifactContributorshipEntryContributionInstance; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to The specific contribution. (defined for API consistency)
    property type_ : TFhirCodeableConcept read FType_ write SetType_;
    // The specific contribution.
    property type_Element : TFhirCodeableConcept read FType_ write SetType_;

    // Typed access to The time that the contribution was made.
    property time : TFslDateTime read GetTimeST write SetTimeST;
    // The time that the contribution was made.
    property timeElement : TFhirDateTime read FTime write SetTime;

  end;

  TFhirCitationCitedArtifactContributorshipEntryContributionInstanceListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirCitationCitedArtifactContributorshipEntryContributionInstanceList;
    function GetCurrent : TFhirCitationCitedArtifactContributorshipEntryContributionInstance;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirCitationCitedArtifactContributorshipEntryContributionInstanceList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirCitationCitedArtifactContributorshipEntryContributionInstance read GetCurrent;
  end;

  TFhirCitationCitedArtifactContributorshipEntryContributionInstanceList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirCitationCitedArtifactContributorshipEntryContributionInstance;
    procedure SetItemN(index : Integer; value : TFhirCitationCitedArtifactContributorshipEntryContributionInstance);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirCitationCitedArtifactContributorshipEntryContributionInstanceList; overload;
    function Clone : TFhirCitationCitedArtifactContributorshipEntryContributionInstanceList; overload;
    function GetEnumerator : TFhirCitationCitedArtifactContributorshipEntryContributionInstanceListEnumerator;
    
    //  Add a FhirCitationCitedArtifactContributorshipEntryContributionInstance to the end of the list.
    function Append : TFhirCitationCitedArtifactContributorshipEntryContributionInstance;
    
    // Add an already existing FhirCitationCitedArtifactContributorshipEntryContributionInstance to the end of the list.
    procedure AddItem(value : TFhirCitationCitedArtifactContributorshipEntryContributionInstance); overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirCitationCitedArtifactContributorshipEntryContributionInstance) : Integer;
    
    // Insert FhirCitationCitedArtifactContributorshipEntryContributionInstance before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirCitationCitedArtifactContributorshipEntryContributionInstance;
    
    // Insert an existing FhirCitationCitedArtifactContributorshipEntryContributionInstance before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirCitationCitedArtifactContributorshipEntryContributionInstance);
    
    // Get the iIndexth FhirCitationCitedArtifactContributorshipEntryContributionInstance. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirCitationCitedArtifactContributorshipEntryContributionInstance);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirCitationCitedArtifactContributorshipEntryContributionInstance;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirCitationCitedArtifactContributorshipEntryContributionInstances[index : Integer] : TFhirCitationCitedArtifactContributorshipEntryContributionInstance read GetItemN write SetItemN; default;
  End;

  // Used to record a display of the author/contributor list without separate coding for each list member.
  TFhirCitationCitedArtifactContributorshipSummary = class (TFhirBackboneElement)
  protected
    FType_ : TFhirCodeableConcept;
    FStyle : TFhirCodeableConcept;
    FSource : TFhirCodeableConcept;
    FValue : TFhirMarkdown;
    procedure SetType_(value : TFhirCodeableConcept);
    procedure SetStyle(value : TFhirCodeableConcept);
    procedure SetSource(value : TFhirCodeableConcept);
    procedure SetValue(value : TFhirMarkdown);
    function GetValueST : String;
    procedure SetValueST(value : String);
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirCitationCitedArtifactContributorshipSummary; overload;
    function Clone : TFhirCitationCitedArtifactContributorshipSummary; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to Used most commonly to express an author list or a contributorship statement. (defined for API consistency)
    property type_ : TFhirCodeableConcept read FType_ write SetType_;
    // Used most commonly to express an author list or a contributorship statement.
    property type_Element : TFhirCodeableConcept read FType_ write SetType_;

    // Typed access to The format for the display string. (defined for API consistency)
    property style : TFhirCodeableConcept read FStyle write SetStyle;
    // The format for the display string.
    property styleElement : TFhirCodeableConcept read FStyle write SetStyle;

    // Typed access to Used to code the producer or rule for creating the display string. (defined for API consistency)
    property source : TFhirCodeableConcept read FSource write SetSource;
    // Used to code the producer or rule for creating the display string.
    property sourceElement : TFhirCodeableConcept read FSource write SetSource;

    // Typed access to The display string for the author list, contributor list, or contributorship statement.
    property value : String read GetValueST write SetValueST;
    // The display string for the author list, contributor list, or contributorship statement.
    property valueElement : TFhirMarkdown read FValue write SetValue;

  end;

  TFhirCitationCitedArtifactContributorshipSummaryListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirCitationCitedArtifactContributorshipSummaryList;
    function GetCurrent : TFhirCitationCitedArtifactContributorshipSummary;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirCitationCitedArtifactContributorshipSummaryList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirCitationCitedArtifactContributorshipSummary read GetCurrent;
  end;

  TFhirCitationCitedArtifactContributorshipSummaryList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirCitationCitedArtifactContributorshipSummary;
    procedure SetItemN(index : Integer; value : TFhirCitationCitedArtifactContributorshipSummary);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirCitationCitedArtifactContributorshipSummaryList; overload;
    function Clone : TFhirCitationCitedArtifactContributorshipSummaryList; overload;
    function GetEnumerator : TFhirCitationCitedArtifactContributorshipSummaryListEnumerator;
    
    //  Add a FhirCitationCitedArtifactContributorshipSummary to the end of the list.
    function Append : TFhirCitationCitedArtifactContributorshipSummary;
    
    // Add an already existing FhirCitationCitedArtifactContributorshipSummary to the end of the list.
    procedure AddItem(value : TFhirCitationCitedArtifactContributorshipSummary); overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirCitationCitedArtifactContributorshipSummary) : Integer;
    
    // Insert FhirCitationCitedArtifactContributorshipSummary before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirCitationCitedArtifactContributorshipSummary;
    
    // Insert an existing FhirCitationCitedArtifactContributorshipSummary before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirCitationCitedArtifactContributorshipSummary);
    
    // Get the iIndexth FhirCitationCitedArtifactContributorshipSummary. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirCitationCitedArtifactContributorshipSummary);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirCitationCitedArtifactContributorshipSummary;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirCitationCitedArtifactContributorshipSummaries[index : Integer] : TFhirCitationCitedArtifactContributorshipSummary read GetItemN write SetItemN; default;
  End;

  // The Citation Resource enables reference to any knowledge artifact for purposes of identification and attribution. The Citation Resource supports existing reference structures and developing publication practices such as versioning, expressing complex contributorship roles, and referencing computable resources.
  TFhirCitation = class (TFhirMetadataResource)
  protected
    FsummaryList : TFhirContactDetailList;
    FclassificationList : TFhirCitationClassificationList;
    FnoteList : TFhirAnnotationList;
    FcurrentStateList : TFhirCodeableConceptList;
    FstatusDateList : TFhirCitationStatusDateList;
    FrelatesToList : TFhirCitationRelatesToList;
    FCitedArtifact : TFhirCitationCitedArtifact;
    procedure SetUrl(value : TFhirUri);
    function GetUrlST : String;
    procedure SetUrlST(value : String);
    function GetIdentifierList : TFhirIdentifierList;
    function GetHasIdentifierList : Boolean;
    procedure SetVersion(value : TFhirString);
    function GetVersionST : String;
    procedure SetVersionST(value : String);
    procedure SetName(value : TFhirString);
    function GetNameST : String;
    procedure SetNameST(value : String);
    procedure SetTitle(value : TFhirString);
    function GetTitleST : String;
    procedure SetTitleST(value : String);
    procedure SetStatus(value : TFhirEnum);
    function GetStatusST : TFhirPublicationStatusEnum;
    procedure SetStatusST(value : TFhirPublicationStatusEnum);
    procedure SetExperimental(value : TFhirBoolean);
    function GetExperimentalST : Boolean;
    procedure SetExperimentalST(value : Boolean);
    procedure SetDate(value : TFhirDateTime);
    function GetDateST : TFslDateTime;
    procedure SetDateST(value : TFslDateTime);
    procedure SetPublisher(value : TFhirString);
    function GetPublisherST : String;
    procedure SetPublisherST(value : String);
    function GetContactList : TFhirContactDetailList;
    function GetHasContactList : Boolean;
    procedure SetDescription(value : TFhirMarkdown);
    function GetDescriptionST : String;
    procedure SetDescriptionST(value : String);
    function GetUseContextList : TFhirUsageContextList;
    function GetHasUseContextList : Boolean;
    function GetJurisdictionList : TFhirCodeableConceptList;
    function GetHasJurisdictionList : Boolean;
    procedure SetPurpose(value : TFhirMarkdown);
    function GetPurposeST : String;
    procedure SetPurposeST(value : String);
    procedure SetCopyright(value : TFhirMarkdown);
    function GetCopyrightST : String;
    procedure SetCopyrightST(value : String);
    procedure SetApprovalDate(value : TFhirDate);
    function GetApprovalDateST : TFslDateTime;
    procedure SetApprovalDateST(value : TFslDateTime);
    procedure SetLastReviewDate(value : TFhirDate);
    function GetLastReviewDateST : TFslDateTime;
    procedure SetLastReviewDateST(value : TFslDateTime);
    procedure SetEffectivePeriod(value : TFhirPeriod);
    function GetAuthorList : TFhirContactDetailList;
    function GetHasAuthorList : Boolean;
    function GetEditorList : TFhirContactDetailList;
    function GetHasEditorList : Boolean;
    function GetReviewerList : TFhirContactDetailList;
    function GetHasReviewerList : Boolean;
    function GetEndorserList : TFhirContactDetailList;
    function GetHasEndorserList : Boolean;
    function GetSummaryList : TFhirContactDetailList;
    function GetHasSummaryList : Boolean;
    function GetClassificationList : TFhirCitationClassificationList;
    function GetHasClassificationList : Boolean;
    function GetNoteList : TFhirAnnotationList;
    function GetHasNoteList : Boolean;
    function GetCurrentStateList : TFhirCodeableConceptList;
    function GetHasCurrentStateList : Boolean;
    function GetStatusDateList : TFhirCitationStatusDateList;
    function GetHasStatusDateList : Boolean;
    function GetRelatesToList : TFhirCitationRelatesToList;
    function GetHasRelatesToList : Boolean;
    procedure SetCitedArtifact(value : TFhirCitationCitedArtifact);
  
    function GetResourceType : TFhirResourceType; override;
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirCitation; overload;
    function Clone : TFhirCitation; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to An absolute URI that is used to identify this citation when it is referenced in a specification, model, design or an instance; also called its canonical identifier. This SHOULD be globally unique and SHOULD be a literal address at which at which an authoritative instance of this summary is (or will be) published. This URL can be the target of a canonical reference. It SHALL remain the same when the summary is stored on different servers.
    property url : String read GetUrlST write SetUrlST;
    // An absolute URI that is used to identify this citation when it is referenced in a specification, model, design or an instance; also called its canonical identifier. This SHOULD be globally unique and SHOULD be a literal address at which at which an authoritative instance of this summary is (or will be) published. This URL can be the target of a canonical reference. It SHALL remain the same when the summary is stored on different servers.
    property urlElement : TFhirUri read FUrl write SetUrl;

    // A formal identifier that is used to identify this citation when it is represented in other formats, or referenced in a specification, model, design or an instance.
    property identifierList : TFhirIdentifierList read GetIdentifierList;
    property hasIdentifierList : boolean read GetHasIdentifierList;

    // Typed access to The identifier that is used to identify this version of the citation when it is referenced in a specification, model, design or instance. This is an arbitrary value managed by the citation author and is not expected to be globally unique. For example, it might be a timestamp (e.g. yyyymmdd) if a managed version is not available. There is also no expectation that versions can be placed in a lexicographical sequence.
    property version : String read GetVersionST write SetVersionST;
    // The identifier that is used to identify this version of the citation when it is referenced in a specification, model, design or instance. This is an arbitrary value managed by the citation author and is not expected to be globally unique. For example, it might be a timestamp (e.g. yyyymmdd) if a managed version is not available. There is also no expectation that versions can be placed in a lexicographical sequence.
    property versionElement : TFhirString read FVersion write SetVersion;

    // Typed access to A natural language name identifying the citation. This name should be usable as an identifier for the module by machine processing applications such as code generation.
    property name : String read GetNameST write SetNameST;
    // A natural language name identifying the citation. This name should be usable as an identifier for the module by machine processing applications such as code generation.
    property nameElement : TFhirString read FName write SetName;

    // Typed access to A short, descriptive, user-friendly title for the citation.
    property title : String read GetTitleST write SetTitleST;
    // A short, descriptive, user-friendly title for the citation.
    property titleElement : TFhirString read FTitle write SetTitle;

    // The status of this summary. Enables tracking the life-cycle of the content.
    property status : TFhirPublicationStatusEnum read GetStatusST write SetStatusST;
    property statusElement : TFhirEnum read FStatus write SetStatus;

    // Typed access to A Boolean value to indicate that this citation is authored for testing purposes (or education/evaluation/marketing) and is not intended to be used for genuine usage.
    property experimental : Boolean read GetExperimentalST write SetExperimentalST;
    // A Boolean value to indicate that this citation is authored for testing purposes (or education/evaluation/marketing) and is not intended to be used for genuine usage.
    property experimentalElement : TFhirBoolean read FExperimental write SetExperimental;

    // Typed access to The date  (and optionally time) when the citation was published. The date must change when the business version changes and it must change if the status code changes. In addition, it should change when the substantive content of the citation changes.
    property date : TFslDateTime read GetDateST write SetDateST;
    // The date  (and optionally time) when the citation was published. The date must change when the business version changes and it must change if the status code changes. In addition, it should change when the substantive content of the citation changes.
    property dateElement : TFhirDateTime read FDate write SetDate;

    // Typed access to The name of the organization or individual that published the citation.
    property publisher : String read GetPublisherST write SetPublisherST;
    // The name of the organization or individual that published the citation.
    property publisherElement : TFhirString read FPublisher write SetPublisher;

    // Contact details to assist a user in finding and communicating with the publisher.
    property contactList : TFhirContactDetailList read GetContactList;
    property hasContactList : boolean read GetHasContactList;

    // Typed access to A free text natural language description of the citation from a consumer's perspective.
    property description : String read GetDescriptionST write SetDescriptionST;
    // A free text natural language description of the citation from a consumer's perspective.
    property descriptionElement : TFhirMarkdown read FDescription write SetDescription;

    // The content was developed with a focus and intent of supporting the contexts that are listed. These contexts may be general categories (gender, age, ...) or may be references to specific programs (insurance plans, studies, ...) and may be used to assist with indexing and searching for appropriate citation instances.
    property useContextList : TFhirUsageContextList read GetUseContextList;
    property hasUseContextList : boolean read GetHasUseContextList;

    // A legal or geographic region in which the citation is intended to be used.
    property jurisdictionList : TFhirCodeableConceptList read GetJurisdictionList;
    property hasJurisdictionList : boolean read GetHasJurisdictionList;

    // Typed access to Explanation of why this citation is needed and why it has been designed as it has.
    property purpose : String read GetPurposeST write SetPurposeST;
    // Explanation of why this citation is needed and why it has been designed as it has.
    property purposeElement : TFhirMarkdown read FPurpose write SetPurpose;

    // Typed access to Use and/or publishing restrictions for the Citation, not for the cited artifact.
    property copyright : String read GetCopyrightST write SetCopyrightST;
    // Use and/or publishing restrictions for the Citation, not for the cited artifact.
    property copyrightElement : TFhirMarkdown read FCopyright write SetCopyright;

    // Typed access to The date on which the resource content was approved by the publisher. Approval happens once when the content is officially approved for usage.
    property approvalDate : TFslDateTime read GetApprovalDateST write SetApprovalDateST;
    // The date on which the resource content was approved by the publisher. Approval happens once when the content is officially approved for usage.
    property approvalDateElement : TFhirDate read FApprovalDate write SetApprovalDate;

    // Typed access to The date on which the resource content was last reviewed. Review happens periodically after approval but does not change the original approval date.
    property lastReviewDate : TFslDateTime read GetLastReviewDateST write SetLastReviewDateST;
    // The date on which the resource content was last reviewed. Review happens periodically after approval but does not change the original approval date.
    property lastReviewDateElement : TFhirDate read FLastReviewDate write SetLastReviewDate;

    // Typed access to The period during which the citation content was or is planned to be in active use. (defined for API consistency)
    property effectivePeriod : TFhirPeriod read FEffectivePeriod write SetEffectivePeriod;
    // The period during which the citation content was or is planned to be in active use.
    property effectivePeriodElement : TFhirPeriod read FEffectivePeriod write SetEffectivePeriod;

    // Who authored the Citation.
    property authorList : TFhirContactDetailList read GetAuthorList;
    property hasAuthorList : boolean read GetHasAuthorList;

    // Who edited the Citation.
    property editorList : TFhirContactDetailList read GetEditorList;
    property hasEditorList : boolean read GetHasEditorList;

    // Who reviewed the Citation.
    property reviewerList : TFhirContactDetailList read GetReviewerList;
    property hasReviewerList : boolean read GetHasReviewerList;

    // Who endorsed the Citation.
    property endorserList : TFhirContactDetailList read GetEndorserList;
    property hasEndorserList : boolean read GetHasEndorserList;

    // A human-readable display of the citation.
    property summaryList : TFhirContactDetailList read GetSummaryList;
    property hasSummaryList : boolean read GetHasSummaryList;

    // The assignment to an organizing scheme.
    property classificationList : TFhirCitationClassificationList read GetClassificationList;
    property hasClassificationList : boolean read GetHasClassificationList;

    // Used for general notes and annotations not coded elsewhere.
    property noteList : TFhirAnnotationList read GetNoteList;
    property hasNoteList : boolean read GetHasNoteList;

    // The status of the citation.
    property currentStateList : TFhirCodeableConceptList read GetCurrentStateList;
    property hasCurrentStateList : boolean read GetHasCurrentStateList;

    // An effective date or period for a status of the citation.
    property statusDateList : TFhirCitationStatusDateList read GetStatusDateList;
    property hasStatusDateList : boolean read GetHasStatusDateList;

    // Artifact related to the Citation Resource.
    property relatesToList : TFhirCitationRelatesToList read GetRelatesToList;
    property hasRelatesToList : boolean read GetHasRelatesToList;

    // Typed access to The article or artifact being described. (defined for API consistency)
    property citedArtifact : TFhirCitationCitedArtifact read FCitedArtifact write SetCitedArtifact;
    // The article or artifact being described.
    property citedArtifactElement : TFhirCitationCitedArtifact read FCitedArtifact write SetCitedArtifact;

  end;

  TFhirCitationListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirCitationList;
    function GetCurrent : TFhirCitation;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirCitationList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirCitation read GetCurrent;
  end;

  TFhirCitationList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirCitation;
    procedure SetItemN(index : Integer; value : TFhirCitation);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirCitationList; overload;
    function Clone : TFhirCitationList; overload;
    function GetEnumerator : TFhirCitationListEnumerator;
    
    //  Add a FhirCitation to the end of the list.
    function Append : TFhirCitation;
    
    // Add an already existing FhirCitation to the end of the list.
    procedure AddItem(value : TFhirCitation); overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirCitation) : Integer;
    
    // Insert FhirCitation before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirCitation;
    
    // Insert an existing FhirCitation before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirCitation);
    
    // Get the iIndexth FhirCitation. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirCitation);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirCitation;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirCitations[index : Integer] : TFhirCitation read GetItemN write SetItemN; default;
  End;

{$ENDIF FHIR_CITATION}
{$IFDEF FHIR_CLAIM}
  // Other claims which are related to this claim such as prior submissions or claims for related services or for the same event.
  TFhirClaimRelated = class (TFhirBackboneElement)
  protected
    FClaim : TFhirReference;
    FRelationship : TFhirCodeableConcept;
    FReference : TFhirIdentifier;
    procedure SetClaim(value : TFhirReference);
    procedure SetRelationship(value : TFhirCodeableConcept);
    procedure SetReference(value : TFhirIdentifier);
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirClaimRelated; overload;
    function Clone : TFhirClaimRelated; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to Reference to a related claim. (defined for API consistency)
    property claim : TFhirReference read FClaim write SetClaim;
    // Reference to a related claim.
    property claimElement : TFhirReference read FClaim write SetClaim;

    // Typed access to A code to convey how the claims are related. (defined for API consistency)
    property relationship : TFhirCodeableConcept read FRelationship write SetRelationship;
    // A code to convey how the claims are related.
    property relationshipElement : TFhirCodeableConcept read FRelationship write SetRelationship;

    // Typed access to An alternate organizational reference to the case or file to which this particular claim pertains. (defined for API consistency)
    property reference : TFhirIdentifier read FReference write SetReference;
    // An alternate organizational reference to the case or file to which this particular claim pertains.
    property referenceElement : TFhirIdentifier read FReference write SetReference;

  end;

  TFhirClaimRelatedListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirClaimRelatedList;
    function GetCurrent : TFhirClaimRelated;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirClaimRelatedList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirClaimRelated read GetCurrent;
  end;

  TFhirClaimRelatedList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirClaimRelated;
    procedure SetItemN(index : Integer; value : TFhirClaimRelated);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirClaimRelatedList; overload;
    function Clone : TFhirClaimRelatedList; overload;
    function GetEnumerator : TFhirClaimRelatedListEnumerator;
    
    //  Add a FhirClaimRelated to the end of the list.
    function Append : TFhirClaimRelated;
    
    // Add an already existing FhirClaimRelated to the end of the list.
    procedure AddItem(value : TFhirClaimRelated); overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirClaimRelated) : Integer;
    
    // Insert FhirClaimRelated before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirClaimRelated;
    
    // Insert an existing FhirClaimRelated before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirClaimRelated);
    
    // Get the iIndexth FhirClaimRelated. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirClaimRelated);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirClaimRelated;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirClaimRelateds[index : Integer] : TFhirClaimRelated read GetItemN write SetItemN; default;
  End;

  // The party to be reimbursed for cost of the products and services according to the terms of the policy.
  TFhirClaimPayee = class (TFhirBackboneElement)
  protected
    FType_ : TFhirCodeableConcept;
    FParty : TFhirReference;
    procedure SetType_(value : TFhirCodeableConcept);
    procedure SetParty(value : TFhirReference);
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirClaimPayee; overload;
    function Clone : TFhirClaimPayee; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to Type of Party to be reimbursed: subscriber, provider, other. (defined for API consistency)
    property type_ : TFhirCodeableConcept read FType_ write SetType_;
    // Type of Party to be reimbursed: subscriber, provider, other.
    property type_Element : TFhirCodeableConcept read FType_ write SetType_;

    // Typed access to Reference to the individual or organization to whom any payment will be made. (defined for API consistency)
    property party : TFhirReference read FParty write SetParty;
    // Reference to the individual or organization to whom any payment will be made.
    property partyElement : TFhirReference read FParty write SetParty;

  end;

  TFhirClaimPayeeListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirClaimPayeeList;
    function GetCurrent : TFhirClaimPayee;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirClaimPayeeList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirClaimPayee read GetCurrent;
  end;

  TFhirClaimPayeeList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirClaimPayee;
    procedure SetItemN(index : Integer; value : TFhirClaimPayee);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirClaimPayeeList; overload;
    function Clone : TFhirClaimPayeeList; overload;
    function GetEnumerator : TFhirClaimPayeeListEnumerator;
    
    //  Add a FhirClaimPayee to the end of the list.
    function Append : TFhirClaimPayee;
    
    // Add an already existing FhirClaimPayee to the end of the list.
    procedure AddItem(value : TFhirClaimPayee); overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirClaimPayee) : Integer;
    
    // Insert FhirClaimPayee before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirClaimPayee;
    
    // Insert an existing FhirClaimPayee before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirClaimPayee);
    
    // Get the iIndexth FhirClaimPayee. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirClaimPayee);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirClaimPayee;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirClaimPayees[index : Integer] : TFhirClaimPayee read GetItemN write SetItemN; default;
  End;

  // The members of the team who provided the products and services.
  TFhirClaimCareTeam = class (TFhirBackboneElement)
  protected
    FSequence : TFhirPositiveInt;
    FProvider : TFhirReference;
    FResponsible : TFhirBoolean;
    FRole : TFhirCodeableConcept;
    FQualification : TFhirCodeableConcept;
    procedure SetSequence(value : TFhirPositiveInt);
    function GetSequenceST : String;
    procedure SetSequenceST(value : String);
    procedure SetProvider(value : TFhirReference);
    procedure SetResponsible(value : TFhirBoolean);
    function GetResponsibleST : Boolean;
    procedure SetResponsibleST(value : Boolean);
    procedure SetRole(value : TFhirCodeableConcept);
    procedure SetQualification(value : TFhirCodeableConcept);
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirClaimCareTeam; overload;
    function Clone : TFhirClaimCareTeam; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to A number to uniquely identify care team entries.
    property sequence : String read GetSequenceST write SetSequenceST;
    // A number to uniquely identify care team entries.
    property sequenceElement : TFhirPositiveInt read FSequence write SetSequence;

    // Typed access to Member of the team who provided the product or service. (defined for API consistency)
    property provider : TFhirReference read FProvider write SetProvider;
    // Member of the team who provided the product or service.
    property providerElement : TFhirReference read FProvider write SetProvider;

    // Typed access to The party who is billing and/or responsible for the claimed products or services.
    property responsible : Boolean read GetResponsibleST write SetResponsibleST;
    // The party who is billing and/or responsible for the claimed products or services.
    property responsibleElement : TFhirBoolean read FResponsible write SetResponsible;

    // Typed access to The lead, assisting or supervising practitioner and their discipline if a multidisciplinary team. (defined for API consistency)
    property role : TFhirCodeableConcept read FRole write SetRole;
    // The lead, assisting or supervising practitioner and their discipline if a multidisciplinary team.
    property roleElement : TFhirCodeableConcept read FRole write SetRole;

    // Typed access to The qualification of the practitioner which is applicable for this service. (defined for API consistency)
    property qualification : TFhirCodeableConcept read FQualification write SetQualification;
    // The qualification of the practitioner which is applicable for this service.
    property qualificationElement : TFhirCodeableConcept read FQualification write SetQualification;

  end;

  TFhirClaimCareTeamListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirClaimCareTeamList;
    function GetCurrent : TFhirClaimCareTeam;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirClaimCareTeamList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirClaimCareTeam read GetCurrent;
  end;

  TFhirClaimCareTeamList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirClaimCareTeam;
    procedure SetItemN(index : Integer; value : TFhirClaimCareTeam);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirClaimCareTeamList; overload;
    function Clone : TFhirClaimCareTeamList; overload;
    function GetEnumerator : TFhirClaimCareTeamListEnumerator;
    
    //  Add a FhirClaimCareTeam to the end of the list.
    function Append : TFhirClaimCareTeam;
    
    // Add an already existing FhirClaimCareTeam to the end of the list.
    procedure AddItem(value : TFhirClaimCareTeam); overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirClaimCareTeam) : Integer;
    
    // Insert FhirClaimCareTeam before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirClaimCareTeam;
    
    // Insert an existing FhirClaimCareTeam before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirClaimCareTeam);
    
    // Get the iIndexth FhirClaimCareTeam. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirClaimCareTeam);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirClaimCareTeam;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirClaimCareTeams[index : Integer] : TFhirClaimCareTeam read GetItemN write SetItemN; default;
  End;

  // Additional information codes regarding exceptions, special considerations, the condition, situation, prior or concurrent issues.
  TFhirClaimSupportingInfo = class (TFhirBackboneElement)
  protected
    FSequence : TFhirPositiveInt;
    FCategory : TFhirCodeableConcept;
    FCode : TFhirCodeableConcept;
    FTiming : TFhirDataType;
    FValue : TFhirDataType;
    FReason : TFhirCodeableConcept;
    procedure SetSequence(value : TFhirPositiveInt);
    function GetSequenceST : String;
    procedure SetSequenceST(value : String);
    procedure SetCategory(value : TFhirCodeableConcept);
    procedure SetCode(value : TFhirCodeableConcept);
    procedure SetTiming(value : TFhirDataType);
    procedure SetValue(value : TFhirDataType);
    procedure SetReason(value : TFhirCodeableConcept);
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirClaimSupportingInfo; overload;
    function Clone : TFhirClaimSupportingInfo; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to A number to uniquely identify supporting information entries.
    property sequence : String read GetSequenceST write SetSequenceST;
    // A number to uniquely identify supporting information entries.
    property sequenceElement : TFhirPositiveInt read FSequence write SetSequence;

    // Typed access to The general class of the information supplied: information; exception; accident, employment; onset, etc. (defined for API consistency)
    property category : TFhirCodeableConcept read FCategory write SetCategory;
    // The general class of the information supplied: information; exception; accident, employment; onset, etc.
    property categoryElement : TFhirCodeableConcept read FCategory write SetCategory;

    // Typed access to System and code pertaining to the specific information regarding special conditions relating to the setting, treatment or patient  for which care is sought. (defined for API consistency)
    property code : TFhirCodeableConcept read FCode write SetCode;
    // System and code pertaining to the specific information regarding special conditions relating to the setting, treatment or patient  for which care is sought.
    property codeElement : TFhirCodeableConcept read FCode write SetCode;

    // Typed access to The date when or period to which this information refers. (defined for API consistency)
    property timing : TFhirDataType read FTiming write SetTiming;
    // The date when or period to which this information refers.
    property timingElement : TFhirDataType read FTiming write SetTiming;

    // Typed access to Additional data or information such as resources, documents, images etc. including references to the data or the actual inclusion of the data. (defined for API consistency)
    property value : TFhirDataType read FValue write SetValue;
    // Additional data or information such as resources, documents, images etc. including references to the data or the actual inclusion of the data.
    property valueElement : TFhirDataType read FValue write SetValue;

    // Typed access to Provides the reason in the situation where a reason code is required in addition to the content. (defined for API consistency)
    property reason : TFhirCodeableConcept read FReason write SetReason;
    // Provides the reason in the situation where a reason code is required in addition to the content.
    property reasonElement : TFhirCodeableConcept read FReason write SetReason;

  end;

  TFhirClaimSupportingInfoListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirClaimSupportingInfoList;
    function GetCurrent : TFhirClaimSupportingInfo;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirClaimSupportingInfoList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirClaimSupportingInfo read GetCurrent;
  end;

  TFhirClaimSupportingInfoList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirClaimSupportingInfo;
    procedure SetItemN(index : Integer; value : TFhirClaimSupportingInfo);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirClaimSupportingInfoList; overload;
    function Clone : TFhirClaimSupportingInfoList; overload;
    function GetEnumerator : TFhirClaimSupportingInfoListEnumerator;
    
    //  Add a FhirClaimSupportingInfo to the end of the list.
    function Append : TFhirClaimSupportingInfo;
    
    // Add an already existing FhirClaimSupportingInfo to the end of the list.
    procedure AddItem(value : TFhirClaimSupportingInfo); overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirClaimSupportingInfo) : Integer;
    
    // Insert FhirClaimSupportingInfo before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirClaimSupportingInfo;
    
    // Insert an existing FhirClaimSupportingInfo before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirClaimSupportingInfo);
    
    // Get the iIndexth FhirClaimSupportingInfo. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirClaimSupportingInfo);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirClaimSupportingInfo;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirClaimSupportingInfos[index : Integer] : TFhirClaimSupportingInfo read GetItemN write SetItemN; default;
  End;

  // Information about diagnoses relevant to the claim items.
  TFhirClaimDiagnosis = class (TFhirBackboneElement)
  protected
    FSequence : TFhirPositiveInt;
    FDiagnosis : TFhirDataType;
    Ftype_List : TFhirCodeableConceptList;
    FOnAdmission : TFhirCodeableConcept;
    FPackageCode : TFhirCodeableConcept;
    procedure SetSequence(value : TFhirPositiveInt);
    function GetSequenceST : String;
    procedure SetSequenceST(value : String);
    procedure SetDiagnosis(value : TFhirDataType);
    function GetType_List : TFhirCodeableConceptList;
    function GetHasType_List : Boolean;
    procedure SetOnAdmission(value : TFhirCodeableConcept);
    procedure SetPackageCode(value : TFhirCodeableConcept);
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirClaimDiagnosis; overload;
    function Clone : TFhirClaimDiagnosis; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to A number to uniquely identify diagnosis entries.
    property sequence : String read GetSequenceST write SetSequenceST;
    // A number to uniquely identify diagnosis entries.
    property sequenceElement : TFhirPositiveInt read FSequence write SetSequence;

    // Typed access to The nature of illness or problem in a coded form or as a reference to an external defined Condition. (defined for API consistency)
    property diagnosis : TFhirDataType read FDiagnosis write SetDiagnosis;
    // The nature of illness or problem in a coded form or as a reference to an external defined Condition.
    property diagnosisElement : TFhirDataType read FDiagnosis write SetDiagnosis;

    // When the condition was observed or the relative ranking.
    property type_List : TFhirCodeableConceptList read GetType_List;
    property hasType_List : boolean read GetHasType_List;

    // Typed access to Indication of whether the diagnosis was present on admission to a facility. (defined for API consistency)
    property onAdmission : TFhirCodeableConcept read FOnAdmission write SetOnAdmission;
    // Indication of whether the diagnosis was present on admission to a facility.
    property onAdmissionElement : TFhirCodeableConcept read FOnAdmission write SetOnAdmission;

    // Typed access to A package billing code or bundle code used to group products and services to a particular health condition (such as heart attack) which is based on a predetermined grouping code system. (defined for API consistency)
    property packageCode : TFhirCodeableConcept read FPackageCode write SetPackageCode;
    // A package billing code or bundle code used to group products and services to a particular health condition (such as heart attack) which is based on a predetermined grouping code system.
    property packageCodeElement : TFhirCodeableConcept read FPackageCode write SetPackageCode;

  end;

  TFhirClaimDiagnosisListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirClaimDiagnosisList;
    function GetCurrent : TFhirClaimDiagnosis;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirClaimDiagnosisList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirClaimDiagnosis read GetCurrent;
  end;

  TFhirClaimDiagnosisList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirClaimDiagnosis;
    procedure SetItemN(index : Integer; value : TFhirClaimDiagnosis);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirClaimDiagnosisList; overload;
    function Clone : TFhirClaimDiagnosisList; overload;
    function GetEnumerator : TFhirClaimDiagnosisListEnumerator;
    
    //  Add a FhirClaimDiagnosis to the end of the list.
    function Append : TFhirClaimDiagnosis;
    
    // Add an already existing FhirClaimDiagnosis to the end of the list.
    procedure AddItem(value : TFhirClaimDiagnosis); overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirClaimDiagnosis) : Integer;
    
    // Insert FhirClaimDiagnosis before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirClaimDiagnosis;
    
    // Insert an existing FhirClaimDiagnosis before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirClaimDiagnosis);
    
    // Get the iIndexth FhirClaimDiagnosis. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirClaimDiagnosis);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirClaimDiagnosis;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirClaimDiagnoses[index : Integer] : TFhirClaimDiagnosis read GetItemN write SetItemN; default;
  End;

  // Procedures performed on the patient relevant to the billing items with the claim.
  TFhirClaimProcedure = class (TFhirBackboneElement)
  protected
    FSequence : TFhirPositiveInt;
    Ftype_List : TFhirCodeableConceptList;
    FDate : TFhirDateTime;
    FProcedure_ : TFhirDataType;
    FudiList : TFhirReferenceList;
    procedure SetSequence(value : TFhirPositiveInt);
    function GetSequenceST : String;
    procedure SetSequenceST(value : String);
    function GetType_List : TFhirCodeableConceptList;
    function GetHasType_List : Boolean;
    procedure SetDate(value : TFhirDateTime);
    function GetDateST : TFslDateTime;
    procedure SetDateST(value : TFslDateTime);
    procedure SetProcedure_(value : TFhirDataType);
    function GetUdiList : TFhirReferenceList;
    function GetHasUdiList : Boolean;
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirClaimProcedure; overload;
    function Clone : TFhirClaimProcedure; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to A number to uniquely identify procedure entries.
    property sequence : String read GetSequenceST write SetSequenceST;
    // A number to uniquely identify procedure entries.
    property sequenceElement : TFhirPositiveInt read FSequence write SetSequence;

    // When the condition was observed or the relative ranking.
    property type_List : TFhirCodeableConceptList read GetType_List;
    property hasType_List : boolean read GetHasType_List;

    // Typed access to Date and optionally time the procedure was performed.
    property date : TFslDateTime read GetDateST write SetDateST;
    // Date and optionally time the procedure was performed.
    property dateElement : TFhirDateTime read FDate write SetDate;

    // Typed access to The code or reference to a Procedure resource which identifies the clinical intervention performed. (defined for API consistency)
    property procedure_ : TFhirDataType read FProcedure_ write SetProcedure_;
    // The code or reference to a Procedure resource which identifies the clinical intervention performed.
    property procedure_Element : TFhirDataType read FProcedure_ write SetProcedure_;

    // Unique Device Identifiers associated with this line item.
    property udiList : TFhirReferenceList read GetUdiList;
    property hasUdiList : boolean read GetHasUdiList;

  end;

  TFhirClaimProcedureListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirClaimProcedureList;
    function GetCurrent : TFhirClaimProcedure;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirClaimProcedureList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirClaimProcedure read GetCurrent;
  end;

  TFhirClaimProcedureList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirClaimProcedure;
    procedure SetItemN(index : Integer; value : TFhirClaimProcedure);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirClaimProcedureList; overload;
    function Clone : TFhirClaimProcedureList; overload;
    function GetEnumerator : TFhirClaimProcedureListEnumerator;
    
    //  Add a FhirClaimProcedure to the end of the list.
    function Append : TFhirClaimProcedure;
    
    // Add an already existing FhirClaimProcedure to the end of the list.
    procedure AddItem(value : TFhirClaimProcedure); overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirClaimProcedure) : Integer;
    
    // Insert FhirClaimProcedure before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirClaimProcedure;
    
    // Insert an existing FhirClaimProcedure before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirClaimProcedure);
    
    // Get the iIndexth FhirClaimProcedure. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirClaimProcedure);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirClaimProcedure;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirClaimProcedures[index : Integer] : TFhirClaimProcedure read GetItemN write SetItemN; default;
  End;

  // Financial instruments for reimbursement for the health care products and services specified on the claim.
  TFhirClaimInsurance = class (TFhirBackboneElement)
  protected
    FSequence : TFhirPositiveInt;
    FFocal : TFhirBoolean;
    FIdentifier : TFhirIdentifier;
    FCoverage : TFhirReference;
    FBusinessArrangement : TFhirString;
    FpreAuthRefList : TFhirStringList;
    FClaimResponse : TFhirReference;
    procedure SetSequence(value : TFhirPositiveInt);
    function GetSequenceST : String;
    procedure SetSequenceST(value : String);
    procedure SetFocal(value : TFhirBoolean);
    function GetFocalST : Boolean;
    procedure SetFocalST(value : Boolean);
    procedure SetIdentifier(value : TFhirIdentifier);
    procedure SetCoverage(value : TFhirReference);
    procedure SetBusinessArrangement(value : TFhirString);
    function GetBusinessArrangementST : String;
    procedure SetBusinessArrangementST(value : String);
    function GetPreAuthRefList : TFhirStringList;
    function GetHasPreAuthRefList : Boolean;
    procedure SetClaimResponse(value : TFhirReference);
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirClaimInsurance; overload;
    function Clone : TFhirClaimInsurance; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to A number to uniquely identify insurance entries and provide a sequence of coverages to convey coordination of benefit order.
    property sequence : String read GetSequenceST write SetSequenceST;
    // A number to uniquely identify insurance entries and provide a sequence of coverages to convey coordination of benefit order.
    property sequenceElement : TFhirPositiveInt read FSequence write SetSequence;

    // Typed access to A flag to indicate that this Coverage is to be used for adjudication of this claim when set to true.
    property focal : Boolean read GetFocalST write SetFocalST;
    // A flag to indicate that this Coverage is to be used for adjudication of this claim when set to true.
    property focalElement : TFhirBoolean read FFocal write SetFocal;

    // Typed access to The business identifier to be used when the claim is sent for adjudication against this insurance policy. (defined for API consistency)
    property identifier : TFhirIdentifier read FIdentifier write SetIdentifier;
    // The business identifier to be used when the claim is sent for adjudication against this insurance policy.
    property identifierElement : TFhirIdentifier read FIdentifier write SetIdentifier;

    // Typed access to Reference to the insurance card level information contained in the Coverage resource. The coverage issuing insurer will use these details to locate the patient's actual coverage within the insurer's information system. (defined for API consistency)
    property coverage : TFhirReference read FCoverage write SetCoverage;
    // Reference to the insurance card level information contained in the Coverage resource. The coverage issuing insurer will use these details to locate the patient's actual coverage within the insurer's information system.
    property coverageElement : TFhirReference read FCoverage write SetCoverage;

    // Typed access to A business agreement number established between the provider and the insurer for special business processing purposes.
    property businessArrangement : String read GetBusinessArrangementST write SetBusinessArrangementST;
    // A business agreement number established between the provider and the insurer for special business processing purposes.
    property businessArrangementElement : TFhirString read FBusinessArrangement write SetBusinessArrangement;

    // Reference numbers previously provided by the insurer to the provider to be quoted on subsequent claims containing services or products related to the prior authorization.
    property preAuthRefList : TFhirStringList read GetPreAuthRefList;
    property hasPreAuthRefList : boolean read GetHasPreAuthRefList;

    // Typed access to The result of the adjudication of the line items for the Coverage specified in this insurance. (defined for API consistency)
    property claimResponse : TFhirReference read FClaimResponse write SetClaimResponse;
    // The result of the adjudication of the line items for the Coverage specified in this insurance.
    property claimResponseElement : TFhirReference read FClaimResponse write SetClaimResponse;

  end;

  TFhirClaimInsuranceListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirClaimInsuranceList;
    function GetCurrent : TFhirClaimInsurance;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirClaimInsuranceList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirClaimInsurance read GetCurrent;
  end;

  TFhirClaimInsuranceList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirClaimInsurance;
    procedure SetItemN(index : Integer; value : TFhirClaimInsurance);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirClaimInsuranceList; overload;
    function Clone : TFhirClaimInsuranceList; overload;
    function GetEnumerator : TFhirClaimInsuranceListEnumerator;
    
    //  Add a FhirClaimInsurance to the end of the list.
    function Append : TFhirClaimInsurance;
    
    // Add an already existing FhirClaimInsurance to the end of the list.
    procedure AddItem(value : TFhirClaimInsurance); overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirClaimInsurance) : Integer;
    
    // Insert FhirClaimInsurance before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirClaimInsurance;
    
    // Insert an existing FhirClaimInsurance before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirClaimInsurance);
    
    // Get the iIndexth FhirClaimInsurance. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirClaimInsurance);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirClaimInsurance;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirClaimInsurances[index : Integer] : TFhirClaimInsurance read GetItemN write SetItemN; default;
  End;

  // Details of an accident which resulted in injuries which required the products and services listed in the claim.
  TFhirClaimAccident = class (TFhirBackboneElement)
  protected
    FDate : TFhirDate;
    FType_ : TFhirCodeableConcept;
    FLocation : TFhirDataType;
    procedure SetDate(value : TFhirDate);
    function GetDateST : TFslDateTime;
    procedure SetDateST(value : TFslDateTime);
    procedure SetType_(value : TFhirCodeableConcept);
    procedure SetLocation(value : TFhirDataType);
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirClaimAccident; overload;
    function Clone : TFhirClaimAccident; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to Date of an accident event  related to the products and services contained in the claim.
    property date : TFslDateTime read GetDateST write SetDateST;
    // Date of an accident event  related to the products and services contained in the claim.
    property dateElement : TFhirDate read FDate write SetDate;

    // Typed access to The type or context of the accident event for the purposes of selection of potential insurance coverages and determination of coordination between insurers. (defined for API consistency)
    property type_ : TFhirCodeableConcept read FType_ write SetType_;
    // The type or context of the accident event for the purposes of selection of potential insurance coverages and determination of coordination between insurers.
    property type_Element : TFhirCodeableConcept read FType_ write SetType_;

    // Typed access to The physical location of the accident event. (defined for API consistency)
    property location : TFhirDataType read FLocation write SetLocation;
    // The physical location of the accident event.
    property locationElement : TFhirDataType read FLocation write SetLocation;

  end;

  TFhirClaimAccidentListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirClaimAccidentList;
    function GetCurrent : TFhirClaimAccident;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirClaimAccidentList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirClaimAccident read GetCurrent;
  end;

  TFhirClaimAccidentList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirClaimAccident;
    procedure SetItemN(index : Integer; value : TFhirClaimAccident);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirClaimAccidentList; overload;
    function Clone : TFhirClaimAccidentList; overload;
    function GetEnumerator : TFhirClaimAccidentListEnumerator;
    
    //  Add a FhirClaimAccident to the end of the list.
    function Append : TFhirClaimAccident;
    
    // Add an already existing FhirClaimAccident to the end of the list.
    procedure AddItem(value : TFhirClaimAccident); overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirClaimAccident) : Integer;
    
    // Insert FhirClaimAccident before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirClaimAccident;
    
    // Insert an existing FhirClaimAccident before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirClaimAccident);
    
    // Get the iIndexth FhirClaimAccident. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirClaimAccident);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirClaimAccident;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirClaimAccidents[index : Integer] : TFhirClaimAccident read GetItemN write SetItemN; default;
  End;

  // A claim line. Either a simple  product or service or a 'group' of details which can each be a simple items or groups of sub-details.
  TFhirClaimItem = class (TFhirBackboneElement)
  protected
    FSequence : TFhirPositiveInt;
    FcareTeamSequenceList : TFhirPositiveIntList;
    FdiagnosisSequenceList : TFhirPositiveIntList;
    FprocedureSequenceList : TFhirPositiveIntList;
    FinformationSequenceList : TFhirPositiveIntList;
    FRevenue : TFhirCodeableConcept;
    FCategory : TFhirCodeableConcept;
    FProductOrService : TFhirCodeableConcept;
    FmodifierList : TFhirCodeableConceptList;
    FprogramCodeList : TFhirCodeableConceptList;
    FServiced : TFhirDataType;
    FLocation : TFhirDataType;
    FQuantity : TFhirQuantity;
    FUnitPrice : TFhirMoney;
    FFactor : TFhirDecimal;
    FNet : TFhirMoney;
    FudiList : TFhirReferenceList;
    FBodySite : TFhirCodeableConcept;
    FsubSiteList : TFhirCodeableConceptList;
    FencounterList : TFhirReferenceList;
    FdetailList : TFhirClaimItemDetailList;
    procedure SetSequence(value : TFhirPositiveInt);
    function GetSequenceST : String;
    procedure SetSequenceST(value : String);
    function GetCareTeamSequenceList : TFhirPositiveIntList;
    function GetHasCareTeamSequenceList : Boolean;
    function GetDiagnosisSequenceList : TFhirPositiveIntList;
    function GetHasDiagnosisSequenceList : Boolean;
    function GetProcedureSequenceList : TFhirPositiveIntList;
    function GetHasProcedureSequenceList : Boolean;
    function GetInformationSequenceList : TFhirPositiveIntList;
    function GetHasInformationSequenceList : Boolean;
    procedure SetRevenue(value : TFhirCodeableConcept);
    procedure SetCategory(value : TFhirCodeableConcept);
    procedure SetProductOrService(value : TFhirCodeableConcept);
    function GetModifierList : TFhirCodeableConceptList;
    function GetHasModifierList : Boolean;
    function GetProgramCodeList : TFhirCodeableConceptList;
    function GetHasProgramCodeList : Boolean;
    procedure SetServiced(value : TFhirDataType);
    procedure SetLocation(value : TFhirDataType);
    procedure SetQuantity(value : TFhirQuantity);
    procedure SetUnitPrice(value : TFhirMoney);
    procedure SetFactor(value : TFhirDecimal);
    function GetFactorST : String;
    procedure SetFactorST(value : String);
    procedure SetNet(value : TFhirMoney);
    function GetUdiList : TFhirReferenceList;
    function GetHasUdiList : Boolean;
    procedure SetBodySite(value : TFhirCodeableConcept);
    function GetSubSiteList : TFhirCodeableConceptList;
    function GetHasSubSiteList : Boolean;
    function GetEncounterList : TFhirReferenceList;
    function GetHasEncounterList : Boolean;
    function GetDetailList : TFhirClaimItemDetailList;
    function GetHasDetailList : Boolean;
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirClaimItem; overload;
    function Clone : TFhirClaimItem; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to A number to uniquely identify item entries.
    property sequence : String read GetSequenceST write SetSequenceST;
    // A number to uniquely identify item entries.
    property sequenceElement : TFhirPositiveInt read FSequence write SetSequence;

    // CareTeam members related to this service or product.
    property careTeamSequenceList : TFhirPositiveIntList read GetCareTeamSequenceList;
    property hasCareTeamSequenceList : boolean read GetHasCareTeamSequenceList;

    // Diagnosis applicable for this service or product.
    property diagnosisSequenceList : TFhirPositiveIntList read GetDiagnosisSequenceList;
    property hasDiagnosisSequenceList : boolean read GetHasDiagnosisSequenceList;

    // Procedures applicable for this service or product.
    property procedureSequenceList : TFhirPositiveIntList read GetProcedureSequenceList;
    property hasProcedureSequenceList : boolean read GetHasProcedureSequenceList;

    // Exceptions, special conditions and supporting information applicable for this service or product.
    property informationSequenceList : TFhirPositiveIntList read GetInformationSequenceList;
    property hasInformationSequenceList : boolean read GetHasInformationSequenceList;

    // Typed access to The type of revenue or cost center providing the product and/or service. (defined for API consistency)
    property revenue : TFhirCodeableConcept read FRevenue write SetRevenue;
    // The type of revenue or cost center providing the product and/or service.
    property revenueElement : TFhirCodeableConcept read FRevenue write SetRevenue;

    // Typed access to Code to identify the general type of benefits under which products and services are provided. (defined for API consistency)
    property category : TFhirCodeableConcept read FCategory write SetCategory;
    // Code to identify the general type of benefits under which products and services are provided.
    property categoryElement : TFhirCodeableConcept read FCategory write SetCategory;

    // Typed access to When the value is a group code then this item collects a set of related claim details, otherwise this contains the product, service, drug or other billing code for the item. (defined for API consistency)
    property productOrService : TFhirCodeableConcept read FProductOrService write SetProductOrService;
    // When the value is a group code then this item collects a set of related claim details, otherwise this contains the product, service, drug or other billing code for the item.
    property productOrServiceElement : TFhirCodeableConcept read FProductOrService write SetProductOrService;

    // Item typification or modifiers codes to convey additional context for the product or service.
    property modifierList : TFhirCodeableConceptList read GetModifierList;
    property hasModifierList : boolean read GetHasModifierList;

    // Identifies the program under which this may be recovered.
    property programCodeList : TFhirCodeableConceptList read GetProgramCodeList;
    property hasProgramCodeList : boolean read GetHasProgramCodeList;

    // Typed access to The date or dates when the service or product was supplied, performed or completed. (defined for API consistency)
    property serviced : TFhirDataType read FServiced write SetServiced;
    // The date or dates when the service or product was supplied, performed or completed.
    property servicedElement : TFhirDataType read FServiced write SetServiced;

    // Typed access to Where the product or service was provided. (defined for API consistency)
    property location : TFhirDataType read FLocation write SetLocation;
    // Where the product or service was provided.
    property locationElement : TFhirDataType read FLocation write SetLocation;

    // Typed access to The number of repetitions of a service or product. (defined for API consistency)
    property quantity : TFhirQuantity read FQuantity write SetQuantity;
    // The number of repetitions of a service or product.
    property quantityElement : TFhirQuantity read FQuantity write SetQuantity;

    // Typed access to If the item is not a group then this is the fee for the product or service, otherwise this is the total of the fees for the details of the group. (defined for API consistency)
    property unitPrice : TFhirMoney read FUnitPrice write SetUnitPrice;
    // If the item is not a group then this is the fee for the product or service, otherwise this is the total of the fees for the details of the group.
    property unitPriceElement : TFhirMoney read FUnitPrice write SetUnitPrice;

    // Typed access to A real number that represents a multiplier used in determining the overall value of services delivered and/or goods received. The concept of a Factor allows for a discount or surcharge multiplier to be applied to a monetary amount.
    property factor : String read GetFactorST write SetFactorST;
    // A real number that represents a multiplier used in determining the overall value of services delivered and/or goods received. The concept of a Factor allows for a discount or surcharge multiplier to be applied to a monetary amount.
    property factorElement : TFhirDecimal read FFactor write SetFactor;

    // Typed access to The quantity times the unit price for an additional service or product or charge. (defined for API consistency)
    property net : TFhirMoney read FNet write SetNet;
    // The quantity times the unit price for an additional service or product or charge.
    property netElement : TFhirMoney read FNet write SetNet;

    // Unique Device Identifiers associated with this line item.
    property udiList : TFhirReferenceList read GetUdiList;
    property hasUdiList : boolean read GetHasUdiList;

    // Typed access to Physical service site on the patient (limb, tooth, etc.). (defined for API consistency)
    property bodySite : TFhirCodeableConcept read FBodySite write SetBodySite;
    // Physical service site on the patient (limb, tooth, etc.).
    property bodySiteElement : TFhirCodeableConcept read FBodySite write SetBodySite;

    // A region or surface of the bodySite, e.g. limb region or tooth surface(s).
    property subSiteList : TFhirCodeableConceptList read GetSubSiteList;
    property hasSubSiteList : boolean read GetHasSubSiteList;

    // The Encounters during which this Claim was created or to which the creation of this record is tightly associated.
    property encounterList : TFhirReferenceList read GetEncounterList;
    property hasEncounterList : boolean read GetHasEncounterList;

    // A claim detail line. Either a simple (a product or service) or a 'group' of sub-details which are simple items.
    property detailList : TFhirClaimItemDetailList read GetDetailList;
    property hasDetailList : boolean read GetHasDetailList;

  end;

  TFhirClaimItemListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirClaimItemList;
    function GetCurrent : TFhirClaimItem;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirClaimItemList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirClaimItem read GetCurrent;
  end;

  TFhirClaimItemList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirClaimItem;
    procedure SetItemN(index : Integer; value : TFhirClaimItem);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirClaimItemList; overload;
    function Clone : TFhirClaimItemList; overload;
    function GetEnumerator : TFhirClaimItemListEnumerator;
    
    //  Add a FhirClaimItem to the end of the list.
    function Append : TFhirClaimItem;
    
    // Add an already existing FhirClaimItem to the end of the list.
    procedure AddItem(value : TFhirClaimItem); overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirClaimItem) : Integer;
    
    // Insert FhirClaimItem before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirClaimItem;
    
    // Insert an existing FhirClaimItem before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirClaimItem);
    
    // Get the iIndexth FhirClaimItem. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirClaimItem);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirClaimItem;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirClaimItems[index : Integer] : TFhirClaimItem read GetItemN write SetItemN; default;
  End;

  // A claim detail line. Either a simple (a product or service) or a 'group' of sub-details which are simple items.
  TFhirClaimItemDetail = class (TFhirBackboneElement)
  protected
    FSequence : TFhirPositiveInt;
    FRevenue : TFhirCodeableConcept;
    FCategory : TFhirCodeableConcept;
    FProductOrService : TFhirCodeableConcept;
    FmodifierList : TFhirCodeableConceptList;
    FprogramCodeList : TFhirCodeableConceptList;
    FQuantity : TFhirQuantity;
    FUnitPrice : TFhirMoney;
    FFactor : TFhirDecimal;
    FNet : TFhirMoney;
    FudiList : TFhirReferenceList;
    FsubDetailList : TFhirClaimItemDetailSubDetailList;
    procedure SetSequence(value : TFhirPositiveInt);
    function GetSequenceST : String;
    procedure SetSequenceST(value : String);
    procedure SetRevenue(value : TFhirCodeableConcept);
    procedure SetCategory(value : TFhirCodeableConcept);
    procedure SetProductOrService(value : TFhirCodeableConcept);
    function GetModifierList : TFhirCodeableConceptList;
    function GetHasModifierList : Boolean;
    function GetProgramCodeList : TFhirCodeableConceptList;
    function GetHasProgramCodeList : Boolean;
    procedure SetQuantity(value : TFhirQuantity);
    procedure SetUnitPrice(value : TFhirMoney);
    procedure SetFactor(value : TFhirDecimal);
    function GetFactorST : String;
    procedure SetFactorST(value : String);
    procedure SetNet(value : TFhirMoney);
    function GetUdiList : TFhirReferenceList;
    function GetHasUdiList : Boolean;
    function GetSubDetailList : TFhirClaimItemDetailSubDetailList;
    function GetHasSubDetailList : Boolean;
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirClaimItemDetail; overload;
    function Clone : TFhirClaimItemDetail; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to A number to uniquely identify item entries.
    property sequence : String read GetSequenceST write SetSequenceST;
    // A number to uniquely identify item entries.
    property sequenceElement : TFhirPositiveInt read FSequence write SetSequence;

    // Typed access to The type of revenue or cost center providing the product and/or service. (defined for API consistency)
    property revenue : TFhirCodeableConcept read FRevenue write SetRevenue;
    // The type of revenue or cost center providing the product and/or service.
    property revenueElement : TFhirCodeableConcept read FRevenue write SetRevenue;

    // Typed access to Code to identify the general type of benefits under which products and services are provided. (defined for API consistency)
    property category : TFhirCodeableConcept read FCategory write SetCategory;
    // Code to identify the general type of benefits under which products and services are provided.
    property categoryElement : TFhirCodeableConcept read FCategory write SetCategory;

    // Typed access to When the value is a group code then this item collects a set of related claim details, otherwise this contains the product, service, drug or other billing code for the item. (defined for API consistency)
    property productOrService : TFhirCodeableConcept read FProductOrService write SetProductOrService;
    // When the value is a group code then this item collects a set of related claim details, otherwise this contains the product, service, drug or other billing code for the item.
    property productOrServiceElement : TFhirCodeableConcept read FProductOrService write SetProductOrService;

    // Item typification or modifiers codes to convey additional context for the product or service.
    property modifierList : TFhirCodeableConceptList read GetModifierList;
    property hasModifierList : boolean read GetHasModifierList;

    // Identifies the program under which this may be recovered.
    property programCodeList : TFhirCodeableConceptList read GetProgramCodeList;
    property hasProgramCodeList : boolean read GetHasProgramCodeList;

    // Typed access to The number of repetitions of a service or product. (defined for API consistency)
    property quantity : TFhirQuantity read FQuantity write SetQuantity;
    // The number of repetitions of a service or product.
    property quantityElement : TFhirQuantity read FQuantity write SetQuantity;

    // Typed access to If the item is not a group then this is the fee for the product or service, otherwise this is the total of the fees for the details of the group. (defined for API consistency)
    property unitPrice : TFhirMoney read FUnitPrice write SetUnitPrice;
    // If the item is not a group then this is the fee for the product or service, otherwise this is the total of the fees for the details of the group.
    property unitPriceElement : TFhirMoney read FUnitPrice write SetUnitPrice;

    // Typed access to A real number that represents a multiplier used in determining the overall value of services delivered and/or goods received. The concept of a Factor allows for a discount or surcharge multiplier to be applied to a monetary amount.
    property factor : String read GetFactorST write SetFactorST;
    // A real number that represents a multiplier used in determining the overall value of services delivered and/or goods received. The concept of a Factor allows for a discount or surcharge multiplier to be applied to a monetary amount.
    property factorElement : TFhirDecimal read FFactor write SetFactor;

    // Typed access to The quantity times the unit price for an additional service or product or charge. (defined for API consistency)
    property net : TFhirMoney read FNet write SetNet;
    // The quantity times the unit price for an additional service or product or charge.
    property netElement : TFhirMoney read FNet write SetNet;

    // Unique Device Identifiers associated with this line item.
    property udiList : TFhirReferenceList read GetUdiList;
    property hasUdiList : boolean read GetHasUdiList;

    // A claim detail line. Either a simple (a product or service) or a 'group' of sub-details which are simple items.
    property subDetailList : TFhirClaimItemDetailSubDetailList read GetSubDetailList;
    property hasSubDetailList : boolean read GetHasSubDetailList;

  end;

  TFhirClaimItemDetailListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirClaimItemDetailList;
    function GetCurrent : TFhirClaimItemDetail;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirClaimItemDetailList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirClaimItemDetail read GetCurrent;
  end;

  TFhirClaimItemDetailList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirClaimItemDetail;
    procedure SetItemN(index : Integer; value : TFhirClaimItemDetail);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirClaimItemDetailList; overload;
    function Clone : TFhirClaimItemDetailList; overload;
    function GetEnumerator : TFhirClaimItemDetailListEnumerator;
    
    //  Add a FhirClaimItemDetail to the end of the list.
    function Append : TFhirClaimItemDetail;
    
    // Add an already existing FhirClaimItemDetail to the end of the list.
    procedure AddItem(value : TFhirClaimItemDetail); overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirClaimItemDetail) : Integer;
    
    // Insert FhirClaimItemDetail before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirClaimItemDetail;
    
    // Insert an existing FhirClaimItemDetail before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirClaimItemDetail);
    
    // Get the iIndexth FhirClaimItemDetail. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirClaimItemDetail);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirClaimItemDetail;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirClaimItemDetails[index : Integer] : TFhirClaimItemDetail read GetItemN write SetItemN; default;
  End;

  // A claim detail line. Either a simple (a product or service) or a 'group' of sub-details which are simple items.
  TFhirClaimItemDetailSubDetail = class (TFhirBackboneElement)
  protected
    FSequence : TFhirPositiveInt;
    FRevenue : TFhirCodeableConcept;
    FCategory : TFhirCodeableConcept;
    FProductOrService : TFhirCodeableConcept;
    FmodifierList : TFhirCodeableConceptList;
    FprogramCodeList : TFhirCodeableConceptList;
    FQuantity : TFhirQuantity;
    FUnitPrice : TFhirMoney;
    FFactor : TFhirDecimal;
    FNet : TFhirMoney;
    FudiList : TFhirReferenceList;
    procedure SetSequence(value : TFhirPositiveInt);
    function GetSequenceST : String;
    procedure SetSequenceST(value : String);
    procedure SetRevenue(value : TFhirCodeableConcept);
    procedure SetCategory(value : TFhirCodeableConcept);
    procedure SetProductOrService(value : TFhirCodeableConcept);
    function GetModifierList : TFhirCodeableConceptList;
    function GetHasModifierList : Boolean;
    function GetProgramCodeList : TFhirCodeableConceptList;
    function GetHasProgramCodeList : Boolean;
    procedure SetQuantity(value : TFhirQuantity);
    procedure SetUnitPrice(value : TFhirMoney);
    procedure SetFactor(value : TFhirDecimal);
    function GetFactorST : String;
    procedure SetFactorST(value : String);
    procedure SetNet(value : TFhirMoney);
    function GetUdiList : TFhirReferenceList;
    function GetHasUdiList : Boolean;
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirClaimItemDetailSubDetail; overload;
    function Clone : TFhirClaimItemDetailSubDetail; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to A number to uniquely identify item entries.
    property sequence : String read GetSequenceST write SetSequenceST;
    // A number to uniquely identify item entries.
    property sequenceElement : TFhirPositiveInt read FSequence write SetSequence;

    // Typed access to The type of revenue or cost center providing the product and/or service. (defined for API consistency)
    property revenue : TFhirCodeableConcept read FRevenue write SetRevenue;
    // The type of revenue or cost center providing the product and/or service.
    property revenueElement : TFhirCodeableConcept read FRevenue write SetRevenue;

    // Typed access to Code to identify the general type of benefits under which products and services are provided. (defined for API consistency)
    property category : TFhirCodeableConcept read FCategory write SetCategory;
    // Code to identify the general type of benefits under which products and services are provided.
    property categoryElement : TFhirCodeableConcept read FCategory write SetCategory;

    // Typed access to When the value is a group code then this item collects a set of related claim details, otherwise this contains the product, service, drug or other billing code for the item. (defined for API consistency)
    property productOrService : TFhirCodeableConcept read FProductOrService write SetProductOrService;
    // When the value is a group code then this item collects a set of related claim details, otherwise this contains the product, service, drug or other billing code for the item.
    property productOrServiceElement : TFhirCodeableConcept read FProductOrService write SetProductOrService;

    // Item typification or modifiers codes to convey additional context for the product or service.
    property modifierList : TFhirCodeableConceptList read GetModifierList;
    property hasModifierList : boolean read GetHasModifierList;

    // Identifies the program under which this may be recovered.
    property programCodeList : TFhirCodeableConceptList read GetProgramCodeList;
    property hasProgramCodeList : boolean read GetHasProgramCodeList;

    // Typed access to The number of repetitions of a service or product. (defined for API consistency)
    property quantity : TFhirQuantity read FQuantity write SetQuantity;
    // The number of repetitions of a service or product.
    property quantityElement : TFhirQuantity read FQuantity write SetQuantity;

    // Typed access to If the item is not a group then this is the fee for the product or service, otherwise this is the total of the fees for the details of the group. (defined for API consistency)
    property unitPrice : TFhirMoney read FUnitPrice write SetUnitPrice;
    // If the item is not a group then this is the fee for the product or service, otherwise this is the total of the fees for the details of the group.
    property unitPriceElement : TFhirMoney read FUnitPrice write SetUnitPrice;

    // Typed access to A real number that represents a multiplier used in determining the overall value of services delivered and/or goods received. The concept of a Factor allows for a discount or surcharge multiplier to be applied to a monetary amount.
    property factor : String read GetFactorST write SetFactorST;
    // A real number that represents a multiplier used in determining the overall value of services delivered and/or goods received. The concept of a Factor allows for a discount or surcharge multiplier to be applied to a monetary amount.
    property factorElement : TFhirDecimal read FFactor write SetFactor;

    // Typed access to The quantity times the unit price for an additional service or product or charge. (defined for API consistency)
    property net : TFhirMoney read FNet write SetNet;
    // The quantity times the unit price for an additional service or product or charge.
    property netElement : TFhirMoney read FNet write SetNet;

    // Unique Device Identifiers associated with this line item.
    property udiList : TFhirReferenceList read GetUdiList;
    property hasUdiList : boolean read GetHasUdiList;

  end;

  TFhirClaimItemDetailSubDetailListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirClaimItemDetailSubDetailList;
    function GetCurrent : TFhirClaimItemDetailSubDetail;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirClaimItemDetailSubDetailList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirClaimItemDetailSubDetail read GetCurrent;
  end;

  TFhirClaimItemDetailSubDetailList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirClaimItemDetailSubDetail;
    procedure SetItemN(index : Integer; value : TFhirClaimItemDetailSubDetail);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirClaimItemDetailSubDetailList; overload;
    function Clone : TFhirClaimItemDetailSubDetailList; overload;
    function GetEnumerator : TFhirClaimItemDetailSubDetailListEnumerator;
    
    //  Add a FhirClaimItemDetailSubDetail to the end of the list.
    function Append : TFhirClaimItemDetailSubDetail;
    
    // Add an already existing FhirClaimItemDetailSubDetail to the end of the list.
    procedure AddItem(value : TFhirClaimItemDetailSubDetail); overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirClaimItemDetailSubDetail) : Integer;
    
    // Insert FhirClaimItemDetailSubDetail before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirClaimItemDetailSubDetail;
    
    // Insert an existing FhirClaimItemDetailSubDetail before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirClaimItemDetailSubDetail);
    
    // Get the iIndexth FhirClaimItemDetailSubDetail. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirClaimItemDetailSubDetail);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirClaimItemDetailSubDetail;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirClaimItemDetailSubDetails[index : Integer] : TFhirClaimItemDetailSubDetail read GetItemN write SetItemN; default;
  End;

  // A provider issued list of professional services and products which have been provided, or are to be provided, to a patient which is sent to an insurer for reimbursement.
  TFhirClaim = class (TFhirDomainResource)
  protected
    FidentifierList : TFhirIdentifierList;
    FStatus : TFhirEnum;
    FType_ : TFhirCodeableConcept;
    FSubType : TFhirCodeableConcept;
    FUse : TFhirEnum;
    FPatient : TFhirReference;
    FBillablePeriod : TFhirPeriod;
    FCreated : TFhirDateTime;
    FEnterer : TFhirReference;
    FInsurer : TFhirReference;
    FProvider : TFhirReference;
    FPriority : TFhirCodeableConcept;
    FFundsReserve : TFhirCodeableConcept;
    FrelatedList : TFhirClaimRelatedList;
    FPrescription : TFhirReference;
    FOriginalPrescription : TFhirReference;
    FPayee : TFhirClaimPayee;
    FReferral : TFhirReference;
    FFacility : TFhirReference;
    FcareTeamList : TFhirClaimCareTeamList;
    FsupportingInfoList : TFhirClaimSupportingInfoList;
    FdiagnosisList : TFhirClaimDiagnosisList;
    Fprocedure_List : TFhirClaimProcedureList;
    FinsuranceList : TFhirClaimInsuranceList;
    FAccident : TFhirClaimAccident;
    FitemList : TFhirClaimItemList;
    FTotal : TFhirMoney;
    function GetIdentifierList : TFhirIdentifierList;
    function GetHasIdentifierList : Boolean;
    procedure SetStatus(value : TFhirEnum);
    function GetStatusST : TFhirFinancialResourceStatusCodesEnum;
    procedure SetStatusST(value : TFhirFinancialResourceStatusCodesEnum);
    procedure SetType_(value : TFhirCodeableConcept);
    procedure SetSubType(value : TFhirCodeableConcept);
    procedure SetUse(value : TFhirEnum);
    function GetUseST : TFhirUseEnum;
    procedure SetUseST(value : TFhirUseEnum);
    procedure SetPatient(value : TFhirReference);
    procedure SetBillablePeriod(value : TFhirPeriod);
    procedure SetCreated(value : TFhirDateTime);
    function GetCreatedST : TFslDateTime;
    procedure SetCreatedST(value : TFslDateTime);
    procedure SetEnterer(value : TFhirReference);
    procedure SetInsurer(value : TFhirReference);
    procedure SetProvider(value : TFhirReference);
    procedure SetPriority(value : TFhirCodeableConcept);
    procedure SetFundsReserve(value : TFhirCodeableConcept);
    function GetRelatedList : TFhirClaimRelatedList;
    function GetHasRelatedList : Boolean;
    procedure SetPrescription(value : TFhirReference);
    procedure SetOriginalPrescription(value : TFhirReference);
    procedure SetPayee(value : TFhirClaimPayee);
    procedure SetReferral(value : TFhirReference);
    procedure SetFacility(value : TFhirReference);
    function GetCareTeamList : TFhirClaimCareTeamList;
    function GetHasCareTeamList : Boolean;
    function GetSupportingInfoList : TFhirClaimSupportingInfoList;
    function GetHasSupportingInfoList : Boolean;
    function GetDiagnosisList : TFhirClaimDiagnosisList;
    function GetHasDiagnosisList : Boolean;
    function GetProcedure_List : TFhirClaimProcedureList;
    function GetHasProcedure_List : Boolean;
    function GetInsuranceList : TFhirClaimInsuranceList;
    function GetHasInsuranceList : Boolean;
    procedure SetAccident(value : TFhirClaimAccident);
    function GetItemList : TFhirClaimItemList;
    function GetHasItemList : Boolean;
    procedure SetTotal(value : TFhirMoney);
  
    function GetResourceType : TFhirResourceType; override;
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirClaim; overload;
    function Clone : TFhirClaim; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // A unique identifier assigned to this claim.
    property identifierList : TFhirIdentifierList read GetIdentifierList;
    property hasIdentifierList : boolean read GetHasIdentifierList;

    // The status of the resource instance.
    property status : TFhirFinancialResourceStatusCodesEnum read GetStatusST write SetStatusST;
    property statusElement : TFhirEnum read FStatus write SetStatus;

    // Typed access to The category of claim, e.g. oral, pharmacy, vision, institutional, professional. (defined for API consistency)
    property type_ : TFhirCodeableConcept read FType_ write SetType_;
    // The category of claim, e.g. oral, pharmacy, vision, institutional, professional.
    property type_Element : TFhirCodeableConcept read FType_ write SetType_;

    // Typed access to A finer grained suite of claim type codes which may convey additional information such as Inpatient vs Outpatient and/or a specialty service. (defined for API consistency)
    property subType : TFhirCodeableConcept read FSubType write SetSubType;
    // A finer grained suite of claim type codes which may convey additional information such as Inpatient vs Outpatient and/or a specialty service.
    property subTypeElement : TFhirCodeableConcept read FSubType write SetSubType;

    // A code to indicate whether the nature of the request is: to request adjudication of products and services previously rendered; or requesting authorization and adjudication for provision in the future; or requesting the non-binding adjudication of the listed products and services which could be provided in the future.
    property use : TFhirUseEnum read GetUseST write SetUseST;
    property useElement : TFhirEnum read FUse write SetUse;

    // Typed access to The party to whom the professional services and/or products have been supplied or are being considered and for whom actual or forecast reimbursement is sought. (defined for API consistency)
    property patient : TFhirReference read FPatient write SetPatient;
    // The party to whom the professional services and/or products have been supplied or are being considered and for whom actual or forecast reimbursement is sought.
    property patientElement : TFhirReference read FPatient write SetPatient;

    // Typed access to The period for which charges are being submitted. (defined for API consistency)
    property billablePeriod : TFhirPeriod read FBillablePeriod write SetBillablePeriod;
    // The period for which charges are being submitted.
    property billablePeriodElement : TFhirPeriod read FBillablePeriod write SetBillablePeriod;

    // Typed access to The date this resource was created.
    property created : TFslDateTime read GetCreatedST write SetCreatedST;
    // The date this resource was created.
    property createdElement : TFhirDateTime read FCreated write SetCreated;

    // Typed access to Individual who created the claim, predetermination or preauthorization. (defined for API consistency)
    property enterer : TFhirReference read FEnterer write SetEnterer;
    // Individual who created the claim, predetermination or preauthorization.
    property entererElement : TFhirReference read FEnterer write SetEnterer;

    // Typed access to The Insurer who is target of the request. (defined for API consistency)
    property insurer : TFhirReference read FInsurer write SetInsurer;
    // The Insurer who is target of the request.
    property insurerElement : TFhirReference read FInsurer write SetInsurer;

    // Typed access to The provider which is responsible for the claim, predetermination or preauthorization. (defined for API consistency)
    property provider : TFhirReference read FProvider write SetProvider;
    // The provider which is responsible for the claim, predetermination or preauthorization.
    property providerElement : TFhirReference read FProvider write SetProvider;

    // Typed access to The provider-required urgency of processing the request. Typical values include: stat, routine deferred. (defined for API consistency)
    property priority : TFhirCodeableConcept read FPriority write SetPriority;
    // The provider-required urgency of processing the request. Typical values include: stat, routine deferred.
    property priorityElement : TFhirCodeableConcept read FPriority write SetPriority;

    // Typed access to A code to indicate whether and for whom funds are to be reserved for future claims. (defined for API consistency)
    property fundsReserve : TFhirCodeableConcept read FFundsReserve write SetFundsReserve;
    // A code to indicate whether and for whom funds are to be reserved for future claims.
    property fundsReserveElement : TFhirCodeableConcept read FFundsReserve write SetFundsReserve;

    // Other claims which are related to this claim such as prior submissions or claims for related services or for the same event.
    property relatedList : TFhirClaimRelatedList read GetRelatedList;
    property hasRelatedList : boolean read GetHasRelatedList;

    // Typed access to Prescription to support the dispensing of pharmacy, device or vision products. (defined for API consistency)
    property prescription : TFhirReference read FPrescription write SetPrescription;
    // Prescription to support the dispensing of pharmacy, device or vision products.
    property prescriptionElement : TFhirReference read FPrescription write SetPrescription;

    // Typed access to Original prescription which has been superseded by this prescription to support the dispensing of pharmacy services, medications or products. (defined for API consistency)
    property originalPrescription : TFhirReference read FOriginalPrescription write SetOriginalPrescription;
    // Original prescription which has been superseded by this prescription to support the dispensing of pharmacy services, medications or products.
    property originalPrescriptionElement : TFhirReference read FOriginalPrescription write SetOriginalPrescription;

    // Typed access to The party to be reimbursed for cost of the products and services according to the terms of the policy. (defined for API consistency)
    property payee : TFhirClaimPayee read FPayee write SetPayee;
    // The party to be reimbursed for cost of the products and services according to the terms of the policy.
    property payeeElement : TFhirClaimPayee read FPayee write SetPayee;

    // Typed access to A reference to a referral resource. (defined for API consistency)
    property referral : TFhirReference read FReferral write SetReferral;
    // A reference to a referral resource.
    property referralElement : TFhirReference read FReferral write SetReferral;

    // Typed access to Facility where the services were provided. (defined for API consistency)
    property facility : TFhirReference read FFacility write SetFacility;
    // Facility where the services were provided.
    property facilityElement : TFhirReference read FFacility write SetFacility;

    // The members of the team who provided the products and services.
    property careTeamList : TFhirClaimCareTeamList read GetCareTeamList;
    property hasCareTeamList : boolean read GetHasCareTeamList;

    // Additional information codes regarding exceptions, special considerations, the condition, situation, prior or concurrent issues.
    property supportingInfoList : TFhirClaimSupportingInfoList read GetSupportingInfoList;
    property hasSupportingInfoList : boolean read GetHasSupportingInfoList;

    // Information about diagnoses relevant to the claim items.
    property diagnosisList : TFhirClaimDiagnosisList read GetDiagnosisList;
    property hasDiagnosisList : boolean read GetHasDiagnosisList;

    // Procedures performed on the patient relevant to the billing items with the claim.
    property procedure_List : TFhirClaimProcedureList read GetProcedure_List;
    property hasProcedure_List : boolean read GetHasProcedure_List;

    // Financial instruments for reimbursement for the health care products and services specified on the claim.
    property insuranceList : TFhirClaimInsuranceList read GetInsuranceList;
    property hasInsuranceList : boolean read GetHasInsuranceList;

    // Typed access to Details of an accident which resulted in injuries which required the products and services listed in the claim. (defined for API consistency)
    property accident : TFhirClaimAccident read FAccident write SetAccident;
    // Details of an accident which resulted in injuries which required the products and services listed in the claim.
    property accidentElement : TFhirClaimAccident read FAccident write SetAccident;

    // A claim line. Either a simple  product or service or a 'group' of details which can each be a simple items or groups of sub-details.
    property itemList : TFhirClaimItemList read GetItemList;
    property hasItemList : boolean read GetHasItemList;

    // Typed access to The total value of the all the items in the claim. (defined for API consistency)
    property total : TFhirMoney read FTotal write SetTotal;
    // The total value of the all the items in the claim.
    property totalElement : TFhirMoney read FTotal write SetTotal;

  end;

  TFhirClaimListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirClaimList;
    function GetCurrent : TFhirClaim;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirClaimList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirClaim read GetCurrent;
  end;

  TFhirClaimList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirClaim;
    procedure SetItemN(index : Integer; value : TFhirClaim);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirClaimList; overload;
    function Clone : TFhirClaimList; overload;
    function GetEnumerator : TFhirClaimListEnumerator;
    
    //  Add a FhirClaim to the end of the list.
    function Append : TFhirClaim;
    
    // Add an already existing FhirClaim to the end of the list.
    procedure AddItem(value : TFhirClaim); overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirClaim) : Integer;
    
    // Insert FhirClaim before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirClaim;
    
    // Insert an existing FhirClaim before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirClaim);
    
    // Get the iIndexth FhirClaim. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirClaim);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirClaim;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirClaims[index : Integer] : TFhirClaim read GetItemN write SetItemN; default;
  End;

{$ENDIF FHIR_CLAIM}
{$IFDEF FHIR_CLAIMRESPONSE}
  // A claim line. Either a simple (a product or service) or a 'group' of details which can also be a simple items or groups of sub-details.
  TFhirClaimResponseItem = class (TFhirBackboneElement)
  protected
    FItemSequence : TFhirPositiveInt;
    FnoteNumberList : TFhirPositiveIntList;
    FadjudicationList : TFhirClaimResponseItemAdjudicationList;
    FdetailList : TFhirClaimResponseItemDetailList;
    procedure SetItemSequence(value : TFhirPositiveInt);
    function GetItemSequenceST : String;
    procedure SetItemSequenceST(value : String);
    function GetNoteNumberList : TFhirPositiveIntList;
    function GetHasNoteNumberList : Boolean;
    function GetAdjudicationList : TFhirClaimResponseItemAdjudicationList;
    function GetHasAdjudicationList : Boolean;
    function GetDetailList : TFhirClaimResponseItemDetailList;
    function GetHasDetailList : Boolean;
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirClaimResponseItem; overload;
    function Clone : TFhirClaimResponseItem; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to A number to uniquely reference the claim item entries.
    property itemSequence : String read GetItemSequenceST write SetItemSequenceST;
    // A number to uniquely reference the claim item entries.
    property itemSequenceElement : TFhirPositiveInt read FItemSequence write SetItemSequence;

    // The numbers associated with notes below which apply to the adjudication of this item.
    property noteNumberList : TFhirPositiveIntList read GetNoteNumberList;
    property hasNoteNumberList : boolean read GetHasNoteNumberList;

    // If this item is a group then the values here are a summary of the adjudication of the detail items. If this item is a simple product or service then this is the result of the adjudication of this item.
    property adjudicationList : TFhirClaimResponseItemAdjudicationList read GetAdjudicationList;
    property hasAdjudicationList : boolean read GetHasAdjudicationList;

    // A claim detail. Either a simple (a product or service) or a 'group' of sub-details which are simple items.
    property detailList : TFhirClaimResponseItemDetailList read GetDetailList;
    property hasDetailList : boolean read GetHasDetailList;

  end;

  TFhirClaimResponseItemListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirClaimResponseItemList;
    function GetCurrent : TFhirClaimResponseItem;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirClaimResponseItemList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirClaimResponseItem read GetCurrent;
  end;

  TFhirClaimResponseItemList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirClaimResponseItem;
    procedure SetItemN(index : Integer; value : TFhirClaimResponseItem);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirClaimResponseItemList; overload;
    function Clone : TFhirClaimResponseItemList; overload;
    function GetEnumerator : TFhirClaimResponseItemListEnumerator;
    
    //  Add a FhirClaimResponseItem to the end of the list.
    function Append : TFhirClaimResponseItem;
    
    // Add an already existing FhirClaimResponseItem to the end of the list.
    procedure AddItem(value : TFhirClaimResponseItem); overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirClaimResponseItem) : Integer;
    
    // Insert FhirClaimResponseItem before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirClaimResponseItem;
    
    // Insert an existing FhirClaimResponseItem before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirClaimResponseItem);
    
    // Get the iIndexth FhirClaimResponseItem. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirClaimResponseItem);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirClaimResponseItem;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirClaimResponseItems[index : Integer] : TFhirClaimResponseItem read GetItemN write SetItemN; default;
  End;

  // If this item is a group then the values here are a summary of the adjudication of the detail items. If this item is a simple product or service then this is the result of the adjudication of this item.
  TFhirClaimResponseItemAdjudication = class (TFhirBackboneElement)
  protected
    FCategory : TFhirCodeableConcept;
    FReason : TFhirCodeableConcept;
    FAmount : TFhirMoney;
    FValue : TFhirDecimal;
    procedure SetCategory(value : TFhirCodeableConcept);
    procedure SetReason(value : TFhirCodeableConcept);
    procedure SetAmount(value : TFhirMoney);
    procedure SetValue(value : TFhirDecimal);
    function GetValueST : String;
    procedure SetValueST(value : String);
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirClaimResponseItemAdjudication; overload;
    function Clone : TFhirClaimResponseItemAdjudication; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to A code to indicate the information type of this adjudication record. Information types may include the value submitted, maximum values or percentages allowed or payable under the plan, amounts that: the patient is responsible for in aggregate or pertaining to this item; amounts paid by other coverages; and, the benefit payable for this item. (defined for API consistency)
    property category : TFhirCodeableConcept read FCategory write SetCategory;
    // A code to indicate the information type of this adjudication record. Information types may include the value submitted, maximum values or percentages allowed or payable under the plan, amounts that: the patient is responsible for in aggregate or pertaining to this item; amounts paid by other coverages; and, the benefit payable for this item.
    property categoryElement : TFhirCodeableConcept read FCategory write SetCategory;

    // Typed access to A code supporting the understanding of the adjudication result and explaining variance from expected amount. (defined for API consistency)
    property reason : TFhirCodeableConcept read FReason write SetReason;
    // A code supporting the understanding of the adjudication result and explaining variance from expected amount.
    property reasonElement : TFhirCodeableConcept read FReason write SetReason;

    // Typed access to Monetary amount associated with the category. (defined for API consistency)
    property amount : TFhirMoney read FAmount write SetAmount;
    // Monetary amount associated with the category.
    property amountElement : TFhirMoney read FAmount write SetAmount;

    // Typed access to A non-monetary value associated with the category. Mutually exclusive to the amount element above.
    property value : String read GetValueST write SetValueST;
    // A non-monetary value associated with the category. Mutually exclusive to the amount element above.
    property valueElement : TFhirDecimal read FValue write SetValue;

  end;

  TFhirClaimResponseItemAdjudicationListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirClaimResponseItemAdjudicationList;
    function GetCurrent : TFhirClaimResponseItemAdjudication;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirClaimResponseItemAdjudicationList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirClaimResponseItemAdjudication read GetCurrent;
  end;

  TFhirClaimResponseItemAdjudicationList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirClaimResponseItemAdjudication;
    procedure SetItemN(index : Integer; value : TFhirClaimResponseItemAdjudication);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirClaimResponseItemAdjudicationList; overload;
    function Clone : TFhirClaimResponseItemAdjudicationList; overload;
    function GetEnumerator : TFhirClaimResponseItemAdjudicationListEnumerator;
    
    //  Add a FhirClaimResponseItemAdjudication to the end of the list.
    function Append : TFhirClaimResponseItemAdjudication;
    
    // Add an already existing FhirClaimResponseItemAdjudication to the end of the list.
    procedure AddItem(value : TFhirClaimResponseItemAdjudication); overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirClaimResponseItemAdjudication) : Integer;
    
    // Insert FhirClaimResponseItemAdjudication before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirClaimResponseItemAdjudication;
    
    // Insert an existing FhirClaimResponseItemAdjudication before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirClaimResponseItemAdjudication);
    
    // Get the iIndexth FhirClaimResponseItemAdjudication. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirClaimResponseItemAdjudication);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirClaimResponseItemAdjudication;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirClaimResponseItemAdjudications[index : Integer] : TFhirClaimResponseItemAdjudication read GetItemN write SetItemN; default;
  End;

  // A claim detail. Either a simple (a product or service) or a 'group' of sub-details which are simple items.
  TFhirClaimResponseItemDetail = class (TFhirBackboneElement)
  protected
    FDetailSequence : TFhirPositiveInt;
    FnoteNumberList : TFhirPositiveIntList;
    FadjudicationList : TFhirClaimResponseItemAdjudicationList;
    FsubDetailList : TFhirClaimResponseItemDetailSubDetailList;
    procedure SetDetailSequence(value : TFhirPositiveInt);
    function GetDetailSequenceST : String;
    procedure SetDetailSequenceST(value : String);
    function GetNoteNumberList : TFhirPositiveIntList;
    function GetHasNoteNumberList : Boolean;
    function GetAdjudicationList : TFhirClaimResponseItemAdjudicationList;
    function GetHasAdjudicationList : Boolean;
    function GetSubDetailList : TFhirClaimResponseItemDetailSubDetailList;
    function GetHasSubDetailList : Boolean;
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirClaimResponseItemDetail; overload;
    function Clone : TFhirClaimResponseItemDetail; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to A number to uniquely reference the claim detail entry.
    property detailSequence : String read GetDetailSequenceST write SetDetailSequenceST;
    // A number to uniquely reference the claim detail entry.
    property detailSequenceElement : TFhirPositiveInt read FDetailSequence write SetDetailSequence;

    // The numbers associated with notes below which apply to the adjudication of this item.
    property noteNumberList : TFhirPositiveIntList read GetNoteNumberList;
    property hasNoteNumberList : boolean read GetHasNoteNumberList;

    // The adjudication results.
    property adjudicationList : TFhirClaimResponseItemAdjudicationList read GetAdjudicationList;
    property hasAdjudicationList : boolean read GetHasAdjudicationList;

    // A sub-detail adjudication of a simple product or service.
    property subDetailList : TFhirClaimResponseItemDetailSubDetailList read GetSubDetailList;
    property hasSubDetailList : boolean read GetHasSubDetailList;

  end;

  TFhirClaimResponseItemDetailListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirClaimResponseItemDetailList;
    function GetCurrent : TFhirClaimResponseItemDetail;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirClaimResponseItemDetailList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirClaimResponseItemDetail read GetCurrent;
  end;

  TFhirClaimResponseItemDetailList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirClaimResponseItemDetail;
    procedure SetItemN(index : Integer; value : TFhirClaimResponseItemDetail);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirClaimResponseItemDetailList; overload;
    function Clone : TFhirClaimResponseItemDetailList; overload;
    function GetEnumerator : TFhirClaimResponseItemDetailListEnumerator;
    
    //  Add a FhirClaimResponseItemDetail to the end of the list.
    function Append : TFhirClaimResponseItemDetail;
    
    // Add an already existing FhirClaimResponseItemDetail to the end of the list.
    procedure AddItem(value : TFhirClaimResponseItemDetail); overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirClaimResponseItemDetail) : Integer;
    
    // Insert FhirClaimResponseItemDetail before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirClaimResponseItemDetail;
    
    // Insert an existing FhirClaimResponseItemDetail before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirClaimResponseItemDetail);
    
    // Get the iIndexth FhirClaimResponseItemDetail. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirClaimResponseItemDetail);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirClaimResponseItemDetail;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirClaimResponseItemDetails[index : Integer] : TFhirClaimResponseItemDetail read GetItemN write SetItemN; default;
  End;

  // A sub-detail adjudication of a simple product or service.
  TFhirClaimResponseItemDetailSubDetail = class (TFhirBackboneElement)
  protected
    FSubDetailSequence : TFhirPositiveInt;
    FnoteNumberList : TFhirPositiveIntList;
    FadjudicationList : TFhirClaimResponseItemAdjudicationList;
    procedure SetSubDetailSequence(value : TFhirPositiveInt);
    function GetSubDetailSequenceST : String;
    procedure SetSubDetailSequenceST(value : String);
    function GetNoteNumberList : TFhirPositiveIntList;
    function GetHasNoteNumberList : Boolean;
    function GetAdjudicationList : TFhirClaimResponseItemAdjudicationList;
    function GetHasAdjudicationList : Boolean;
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirClaimResponseItemDetailSubDetail; overload;
    function Clone : TFhirClaimResponseItemDetailSubDetail; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to A number to uniquely reference the claim sub-detail entry.
    property subDetailSequence : String read GetSubDetailSequenceST write SetSubDetailSequenceST;
    // A number to uniquely reference the claim sub-detail entry.
    property subDetailSequenceElement : TFhirPositiveInt read FSubDetailSequence write SetSubDetailSequence;

    // The numbers associated with notes below which apply to the adjudication of this item.
    property noteNumberList : TFhirPositiveIntList read GetNoteNumberList;
    property hasNoteNumberList : boolean read GetHasNoteNumberList;

    // The adjudication results.
    property adjudicationList : TFhirClaimResponseItemAdjudicationList read GetAdjudicationList;
    property hasAdjudicationList : boolean read GetHasAdjudicationList;

  end;

  TFhirClaimResponseItemDetailSubDetailListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirClaimResponseItemDetailSubDetailList;
    function GetCurrent : TFhirClaimResponseItemDetailSubDetail;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirClaimResponseItemDetailSubDetailList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirClaimResponseItemDetailSubDetail read GetCurrent;
  end;

  TFhirClaimResponseItemDetailSubDetailList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirClaimResponseItemDetailSubDetail;
    procedure SetItemN(index : Integer; value : TFhirClaimResponseItemDetailSubDetail);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirClaimResponseItemDetailSubDetailList; overload;
    function Clone : TFhirClaimResponseItemDetailSubDetailList; overload;
    function GetEnumerator : TFhirClaimResponseItemDetailSubDetailListEnumerator;
    
    //  Add a FhirClaimResponseItemDetailSubDetail to the end of the list.
    function Append : TFhirClaimResponseItemDetailSubDetail;
    
    // Add an already existing FhirClaimResponseItemDetailSubDetail to the end of the list.
    procedure AddItem(value : TFhirClaimResponseItemDetailSubDetail); overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirClaimResponseItemDetailSubDetail) : Integer;
    
    // Insert FhirClaimResponseItemDetailSubDetail before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirClaimResponseItemDetailSubDetail;
    
    // Insert an existing FhirClaimResponseItemDetailSubDetail before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirClaimResponseItemDetailSubDetail);
    
    // Get the iIndexth FhirClaimResponseItemDetailSubDetail. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirClaimResponseItemDetailSubDetail);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirClaimResponseItemDetailSubDetail;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirClaimResponseItemDetailSubDetails[index : Integer] : TFhirClaimResponseItemDetailSubDetail read GetItemN write SetItemN; default;
  End;

  // The first-tier service adjudications for payor added product or service lines.
  TFhirClaimResponseAddItem = class (TFhirBackboneElement)
  protected
    FitemSequenceList : TFhirPositiveIntList;
    FdetailSequenceList : TFhirPositiveIntList;
    FsubdetailSequenceList : TFhirPositiveIntList;
    FproviderList : TFhirReferenceList;
    FProductOrService : TFhirCodeableConcept;
    FmodifierList : TFhirCodeableConceptList;
    FprogramCodeList : TFhirCodeableConceptList;
    FServiced : TFhirDataType;
    FLocation : TFhirDataType;
    FQuantity : TFhirQuantity;
    FUnitPrice : TFhirMoney;
    FFactor : TFhirDecimal;
    FNet : TFhirMoney;
    FBodySite : TFhirCodeableConcept;
    FsubSiteList : TFhirCodeableConceptList;
    FnoteNumberList : TFhirPositiveIntList;
    FadjudicationList : TFhirClaimResponseItemAdjudicationList;
    FdetailList : TFhirClaimResponseAddItemDetailList;
    function GetItemSequenceList : TFhirPositiveIntList;
    function GetHasItemSequenceList : Boolean;
    function GetDetailSequenceList : TFhirPositiveIntList;
    function GetHasDetailSequenceList : Boolean;
    function GetSubdetailSequenceList : TFhirPositiveIntList;
    function GetHasSubdetailSequenceList : Boolean;
    function GetProviderList : TFhirReferenceList;
    function GetHasProviderList : Boolean;
    procedure SetProductOrService(value : TFhirCodeableConcept);
    function GetModifierList : TFhirCodeableConceptList;
    function GetHasModifierList : Boolean;
    function GetProgramCodeList : TFhirCodeableConceptList;
    function GetHasProgramCodeList : Boolean;
    procedure SetServiced(value : TFhirDataType);
    procedure SetLocation(value : TFhirDataType);
    procedure SetQuantity(value : TFhirQuantity);
    procedure SetUnitPrice(value : TFhirMoney);
    procedure SetFactor(value : TFhirDecimal);
    function GetFactorST : String;
    procedure SetFactorST(value : String);
    procedure SetNet(value : TFhirMoney);
    procedure SetBodySite(value : TFhirCodeableConcept);
    function GetSubSiteList : TFhirCodeableConceptList;
    function GetHasSubSiteList : Boolean;
    function GetNoteNumberList : TFhirPositiveIntList;
    function GetHasNoteNumberList : Boolean;
    function GetAdjudicationList : TFhirClaimResponseItemAdjudicationList;
    function GetHasAdjudicationList : Boolean;
    function GetDetailList : TFhirClaimResponseAddItemDetailList;
    function GetHasDetailList : Boolean;
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirClaimResponseAddItem; overload;
    function Clone : TFhirClaimResponseAddItem; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Claim items which this service line is intended to replace.
    property itemSequenceList : TFhirPositiveIntList read GetItemSequenceList;
    property hasItemSequenceList : boolean read GetHasItemSequenceList;

    // The sequence number of the details within the claim item which this line is intended to replace.
    property detailSequenceList : TFhirPositiveIntList read GetDetailSequenceList;
    property hasDetailSequenceList : boolean read GetHasDetailSequenceList;

    // The sequence number of the sub-details within the details within the claim item which this line is intended to replace.
    property subdetailSequenceList : TFhirPositiveIntList read GetSubdetailSequenceList;
    property hasSubdetailSequenceList : boolean read GetHasSubdetailSequenceList;

    // The providers who are authorized for the services rendered to the patient.
    property providerList : TFhirReferenceList read GetProviderList;
    property hasProviderList : boolean read GetHasProviderList;

    // Typed access to When the value is a group code then this item collects a set of related claim details, otherwise this contains the product, service, drug or other billing code for the item. (defined for API consistency)
    property productOrService : TFhirCodeableConcept read FProductOrService write SetProductOrService;
    // When the value is a group code then this item collects a set of related claim details, otherwise this contains the product, service, drug or other billing code for the item.
    property productOrServiceElement : TFhirCodeableConcept read FProductOrService write SetProductOrService;

    // Item typification or modifiers codes to convey additional context for the product or service.
    property modifierList : TFhirCodeableConceptList read GetModifierList;
    property hasModifierList : boolean read GetHasModifierList;

    // Identifies the program under which this may be recovered.
    property programCodeList : TFhirCodeableConceptList read GetProgramCodeList;
    property hasProgramCodeList : boolean read GetHasProgramCodeList;

    // Typed access to The date or dates when the service or product was supplied, performed or completed. (defined for API consistency)
    property serviced : TFhirDataType read FServiced write SetServiced;
    // The date or dates when the service or product was supplied, performed or completed.
    property servicedElement : TFhirDataType read FServiced write SetServiced;

    // Typed access to Where the product or service was provided. (defined for API consistency)
    property location : TFhirDataType read FLocation write SetLocation;
    // Where the product or service was provided.
    property locationElement : TFhirDataType read FLocation write SetLocation;

    // Typed access to The number of repetitions of a service or product. (defined for API consistency)
    property quantity : TFhirQuantity read FQuantity write SetQuantity;
    // The number of repetitions of a service or product.
    property quantityElement : TFhirQuantity read FQuantity write SetQuantity;

    // Typed access to If the item is not a group then this is the fee for the product or service, otherwise this is the total of the fees for the details of the group. (defined for API consistency)
    property unitPrice : TFhirMoney read FUnitPrice write SetUnitPrice;
    // If the item is not a group then this is the fee for the product or service, otherwise this is the total of the fees for the details of the group.
    property unitPriceElement : TFhirMoney read FUnitPrice write SetUnitPrice;

    // Typed access to A real number that represents a multiplier used in determining the overall value of services delivered and/or goods received. The concept of a Factor allows for a discount or surcharge multiplier to be applied to a monetary amount.
    property factor : String read GetFactorST write SetFactorST;
    // A real number that represents a multiplier used in determining the overall value of services delivered and/or goods received. The concept of a Factor allows for a discount or surcharge multiplier to be applied to a monetary amount.
    property factorElement : TFhirDecimal read FFactor write SetFactor;

    // Typed access to The quantity times the unit price for an additional service or product or charge. (defined for API consistency)
    property net : TFhirMoney read FNet write SetNet;
    // The quantity times the unit price for an additional service or product or charge.
    property netElement : TFhirMoney read FNet write SetNet;

    // Typed access to Physical service site on the patient (limb, tooth, etc.). (defined for API consistency)
    property bodySite : TFhirCodeableConcept read FBodySite write SetBodySite;
    // Physical service site on the patient (limb, tooth, etc.).
    property bodySiteElement : TFhirCodeableConcept read FBodySite write SetBodySite;

    // A region or surface of the bodySite, e.g. limb region or tooth surface(s).
    property subSiteList : TFhirCodeableConceptList read GetSubSiteList;
    property hasSubSiteList : boolean read GetHasSubSiteList;

    // The numbers associated with notes below which apply to the adjudication of this item.
    property noteNumberList : TFhirPositiveIntList read GetNoteNumberList;
    property hasNoteNumberList : boolean read GetHasNoteNumberList;

    // The adjudication results.
    property adjudicationList : TFhirClaimResponseItemAdjudicationList read GetAdjudicationList;
    property hasAdjudicationList : boolean read GetHasAdjudicationList;

    // The second-tier service adjudications for payor added services.
    property detailList : TFhirClaimResponseAddItemDetailList read GetDetailList;
    property hasDetailList : boolean read GetHasDetailList;

  end;

  TFhirClaimResponseAddItemListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirClaimResponseAddItemList;
    function GetCurrent : TFhirClaimResponseAddItem;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirClaimResponseAddItemList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirClaimResponseAddItem read GetCurrent;
  end;

  TFhirClaimResponseAddItemList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirClaimResponseAddItem;
    procedure SetItemN(index : Integer; value : TFhirClaimResponseAddItem);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirClaimResponseAddItemList; overload;
    function Clone : TFhirClaimResponseAddItemList; overload;
    function GetEnumerator : TFhirClaimResponseAddItemListEnumerator;
    
    //  Add a FhirClaimResponseAddItem to the end of the list.
    function Append : TFhirClaimResponseAddItem;
    
    // Add an already existing FhirClaimResponseAddItem to the end of the list.
    procedure AddItem(value : TFhirClaimResponseAddItem); overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirClaimResponseAddItem) : Integer;
    
    // Insert FhirClaimResponseAddItem before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirClaimResponseAddItem;
    
    // Insert an existing FhirClaimResponseAddItem before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirClaimResponseAddItem);
    
    // Get the iIndexth FhirClaimResponseAddItem. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirClaimResponseAddItem);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirClaimResponseAddItem;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirClaimResponseAddItems[index : Integer] : TFhirClaimResponseAddItem read GetItemN write SetItemN; default;
  End;

  // The second-tier service adjudications for payor added services.
  TFhirClaimResponseAddItemDetail = class (TFhirBackboneElement)
  protected
    FProductOrService : TFhirCodeableConcept;
    FmodifierList : TFhirCodeableConceptList;
    FQuantity : TFhirQuantity;
    FUnitPrice : TFhirMoney;
    FFactor : TFhirDecimal;
    FNet : TFhirMoney;
    FnoteNumberList : TFhirPositiveIntList;
    FadjudicationList : TFhirClaimResponseItemAdjudicationList;
    FsubDetailList : TFhirClaimResponseAddItemDetailSubDetailList;
    procedure SetProductOrService(value : TFhirCodeableConcept);
    function GetModifierList : TFhirCodeableConceptList;
    function GetHasModifierList : Boolean;
    procedure SetQuantity(value : TFhirQuantity);
    procedure SetUnitPrice(value : TFhirMoney);
    procedure SetFactor(value : TFhirDecimal);
    function GetFactorST : String;
    procedure SetFactorST(value : String);
    procedure SetNet(value : TFhirMoney);
    function GetNoteNumberList : TFhirPositiveIntList;
    function GetHasNoteNumberList : Boolean;
    function GetAdjudicationList : TFhirClaimResponseItemAdjudicationList;
    function GetHasAdjudicationList : Boolean;
    function GetSubDetailList : TFhirClaimResponseAddItemDetailSubDetailList;
    function GetHasSubDetailList : Boolean;
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirClaimResponseAddItemDetail; overload;
    function Clone : TFhirClaimResponseAddItemDetail; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to When the value is a group code then this item collects a set of related claim details, otherwise this contains the product, service, drug or other billing code for the item. (defined for API consistency)
    property productOrService : TFhirCodeableConcept read FProductOrService write SetProductOrService;
    // When the value is a group code then this item collects a set of related claim details, otherwise this contains the product, service, drug or other billing code for the item.
    property productOrServiceElement : TFhirCodeableConcept read FProductOrService write SetProductOrService;

    // Item typification or modifiers codes to convey additional context for the product or service.
    property modifierList : TFhirCodeableConceptList read GetModifierList;
    property hasModifierList : boolean read GetHasModifierList;

    // Typed access to The number of repetitions of a service or product. (defined for API consistency)
    property quantity : TFhirQuantity read FQuantity write SetQuantity;
    // The number of repetitions of a service or product.
    property quantityElement : TFhirQuantity read FQuantity write SetQuantity;

    // Typed access to If the item is not a group then this is the fee for the product or service, otherwise this is the total of the fees for the details of the group. (defined for API consistency)
    property unitPrice : TFhirMoney read FUnitPrice write SetUnitPrice;
    // If the item is not a group then this is the fee for the product or service, otherwise this is the total of the fees for the details of the group.
    property unitPriceElement : TFhirMoney read FUnitPrice write SetUnitPrice;

    // Typed access to A real number that represents a multiplier used in determining the overall value of services delivered and/or goods received. The concept of a Factor allows for a discount or surcharge multiplier to be applied to a monetary amount.
    property factor : String read GetFactorST write SetFactorST;
    // A real number that represents a multiplier used in determining the overall value of services delivered and/or goods received. The concept of a Factor allows for a discount or surcharge multiplier to be applied to a monetary amount.
    property factorElement : TFhirDecimal read FFactor write SetFactor;

    // Typed access to The quantity times the unit price for an additional service or product or charge. (defined for API consistency)
    property net : TFhirMoney read FNet write SetNet;
    // The quantity times the unit price for an additional service or product or charge.
    property netElement : TFhirMoney read FNet write SetNet;

    // The numbers associated with notes below which apply to the adjudication of this item.
    property noteNumberList : TFhirPositiveIntList read GetNoteNumberList;
    property hasNoteNumberList : boolean read GetHasNoteNumberList;

    // The adjudication results.
    property adjudicationList : TFhirClaimResponseItemAdjudicationList read GetAdjudicationList;
    property hasAdjudicationList : boolean read GetHasAdjudicationList;

    // The third-tier service adjudications for payor added services.
    property subDetailList : TFhirClaimResponseAddItemDetailSubDetailList read GetSubDetailList;
    property hasSubDetailList : boolean read GetHasSubDetailList;

  end;

  TFhirClaimResponseAddItemDetailListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirClaimResponseAddItemDetailList;
    function GetCurrent : TFhirClaimResponseAddItemDetail;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirClaimResponseAddItemDetailList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirClaimResponseAddItemDetail read GetCurrent;
  end;

  TFhirClaimResponseAddItemDetailList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirClaimResponseAddItemDetail;
    procedure SetItemN(index : Integer; value : TFhirClaimResponseAddItemDetail);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirClaimResponseAddItemDetailList; overload;
    function Clone : TFhirClaimResponseAddItemDetailList; overload;
    function GetEnumerator : TFhirClaimResponseAddItemDetailListEnumerator;
    
    //  Add a FhirClaimResponseAddItemDetail to the end of the list.
    function Append : TFhirClaimResponseAddItemDetail;
    
    // Add an already existing FhirClaimResponseAddItemDetail to the end of the list.
    procedure AddItem(value : TFhirClaimResponseAddItemDetail); overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirClaimResponseAddItemDetail) : Integer;
    
    // Insert FhirClaimResponseAddItemDetail before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirClaimResponseAddItemDetail;
    
    // Insert an existing FhirClaimResponseAddItemDetail before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirClaimResponseAddItemDetail);
    
    // Get the iIndexth FhirClaimResponseAddItemDetail. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirClaimResponseAddItemDetail);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirClaimResponseAddItemDetail;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirClaimResponseAddItemDetails[index : Integer] : TFhirClaimResponseAddItemDetail read GetItemN write SetItemN; default;
  End;

  // The third-tier service adjudications for payor added services.
  TFhirClaimResponseAddItemDetailSubDetail = class (TFhirBackboneElement)
  protected
    FProductOrService : TFhirCodeableConcept;
    FmodifierList : TFhirCodeableConceptList;
    FQuantity : TFhirQuantity;
    FUnitPrice : TFhirMoney;
    FFactor : TFhirDecimal;
    FNet : TFhirMoney;
    FnoteNumberList : TFhirPositiveIntList;
    FadjudicationList : TFhirClaimResponseItemAdjudicationList;
    procedure SetProductOrService(value : TFhirCodeableConcept);
    function GetModifierList : TFhirCodeableConceptList;
    function GetHasModifierList : Boolean;
    procedure SetQuantity(value : TFhirQuantity);
    procedure SetUnitPrice(value : TFhirMoney);
    procedure SetFactor(value : TFhirDecimal);
    function GetFactorST : String;
    procedure SetFactorST(value : String);
    procedure SetNet(value : TFhirMoney);
    function GetNoteNumberList : TFhirPositiveIntList;
    function GetHasNoteNumberList : Boolean;
    function GetAdjudicationList : TFhirClaimResponseItemAdjudicationList;
    function GetHasAdjudicationList : Boolean;
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirClaimResponseAddItemDetailSubDetail; overload;
    function Clone : TFhirClaimResponseAddItemDetailSubDetail; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to When the value is a group code then this item collects a set of related claim details, otherwise this contains the product, service, drug or other billing code for the item. (defined for API consistency)
    property productOrService : TFhirCodeableConcept read FProductOrService write SetProductOrService;
    // When the value is a group code then this item collects a set of related claim details, otherwise this contains the product, service, drug or other billing code for the item.
    property productOrServiceElement : TFhirCodeableConcept read FProductOrService write SetProductOrService;

    // Item typification or modifiers codes to convey additional context for the product or service.
    property modifierList : TFhirCodeableConceptList read GetModifierList;
    property hasModifierList : boolean read GetHasModifierList;

    // Typed access to The number of repetitions of a service or product. (defined for API consistency)
    property quantity : TFhirQuantity read FQuantity write SetQuantity;
    // The number of repetitions of a service or product.
    property quantityElement : TFhirQuantity read FQuantity write SetQuantity;

    // Typed access to If the item is not a group then this is the fee for the product or service, otherwise this is the total of the fees for the details of the group. (defined for API consistency)
    property unitPrice : TFhirMoney read FUnitPrice write SetUnitPrice;
    // If the item is not a group then this is the fee for the product or service, otherwise this is the total of the fees for the details of the group.
    property unitPriceElement : TFhirMoney read FUnitPrice write SetUnitPrice;

    // Typed access to A real number that represents a multiplier used in determining the overall value of services delivered and/or goods received. The concept of a Factor allows for a discount or surcharge multiplier to be applied to a monetary amount.
    property factor : String read GetFactorST write SetFactorST;
    // A real number that represents a multiplier used in determining the overall value of services delivered and/or goods received. The concept of a Factor allows for a discount or surcharge multiplier to be applied to a monetary amount.
    property factorElement : TFhirDecimal read FFactor write SetFactor;

    // Typed access to The quantity times the unit price for an additional service or product or charge. (defined for API consistency)
    property net : TFhirMoney read FNet write SetNet;
    // The quantity times the unit price for an additional service or product or charge.
    property netElement : TFhirMoney read FNet write SetNet;

    // The numbers associated with notes below which apply to the adjudication of this item.
    property noteNumberList : TFhirPositiveIntList read GetNoteNumberList;
    property hasNoteNumberList : boolean read GetHasNoteNumberList;

    // The adjudication results.
    property adjudicationList : TFhirClaimResponseItemAdjudicationList read GetAdjudicationList;
    property hasAdjudicationList : boolean read GetHasAdjudicationList;

  end;

  TFhirClaimResponseAddItemDetailSubDetailListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirClaimResponseAddItemDetailSubDetailList;
    function GetCurrent : TFhirClaimResponseAddItemDetailSubDetail;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirClaimResponseAddItemDetailSubDetailList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirClaimResponseAddItemDetailSubDetail read GetCurrent;
  end;

  TFhirClaimResponseAddItemDetailSubDetailList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirClaimResponseAddItemDetailSubDetail;
    procedure SetItemN(index : Integer; value : TFhirClaimResponseAddItemDetailSubDetail);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirClaimResponseAddItemDetailSubDetailList; overload;
    function Clone : TFhirClaimResponseAddItemDetailSubDetailList; overload;
    function GetEnumerator : TFhirClaimResponseAddItemDetailSubDetailListEnumerator;
    
    //  Add a FhirClaimResponseAddItemDetailSubDetail to the end of the list.
    function Append : TFhirClaimResponseAddItemDetailSubDetail;
    
    // Add an already existing FhirClaimResponseAddItemDetailSubDetail to the end of the list.
    procedure AddItem(value : TFhirClaimResponseAddItemDetailSubDetail); overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirClaimResponseAddItemDetailSubDetail) : Integer;
    
    // Insert FhirClaimResponseAddItemDetailSubDetail before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirClaimResponseAddItemDetailSubDetail;
    
    // Insert an existing FhirClaimResponseAddItemDetailSubDetail before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirClaimResponseAddItemDetailSubDetail);
    
    // Get the iIndexth FhirClaimResponseAddItemDetailSubDetail. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirClaimResponseAddItemDetailSubDetail);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirClaimResponseAddItemDetailSubDetail;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirClaimResponseAddItemDetailSubDetails[index : Integer] : TFhirClaimResponseAddItemDetailSubDetail read GetItemN write SetItemN; default;
  End;

  // Categorized monetary totals for the adjudication.
  TFhirClaimResponseTotal = class (TFhirBackboneElement)
  protected
    FCategory : TFhirCodeableConcept;
    FAmount : TFhirMoney;
    procedure SetCategory(value : TFhirCodeableConcept);
    procedure SetAmount(value : TFhirMoney);
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirClaimResponseTotal; overload;
    function Clone : TFhirClaimResponseTotal; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to A code to indicate the information type of this adjudication record. Information types may include: the value submitted, maximum values or percentages allowed or payable under the plan, amounts that the patient is responsible for in aggregate or pertaining to this item, amounts paid by other coverages, and the benefit payable for this item. (defined for API consistency)
    property category : TFhirCodeableConcept read FCategory write SetCategory;
    // A code to indicate the information type of this adjudication record. Information types may include: the value submitted, maximum values or percentages allowed or payable under the plan, amounts that the patient is responsible for in aggregate or pertaining to this item, amounts paid by other coverages, and the benefit payable for this item.
    property categoryElement : TFhirCodeableConcept read FCategory write SetCategory;

    // Typed access to Monetary total amount associated with the category. (defined for API consistency)
    property amount : TFhirMoney read FAmount write SetAmount;
    // Monetary total amount associated with the category.
    property amountElement : TFhirMoney read FAmount write SetAmount;

  end;

  TFhirClaimResponseTotalListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirClaimResponseTotalList;
    function GetCurrent : TFhirClaimResponseTotal;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirClaimResponseTotalList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirClaimResponseTotal read GetCurrent;
  end;

  TFhirClaimResponseTotalList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirClaimResponseTotal;
    procedure SetItemN(index : Integer; value : TFhirClaimResponseTotal);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirClaimResponseTotalList; overload;
    function Clone : TFhirClaimResponseTotalList; overload;
    function GetEnumerator : TFhirClaimResponseTotalListEnumerator;
    
    //  Add a FhirClaimResponseTotal to the end of the list.
    function Append : TFhirClaimResponseTotal;
    
    // Add an already existing FhirClaimResponseTotal to the end of the list.
    procedure AddItem(value : TFhirClaimResponseTotal); overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirClaimResponseTotal) : Integer;
    
    // Insert FhirClaimResponseTotal before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirClaimResponseTotal;
    
    // Insert an existing FhirClaimResponseTotal before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirClaimResponseTotal);
    
    // Get the iIndexth FhirClaimResponseTotal. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirClaimResponseTotal);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirClaimResponseTotal;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirClaimResponseTotals[index : Integer] : TFhirClaimResponseTotal read GetItemN write SetItemN; default;
  End;

  // Payment details for the adjudication of the claim.
  TFhirClaimResponsePayment = class (TFhirBackboneElement)
  protected
    FType_ : TFhirCodeableConcept;
    FAdjustment : TFhirMoney;
    FAdjustmentReason : TFhirCodeableConcept;
    FDate : TFhirDate;
    FAmount : TFhirMoney;
    FIdentifier : TFhirIdentifier;
    procedure SetType_(value : TFhirCodeableConcept);
    procedure SetAdjustment(value : TFhirMoney);
    procedure SetAdjustmentReason(value : TFhirCodeableConcept);
    procedure SetDate(value : TFhirDate);
    function GetDateST : TFslDateTime;
    procedure SetDateST(value : TFslDateTime);
    procedure SetAmount(value : TFhirMoney);
    procedure SetIdentifier(value : TFhirIdentifier);
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirClaimResponsePayment; overload;
    function Clone : TFhirClaimResponsePayment; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to Whether this represents partial or complete payment of the benefits payable. (defined for API consistency)
    property type_ : TFhirCodeableConcept read FType_ write SetType_;
    // Whether this represents partial or complete payment of the benefits payable.
    property type_Element : TFhirCodeableConcept read FType_ write SetType_;

    // Typed access to Total amount of all adjustments to this payment included in this transaction which are not related to this claim's adjudication. (defined for API consistency)
    property adjustment : TFhirMoney read FAdjustment write SetAdjustment;
    // Total amount of all adjustments to this payment included in this transaction which are not related to this claim's adjudication.
    property adjustmentElement : TFhirMoney read FAdjustment write SetAdjustment;

    // Typed access to Reason for the payment adjustment. (defined for API consistency)
    property adjustmentReason : TFhirCodeableConcept read FAdjustmentReason write SetAdjustmentReason;
    // Reason for the payment adjustment.
    property adjustmentReasonElement : TFhirCodeableConcept read FAdjustmentReason write SetAdjustmentReason;

    // Typed access to Estimated date the payment will be issued or the actual issue date of payment.
    property date : TFslDateTime read GetDateST write SetDateST;
    // Estimated date the payment will be issued or the actual issue date of payment.
    property dateElement : TFhirDate read FDate write SetDate;

    // Typed access to Benefits payable less any payment adjustment. (defined for API consistency)
    property amount : TFhirMoney read FAmount write SetAmount;
    // Benefits payable less any payment adjustment.
    property amountElement : TFhirMoney read FAmount write SetAmount;

    // Typed access to Issuer's unique identifier for the payment instrument. (defined for API consistency)
    property identifier : TFhirIdentifier read FIdentifier write SetIdentifier;
    // Issuer's unique identifier for the payment instrument.
    property identifierElement : TFhirIdentifier read FIdentifier write SetIdentifier;

  end;

  TFhirClaimResponsePaymentListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirClaimResponsePaymentList;
    function GetCurrent : TFhirClaimResponsePayment;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirClaimResponsePaymentList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirClaimResponsePayment read GetCurrent;
  end;

  TFhirClaimResponsePaymentList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirClaimResponsePayment;
    procedure SetItemN(index : Integer; value : TFhirClaimResponsePayment);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirClaimResponsePaymentList; overload;
    function Clone : TFhirClaimResponsePaymentList; overload;
    function GetEnumerator : TFhirClaimResponsePaymentListEnumerator;
    
    //  Add a FhirClaimResponsePayment to the end of the list.
    function Append : TFhirClaimResponsePayment;
    
    // Add an already existing FhirClaimResponsePayment to the end of the list.
    procedure AddItem(value : TFhirClaimResponsePayment); overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirClaimResponsePayment) : Integer;
    
    // Insert FhirClaimResponsePayment before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirClaimResponsePayment;
    
    // Insert an existing FhirClaimResponsePayment before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirClaimResponsePayment);
    
    // Get the iIndexth FhirClaimResponsePayment. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirClaimResponsePayment);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirClaimResponsePayment;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirClaimResponsePayments[index : Integer] : TFhirClaimResponsePayment read GetItemN write SetItemN; default;
  End;

  // A note that describes or explains adjudication results in a human readable form.
  TFhirClaimResponseProcessNote = class (TFhirBackboneElement)
  protected
    FNumber : TFhirPositiveInt;
    FType_ : TFhirEnum;
    FText : TFhirString;
    FLanguage : TFhirCodeableConcept;
    procedure SetNumber(value : TFhirPositiveInt);
    function GetNumberST : String;
    procedure SetNumberST(value : String);
    procedure SetType_(value : TFhirEnum);
    function GetType_ST : TFhirNoteTypeEnum;
    procedure SetType_ST(value : TFhirNoteTypeEnum);
    procedure SetText(value : TFhirString);
    function GetTextST : String;
    procedure SetTextST(value : String);
    procedure SetLanguage(value : TFhirCodeableConcept);
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirClaimResponseProcessNote; overload;
    function Clone : TFhirClaimResponseProcessNote; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to A number to uniquely identify a note entry.
    property number : String read GetNumberST write SetNumberST;
    // A number to uniquely identify a note entry.
    property numberElement : TFhirPositiveInt read FNumber write SetNumber;

    // The business purpose of the note text.
    property type_ : TFhirNoteTypeEnum read GetType_ST write SetType_ST;
    property type_Element : TFhirEnum read FType_ write SetType_;

    // Typed access to The explanation or description associated with the processing.
    property text : String read GetTextST write SetTextST;
    // The explanation or description associated with the processing.
    property textElement : TFhirString read FText write SetText;

    // Typed access to A code to define the language used in the text of the note. (defined for API consistency)
    property language : TFhirCodeableConcept read FLanguage write SetLanguage;
    // A code to define the language used in the text of the note.
    property languageElement : TFhirCodeableConcept read FLanguage write SetLanguage;

  end;

  TFhirClaimResponseProcessNoteListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirClaimResponseProcessNoteList;
    function GetCurrent : TFhirClaimResponseProcessNote;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirClaimResponseProcessNoteList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirClaimResponseProcessNote read GetCurrent;
  end;

  TFhirClaimResponseProcessNoteList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirClaimResponseProcessNote;
    procedure SetItemN(index : Integer; value : TFhirClaimResponseProcessNote);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirClaimResponseProcessNoteList; overload;
    function Clone : TFhirClaimResponseProcessNoteList; overload;
    function GetEnumerator : TFhirClaimResponseProcessNoteListEnumerator;
    
    //  Add a FhirClaimResponseProcessNote to the end of the list.
    function Append : TFhirClaimResponseProcessNote;
    
    // Add an already existing FhirClaimResponseProcessNote to the end of the list.
    procedure AddItem(value : TFhirClaimResponseProcessNote); overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirClaimResponseProcessNote) : Integer;
    
    // Insert FhirClaimResponseProcessNote before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirClaimResponseProcessNote;
    
    // Insert an existing FhirClaimResponseProcessNote before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirClaimResponseProcessNote);
    
    // Get the iIndexth FhirClaimResponseProcessNote. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirClaimResponseProcessNote);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirClaimResponseProcessNote;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirClaimResponseProcessNotes[index : Integer] : TFhirClaimResponseProcessNote read GetItemN write SetItemN; default;
  End;

  // Financial instruments for reimbursement for the health care products and services specified on the claim.
  TFhirClaimResponseInsurance = class (TFhirBackboneElement)
  protected
    FSequence : TFhirPositiveInt;
    FFocal : TFhirBoolean;
    FCoverage : TFhirReference;
    FBusinessArrangement : TFhirString;
    FClaimResponse : TFhirReference;
    procedure SetSequence(value : TFhirPositiveInt);
    function GetSequenceST : String;
    procedure SetSequenceST(value : String);
    procedure SetFocal(value : TFhirBoolean);
    function GetFocalST : Boolean;
    procedure SetFocalST(value : Boolean);
    procedure SetCoverage(value : TFhirReference);
    procedure SetBusinessArrangement(value : TFhirString);
    function GetBusinessArrangementST : String;
    procedure SetBusinessArrangementST(value : String);
    procedure SetClaimResponse(value : TFhirReference);
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirClaimResponseInsurance; overload;
    function Clone : TFhirClaimResponseInsurance; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to A number to uniquely identify insurance entries and provide a sequence of coverages to convey coordination of benefit order.
    property sequence : String read GetSequenceST write SetSequenceST;
    // A number to uniquely identify insurance entries and provide a sequence of coverages to convey coordination of benefit order.
    property sequenceElement : TFhirPositiveInt read FSequence write SetSequence;

    // Typed access to A flag to indicate that this Coverage is to be used for adjudication of this claim when set to true.
    property focal : Boolean read GetFocalST write SetFocalST;
    // A flag to indicate that this Coverage is to be used for adjudication of this claim when set to true.
    property focalElement : TFhirBoolean read FFocal write SetFocal;

    // Typed access to Reference to the insurance card level information contained in the Coverage resource. The coverage issuing insurer will use these details to locate the patient's actual coverage within the insurer's information system. (defined for API consistency)
    property coverage : TFhirReference read FCoverage write SetCoverage;
    // Reference to the insurance card level information contained in the Coverage resource. The coverage issuing insurer will use these details to locate the patient's actual coverage within the insurer's information system.
    property coverageElement : TFhirReference read FCoverage write SetCoverage;

    // Typed access to A business agreement number established between the provider and the insurer for special business processing purposes.
    property businessArrangement : String read GetBusinessArrangementST write SetBusinessArrangementST;
    // A business agreement number established between the provider and the insurer for special business processing purposes.
    property businessArrangementElement : TFhirString read FBusinessArrangement write SetBusinessArrangement;

    // Typed access to The result of the adjudication of the line items for the Coverage specified in this insurance. (defined for API consistency)
    property claimResponse : TFhirReference read FClaimResponse write SetClaimResponse;
    // The result of the adjudication of the line items for the Coverage specified in this insurance.
    property claimResponseElement : TFhirReference read FClaimResponse write SetClaimResponse;

  end;

  TFhirClaimResponseInsuranceListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirClaimResponseInsuranceList;
    function GetCurrent : TFhirClaimResponseInsurance;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirClaimResponseInsuranceList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirClaimResponseInsurance read GetCurrent;
  end;

  TFhirClaimResponseInsuranceList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirClaimResponseInsurance;
    procedure SetItemN(index : Integer; value : TFhirClaimResponseInsurance);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirClaimResponseInsuranceList; overload;
    function Clone : TFhirClaimResponseInsuranceList; overload;
    function GetEnumerator : TFhirClaimResponseInsuranceListEnumerator;
    
    //  Add a FhirClaimResponseInsurance to the end of the list.
    function Append : TFhirClaimResponseInsurance;
    
    // Add an already existing FhirClaimResponseInsurance to the end of the list.
    procedure AddItem(value : TFhirClaimResponseInsurance); overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirClaimResponseInsurance) : Integer;
    
    // Insert FhirClaimResponseInsurance before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirClaimResponseInsurance;
    
    // Insert an existing FhirClaimResponseInsurance before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirClaimResponseInsurance);
    
    // Get the iIndexth FhirClaimResponseInsurance. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirClaimResponseInsurance);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirClaimResponseInsurance;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirClaimResponseInsurances[index : Integer] : TFhirClaimResponseInsurance read GetItemN write SetItemN; default;
  End;

  // Errors encountered during the processing of the adjudication.
  TFhirClaimResponseError = class (TFhirBackboneElement)
  protected
    FItemSequence : TFhirPositiveInt;
    FDetailSequence : TFhirPositiveInt;
    FSubDetailSequence : TFhirPositiveInt;
    FCode : TFhirCodeableConcept;
    procedure SetItemSequence(value : TFhirPositiveInt);
    function GetItemSequenceST : String;
    procedure SetItemSequenceST(value : String);
    procedure SetDetailSequence(value : TFhirPositiveInt);
    function GetDetailSequenceST : String;
    procedure SetDetailSequenceST(value : String);
    procedure SetSubDetailSequence(value : TFhirPositiveInt);
    function GetSubDetailSequenceST : String;
    procedure SetSubDetailSequenceST(value : String);
    procedure SetCode(value : TFhirCodeableConcept);
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirClaimResponseError; overload;
    function Clone : TFhirClaimResponseError; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to The sequence number of the line item submitted which contains the error. This value is omitted when the error occurs outside of the item structure.
    property itemSequence : String read GetItemSequenceST write SetItemSequenceST;
    // The sequence number of the line item submitted which contains the error. This value is omitted when the error occurs outside of the item structure.
    property itemSequenceElement : TFhirPositiveInt read FItemSequence write SetItemSequence;

    // Typed access to The sequence number of the detail within the line item submitted which contains the error. This value is omitted when the error occurs outside of the item structure.
    property detailSequence : String read GetDetailSequenceST write SetDetailSequenceST;
    // The sequence number of the detail within the line item submitted which contains the error. This value is omitted when the error occurs outside of the item structure.
    property detailSequenceElement : TFhirPositiveInt read FDetailSequence write SetDetailSequence;

    // Typed access to The sequence number of the sub-detail within the detail within the line item submitted which contains the error. This value is omitted when the error occurs outside of the item structure.
    property subDetailSequence : String read GetSubDetailSequenceST write SetSubDetailSequenceST;
    // The sequence number of the sub-detail within the detail within the line item submitted which contains the error. This value is omitted when the error occurs outside of the item structure.
    property subDetailSequenceElement : TFhirPositiveInt read FSubDetailSequence write SetSubDetailSequence;

    // Typed access to An error code, from a specified code system, which details why the claim could not be adjudicated. (defined for API consistency)
    property code : TFhirCodeableConcept read FCode write SetCode;
    // An error code, from a specified code system, which details why the claim could not be adjudicated.
    property codeElement : TFhirCodeableConcept read FCode write SetCode;

  end;

  TFhirClaimResponseErrorListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirClaimResponseErrorList;
    function GetCurrent : TFhirClaimResponseError;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirClaimResponseErrorList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirClaimResponseError read GetCurrent;
  end;

  TFhirClaimResponseErrorList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirClaimResponseError;
    procedure SetItemN(index : Integer; value : TFhirClaimResponseError);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirClaimResponseErrorList; overload;
    function Clone : TFhirClaimResponseErrorList; overload;
    function GetEnumerator : TFhirClaimResponseErrorListEnumerator;
    
    //  Add a FhirClaimResponseError to the end of the list.
    function Append : TFhirClaimResponseError;
    
    // Add an already existing FhirClaimResponseError to the end of the list.
    procedure AddItem(value : TFhirClaimResponseError); overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirClaimResponseError) : Integer;
    
    // Insert FhirClaimResponseError before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirClaimResponseError;
    
    // Insert an existing FhirClaimResponseError before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirClaimResponseError);
    
    // Get the iIndexth FhirClaimResponseError. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirClaimResponseError);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirClaimResponseError;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirClaimResponseErrors[index : Integer] : TFhirClaimResponseError read GetItemN write SetItemN; default;
  End;

  // This resource provides the adjudication details from the processing of a Claim resource.
  TFhirClaimResponse = class (TFhirDomainResource)
  protected
    FidentifierList : TFhirIdentifierList;
    FStatus : TFhirEnum;
    FType_ : TFhirCodeableConcept;
    FSubType : TFhirCodeableConcept;
    FUse : TFhirEnum;
    FPatient : TFhirReference;
    FCreated : TFhirDateTime;
    FInsurer : TFhirReference;
    FRequestor : TFhirReference;
    FRequest : TFhirReference;
    FOutcome : TFhirEnum;
    FDisposition : TFhirString;
    FPreAuthRef : TFhirString;
    FPreAuthPeriod : TFhirPeriod;
    FPayeeType : TFhirCodeableConcept;
    FitemList : TFhirClaimResponseItemList;
    FaddItemList : TFhirClaimResponseAddItemList;
    FadjudicationList : TFhirClaimResponseItemAdjudicationList;
    FtotalList : TFhirClaimResponseTotalList;
    FPayment : TFhirClaimResponsePayment;
    FFundsReserve : TFhirCodeableConcept;
    FFormCode : TFhirCodeableConcept;
    FForm : TFhirAttachment;
    FprocessNoteList : TFhirClaimResponseProcessNoteList;
    FcommunicationRequestList : TFhirReferenceList;
    FinsuranceList : TFhirClaimResponseInsuranceList;
    FerrorList : TFhirClaimResponseErrorList;
    function GetIdentifierList : TFhirIdentifierList;
    function GetHasIdentifierList : Boolean;
    procedure SetStatus(value : TFhirEnum);
    function GetStatusST : TFhirFinancialResourceStatusCodesEnum;
    procedure SetStatusST(value : TFhirFinancialResourceStatusCodesEnum);
    procedure SetType_(value : TFhirCodeableConcept);
    procedure SetSubType(value : TFhirCodeableConcept);
    procedure SetUse(value : TFhirEnum);
    function GetUseST : TFhirUseEnum;
    procedure SetUseST(value : TFhirUseEnum);
    procedure SetPatient(value : TFhirReference);
    procedure SetCreated(value : TFhirDateTime);
    function GetCreatedST : TFslDateTime;
    procedure SetCreatedST(value : TFslDateTime);
    procedure SetInsurer(value : TFhirReference);
    procedure SetRequestor(value : TFhirReference);
    procedure SetRequest(value : TFhirReference);
    procedure SetOutcome(value : TFhirEnum);
    function GetOutcomeST : TFhirClaimProcessingCodesEnum;
    procedure SetOutcomeST(value : TFhirClaimProcessingCodesEnum);
    procedure SetDisposition(value : TFhirString);
    function GetDispositionST : String;
    procedure SetDispositionST(value : String);
    procedure SetPreAuthRef(value : TFhirString);
    function GetPreAuthRefST : String;
    procedure SetPreAuthRefST(value : String);
    procedure SetPreAuthPeriod(value : TFhirPeriod);
    procedure SetPayeeType(value : TFhirCodeableConcept);
    function GetItemList : TFhirClaimResponseItemList;
    function GetHasItemList : Boolean;
    function GetAddItemList : TFhirClaimResponseAddItemList;
    function GetHasAddItemList : Boolean;
    function GetAdjudicationList : TFhirClaimResponseItemAdjudicationList;
    function GetHasAdjudicationList : Boolean;
    function GetTotalList : TFhirClaimResponseTotalList;
    function GetHasTotalList : Boolean;
    procedure SetPayment(value : TFhirClaimResponsePayment);
    procedure SetFundsReserve(value : TFhirCodeableConcept);
    procedure SetFormCode(value : TFhirCodeableConcept);
    procedure SetForm(value : TFhirAttachment);
    function GetProcessNoteList : TFhirClaimResponseProcessNoteList;
    function GetHasProcessNoteList : Boolean;
    function GetCommunicationRequestList : TFhirReferenceList;
    function GetHasCommunicationRequestList : Boolean;
    function GetInsuranceList : TFhirClaimResponseInsuranceList;
    function GetHasInsuranceList : Boolean;
    function GetErrorList : TFhirClaimResponseErrorList;
    function GetHasErrorList : Boolean;
  
    function GetResourceType : TFhirResourceType; override;
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirClaimResponse; overload;
    function Clone : TFhirClaimResponse; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // A unique identifier assigned to this claim response.
    property identifierList : TFhirIdentifierList read GetIdentifierList;
    property hasIdentifierList : boolean read GetHasIdentifierList;

    // The status of the resource instance.
    property status : TFhirFinancialResourceStatusCodesEnum read GetStatusST write SetStatusST;
    property statusElement : TFhirEnum read FStatus write SetStatus;

    // Typed access to A finer grained suite of claim type codes which may convey additional information such as Inpatient vs Outpatient and/or a specialty service. (defined for API consistency)
    property type_ : TFhirCodeableConcept read FType_ write SetType_;
    // A finer grained suite of claim type codes which may convey additional information such as Inpatient vs Outpatient and/or a specialty service.
    property type_Element : TFhirCodeableConcept read FType_ write SetType_;

    // Typed access to A finer grained suite of claim type codes which may convey additional information such as Inpatient vs Outpatient and/or a specialty service. (defined for API consistency)
    property subType : TFhirCodeableConcept read FSubType write SetSubType;
    // A finer grained suite of claim type codes which may convey additional information such as Inpatient vs Outpatient and/or a specialty service.
    property subTypeElement : TFhirCodeableConcept read FSubType write SetSubType;

    // A code to indicate whether the nature of the request is: to request adjudication of products and services previously rendered; or requesting authorization and adjudication for provision in the future; or requesting the non-binding adjudication of the listed products and services which could be provided in the future.
    property use : TFhirUseEnum read GetUseST write SetUseST;
    property useElement : TFhirEnum read FUse write SetUse;

    // Typed access to The party to whom the professional services and/or products have been supplied or are being considered and for whom actual for facast reimbursement is sought. (defined for API consistency)
    property patient : TFhirReference read FPatient write SetPatient;
    // The party to whom the professional services and/or products have been supplied or are being considered and for whom actual for facast reimbursement is sought.
    property patientElement : TFhirReference read FPatient write SetPatient;

    // Typed access to The date this resource was created.
    property created : TFslDateTime read GetCreatedST write SetCreatedST;
    // The date this resource was created.
    property createdElement : TFhirDateTime read FCreated write SetCreated;

    // Typed access to The party responsible for authorization, adjudication and reimbursement. (defined for API consistency)
    property insurer : TFhirReference read FInsurer write SetInsurer;
    // The party responsible for authorization, adjudication and reimbursement.
    property insurerElement : TFhirReference read FInsurer write SetInsurer;

    // Typed access to The provider which is responsible for the claim, predetermination or preauthorization. (defined for API consistency)
    property requestor : TFhirReference read FRequestor write SetRequestor;
    // The provider which is responsible for the claim, predetermination or preauthorization.
    property requestorElement : TFhirReference read FRequestor write SetRequestor;

    // Typed access to Original request resource reference. (defined for API consistency)
    property request : TFhirReference read FRequest write SetRequest;
    // Original request resource reference.
    property requestElement : TFhirReference read FRequest write SetRequest;

    // The outcome of the claim, predetermination, or preauthorization processing.
    property outcome : TFhirClaimProcessingCodesEnum read GetOutcomeST write SetOutcomeST;
    property outcomeElement : TFhirEnum read FOutcome write SetOutcome;

    // Typed access to A human readable description of the status of the adjudication.
    property disposition : String read GetDispositionST write SetDispositionST;
    // A human readable description of the status of the adjudication.
    property dispositionElement : TFhirString read FDisposition write SetDisposition;

    // Typed access to Reference from the Insurer which is used in later communications which refers to this adjudication.
    property preAuthRef : String read GetPreAuthRefST write SetPreAuthRefST;
    // Reference from the Insurer which is used in later communications which refers to this adjudication.
    property preAuthRefElement : TFhirString read FPreAuthRef write SetPreAuthRef;

    // Typed access to The time frame during which this authorization is effective. (defined for API consistency)
    property preAuthPeriod : TFhirPeriod read FPreAuthPeriod write SetPreAuthPeriod;
    // The time frame during which this authorization is effective.
    property preAuthPeriodElement : TFhirPeriod read FPreAuthPeriod write SetPreAuthPeriod;

    // Typed access to Type of Party to be reimbursed: subscriber, provider, other. (defined for API consistency)
    property payeeType : TFhirCodeableConcept read FPayeeType write SetPayeeType;
    // Type of Party to be reimbursed: subscriber, provider, other.
    property payeeTypeElement : TFhirCodeableConcept read FPayeeType write SetPayeeType;

    // A claim line. Either a simple (a product or service) or a 'group' of details which can also be a simple items or groups of sub-details.
    property itemList : TFhirClaimResponseItemList read GetItemList;
    property hasItemList : boolean read GetHasItemList;

    // The first-tier service adjudications for payor added product or service lines.
    property addItemList : TFhirClaimResponseAddItemList read GetAddItemList;
    property hasAddItemList : boolean read GetHasAddItemList;

    // The adjudication results which are presented at the header level rather than at the line-item or add-item levels.
    property adjudicationList : TFhirClaimResponseItemAdjudicationList read GetAdjudicationList;
    property hasAdjudicationList : boolean read GetHasAdjudicationList;

    // Categorized monetary totals for the adjudication.
    property totalList : TFhirClaimResponseTotalList read GetTotalList;
    property hasTotalList : boolean read GetHasTotalList;

    // Typed access to Payment details for the adjudication of the claim. (defined for API consistency)
    property payment : TFhirClaimResponsePayment read FPayment write SetPayment;
    // Payment details for the adjudication of the claim.
    property paymentElement : TFhirClaimResponsePayment read FPayment write SetPayment;

    // Typed access to A code, used only on a response to a preauthorization, to indicate whether the benefits payable have been reserved and for whom. (defined for API consistency)
    property fundsReserve : TFhirCodeableConcept read FFundsReserve write SetFundsReserve;
    // A code, used only on a response to a preauthorization, to indicate whether the benefits payable have been reserved and for whom.
    property fundsReserveElement : TFhirCodeableConcept read FFundsReserve write SetFundsReserve;

    // Typed access to A code for the form to be used for printing the content. (defined for API consistency)
    property formCode : TFhirCodeableConcept read FFormCode write SetFormCode;
    // A code for the form to be used for printing the content.
    property formCodeElement : TFhirCodeableConcept read FFormCode write SetFormCode;

    // Typed access to The actual form, by reference or inclusion, for printing the content or an EOB. (defined for API consistency)
    property form : TFhirAttachment read FForm write SetForm;
    // The actual form, by reference or inclusion, for printing the content or an EOB.
    property formElement : TFhirAttachment read FForm write SetForm;

    // A note that describes or explains adjudication results in a human readable form.
    property processNoteList : TFhirClaimResponseProcessNoteList read GetProcessNoteList;
    property hasProcessNoteList : boolean read GetHasProcessNoteList;

    // Request for additional supporting or authorizing information.
    property communicationRequestList : TFhirReferenceList read GetCommunicationRequestList;
    property hasCommunicationRequestList : boolean read GetHasCommunicationRequestList;

    // Financial instruments for reimbursement for the health care products and services specified on the claim.
    property insuranceList : TFhirClaimResponseInsuranceList read GetInsuranceList;
    property hasInsuranceList : boolean read GetHasInsuranceList;

    // Errors encountered during the processing of the adjudication.
    property errorList : TFhirClaimResponseErrorList read GetErrorList;
    property hasErrorList : boolean read GetHasErrorList;

  end;

  TFhirClaimResponseListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirClaimResponseList;
    function GetCurrent : TFhirClaimResponse;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirClaimResponseList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirClaimResponse read GetCurrent;
  end;

  TFhirClaimResponseList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirClaimResponse;
    procedure SetItemN(index : Integer; value : TFhirClaimResponse);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirClaimResponseList; overload;
    function Clone : TFhirClaimResponseList; overload;
    function GetEnumerator : TFhirClaimResponseListEnumerator;
    
    //  Add a FhirClaimResponse to the end of the list.
    function Append : TFhirClaimResponse;
    
    // Add an already existing FhirClaimResponse to the end of the list.
    procedure AddItem(value : TFhirClaimResponse); overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirClaimResponse) : Integer;
    
    // Insert FhirClaimResponse before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirClaimResponse;
    
    // Insert an existing FhirClaimResponse before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirClaimResponse);
    
    // Get the iIndexth FhirClaimResponse. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirClaimResponse);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirClaimResponse;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirClaimResponses[index : Integer] : TFhirClaimResponse read GetItemN write SetItemN; default;
  End;

{$ENDIF FHIR_CLAIMRESPONSE}
{$IFDEF FHIR_COVERAGE}
  // A suite of underwriter specific classifiers.
  TFhirCoverageClass = class (TFhirBackboneElement)
  protected
    FType_ : TFhirCodeableConcept;
    FValue : TFhirString;
    FName : TFhirString;
    procedure SetType_(value : TFhirCodeableConcept);
    procedure SetValue(value : TFhirString);
    function GetValueST : String;
    procedure SetValueST(value : String);
    procedure SetName(value : TFhirString);
    function GetNameST : String;
    procedure SetNameST(value : String);
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirCoverageClass; overload;
    function Clone : TFhirCoverageClass; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to The type of classification for which an insurer-specific class label or number and optional name is provided.  For example, type may be used to identify a class of coverage or employer group, policy, or plan. (defined for API consistency)
    property type_ : TFhirCodeableConcept read FType_ write SetType_;
    // The type of classification for which an insurer-specific class label or number and optional name is provided.  For example, type may be used to identify a class of coverage or employer group, policy, or plan.
    property type_Element : TFhirCodeableConcept read FType_ write SetType_;

    // Typed access to The alphanumeric string value associated with the insurer issued label.
    property value : String read GetValueST write SetValueST;
    // The alphanumeric string value associated with the insurer issued label.
    property valueElement : TFhirString read FValue write SetValue;

    // Typed access to A short description for the class.
    property name : String read GetNameST write SetNameST;
    // A short description for the class.
    property nameElement : TFhirString read FName write SetName;

  end;

  TFhirCoverageClassListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirCoverageClassList;
    function GetCurrent : TFhirCoverageClass;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirCoverageClassList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirCoverageClass read GetCurrent;
  end;

  TFhirCoverageClassList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirCoverageClass;
    procedure SetItemN(index : Integer; value : TFhirCoverageClass);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirCoverageClassList; overload;
    function Clone : TFhirCoverageClassList; overload;
    function GetEnumerator : TFhirCoverageClassListEnumerator;
    
    //  Add a FhirCoverageClass to the end of the list.
    function Append : TFhirCoverageClass;
    
    // Add an already existing FhirCoverageClass to the end of the list.
    procedure AddItem(value : TFhirCoverageClass); overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirCoverageClass) : Integer;
    
    // Insert FhirCoverageClass before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirCoverageClass;
    
    // Insert an existing FhirCoverageClass before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirCoverageClass);
    
    // Get the iIndexth FhirCoverageClass. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirCoverageClass);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirCoverageClass;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirCoverageClasses[index : Integer] : TFhirCoverageClass read GetItemN write SetItemN; default;
  End;

  // A suite of codes indicating the cost category and associated amount which have been detailed in the policy and may have been  included on the health card.
  TFhirCoverageCostToBeneficiary = class (TFhirBackboneElement)
  protected
    FType_ : TFhirCodeableConcept;
    FValue : TFhirDataType;
    FexceptionList : TFhirCoverageCostToBeneficiaryExceptionList;
    procedure SetType_(value : TFhirCodeableConcept);
    procedure SetValue(value : TFhirDataType);
    function GetExceptionList : TFhirCoverageCostToBeneficiaryExceptionList;
    function GetHasExceptionList : Boolean;
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirCoverageCostToBeneficiary; overload;
    function Clone : TFhirCoverageCostToBeneficiary; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to The category of patient centric costs associated with treatment. (defined for API consistency)
    property type_ : TFhirCodeableConcept read FType_ write SetType_;
    // The category of patient centric costs associated with treatment.
    property type_Element : TFhirCodeableConcept read FType_ write SetType_;

    // Typed access to The amount due from the patient for the cost category. (defined for API consistency)
    property value : TFhirDataType read FValue write SetValue;
    // The amount due from the patient for the cost category.
    property valueElement : TFhirDataType read FValue write SetValue;

    // A suite of codes indicating exceptions or reductions to patient costs and their effective periods.
    property exceptionList : TFhirCoverageCostToBeneficiaryExceptionList read GetExceptionList;
    property hasExceptionList : boolean read GetHasExceptionList;

  end;

  TFhirCoverageCostToBeneficiaryListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirCoverageCostToBeneficiaryList;
    function GetCurrent : TFhirCoverageCostToBeneficiary;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirCoverageCostToBeneficiaryList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirCoverageCostToBeneficiary read GetCurrent;
  end;

  TFhirCoverageCostToBeneficiaryList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirCoverageCostToBeneficiary;
    procedure SetItemN(index : Integer; value : TFhirCoverageCostToBeneficiary);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirCoverageCostToBeneficiaryList; overload;
    function Clone : TFhirCoverageCostToBeneficiaryList; overload;
    function GetEnumerator : TFhirCoverageCostToBeneficiaryListEnumerator;
    
    //  Add a FhirCoverageCostToBeneficiary to the end of the list.
    function Append : TFhirCoverageCostToBeneficiary;
    
    // Add an already existing FhirCoverageCostToBeneficiary to the end of the list.
    procedure AddItem(value : TFhirCoverageCostToBeneficiary); overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirCoverageCostToBeneficiary) : Integer;
    
    // Insert FhirCoverageCostToBeneficiary before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirCoverageCostToBeneficiary;
    
    // Insert an existing FhirCoverageCostToBeneficiary before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirCoverageCostToBeneficiary);
    
    // Get the iIndexth FhirCoverageCostToBeneficiary. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirCoverageCostToBeneficiary);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirCoverageCostToBeneficiary;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirCoverageCostToBeneficiaries[index : Integer] : TFhirCoverageCostToBeneficiary read GetItemN write SetItemN; default;
  End;

  // A suite of codes indicating exceptions or reductions to patient costs and their effective periods.
  TFhirCoverageCostToBeneficiaryException = class (TFhirBackboneElement)
  protected
    FType_ : TFhirCodeableConcept;
    FPeriod : TFhirPeriod;
    procedure SetType_(value : TFhirCodeableConcept);
    procedure SetPeriod(value : TFhirPeriod);
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirCoverageCostToBeneficiaryException; overload;
    function Clone : TFhirCoverageCostToBeneficiaryException; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to The code for the specific exception. (defined for API consistency)
    property type_ : TFhirCodeableConcept read FType_ write SetType_;
    // The code for the specific exception.
    property type_Element : TFhirCodeableConcept read FType_ write SetType_;

    // Typed access to The timeframe the exception is in force. (defined for API consistency)
    property period : TFhirPeriod read FPeriod write SetPeriod;
    // The timeframe the exception is in force.
    property periodElement : TFhirPeriod read FPeriod write SetPeriod;

  end;

  TFhirCoverageCostToBeneficiaryExceptionListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirCoverageCostToBeneficiaryExceptionList;
    function GetCurrent : TFhirCoverageCostToBeneficiaryException;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirCoverageCostToBeneficiaryExceptionList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirCoverageCostToBeneficiaryException read GetCurrent;
  end;

  TFhirCoverageCostToBeneficiaryExceptionList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirCoverageCostToBeneficiaryException;
    procedure SetItemN(index : Integer; value : TFhirCoverageCostToBeneficiaryException);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirCoverageCostToBeneficiaryExceptionList; overload;
    function Clone : TFhirCoverageCostToBeneficiaryExceptionList; overload;
    function GetEnumerator : TFhirCoverageCostToBeneficiaryExceptionListEnumerator;
    
    //  Add a FhirCoverageCostToBeneficiaryException to the end of the list.
    function Append : TFhirCoverageCostToBeneficiaryException;
    
    // Add an already existing FhirCoverageCostToBeneficiaryException to the end of the list.
    procedure AddItem(value : TFhirCoverageCostToBeneficiaryException); overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirCoverageCostToBeneficiaryException) : Integer;
    
    // Insert FhirCoverageCostToBeneficiaryException before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirCoverageCostToBeneficiaryException;
    
    // Insert an existing FhirCoverageCostToBeneficiaryException before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirCoverageCostToBeneficiaryException);
    
    // Get the iIndexth FhirCoverageCostToBeneficiaryException. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirCoverageCostToBeneficiaryException);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirCoverageCostToBeneficiaryException;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirCoverageCostToBeneficiaryExceptions[index : Integer] : TFhirCoverageCostToBeneficiaryException read GetItemN write SetItemN; default;
  End;

  // Financial instrument which may be used to reimburse or pay for health care products and services. Includes both insurance and self-payment.
  TFhirCoverage = class (TFhirDomainResource)
  protected
    FidentifierList : TFhirIdentifierList;
    FStatus : TFhirEnum;
    FType_ : TFhirCodeableConcept;
    FPolicyHolder : TFhirReference;
    FSubscriber : TFhirReference;
    FSubscriberId : TFhirIdentifier;
    FBeneficiary : TFhirReference;
    FDependent : TFhirString;
    FRelationship : TFhirCodeableConcept;
    FPeriod : TFhirPeriod;
    FpayorList : TFhirReferenceList;
    Fclass_List : TFhirCoverageClassList;
    FOrder : TFhirPositiveInt;
    FNetwork : TFhirString;
    FcostToBeneficiaryList : TFhirCoverageCostToBeneficiaryList;
    FSubrogation : TFhirBoolean;
    FcontractList : TFhirReferenceList;
    function GetIdentifierList : TFhirIdentifierList;
    function GetHasIdentifierList : Boolean;
    procedure SetStatus(value : TFhirEnum);
    function GetStatusST : TFhirFinancialResourceStatusCodesEnum;
    procedure SetStatusST(value : TFhirFinancialResourceStatusCodesEnum);
    procedure SetType_(value : TFhirCodeableConcept);
    procedure SetPolicyHolder(value : TFhirReference);
    procedure SetSubscriber(value : TFhirReference);
    procedure SetSubscriberId(value : TFhirIdentifier);
    procedure SetBeneficiary(value : TFhirReference);
    procedure SetDependent(value : TFhirString);
    function GetDependentST : String;
    procedure SetDependentST(value : String);
    procedure SetRelationship(value : TFhirCodeableConcept);
    procedure SetPeriod(value : TFhirPeriod);
    function GetPayorList : TFhirReferenceList;
    function GetHasPayorList : Boolean;
    function GetClass_List : TFhirCoverageClassList;
    function GetHasClass_List : Boolean;
    procedure SetOrder(value : TFhirPositiveInt);
    function GetOrderST : String;
    procedure SetOrderST(value : String);
    procedure SetNetwork(value : TFhirString);
    function GetNetworkST : String;
    procedure SetNetworkST(value : String);
    function GetCostToBeneficiaryList : TFhirCoverageCostToBeneficiaryList;
    function GetHasCostToBeneficiaryList : Boolean;
    procedure SetSubrogation(value : TFhirBoolean);
    function GetSubrogationST : Boolean;
    procedure SetSubrogationST(value : Boolean);
    function GetContractList : TFhirReferenceList;
    function GetHasContractList : Boolean;
  
    function GetResourceType : TFhirResourceType; override;
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirCoverage; overload;
    function Clone : TFhirCoverage; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // A unique identifier assigned to this coverage.
    property identifierList : TFhirIdentifierList read GetIdentifierList;
    property hasIdentifierList : boolean read GetHasIdentifierList;

    // The status of the resource instance.
    property status : TFhirFinancialResourceStatusCodesEnum read GetStatusST write SetStatusST;
    property statusElement : TFhirEnum read FStatus write SetStatus;

    // Typed access to The type of coverage: social program, medical plan, accident coverage (workers compensation, auto), group health or payment by an individual or organization. (defined for API consistency)
    property type_ : TFhirCodeableConcept read FType_ write SetType_;
    // The type of coverage: social program, medical plan, accident coverage (workers compensation, auto), group health or payment by an individual or organization.
    property type_Element : TFhirCodeableConcept read FType_ write SetType_;

    // Typed access to The party who 'owns' the insurance policy. (defined for API consistency)
    property policyHolder : TFhirReference read FPolicyHolder write SetPolicyHolder;
    // The party who 'owns' the insurance policy.
    property policyHolderElement : TFhirReference read FPolicyHolder write SetPolicyHolder;

    // Typed access to The party who has signed-up for or 'owns' the contractual relationship to the policy or to whom the benefit of the policy for services rendered to them or their family is due. (defined for API consistency)
    property subscriber : TFhirReference read FSubscriber write SetSubscriber;
    // The party who has signed-up for or 'owns' the contractual relationship to the policy or to whom the benefit of the policy for services rendered to them or their family is due.
    property subscriberElement : TFhirReference read FSubscriber write SetSubscriber;

    // Typed access to The insurer assigned ID for the Subscriber. (defined for API consistency)
    property subscriberId : TFhirIdentifier read FSubscriberId write SetSubscriberId;
    // The insurer assigned ID for the Subscriber.
    property subscriberIdElement : TFhirIdentifier read FSubscriberId write SetSubscriberId;

    // Typed access to The party who benefits from the insurance coverage; the patient when products and/or services are provided. (defined for API consistency)
    property beneficiary : TFhirReference read FBeneficiary write SetBeneficiary;
    // The party who benefits from the insurance coverage; the patient when products and/or services are provided.
    property beneficiaryElement : TFhirReference read FBeneficiary write SetBeneficiary;

    // Typed access to A designator for a dependent under the coverage.
    property dependent : String read GetDependentST write SetDependentST;
    // A designator for a dependent under the coverage.
    property dependentElement : TFhirString read FDependent write SetDependent;

    // Typed access to The relationship of beneficiary (patient) to the subscriber. (defined for API consistency)
    property relationship : TFhirCodeableConcept read FRelationship write SetRelationship;
    // The relationship of beneficiary (patient) to the subscriber.
    property relationshipElement : TFhirCodeableConcept read FRelationship write SetRelationship;

    // Typed access to Time period during which the coverage is in force. A missing start date indicates the start date isn't known, a missing end date means the coverage is continuing to be in force. (defined for API consistency)
    property period : TFhirPeriod read FPeriod write SetPeriod;
    // Time period during which the coverage is in force. A missing start date indicates the start date isn't known, a missing end date means the coverage is continuing to be in force.
    property periodElement : TFhirPeriod read FPeriod write SetPeriod;

    // The program or plan underwriter or payor including both insurance and non-insurance agreements, such as patient-pay agreements.
    property payorList : TFhirReferenceList read GetPayorList;
    property hasPayorList : boolean read GetHasPayorList;

    // A suite of underwriter specific classifiers.
    property class_List : TFhirCoverageClassList read GetClass_List;
    property hasClass_List : boolean read GetHasClass_List;

    // Typed access to The order of applicability of this coverage relative to other coverages which are currently in force. Note, there may be gaps in the numbering and this does not imply primary, secondary etc. as the specific positioning of coverages depends upon the episode of care.
    property order : String read GetOrderST write SetOrderST;
    // The order of applicability of this coverage relative to other coverages which are currently in force. Note, there may be gaps in the numbering and this does not imply primary, secondary etc. as the specific positioning of coverages depends upon the episode of care.
    property orderElement : TFhirPositiveInt read FOrder write SetOrder;

    // Typed access to The insurer-specific identifier for the insurer-defined network of providers to which the beneficiary may seek treatment which will be covered at the 'in-network' rate, otherwise 'out of network' terms and conditions apply.
    property network : String read GetNetworkST write SetNetworkST;
    // The insurer-specific identifier for the insurer-defined network of providers to which the beneficiary may seek treatment which will be covered at the 'in-network' rate, otherwise 'out of network' terms and conditions apply.
    property networkElement : TFhirString read FNetwork write SetNetwork;

    // A suite of codes indicating the cost category and associated amount which have been detailed in the policy and may have been  included on the health card.
    property costToBeneficiaryList : TFhirCoverageCostToBeneficiaryList read GetCostToBeneficiaryList;
    property hasCostToBeneficiaryList : boolean read GetHasCostToBeneficiaryList;

    // Typed access to When 'subrogation=true' this insurance instance has been included not for adjudication but to provide insurers with the details to recover costs.
    property subrogation : Boolean read GetSubrogationST write SetSubrogationST;
    // When 'subrogation=true' this insurance instance has been included not for adjudication but to provide insurers with the details to recover costs.
    property subrogationElement : TFhirBoolean read FSubrogation write SetSubrogation;

    // The policy(s) which constitute this insurance coverage.
    property contractList : TFhirReferenceList read GetContractList;
    property hasContractList : boolean read GetHasContractList;

  end;

  TFhirCoverageListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirCoverageList;
    function GetCurrent : TFhirCoverage;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirCoverageList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirCoverage read GetCurrent;
  end;

  TFhirCoverageList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirCoverage;
    procedure SetItemN(index : Integer; value : TFhirCoverage);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirCoverageList; overload;
    function Clone : TFhirCoverageList; overload;
    function GetEnumerator : TFhirCoverageListEnumerator;
    
    //  Add a FhirCoverage to the end of the list.
    function Append : TFhirCoverage;
    
    // Add an already existing FhirCoverage to the end of the list.
    procedure AddItem(value : TFhirCoverage); overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirCoverage) : Integer;
    
    // Insert FhirCoverage before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirCoverage;
    
    // Insert an existing FhirCoverage before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirCoverage);
    
    // Get the iIndexth FhirCoverage. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirCoverage);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirCoverage;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirCoverages[index : Integer] : TFhirCoverage read GetItemN write SetItemN; default;
  End;

{$ENDIF FHIR_COVERAGE}
{$IFDEF FHIR_COVERAGEELIGIBILITYREQUEST}
  // Additional information codes regarding exceptions, special considerations, the condition, situation, prior or concurrent issues.
  TFhirCoverageEligibilityRequestSupportingInfo = class (TFhirBackboneElement)
  protected
    FSequence : TFhirPositiveInt;
    FInformation : TFhirReference;
    FAppliesToAll : TFhirBoolean;
    procedure SetSequence(value : TFhirPositiveInt);
    function GetSequenceST : String;
    procedure SetSequenceST(value : String);
    procedure SetInformation(value : TFhirReference);
    procedure SetAppliesToAll(value : TFhirBoolean);
    function GetAppliesToAllST : Boolean;
    procedure SetAppliesToAllST(value : Boolean);
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirCoverageEligibilityRequestSupportingInfo; overload;
    function Clone : TFhirCoverageEligibilityRequestSupportingInfo; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to A number to uniquely identify supporting information entries.
    property sequence : String read GetSequenceST write SetSequenceST;
    // A number to uniquely identify supporting information entries.
    property sequenceElement : TFhirPositiveInt read FSequence write SetSequence;

    // Typed access to Additional data or information such as resources, documents, images etc. including references to the data or the actual inclusion of the data. (defined for API consistency)
    property information : TFhirReference read FInformation write SetInformation;
    // Additional data or information such as resources, documents, images etc. including references to the data or the actual inclusion of the data.
    property informationElement : TFhirReference read FInformation write SetInformation;

    // Typed access to The supporting materials are applicable for all detail items, product/servce categories and specific billing codes.
    property appliesToAll : Boolean read GetAppliesToAllST write SetAppliesToAllST;
    // The supporting materials are applicable for all detail items, product/servce categories and specific billing codes.
    property appliesToAllElement : TFhirBoolean read FAppliesToAll write SetAppliesToAll;

  end;

  TFhirCoverageEligibilityRequestSupportingInfoListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirCoverageEligibilityRequestSupportingInfoList;
    function GetCurrent : TFhirCoverageEligibilityRequestSupportingInfo;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirCoverageEligibilityRequestSupportingInfoList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirCoverageEligibilityRequestSupportingInfo read GetCurrent;
  end;

  TFhirCoverageEligibilityRequestSupportingInfoList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirCoverageEligibilityRequestSupportingInfo;
    procedure SetItemN(index : Integer; value : TFhirCoverageEligibilityRequestSupportingInfo);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirCoverageEligibilityRequestSupportingInfoList; overload;
    function Clone : TFhirCoverageEligibilityRequestSupportingInfoList; overload;
    function GetEnumerator : TFhirCoverageEligibilityRequestSupportingInfoListEnumerator;
    
    //  Add a FhirCoverageEligibilityRequestSupportingInfo to the end of the list.
    function Append : TFhirCoverageEligibilityRequestSupportingInfo;
    
    // Add an already existing FhirCoverageEligibilityRequestSupportingInfo to the end of the list.
    procedure AddItem(value : TFhirCoverageEligibilityRequestSupportingInfo); overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirCoverageEligibilityRequestSupportingInfo) : Integer;
    
    // Insert FhirCoverageEligibilityRequestSupportingInfo before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirCoverageEligibilityRequestSupportingInfo;
    
    // Insert an existing FhirCoverageEligibilityRequestSupportingInfo before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirCoverageEligibilityRequestSupportingInfo);
    
    // Get the iIndexth FhirCoverageEligibilityRequestSupportingInfo. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirCoverageEligibilityRequestSupportingInfo);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirCoverageEligibilityRequestSupportingInfo;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirCoverageEligibilityRequestSupportingInfos[index : Integer] : TFhirCoverageEligibilityRequestSupportingInfo read GetItemN write SetItemN; default;
  End;

  // Financial instruments for reimbursement for the health care products and services.
  TFhirCoverageEligibilityRequestInsurance = class (TFhirBackboneElement)
  protected
    FFocal : TFhirBoolean;
    FCoverage : TFhirReference;
    FBusinessArrangement : TFhirString;
    procedure SetFocal(value : TFhirBoolean);
    function GetFocalST : Boolean;
    procedure SetFocalST(value : Boolean);
    procedure SetCoverage(value : TFhirReference);
    procedure SetBusinessArrangement(value : TFhirString);
    function GetBusinessArrangementST : String;
    procedure SetBusinessArrangementST(value : String);
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirCoverageEligibilityRequestInsurance; overload;
    function Clone : TFhirCoverageEligibilityRequestInsurance; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to A flag to indicate that this Coverage is to be used for evaluation of this request when set to true.
    property focal : Boolean read GetFocalST write SetFocalST;
    // A flag to indicate that this Coverage is to be used for evaluation of this request when set to true.
    property focalElement : TFhirBoolean read FFocal write SetFocal;

    // Typed access to Reference to the insurance card level information contained in the Coverage resource. The coverage issuing insurer will use these details to locate the patient's actual coverage within the insurer's information system. (defined for API consistency)
    property coverage : TFhirReference read FCoverage write SetCoverage;
    // Reference to the insurance card level information contained in the Coverage resource. The coverage issuing insurer will use these details to locate the patient's actual coverage within the insurer's information system.
    property coverageElement : TFhirReference read FCoverage write SetCoverage;

    // Typed access to A business agreement number established between the provider and the insurer for special business processing purposes.
    property businessArrangement : String read GetBusinessArrangementST write SetBusinessArrangementST;
    // A business agreement number established between the provider and the insurer for special business processing purposes.
    property businessArrangementElement : TFhirString read FBusinessArrangement write SetBusinessArrangement;

  end;

  TFhirCoverageEligibilityRequestInsuranceListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirCoverageEligibilityRequestInsuranceList;
    function GetCurrent : TFhirCoverageEligibilityRequestInsurance;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirCoverageEligibilityRequestInsuranceList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirCoverageEligibilityRequestInsurance read GetCurrent;
  end;

  TFhirCoverageEligibilityRequestInsuranceList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirCoverageEligibilityRequestInsurance;
    procedure SetItemN(index : Integer; value : TFhirCoverageEligibilityRequestInsurance);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirCoverageEligibilityRequestInsuranceList; overload;
    function Clone : TFhirCoverageEligibilityRequestInsuranceList; overload;
    function GetEnumerator : TFhirCoverageEligibilityRequestInsuranceListEnumerator;
    
    //  Add a FhirCoverageEligibilityRequestInsurance to the end of the list.
    function Append : TFhirCoverageEligibilityRequestInsurance;
    
    // Add an already existing FhirCoverageEligibilityRequestInsurance to the end of the list.
    procedure AddItem(value : TFhirCoverageEligibilityRequestInsurance); overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirCoverageEligibilityRequestInsurance) : Integer;
    
    // Insert FhirCoverageEligibilityRequestInsurance before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirCoverageEligibilityRequestInsurance;
    
    // Insert an existing FhirCoverageEligibilityRequestInsurance before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirCoverageEligibilityRequestInsurance);
    
    // Get the iIndexth FhirCoverageEligibilityRequestInsurance. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirCoverageEligibilityRequestInsurance);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirCoverageEligibilityRequestInsurance;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirCoverageEligibilityRequestInsurances[index : Integer] : TFhirCoverageEligibilityRequestInsurance read GetItemN write SetItemN; default;
  End;

  // Service categories or billable services for which benefit details and/or an authorization prior to service delivery may be required by the payor.
  TFhirCoverageEligibilityRequestItem = class (TFhirBackboneElement)
  protected
    FsupportingInfoSequenceList : TFhirPositiveIntList;
    FCategory : TFhirCodeableConcept;
    FProductOrService : TFhirCodeableConcept;
    FmodifierList : TFhirCodeableConceptList;
    FProvider : TFhirReference;
    FQuantity : TFhirQuantity;
    FUnitPrice : TFhirMoney;
    FFacility : TFhirReference;
    FdiagnosisList : TFhirCoverageEligibilityRequestItemDiagnosisList;
    FdetailList : TFhirReferenceList;
    function GetSupportingInfoSequenceList : TFhirPositiveIntList;
    function GetHasSupportingInfoSequenceList : Boolean;
    procedure SetCategory(value : TFhirCodeableConcept);
    procedure SetProductOrService(value : TFhirCodeableConcept);
    function GetModifierList : TFhirCodeableConceptList;
    function GetHasModifierList : Boolean;
    procedure SetProvider(value : TFhirReference);
    procedure SetQuantity(value : TFhirQuantity);
    procedure SetUnitPrice(value : TFhirMoney);
    procedure SetFacility(value : TFhirReference);
    function GetDiagnosisList : TFhirCoverageEligibilityRequestItemDiagnosisList;
    function GetHasDiagnosisList : Boolean;
    function GetDetailList : TFhirReferenceList;
    function GetHasDetailList : Boolean;
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirCoverageEligibilityRequestItem; overload;
    function Clone : TFhirCoverageEligibilityRequestItem; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Exceptions, special conditions and supporting information applicable for this service or product line.
    property supportingInfoSequenceList : TFhirPositiveIntList read GetSupportingInfoSequenceList;
    property hasSupportingInfoSequenceList : boolean read GetHasSupportingInfoSequenceList;

    // Typed access to Code to identify the general type of benefits under which products and services are provided. (defined for API consistency)
    property category : TFhirCodeableConcept read FCategory write SetCategory;
    // Code to identify the general type of benefits under which products and services are provided.
    property categoryElement : TFhirCodeableConcept read FCategory write SetCategory;

    // Typed access to This contains the product, service, drug or other billing code for the item. (defined for API consistency)
    property productOrService : TFhirCodeableConcept read FProductOrService write SetProductOrService;
    // This contains the product, service, drug or other billing code for the item.
    property productOrServiceElement : TFhirCodeableConcept read FProductOrService write SetProductOrService;

    // Item typification or modifiers codes to convey additional context for the product or service.
    property modifierList : TFhirCodeableConceptList read GetModifierList;
    property hasModifierList : boolean read GetHasModifierList;

    // Typed access to The practitioner who is responsible for the product or service to be rendered to the patient. (defined for API consistency)
    property provider : TFhirReference read FProvider write SetProvider;
    // The practitioner who is responsible for the product or service to be rendered to the patient.
    property providerElement : TFhirReference read FProvider write SetProvider;

    // Typed access to The number of repetitions of a service or product. (defined for API consistency)
    property quantity : TFhirQuantity read FQuantity write SetQuantity;
    // The number of repetitions of a service or product.
    property quantityElement : TFhirQuantity read FQuantity write SetQuantity;

    // Typed access to The amount charged to the patient by the provider for a single unit. (defined for API consistency)
    property unitPrice : TFhirMoney read FUnitPrice write SetUnitPrice;
    // The amount charged to the patient by the provider for a single unit.
    property unitPriceElement : TFhirMoney read FUnitPrice write SetUnitPrice;

    // Typed access to Facility where the services will be provided. (defined for API consistency)
    property facility : TFhirReference read FFacility write SetFacility;
    // Facility where the services will be provided.
    property facilityElement : TFhirReference read FFacility write SetFacility;

    // Patient diagnosis for which care is sought.
    property diagnosisList : TFhirCoverageEligibilityRequestItemDiagnosisList read GetDiagnosisList;
    property hasDiagnosisList : boolean read GetHasDiagnosisList;

    // The plan/proposal/order describing the proposed service in detail.
    property detailList : TFhirReferenceList read GetDetailList;
    property hasDetailList : boolean read GetHasDetailList;

  end;

  TFhirCoverageEligibilityRequestItemListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirCoverageEligibilityRequestItemList;
    function GetCurrent : TFhirCoverageEligibilityRequestItem;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirCoverageEligibilityRequestItemList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirCoverageEligibilityRequestItem read GetCurrent;
  end;

  TFhirCoverageEligibilityRequestItemList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirCoverageEligibilityRequestItem;
    procedure SetItemN(index : Integer; value : TFhirCoverageEligibilityRequestItem);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirCoverageEligibilityRequestItemList; overload;
    function Clone : TFhirCoverageEligibilityRequestItemList; overload;
    function GetEnumerator : TFhirCoverageEligibilityRequestItemListEnumerator;
    
    //  Add a FhirCoverageEligibilityRequestItem to the end of the list.
    function Append : TFhirCoverageEligibilityRequestItem;
    
    // Add an already existing FhirCoverageEligibilityRequestItem to the end of the list.
    procedure AddItem(value : TFhirCoverageEligibilityRequestItem); overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirCoverageEligibilityRequestItem) : Integer;
    
    // Insert FhirCoverageEligibilityRequestItem before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirCoverageEligibilityRequestItem;
    
    // Insert an existing FhirCoverageEligibilityRequestItem before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirCoverageEligibilityRequestItem);
    
    // Get the iIndexth FhirCoverageEligibilityRequestItem. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirCoverageEligibilityRequestItem);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirCoverageEligibilityRequestItem;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirCoverageEligibilityRequestItems[index : Integer] : TFhirCoverageEligibilityRequestItem read GetItemN write SetItemN; default;
  End;

  // Patient diagnosis for which care is sought.
  TFhirCoverageEligibilityRequestItemDiagnosis = class (TFhirBackboneElement)
  protected
    FDiagnosis : TFhirDataType;
    procedure SetDiagnosis(value : TFhirDataType);
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirCoverageEligibilityRequestItemDiagnosis; overload;
    function Clone : TFhirCoverageEligibilityRequestItemDiagnosis; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to The nature of illness or problem in a coded form or as a reference to an external defined Condition. (defined for API consistency)
    property diagnosis : TFhirDataType read FDiagnosis write SetDiagnosis;
    // The nature of illness or problem in a coded form or as a reference to an external defined Condition.
    property diagnosisElement : TFhirDataType read FDiagnosis write SetDiagnosis;

  end;

  TFhirCoverageEligibilityRequestItemDiagnosisListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirCoverageEligibilityRequestItemDiagnosisList;
    function GetCurrent : TFhirCoverageEligibilityRequestItemDiagnosis;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirCoverageEligibilityRequestItemDiagnosisList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirCoverageEligibilityRequestItemDiagnosis read GetCurrent;
  end;

  TFhirCoverageEligibilityRequestItemDiagnosisList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirCoverageEligibilityRequestItemDiagnosis;
    procedure SetItemN(index : Integer; value : TFhirCoverageEligibilityRequestItemDiagnosis);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirCoverageEligibilityRequestItemDiagnosisList; overload;
    function Clone : TFhirCoverageEligibilityRequestItemDiagnosisList; overload;
    function GetEnumerator : TFhirCoverageEligibilityRequestItemDiagnosisListEnumerator;
    
    //  Add a FhirCoverageEligibilityRequestItemDiagnosis to the end of the list.
    function Append : TFhirCoverageEligibilityRequestItemDiagnosis;
    
    // Add an already existing FhirCoverageEligibilityRequestItemDiagnosis to the end of the list.
    procedure AddItem(value : TFhirCoverageEligibilityRequestItemDiagnosis); overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirCoverageEligibilityRequestItemDiagnosis) : Integer;
    
    // Insert FhirCoverageEligibilityRequestItemDiagnosis before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirCoverageEligibilityRequestItemDiagnosis;
    
    // Insert an existing FhirCoverageEligibilityRequestItemDiagnosis before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirCoverageEligibilityRequestItemDiagnosis);
    
    // Get the iIndexth FhirCoverageEligibilityRequestItemDiagnosis. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirCoverageEligibilityRequestItemDiagnosis);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirCoverageEligibilityRequestItemDiagnosis;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirCoverageEligibilityRequestItemDiagnoses[index : Integer] : TFhirCoverageEligibilityRequestItemDiagnosis read GetItemN write SetItemN; default;
  End;

  // The CoverageEligibilityRequest provides patient and insurance coverage information to an insurer for them to respond, in the form of an CoverageEligibilityResponse, with information regarding whether the stated coverage is valid and in-force and optionally to provide the insurance details of the policy.
  TFhirCoverageEligibilityRequest = class (TFhirDomainResource)
  protected
    FidentifierList : TFhirIdentifierList;
    FStatus : TFhirEnum;
    FPriority : TFhirCodeableConcept;
    FPurpose : TFhirEnumList;
    FPatient : TFhirReference;
    FServiced : TFhirDataType;
    FCreated : TFhirDateTime;
    FEnterer : TFhirReference;
    FProvider : TFhirReference;
    FInsurer : TFhirReference;
    FFacility : TFhirReference;
    FsupportingInfoList : TFhirCoverageEligibilityRequestSupportingInfoList;
    FinsuranceList : TFhirCoverageEligibilityRequestInsuranceList;
    FitemList : TFhirCoverageEligibilityRequestItemList;
    function GetIdentifierList : TFhirIdentifierList;
    function GetHasIdentifierList : Boolean;
    procedure SetStatus(value : TFhirEnum);
    function GetStatusST : TFhirFinancialResourceStatusCodesEnum;
    procedure SetStatusST(value : TFhirFinancialResourceStatusCodesEnum);
    procedure SetPriority(value : TFhirCodeableConcept);
    function GetPurpose : TFhirEnumList;
    function GetHasPurpose : Boolean;
    function GetPurposeST : TFhirEligibilityRequestPurposeEnumList;
    procedure SetPurposeST(value : TFhirEligibilityRequestPurposeEnumList);
    procedure SetPatient(value : TFhirReference);
    procedure SetServiced(value : TFhirDataType);
    procedure SetCreated(value : TFhirDateTime);
    function GetCreatedST : TFslDateTime;
    procedure SetCreatedST(value : TFslDateTime);
    procedure SetEnterer(value : TFhirReference);
    procedure SetProvider(value : TFhirReference);
    procedure SetInsurer(value : TFhirReference);
    procedure SetFacility(value : TFhirReference);
    function GetSupportingInfoList : TFhirCoverageEligibilityRequestSupportingInfoList;
    function GetHasSupportingInfoList : Boolean;
    function GetInsuranceList : TFhirCoverageEligibilityRequestInsuranceList;
    function GetHasInsuranceList : Boolean;
    function GetItemList : TFhirCoverageEligibilityRequestItemList;
    function GetHasItemList : Boolean;
  
    function GetResourceType : TFhirResourceType; override;
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirCoverageEligibilityRequest; overload;
    function Clone : TFhirCoverageEligibilityRequest; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // A unique identifier assigned to this coverage eligiblity request.
    property identifierList : TFhirIdentifierList read GetIdentifierList;
    property hasIdentifierList : boolean read GetHasIdentifierList;

    // The status of the resource instance.
    property status : TFhirFinancialResourceStatusCodesEnum read GetStatusST write SetStatusST;
    property statusElement : TFhirEnum read FStatus write SetStatus;

    // Typed access to When the requestor expects the processor to complete processing. (defined for API consistency)
    property priority : TFhirCodeableConcept read FPriority write SetPriority;
    // When the requestor expects the processor to complete processing.
    property priorityElement : TFhirCodeableConcept read FPriority write SetPriority;

    // Code to specify whether requesting: prior authorization requirements for some service categories or billing codes; benefits for coverages specified or discovered; discovery and return of coverages for the patient; and/or validation that the specified coverage is in-force at the date/period specified or 'now' if not specified.
    property purpose : TFhirEligibilityRequestPurposeEnumList read GetPurposeST write SetPurposeST;
    property purposeList : TFhirEnumList read GetPurpose;
    property hasPurpose : boolean read GetHasPurpose;
    // Typed access to The party who is the beneficiary of the supplied coverage and for whom eligibility is sought. (defined for API consistency)
    property patient : TFhirReference read FPatient write SetPatient;
    // The party who is the beneficiary of the supplied coverage and for whom eligibility is sought.
    property patientElement : TFhirReference read FPatient write SetPatient;

    // Typed access to The date or dates when the enclosed suite of services were performed or completed. (defined for API consistency)
    property serviced : TFhirDataType read FServiced write SetServiced;
    // The date or dates when the enclosed suite of services were performed or completed.
    property servicedElement : TFhirDataType read FServiced write SetServiced;

    // Typed access to The date when this resource was created.
    property created : TFslDateTime read GetCreatedST write SetCreatedST;
    // The date when this resource was created.
    property createdElement : TFhirDateTime read FCreated write SetCreated;

    // Typed access to Person who created the request. (defined for API consistency)
    property enterer : TFhirReference read FEnterer write SetEnterer;
    // Person who created the request.
    property entererElement : TFhirReference read FEnterer write SetEnterer;

    // Typed access to The provider which is responsible for the request. (defined for API consistency)
    property provider : TFhirReference read FProvider write SetProvider;
    // The provider which is responsible for the request.
    property providerElement : TFhirReference read FProvider write SetProvider;

    // Typed access to The Insurer who issued the coverage in question and is the recipient of the request. (defined for API consistency)
    property insurer : TFhirReference read FInsurer write SetInsurer;
    // The Insurer who issued the coverage in question and is the recipient of the request.
    property insurerElement : TFhirReference read FInsurer write SetInsurer;

    // Typed access to Facility where the services are intended to be provided. (defined for API consistency)
    property facility : TFhirReference read FFacility write SetFacility;
    // Facility where the services are intended to be provided.
    property facilityElement : TFhirReference read FFacility write SetFacility;

    // Additional information codes regarding exceptions, special considerations, the condition, situation, prior or concurrent issues.
    property supportingInfoList : TFhirCoverageEligibilityRequestSupportingInfoList read GetSupportingInfoList;
    property hasSupportingInfoList : boolean read GetHasSupportingInfoList;

    // Financial instruments for reimbursement for the health care products and services.
    property insuranceList : TFhirCoverageEligibilityRequestInsuranceList read GetInsuranceList;
    property hasInsuranceList : boolean read GetHasInsuranceList;

    // Service categories or billable services for which benefit details and/or an authorization prior to service delivery may be required by the payor.
    property itemList : TFhirCoverageEligibilityRequestItemList read GetItemList;
    property hasItemList : boolean read GetHasItemList;

  end;

  TFhirCoverageEligibilityRequestListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirCoverageEligibilityRequestList;
    function GetCurrent : TFhirCoverageEligibilityRequest;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirCoverageEligibilityRequestList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirCoverageEligibilityRequest read GetCurrent;
  end;

  TFhirCoverageEligibilityRequestList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirCoverageEligibilityRequest;
    procedure SetItemN(index : Integer; value : TFhirCoverageEligibilityRequest);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirCoverageEligibilityRequestList; overload;
    function Clone : TFhirCoverageEligibilityRequestList; overload;
    function GetEnumerator : TFhirCoverageEligibilityRequestListEnumerator;
    
    //  Add a FhirCoverageEligibilityRequest to the end of the list.
    function Append : TFhirCoverageEligibilityRequest;
    
    // Add an already existing FhirCoverageEligibilityRequest to the end of the list.
    procedure AddItem(value : TFhirCoverageEligibilityRequest); overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirCoverageEligibilityRequest) : Integer;
    
    // Insert FhirCoverageEligibilityRequest before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirCoverageEligibilityRequest;
    
    // Insert an existing FhirCoverageEligibilityRequest before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirCoverageEligibilityRequest);
    
    // Get the iIndexth FhirCoverageEligibilityRequest. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirCoverageEligibilityRequest);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirCoverageEligibilityRequest;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirCoverageEligibilityRequests[index : Integer] : TFhirCoverageEligibilityRequest read GetItemN write SetItemN; default;
  End;

{$ENDIF FHIR_COVERAGEELIGIBILITYREQUEST}
{$IFDEF FHIR_COVERAGEELIGIBILITYRESPONSE}
  // Financial instruments for reimbursement for the health care products and services.
  TFhirCoverageEligibilityResponseInsurance = class (TFhirBackboneElement)
  protected
    FCoverage : TFhirReference;
    FInforce : TFhirBoolean;
    FBenefitPeriod : TFhirPeriod;
    FitemList : TFhirCoverageEligibilityResponseInsuranceItemList;
    procedure SetCoverage(value : TFhirReference);
    procedure SetInforce(value : TFhirBoolean);
    function GetInforceST : Boolean;
    procedure SetInforceST(value : Boolean);
    procedure SetBenefitPeriod(value : TFhirPeriod);
    function GetItemList : TFhirCoverageEligibilityResponseInsuranceItemList;
    function GetHasItemList : Boolean;
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirCoverageEligibilityResponseInsurance; overload;
    function Clone : TFhirCoverageEligibilityResponseInsurance; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to Reference to the insurance card level information contained in the Coverage resource. The coverage issuing insurer will use these details to locate the patient's actual coverage within the insurer's information system. (defined for API consistency)
    property coverage : TFhirReference read FCoverage write SetCoverage;
    // Reference to the insurance card level information contained in the Coverage resource. The coverage issuing insurer will use these details to locate the patient's actual coverage within the insurer's information system.
    property coverageElement : TFhirReference read FCoverage write SetCoverage;

    // Typed access to Flag indicating if the coverage provided is inforce currently if no service date(s) specified or for the whole duration of the service dates.
    property inforce : Boolean read GetInforceST write SetInforceST;
    // Flag indicating if the coverage provided is inforce currently if no service date(s) specified or for the whole duration of the service dates.
    property inforceElement : TFhirBoolean read FInforce write SetInforce;

    // Typed access to The term of the benefits documented in this response. (defined for API consistency)
    property benefitPeriod : TFhirPeriod read FBenefitPeriod write SetBenefitPeriod;
    // The term of the benefits documented in this response.
    property benefitPeriodElement : TFhirPeriod read FBenefitPeriod write SetBenefitPeriod;

    // Benefits and optionally current balances, and authorization details by category or service.
    property itemList : TFhirCoverageEligibilityResponseInsuranceItemList read GetItemList;
    property hasItemList : boolean read GetHasItemList;

  end;

  TFhirCoverageEligibilityResponseInsuranceListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirCoverageEligibilityResponseInsuranceList;
    function GetCurrent : TFhirCoverageEligibilityResponseInsurance;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirCoverageEligibilityResponseInsuranceList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirCoverageEligibilityResponseInsurance read GetCurrent;
  end;

  TFhirCoverageEligibilityResponseInsuranceList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirCoverageEligibilityResponseInsurance;
    procedure SetItemN(index : Integer; value : TFhirCoverageEligibilityResponseInsurance);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirCoverageEligibilityResponseInsuranceList; overload;
    function Clone : TFhirCoverageEligibilityResponseInsuranceList; overload;
    function GetEnumerator : TFhirCoverageEligibilityResponseInsuranceListEnumerator;
    
    //  Add a FhirCoverageEligibilityResponseInsurance to the end of the list.
    function Append : TFhirCoverageEligibilityResponseInsurance;
    
    // Add an already existing FhirCoverageEligibilityResponseInsurance to the end of the list.
    procedure AddItem(value : TFhirCoverageEligibilityResponseInsurance); overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirCoverageEligibilityResponseInsurance) : Integer;
    
    // Insert FhirCoverageEligibilityResponseInsurance before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirCoverageEligibilityResponseInsurance;
    
    // Insert an existing FhirCoverageEligibilityResponseInsurance before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirCoverageEligibilityResponseInsurance);
    
    // Get the iIndexth FhirCoverageEligibilityResponseInsurance. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirCoverageEligibilityResponseInsurance);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirCoverageEligibilityResponseInsurance;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirCoverageEligibilityResponseInsurances[index : Integer] : TFhirCoverageEligibilityResponseInsurance read GetItemN write SetItemN; default;
  End;

  // Benefits and optionally current balances, and authorization details by category or service.
  TFhirCoverageEligibilityResponseInsuranceItem = class (TFhirBackboneElement)
  protected
    FCategory : TFhirCodeableConcept;
    FProductOrService : TFhirCodeableConcept;
    FmodifierList : TFhirCodeableConceptList;
    FProvider : TFhirReference;
    FExcluded : TFhirBoolean;
    FName : TFhirString;
    FDescription : TFhirString;
    FNetwork : TFhirCodeableConcept;
    FUnit_ : TFhirCodeableConcept;
    FTerm : TFhirCodeableConcept;
    FbenefitList : TFhirCoverageEligibilityResponseInsuranceItemBenefitList;
    FAuthorizationRequired : TFhirBoolean;
    FauthorizationSupportingList : TFhirCodeableConceptList;
    FAuthorizationUrl : TFhirUri;
    procedure SetCategory(value : TFhirCodeableConcept);
    procedure SetProductOrService(value : TFhirCodeableConcept);
    function GetModifierList : TFhirCodeableConceptList;
    function GetHasModifierList : Boolean;
    procedure SetProvider(value : TFhirReference);
    procedure SetExcluded(value : TFhirBoolean);
    function GetExcludedST : Boolean;
    procedure SetExcludedST(value : Boolean);
    procedure SetName(value : TFhirString);
    function GetNameST : String;
    procedure SetNameST(value : String);
    procedure SetDescription(value : TFhirString);
    function GetDescriptionST : String;
    procedure SetDescriptionST(value : String);
    procedure SetNetwork(value : TFhirCodeableConcept);
    procedure SetUnit_(value : TFhirCodeableConcept);
    procedure SetTerm(value : TFhirCodeableConcept);
    function GetBenefitList : TFhirCoverageEligibilityResponseInsuranceItemBenefitList;
    function GetHasBenefitList : Boolean;
    procedure SetAuthorizationRequired(value : TFhirBoolean);
    function GetAuthorizationRequiredST : Boolean;
    procedure SetAuthorizationRequiredST(value : Boolean);
    function GetAuthorizationSupportingList : TFhirCodeableConceptList;
    function GetHasAuthorizationSupportingList : Boolean;
    procedure SetAuthorizationUrl(value : TFhirUri);
    function GetAuthorizationUrlST : String;
    procedure SetAuthorizationUrlST(value : String);
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirCoverageEligibilityResponseInsuranceItem; overload;
    function Clone : TFhirCoverageEligibilityResponseInsuranceItem; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to Code to identify the general type of benefits under which products and services are provided. (defined for API consistency)
    property category : TFhirCodeableConcept read FCategory write SetCategory;
    // Code to identify the general type of benefits under which products and services are provided.
    property categoryElement : TFhirCodeableConcept read FCategory write SetCategory;

    // Typed access to This contains the product, service, drug or other billing code for the item. (defined for API consistency)
    property productOrService : TFhirCodeableConcept read FProductOrService write SetProductOrService;
    // This contains the product, service, drug or other billing code for the item.
    property productOrServiceElement : TFhirCodeableConcept read FProductOrService write SetProductOrService;

    // Item typification or modifiers codes to convey additional context for the product or service.
    property modifierList : TFhirCodeableConceptList read GetModifierList;
    property hasModifierList : boolean read GetHasModifierList;

    // Typed access to The practitioner who is eligible for the provision of the product or service. (defined for API consistency)
    property provider : TFhirReference read FProvider write SetProvider;
    // The practitioner who is eligible for the provision of the product or service.
    property providerElement : TFhirReference read FProvider write SetProvider;

    // Typed access to True if the indicated class of service is excluded from the plan, missing or False indicates the product or service is included in the coverage.
    property excluded : Boolean read GetExcludedST write SetExcludedST;
    // True if the indicated class of service is excluded from the plan, missing or False indicates the product or service is included in the coverage.
    property excludedElement : TFhirBoolean read FExcluded write SetExcluded;

    // Typed access to A short name or tag for the benefit.
    property name : String read GetNameST write SetNameST;
    // A short name or tag for the benefit.
    property nameElement : TFhirString read FName write SetName;

    // Typed access to A richer description of the benefit or services covered.
    property description : String read GetDescriptionST write SetDescriptionST;
    // A richer description of the benefit or services covered.
    property descriptionElement : TFhirString read FDescription write SetDescription;

    // Typed access to Is a flag to indicate whether the benefits refer to in-network providers or out-of-network providers. (defined for API consistency)
    property network : TFhirCodeableConcept read FNetwork write SetNetwork;
    // Is a flag to indicate whether the benefits refer to in-network providers or out-of-network providers.
    property networkElement : TFhirCodeableConcept read FNetwork write SetNetwork;

    // Typed access to Indicates if the benefits apply to an individual or to the family. (defined for API consistency)
    property unit_ : TFhirCodeableConcept read FUnit_ write SetUnit_;
    // Indicates if the benefits apply to an individual or to the family.
    property unit_Element : TFhirCodeableConcept read FUnit_ write SetUnit_;

    // Typed access to The term or period of the values such as 'maximum lifetime benefit' or 'maximum annual visits'. (defined for API consistency)
    property term : TFhirCodeableConcept read FTerm write SetTerm;
    // The term or period of the values such as 'maximum lifetime benefit' or 'maximum annual visits'.
    property termElement : TFhirCodeableConcept read FTerm write SetTerm;

    // Benefits used to date.
    property benefitList : TFhirCoverageEligibilityResponseInsuranceItemBenefitList read GetBenefitList;
    property hasBenefitList : boolean read GetHasBenefitList;

    // Typed access to A boolean flag indicating whether a preauthorization is required prior to actual service delivery.
    property authorizationRequired : Boolean read GetAuthorizationRequiredST write SetAuthorizationRequiredST;
    // A boolean flag indicating whether a preauthorization is required prior to actual service delivery.
    property authorizationRequiredElement : TFhirBoolean read FAuthorizationRequired write SetAuthorizationRequired;

    // Codes or comments regarding information or actions associated with the preauthorization.
    property authorizationSupportingList : TFhirCodeableConceptList read GetAuthorizationSupportingList;
    property hasAuthorizationSupportingList : boolean read GetHasAuthorizationSupportingList;

    // Typed access to A web location for obtaining requirements or descriptive information regarding the preauthorization.
    property authorizationUrl : String read GetAuthorizationUrlST write SetAuthorizationUrlST;
    // A web location for obtaining requirements or descriptive information regarding the preauthorization.
    property authorizationUrlElement : TFhirUri read FAuthorizationUrl write SetAuthorizationUrl;

  end;

  TFhirCoverageEligibilityResponseInsuranceItemListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirCoverageEligibilityResponseInsuranceItemList;
    function GetCurrent : TFhirCoverageEligibilityResponseInsuranceItem;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirCoverageEligibilityResponseInsuranceItemList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirCoverageEligibilityResponseInsuranceItem read GetCurrent;
  end;

  TFhirCoverageEligibilityResponseInsuranceItemList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirCoverageEligibilityResponseInsuranceItem;
    procedure SetItemN(index : Integer; value : TFhirCoverageEligibilityResponseInsuranceItem);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirCoverageEligibilityResponseInsuranceItemList; overload;
    function Clone : TFhirCoverageEligibilityResponseInsuranceItemList; overload;
    function GetEnumerator : TFhirCoverageEligibilityResponseInsuranceItemListEnumerator;
    
    //  Add a FhirCoverageEligibilityResponseInsuranceItem to the end of the list.
    function Append : TFhirCoverageEligibilityResponseInsuranceItem;
    
    // Add an already existing FhirCoverageEligibilityResponseInsuranceItem to the end of the list.
    procedure AddItem(value : TFhirCoverageEligibilityResponseInsuranceItem); overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirCoverageEligibilityResponseInsuranceItem) : Integer;
    
    // Insert FhirCoverageEligibilityResponseInsuranceItem before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirCoverageEligibilityResponseInsuranceItem;
    
    // Insert an existing FhirCoverageEligibilityResponseInsuranceItem before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirCoverageEligibilityResponseInsuranceItem);
    
    // Get the iIndexth FhirCoverageEligibilityResponseInsuranceItem. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirCoverageEligibilityResponseInsuranceItem);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirCoverageEligibilityResponseInsuranceItem;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirCoverageEligibilityResponseInsuranceItems[index : Integer] : TFhirCoverageEligibilityResponseInsuranceItem read GetItemN write SetItemN; default;
  End;

  // Benefits used to date.
  TFhirCoverageEligibilityResponseInsuranceItemBenefit = class (TFhirBackboneElement)
  protected
    FType_ : TFhirCodeableConcept;
    FAllowed : TFhirDataType;
    FUsed : TFhirDataType;
    procedure SetType_(value : TFhirCodeableConcept);
    procedure SetAllowed(value : TFhirDataType);
    procedure SetUsed(value : TFhirDataType);
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirCoverageEligibilityResponseInsuranceItemBenefit; overload;
    function Clone : TFhirCoverageEligibilityResponseInsuranceItemBenefit; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to Classification of benefit being provided. (defined for API consistency)
    property type_ : TFhirCodeableConcept read FType_ write SetType_;
    // Classification of benefit being provided.
    property type_Element : TFhirCodeableConcept read FType_ write SetType_;

    // Typed access to The quantity of the benefit which is permitted under the coverage. (defined for API consistency)
    property allowed : TFhirDataType read FAllowed write SetAllowed;
    // The quantity of the benefit which is permitted under the coverage.
    property allowedElement : TFhirDataType read FAllowed write SetAllowed;

    // Typed access to The quantity of the benefit which have been consumed to date. (defined for API consistency)
    property used : TFhirDataType read FUsed write SetUsed;
    // The quantity of the benefit which have been consumed to date.
    property usedElement : TFhirDataType read FUsed write SetUsed;

  end;

  TFhirCoverageEligibilityResponseInsuranceItemBenefitListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirCoverageEligibilityResponseInsuranceItemBenefitList;
    function GetCurrent : TFhirCoverageEligibilityResponseInsuranceItemBenefit;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirCoverageEligibilityResponseInsuranceItemBenefitList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirCoverageEligibilityResponseInsuranceItemBenefit read GetCurrent;
  end;

  TFhirCoverageEligibilityResponseInsuranceItemBenefitList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirCoverageEligibilityResponseInsuranceItemBenefit;
    procedure SetItemN(index : Integer; value : TFhirCoverageEligibilityResponseInsuranceItemBenefit);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirCoverageEligibilityResponseInsuranceItemBenefitList; overload;
    function Clone : TFhirCoverageEligibilityResponseInsuranceItemBenefitList; overload;
    function GetEnumerator : TFhirCoverageEligibilityResponseInsuranceItemBenefitListEnumerator;
    
    //  Add a FhirCoverageEligibilityResponseInsuranceItemBenefit to the end of the list.
    function Append : TFhirCoverageEligibilityResponseInsuranceItemBenefit;
    
    // Add an already existing FhirCoverageEligibilityResponseInsuranceItemBenefit to the end of the list.
    procedure AddItem(value : TFhirCoverageEligibilityResponseInsuranceItemBenefit); overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirCoverageEligibilityResponseInsuranceItemBenefit) : Integer;
    
    // Insert FhirCoverageEligibilityResponseInsuranceItemBenefit before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirCoverageEligibilityResponseInsuranceItemBenefit;
    
    // Insert an existing FhirCoverageEligibilityResponseInsuranceItemBenefit before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirCoverageEligibilityResponseInsuranceItemBenefit);
    
    // Get the iIndexth FhirCoverageEligibilityResponseInsuranceItemBenefit. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirCoverageEligibilityResponseInsuranceItemBenefit);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirCoverageEligibilityResponseInsuranceItemBenefit;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirCoverageEligibilityResponseInsuranceItemBenefits[index : Integer] : TFhirCoverageEligibilityResponseInsuranceItemBenefit read GetItemN write SetItemN; default;
  End;

  // Errors encountered during the processing of the request.
  TFhirCoverageEligibilityResponseError = class (TFhirBackboneElement)
  protected
    FCode : TFhirCodeableConcept;
    procedure SetCode(value : TFhirCodeableConcept);
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirCoverageEligibilityResponseError; overload;
    function Clone : TFhirCoverageEligibilityResponseError; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to An error code,from a specified code system, which details why the eligibility check could not be performed. (defined for API consistency)
    property code : TFhirCodeableConcept read FCode write SetCode;
    // An error code,from a specified code system, which details why the eligibility check could not be performed.
    property codeElement : TFhirCodeableConcept read FCode write SetCode;

  end;

  TFhirCoverageEligibilityResponseErrorListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirCoverageEligibilityResponseErrorList;
    function GetCurrent : TFhirCoverageEligibilityResponseError;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirCoverageEligibilityResponseErrorList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirCoverageEligibilityResponseError read GetCurrent;
  end;

  TFhirCoverageEligibilityResponseErrorList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirCoverageEligibilityResponseError;
    procedure SetItemN(index : Integer; value : TFhirCoverageEligibilityResponseError);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirCoverageEligibilityResponseErrorList; overload;
    function Clone : TFhirCoverageEligibilityResponseErrorList; overload;
    function GetEnumerator : TFhirCoverageEligibilityResponseErrorListEnumerator;
    
    //  Add a FhirCoverageEligibilityResponseError to the end of the list.
    function Append : TFhirCoverageEligibilityResponseError;
    
    // Add an already existing FhirCoverageEligibilityResponseError to the end of the list.
    procedure AddItem(value : TFhirCoverageEligibilityResponseError); overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirCoverageEligibilityResponseError) : Integer;
    
    // Insert FhirCoverageEligibilityResponseError before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirCoverageEligibilityResponseError;
    
    // Insert an existing FhirCoverageEligibilityResponseError before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirCoverageEligibilityResponseError);
    
    // Get the iIndexth FhirCoverageEligibilityResponseError. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirCoverageEligibilityResponseError);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirCoverageEligibilityResponseError;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirCoverageEligibilityResponseErrors[index : Integer] : TFhirCoverageEligibilityResponseError read GetItemN write SetItemN; default;
  End;

  // This resource provides eligibility and plan details from the processing of an CoverageEligibilityRequest resource.
  TFhirCoverageEligibilityResponse = class (TFhirDomainResource)
  protected
    FidentifierList : TFhirIdentifierList;
    FStatus : TFhirEnum;
    FPurpose : TFhirEnumList;
    FPatient : TFhirReference;
    FServiced : TFhirDataType;
    FCreated : TFhirDateTime;
    FRequestor : TFhirReference;
    FRequest : TFhirReference;
    FOutcome : TFhirEnum;
    FDisposition : TFhirString;
    FInsurer : TFhirReference;
    FinsuranceList : TFhirCoverageEligibilityResponseInsuranceList;
    FPreAuthRef : TFhirString;
    FForm : TFhirCodeableConcept;
    FerrorList : TFhirCoverageEligibilityResponseErrorList;
    function GetIdentifierList : TFhirIdentifierList;
    function GetHasIdentifierList : Boolean;
    procedure SetStatus(value : TFhirEnum);
    function GetStatusST : TFhirFinancialResourceStatusCodesEnum;
    procedure SetStatusST(value : TFhirFinancialResourceStatusCodesEnum);
    function GetPurpose : TFhirEnumList;
    function GetHasPurpose : Boolean;
    function GetPurposeST : TFhirEligibilityResponsePurposeEnumList;
    procedure SetPurposeST(value : TFhirEligibilityResponsePurposeEnumList);
    procedure SetPatient(value : TFhirReference);
    procedure SetServiced(value : TFhirDataType);
    procedure SetCreated(value : TFhirDateTime);
    function GetCreatedST : TFslDateTime;
    procedure SetCreatedST(value : TFslDateTime);
    procedure SetRequestor(value : TFhirReference);
    procedure SetRequest(value : TFhirReference);
    procedure SetOutcome(value : TFhirEnum);
    function GetOutcomeST : TFhirEligibilityOutcomeEnum;
    procedure SetOutcomeST(value : TFhirEligibilityOutcomeEnum);
    procedure SetDisposition(value : TFhirString);
    function GetDispositionST : String;
    procedure SetDispositionST(value : String);
    procedure SetInsurer(value : TFhirReference);
    function GetInsuranceList : TFhirCoverageEligibilityResponseInsuranceList;
    function GetHasInsuranceList : Boolean;
    procedure SetPreAuthRef(value : TFhirString);
    function GetPreAuthRefST : String;
    procedure SetPreAuthRefST(value : String);
    procedure SetForm(value : TFhirCodeableConcept);
    function GetErrorList : TFhirCoverageEligibilityResponseErrorList;
    function GetHasErrorList : Boolean;
  
    function GetResourceType : TFhirResourceType; override;
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirCoverageEligibilityResponse; overload;
    function Clone : TFhirCoverageEligibilityResponse; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // A unique identifier assigned to this coverage eligiblity request.
    property identifierList : TFhirIdentifierList read GetIdentifierList;
    property hasIdentifierList : boolean read GetHasIdentifierList;

    // The status of the resource instance.
    property status : TFhirFinancialResourceStatusCodesEnum read GetStatusST write SetStatusST;
    property statusElement : TFhirEnum read FStatus write SetStatus;

    // Code to specify whether requesting: prior authorization requirements for some service categories or billing codes; benefits for coverages specified or discovered; discovery and return of coverages for the patient; and/or validation that the specified coverage is in-force at the date/period specified or 'now' if not specified.
    property purpose : TFhirEligibilityResponsePurposeEnumList read GetPurposeST write SetPurposeST;
    property purposeList : TFhirEnumList read GetPurpose;
    property hasPurpose : boolean read GetHasPurpose;
    // Typed access to The party who is the beneficiary of the supplied coverage and for whom eligibility is sought. (defined for API consistency)
    property patient : TFhirReference read FPatient write SetPatient;
    // The party who is the beneficiary of the supplied coverage and for whom eligibility is sought.
    property patientElement : TFhirReference read FPatient write SetPatient;

    // Typed access to The date or dates when the enclosed suite of services were performed or completed. (defined for API consistency)
    property serviced : TFhirDataType read FServiced write SetServiced;
    // The date or dates when the enclosed suite of services were performed or completed.
    property servicedElement : TFhirDataType read FServiced write SetServiced;

    // Typed access to The date this resource was created.
    property created : TFslDateTime read GetCreatedST write SetCreatedST;
    // The date this resource was created.
    property createdElement : TFhirDateTime read FCreated write SetCreated;

    // Typed access to The provider which is responsible for the request. (defined for API consistency)
    property requestor : TFhirReference read FRequestor write SetRequestor;
    // The provider which is responsible for the request.
    property requestorElement : TFhirReference read FRequestor write SetRequestor;

    // Typed access to Reference to the original request resource. (defined for API consistency)
    property request : TFhirReference read FRequest write SetRequest;
    // Reference to the original request resource.
    property requestElement : TFhirReference read FRequest write SetRequest;

    // The outcome of the request processing.
    property outcome : TFhirEligibilityOutcomeEnum read GetOutcomeST write SetOutcomeST;
    property outcomeElement : TFhirEnum read FOutcome write SetOutcome;

    // Typed access to A human readable description of the status of the adjudication.
    property disposition : String read GetDispositionST write SetDispositionST;
    // A human readable description of the status of the adjudication.
    property dispositionElement : TFhirString read FDisposition write SetDisposition;

    // Typed access to The Insurer who issued the coverage in question and is the author of the response. (defined for API consistency)
    property insurer : TFhirReference read FInsurer write SetInsurer;
    // The Insurer who issued the coverage in question and is the author of the response.
    property insurerElement : TFhirReference read FInsurer write SetInsurer;

    // Financial instruments for reimbursement for the health care products and services.
    property insuranceList : TFhirCoverageEligibilityResponseInsuranceList read GetInsuranceList;
    property hasInsuranceList : boolean read GetHasInsuranceList;

    // Typed access to A reference from the Insurer to which these services pertain to be used on further communication and as proof that the request occurred.
    property preAuthRef : String read GetPreAuthRefST write SetPreAuthRefST;
    // A reference from the Insurer to which these services pertain to be used on further communication and as proof that the request occurred.
    property preAuthRefElement : TFhirString read FPreAuthRef write SetPreAuthRef;

    // Typed access to A code for the form to be used for printing the content. (defined for API consistency)
    property form : TFhirCodeableConcept read FForm write SetForm;
    // A code for the form to be used for printing the content.
    property formElement : TFhirCodeableConcept read FForm write SetForm;

    // Errors encountered during the processing of the request.
    property errorList : TFhirCoverageEligibilityResponseErrorList read GetErrorList;
    property hasErrorList : boolean read GetHasErrorList;

  end;

  TFhirCoverageEligibilityResponseListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirCoverageEligibilityResponseList;
    function GetCurrent : TFhirCoverageEligibilityResponse;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirCoverageEligibilityResponseList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirCoverageEligibilityResponse read GetCurrent;
  end;

  TFhirCoverageEligibilityResponseList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirCoverageEligibilityResponse;
    procedure SetItemN(index : Integer; value : TFhirCoverageEligibilityResponse);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirCoverageEligibilityResponseList; overload;
    function Clone : TFhirCoverageEligibilityResponseList; overload;
    function GetEnumerator : TFhirCoverageEligibilityResponseListEnumerator;
    
    //  Add a FhirCoverageEligibilityResponse to the end of the list.
    function Append : TFhirCoverageEligibilityResponse;
    
    // Add an already existing FhirCoverageEligibilityResponse to the end of the list.
    procedure AddItem(value : TFhirCoverageEligibilityResponse); overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirCoverageEligibilityResponse) : Integer;
    
    // Insert FhirCoverageEligibilityResponse before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirCoverageEligibilityResponse;
    
    // Insert an existing FhirCoverageEligibilityResponse before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirCoverageEligibilityResponse);
    
    // Get the iIndexth FhirCoverageEligibilityResponse. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirCoverageEligibilityResponse);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirCoverageEligibilityResponse;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirCoverageEligibilityResponses[index : Integer] : TFhirCoverageEligibilityResponse read GetItemN write SetItemN; default;
  End;

{$ENDIF FHIR_COVERAGEELIGIBILITYRESPONSE}
{$IFDEF FHIR_ENROLLMENTREQUEST}
  // This resource provides the insurance enrollment details to the insurer regarding a specified coverage.
  TFhirEnrollmentRequest = class (TFhirDomainResource)
  protected
    FidentifierList : TFhirIdentifierList;
    FStatus : TFhirEnum;
    FCreated : TFhirDateTime;
    FInsurer : TFhirReference;
    FProvider : TFhirReference;
    FCandidate : TFhirReference;
    FCoverage : TFhirReference;
    function GetIdentifierList : TFhirIdentifierList;
    function GetHasIdentifierList : Boolean;
    procedure SetStatus(value : TFhirEnum);
    function GetStatusST : TFhirFinancialResourceStatusCodesEnum;
    procedure SetStatusST(value : TFhirFinancialResourceStatusCodesEnum);
    procedure SetCreated(value : TFhirDateTime);
    function GetCreatedST : TFslDateTime;
    procedure SetCreatedST(value : TFslDateTime);
    procedure SetInsurer(value : TFhirReference);
    procedure SetProvider(value : TFhirReference);
    procedure SetCandidate(value : TFhirReference);
    procedure SetCoverage(value : TFhirReference);
  
    function GetResourceType : TFhirResourceType; override;
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirEnrollmentRequest; overload;
    function Clone : TFhirEnrollmentRequest; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // The Response business identifier.
    property identifierList : TFhirIdentifierList read GetIdentifierList;
    property hasIdentifierList : boolean read GetHasIdentifierList;

    // The status of the resource instance.
    property status : TFhirFinancialResourceStatusCodesEnum read GetStatusST write SetStatusST;
    property statusElement : TFhirEnum read FStatus write SetStatus;

    // Typed access to The date when this resource was created.
    property created : TFslDateTime read GetCreatedST write SetCreatedST;
    // The date when this resource was created.
    property createdElement : TFhirDateTime read FCreated write SetCreated;

    // Typed access to The Insurer who is target  of the request. (defined for API consistency)
    property insurer : TFhirReference read FInsurer write SetInsurer;
    // The Insurer who is target  of the request.
    property insurerElement : TFhirReference read FInsurer write SetInsurer;

    // Typed access to The practitioner who is responsible for the services rendered to the patient. (defined for API consistency)
    property provider : TFhirReference read FProvider write SetProvider;
    // The practitioner who is responsible for the services rendered to the patient.
    property providerElement : TFhirReference read FProvider write SetProvider;

    // Typed access to Patient Resource. (defined for API consistency)
    property candidate : TFhirReference read FCandidate write SetCandidate;
    // Patient Resource.
    property candidateElement : TFhirReference read FCandidate write SetCandidate;

    // Typed access to Reference to the program or plan identification, underwriter or payor. (defined for API consistency)
    property coverage : TFhirReference read FCoverage write SetCoverage;
    // Reference to the program or plan identification, underwriter or payor.
    property coverageElement : TFhirReference read FCoverage write SetCoverage;

  end;

  TFhirEnrollmentRequestListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirEnrollmentRequestList;
    function GetCurrent : TFhirEnrollmentRequest;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirEnrollmentRequestList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirEnrollmentRequest read GetCurrent;
  end;

  TFhirEnrollmentRequestList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirEnrollmentRequest;
    procedure SetItemN(index : Integer; value : TFhirEnrollmentRequest);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirEnrollmentRequestList; overload;
    function Clone : TFhirEnrollmentRequestList; overload;
    function GetEnumerator : TFhirEnrollmentRequestListEnumerator;
    
    //  Add a FhirEnrollmentRequest to the end of the list.
    function Append : TFhirEnrollmentRequest;
    
    // Add an already existing FhirEnrollmentRequest to the end of the list.
    procedure AddItem(value : TFhirEnrollmentRequest); overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirEnrollmentRequest) : Integer;
    
    // Insert FhirEnrollmentRequest before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirEnrollmentRequest;
    
    // Insert an existing FhirEnrollmentRequest before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirEnrollmentRequest);
    
    // Get the iIndexth FhirEnrollmentRequest. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirEnrollmentRequest);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirEnrollmentRequest;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirEnrollmentRequests[index : Integer] : TFhirEnrollmentRequest read GetItemN write SetItemN; default;
  End;

{$ENDIF FHIR_ENROLLMENTREQUEST}
{$IFDEF FHIR_ENROLLMENTRESPONSE}
  // This resource provides enrollment and plan details from the processing of an EnrollmentRequest resource.
  TFhirEnrollmentResponse = class (TFhirDomainResource)
  protected
    FidentifierList : TFhirIdentifierList;
    FStatus : TFhirEnum;
    FRequest : TFhirReference;
    FOutcome : TFhirEnum;
    FDisposition : TFhirString;
    FCreated : TFhirDateTime;
    FOrganization : TFhirReference;
    FRequestProvider : TFhirReference;
    function GetIdentifierList : TFhirIdentifierList;
    function GetHasIdentifierList : Boolean;
    procedure SetStatus(value : TFhirEnum);
    function GetStatusST : TFhirFinancialResourceStatusCodesEnum;
    procedure SetStatusST(value : TFhirFinancialResourceStatusCodesEnum);
    procedure SetRequest(value : TFhirReference);
    procedure SetOutcome(value : TFhirEnum);
    function GetOutcomeST : TFhirEnrollmentOutcomeEnum;
    procedure SetOutcomeST(value : TFhirEnrollmentOutcomeEnum);
    procedure SetDisposition(value : TFhirString);
    function GetDispositionST : String;
    procedure SetDispositionST(value : String);
    procedure SetCreated(value : TFhirDateTime);
    function GetCreatedST : TFslDateTime;
    procedure SetCreatedST(value : TFslDateTime);
    procedure SetOrganization(value : TFhirReference);
    procedure SetRequestProvider(value : TFhirReference);
  
    function GetResourceType : TFhirResourceType; override;
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirEnrollmentResponse; overload;
    function Clone : TFhirEnrollmentResponse; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // The Response business identifier.
    property identifierList : TFhirIdentifierList read GetIdentifierList;
    property hasIdentifierList : boolean read GetHasIdentifierList;

    // The status of the resource instance.
    property status : TFhirFinancialResourceStatusCodesEnum read GetStatusST write SetStatusST;
    property statusElement : TFhirEnum read FStatus write SetStatus;

    // Typed access to Original request resource reference. (defined for API consistency)
    property request : TFhirReference read FRequest write SetRequest;
    // Original request resource reference.
    property requestElement : TFhirReference read FRequest write SetRequest;

    // Processing status: error, complete.
    property outcome : TFhirEnrollmentOutcomeEnum read GetOutcomeST write SetOutcomeST;
    property outcomeElement : TFhirEnum read FOutcome write SetOutcome;

    // Typed access to A description of the status of the adjudication.
    property disposition : String read GetDispositionST write SetDispositionST;
    // A description of the status of the adjudication.
    property dispositionElement : TFhirString read FDisposition write SetDisposition;

    // Typed access to The date when the enclosed suite of services were performed or completed.
    property created : TFslDateTime read GetCreatedST write SetCreatedST;
    // The date when the enclosed suite of services were performed or completed.
    property createdElement : TFhirDateTime read FCreated write SetCreated;

    // Typed access to The Insurer who produced this adjudicated response. (defined for API consistency)
    property organization : TFhirReference read FOrganization write SetOrganization;
    // The Insurer who produced this adjudicated response.
    property organizationElement : TFhirReference read FOrganization write SetOrganization;

    // Typed access to The practitioner who is responsible for the services rendered to the patient. (defined for API consistency)
    property requestProvider : TFhirReference read FRequestProvider write SetRequestProvider;
    // The practitioner who is responsible for the services rendered to the patient.
    property requestProviderElement : TFhirReference read FRequestProvider write SetRequestProvider;

  end;

  TFhirEnrollmentResponseListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirEnrollmentResponseList;
    function GetCurrent : TFhirEnrollmentResponse;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirEnrollmentResponseList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirEnrollmentResponse read GetCurrent;
  end;

  TFhirEnrollmentResponseList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirEnrollmentResponse;
    procedure SetItemN(index : Integer; value : TFhirEnrollmentResponse);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirEnrollmentResponseList; overload;
    function Clone : TFhirEnrollmentResponseList; overload;
    function GetEnumerator : TFhirEnrollmentResponseListEnumerator;
    
    //  Add a FhirEnrollmentResponse to the end of the list.
    function Append : TFhirEnrollmentResponse;
    
    // Add an already existing FhirEnrollmentResponse to the end of the list.
    procedure AddItem(value : TFhirEnrollmentResponse); overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirEnrollmentResponse) : Integer;
    
    // Insert FhirEnrollmentResponse before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirEnrollmentResponse;
    
    // Insert an existing FhirEnrollmentResponse before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirEnrollmentResponse);
    
    // Get the iIndexth FhirEnrollmentResponse. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirEnrollmentResponse);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirEnrollmentResponse;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirEnrollmentResponses[index : Integer] : TFhirEnrollmentResponse read GetItemN write SetItemN; default;
  End;

{$ENDIF FHIR_ENROLLMENTRESPONSE}
{$IFDEF FHIR_EXPLANATIONOFBENEFIT}
  // Other claims which are related to this claim such as prior submissions or claims for related services or for the same event.
  TFhirExplanationOfBenefitRelated = class (TFhirBackboneElement)
  protected
    FClaim : TFhirReference;
    FRelationship : TFhirCodeableConcept;
    FReference : TFhirIdentifier;
    procedure SetClaim(value : TFhirReference);
    procedure SetRelationship(value : TFhirCodeableConcept);
    procedure SetReference(value : TFhirIdentifier);
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirExplanationOfBenefitRelated; overload;
    function Clone : TFhirExplanationOfBenefitRelated; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to Reference to a related claim. (defined for API consistency)
    property claim : TFhirReference read FClaim write SetClaim;
    // Reference to a related claim.
    property claimElement : TFhirReference read FClaim write SetClaim;

    // Typed access to A code to convey how the claims are related. (defined for API consistency)
    property relationship : TFhirCodeableConcept read FRelationship write SetRelationship;
    // A code to convey how the claims are related.
    property relationshipElement : TFhirCodeableConcept read FRelationship write SetRelationship;

    // Typed access to An alternate organizational reference to the case or file to which this particular claim pertains. (defined for API consistency)
    property reference : TFhirIdentifier read FReference write SetReference;
    // An alternate organizational reference to the case or file to which this particular claim pertains.
    property referenceElement : TFhirIdentifier read FReference write SetReference;

  end;

  TFhirExplanationOfBenefitRelatedListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirExplanationOfBenefitRelatedList;
    function GetCurrent : TFhirExplanationOfBenefitRelated;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirExplanationOfBenefitRelatedList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirExplanationOfBenefitRelated read GetCurrent;
  end;

  TFhirExplanationOfBenefitRelatedList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirExplanationOfBenefitRelated;
    procedure SetItemN(index : Integer; value : TFhirExplanationOfBenefitRelated);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirExplanationOfBenefitRelatedList; overload;
    function Clone : TFhirExplanationOfBenefitRelatedList; overload;
    function GetEnumerator : TFhirExplanationOfBenefitRelatedListEnumerator;
    
    //  Add a FhirExplanationOfBenefitRelated to the end of the list.
    function Append : TFhirExplanationOfBenefitRelated;
    
    // Add an already existing FhirExplanationOfBenefitRelated to the end of the list.
    procedure AddItem(value : TFhirExplanationOfBenefitRelated); overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirExplanationOfBenefitRelated) : Integer;
    
    // Insert FhirExplanationOfBenefitRelated before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirExplanationOfBenefitRelated;
    
    // Insert an existing FhirExplanationOfBenefitRelated before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirExplanationOfBenefitRelated);
    
    // Get the iIndexth FhirExplanationOfBenefitRelated. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirExplanationOfBenefitRelated);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirExplanationOfBenefitRelated;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirExplanationOfBenefitRelateds[index : Integer] : TFhirExplanationOfBenefitRelated read GetItemN write SetItemN; default;
  End;

  // The party to be reimbursed for cost of the products and services according to the terms of the policy.
  TFhirExplanationOfBenefitPayee = class (TFhirBackboneElement)
  protected
    FType_ : TFhirCodeableConcept;
    FParty : TFhirReference;
    procedure SetType_(value : TFhirCodeableConcept);
    procedure SetParty(value : TFhirReference);
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirExplanationOfBenefitPayee; overload;
    function Clone : TFhirExplanationOfBenefitPayee; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to Type of Party to be reimbursed: Subscriber, provider, other. (defined for API consistency)
    property type_ : TFhirCodeableConcept read FType_ write SetType_;
    // Type of Party to be reimbursed: Subscriber, provider, other.
    property type_Element : TFhirCodeableConcept read FType_ write SetType_;

    // Typed access to Reference to the individual or organization to whom any payment will be made. (defined for API consistency)
    property party : TFhirReference read FParty write SetParty;
    // Reference to the individual or organization to whom any payment will be made.
    property partyElement : TFhirReference read FParty write SetParty;

  end;

  TFhirExplanationOfBenefitPayeeListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirExplanationOfBenefitPayeeList;
    function GetCurrent : TFhirExplanationOfBenefitPayee;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirExplanationOfBenefitPayeeList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirExplanationOfBenefitPayee read GetCurrent;
  end;

  TFhirExplanationOfBenefitPayeeList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirExplanationOfBenefitPayee;
    procedure SetItemN(index : Integer; value : TFhirExplanationOfBenefitPayee);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirExplanationOfBenefitPayeeList; overload;
    function Clone : TFhirExplanationOfBenefitPayeeList; overload;
    function GetEnumerator : TFhirExplanationOfBenefitPayeeListEnumerator;
    
    //  Add a FhirExplanationOfBenefitPayee to the end of the list.
    function Append : TFhirExplanationOfBenefitPayee;
    
    // Add an already existing FhirExplanationOfBenefitPayee to the end of the list.
    procedure AddItem(value : TFhirExplanationOfBenefitPayee); overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirExplanationOfBenefitPayee) : Integer;
    
    // Insert FhirExplanationOfBenefitPayee before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirExplanationOfBenefitPayee;
    
    // Insert an existing FhirExplanationOfBenefitPayee before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirExplanationOfBenefitPayee);
    
    // Get the iIndexth FhirExplanationOfBenefitPayee. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirExplanationOfBenefitPayee);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirExplanationOfBenefitPayee;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirExplanationOfBenefitPayees[index : Integer] : TFhirExplanationOfBenefitPayee read GetItemN write SetItemN; default;
  End;

  // The members of the team who provided the products and services.
  TFhirExplanationOfBenefitCareTeam = class (TFhirBackboneElement)
  protected
    FSequence : TFhirPositiveInt;
    FProvider : TFhirReference;
    FResponsible : TFhirBoolean;
    FRole : TFhirCodeableConcept;
    FQualification : TFhirCodeableConcept;
    procedure SetSequence(value : TFhirPositiveInt);
    function GetSequenceST : String;
    procedure SetSequenceST(value : String);
    procedure SetProvider(value : TFhirReference);
    procedure SetResponsible(value : TFhirBoolean);
    function GetResponsibleST : Boolean;
    procedure SetResponsibleST(value : Boolean);
    procedure SetRole(value : TFhirCodeableConcept);
    procedure SetQualification(value : TFhirCodeableConcept);
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirExplanationOfBenefitCareTeam; overload;
    function Clone : TFhirExplanationOfBenefitCareTeam; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to A number to uniquely identify care team entries.
    property sequence : String read GetSequenceST write SetSequenceST;
    // A number to uniquely identify care team entries.
    property sequenceElement : TFhirPositiveInt read FSequence write SetSequence;

    // Typed access to Member of the team who provided the product or service. (defined for API consistency)
    property provider : TFhirReference read FProvider write SetProvider;
    // Member of the team who provided the product or service.
    property providerElement : TFhirReference read FProvider write SetProvider;

    // Typed access to The party who is billing and/or responsible for the claimed products or services.
    property responsible : Boolean read GetResponsibleST write SetResponsibleST;
    // The party who is billing and/or responsible for the claimed products or services.
    property responsibleElement : TFhirBoolean read FResponsible write SetResponsible;

    // Typed access to The lead, assisting or supervising practitioner and their discipline if a multidisciplinary team. (defined for API consistency)
    property role : TFhirCodeableConcept read FRole write SetRole;
    // The lead, assisting or supervising practitioner and their discipline if a multidisciplinary team.
    property roleElement : TFhirCodeableConcept read FRole write SetRole;

    // Typed access to The qualification of the practitioner which is applicable for this service. (defined for API consistency)
    property qualification : TFhirCodeableConcept read FQualification write SetQualification;
    // The qualification of the practitioner which is applicable for this service.
    property qualificationElement : TFhirCodeableConcept read FQualification write SetQualification;

  end;

  TFhirExplanationOfBenefitCareTeamListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirExplanationOfBenefitCareTeamList;
    function GetCurrent : TFhirExplanationOfBenefitCareTeam;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirExplanationOfBenefitCareTeamList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirExplanationOfBenefitCareTeam read GetCurrent;
  end;

  TFhirExplanationOfBenefitCareTeamList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirExplanationOfBenefitCareTeam;
    procedure SetItemN(index : Integer; value : TFhirExplanationOfBenefitCareTeam);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirExplanationOfBenefitCareTeamList; overload;
    function Clone : TFhirExplanationOfBenefitCareTeamList; overload;
    function GetEnumerator : TFhirExplanationOfBenefitCareTeamListEnumerator;
    
    //  Add a FhirExplanationOfBenefitCareTeam to the end of the list.
    function Append : TFhirExplanationOfBenefitCareTeam;
    
    // Add an already existing FhirExplanationOfBenefitCareTeam to the end of the list.
    procedure AddItem(value : TFhirExplanationOfBenefitCareTeam); overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirExplanationOfBenefitCareTeam) : Integer;
    
    // Insert FhirExplanationOfBenefitCareTeam before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirExplanationOfBenefitCareTeam;
    
    // Insert an existing FhirExplanationOfBenefitCareTeam before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirExplanationOfBenefitCareTeam);
    
    // Get the iIndexth FhirExplanationOfBenefitCareTeam. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirExplanationOfBenefitCareTeam);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirExplanationOfBenefitCareTeam;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirExplanationOfBenefitCareTeams[index : Integer] : TFhirExplanationOfBenefitCareTeam read GetItemN write SetItemN; default;
  End;

  // Additional information codes regarding exceptions, special considerations, the condition, situation, prior or concurrent issues.
  TFhirExplanationOfBenefitSupportingInfo = class (TFhirBackboneElement)
  protected
    FSequence : TFhirPositiveInt;
    FCategory : TFhirCodeableConcept;
    FCode : TFhirCodeableConcept;
    FTiming : TFhirDataType;
    FValue : TFhirDataType;
    FReason : TFhirCoding;
    procedure SetSequence(value : TFhirPositiveInt);
    function GetSequenceST : String;
    procedure SetSequenceST(value : String);
    procedure SetCategory(value : TFhirCodeableConcept);
    procedure SetCode(value : TFhirCodeableConcept);
    procedure SetTiming(value : TFhirDataType);
    procedure SetValue(value : TFhirDataType);
    procedure SetReason(value : TFhirCoding);
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirExplanationOfBenefitSupportingInfo; overload;
    function Clone : TFhirExplanationOfBenefitSupportingInfo; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to A number to uniquely identify supporting information entries.
    property sequence : String read GetSequenceST write SetSequenceST;
    // A number to uniquely identify supporting information entries.
    property sequenceElement : TFhirPositiveInt read FSequence write SetSequence;

    // Typed access to The general class of the information supplied: information; exception; accident, employment; onset, etc. (defined for API consistency)
    property category : TFhirCodeableConcept read FCategory write SetCategory;
    // The general class of the information supplied: information; exception; accident, employment; onset, etc.
    property categoryElement : TFhirCodeableConcept read FCategory write SetCategory;

    // Typed access to System and code pertaining to the specific information regarding special conditions relating to the setting, treatment or patient  for which care is sought. (defined for API consistency)
    property code : TFhirCodeableConcept read FCode write SetCode;
    // System and code pertaining to the specific information regarding special conditions relating to the setting, treatment or patient  for which care is sought.
    property codeElement : TFhirCodeableConcept read FCode write SetCode;

    // Typed access to The date when or period to which this information refers. (defined for API consistency)
    property timing : TFhirDataType read FTiming write SetTiming;
    // The date when or period to which this information refers.
    property timingElement : TFhirDataType read FTiming write SetTiming;

    // Typed access to Additional data or information such as resources, documents, images etc. including references to the data or the actual inclusion of the data. (defined for API consistency)
    property value : TFhirDataType read FValue write SetValue;
    // Additional data or information such as resources, documents, images etc. including references to the data or the actual inclusion of the data.
    property valueElement : TFhirDataType read FValue write SetValue;

    // Typed access to Provides the reason in the situation where a reason code is required in addition to the content. (defined for API consistency)
    property reason : TFhirCoding read FReason write SetReason;
    // Provides the reason in the situation where a reason code is required in addition to the content.
    property reasonElement : TFhirCoding read FReason write SetReason;

  end;

  TFhirExplanationOfBenefitSupportingInfoListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirExplanationOfBenefitSupportingInfoList;
    function GetCurrent : TFhirExplanationOfBenefitSupportingInfo;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirExplanationOfBenefitSupportingInfoList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirExplanationOfBenefitSupportingInfo read GetCurrent;
  end;

  TFhirExplanationOfBenefitSupportingInfoList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirExplanationOfBenefitSupportingInfo;
    procedure SetItemN(index : Integer; value : TFhirExplanationOfBenefitSupportingInfo);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirExplanationOfBenefitSupportingInfoList; overload;
    function Clone : TFhirExplanationOfBenefitSupportingInfoList; overload;
    function GetEnumerator : TFhirExplanationOfBenefitSupportingInfoListEnumerator;
    
    //  Add a FhirExplanationOfBenefitSupportingInfo to the end of the list.
    function Append : TFhirExplanationOfBenefitSupportingInfo;
    
    // Add an already existing FhirExplanationOfBenefitSupportingInfo to the end of the list.
    procedure AddItem(value : TFhirExplanationOfBenefitSupportingInfo); overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirExplanationOfBenefitSupportingInfo) : Integer;
    
    // Insert FhirExplanationOfBenefitSupportingInfo before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirExplanationOfBenefitSupportingInfo;
    
    // Insert an existing FhirExplanationOfBenefitSupportingInfo before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirExplanationOfBenefitSupportingInfo);
    
    // Get the iIndexth FhirExplanationOfBenefitSupportingInfo. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirExplanationOfBenefitSupportingInfo);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirExplanationOfBenefitSupportingInfo;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirExplanationOfBenefitSupportingInfos[index : Integer] : TFhirExplanationOfBenefitSupportingInfo read GetItemN write SetItemN; default;
  End;

  // Information about diagnoses relevant to the claim items.
  TFhirExplanationOfBenefitDiagnosis = class (TFhirBackboneElement)
  protected
    FSequence : TFhirPositiveInt;
    FDiagnosis : TFhirDataType;
    Ftype_List : TFhirCodeableConceptList;
    FOnAdmission : TFhirCodeableConcept;
    FPackageCode : TFhirCodeableConcept;
    procedure SetSequence(value : TFhirPositiveInt);
    function GetSequenceST : String;
    procedure SetSequenceST(value : String);
    procedure SetDiagnosis(value : TFhirDataType);
    function GetType_List : TFhirCodeableConceptList;
    function GetHasType_List : Boolean;
    procedure SetOnAdmission(value : TFhirCodeableConcept);
    procedure SetPackageCode(value : TFhirCodeableConcept);
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirExplanationOfBenefitDiagnosis; overload;
    function Clone : TFhirExplanationOfBenefitDiagnosis; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to A number to uniquely identify diagnosis entries.
    property sequence : String read GetSequenceST write SetSequenceST;
    // A number to uniquely identify diagnosis entries.
    property sequenceElement : TFhirPositiveInt read FSequence write SetSequence;

    // Typed access to The nature of illness or problem in a coded form or as a reference to an external defined Condition. (defined for API consistency)
    property diagnosis : TFhirDataType read FDiagnosis write SetDiagnosis;
    // The nature of illness or problem in a coded form or as a reference to an external defined Condition.
    property diagnosisElement : TFhirDataType read FDiagnosis write SetDiagnosis;

    // When the condition was observed or the relative ranking.
    property type_List : TFhirCodeableConceptList read GetType_List;
    property hasType_List : boolean read GetHasType_List;

    // Typed access to Indication of whether the diagnosis was present on admission to a facility. (defined for API consistency)
    property onAdmission : TFhirCodeableConcept read FOnAdmission write SetOnAdmission;
    // Indication of whether the diagnosis was present on admission to a facility.
    property onAdmissionElement : TFhirCodeableConcept read FOnAdmission write SetOnAdmission;

    // Typed access to A package billing code or bundle code used to group products and services to a particular health condition (such as heart attack) which is based on a predetermined grouping code system. (defined for API consistency)
    property packageCode : TFhirCodeableConcept read FPackageCode write SetPackageCode;
    // A package billing code or bundle code used to group products and services to a particular health condition (such as heart attack) which is based on a predetermined grouping code system.
    property packageCodeElement : TFhirCodeableConcept read FPackageCode write SetPackageCode;

  end;

  TFhirExplanationOfBenefitDiagnosisListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirExplanationOfBenefitDiagnosisList;
    function GetCurrent : TFhirExplanationOfBenefitDiagnosis;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirExplanationOfBenefitDiagnosisList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirExplanationOfBenefitDiagnosis read GetCurrent;
  end;

  TFhirExplanationOfBenefitDiagnosisList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirExplanationOfBenefitDiagnosis;
    procedure SetItemN(index : Integer; value : TFhirExplanationOfBenefitDiagnosis);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirExplanationOfBenefitDiagnosisList; overload;
    function Clone : TFhirExplanationOfBenefitDiagnosisList; overload;
    function GetEnumerator : TFhirExplanationOfBenefitDiagnosisListEnumerator;
    
    //  Add a FhirExplanationOfBenefitDiagnosis to the end of the list.
    function Append : TFhirExplanationOfBenefitDiagnosis;
    
    // Add an already existing FhirExplanationOfBenefitDiagnosis to the end of the list.
    procedure AddItem(value : TFhirExplanationOfBenefitDiagnosis); overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirExplanationOfBenefitDiagnosis) : Integer;
    
    // Insert FhirExplanationOfBenefitDiagnosis before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirExplanationOfBenefitDiagnosis;
    
    // Insert an existing FhirExplanationOfBenefitDiagnosis before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirExplanationOfBenefitDiagnosis);
    
    // Get the iIndexth FhirExplanationOfBenefitDiagnosis. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirExplanationOfBenefitDiagnosis);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirExplanationOfBenefitDiagnosis;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirExplanationOfBenefitDiagnoses[index : Integer] : TFhirExplanationOfBenefitDiagnosis read GetItemN write SetItemN; default;
  End;

  // Procedures performed on the patient relevant to the billing items with the claim.
  TFhirExplanationOfBenefitProcedure = class (TFhirBackboneElement)
  protected
    FSequence : TFhirPositiveInt;
    Ftype_List : TFhirCodeableConceptList;
    FDate : TFhirDateTime;
    FProcedure_ : TFhirDataType;
    FudiList : TFhirReferenceList;
    procedure SetSequence(value : TFhirPositiveInt);
    function GetSequenceST : String;
    procedure SetSequenceST(value : String);
    function GetType_List : TFhirCodeableConceptList;
    function GetHasType_List : Boolean;
    procedure SetDate(value : TFhirDateTime);
    function GetDateST : TFslDateTime;
    procedure SetDateST(value : TFslDateTime);
    procedure SetProcedure_(value : TFhirDataType);
    function GetUdiList : TFhirReferenceList;
    function GetHasUdiList : Boolean;
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirExplanationOfBenefitProcedure; overload;
    function Clone : TFhirExplanationOfBenefitProcedure; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to A number to uniquely identify procedure entries.
    property sequence : String read GetSequenceST write SetSequenceST;
    // A number to uniquely identify procedure entries.
    property sequenceElement : TFhirPositiveInt read FSequence write SetSequence;

    // When the condition was observed or the relative ranking.
    property type_List : TFhirCodeableConceptList read GetType_List;
    property hasType_List : boolean read GetHasType_List;

    // Typed access to Date and optionally time the procedure was performed.
    property date : TFslDateTime read GetDateST write SetDateST;
    // Date and optionally time the procedure was performed.
    property dateElement : TFhirDateTime read FDate write SetDate;

    // Typed access to The code or reference to a Procedure resource which identifies the clinical intervention performed. (defined for API consistency)
    property procedure_ : TFhirDataType read FProcedure_ write SetProcedure_;
    // The code or reference to a Procedure resource which identifies the clinical intervention performed.
    property procedure_Element : TFhirDataType read FProcedure_ write SetProcedure_;

    // Unique Device Identifiers associated with this line item.
    property udiList : TFhirReferenceList read GetUdiList;
    property hasUdiList : boolean read GetHasUdiList;

  end;

  TFhirExplanationOfBenefitProcedureListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirExplanationOfBenefitProcedureList;
    function GetCurrent : TFhirExplanationOfBenefitProcedure;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirExplanationOfBenefitProcedureList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirExplanationOfBenefitProcedure read GetCurrent;
  end;

  TFhirExplanationOfBenefitProcedureList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirExplanationOfBenefitProcedure;
    procedure SetItemN(index : Integer; value : TFhirExplanationOfBenefitProcedure);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirExplanationOfBenefitProcedureList; overload;
    function Clone : TFhirExplanationOfBenefitProcedureList; overload;
    function GetEnumerator : TFhirExplanationOfBenefitProcedureListEnumerator;
    
    //  Add a FhirExplanationOfBenefitProcedure to the end of the list.
    function Append : TFhirExplanationOfBenefitProcedure;
    
    // Add an already existing FhirExplanationOfBenefitProcedure to the end of the list.
    procedure AddItem(value : TFhirExplanationOfBenefitProcedure); overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirExplanationOfBenefitProcedure) : Integer;
    
    // Insert FhirExplanationOfBenefitProcedure before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirExplanationOfBenefitProcedure;
    
    // Insert an existing FhirExplanationOfBenefitProcedure before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirExplanationOfBenefitProcedure);
    
    // Get the iIndexth FhirExplanationOfBenefitProcedure. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirExplanationOfBenefitProcedure);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirExplanationOfBenefitProcedure;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirExplanationOfBenefitProcedures[index : Integer] : TFhirExplanationOfBenefitProcedure read GetItemN write SetItemN; default;
  End;

  // Financial instruments for reimbursement for the health care products and services specified on the claim.
  TFhirExplanationOfBenefitInsurance = class (TFhirBackboneElement)
  protected
    FFocal : TFhirBoolean;
    FCoverage : TFhirReference;
    FpreAuthRefList : TFhirStringList;
    procedure SetFocal(value : TFhirBoolean);
    function GetFocalST : Boolean;
    procedure SetFocalST(value : Boolean);
    procedure SetCoverage(value : TFhirReference);
    function GetPreAuthRefList : TFhirStringList;
    function GetHasPreAuthRefList : Boolean;
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirExplanationOfBenefitInsurance; overload;
    function Clone : TFhirExplanationOfBenefitInsurance; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to A flag to indicate that this Coverage is to be used for adjudication of this claim when set to true.
    property focal : Boolean read GetFocalST write SetFocalST;
    // A flag to indicate that this Coverage is to be used for adjudication of this claim when set to true.
    property focalElement : TFhirBoolean read FFocal write SetFocal;

    // Typed access to Reference to the insurance card level information contained in the Coverage resource. The coverage issuing insurer will use these details to locate the patient's actual coverage within the insurer's information system. (defined for API consistency)
    property coverage : TFhirReference read FCoverage write SetCoverage;
    // Reference to the insurance card level information contained in the Coverage resource. The coverage issuing insurer will use these details to locate the patient's actual coverage within the insurer's information system.
    property coverageElement : TFhirReference read FCoverage write SetCoverage;

    // Reference numbers previously provided by the insurer to the provider to be quoted on subsequent claims containing services or products related to the prior authorization.
    property preAuthRefList : TFhirStringList read GetPreAuthRefList;
    property hasPreAuthRefList : boolean read GetHasPreAuthRefList;

  end;

  TFhirExplanationOfBenefitInsuranceListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirExplanationOfBenefitInsuranceList;
    function GetCurrent : TFhirExplanationOfBenefitInsurance;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirExplanationOfBenefitInsuranceList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirExplanationOfBenefitInsurance read GetCurrent;
  end;

  TFhirExplanationOfBenefitInsuranceList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirExplanationOfBenefitInsurance;
    procedure SetItemN(index : Integer; value : TFhirExplanationOfBenefitInsurance);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirExplanationOfBenefitInsuranceList; overload;
    function Clone : TFhirExplanationOfBenefitInsuranceList; overload;
    function GetEnumerator : TFhirExplanationOfBenefitInsuranceListEnumerator;
    
    //  Add a FhirExplanationOfBenefitInsurance to the end of the list.
    function Append : TFhirExplanationOfBenefitInsurance;
    
    // Add an already existing FhirExplanationOfBenefitInsurance to the end of the list.
    procedure AddItem(value : TFhirExplanationOfBenefitInsurance); overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirExplanationOfBenefitInsurance) : Integer;
    
    // Insert FhirExplanationOfBenefitInsurance before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirExplanationOfBenefitInsurance;
    
    // Insert an existing FhirExplanationOfBenefitInsurance before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirExplanationOfBenefitInsurance);
    
    // Get the iIndexth FhirExplanationOfBenefitInsurance. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirExplanationOfBenefitInsurance);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirExplanationOfBenefitInsurance;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirExplanationOfBenefitInsurances[index : Integer] : TFhirExplanationOfBenefitInsurance read GetItemN write SetItemN; default;
  End;

  // Details of a accident which resulted in injuries which required the products and services listed in the claim.
  TFhirExplanationOfBenefitAccident = class (TFhirBackboneElement)
  protected
    FDate : TFhirDate;
    FType_ : TFhirCodeableConcept;
    FLocation : TFhirDataType;
    procedure SetDate(value : TFhirDate);
    function GetDateST : TFslDateTime;
    procedure SetDateST(value : TFslDateTime);
    procedure SetType_(value : TFhirCodeableConcept);
    procedure SetLocation(value : TFhirDataType);
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirExplanationOfBenefitAccident; overload;
    function Clone : TFhirExplanationOfBenefitAccident; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to Date of an accident event  related to the products and services contained in the claim.
    property date : TFslDateTime read GetDateST write SetDateST;
    // Date of an accident event  related to the products and services contained in the claim.
    property dateElement : TFhirDate read FDate write SetDate;

    // Typed access to The type or context of the accident event for the purposes of selection of potential insurance coverages and determination of coordination between insurers. (defined for API consistency)
    property type_ : TFhirCodeableConcept read FType_ write SetType_;
    // The type or context of the accident event for the purposes of selection of potential insurance coverages and determination of coordination between insurers.
    property type_Element : TFhirCodeableConcept read FType_ write SetType_;

    // Typed access to The physical location of the accident event. (defined for API consistency)
    property location : TFhirDataType read FLocation write SetLocation;
    // The physical location of the accident event.
    property locationElement : TFhirDataType read FLocation write SetLocation;

  end;

  TFhirExplanationOfBenefitAccidentListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirExplanationOfBenefitAccidentList;
    function GetCurrent : TFhirExplanationOfBenefitAccident;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirExplanationOfBenefitAccidentList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirExplanationOfBenefitAccident read GetCurrent;
  end;

  TFhirExplanationOfBenefitAccidentList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirExplanationOfBenefitAccident;
    procedure SetItemN(index : Integer; value : TFhirExplanationOfBenefitAccident);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirExplanationOfBenefitAccidentList; overload;
    function Clone : TFhirExplanationOfBenefitAccidentList; overload;
    function GetEnumerator : TFhirExplanationOfBenefitAccidentListEnumerator;
    
    //  Add a FhirExplanationOfBenefitAccident to the end of the list.
    function Append : TFhirExplanationOfBenefitAccident;
    
    // Add an already existing FhirExplanationOfBenefitAccident to the end of the list.
    procedure AddItem(value : TFhirExplanationOfBenefitAccident); overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirExplanationOfBenefitAccident) : Integer;
    
    // Insert FhirExplanationOfBenefitAccident before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirExplanationOfBenefitAccident;
    
    // Insert an existing FhirExplanationOfBenefitAccident before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirExplanationOfBenefitAccident);
    
    // Get the iIndexth FhirExplanationOfBenefitAccident. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirExplanationOfBenefitAccident);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirExplanationOfBenefitAccident;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirExplanationOfBenefitAccidents[index : Integer] : TFhirExplanationOfBenefitAccident read GetItemN write SetItemN; default;
  End;

  // A claim line. Either a simple (a product or service) or a 'group' of details which can also be a simple items or groups of sub-details.
  TFhirExplanationOfBenefitItem = class (TFhirBackboneElement)
  protected
    FSequence : TFhirPositiveInt;
    FcareTeamSequenceList : TFhirPositiveIntList;
    FdiagnosisSequenceList : TFhirPositiveIntList;
    FprocedureSequenceList : TFhirPositiveIntList;
    FinformationSequenceList : TFhirPositiveIntList;
    FRevenue : TFhirCodeableConcept;
    FCategory : TFhirCodeableConcept;
    FProductOrService : TFhirCodeableConcept;
    FmodifierList : TFhirCodeableConceptList;
    FprogramCodeList : TFhirCodeableConceptList;
    FServiced : TFhirDataType;
    FLocation : TFhirDataType;
    FQuantity : TFhirQuantity;
    FUnitPrice : TFhirMoney;
    FFactor : TFhirDecimal;
    FNet : TFhirMoney;
    FudiList : TFhirReferenceList;
    FBodySite : TFhirCodeableConcept;
    FsubSiteList : TFhirCodeableConceptList;
    FencounterList : TFhirReferenceList;
    FnoteNumberList : TFhirPositiveIntList;
    FadjudicationList : TFhirExplanationOfBenefitItemAdjudicationList;
    FdetailList : TFhirExplanationOfBenefitItemDetailList;
    procedure SetSequence(value : TFhirPositiveInt);
    function GetSequenceST : String;
    procedure SetSequenceST(value : String);
    function GetCareTeamSequenceList : TFhirPositiveIntList;
    function GetHasCareTeamSequenceList : Boolean;
    function GetDiagnosisSequenceList : TFhirPositiveIntList;
    function GetHasDiagnosisSequenceList : Boolean;
    function GetProcedureSequenceList : TFhirPositiveIntList;
    function GetHasProcedureSequenceList : Boolean;
    function GetInformationSequenceList : TFhirPositiveIntList;
    function GetHasInformationSequenceList : Boolean;
    procedure SetRevenue(value : TFhirCodeableConcept);
    procedure SetCategory(value : TFhirCodeableConcept);
    procedure SetProductOrService(value : TFhirCodeableConcept);
    function GetModifierList : TFhirCodeableConceptList;
    function GetHasModifierList : Boolean;
    function GetProgramCodeList : TFhirCodeableConceptList;
    function GetHasProgramCodeList : Boolean;
    procedure SetServiced(value : TFhirDataType);
    procedure SetLocation(value : TFhirDataType);
    procedure SetQuantity(value : TFhirQuantity);
    procedure SetUnitPrice(value : TFhirMoney);
    procedure SetFactor(value : TFhirDecimal);
    function GetFactorST : String;
    procedure SetFactorST(value : String);
    procedure SetNet(value : TFhirMoney);
    function GetUdiList : TFhirReferenceList;
    function GetHasUdiList : Boolean;
    procedure SetBodySite(value : TFhirCodeableConcept);
    function GetSubSiteList : TFhirCodeableConceptList;
    function GetHasSubSiteList : Boolean;
    function GetEncounterList : TFhirReferenceList;
    function GetHasEncounterList : Boolean;
    function GetNoteNumberList : TFhirPositiveIntList;
    function GetHasNoteNumberList : Boolean;
    function GetAdjudicationList : TFhirExplanationOfBenefitItemAdjudicationList;
    function GetHasAdjudicationList : Boolean;
    function GetDetailList : TFhirExplanationOfBenefitItemDetailList;
    function GetHasDetailList : Boolean;
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirExplanationOfBenefitItem; overload;
    function Clone : TFhirExplanationOfBenefitItem; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to A number to uniquely identify item entries.
    property sequence : String read GetSequenceST write SetSequenceST;
    // A number to uniquely identify item entries.
    property sequenceElement : TFhirPositiveInt read FSequence write SetSequence;

    // Care team members related to this service or product.
    property careTeamSequenceList : TFhirPositiveIntList read GetCareTeamSequenceList;
    property hasCareTeamSequenceList : boolean read GetHasCareTeamSequenceList;

    // Diagnoses applicable for this service or product.
    property diagnosisSequenceList : TFhirPositiveIntList read GetDiagnosisSequenceList;
    property hasDiagnosisSequenceList : boolean read GetHasDiagnosisSequenceList;

    // Procedures applicable for this service or product.
    property procedureSequenceList : TFhirPositiveIntList read GetProcedureSequenceList;
    property hasProcedureSequenceList : boolean read GetHasProcedureSequenceList;

    // Exceptions, special conditions and supporting information applicable for this service or product.
    property informationSequenceList : TFhirPositiveIntList read GetInformationSequenceList;
    property hasInformationSequenceList : boolean read GetHasInformationSequenceList;

    // Typed access to The type of revenue or cost center providing the product and/or service. (defined for API consistency)
    property revenue : TFhirCodeableConcept read FRevenue write SetRevenue;
    // The type of revenue or cost center providing the product and/or service.
    property revenueElement : TFhirCodeableConcept read FRevenue write SetRevenue;

    // Typed access to Code to identify the general type of benefits under which products and services are provided. (defined for API consistency)
    property category : TFhirCodeableConcept read FCategory write SetCategory;
    // Code to identify the general type of benefits under which products and services are provided.
    property categoryElement : TFhirCodeableConcept read FCategory write SetCategory;

    // Typed access to When the value is a group code then this item collects a set of related claim details, otherwise this contains the product, service, drug or other billing code for the item. (defined for API consistency)
    property productOrService : TFhirCodeableConcept read FProductOrService write SetProductOrService;
    // When the value is a group code then this item collects a set of related claim details, otherwise this contains the product, service, drug or other billing code for the item.
    property productOrServiceElement : TFhirCodeableConcept read FProductOrService write SetProductOrService;

    // Item typification or modifiers codes to convey additional context for the product or service.
    property modifierList : TFhirCodeableConceptList read GetModifierList;
    property hasModifierList : boolean read GetHasModifierList;

    // Identifies the program under which this may be recovered.
    property programCodeList : TFhirCodeableConceptList read GetProgramCodeList;
    property hasProgramCodeList : boolean read GetHasProgramCodeList;

    // Typed access to The date or dates when the service or product was supplied, performed or completed. (defined for API consistency)
    property serviced : TFhirDataType read FServiced write SetServiced;
    // The date or dates when the service or product was supplied, performed or completed.
    property servicedElement : TFhirDataType read FServiced write SetServiced;

    // Typed access to Where the product or service was provided. (defined for API consistency)
    property location : TFhirDataType read FLocation write SetLocation;
    // Where the product or service was provided.
    property locationElement : TFhirDataType read FLocation write SetLocation;

    // Typed access to The number of repetitions of a service or product. (defined for API consistency)
    property quantity : TFhirQuantity read FQuantity write SetQuantity;
    // The number of repetitions of a service or product.
    property quantityElement : TFhirQuantity read FQuantity write SetQuantity;

    // Typed access to If the item is not a group then this is the fee for the product or service, otherwise this is the total of the fees for the details of the group. (defined for API consistency)
    property unitPrice : TFhirMoney read FUnitPrice write SetUnitPrice;
    // If the item is not a group then this is the fee for the product or service, otherwise this is the total of the fees for the details of the group.
    property unitPriceElement : TFhirMoney read FUnitPrice write SetUnitPrice;

    // Typed access to A real number that represents a multiplier used in determining the overall value of services delivered and/or goods received. The concept of a Factor allows for a discount or surcharge multiplier to be applied to a monetary amount.
    property factor : String read GetFactorST write SetFactorST;
    // A real number that represents a multiplier used in determining the overall value of services delivered and/or goods received. The concept of a Factor allows for a discount or surcharge multiplier to be applied to a monetary amount.
    property factorElement : TFhirDecimal read FFactor write SetFactor;

    // Typed access to The quantity times the unit price for an additional service or product or charge. (defined for API consistency)
    property net : TFhirMoney read FNet write SetNet;
    // The quantity times the unit price for an additional service or product or charge.
    property netElement : TFhirMoney read FNet write SetNet;

    // Unique Device Identifiers associated with this line item.
    property udiList : TFhirReferenceList read GetUdiList;
    property hasUdiList : boolean read GetHasUdiList;

    // Typed access to Physical service site on the patient (limb, tooth, etc.). (defined for API consistency)
    property bodySite : TFhirCodeableConcept read FBodySite write SetBodySite;
    // Physical service site on the patient (limb, tooth, etc.).
    property bodySiteElement : TFhirCodeableConcept read FBodySite write SetBodySite;

    // A region or surface of the bodySite, e.g. limb region or tooth surface(s).
    property subSiteList : TFhirCodeableConceptList read GetSubSiteList;
    property hasSubSiteList : boolean read GetHasSubSiteList;

    // A billed item may include goods or services provided in multiple encounters.
    property encounterList : TFhirReferenceList read GetEncounterList;
    property hasEncounterList : boolean read GetHasEncounterList;

    // The numbers associated with notes below which apply to the adjudication of this item.
    property noteNumberList : TFhirPositiveIntList read GetNoteNumberList;
    property hasNoteNumberList : boolean read GetHasNoteNumberList;

    // If this item is a group then the values here are a summary of the adjudication of the detail items. If this item is a simple product or service then this is the result of the adjudication of this item.
    property adjudicationList : TFhirExplanationOfBenefitItemAdjudicationList read GetAdjudicationList;
    property hasAdjudicationList : boolean read GetHasAdjudicationList;

    // Second-tier of goods and services.
    property detailList : TFhirExplanationOfBenefitItemDetailList read GetDetailList;
    property hasDetailList : boolean read GetHasDetailList;

  end;

  TFhirExplanationOfBenefitItemListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirExplanationOfBenefitItemList;
    function GetCurrent : TFhirExplanationOfBenefitItem;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirExplanationOfBenefitItemList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirExplanationOfBenefitItem read GetCurrent;
  end;

  TFhirExplanationOfBenefitItemList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirExplanationOfBenefitItem;
    procedure SetItemN(index : Integer; value : TFhirExplanationOfBenefitItem);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirExplanationOfBenefitItemList; overload;
    function Clone : TFhirExplanationOfBenefitItemList; overload;
    function GetEnumerator : TFhirExplanationOfBenefitItemListEnumerator;
    
    //  Add a FhirExplanationOfBenefitItem to the end of the list.
    function Append : TFhirExplanationOfBenefitItem;
    
    // Add an already existing FhirExplanationOfBenefitItem to the end of the list.
    procedure AddItem(value : TFhirExplanationOfBenefitItem); overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirExplanationOfBenefitItem) : Integer;
    
    // Insert FhirExplanationOfBenefitItem before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirExplanationOfBenefitItem;
    
    // Insert an existing FhirExplanationOfBenefitItem before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirExplanationOfBenefitItem);
    
    // Get the iIndexth FhirExplanationOfBenefitItem. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirExplanationOfBenefitItem);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirExplanationOfBenefitItem;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirExplanationOfBenefitItems[index : Integer] : TFhirExplanationOfBenefitItem read GetItemN write SetItemN; default;
  End;

  // If this item is a group then the values here are a summary of the adjudication of the detail items. If this item is a simple product or service then this is the result of the adjudication of this item.
  TFhirExplanationOfBenefitItemAdjudication = class (TFhirBackboneElement)
  protected
    FCategory : TFhirCodeableConcept;
    FReason : TFhirCodeableConcept;
    FAmount : TFhirMoney;
    FValue : TFhirDecimal;
    procedure SetCategory(value : TFhirCodeableConcept);
    procedure SetReason(value : TFhirCodeableConcept);
    procedure SetAmount(value : TFhirMoney);
    procedure SetValue(value : TFhirDecimal);
    function GetValueST : String;
    procedure SetValueST(value : String);
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirExplanationOfBenefitItemAdjudication; overload;
    function Clone : TFhirExplanationOfBenefitItemAdjudication; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to A code to indicate the information type of this adjudication record. Information types may include: the value submitted, maximum values or percentages allowed or payable under the plan, amounts that the patient is responsible for in-aggregate or pertaining to this item, amounts paid by other coverages, and the benefit payable for this item. (defined for API consistency)
    property category : TFhirCodeableConcept read FCategory write SetCategory;
    // A code to indicate the information type of this adjudication record. Information types may include: the value submitted, maximum values or percentages allowed or payable under the plan, amounts that the patient is responsible for in-aggregate or pertaining to this item, amounts paid by other coverages, and the benefit payable for this item.
    property categoryElement : TFhirCodeableConcept read FCategory write SetCategory;

    // Typed access to A code supporting the understanding of the adjudication result and explaining variance from expected amount. (defined for API consistency)
    property reason : TFhirCodeableConcept read FReason write SetReason;
    // A code supporting the understanding of the adjudication result and explaining variance from expected amount.
    property reasonElement : TFhirCodeableConcept read FReason write SetReason;

    // Typed access to Monetary amount associated with the category. (defined for API consistency)
    property amount : TFhirMoney read FAmount write SetAmount;
    // Monetary amount associated with the category.
    property amountElement : TFhirMoney read FAmount write SetAmount;

    // Typed access to A non-monetary value associated with the category. Mutually exclusive to the amount element above.
    property value : String read GetValueST write SetValueST;
    // A non-monetary value associated with the category. Mutually exclusive to the amount element above.
    property valueElement : TFhirDecimal read FValue write SetValue;

  end;

  TFhirExplanationOfBenefitItemAdjudicationListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirExplanationOfBenefitItemAdjudicationList;
    function GetCurrent : TFhirExplanationOfBenefitItemAdjudication;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirExplanationOfBenefitItemAdjudicationList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirExplanationOfBenefitItemAdjudication read GetCurrent;
  end;

  TFhirExplanationOfBenefitItemAdjudicationList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirExplanationOfBenefitItemAdjudication;
    procedure SetItemN(index : Integer; value : TFhirExplanationOfBenefitItemAdjudication);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirExplanationOfBenefitItemAdjudicationList; overload;
    function Clone : TFhirExplanationOfBenefitItemAdjudicationList; overload;
    function GetEnumerator : TFhirExplanationOfBenefitItemAdjudicationListEnumerator;
    
    //  Add a FhirExplanationOfBenefitItemAdjudication to the end of the list.
    function Append : TFhirExplanationOfBenefitItemAdjudication;
    
    // Add an already existing FhirExplanationOfBenefitItemAdjudication to the end of the list.
    procedure AddItem(value : TFhirExplanationOfBenefitItemAdjudication); overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirExplanationOfBenefitItemAdjudication) : Integer;
    
    // Insert FhirExplanationOfBenefitItemAdjudication before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirExplanationOfBenefitItemAdjudication;
    
    // Insert an existing FhirExplanationOfBenefitItemAdjudication before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirExplanationOfBenefitItemAdjudication);
    
    // Get the iIndexth FhirExplanationOfBenefitItemAdjudication. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirExplanationOfBenefitItemAdjudication);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirExplanationOfBenefitItemAdjudication;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirExplanationOfBenefitItemAdjudications[index : Integer] : TFhirExplanationOfBenefitItemAdjudication read GetItemN write SetItemN; default;
  End;

  // Second-tier of goods and services.
  TFhirExplanationOfBenefitItemDetail = class (TFhirBackboneElement)
  protected
    FSequence : TFhirPositiveInt;
    FRevenue : TFhirCodeableConcept;
    FCategory : TFhirCodeableConcept;
    FProductOrService : TFhirCodeableConcept;
    FmodifierList : TFhirCodeableConceptList;
    FprogramCodeList : TFhirCodeableConceptList;
    FQuantity : TFhirQuantity;
    FUnitPrice : TFhirMoney;
    FFactor : TFhirDecimal;
    FNet : TFhirMoney;
    FudiList : TFhirReferenceList;
    FnoteNumberList : TFhirPositiveIntList;
    FadjudicationList : TFhirExplanationOfBenefitItemAdjudicationList;
    FsubDetailList : TFhirExplanationOfBenefitItemDetailSubDetailList;
    procedure SetSequence(value : TFhirPositiveInt);
    function GetSequenceST : String;
    procedure SetSequenceST(value : String);
    procedure SetRevenue(value : TFhirCodeableConcept);
    procedure SetCategory(value : TFhirCodeableConcept);
    procedure SetProductOrService(value : TFhirCodeableConcept);
    function GetModifierList : TFhirCodeableConceptList;
    function GetHasModifierList : Boolean;
    function GetProgramCodeList : TFhirCodeableConceptList;
    function GetHasProgramCodeList : Boolean;
    procedure SetQuantity(value : TFhirQuantity);
    procedure SetUnitPrice(value : TFhirMoney);
    procedure SetFactor(value : TFhirDecimal);
    function GetFactorST : String;
    procedure SetFactorST(value : String);
    procedure SetNet(value : TFhirMoney);
    function GetUdiList : TFhirReferenceList;
    function GetHasUdiList : Boolean;
    function GetNoteNumberList : TFhirPositiveIntList;
    function GetHasNoteNumberList : Boolean;
    function GetAdjudicationList : TFhirExplanationOfBenefitItemAdjudicationList;
    function GetHasAdjudicationList : Boolean;
    function GetSubDetailList : TFhirExplanationOfBenefitItemDetailSubDetailList;
    function GetHasSubDetailList : Boolean;
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirExplanationOfBenefitItemDetail; overload;
    function Clone : TFhirExplanationOfBenefitItemDetail; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to A claim detail line. Either a simple (a product or service) or a 'group' of sub-details which are simple items.
    property sequence : String read GetSequenceST write SetSequenceST;
    // A claim detail line. Either a simple (a product or service) or a 'group' of sub-details which are simple items.
    property sequenceElement : TFhirPositiveInt read FSequence write SetSequence;

    // Typed access to The type of revenue or cost center providing the product and/or service. (defined for API consistency)
    property revenue : TFhirCodeableConcept read FRevenue write SetRevenue;
    // The type of revenue or cost center providing the product and/or service.
    property revenueElement : TFhirCodeableConcept read FRevenue write SetRevenue;

    // Typed access to Code to identify the general type of benefits under which products and services are provided. (defined for API consistency)
    property category : TFhirCodeableConcept read FCategory write SetCategory;
    // Code to identify the general type of benefits under which products and services are provided.
    property categoryElement : TFhirCodeableConcept read FCategory write SetCategory;

    // Typed access to When the value is a group code then this item collects a set of related claim details, otherwise this contains the product, service, drug or other billing code for the item. (defined for API consistency)
    property productOrService : TFhirCodeableConcept read FProductOrService write SetProductOrService;
    // When the value is a group code then this item collects a set of related claim details, otherwise this contains the product, service, drug or other billing code for the item.
    property productOrServiceElement : TFhirCodeableConcept read FProductOrService write SetProductOrService;

    // Item typification or modifiers codes to convey additional context for the product or service.
    property modifierList : TFhirCodeableConceptList read GetModifierList;
    property hasModifierList : boolean read GetHasModifierList;

    // Identifies the program under which this may be recovered.
    property programCodeList : TFhirCodeableConceptList read GetProgramCodeList;
    property hasProgramCodeList : boolean read GetHasProgramCodeList;

    // Typed access to The number of repetitions of a service or product. (defined for API consistency)
    property quantity : TFhirQuantity read FQuantity write SetQuantity;
    // The number of repetitions of a service or product.
    property quantityElement : TFhirQuantity read FQuantity write SetQuantity;

    // Typed access to If the item is not a group then this is the fee for the product or service, otherwise this is the total of the fees for the details of the group. (defined for API consistency)
    property unitPrice : TFhirMoney read FUnitPrice write SetUnitPrice;
    // If the item is not a group then this is the fee for the product or service, otherwise this is the total of the fees for the details of the group.
    property unitPriceElement : TFhirMoney read FUnitPrice write SetUnitPrice;

    // Typed access to A real number that represents a multiplier used in determining the overall value of services delivered and/or goods received. The concept of a Factor allows for a discount or surcharge multiplier to be applied to a monetary amount.
    property factor : String read GetFactorST write SetFactorST;
    // A real number that represents a multiplier used in determining the overall value of services delivered and/or goods received. The concept of a Factor allows for a discount or surcharge multiplier to be applied to a monetary amount.
    property factorElement : TFhirDecimal read FFactor write SetFactor;

    // Typed access to The quantity times the unit price for an additional service or product or charge. (defined for API consistency)
    property net : TFhirMoney read FNet write SetNet;
    // The quantity times the unit price for an additional service or product or charge.
    property netElement : TFhirMoney read FNet write SetNet;

    // Unique Device Identifiers associated with this line item.
    property udiList : TFhirReferenceList read GetUdiList;
    property hasUdiList : boolean read GetHasUdiList;

    // The numbers associated with notes below which apply to the adjudication of this item.
    property noteNumberList : TFhirPositiveIntList read GetNoteNumberList;
    property hasNoteNumberList : boolean read GetHasNoteNumberList;

    // The adjudication results.
    property adjudicationList : TFhirExplanationOfBenefitItemAdjudicationList read GetAdjudicationList;
    property hasAdjudicationList : boolean read GetHasAdjudicationList;

    // Third-tier of goods and services.
    property subDetailList : TFhirExplanationOfBenefitItemDetailSubDetailList read GetSubDetailList;
    property hasSubDetailList : boolean read GetHasSubDetailList;

  end;

  TFhirExplanationOfBenefitItemDetailListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirExplanationOfBenefitItemDetailList;
    function GetCurrent : TFhirExplanationOfBenefitItemDetail;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirExplanationOfBenefitItemDetailList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirExplanationOfBenefitItemDetail read GetCurrent;
  end;

  TFhirExplanationOfBenefitItemDetailList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirExplanationOfBenefitItemDetail;
    procedure SetItemN(index : Integer; value : TFhirExplanationOfBenefitItemDetail);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirExplanationOfBenefitItemDetailList; overload;
    function Clone : TFhirExplanationOfBenefitItemDetailList; overload;
    function GetEnumerator : TFhirExplanationOfBenefitItemDetailListEnumerator;
    
    //  Add a FhirExplanationOfBenefitItemDetail to the end of the list.
    function Append : TFhirExplanationOfBenefitItemDetail;
    
    // Add an already existing FhirExplanationOfBenefitItemDetail to the end of the list.
    procedure AddItem(value : TFhirExplanationOfBenefitItemDetail); overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirExplanationOfBenefitItemDetail) : Integer;
    
    // Insert FhirExplanationOfBenefitItemDetail before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirExplanationOfBenefitItemDetail;
    
    // Insert an existing FhirExplanationOfBenefitItemDetail before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirExplanationOfBenefitItemDetail);
    
    // Get the iIndexth FhirExplanationOfBenefitItemDetail. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirExplanationOfBenefitItemDetail);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirExplanationOfBenefitItemDetail;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirExplanationOfBenefitItemDetails[index : Integer] : TFhirExplanationOfBenefitItemDetail read GetItemN write SetItemN; default;
  End;

  // Third-tier of goods and services.
  TFhirExplanationOfBenefitItemDetailSubDetail = class (TFhirBackboneElement)
  protected
    FSequence : TFhirPositiveInt;
    FRevenue : TFhirCodeableConcept;
    FCategory : TFhirCodeableConcept;
    FProductOrService : TFhirCodeableConcept;
    FmodifierList : TFhirCodeableConceptList;
    FprogramCodeList : TFhirCodeableConceptList;
    FQuantity : TFhirQuantity;
    FUnitPrice : TFhirMoney;
    FFactor : TFhirDecimal;
    FNet : TFhirMoney;
    FudiList : TFhirReferenceList;
    FnoteNumberList : TFhirPositiveIntList;
    FadjudicationList : TFhirExplanationOfBenefitItemAdjudicationList;
    procedure SetSequence(value : TFhirPositiveInt);
    function GetSequenceST : String;
    procedure SetSequenceST(value : String);
    procedure SetRevenue(value : TFhirCodeableConcept);
    procedure SetCategory(value : TFhirCodeableConcept);
    procedure SetProductOrService(value : TFhirCodeableConcept);
    function GetModifierList : TFhirCodeableConceptList;
    function GetHasModifierList : Boolean;
    function GetProgramCodeList : TFhirCodeableConceptList;
    function GetHasProgramCodeList : Boolean;
    procedure SetQuantity(value : TFhirQuantity);
    procedure SetUnitPrice(value : TFhirMoney);
    procedure SetFactor(value : TFhirDecimal);
    function GetFactorST : String;
    procedure SetFactorST(value : String);
    procedure SetNet(value : TFhirMoney);
    function GetUdiList : TFhirReferenceList;
    function GetHasUdiList : Boolean;
    function GetNoteNumberList : TFhirPositiveIntList;
    function GetHasNoteNumberList : Boolean;
    function GetAdjudicationList : TFhirExplanationOfBenefitItemAdjudicationList;
    function GetHasAdjudicationList : Boolean;
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirExplanationOfBenefitItemDetailSubDetail; overload;
    function Clone : TFhirExplanationOfBenefitItemDetailSubDetail; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to A claim detail line. Either a simple (a product or service) or a 'group' of sub-details which are simple items.
    property sequence : String read GetSequenceST write SetSequenceST;
    // A claim detail line. Either a simple (a product or service) or a 'group' of sub-details which are simple items.
    property sequenceElement : TFhirPositiveInt read FSequence write SetSequence;

    // Typed access to The type of revenue or cost center providing the product and/or service. (defined for API consistency)
    property revenue : TFhirCodeableConcept read FRevenue write SetRevenue;
    // The type of revenue or cost center providing the product and/or service.
    property revenueElement : TFhirCodeableConcept read FRevenue write SetRevenue;

    // Typed access to Code to identify the general type of benefits under which products and services are provided. (defined for API consistency)
    property category : TFhirCodeableConcept read FCategory write SetCategory;
    // Code to identify the general type of benefits under which products and services are provided.
    property categoryElement : TFhirCodeableConcept read FCategory write SetCategory;

    // Typed access to When the value is a group code then this item collects a set of related claim details, otherwise this contains the product, service, drug or other billing code for the item. (defined for API consistency)
    property productOrService : TFhirCodeableConcept read FProductOrService write SetProductOrService;
    // When the value is a group code then this item collects a set of related claim details, otherwise this contains the product, service, drug or other billing code for the item.
    property productOrServiceElement : TFhirCodeableConcept read FProductOrService write SetProductOrService;

    // Item typification or modifiers codes to convey additional context for the product or service.
    property modifierList : TFhirCodeableConceptList read GetModifierList;
    property hasModifierList : boolean read GetHasModifierList;

    // Identifies the program under which this may be recovered.
    property programCodeList : TFhirCodeableConceptList read GetProgramCodeList;
    property hasProgramCodeList : boolean read GetHasProgramCodeList;

    // Typed access to The number of repetitions of a service or product. (defined for API consistency)
    property quantity : TFhirQuantity read FQuantity write SetQuantity;
    // The number of repetitions of a service or product.
    property quantityElement : TFhirQuantity read FQuantity write SetQuantity;

    // Typed access to If the item is not a group then this is the fee for the product or service, otherwise this is the total of the fees for the details of the group. (defined for API consistency)
    property unitPrice : TFhirMoney read FUnitPrice write SetUnitPrice;
    // If the item is not a group then this is the fee for the product or service, otherwise this is the total of the fees for the details of the group.
    property unitPriceElement : TFhirMoney read FUnitPrice write SetUnitPrice;

    // Typed access to A real number that represents a multiplier used in determining the overall value of services delivered and/or goods received. The concept of a Factor allows for a discount or surcharge multiplier to be applied to a monetary amount.
    property factor : String read GetFactorST write SetFactorST;
    // A real number that represents a multiplier used in determining the overall value of services delivered and/or goods received. The concept of a Factor allows for a discount or surcharge multiplier to be applied to a monetary amount.
    property factorElement : TFhirDecimal read FFactor write SetFactor;

    // Typed access to The quantity times the unit price for an additional service or product or charge. (defined for API consistency)
    property net : TFhirMoney read FNet write SetNet;
    // The quantity times the unit price for an additional service or product or charge.
    property netElement : TFhirMoney read FNet write SetNet;

    // Unique Device Identifiers associated with this line item.
    property udiList : TFhirReferenceList read GetUdiList;
    property hasUdiList : boolean read GetHasUdiList;

    // The numbers associated with notes below which apply to the adjudication of this item.
    property noteNumberList : TFhirPositiveIntList read GetNoteNumberList;
    property hasNoteNumberList : boolean read GetHasNoteNumberList;

    // The adjudication results.
    property adjudicationList : TFhirExplanationOfBenefitItemAdjudicationList read GetAdjudicationList;
    property hasAdjudicationList : boolean read GetHasAdjudicationList;

  end;

  TFhirExplanationOfBenefitItemDetailSubDetailListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirExplanationOfBenefitItemDetailSubDetailList;
    function GetCurrent : TFhirExplanationOfBenefitItemDetailSubDetail;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirExplanationOfBenefitItemDetailSubDetailList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirExplanationOfBenefitItemDetailSubDetail read GetCurrent;
  end;

  TFhirExplanationOfBenefitItemDetailSubDetailList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirExplanationOfBenefitItemDetailSubDetail;
    procedure SetItemN(index : Integer; value : TFhirExplanationOfBenefitItemDetailSubDetail);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirExplanationOfBenefitItemDetailSubDetailList; overload;
    function Clone : TFhirExplanationOfBenefitItemDetailSubDetailList; overload;
    function GetEnumerator : TFhirExplanationOfBenefitItemDetailSubDetailListEnumerator;
    
    //  Add a FhirExplanationOfBenefitItemDetailSubDetail to the end of the list.
    function Append : TFhirExplanationOfBenefitItemDetailSubDetail;
    
    // Add an already existing FhirExplanationOfBenefitItemDetailSubDetail to the end of the list.
    procedure AddItem(value : TFhirExplanationOfBenefitItemDetailSubDetail); overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirExplanationOfBenefitItemDetailSubDetail) : Integer;
    
    // Insert FhirExplanationOfBenefitItemDetailSubDetail before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirExplanationOfBenefitItemDetailSubDetail;
    
    // Insert an existing FhirExplanationOfBenefitItemDetailSubDetail before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirExplanationOfBenefitItemDetailSubDetail);
    
    // Get the iIndexth FhirExplanationOfBenefitItemDetailSubDetail. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirExplanationOfBenefitItemDetailSubDetail);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirExplanationOfBenefitItemDetailSubDetail;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirExplanationOfBenefitItemDetailSubDetails[index : Integer] : TFhirExplanationOfBenefitItemDetailSubDetail read GetItemN write SetItemN; default;
  End;

  // The first-tier service adjudications for payor added product or service lines.
  TFhirExplanationOfBenefitAddItem = class (TFhirBackboneElement)
  protected
    FitemSequenceList : TFhirPositiveIntList;
    FdetailSequenceList : TFhirPositiveIntList;
    FsubDetailSequenceList : TFhirPositiveIntList;
    FproviderList : TFhirReferenceList;
    FProductOrService : TFhirCodeableConcept;
    FmodifierList : TFhirCodeableConceptList;
    FprogramCodeList : TFhirCodeableConceptList;
    FServiced : TFhirDataType;
    FLocation : TFhirDataType;
    FQuantity : TFhirQuantity;
    FUnitPrice : TFhirMoney;
    FFactor : TFhirDecimal;
    FNet : TFhirMoney;
    FBodySite : TFhirCodeableConcept;
    FsubSiteList : TFhirCodeableConceptList;
    FnoteNumberList : TFhirPositiveIntList;
    FadjudicationList : TFhirExplanationOfBenefitItemAdjudicationList;
    FdetailList : TFhirExplanationOfBenefitAddItemDetailList;
    function GetItemSequenceList : TFhirPositiveIntList;
    function GetHasItemSequenceList : Boolean;
    function GetDetailSequenceList : TFhirPositiveIntList;
    function GetHasDetailSequenceList : Boolean;
    function GetSubDetailSequenceList : TFhirPositiveIntList;
    function GetHasSubDetailSequenceList : Boolean;
    function GetProviderList : TFhirReferenceList;
    function GetHasProviderList : Boolean;
    procedure SetProductOrService(value : TFhirCodeableConcept);
    function GetModifierList : TFhirCodeableConceptList;
    function GetHasModifierList : Boolean;
    function GetProgramCodeList : TFhirCodeableConceptList;
    function GetHasProgramCodeList : Boolean;
    procedure SetServiced(value : TFhirDataType);
    procedure SetLocation(value : TFhirDataType);
    procedure SetQuantity(value : TFhirQuantity);
    procedure SetUnitPrice(value : TFhirMoney);
    procedure SetFactor(value : TFhirDecimal);
    function GetFactorST : String;
    procedure SetFactorST(value : String);
    procedure SetNet(value : TFhirMoney);
    procedure SetBodySite(value : TFhirCodeableConcept);
    function GetSubSiteList : TFhirCodeableConceptList;
    function GetHasSubSiteList : Boolean;
    function GetNoteNumberList : TFhirPositiveIntList;
    function GetHasNoteNumberList : Boolean;
    function GetAdjudicationList : TFhirExplanationOfBenefitItemAdjudicationList;
    function GetHasAdjudicationList : Boolean;
    function GetDetailList : TFhirExplanationOfBenefitAddItemDetailList;
    function GetHasDetailList : Boolean;
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirExplanationOfBenefitAddItem; overload;
    function Clone : TFhirExplanationOfBenefitAddItem; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Claim items which this service line is intended to replace.
    property itemSequenceList : TFhirPositiveIntList read GetItemSequenceList;
    property hasItemSequenceList : boolean read GetHasItemSequenceList;

    // The sequence number of the details within the claim item which this line is intended to replace.
    property detailSequenceList : TFhirPositiveIntList read GetDetailSequenceList;
    property hasDetailSequenceList : boolean read GetHasDetailSequenceList;

    // The sequence number of the sub-details woithin the details within the claim item which this line is intended to replace.
    property subDetailSequenceList : TFhirPositiveIntList read GetSubDetailSequenceList;
    property hasSubDetailSequenceList : boolean read GetHasSubDetailSequenceList;

    // The providers who are authorized for the services rendered to the patient.
    property providerList : TFhirReferenceList read GetProviderList;
    property hasProviderList : boolean read GetHasProviderList;

    // Typed access to When the value is a group code then this item collects a set of related claim details, otherwise this contains the product, service, drug or other billing code for the item. (defined for API consistency)
    property productOrService : TFhirCodeableConcept read FProductOrService write SetProductOrService;
    // When the value is a group code then this item collects a set of related claim details, otherwise this contains the product, service, drug or other billing code for the item.
    property productOrServiceElement : TFhirCodeableConcept read FProductOrService write SetProductOrService;

    // Item typification or modifiers codes to convey additional context for the product or service.
    property modifierList : TFhirCodeableConceptList read GetModifierList;
    property hasModifierList : boolean read GetHasModifierList;

    // Identifies the program under which this may be recovered.
    property programCodeList : TFhirCodeableConceptList read GetProgramCodeList;
    property hasProgramCodeList : boolean read GetHasProgramCodeList;

    // Typed access to The date or dates when the service or product was supplied, performed or completed. (defined for API consistency)
    property serviced : TFhirDataType read FServiced write SetServiced;
    // The date or dates when the service or product was supplied, performed or completed.
    property servicedElement : TFhirDataType read FServiced write SetServiced;

    // Typed access to Where the product or service was provided. (defined for API consistency)
    property location : TFhirDataType read FLocation write SetLocation;
    // Where the product or service was provided.
    property locationElement : TFhirDataType read FLocation write SetLocation;

    // Typed access to The number of repetitions of a service or product. (defined for API consistency)
    property quantity : TFhirQuantity read FQuantity write SetQuantity;
    // The number of repetitions of a service or product.
    property quantityElement : TFhirQuantity read FQuantity write SetQuantity;

    // Typed access to If the item is not a group then this is the fee for the product or service, otherwise this is the total of the fees for the details of the group. (defined for API consistency)
    property unitPrice : TFhirMoney read FUnitPrice write SetUnitPrice;
    // If the item is not a group then this is the fee for the product or service, otherwise this is the total of the fees for the details of the group.
    property unitPriceElement : TFhirMoney read FUnitPrice write SetUnitPrice;

    // Typed access to A real number that represents a multiplier used in determining the overall value of services delivered and/or goods received. The concept of a Factor allows for a discount or surcharge multiplier to be applied to a monetary amount.
    property factor : String read GetFactorST write SetFactorST;
    // A real number that represents a multiplier used in determining the overall value of services delivered and/or goods received. The concept of a Factor allows for a discount or surcharge multiplier to be applied to a monetary amount.
    property factorElement : TFhirDecimal read FFactor write SetFactor;

    // Typed access to The quantity times the unit price for an additional service or product or charge. (defined for API consistency)
    property net : TFhirMoney read FNet write SetNet;
    // The quantity times the unit price for an additional service or product or charge.
    property netElement : TFhirMoney read FNet write SetNet;

    // Typed access to Physical service site on the patient (limb, tooth, etc.). (defined for API consistency)
    property bodySite : TFhirCodeableConcept read FBodySite write SetBodySite;
    // Physical service site on the patient (limb, tooth, etc.).
    property bodySiteElement : TFhirCodeableConcept read FBodySite write SetBodySite;

    // A region or surface of the bodySite, e.g. limb region or tooth surface(s).
    property subSiteList : TFhirCodeableConceptList read GetSubSiteList;
    property hasSubSiteList : boolean read GetHasSubSiteList;

    // The numbers associated with notes below which apply to the adjudication of this item.
    property noteNumberList : TFhirPositiveIntList read GetNoteNumberList;
    property hasNoteNumberList : boolean read GetHasNoteNumberList;

    // The adjudication results.
    property adjudicationList : TFhirExplanationOfBenefitItemAdjudicationList read GetAdjudicationList;
    property hasAdjudicationList : boolean read GetHasAdjudicationList;

    // The second-tier service adjudications for payor added services.
    property detailList : TFhirExplanationOfBenefitAddItemDetailList read GetDetailList;
    property hasDetailList : boolean read GetHasDetailList;

  end;

  TFhirExplanationOfBenefitAddItemListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirExplanationOfBenefitAddItemList;
    function GetCurrent : TFhirExplanationOfBenefitAddItem;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirExplanationOfBenefitAddItemList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirExplanationOfBenefitAddItem read GetCurrent;
  end;

  TFhirExplanationOfBenefitAddItemList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirExplanationOfBenefitAddItem;
    procedure SetItemN(index : Integer; value : TFhirExplanationOfBenefitAddItem);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirExplanationOfBenefitAddItemList; overload;
    function Clone : TFhirExplanationOfBenefitAddItemList; overload;
    function GetEnumerator : TFhirExplanationOfBenefitAddItemListEnumerator;
    
    //  Add a FhirExplanationOfBenefitAddItem to the end of the list.
    function Append : TFhirExplanationOfBenefitAddItem;
    
    // Add an already existing FhirExplanationOfBenefitAddItem to the end of the list.
    procedure AddItem(value : TFhirExplanationOfBenefitAddItem); overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirExplanationOfBenefitAddItem) : Integer;
    
    // Insert FhirExplanationOfBenefitAddItem before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirExplanationOfBenefitAddItem;
    
    // Insert an existing FhirExplanationOfBenefitAddItem before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirExplanationOfBenefitAddItem);
    
    // Get the iIndexth FhirExplanationOfBenefitAddItem. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirExplanationOfBenefitAddItem);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirExplanationOfBenefitAddItem;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirExplanationOfBenefitAddItems[index : Integer] : TFhirExplanationOfBenefitAddItem read GetItemN write SetItemN; default;
  End;

  // The second-tier service adjudications for payor added services.
  TFhirExplanationOfBenefitAddItemDetail = class (TFhirBackboneElement)
  protected
    FProductOrService : TFhirCodeableConcept;
    FmodifierList : TFhirCodeableConceptList;
    FQuantity : TFhirQuantity;
    FUnitPrice : TFhirMoney;
    FFactor : TFhirDecimal;
    FNet : TFhirMoney;
    FnoteNumberList : TFhirPositiveIntList;
    FadjudicationList : TFhirExplanationOfBenefitItemAdjudicationList;
    FsubDetailList : TFhirExplanationOfBenefitAddItemDetailSubDetailList;
    procedure SetProductOrService(value : TFhirCodeableConcept);
    function GetModifierList : TFhirCodeableConceptList;
    function GetHasModifierList : Boolean;
    procedure SetQuantity(value : TFhirQuantity);
    procedure SetUnitPrice(value : TFhirMoney);
    procedure SetFactor(value : TFhirDecimal);
    function GetFactorST : String;
    procedure SetFactorST(value : String);
    procedure SetNet(value : TFhirMoney);
    function GetNoteNumberList : TFhirPositiveIntList;
    function GetHasNoteNumberList : Boolean;
    function GetAdjudicationList : TFhirExplanationOfBenefitItemAdjudicationList;
    function GetHasAdjudicationList : Boolean;
    function GetSubDetailList : TFhirExplanationOfBenefitAddItemDetailSubDetailList;
    function GetHasSubDetailList : Boolean;
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirExplanationOfBenefitAddItemDetail; overload;
    function Clone : TFhirExplanationOfBenefitAddItemDetail; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to When the value is a group code then this item collects a set of related claim details, otherwise this contains the product, service, drug or other billing code for the item. (defined for API consistency)
    property productOrService : TFhirCodeableConcept read FProductOrService write SetProductOrService;
    // When the value is a group code then this item collects a set of related claim details, otherwise this contains the product, service, drug or other billing code for the item.
    property productOrServiceElement : TFhirCodeableConcept read FProductOrService write SetProductOrService;

    // Item typification or modifiers codes to convey additional context for the product or service.
    property modifierList : TFhirCodeableConceptList read GetModifierList;
    property hasModifierList : boolean read GetHasModifierList;

    // Typed access to The number of repetitions of a service or product. (defined for API consistency)
    property quantity : TFhirQuantity read FQuantity write SetQuantity;
    // The number of repetitions of a service or product.
    property quantityElement : TFhirQuantity read FQuantity write SetQuantity;

    // Typed access to If the item is not a group then this is the fee for the product or service, otherwise this is the total of the fees for the details of the group. (defined for API consistency)
    property unitPrice : TFhirMoney read FUnitPrice write SetUnitPrice;
    // If the item is not a group then this is the fee for the product or service, otherwise this is the total of the fees for the details of the group.
    property unitPriceElement : TFhirMoney read FUnitPrice write SetUnitPrice;

    // Typed access to A real number that represents a multiplier used in determining the overall value of services delivered and/or goods received. The concept of a Factor allows for a discount or surcharge multiplier to be applied to a monetary amount.
    property factor : String read GetFactorST write SetFactorST;
    // A real number that represents a multiplier used in determining the overall value of services delivered and/or goods received. The concept of a Factor allows for a discount or surcharge multiplier to be applied to a monetary amount.
    property factorElement : TFhirDecimal read FFactor write SetFactor;

    // Typed access to The quantity times the unit price for an additional service or product or charge. (defined for API consistency)
    property net : TFhirMoney read FNet write SetNet;
    // The quantity times the unit price for an additional service or product or charge.
    property netElement : TFhirMoney read FNet write SetNet;

    // The numbers associated with notes below which apply to the adjudication of this item.
    property noteNumberList : TFhirPositiveIntList read GetNoteNumberList;
    property hasNoteNumberList : boolean read GetHasNoteNumberList;

    // The adjudication results.
    property adjudicationList : TFhirExplanationOfBenefitItemAdjudicationList read GetAdjudicationList;
    property hasAdjudicationList : boolean read GetHasAdjudicationList;

    // The third-tier service adjudications for payor added services.
    property subDetailList : TFhirExplanationOfBenefitAddItemDetailSubDetailList read GetSubDetailList;
    property hasSubDetailList : boolean read GetHasSubDetailList;

  end;

  TFhirExplanationOfBenefitAddItemDetailListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirExplanationOfBenefitAddItemDetailList;
    function GetCurrent : TFhirExplanationOfBenefitAddItemDetail;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirExplanationOfBenefitAddItemDetailList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirExplanationOfBenefitAddItemDetail read GetCurrent;
  end;

  TFhirExplanationOfBenefitAddItemDetailList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirExplanationOfBenefitAddItemDetail;
    procedure SetItemN(index : Integer; value : TFhirExplanationOfBenefitAddItemDetail);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirExplanationOfBenefitAddItemDetailList; overload;
    function Clone : TFhirExplanationOfBenefitAddItemDetailList; overload;
    function GetEnumerator : TFhirExplanationOfBenefitAddItemDetailListEnumerator;
    
    //  Add a FhirExplanationOfBenefitAddItemDetail to the end of the list.
    function Append : TFhirExplanationOfBenefitAddItemDetail;
    
    // Add an already existing FhirExplanationOfBenefitAddItemDetail to the end of the list.
    procedure AddItem(value : TFhirExplanationOfBenefitAddItemDetail); overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirExplanationOfBenefitAddItemDetail) : Integer;
    
    // Insert FhirExplanationOfBenefitAddItemDetail before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirExplanationOfBenefitAddItemDetail;
    
    // Insert an existing FhirExplanationOfBenefitAddItemDetail before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirExplanationOfBenefitAddItemDetail);
    
    // Get the iIndexth FhirExplanationOfBenefitAddItemDetail. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirExplanationOfBenefitAddItemDetail);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirExplanationOfBenefitAddItemDetail;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirExplanationOfBenefitAddItemDetails[index : Integer] : TFhirExplanationOfBenefitAddItemDetail read GetItemN write SetItemN; default;
  End;

  // The third-tier service adjudications for payor added services.
  TFhirExplanationOfBenefitAddItemDetailSubDetail = class (TFhirBackboneElement)
  protected
    FProductOrService : TFhirCodeableConcept;
    FmodifierList : TFhirCodeableConceptList;
    FQuantity : TFhirQuantity;
    FUnitPrice : TFhirMoney;
    FFactor : TFhirDecimal;
    FNet : TFhirMoney;
    FnoteNumberList : TFhirPositiveIntList;
    FadjudicationList : TFhirExplanationOfBenefitItemAdjudicationList;
    procedure SetProductOrService(value : TFhirCodeableConcept);
    function GetModifierList : TFhirCodeableConceptList;
    function GetHasModifierList : Boolean;
    procedure SetQuantity(value : TFhirQuantity);
    procedure SetUnitPrice(value : TFhirMoney);
    procedure SetFactor(value : TFhirDecimal);
    function GetFactorST : String;
    procedure SetFactorST(value : String);
    procedure SetNet(value : TFhirMoney);
    function GetNoteNumberList : TFhirPositiveIntList;
    function GetHasNoteNumberList : Boolean;
    function GetAdjudicationList : TFhirExplanationOfBenefitItemAdjudicationList;
    function GetHasAdjudicationList : Boolean;
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirExplanationOfBenefitAddItemDetailSubDetail; overload;
    function Clone : TFhirExplanationOfBenefitAddItemDetailSubDetail; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to When the value is a group code then this item collects a set of related claim details, otherwise this contains the product, service, drug or other billing code for the item. (defined for API consistency)
    property productOrService : TFhirCodeableConcept read FProductOrService write SetProductOrService;
    // When the value is a group code then this item collects a set of related claim details, otherwise this contains the product, service, drug or other billing code for the item.
    property productOrServiceElement : TFhirCodeableConcept read FProductOrService write SetProductOrService;

    // Item typification or modifiers codes to convey additional context for the product or service.
    property modifierList : TFhirCodeableConceptList read GetModifierList;
    property hasModifierList : boolean read GetHasModifierList;

    // Typed access to The number of repetitions of a service or product. (defined for API consistency)
    property quantity : TFhirQuantity read FQuantity write SetQuantity;
    // The number of repetitions of a service or product.
    property quantityElement : TFhirQuantity read FQuantity write SetQuantity;

    // Typed access to If the item is not a group then this is the fee for the product or service, otherwise this is the total of the fees for the details of the group. (defined for API consistency)
    property unitPrice : TFhirMoney read FUnitPrice write SetUnitPrice;
    // If the item is not a group then this is the fee for the product or service, otherwise this is the total of the fees for the details of the group.
    property unitPriceElement : TFhirMoney read FUnitPrice write SetUnitPrice;

    // Typed access to A real number that represents a multiplier used in determining the overall value of services delivered and/or goods received. The concept of a Factor allows for a discount or surcharge multiplier to be applied to a monetary amount.
    property factor : String read GetFactorST write SetFactorST;
    // A real number that represents a multiplier used in determining the overall value of services delivered and/or goods received. The concept of a Factor allows for a discount or surcharge multiplier to be applied to a monetary amount.
    property factorElement : TFhirDecimal read FFactor write SetFactor;

    // Typed access to The quantity times the unit price for an additional service or product or charge. (defined for API consistency)
    property net : TFhirMoney read FNet write SetNet;
    // The quantity times the unit price for an additional service or product or charge.
    property netElement : TFhirMoney read FNet write SetNet;

    // The numbers associated with notes below which apply to the adjudication of this item.
    property noteNumberList : TFhirPositiveIntList read GetNoteNumberList;
    property hasNoteNumberList : boolean read GetHasNoteNumberList;

    // The adjudication results.
    property adjudicationList : TFhirExplanationOfBenefitItemAdjudicationList read GetAdjudicationList;
    property hasAdjudicationList : boolean read GetHasAdjudicationList;

  end;

  TFhirExplanationOfBenefitAddItemDetailSubDetailListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirExplanationOfBenefitAddItemDetailSubDetailList;
    function GetCurrent : TFhirExplanationOfBenefitAddItemDetailSubDetail;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirExplanationOfBenefitAddItemDetailSubDetailList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirExplanationOfBenefitAddItemDetailSubDetail read GetCurrent;
  end;

  TFhirExplanationOfBenefitAddItemDetailSubDetailList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirExplanationOfBenefitAddItemDetailSubDetail;
    procedure SetItemN(index : Integer; value : TFhirExplanationOfBenefitAddItemDetailSubDetail);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirExplanationOfBenefitAddItemDetailSubDetailList; overload;
    function Clone : TFhirExplanationOfBenefitAddItemDetailSubDetailList; overload;
    function GetEnumerator : TFhirExplanationOfBenefitAddItemDetailSubDetailListEnumerator;
    
    //  Add a FhirExplanationOfBenefitAddItemDetailSubDetail to the end of the list.
    function Append : TFhirExplanationOfBenefitAddItemDetailSubDetail;
    
    // Add an already existing FhirExplanationOfBenefitAddItemDetailSubDetail to the end of the list.
    procedure AddItem(value : TFhirExplanationOfBenefitAddItemDetailSubDetail); overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirExplanationOfBenefitAddItemDetailSubDetail) : Integer;
    
    // Insert FhirExplanationOfBenefitAddItemDetailSubDetail before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirExplanationOfBenefitAddItemDetailSubDetail;
    
    // Insert an existing FhirExplanationOfBenefitAddItemDetailSubDetail before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirExplanationOfBenefitAddItemDetailSubDetail);
    
    // Get the iIndexth FhirExplanationOfBenefitAddItemDetailSubDetail. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirExplanationOfBenefitAddItemDetailSubDetail);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirExplanationOfBenefitAddItemDetailSubDetail;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirExplanationOfBenefitAddItemDetailSubDetails[index : Integer] : TFhirExplanationOfBenefitAddItemDetailSubDetail read GetItemN write SetItemN; default;
  End;

  // Categorized monetary totals for the adjudication.
  TFhirExplanationOfBenefitTotal = class (TFhirBackboneElement)
  protected
    FCategory : TFhirCodeableConcept;
    FAmount : TFhirMoney;
    procedure SetCategory(value : TFhirCodeableConcept);
    procedure SetAmount(value : TFhirMoney);
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirExplanationOfBenefitTotal; overload;
    function Clone : TFhirExplanationOfBenefitTotal; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to A code to indicate the information type of this adjudication record. Information types may include: the value submitted, maximum values or percentages allowed or payable under the plan, amounts that the patient is responsible for in aggregate or pertaining to this item, amounts paid by other coverages, and the benefit payable for this item. (defined for API consistency)
    property category : TFhirCodeableConcept read FCategory write SetCategory;
    // A code to indicate the information type of this adjudication record. Information types may include: the value submitted, maximum values or percentages allowed or payable under the plan, amounts that the patient is responsible for in aggregate or pertaining to this item, amounts paid by other coverages, and the benefit payable for this item.
    property categoryElement : TFhirCodeableConcept read FCategory write SetCategory;

    // Typed access to Monetary total amount associated with the category. (defined for API consistency)
    property amount : TFhirMoney read FAmount write SetAmount;
    // Monetary total amount associated with the category.
    property amountElement : TFhirMoney read FAmount write SetAmount;

  end;

  TFhirExplanationOfBenefitTotalListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirExplanationOfBenefitTotalList;
    function GetCurrent : TFhirExplanationOfBenefitTotal;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirExplanationOfBenefitTotalList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirExplanationOfBenefitTotal read GetCurrent;
  end;

  TFhirExplanationOfBenefitTotalList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirExplanationOfBenefitTotal;
    procedure SetItemN(index : Integer; value : TFhirExplanationOfBenefitTotal);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirExplanationOfBenefitTotalList; overload;
    function Clone : TFhirExplanationOfBenefitTotalList; overload;
    function GetEnumerator : TFhirExplanationOfBenefitTotalListEnumerator;
    
    //  Add a FhirExplanationOfBenefitTotal to the end of the list.
    function Append : TFhirExplanationOfBenefitTotal;
    
    // Add an already existing FhirExplanationOfBenefitTotal to the end of the list.
    procedure AddItem(value : TFhirExplanationOfBenefitTotal); overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirExplanationOfBenefitTotal) : Integer;
    
    // Insert FhirExplanationOfBenefitTotal before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirExplanationOfBenefitTotal;
    
    // Insert an existing FhirExplanationOfBenefitTotal before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirExplanationOfBenefitTotal);
    
    // Get the iIndexth FhirExplanationOfBenefitTotal. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirExplanationOfBenefitTotal);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirExplanationOfBenefitTotal;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirExplanationOfBenefitTotals[index : Integer] : TFhirExplanationOfBenefitTotal read GetItemN write SetItemN; default;
  End;

  // Payment details for the adjudication of the claim.
  TFhirExplanationOfBenefitPayment = class (TFhirBackboneElement)
  protected
    FType_ : TFhirCodeableConcept;
    FAdjustment : TFhirMoney;
    FAdjustmentReason : TFhirCodeableConcept;
    FDate : TFhirDate;
    FAmount : TFhirMoney;
    FIdentifier : TFhirIdentifier;
    procedure SetType_(value : TFhirCodeableConcept);
    procedure SetAdjustment(value : TFhirMoney);
    procedure SetAdjustmentReason(value : TFhirCodeableConcept);
    procedure SetDate(value : TFhirDate);
    function GetDateST : TFslDateTime;
    procedure SetDateST(value : TFslDateTime);
    procedure SetAmount(value : TFhirMoney);
    procedure SetIdentifier(value : TFhirIdentifier);
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirExplanationOfBenefitPayment; overload;
    function Clone : TFhirExplanationOfBenefitPayment; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to Whether this represents partial or complete payment of the benefits payable. (defined for API consistency)
    property type_ : TFhirCodeableConcept read FType_ write SetType_;
    // Whether this represents partial or complete payment of the benefits payable.
    property type_Element : TFhirCodeableConcept read FType_ write SetType_;

    // Typed access to Total amount of all adjustments to this payment included in this transaction which are not related to this claim's adjudication. (defined for API consistency)
    property adjustment : TFhirMoney read FAdjustment write SetAdjustment;
    // Total amount of all adjustments to this payment included in this transaction which are not related to this claim's adjudication.
    property adjustmentElement : TFhirMoney read FAdjustment write SetAdjustment;

    // Typed access to Reason for the payment adjustment. (defined for API consistency)
    property adjustmentReason : TFhirCodeableConcept read FAdjustmentReason write SetAdjustmentReason;
    // Reason for the payment adjustment.
    property adjustmentReasonElement : TFhirCodeableConcept read FAdjustmentReason write SetAdjustmentReason;

    // Typed access to Estimated date the payment will be issued or the actual issue date of payment.
    property date : TFslDateTime read GetDateST write SetDateST;
    // Estimated date the payment will be issued or the actual issue date of payment.
    property dateElement : TFhirDate read FDate write SetDate;

    // Typed access to Benefits payable less any payment adjustment. (defined for API consistency)
    property amount : TFhirMoney read FAmount write SetAmount;
    // Benefits payable less any payment adjustment.
    property amountElement : TFhirMoney read FAmount write SetAmount;

    // Typed access to Issuer's unique identifier for the payment instrument. (defined for API consistency)
    property identifier : TFhirIdentifier read FIdentifier write SetIdentifier;
    // Issuer's unique identifier for the payment instrument.
    property identifierElement : TFhirIdentifier read FIdentifier write SetIdentifier;

  end;

  TFhirExplanationOfBenefitPaymentListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirExplanationOfBenefitPaymentList;
    function GetCurrent : TFhirExplanationOfBenefitPayment;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirExplanationOfBenefitPaymentList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirExplanationOfBenefitPayment read GetCurrent;
  end;

  TFhirExplanationOfBenefitPaymentList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirExplanationOfBenefitPayment;
    procedure SetItemN(index : Integer; value : TFhirExplanationOfBenefitPayment);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirExplanationOfBenefitPaymentList; overload;
    function Clone : TFhirExplanationOfBenefitPaymentList; overload;
    function GetEnumerator : TFhirExplanationOfBenefitPaymentListEnumerator;
    
    //  Add a FhirExplanationOfBenefitPayment to the end of the list.
    function Append : TFhirExplanationOfBenefitPayment;
    
    // Add an already existing FhirExplanationOfBenefitPayment to the end of the list.
    procedure AddItem(value : TFhirExplanationOfBenefitPayment); overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirExplanationOfBenefitPayment) : Integer;
    
    // Insert FhirExplanationOfBenefitPayment before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirExplanationOfBenefitPayment;
    
    // Insert an existing FhirExplanationOfBenefitPayment before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirExplanationOfBenefitPayment);
    
    // Get the iIndexth FhirExplanationOfBenefitPayment. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirExplanationOfBenefitPayment);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirExplanationOfBenefitPayment;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirExplanationOfBenefitPayments[index : Integer] : TFhirExplanationOfBenefitPayment read GetItemN write SetItemN; default;
  End;

  // A note that describes or explains adjudication results in a human readable form.
  TFhirExplanationOfBenefitProcessNote = class (TFhirBackboneElement)
  protected
    FNumber : TFhirPositiveInt;
    FType_ : TFhirEnum;
    FText : TFhirString;
    FLanguage : TFhirCodeableConcept;
    procedure SetNumber(value : TFhirPositiveInt);
    function GetNumberST : String;
    procedure SetNumberST(value : String);
    procedure SetType_(value : TFhirEnum);
    function GetType_ST : TFhirNoteTypeEnum;
    procedure SetType_ST(value : TFhirNoteTypeEnum);
    procedure SetText(value : TFhirString);
    function GetTextST : String;
    procedure SetTextST(value : String);
    procedure SetLanguage(value : TFhirCodeableConcept);
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirExplanationOfBenefitProcessNote; overload;
    function Clone : TFhirExplanationOfBenefitProcessNote; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to A number to uniquely identify a note entry.
    property number : String read GetNumberST write SetNumberST;
    // A number to uniquely identify a note entry.
    property numberElement : TFhirPositiveInt read FNumber write SetNumber;

    // The business purpose of the note text.
    property type_ : TFhirNoteTypeEnum read GetType_ST write SetType_ST;
    property type_Element : TFhirEnum read FType_ write SetType_;

    // Typed access to The explanation or description associated with the processing.
    property text : String read GetTextST write SetTextST;
    // The explanation or description associated with the processing.
    property textElement : TFhirString read FText write SetText;

    // Typed access to A code to define the language used in the text of the note. (defined for API consistency)
    property language : TFhirCodeableConcept read FLanguage write SetLanguage;
    // A code to define the language used in the text of the note.
    property languageElement : TFhirCodeableConcept read FLanguage write SetLanguage;

  end;

  TFhirExplanationOfBenefitProcessNoteListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirExplanationOfBenefitProcessNoteList;
    function GetCurrent : TFhirExplanationOfBenefitProcessNote;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirExplanationOfBenefitProcessNoteList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirExplanationOfBenefitProcessNote read GetCurrent;
  end;

  TFhirExplanationOfBenefitProcessNoteList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirExplanationOfBenefitProcessNote;
    procedure SetItemN(index : Integer; value : TFhirExplanationOfBenefitProcessNote);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirExplanationOfBenefitProcessNoteList; overload;
    function Clone : TFhirExplanationOfBenefitProcessNoteList; overload;
    function GetEnumerator : TFhirExplanationOfBenefitProcessNoteListEnumerator;
    
    //  Add a FhirExplanationOfBenefitProcessNote to the end of the list.
    function Append : TFhirExplanationOfBenefitProcessNote;
    
    // Add an already existing FhirExplanationOfBenefitProcessNote to the end of the list.
    procedure AddItem(value : TFhirExplanationOfBenefitProcessNote); overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirExplanationOfBenefitProcessNote) : Integer;
    
    // Insert FhirExplanationOfBenefitProcessNote before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirExplanationOfBenefitProcessNote;
    
    // Insert an existing FhirExplanationOfBenefitProcessNote before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirExplanationOfBenefitProcessNote);
    
    // Get the iIndexth FhirExplanationOfBenefitProcessNote. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirExplanationOfBenefitProcessNote);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirExplanationOfBenefitProcessNote;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirExplanationOfBenefitProcessNotes[index : Integer] : TFhirExplanationOfBenefitProcessNote read GetItemN write SetItemN; default;
  End;

  // Balance by Benefit Category.
  TFhirExplanationOfBenefitBenefitBalance = class (TFhirBackboneElement)
  protected
    FCategory : TFhirCodeableConcept;
    FExcluded : TFhirBoolean;
    FName : TFhirString;
    FDescription : TFhirString;
    FNetwork : TFhirCodeableConcept;
    FUnit_ : TFhirCodeableConcept;
    FTerm : TFhirCodeableConcept;
    FfinancialList : TFhirExplanationOfBenefitBenefitBalanceFinancialList;
    procedure SetCategory(value : TFhirCodeableConcept);
    procedure SetExcluded(value : TFhirBoolean);
    function GetExcludedST : Boolean;
    procedure SetExcludedST(value : Boolean);
    procedure SetName(value : TFhirString);
    function GetNameST : String;
    procedure SetNameST(value : String);
    procedure SetDescription(value : TFhirString);
    function GetDescriptionST : String;
    procedure SetDescriptionST(value : String);
    procedure SetNetwork(value : TFhirCodeableConcept);
    procedure SetUnit_(value : TFhirCodeableConcept);
    procedure SetTerm(value : TFhirCodeableConcept);
    function GetFinancialList : TFhirExplanationOfBenefitBenefitBalanceFinancialList;
    function GetHasFinancialList : Boolean;
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirExplanationOfBenefitBenefitBalance; overload;
    function Clone : TFhirExplanationOfBenefitBenefitBalance; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to Code to identify the general type of benefits under which products and services are provided. (defined for API consistency)
    property category : TFhirCodeableConcept read FCategory write SetCategory;
    // Code to identify the general type of benefits under which products and services are provided.
    property categoryElement : TFhirCodeableConcept read FCategory write SetCategory;

    // Typed access to True if the indicated class of service is excluded from the plan, missing or False indicates the product or service is included in the coverage.
    property excluded : Boolean read GetExcludedST write SetExcludedST;
    // True if the indicated class of service is excluded from the plan, missing or False indicates the product or service is included in the coverage.
    property excludedElement : TFhirBoolean read FExcluded write SetExcluded;

    // Typed access to A short name or tag for the benefit.
    property name : String read GetNameST write SetNameST;
    // A short name or tag for the benefit.
    property nameElement : TFhirString read FName write SetName;

    // Typed access to A richer description of the benefit or services covered.
    property description : String read GetDescriptionST write SetDescriptionST;
    // A richer description of the benefit or services covered.
    property descriptionElement : TFhirString read FDescription write SetDescription;

    // Typed access to Is a flag to indicate whether the benefits refer to in-network providers or out-of-network providers. (defined for API consistency)
    property network : TFhirCodeableConcept read FNetwork write SetNetwork;
    // Is a flag to indicate whether the benefits refer to in-network providers or out-of-network providers.
    property networkElement : TFhirCodeableConcept read FNetwork write SetNetwork;

    // Typed access to Indicates if the benefits apply to an individual or to the family. (defined for API consistency)
    property unit_ : TFhirCodeableConcept read FUnit_ write SetUnit_;
    // Indicates if the benefits apply to an individual or to the family.
    property unit_Element : TFhirCodeableConcept read FUnit_ write SetUnit_;

    // Typed access to The term or period of the values such as 'maximum lifetime benefit' or 'maximum annual visits'. (defined for API consistency)
    property term : TFhirCodeableConcept read FTerm write SetTerm;
    // The term or period of the values such as 'maximum lifetime benefit' or 'maximum annual visits'.
    property termElement : TFhirCodeableConcept read FTerm write SetTerm;

    // Benefits Used to date.
    property financialList : TFhirExplanationOfBenefitBenefitBalanceFinancialList read GetFinancialList;
    property hasFinancialList : boolean read GetHasFinancialList;

  end;

  TFhirExplanationOfBenefitBenefitBalanceListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirExplanationOfBenefitBenefitBalanceList;
    function GetCurrent : TFhirExplanationOfBenefitBenefitBalance;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirExplanationOfBenefitBenefitBalanceList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirExplanationOfBenefitBenefitBalance read GetCurrent;
  end;

  TFhirExplanationOfBenefitBenefitBalanceList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirExplanationOfBenefitBenefitBalance;
    procedure SetItemN(index : Integer; value : TFhirExplanationOfBenefitBenefitBalance);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirExplanationOfBenefitBenefitBalanceList; overload;
    function Clone : TFhirExplanationOfBenefitBenefitBalanceList; overload;
    function GetEnumerator : TFhirExplanationOfBenefitBenefitBalanceListEnumerator;
    
    //  Add a FhirExplanationOfBenefitBenefitBalance to the end of the list.
    function Append : TFhirExplanationOfBenefitBenefitBalance;
    
    // Add an already existing FhirExplanationOfBenefitBenefitBalance to the end of the list.
    procedure AddItem(value : TFhirExplanationOfBenefitBenefitBalance); overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirExplanationOfBenefitBenefitBalance) : Integer;
    
    // Insert FhirExplanationOfBenefitBenefitBalance before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirExplanationOfBenefitBenefitBalance;
    
    // Insert an existing FhirExplanationOfBenefitBenefitBalance before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirExplanationOfBenefitBenefitBalance);
    
    // Get the iIndexth FhirExplanationOfBenefitBenefitBalance. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirExplanationOfBenefitBenefitBalance);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirExplanationOfBenefitBenefitBalance;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirExplanationOfBenefitBenefitBalances[index : Integer] : TFhirExplanationOfBenefitBenefitBalance read GetItemN write SetItemN; default;
  End;

  // Benefits Used to date.
  TFhirExplanationOfBenefitBenefitBalanceFinancial = class (TFhirBackboneElement)
  protected
    FType_ : TFhirCodeableConcept;
    FAllowed : TFhirDataType;
    FUsed : TFhirDataType;
    procedure SetType_(value : TFhirCodeableConcept);
    procedure SetAllowed(value : TFhirDataType);
    procedure SetUsed(value : TFhirDataType);
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirExplanationOfBenefitBenefitBalanceFinancial; overload;
    function Clone : TFhirExplanationOfBenefitBenefitBalanceFinancial; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to Classification of benefit being provided. (defined for API consistency)
    property type_ : TFhirCodeableConcept read FType_ write SetType_;
    // Classification of benefit being provided.
    property type_Element : TFhirCodeableConcept read FType_ write SetType_;

    // Typed access to The quantity of the benefit which is permitted under the coverage. (defined for API consistency)
    property allowed : TFhirDataType read FAllowed write SetAllowed;
    // The quantity of the benefit which is permitted under the coverage.
    property allowedElement : TFhirDataType read FAllowed write SetAllowed;

    // Typed access to The quantity of the benefit which have been consumed to date. (defined for API consistency)
    property used : TFhirDataType read FUsed write SetUsed;
    // The quantity of the benefit which have been consumed to date.
    property usedElement : TFhirDataType read FUsed write SetUsed;

  end;

  TFhirExplanationOfBenefitBenefitBalanceFinancialListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirExplanationOfBenefitBenefitBalanceFinancialList;
    function GetCurrent : TFhirExplanationOfBenefitBenefitBalanceFinancial;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirExplanationOfBenefitBenefitBalanceFinancialList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirExplanationOfBenefitBenefitBalanceFinancial read GetCurrent;
  end;

  TFhirExplanationOfBenefitBenefitBalanceFinancialList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirExplanationOfBenefitBenefitBalanceFinancial;
    procedure SetItemN(index : Integer; value : TFhirExplanationOfBenefitBenefitBalanceFinancial);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirExplanationOfBenefitBenefitBalanceFinancialList; overload;
    function Clone : TFhirExplanationOfBenefitBenefitBalanceFinancialList; overload;
    function GetEnumerator : TFhirExplanationOfBenefitBenefitBalanceFinancialListEnumerator;
    
    //  Add a FhirExplanationOfBenefitBenefitBalanceFinancial to the end of the list.
    function Append : TFhirExplanationOfBenefitBenefitBalanceFinancial;
    
    // Add an already existing FhirExplanationOfBenefitBenefitBalanceFinancial to the end of the list.
    procedure AddItem(value : TFhirExplanationOfBenefitBenefitBalanceFinancial); overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirExplanationOfBenefitBenefitBalanceFinancial) : Integer;
    
    // Insert FhirExplanationOfBenefitBenefitBalanceFinancial before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirExplanationOfBenefitBenefitBalanceFinancial;
    
    // Insert an existing FhirExplanationOfBenefitBenefitBalanceFinancial before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirExplanationOfBenefitBenefitBalanceFinancial);
    
    // Get the iIndexth FhirExplanationOfBenefitBenefitBalanceFinancial. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirExplanationOfBenefitBenefitBalanceFinancial);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirExplanationOfBenefitBenefitBalanceFinancial;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirExplanationOfBenefitBenefitBalanceFinancials[index : Integer] : TFhirExplanationOfBenefitBenefitBalanceFinancial read GetItemN write SetItemN; default;
  End;

  // This resource provides: the claim details; adjudication details from the processing of a Claim; and optionally account balance information, for informing the subscriber of the benefits provided.
  TFhirExplanationOfBenefit = class (TFhirDomainResource)
  protected
    FidentifierList : TFhirIdentifierList;
    FStatus : TFhirEnum;
    FType_ : TFhirCodeableConcept;
    FSubType : TFhirCodeableConcept;
    FUse : TFhirEnum;
    FPatient : TFhirReference;
    FBillablePeriod : TFhirPeriod;
    FCreated : TFhirDateTime;
    FEnterer : TFhirReference;
    FInsurer : TFhirReference;
    FProvider : TFhirReference;
    FPriority : TFhirCodeableConcept;
    FFundsReserveRequested : TFhirCodeableConcept;
    FFundsReserve : TFhirCodeableConcept;
    FrelatedList : TFhirExplanationOfBenefitRelatedList;
    FPrescription : TFhirReference;
    FOriginalPrescription : TFhirReference;
    FPayee : TFhirExplanationOfBenefitPayee;
    FReferral : TFhirReference;
    FFacility : TFhirReference;
    FClaim : TFhirReference;
    FClaimResponse : TFhirReference;
    FOutcome : TFhirEnum;
    FDisposition : TFhirString;
    FpreAuthRefList : TFhirStringList;
    FpreAuthRefPeriodList : TFhirPeriodList;
    FcareTeamList : TFhirExplanationOfBenefitCareTeamList;
    FsupportingInfoList : TFhirExplanationOfBenefitSupportingInfoList;
    FdiagnosisList : TFhirExplanationOfBenefitDiagnosisList;
    Fprocedure_List : TFhirExplanationOfBenefitProcedureList;
    FPrecedence : TFhirPositiveInt;
    FinsuranceList : TFhirExplanationOfBenefitInsuranceList;
    FAccident : TFhirExplanationOfBenefitAccident;
    FitemList : TFhirExplanationOfBenefitItemList;
    FaddItemList : TFhirExplanationOfBenefitAddItemList;
    FadjudicationList : TFhirExplanationOfBenefitItemAdjudicationList;
    FtotalList : TFhirExplanationOfBenefitTotalList;
    FPayment : TFhirExplanationOfBenefitPayment;
    FFormCode : TFhirCodeableConcept;
    FForm : TFhirAttachment;
    FprocessNoteList : TFhirExplanationOfBenefitProcessNoteList;
    FBenefitPeriod : TFhirPeriod;
    FbenefitBalanceList : TFhirExplanationOfBenefitBenefitBalanceList;
    function GetIdentifierList : TFhirIdentifierList;
    function GetHasIdentifierList : Boolean;
    procedure SetStatus(value : TFhirEnum);
    function GetStatusST : TFhirExplanationOfBenefitStatusEnum;
    procedure SetStatusST(value : TFhirExplanationOfBenefitStatusEnum);
    procedure SetType_(value : TFhirCodeableConcept);
    procedure SetSubType(value : TFhirCodeableConcept);
    procedure SetUse(value : TFhirEnum);
    function GetUseST : TFhirUseEnum;
    procedure SetUseST(value : TFhirUseEnum);
    procedure SetPatient(value : TFhirReference);
    procedure SetBillablePeriod(value : TFhirPeriod);
    procedure SetCreated(value : TFhirDateTime);
    function GetCreatedST : TFslDateTime;
    procedure SetCreatedST(value : TFslDateTime);
    procedure SetEnterer(value : TFhirReference);
    procedure SetInsurer(value : TFhirReference);
    procedure SetProvider(value : TFhirReference);
    procedure SetPriority(value : TFhirCodeableConcept);
    procedure SetFundsReserveRequested(value : TFhirCodeableConcept);
    procedure SetFundsReserve(value : TFhirCodeableConcept);
    function GetRelatedList : TFhirExplanationOfBenefitRelatedList;
    function GetHasRelatedList : Boolean;
    procedure SetPrescription(value : TFhirReference);
    procedure SetOriginalPrescription(value : TFhirReference);
    procedure SetPayee(value : TFhirExplanationOfBenefitPayee);
    procedure SetReferral(value : TFhirReference);
    procedure SetFacility(value : TFhirReference);
    procedure SetClaim(value : TFhirReference);
    procedure SetClaimResponse(value : TFhirReference);
    procedure SetOutcome(value : TFhirEnum);
    function GetOutcomeST : TFhirClaimProcessingCodesEnum;
    procedure SetOutcomeST(value : TFhirClaimProcessingCodesEnum);
    procedure SetDisposition(value : TFhirString);
    function GetDispositionST : String;
    procedure SetDispositionST(value : String);
    function GetPreAuthRefList : TFhirStringList;
    function GetHasPreAuthRefList : Boolean;
    function GetPreAuthRefPeriodList : TFhirPeriodList;
    function GetHasPreAuthRefPeriodList : Boolean;
    function GetCareTeamList : TFhirExplanationOfBenefitCareTeamList;
    function GetHasCareTeamList : Boolean;
    function GetSupportingInfoList : TFhirExplanationOfBenefitSupportingInfoList;
    function GetHasSupportingInfoList : Boolean;
    function GetDiagnosisList : TFhirExplanationOfBenefitDiagnosisList;
    function GetHasDiagnosisList : Boolean;
    function GetProcedure_List : TFhirExplanationOfBenefitProcedureList;
    function GetHasProcedure_List : Boolean;
    procedure SetPrecedence(value : TFhirPositiveInt);
    function GetPrecedenceST : String;
    procedure SetPrecedenceST(value : String);
    function GetInsuranceList : TFhirExplanationOfBenefitInsuranceList;
    function GetHasInsuranceList : Boolean;
    procedure SetAccident(value : TFhirExplanationOfBenefitAccident);
    function GetItemList : TFhirExplanationOfBenefitItemList;
    function GetHasItemList : Boolean;
    function GetAddItemList : TFhirExplanationOfBenefitAddItemList;
    function GetHasAddItemList : Boolean;
    function GetAdjudicationList : TFhirExplanationOfBenefitItemAdjudicationList;
    function GetHasAdjudicationList : Boolean;
    function GetTotalList : TFhirExplanationOfBenefitTotalList;
    function GetHasTotalList : Boolean;
    procedure SetPayment(value : TFhirExplanationOfBenefitPayment);
    procedure SetFormCode(value : TFhirCodeableConcept);
    procedure SetForm(value : TFhirAttachment);
    function GetProcessNoteList : TFhirExplanationOfBenefitProcessNoteList;
    function GetHasProcessNoteList : Boolean;
    procedure SetBenefitPeriod(value : TFhirPeriod);
    function GetBenefitBalanceList : TFhirExplanationOfBenefitBenefitBalanceList;
    function GetHasBenefitBalanceList : Boolean;
  
    function GetResourceType : TFhirResourceType; override;
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirExplanationOfBenefit; overload;
    function Clone : TFhirExplanationOfBenefit; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // A unique identifier assigned to this explanation of benefit.
    property identifierList : TFhirIdentifierList read GetIdentifierList;
    property hasIdentifierList : boolean read GetHasIdentifierList;

    // The status of the resource instance.
    property status : TFhirExplanationOfBenefitStatusEnum read GetStatusST write SetStatusST;
    property statusElement : TFhirEnum read FStatus write SetStatus;

    // Typed access to The category of claim, e.g. oral, pharmacy, vision, institutional, professional. (defined for API consistency)
    property type_ : TFhirCodeableConcept read FType_ write SetType_;
    // The category of claim, e.g. oral, pharmacy, vision, institutional, professional.
    property type_Element : TFhirCodeableConcept read FType_ write SetType_;

    // Typed access to A finer grained suite of claim type codes which may convey additional information such as Inpatient vs Outpatient and/or a specialty service. (defined for API consistency)
    property subType : TFhirCodeableConcept read FSubType write SetSubType;
    // A finer grained suite of claim type codes which may convey additional information such as Inpatient vs Outpatient and/or a specialty service.
    property subTypeElement : TFhirCodeableConcept read FSubType write SetSubType;

    // A code to indicate whether the nature of the request is: to request adjudication of products and services previously rendered; or requesting authorization and adjudication for provision in the future; or requesting the non-binding adjudication of the listed products and services which could be provided in the future.
    property use : TFhirUseEnum read GetUseST write SetUseST;
    property useElement : TFhirEnum read FUse write SetUse;

    // Typed access to The party to whom the professional services and/or products have been supplied or are being considered and for whom actual for forecast reimbursement is sought. (defined for API consistency)
    property patient : TFhirReference read FPatient write SetPatient;
    // The party to whom the professional services and/or products have been supplied or are being considered and for whom actual for forecast reimbursement is sought.
    property patientElement : TFhirReference read FPatient write SetPatient;

    // Typed access to The period for which charges are being submitted. (defined for API consistency)
    property billablePeriod : TFhirPeriod read FBillablePeriod write SetBillablePeriod;
    // The period for which charges are being submitted.
    property billablePeriodElement : TFhirPeriod read FBillablePeriod write SetBillablePeriod;

    // Typed access to The date this resource was created.
    property created : TFslDateTime read GetCreatedST write SetCreatedST;
    // The date this resource was created.
    property createdElement : TFhirDateTime read FCreated write SetCreated;

    // Typed access to Individual who created the claim, predetermination or preauthorization. (defined for API consistency)
    property enterer : TFhirReference read FEnterer write SetEnterer;
    // Individual who created the claim, predetermination or preauthorization.
    property entererElement : TFhirReference read FEnterer write SetEnterer;

    // Typed access to The party responsible for authorization, adjudication and reimbursement. (defined for API consistency)
    property insurer : TFhirReference read FInsurer write SetInsurer;
    // The party responsible for authorization, adjudication and reimbursement.
    property insurerElement : TFhirReference read FInsurer write SetInsurer;

    // Typed access to The provider which is responsible for the claim, predetermination or preauthorization. (defined for API consistency)
    property provider : TFhirReference read FProvider write SetProvider;
    // The provider which is responsible for the claim, predetermination or preauthorization.
    property providerElement : TFhirReference read FProvider write SetProvider;

    // Typed access to The provider-required urgency of processing the request. Typical values include: stat, routine deferred. (defined for API consistency)
    property priority : TFhirCodeableConcept read FPriority write SetPriority;
    // The provider-required urgency of processing the request. Typical values include: stat, routine deferred.
    property priorityElement : TFhirCodeableConcept read FPriority write SetPriority;

    // Typed access to A code to indicate whether and for whom funds are to be reserved for future claims. (defined for API consistency)
    property fundsReserveRequested : TFhirCodeableConcept read FFundsReserveRequested write SetFundsReserveRequested;
    // A code to indicate whether and for whom funds are to be reserved for future claims.
    property fundsReserveRequestedElement : TFhirCodeableConcept read FFundsReserveRequested write SetFundsReserveRequested;

    // Typed access to A code, used only on a response to a preauthorization, to indicate whether the benefits payable have been reserved and for whom. (defined for API consistency)
    property fundsReserve : TFhirCodeableConcept read FFundsReserve write SetFundsReserve;
    // A code, used only on a response to a preauthorization, to indicate whether the benefits payable have been reserved and for whom.
    property fundsReserveElement : TFhirCodeableConcept read FFundsReserve write SetFundsReserve;

    // Other claims which are related to this claim such as prior submissions or claims for related services or for the same event.
    property relatedList : TFhirExplanationOfBenefitRelatedList read GetRelatedList;
    property hasRelatedList : boolean read GetHasRelatedList;

    // Typed access to Prescription to support the dispensing of pharmacy, device or vision products. (defined for API consistency)
    property prescription : TFhirReference read FPrescription write SetPrescription;
    // Prescription to support the dispensing of pharmacy, device or vision products.
    property prescriptionElement : TFhirReference read FPrescription write SetPrescription;

    // Typed access to Original prescription which has been superseded by this prescription to support the dispensing of pharmacy services, medications or products. (defined for API consistency)
    property originalPrescription : TFhirReference read FOriginalPrescription write SetOriginalPrescription;
    // Original prescription which has been superseded by this prescription to support the dispensing of pharmacy services, medications or products.
    property originalPrescriptionElement : TFhirReference read FOriginalPrescription write SetOriginalPrescription;

    // Typed access to The party to be reimbursed for cost of the products and services according to the terms of the policy. (defined for API consistency)
    property payee : TFhirExplanationOfBenefitPayee read FPayee write SetPayee;
    // The party to be reimbursed for cost of the products and services according to the terms of the policy.
    property payeeElement : TFhirExplanationOfBenefitPayee read FPayee write SetPayee;

    // Typed access to A reference to a referral resource. (defined for API consistency)
    property referral : TFhirReference read FReferral write SetReferral;
    // A reference to a referral resource.
    property referralElement : TFhirReference read FReferral write SetReferral;

    // Typed access to Facility where the services were provided. (defined for API consistency)
    property facility : TFhirReference read FFacility write SetFacility;
    // Facility where the services were provided.
    property facilityElement : TFhirReference read FFacility write SetFacility;

    // Typed access to The business identifier for the instance of the adjudication request: claim predetermination or preauthorization. (defined for API consistency)
    property claim : TFhirReference read FClaim write SetClaim;
    // The business identifier for the instance of the adjudication request: claim predetermination or preauthorization.
    property claimElement : TFhirReference read FClaim write SetClaim;

    // Typed access to The business identifier for the instance of the adjudication response: claim, predetermination or preauthorization response. (defined for API consistency)
    property claimResponse : TFhirReference read FClaimResponse write SetClaimResponse;
    // The business identifier for the instance of the adjudication response: claim, predetermination or preauthorization response.
    property claimResponseElement : TFhirReference read FClaimResponse write SetClaimResponse;

    // The outcome of the claim, predetermination, or preauthorization processing.
    property outcome : TFhirClaimProcessingCodesEnum read GetOutcomeST write SetOutcomeST;
    property outcomeElement : TFhirEnum read FOutcome write SetOutcome;

    // Typed access to A human readable description of the status of the adjudication.
    property disposition : String read GetDispositionST write SetDispositionST;
    // A human readable description of the status of the adjudication.
    property dispositionElement : TFhirString read FDisposition write SetDisposition;

    // Reference from the Insurer which is used in later communications which refers to this adjudication.
    property preAuthRefList : TFhirStringList read GetPreAuthRefList;
    property hasPreAuthRefList : boolean read GetHasPreAuthRefList;

    // The timeframe during which the supplied preauthorization reference may be quoted on claims to obtain the adjudication as provided.
    property preAuthRefPeriodList : TFhirPeriodList read GetPreAuthRefPeriodList;
    property hasPreAuthRefPeriodList : boolean read GetHasPreAuthRefPeriodList;

    // The members of the team who provided the products and services.
    property careTeamList : TFhirExplanationOfBenefitCareTeamList read GetCareTeamList;
    property hasCareTeamList : boolean read GetHasCareTeamList;

    // Additional information codes regarding exceptions, special considerations, the condition, situation, prior or concurrent issues.
    property supportingInfoList : TFhirExplanationOfBenefitSupportingInfoList read GetSupportingInfoList;
    property hasSupportingInfoList : boolean read GetHasSupportingInfoList;

    // Information about diagnoses relevant to the claim items.
    property diagnosisList : TFhirExplanationOfBenefitDiagnosisList read GetDiagnosisList;
    property hasDiagnosisList : boolean read GetHasDiagnosisList;

    // Procedures performed on the patient relevant to the billing items with the claim.
    property procedure_List : TFhirExplanationOfBenefitProcedureList read GetProcedure_List;
    property hasProcedure_List : boolean read GetHasProcedure_List;

    // Typed access to This indicates the relative order of a series of EOBs related to different coverages for the same suite of services.
    property precedence : String read GetPrecedenceST write SetPrecedenceST;
    // This indicates the relative order of a series of EOBs related to different coverages for the same suite of services.
    property precedenceElement : TFhirPositiveInt read FPrecedence write SetPrecedence;

    // Financial instruments for reimbursement for the health care products and services specified on the claim.
    property insuranceList : TFhirExplanationOfBenefitInsuranceList read GetInsuranceList;
    property hasInsuranceList : boolean read GetHasInsuranceList;

    // Typed access to Details of a accident which resulted in injuries which required the products and services listed in the claim. (defined for API consistency)
    property accident : TFhirExplanationOfBenefitAccident read FAccident write SetAccident;
    // Details of a accident which resulted in injuries which required the products and services listed in the claim.
    property accidentElement : TFhirExplanationOfBenefitAccident read FAccident write SetAccident;

    // A claim line. Either a simple (a product or service) or a 'group' of details which can also be a simple items or groups of sub-details.
    property itemList : TFhirExplanationOfBenefitItemList read GetItemList;
    property hasItemList : boolean read GetHasItemList;

    // The first-tier service adjudications for payor added product or service lines.
    property addItemList : TFhirExplanationOfBenefitAddItemList read GetAddItemList;
    property hasAddItemList : boolean read GetHasAddItemList;

    // The adjudication results which are presented at the header level rather than at the line-item or add-item levels.
    property adjudicationList : TFhirExplanationOfBenefitItemAdjudicationList read GetAdjudicationList;
    property hasAdjudicationList : boolean read GetHasAdjudicationList;

    // Categorized monetary totals for the adjudication.
    property totalList : TFhirExplanationOfBenefitTotalList read GetTotalList;
    property hasTotalList : boolean read GetHasTotalList;

    // Typed access to Payment details for the adjudication of the claim. (defined for API consistency)
    property payment : TFhirExplanationOfBenefitPayment read FPayment write SetPayment;
    // Payment details for the adjudication of the claim.
    property paymentElement : TFhirExplanationOfBenefitPayment read FPayment write SetPayment;

    // Typed access to A code for the form to be used for printing the content. (defined for API consistency)
    property formCode : TFhirCodeableConcept read FFormCode write SetFormCode;
    // A code for the form to be used for printing the content.
    property formCodeElement : TFhirCodeableConcept read FFormCode write SetFormCode;

    // Typed access to The actual form, by reference or inclusion, for printing the content or an EOB. (defined for API consistency)
    property form : TFhirAttachment read FForm write SetForm;
    // The actual form, by reference or inclusion, for printing the content or an EOB.
    property formElement : TFhirAttachment read FForm write SetForm;

    // A note that describes or explains adjudication results in a human readable form.
    property processNoteList : TFhirExplanationOfBenefitProcessNoteList read GetProcessNoteList;
    property hasProcessNoteList : boolean read GetHasProcessNoteList;

    // Typed access to The term of the benefits documented in this response. (defined for API consistency)
    property benefitPeriod : TFhirPeriod read FBenefitPeriod write SetBenefitPeriod;
    // The term of the benefits documented in this response.
    property benefitPeriodElement : TFhirPeriod read FBenefitPeriod write SetBenefitPeriod;

    // Balance by Benefit Category.
    property benefitBalanceList : TFhirExplanationOfBenefitBenefitBalanceList read GetBenefitBalanceList;
    property hasBenefitBalanceList : boolean read GetHasBenefitBalanceList;

  end;

  TFhirExplanationOfBenefitListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirExplanationOfBenefitList;
    function GetCurrent : TFhirExplanationOfBenefit;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirExplanationOfBenefitList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirExplanationOfBenefit read GetCurrent;
  end;

  TFhirExplanationOfBenefitList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirExplanationOfBenefit;
    procedure SetItemN(index : Integer; value : TFhirExplanationOfBenefit);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirExplanationOfBenefitList; overload;
    function Clone : TFhirExplanationOfBenefitList; overload;
    function GetEnumerator : TFhirExplanationOfBenefitListEnumerator;
    
    //  Add a FhirExplanationOfBenefit to the end of the list.
    function Append : TFhirExplanationOfBenefit;
    
    // Add an already existing FhirExplanationOfBenefit to the end of the list.
    procedure AddItem(value : TFhirExplanationOfBenefit); overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirExplanationOfBenefit) : Integer;
    
    // Insert FhirExplanationOfBenefit before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirExplanationOfBenefit;
    
    // Insert an existing FhirExplanationOfBenefit before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirExplanationOfBenefit);
    
    // Get the iIndexth FhirExplanationOfBenefit. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirExplanationOfBenefit);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirExplanationOfBenefit;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirExplanationOfBenefits[index : Integer] : TFhirExplanationOfBenefit read GetItemN write SetItemN; default;
  End;

{$ENDIF FHIR_EXPLANATIONOFBENEFIT}
{$IFDEF FHIR_INSURANCEPLAN}
  // The contact for the health insurance product for a certain purpose.
  TFhirInsurancePlanContact = class (TFhirBackboneElement)
  protected
    FPurpose : TFhirCodeableConcept;
    FName : TFhirHumanName;
    FtelecomList : TFhirContactPointList;
    FAddress : TFhirAddress;
    procedure SetPurpose(value : TFhirCodeableConcept);
    procedure SetName(value : TFhirHumanName);
    function GetTelecomList : TFhirContactPointList;
    function GetHasTelecomList : Boolean;
    procedure SetAddress(value : TFhirAddress);
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirInsurancePlanContact; overload;
    function Clone : TFhirInsurancePlanContact; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to Indicates a purpose for which the contact can be reached. (defined for API consistency)
    property purpose : TFhirCodeableConcept read FPurpose write SetPurpose;
    // Indicates a purpose for which the contact can be reached.
    property purposeElement : TFhirCodeableConcept read FPurpose write SetPurpose;

    // Typed access to A name associated with the contact. (defined for API consistency)
    property name : TFhirHumanName read FName write SetName;
    // A name associated with the contact.
    property nameElement : TFhirHumanName read FName write SetName;

    // A contact detail (e.g. a telephone number or an email address) by which the party may be contacted.
    property telecomList : TFhirContactPointList read GetTelecomList;
    property hasTelecomList : boolean read GetHasTelecomList;

    // Typed access to Visiting or postal addresses for the contact. (defined for API consistency)
    property address : TFhirAddress read FAddress write SetAddress;
    // Visiting or postal addresses for the contact.
    property addressElement : TFhirAddress read FAddress write SetAddress;

  end;

  TFhirInsurancePlanContactListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirInsurancePlanContactList;
    function GetCurrent : TFhirInsurancePlanContact;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirInsurancePlanContactList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirInsurancePlanContact read GetCurrent;
  end;

  TFhirInsurancePlanContactList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirInsurancePlanContact;
    procedure SetItemN(index : Integer; value : TFhirInsurancePlanContact);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirInsurancePlanContactList; overload;
    function Clone : TFhirInsurancePlanContactList; overload;
    function GetEnumerator : TFhirInsurancePlanContactListEnumerator;
    
    //  Add a FhirInsurancePlanContact to the end of the list.
    function Append : TFhirInsurancePlanContact;
    
    // Add an already existing FhirInsurancePlanContact to the end of the list.
    procedure AddItem(value : TFhirInsurancePlanContact); overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirInsurancePlanContact) : Integer;
    
    // Insert FhirInsurancePlanContact before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirInsurancePlanContact;
    
    // Insert an existing FhirInsurancePlanContact before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirInsurancePlanContact);
    
    // Get the iIndexth FhirInsurancePlanContact. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirInsurancePlanContact);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirInsurancePlanContact;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirInsurancePlanContacts[index : Integer] : TFhirInsurancePlanContact read GetItemN write SetItemN; default;
  End;

  // Details about the coverage offered by the insurance product.
  TFhirInsurancePlanCoverage = class (TFhirBackboneElement)
  protected
    FType_ : TFhirCodeableConcept;
    FnetworkList : TFhirReferenceList;
    FbenefitList : TFhirInsurancePlanCoverageBenefitList;
    procedure SetType_(value : TFhirCodeableConcept);
    function GetNetworkList : TFhirReferenceList;
    function GetHasNetworkList : Boolean;
    function GetBenefitList : TFhirInsurancePlanCoverageBenefitList;
    function GetHasBenefitList : Boolean;
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirInsurancePlanCoverage; overload;
    function Clone : TFhirInsurancePlanCoverage; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to Type of coverage  (Medical; Dental; Mental Health; Substance Abuse; Vision; Drug; Short Term; Long Term Care; Hospice; Home Health). (defined for API consistency)
    property type_ : TFhirCodeableConcept read FType_ write SetType_;
    // Type of coverage  (Medical; Dental; Mental Health; Substance Abuse; Vision; Drug; Short Term; Long Term Care; Hospice; Home Health).
    property type_Element : TFhirCodeableConcept read FType_ write SetType_;

    // Reference to the network that providing the type of coverage.
    property networkList : TFhirReferenceList read GetNetworkList;
    property hasNetworkList : boolean read GetHasNetworkList;

    // Specific benefits under this type of coverage.
    property benefitList : TFhirInsurancePlanCoverageBenefitList read GetBenefitList;
    property hasBenefitList : boolean read GetHasBenefitList;

  end;

  TFhirInsurancePlanCoverageListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirInsurancePlanCoverageList;
    function GetCurrent : TFhirInsurancePlanCoverage;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirInsurancePlanCoverageList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirInsurancePlanCoverage read GetCurrent;
  end;

  TFhirInsurancePlanCoverageList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirInsurancePlanCoverage;
    procedure SetItemN(index : Integer; value : TFhirInsurancePlanCoverage);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirInsurancePlanCoverageList; overload;
    function Clone : TFhirInsurancePlanCoverageList; overload;
    function GetEnumerator : TFhirInsurancePlanCoverageListEnumerator;
    
    //  Add a FhirInsurancePlanCoverage to the end of the list.
    function Append : TFhirInsurancePlanCoverage;
    
    // Add an already existing FhirInsurancePlanCoverage to the end of the list.
    procedure AddItem(value : TFhirInsurancePlanCoverage); overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirInsurancePlanCoverage) : Integer;
    
    // Insert FhirInsurancePlanCoverage before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirInsurancePlanCoverage;
    
    // Insert an existing FhirInsurancePlanCoverage before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirInsurancePlanCoverage);
    
    // Get the iIndexth FhirInsurancePlanCoverage. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirInsurancePlanCoverage);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirInsurancePlanCoverage;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirInsurancePlanCoverages[index : Integer] : TFhirInsurancePlanCoverage read GetItemN write SetItemN; default;
  End;

  // Specific benefits under this type of coverage.
  TFhirInsurancePlanCoverageBenefit = class (TFhirBackboneElement)
  protected
    FType_ : TFhirCodeableConcept;
    FRequirement : TFhirString;
    FlimitList : TFhirInsurancePlanCoverageBenefitLimitList;
    procedure SetType_(value : TFhirCodeableConcept);
    procedure SetRequirement(value : TFhirString);
    function GetRequirementST : String;
    procedure SetRequirementST(value : String);
    function GetLimitList : TFhirInsurancePlanCoverageBenefitLimitList;
    function GetHasLimitList : Boolean;
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirInsurancePlanCoverageBenefit; overload;
    function Clone : TFhirInsurancePlanCoverageBenefit; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to Type of benefit (primary care; speciality care; inpatient; outpatient). (defined for API consistency)
    property type_ : TFhirCodeableConcept read FType_ write SetType_;
    // Type of benefit (primary care; speciality care; inpatient; outpatient).
    property type_Element : TFhirCodeableConcept read FType_ write SetType_;

    // Typed access to The referral requirements to have access/coverage for this benefit.
    property requirement : String read GetRequirementST write SetRequirementST;
    // The referral requirements to have access/coverage for this benefit.
    property requirementElement : TFhirString read FRequirement write SetRequirement;

    // The specific limits on the benefit.
    property limitList : TFhirInsurancePlanCoverageBenefitLimitList read GetLimitList;
    property hasLimitList : boolean read GetHasLimitList;

  end;

  TFhirInsurancePlanCoverageBenefitListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirInsurancePlanCoverageBenefitList;
    function GetCurrent : TFhirInsurancePlanCoverageBenefit;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirInsurancePlanCoverageBenefitList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirInsurancePlanCoverageBenefit read GetCurrent;
  end;

  TFhirInsurancePlanCoverageBenefitList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirInsurancePlanCoverageBenefit;
    procedure SetItemN(index : Integer; value : TFhirInsurancePlanCoverageBenefit);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirInsurancePlanCoverageBenefitList; overload;
    function Clone : TFhirInsurancePlanCoverageBenefitList; overload;
    function GetEnumerator : TFhirInsurancePlanCoverageBenefitListEnumerator;
    
    //  Add a FhirInsurancePlanCoverageBenefit to the end of the list.
    function Append : TFhirInsurancePlanCoverageBenefit;
    
    // Add an already existing FhirInsurancePlanCoverageBenefit to the end of the list.
    procedure AddItem(value : TFhirInsurancePlanCoverageBenefit); overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirInsurancePlanCoverageBenefit) : Integer;
    
    // Insert FhirInsurancePlanCoverageBenefit before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirInsurancePlanCoverageBenefit;
    
    // Insert an existing FhirInsurancePlanCoverageBenefit before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirInsurancePlanCoverageBenefit);
    
    // Get the iIndexth FhirInsurancePlanCoverageBenefit. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirInsurancePlanCoverageBenefit);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirInsurancePlanCoverageBenefit;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirInsurancePlanCoverageBenefits[index : Integer] : TFhirInsurancePlanCoverageBenefit read GetItemN write SetItemN; default;
  End;

  // The specific limits on the benefit.
  TFhirInsurancePlanCoverageBenefitLimit = class (TFhirBackboneElement)
  protected
    FValue : TFhirQuantity;
    FCode : TFhirCodeableConcept;
    procedure SetValue(value : TFhirQuantity);
    procedure SetCode(value : TFhirCodeableConcept);
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirInsurancePlanCoverageBenefitLimit; overload;
    function Clone : TFhirInsurancePlanCoverageBenefitLimit; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to The maximum amount of a service item a plan will pay for a covered benefit.  For examples. wellness visits, or eyeglasses. (defined for API consistency)
    property value : TFhirQuantity read FValue write SetValue;
    // The maximum amount of a service item a plan will pay for a covered benefit.  For examples. wellness visits, or eyeglasses.
    property valueElement : TFhirQuantity read FValue write SetValue;

    // Typed access to The specific limit on the benefit. (defined for API consistency)
    property code : TFhirCodeableConcept read FCode write SetCode;
    // The specific limit on the benefit.
    property codeElement : TFhirCodeableConcept read FCode write SetCode;

  end;

  TFhirInsurancePlanCoverageBenefitLimitListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirInsurancePlanCoverageBenefitLimitList;
    function GetCurrent : TFhirInsurancePlanCoverageBenefitLimit;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirInsurancePlanCoverageBenefitLimitList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirInsurancePlanCoverageBenefitLimit read GetCurrent;
  end;

  TFhirInsurancePlanCoverageBenefitLimitList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirInsurancePlanCoverageBenefitLimit;
    procedure SetItemN(index : Integer; value : TFhirInsurancePlanCoverageBenefitLimit);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirInsurancePlanCoverageBenefitLimitList; overload;
    function Clone : TFhirInsurancePlanCoverageBenefitLimitList; overload;
    function GetEnumerator : TFhirInsurancePlanCoverageBenefitLimitListEnumerator;
    
    //  Add a FhirInsurancePlanCoverageBenefitLimit to the end of the list.
    function Append : TFhirInsurancePlanCoverageBenefitLimit;
    
    // Add an already existing FhirInsurancePlanCoverageBenefitLimit to the end of the list.
    procedure AddItem(value : TFhirInsurancePlanCoverageBenefitLimit); overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirInsurancePlanCoverageBenefitLimit) : Integer;
    
    // Insert FhirInsurancePlanCoverageBenefitLimit before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirInsurancePlanCoverageBenefitLimit;
    
    // Insert an existing FhirInsurancePlanCoverageBenefitLimit before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirInsurancePlanCoverageBenefitLimit);
    
    // Get the iIndexth FhirInsurancePlanCoverageBenefitLimit. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirInsurancePlanCoverageBenefitLimit);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirInsurancePlanCoverageBenefitLimit;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirInsurancePlanCoverageBenefitLimits[index : Integer] : TFhirInsurancePlanCoverageBenefitLimit read GetItemN write SetItemN; default;
  End;

  // Details about an insurance plan.
  TFhirInsurancePlanPlan = class (TFhirBackboneElement)
  protected
    FidentifierList : TFhirIdentifierList;
    FType_ : TFhirCodeableConcept;
    FcoverageAreaList : TFhirReferenceList;
    FnetworkList : TFhirReferenceList;
    FgeneralCostList : TFhirInsurancePlanPlanGeneralCostList;
    FspecificCostList : TFhirInsurancePlanPlanSpecificCostList;
    function GetIdentifierList : TFhirIdentifierList;
    function GetHasIdentifierList : Boolean;
    procedure SetType_(value : TFhirCodeableConcept);
    function GetCoverageAreaList : TFhirReferenceList;
    function GetHasCoverageAreaList : Boolean;
    function GetNetworkList : TFhirReferenceList;
    function GetHasNetworkList : Boolean;
    function GetGeneralCostList : TFhirInsurancePlanPlanGeneralCostList;
    function GetHasGeneralCostList : Boolean;
    function GetSpecificCostList : TFhirInsurancePlanPlanSpecificCostList;
    function GetHasSpecificCostList : Boolean;
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirInsurancePlanPlan; overload;
    function Clone : TFhirInsurancePlanPlan; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Business identifiers assigned to this health insurance plan which remain constant as the resource is updated and propagates from server to server.
    property identifierList : TFhirIdentifierList read GetIdentifierList;
    property hasIdentifierList : boolean read GetHasIdentifierList;

    // Typed access to Type of plan. For example, "Platinum" or "High Deductable". (defined for API consistency)
    property type_ : TFhirCodeableConcept read FType_ write SetType_;
    // Type of plan. For example, "Platinum" or "High Deductable".
    property type_Element : TFhirCodeableConcept read FType_ write SetType_;

    // The geographic region in which a health insurance plan's benefits apply.
    property coverageAreaList : TFhirReferenceList read GetCoverageAreaList;
    property hasCoverageAreaList : boolean read GetHasCoverageAreaList;

    // Reference to the network that providing the type of coverage.
    property networkList : TFhirReferenceList read GetNetworkList;
    property hasNetworkList : boolean read GetHasNetworkList;

    // Overall costs associated with the plan.
    property generalCostList : TFhirInsurancePlanPlanGeneralCostList read GetGeneralCostList;
    property hasGeneralCostList : boolean read GetHasGeneralCostList;

    // Costs associated with the coverage provided by the product.
    property specificCostList : TFhirInsurancePlanPlanSpecificCostList read GetSpecificCostList;
    property hasSpecificCostList : boolean read GetHasSpecificCostList;

  end;

  TFhirInsurancePlanPlanListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirInsurancePlanPlanList;
    function GetCurrent : TFhirInsurancePlanPlan;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirInsurancePlanPlanList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirInsurancePlanPlan read GetCurrent;
  end;

  TFhirInsurancePlanPlanList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirInsurancePlanPlan;
    procedure SetItemN(index : Integer; value : TFhirInsurancePlanPlan);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirInsurancePlanPlanList; overload;
    function Clone : TFhirInsurancePlanPlanList; overload;
    function GetEnumerator : TFhirInsurancePlanPlanListEnumerator;
    
    //  Add a FhirInsurancePlanPlan to the end of the list.
    function Append : TFhirInsurancePlanPlan;
    
    // Add an already existing FhirInsurancePlanPlan to the end of the list.
    procedure AddItem(value : TFhirInsurancePlanPlan); overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirInsurancePlanPlan) : Integer;
    
    // Insert FhirInsurancePlanPlan before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirInsurancePlanPlan;
    
    // Insert an existing FhirInsurancePlanPlan before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirInsurancePlanPlan);
    
    // Get the iIndexth FhirInsurancePlanPlan. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirInsurancePlanPlan);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirInsurancePlanPlan;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirInsurancePlanPlans[index : Integer] : TFhirInsurancePlanPlan read GetItemN write SetItemN; default;
  End;

  // Overall costs associated with the plan.
  TFhirInsurancePlanPlanGeneralCost = class (TFhirBackboneElement)
  protected
    FType_ : TFhirCodeableConcept;
    FGroupSize : TFhirPositiveInt;
    FCost : TFhirMoney;
    FComment : TFhirString;
    procedure SetType_(value : TFhirCodeableConcept);
    procedure SetGroupSize(value : TFhirPositiveInt);
    function GetGroupSizeST : String;
    procedure SetGroupSizeST(value : String);
    procedure SetCost(value : TFhirMoney);
    procedure SetComment(value : TFhirString);
    function GetCommentST : String;
    procedure SetCommentST(value : String);
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirInsurancePlanPlanGeneralCost; overload;
    function Clone : TFhirInsurancePlanPlanGeneralCost; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to Type of cost. (defined for API consistency)
    property type_ : TFhirCodeableConcept read FType_ write SetType_;
    // Type of cost.
    property type_Element : TFhirCodeableConcept read FType_ write SetType_;

    // Typed access to Number of participants enrolled in the plan.
    property groupSize : String read GetGroupSizeST write SetGroupSizeST;
    // Number of participants enrolled in the plan.
    property groupSizeElement : TFhirPositiveInt read FGroupSize write SetGroupSize;

    // Typed access to Value of the cost. (defined for API consistency)
    property cost : TFhirMoney read FCost write SetCost;
    // Value of the cost.
    property costElement : TFhirMoney read FCost write SetCost;

    // Typed access to Additional information about the general costs associated with this plan.
    property comment : String read GetCommentST write SetCommentST;
    // Additional information about the general costs associated with this plan.
    property commentElement : TFhirString read FComment write SetComment;

  end;

  TFhirInsurancePlanPlanGeneralCostListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirInsurancePlanPlanGeneralCostList;
    function GetCurrent : TFhirInsurancePlanPlanGeneralCost;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirInsurancePlanPlanGeneralCostList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirInsurancePlanPlanGeneralCost read GetCurrent;
  end;

  TFhirInsurancePlanPlanGeneralCostList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirInsurancePlanPlanGeneralCost;
    procedure SetItemN(index : Integer; value : TFhirInsurancePlanPlanGeneralCost);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirInsurancePlanPlanGeneralCostList; overload;
    function Clone : TFhirInsurancePlanPlanGeneralCostList; overload;
    function GetEnumerator : TFhirInsurancePlanPlanGeneralCostListEnumerator;
    
    //  Add a FhirInsurancePlanPlanGeneralCost to the end of the list.
    function Append : TFhirInsurancePlanPlanGeneralCost;
    
    // Add an already existing FhirInsurancePlanPlanGeneralCost to the end of the list.
    procedure AddItem(value : TFhirInsurancePlanPlanGeneralCost); overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirInsurancePlanPlanGeneralCost) : Integer;
    
    // Insert FhirInsurancePlanPlanGeneralCost before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirInsurancePlanPlanGeneralCost;
    
    // Insert an existing FhirInsurancePlanPlanGeneralCost before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirInsurancePlanPlanGeneralCost);
    
    // Get the iIndexth FhirInsurancePlanPlanGeneralCost. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirInsurancePlanPlanGeneralCost);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirInsurancePlanPlanGeneralCost;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirInsurancePlanPlanGeneralCosts[index : Integer] : TFhirInsurancePlanPlanGeneralCost read GetItemN write SetItemN; default;
  End;

  // Costs associated with the coverage provided by the product.
  TFhirInsurancePlanPlanSpecificCost = class (TFhirBackboneElement)
  protected
    FCategory : TFhirCodeableConcept;
    FbenefitList : TFhirInsurancePlanPlanSpecificCostBenefitList;
    procedure SetCategory(value : TFhirCodeableConcept);
    function GetBenefitList : TFhirInsurancePlanPlanSpecificCostBenefitList;
    function GetHasBenefitList : Boolean;
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirInsurancePlanPlanSpecificCost; overload;
    function Clone : TFhirInsurancePlanPlanSpecificCost; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to General category of benefit (Medical; Dental; Vision; Drug; Mental Health; Substance Abuse; Hospice, Home Health). (defined for API consistency)
    property category : TFhirCodeableConcept read FCategory write SetCategory;
    // General category of benefit (Medical; Dental; Vision; Drug; Mental Health; Substance Abuse; Hospice, Home Health).
    property categoryElement : TFhirCodeableConcept read FCategory write SetCategory;

    // List of the specific benefits under this category of benefit.
    property benefitList : TFhirInsurancePlanPlanSpecificCostBenefitList read GetBenefitList;
    property hasBenefitList : boolean read GetHasBenefitList;

  end;

  TFhirInsurancePlanPlanSpecificCostListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirInsurancePlanPlanSpecificCostList;
    function GetCurrent : TFhirInsurancePlanPlanSpecificCost;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirInsurancePlanPlanSpecificCostList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirInsurancePlanPlanSpecificCost read GetCurrent;
  end;

  TFhirInsurancePlanPlanSpecificCostList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirInsurancePlanPlanSpecificCost;
    procedure SetItemN(index : Integer; value : TFhirInsurancePlanPlanSpecificCost);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirInsurancePlanPlanSpecificCostList; overload;
    function Clone : TFhirInsurancePlanPlanSpecificCostList; overload;
    function GetEnumerator : TFhirInsurancePlanPlanSpecificCostListEnumerator;
    
    //  Add a FhirInsurancePlanPlanSpecificCost to the end of the list.
    function Append : TFhirInsurancePlanPlanSpecificCost;
    
    // Add an already existing FhirInsurancePlanPlanSpecificCost to the end of the list.
    procedure AddItem(value : TFhirInsurancePlanPlanSpecificCost); overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirInsurancePlanPlanSpecificCost) : Integer;
    
    // Insert FhirInsurancePlanPlanSpecificCost before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirInsurancePlanPlanSpecificCost;
    
    // Insert an existing FhirInsurancePlanPlanSpecificCost before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirInsurancePlanPlanSpecificCost);
    
    // Get the iIndexth FhirInsurancePlanPlanSpecificCost. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirInsurancePlanPlanSpecificCost);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirInsurancePlanPlanSpecificCost;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirInsurancePlanPlanSpecificCosts[index : Integer] : TFhirInsurancePlanPlanSpecificCost read GetItemN write SetItemN; default;
  End;

  // List of the specific benefits under this category of benefit.
  TFhirInsurancePlanPlanSpecificCostBenefit = class (TFhirBackboneElement)
  protected
    FType_ : TFhirCodeableConcept;
    FcostList : TFhirInsurancePlanPlanSpecificCostBenefitCostList;
    procedure SetType_(value : TFhirCodeableConcept);
    function GetCostList : TFhirInsurancePlanPlanSpecificCostBenefitCostList;
    function GetHasCostList : Boolean;
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirInsurancePlanPlanSpecificCostBenefit; overload;
    function Clone : TFhirInsurancePlanPlanSpecificCostBenefit; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to Type of specific benefit (preventative; primary care office visit; speciality office visit; hospitalization; emergency room; urgent care). (defined for API consistency)
    property type_ : TFhirCodeableConcept read FType_ write SetType_;
    // Type of specific benefit (preventative; primary care office visit; speciality office visit; hospitalization; emergency room; urgent care).
    property type_Element : TFhirCodeableConcept read FType_ write SetType_;

    // List of the costs associated with a specific benefit.
    property costList : TFhirInsurancePlanPlanSpecificCostBenefitCostList read GetCostList;
    property hasCostList : boolean read GetHasCostList;

  end;

  TFhirInsurancePlanPlanSpecificCostBenefitListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirInsurancePlanPlanSpecificCostBenefitList;
    function GetCurrent : TFhirInsurancePlanPlanSpecificCostBenefit;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirInsurancePlanPlanSpecificCostBenefitList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirInsurancePlanPlanSpecificCostBenefit read GetCurrent;
  end;

  TFhirInsurancePlanPlanSpecificCostBenefitList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirInsurancePlanPlanSpecificCostBenefit;
    procedure SetItemN(index : Integer; value : TFhirInsurancePlanPlanSpecificCostBenefit);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirInsurancePlanPlanSpecificCostBenefitList; overload;
    function Clone : TFhirInsurancePlanPlanSpecificCostBenefitList; overload;
    function GetEnumerator : TFhirInsurancePlanPlanSpecificCostBenefitListEnumerator;
    
    //  Add a FhirInsurancePlanPlanSpecificCostBenefit to the end of the list.
    function Append : TFhirInsurancePlanPlanSpecificCostBenefit;
    
    // Add an already existing FhirInsurancePlanPlanSpecificCostBenefit to the end of the list.
    procedure AddItem(value : TFhirInsurancePlanPlanSpecificCostBenefit); overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirInsurancePlanPlanSpecificCostBenefit) : Integer;
    
    // Insert FhirInsurancePlanPlanSpecificCostBenefit before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirInsurancePlanPlanSpecificCostBenefit;
    
    // Insert an existing FhirInsurancePlanPlanSpecificCostBenefit before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirInsurancePlanPlanSpecificCostBenefit);
    
    // Get the iIndexth FhirInsurancePlanPlanSpecificCostBenefit. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirInsurancePlanPlanSpecificCostBenefit);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirInsurancePlanPlanSpecificCostBenefit;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirInsurancePlanPlanSpecificCostBenefits[index : Integer] : TFhirInsurancePlanPlanSpecificCostBenefit read GetItemN write SetItemN; default;
  End;

  // List of the costs associated with a specific benefit.
  TFhirInsurancePlanPlanSpecificCostBenefitCost = class (TFhirBackboneElement)
  protected
    FType_ : TFhirCodeableConcept;
    FApplicability : TFhirCodeableConcept;
    FqualifiersList : TFhirCodeableConceptList;
    FValue : TFhirQuantity;
    procedure SetType_(value : TFhirCodeableConcept);
    procedure SetApplicability(value : TFhirCodeableConcept);
    function GetQualifiersList : TFhirCodeableConceptList;
    function GetHasQualifiersList : Boolean;
    procedure SetValue(value : TFhirQuantity);
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirInsurancePlanPlanSpecificCostBenefitCost; overload;
    function Clone : TFhirInsurancePlanPlanSpecificCostBenefitCost; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to Type of cost (copay; individual cap; family cap; coinsurance; deductible). (defined for API consistency)
    property type_ : TFhirCodeableConcept read FType_ write SetType_;
    // Type of cost (copay; individual cap; family cap; coinsurance; deductible).
    property type_Element : TFhirCodeableConcept read FType_ write SetType_;

    // Typed access to Whether the cost applies to in-network or out-of-network providers (in-network; out-of-network; other). (defined for API consistency)
    property applicability : TFhirCodeableConcept read FApplicability write SetApplicability;
    // Whether the cost applies to in-network or out-of-network providers (in-network; out-of-network; other).
    property applicabilityElement : TFhirCodeableConcept read FApplicability write SetApplicability;

    // Additional information about the cost, such as information about funding sources (e.g. HSA, HRA, FSA, RRA).
    property qualifiersList : TFhirCodeableConceptList read GetQualifiersList;
    property hasQualifiersList : boolean read GetHasQualifiersList;

    // Typed access to The actual cost value. (some of the costs may be represented as percentages rather than currency, e.g. 10% coinsurance). (defined for API consistency)
    property value : TFhirQuantity read FValue write SetValue;
    // The actual cost value. (some of the costs may be represented as percentages rather than currency, e.g. 10% coinsurance).
    property valueElement : TFhirQuantity read FValue write SetValue;

  end;

  TFhirInsurancePlanPlanSpecificCostBenefitCostListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirInsurancePlanPlanSpecificCostBenefitCostList;
    function GetCurrent : TFhirInsurancePlanPlanSpecificCostBenefitCost;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirInsurancePlanPlanSpecificCostBenefitCostList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirInsurancePlanPlanSpecificCostBenefitCost read GetCurrent;
  end;

  TFhirInsurancePlanPlanSpecificCostBenefitCostList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirInsurancePlanPlanSpecificCostBenefitCost;
    procedure SetItemN(index : Integer; value : TFhirInsurancePlanPlanSpecificCostBenefitCost);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirInsurancePlanPlanSpecificCostBenefitCostList; overload;
    function Clone : TFhirInsurancePlanPlanSpecificCostBenefitCostList; overload;
    function GetEnumerator : TFhirInsurancePlanPlanSpecificCostBenefitCostListEnumerator;
    
    //  Add a FhirInsurancePlanPlanSpecificCostBenefitCost to the end of the list.
    function Append : TFhirInsurancePlanPlanSpecificCostBenefitCost;
    
    // Add an already existing FhirInsurancePlanPlanSpecificCostBenefitCost to the end of the list.
    procedure AddItem(value : TFhirInsurancePlanPlanSpecificCostBenefitCost); overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirInsurancePlanPlanSpecificCostBenefitCost) : Integer;
    
    // Insert FhirInsurancePlanPlanSpecificCostBenefitCost before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirInsurancePlanPlanSpecificCostBenefitCost;
    
    // Insert an existing FhirInsurancePlanPlanSpecificCostBenefitCost before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirInsurancePlanPlanSpecificCostBenefitCost);
    
    // Get the iIndexth FhirInsurancePlanPlanSpecificCostBenefitCost. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirInsurancePlanPlanSpecificCostBenefitCost);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirInsurancePlanPlanSpecificCostBenefitCost;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirInsurancePlanPlanSpecificCostBenefitCosts[index : Integer] : TFhirInsurancePlanPlanSpecificCostBenefitCost read GetItemN write SetItemN; default;
  End;

  // Details of a Health Insurance product/plan provided by an organization.
  TFhirInsurancePlan = class (TFhirDomainResource)
  protected
    FidentifierList : TFhirIdentifierList;
    FStatus : TFhirEnum;
    Ftype_List : TFhirCodeableConceptList;
    FName : TFhirString;
    FaliasList : TFhirStringList;
    FPeriod : TFhirPeriod;
    FOwnedBy : TFhirReference;
    FAdministeredBy : TFhirReference;
    FcoverageAreaList : TFhirReferenceList;
    FcontactList : TFhirInsurancePlanContactList;
    FendpointList : TFhirReferenceList;
    FnetworkList : TFhirReferenceList;
    FcoverageList : TFhirInsurancePlanCoverageList;
    FplanList : TFhirInsurancePlanPlanList;
    function GetIdentifierList : TFhirIdentifierList;
    function GetHasIdentifierList : Boolean;
    procedure SetStatus(value : TFhirEnum);
    function GetStatusST : TFhirPublicationStatusEnum;
    procedure SetStatusST(value : TFhirPublicationStatusEnum);
    function GetType_List : TFhirCodeableConceptList;
    function GetHasType_List : Boolean;
    procedure SetName(value : TFhirString);
    function GetNameST : String;
    procedure SetNameST(value : String);
    function GetAliasList : TFhirStringList;
    function GetHasAliasList : Boolean;
    procedure SetPeriod(value : TFhirPeriod);
    procedure SetOwnedBy(value : TFhirReference);
    procedure SetAdministeredBy(value : TFhirReference);
    function GetCoverageAreaList : TFhirReferenceList;
    function GetHasCoverageAreaList : Boolean;
    function GetContactList : TFhirInsurancePlanContactList;
    function GetHasContactList : Boolean;
    function GetEndpointList : TFhirReferenceList;
    function GetHasEndpointList : Boolean;
    function GetNetworkList : TFhirReferenceList;
    function GetHasNetworkList : Boolean;
    function GetCoverageList : TFhirInsurancePlanCoverageList;
    function GetHasCoverageList : Boolean;
    function GetPlanList : TFhirInsurancePlanPlanList;
    function GetHasPlanList : Boolean;
  
    function GetResourceType : TFhirResourceType; override;
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirInsurancePlan; overload;
    function Clone : TFhirInsurancePlan; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Business identifiers assigned to this health insurance product which remain constant as the resource is updated and propagates from server to server.
    property identifierList : TFhirIdentifierList read GetIdentifierList;
    property hasIdentifierList : boolean read GetHasIdentifierList;

    // The current state of the health insurance product.
    property status : TFhirPublicationStatusEnum read GetStatusST write SetStatusST;
    property statusElement : TFhirEnum read FStatus write SetStatus;

    // The kind of health insurance product.
    property type_List : TFhirCodeableConceptList read GetType_List;
    property hasType_List : boolean read GetHasType_List;

    // Typed access to Official name of the health insurance product as designated by the owner.
    property name : String read GetNameST write SetNameST;
    // Official name of the health insurance product as designated by the owner.
    property nameElement : TFhirString read FName write SetName;

    // A list of alternate names that the product is known as, or was known as in the past.
    property aliasList : TFhirStringList read GetAliasList;
    property hasAliasList : boolean read GetHasAliasList;

    // Typed access to The period of time that the health insurance product is available. (defined for API consistency)
    property period : TFhirPeriod read FPeriod write SetPeriod;
    // The period of time that the health insurance product is available.
    property periodElement : TFhirPeriod read FPeriod write SetPeriod;

    // Typed access to The entity that is providing  the health insurance product and underwriting the risk.  This is typically an insurance carriers, other third-party payers, or health plan sponsors comonly referred to as 'payers'. (defined for API consistency)
    property ownedBy : TFhirReference read FOwnedBy write SetOwnedBy;
    // The entity that is providing  the health insurance product and underwriting the risk.  This is typically an insurance carriers, other third-party payers, or health plan sponsors comonly referred to as 'payers'.
    property ownedByElement : TFhirReference read FOwnedBy write SetOwnedBy;

    // Typed access to An organization which administer other services such as underwriting, customer service and/or claims processing on behalf of the health insurance product owner. (defined for API consistency)
    property administeredBy : TFhirReference read FAdministeredBy write SetAdministeredBy;
    // An organization which administer other services such as underwriting, customer service and/or claims processing on behalf of the health insurance product owner.
    property administeredByElement : TFhirReference read FAdministeredBy write SetAdministeredBy;

    // The geographic region in which a health insurance product's benefits apply.
    property coverageAreaList : TFhirReferenceList read GetCoverageAreaList;
    property hasCoverageAreaList : boolean read GetHasCoverageAreaList;

    // The contact for the health insurance product for a certain purpose.
    property contactList : TFhirInsurancePlanContactList read GetContactList;
    property hasContactList : boolean read GetHasContactList;

    // The technical endpoints providing access to services operated for the health insurance product.
    property endpointList : TFhirReferenceList read GetEndpointList;
    property hasEndpointList : boolean read GetHasEndpointList;

    // Reference to the network included in the health insurance product.
    property networkList : TFhirReferenceList read GetNetworkList;
    property hasNetworkList : boolean read GetHasNetworkList;

    // Details about the coverage offered by the insurance product.
    property coverageList : TFhirInsurancePlanCoverageList read GetCoverageList;
    property hasCoverageList : boolean read GetHasCoverageList;

    // Details about an insurance plan.
    property planList : TFhirInsurancePlanPlanList read GetPlanList;
    property hasPlanList : boolean read GetHasPlanList;

  end;

  TFhirInsurancePlanListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirInsurancePlanList;
    function GetCurrent : TFhirInsurancePlan;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirInsurancePlanList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirInsurancePlan read GetCurrent;
  end;

  TFhirInsurancePlanList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirInsurancePlan;
    procedure SetItemN(index : Integer; value : TFhirInsurancePlan);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirInsurancePlanList; overload;
    function Clone : TFhirInsurancePlanList; overload;
    function GetEnumerator : TFhirInsurancePlanListEnumerator;
    
    //  Add a FhirInsurancePlan to the end of the list.
    function Append : TFhirInsurancePlan;
    
    // Add an already existing FhirInsurancePlan to the end of the list.
    procedure AddItem(value : TFhirInsurancePlan); overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirInsurancePlan) : Integer;
    
    // Insert FhirInsurancePlan before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirInsurancePlan;
    
    // Insert an existing FhirInsurancePlan before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirInsurancePlan);
    
    // Get the iIndexth FhirInsurancePlan. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirInsurancePlan);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirInsurancePlan;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirInsurancePlans[index : Integer] : TFhirInsurancePlan read GetItemN write SetItemN; default;
  End;

{$ENDIF FHIR_INSURANCEPLAN}
{$IFDEF FHIR_INVOICE}
  // Indicates who or what performed or participated in the charged service.
  TFhirInvoiceParticipant = class (TFhirBackboneElement)
  protected
    FRole : TFhirCodeableConcept;
    FActor : TFhirReference;
    procedure SetRole(value : TFhirCodeableConcept);
    procedure SetActor(value : TFhirReference);
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirInvoiceParticipant; overload;
    function Clone : TFhirInvoiceParticipant; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to Describes the type of involvement (e.g. transcriptionist, creator etc.). If the invoice has been created automatically, the Participant may be a billing engine or another kind of device. (defined for API consistency)
    property role : TFhirCodeableConcept read FRole write SetRole;
    // Describes the type of involvement (e.g. transcriptionist, creator etc.). If the invoice has been created automatically, the Participant may be a billing engine or another kind of device.
    property roleElement : TFhirCodeableConcept read FRole write SetRole;

    // Typed access to The device, practitioner, etc. who performed or participated in the service. (defined for API consistency)
    property actor : TFhirReference read FActor write SetActor;
    // The device, practitioner, etc. who performed or participated in the service.
    property actorElement : TFhirReference read FActor write SetActor;

  end;

  TFhirInvoiceParticipantListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirInvoiceParticipantList;
    function GetCurrent : TFhirInvoiceParticipant;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirInvoiceParticipantList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirInvoiceParticipant read GetCurrent;
  end;

  TFhirInvoiceParticipantList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirInvoiceParticipant;
    procedure SetItemN(index : Integer; value : TFhirInvoiceParticipant);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirInvoiceParticipantList; overload;
    function Clone : TFhirInvoiceParticipantList; overload;
    function GetEnumerator : TFhirInvoiceParticipantListEnumerator;
    
    //  Add a FhirInvoiceParticipant to the end of the list.
    function Append : TFhirInvoiceParticipant;
    
    // Add an already existing FhirInvoiceParticipant to the end of the list.
    procedure AddItem(value : TFhirInvoiceParticipant); overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirInvoiceParticipant) : Integer;
    
    // Insert FhirInvoiceParticipant before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirInvoiceParticipant;
    
    // Insert an existing FhirInvoiceParticipant before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirInvoiceParticipant);
    
    // Get the iIndexth FhirInvoiceParticipant. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirInvoiceParticipant);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirInvoiceParticipant;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirInvoiceParticipants[index : Integer] : TFhirInvoiceParticipant read GetItemN write SetItemN; default;
  End;

  // Each line item represents one charge for goods and services rendered. Details such as date, code and amount are found in the referenced ChargeItem resource.
  TFhirInvoiceLineItem = class (TFhirBackboneElement)
  protected
    FSequence : TFhirPositiveInt;
    FChargeItem : TFhirDataType;
    FpriceComponentList : TFhirInvoiceLineItemPriceComponentList;
    procedure SetSequence(value : TFhirPositiveInt);
    function GetSequenceST : String;
    procedure SetSequenceST(value : String);
    procedure SetChargeItem(value : TFhirDataType);
    function GetPriceComponentList : TFhirInvoiceLineItemPriceComponentList;
    function GetHasPriceComponentList : Boolean;
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirInvoiceLineItem; overload;
    function Clone : TFhirInvoiceLineItem; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to Sequence in which the items appear on the invoice.
    property sequence : String read GetSequenceST write SetSequenceST;
    // Sequence in which the items appear on the invoice.
    property sequenceElement : TFhirPositiveInt read FSequence write SetSequence;

    // Typed access to The ChargeItem contains information such as the billing code, date, amount etc. If no further details are required for the lineItem, inline billing codes can be added using the CodeableConcept data type instead of the Reference. (defined for API consistency)
    property chargeItem : TFhirDataType read FChargeItem write SetChargeItem;
    // The ChargeItem contains information such as the billing code, date, amount etc. If no further details are required for the lineItem, inline billing codes can be added using the CodeableConcept data type instead of the Reference.
    property chargeItemElement : TFhirDataType read FChargeItem write SetChargeItem;

    // The price for a ChargeItem may be calculated as a base price with surcharges/deductions that apply in certain conditions. A ChargeItemDefinition resource that defines the prices, factors and conditions that apply to a billing code is currently under development. The priceComponent element can be used to offer transparency to the recipient of the Invoice as to how the prices have been calculated.
    property priceComponentList : TFhirInvoiceLineItemPriceComponentList read GetPriceComponentList;
    property hasPriceComponentList : boolean read GetHasPriceComponentList;

  end;

  TFhirInvoiceLineItemListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirInvoiceLineItemList;
    function GetCurrent : TFhirInvoiceLineItem;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirInvoiceLineItemList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirInvoiceLineItem read GetCurrent;
  end;

  TFhirInvoiceLineItemList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirInvoiceLineItem;
    procedure SetItemN(index : Integer; value : TFhirInvoiceLineItem);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirInvoiceLineItemList; overload;
    function Clone : TFhirInvoiceLineItemList; overload;
    function GetEnumerator : TFhirInvoiceLineItemListEnumerator;
    
    //  Add a FhirInvoiceLineItem to the end of the list.
    function Append : TFhirInvoiceLineItem;
    
    // Add an already existing FhirInvoiceLineItem to the end of the list.
    procedure AddItem(value : TFhirInvoiceLineItem); overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirInvoiceLineItem) : Integer;
    
    // Insert FhirInvoiceLineItem before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirInvoiceLineItem;
    
    // Insert an existing FhirInvoiceLineItem before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirInvoiceLineItem);
    
    // Get the iIndexth FhirInvoiceLineItem. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirInvoiceLineItem);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirInvoiceLineItem;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirInvoiceLineItems[index : Integer] : TFhirInvoiceLineItem read GetItemN write SetItemN; default;
  End;

  // The price for a ChargeItem may be calculated as a base price with surcharges/deductions that apply in certain conditions. A ChargeItemDefinition resource that defines the prices, factors and conditions that apply to a billing code is currently under development. The priceComponent element can be used to offer transparency to the recipient of the Invoice as to how the prices have been calculated.
  TFhirInvoiceLineItemPriceComponent = class (TFhirBackboneElement)
  protected
    FType_ : TFhirEnum;
    FCode : TFhirCodeableConcept;
    FFactor : TFhirDecimal;
    FAmount : TFhirMoney;
    procedure SetType_(value : TFhirEnum);
    function GetType_ST : TFhirInvoicePriceComponentTypeEnum;
    procedure SetType_ST(value : TFhirInvoicePriceComponentTypeEnum);
    procedure SetCode(value : TFhirCodeableConcept);
    procedure SetFactor(value : TFhirDecimal);
    function GetFactorST : String;
    procedure SetFactorST(value : String);
    procedure SetAmount(value : TFhirMoney);
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirInvoiceLineItemPriceComponent; overload;
    function Clone : TFhirInvoiceLineItemPriceComponent; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // This code identifies the type of the component.
    property type_ : TFhirInvoicePriceComponentTypeEnum read GetType_ST write SetType_ST;
    property type_Element : TFhirEnum read FType_ write SetType_;

    // Typed access to A code that identifies the component. Codes may be used to differentiate between kinds of taxes, surcharges, discounts etc. (defined for API consistency)
    property code : TFhirCodeableConcept read FCode write SetCode;
    // A code that identifies the component. Codes may be used to differentiate between kinds of taxes, surcharges, discounts etc.
    property codeElement : TFhirCodeableConcept read FCode write SetCode;

    // Typed access to The factor that has been applied on the base price for calculating this component.
    property factor : String read GetFactorST write SetFactorST;
    // The factor that has been applied on the base price for calculating this component.
    property factorElement : TFhirDecimal read FFactor write SetFactor;

    // Typed access to The amount calculated for this component. (defined for API consistency)
    property amount : TFhirMoney read FAmount write SetAmount;
    // The amount calculated for this component.
    property amountElement : TFhirMoney read FAmount write SetAmount;

  end;

  TFhirInvoiceLineItemPriceComponentListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirInvoiceLineItemPriceComponentList;
    function GetCurrent : TFhirInvoiceLineItemPriceComponent;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirInvoiceLineItemPriceComponentList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirInvoiceLineItemPriceComponent read GetCurrent;
  end;

  TFhirInvoiceLineItemPriceComponentList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirInvoiceLineItemPriceComponent;
    procedure SetItemN(index : Integer; value : TFhirInvoiceLineItemPriceComponent);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirInvoiceLineItemPriceComponentList; overload;
    function Clone : TFhirInvoiceLineItemPriceComponentList; overload;
    function GetEnumerator : TFhirInvoiceLineItemPriceComponentListEnumerator;
    
    //  Add a FhirInvoiceLineItemPriceComponent to the end of the list.
    function Append : TFhirInvoiceLineItemPriceComponent;
    
    // Add an already existing FhirInvoiceLineItemPriceComponent to the end of the list.
    procedure AddItem(value : TFhirInvoiceLineItemPriceComponent); overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirInvoiceLineItemPriceComponent) : Integer;
    
    // Insert FhirInvoiceLineItemPriceComponent before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirInvoiceLineItemPriceComponent;
    
    // Insert an existing FhirInvoiceLineItemPriceComponent before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirInvoiceLineItemPriceComponent);
    
    // Get the iIndexth FhirInvoiceLineItemPriceComponent. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirInvoiceLineItemPriceComponent);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirInvoiceLineItemPriceComponent;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirInvoiceLineItemPriceComponents[index : Integer] : TFhirInvoiceLineItemPriceComponent read GetItemN write SetItemN; default;
  End;

  // Invoice containing collected ChargeItems from an Account with calculated individual and total price for Billing purpose.
  TFhirInvoice = class (TFhirDomainResource)
  protected
    FidentifierList : TFhirIdentifierList;
    FStatus : TFhirEnum;
    FCancelledReason : TFhirString;
    FType_ : TFhirCodeableConcept;
    FSubject : TFhirReference;
    FRecipient : TFhirReference;
    FDate : TFhirDateTime;
    FparticipantList : TFhirInvoiceParticipantList;
    FIssuer : TFhirReference;
    FAccount : TFhirReference;
    FlineItemList : TFhirInvoiceLineItemList;
    FtotalPriceComponentList : TFhirInvoiceLineItemPriceComponentList;
    FTotalNet : TFhirMoney;
    FTotalGross : TFhirMoney;
    FPaymentTerms : TFhirMarkdown;
    FnoteList : TFhirAnnotationList;
    function GetIdentifierList : TFhirIdentifierList;
    function GetHasIdentifierList : Boolean;
    procedure SetStatus(value : TFhirEnum);
    function GetStatusST : TFhirInvoiceStatusEnum;
    procedure SetStatusST(value : TFhirInvoiceStatusEnum);
    procedure SetCancelledReason(value : TFhirString);
    function GetCancelledReasonST : String;
    procedure SetCancelledReasonST(value : String);
    procedure SetType_(value : TFhirCodeableConcept);
    procedure SetSubject(value : TFhirReference);
    procedure SetRecipient(value : TFhirReference);
    procedure SetDate(value : TFhirDateTime);
    function GetDateST : TFslDateTime;
    procedure SetDateST(value : TFslDateTime);
    function GetParticipantList : TFhirInvoiceParticipantList;
    function GetHasParticipantList : Boolean;
    procedure SetIssuer(value : TFhirReference);
    procedure SetAccount(value : TFhirReference);
    function GetLineItemList : TFhirInvoiceLineItemList;
    function GetHasLineItemList : Boolean;
    function GetTotalPriceComponentList : TFhirInvoiceLineItemPriceComponentList;
    function GetHasTotalPriceComponentList : Boolean;
    procedure SetTotalNet(value : TFhirMoney);
    procedure SetTotalGross(value : TFhirMoney);
    procedure SetPaymentTerms(value : TFhirMarkdown);
    function GetPaymentTermsST : String;
    procedure SetPaymentTermsST(value : String);
    function GetNoteList : TFhirAnnotationList;
    function GetHasNoteList : Boolean;
  
    function GetResourceType : TFhirResourceType; override;
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirInvoice; overload;
    function Clone : TFhirInvoice; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Identifier of this Invoice, often used for reference in correspondence about this invoice or for tracking of payments.
    property identifierList : TFhirIdentifierList read GetIdentifierList;
    property hasIdentifierList : boolean read GetHasIdentifierList;

    // The current state of the Invoice.
    property status : TFhirInvoiceStatusEnum read GetStatusST write SetStatusST;
    property statusElement : TFhirEnum read FStatus write SetStatus;

    // Typed access to In case of Invoice cancellation a reason must be given (entered in error, superseded by corrected invoice etc.).
    property cancelledReason : String read GetCancelledReasonST write SetCancelledReasonST;
    // In case of Invoice cancellation a reason must be given (entered in error, superseded by corrected invoice etc.).
    property cancelledReasonElement : TFhirString read FCancelledReason write SetCancelledReason;

    // Typed access to Type of Invoice depending on domain, realm an usage (e.g. internal/external, dental, preliminary). (defined for API consistency)
    property type_ : TFhirCodeableConcept read FType_ write SetType_;
    // Type of Invoice depending on domain, realm an usage (e.g. internal/external, dental, preliminary).
    property type_Element : TFhirCodeableConcept read FType_ write SetType_;

    // Typed access to The individual or set of individuals receiving the goods and services billed in this invoice. (defined for API consistency)
    property subject : TFhirReference read FSubject write SetSubject;
    // The individual or set of individuals receiving the goods and services billed in this invoice.
    property subjectElement : TFhirReference read FSubject write SetSubject;

    // Typed access to The individual or Organization responsible for balancing of this invoice. (defined for API consistency)
    property recipient : TFhirReference read FRecipient write SetRecipient;
    // The individual or Organization responsible for balancing of this invoice.
    property recipientElement : TFhirReference read FRecipient write SetRecipient;

    // Typed access to Date/time(s) of when this Invoice was posted.
    property date : TFslDateTime read GetDateST write SetDateST;
    // Date/time(s) of when this Invoice was posted.
    property dateElement : TFhirDateTime read FDate write SetDate;

    // Indicates who or what performed or participated in the charged service.
    property participantList : TFhirInvoiceParticipantList read GetParticipantList;
    property hasParticipantList : boolean read GetHasParticipantList;

    // Typed access to The organizationissuing the Invoice. (defined for API consistency)
    property issuer : TFhirReference read FIssuer write SetIssuer;
    // The organizationissuing the Invoice.
    property issuerElement : TFhirReference read FIssuer write SetIssuer;

    // Typed access to Account which is supposed to be balanced with this Invoice. (defined for API consistency)
    property account : TFhirReference read FAccount write SetAccount;
    // Account which is supposed to be balanced with this Invoice.
    property accountElement : TFhirReference read FAccount write SetAccount;

    // Each line item represents one charge for goods and services rendered. Details such as date, code and amount are found in the referenced ChargeItem resource.
    property lineItemList : TFhirInvoiceLineItemList read GetLineItemList;
    property hasLineItemList : boolean read GetHasLineItemList;

    // The total amount for the Invoice may be calculated as the sum of the line items with surcharges/deductions that apply in certain conditions.  The priceComponent element can be used to offer transparency to the recipient of the Invoice of how the total price was calculated.
    property totalPriceComponentList : TFhirInvoiceLineItemPriceComponentList read GetTotalPriceComponentList;
    property hasTotalPriceComponentList : boolean read GetHasTotalPriceComponentList;

    // Typed access to Invoice total , taxes excluded. (defined for API consistency)
    property totalNet : TFhirMoney read FTotalNet write SetTotalNet;
    // Invoice total , taxes excluded.
    property totalNetElement : TFhirMoney read FTotalNet write SetTotalNet;

    // Typed access to Invoice total, tax included. (defined for API consistency)
    property totalGross : TFhirMoney read FTotalGross write SetTotalGross;
    // Invoice total, tax included.
    property totalGrossElement : TFhirMoney read FTotalGross write SetTotalGross;

    // Typed access to Payment details such as banking details, period of payment, deductibles, methods of payment.
    property paymentTerms : String read GetPaymentTermsST write SetPaymentTermsST;
    // Payment details such as banking details, period of payment, deductibles, methods of payment.
    property paymentTermsElement : TFhirMarkdown read FPaymentTerms write SetPaymentTerms;

    // Comments made about the invoice by the issuer, subject, or other participants.
    property noteList : TFhirAnnotationList read GetNoteList;
    property hasNoteList : boolean read GetHasNoteList;

  end;

  TFhirInvoiceListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirInvoiceList;
    function GetCurrent : TFhirInvoice;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirInvoiceList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirInvoice read GetCurrent;
  end;

  TFhirInvoiceList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirInvoice;
    procedure SetItemN(index : Integer; value : TFhirInvoice);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirInvoiceList; overload;
    function Clone : TFhirInvoiceList; overload;
    function GetEnumerator : TFhirInvoiceListEnumerator;
    
    //  Add a FhirInvoice to the end of the list.
    function Append : TFhirInvoice;
    
    // Add an already existing FhirInvoice to the end of the list.
    procedure AddItem(value : TFhirInvoice); overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirInvoice) : Integer;
    
    // Insert FhirInvoice before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirInvoice;
    
    // Insert an existing FhirInvoice before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirInvoice);
    
    // Get the iIndexth FhirInvoice. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirInvoice);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirInvoice;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirInvoices[index : Integer] : TFhirInvoice read GetItemN write SetItemN; default;
  End;

{$ENDIF FHIR_INVOICE}
{$IFDEF FHIR_PAYMENTNOTICE}
  // This resource provides the status of the payment for goods and services rendered, and the request and response resource references.
  TFhirPaymentNotice = class (TFhirDomainResource)
  protected
    FidentifierList : TFhirIdentifierList;
    FStatus : TFhirEnum;
    FRequest : TFhirReference;
    FResponse : TFhirReference;
    FCreated : TFhirDateTime;
    FProvider : TFhirReference;
    FPayment : TFhirReference;
    FPaymentDate : TFhirDate;
    FPayee : TFhirReference;
    FRecipient : TFhirReference;
    FAmount : TFhirMoney;
    FPaymentStatus : TFhirCodeableConcept;
    function GetIdentifierList : TFhirIdentifierList;
    function GetHasIdentifierList : Boolean;
    procedure SetStatus(value : TFhirEnum);
    function GetStatusST : TFhirFinancialResourceStatusCodesEnum;
    procedure SetStatusST(value : TFhirFinancialResourceStatusCodesEnum);
    procedure SetRequest(value : TFhirReference);
    procedure SetResponse(value : TFhirReference);
    procedure SetCreated(value : TFhirDateTime);
    function GetCreatedST : TFslDateTime;
    procedure SetCreatedST(value : TFslDateTime);
    procedure SetProvider(value : TFhirReference);
    procedure SetPayment(value : TFhirReference);
    procedure SetPaymentDate(value : TFhirDate);
    function GetPaymentDateST : TFslDateTime;
    procedure SetPaymentDateST(value : TFslDateTime);
    procedure SetPayee(value : TFhirReference);
    procedure SetRecipient(value : TFhirReference);
    procedure SetAmount(value : TFhirMoney);
    procedure SetPaymentStatus(value : TFhirCodeableConcept);
  
    function GetResourceType : TFhirResourceType; override;
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirPaymentNotice; overload;
    function Clone : TFhirPaymentNotice; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // A unique identifier assigned to this payment notice.
    property identifierList : TFhirIdentifierList read GetIdentifierList;
    property hasIdentifierList : boolean read GetHasIdentifierList;

    // The status of the resource instance.
    property status : TFhirFinancialResourceStatusCodesEnum read GetStatusST write SetStatusST;
    property statusElement : TFhirEnum read FStatus write SetStatus;

    // Typed access to Reference of resource for which payment is being made. (defined for API consistency)
    property request : TFhirReference read FRequest write SetRequest;
    // Reference of resource for which payment is being made.
    property requestElement : TFhirReference read FRequest write SetRequest;

    // Typed access to Reference of response to resource for which payment is being made. (defined for API consistency)
    property response : TFhirReference read FResponse write SetResponse;
    // Reference of response to resource for which payment is being made.
    property responseElement : TFhirReference read FResponse write SetResponse;

    // Typed access to The date when this resource was created.
    property created : TFslDateTime read GetCreatedST write SetCreatedST;
    // The date when this resource was created.
    property createdElement : TFhirDateTime read FCreated write SetCreated;

    // Typed access to The practitioner who is responsible for the services rendered to the patient. (defined for API consistency)
    property provider : TFhirReference read FProvider write SetProvider;
    // The practitioner who is responsible for the services rendered to the patient.
    property providerElement : TFhirReference read FProvider write SetProvider;

    // Typed access to A reference to the payment which is the subject of this notice. (defined for API consistency)
    property payment : TFhirReference read FPayment write SetPayment;
    // A reference to the payment which is the subject of this notice.
    property paymentElement : TFhirReference read FPayment write SetPayment;

    // Typed access to The date when the above payment action occurred.
    property paymentDate : TFslDateTime read GetPaymentDateST write SetPaymentDateST;
    // The date when the above payment action occurred.
    property paymentDateElement : TFhirDate read FPaymentDate write SetPaymentDate;

    // Typed access to The party who will receive or has received payment that is the subject of this notification. (defined for API consistency)
    property payee : TFhirReference read FPayee write SetPayee;
    // The party who will receive or has received payment that is the subject of this notification.
    property payeeElement : TFhirReference read FPayee write SetPayee;

    // Typed access to The party who is notified of the payment status. (defined for API consistency)
    property recipient : TFhirReference read FRecipient write SetRecipient;
    // The party who is notified of the payment status.
    property recipientElement : TFhirReference read FRecipient write SetRecipient;

    // Typed access to The amount sent to the payee. (defined for API consistency)
    property amount : TFhirMoney read FAmount write SetAmount;
    // The amount sent to the payee.
    property amountElement : TFhirMoney read FAmount write SetAmount;

    // Typed access to A code indicating whether payment has been sent or cleared. (defined for API consistency)
    property paymentStatus : TFhirCodeableConcept read FPaymentStatus write SetPaymentStatus;
    // A code indicating whether payment has been sent or cleared.
    property paymentStatusElement : TFhirCodeableConcept read FPaymentStatus write SetPaymentStatus;

  end;

  TFhirPaymentNoticeListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirPaymentNoticeList;
    function GetCurrent : TFhirPaymentNotice;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirPaymentNoticeList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirPaymentNotice read GetCurrent;
  end;

  TFhirPaymentNoticeList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirPaymentNotice;
    procedure SetItemN(index : Integer; value : TFhirPaymentNotice);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirPaymentNoticeList; overload;
    function Clone : TFhirPaymentNoticeList; overload;
    function GetEnumerator : TFhirPaymentNoticeListEnumerator;
    
    //  Add a FhirPaymentNotice to the end of the list.
    function Append : TFhirPaymentNotice;
    
    // Add an already existing FhirPaymentNotice to the end of the list.
    procedure AddItem(value : TFhirPaymentNotice); overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirPaymentNotice) : Integer;
    
    // Insert FhirPaymentNotice before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirPaymentNotice;
    
    // Insert an existing FhirPaymentNotice before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirPaymentNotice);
    
    // Get the iIndexth FhirPaymentNotice. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirPaymentNotice);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirPaymentNotice;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirPaymentNotices[index : Integer] : TFhirPaymentNotice read GetItemN write SetItemN; default;
  End;

{$ENDIF FHIR_PAYMENTNOTICE}
{$IFDEF FHIR_PAYMENTRECONCILIATION}
  // Distribution of the payment amount for a previously acknowledged payable.
  TFhirPaymentReconciliationDetail = class (TFhirBackboneElement)
  protected
    FIdentifier : TFhirIdentifier;
    FPredecessor : TFhirIdentifier;
    FType_ : TFhirCodeableConcept;
    FRequest : TFhirReference;
    FSubmitter : TFhirReference;
    FResponse : TFhirReference;
    FDate : TFhirDate;
    FResponsible : TFhirReference;
    FPayee : TFhirReference;
    FAmount : TFhirMoney;
    procedure SetIdentifier(value : TFhirIdentifier);
    procedure SetPredecessor(value : TFhirIdentifier);
    procedure SetType_(value : TFhirCodeableConcept);
    procedure SetRequest(value : TFhirReference);
    procedure SetSubmitter(value : TFhirReference);
    procedure SetResponse(value : TFhirReference);
    procedure SetDate(value : TFhirDate);
    function GetDateST : TFslDateTime;
    procedure SetDateST(value : TFslDateTime);
    procedure SetResponsible(value : TFhirReference);
    procedure SetPayee(value : TFhirReference);
    procedure SetAmount(value : TFhirMoney);
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirPaymentReconciliationDetail; overload;
    function Clone : TFhirPaymentReconciliationDetail; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to Unique identifier for the current payment item for the referenced payable. (defined for API consistency)
    property identifier : TFhirIdentifier read FIdentifier write SetIdentifier;
    // Unique identifier for the current payment item for the referenced payable.
    property identifierElement : TFhirIdentifier read FIdentifier write SetIdentifier;

    // Typed access to Unique identifier for the prior payment item for the referenced payable. (defined for API consistency)
    property predecessor : TFhirIdentifier read FPredecessor write SetPredecessor;
    // Unique identifier for the prior payment item for the referenced payable.
    property predecessorElement : TFhirIdentifier read FPredecessor write SetPredecessor;

    // Typed access to Code to indicate the nature of the payment. (defined for API consistency)
    property type_ : TFhirCodeableConcept read FType_ write SetType_;
    // Code to indicate the nature of the payment.
    property type_Element : TFhirCodeableConcept read FType_ write SetType_;

    // Typed access to A resource, such as a Claim, the evaluation of which could lead to payment. (defined for API consistency)
    property request : TFhirReference read FRequest write SetRequest;
    // A resource, such as a Claim, the evaluation of which could lead to payment.
    property requestElement : TFhirReference read FRequest write SetRequest;

    // Typed access to The party which submitted the claim or financial transaction. (defined for API consistency)
    property submitter : TFhirReference read FSubmitter write SetSubmitter;
    // The party which submitted the claim or financial transaction.
    property submitterElement : TFhirReference read FSubmitter write SetSubmitter;

    // Typed access to A resource, such as a ClaimResponse, which contains a commitment to payment. (defined for API consistency)
    property response : TFhirReference read FResponse write SetResponse;
    // A resource, such as a ClaimResponse, which contains a commitment to payment.
    property responseElement : TFhirReference read FResponse write SetResponse;

    // Typed access to The date from the response resource containing a commitment to pay.
    property date : TFslDateTime read GetDateST write SetDateST;
    // The date from the response resource containing a commitment to pay.
    property dateElement : TFhirDate read FDate write SetDate;

    // Typed access to A reference to the individual who is responsible for inquiries regarding the response and its payment. (defined for API consistency)
    property responsible : TFhirReference read FResponsible write SetResponsible;
    // A reference to the individual who is responsible for inquiries regarding the response and its payment.
    property responsibleElement : TFhirReference read FResponsible write SetResponsible;

    // Typed access to The party which is receiving the payment. (defined for API consistency)
    property payee : TFhirReference read FPayee write SetPayee;
    // The party which is receiving the payment.
    property payeeElement : TFhirReference read FPayee write SetPayee;

    // Typed access to The monetary amount allocated from the total payment to the payable. (defined for API consistency)
    property amount : TFhirMoney read FAmount write SetAmount;
    // The monetary amount allocated from the total payment to the payable.
    property amountElement : TFhirMoney read FAmount write SetAmount;

  end;

  TFhirPaymentReconciliationDetailListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirPaymentReconciliationDetailList;
    function GetCurrent : TFhirPaymentReconciliationDetail;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirPaymentReconciliationDetailList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirPaymentReconciliationDetail read GetCurrent;
  end;

  TFhirPaymentReconciliationDetailList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirPaymentReconciliationDetail;
    procedure SetItemN(index : Integer; value : TFhirPaymentReconciliationDetail);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirPaymentReconciliationDetailList; overload;
    function Clone : TFhirPaymentReconciliationDetailList; overload;
    function GetEnumerator : TFhirPaymentReconciliationDetailListEnumerator;
    
    //  Add a FhirPaymentReconciliationDetail to the end of the list.
    function Append : TFhirPaymentReconciliationDetail;
    
    // Add an already existing FhirPaymentReconciliationDetail to the end of the list.
    procedure AddItem(value : TFhirPaymentReconciliationDetail); overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirPaymentReconciliationDetail) : Integer;
    
    // Insert FhirPaymentReconciliationDetail before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirPaymentReconciliationDetail;
    
    // Insert an existing FhirPaymentReconciliationDetail before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirPaymentReconciliationDetail);
    
    // Get the iIndexth FhirPaymentReconciliationDetail. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirPaymentReconciliationDetail);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirPaymentReconciliationDetail;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirPaymentReconciliationDetails[index : Integer] : TFhirPaymentReconciliationDetail read GetItemN write SetItemN; default;
  End;

  // A note that describes or explains the processing in a human readable form.
  TFhirPaymentReconciliationProcessNote = class (TFhirBackboneElement)
  protected
    FType_ : TFhirEnum;
    FText : TFhirString;
    procedure SetType_(value : TFhirEnum);
    function GetType_ST : TFhirNoteTypeEnum;
    procedure SetType_ST(value : TFhirNoteTypeEnum);
    procedure SetText(value : TFhirString);
    function GetTextST : String;
    procedure SetTextST(value : String);
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirPaymentReconciliationProcessNote; overload;
    function Clone : TFhirPaymentReconciliationProcessNote; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // The business purpose of the note text.
    property type_ : TFhirNoteTypeEnum read GetType_ST write SetType_ST;
    property type_Element : TFhirEnum read FType_ write SetType_;

    // Typed access to The explanation or description associated with the processing.
    property text : String read GetTextST write SetTextST;
    // The explanation or description associated with the processing.
    property textElement : TFhirString read FText write SetText;

  end;

  TFhirPaymentReconciliationProcessNoteListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirPaymentReconciliationProcessNoteList;
    function GetCurrent : TFhirPaymentReconciliationProcessNote;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirPaymentReconciliationProcessNoteList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirPaymentReconciliationProcessNote read GetCurrent;
  end;

  TFhirPaymentReconciliationProcessNoteList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirPaymentReconciliationProcessNote;
    procedure SetItemN(index : Integer; value : TFhirPaymentReconciliationProcessNote);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirPaymentReconciliationProcessNoteList; overload;
    function Clone : TFhirPaymentReconciliationProcessNoteList; overload;
    function GetEnumerator : TFhirPaymentReconciliationProcessNoteListEnumerator;
    
    //  Add a FhirPaymentReconciliationProcessNote to the end of the list.
    function Append : TFhirPaymentReconciliationProcessNote;
    
    // Add an already existing FhirPaymentReconciliationProcessNote to the end of the list.
    procedure AddItem(value : TFhirPaymentReconciliationProcessNote); overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirPaymentReconciliationProcessNote) : Integer;
    
    // Insert FhirPaymentReconciliationProcessNote before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirPaymentReconciliationProcessNote;
    
    // Insert an existing FhirPaymentReconciliationProcessNote before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirPaymentReconciliationProcessNote);
    
    // Get the iIndexth FhirPaymentReconciliationProcessNote. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirPaymentReconciliationProcessNote);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirPaymentReconciliationProcessNote;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirPaymentReconciliationProcessNotes[index : Integer] : TFhirPaymentReconciliationProcessNote read GetItemN write SetItemN; default;
  End;

  // This resource provides the details including amount of a payment and allocates the payment items being paid.
  TFhirPaymentReconciliation = class (TFhirDomainResource)
  protected
    FidentifierList : TFhirIdentifierList;
    FStatus : TFhirEnum;
    FPeriod : TFhirPeriod;
    FCreated : TFhirDateTime;
    FPaymentIssuer : TFhirReference;
    FRequest : TFhirReference;
    FRequestor : TFhirReference;
    FOutcome : TFhirEnum;
    FDisposition : TFhirString;
    FPaymentDate : TFhirDate;
    FPaymentAmount : TFhirMoney;
    FPaymentIdentifier : TFhirIdentifier;
    FdetailList : TFhirPaymentReconciliationDetailList;
    FFormCode : TFhirCodeableConcept;
    FprocessNoteList : TFhirPaymentReconciliationProcessNoteList;
    function GetIdentifierList : TFhirIdentifierList;
    function GetHasIdentifierList : Boolean;
    procedure SetStatus(value : TFhirEnum);
    function GetStatusST : TFhirFinancialResourceStatusCodesEnum;
    procedure SetStatusST(value : TFhirFinancialResourceStatusCodesEnum);
    procedure SetPeriod(value : TFhirPeriod);
    procedure SetCreated(value : TFhirDateTime);
    function GetCreatedST : TFslDateTime;
    procedure SetCreatedST(value : TFslDateTime);
    procedure SetPaymentIssuer(value : TFhirReference);
    procedure SetRequest(value : TFhirReference);
    procedure SetRequestor(value : TFhirReference);
    procedure SetOutcome(value : TFhirEnum);
    function GetOutcomeST : TFhirPaymentOutcomeEnum;
    procedure SetOutcomeST(value : TFhirPaymentOutcomeEnum);
    procedure SetDisposition(value : TFhirString);
    function GetDispositionST : String;
    procedure SetDispositionST(value : String);
    procedure SetPaymentDate(value : TFhirDate);
    function GetPaymentDateST : TFslDateTime;
    procedure SetPaymentDateST(value : TFslDateTime);
    procedure SetPaymentAmount(value : TFhirMoney);
    procedure SetPaymentIdentifier(value : TFhirIdentifier);
    function GetDetailList : TFhirPaymentReconciliationDetailList;
    function GetHasDetailList : Boolean;
    procedure SetFormCode(value : TFhirCodeableConcept);
    function GetProcessNoteList : TFhirPaymentReconciliationProcessNoteList;
    function GetHasProcessNoteList : Boolean;
  
    function GetResourceType : TFhirResourceType; override;
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirPaymentReconciliation; overload;
    function Clone : TFhirPaymentReconciliation; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // A unique identifier assigned to this payment reconciliation.
    property identifierList : TFhirIdentifierList read GetIdentifierList;
    property hasIdentifierList : boolean read GetHasIdentifierList;

    // The status of the resource instance.
    property status : TFhirFinancialResourceStatusCodesEnum read GetStatusST write SetStatusST;
    property statusElement : TFhirEnum read FStatus write SetStatus;

    // Typed access to The period of time for which payments have been gathered into this bulk payment for settlement. (defined for API consistency)
    property period : TFhirPeriod read FPeriod write SetPeriod;
    // The period of time for which payments have been gathered into this bulk payment for settlement.
    property periodElement : TFhirPeriod read FPeriod write SetPeriod;

    // Typed access to The date when the resource was created.
    property created : TFslDateTime read GetCreatedST write SetCreatedST;
    // The date when the resource was created.
    property createdElement : TFhirDateTime read FCreated write SetCreated;

    // Typed access to The party who generated the payment. (defined for API consistency)
    property paymentIssuer : TFhirReference read FPaymentIssuer write SetPaymentIssuer;
    // The party who generated the payment.
    property paymentIssuerElement : TFhirReference read FPaymentIssuer write SetPaymentIssuer;

    // Typed access to Original request resource reference. (defined for API consistency)
    property request : TFhirReference read FRequest write SetRequest;
    // Original request resource reference.
    property requestElement : TFhirReference read FRequest write SetRequest;

    // Typed access to The practitioner who is responsible for the services rendered to the patient. (defined for API consistency)
    property requestor : TFhirReference read FRequestor write SetRequestor;
    // The practitioner who is responsible for the services rendered to the patient.
    property requestorElement : TFhirReference read FRequestor write SetRequestor;

    // The outcome of a request for a reconciliation.
    property outcome : TFhirPaymentOutcomeEnum read GetOutcomeST write SetOutcomeST;
    property outcomeElement : TFhirEnum read FOutcome write SetOutcome;

    // Typed access to A human readable description of the status of the request for the reconciliation.
    property disposition : String read GetDispositionST write SetDispositionST;
    // A human readable description of the status of the request for the reconciliation.
    property dispositionElement : TFhirString read FDisposition write SetDisposition;

    // Typed access to The date of payment as indicated on the financial instrument.
    property paymentDate : TFslDateTime read GetPaymentDateST write SetPaymentDateST;
    // The date of payment as indicated on the financial instrument.
    property paymentDateElement : TFhirDate read FPaymentDate write SetPaymentDate;

    // Typed access to Total payment amount as indicated on the financial instrument. (defined for API consistency)
    property paymentAmount : TFhirMoney read FPaymentAmount write SetPaymentAmount;
    // Total payment amount as indicated on the financial instrument.
    property paymentAmountElement : TFhirMoney read FPaymentAmount write SetPaymentAmount;

    // Typed access to Issuer's unique identifier for the payment instrument. (defined for API consistency)
    property paymentIdentifier : TFhirIdentifier read FPaymentIdentifier write SetPaymentIdentifier;
    // Issuer's unique identifier for the payment instrument.
    property paymentIdentifierElement : TFhirIdentifier read FPaymentIdentifier write SetPaymentIdentifier;

    // Distribution of the payment amount for a previously acknowledged payable.
    property detailList : TFhirPaymentReconciliationDetailList read GetDetailList;
    property hasDetailList : boolean read GetHasDetailList;

    // Typed access to A code for the form to be used for printing the content. (defined for API consistency)
    property formCode : TFhirCodeableConcept read FFormCode write SetFormCode;
    // A code for the form to be used for printing the content.
    property formCodeElement : TFhirCodeableConcept read FFormCode write SetFormCode;

    // A note that describes or explains the processing in a human readable form.
    property processNoteList : TFhirPaymentReconciliationProcessNoteList read GetProcessNoteList;
    property hasProcessNoteList : boolean read GetHasProcessNoteList;

  end;

  TFhirPaymentReconciliationListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirPaymentReconciliationList;
    function GetCurrent : TFhirPaymentReconciliation;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirPaymentReconciliationList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirPaymentReconciliation read GetCurrent;
  end;

  TFhirPaymentReconciliationList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirPaymentReconciliation;
    procedure SetItemN(index : Integer; value : TFhirPaymentReconciliation);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirPaymentReconciliationList; overload;
    function Clone : TFhirPaymentReconciliationList; overload;
    function GetEnumerator : TFhirPaymentReconciliationListEnumerator;
    
    //  Add a FhirPaymentReconciliation to the end of the list.
    function Append : TFhirPaymentReconciliation;
    
    // Add an already existing FhirPaymentReconciliation to the end of the list.
    procedure AddItem(value : TFhirPaymentReconciliation); overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirPaymentReconciliation) : Integer;
    
    // Insert FhirPaymentReconciliation before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirPaymentReconciliation;
    
    // Insert an existing FhirPaymentReconciliation before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirPaymentReconciliation);
    
    // Get the iIndexth FhirPaymentReconciliation. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirPaymentReconciliation);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirPaymentReconciliation;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirPaymentReconciliations[index : Integer] : TFhirPaymentReconciliation read GetItemN write SetItemN; default;
  End;

{$ENDIF FHIR_PAYMENTRECONCILIATION}



implementation

uses
  fhir5_utilities;



{$IFDEF FHIR_ACCOUNT}
{ TFhirAccountCoverage }

constructor TFhirAccountCoverage.Create;
begin
  inherited;
end;

destructor TFhirAccountCoverage.Destroy;
begin
  FCoverage.free;
  FPriority.free;
  inherited;
end;

procedure TFhirAccountCoverage.Assign(oSource : TFslObject);
begin
  inherited;
  coverage := TFhirAccountCoverage(oSource).coverage.Clone;
  priorityElement := TFhirAccountCoverage(oSource).priorityElement.Clone;
end;

procedure TFhirAccountCoverage.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'coverage') Then
     list.add(self.link, 'coverage', FCoverage.Link);
  if (child_name = 'priority') Then
     list.add(self.link, 'priority', FPriority.Link);
end;

procedure TFhirAccountCoverage.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'coverage', 'Reference', false, TFhirReference, FCoverage.Link));
  oList.add(TFHIRProperty.create(self, 'priority', 'positiveInt', false, TFhirPositiveInt, FPriority.Link));
end;

function TFhirAccountCoverage.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'coverage') then
  begin
    Coverage := propValue as TFhirReference;
    result := propValue;
  end
  else if (propName = 'priority') then
  begin
    PriorityElement := asPositiveInt(propValue);
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirAccountCoverage.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirAccountCoverage.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'coverage') then result := TFhirReference.create()
  else if (propName = 'priority') then result := TFhirPositiveInt.create()
  else result := inherited createPropertyValue(propName);
end;

function TFhirAccountCoverage.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'coverage') then result := 'Reference'
  else if (propName = 'priority') then result := 'positiveInt'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirAccountCoverage.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'coverage') then CoverageElement := nil
  else if (propName = 'priority') then PriorityElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirAccountCoverage.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'coverage') then CoverageElement := new as TFhirReference
  else if (propName = 'priority') then PriorityElement := asPositiveInt(new)
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirAccountCoverage.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirAccountCoverage.fhirType : string;
begin
  result := 'Account.coverage';
end;

function TFhirAccountCoverage.Link : TFhirAccountCoverage;
begin
  result := TFhirAccountCoverage(inherited Link);
end;

function TFhirAccountCoverage.Clone : TFhirAccountCoverage;
begin
  result := TFhirAccountCoverage(inherited Clone);
end;

function TFhirAccountCoverage.equals(other : TObject) : boolean; 
var
  o : TFhirAccountCoverage;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirAccountCoverage)) then
    result := false
  else
  begin
    o := TFhirAccountCoverage(other);
    result := compareDeep(coverageElement, o.coverageElement, true) and compareDeep(priorityElement, o.priorityElement, true);
  end;
end;

function TFhirAccountCoverage.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FCoverage) and isEmptyProp(FPriority);
end;

procedure TFhirAccountCoverage.listFieldsInOrder(fields : TStringList);
begin
  inherited listFieldsInOrder(fields);
  fields.add('coverage');
  fields.add('priority');
end;

function TFhirAccountCoverage.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
end;

procedure TFhirAccountCoverage.SetCoverage(value : TFhirReference);
begin
  FCoverage.free;
  FCoverage := value;
end;

procedure TFhirAccountCoverage.SetPriority(value : TFhirPositiveInt);
begin
  FPriority.free;
  FPriority := value;
end;

function TFhirAccountCoverage.GetPriorityST : String;
begin
  if FPriority = nil then
    result := ''
  else
    result := FPriority.value;
end;

procedure TFhirAccountCoverage.SetPriorityST(value : String);
begin
  if value <> '' then
  begin
    if FPriority = nil then
      FPriority := TFhirPositiveInt.create;
    FPriority.value := value
  end
  else if FPriority <> nil then
    FPriority.value := '';
end;

{ TFhirAccountCoverageListEnumerator }

constructor TFhirAccountCoverageListEnumerator.Create(list : TFhirAccountCoverageList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirAccountCoverageListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirAccountCoverageListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirAccountCoverageListEnumerator.GetCurrent : TFhirAccountCoverage;
begin
  Result := FList[FIndex];
end;

function TFhirAccountCoverageListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirAccountCoverageList }

procedure TFhirAccountCoverageList.AddItem(value: TFhirAccountCoverage);
begin
  assert(value.ClassName = 'TFhirAccountCoverage', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirAccountCoverage');
  add(value);
end;

function TFhirAccountCoverageList.Append: TFhirAccountCoverage;
begin
  result := TFhirAccountCoverage.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirAccountCoverageList.ClearItems;
begin
  Clear;
end;

function TFhirAccountCoverageList.GetEnumerator : TFhirAccountCoverageListEnumerator;
begin
  result := TFhirAccountCoverageListEnumerator.Create(self.link);
end;

function TFhirAccountCoverageList.Clone: TFhirAccountCoverageList;
begin
  result := TFhirAccountCoverageList(inherited Clone);
end;

function TFhirAccountCoverageList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirAccountCoverageList.GetItemN(index: Integer): TFhirAccountCoverage;
begin
  result := TFhirAccountCoverage(ObjectByIndex[index]);
end;

function TFhirAccountCoverageList.ItemClass: TFslObjectClass;
begin
  result := TFhirAccountCoverage;
end;
function TFhirAccountCoverageList.IndexOf(value: TFhirAccountCoverage): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirAccountCoverageList.Insert(index: Integer): TFhirAccountCoverage;
begin
  result := TFhirAccountCoverage.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirAccountCoverageList.InsertItem(index: Integer; value: TFhirAccountCoverage);
begin
  assert(value is TFhirAccountCoverage);
  Inherited Insert(index, value);
end;

function TFhirAccountCoverageList.Item(index: Integer): TFhirAccountCoverage;
begin
  result := TFhirAccountCoverage(ObjectByIndex[index]);
end;

function TFhirAccountCoverageList.Link: TFhirAccountCoverageList;
begin
  result := TFhirAccountCoverageList(inherited Link);
end;

procedure TFhirAccountCoverageList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirAccountCoverageList.SetItemByIndex(index: Integer; value: TFhirAccountCoverage);
begin
  assert(value is TFhirAccountCoverage);
  FhirAccountCoverages[index] := value;
end;

procedure TFhirAccountCoverageList.SetItemN(index: Integer; value: TFhirAccountCoverage);
begin
  assert(value is TFhirAccountCoverage);
  ObjectByIndex[index] := value;
end;

{ TFhirAccountGuarantor }

constructor TFhirAccountGuarantor.Create;
begin
  inherited;
end;

destructor TFhirAccountGuarantor.Destroy;
begin
  FParty.free;
  FOnHold.free;
  FPeriod.free;
  inherited;
end;

procedure TFhirAccountGuarantor.Assign(oSource : TFslObject);
begin
  inherited;
  party := TFhirAccountGuarantor(oSource).party.Clone;
  onHoldElement := TFhirAccountGuarantor(oSource).onHoldElement.Clone;
  period := TFhirAccountGuarantor(oSource).period.Clone;
end;

procedure TFhirAccountGuarantor.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'party') Then
     list.add(self.link, 'party', FParty.Link);
  if (child_name = 'onHold') Then
     list.add(self.link, 'onHold', FOnHold.Link);
  if (child_name = 'period') Then
     list.add(self.link, 'period', FPeriod.Link);
end;

procedure TFhirAccountGuarantor.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'party', 'Reference', false, TFhirReference, FParty.Link));
  oList.add(TFHIRProperty.create(self, 'onHold', 'boolean', false, TFhirBoolean, FOnHold.Link));
  oList.add(TFHIRProperty.create(self, 'period', 'Period', false, TFhirPeriod, FPeriod.Link));
end;

function TFhirAccountGuarantor.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'party') then
  begin
    Party := propValue as TFhirReference;
    result := propValue;
  end
  else if (propName = 'onHold') then
  begin
    OnHoldElement := asBoolean(propValue);
    result := propValue;
  end
  else if (propName = 'period') then
  begin
    Period := propValue as TFhirPeriod;
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirAccountGuarantor.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirAccountGuarantor.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'party') then result := TFhirReference.create()
  else if (propName = 'onHold') then result := TFhirBoolean.create()
  else if (propName = 'period') then result := TFhirPeriod.create()
  else result := inherited createPropertyValue(propName);
end;

function TFhirAccountGuarantor.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'party') then result := 'Reference'
  else if (propName = 'onHold') then result := 'boolean'
  else if (propName = 'period') then result := 'Period'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirAccountGuarantor.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'party') then PartyElement := nil
  else if (propName = 'onHold') then OnHoldElement := nil
  else if (propName = 'period') then PeriodElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirAccountGuarantor.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'party') then PartyElement := new as TFhirReference
  else if (propName = 'onHold') then OnHoldElement := asBoolean(new)
  else if (propName = 'period') then PeriodElement := new as TFhirPeriod
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirAccountGuarantor.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirAccountGuarantor.fhirType : string;
begin
  result := 'Account.guarantor';
end;

function TFhirAccountGuarantor.Link : TFhirAccountGuarantor;
begin
  result := TFhirAccountGuarantor(inherited Link);
end;

function TFhirAccountGuarantor.Clone : TFhirAccountGuarantor;
begin
  result := TFhirAccountGuarantor(inherited Clone);
end;

function TFhirAccountGuarantor.equals(other : TObject) : boolean; 
var
  o : TFhirAccountGuarantor;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirAccountGuarantor)) then
    result := false
  else
  begin
    o := TFhirAccountGuarantor(other);
    result := compareDeep(partyElement, o.partyElement, true) and compareDeep(onHoldElement, o.onHoldElement, true) and 
      compareDeep(periodElement, o.periodElement, true);
  end;
end;

function TFhirAccountGuarantor.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FParty) and isEmptyProp(FOnHold) and isEmptyProp(FPeriod);
end;

procedure TFhirAccountGuarantor.listFieldsInOrder(fields : TStringList);
begin
  inherited listFieldsInOrder(fields);
  fields.add('party');
  fields.add('onHold');
  fields.add('period');
end;

function TFhirAccountGuarantor.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
end;

procedure TFhirAccountGuarantor.SetParty(value : TFhirReference);
begin
  FParty.free;
  FParty := value;
end;

procedure TFhirAccountGuarantor.SetOnHold(value : TFhirBoolean);
begin
  FOnHold.free;
  FOnHold := value;
end;

function TFhirAccountGuarantor.GetOnHoldST : Boolean;
begin
  if FOnHold = nil then
    result := false
  else
    result := FOnHold.value;
end;

procedure TFhirAccountGuarantor.SetOnHoldST(value : Boolean);
begin
  if FOnHold = nil then
    FOnHold := TFhirBoolean.create;
  FOnHold.value := value
end;

procedure TFhirAccountGuarantor.SetPeriod(value : TFhirPeriod);
begin
  FPeriod.free;
  FPeriod := value;
end;

{ TFhirAccountGuarantorListEnumerator }

constructor TFhirAccountGuarantorListEnumerator.Create(list : TFhirAccountGuarantorList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirAccountGuarantorListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirAccountGuarantorListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirAccountGuarantorListEnumerator.GetCurrent : TFhirAccountGuarantor;
begin
  Result := FList[FIndex];
end;

function TFhirAccountGuarantorListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirAccountGuarantorList }

procedure TFhirAccountGuarantorList.AddItem(value: TFhirAccountGuarantor);
begin
  assert(value.ClassName = 'TFhirAccountGuarantor', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirAccountGuarantor');
  add(value);
end;

function TFhirAccountGuarantorList.Append: TFhirAccountGuarantor;
begin
  result := TFhirAccountGuarantor.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirAccountGuarantorList.ClearItems;
begin
  Clear;
end;

function TFhirAccountGuarantorList.GetEnumerator : TFhirAccountGuarantorListEnumerator;
begin
  result := TFhirAccountGuarantorListEnumerator.Create(self.link);
end;

function TFhirAccountGuarantorList.Clone: TFhirAccountGuarantorList;
begin
  result := TFhirAccountGuarantorList(inherited Clone);
end;

function TFhirAccountGuarantorList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirAccountGuarantorList.GetItemN(index: Integer): TFhirAccountGuarantor;
begin
  result := TFhirAccountGuarantor(ObjectByIndex[index]);
end;

function TFhirAccountGuarantorList.ItemClass: TFslObjectClass;
begin
  result := TFhirAccountGuarantor;
end;
function TFhirAccountGuarantorList.IndexOf(value: TFhirAccountGuarantor): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirAccountGuarantorList.Insert(index: Integer): TFhirAccountGuarantor;
begin
  result := TFhirAccountGuarantor.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirAccountGuarantorList.InsertItem(index: Integer; value: TFhirAccountGuarantor);
begin
  assert(value is TFhirAccountGuarantor);
  Inherited Insert(index, value);
end;

function TFhirAccountGuarantorList.Item(index: Integer): TFhirAccountGuarantor;
begin
  result := TFhirAccountGuarantor(ObjectByIndex[index]);
end;

function TFhirAccountGuarantorList.Link: TFhirAccountGuarantorList;
begin
  result := TFhirAccountGuarantorList(inherited Link);
end;

procedure TFhirAccountGuarantorList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirAccountGuarantorList.SetItemByIndex(index: Integer; value: TFhirAccountGuarantor);
begin
  assert(value is TFhirAccountGuarantor);
  FhirAccountGuarantors[index] := value;
end;

procedure TFhirAccountGuarantorList.SetItemN(index: Integer; value: TFhirAccountGuarantor);
begin
  assert(value is TFhirAccountGuarantor);
  ObjectByIndex[index] := value;
end;

{ TFhirAccount }

constructor TFhirAccount.Create;
begin
  inherited;
end;

destructor TFhirAccount.Destroy;
begin
  FIdentifierList.Free;
  FStatus.free;
  FType_.free;
  FName.free;
  FSubjectList.Free;
  FServicePeriod.free;
  FCoverageList.Free;
  FOwner.free;
  FDescription.free;
  FGuarantorList.Free;
  FPartOf.free;
  inherited;
end;

procedure TFhirAccount.Assign(oSource : TFslObject);
begin
  inherited;
  if (TFhirAccount(oSource).FIdentifierList = nil) then
  begin
    FIdentifierList.free;
    FIdentifierList := nil;
  end
  else
  begin
    if FIdentifierList = nil then
      FIdentifierList := TFhirIdentifierList.Create;
    FIdentifierList.Assign(TFhirAccount(oSource).FIdentifierList);
  end;
  statusElement := TFhirAccount(oSource).statusElement.Clone;
  type_ := TFhirAccount(oSource).type_.Clone;
  nameElement := TFhirAccount(oSource).nameElement.Clone;
  if (TFhirAccount(oSource).FSubjectList = nil) then
  begin
    FSubjectList.free;
    FSubjectList := nil;
  end
  else
  begin
    if FSubjectList = nil then
      FSubjectList := TFhirReferenceList.Create;
    FSubjectList.Assign(TFhirAccount(oSource).FSubjectList);
  end;
  servicePeriod := TFhirAccount(oSource).servicePeriod.Clone;
  if (TFhirAccount(oSource).FCoverageList = nil) then
  begin
    FCoverageList.free;
    FCoverageList := nil;
  end
  else
  begin
    if FCoverageList = nil then
      FCoverageList := TFhirAccountCoverageList.Create;
    FCoverageList.Assign(TFhirAccount(oSource).FCoverageList);
  end;
  owner := TFhirAccount(oSource).owner.Clone;
  descriptionElement := TFhirAccount(oSource).descriptionElement.Clone;
  if (TFhirAccount(oSource).FGuarantorList = nil) then
  begin
    FGuarantorList.free;
    FGuarantorList := nil;
  end
  else
  begin
    if FGuarantorList = nil then
      FGuarantorList := TFhirAccountGuarantorList.Create;
    FGuarantorList.Assign(TFhirAccount(oSource).FGuarantorList);
  end;
  partOf := TFhirAccount(oSource).partOf.Clone;
end;

function TFhirAccount.GetResourceType : TFhirResourceType;
begin
  result := frtAccount;
end;

procedure TFhirAccount.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'identifier') Then
    list.addAll(self, 'identifier', FIdentifierList);
  if (child_name = 'status') Then
     list.add(self.link, 'status', FStatus.Link);
  if (child_name = 'type') Then
     list.add(self.link, 'type', FType_.Link);
  if (child_name = 'name') Then
     list.add(self.link, 'name', FName.Link);
  if (child_name = 'subject') Then
    list.addAll(self, 'subject', FSubjectList);
  if (child_name = 'servicePeriod') Then
     list.add(self.link, 'servicePeriod', FServicePeriod.Link);
  if (child_name = 'coverage') Then
    list.addAll(self, 'coverage', FCoverageList);
  if (child_name = 'owner') Then
     list.add(self.link, 'owner', FOwner.Link);
  if (child_name = 'description') Then
     list.add(self.link, 'description', FDescription.Link);
  if (child_name = 'guarantor') Then
    list.addAll(self, 'guarantor', FGuarantorList);
  if (child_name = 'partOf') Then
     list.add(self.link, 'partOf', FPartOf.Link);
end;

procedure TFhirAccount.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'identifier', 'Identifier', true, TFhirIdentifier, FIdentifierList.Link));
  oList.add(TFHIRProperty.create(self, 'status', 'code', false, TFhirEnum, FStatus.Link));
  oList.add(TFHIRProperty.create(self, 'type', 'CodeableConcept', false, TFhirCodeableConcept, FType_.Link));
  oList.add(TFHIRProperty.create(self, 'name', 'string', false, TFhirString, FName.Link));
  oList.add(TFHIRProperty.create(self, 'subject', 'Reference', true, TFhirReference, FSubjectList.Link));
  oList.add(TFHIRProperty.create(self, 'servicePeriod', 'Period', false, TFhirPeriod, FServicePeriod.Link));
  oList.add(TFHIRProperty.create(self, 'coverage', 'BackboneElement', true, TFhirAccountCoverage, FCoverageList.Link));
  oList.add(TFHIRProperty.create(self, 'owner', 'Reference', false, TFhirReference, FOwner.Link));
  oList.add(TFHIRProperty.create(self, 'description', 'string', false, TFhirString, FDescription.Link));
  oList.add(TFHIRProperty.create(self, 'guarantor', 'BackboneElement', true, TFhirAccountGuarantor, FGuarantorList.Link));
  oList.add(TFHIRProperty.create(self, 'partOf', 'Reference', false, TFhirReference, FPartOf.Link));
end;

function TFhirAccount.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'identifier') then
  begin
    IdentifierList.add(propValue as TFhirIdentifier);
    result := propValue;
  end
  else if (propName = 'status') then
  begin
    StatusElement := asEnum(SYSTEMS_TFhirAccountStatusEnum, CODES_TFhirAccountStatusEnum, propValue);
    result := propValue;
  end
  else if (propName = 'type') then
  begin
    Type_ := propValue as TFhirCodeableConcept;
    result := propValue;
  end
  else if (propName = 'name') then
  begin
    NameElement := asString(propValue);
    result := propValue;
  end
  else if (propName = 'subject') then
  begin
    SubjectList.add(propValue as TFhirReference);
    result := propValue;
  end
  else if (propName = 'servicePeriod') then
  begin
    ServicePeriod := propValue as TFhirPeriod;
    result := propValue;
  end
  else if (propName = 'coverage') then
  begin
    CoverageList.add(propValue as TFhirAccountCoverage);
    result := propValue;
  end
  else if (propName = 'owner') then
  begin
    Owner := propValue as TFhirReference;
    result := propValue;
  end
  else if (propName = 'description') then
  begin
    DescriptionElement := asString(propValue);
    result := propValue;
  end
  else if (propName = 'guarantor') then
  begin
    GuarantorList.add(propValue as TFhirAccountGuarantor);
    result := propValue;
  end
  else if (propName = 'partOf') then
  begin
    PartOf := propValue as TFhirReference;
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirAccount.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'identifier') then IdentifierList.insertItem(index, propValue as TFhirIdentifier)
  else if (propName = 'subject') then SubjectList.insertItem(index, propValue as TFhirReference)
  else if (propName = 'coverage') then CoverageList.insertItem(index, propValue as TFhirAccountCoverage)
  else if (propName = 'guarantor') then GuarantorList.insertItem(index, propValue as TFhirAccountGuarantor)
  else inherited;
end;

function TFhirAccount.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'identifier') then result := IdentifierList.new()
  else if (propName = 'status') then result := TFhirEnum.create(SYSTEMS_TFhirAccountStatusEnum[AccountStatusNull], CODES_TFhirAccountStatusEnum[AccountStatusNull]) 
  else if (propName = 'type') then result := TFhirCodeableConcept.create()
  else if (propName = 'name') then result := TFhirString.create()
  else if (propName = 'subject') then result := SubjectList.new()
  else if (propName = 'servicePeriod') then result := TFhirPeriod.create()
  else if (propName = 'coverage') then result := CoverageList.new()
  else if (propName = 'owner') then result := TFhirReference.create()
  else if (propName = 'description') then result := TFhirString.create()
  else if (propName = 'guarantor') then result := GuarantorList.new()
  else if (propName = 'partOf') then result := TFhirReference.create()
  else result := inherited createPropertyValue(propName);
end;

function TFhirAccount.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'identifier') then result := 'Identifier'
  else if (propName = 'status') then result := 'code'
  else if (propName = 'type') then result := 'CodeableConcept'
  else if (propName = 'name') then result := 'string'
  else if (propName = 'subject') then result := 'Reference'
  else if (propName = 'servicePeriod') then result := 'Period'
  else if (propName = 'coverage') then result := 'BackboneElement'
  else if (propName = 'owner') then result := 'Reference'
  else if (propName = 'description') then result := 'string'
  else if (propName = 'guarantor') then result := 'BackboneElement'
  else if (propName = 'partOf') then result := 'Reference'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirAccount.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'identifier') then deletePropertyValue('identifier', IdentifierList, value)
  else if (propName = 'status') then StatusElement := nil
  else if (propName = 'type') then Type_Element := nil
  else if (propName = 'name') then NameElement := nil
  else if (propName = 'subject') then deletePropertyValue('subject', SubjectList, value)
  else if (propName = 'servicePeriod') then ServicePeriodElement := nil
  else if (propName = 'coverage') then deletePropertyValue('coverage', CoverageList, value)
  else if (propName = 'owner') then OwnerElement := nil
  else if (propName = 'description') then DescriptionElement := nil
  else if (propName = 'guarantor') then deletePropertyValue('guarantor', GuarantorList, value)
  else if (propName = 'partOf') then PartOfElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirAccount.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'identifier') then replacePropertyValue('identifier', IdentifierList, existing, new)
  else if (propName = 'status') then StatusElement := asEnum(SYSTEMS_TFhirAccountStatusEnum, CODES_TFhirAccountStatusEnum, new)
  else if (propName = 'type') then Type_Element := new as TFhirCodeableConcept
  else if (propName = 'name') then NameElement := asString(new)
  else if (propName = 'subject') then replacePropertyValue('subject', SubjectList, existing, new)
  else if (propName = 'servicePeriod') then ServicePeriodElement := new as TFhirPeriod
  else if (propName = 'coverage') then replacePropertyValue('coverage', CoverageList, existing, new)
  else if (propName = 'owner') then OwnerElement := new as TFhirReference
  else if (propName = 'description') then DescriptionElement := asString(new)
  else if (propName = 'guarantor') then replacePropertyValue('guarantor', GuarantorList, existing, new)
  else if (propName = 'partOf') then PartOfElement := new as TFhirReference
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirAccount.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'identifier') then IdentifierList.move(source, destination)
  else if (propName = 'subject') then SubjectList.move(source, destination)
  else if (propName = 'coverage') then CoverageList.move(source, destination)
  else if (propName = 'guarantor') then GuarantorList.move(source, destination)
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirAccount.fhirType : string;
begin
  result := 'Account';
end;

function TFhirAccount.Link : TFhirAccount;
begin
  result := TFhirAccount(inherited Link);
end;

function TFhirAccount.Clone : TFhirAccount;
begin
  result := TFhirAccount(inherited Clone);
end;

function TFhirAccount.equals(other : TObject) : boolean; 
var
  o : TFhirAccount;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirAccount)) then
    result := false
  else
  begin
    o := TFhirAccount(other);
    result := compareDeep(identifierList, o.identifierList, true) and compareDeep(statusElement, o.statusElement, true) and 
      compareDeep(type_Element, o.type_Element, true) and compareDeep(nameElement, o.nameElement, true) and 
      compareDeep(subjectList, o.subjectList, true) and compareDeep(servicePeriodElement, o.servicePeriodElement, true) and 
      compareDeep(coverageList, o.coverageList, true) and compareDeep(ownerElement, o.ownerElement, true) and 
      compareDeep(descriptionElement, o.descriptionElement, true) and compareDeep(guarantorList, o.guarantorList, true) and 
      compareDeep(partOfElement, o.partOfElement, true);
  end;
end;

function TFhirAccount.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FidentifierList) and isEmptyProp(FStatus) and isEmptyProp(FType_) and isEmptyProp(FName) and isEmptyProp(FsubjectList) and isEmptyProp(FServicePeriod) and isEmptyProp(FcoverageList) and isEmptyProp(FOwner) and isEmptyProp(FDescription) and isEmptyProp(FguarantorList) and isEmptyProp(FPartOf);
end;

procedure TFhirAccount.listFieldsInOrder(fields : TStringList);
begin
  inherited listFieldsInOrder(fields);
  fields.add('identifier');
  fields.add('status');
  fields.add('type');
  fields.add('name');
  fields.add('subject');
  fields.add('servicePeriod');
  fields.add('coverage');
  fields.add('owner');
  fields.add('description');
  fields.add('guarantor');
  fields.add('partOf');
end;

function TFhirAccount.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FIdentifierList.sizeInBytes(magic));
  inc(result, FSubjectList.sizeInBytes(magic));
  inc(result, FCoverageList.sizeInBytes(magic));
  inc(result, FGuarantorList.sizeInBytes(magic));
end;

function TFhirAccount.GetIdentifierList : TFhirIdentifierList;
begin
  if FIdentifierList = nil then
    FIdentifierList := TFhirIdentifierList.Create;
  result := FIdentifierList;
end;

function TFhirAccount.GetHasIdentifierList : boolean;
begin
  result := (FIdentifierList <> nil) and (FIdentifierList.count > 0);
end;

procedure TFhirAccount.SetStatus(value : TFhirEnum);
begin
  FStatus.free;
  FStatus := value;
end;

function TFhirAccount.GetStatusST : TFhirAccountStatusEnum;
begin
  if FStatus = nil then
    result := TFhirAccountStatusEnum(0)
  else
    result := TFhirAccountStatusEnum(StringArrayIndexOfSensitive(CODES_TFhirAccountStatusEnum, FStatus.value));
end;

procedure TFhirAccount.SetStatusST(value : TFhirAccountStatusEnum);
begin
  if ord(value) = 0 then
    StatusElement := nil
  else
    StatusElement := TFhirEnum.create(SYSTEMS_TFhirAccountStatusEnum[value], CODES_TFhirAccountStatusEnum[value]);
end;

procedure TFhirAccount.SetType_(value : TFhirCodeableConcept);
begin
  FType_.free;
  FType_ := value;
end;

procedure TFhirAccount.SetName(value : TFhirString);
begin
  FName.free;
  FName := value;
end;

function TFhirAccount.GetNameST : String;
begin
  if FName = nil then
    result := ''
  else
    result := FName.value;
end;

procedure TFhirAccount.SetNameST(value : String);
begin
  if value <> '' then
  begin
    if FName = nil then
      FName := TFhirString.create;
    FName.value := value
  end
  else if FName <> nil then
    FName.value := '';
end;

function TFhirAccount.GetSubjectList : TFhirReferenceList;
begin
  if FSubjectList = nil then
    FSubjectList := TFhirReferenceList.Create;
  result := FSubjectList;
end;

function TFhirAccount.GetHasSubjectList : boolean;
begin
  result := (FSubjectList <> nil) and (FSubjectList.count > 0);
end;

procedure TFhirAccount.SetServicePeriod(value : TFhirPeriod);
begin
  FServicePeriod.free;
  FServicePeriod := value;
end;

function TFhirAccount.GetCoverageList : TFhirAccountCoverageList;
begin
  if FCoverageList = nil then
    FCoverageList := TFhirAccountCoverageList.Create;
  result := FCoverageList;
end;

function TFhirAccount.GetHasCoverageList : boolean;
begin
  result := (FCoverageList <> nil) and (FCoverageList.count > 0);
end;

procedure TFhirAccount.SetOwner(value : TFhirReference);
begin
  FOwner.free;
  FOwner := value;
end;

procedure TFhirAccount.SetDescription(value : TFhirString);
begin
  FDescription.free;
  FDescription := value;
end;

function TFhirAccount.GetDescriptionST : String;
begin
  if FDescription = nil then
    result := ''
  else
    result := FDescription.value;
end;

procedure TFhirAccount.SetDescriptionST(value : String);
begin
  if value <> '' then
  begin
    if FDescription = nil then
      FDescription := TFhirString.create;
    FDescription.value := value
  end
  else if FDescription <> nil then
    FDescription.value := '';
end;

function TFhirAccount.GetGuarantorList : TFhirAccountGuarantorList;
begin
  if FGuarantorList = nil then
    FGuarantorList := TFhirAccountGuarantorList.Create;
  result := FGuarantorList;
end;

function TFhirAccount.GetHasGuarantorList : boolean;
begin
  result := (FGuarantorList <> nil) and (FGuarantorList.count > 0);
end;

procedure TFhirAccount.SetPartOf(value : TFhirReference);
begin
  FPartOf.free;
  FPartOf := value;
end;

{ TFhirAccountListEnumerator }

constructor TFhirAccountListEnumerator.Create(list : TFhirAccountList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirAccountListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirAccountListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirAccountListEnumerator.GetCurrent : TFhirAccount;
begin
  Result := FList[FIndex];
end;

function TFhirAccountListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirAccountList }

procedure TFhirAccountList.AddItem(value: TFhirAccount);
begin
  assert(value.ClassName = 'TFhirAccount', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirAccount');
  add(value);
end;

function TFhirAccountList.Append: TFhirAccount;
begin
  result := TFhirAccount.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirAccountList.ClearItems;
begin
  Clear;
end;

function TFhirAccountList.GetEnumerator : TFhirAccountListEnumerator;
begin
  result := TFhirAccountListEnumerator.Create(self.link);
end;

function TFhirAccountList.Clone: TFhirAccountList;
begin
  result := TFhirAccountList(inherited Clone);
end;

function TFhirAccountList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirAccountList.GetItemN(index: Integer): TFhirAccount;
begin
  result := TFhirAccount(ObjectByIndex[index]);
end;

function TFhirAccountList.ItemClass: TFslObjectClass;
begin
  result := TFhirAccount;
end;
function TFhirAccountList.IndexOf(value: TFhirAccount): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirAccountList.Insert(index: Integer): TFhirAccount;
begin
  result := TFhirAccount.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirAccountList.InsertItem(index: Integer; value: TFhirAccount);
begin
  assert(value is TFhirAccount);
  Inherited Insert(index, value);
end;

function TFhirAccountList.Item(index: Integer): TFhirAccount;
begin
  result := TFhirAccount(ObjectByIndex[index]);
end;

function TFhirAccountList.Link: TFhirAccountList;
begin
  result := TFhirAccountList(inherited Link);
end;

procedure TFhirAccountList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirAccountList.SetItemByIndex(index: Integer; value: TFhirAccount);
begin
  assert(value is TFhirAccount);
  FhirAccounts[index] := value;
end;

procedure TFhirAccountList.SetItemN(index: Integer; value: TFhirAccount);
begin
  assert(value is TFhirAccount);
  ObjectByIndex[index] := value;
end;

{$ENDIF FHIR_ACCOUNT}
{$IFDEF FHIR_CHARGEITEM}
{ TFhirChargeItemPerformer }

constructor TFhirChargeItemPerformer.Create;
begin
  inherited;
end;

destructor TFhirChargeItemPerformer.Destroy;
begin
  FFunction_.free;
  FActor.free;
  inherited;
end;

procedure TFhirChargeItemPerformer.Assign(oSource : TFslObject);
begin
  inherited;
  function_ := TFhirChargeItemPerformer(oSource).function_.Clone;
  actor := TFhirChargeItemPerformer(oSource).actor.Clone;
end;

procedure TFhirChargeItemPerformer.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'function') Then
     list.add(self.link, 'function', FFunction_.Link);
  if (child_name = 'actor') Then
     list.add(self.link, 'actor', FActor.Link);
end;

procedure TFhirChargeItemPerformer.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'function', 'CodeableConcept', false, TFhirCodeableConcept, FFunction_.Link));
  oList.add(TFHIRProperty.create(self, 'actor', 'Reference', false, TFhirReference, FActor.Link));
end;

function TFhirChargeItemPerformer.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'function') then
  begin
    Function_ := propValue as TFhirCodeableConcept;
    result := propValue;
  end
  else if (propName = 'actor') then
  begin
    Actor := propValue as TFhirReference;
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirChargeItemPerformer.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirChargeItemPerformer.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'function') then result := TFhirCodeableConcept.create()
  else if (propName = 'actor') then result := TFhirReference.create()
  else result := inherited createPropertyValue(propName);
end;

function TFhirChargeItemPerformer.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'function') then result := 'CodeableConcept'
  else if (propName = 'actor') then result := 'Reference'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirChargeItemPerformer.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'function') then Function_Element := nil
  else if (propName = 'actor') then ActorElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirChargeItemPerformer.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'function') then Function_Element := new as TFhirCodeableConcept
  else if (propName = 'actor') then ActorElement := new as TFhirReference
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirChargeItemPerformer.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirChargeItemPerformer.fhirType : string;
begin
  result := 'ChargeItem.performer';
end;

function TFhirChargeItemPerformer.Link : TFhirChargeItemPerformer;
begin
  result := TFhirChargeItemPerformer(inherited Link);
end;

function TFhirChargeItemPerformer.Clone : TFhirChargeItemPerformer;
begin
  result := TFhirChargeItemPerformer(inherited Clone);
end;

function TFhirChargeItemPerformer.equals(other : TObject) : boolean; 
var
  o : TFhirChargeItemPerformer;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirChargeItemPerformer)) then
    result := false
  else
  begin
    o := TFhirChargeItemPerformer(other);
    result := compareDeep(function_Element, o.function_Element, true) and compareDeep(actorElement, o.actorElement, true);
  end;
end;

function TFhirChargeItemPerformer.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FFunction_) and isEmptyProp(FActor);
end;

procedure TFhirChargeItemPerformer.listFieldsInOrder(fields : TStringList);
begin
  inherited listFieldsInOrder(fields);
  fields.add('function');
  fields.add('actor');
end;

function TFhirChargeItemPerformer.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
end;

procedure TFhirChargeItemPerformer.SetFunction_(value : TFhirCodeableConcept);
begin
  FFunction_.free;
  FFunction_ := value;
end;

procedure TFhirChargeItemPerformer.SetActor(value : TFhirReference);
begin
  FActor.free;
  FActor := value;
end;

{ TFhirChargeItemPerformerListEnumerator }

constructor TFhirChargeItemPerformerListEnumerator.Create(list : TFhirChargeItemPerformerList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirChargeItemPerformerListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirChargeItemPerformerListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirChargeItemPerformerListEnumerator.GetCurrent : TFhirChargeItemPerformer;
begin
  Result := FList[FIndex];
end;

function TFhirChargeItemPerformerListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirChargeItemPerformerList }

procedure TFhirChargeItemPerformerList.AddItem(value: TFhirChargeItemPerformer);
begin
  assert(value.ClassName = 'TFhirChargeItemPerformer', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirChargeItemPerformer');
  add(value);
end;

function TFhirChargeItemPerformerList.Append: TFhirChargeItemPerformer;
begin
  result := TFhirChargeItemPerformer.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirChargeItemPerformerList.ClearItems;
begin
  Clear;
end;

function TFhirChargeItemPerformerList.GetEnumerator : TFhirChargeItemPerformerListEnumerator;
begin
  result := TFhirChargeItemPerformerListEnumerator.Create(self.link);
end;

function TFhirChargeItemPerformerList.Clone: TFhirChargeItemPerformerList;
begin
  result := TFhirChargeItemPerformerList(inherited Clone);
end;

function TFhirChargeItemPerformerList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirChargeItemPerformerList.GetItemN(index: Integer): TFhirChargeItemPerformer;
begin
  result := TFhirChargeItemPerformer(ObjectByIndex[index]);
end;

function TFhirChargeItemPerformerList.ItemClass: TFslObjectClass;
begin
  result := TFhirChargeItemPerformer;
end;
function TFhirChargeItemPerformerList.IndexOf(value: TFhirChargeItemPerformer): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirChargeItemPerformerList.Insert(index: Integer): TFhirChargeItemPerformer;
begin
  result := TFhirChargeItemPerformer.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirChargeItemPerformerList.InsertItem(index: Integer; value: TFhirChargeItemPerformer);
begin
  assert(value is TFhirChargeItemPerformer);
  Inherited Insert(index, value);
end;

function TFhirChargeItemPerformerList.Item(index: Integer): TFhirChargeItemPerformer;
begin
  result := TFhirChargeItemPerformer(ObjectByIndex[index]);
end;

function TFhirChargeItemPerformerList.Link: TFhirChargeItemPerformerList;
begin
  result := TFhirChargeItemPerformerList(inherited Link);
end;

procedure TFhirChargeItemPerformerList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirChargeItemPerformerList.SetItemByIndex(index: Integer; value: TFhirChargeItemPerformer);
begin
  assert(value is TFhirChargeItemPerformer);
  FhirChargeItemPerformers[index] := value;
end;

procedure TFhirChargeItemPerformerList.SetItemN(index: Integer; value: TFhirChargeItemPerformer);
begin
  assert(value is TFhirChargeItemPerformer);
  ObjectByIndex[index] := value;
end;

{ TFhirChargeItem }

constructor TFhirChargeItem.Create;
begin
  inherited;
end;

destructor TFhirChargeItem.Destroy;
begin
  FIdentifierList.Free;
  FDefinitionUriList.Free;
  FDefinitionCanonicalList.Free;
  FStatus.free;
  FPartOfList.Free;
  FCode.free;
  FSubject.free;
  FContext.free;
  FOccurrence.free;
  FPerformerList.Free;
  FPerformingOrganization.free;
  FRequestingOrganization.free;
  FCostCenter.free;
  FQuantity.free;
  FBodysiteList.Free;
  FFactorOverride.free;
  FPriceOverride.free;
  FOverrideReason.free;
  FEnterer.free;
  FEnteredDate.free;
  FReasonList.Free;
  FServiceList.Free;
  FProduct.free;
  FAccountList.Free;
  FNoteList.Free;
  FSupportingInformationList.Free;
  inherited;
end;

procedure TFhirChargeItem.Assign(oSource : TFslObject);
begin
  inherited;
  if (TFhirChargeItem(oSource).FIdentifierList = nil) then
  begin
    FIdentifierList.free;
    FIdentifierList := nil;
  end
  else
  begin
    if FIdentifierList = nil then
      FIdentifierList := TFhirIdentifierList.Create;
    FIdentifierList.Assign(TFhirChargeItem(oSource).FIdentifierList);
  end;
  if (TFhirChargeItem(oSource).FDefinitionUriList = nil) then
  begin
    FDefinitionUriList.free;
    FDefinitionUriList := nil;
  end
  else
  begin
    if FDefinitionUriList = nil then
      FDefinitionUriList := TFhirUriList.Create;
    FDefinitionUriList.Assign(TFhirChargeItem(oSource).FDefinitionUriList);
  end;
  if (TFhirChargeItem(oSource).FDefinitionCanonicalList = nil) then
  begin
    FDefinitionCanonicalList.free;
    FDefinitionCanonicalList := nil;
  end
  else
  begin
    if FDefinitionCanonicalList = nil then
      FDefinitionCanonicalList := TFhirCanonicalList.Create;
    FDefinitionCanonicalList.Assign(TFhirChargeItem(oSource).FDefinitionCanonicalList);
  end;
  statusElement := TFhirChargeItem(oSource).statusElement.Clone;
  if (TFhirChargeItem(oSource).FPartOfList = nil) then
  begin
    FPartOfList.free;
    FPartOfList := nil;
  end
  else
  begin
    if FPartOfList = nil then
      FPartOfList := TFhirReferenceList.Create;
    FPartOfList.Assign(TFhirChargeItem(oSource).FPartOfList);
  end;
  code := TFhirChargeItem(oSource).code.Clone;
  subject := TFhirChargeItem(oSource).subject.Clone;
  context := TFhirChargeItem(oSource).context.Clone;
  occurrence := TFhirChargeItem(oSource).occurrence.Clone;
  if (TFhirChargeItem(oSource).FPerformerList = nil) then
  begin
    FPerformerList.free;
    FPerformerList := nil;
  end
  else
  begin
    if FPerformerList = nil then
      FPerformerList := TFhirChargeItemPerformerList.Create;
    FPerformerList.Assign(TFhirChargeItem(oSource).FPerformerList);
  end;
  performingOrganization := TFhirChargeItem(oSource).performingOrganization.Clone;
  requestingOrganization := TFhirChargeItem(oSource).requestingOrganization.Clone;
  costCenter := TFhirChargeItem(oSource).costCenter.Clone;
  quantity := TFhirChargeItem(oSource).quantity.Clone;
  if (TFhirChargeItem(oSource).FBodysiteList = nil) then
  begin
    FBodysiteList.free;
    FBodysiteList := nil;
  end
  else
  begin
    if FBodysiteList = nil then
      FBodysiteList := TFhirCodeableConceptList.Create;
    FBodysiteList.Assign(TFhirChargeItem(oSource).FBodysiteList);
  end;
  factorOverrideElement := TFhirChargeItem(oSource).factorOverrideElement.Clone;
  priceOverride := TFhirChargeItem(oSource).priceOverride.Clone;
  overrideReasonElement := TFhirChargeItem(oSource).overrideReasonElement.Clone;
  enterer := TFhirChargeItem(oSource).enterer.Clone;
  enteredDateElement := TFhirChargeItem(oSource).enteredDateElement.Clone;
  if (TFhirChargeItem(oSource).FReasonList = nil) then
  begin
    FReasonList.free;
    FReasonList := nil;
  end
  else
  begin
    if FReasonList = nil then
      FReasonList := TFhirCodeableConceptList.Create;
    FReasonList.Assign(TFhirChargeItem(oSource).FReasonList);
  end;
  if (TFhirChargeItem(oSource).FServiceList = nil) then
  begin
    FServiceList.free;
    FServiceList := nil;
  end
  else
  begin
    if FServiceList = nil then
      FServiceList := TFhirReferenceList.Create;
    FServiceList.Assign(TFhirChargeItem(oSource).FServiceList);
  end;
  product := TFhirChargeItem(oSource).product.Clone;
  if (TFhirChargeItem(oSource).FAccountList = nil) then
  begin
    FAccountList.free;
    FAccountList := nil;
  end
  else
  begin
    if FAccountList = nil then
      FAccountList := TFhirReferenceList.Create;
    FAccountList.Assign(TFhirChargeItem(oSource).FAccountList);
  end;
  if (TFhirChargeItem(oSource).FNoteList = nil) then
  begin
    FNoteList.free;
    FNoteList := nil;
  end
  else
  begin
    if FNoteList = nil then
      FNoteList := TFhirAnnotationList.Create;
    FNoteList.Assign(TFhirChargeItem(oSource).FNoteList);
  end;
  if (TFhirChargeItem(oSource).FSupportingInformationList = nil) then
  begin
    FSupportingInformationList.free;
    FSupportingInformationList := nil;
  end
  else
  begin
    if FSupportingInformationList = nil then
      FSupportingInformationList := TFhirReferenceList.Create;
    FSupportingInformationList.Assign(TFhirChargeItem(oSource).FSupportingInformationList);
  end;
end;

function TFhirChargeItem.GetResourceType : TFhirResourceType;
begin
  result := frtChargeItem;
end;

procedure TFhirChargeItem.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'identifier') Then
    list.addAll(self, 'identifier', FIdentifierList);
  if (child_name = 'definitionUri') Then
    list.addAll(self, 'definitionUri', FDefinitionUriList);
  if (child_name = 'definitionCanonical') Then
    list.addAll(self, 'definitionCanonical', FDefinitionCanonicalList);
  if (child_name = 'status') Then
     list.add(self.link, 'status', FStatus.Link);
  if (child_name = 'partOf') Then
    list.addAll(self, 'partOf', FPartOfList);
  if (child_name = 'code') Then
     list.add(self.link, 'code', FCode.Link);
  if (child_name = 'subject') Then
     list.add(self.link, 'subject', FSubject.Link);
  if (child_name = 'context') Then
     list.add(self.link, 'context', FContext.Link);
  if (child_name = 'occurrence[x]') or (child_name = 'occurrence') Then
     list.add(self.link, 'occurrence[x]', FOccurrence.Link);
  if (child_name = 'performer') Then
    list.addAll(self, 'performer', FPerformerList);
  if (child_name = 'performingOrganization') Then
     list.add(self.link, 'performingOrganization', FPerformingOrganization.Link);
  if (child_name = 'requestingOrganization') Then
     list.add(self.link, 'requestingOrganization', FRequestingOrganization.Link);
  if (child_name = 'costCenter') Then
     list.add(self.link, 'costCenter', FCostCenter.Link);
  if (child_name = 'quantity') Then
     list.add(self.link, 'quantity', FQuantity.Link);
  if (child_name = 'bodysite') Then
    list.addAll(self, 'bodysite', FBodysiteList);
  if (child_name = 'factorOverride') Then
     list.add(self.link, 'factorOverride', FFactorOverride.Link);
  if (child_name = 'priceOverride') Then
     list.add(self.link, 'priceOverride', FPriceOverride.Link);
  if (child_name = 'overrideReason') Then
     list.add(self.link, 'overrideReason', FOverrideReason.Link);
  if (child_name = 'enterer') Then
     list.add(self.link, 'enterer', FEnterer.Link);
  if (child_name = 'enteredDate') Then
     list.add(self.link, 'enteredDate', FEnteredDate.Link);
  if (child_name = 'reason') Then
    list.addAll(self, 'reason', FReasonList);
  if (child_name = 'service') Then
    list.addAll(self, 'service', FServiceList);
  if (child_name = 'product[x]') or (child_name = 'product') Then
     list.add(self.link, 'product[x]', FProduct.Link);
  if (child_name = 'account') Then
    list.addAll(self, 'account', FAccountList);
  if (child_name = 'note') Then
    list.addAll(self, 'note', FNoteList);
  if (child_name = 'supportingInformation') Then
    list.addAll(self, 'supportingInformation', FSupportingInformationList);
end;

procedure TFhirChargeItem.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'identifier', 'Identifier', true, TFhirIdentifier, FIdentifierList.Link));
  oList.add(TFHIRProperty.create(self, 'definitionUri', 'uri', true, TFhirUri, FDefinitionUriList.Link));
  oList.add(TFHIRProperty.create(self, 'definitionCanonical', 'canonical', true, TFhirCanonical, FDefinitionCanonicalList.Link));
  oList.add(TFHIRProperty.create(self, 'status', 'code', false, TFhirEnum, FStatus.Link));
  oList.add(TFHIRProperty.create(self, 'partOf', 'Reference', true, TFhirReference, FPartOfList.Link));
  oList.add(TFHIRProperty.create(self, 'code', 'CodeableConcept', false, TFhirCodeableConcept, FCode.Link));
  oList.add(TFHIRProperty.create(self, 'subject', 'Reference', false, TFhirReference, FSubject.Link));
  oList.add(TFHIRProperty.create(self, 'context', 'Reference', false, TFhirReference, FContext.Link));
  oList.add(TFHIRProperty.create(self, 'occurrence[x]', 'dateTime|Period|Timing', false, TFhirDataType, FOccurrence.Link));
  oList.add(TFHIRProperty.create(self, 'performer', 'BackboneElement', true, TFhirChargeItemPerformer, FPerformerList.Link));
  oList.add(TFHIRProperty.create(self, 'performingOrganization', 'Reference', false, TFhirReference, FPerformingOrganization.Link));
  oList.add(TFHIRProperty.create(self, 'requestingOrganization', 'Reference', false, TFhirReference, FRequestingOrganization.Link));
  oList.add(TFHIRProperty.create(self, 'costCenter', 'Reference', false, TFhirReference, FCostCenter.Link));
  oList.add(TFHIRProperty.create(self, 'quantity', 'Quantity', false, TFhirQuantity, FQuantity.Link));
  oList.add(TFHIRProperty.create(self, 'bodysite', 'CodeableConcept', true, TFhirCodeableConcept, FBodysiteList.Link));
  oList.add(TFHIRProperty.create(self, 'factorOverride', 'decimal', false, TFhirDecimal, FFactorOverride.Link));
  oList.add(TFHIRProperty.create(self, 'priceOverride', 'Money', false, TFhirMoney, FPriceOverride.Link));
  oList.add(TFHIRProperty.create(self, 'overrideReason', 'string', false, TFhirString, FOverrideReason.Link));
  oList.add(TFHIRProperty.create(self, 'enterer', 'Reference', false, TFhirReference, FEnterer.Link));
  oList.add(TFHIRProperty.create(self, 'enteredDate', 'dateTime', false, TFhirDateTime, FEnteredDate.Link));
  oList.add(TFHIRProperty.create(self, 'reason', 'CodeableConcept', true, TFhirCodeableConcept, FReasonList.Link));
  oList.add(TFHIRProperty.create(self, 'service', 'Reference', true, TFhirReference, FServiceList.Link));
  oList.add(TFHIRProperty.create(self, 'product[x]', 'Reference|CodeableConcept', false, TFhirDataType, FProduct.Link));
  oList.add(TFHIRProperty.create(self, 'account', 'Reference', true, TFhirReference, FAccountList.Link));
  oList.add(TFHIRProperty.create(self, 'note', 'Annotation', true, TFhirAnnotation, FNoteList.Link));
  oList.add(TFHIRProperty.create(self, 'supportingInformation', 'Reference', true, TFhirReference, FSupportingInformationList.Link));
end;

function TFhirChargeItem.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'identifier') then
  begin
    IdentifierList.add(propValue as TFhirIdentifier);
    result := propValue;
  end
  else if (propName = 'definitionUri') then
  begin
    DefinitionUriList.add(asUri(propValue)){2};     result := propValue;

  end
  else if (propName = 'definitionCanonical') then
  begin
    DefinitionCanonicalList.add(asCanonical(propValue)){2};     result := propValue;

  end
  else if (propName = 'status') then
  begin
    StatusElement := asEnum(SYSTEMS_TFhirChargeItemStatusEnum, CODES_TFhirChargeItemStatusEnum, propValue);
    result := propValue;
  end
  else if (propName = 'partOf') then
  begin
    PartOfList.add(propValue as TFhirReference);
    result := propValue;
  end
  else if (propName = 'code') then
  begin
    Code := propValue as TFhirCodeableConcept;
    result := propValue;
  end
  else if (propName = 'subject') then
  begin
    Subject := propValue as TFhirReference;
    result := propValue;
  end
  else if (propName = 'context') then
  begin
    Context := propValue as TFhirReference;
    result := propValue;
  end
  else if (isMatchingName(propName, 'occurrence', ['DateTime', 'Period', 'Timing'])) then
  begin
    Occurrence := propValue as TFhirDataType;
    result := propValue;
  end
  else if (propName = 'performer') then
  begin
    PerformerList.add(propValue as TFhirChargeItemPerformer);
    result := propValue;
  end
  else if (propName = 'performingOrganization') then
  begin
    PerformingOrganization := propValue as TFhirReference;
    result := propValue;
  end
  else if (propName = 'requestingOrganization') then
  begin
    RequestingOrganization := propValue as TFhirReference;
    result := propValue;
  end
  else if (propName = 'costCenter') then
  begin
    CostCenter := propValue as TFhirReference;
    result := propValue;
  end
  else if (propName = 'quantity') then
  begin
    Quantity := propValue as TFhirQuantity;
    result := propValue;
  end
  else if (propName = 'bodysite') then
  begin
    BodysiteList.add(propValue as TFhirCodeableConcept);
    result := propValue;
  end
  else if (propName = 'factorOverride') then
  begin
    FactorOverrideElement := asDecimal(propValue);
    result := propValue;
  end
  else if (propName = 'priceOverride') then
  begin
    PriceOverride := propValue as TFhirMoney;
    result := propValue;
  end
  else if (propName = 'overrideReason') then
  begin
    OverrideReasonElement := asString(propValue);
    result := propValue;
  end
  else if (propName = 'enterer') then
  begin
    Enterer := propValue as TFhirReference;
    result := propValue;
  end
  else if (propName = 'enteredDate') then
  begin
    EnteredDateElement := asDateTime(propValue);
    result := propValue;
  end
  else if (propName = 'reason') then
  begin
    ReasonList.add(propValue as TFhirCodeableConcept);
    result := propValue;
  end
  else if (propName = 'service') then
  begin
    ServiceList.add(propValue as TFhirReference);
    result := propValue;
  end
  else if (isMatchingName(propName, 'product', ['Reference', 'CodeableConcept'])) then
  begin
    Product := propValue as TFhirDataType;
    result := propValue;
  end
  else if (propName = 'account') then
  begin
    AccountList.add(propValue as TFhirReference);
    result := propValue;
  end
  else if (propName = 'note') then
  begin
    NoteList.add(propValue as TFhirAnnotation);
    result := propValue;
  end
  else if (propName = 'supportingInformation') then
  begin
    SupportingInformationList.add(propValue as TFhirReference);
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirChargeItem.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'identifier') then IdentifierList.insertItem(index, propValue as TFhirIdentifier)
  else if (propName = 'definitionUri') then DefinitionUriList.insertItem(index, asUri(propValue))
  else if (propName = 'definitionCanonical') then DefinitionCanonicalList.insertItem(index, asCanonical(propValue))
  else if (propName = 'partOf') then PartOfList.insertItem(index, propValue as TFhirReference)
  else if (propName = 'performer') then PerformerList.insertItem(index, propValue as TFhirChargeItemPerformer)
  else if (propName = 'bodysite') then BodysiteList.insertItem(index, propValue as TFhirCodeableConcept)
  else if (propName = 'reason') then ReasonList.insertItem(index, propValue as TFhirCodeableConcept)
  else if (propName = 'service') then ServiceList.insertItem(index, propValue as TFhirReference)
  else if (propName = 'account') then AccountList.insertItem(index, propValue as TFhirReference)
  else if (propName = 'note') then NoteList.insertItem(index, propValue as TFhirAnnotation)
  else if (propName = 'supportingInformation') then SupportingInformationList.insertItem(index, propValue as TFhirReference)
  else inherited;
end;

function TFhirChargeItem.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'identifier') then result := IdentifierList.new()
  else if (propName = 'definitionUri') then result := DefinitionUriList.new()
  else if (propName = 'definitionCanonical') then result := DefinitionCanonicalList.new()
  else if (propName = 'status') then result := TFhirEnum.create(SYSTEMS_TFhirChargeItemStatusEnum[ChargeItemStatusNull], CODES_TFhirChargeItemStatusEnum[ChargeItemStatusNull]) 
  else if (propName = 'partOf') then result := PartOfList.new()
  else if (propName = 'code') then result := TFhirCodeableConcept.create()
  else if (propName = 'subject') then result := TFhirReference.create()
  else if (propName = 'context') then result := TFhirReference.create()
  else if (isMatchingName(propName, 'occurrence', ['DateTime', 'Period', 'Timing'])) then raise EFHIRException.create('Cannot make property Occurrence')
  else if (propName = 'performer') then result := PerformerList.new()
  else if (propName = 'performingOrganization') then result := TFhirReference.create()
  else if (propName = 'requestingOrganization') then result := TFhirReference.create()
  else if (propName = 'costCenter') then result := TFhirReference.create()
  else if (propName = 'quantity') then result := TFhirQuantity.create()
  else if (propName = 'bodysite') then result := BodysiteList.new()
  else if (propName = 'factorOverride') then result := TFhirDecimal.create()
  else if (propName = 'priceOverride') then result := TFhirMoney.create()
  else if (propName = 'overrideReason') then result := TFhirString.create()
  else if (propName = 'enterer') then result := TFhirReference.create()
  else if (propName = 'enteredDate') then result := TFhirDateTime.create()
  else if (propName = 'reason') then result := ReasonList.new()
  else if (propName = 'service') then result := ServiceList.new()
  else if (isMatchingName(propName, 'product', ['Reference', 'CodeableConcept'])) then raise EFHIRException.create('Cannot make property Product')
  else if (propName = 'account') then result := AccountList.new()
  else if (propName = 'note') then result := NoteList.new()
  else if (propName = 'supportingInformation') then result := SupportingInformationList.new()
  else result := inherited createPropertyValue(propName);
end;

function TFhirChargeItem.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'identifier') then result := 'Identifier'
  else if (propName = 'definitionUri') then result := 'uri'
  else if (propName = 'definitionCanonical') then result := 'canonical'
  else if (propName = 'status') then result := 'code'
  else if (propName = 'partOf') then result := 'Reference'
  else if (propName = 'code') then result := 'CodeableConcept'
  else if (propName = 'subject') then result := 'Reference'
  else if (propName = 'context') then result := 'Reference'
  else if (propName = 'occurrence[x]') then result := 'dateTime|Period|Timing'
  else if (propName = 'performer') then result := 'BackboneElement'
  else if (propName = 'performingOrganization') then result := 'Reference'
  else if (propName = 'requestingOrganization') then result := 'Reference'
  else if (propName = 'costCenter') then result := 'Reference'
  else if (propName = 'quantity') then result := 'Quantity'
  else if (propName = 'bodysite') then result := 'CodeableConcept'
  else if (propName = 'factorOverride') then result := 'decimal'
  else if (propName = 'priceOverride') then result := 'Money'
  else if (propName = 'overrideReason') then result := 'string'
  else if (propName = 'enterer') then result := 'Reference'
  else if (propName = 'enteredDate') then result := 'dateTime'
  else if (propName = 'reason') then result := 'CodeableConcept'
  else if (propName = 'service') then result := 'Reference'
  else if (propName = 'product[x]') then result := 'Reference|CodeableConcept'
  else if (propName = 'account') then result := 'Reference'
  else if (propName = 'note') then result := 'Annotation'
  else if (propName = 'supportingInformation') then result := 'Reference'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirChargeItem.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'identifier') then deletePropertyValue('identifier', IdentifierList, value)
  else if (propName = 'definitionUri') then deletePropertyValue('definitionUri', DefinitionUriList, value)
  else if (propName = 'definitionCanonical') then deletePropertyValue('definitionCanonical', DefinitionCanonicalList, value)
  else if (propName = 'status') then StatusElement := nil
  else if (propName = 'partOf') then deletePropertyValue('partOf', PartOfList, value)
  else if (propName = 'code') then CodeElement := nil
  else if (propName = 'subject') then SubjectElement := nil
  else if (propName = 'context') then ContextElement := nil
  else if (isMatchingName(propName, 'occurrence', ['DateTime', 'Period', 'Timing'])) then OccurrenceElement := nil
  else if (propName = 'performer') then deletePropertyValue('performer', PerformerList, value)
  else if (propName = 'performingOrganization') then PerformingOrganizationElement := nil
  else if (propName = 'requestingOrganization') then RequestingOrganizationElement := nil
  else if (propName = 'costCenter') then CostCenterElement := nil
  else if (propName = 'quantity') then QuantityElement := nil
  else if (propName = 'bodysite') then deletePropertyValue('bodysite', BodysiteList, value)
  else if (propName = 'factorOverride') then FactorOverrideElement := nil
  else if (propName = 'priceOverride') then PriceOverrideElement := nil
  else if (propName = 'overrideReason') then OverrideReasonElement := nil
  else if (propName = 'enterer') then EntererElement := nil
  else if (propName = 'enteredDate') then EnteredDateElement := nil
  else if (propName = 'reason') then deletePropertyValue('reason', ReasonList, value)
  else if (propName = 'service') then deletePropertyValue('service', ServiceList, value)
  else if (isMatchingName(propName, 'product', ['Reference', 'CodeableConcept'])) then ProductElement := nil
  else if (propName = 'account') then deletePropertyValue('account', AccountList, value)
  else if (propName = 'note') then deletePropertyValue('note', NoteList, value)
  else if (propName = 'supportingInformation') then deletePropertyValue('supportingInformation', SupportingInformationList, value)
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirChargeItem.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'identifier') then replacePropertyValue('identifier', IdentifierList, existing, new)
  else if (propName = 'definitionUri') then replacePropertyValue('definitionUri', DefinitionUriList, existing, new)
  else if (propName = 'definitionCanonical') then replacePropertyValue('definitionCanonical', DefinitionCanonicalList, existing, new)
  else if (propName = 'status') then StatusElement := asEnum(SYSTEMS_TFhirChargeItemStatusEnum, CODES_TFhirChargeItemStatusEnum, new)
  else if (propName = 'partOf') then replacePropertyValue('partOf', PartOfList, existing, new)
  else if (propName = 'code') then CodeElement := new as TFhirCodeableConcept
  else if (propName = 'subject') then SubjectElement := new as TFhirReference
  else if (propName = 'context') then ContextElement := new as TFhirReference
  else if (isMatchingName(propName, 'occurrence', ['DateTime', 'Period', 'Timing'])) then OccurrenceElement := new as TFhirDataType
  else if (propName = 'performer') then replacePropertyValue('performer', PerformerList, existing, new)
  else if (propName = 'performingOrganization') then PerformingOrganizationElement := new as TFhirReference
  else if (propName = 'requestingOrganization') then RequestingOrganizationElement := new as TFhirReference
  else if (propName = 'costCenter') then CostCenterElement := new as TFhirReference
  else if (propName = 'quantity') then QuantityElement := new as TFhirQuantity
  else if (propName = 'bodysite') then replacePropertyValue('bodysite', BodysiteList, existing, new)
  else if (propName = 'factorOverride') then FactorOverrideElement := asDecimal(new)
  else if (propName = 'priceOverride') then PriceOverrideElement := new as TFhirMoney
  else if (propName = 'overrideReason') then OverrideReasonElement := asString(new)
  else if (propName = 'enterer') then EntererElement := new as TFhirReference
  else if (propName = 'enteredDate') then EnteredDateElement := asDateTime(new)
  else if (propName = 'reason') then replacePropertyValue('reason', ReasonList, existing, new)
  else if (propName = 'service') then replacePropertyValue('service', ServiceList, existing, new)
  else if (isMatchingName(propName, 'product', ['Reference', 'CodeableConcept'])) then ProductElement := new as TFhirDataType
  else if (propName = 'account') then replacePropertyValue('account', AccountList, existing, new)
  else if (propName = 'note') then replacePropertyValue('note', NoteList, existing, new)
  else if (propName = 'supportingInformation') then replacePropertyValue('supportingInformation', SupportingInformationList, existing, new)
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirChargeItem.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'identifier') then IdentifierList.move(source, destination)
  else if (propName = 'definitionUri') then DefinitionUriList.move(source, destination)
  else if (propName = 'definitionCanonical') then DefinitionCanonicalList.move(source, destination)
  else if (propName = 'partOf') then PartOfList.move(source, destination)
  else if (propName = 'performer') then PerformerList.move(source, destination)
  else if (propName = 'bodysite') then BodysiteList.move(source, destination)
  else if (propName = 'reason') then ReasonList.move(source, destination)
  else if (propName = 'service') then ServiceList.move(source, destination)
  else if (propName = 'account') then AccountList.move(source, destination)
  else if (propName = 'note') then NoteList.move(source, destination)
  else if (propName = 'supportingInformation') then SupportingInformationList.move(source, destination)
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirChargeItem.fhirType : string;
begin
  result := 'ChargeItem';
end;

function TFhirChargeItem.Link : TFhirChargeItem;
begin
  result := TFhirChargeItem(inherited Link);
end;

function TFhirChargeItem.Clone : TFhirChargeItem;
begin
  result := TFhirChargeItem(inherited Clone);
end;

function TFhirChargeItem.equals(other : TObject) : boolean; 
var
  o : TFhirChargeItem;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirChargeItem)) then
    result := false
  else
  begin
    o := TFhirChargeItem(other);
    result := compareDeep(identifierList, o.identifierList, true) and compareDeep(definitionUriList, o.definitionUriList, true) and 
      compareDeep(definitionCanonicalList, o.definitionCanonicalList, true) and compareDeep(statusElement, o.statusElement, true) and 
      compareDeep(partOfList, o.partOfList, true) and compareDeep(codeElement, o.codeElement, true) and 
      compareDeep(subjectElement, o.subjectElement, true) and compareDeep(contextElement, o.contextElement, true) and 
      compareDeep(occurrenceElement, o.occurrenceElement, true) and compareDeep(performerList, o.performerList, true) and 
      compareDeep(performingOrganizationElement, o.performingOrganizationElement, true) and 
      compareDeep(requestingOrganizationElement, o.requestingOrganizationElement, true) and 
      compareDeep(costCenterElement, o.costCenterElement, true) and compareDeep(quantityElement, o.quantityElement, true) and 
      compareDeep(bodysiteList, o.bodysiteList, true) and compareDeep(factorOverrideElement, o.factorOverrideElement, true) and 
      compareDeep(priceOverrideElement, o.priceOverrideElement, true) and compareDeep(overrideReasonElement, o.overrideReasonElement, true) and 
      compareDeep(entererElement, o.entererElement, true) and compareDeep(enteredDateElement, o.enteredDateElement, true) and 
      compareDeep(reasonList, o.reasonList, true) and compareDeep(serviceList, o.serviceList, true) and 
      compareDeep(productElement, o.productElement, true) and compareDeep(accountList, o.accountList, true) and 
      compareDeep(noteList, o.noteList, true) and compareDeep(supportingInformationList, o.supportingInformationList, true);
  end;
end;

function TFhirChargeItem.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FidentifierList) and isEmptyProp(FdefinitionUriList) and isEmptyProp(FdefinitionCanonicalList) and isEmptyProp(FStatus) and isEmptyProp(FpartOfList) and isEmptyProp(FCode) and isEmptyProp(FSubject) and isEmptyProp(FContext) and isEmptyProp(FOccurrence) and isEmptyProp(FperformerList) and isEmptyProp(FPerformingOrganization) and isEmptyProp(FRequestingOrganization) and isEmptyProp(FCostCenter) and isEmptyProp(FQuantity) and isEmptyProp(FbodysiteList) and isEmptyProp(FFactorOverride) and isEmptyProp(FPriceOverride) and isEmptyProp(FOverrideReason) and isEmptyProp(FEnterer) and isEmptyProp(FEnteredDate) and isEmptyProp(FreasonList) and isEmptyProp(FserviceList) and isEmptyProp(FProduct) and isEmptyProp(FaccountList) and isEmptyProp(FnoteList) and isEmptyProp(FsupportingInformationList);
end;

procedure TFhirChargeItem.listFieldsInOrder(fields : TStringList);
begin
  inherited listFieldsInOrder(fields);
  fields.add('identifier');
  fields.add('definitionUri');
  fields.add('definitionCanonical');
  fields.add('status');
  fields.add('partOf');
  fields.add('code');
  fields.add('subject');
  fields.add('context');
  fields.add('occurrence[x]');
  fields.add('performer');
  fields.add('performingOrganization');
  fields.add('requestingOrganization');
  fields.add('costCenter');
  fields.add('quantity');
  fields.add('bodysite');
  fields.add('factorOverride');
  fields.add('priceOverride');
  fields.add('overrideReason');
  fields.add('enterer');
  fields.add('enteredDate');
  fields.add('reason');
  fields.add('service');
  fields.add('product[x]');
  fields.add('account');
  fields.add('note');
  fields.add('supportingInformation');
end;

function TFhirChargeItem.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FIdentifierList.sizeInBytes(magic));
  inc(result, FDefinitionUriList.sizeInBytes(magic));
  inc(result, FDefinitionCanonicalList.sizeInBytes(magic));
  inc(result, FPartOfList.sizeInBytes(magic));
  inc(result, FPerformerList.sizeInBytes(magic));
  inc(result, FBodysiteList.sizeInBytes(magic));
  inc(result, FReasonList.sizeInBytes(magic));
  inc(result, FServiceList.sizeInBytes(magic));
  inc(result, FAccountList.sizeInBytes(magic));
  inc(result, FNoteList.sizeInBytes(magic));
  inc(result, FSupportingInformationList.sizeInBytes(magic));
end;

function TFhirChargeItem.GetIdentifierList : TFhirIdentifierList;
begin
  if FIdentifierList = nil then
    FIdentifierList := TFhirIdentifierList.Create;
  result := FIdentifierList;
end;

function TFhirChargeItem.GetHasIdentifierList : boolean;
begin
  result := (FIdentifierList <> nil) and (FIdentifierList.count > 0);
end;

function TFhirChargeItem.GetDefinitionUriList : TFhirUriList;
begin
  if FDefinitionUriList = nil then
    FDefinitionUriList := TFhirUriList.Create;
  result := FDefinitionUriList;
end;

function TFhirChargeItem.GetHasDefinitionUriList : boolean;
begin
  result := (FDefinitionUriList <> nil) and (FDefinitionUriList.count > 0);
end;

function TFhirChargeItem.GetDefinitionCanonicalList : TFhirCanonicalList;
begin
  if FDefinitionCanonicalList = nil then
    FDefinitionCanonicalList := TFhirCanonicalList.Create;
  result := FDefinitionCanonicalList;
end;

function TFhirChargeItem.GetHasDefinitionCanonicalList : boolean;
begin
  result := (FDefinitionCanonicalList <> nil) and (FDefinitionCanonicalList.count > 0);
end;

procedure TFhirChargeItem.SetStatus(value : TFhirEnum);
begin
  FStatus.free;
  FStatus := value;
end;

function TFhirChargeItem.GetStatusST : TFhirChargeItemStatusEnum;
begin
  if FStatus = nil then
    result := TFhirChargeItemStatusEnum(0)
  else
    result := TFhirChargeItemStatusEnum(StringArrayIndexOfSensitive(CODES_TFhirChargeItemStatusEnum, FStatus.value));
end;

procedure TFhirChargeItem.SetStatusST(value : TFhirChargeItemStatusEnum);
begin
  if ord(value) = 0 then
    StatusElement := nil
  else
    StatusElement := TFhirEnum.create(SYSTEMS_TFhirChargeItemStatusEnum[value], CODES_TFhirChargeItemStatusEnum[value]);
end;

function TFhirChargeItem.GetPartOfList : TFhirReferenceList;
begin
  if FPartOfList = nil then
    FPartOfList := TFhirReferenceList.Create;
  result := FPartOfList;
end;

function TFhirChargeItem.GetHasPartOfList : boolean;
begin
  result := (FPartOfList <> nil) and (FPartOfList.count > 0);
end;

procedure TFhirChargeItem.SetCode(value : TFhirCodeableConcept);
begin
  FCode.free;
  FCode := value;
end;

procedure TFhirChargeItem.SetSubject(value : TFhirReference);
begin
  FSubject.free;
  FSubject := value;
end;

procedure TFhirChargeItem.SetContext(value : TFhirReference);
begin
  FContext.free;
  FContext := value;
end;

procedure TFhirChargeItem.SetOccurrence(value : TFhirDataType);
begin
  FOccurrence.free;
  FOccurrence := value;
end;

function TFhirChargeItem.GetPerformerList : TFhirChargeItemPerformerList;
begin
  if FPerformerList = nil then
    FPerformerList := TFhirChargeItemPerformerList.Create;
  result := FPerformerList;
end;

function TFhirChargeItem.GetHasPerformerList : boolean;
begin
  result := (FPerformerList <> nil) and (FPerformerList.count > 0);
end;

procedure TFhirChargeItem.SetPerformingOrganization(value : TFhirReference);
begin
  FPerformingOrganization.free;
  FPerformingOrganization := value;
end;

procedure TFhirChargeItem.SetRequestingOrganization(value : TFhirReference);
begin
  FRequestingOrganization.free;
  FRequestingOrganization := value;
end;

procedure TFhirChargeItem.SetCostCenter(value : TFhirReference);
begin
  FCostCenter.free;
  FCostCenter := value;
end;

procedure TFhirChargeItem.SetQuantity(value : TFhirQuantity);
begin
  FQuantity.free;
  FQuantity := value;
end;

function TFhirChargeItem.GetBodysiteList : TFhirCodeableConceptList;
begin
  if FBodysiteList = nil then
    FBodysiteList := TFhirCodeableConceptList.Create;
  result := FBodysiteList;
end;

function TFhirChargeItem.GetHasBodysiteList : boolean;
begin
  result := (FBodysiteList <> nil) and (FBodysiteList.count > 0);
end;

procedure TFhirChargeItem.SetFactorOverride(value : TFhirDecimal);
begin
  FFactorOverride.free;
  FFactorOverride := value;
end;

function TFhirChargeItem.GetFactorOverrideST : String;
begin
  if FFactorOverride = nil then
    result := ''
  else
    result := FFactorOverride.value;
end;

procedure TFhirChargeItem.SetFactorOverrideST(value : String);
begin
  if value <> '' then
  begin
    if FFactorOverride = nil then
      FFactorOverride := TFhirDecimal.create;
    FFactorOverride.value := value
  end
  else if FFactorOverride <> nil then
    FFactorOverride.value := '';
end;

procedure TFhirChargeItem.SetPriceOverride(value : TFhirMoney);
begin
  FPriceOverride.free;
  FPriceOverride := value;
end;

procedure TFhirChargeItem.SetOverrideReason(value : TFhirString);
begin
  FOverrideReason.free;
  FOverrideReason := value;
end;

function TFhirChargeItem.GetOverrideReasonST : String;
begin
  if FOverrideReason = nil then
    result := ''
  else
    result := FOverrideReason.value;
end;

procedure TFhirChargeItem.SetOverrideReasonST(value : String);
begin
  if value <> '' then
  begin
    if FOverrideReason = nil then
      FOverrideReason := TFhirString.create;
    FOverrideReason.value := value
  end
  else if FOverrideReason <> nil then
    FOverrideReason.value := '';
end;

procedure TFhirChargeItem.SetEnterer(value : TFhirReference);
begin
  FEnterer.free;
  FEnterer := value;
end;

procedure TFhirChargeItem.SetEnteredDate(value : TFhirDateTime);
begin
  FEnteredDate.free;
  FEnteredDate := value;
end;

function TFhirChargeItem.GetEnteredDateST : TFslDateTime;
begin
  if FEnteredDate = nil then
    result := TFslDateTime.makeNull
  else
    result := FEnteredDate.value;
end;

procedure TFhirChargeItem.SetEnteredDateST(value : TFslDateTime);
begin
  if FEnteredDate = nil then
    FEnteredDate := TFhirDateTime.create;
  FEnteredDate.value := value
end;

function TFhirChargeItem.GetReasonList : TFhirCodeableConceptList;
begin
  if FReasonList = nil then
    FReasonList := TFhirCodeableConceptList.Create;
  result := FReasonList;
end;

function TFhirChargeItem.GetHasReasonList : boolean;
begin
  result := (FReasonList <> nil) and (FReasonList.count > 0);
end;

function TFhirChargeItem.GetServiceList : TFhirReferenceList;
begin
  if FServiceList = nil then
    FServiceList := TFhirReferenceList.Create;
  result := FServiceList;
end;

function TFhirChargeItem.GetHasServiceList : boolean;
begin
  result := (FServiceList <> nil) and (FServiceList.count > 0);
end;

procedure TFhirChargeItem.SetProduct(value : TFhirDataType);
begin
  FProduct.free;
  FProduct := value;
end;

function TFhirChargeItem.GetAccountList : TFhirReferenceList;
begin
  if FAccountList = nil then
    FAccountList := TFhirReferenceList.Create;
  result := FAccountList;
end;

function TFhirChargeItem.GetHasAccountList : boolean;
begin
  result := (FAccountList <> nil) and (FAccountList.count > 0);
end;

function TFhirChargeItem.GetNoteList : TFhirAnnotationList;
begin
  if FNoteList = nil then
    FNoteList := TFhirAnnotationList.Create;
  result := FNoteList;
end;

function TFhirChargeItem.GetHasNoteList : boolean;
begin
  result := (FNoteList <> nil) and (FNoteList.count > 0);
end;

function TFhirChargeItem.GetSupportingInformationList : TFhirReferenceList;
begin
  if FSupportingInformationList = nil then
    FSupportingInformationList := TFhirReferenceList.Create;
  result := FSupportingInformationList;
end;

function TFhirChargeItem.GetHasSupportingInformationList : boolean;
begin
  result := (FSupportingInformationList <> nil) and (FSupportingInformationList.count > 0);
end;

{ TFhirChargeItemListEnumerator }

constructor TFhirChargeItemListEnumerator.Create(list : TFhirChargeItemList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirChargeItemListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirChargeItemListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirChargeItemListEnumerator.GetCurrent : TFhirChargeItem;
begin
  Result := FList[FIndex];
end;

function TFhirChargeItemListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirChargeItemList }

procedure TFhirChargeItemList.AddItem(value: TFhirChargeItem);
begin
  assert(value.ClassName = 'TFhirChargeItem', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirChargeItem');
  add(value);
end;

function TFhirChargeItemList.Append: TFhirChargeItem;
begin
  result := TFhirChargeItem.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirChargeItemList.ClearItems;
begin
  Clear;
end;

function TFhirChargeItemList.GetEnumerator : TFhirChargeItemListEnumerator;
begin
  result := TFhirChargeItemListEnumerator.Create(self.link);
end;

function TFhirChargeItemList.Clone: TFhirChargeItemList;
begin
  result := TFhirChargeItemList(inherited Clone);
end;

function TFhirChargeItemList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirChargeItemList.GetItemN(index: Integer): TFhirChargeItem;
begin
  result := TFhirChargeItem(ObjectByIndex[index]);
end;

function TFhirChargeItemList.ItemClass: TFslObjectClass;
begin
  result := TFhirChargeItem;
end;
function TFhirChargeItemList.IndexOf(value: TFhirChargeItem): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirChargeItemList.Insert(index: Integer): TFhirChargeItem;
begin
  result := TFhirChargeItem.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirChargeItemList.InsertItem(index: Integer; value: TFhirChargeItem);
begin
  assert(value is TFhirChargeItem);
  Inherited Insert(index, value);
end;

function TFhirChargeItemList.Item(index: Integer): TFhirChargeItem;
begin
  result := TFhirChargeItem(ObjectByIndex[index]);
end;

function TFhirChargeItemList.Link: TFhirChargeItemList;
begin
  result := TFhirChargeItemList(inherited Link);
end;

procedure TFhirChargeItemList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirChargeItemList.SetItemByIndex(index: Integer; value: TFhirChargeItem);
begin
  assert(value is TFhirChargeItem);
  FhirChargeItems[index] := value;
end;

procedure TFhirChargeItemList.SetItemN(index: Integer; value: TFhirChargeItem);
begin
  assert(value is TFhirChargeItem);
  ObjectByIndex[index] := value;
end;

{$ENDIF FHIR_CHARGEITEM}
{$IFDEF FHIR_CHARGEITEMDEFINITION}
{ TFhirChargeItemDefinitionApplicability }

constructor TFhirChargeItemDefinitionApplicability.Create;
begin
  inherited;
end;

destructor TFhirChargeItemDefinitionApplicability.Destroy;
begin
  FDescription.free;
  FLanguage.free;
  FExpression.free;
  inherited;
end;

procedure TFhirChargeItemDefinitionApplicability.Assign(oSource : TFslObject);
begin
  inherited;
  descriptionElement := TFhirChargeItemDefinitionApplicability(oSource).descriptionElement.Clone;
  languageElement := TFhirChargeItemDefinitionApplicability(oSource).languageElement.Clone;
  expressionElement := TFhirChargeItemDefinitionApplicability(oSource).expressionElement.Clone;
end;

procedure TFhirChargeItemDefinitionApplicability.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'description') Then
     list.add(self.link, 'description', FDescription.Link);
  if (child_name = 'language') Then
     list.add(self.link, 'language', FLanguage.Link);
  if (child_name = 'expression') Then
     list.add(self.link, 'expression', FExpression.Link);
end;

procedure TFhirChargeItemDefinitionApplicability.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'description', 'string', false, TFhirString, FDescription.Link));
  oList.add(TFHIRProperty.create(self, 'language', 'string', false, TFhirString, FLanguage.Link));
  oList.add(TFHIRProperty.create(self, 'expression', 'string', false, TFhirString, FExpression.Link));
end;

function TFhirChargeItemDefinitionApplicability.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'description') then
  begin
    DescriptionElement := asString(propValue);
    result := propValue;
  end
  else if (propName = 'language') then
  begin
    LanguageElement := asString(propValue);
    result := propValue;
  end
  else if (propName = 'expression') then
  begin
    ExpressionElement := asString(propValue);
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirChargeItemDefinitionApplicability.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirChargeItemDefinitionApplicability.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'description') then result := TFhirString.create()
  else if (propName = 'language') then result := TFhirString.create()
  else if (propName = 'expression') then result := TFhirString.create()
  else result := inherited createPropertyValue(propName);
end;

function TFhirChargeItemDefinitionApplicability.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'description') then result := 'string'
  else if (propName = 'language') then result := 'string'
  else if (propName = 'expression') then result := 'string'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirChargeItemDefinitionApplicability.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'description') then DescriptionElement := nil
  else if (propName = 'language') then LanguageElement := nil
  else if (propName = 'expression') then ExpressionElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirChargeItemDefinitionApplicability.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'description') then DescriptionElement := asString(new)
  else if (propName = 'language') then LanguageElement := asString(new)
  else if (propName = 'expression') then ExpressionElement := asString(new)
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirChargeItemDefinitionApplicability.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirChargeItemDefinitionApplicability.fhirType : string;
begin
  result := 'ChargeItemDefinition.applicability';
end;

function TFhirChargeItemDefinitionApplicability.Link : TFhirChargeItemDefinitionApplicability;
begin
  result := TFhirChargeItemDefinitionApplicability(inherited Link);
end;

function TFhirChargeItemDefinitionApplicability.Clone : TFhirChargeItemDefinitionApplicability;
begin
  result := TFhirChargeItemDefinitionApplicability(inherited Clone);
end;

function TFhirChargeItemDefinitionApplicability.equals(other : TObject) : boolean; 
var
  o : TFhirChargeItemDefinitionApplicability;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirChargeItemDefinitionApplicability)) then
    result := false
  else
  begin
    o := TFhirChargeItemDefinitionApplicability(other);
    result := compareDeep(descriptionElement, o.descriptionElement, true) and compareDeep(languageElement, o.languageElement, true) and 
      compareDeep(expressionElement, o.expressionElement, true);
  end;
end;

function TFhirChargeItemDefinitionApplicability.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FDescription) and isEmptyProp(FLanguage) and isEmptyProp(FExpression);
end;

procedure TFhirChargeItemDefinitionApplicability.listFieldsInOrder(fields : TStringList);
begin
  inherited listFieldsInOrder(fields);
  fields.add('description');
  fields.add('language');
  fields.add('expression');
end;

function TFhirChargeItemDefinitionApplicability.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
end;

procedure TFhirChargeItemDefinitionApplicability.SetDescription(value : TFhirString);
begin
  FDescription.free;
  FDescription := value;
end;

function TFhirChargeItemDefinitionApplicability.GetDescriptionST : String;
begin
  if FDescription = nil then
    result := ''
  else
    result := FDescription.value;
end;

procedure TFhirChargeItemDefinitionApplicability.SetDescriptionST(value : String);
begin
  if value <> '' then
  begin
    if FDescription = nil then
      FDescription := TFhirString.create;
    FDescription.value := value
  end
  else if FDescription <> nil then
    FDescription.value := '';
end;

procedure TFhirChargeItemDefinitionApplicability.SetLanguage(value : TFhirString);
begin
  FLanguage.free;
  FLanguage := value;
end;

function TFhirChargeItemDefinitionApplicability.GetLanguageST : String;
begin
  if FLanguage = nil then
    result := ''
  else
    result := FLanguage.value;
end;

procedure TFhirChargeItemDefinitionApplicability.SetLanguageST(value : String);
begin
  if value <> '' then
  begin
    if FLanguage = nil then
      FLanguage := TFhirString.create;
    FLanguage.value := value
  end
  else if FLanguage <> nil then
    FLanguage.value := '';
end;

procedure TFhirChargeItemDefinitionApplicability.SetExpression(value : TFhirString);
begin
  FExpression.free;
  FExpression := value;
end;

function TFhirChargeItemDefinitionApplicability.GetExpressionST : String;
begin
  if FExpression = nil then
    result := ''
  else
    result := FExpression.value;
end;

procedure TFhirChargeItemDefinitionApplicability.SetExpressionST(value : String);
begin
  if value <> '' then
  begin
    if FExpression = nil then
      FExpression := TFhirString.create;
    FExpression.value := value
  end
  else if FExpression <> nil then
    FExpression.value := '';
end;

{ TFhirChargeItemDefinitionApplicabilityListEnumerator }

constructor TFhirChargeItemDefinitionApplicabilityListEnumerator.Create(list : TFhirChargeItemDefinitionApplicabilityList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirChargeItemDefinitionApplicabilityListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirChargeItemDefinitionApplicabilityListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirChargeItemDefinitionApplicabilityListEnumerator.GetCurrent : TFhirChargeItemDefinitionApplicability;
begin
  Result := FList[FIndex];
end;

function TFhirChargeItemDefinitionApplicabilityListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirChargeItemDefinitionApplicabilityList }

procedure TFhirChargeItemDefinitionApplicabilityList.AddItem(value: TFhirChargeItemDefinitionApplicability);
begin
  assert(value.ClassName = 'TFhirChargeItemDefinitionApplicability', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirChargeItemDefinitionApplicability');
  add(value);
end;

function TFhirChargeItemDefinitionApplicabilityList.Append: TFhirChargeItemDefinitionApplicability;
begin
  result := TFhirChargeItemDefinitionApplicability.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirChargeItemDefinitionApplicabilityList.ClearItems;
begin
  Clear;
end;

function TFhirChargeItemDefinitionApplicabilityList.GetEnumerator : TFhirChargeItemDefinitionApplicabilityListEnumerator;
begin
  result := TFhirChargeItemDefinitionApplicabilityListEnumerator.Create(self.link);
end;

function TFhirChargeItemDefinitionApplicabilityList.Clone: TFhirChargeItemDefinitionApplicabilityList;
begin
  result := TFhirChargeItemDefinitionApplicabilityList(inherited Clone);
end;

function TFhirChargeItemDefinitionApplicabilityList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirChargeItemDefinitionApplicabilityList.GetItemN(index: Integer): TFhirChargeItemDefinitionApplicability;
begin
  result := TFhirChargeItemDefinitionApplicability(ObjectByIndex[index]);
end;

function TFhirChargeItemDefinitionApplicabilityList.ItemClass: TFslObjectClass;
begin
  result := TFhirChargeItemDefinitionApplicability;
end;
function TFhirChargeItemDefinitionApplicabilityList.IndexOf(value: TFhirChargeItemDefinitionApplicability): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirChargeItemDefinitionApplicabilityList.Insert(index: Integer): TFhirChargeItemDefinitionApplicability;
begin
  result := TFhirChargeItemDefinitionApplicability.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirChargeItemDefinitionApplicabilityList.InsertItem(index: Integer; value: TFhirChargeItemDefinitionApplicability);
begin
  assert(value is TFhirChargeItemDefinitionApplicability);
  Inherited Insert(index, value);
end;

function TFhirChargeItemDefinitionApplicabilityList.Item(index: Integer): TFhirChargeItemDefinitionApplicability;
begin
  result := TFhirChargeItemDefinitionApplicability(ObjectByIndex[index]);
end;

function TFhirChargeItemDefinitionApplicabilityList.Link: TFhirChargeItemDefinitionApplicabilityList;
begin
  result := TFhirChargeItemDefinitionApplicabilityList(inherited Link);
end;

procedure TFhirChargeItemDefinitionApplicabilityList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirChargeItemDefinitionApplicabilityList.SetItemByIndex(index: Integer; value: TFhirChargeItemDefinitionApplicability);
begin
  assert(value is TFhirChargeItemDefinitionApplicability);
  FhirChargeItemDefinitionApplicabilities[index] := value;
end;

procedure TFhirChargeItemDefinitionApplicabilityList.SetItemN(index: Integer; value: TFhirChargeItemDefinitionApplicability);
begin
  assert(value is TFhirChargeItemDefinitionApplicability);
  ObjectByIndex[index] := value;
end;

{ TFhirChargeItemDefinitionPropertyGroup }

constructor TFhirChargeItemDefinitionPropertyGroup.Create;
begin
  inherited;
end;

destructor TFhirChargeItemDefinitionPropertyGroup.Destroy;
begin
  FApplicabilityList.Free;
  FPriceComponentList.Free;
  inherited;
end;

procedure TFhirChargeItemDefinitionPropertyGroup.Assign(oSource : TFslObject);
begin
  inherited;
  if (TFhirChargeItemDefinitionPropertyGroup(oSource).FApplicabilityList = nil) then
  begin
    FApplicabilityList.free;
    FApplicabilityList := nil;
  end
  else
  begin
    if FApplicabilityList = nil then
      FApplicabilityList := TFhirChargeItemDefinitionApplicabilityList.Create;
    FApplicabilityList.Assign(TFhirChargeItemDefinitionPropertyGroup(oSource).FApplicabilityList);
  end;
  if (TFhirChargeItemDefinitionPropertyGroup(oSource).FPriceComponentList = nil) then
  begin
    FPriceComponentList.free;
    FPriceComponentList := nil;
  end
  else
  begin
    if FPriceComponentList = nil then
      FPriceComponentList := TFhirChargeItemDefinitionPropertyGroupPriceComponentList.Create;
    FPriceComponentList.Assign(TFhirChargeItemDefinitionPropertyGroup(oSource).FPriceComponentList);
  end;
end;

procedure TFhirChargeItemDefinitionPropertyGroup.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'applicability') Then
    list.addAll(self, 'applicability', FApplicabilityList);
  if (child_name = 'priceComponent') Then
    list.addAll(self, 'priceComponent', FPriceComponentList);
end;

procedure TFhirChargeItemDefinitionPropertyGroup.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'applicability', '', true, TFhirChargeItemDefinitionApplicability, FApplicabilityList.Link));
  oList.add(TFHIRProperty.create(self, 'priceComponent', 'BackboneElement', true, TFhirChargeItemDefinitionPropertyGroupPriceComponent, FPriceComponentList.Link));
end;

function TFhirChargeItemDefinitionPropertyGroup.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'applicability') then
  begin
    ApplicabilityList.add(propValue as TFhirChargeItemDefinitionApplicability);
    result := propValue;
  end
  else if (propName = 'priceComponent') then
  begin
    PriceComponentList.add(propValue as TFhirChargeItemDefinitionPropertyGroupPriceComponent);
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirChargeItemDefinitionPropertyGroup.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'applicability') then ApplicabilityList.insertItem(index, propValue as TFhirChargeItemDefinitionApplicability)
  else if (propName = 'priceComponent') then PriceComponentList.insertItem(index, propValue as TFhirChargeItemDefinitionPropertyGroupPriceComponent)
  else inherited;
end;

function TFhirChargeItemDefinitionPropertyGroup.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'applicability') then result := ApplicabilityList.new()
  else if (propName = 'priceComponent') then result := PriceComponentList.new()
  else result := inherited createPropertyValue(propName);
end;

function TFhirChargeItemDefinitionPropertyGroup.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'applicability') then result := ''
  else if (propName = 'priceComponent') then result := 'BackboneElement'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirChargeItemDefinitionPropertyGroup.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'applicability') then deletePropertyValue('applicability', ApplicabilityList, value)
  else if (propName = 'priceComponent') then deletePropertyValue('priceComponent', PriceComponentList, value)
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirChargeItemDefinitionPropertyGroup.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'applicability') then replacePropertyValue('applicability', ApplicabilityList, existing, new)
  else if (propName = 'priceComponent') then replacePropertyValue('priceComponent', PriceComponentList, existing, new)
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirChargeItemDefinitionPropertyGroup.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'applicability') then ApplicabilityList.move(source, destination)
  else if (propName = 'priceComponent') then PriceComponentList.move(source, destination)
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirChargeItemDefinitionPropertyGroup.fhirType : string;
begin
  result := 'ChargeItemDefinition.propertyGroup';
end;

function TFhirChargeItemDefinitionPropertyGroup.Link : TFhirChargeItemDefinitionPropertyGroup;
begin
  result := TFhirChargeItemDefinitionPropertyGroup(inherited Link);
end;

function TFhirChargeItemDefinitionPropertyGroup.Clone : TFhirChargeItemDefinitionPropertyGroup;
begin
  result := TFhirChargeItemDefinitionPropertyGroup(inherited Clone);
end;

function TFhirChargeItemDefinitionPropertyGroup.equals(other : TObject) : boolean; 
var
  o : TFhirChargeItemDefinitionPropertyGroup;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirChargeItemDefinitionPropertyGroup)) then
    result := false
  else
  begin
    o := TFhirChargeItemDefinitionPropertyGroup(other);
    result := compareDeep(applicabilityList, o.applicabilityList, true) and compareDeep(priceComponentList, o.priceComponentList, true);
  end;
end;

function TFhirChargeItemDefinitionPropertyGroup.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FapplicabilityList) and isEmptyProp(FpriceComponentList);
end;

procedure TFhirChargeItemDefinitionPropertyGroup.listFieldsInOrder(fields : TStringList);
begin
  inherited listFieldsInOrder(fields);
  fields.add('applicability');
  fields.add('priceComponent');
end;

function TFhirChargeItemDefinitionPropertyGroup.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FApplicabilityList.sizeInBytes(magic));
  inc(result, FPriceComponentList.sizeInBytes(magic));
end;

function TFhirChargeItemDefinitionPropertyGroup.GetApplicabilityList : TFhirChargeItemDefinitionApplicabilityList;
begin
  if FApplicabilityList = nil then
    FApplicabilityList := TFhirChargeItemDefinitionApplicabilityList.Create;
  result := FApplicabilityList;
end;

function TFhirChargeItemDefinitionPropertyGroup.GetHasApplicabilityList : boolean;
begin
  result := (FApplicabilityList <> nil) and (FApplicabilityList.count > 0);
end;

function TFhirChargeItemDefinitionPropertyGroup.GetPriceComponentList : TFhirChargeItemDefinitionPropertyGroupPriceComponentList;
begin
  if FPriceComponentList = nil then
    FPriceComponentList := TFhirChargeItemDefinitionPropertyGroupPriceComponentList.Create;
  result := FPriceComponentList;
end;

function TFhirChargeItemDefinitionPropertyGroup.GetHasPriceComponentList : boolean;
begin
  result := (FPriceComponentList <> nil) and (FPriceComponentList.count > 0);
end;

{ TFhirChargeItemDefinitionPropertyGroupListEnumerator }

constructor TFhirChargeItemDefinitionPropertyGroupListEnumerator.Create(list : TFhirChargeItemDefinitionPropertyGroupList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirChargeItemDefinitionPropertyGroupListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirChargeItemDefinitionPropertyGroupListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirChargeItemDefinitionPropertyGroupListEnumerator.GetCurrent : TFhirChargeItemDefinitionPropertyGroup;
begin
  Result := FList[FIndex];
end;

function TFhirChargeItemDefinitionPropertyGroupListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirChargeItemDefinitionPropertyGroupList }

procedure TFhirChargeItemDefinitionPropertyGroupList.AddItem(value: TFhirChargeItemDefinitionPropertyGroup);
begin
  assert(value.ClassName = 'TFhirChargeItemDefinitionPropertyGroup', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirChargeItemDefinitionPropertyGroup');
  add(value);
end;

function TFhirChargeItemDefinitionPropertyGroupList.Append: TFhirChargeItemDefinitionPropertyGroup;
begin
  result := TFhirChargeItemDefinitionPropertyGroup.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirChargeItemDefinitionPropertyGroupList.ClearItems;
begin
  Clear;
end;

function TFhirChargeItemDefinitionPropertyGroupList.GetEnumerator : TFhirChargeItemDefinitionPropertyGroupListEnumerator;
begin
  result := TFhirChargeItemDefinitionPropertyGroupListEnumerator.Create(self.link);
end;

function TFhirChargeItemDefinitionPropertyGroupList.Clone: TFhirChargeItemDefinitionPropertyGroupList;
begin
  result := TFhirChargeItemDefinitionPropertyGroupList(inherited Clone);
end;

function TFhirChargeItemDefinitionPropertyGroupList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirChargeItemDefinitionPropertyGroupList.GetItemN(index: Integer): TFhirChargeItemDefinitionPropertyGroup;
begin
  result := TFhirChargeItemDefinitionPropertyGroup(ObjectByIndex[index]);
end;

function TFhirChargeItemDefinitionPropertyGroupList.ItemClass: TFslObjectClass;
begin
  result := TFhirChargeItemDefinitionPropertyGroup;
end;
function TFhirChargeItemDefinitionPropertyGroupList.IndexOf(value: TFhirChargeItemDefinitionPropertyGroup): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirChargeItemDefinitionPropertyGroupList.Insert(index: Integer): TFhirChargeItemDefinitionPropertyGroup;
begin
  result := TFhirChargeItemDefinitionPropertyGroup.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirChargeItemDefinitionPropertyGroupList.InsertItem(index: Integer; value: TFhirChargeItemDefinitionPropertyGroup);
begin
  assert(value is TFhirChargeItemDefinitionPropertyGroup);
  Inherited Insert(index, value);
end;

function TFhirChargeItemDefinitionPropertyGroupList.Item(index: Integer): TFhirChargeItemDefinitionPropertyGroup;
begin
  result := TFhirChargeItemDefinitionPropertyGroup(ObjectByIndex[index]);
end;

function TFhirChargeItemDefinitionPropertyGroupList.Link: TFhirChargeItemDefinitionPropertyGroupList;
begin
  result := TFhirChargeItemDefinitionPropertyGroupList(inherited Link);
end;

procedure TFhirChargeItemDefinitionPropertyGroupList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirChargeItemDefinitionPropertyGroupList.SetItemByIndex(index: Integer; value: TFhirChargeItemDefinitionPropertyGroup);
begin
  assert(value is TFhirChargeItemDefinitionPropertyGroup);
  FhirChargeItemDefinitionPropertyGroups[index] := value;
end;

procedure TFhirChargeItemDefinitionPropertyGroupList.SetItemN(index: Integer; value: TFhirChargeItemDefinitionPropertyGroup);
begin
  assert(value is TFhirChargeItemDefinitionPropertyGroup);
  ObjectByIndex[index] := value;
end;

{ TFhirChargeItemDefinitionPropertyGroupPriceComponent }

constructor TFhirChargeItemDefinitionPropertyGroupPriceComponent.Create;
begin
  inherited;
end;

destructor TFhirChargeItemDefinitionPropertyGroupPriceComponent.Destroy;
begin
  FType_.free;
  FCode.free;
  FFactor.free;
  FAmount.free;
  inherited;
end;

procedure TFhirChargeItemDefinitionPropertyGroupPriceComponent.Assign(oSource : TFslObject);
begin
  inherited;
  type_Element := TFhirChargeItemDefinitionPropertyGroupPriceComponent(oSource).type_Element.Clone;
  code := TFhirChargeItemDefinitionPropertyGroupPriceComponent(oSource).code.Clone;
  factorElement := TFhirChargeItemDefinitionPropertyGroupPriceComponent(oSource).factorElement.Clone;
  amount := TFhirChargeItemDefinitionPropertyGroupPriceComponent(oSource).amount.Clone;
end;

procedure TFhirChargeItemDefinitionPropertyGroupPriceComponent.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'type') Then
     list.add(self.link, 'type', FType_.Link);
  if (child_name = 'code') Then
     list.add(self.link, 'code', FCode.Link);
  if (child_name = 'factor') Then
     list.add(self.link, 'factor', FFactor.Link);
  if (child_name = 'amount') Then
     list.add(self.link, 'amount', FAmount.Link);
end;

procedure TFhirChargeItemDefinitionPropertyGroupPriceComponent.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'type', 'code', false, TFhirEnum, FType_.Link));
  oList.add(TFHIRProperty.create(self, 'code', 'CodeableConcept', false, TFhirCodeableConcept, FCode.Link));
  oList.add(TFHIRProperty.create(self, 'factor', 'decimal', false, TFhirDecimal, FFactor.Link));
  oList.add(TFHIRProperty.create(self, 'amount', 'Money', false, TFhirMoney, FAmount.Link));
end;

function TFhirChargeItemDefinitionPropertyGroupPriceComponent.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'type') then
  begin
    Type_Element := asEnum(SYSTEMS_TFhirInvoicePriceComponentTypeEnum, CODES_TFhirInvoicePriceComponentTypeEnum, propValue);
    result := propValue;
  end
  else if (propName = 'code') then
  begin
    Code := propValue as TFhirCodeableConcept;
    result := propValue;
  end
  else if (propName = 'factor') then
  begin
    FactorElement := asDecimal(propValue);
    result := propValue;
  end
  else if (propName = 'amount') then
  begin
    Amount := propValue as TFhirMoney;
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirChargeItemDefinitionPropertyGroupPriceComponent.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirChargeItemDefinitionPropertyGroupPriceComponent.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'type') then result := TFhirEnum.create(SYSTEMS_TFhirInvoicePriceComponentTypeEnum[InvoicePriceComponentTypeNull], CODES_TFhirInvoicePriceComponentTypeEnum[InvoicePriceComponentTypeNull]) 
  else if (propName = 'code') then result := TFhirCodeableConcept.create()
  else if (propName = 'factor') then result := TFhirDecimal.create()
  else if (propName = 'amount') then result := TFhirMoney.create()
  else result := inherited createPropertyValue(propName);
end;

function TFhirChargeItemDefinitionPropertyGroupPriceComponent.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'type') then result := 'code'
  else if (propName = 'code') then result := 'CodeableConcept'
  else if (propName = 'factor') then result := 'decimal'
  else if (propName = 'amount') then result := 'Money'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirChargeItemDefinitionPropertyGroupPriceComponent.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'type') then Type_Element := nil
  else if (propName = 'code') then CodeElement := nil
  else if (propName = 'factor') then FactorElement := nil
  else if (propName = 'amount') then AmountElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirChargeItemDefinitionPropertyGroupPriceComponent.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'type') then Type_Element := asEnum(SYSTEMS_TFhirInvoicePriceComponentTypeEnum, CODES_TFhirInvoicePriceComponentTypeEnum, new)
  else if (propName = 'code') then CodeElement := new as TFhirCodeableConcept
  else if (propName = 'factor') then FactorElement := asDecimal(new)
  else if (propName = 'amount') then AmountElement := new as TFhirMoney
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirChargeItemDefinitionPropertyGroupPriceComponent.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirChargeItemDefinitionPropertyGroupPriceComponent.fhirType : string;
begin
  result := 'ChargeItemDefinition.propertyGroup.priceComponent';
end;

function TFhirChargeItemDefinitionPropertyGroupPriceComponent.Link : TFhirChargeItemDefinitionPropertyGroupPriceComponent;
begin
  result := TFhirChargeItemDefinitionPropertyGroupPriceComponent(inherited Link);
end;

function TFhirChargeItemDefinitionPropertyGroupPriceComponent.Clone : TFhirChargeItemDefinitionPropertyGroupPriceComponent;
begin
  result := TFhirChargeItemDefinitionPropertyGroupPriceComponent(inherited Clone);
end;

function TFhirChargeItemDefinitionPropertyGroupPriceComponent.equals(other : TObject) : boolean; 
var
  o : TFhirChargeItemDefinitionPropertyGroupPriceComponent;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirChargeItemDefinitionPropertyGroupPriceComponent)) then
    result := false
  else
  begin
    o := TFhirChargeItemDefinitionPropertyGroupPriceComponent(other);
    result := compareDeep(type_Element, o.type_Element, true) and compareDeep(codeElement, o.codeElement, true) and 
      compareDeep(factorElement, o.factorElement, true) and compareDeep(amountElement, o.amountElement, true);
  end;
end;

function TFhirChargeItemDefinitionPropertyGroupPriceComponent.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FType_) and isEmptyProp(FCode) and isEmptyProp(FFactor) and isEmptyProp(FAmount);
end;

procedure TFhirChargeItemDefinitionPropertyGroupPriceComponent.listFieldsInOrder(fields : TStringList);
begin
  inherited listFieldsInOrder(fields);
  fields.add('type');
  fields.add('code');
  fields.add('factor');
  fields.add('amount');
end;

function TFhirChargeItemDefinitionPropertyGroupPriceComponent.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
end;

procedure TFhirChargeItemDefinitionPropertyGroupPriceComponent.SetType_(value : TFhirEnum);
begin
  FType_.free;
  FType_ := value;
end;

function TFhirChargeItemDefinitionPropertyGroupPriceComponent.GetType_ST : TFhirInvoicePriceComponentTypeEnum;
begin
  if FType_ = nil then
    result := TFhirInvoicePriceComponentTypeEnum(0)
  else
    result := TFhirInvoicePriceComponentTypeEnum(StringArrayIndexOfSensitive(CODES_TFhirInvoicePriceComponentTypeEnum, FType_.value));
end;

procedure TFhirChargeItemDefinitionPropertyGroupPriceComponent.SetType_ST(value : TFhirInvoicePriceComponentTypeEnum);
begin
  if ord(value) = 0 then
    Type_Element := nil
  else
    Type_Element := TFhirEnum.create(SYSTEMS_TFhirInvoicePriceComponentTypeEnum[value], CODES_TFhirInvoicePriceComponentTypeEnum[value]);
end;

procedure TFhirChargeItemDefinitionPropertyGroupPriceComponent.SetCode(value : TFhirCodeableConcept);
begin
  FCode.free;
  FCode := value;
end;

procedure TFhirChargeItemDefinitionPropertyGroupPriceComponent.SetFactor(value : TFhirDecimal);
begin
  FFactor.free;
  FFactor := value;
end;

function TFhirChargeItemDefinitionPropertyGroupPriceComponent.GetFactorST : String;
begin
  if FFactor = nil then
    result := ''
  else
    result := FFactor.value;
end;

procedure TFhirChargeItemDefinitionPropertyGroupPriceComponent.SetFactorST(value : String);
begin
  if value <> '' then
  begin
    if FFactor = nil then
      FFactor := TFhirDecimal.create;
    FFactor.value := value
  end
  else if FFactor <> nil then
    FFactor.value := '';
end;

procedure TFhirChargeItemDefinitionPropertyGroupPriceComponent.SetAmount(value : TFhirMoney);
begin
  FAmount.free;
  FAmount := value;
end;

{ TFhirChargeItemDefinitionPropertyGroupPriceComponentListEnumerator }

constructor TFhirChargeItemDefinitionPropertyGroupPriceComponentListEnumerator.Create(list : TFhirChargeItemDefinitionPropertyGroupPriceComponentList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirChargeItemDefinitionPropertyGroupPriceComponentListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirChargeItemDefinitionPropertyGroupPriceComponentListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirChargeItemDefinitionPropertyGroupPriceComponentListEnumerator.GetCurrent : TFhirChargeItemDefinitionPropertyGroupPriceComponent;
begin
  Result := FList[FIndex];
end;

function TFhirChargeItemDefinitionPropertyGroupPriceComponentListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirChargeItemDefinitionPropertyGroupPriceComponentList }

procedure TFhirChargeItemDefinitionPropertyGroupPriceComponentList.AddItem(value: TFhirChargeItemDefinitionPropertyGroupPriceComponent);
begin
  assert(value.ClassName = 'TFhirChargeItemDefinitionPropertyGroupPriceComponent', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirChargeItemDefinitionPropertyGroupPriceComponent');
  add(value);
end;

function TFhirChargeItemDefinitionPropertyGroupPriceComponentList.Append: TFhirChargeItemDefinitionPropertyGroupPriceComponent;
begin
  result := TFhirChargeItemDefinitionPropertyGroupPriceComponent.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirChargeItemDefinitionPropertyGroupPriceComponentList.ClearItems;
begin
  Clear;
end;

function TFhirChargeItemDefinitionPropertyGroupPriceComponentList.GetEnumerator : TFhirChargeItemDefinitionPropertyGroupPriceComponentListEnumerator;
begin
  result := TFhirChargeItemDefinitionPropertyGroupPriceComponentListEnumerator.Create(self.link);
end;

function TFhirChargeItemDefinitionPropertyGroupPriceComponentList.Clone: TFhirChargeItemDefinitionPropertyGroupPriceComponentList;
begin
  result := TFhirChargeItemDefinitionPropertyGroupPriceComponentList(inherited Clone);
end;

function TFhirChargeItemDefinitionPropertyGroupPriceComponentList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirChargeItemDefinitionPropertyGroupPriceComponentList.GetItemN(index: Integer): TFhirChargeItemDefinitionPropertyGroupPriceComponent;
begin
  result := TFhirChargeItemDefinitionPropertyGroupPriceComponent(ObjectByIndex[index]);
end;

function TFhirChargeItemDefinitionPropertyGroupPriceComponentList.ItemClass: TFslObjectClass;
begin
  result := TFhirChargeItemDefinitionPropertyGroupPriceComponent;
end;
function TFhirChargeItemDefinitionPropertyGroupPriceComponentList.IndexOf(value: TFhirChargeItemDefinitionPropertyGroupPriceComponent): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirChargeItemDefinitionPropertyGroupPriceComponentList.Insert(index: Integer): TFhirChargeItemDefinitionPropertyGroupPriceComponent;
begin
  result := TFhirChargeItemDefinitionPropertyGroupPriceComponent.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirChargeItemDefinitionPropertyGroupPriceComponentList.InsertItem(index: Integer; value: TFhirChargeItemDefinitionPropertyGroupPriceComponent);
begin
  assert(value is TFhirChargeItemDefinitionPropertyGroupPriceComponent);
  Inherited Insert(index, value);
end;

function TFhirChargeItemDefinitionPropertyGroupPriceComponentList.Item(index: Integer): TFhirChargeItemDefinitionPropertyGroupPriceComponent;
begin
  result := TFhirChargeItemDefinitionPropertyGroupPriceComponent(ObjectByIndex[index]);
end;

function TFhirChargeItemDefinitionPropertyGroupPriceComponentList.Link: TFhirChargeItemDefinitionPropertyGroupPriceComponentList;
begin
  result := TFhirChargeItemDefinitionPropertyGroupPriceComponentList(inherited Link);
end;

procedure TFhirChargeItemDefinitionPropertyGroupPriceComponentList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirChargeItemDefinitionPropertyGroupPriceComponentList.SetItemByIndex(index: Integer; value: TFhirChargeItemDefinitionPropertyGroupPriceComponent);
begin
  assert(value is TFhirChargeItemDefinitionPropertyGroupPriceComponent);
  FhirChargeItemDefinitionPropertyGroupPriceComponents[index] := value;
end;

procedure TFhirChargeItemDefinitionPropertyGroupPriceComponentList.SetItemN(index: Integer; value: TFhirChargeItemDefinitionPropertyGroupPriceComponent);
begin
  assert(value is TFhirChargeItemDefinitionPropertyGroupPriceComponent);
  ObjectByIndex[index] := value;
end;

{ TFhirChargeItemDefinition }

constructor TFhirChargeItemDefinition.Create;
begin
  inherited;
end;

destructor TFhirChargeItemDefinition.Destroy;
begin
  FDerivedFromUriList.Free;
  FPartOfList.Free;
  FReplacesList.Free;
  FCode.free;
  FInstanceList.Free;
  FApplicabilityList.Free;
  FPropertyGroupList.Free;
  inherited;
end;

procedure TFhirChargeItemDefinition.Assign(oSource : TFslObject);
begin
  inherited;
  if (TFhirChargeItemDefinition(oSource).FDerivedFromUriList = nil) then
  begin
    FDerivedFromUriList.free;
    FDerivedFromUriList := nil;
  end
  else
  begin
    if FDerivedFromUriList = nil then
      FDerivedFromUriList := TFhirUriList.Create;
    FDerivedFromUriList.Assign(TFhirChargeItemDefinition(oSource).FDerivedFromUriList);
  end;
  if (TFhirChargeItemDefinition(oSource).FPartOfList = nil) then
  begin
    FPartOfList.free;
    FPartOfList := nil;
  end
  else
  begin
    if FPartOfList = nil then
      FPartOfList := TFhirCanonicalList.Create;
    FPartOfList.Assign(TFhirChargeItemDefinition(oSource).FPartOfList);
  end;
  if (TFhirChargeItemDefinition(oSource).FReplacesList = nil) then
  begin
    FReplacesList.free;
    FReplacesList := nil;
  end
  else
  begin
    if FReplacesList = nil then
      FReplacesList := TFhirCanonicalList.Create;
    FReplacesList.Assign(TFhirChargeItemDefinition(oSource).FReplacesList);
  end;
  code := TFhirChargeItemDefinition(oSource).code.Clone;
  if (TFhirChargeItemDefinition(oSource).FInstanceList = nil) then
  begin
    FInstanceList.free;
    FInstanceList := nil;
  end
  else
  begin
    if FInstanceList = nil then
      FInstanceList := TFhirReferenceList.Create;
    FInstanceList.Assign(TFhirChargeItemDefinition(oSource).FInstanceList);
  end;
  if (TFhirChargeItemDefinition(oSource).FApplicabilityList = nil) then
  begin
    FApplicabilityList.free;
    FApplicabilityList := nil;
  end
  else
  begin
    if FApplicabilityList = nil then
      FApplicabilityList := TFhirChargeItemDefinitionApplicabilityList.Create;
    FApplicabilityList.Assign(TFhirChargeItemDefinition(oSource).FApplicabilityList);
  end;
  if (TFhirChargeItemDefinition(oSource).FPropertyGroupList = nil) then
  begin
    FPropertyGroupList.free;
    FPropertyGroupList := nil;
  end
  else
  begin
    if FPropertyGroupList = nil then
      FPropertyGroupList := TFhirChargeItemDefinitionPropertyGroupList.Create;
    FPropertyGroupList.Assign(TFhirChargeItemDefinition(oSource).FPropertyGroupList);
  end;
end;

function TFhirChargeItemDefinition.GetResourceType : TFhirResourceType;
begin
  result := frtChargeItemDefinition;
end;

procedure TFhirChargeItemDefinition.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'derivedFromUri') Then
    list.addAll(self, 'derivedFromUri', FDerivedFromUriList);
  if (child_name = 'partOf') Then
    list.addAll(self, 'partOf', FPartOfList);
  if (child_name = 'replaces') Then
    list.addAll(self, 'replaces', FReplacesList);
  if (child_name = 'code') Then
     list.add(self.link, 'code', FCode.Link);
  if (child_name = 'instance') Then
    list.addAll(self, 'instance', FInstanceList);
  if (child_name = 'applicability') Then
    list.addAll(self, 'applicability', FApplicabilityList);
  if (child_name = 'propertyGroup') Then
    list.addAll(self, 'propertyGroup', FPropertyGroupList);
end;

procedure TFhirChargeItemDefinition.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'derivedFromUri', 'uri', true, TFhirUri, FDerivedFromUriList.Link));
  oList.add(TFHIRProperty.create(self, 'partOf', 'canonical', true, TFhirCanonical, FPartOfList.Link));
  oList.add(TFHIRProperty.create(self, 'replaces', 'canonical', true, TFhirCanonical, FReplacesList.Link));
  oList.add(TFHIRProperty.create(self, 'code', 'CodeableConcept', false, TFhirCodeableConcept, FCode.Link));
  oList.add(TFHIRProperty.create(self, 'instance', 'Reference', true, TFhirReference, FInstanceList.Link));
  oList.add(TFHIRProperty.create(self, 'applicability', 'BackboneElement', true, TFhirChargeItemDefinitionApplicability, FApplicabilityList.Link));
  oList.add(TFHIRProperty.create(self, 'propertyGroup', 'BackboneElement', true, TFhirChargeItemDefinitionPropertyGroup, FPropertyGroupList.Link));
end;

function TFhirChargeItemDefinition.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'derivedFromUri') then
  begin
    DerivedFromUriList.add(asUri(propValue)){2};     result := propValue;

  end
  else if (propName = 'partOf') then
  begin
    PartOfList.add(asCanonical(propValue)){2};     result := propValue;

  end
  else if (propName = 'replaces') then
  begin
    ReplacesList.add(asCanonical(propValue)){2};     result := propValue;

  end
  else if (propName = 'code') then
  begin
    Code := propValue as TFhirCodeableConcept;
    result := propValue;
  end
  else if (propName = 'instance') then
  begin
    InstanceList.add(propValue as TFhirReference);
    result := propValue;
  end
  else if (propName = 'applicability') then
  begin
    ApplicabilityList.add(propValue as TFhirChargeItemDefinitionApplicability);
    result := propValue;
  end
  else if (propName = 'propertyGroup') then
  begin
    PropertyGroupList.add(propValue as TFhirChargeItemDefinitionPropertyGroup);
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirChargeItemDefinition.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'derivedFromUri') then DerivedFromUriList.insertItem(index, asUri(propValue))
  else if (propName = 'partOf') then PartOfList.insertItem(index, asCanonical(propValue))
  else if (propName = 'replaces') then ReplacesList.insertItem(index, asCanonical(propValue))
  else if (propName = 'instance') then InstanceList.insertItem(index, propValue as TFhirReference)
  else if (propName = 'applicability') then ApplicabilityList.insertItem(index, propValue as TFhirChargeItemDefinitionApplicability)
  else if (propName = 'propertyGroup') then PropertyGroupList.insertItem(index, propValue as TFhirChargeItemDefinitionPropertyGroup)
  else inherited;
end;

function TFhirChargeItemDefinition.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'derivedFromUri') then result := DerivedFromUriList.new()
  else if (propName = 'partOf') then result := PartOfList.new()
  else if (propName = 'replaces') then result := ReplacesList.new()
  else if (propName = 'code') then result := TFhirCodeableConcept.create()
  else if (propName = 'instance') then result := InstanceList.new()
  else if (propName = 'applicability') then result := ApplicabilityList.new()
  else if (propName = 'propertyGroup') then result := PropertyGroupList.new()
  else result := inherited createPropertyValue(propName);
end;

function TFhirChargeItemDefinition.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'derivedFromUri') then result := 'uri'
  else if (propName = 'partOf') then result := 'canonical'
  else if (propName = 'replaces') then result := 'canonical'
  else if (propName = 'code') then result := 'CodeableConcept'
  else if (propName = 'instance') then result := 'Reference'
  else if (propName = 'applicability') then result := 'BackboneElement'
  else if (propName = 'propertyGroup') then result := 'BackboneElement'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirChargeItemDefinition.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'derivedFromUri') then deletePropertyValue('derivedFromUri', DerivedFromUriList, value)
  else if (propName = 'partOf') then deletePropertyValue('partOf', PartOfList, value)
  else if (propName = 'replaces') then deletePropertyValue('replaces', ReplacesList, value)
  else if (propName = 'code') then CodeElement := nil
  else if (propName = 'instance') then deletePropertyValue('instance', InstanceList, value)
  else if (propName = 'applicability') then deletePropertyValue('applicability', ApplicabilityList, value)
  else if (propName = 'propertyGroup') then deletePropertyValue('propertyGroup', PropertyGroupList, value)
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirChargeItemDefinition.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'derivedFromUri') then replacePropertyValue('derivedFromUri', DerivedFromUriList, existing, new)
  else if (propName = 'partOf') then replacePropertyValue('partOf', PartOfList, existing, new)
  else if (propName = 'replaces') then replacePropertyValue('replaces', ReplacesList, existing, new)
  else if (propName = 'code') then CodeElement := new as TFhirCodeableConcept
  else if (propName = 'instance') then replacePropertyValue('instance', InstanceList, existing, new)
  else if (propName = 'applicability') then replacePropertyValue('applicability', ApplicabilityList, existing, new)
  else if (propName = 'propertyGroup') then replacePropertyValue('propertyGroup', PropertyGroupList, existing, new)
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirChargeItemDefinition.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'derivedFromUri') then DerivedFromUriList.move(source, destination)
  else if (propName = 'partOf') then PartOfList.move(source, destination)
  else if (propName = 'replaces') then ReplacesList.move(source, destination)
  else if (propName = 'instance') then InstanceList.move(source, destination)
  else if (propName = 'applicability') then ApplicabilityList.move(source, destination)
  else if (propName = 'propertyGroup') then PropertyGroupList.move(source, destination)
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirChargeItemDefinition.fhirType : string;
begin
  result := 'ChargeItemDefinition';
end;

function TFhirChargeItemDefinition.Link : TFhirChargeItemDefinition;
begin
  result := TFhirChargeItemDefinition(inherited Link);
end;

function TFhirChargeItemDefinition.Clone : TFhirChargeItemDefinition;
begin
  result := TFhirChargeItemDefinition(inherited Clone);
end;

function TFhirChargeItemDefinition.equals(other : TObject) : boolean; 
var
  o : TFhirChargeItemDefinition;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirChargeItemDefinition)) then
    result := false
  else
  begin
    o := TFhirChargeItemDefinition(other);
    result := compareDeep(derivedFromUriList, o.derivedFromUriList, true) and compareDeep(partOfList, o.partOfList, true) and 
      compareDeep(replacesList, o.replacesList, true) and compareDeep(codeElement, o.codeElement, true) and 
      compareDeep(instanceList, o.instanceList, true) and compareDeep(applicabilityList, o.applicabilityList, true) and 
      compareDeep(propertyGroupList, o.propertyGroupList, true);
  end;
end;

function TFhirChargeItemDefinition.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FderivedFromUriList) and isEmptyProp(FpartOfList) and isEmptyProp(FreplacesList) and isEmptyProp(FCode) and isEmptyProp(FinstanceList) and isEmptyProp(FapplicabilityList) and isEmptyProp(FpropertyGroupList);
end;

procedure TFhirChargeItemDefinition.listFieldsInOrder(fields : TStringList);
begin
  inherited listFieldsInOrder(fields);
  fields.add('url');
  fields.add('identifier');
  fields.add('version');
  fields.add('title');
  fields.add('derivedFromUri');
  fields.add('partOf');
  fields.add('replaces');
  fields.add('status');
  fields.add('experimental');
  fields.add('date');
  fields.add('publisher');
  fields.add('contact');
  fields.add('description');
  fields.add('useContext');
  fields.add('jurisdiction');
  fields.add('copyright');
  fields.add('approvalDate');
  fields.add('lastReviewDate');
  fields.add('effectivePeriod');
  fields.add('code');
  fields.add('instance');
  fields.add('applicability');
  fields.add('propertyGroup');
end;

function TFhirChargeItemDefinition.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FDerivedFromUriList.sizeInBytes(magic));
  inc(result, FPartOfList.sizeInBytes(magic));
  inc(result, FReplacesList.sizeInBytes(magic));
  inc(result, FInstanceList.sizeInBytes(magic));
  inc(result, FApplicabilityList.sizeInBytes(magic));
  inc(result, FPropertyGroupList.sizeInBytes(magic));
end;

procedure TFhirChargeItemDefinition.SetUrl(value : TFhirUri);
begin
  FUrl.free;
  FUrl := value;
end;

function TFhirChargeItemDefinition.GetUrlST : String;
begin
  if FUrl = nil then
    result := ''
  else
    result := FUrl.value;
end;

procedure TFhirChargeItemDefinition.SetUrlST(value : String);
begin
  if value <> '' then
  begin
    if FUrl = nil then
      FUrl := TFhirUri.create;
    FUrl.value := value
  end
  else if FUrl <> nil then
    FUrl.value := '';
end;

function TFhirChargeItemDefinition.GetIdentifierList : TFhirIdentifierList;
begin
  if FIdentifierList = nil then
    FIdentifierList := TFhirIdentifierList.Create;
  result := FIdentifierList;
end;

function TFhirChargeItemDefinition.GetHasIdentifierList : boolean;
begin
  result := (FIdentifierList <> nil) and (FIdentifierList.count > 0);
end;

procedure TFhirChargeItemDefinition.SetVersion(value : TFhirString);
begin
  FVersion.free;
  FVersion := value;
end;

function TFhirChargeItemDefinition.GetVersionST : String;
begin
  if FVersion = nil then
    result := ''
  else
    result := FVersion.value;
end;

procedure TFhirChargeItemDefinition.SetVersionST(value : String);
begin
  if value <> '' then
  begin
    if FVersion = nil then
      FVersion := TFhirString.create;
    FVersion.value := value
  end
  else if FVersion <> nil then
    FVersion.value := '';
end;

procedure TFhirChargeItemDefinition.SetTitle(value : TFhirString);
begin
  FTitle.free;
  FTitle := value;
end;

function TFhirChargeItemDefinition.GetTitleST : String;
begin
  if FTitle = nil then
    result := ''
  else
    result := FTitle.value;
end;

procedure TFhirChargeItemDefinition.SetTitleST(value : String);
begin
  if value <> '' then
  begin
    if FTitle = nil then
      FTitle := TFhirString.create;
    FTitle.value := value
  end
  else if FTitle <> nil then
    FTitle.value := '';
end;

function TFhirChargeItemDefinition.GetDerivedFromUriList : TFhirUriList;
begin
  if FDerivedFromUriList = nil then
    FDerivedFromUriList := TFhirUriList.Create;
  result := FDerivedFromUriList;
end;

function TFhirChargeItemDefinition.GetHasDerivedFromUriList : boolean;
begin
  result := (FDerivedFromUriList <> nil) and (FDerivedFromUriList.count > 0);
end;

function TFhirChargeItemDefinition.GetPartOfList : TFhirCanonicalList;
begin
  if FPartOfList = nil then
    FPartOfList := TFhirCanonicalList.Create;
  result := FPartOfList;
end;

function TFhirChargeItemDefinition.GetHasPartOfList : boolean;
begin
  result := (FPartOfList <> nil) and (FPartOfList.count > 0);
end;

function TFhirChargeItemDefinition.GetReplacesList : TFhirCanonicalList;
begin
  if FReplacesList = nil then
    FReplacesList := TFhirCanonicalList.Create;
  result := FReplacesList;
end;

function TFhirChargeItemDefinition.GetHasReplacesList : boolean;
begin
  result := (FReplacesList <> nil) and (FReplacesList.count > 0);
end;

procedure TFhirChargeItemDefinition.SetStatus(value : TFhirEnum);
begin
  FStatus.free;
  FStatus := value;
end;

function TFhirChargeItemDefinition.GetStatusST : TFhirPublicationStatusEnum;
begin
  if FStatus = nil then
    result := TFhirPublicationStatusEnum(0)
  else
    result := TFhirPublicationStatusEnum(StringArrayIndexOfSensitive(CODES_TFhirPublicationStatusEnum, FStatus.value));
end;

procedure TFhirChargeItemDefinition.SetStatusST(value : TFhirPublicationStatusEnum);
begin
  if ord(value) = 0 then
    StatusElement := nil
  else
    StatusElement := TFhirEnum.create(SYSTEMS_TFhirPublicationStatusEnum[value], CODES_TFhirPublicationStatusEnum[value]);
end;

procedure TFhirChargeItemDefinition.SetExperimental(value : TFhirBoolean);
begin
  FExperimental.free;
  FExperimental := value;
end;

function TFhirChargeItemDefinition.GetExperimentalST : Boolean;
begin
  if FExperimental = nil then
    result := false
  else
    result := FExperimental.value;
end;

procedure TFhirChargeItemDefinition.SetExperimentalST(value : Boolean);
begin
  if FExperimental = nil then
    FExperimental := TFhirBoolean.create;
  FExperimental.value := value
end;

procedure TFhirChargeItemDefinition.SetDate(value : TFhirDateTime);
begin
  FDate.free;
  FDate := value;
end;

function TFhirChargeItemDefinition.GetDateST : TFslDateTime;
begin
  if FDate = nil then
    result := TFslDateTime.makeNull
  else
    result := FDate.value;
end;

procedure TFhirChargeItemDefinition.SetDateST(value : TFslDateTime);
begin
  if FDate = nil then
    FDate := TFhirDateTime.create;
  FDate.value := value
end;

procedure TFhirChargeItemDefinition.SetPublisher(value : TFhirString);
begin
  FPublisher.free;
  FPublisher := value;
end;

function TFhirChargeItemDefinition.GetPublisherST : String;
begin
  if FPublisher = nil then
    result := ''
  else
    result := FPublisher.value;
end;

procedure TFhirChargeItemDefinition.SetPublisherST(value : String);
begin
  if value <> '' then
  begin
    if FPublisher = nil then
      FPublisher := TFhirString.create;
    FPublisher.value := value
  end
  else if FPublisher <> nil then
    FPublisher.value := '';
end;

function TFhirChargeItemDefinition.GetContactList : TFhirContactDetailList;
begin
  if FContactList = nil then
    FContactList := TFhirContactDetailList.Create;
  result := FContactList;
end;

function TFhirChargeItemDefinition.GetHasContactList : boolean;
begin
  result := (FContactList <> nil) and (FContactList.count > 0);
end;

procedure TFhirChargeItemDefinition.SetDescription(value : TFhirMarkdown);
begin
  FDescription.free;
  FDescription := value;
end;

function TFhirChargeItemDefinition.GetDescriptionST : String;
begin
  if FDescription = nil then
    result := ''
  else
    result := FDescription.value;
end;

procedure TFhirChargeItemDefinition.SetDescriptionST(value : String);
begin
  if value <> '' then
  begin
    if FDescription = nil then
      FDescription := TFhirMarkdown.create;
    FDescription.value := value
  end
  else if FDescription <> nil then
    FDescription.value := '';
end;

function TFhirChargeItemDefinition.GetUseContextList : TFhirUsageContextList;
begin
  if FUseContextList = nil then
    FUseContextList := TFhirUsageContextList.Create;
  result := FUseContextList;
end;

function TFhirChargeItemDefinition.GetHasUseContextList : boolean;
begin
  result := (FUseContextList <> nil) and (FUseContextList.count > 0);
end;

function TFhirChargeItemDefinition.GetJurisdictionList : TFhirCodeableConceptList;
begin
  if FJurisdictionList = nil then
    FJurisdictionList := TFhirCodeableConceptList.Create;
  result := FJurisdictionList;
end;

function TFhirChargeItemDefinition.GetHasJurisdictionList : boolean;
begin
  result := (FJurisdictionList <> nil) and (FJurisdictionList.count > 0);
end;

procedure TFhirChargeItemDefinition.SetCopyright(value : TFhirMarkdown);
begin
  FCopyright.free;
  FCopyright := value;
end;

function TFhirChargeItemDefinition.GetCopyrightST : String;
begin
  if FCopyright = nil then
    result := ''
  else
    result := FCopyright.value;
end;

procedure TFhirChargeItemDefinition.SetCopyrightST(value : String);
begin
  if value <> '' then
  begin
    if FCopyright = nil then
      FCopyright := TFhirMarkdown.create;
    FCopyright.value := value
  end
  else if FCopyright <> nil then
    FCopyright.value := '';
end;

procedure TFhirChargeItemDefinition.SetApprovalDate(value : TFhirDate);
begin
  FApprovalDate.free;
  FApprovalDate := value;
end;

function TFhirChargeItemDefinition.GetApprovalDateST : TFslDateTime;
begin
  if FApprovalDate = nil then
    result := TFslDateTime.makeNull
  else
    result := FApprovalDate.value;
end;

procedure TFhirChargeItemDefinition.SetApprovalDateST(value : TFslDateTime);
begin
  if FApprovalDate = nil then
    FApprovalDate := TFhirDate.create;
  FApprovalDate.value := value
end;

procedure TFhirChargeItemDefinition.SetLastReviewDate(value : TFhirDate);
begin
  FLastReviewDate.free;
  FLastReviewDate := value;
end;

function TFhirChargeItemDefinition.GetLastReviewDateST : TFslDateTime;
begin
  if FLastReviewDate = nil then
    result := TFslDateTime.makeNull
  else
    result := FLastReviewDate.value;
end;

procedure TFhirChargeItemDefinition.SetLastReviewDateST(value : TFslDateTime);
begin
  if FLastReviewDate = nil then
    FLastReviewDate := TFhirDate.create;
  FLastReviewDate.value := value
end;

procedure TFhirChargeItemDefinition.SetEffectivePeriod(value : TFhirPeriod);
begin
  FEffectivePeriod.free;
  FEffectivePeriod := value;
end;

procedure TFhirChargeItemDefinition.SetCode(value : TFhirCodeableConcept);
begin
  FCode.free;
  FCode := value;
end;

function TFhirChargeItemDefinition.GetInstanceList : TFhirReferenceList;
begin
  if FInstanceList = nil then
    FInstanceList := TFhirReferenceList.Create;
  result := FInstanceList;
end;

function TFhirChargeItemDefinition.GetHasInstanceList : boolean;
begin
  result := (FInstanceList <> nil) and (FInstanceList.count > 0);
end;

function TFhirChargeItemDefinition.GetApplicabilityList : TFhirChargeItemDefinitionApplicabilityList;
begin
  if FApplicabilityList = nil then
    FApplicabilityList := TFhirChargeItemDefinitionApplicabilityList.Create;
  result := FApplicabilityList;
end;

function TFhirChargeItemDefinition.GetHasApplicabilityList : boolean;
begin
  result := (FApplicabilityList <> nil) and (FApplicabilityList.count > 0);
end;

function TFhirChargeItemDefinition.GetPropertyGroupList : TFhirChargeItemDefinitionPropertyGroupList;
begin
  if FPropertyGroupList = nil then
    FPropertyGroupList := TFhirChargeItemDefinitionPropertyGroupList.Create;
  result := FPropertyGroupList;
end;

function TFhirChargeItemDefinition.GetHasPropertyGroupList : boolean;
begin
  result := (FPropertyGroupList <> nil) and (FPropertyGroupList.count > 0);
end;

{ TFhirChargeItemDefinitionListEnumerator }

constructor TFhirChargeItemDefinitionListEnumerator.Create(list : TFhirChargeItemDefinitionList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirChargeItemDefinitionListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirChargeItemDefinitionListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirChargeItemDefinitionListEnumerator.GetCurrent : TFhirChargeItemDefinition;
begin
  Result := FList[FIndex];
end;

function TFhirChargeItemDefinitionListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirChargeItemDefinitionList }

procedure TFhirChargeItemDefinitionList.AddItem(value: TFhirChargeItemDefinition);
begin
  assert(value.ClassName = 'TFhirChargeItemDefinition', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirChargeItemDefinition');
  add(value);
end;

function TFhirChargeItemDefinitionList.Append: TFhirChargeItemDefinition;
begin
  result := TFhirChargeItemDefinition.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirChargeItemDefinitionList.ClearItems;
begin
  Clear;
end;

function TFhirChargeItemDefinitionList.GetEnumerator : TFhirChargeItemDefinitionListEnumerator;
begin
  result := TFhirChargeItemDefinitionListEnumerator.Create(self.link);
end;

function TFhirChargeItemDefinitionList.Clone: TFhirChargeItemDefinitionList;
begin
  result := TFhirChargeItemDefinitionList(inherited Clone);
end;

function TFhirChargeItemDefinitionList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirChargeItemDefinitionList.GetItemN(index: Integer): TFhirChargeItemDefinition;
begin
  result := TFhirChargeItemDefinition(ObjectByIndex[index]);
end;

function TFhirChargeItemDefinitionList.ItemClass: TFslObjectClass;
begin
  result := TFhirChargeItemDefinition;
end;
function TFhirChargeItemDefinitionList.IndexOf(value: TFhirChargeItemDefinition): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirChargeItemDefinitionList.Insert(index: Integer): TFhirChargeItemDefinition;
begin
  result := TFhirChargeItemDefinition.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirChargeItemDefinitionList.InsertItem(index: Integer; value: TFhirChargeItemDefinition);
begin
  assert(value is TFhirChargeItemDefinition);
  Inherited Insert(index, value);
end;

function TFhirChargeItemDefinitionList.Item(index: Integer): TFhirChargeItemDefinition;
begin
  result := TFhirChargeItemDefinition(ObjectByIndex[index]);
end;

function TFhirChargeItemDefinitionList.Link: TFhirChargeItemDefinitionList;
begin
  result := TFhirChargeItemDefinitionList(inherited Link);
end;

procedure TFhirChargeItemDefinitionList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirChargeItemDefinitionList.SetItemByIndex(index: Integer; value: TFhirChargeItemDefinition);
begin
  assert(value is TFhirChargeItemDefinition);
  FhirChargeItemDefinitions[index] := value;
end;

procedure TFhirChargeItemDefinitionList.SetItemN(index: Integer; value: TFhirChargeItemDefinition);
begin
  assert(value is TFhirChargeItemDefinition);
  ObjectByIndex[index] := value;
end;

{$ENDIF FHIR_CHARGEITEMDEFINITION}
{$IFDEF FHIR_CITATION}
{ TFhirCitationClassification }

constructor TFhirCitationClassification.Create;
begin
  inherited;
end;

destructor TFhirCitationClassification.Destroy;
begin
  FType_.free;
  FClassifierList.Free;
  inherited;
end;

procedure TFhirCitationClassification.Assign(oSource : TFslObject);
begin
  inherited;
  type_ := TFhirCitationClassification(oSource).type_.Clone;
  if (TFhirCitationClassification(oSource).FClassifierList = nil) then
  begin
    FClassifierList.free;
    FClassifierList := nil;
  end
  else
  begin
    if FClassifierList = nil then
      FClassifierList := TFhirCodeableConceptList.Create;
    FClassifierList.Assign(TFhirCitationClassification(oSource).FClassifierList);
  end;
end;

procedure TFhirCitationClassification.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'type') Then
     list.add(self.link, 'type', FType_.Link);
  if (child_name = 'classifier') Then
    list.addAll(self, 'classifier', FClassifierList);
end;

procedure TFhirCitationClassification.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'type', 'CodeableConcept', false, TFhirCodeableConcept, FType_.Link));
  oList.add(TFHIRProperty.create(self, 'classifier', 'CodeableConcept', true, TFhirCodeableConcept, FClassifierList.Link));
end;

function TFhirCitationClassification.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'type') then
  begin
    Type_ := propValue as TFhirCodeableConcept;
    result := propValue;
  end
  else if (propName = 'classifier') then
  begin
    ClassifierList.add(propValue as TFhirCodeableConcept);
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirCitationClassification.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'classifier') then ClassifierList.insertItem(index, propValue as TFhirCodeableConcept)
  else inherited;
end;

function TFhirCitationClassification.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'type') then result := TFhirCodeableConcept.create()
  else if (propName = 'classifier') then result := ClassifierList.new()
  else result := inherited createPropertyValue(propName);
end;

function TFhirCitationClassification.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'type') then result := 'CodeableConcept'
  else if (propName = 'classifier') then result := 'CodeableConcept'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirCitationClassification.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'type') then Type_Element := nil
  else if (propName = 'classifier') then deletePropertyValue('classifier', ClassifierList, value)
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirCitationClassification.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'type') then Type_Element := new as TFhirCodeableConcept
  else if (propName = 'classifier') then replacePropertyValue('classifier', ClassifierList, existing, new)
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirCitationClassification.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'classifier') then ClassifierList.move(source, destination)
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirCitationClassification.fhirType : string;
begin
  result := 'Citation.classification';
end;

function TFhirCitationClassification.Link : TFhirCitationClassification;
begin
  result := TFhirCitationClassification(inherited Link);
end;

function TFhirCitationClassification.Clone : TFhirCitationClassification;
begin
  result := TFhirCitationClassification(inherited Clone);
end;

function TFhirCitationClassification.equals(other : TObject) : boolean; 
var
  o : TFhirCitationClassification;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirCitationClassification)) then
    result := false
  else
  begin
    o := TFhirCitationClassification(other);
    result := compareDeep(type_Element, o.type_Element, true) and compareDeep(classifierList, o.classifierList, true);
  end;
end;

function TFhirCitationClassification.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FType_) and isEmptyProp(FclassifierList);
end;

procedure TFhirCitationClassification.listFieldsInOrder(fields : TStringList);
begin
  inherited listFieldsInOrder(fields);
  fields.add('type');
  fields.add('classifier');
end;

function TFhirCitationClassification.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FClassifierList.sizeInBytes(magic));
end;

procedure TFhirCitationClassification.SetType_(value : TFhirCodeableConcept);
begin
  FType_.free;
  FType_ := value;
end;

function TFhirCitationClassification.GetClassifierList : TFhirCodeableConceptList;
begin
  if FClassifierList = nil then
    FClassifierList := TFhirCodeableConceptList.Create;
  result := FClassifierList;
end;

function TFhirCitationClassification.GetHasClassifierList : boolean;
begin
  result := (FClassifierList <> nil) and (FClassifierList.count > 0);
end;

{ TFhirCitationClassificationListEnumerator }

constructor TFhirCitationClassificationListEnumerator.Create(list : TFhirCitationClassificationList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirCitationClassificationListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirCitationClassificationListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirCitationClassificationListEnumerator.GetCurrent : TFhirCitationClassification;
begin
  Result := FList[FIndex];
end;

function TFhirCitationClassificationListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirCitationClassificationList }

procedure TFhirCitationClassificationList.AddItem(value: TFhirCitationClassification);
begin
  assert(value.ClassName = 'TFhirCitationClassification', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirCitationClassification');
  add(value);
end;

function TFhirCitationClassificationList.Append: TFhirCitationClassification;
begin
  result := TFhirCitationClassification.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirCitationClassificationList.ClearItems;
begin
  Clear;
end;

function TFhirCitationClassificationList.GetEnumerator : TFhirCitationClassificationListEnumerator;
begin
  result := TFhirCitationClassificationListEnumerator.Create(self.link);
end;

function TFhirCitationClassificationList.Clone: TFhirCitationClassificationList;
begin
  result := TFhirCitationClassificationList(inherited Clone);
end;

function TFhirCitationClassificationList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirCitationClassificationList.GetItemN(index: Integer): TFhirCitationClassification;
begin
  result := TFhirCitationClassification(ObjectByIndex[index]);
end;

function TFhirCitationClassificationList.ItemClass: TFslObjectClass;
begin
  result := TFhirCitationClassification;
end;
function TFhirCitationClassificationList.IndexOf(value: TFhirCitationClassification): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirCitationClassificationList.Insert(index: Integer): TFhirCitationClassification;
begin
  result := TFhirCitationClassification.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirCitationClassificationList.InsertItem(index: Integer; value: TFhirCitationClassification);
begin
  assert(value is TFhirCitationClassification);
  Inherited Insert(index, value);
end;

function TFhirCitationClassificationList.Item(index: Integer): TFhirCitationClassification;
begin
  result := TFhirCitationClassification(ObjectByIndex[index]);
end;

function TFhirCitationClassificationList.Link: TFhirCitationClassificationList;
begin
  result := TFhirCitationClassificationList(inherited Link);
end;

procedure TFhirCitationClassificationList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirCitationClassificationList.SetItemByIndex(index: Integer; value: TFhirCitationClassification);
begin
  assert(value is TFhirCitationClassification);
  FhirCitationClassifications[index] := value;
end;

procedure TFhirCitationClassificationList.SetItemN(index: Integer; value: TFhirCitationClassification);
begin
  assert(value is TFhirCitationClassification);
  ObjectByIndex[index] := value;
end;

{ TFhirCitationStatusDate }

constructor TFhirCitationStatusDate.Create;
begin
  inherited;
end;

destructor TFhirCitationStatusDate.Destroy;
begin
  FActivity.free;
  FActual.free;
  FPeriod.free;
  inherited;
end;

procedure TFhirCitationStatusDate.Assign(oSource : TFslObject);
begin
  inherited;
  activity := TFhirCitationStatusDate(oSource).activity.Clone;
  actualElement := TFhirCitationStatusDate(oSource).actualElement.Clone;
  period := TFhirCitationStatusDate(oSource).period.Clone;
end;

procedure TFhirCitationStatusDate.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'activity') Then
     list.add(self.link, 'activity', FActivity.Link);
  if (child_name = 'actual') Then
     list.add(self.link, 'actual', FActual.Link);
  if (child_name = 'period') Then
     list.add(self.link, 'period', FPeriod.Link);
end;

procedure TFhirCitationStatusDate.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'activity', 'CodeableConcept', false, TFhirCodeableConcept, FActivity.Link));
  oList.add(TFHIRProperty.create(self, 'actual', 'boolean', false, TFhirBoolean, FActual.Link));
  oList.add(TFHIRProperty.create(self, 'period', 'Period', false, TFhirPeriod, FPeriod.Link));
end;

function TFhirCitationStatusDate.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'activity') then
  begin
    Activity := propValue as TFhirCodeableConcept;
    result := propValue;
  end
  else if (propName = 'actual') then
  begin
    ActualElement := asBoolean(propValue);
    result := propValue;
  end
  else if (propName = 'period') then
  begin
    Period := propValue as TFhirPeriod;
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirCitationStatusDate.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirCitationStatusDate.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'activity') then result := TFhirCodeableConcept.create()
  else if (propName = 'actual') then result := TFhirBoolean.create()
  else if (propName = 'period') then result := TFhirPeriod.create()
  else result := inherited createPropertyValue(propName);
end;

function TFhirCitationStatusDate.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'activity') then result := 'CodeableConcept'
  else if (propName = 'actual') then result := 'boolean'
  else if (propName = 'period') then result := 'Period'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirCitationStatusDate.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'activity') then ActivityElement := nil
  else if (propName = 'actual') then ActualElement := nil
  else if (propName = 'period') then PeriodElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirCitationStatusDate.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'activity') then ActivityElement := new as TFhirCodeableConcept
  else if (propName = 'actual') then ActualElement := asBoolean(new)
  else if (propName = 'period') then PeriodElement := new as TFhirPeriod
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirCitationStatusDate.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirCitationStatusDate.fhirType : string;
begin
  result := 'Citation.statusDate';
end;

function TFhirCitationStatusDate.Link : TFhirCitationStatusDate;
begin
  result := TFhirCitationStatusDate(inherited Link);
end;

function TFhirCitationStatusDate.Clone : TFhirCitationStatusDate;
begin
  result := TFhirCitationStatusDate(inherited Clone);
end;

function TFhirCitationStatusDate.equals(other : TObject) : boolean; 
var
  o : TFhirCitationStatusDate;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirCitationStatusDate)) then
    result := false
  else
  begin
    o := TFhirCitationStatusDate(other);
    result := compareDeep(activityElement, o.activityElement, true) and compareDeep(actualElement, o.actualElement, true) and 
      compareDeep(periodElement, o.periodElement, true);
  end;
end;

function TFhirCitationStatusDate.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FActivity) and isEmptyProp(FActual) and isEmptyProp(FPeriod);
end;

procedure TFhirCitationStatusDate.listFieldsInOrder(fields : TStringList);
begin
  inherited listFieldsInOrder(fields);
  fields.add('activity');
  fields.add('actual');
  fields.add('period');
end;

function TFhirCitationStatusDate.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
end;

procedure TFhirCitationStatusDate.SetActivity(value : TFhirCodeableConcept);
begin
  FActivity.free;
  FActivity := value;
end;

procedure TFhirCitationStatusDate.SetActual(value : TFhirBoolean);
begin
  FActual.free;
  FActual := value;
end;

function TFhirCitationStatusDate.GetActualST : Boolean;
begin
  if FActual = nil then
    result := false
  else
    result := FActual.value;
end;

procedure TFhirCitationStatusDate.SetActualST(value : Boolean);
begin
  if FActual = nil then
    FActual := TFhirBoolean.create;
  FActual.value := value
end;

procedure TFhirCitationStatusDate.SetPeriod(value : TFhirPeriod);
begin
  FPeriod.free;
  FPeriod := value;
end;

{ TFhirCitationStatusDateListEnumerator }

constructor TFhirCitationStatusDateListEnumerator.Create(list : TFhirCitationStatusDateList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirCitationStatusDateListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirCitationStatusDateListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirCitationStatusDateListEnumerator.GetCurrent : TFhirCitationStatusDate;
begin
  Result := FList[FIndex];
end;

function TFhirCitationStatusDateListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirCitationStatusDateList }

procedure TFhirCitationStatusDateList.AddItem(value: TFhirCitationStatusDate);
begin
  assert(value.ClassName = 'TFhirCitationStatusDate', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirCitationStatusDate');
  add(value);
end;

function TFhirCitationStatusDateList.Append: TFhirCitationStatusDate;
begin
  result := TFhirCitationStatusDate.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirCitationStatusDateList.ClearItems;
begin
  Clear;
end;

function TFhirCitationStatusDateList.GetEnumerator : TFhirCitationStatusDateListEnumerator;
begin
  result := TFhirCitationStatusDateListEnumerator.Create(self.link);
end;

function TFhirCitationStatusDateList.Clone: TFhirCitationStatusDateList;
begin
  result := TFhirCitationStatusDateList(inherited Clone);
end;

function TFhirCitationStatusDateList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirCitationStatusDateList.GetItemN(index: Integer): TFhirCitationStatusDate;
begin
  result := TFhirCitationStatusDate(ObjectByIndex[index]);
end;

function TFhirCitationStatusDateList.ItemClass: TFslObjectClass;
begin
  result := TFhirCitationStatusDate;
end;
function TFhirCitationStatusDateList.IndexOf(value: TFhirCitationStatusDate): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirCitationStatusDateList.Insert(index: Integer): TFhirCitationStatusDate;
begin
  result := TFhirCitationStatusDate.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirCitationStatusDateList.InsertItem(index: Integer; value: TFhirCitationStatusDate);
begin
  assert(value is TFhirCitationStatusDate);
  Inherited Insert(index, value);
end;

function TFhirCitationStatusDateList.Item(index: Integer): TFhirCitationStatusDate;
begin
  result := TFhirCitationStatusDate(ObjectByIndex[index]);
end;

function TFhirCitationStatusDateList.Link: TFhirCitationStatusDateList;
begin
  result := TFhirCitationStatusDateList(inherited Link);
end;

procedure TFhirCitationStatusDateList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirCitationStatusDateList.SetItemByIndex(index: Integer; value: TFhirCitationStatusDate);
begin
  assert(value is TFhirCitationStatusDate);
  FhirCitationStatusDates[index] := value;
end;

procedure TFhirCitationStatusDateList.SetItemN(index: Integer; value: TFhirCitationStatusDate);
begin
  assert(value is TFhirCitationStatusDate);
  ObjectByIndex[index] := value;
end;

{ TFhirCitationRelatesTo }

constructor TFhirCitationRelatesTo.Create;
begin
  inherited;
end;

destructor TFhirCitationRelatesTo.Destroy;
begin
  FRelationshipType.free;
  FTargetClassifierList.Free;
  FTarget.free;
  inherited;
end;

procedure TFhirCitationRelatesTo.Assign(oSource : TFslObject);
begin
  inherited;
  relationshipType := TFhirCitationRelatesTo(oSource).relationshipType.Clone;
  if (TFhirCitationRelatesTo(oSource).FTargetClassifierList = nil) then
  begin
    FTargetClassifierList.free;
    FTargetClassifierList := nil;
  end
  else
  begin
    if FTargetClassifierList = nil then
      FTargetClassifierList := TFhirCodeableConceptList.Create;
    FTargetClassifierList.Assign(TFhirCitationRelatesTo(oSource).FTargetClassifierList);
  end;
  target := TFhirCitationRelatesTo(oSource).target.Clone;
end;

procedure TFhirCitationRelatesTo.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'relationshipType') Then
     list.add(self.link, 'relationshipType', FRelationshipType.Link);
  if (child_name = 'targetClassifier') Then
    list.addAll(self, 'targetClassifier', FTargetClassifierList);
  if (child_name = 'target[x]') or (child_name = 'target') Then
     list.add(self.link, 'target[x]', FTarget.Link);
end;

procedure TFhirCitationRelatesTo.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'relationshipType', 'CodeableConcept', false, TFhirCodeableConcept, FRelationshipType.Link));
  oList.add(TFHIRProperty.create(self, 'targetClassifier', 'CodeableConcept', true, TFhirCodeableConcept, FTargetClassifierList.Link));
  oList.add(TFHIRProperty.create(self, 'target[x]', 'uri|Identifier|Reference|Attachment', false, TFhirDataType, FTarget.Link));
end;

function TFhirCitationRelatesTo.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'relationshipType') then
  begin
    RelationshipType := propValue as TFhirCodeableConcept;
    result := propValue;
  end
  else if (propName = 'targetClassifier') then
  begin
    TargetClassifierList.add(propValue as TFhirCodeableConcept);
    result := propValue;
  end
  else if (isMatchingName(propName, 'target', ['Uri', 'Identifier', 'Reference', 'Attachment'])) then
  begin
    Target := propValue as TFhirDataType;
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirCitationRelatesTo.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'targetClassifier') then TargetClassifierList.insertItem(index, propValue as TFhirCodeableConcept)
  else inherited;
end;

function TFhirCitationRelatesTo.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'relationshipType') then result := TFhirCodeableConcept.create()
  else if (propName = 'targetClassifier') then result := TargetClassifierList.new()
  else if (isMatchingName(propName, 'target', ['Uri', 'Identifier', 'Reference', 'Attachment'])) then raise EFHIRException.create('Cannot make property Target')
  else result := inherited createPropertyValue(propName);
end;

function TFhirCitationRelatesTo.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'relationshipType') then result := 'CodeableConcept'
  else if (propName = 'targetClassifier') then result := 'CodeableConcept'
  else if (propName = 'target[x]') then result := 'uri|Identifier|Reference|Attachment'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirCitationRelatesTo.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'relationshipType') then RelationshipTypeElement := nil
  else if (propName = 'targetClassifier') then deletePropertyValue('targetClassifier', TargetClassifierList, value)
  else if (isMatchingName(propName, 'target', ['Uri', 'Identifier', 'Reference', 'Attachment'])) then TargetElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirCitationRelatesTo.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'relationshipType') then RelationshipTypeElement := new as TFhirCodeableConcept
  else if (propName = 'targetClassifier') then replacePropertyValue('targetClassifier', TargetClassifierList, existing, new)
  else if (isMatchingName(propName, 'target', ['Uri', 'Identifier', 'Reference', 'Attachment'])) then TargetElement := new as TFhirDataType
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirCitationRelatesTo.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'targetClassifier') then TargetClassifierList.move(source, destination)
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirCitationRelatesTo.fhirType : string;
begin
  result := 'Citation.relatesTo';
end;

function TFhirCitationRelatesTo.Link : TFhirCitationRelatesTo;
begin
  result := TFhirCitationRelatesTo(inherited Link);
end;

function TFhirCitationRelatesTo.Clone : TFhirCitationRelatesTo;
begin
  result := TFhirCitationRelatesTo(inherited Clone);
end;

function TFhirCitationRelatesTo.equals(other : TObject) : boolean; 
var
  o : TFhirCitationRelatesTo;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirCitationRelatesTo)) then
    result := false
  else
  begin
    o := TFhirCitationRelatesTo(other);
    result := compareDeep(relationshipTypeElement, o.relationshipTypeElement, true) and 
      compareDeep(targetClassifierList, o.targetClassifierList, true) and compareDeep(targetElement, o.targetElement, true);
  end;
end;

function TFhirCitationRelatesTo.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FRelationshipType) and isEmptyProp(FtargetClassifierList) and isEmptyProp(FTarget);
end;

procedure TFhirCitationRelatesTo.listFieldsInOrder(fields : TStringList);
begin
  inherited listFieldsInOrder(fields);
  fields.add('relationshipType');
  fields.add('targetClassifier');
  fields.add('target[x]');
end;

function TFhirCitationRelatesTo.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FTargetClassifierList.sizeInBytes(magic));
end;

procedure TFhirCitationRelatesTo.SetRelationshipType(value : TFhirCodeableConcept);
begin
  FRelationshipType.free;
  FRelationshipType := value;
end;

function TFhirCitationRelatesTo.GetTargetClassifierList : TFhirCodeableConceptList;
begin
  if FTargetClassifierList = nil then
    FTargetClassifierList := TFhirCodeableConceptList.Create;
  result := FTargetClassifierList;
end;

function TFhirCitationRelatesTo.GetHasTargetClassifierList : boolean;
begin
  result := (FTargetClassifierList <> nil) and (FTargetClassifierList.count > 0);
end;

procedure TFhirCitationRelatesTo.SetTarget(value : TFhirDataType);
begin
  FTarget.free;
  FTarget := value;
end;

{ TFhirCitationRelatesToListEnumerator }

constructor TFhirCitationRelatesToListEnumerator.Create(list : TFhirCitationRelatesToList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirCitationRelatesToListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirCitationRelatesToListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirCitationRelatesToListEnumerator.GetCurrent : TFhirCitationRelatesTo;
begin
  Result := FList[FIndex];
end;

function TFhirCitationRelatesToListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirCitationRelatesToList }

procedure TFhirCitationRelatesToList.AddItem(value: TFhirCitationRelatesTo);
begin
  assert(value.ClassName = 'TFhirCitationRelatesTo', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirCitationRelatesTo');
  add(value);
end;

function TFhirCitationRelatesToList.Append: TFhirCitationRelatesTo;
begin
  result := TFhirCitationRelatesTo.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirCitationRelatesToList.ClearItems;
begin
  Clear;
end;

function TFhirCitationRelatesToList.GetEnumerator : TFhirCitationRelatesToListEnumerator;
begin
  result := TFhirCitationRelatesToListEnumerator.Create(self.link);
end;

function TFhirCitationRelatesToList.Clone: TFhirCitationRelatesToList;
begin
  result := TFhirCitationRelatesToList(inherited Clone);
end;

function TFhirCitationRelatesToList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirCitationRelatesToList.GetItemN(index: Integer): TFhirCitationRelatesTo;
begin
  result := TFhirCitationRelatesTo(ObjectByIndex[index]);
end;

function TFhirCitationRelatesToList.ItemClass: TFslObjectClass;
begin
  result := TFhirCitationRelatesTo;
end;
function TFhirCitationRelatesToList.IndexOf(value: TFhirCitationRelatesTo): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirCitationRelatesToList.Insert(index: Integer): TFhirCitationRelatesTo;
begin
  result := TFhirCitationRelatesTo.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirCitationRelatesToList.InsertItem(index: Integer; value: TFhirCitationRelatesTo);
begin
  assert(value is TFhirCitationRelatesTo);
  Inherited Insert(index, value);
end;

function TFhirCitationRelatesToList.Item(index: Integer): TFhirCitationRelatesTo;
begin
  result := TFhirCitationRelatesTo(ObjectByIndex[index]);
end;

function TFhirCitationRelatesToList.Link: TFhirCitationRelatesToList;
begin
  result := TFhirCitationRelatesToList(inherited Link);
end;

procedure TFhirCitationRelatesToList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirCitationRelatesToList.SetItemByIndex(index: Integer; value: TFhirCitationRelatesTo);
begin
  assert(value is TFhirCitationRelatesTo);
  FhirCitationRelatesTos[index] := value;
end;

procedure TFhirCitationRelatesToList.SetItemN(index: Integer; value: TFhirCitationRelatesTo);
begin
  assert(value is TFhirCitationRelatesTo);
  ObjectByIndex[index] := value;
end;

{ TFhirCitationCitedArtifact }

constructor TFhirCitationCitedArtifact.Create;
begin
  inherited;
end;

destructor TFhirCitationCitedArtifact.Destroy;
begin
  FIdentifierList.Free;
  FRelatedIdentifierList.Free;
  FDateAccessed.free;
  FVersion.free;
  FCurrentStateList.Free;
  FStatusDateList.Free;
  FTitleList.Free;
  FAbstractList.Free;
  FPart.free;
  FRelatesToList.Free;
  FPublicationFormList.Free;
  FWebLocationList.Free;
  FClassificationList.Free;
  FContributorship.free;
  FNoteList.Free;
  inherited;
end;

procedure TFhirCitationCitedArtifact.Assign(oSource : TFslObject);
begin
  inherited;
  if (TFhirCitationCitedArtifact(oSource).FIdentifierList = nil) then
  begin
    FIdentifierList.free;
    FIdentifierList := nil;
  end
  else
  begin
    if FIdentifierList = nil then
      FIdentifierList := TFhirIdentifierList.Create;
    FIdentifierList.Assign(TFhirCitationCitedArtifact(oSource).FIdentifierList);
  end;
  if (TFhirCitationCitedArtifact(oSource).FRelatedIdentifierList = nil) then
  begin
    FRelatedIdentifierList.free;
    FRelatedIdentifierList := nil;
  end
  else
  begin
    if FRelatedIdentifierList = nil then
      FRelatedIdentifierList := TFhirIdentifierList.Create;
    FRelatedIdentifierList.Assign(TFhirCitationCitedArtifact(oSource).FRelatedIdentifierList);
  end;
  dateAccessedElement := TFhirCitationCitedArtifact(oSource).dateAccessedElement.Clone;
  version := TFhirCitationCitedArtifact(oSource).version.Clone;
  if (TFhirCitationCitedArtifact(oSource).FCurrentStateList = nil) then
  begin
    FCurrentStateList.free;
    FCurrentStateList := nil;
  end
  else
  begin
    if FCurrentStateList = nil then
      FCurrentStateList := TFhirCodeableConceptList.Create;
    FCurrentStateList.Assign(TFhirCitationCitedArtifact(oSource).FCurrentStateList);
  end;
  if (TFhirCitationCitedArtifact(oSource).FStatusDateList = nil) then
  begin
    FStatusDateList.free;
    FStatusDateList := nil;
  end
  else
  begin
    if FStatusDateList = nil then
      FStatusDateList := TFhirCitationCitedArtifactStatusDateList.Create;
    FStatusDateList.Assign(TFhirCitationCitedArtifact(oSource).FStatusDateList);
  end;
  if (TFhirCitationCitedArtifact(oSource).FTitleList = nil) then
  begin
    FTitleList.free;
    FTitleList := nil;
  end
  else
  begin
    if FTitleList = nil then
      FTitleList := TFhirCitationCitedArtifactTitleList.Create;
    FTitleList.Assign(TFhirCitationCitedArtifact(oSource).FTitleList);
  end;
  if (TFhirCitationCitedArtifact(oSource).FAbstractList = nil) then
  begin
    FAbstractList.free;
    FAbstractList := nil;
  end
  else
  begin
    if FAbstractList = nil then
      FAbstractList := TFhirCitationCitedArtifactAbstractList.Create;
    FAbstractList.Assign(TFhirCitationCitedArtifact(oSource).FAbstractList);
  end;
  part := TFhirCitationCitedArtifact(oSource).part.Clone;
  if (TFhirCitationCitedArtifact(oSource).FRelatesToList = nil) then
  begin
    FRelatesToList.free;
    FRelatesToList := nil;
  end
  else
  begin
    if FRelatesToList = nil then
      FRelatesToList := TFhirCitationCitedArtifactRelatesToList.Create;
    FRelatesToList.Assign(TFhirCitationCitedArtifact(oSource).FRelatesToList);
  end;
  if (TFhirCitationCitedArtifact(oSource).FPublicationFormList = nil) then
  begin
    FPublicationFormList.free;
    FPublicationFormList := nil;
  end
  else
  begin
    if FPublicationFormList = nil then
      FPublicationFormList := TFhirCitationCitedArtifactPublicationFormList.Create;
    FPublicationFormList.Assign(TFhirCitationCitedArtifact(oSource).FPublicationFormList);
  end;
  if (TFhirCitationCitedArtifact(oSource).FWebLocationList = nil) then
  begin
    FWebLocationList.free;
    FWebLocationList := nil;
  end
  else
  begin
    if FWebLocationList = nil then
      FWebLocationList := TFhirCitationCitedArtifactWebLocationList.Create;
    FWebLocationList.Assign(TFhirCitationCitedArtifact(oSource).FWebLocationList);
  end;
  if (TFhirCitationCitedArtifact(oSource).FClassificationList = nil) then
  begin
    FClassificationList.free;
    FClassificationList := nil;
  end
  else
  begin
    if FClassificationList = nil then
      FClassificationList := TFhirCitationCitedArtifactClassificationList.Create;
    FClassificationList.Assign(TFhirCitationCitedArtifact(oSource).FClassificationList);
  end;
  contributorship := TFhirCitationCitedArtifact(oSource).contributorship.Clone;
  if (TFhirCitationCitedArtifact(oSource).FNoteList = nil) then
  begin
    FNoteList.free;
    FNoteList := nil;
  end
  else
  begin
    if FNoteList = nil then
      FNoteList := TFhirAnnotationList.Create;
    FNoteList.Assign(TFhirCitationCitedArtifact(oSource).FNoteList);
  end;
end;

procedure TFhirCitationCitedArtifact.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'identifier') Then
    list.addAll(self, 'identifier', FIdentifierList);
  if (child_name = 'relatedIdentifier') Then
    list.addAll(self, 'relatedIdentifier', FRelatedIdentifierList);
  if (child_name = 'dateAccessed') Then
     list.add(self.link, 'dateAccessed', FDateAccessed.Link);
  if (child_name = 'version') Then
     list.add(self.link, 'version', FVersion.Link);
  if (child_name = 'currentState') Then
    list.addAll(self, 'currentState', FCurrentStateList);
  if (child_name = 'statusDate') Then
    list.addAll(self, 'statusDate', FStatusDateList);
  if (child_name = 'title') Then
    list.addAll(self, 'title', FTitleList);
  if (child_name = 'abstract') Then
    list.addAll(self, 'abstract', FAbstractList);
  if (child_name = 'part') Then
     list.add(self.link, 'part', FPart.Link);
  if (child_name = 'relatesTo') Then
    list.addAll(self, 'relatesTo', FRelatesToList);
  if (child_name = 'publicationForm') Then
    list.addAll(self, 'publicationForm', FPublicationFormList);
  if (child_name = 'webLocation') Then
    list.addAll(self, 'webLocation', FWebLocationList);
  if (child_name = 'classification') Then
    list.addAll(self, 'classification', FClassificationList);
  if (child_name = 'contributorship') Then
     list.add(self.link, 'contributorship', FContributorship.Link);
  if (child_name = 'note') Then
    list.addAll(self, 'note', FNoteList);
end;

procedure TFhirCitationCitedArtifact.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'identifier', 'Identifier', true, TFhirIdentifier, FIdentifierList.Link));
  oList.add(TFHIRProperty.create(self, 'relatedIdentifier', 'Identifier', true, TFhirIdentifier, FRelatedIdentifierList.Link));
  oList.add(TFHIRProperty.create(self, 'dateAccessed', 'dateTime', false, TFhirDateTime, FDateAccessed.Link));
  oList.add(TFHIRProperty.create(self, 'version', 'BackboneElement', false, TFhirCitationCitedArtifactVersion, FVersion.Link));
  oList.add(TFHIRProperty.create(self, 'currentState', 'CodeableConcept', true, TFhirCodeableConcept, FCurrentStateList.Link));
  oList.add(TFHIRProperty.create(self, 'statusDate', 'BackboneElement', true, TFhirCitationCitedArtifactStatusDate, FStatusDateList.Link));
  oList.add(TFHIRProperty.create(self, 'title', 'BackboneElement', true, TFhirCitationCitedArtifactTitle, FTitleList.Link));
  oList.add(TFHIRProperty.create(self, 'abstract', 'BackboneElement', true, TFhirCitationCitedArtifactAbstract, FAbstractList.Link));
  oList.add(TFHIRProperty.create(self, 'part', 'BackboneElement', false, TFhirCitationCitedArtifactPart, FPart.Link));
  oList.add(TFHIRProperty.create(self, 'relatesTo', 'BackboneElement', true, TFhirCitationCitedArtifactRelatesTo, FRelatesToList.Link));
  oList.add(TFHIRProperty.create(self, 'publicationForm', 'BackboneElement', true, TFhirCitationCitedArtifactPublicationForm, FPublicationFormList.Link));
  oList.add(TFHIRProperty.create(self, 'webLocation', 'BackboneElement', true, TFhirCitationCitedArtifactWebLocation, FWebLocationList.Link));
  oList.add(TFHIRProperty.create(self, 'classification', 'BackboneElement', true, TFhirCitationCitedArtifactClassification, FClassificationList.Link));
  oList.add(TFHIRProperty.create(self, 'contributorship', 'BackboneElement', false, TFhirCitationCitedArtifactContributorship, FContributorship.Link));
  oList.add(TFHIRProperty.create(self, 'note', 'Annotation', true, TFhirAnnotation, FNoteList.Link));
end;

function TFhirCitationCitedArtifact.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'identifier') then
  begin
    IdentifierList.add(propValue as TFhirIdentifier);
    result := propValue;
  end
  else if (propName = 'relatedIdentifier') then
  begin
    RelatedIdentifierList.add(propValue as TFhirIdentifier);
    result := propValue;
  end
  else if (propName = 'dateAccessed') then
  begin
    DateAccessedElement := asDateTime(propValue);
    result := propValue;
  end
  else if (propName = 'version') then
  begin
    Version := propValue as TFhirCitationCitedArtifactVersion;
    result := propValue;
  end
  else if (propName = 'currentState') then
  begin
    CurrentStateList.add(propValue as TFhirCodeableConcept);
    result := propValue;
  end
  else if (propName = 'statusDate') then
  begin
    StatusDateList.add(propValue as TFhirCitationCitedArtifactStatusDate);
    result := propValue;
  end
  else if (propName = 'title') then
  begin
    TitleList.add(propValue as TFhirCitationCitedArtifactTitle);
    result := propValue;
  end
  else if (propName = 'abstract') then
  begin
    AbstractList.add(propValue as TFhirCitationCitedArtifactAbstract);
    result := propValue;
  end
  else if (propName = 'part') then
  begin
    Part := propValue as TFhirCitationCitedArtifactPart;
    result := propValue;
  end
  else if (propName = 'relatesTo') then
  begin
    RelatesToList.add(propValue as TFhirCitationCitedArtifactRelatesTo);
    result := propValue;
  end
  else if (propName = 'publicationForm') then
  begin
    PublicationFormList.add(propValue as TFhirCitationCitedArtifactPublicationForm);
    result := propValue;
  end
  else if (propName = 'webLocation') then
  begin
    WebLocationList.add(propValue as TFhirCitationCitedArtifactWebLocation);
    result := propValue;
  end
  else if (propName = 'classification') then
  begin
    ClassificationList.add(propValue as TFhirCitationCitedArtifactClassification);
    result := propValue;
  end
  else if (propName = 'contributorship') then
  begin
    Contributorship := propValue as TFhirCitationCitedArtifactContributorship;
    result := propValue;
  end
  else if (propName = 'note') then
  begin
    NoteList.add(propValue as TFhirAnnotation);
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirCitationCitedArtifact.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'identifier') then IdentifierList.insertItem(index, propValue as TFhirIdentifier)
  else if (propName = 'relatedIdentifier') then RelatedIdentifierList.insertItem(index, propValue as TFhirIdentifier)
  else if (propName = 'currentState') then CurrentStateList.insertItem(index, propValue as TFhirCodeableConcept)
  else if (propName = 'statusDate') then StatusDateList.insertItem(index, propValue as TFhirCitationCitedArtifactStatusDate)
  else if (propName = 'title') then TitleList.insertItem(index, propValue as TFhirCitationCitedArtifactTitle)
  else if (propName = 'abstract') then AbstractList.insertItem(index, propValue as TFhirCitationCitedArtifactAbstract)
  else if (propName = 'relatesTo') then RelatesToList.insertItem(index, propValue as TFhirCitationCitedArtifactRelatesTo)
  else if (propName = 'publicationForm') then PublicationFormList.insertItem(index, propValue as TFhirCitationCitedArtifactPublicationForm)
  else if (propName = 'webLocation') then WebLocationList.insertItem(index, propValue as TFhirCitationCitedArtifactWebLocation)
  else if (propName = 'classification') then ClassificationList.insertItem(index, propValue as TFhirCitationCitedArtifactClassification)
  else if (propName = 'note') then NoteList.insertItem(index, propValue as TFhirAnnotation)
  else inherited;
end;

function TFhirCitationCitedArtifact.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'identifier') then result := IdentifierList.new()
  else if (propName = 'relatedIdentifier') then result := RelatedIdentifierList.new()
  else if (propName = 'dateAccessed') then result := TFhirDateTime.create()
  else if (propName = 'version') then result := TFhirCitationCitedArtifactVersion.create()
  else if (propName = 'currentState') then result := CurrentStateList.new()
  else if (propName = 'statusDate') then result := StatusDateList.new()
  else if (propName = 'title') then result := TitleList.new()
  else if (propName = 'abstract') then result := AbstractList.new()
  else if (propName = 'part') then result := TFhirCitationCitedArtifactPart.create()
  else if (propName = 'relatesTo') then result := RelatesToList.new()
  else if (propName = 'publicationForm') then result := PublicationFormList.new()
  else if (propName = 'webLocation') then result := WebLocationList.new()
  else if (propName = 'classification') then result := ClassificationList.new()
  else if (propName = 'contributorship') then result := TFhirCitationCitedArtifactContributorship.create()
  else if (propName = 'note') then result := NoteList.new()
  else result := inherited createPropertyValue(propName);
end;

function TFhirCitationCitedArtifact.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'identifier') then result := 'Identifier'
  else if (propName = 'relatedIdentifier') then result := 'Identifier'
  else if (propName = 'dateAccessed') then result := 'dateTime'
  else if (propName = 'version') then result := 'BackboneElement'
  else if (propName = 'currentState') then result := 'CodeableConcept'
  else if (propName = 'statusDate') then result := 'BackboneElement'
  else if (propName = 'title') then result := 'BackboneElement'
  else if (propName = 'abstract') then result := 'BackboneElement'
  else if (propName = 'part') then result := 'BackboneElement'
  else if (propName = 'relatesTo') then result := 'BackboneElement'
  else if (propName = 'publicationForm') then result := 'BackboneElement'
  else if (propName = 'webLocation') then result := 'BackboneElement'
  else if (propName = 'classification') then result := 'BackboneElement'
  else if (propName = 'contributorship') then result := 'BackboneElement'
  else if (propName = 'note') then result := 'Annotation'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirCitationCitedArtifact.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'identifier') then deletePropertyValue('identifier', IdentifierList, value)
  else if (propName = 'relatedIdentifier') then deletePropertyValue('relatedIdentifier', RelatedIdentifierList, value)
  else if (propName = 'dateAccessed') then DateAccessedElement := nil
  else if (propName = 'version') then VersionElement := nil
  else if (propName = 'currentState') then deletePropertyValue('currentState', CurrentStateList, value)
  else if (propName = 'statusDate') then deletePropertyValue('statusDate', StatusDateList, value)
  else if (propName = 'title') then deletePropertyValue('title', TitleList, value)
  else if (propName = 'abstract') then deletePropertyValue('abstract', AbstractList, value)
  else if (propName = 'part') then PartElement := nil
  else if (propName = 'relatesTo') then deletePropertyValue('relatesTo', RelatesToList, value)
  else if (propName = 'publicationForm') then deletePropertyValue('publicationForm', PublicationFormList, value)
  else if (propName = 'webLocation') then deletePropertyValue('webLocation', WebLocationList, value)
  else if (propName = 'classification') then deletePropertyValue('classification', ClassificationList, value)
  else if (propName = 'contributorship') then ContributorshipElement := nil
  else if (propName = 'note') then deletePropertyValue('note', NoteList, value)
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirCitationCitedArtifact.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'identifier') then replacePropertyValue('identifier', IdentifierList, existing, new)
  else if (propName = 'relatedIdentifier') then replacePropertyValue('relatedIdentifier', RelatedIdentifierList, existing, new)
  else if (propName = 'dateAccessed') then DateAccessedElement := asDateTime(new)
  else if (propName = 'version') then VersionElement := new as TFhirCitationCitedArtifactVersion
  else if (propName = 'currentState') then replacePropertyValue('currentState', CurrentStateList, existing, new)
  else if (propName = 'statusDate') then replacePropertyValue('statusDate', StatusDateList, existing, new)
  else if (propName = 'title') then replacePropertyValue('title', TitleList, existing, new)
  else if (propName = 'abstract') then replacePropertyValue('abstract', AbstractList, existing, new)
  else if (propName = 'part') then PartElement := new as TFhirCitationCitedArtifactPart
  else if (propName = 'relatesTo') then replacePropertyValue('relatesTo', RelatesToList, existing, new)
  else if (propName = 'publicationForm') then replacePropertyValue('publicationForm', PublicationFormList, existing, new)
  else if (propName = 'webLocation') then replacePropertyValue('webLocation', WebLocationList, existing, new)
  else if (propName = 'classification') then replacePropertyValue('classification', ClassificationList, existing, new)
  else if (propName = 'contributorship') then ContributorshipElement := new as TFhirCitationCitedArtifactContributorship
  else if (propName = 'note') then replacePropertyValue('note', NoteList, existing, new)
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirCitationCitedArtifact.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'identifier') then IdentifierList.move(source, destination)
  else if (propName = 'relatedIdentifier') then RelatedIdentifierList.move(source, destination)
  else if (propName = 'currentState') then CurrentStateList.move(source, destination)
  else if (propName = 'statusDate') then StatusDateList.move(source, destination)
  else if (propName = 'title') then TitleList.move(source, destination)
  else if (propName = 'abstract') then AbstractList.move(source, destination)
  else if (propName = 'relatesTo') then RelatesToList.move(source, destination)
  else if (propName = 'publicationForm') then PublicationFormList.move(source, destination)
  else if (propName = 'webLocation') then WebLocationList.move(source, destination)
  else if (propName = 'classification') then ClassificationList.move(source, destination)
  else if (propName = 'note') then NoteList.move(source, destination)
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirCitationCitedArtifact.fhirType : string;
begin
  result := 'Citation.citedArtifact';
end;

function TFhirCitationCitedArtifact.Link : TFhirCitationCitedArtifact;
begin
  result := TFhirCitationCitedArtifact(inherited Link);
end;

function TFhirCitationCitedArtifact.Clone : TFhirCitationCitedArtifact;
begin
  result := TFhirCitationCitedArtifact(inherited Clone);
end;

function TFhirCitationCitedArtifact.equals(other : TObject) : boolean; 
var
  o : TFhirCitationCitedArtifact;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirCitationCitedArtifact)) then
    result := false
  else
  begin
    o := TFhirCitationCitedArtifact(other);
    result := compareDeep(identifierList, o.identifierList, true) and compareDeep(relatedIdentifierList, o.relatedIdentifierList, true) and 
      compareDeep(dateAccessedElement, o.dateAccessedElement, true) and compareDeep(versionElement, o.versionElement, true) and 
      compareDeep(currentStateList, o.currentStateList, true) and compareDeep(statusDateList, o.statusDateList, true) and 
      compareDeep(titleList, o.titleList, true) and compareDeep(abstractList, o.abstractList, true) and 
      compareDeep(partElement, o.partElement, true) and compareDeep(relatesToList, o.relatesToList, true) and 
      compareDeep(publicationFormList, o.publicationFormList, true) and compareDeep(webLocationList, o.webLocationList, true) and 
      compareDeep(classificationList, o.classificationList, true) and compareDeep(contributorshipElement, o.contributorshipElement, true) and 
      compareDeep(noteList, o.noteList, true);
  end;
end;

function TFhirCitationCitedArtifact.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FidentifierList) and isEmptyProp(FrelatedIdentifierList) and isEmptyProp(FDateAccessed) and isEmptyProp(FVersion) and isEmptyProp(FcurrentStateList) and isEmptyProp(FstatusDateList) and isEmptyProp(FtitleList) and isEmptyProp(FabstractList) and isEmptyProp(FPart) and isEmptyProp(FrelatesToList) and isEmptyProp(FpublicationFormList) and isEmptyProp(FwebLocationList) and isEmptyProp(FclassificationList) and isEmptyProp(FContributorship) and isEmptyProp(FnoteList);
end;

procedure TFhirCitationCitedArtifact.listFieldsInOrder(fields : TStringList);
begin
  inherited listFieldsInOrder(fields);
  fields.add('identifier');
  fields.add('relatedIdentifier');
  fields.add('dateAccessed');
  fields.add('version');
  fields.add('currentState');
  fields.add('statusDate');
  fields.add('title');
  fields.add('abstract');
  fields.add('part');
  fields.add('relatesTo');
  fields.add('publicationForm');
  fields.add('webLocation');
  fields.add('classification');
  fields.add('contributorship');
  fields.add('note');
end;

function TFhirCitationCitedArtifact.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FIdentifierList.sizeInBytes(magic));
  inc(result, FRelatedIdentifierList.sizeInBytes(magic));
  inc(result, FCurrentStateList.sizeInBytes(magic));
  inc(result, FStatusDateList.sizeInBytes(magic));
  inc(result, FTitleList.sizeInBytes(magic));
  inc(result, FAbstractList.sizeInBytes(magic));
  inc(result, FRelatesToList.sizeInBytes(magic));
  inc(result, FPublicationFormList.sizeInBytes(magic));
  inc(result, FWebLocationList.sizeInBytes(magic));
  inc(result, FClassificationList.sizeInBytes(magic));
  inc(result, FNoteList.sizeInBytes(magic));
end;

function TFhirCitationCitedArtifact.GetIdentifierList : TFhirIdentifierList;
begin
  if FIdentifierList = nil then
    FIdentifierList := TFhirIdentifierList.Create;
  result := FIdentifierList;
end;

function TFhirCitationCitedArtifact.GetHasIdentifierList : boolean;
begin
  result := (FIdentifierList <> nil) and (FIdentifierList.count > 0);
end;

function TFhirCitationCitedArtifact.GetRelatedIdentifierList : TFhirIdentifierList;
begin
  if FRelatedIdentifierList = nil then
    FRelatedIdentifierList := TFhirIdentifierList.Create;
  result := FRelatedIdentifierList;
end;

function TFhirCitationCitedArtifact.GetHasRelatedIdentifierList : boolean;
begin
  result := (FRelatedIdentifierList <> nil) and (FRelatedIdentifierList.count > 0);
end;

procedure TFhirCitationCitedArtifact.SetDateAccessed(value : TFhirDateTime);
begin
  FDateAccessed.free;
  FDateAccessed := value;
end;

function TFhirCitationCitedArtifact.GetDateAccessedST : TFslDateTime;
begin
  if FDateAccessed = nil then
    result := TFslDateTime.makeNull
  else
    result := FDateAccessed.value;
end;

procedure TFhirCitationCitedArtifact.SetDateAccessedST(value : TFslDateTime);
begin
  if FDateAccessed = nil then
    FDateAccessed := TFhirDateTime.create;
  FDateAccessed.value := value
end;

procedure TFhirCitationCitedArtifact.SetVersion(value : TFhirCitationCitedArtifactVersion);
begin
  FVersion.free;
  FVersion := value;
end;

function TFhirCitationCitedArtifact.GetCurrentStateList : TFhirCodeableConceptList;
begin
  if FCurrentStateList = nil then
    FCurrentStateList := TFhirCodeableConceptList.Create;
  result := FCurrentStateList;
end;

function TFhirCitationCitedArtifact.GetHasCurrentStateList : boolean;
begin
  result := (FCurrentStateList <> nil) and (FCurrentStateList.count > 0);
end;

function TFhirCitationCitedArtifact.GetStatusDateList : TFhirCitationCitedArtifactStatusDateList;
begin
  if FStatusDateList = nil then
    FStatusDateList := TFhirCitationCitedArtifactStatusDateList.Create;
  result := FStatusDateList;
end;

function TFhirCitationCitedArtifact.GetHasStatusDateList : boolean;
begin
  result := (FStatusDateList <> nil) and (FStatusDateList.count > 0);
end;

function TFhirCitationCitedArtifact.GetTitleList : TFhirCitationCitedArtifactTitleList;
begin
  if FTitleList = nil then
    FTitleList := TFhirCitationCitedArtifactTitleList.Create;
  result := FTitleList;
end;

function TFhirCitationCitedArtifact.GetHasTitleList : boolean;
begin
  result := (FTitleList <> nil) and (FTitleList.count > 0);
end;

function TFhirCitationCitedArtifact.GetAbstractList : TFhirCitationCitedArtifactAbstractList;
begin
  if FAbstractList = nil then
    FAbstractList := TFhirCitationCitedArtifactAbstractList.Create;
  result := FAbstractList;
end;

function TFhirCitationCitedArtifact.GetHasAbstractList : boolean;
begin
  result := (FAbstractList <> nil) and (FAbstractList.count > 0);
end;

procedure TFhirCitationCitedArtifact.SetPart(value : TFhirCitationCitedArtifactPart);
begin
  FPart.free;
  FPart := value;
end;

function TFhirCitationCitedArtifact.GetRelatesToList : TFhirCitationCitedArtifactRelatesToList;
begin
  if FRelatesToList = nil then
    FRelatesToList := TFhirCitationCitedArtifactRelatesToList.Create;
  result := FRelatesToList;
end;

function TFhirCitationCitedArtifact.GetHasRelatesToList : boolean;
begin
  result := (FRelatesToList <> nil) and (FRelatesToList.count > 0);
end;

function TFhirCitationCitedArtifact.GetPublicationFormList : TFhirCitationCitedArtifactPublicationFormList;
begin
  if FPublicationFormList = nil then
    FPublicationFormList := TFhirCitationCitedArtifactPublicationFormList.Create;
  result := FPublicationFormList;
end;

function TFhirCitationCitedArtifact.GetHasPublicationFormList : boolean;
begin
  result := (FPublicationFormList <> nil) and (FPublicationFormList.count > 0);
end;

function TFhirCitationCitedArtifact.GetWebLocationList : TFhirCitationCitedArtifactWebLocationList;
begin
  if FWebLocationList = nil then
    FWebLocationList := TFhirCitationCitedArtifactWebLocationList.Create;
  result := FWebLocationList;
end;

function TFhirCitationCitedArtifact.GetHasWebLocationList : boolean;
begin
  result := (FWebLocationList <> nil) and (FWebLocationList.count > 0);
end;

function TFhirCitationCitedArtifact.GetClassificationList : TFhirCitationCitedArtifactClassificationList;
begin
  if FClassificationList = nil then
    FClassificationList := TFhirCitationCitedArtifactClassificationList.Create;
  result := FClassificationList;
end;

function TFhirCitationCitedArtifact.GetHasClassificationList : boolean;
begin
  result := (FClassificationList <> nil) and (FClassificationList.count > 0);
end;

procedure TFhirCitationCitedArtifact.SetContributorship(value : TFhirCitationCitedArtifactContributorship);
begin
  FContributorship.free;
  FContributorship := value;
end;

function TFhirCitationCitedArtifact.GetNoteList : TFhirAnnotationList;
begin
  if FNoteList = nil then
    FNoteList := TFhirAnnotationList.Create;
  result := FNoteList;
end;

function TFhirCitationCitedArtifact.GetHasNoteList : boolean;
begin
  result := (FNoteList <> nil) and (FNoteList.count > 0);
end;

{ TFhirCitationCitedArtifactListEnumerator }

constructor TFhirCitationCitedArtifactListEnumerator.Create(list : TFhirCitationCitedArtifactList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirCitationCitedArtifactListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirCitationCitedArtifactListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirCitationCitedArtifactListEnumerator.GetCurrent : TFhirCitationCitedArtifact;
begin
  Result := FList[FIndex];
end;

function TFhirCitationCitedArtifactListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirCitationCitedArtifactList }

procedure TFhirCitationCitedArtifactList.AddItem(value: TFhirCitationCitedArtifact);
begin
  assert(value.ClassName = 'TFhirCitationCitedArtifact', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirCitationCitedArtifact');
  add(value);
end;

function TFhirCitationCitedArtifactList.Append: TFhirCitationCitedArtifact;
begin
  result := TFhirCitationCitedArtifact.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirCitationCitedArtifactList.ClearItems;
begin
  Clear;
end;

function TFhirCitationCitedArtifactList.GetEnumerator : TFhirCitationCitedArtifactListEnumerator;
begin
  result := TFhirCitationCitedArtifactListEnumerator.Create(self.link);
end;

function TFhirCitationCitedArtifactList.Clone: TFhirCitationCitedArtifactList;
begin
  result := TFhirCitationCitedArtifactList(inherited Clone);
end;

function TFhirCitationCitedArtifactList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirCitationCitedArtifactList.GetItemN(index: Integer): TFhirCitationCitedArtifact;
begin
  result := TFhirCitationCitedArtifact(ObjectByIndex[index]);
end;

function TFhirCitationCitedArtifactList.ItemClass: TFslObjectClass;
begin
  result := TFhirCitationCitedArtifact;
end;
function TFhirCitationCitedArtifactList.IndexOf(value: TFhirCitationCitedArtifact): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirCitationCitedArtifactList.Insert(index: Integer): TFhirCitationCitedArtifact;
begin
  result := TFhirCitationCitedArtifact.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirCitationCitedArtifactList.InsertItem(index: Integer; value: TFhirCitationCitedArtifact);
begin
  assert(value is TFhirCitationCitedArtifact);
  Inherited Insert(index, value);
end;

function TFhirCitationCitedArtifactList.Item(index: Integer): TFhirCitationCitedArtifact;
begin
  result := TFhirCitationCitedArtifact(ObjectByIndex[index]);
end;

function TFhirCitationCitedArtifactList.Link: TFhirCitationCitedArtifactList;
begin
  result := TFhirCitationCitedArtifactList(inherited Link);
end;

procedure TFhirCitationCitedArtifactList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirCitationCitedArtifactList.SetItemByIndex(index: Integer; value: TFhirCitationCitedArtifact);
begin
  assert(value is TFhirCitationCitedArtifact);
  FhirCitationCitedArtifacts[index] := value;
end;

procedure TFhirCitationCitedArtifactList.SetItemN(index: Integer; value: TFhirCitationCitedArtifact);
begin
  assert(value is TFhirCitationCitedArtifact);
  ObjectByIndex[index] := value;
end;

{ TFhirCitationCitedArtifactVersion }

constructor TFhirCitationCitedArtifactVersion.Create;
begin
  inherited;
end;

destructor TFhirCitationCitedArtifactVersion.Destroy;
begin
  FValue.free;
  FBaseCitation.free;
  inherited;
end;

procedure TFhirCitationCitedArtifactVersion.Assign(oSource : TFslObject);
begin
  inherited;
  valueElement := TFhirCitationCitedArtifactVersion(oSource).valueElement.Clone;
  baseCitation := TFhirCitationCitedArtifactVersion(oSource).baseCitation.Clone;
end;

procedure TFhirCitationCitedArtifactVersion.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'value') Then
     list.add(self.link, 'value', FValue.Link);
  if (child_name = 'baseCitation') Then
     list.add(self.link, 'baseCitation', FBaseCitation.Link);
end;

procedure TFhirCitationCitedArtifactVersion.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'value', 'string', false, TFhirString, FValue.Link));
  oList.add(TFHIRProperty.create(self, 'baseCitation', 'Reference', false, TFhirReference, FBaseCitation.Link));
end;

function TFhirCitationCitedArtifactVersion.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'value') then
  begin
    ValueElement := asString(propValue);
    result := propValue;
  end
  else if (propName = 'baseCitation') then
  begin
    BaseCitation := propValue as TFhirReference;
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirCitationCitedArtifactVersion.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirCitationCitedArtifactVersion.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'value') then result := TFhirString.create()
  else if (propName = 'baseCitation') then result := TFhirReference.create()
  else result := inherited createPropertyValue(propName);
end;

function TFhirCitationCitedArtifactVersion.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'value') then result := 'string'
  else if (propName = 'baseCitation') then result := 'Reference'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirCitationCitedArtifactVersion.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'value') then ValueElement := nil
  else if (propName = 'baseCitation') then BaseCitationElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirCitationCitedArtifactVersion.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'value') then ValueElement := asString(new)
  else if (propName = 'baseCitation') then BaseCitationElement := new as TFhirReference
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirCitationCitedArtifactVersion.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirCitationCitedArtifactVersion.fhirType : string;
begin
  result := 'Citation.citedArtifact.version';
end;

function TFhirCitationCitedArtifactVersion.Link : TFhirCitationCitedArtifactVersion;
begin
  result := TFhirCitationCitedArtifactVersion(inherited Link);
end;

function TFhirCitationCitedArtifactVersion.Clone : TFhirCitationCitedArtifactVersion;
begin
  result := TFhirCitationCitedArtifactVersion(inherited Clone);
end;

function TFhirCitationCitedArtifactVersion.equals(other : TObject) : boolean; 
var
  o : TFhirCitationCitedArtifactVersion;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirCitationCitedArtifactVersion)) then
    result := false
  else
  begin
    o := TFhirCitationCitedArtifactVersion(other);
    result := compareDeep(valueElement, o.valueElement, true) and compareDeep(baseCitationElement, o.baseCitationElement, true);
  end;
end;

function TFhirCitationCitedArtifactVersion.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FValue) and isEmptyProp(FBaseCitation);
end;

procedure TFhirCitationCitedArtifactVersion.listFieldsInOrder(fields : TStringList);
begin
  inherited listFieldsInOrder(fields);
  fields.add('value');
  fields.add('baseCitation');
end;

function TFhirCitationCitedArtifactVersion.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
end;

procedure TFhirCitationCitedArtifactVersion.SetValue(value : TFhirString);
begin
  FValue.free;
  FValue := value;
end;

function TFhirCitationCitedArtifactVersion.GetValueST : String;
begin
  if FValue = nil then
    result := ''
  else
    result := FValue.value;
end;

procedure TFhirCitationCitedArtifactVersion.SetValueST(value : String);
begin
  if value <> '' then
  begin
    if FValue = nil then
      FValue := TFhirString.create;
    FValue.value := value
  end
  else if FValue <> nil then
    FValue.value := '';
end;

procedure TFhirCitationCitedArtifactVersion.SetBaseCitation(value : TFhirReference);
begin
  FBaseCitation.free;
  FBaseCitation := value;
end;

{ TFhirCitationCitedArtifactVersionListEnumerator }

constructor TFhirCitationCitedArtifactVersionListEnumerator.Create(list : TFhirCitationCitedArtifactVersionList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirCitationCitedArtifactVersionListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirCitationCitedArtifactVersionListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirCitationCitedArtifactVersionListEnumerator.GetCurrent : TFhirCitationCitedArtifactVersion;
begin
  Result := FList[FIndex];
end;

function TFhirCitationCitedArtifactVersionListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirCitationCitedArtifactVersionList }

procedure TFhirCitationCitedArtifactVersionList.AddItem(value: TFhirCitationCitedArtifactVersion);
begin
  assert(value.ClassName = 'TFhirCitationCitedArtifactVersion', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirCitationCitedArtifactVersion');
  add(value);
end;

function TFhirCitationCitedArtifactVersionList.Append: TFhirCitationCitedArtifactVersion;
begin
  result := TFhirCitationCitedArtifactVersion.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirCitationCitedArtifactVersionList.ClearItems;
begin
  Clear;
end;

function TFhirCitationCitedArtifactVersionList.GetEnumerator : TFhirCitationCitedArtifactVersionListEnumerator;
begin
  result := TFhirCitationCitedArtifactVersionListEnumerator.Create(self.link);
end;

function TFhirCitationCitedArtifactVersionList.Clone: TFhirCitationCitedArtifactVersionList;
begin
  result := TFhirCitationCitedArtifactVersionList(inherited Clone);
end;

function TFhirCitationCitedArtifactVersionList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirCitationCitedArtifactVersionList.GetItemN(index: Integer): TFhirCitationCitedArtifactVersion;
begin
  result := TFhirCitationCitedArtifactVersion(ObjectByIndex[index]);
end;

function TFhirCitationCitedArtifactVersionList.ItemClass: TFslObjectClass;
begin
  result := TFhirCitationCitedArtifactVersion;
end;
function TFhirCitationCitedArtifactVersionList.IndexOf(value: TFhirCitationCitedArtifactVersion): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirCitationCitedArtifactVersionList.Insert(index: Integer): TFhirCitationCitedArtifactVersion;
begin
  result := TFhirCitationCitedArtifactVersion.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirCitationCitedArtifactVersionList.InsertItem(index: Integer; value: TFhirCitationCitedArtifactVersion);
begin
  assert(value is TFhirCitationCitedArtifactVersion);
  Inherited Insert(index, value);
end;

function TFhirCitationCitedArtifactVersionList.Item(index: Integer): TFhirCitationCitedArtifactVersion;
begin
  result := TFhirCitationCitedArtifactVersion(ObjectByIndex[index]);
end;

function TFhirCitationCitedArtifactVersionList.Link: TFhirCitationCitedArtifactVersionList;
begin
  result := TFhirCitationCitedArtifactVersionList(inherited Link);
end;

procedure TFhirCitationCitedArtifactVersionList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirCitationCitedArtifactVersionList.SetItemByIndex(index: Integer; value: TFhirCitationCitedArtifactVersion);
begin
  assert(value is TFhirCitationCitedArtifactVersion);
  FhirCitationCitedArtifactVersions[index] := value;
end;

procedure TFhirCitationCitedArtifactVersionList.SetItemN(index: Integer; value: TFhirCitationCitedArtifactVersion);
begin
  assert(value is TFhirCitationCitedArtifactVersion);
  ObjectByIndex[index] := value;
end;

{ TFhirCitationCitedArtifactStatusDate }

constructor TFhirCitationCitedArtifactStatusDate.Create;
begin
  inherited;
end;

destructor TFhirCitationCitedArtifactStatusDate.Destroy;
begin
  FActivity.free;
  FActual.free;
  FPeriod.free;
  inherited;
end;

procedure TFhirCitationCitedArtifactStatusDate.Assign(oSource : TFslObject);
begin
  inherited;
  activity := TFhirCitationCitedArtifactStatusDate(oSource).activity.Clone;
  actualElement := TFhirCitationCitedArtifactStatusDate(oSource).actualElement.Clone;
  period := TFhirCitationCitedArtifactStatusDate(oSource).period.Clone;
end;

procedure TFhirCitationCitedArtifactStatusDate.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'activity') Then
     list.add(self.link, 'activity', FActivity.Link);
  if (child_name = 'actual') Then
     list.add(self.link, 'actual', FActual.Link);
  if (child_name = 'period') Then
     list.add(self.link, 'period', FPeriod.Link);
end;

procedure TFhirCitationCitedArtifactStatusDate.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'activity', 'CodeableConcept', false, TFhirCodeableConcept, FActivity.Link));
  oList.add(TFHIRProperty.create(self, 'actual', 'boolean', false, TFhirBoolean, FActual.Link));
  oList.add(TFHIRProperty.create(self, 'period', 'Period', false, TFhirPeriod, FPeriod.Link));
end;

function TFhirCitationCitedArtifactStatusDate.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'activity') then
  begin
    Activity := propValue as TFhirCodeableConcept;
    result := propValue;
  end
  else if (propName = 'actual') then
  begin
    ActualElement := asBoolean(propValue);
    result := propValue;
  end
  else if (propName = 'period') then
  begin
    Period := propValue as TFhirPeriod;
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirCitationCitedArtifactStatusDate.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirCitationCitedArtifactStatusDate.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'activity') then result := TFhirCodeableConcept.create()
  else if (propName = 'actual') then result := TFhirBoolean.create()
  else if (propName = 'period') then result := TFhirPeriod.create()
  else result := inherited createPropertyValue(propName);
end;

function TFhirCitationCitedArtifactStatusDate.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'activity') then result := 'CodeableConcept'
  else if (propName = 'actual') then result := 'boolean'
  else if (propName = 'period') then result := 'Period'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirCitationCitedArtifactStatusDate.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'activity') then ActivityElement := nil
  else if (propName = 'actual') then ActualElement := nil
  else if (propName = 'period') then PeriodElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirCitationCitedArtifactStatusDate.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'activity') then ActivityElement := new as TFhirCodeableConcept
  else if (propName = 'actual') then ActualElement := asBoolean(new)
  else if (propName = 'period') then PeriodElement := new as TFhirPeriod
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirCitationCitedArtifactStatusDate.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirCitationCitedArtifactStatusDate.fhirType : string;
begin
  result := 'Citation.citedArtifact.statusDate';
end;

function TFhirCitationCitedArtifactStatusDate.Link : TFhirCitationCitedArtifactStatusDate;
begin
  result := TFhirCitationCitedArtifactStatusDate(inherited Link);
end;

function TFhirCitationCitedArtifactStatusDate.Clone : TFhirCitationCitedArtifactStatusDate;
begin
  result := TFhirCitationCitedArtifactStatusDate(inherited Clone);
end;

function TFhirCitationCitedArtifactStatusDate.equals(other : TObject) : boolean; 
var
  o : TFhirCitationCitedArtifactStatusDate;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirCitationCitedArtifactStatusDate)) then
    result := false
  else
  begin
    o := TFhirCitationCitedArtifactStatusDate(other);
    result := compareDeep(activityElement, o.activityElement, true) and compareDeep(actualElement, o.actualElement, true) and 
      compareDeep(periodElement, o.periodElement, true);
  end;
end;

function TFhirCitationCitedArtifactStatusDate.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FActivity) and isEmptyProp(FActual) and isEmptyProp(FPeriod);
end;

procedure TFhirCitationCitedArtifactStatusDate.listFieldsInOrder(fields : TStringList);
begin
  inherited listFieldsInOrder(fields);
  fields.add('activity');
  fields.add('actual');
  fields.add('period');
end;

function TFhirCitationCitedArtifactStatusDate.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
end;

procedure TFhirCitationCitedArtifactStatusDate.SetActivity(value : TFhirCodeableConcept);
begin
  FActivity.free;
  FActivity := value;
end;

procedure TFhirCitationCitedArtifactStatusDate.SetActual(value : TFhirBoolean);
begin
  FActual.free;
  FActual := value;
end;

function TFhirCitationCitedArtifactStatusDate.GetActualST : Boolean;
begin
  if FActual = nil then
    result := false
  else
    result := FActual.value;
end;

procedure TFhirCitationCitedArtifactStatusDate.SetActualST(value : Boolean);
begin
  if FActual = nil then
    FActual := TFhirBoolean.create;
  FActual.value := value
end;

procedure TFhirCitationCitedArtifactStatusDate.SetPeriod(value : TFhirPeriod);
begin
  FPeriod.free;
  FPeriod := value;
end;

{ TFhirCitationCitedArtifactStatusDateListEnumerator }

constructor TFhirCitationCitedArtifactStatusDateListEnumerator.Create(list : TFhirCitationCitedArtifactStatusDateList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirCitationCitedArtifactStatusDateListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirCitationCitedArtifactStatusDateListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirCitationCitedArtifactStatusDateListEnumerator.GetCurrent : TFhirCitationCitedArtifactStatusDate;
begin
  Result := FList[FIndex];
end;

function TFhirCitationCitedArtifactStatusDateListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirCitationCitedArtifactStatusDateList }

procedure TFhirCitationCitedArtifactStatusDateList.AddItem(value: TFhirCitationCitedArtifactStatusDate);
begin
  assert(value.ClassName = 'TFhirCitationCitedArtifactStatusDate', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirCitationCitedArtifactStatusDate');
  add(value);
end;

function TFhirCitationCitedArtifactStatusDateList.Append: TFhirCitationCitedArtifactStatusDate;
begin
  result := TFhirCitationCitedArtifactStatusDate.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirCitationCitedArtifactStatusDateList.ClearItems;
begin
  Clear;
end;

function TFhirCitationCitedArtifactStatusDateList.GetEnumerator : TFhirCitationCitedArtifactStatusDateListEnumerator;
begin
  result := TFhirCitationCitedArtifactStatusDateListEnumerator.Create(self.link);
end;

function TFhirCitationCitedArtifactStatusDateList.Clone: TFhirCitationCitedArtifactStatusDateList;
begin
  result := TFhirCitationCitedArtifactStatusDateList(inherited Clone);
end;

function TFhirCitationCitedArtifactStatusDateList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirCitationCitedArtifactStatusDateList.GetItemN(index: Integer): TFhirCitationCitedArtifactStatusDate;
begin
  result := TFhirCitationCitedArtifactStatusDate(ObjectByIndex[index]);
end;

function TFhirCitationCitedArtifactStatusDateList.ItemClass: TFslObjectClass;
begin
  result := TFhirCitationCitedArtifactStatusDate;
end;
function TFhirCitationCitedArtifactStatusDateList.IndexOf(value: TFhirCitationCitedArtifactStatusDate): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirCitationCitedArtifactStatusDateList.Insert(index: Integer): TFhirCitationCitedArtifactStatusDate;
begin
  result := TFhirCitationCitedArtifactStatusDate.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirCitationCitedArtifactStatusDateList.InsertItem(index: Integer; value: TFhirCitationCitedArtifactStatusDate);
begin
  assert(value is TFhirCitationCitedArtifactStatusDate);
  Inherited Insert(index, value);
end;

function TFhirCitationCitedArtifactStatusDateList.Item(index: Integer): TFhirCitationCitedArtifactStatusDate;
begin
  result := TFhirCitationCitedArtifactStatusDate(ObjectByIndex[index]);
end;

function TFhirCitationCitedArtifactStatusDateList.Link: TFhirCitationCitedArtifactStatusDateList;
begin
  result := TFhirCitationCitedArtifactStatusDateList(inherited Link);
end;

procedure TFhirCitationCitedArtifactStatusDateList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirCitationCitedArtifactStatusDateList.SetItemByIndex(index: Integer; value: TFhirCitationCitedArtifactStatusDate);
begin
  assert(value is TFhirCitationCitedArtifactStatusDate);
  FhirCitationCitedArtifactStatusDates[index] := value;
end;

procedure TFhirCitationCitedArtifactStatusDateList.SetItemN(index: Integer; value: TFhirCitationCitedArtifactStatusDate);
begin
  assert(value is TFhirCitationCitedArtifactStatusDate);
  ObjectByIndex[index] := value;
end;

{ TFhirCitationCitedArtifactTitle }

constructor TFhirCitationCitedArtifactTitle.Create;
begin
  inherited;
end;

destructor TFhirCitationCitedArtifactTitle.Destroy;
begin
  FType_.free;
  FLanguage.free;
  FText.free;
  inherited;
end;

procedure TFhirCitationCitedArtifactTitle.Assign(oSource : TFslObject);
begin
  inherited;
  type_ := TFhirCitationCitedArtifactTitle(oSource).type_.Clone;
  language := TFhirCitationCitedArtifactTitle(oSource).language.Clone;
  textElement := TFhirCitationCitedArtifactTitle(oSource).textElement.Clone;
end;

procedure TFhirCitationCitedArtifactTitle.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'type') Then
     list.add(self.link, 'type', FType_.Link);
  if (child_name = 'language') Then
     list.add(self.link, 'language', FLanguage.Link);
  if (child_name = 'text') Then
     list.add(self.link, 'text', FText.Link);
end;

procedure TFhirCitationCitedArtifactTitle.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'type', 'CodeableConcept', false, TFhirCodeableConcept, FType_.Link));
  oList.add(TFHIRProperty.create(self, 'language', 'CodeableConcept', false, TFhirCodeableConcept, FLanguage.Link));
  oList.add(TFHIRProperty.create(self, 'text', 'markdown', false, TFhirMarkdown, FText.Link));
end;

function TFhirCitationCitedArtifactTitle.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'type') then
  begin
    Type_ := propValue as TFhirCodeableConcept;
    result := propValue;
  end
  else if (propName = 'language') then
  begin
    Language := propValue as TFhirCodeableConcept;
    result := propValue;
  end
  else if (propName = 'text') then
  begin
    TextElement := asMarkdown(propValue);
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirCitationCitedArtifactTitle.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirCitationCitedArtifactTitle.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'type') then result := TFhirCodeableConcept.create()
  else if (propName = 'language') then result := TFhirCodeableConcept.create()
  else if (propName = 'text') then result := TFhirMarkdown.create()
  else result := inherited createPropertyValue(propName);
end;

function TFhirCitationCitedArtifactTitle.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'type') then result := 'CodeableConcept'
  else if (propName = 'language') then result := 'CodeableConcept'
  else if (propName = 'text') then result := 'markdown'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirCitationCitedArtifactTitle.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'type') then Type_Element := nil
  else if (propName = 'language') then LanguageElement := nil
  else if (propName = 'text') then TextElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirCitationCitedArtifactTitle.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'type') then Type_Element := new as TFhirCodeableConcept
  else if (propName = 'language') then LanguageElement := new as TFhirCodeableConcept
  else if (propName = 'text') then TextElement := asMarkdown(new)
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirCitationCitedArtifactTitle.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirCitationCitedArtifactTitle.fhirType : string;
begin
  result := 'Citation.citedArtifact.title';
end;

function TFhirCitationCitedArtifactTitle.Link : TFhirCitationCitedArtifactTitle;
begin
  result := TFhirCitationCitedArtifactTitle(inherited Link);
end;

function TFhirCitationCitedArtifactTitle.Clone : TFhirCitationCitedArtifactTitle;
begin
  result := TFhirCitationCitedArtifactTitle(inherited Clone);
end;

function TFhirCitationCitedArtifactTitle.equals(other : TObject) : boolean; 
var
  o : TFhirCitationCitedArtifactTitle;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirCitationCitedArtifactTitle)) then
    result := false
  else
  begin
    o := TFhirCitationCitedArtifactTitle(other);
    result := compareDeep(type_Element, o.type_Element, true) and compareDeep(languageElement, o.languageElement, true) and 
      compareDeep(textElement, o.textElement, true);
  end;
end;

function TFhirCitationCitedArtifactTitle.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FType_) and isEmptyProp(FLanguage) and isEmptyProp(FText);
end;

procedure TFhirCitationCitedArtifactTitle.listFieldsInOrder(fields : TStringList);
begin
  inherited listFieldsInOrder(fields);
  fields.add('type');
  fields.add('language');
  fields.add('text');
end;

function TFhirCitationCitedArtifactTitle.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
end;

procedure TFhirCitationCitedArtifactTitle.SetType_(value : TFhirCodeableConcept);
begin
  FType_.free;
  FType_ := value;
end;

procedure TFhirCitationCitedArtifactTitle.SetLanguage(value : TFhirCodeableConcept);
begin
  FLanguage.free;
  FLanguage := value;
end;

procedure TFhirCitationCitedArtifactTitle.SetText(value : TFhirMarkdown);
begin
  FText.free;
  FText := value;
end;

function TFhirCitationCitedArtifactTitle.GetTextST : String;
begin
  if FText = nil then
    result := ''
  else
    result := FText.value;
end;

procedure TFhirCitationCitedArtifactTitle.SetTextST(value : String);
begin
  if value <> '' then
  begin
    if FText = nil then
      FText := TFhirMarkdown.create;
    FText.value := value
  end
  else if FText <> nil then
    FText.value := '';
end;

{ TFhirCitationCitedArtifactTitleListEnumerator }

constructor TFhirCitationCitedArtifactTitleListEnumerator.Create(list : TFhirCitationCitedArtifactTitleList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirCitationCitedArtifactTitleListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirCitationCitedArtifactTitleListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirCitationCitedArtifactTitleListEnumerator.GetCurrent : TFhirCitationCitedArtifactTitle;
begin
  Result := FList[FIndex];
end;

function TFhirCitationCitedArtifactTitleListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirCitationCitedArtifactTitleList }

procedure TFhirCitationCitedArtifactTitleList.AddItem(value: TFhirCitationCitedArtifactTitle);
begin
  assert(value.ClassName = 'TFhirCitationCitedArtifactTitle', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirCitationCitedArtifactTitle');
  add(value);
end;

function TFhirCitationCitedArtifactTitleList.Append: TFhirCitationCitedArtifactTitle;
begin
  result := TFhirCitationCitedArtifactTitle.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirCitationCitedArtifactTitleList.ClearItems;
begin
  Clear;
end;

function TFhirCitationCitedArtifactTitleList.GetEnumerator : TFhirCitationCitedArtifactTitleListEnumerator;
begin
  result := TFhirCitationCitedArtifactTitleListEnumerator.Create(self.link);
end;

function TFhirCitationCitedArtifactTitleList.Clone: TFhirCitationCitedArtifactTitleList;
begin
  result := TFhirCitationCitedArtifactTitleList(inherited Clone);
end;

function TFhirCitationCitedArtifactTitleList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirCitationCitedArtifactTitleList.GetItemN(index: Integer): TFhirCitationCitedArtifactTitle;
begin
  result := TFhirCitationCitedArtifactTitle(ObjectByIndex[index]);
end;

function TFhirCitationCitedArtifactTitleList.ItemClass: TFslObjectClass;
begin
  result := TFhirCitationCitedArtifactTitle;
end;
function TFhirCitationCitedArtifactTitleList.IndexOf(value: TFhirCitationCitedArtifactTitle): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirCitationCitedArtifactTitleList.Insert(index: Integer): TFhirCitationCitedArtifactTitle;
begin
  result := TFhirCitationCitedArtifactTitle.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirCitationCitedArtifactTitleList.InsertItem(index: Integer; value: TFhirCitationCitedArtifactTitle);
begin
  assert(value is TFhirCitationCitedArtifactTitle);
  Inherited Insert(index, value);
end;

function TFhirCitationCitedArtifactTitleList.Item(index: Integer): TFhirCitationCitedArtifactTitle;
begin
  result := TFhirCitationCitedArtifactTitle(ObjectByIndex[index]);
end;

function TFhirCitationCitedArtifactTitleList.Link: TFhirCitationCitedArtifactTitleList;
begin
  result := TFhirCitationCitedArtifactTitleList(inherited Link);
end;

procedure TFhirCitationCitedArtifactTitleList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirCitationCitedArtifactTitleList.SetItemByIndex(index: Integer; value: TFhirCitationCitedArtifactTitle);
begin
  assert(value is TFhirCitationCitedArtifactTitle);
  FhirCitationCitedArtifactTitles[index] := value;
end;

procedure TFhirCitationCitedArtifactTitleList.SetItemN(index: Integer; value: TFhirCitationCitedArtifactTitle);
begin
  assert(value is TFhirCitationCitedArtifactTitle);
  ObjectByIndex[index] := value;
end;

{ TFhirCitationCitedArtifactAbstract }

constructor TFhirCitationCitedArtifactAbstract.Create;
begin
  inherited;
end;

destructor TFhirCitationCitedArtifactAbstract.Destroy;
begin
  FType_.free;
  FLanguage.free;
  FText.free;
  FCopyright.free;
  inherited;
end;

procedure TFhirCitationCitedArtifactAbstract.Assign(oSource : TFslObject);
begin
  inherited;
  type_ := TFhirCitationCitedArtifactAbstract(oSource).type_.Clone;
  language := TFhirCitationCitedArtifactAbstract(oSource).language.Clone;
  textElement := TFhirCitationCitedArtifactAbstract(oSource).textElement.Clone;
  copyrightElement := TFhirCitationCitedArtifactAbstract(oSource).copyrightElement.Clone;
end;

procedure TFhirCitationCitedArtifactAbstract.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'type') Then
     list.add(self.link, 'type', FType_.Link);
  if (child_name = 'language') Then
     list.add(self.link, 'language', FLanguage.Link);
  if (child_name = 'text') Then
     list.add(self.link, 'text', FText.Link);
  if (child_name = 'copyright') Then
     list.add(self.link, 'copyright', FCopyright.Link);
end;

procedure TFhirCitationCitedArtifactAbstract.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'type', 'CodeableConcept', false, TFhirCodeableConcept, FType_.Link));
  oList.add(TFHIRProperty.create(self, 'language', 'CodeableConcept', false, TFhirCodeableConcept, FLanguage.Link));
  oList.add(TFHIRProperty.create(self, 'text', 'markdown', false, TFhirMarkdown, FText.Link));
  oList.add(TFHIRProperty.create(self, 'copyright', 'markdown', false, TFhirMarkdown, FCopyright.Link));
end;

function TFhirCitationCitedArtifactAbstract.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'type') then
  begin
    Type_ := propValue as TFhirCodeableConcept;
    result := propValue;
  end
  else if (propName = 'language') then
  begin
    Language := propValue as TFhirCodeableConcept;
    result := propValue;
  end
  else if (propName = 'text') then
  begin
    TextElement := asMarkdown(propValue);
    result := propValue;
  end
  else if (propName = 'copyright') then
  begin
    CopyrightElement := asMarkdown(propValue);
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirCitationCitedArtifactAbstract.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirCitationCitedArtifactAbstract.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'type') then result := TFhirCodeableConcept.create()
  else if (propName = 'language') then result := TFhirCodeableConcept.create()
  else if (propName = 'text') then result := TFhirMarkdown.create()
  else if (propName = 'copyright') then result := TFhirMarkdown.create()
  else result := inherited createPropertyValue(propName);
end;

function TFhirCitationCitedArtifactAbstract.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'type') then result := 'CodeableConcept'
  else if (propName = 'language') then result := 'CodeableConcept'
  else if (propName = 'text') then result := 'markdown'
  else if (propName = 'copyright') then result := 'markdown'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirCitationCitedArtifactAbstract.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'type') then Type_Element := nil
  else if (propName = 'language') then LanguageElement := nil
  else if (propName = 'text') then TextElement := nil
  else if (propName = 'copyright') then CopyrightElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirCitationCitedArtifactAbstract.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'type') then Type_Element := new as TFhirCodeableConcept
  else if (propName = 'language') then LanguageElement := new as TFhirCodeableConcept
  else if (propName = 'text') then TextElement := asMarkdown(new)
  else if (propName = 'copyright') then CopyrightElement := asMarkdown(new)
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirCitationCitedArtifactAbstract.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirCitationCitedArtifactAbstract.fhirType : string;
begin
  result := 'Citation.citedArtifact.abstract';
end;

function TFhirCitationCitedArtifactAbstract.Link : TFhirCitationCitedArtifactAbstract;
begin
  result := TFhirCitationCitedArtifactAbstract(inherited Link);
end;

function TFhirCitationCitedArtifactAbstract.Clone : TFhirCitationCitedArtifactAbstract;
begin
  result := TFhirCitationCitedArtifactAbstract(inherited Clone);
end;

function TFhirCitationCitedArtifactAbstract.equals(other : TObject) : boolean; 
var
  o : TFhirCitationCitedArtifactAbstract;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirCitationCitedArtifactAbstract)) then
    result := false
  else
  begin
    o := TFhirCitationCitedArtifactAbstract(other);
    result := compareDeep(type_Element, o.type_Element, true) and compareDeep(languageElement, o.languageElement, true) and 
      compareDeep(textElement, o.textElement, true) and compareDeep(copyrightElement, o.copyrightElement, true);
  end;
end;

function TFhirCitationCitedArtifactAbstract.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FType_) and isEmptyProp(FLanguage) and isEmptyProp(FText) and isEmptyProp(FCopyright);
end;

procedure TFhirCitationCitedArtifactAbstract.listFieldsInOrder(fields : TStringList);
begin
  inherited listFieldsInOrder(fields);
  fields.add('type');
  fields.add('language');
  fields.add('text');
  fields.add('copyright');
end;

function TFhirCitationCitedArtifactAbstract.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
end;

procedure TFhirCitationCitedArtifactAbstract.SetType_(value : TFhirCodeableConcept);
begin
  FType_.free;
  FType_ := value;
end;

procedure TFhirCitationCitedArtifactAbstract.SetLanguage(value : TFhirCodeableConcept);
begin
  FLanguage.free;
  FLanguage := value;
end;

procedure TFhirCitationCitedArtifactAbstract.SetText(value : TFhirMarkdown);
begin
  FText.free;
  FText := value;
end;

function TFhirCitationCitedArtifactAbstract.GetTextST : String;
begin
  if FText = nil then
    result := ''
  else
    result := FText.value;
end;

procedure TFhirCitationCitedArtifactAbstract.SetTextST(value : String);
begin
  if value <> '' then
  begin
    if FText = nil then
      FText := TFhirMarkdown.create;
    FText.value := value
  end
  else if FText <> nil then
    FText.value := '';
end;

procedure TFhirCitationCitedArtifactAbstract.SetCopyright(value : TFhirMarkdown);
begin
  FCopyright.free;
  FCopyright := value;
end;

function TFhirCitationCitedArtifactAbstract.GetCopyrightST : String;
begin
  if FCopyright = nil then
    result := ''
  else
    result := FCopyright.value;
end;

procedure TFhirCitationCitedArtifactAbstract.SetCopyrightST(value : String);
begin
  if value <> '' then
  begin
    if FCopyright = nil then
      FCopyright := TFhirMarkdown.create;
    FCopyright.value := value
  end
  else if FCopyright <> nil then
    FCopyright.value := '';
end;

{ TFhirCitationCitedArtifactAbstractListEnumerator }

constructor TFhirCitationCitedArtifactAbstractListEnumerator.Create(list : TFhirCitationCitedArtifactAbstractList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirCitationCitedArtifactAbstractListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirCitationCitedArtifactAbstractListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirCitationCitedArtifactAbstractListEnumerator.GetCurrent : TFhirCitationCitedArtifactAbstract;
begin
  Result := FList[FIndex];
end;

function TFhirCitationCitedArtifactAbstractListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirCitationCitedArtifactAbstractList }

procedure TFhirCitationCitedArtifactAbstractList.AddItem(value: TFhirCitationCitedArtifactAbstract);
begin
  assert(value.ClassName = 'TFhirCitationCitedArtifactAbstract', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirCitationCitedArtifactAbstract');
  add(value);
end;

function TFhirCitationCitedArtifactAbstractList.Append: TFhirCitationCitedArtifactAbstract;
begin
  result := TFhirCitationCitedArtifactAbstract.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirCitationCitedArtifactAbstractList.ClearItems;
begin
  Clear;
end;

function TFhirCitationCitedArtifactAbstractList.GetEnumerator : TFhirCitationCitedArtifactAbstractListEnumerator;
begin
  result := TFhirCitationCitedArtifactAbstractListEnumerator.Create(self.link);
end;

function TFhirCitationCitedArtifactAbstractList.Clone: TFhirCitationCitedArtifactAbstractList;
begin
  result := TFhirCitationCitedArtifactAbstractList(inherited Clone);
end;

function TFhirCitationCitedArtifactAbstractList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirCitationCitedArtifactAbstractList.GetItemN(index: Integer): TFhirCitationCitedArtifactAbstract;
begin
  result := TFhirCitationCitedArtifactAbstract(ObjectByIndex[index]);
end;

function TFhirCitationCitedArtifactAbstractList.ItemClass: TFslObjectClass;
begin
  result := TFhirCitationCitedArtifactAbstract;
end;
function TFhirCitationCitedArtifactAbstractList.IndexOf(value: TFhirCitationCitedArtifactAbstract): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirCitationCitedArtifactAbstractList.Insert(index: Integer): TFhirCitationCitedArtifactAbstract;
begin
  result := TFhirCitationCitedArtifactAbstract.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirCitationCitedArtifactAbstractList.InsertItem(index: Integer; value: TFhirCitationCitedArtifactAbstract);
begin
  assert(value is TFhirCitationCitedArtifactAbstract);
  Inherited Insert(index, value);
end;

function TFhirCitationCitedArtifactAbstractList.Item(index: Integer): TFhirCitationCitedArtifactAbstract;
begin
  result := TFhirCitationCitedArtifactAbstract(ObjectByIndex[index]);
end;

function TFhirCitationCitedArtifactAbstractList.Link: TFhirCitationCitedArtifactAbstractList;
begin
  result := TFhirCitationCitedArtifactAbstractList(inherited Link);
end;

procedure TFhirCitationCitedArtifactAbstractList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirCitationCitedArtifactAbstractList.SetItemByIndex(index: Integer; value: TFhirCitationCitedArtifactAbstract);
begin
  assert(value is TFhirCitationCitedArtifactAbstract);
  FhirCitationCitedArtifactAbstracts[index] := value;
end;

procedure TFhirCitationCitedArtifactAbstractList.SetItemN(index: Integer; value: TFhirCitationCitedArtifactAbstract);
begin
  assert(value is TFhirCitationCitedArtifactAbstract);
  ObjectByIndex[index] := value;
end;

{ TFhirCitationCitedArtifactPart }

constructor TFhirCitationCitedArtifactPart.Create;
begin
  inherited;
end;

destructor TFhirCitationCitedArtifactPart.Destroy;
begin
  FType_.free;
  FValue.free;
  FBaseCitation.free;
  inherited;
end;

procedure TFhirCitationCitedArtifactPart.Assign(oSource : TFslObject);
begin
  inherited;
  type_ := TFhirCitationCitedArtifactPart(oSource).type_.Clone;
  valueElement := TFhirCitationCitedArtifactPart(oSource).valueElement.Clone;
  baseCitation := TFhirCitationCitedArtifactPart(oSource).baseCitation.Clone;
end;

procedure TFhirCitationCitedArtifactPart.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'type') Then
     list.add(self.link, 'type', FType_.Link);
  if (child_name = 'value') Then
     list.add(self.link, 'value', FValue.Link);
  if (child_name = 'baseCitation') Then
     list.add(self.link, 'baseCitation', FBaseCitation.Link);
end;

procedure TFhirCitationCitedArtifactPart.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'type', 'CodeableConcept', false, TFhirCodeableConcept, FType_.Link));
  oList.add(TFHIRProperty.create(self, 'value', 'string', false, TFhirString, FValue.Link));
  oList.add(TFHIRProperty.create(self, 'baseCitation', 'Reference', false, TFhirReference, FBaseCitation.Link));
end;

function TFhirCitationCitedArtifactPart.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'type') then
  begin
    Type_ := propValue as TFhirCodeableConcept;
    result := propValue;
  end
  else if (propName = 'value') then
  begin
    ValueElement := asString(propValue);
    result := propValue;
  end
  else if (propName = 'baseCitation') then
  begin
    BaseCitation := propValue as TFhirReference;
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirCitationCitedArtifactPart.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirCitationCitedArtifactPart.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'type') then result := TFhirCodeableConcept.create()
  else if (propName = 'value') then result := TFhirString.create()
  else if (propName = 'baseCitation') then result := TFhirReference.create()
  else result := inherited createPropertyValue(propName);
end;

function TFhirCitationCitedArtifactPart.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'type') then result := 'CodeableConcept'
  else if (propName = 'value') then result := 'string'
  else if (propName = 'baseCitation') then result := 'Reference'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirCitationCitedArtifactPart.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'type') then Type_Element := nil
  else if (propName = 'value') then ValueElement := nil
  else if (propName = 'baseCitation') then BaseCitationElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirCitationCitedArtifactPart.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'type') then Type_Element := new as TFhirCodeableConcept
  else if (propName = 'value') then ValueElement := asString(new)
  else if (propName = 'baseCitation') then BaseCitationElement := new as TFhirReference
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirCitationCitedArtifactPart.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirCitationCitedArtifactPart.fhirType : string;
begin
  result := 'Citation.citedArtifact.part';
end;

function TFhirCitationCitedArtifactPart.Link : TFhirCitationCitedArtifactPart;
begin
  result := TFhirCitationCitedArtifactPart(inherited Link);
end;

function TFhirCitationCitedArtifactPart.Clone : TFhirCitationCitedArtifactPart;
begin
  result := TFhirCitationCitedArtifactPart(inherited Clone);
end;

function TFhirCitationCitedArtifactPart.equals(other : TObject) : boolean; 
var
  o : TFhirCitationCitedArtifactPart;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirCitationCitedArtifactPart)) then
    result := false
  else
  begin
    o := TFhirCitationCitedArtifactPart(other);
    result := compareDeep(type_Element, o.type_Element, true) and compareDeep(valueElement, o.valueElement, true) and 
      compareDeep(baseCitationElement, o.baseCitationElement, true);
  end;
end;

function TFhirCitationCitedArtifactPart.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FType_) and isEmptyProp(FValue) and isEmptyProp(FBaseCitation);
end;

procedure TFhirCitationCitedArtifactPart.listFieldsInOrder(fields : TStringList);
begin
  inherited listFieldsInOrder(fields);
  fields.add('type');
  fields.add('value');
  fields.add('baseCitation');
end;

function TFhirCitationCitedArtifactPart.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
end;

procedure TFhirCitationCitedArtifactPart.SetType_(value : TFhirCodeableConcept);
begin
  FType_.free;
  FType_ := value;
end;

procedure TFhirCitationCitedArtifactPart.SetValue(value : TFhirString);
begin
  FValue.free;
  FValue := value;
end;

function TFhirCitationCitedArtifactPart.GetValueST : String;
begin
  if FValue = nil then
    result := ''
  else
    result := FValue.value;
end;

procedure TFhirCitationCitedArtifactPart.SetValueST(value : String);
begin
  if value <> '' then
  begin
    if FValue = nil then
      FValue := TFhirString.create;
    FValue.value := value
  end
  else if FValue <> nil then
    FValue.value := '';
end;

procedure TFhirCitationCitedArtifactPart.SetBaseCitation(value : TFhirReference);
begin
  FBaseCitation.free;
  FBaseCitation := value;
end;

{ TFhirCitationCitedArtifactPartListEnumerator }

constructor TFhirCitationCitedArtifactPartListEnumerator.Create(list : TFhirCitationCitedArtifactPartList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirCitationCitedArtifactPartListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirCitationCitedArtifactPartListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirCitationCitedArtifactPartListEnumerator.GetCurrent : TFhirCitationCitedArtifactPart;
begin
  Result := FList[FIndex];
end;

function TFhirCitationCitedArtifactPartListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirCitationCitedArtifactPartList }

procedure TFhirCitationCitedArtifactPartList.AddItem(value: TFhirCitationCitedArtifactPart);
begin
  assert(value.ClassName = 'TFhirCitationCitedArtifactPart', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirCitationCitedArtifactPart');
  add(value);
end;

function TFhirCitationCitedArtifactPartList.Append: TFhirCitationCitedArtifactPart;
begin
  result := TFhirCitationCitedArtifactPart.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirCitationCitedArtifactPartList.ClearItems;
begin
  Clear;
end;

function TFhirCitationCitedArtifactPartList.GetEnumerator : TFhirCitationCitedArtifactPartListEnumerator;
begin
  result := TFhirCitationCitedArtifactPartListEnumerator.Create(self.link);
end;

function TFhirCitationCitedArtifactPartList.Clone: TFhirCitationCitedArtifactPartList;
begin
  result := TFhirCitationCitedArtifactPartList(inherited Clone);
end;

function TFhirCitationCitedArtifactPartList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirCitationCitedArtifactPartList.GetItemN(index: Integer): TFhirCitationCitedArtifactPart;
begin
  result := TFhirCitationCitedArtifactPart(ObjectByIndex[index]);
end;

function TFhirCitationCitedArtifactPartList.ItemClass: TFslObjectClass;
begin
  result := TFhirCitationCitedArtifactPart;
end;
function TFhirCitationCitedArtifactPartList.IndexOf(value: TFhirCitationCitedArtifactPart): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirCitationCitedArtifactPartList.Insert(index: Integer): TFhirCitationCitedArtifactPart;
begin
  result := TFhirCitationCitedArtifactPart.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirCitationCitedArtifactPartList.InsertItem(index: Integer; value: TFhirCitationCitedArtifactPart);
begin
  assert(value is TFhirCitationCitedArtifactPart);
  Inherited Insert(index, value);
end;

function TFhirCitationCitedArtifactPartList.Item(index: Integer): TFhirCitationCitedArtifactPart;
begin
  result := TFhirCitationCitedArtifactPart(ObjectByIndex[index]);
end;

function TFhirCitationCitedArtifactPartList.Link: TFhirCitationCitedArtifactPartList;
begin
  result := TFhirCitationCitedArtifactPartList(inherited Link);
end;

procedure TFhirCitationCitedArtifactPartList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirCitationCitedArtifactPartList.SetItemByIndex(index: Integer; value: TFhirCitationCitedArtifactPart);
begin
  assert(value is TFhirCitationCitedArtifactPart);
  FhirCitationCitedArtifactParts[index] := value;
end;

procedure TFhirCitationCitedArtifactPartList.SetItemN(index: Integer; value: TFhirCitationCitedArtifactPart);
begin
  assert(value is TFhirCitationCitedArtifactPart);
  ObjectByIndex[index] := value;
end;

{ TFhirCitationCitedArtifactRelatesTo }

constructor TFhirCitationCitedArtifactRelatesTo.Create;
begin
  inherited;
end;

destructor TFhirCitationCitedArtifactRelatesTo.Destroy;
begin
  FRelationshipType.free;
  FTargetClassifierList.Free;
  FTarget.free;
  inherited;
end;

procedure TFhirCitationCitedArtifactRelatesTo.Assign(oSource : TFslObject);
begin
  inherited;
  relationshipType := TFhirCitationCitedArtifactRelatesTo(oSource).relationshipType.Clone;
  if (TFhirCitationCitedArtifactRelatesTo(oSource).FTargetClassifierList = nil) then
  begin
    FTargetClassifierList.free;
    FTargetClassifierList := nil;
  end
  else
  begin
    if FTargetClassifierList = nil then
      FTargetClassifierList := TFhirCodeableConceptList.Create;
    FTargetClassifierList.Assign(TFhirCitationCitedArtifactRelatesTo(oSource).FTargetClassifierList);
  end;
  target := TFhirCitationCitedArtifactRelatesTo(oSource).target.Clone;
end;

procedure TFhirCitationCitedArtifactRelatesTo.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'relationshipType') Then
     list.add(self.link, 'relationshipType', FRelationshipType.Link);
  if (child_name = 'targetClassifier') Then
    list.addAll(self, 'targetClassifier', FTargetClassifierList);
  if (child_name = 'target[x]') or (child_name = 'target') Then
     list.add(self.link, 'target[x]', FTarget.Link);
end;

procedure TFhirCitationCitedArtifactRelatesTo.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'relationshipType', 'CodeableConcept', false, TFhirCodeableConcept, FRelationshipType.Link));
  oList.add(TFHIRProperty.create(self, 'targetClassifier', 'CodeableConcept', true, TFhirCodeableConcept, FTargetClassifierList.Link));
  oList.add(TFHIRProperty.create(self, 'target[x]', 'uri|Identifier|Reference|Attachment', false, TFhirDataType, FTarget.Link));
end;

function TFhirCitationCitedArtifactRelatesTo.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'relationshipType') then
  begin
    RelationshipType := propValue as TFhirCodeableConcept;
    result := propValue;
  end
  else if (propName = 'targetClassifier') then
  begin
    TargetClassifierList.add(propValue as TFhirCodeableConcept);
    result := propValue;
  end
  else if (isMatchingName(propName, 'target', ['Uri', 'Identifier', 'Reference', 'Attachment'])) then
  begin
    Target := propValue as TFhirDataType;
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirCitationCitedArtifactRelatesTo.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'targetClassifier') then TargetClassifierList.insertItem(index, propValue as TFhirCodeableConcept)
  else inherited;
end;

function TFhirCitationCitedArtifactRelatesTo.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'relationshipType') then result := TFhirCodeableConcept.create()
  else if (propName = 'targetClassifier') then result := TargetClassifierList.new()
  else if (isMatchingName(propName, 'target', ['Uri', 'Identifier', 'Reference', 'Attachment'])) then raise EFHIRException.create('Cannot make property Target')
  else result := inherited createPropertyValue(propName);
end;

function TFhirCitationCitedArtifactRelatesTo.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'relationshipType') then result := 'CodeableConcept'
  else if (propName = 'targetClassifier') then result := 'CodeableConcept'
  else if (propName = 'target[x]') then result := 'uri|Identifier|Reference|Attachment'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirCitationCitedArtifactRelatesTo.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'relationshipType') then RelationshipTypeElement := nil
  else if (propName = 'targetClassifier') then deletePropertyValue('targetClassifier', TargetClassifierList, value)
  else if (isMatchingName(propName, 'target', ['Uri', 'Identifier', 'Reference', 'Attachment'])) then TargetElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirCitationCitedArtifactRelatesTo.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'relationshipType') then RelationshipTypeElement := new as TFhirCodeableConcept
  else if (propName = 'targetClassifier') then replacePropertyValue('targetClassifier', TargetClassifierList, existing, new)
  else if (isMatchingName(propName, 'target', ['Uri', 'Identifier', 'Reference', 'Attachment'])) then TargetElement := new as TFhirDataType
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirCitationCitedArtifactRelatesTo.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'targetClassifier') then TargetClassifierList.move(source, destination)
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirCitationCitedArtifactRelatesTo.fhirType : string;
begin
  result := 'Citation.citedArtifact.relatesTo';
end;

function TFhirCitationCitedArtifactRelatesTo.Link : TFhirCitationCitedArtifactRelatesTo;
begin
  result := TFhirCitationCitedArtifactRelatesTo(inherited Link);
end;

function TFhirCitationCitedArtifactRelatesTo.Clone : TFhirCitationCitedArtifactRelatesTo;
begin
  result := TFhirCitationCitedArtifactRelatesTo(inherited Clone);
end;

function TFhirCitationCitedArtifactRelatesTo.equals(other : TObject) : boolean; 
var
  o : TFhirCitationCitedArtifactRelatesTo;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirCitationCitedArtifactRelatesTo)) then
    result := false
  else
  begin
    o := TFhirCitationCitedArtifactRelatesTo(other);
    result := compareDeep(relationshipTypeElement, o.relationshipTypeElement, true) and 
      compareDeep(targetClassifierList, o.targetClassifierList, true) and compareDeep(targetElement, o.targetElement, true);
  end;
end;

function TFhirCitationCitedArtifactRelatesTo.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FRelationshipType) and isEmptyProp(FtargetClassifierList) and isEmptyProp(FTarget);
end;

procedure TFhirCitationCitedArtifactRelatesTo.listFieldsInOrder(fields : TStringList);
begin
  inherited listFieldsInOrder(fields);
  fields.add('relationshipType');
  fields.add('targetClassifier');
  fields.add('target[x]');
end;

function TFhirCitationCitedArtifactRelatesTo.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FTargetClassifierList.sizeInBytes(magic));
end;

procedure TFhirCitationCitedArtifactRelatesTo.SetRelationshipType(value : TFhirCodeableConcept);
begin
  FRelationshipType.free;
  FRelationshipType := value;
end;

function TFhirCitationCitedArtifactRelatesTo.GetTargetClassifierList : TFhirCodeableConceptList;
begin
  if FTargetClassifierList = nil then
    FTargetClassifierList := TFhirCodeableConceptList.Create;
  result := FTargetClassifierList;
end;

function TFhirCitationCitedArtifactRelatesTo.GetHasTargetClassifierList : boolean;
begin
  result := (FTargetClassifierList <> nil) and (FTargetClassifierList.count > 0);
end;

procedure TFhirCitationCitedArtifactRelatesTo.SetTarget(value : TFhirDataType);
begin
  FTarget.free;
  FTarget := value;
end;

{ TFhirCitationCitedArtifactRelatesToListEnumerator }

constructor TFhirCitationCitedArtifactRelatesToListEnumerator.Create(list : TFhirCitationCitedArtifactRelatesToList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirCitationCitedArtifactRelatesToListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirCitationCitedArtifactRelatesToListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirCitationCitedArtifactRelatesToListEnumerator.GetCurrent : TFhirCitationCitedArtifactRelatesTo;
begin
  Result := FList[FIndex];
end;

function TFhirCitationCitedArtifactRelatesToListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirCitationCitedArtifactRelatesToList }

procedure TFhirCitationCitedArtifactRelatesToList.AddItem(value: TFhirCitationCitedArtifactRelatesTo);
begin
  assert(value.ClassName = 'TFhirCitationCitedArtifactRelatesTo', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirCitationCitedArtifactRelatesTo');
  add(value);
end;

function TFhirCitationCitedArtifactRelatesToList.Append: TFhirCitationCitedArtifactRelatesTo;
begin
  result := TFhirCitationCitedArtifactRelatesTo.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirCitationCitedArtifactRelatesToList.ClearItems;
begin
  Clear;
end;

function TFhirCitationCitedArtifactRelatesToList.GetEnumerator : TFhirCitationCitedArtifactRelatesToListEnumerator;
begin
  result := TFhirCitationCitedArtifactRelatesToListEnumerator.Create(self.link);
end;

function TFhirCitationCitedArtifactRelatesToList.Clone: TFhirCitationCitedArtifactRelatesToList;
begin
  result := TFhirCitationCitedArtifactRelatesToList(inherited Clone);
end;

function TFhirCitationCitedArtifactRelatesToList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirCitationCitedArtifactRelatesToList.GetItemN(index: Integer): TFhirCitationCitedArtifactRelatesTo;
begin
  result := TFhirCitationCitedArtifactRelatesTo(ObjectByIndex[index]);
end;

function TFhirCitationCitedArtifactRelatesToList.ItemClass: TFslObjectClass;
begin
  result := TFhirCitationCitedArtifactRelatesTo;
end;
function TFhirCitationCitedArtifactRelatesToList.IndexOf(value: TFhirCitationCitedArtifactRelatesTo): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirCitationCitedArtifactRelatesToList.Insert(index: Integer): TFhirCitationCitedArtifactRelatesTo;
begin
  result := TFhirCitationCitedArtifactRelatesTo.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirCitationCitedArtifactRelatesToList.InsertItem(index: Integer; value: TFhirCitationCitedArtifactRelatesTo);
begin
  assert(value is TFhirCitationCitedArtifactRelatesTo);
  Inherited Insert(index, value);
end;

function TFhirCitationCitedArtifactRelatesToList.Item(index: Integer): TFhirCitationCitedArtifactRelatesTo;
begin
  result := TFhirCitationCitedArtifactRelatesTo(ObjectByIndex[index]);
end;

function TFhirCitationCitedArtifactRelatesToList.Link: TFhirCitationCitedArtifactRelatesToList;
begin
  result := TFhirCitationCitedArtifactRelatesToList(inherited Link);
end;

procedure TFhirCitationCitedArtifactRelatesToList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirCitationCitedArtifactRelatesToList.SetItemByIndex(index: Integer; value: TFhirCitationCitedArtifactRelatesTo);
begin
  assert(value is TFhirCitationCitedArtifactRelatesTo);
  FhirCitationCitedArtifactRelatesTos[index] := value;
end;

procedure TFhirCitationCitedArtifactRelatesToList.SetItemN(index: Integer; value: TFhirCitationCitedArtifactRelatesTo);
begin
  assert(value is TFhirCitationCitedArtifactRelatesTo);
  ObjectByIndex[index] := value;
end;

{ TFhirCitationCitedArtifactPublicationForm }

constructor TFhirCitationCitedArtifactPublicationForm.Create;
begin
  inherited;
end;

destructor TFhirCitationCitedArtifactPublicationForm.Destroy;
begin
  FPublishedIn.free;
  FPeriodicRelease.free;
  FArticleDate.free;
  FLastRevisionDate.free;
  FLanguageList.Free;
  FAccessionNumber.free;
  FPageString.free;
  FFirstPage.free;
  FLastPage.free;
  FPageCount.free;
  FCopyright.free;
  inherited;
end;

procedure TFhirCitationCitedArtifactPublicationForm.Assign(oSource : TFslObject);
begin
  inherited;
  publishedIn := TFhirCitationCitedArtifactPublicationForm(oSource).publishedIn.Clone;
  periodicRelease := TFhirCitationCitedArtifactPublicationForm(oSource).periodicRelease.Clone;
  articleDateElement := TFhirCitationCitedArtifactPublicationForm(oSource).articleDateElement.Clone;
  lastRevisionDateElement := TFhirCitationCitedArtifactPublicationForm(oSource).lastRevisionDateElement.Clone;
  if (TFhirCitationCitedArtifactPublicationForm(oSource).FLanguageList = nil) then
  begin
    FLanguageList.free;
    FLanguageList := nil;
  end
  else
  begin
    if FLanguageList = nil then
      FLanguageList := TFhirCodeableConceptList.Create;
    FLanguageList.Assign(TFhirCitationCitedArtifactPublicationForm(oSource).FLanguageList);
  end;
  accessionNumberElement := TFhirCitationCitedArtifactPublicationForm(oSource).accessionNumberElement.Clone;
  pageStringElement := TFhirCitationCitedArtifactPublicationForm(oSource).pageStringElement.Clone;
  firstPageElement := TFhirCitationCitedArtifactPublicationForm(oSource).firstPageElement.Clone;
  lastPageElement := TFhirCitationCitedArtifactPublicationForm(oSource).lastPageElement.Clone;
  pageCountElement := TFhirCitationCitedArtifactPublicationForm(oSource).pageCountElement.Clone;
  copyrightElement := TFhirCitationCitedArtifactPublicationForm(oSource).copyrightElement.Clone;
end;

procedure TFhirCitationCitedArtifactPublicationForm.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'publishedIn') Then
     list.add(self.link, 'publishedIn', FPublishedIn.Link);
  if (child_name = 'periodicRelease') Then
     list.add(self.link, 'periodicRelease', FPeriodicRelease.Link);
  if (child_name = 'articleDate') Then
     list.add(self.link, 'articleDate', FArticleDate.Link);
  if (child_name = 'lastRevisionDate') Then
     list.add(self.link, 'lastRevisionDate', FLastRevisionDate.Link);
  if (child_name = 'language') Then
    list.addAll(self, 'language', FLanguageList);
  if (child_name = 'accessionNumber') Then
     list.add(self.link, 'accessionNumber', FAccessionNumber.Link);
  if (child_name = 'pageString') Then
     list.add(self.link, 'pageString', FPageString.Link);
  if (child_name = 'firstPage') Then
     list.add(self.link, 'firstPage', FFirstPage.Link);
  if (child_name = 'lastPage') Then
     list.add(self.link, 'lastPage', FLastPage.Link);
  if (child_name = 'pageCount') Then
     list.add(self.link, 'pageCount', FPageCount.Link);
  if (child_name = 'copyright') Then
     list.add(self.link, 'copyright', FCopyright.Link);
end;

procedure TFhirCitationCitedArtifactPublicationForm.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'publishedIn', 'BackboneElement', false, TFhirCitationCitedArtifactPublicationFormPublishedIn, FPublishedIn.Link));
  oList.add(TFHIRProperty.create(self, 'periodicRelease', 'BackboneElement', false, TFhirCitationCitedArtifactPublicationFormPeriodicRelease, FPeriodicRelease.Link));
  oList.add(TFHIRProperty.create(self, 'articleDate', 'dateTime', false, TFhirDateTime, FArticleDate.Link));
  oList.add(TFHIRProperty.create(self, 'lastRevisionDate', 'dateTime', false, TFhirDateTime, FLastRevisionDate.Link));
  oList.add(TFHIRProperty.create(self, 'language', 'CodeableConcept', true, TFhirCodeableConcept, FLanguageList.Link));
  oList.add(TFHIRProperty.create(self, 'accessionNumber', 'string', false, TFhirString, FAccessionNumber.Link));
  oList.add(TFHIRProperty.create(self, 'pageString', 'string', false, TFhirString, FPageString.Link));
  oList.add(TFHIRProperty.create(self, 'firstPage', 'string', false, TFhirString, FFirstPage.Link));
  oList.add(TFHIRProperty.create(self, 'lastPage', 'string', false, TFhirString, FLastPage.Link));
  oList.add(TFHIRProperty.create(self, 'pageCount', 'string', false, TFhirString, FPageCount.Link));
  oList.add(TFHIRProperty.create(self, 'copyright', 'markdown', false, TFhirMarkdown, FCopyright.Link));
end;

function TFhirCitationCitedArtifactPublicationForm.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'publishedIn') then
  begin
    PublishedIn := propValue as TFhirCitationCitedArtifactPublicationFormPublishedIn;
    result := propValue;
  end
  else if (propName = 'periodicRelease') then
  begin
    PeriodicRelease := propValue as TFhirCitationCitedArtifactPublicationFormPeriodicRelease;
    result := propValue;
  end
  else if (propName = 'articleDate') then
  begin
    ArticleDateElement := asDateTime(propValue);
    result := propValue;
  end
  else if (propName = 'lastRevisionDate') then
  begin
    LastRevisionDateElement := asDateTime(propValue);
    result := propValue;
  end
  else if (propName = 'language') then
  begin
    LanguageList.add(propValue as TFhirCodeableConcept);
    result := propValue;
  end
  else if (propName = 'accessionNumber') then
  begin
    AccessionNumberElement := asString(propValue);
    result := propValue;
  end
  else if (propName = 'pageString') then
  begin
    PageStringElement := asString(propValue);
    result := propValue;
  end
  else if (propName = 'firstPage') then
  begin
    FirstPageElement := asString(propValue);
    result := propValue;
  end
  else if (propName = 'lastPage') then
  begin
    LastPageElement := asString(propValue);
    result := propValue;
  end
  else if (propName = 'pageCount') then
  begin
    PageCountElement := asString(propValue);
    result := propValue;
  end
  else if (propName = 'copyright') then
  begin
    CopyrightElement := asMarkdown(propValue);
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirCitationCitedArtifactPublicationForm.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'language') then LanguageList.insertItem(index, propValue as TFhirCodeableConcept)
  else inherited;
end;

function TFhirCitationCitedArtifactPublicationForm.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'publishedIn') then result := TFhirCitationCitedArtifactPublicationFormPublishedIn.create()
  else if (propName = 'periodicRelease') then result := TFhirCitationCitedArtifactPublicationFormPeriodicRelease.create()
  else if (propName = 'articleDate') then result := TFhirDateTime.create()
  else if (propName = 'lastRevisionDate') then result := TFhirDateTime.create()
  else if (propName = 'language') then result := LanguageList.new()
  else if (propName = 'accessionNumber') then result := TFhirString.create()
  else if (propName = 'pageString') then result := TFhirString.create()
  else if (propName = 'firstPage') then result := TFhirString.create()
  else if (propName = 'lastPage') then result := TFhirString.create()
  else if (propName = 'pageCount') then result := TFhirString.create()
  else if (propName = 'copyright') then result := TFhirMarkdown.create()
  else result := inherited createPropertyValue(propName);
end;

function TFhirCitationCitedArtifactPublicationForm.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'publishedIn') then result := 'BackboneElement'
  else if (propName = 'periodicRelease') then result := 'BackboneElement'
  else if (propName = 'articleDate') then result := 'dateTime'
  else if (propName = 'lastRevisionDate') then result := 'dateTime'
  else if (propName = 'language') then result := 'CodeableConcept'
  else if (propName = 'accessionNumber') then result := 'string'
  else if (propName = 'pageString') then result := 'string'
  else if (propName = 'firstPage') then result := 'string'
  else if (propName = 'lastPage') then result := 'string'
  else if (propName = 'pageCount') then result := 'string'
  else if (propName = 'copyright') then result := 'markdown'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirCitationCitedArtifactPublicationForm.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'publishedIn') then PublishedInElement := nil
  else if (propName = 'periodicRelease') then PeriodicReleaseElement := nil
  else if (propName = 'articleDate') then ArticleDateElement := nil
  else if (propName = 'lastRevisionDate') then LastRevisionDateElement := nil
  else if (propName = 'language') then deletePropertyValue('language', LanguageList, value)
  else if (propName = 'accessionNumber') then AccessionNumberElement := nil
  else if (propName = 'pageString') then PageStringElement := nil
  else if (propName = 'firstPage') then FirstPageElement := nil
  else if (propName = 'lastPage') then LastPageElement := nil
  else if (propName = 'pageCount') then PageCountElement := nil
  else if (propName = 'copyright') then CopyrightElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirCitationCitedArtifactPublicationForm.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'publishedIn') then PublishedInElement := new as TFhirCitationCitedArtifactPublicationFormPublishedIn
  else if (propName = 'periodicRelease') then PeriodicReleaseElement := new as TFhirCitationCitedArtifactPublicationFormPeriodicRelease
  else if (propName = 'articleDate') then ArticleDateElement := asDateTime(new)
  else if (propName = 'lastRevisionDate') then LastRevisionDateElement := asDateTime(new)
  else if (propName = 'language') then replacePropertyValue('language', LanguageList, existing, new)
  else if (propName = 'accessionNumber') then AccessionNumberElement := asString(new)
  else if (propName = 'pageString') then PageStringElement := asString(new)
  else if (propName = 'firstPage') then FirstPageElement := asString(new)
  else if (propName = 'lastPage') then LastPageElement := asString(new)
  else if (propName = 'pageCount') then PageCountElement := asString(new)
  else if (propName = 'copyright') then CopyrightElement := asMarkdown(new)
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirCitationCitedArtifactPublicationForm.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'language') then LanguageList.move(source, destination)
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirCitationCitedArtifactPublicationForm.fhirType : string;
begin
  result := 'Citation.citedArtifact.publicationForm';
end;

function TFhirCitationCitedArtifactPublicationForm.Link : TFhirCitationCitedArtifactPublicationForm;
begin
  result := TFhirCitationCitedArtifactPublicationForm(inherited Link);
end;

function TFhirCitationCitedArtifactPublicationForm.Clone : TFhirCitationCitedArtifactPublicationForm;
begin
  result := TFhirCitationCitedArtifactPublicationForm(inherited Clone);
end;

function TFhirCitationCitedArtifactPublicationForm.equals(other : TObject) : boolean; 
var
  o : TFhirCitationCitedArtifactPublicationForm;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirCitationCitedArtifactPublicationForm)) then
    result := false
  else
  begin
    o := TFhirCitationCitedArtifactPublicationForm(other);
    result := compareDeep(publishedInElement, o.publishedInElement, true) and compareDeep(periodicReleaseElement, o.periodicReleaseElement, true) and 
      compareDeep(articleDateElement, o.articleDateElement, true) and compareDeep(lastRevisionDateElement, o.lastRevisionDateElement, true) and 
      compareDeep(languageList, o.languageList, true) and compareDeep(accessionNumberElement, o.accessionNumberElement, true) and 
      compareDeep(pageStringElement, o.pageStringElement, true) and compareDeep(firstPageElement, o.firstPageElement, true) and 
      compareDeep(lastPageElement, o.lastPageElement, true) and compareDeep(pageCountElement, o.pageCountElement, true) and 
      compareDeep(copyrightElement, o.copyrightElement, true);
  end;
end;

function TFhirCitationCitedArtifactPublicationForm.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FPublishedIn) and isEmptyProp(FPeriodicRelease) and isEmptyProp(FArticleDate) and isEmptyProp(FLastRevisionDate) and isEmptyProp(FlanguageList) and isEmptyProp(FAccessionNumber) and isEmptyProp(FPageString) and isEmptyProp(FFirstPage) and isEmptyProp(FLastPage) and isEmptyProp(FPageCount) and isEmptyProp(FCopyright);
end;

procedure TFhirCitationCitedArtifactPublicationForm.listFieldsInOrder(fields : TStringList);
begin
  inherited listFieldsInOrder(fields);
  fields.add('publishedIn');
  fields.add('periodicRelease');
  fields.add('articleDate');
  fields.add('lastRevisionDate');
  fields.add('language');
  fields.add('accessionNumber');
  fields.add('pageString');
  fields.add('firstPage');
  fields.add('lastPage');
  fields.add('pageCount');
  fields.add('copyright');
end;

function TFhirCitationCitedArtifactPublicationForm.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FLanguageList.sizeInBytes(magic));
end;

procedure TFhirCitationCitedArtifactPublicationForm.SetPublishedIn(value : TFhirCitationCitedArtifactPublicationFormPublishedIn);
begin
  FPublishedIn.free;
  FPublishedIn := value;
end;

procedure TFhirCitationCitedArtifactPublicationForm.SetPeriodicRelease(value : TFhirCitationCitedArtifactPublicationFormPeriodicRelease);
begin
  FPeriodicRelease.free;
  FPeriodicRelease := value;
end;

procedure TFhirCitationCitedArtifactPublicationForm.SetArticleDate(value : TFhirDateTime);
begin
  FArticleDate.free;
  FArticleDate := value;
end;

function TFhirCitationCitedArtifactPublicationForm.GetArticleDateST : TFslDateTime;
begin
  if FArticleDate = nil then
    result := TFslDateTime.makeNull
  else
    result := FArticleDate.value;
end;

procedure TFhirCitationCitedArtifactPublicationForm.SetArticleDateST(value : TFslDateTime);
begin
  if FArticleDate = nil then
    FArticleDate := TFhirDateTime.create;
  FArticleDate.value := value
end;

procedure TFhirCitationCitedArtifactPublicationForm.SetLastRevisionDate(value : TFhirDateTime);
begin
  FLastRevisionDate.free;
  FLastRevisionDate := value;
end;

function TFhirCitationCitedArtifactPublicationForm.GetLastRevisionDateST : TFslDateTime;
begin
  if FLastRevisionDate = nil then
    result := TFslDateTime.makeNull
  else
    result := FLastRevisionDate.value;
end;

procedure TFhirCitationCitedArtifactPublicationForm.SetLastRevisionDateST(value : TFslDateTime);
begin
  if FLastRevisionDate = nil then
    FLastRevisionDate := TFhirDateTime.create;
  FLastRevisionDate.value := value
end;

function TFhirCitationCitedArtifactPublicationForm.GetLanguageList : TFhirCodeableConceptList;
begin
  if FLanguageList = nil then
    FLanguageList := TFhirCodeableConceptList.Create;
  result := FLanguageList;
end;

function TFhirCitationCitedArtifactPublicationForm.GetHasLanguageList : boolean;
begin
  result := (FLanguageList <> nil) and (FLanguageList.count > 0);
end;

procedure TFhirCitationCitedArtifactPublicationForm.SetAccessionNumber(value : TFhirString);
begin
  FAccessionNumber.free;
  FAccessionNumber := value;
end;

function TFhirCitationCitedArtifactPublicationForm.GetAccessionNumberST : String;
begin
  if FAccessionNumber = nil then
    result := ''
  else
    result := FAccessionNumber.value;
end;

procedure TFhirCitationCitedArtifactPublicationForm.SetAccessionNumberST(value : String);
begin
  if value <> '' then
  begin
    if FAccessionNumber = nil then
      FAccessionNumber := TFhirString.create;
    FAccessionNumber.value := value
  end
  else if FAccessionNumber <> nil then
    FAccessionNumber.value := '';
end;

procedure TFhirCitationCitedArtifactPublicationForm.SetPageString(value : TFhirString);
begin
  FPageString.free;
  FPageString := value;
end;

function TFhirCitationCitedArtifactPublicationForm.GetPageStringST : String;
begin
  if FPageString = nil then
    result := ''
  else
    result := FPageString.value;
end;

procedure TFhirCitationCitedArtifactPublicationForm.SetPageStringST(value : String);
begin
  if value <> '' then
  begin
    if FPageString = nil then
      FPageString := TFhirString.create;
    FPageString.value := value
  end
  else if FPageString <> nil then
    FPageString.value := '';
end;

procedure TFhirCitationCitedArtifactPublicationForm.SetFirstPage(value : TFhirString);
begin
  FFirstPage.free;
  FFirstPage := value;
end;

function TFhirCitationCitedArtifactPublicationForm.GetFirstPageST : String;
begin
  if FFirstPage = nil then
    result := ''
  else
    result := FFirstPage.value;
end;

procedure TFhirCitationCitedArtifactPublicationForm.SetFirstPageST(value : String);
begin
  if value <> '' then
  begin
    if FFirstPage = nil then
      FFirstPage := TFhirString.create;
    FFirstPage.value := value
  end
  else if FFirstPage <> nil then
    FFirstPage.value := '';
end;

procedure TFhirCitationCitedArtifactPublicationForm.SetLastPage(value : TFhirString);
begin
  FLastPage.free;
  FLastPage := value;
end;

function TFhirCitationCitedArtifactPublicationForm.GetLastPageST : String;
begin
  if FLastPage = nil then
    result := ''
  else
    result := FLastPage.value;
end;

procedure TFhirCitationCitedArtifactPublicationForm.SetLastPageST(value : String);
begin
  if value <> '' then
  begin
    if FLastPage = nil then
      FLastPage := TFhirString.create;
    FLastPage.value := value
  end
  else if FLastPage <> nil then
    FLastPage.value := '';
end;

procedure TFhirCitationCitedArtifactPublicationForm.SetPageCount(value : TFhirString);
begin
  FPageCount.free;
  FPageCount := value;
end;

function TFhirCitationCitedArtifactPublicationForm.GetPageCountST : String;
begin
  if FPageCount = nil then
    result := ''
  else
    result := FPageCount.value;
end;

procedure TFhirCitationCitedArtifactPublicationForm.SetPageCountST(value : String);
begin
  if value <> '' then
  begin
    if FPageCount = nil then
      FPageCount := TFhirString.create;
    FPageCount.value := value
  end
  else if FPageCount <> nil then
    FPageCount.value := '';
end;

procedure TFhirCitationCitedArtifactPublicationForm.SetCopyright(value : TFhirMarkdown);
begin
  FCopyright.free;
  FCopyright := value;
end;

function TFhirCitationCitedArtifactPublicationForm.GetCopyrightST : String;
begin
  if FCopyright = nil then
    result := ''
  else
    result := FCopyright.value;
end;

procedure TFhirCitationCitedArtifactPublicationForm.SetCopyrightST(value : String);
begin
  if value <> '' then
  begin
    if FCopyright = nil then
      FCopyright := TFhirMarkdown.create;
    FCopyright.value := value
  end
  else if FCopyright <> nil then
    FCopyright.value := '';
end;

{ TFhirCitationCitedArtifactPublicationFormListEnumerator }

constructor TFhirCitationCitedArtifactPublicationFormListEnumerator.Create(list : TFhirCitationCitedArtifactPublicationFormList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirCitationCitedArtifactPublicationFormListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirCitationCitedArtifactPublicationFormListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirCitationCitedArtifactPublicationFormListEnumerator.GetCurrent : TFhirCitationCitedArtifactPublicationForm;
begin
  Result := FList[FIndex];
end;

function TFhirCitationCitedArtifactPublicationFormListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirCitationCitedArtifactPublicationFormList }

procedure TFhirCitationCitedArtifactPublicationFormList.AddItem(value: TFhirCitationCitedArtifactPublicationForm);
begin
  assert(value.ClassName = 'TFhirCitationCitedArtifactPublicationForm', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirCitationCitedArtifactPublicationForm');
  add(value);
end;

function TFhirCitationCitedArtifactPublicationFormList.Append: TFhirCitationCitedArtifactPublicationForm;
begin
  result := TFhirCitationCitedArtifactPublicationForm.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirCitationCitedArtifactPublicationFormList.ClearItems;
begin
  Clear;
end;

function TFhirCitationCitedArtifactPublicationFormList.GetEnumerator : TFhirCitationCitedArtifactPublicationFormListEnumerator;
begin
  result := TFhirCitationCitedArtifactPublicationFormListEnumerator.Create(self.link);
end;

function TFhirCitationCitedArtifactPublicationFormList.Clone: TFhirCitationCitedArtifactPublicationFormList;
begin
  result := TFhirCitationCitedArtifactPublicationFormList(inherited Clone);
end;

function TFhirCitationCitedArtifactPublicationFormList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirCitationCitedArtifactPublicationFormList.GetItemN(index: Integer): TFhirCitationCitedArtifactPublicationForm;
begin
  result := TFhirCitationCitedArtifactPublicationForm(ObjectByIndex[index]);
end;

function TFhirCitationCitedArtifactPublicationFormList.ItemClass: TFslObjectClass;
begin
  result := TFhirCitationCitedArtifactPublicationForm;
end;
function TFhirCitationCitedArtifactPublicationFormList.IndexOf(value: TFhirCitationCitedArtifactPublicationForm): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirCitationCitedArtifactPublicationFormList.Insert(index: Integer): TFhirCitationCitedArtifactPublicationForm;
begin
  result := TFhirCitationCitedArtifactPublicationForm.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirCitationCitedArtifactPublicationFormList.InsertItem(index: Integer; value: TFhirCitationCitedArtifactPublicationForm);
begin
  assert(value is TFhirCitationCitedArtifactPublicationForm);
  Inherited Insert(index, value);
end;

function TFhirCitationCitedArtifactPublicationFormList.Item(index: Integer): TFhirCitationCitedArtifactPublicationForm;
begin
  result := TFhirCitationCitedArtifactPublicationForm(ObjectByIndex[index]);
end;

function TFhirCitationCitedArtifactPublicationFormList.Link: TFhirCitationCitedArtifactPublicationFormList;
begin
  result := TFhirCitationCitedArtifactPublicationFormList(inherited Link);
end;

procedure TFhirCitationCitedArtifactPublicationFormList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirCitationCitedArtifactPublicationFormList.SetItemByIndex(index: Integer; value: TFhirCitationCitedArtifactPublicationForm);
begin
  assert(value is TFhirCitationCitedArtifactPublicationForm);
  FhirCitationCitedArtifactPublicationForms[index] := value;
end;

procedure TFhirCitationCitedArtifactPublicationFormList.SetItemN(index: Integer; value: TFhirCitationCitedArtifactPublicationForm);
begin
  assert(value is TFhirCitationCitedArtifactPublicationForm);
  ObjectByIndex[index] := value;
end;

{ TFhirCitationCitedArtifactPublicationFormPublishedIn }

constructor TFhirCitationCitedArtifactPublicationFormPublishedIn.Create;
begin
  inherited;
end;

destructor TFhirCitationCitedArtifactPublicationFormPublishedIn.Destroy;
begin
  FType_.free;
  FIdentifierList.Free;
  FTitle.free;
  FPublisher.free;
  FPublisherLocation.free;
  inherited;
end;

procedure TFhirCitationCitedArtifactPublicationFormPublishedIn.Assign(oSource : TFslObject);
begin
  inherited;
  type_ := TFhirCitationCitedArtifactPublicationFormPublishedIn(oSource).type_.Clone;
  if (TFhirCitationCitedArtifactPublicationFormPublishedIn(oSource).FIdentifierList = nil) then
  begin
    FIdentifierList.free;
    FIdentifierList := nil;
  end
  else
  begin
    if FIdentifierList = nil then
      FIdentifierList := TFhirIdentifierList.Create;
    FIdentifierList.Assign(TFhirCitationCitedArtifactPublicationFormPublishedIn(oSource).FIdentifierList);
  end;
  titleElement := TFhirCitationCitedArtifactPublicationFormPublishedIn(oSource).titleElement.Clone;
  publisher := TFhirCitationCitedArtifactPublicationFormPublishedIn(oSource).publisher.Clone;
  publisherLocationElement := TFhirCitationCitedArtifactPublicationFormPublishedIn(oSource).publisherLocationElement.Clone;
end;

procedure TFhirCitationCitedArtifactPublicationFormPublishedIn.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'type') Then
     list.add(self.link, 'type', FType_.Link);
  if (child_name = 'identifier') Then
    list.addAll(self, 'identifier', FIdentifierList);
  if (child_name = 'title') Then
     list.add(self.link, 'title', FTitle.Link);
  if (child_name = 'publisher') Then
     list.add(self.link, 'publisher', FPublisher.Link);
  if (child_name = 'publisherLocation') Then
     list.add(self.link, 'publisherLocation', FPublisherLocation.Link);
end;

procedure TFhirCitationCitedArtifactPublicationFormPublishedIn.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'type', 'CodeableConcept', false, TFhirCodeableConcept, FType_.Link));
  oList.add(TFHIRProperty.create(self, 'identifier', 'Identifier', true, TFhirIdentifier, FIdentifierList.Link));
  oList.add(TFHIRProperty.create(self, 'title', 'string', false, TFhirString, FTitle.Link));
  oList.add(TFHIRProperty.create(self, 'publisher', 'Reference', false, TFhirReference, FPublisher.Link));
  oList.add(TFHIRProperty.create(self, 'publisherLocation', 'string', false, TFhirString, FPublisherLocation.Link));
end;

function TFhirCitationCitedArtifactPublicationFormPublishedIn.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'type') then
  begin
    Type_ := propValue as TFhirCodeableConcept;
    result := propValue;
  end
  else if (propName = 'identifier') then
  begin
    IdentifierList.add(propValue as TFhirIdentifier);
    result := propValue;
  end
  else if (propName = 'title') then
  begin
    TitleElement := asString(propValue);
    result := propValue;
  end
  else if (propName = 'publisher') then
  begin
    Publisher := propValue as TFhirReference;
    result := propValue;
  end
  else if (propName = 'publisherLocation') then
  begin
    PublisherLocationElement := asString(propValue);
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirCitationCitedArtifactPublicationFormPublishedIn.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'identifier') then IdentifierList.insertItem(index, propValue as TFhirIdentifier)
  else inherited;
end;

function TFhirCitationCitedArtifactPublicationFormPublishedIn.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'type') then result := TFhirCodeableConcept.create()
  else if (propName = 'identifier') then result := IdentifierList.new()
  else if (propName = 'title') then result := TFhirString.create()
  else if (propName = 'publisher') then result := TFhirReference.create()
  else if (propName = 'publisherLocation') then result := TFhirString.create()
  else result := inherited createPropertyValue(propName);
end;

function TFhirCitationCitedArtifactPublicationFormPublishedIn.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'type') then result := 'CodeableConcept'
  else if (propName = 'identifier') then result := 'Identifier'
  else if (propName = 'title') then result := 'string'
  else if (propName = 'publisher') then result := 'Reference'
  else if (propName = 'publisherLocation') then result := 'string'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirCitationCitedArtifactPublicationFormPublishedIn.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'type') then Type_Element := nil
  else if (propName = 'identifier') then deletePropertyValue('identifier', IdentifierList, value)
  else if (propName = 'title') then TitleElement := nil
  else if (propName = 'publisher') then PublisherElement := nil
  else if (propName = 'publisherLocation') then PublisherLocationElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirCitationCitedArtifactPublicationFormPublishedIn.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'type') then Type_Element := new as TFhirCodeableConcept
  else if (propName = 'identifier') then replacePropertyValue('identifier', IdentifierList, existing, new)
  else if (propName = 'title') then TitleElement := asString(new)
  else if (propName = 'publisher') then PublisherElement := new as TFhirReference
  else if (propName = 'publisherLocation') then PublisherLocationElement := asString(new)
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirCitationCitedArtifactPublicationFormPublishedIn.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'identifier') then IdentifierList.move(source, destination)
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirCitationCitedArtifactPublicationFormPublishedIn.fhirType : string;
begin
  result := 'Citation.citedArtifact.publicationForm.publishedIn';
end;

function TFhirCitationCitedArtifactPublicationFormPublishedIn.Link : TFhirCitationCitedArtifactPublicationFormPublishedIn;
begin
  result := TFhirCitationCitedArtifactPublicationFormPublishedIn(inherited Link);
end;

function TFhirCitationCitedArtifactPublicationFormPublishedIn.Clone : TFhirCitationCitedArtifactPublicationFormPublishedIn;
begin
  result := TFhirCitationCitedArtifactPublicationFormPublishedIn(inherited Clone);
end;

function TFhirCitationCitedArtifactPublicationFormPublishedIn.equals(other : TObject) : boolean; 
var
  o : TFhirCitationCitedArtifactPublicationFormPublishedIn;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirCitationCitedArtifactPublicationFormPublishedIn)) then
    result := false
  else
  begin
    o := TFhirCitationCitedArtifactPublicationFormPublishedIn(other);
    result := compareDeep(type_Element, o.type_Element, true) and compareDeep(identifierList, o.identifierList, true) and 
      compareDeep(titleElement, o.titleElement, true) and compareDeep(publisherElement, o.publisherElement, true) and 
      compareDeep(publisherLocationElement, o.publisherLocationElement, true);
  end;
end;

function TFhirCitationCitedArtifactPublicationFormPublishedIn.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FType_) and isEmptyProp(FidentifierList) and isEmptyProp(FTitle) and isEmptyProp(FPublisher) and isEmptyProp(FPublisherLocation);
end;

procedure TFhirCitationCitedArtifactPublicationFormPublishedIn.listFieldsInOrder(fields : TStringList);
begin
  inherited listFieldsInOrder(fields);
  fields.add('type');
  fields.add('identifier');
  fields.add('title');
  fields.add('publisher');
  fields.add('publisherLocation');
end;

function TFhirCitationCitedArtifactPublicationFormPublishedIn.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FIdentifierList.sizeInBytes(magic));
end;

procedure TFhirCitationCitedArtifactPublicationFormPublishedIn.SetType_(value : TFhirCodeableConcept);
begin
  FType_.free;
  FType_ := value;
end;

function TFhirCitationCitedArtifactPublicationFormPublishedIn.GetIdentifierList : TFhirIdentifierList;
begin
  if FIdentifierList = nil then
    FIdentifierList := TFhirIdentifierList.Create;
  result := FIdentifierList;
end;

function TFhirCitationCitedArtifactPublicationFormPublishedIn.GetHasIdentifierList : boolean;
begin
  result := (FIdentifierList <> nil) and (FIdentifierList.count > 0);
end;

procedure TFhirCitationCitedArtifactPublicationFormPublishedIn.SetTitle(value : TFhirString);
begin
  FTitle.free;
  FTitle := value;
end;

function TFhirCitationCitedArtifactPublicationFormPublishedIn.GetTitleST : String;
begin
  if FTitle = nil then
    result := ''
  else
    result := FTitle.value;
end;

procedure TFhirCitationCitedArtifactPublicationFormPublishedIn.SetTitleST(value : String);
begin
  if value <> '' then
  begin
    if FTitle = nil then
      FTitle := TFhirString.create;
    FTitle.value := value
  end
  else if FTitle <> nil then
    FTitle.value := '';
end;

procedure TFhirCitationCitedArtifactPublicationFormPublishedIn.SetPublisher(value : TFhirReference);
begin
  FPublisher.free;
  FPublisher := value;
end;

procedure TFhirCitationCitedArtifactPublicationFormPublishedIn.SetPublisherLocation(value : TFhirString);
begin
  FPublisherLocation.free;
  FPublisherLocation := value;
end;

function TFhirCitationCitedArtifactPublicationFormPublishedIn.GetPublisherLocationST : String;
begin
  if FPublisherLocation = nil then
    result := ''
  else
    result := FPublisherLocation.value;
end;

procedure TFhirCitationCitedArtifactPublicationFormPublishedIn.SetPublisherLocationST(value : String);
begin
  if value <> '' then
  begin
    if FPublisherLocation = nil then
      FPublisherLocation := TFhirString.create;
    FPublisherLocation.value := value
  end
  else if FPublisherLocation <> nil then
    FPublisherLocation.value := '';
end;

{ TFhirCitationCitedArtifactPublicationFormPublishedInListEnumerator }

constructor TFhirCitationCitedArtifactPublicationFormPublishedInListEnumerator.Create(list : TFhirCitationCitedArtifactPublicationFormPublishedInList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirCitationCitedArtifactPublicationFormPublishedInListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirCitationCitedArtifactPublicationFormPublishedInListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirCitationCitedArtifactPublicationFormPublishedInListEnumerator.GetCurrent : TFhirCitationCitedArtifactPublicationFormPublishedIn;
begin
  Result := FList[FIndex];
end;

function TFhirCitationCitedArtifactPublicationFormPublishedInListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirCitationCitedArtifactPublicationFormPublishedInList }

procedure TFhirCitationCitedArtifactPublicationFormPublishedInList.AddItem(value: TFhirCitationCitedArtifactPublicationFormPublishedIn);
begin
  assert(value.ClassName = 'TFhirCitationCitedArtifactPublicationFormPublishedIn', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirCitationCitedArtifactPublicationFormPublishedIn');
  add(value);
end;

function TFhirCitationCitedArtifactPublicationFormPublishedInList.Append: TFhirCitationCitedArtifactPublicationFormPublishedIn;
begin
  result := TFhirCitationCitedArtifactPublicationFormPublishedIn.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirCitationCitedArtifactPublicationFormPublishedInList.ClearItems;
begin
  Clear;
end;

function TFhirCitationCitedArtifactPublicationFormPublishedInList.GetEnumerator : TFhirCitationCitedArtifactPublicationFormPublishedInListEnumerator;
begin
  result := TFhirCitationCitedArtifactPublicationFormPublishedInListEnumerator.Create(self.link);
end;

function TFhirCitationCitedArtifactPublicationFormPublishedInList.Clone: TFhirCitationCitedArtifactPublicationFormPublishedInList;
begin
  result := TFhirCitationCitedArtifactPublicationFormPublishedInList(inherited Clone);
end;

function TFhirCitationCitedArtifactPublicationFormPublishedInList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirCitationCitedArtifactPublicationFormPublishedInList.GetItemN(index: Integer): TFhirCitationCitedArtifactPublicationFormPublishedIn;
begin
  result := TFhirCitationCitedArtifactPublicationFormPublishedIn(ObjectByIndex[index]);
end;

function TFhirCitationCitedArtifactPublicationFormPublishedInList.ItemClass: TFslObjectClass;
begin
  result := TFhirCitationCitedArtifactPublicationFormPublishedIn;
end;
function TFhirCitationCitedArtifactPublicationFormPublishedInList.IndexOf(value: TFhirCitationCitedArtifactPublicationFormPublishedIn): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirCitationCitedArtifactPublicationFormPublishedInList.Insert(index: Integer): TFhirCitationCitedArtifactPublicationFormPublishedIn;
begin
  result := TFhirCitationCitedArtifactPublicationFormPublishedIn.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirCitationCitedArtifactPublicationFormPublishedInList.InsertItem(index: Integer; value: TFhirCitationCitedArtifactPublicationFormPublishedIn);
begin
  assert(value is TFhirCitationCitedArtifactPublicationFormPublishedIn);
  Inherited Insert(index, value);
end;

function TFhirCitationCitedArtifactPublicationFormPublishedInList.Item(index: Integer): TFhirCitationCitedArtifactPublicationFormPublishedIn;
begin
  result := TFhirCitationCitedArtifactPublicationFormPublishedIn(ObjectByIndex[index]);
end;

function TFhirCitationCitedArtifactPublicationFormPublishedInList.Link: TFhirCitationCitedArtifactPublicationFormPublishedInList;
begin
  result := TFhirCitationCitedArtifactPublicationFormPublishedInList(inherited Link);
end;

procedure TFhirCitationCitedArtifactPublicationFormPublishedInList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirCitationCitedArtifactPublicationFormPublishedInList.SetItemByIndex(index: Integer; value: TFhirCitationCitedArtifactPublicationFormPublishedIn);
begin
  assert(value is TFhirCitationCitedArtifactPublicationFormPublishedIn);
  FhirCitationCitedArtifactPublicationFormPublishedIns[index] := value;
end;

procedure TFhirCitationCitedArtifactPublicationFormPublishedInList.SetItemN(index: Integer; value: TFhirCitationCitedArtifactPublicationFormPublishedIn);
begin
  assert(value is TFhirCitationCitedArtifactPublicationFormPublishedIn);
  ObjectByIndex[index] := value;
end;

{ TFhirCitationCitedArtifactPublicationFormPeriodicRelease }

constructor TFhirCitationCitedArtifactPublicationFormPeriodicRelease.Create;
begin
  inherited;
end;

destructor TFhirCitationCitedArtifactPublicationFormPeriodicRelease.Destroy;
begin
  FCitedMedium.free;
  FVolume.free;
  FIssue.free;
  FDateOfPublication.free;
  inherited;
end;

procedure TFhirCitationCitedArtifactPublicationFormPeriodicRelease.Assign(oSource : TFslObject);
begin
  inherited;
  citedMedium := TFhirCitationCitedArtifactPublicationFormPeriodicRelease(oSource).citedMedium.Clone;
  volumeElement := TFhirCitationCitedArtifactPublicationFormPeriodicRelease(oSource).volumeElement.Clone;
  issueElement := TFhirCitationCitedArtifactPublicationFormPeriodicRelease(oSource).issueElement.Clone;
  dateOfPublication := TFhirCitationCitedArtifactPublicationFormPeriodicRelease(oSource).dateOfPublication.Clone;
end;

procedure TFhirCitationCitedArtifactPublicationFormPeriodicRelease.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'citedMedium') Then
     list.add(self.link, 'citedMedium', FCitedMedium.Link);
  if (child_name = 'volume') Then
     list.add(self.link, 'volume', FVolume.Link);
  if (child_name = 'issue') Then
     list.add(self.link, 'issue', FIssue.Link);
  if (child_name = 'dateOfPublication') Then
     list.add(self.link, 'dateOfPublication', FDateOfPublication.Link);
end;

procedure TFhirCitationCitedArtifactPublicationFormPeriodicRelease.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'citedMedium', 'CodeableConcept', false, TFhirCodeableConcept, FCitedMedium.Link));
  oList.add(TFHIRProperty.create(self, 'volume', 'string', false, TFhirString, FVolume.Link));
  oList.add(TFHIRProperty.create(self, 'issue', 'string', false, TFhirString, FIssue.Link));
  oList.add(TFHIRProperty.create(self, 'dateOfPublication', 'BackboneElement', false, TFhirCitationCitedArtifactPublicationFormPeriodicReleaseDateOfPublication, FDateOfPublication.Link));
end;

function TFhirCitationCitedArtifactPublicationFormPeriodicRelease.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'citedMedium') then
  begin
    CitedMedium := propValue as TFhirCodeableConcept;
    result := propValue;
  end
  else if (propName = 'volume') then
  begin
    VolumeElement := asString(propValue);
    result := propValue;
  end
  else if (propName = 'issue') then
  begin
    IssueElement := asString(propValue);
    result := propValue;
  end
  else if (propName = 'dateOfPublication') then
  begin
    DateOfPublication := propValue as TFhirCitationCitedArtifactPublicationFormPeriodicReleaseDateOfPublication;
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirCitationCitedArtifactPublicationFormPeriodicRelease.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirCitationCitedArtifactPublicationFormPeriodicRelease.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'citedMedium') then result := TFhirCodeableConcept.create()
  else if (propName = 'volume') then result := TFhirString.create()
  else if (propName = 'issue') then result := TFhirString.create()
  else if (propName = 'dateOfPublication') then result := TFhirCitationCitedArtifactPublicationFormPeriodicReleaseDateOfPublication.create()
  else result := inherited createPropertyValue(propName);
end;

function TFhirCitationCitedArtifactPublicationFormPeriodicRelease.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'citedMedium') then result := 'CodeableConcept'
  else if (propName = 'volume') then result := 'string'
  else if (propName = 'issue') then result := 'string'
  else if (propName = 'dateOfPublication') then result := 'BackboneElement'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirCitationCitedArtifactPublicationFormPeriodicRelease.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'citedMedium') then CitedMediumElement := nil
  else if (propName = 'volume') then VolumeElement := nil
  else if (propName = 'issue') then IssueElement := nil
  else if (propName = 'dateOfPublication') then DateOfPublicationElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirCitationCitedArtifactPublicationFormPeriodicRelease.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'citedMedium') then CitedMediumElement := new as TFhirCodeableConcept
  else if (propName = 'volume') then VolumeElement := asString(new)
  else if (propName = 'issue') then IssueElement := asString(new)
  else if (propName = 'dateOfPublication') then DateOfPublicationElement := new as TFhirCitationCitedArtifactPublicationFormPeriodicReleaseDateOfPublication
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirCitationCitedArtifactPublicationFormPeriodicRelease.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirCitationCitedArtifactPublicationFormPeriodicRelease.fhirType : string;
begin
  result := 'Citation.citedArtifact.publicationForm.periodicRelease';
end;

function TFhirCitationCitedArtifactPublicationFormPeriodicRelease.Link : TFhirCitationCitedArtifactPublicationFormPeriodicRelease;
begin
  result := TFhirCitationCitedArtifactPublicationFormPeriodicRelease(inherited Link);
end;

function TFhirCitationCitedArtifactPublicationFormPeriodicRelease.Clone : TFhirCitationCitedArtifactPublicationFormPeriodicRelease;
begin
  result := TFhirCitationCitedArtifactPublicationFormPeriodicRelease(inherited Clone);
end;

function TFhirCitationCitedArtifactPublicationFormPeriodicRelease.equals(other : TObject) : boolean; 
var
  o : TFhirCitationCitedArtifactPublicationFormPeriodicRelease;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirCitationCitedArtifactPublicationFormPeriodicRelease)) then
    result := false
  else
  begin
    o := TFhirCitationCitedArtifactPublicationFormPeriodicRelease(other);
    result := compareDeep(citedMediumElement, o.citedMediumElement, true) and compareDeep(volumeElement, o.volumeElement, true) and 
      compareDeep(issueElement, o.issueElement, true) and compareDeep(dateOfPublicationElement, o.dateOfPublicationElement, true);
  end;
end;

function TFhirCitationCitedArtifactPublicationFormPeriodicRelease.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FCitedMedium) and isEmptyProp(FVolume) and isEmptyProp(FIssue) and isEmptyProp(FDateOfPublication);
end;

procedure TFhirCitationCitedArtifactPublicationFormPeriodicRelease.listFieldsInOrder(fields : TStringList);
begin
  inherited listFieldsInOrder(fields);
  fields.add('citedMedium');
  fields.add('volume');
  fields.add('issue');
  fields.add('dateOfPublication');
end;

function TFhirCitationCitedArtifactPublicationFormPeriodicRelease.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
end;

procedure TFhirCitationCitedArtifactPublicationFormPeriodicRelease.SetCitedMedium(value : TFhirCodeableConcept);
begin
  FCitedMedium.free;
  FCitedMedium := value;
end;

procedure TFhirCitationCitedArtifactPublicationFormPeriodicRelease.SetVolume(value : TFhirString);
begin
  FVolume.free;
  FVolume := value;
end;

function TFhirCitationCitedArtifactPublicationFormPeriodicRelease.GetVolumeST : String;
begin
  if FVolume = nil then
    result := ''
  else
    result := FVolume.value;
end;

procedure TFhirCitationCitedArtifactPublicationFormPeriodicRelease.SetVolumeST(value : String);
begin
  if value <> '' then
  begin
    if FVolume = nil then
      FVolume := TFhirString.create;
    FVolume.value := value
  end
  else if FVolume <> nil then
    FVolume.value := '';
end;

procedure TFhirCitationCitedArtifactPublicationFormPeriodicRelease.SetIssue(value : TFhirString);
begin
  FIssue.free;
  FIssue := value;
end;

function TFhirCitationCitedArtifactPublicationFormPeriodicRelease.GetIssueST : String;
begin
  if FIssue = nil then
    result := ''
  else
    result := FIssue.value;
end;

procedure TFhirCitationCitedArtifactPublicationFormPeriodicRelease.SetIssueST(value : String);
begin
  if value <> '' then
  begin
    if FIssue = nil then
      FIssue := TFhirString.create;
    FIssue.value := value
  end
  else if FIssue <> nil then
    FIssue.value := '';
end;

procedure TFhirCitationCitedArtifactPublicationFormPeriodicRelease.SetDateOfPublication(value : TFhirCitationCitedArtifactPublicationFormPeriodicReleaseDateOfPublication);
begin
  FDateOfPublication.free;
  FDateOfPublication := value;
end;

{ TFhirCitationCitedArtifactPublicationFormPeriodicReleaseListEnumerator }

constructor TFhirCitationCitedArtifactPublicationFormPeriodicReleaseListEnumerator.Create(list : TFhirCitationCitedArtifactPublicationFormPeriodicReleaseList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirCitationCitedArtifactPublicationFormPeriodicReleaseListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirCitationCitedArtifactPublicationFormPeriodicReleaseListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirCitationCitedArtifactPublicationFormPeriodicReleaseListEnumerator.GetCurrent : TFhirCitationCitedArtifactPublicationFormPeriodicRelease;
begin
  Result := FList[FIndex];
end;

function TFhirCitationCitedArtifactPublicationFormPeriodicReleaseListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirCitationCitedArtifactPublicationFormPeriodicReleaseList }

procedure TFhirCitationCitedArtifactPublicationFormPeriodicReleaseList.AddItem(value: TFhirCitationCitedArtifactPublicationFormPeriodicRelease);
begin
  assert(value.ClassName = 'TFhirCitationCitedArtifactPublicationFormPeriodicRelease', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirCitationCitedArtifactPublicationFormPeriodicRelease');
  add(value);
end;

function TFhirCitationCitedArtifactPublicationFormPeriodicReleaseList.Append: TFhirCitationCitedArtifactPublicationFormPeriodicRelease;
begin
  result := TFhirCitationCitedArtifactPublicationFormPeriodicRelease.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirCitationCitedArtifactPublicationFormPeriodicReleaseList.ClearItems;
begin
  Clear;
end;

function TFhirCitationCitedArtifactPublicationFormPeriodicReleaseList.GetEnumerator : TFhirCitationCitedArtifactPublicationFormPeriodicReleaseListEnumerator;
begin
  result := TFhirCitationCitedArtifactPublicationFormPeriodicReleaseListEnumerator.Create(self.link);
end;

function TFhirCitationCitedArtifactPublicationFormPeriodicReleaseList.Clone: TFhirCitationCitedArtifactPublicationFormPeriodicReleaseList;
begin
  result := TFhirCitationCitedArtifactPublicationFormPeriodicReleaseList(inherited Clone);
end;

function TFhirCitationCitedArtifactPublicationFormPeriodicReleaseList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirCitationCitedArtifactPublicationFormPeriodicReleaseList.GetItemN(index: Integer): TFhirCitationCitedArtifactPublicationFormPeriodicRelease;
begin
  result := TFhirCitationCitedArtifactPublicationFormPeriodicRelease(ObjectByIndex[index]);
end;

function TFhirCitationCitedArtifactPublicationFormPeriodicReleaseList.ItemClass: TFslObjectClass;
begin
  result := TFhirCitationCitedArtifactPublicationFormPeriodicRelease;
end;
function TFhirCitationCitedArtifactPublicationFormPeriodicReleaseList.IndexOf(value: TFhirCitationCitedArtifactPublicationFormPeriodicRelease): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirCitationCitedArtifactPublicationFormPeriodicReleaseList.Insert(index: Integer): TFhirCitationCitedArtifactPublicationFormPeriodicRelease;
begin
  result := TFhirCitationCitedArtifactPublicationFormPeriodicRelease.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirCitationCitedArtifactPublicationFormPeriodicReleaseList.InsertItem(index: Integer; value: TFhirCitationCitedArtifactPublicationFormPeriodicRelease);
begin
  assert(value is TFhirCitationCitedArtifactPublicationFormPeriodicRelease);
  Inherited Insert(index, value);
end;

function TFhirCitationCitedArtifactPublicationFormPeriodicReleaseList.Item(index: Integer): TFhirCitationCitedArtifactPublicationFormPeriodicRelease;
begin
  result := TFhirCitationCitedArtifactPublicationFormPeriodicRelease(ObjectByIndex[index]);
end;

function TFhirCitationCitedArtifactPublicationFormPeriodicReleaseList.Link: TFhirCitationCitedArtifactPublicationFormPeriodicReleaseList;
begin
  result := TFhirCitationCitedArtifactPublicationFormPeriodicReleaseList(inherited Link);
end;

procedure TFhirCitationCitedArtifactPublicationFormPeriodicReleaseList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirCitationCitedArtifactPublicationFormPeriodicReleaseList.SetItemByIndex(index: Integer; value: TFhirCitationCitedArtifactPublicationFormPeriodicRelease);
begin
  assert(value is TFhirCitationCitedArtifactPublicationFormPeriodicRelease);
  FhirCitationCitedArtifactPublicationFormPeriodicReleases[index] := value;
end;

procedure TFhirCitationCitedArtifactPublicationFormPeriodicReleaseList.SetItemN(index: Integer; value: TFhirCitationCitedArtifactPublicationFormPeriodicRelease);
begin
  assert(value is TFhirCitationCitedArtifactPublicationFormPeriodicRelease);
  ObjectByIndex[index] := value;
end;

{ TFhirCitationCitedArtifactPublicationFormPeriodicReleaseDateOfPublication }

constructor TFhirCitationCitedArtifactPublicationFormPeriodicReleaseDateOfPublication.Create;
begin
  inherited;
end;

destructor TFhirCitationCitedArtifactPublicationFormPeriodicReleaseDateOfPublication.Destroy;
begin
  FDate.free;
  FYear.free;
  FMonth.free;
  FDay.free;
  FSeason.free;
  FText.free;
  inherited;
end;

procedure TFhirCitationCitedArtifactPublicationFormPeriodicReleaseDateOfPublication.Assign(oSource : TFslObject);
begin
  inherited;
  dateElement := TFhirCitationCitedArtifactPublicationFormPeriodicReleaseDateOfPublication(oSource).dateElement.Clone;
  yearElement := TFhirCitationCitedArtifactPublicationFormPeriodicReleaseDateOfPublication(oSource).yearElement.Clone;
  monthElement := TFhirCitationCitedArtifactPublicationFormPeriodicReleaseDateOfPublication(oSource).monthElement.Clone;
  dayElement := TFhirCitationCitedArtifactPublicationFormPeriodicReleaseDateOfPublication(oSource).dayElement.Clone;
  seasonElement := TFhirCitationCitedArtifactPublicationFormPeriodicReleaseDateOfPublication(oSource).seasonElement.Clone;
  textElement := TFhirCitationCitedArtifactPublicationFormPeriodicReleaseDateOfPublication(oSource).textElement.Clone;
end;

procedure TFhirCitationCitedArtifactPublicationFormPeriodicReleaseDateOfPublication.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'date') Then
     list.add(self.link, 'date', FDate.Link);
  if (child_name = 'year') Then
     list.add(self.link, 'year', FYear.Link);
  if (child_name = 'month') Then
     list.add(self.link, 'month', FMonth.Link);
  if (child_name = 'day') Then
     list.add(self.link, 'day', FDay.Link);
  if (child_name = 'season') Then
     list.add(self.link, 'season', FSeason.Link);
  if (child_name = 'text') Then
     list.add(self.link, 'text', FText.Link);
end;

procedure TFhirCitationCitedArtifactPublicationFormPeriodicReleaseDateOfPublication.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'date', 'date', false, TFhirDate, FDate.Link));
  oList.add(TFHIRProperty.create(self, 'year', 'string', false, TFhirString, FYear.Link));
  oList.add(TFHIRProperty.create(self, 'month', 'string', false, TFhirString, FMonth.Link));
  oList.add(TFHIRProperty.create(self, 'day', 'string', false, TFhirString, FDay.Link));
  oList.add(TFHIRProperty.create(self, 'season', 'string', false, TFhirString, FSeason.Link));
  oList.add(TFHIRProperty.create(self, 'text', 'string', false, TFhirString, FText.Link));
end;

function TFhirCitationCitedArtifactPublicationFormPeriodicReleaseDateOfPublication.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'date') then
  begin
    DateElement := asDate(propValue);
    result := propValue;
  end
  else if (propName = 'year') then
  begin
    YearElement := asString(propValue);
    result := propValue;
  end
  else if (propName = 'month') then
  begin
    MonthElement := asString(propValue);
    result := propValue;
  end
  else if (propName = 'day') then
  begin
    DayElement := asString(propValue);
    result := propValue;
  end
  else if (propName = 'season') then
  begin
    SeasonElement := asString(propValue);
    result := propValue;
  end
  else if (propName = 'text') then
  begin
    TextElement := asString(propValue);
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirCitationCitedArtifactPublicationFormPeriodicReleaseDateOfPublication.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirCitationCitedArtifactPublicationFormPeriodicReleaseDateOfPublication.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'date') then result := TFhirDate.create()
  else if (propName = 'year') then result := TFhirString.create()
  else if (propName = 'month') then result := TFhirString.create()
  else if (propName = 'day') then result := TFhirString.create()
  else if (propName = 'season') then result := TFhirString.create()
  else if (propName = 'text') then result := TFhirString.create()
  else result := inherited createPropertyValue(propName);
end;

function TFhirCitationCitedArtifactPublicationFormPeriodicReleaseDateOfPublication.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'date') then result := 'date'
  else if (propName = 'year') then result := 'string'
  else if (propName = 'month') then result := 'string'
  else if (propName = 'day') then result := 'string'
  else if (propName = 'season') then result := 'string'
  else if (propName = 'text') then result := 'string'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirCitationCitedArtifactPublicationFormPeriodicReleaseDateOfPublication.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'date') then DateElement := nil
  else if (propName = 'year') then YearElement := nil
  else if (propName = 'month') then MonthElement := nil
  else if (propName = 'day') then DayElement := nil
  else if (propName = 'season') then SeasonElement := nil
  else if (propName = 'text') then TextElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirCitationCitedArtifactPublicationFormPeriodicReleaseDateOfPublication.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'date') then DateElement := asDate(new)
  else if (propName = 'year') then YearElement := asString(new)
  else if (propName = 'month') then MonthElement := asString(new)
  else if (propName = 'day') then DayElement := asString(new)
  else if (propName = 'season') then SeasonElement := asString(new)
  else if (propName = 'text') then TextElement := asString(new)
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirCitationCitedArtifactPublicationFormPeriodicReleaseDateOfPublication.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirCitationCitedArtifactPublicationFormPeriodicReleaseDateOfPublication.fhirType : string;
begin
  result := 'Citation.citedArtifact.publicationForm.periodicRelease.dateOfPublication';
end;

function TFhirCitationCitedArtifactPublicationFormPeriodicReleaseDateOfPublication.Link : TFhirCitationCitedArtifactPublicationFormPeriodicReleaseDateOfPublication;
begin
  result := TFhirCitationCitedArtifactPublicationFormPeriodicReleaseDateOfPublication(inherited Link);
end;

function TFhirCitationCitedArtifactPublicationFormPeriodicReleaseDateOfPublication.Clone : TFhirCitationCitedArtifactPublicationFormPeriodicReleaseDateOfPublication;
begin
  result := TFhirCitationCitedArtifactPublicationFormPeriodicReleaseDateOfPublication(inherited Clone);
end;

function TFhirCitationCitedArtifactPublicationFormPeriodicReleaseDateOfPublication.equals(other : TObject) : boolean; 
var
  o : TFhirCitationCitedArtifactPublicationFormPeriodicReleaseDateOfPublication;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirCitationCitedArtifactPublicationFormPeriodicReleaseDateOfPublication)) then
    result := false
  else
  begin
    o := TFhirCitationCitedArtifactPublicationFormPeriodicReleaseDateOfPublication(other);
    result := compareDeep(dateElement, o.dateElement, true) and compareDeep(yearElement, o.yearElement, true) and 
      compareDeep(monthElement, o.monthElement, true) and compareDeep(dayElement, o.dayElement, true) and 
      compareDeep(seasonElement, o.seasonElement, true) and compareDeep(textElement, o.textElement, true);
  end;
end;

function TFhirCitationCitedArtifactPublicationFormPeriodicReleaseDateOfPublication.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FDate) and isEmptyProp(FYear) and isEmptyProp(FMonth) and isEmptyProp(FDay) and isEmptyProp(FSeason) and isEmptyProp(FText);
end;

procedure TFhirCitationCitedArtifactPublicationFormPeriodicReleaseDateOfPublication.listFieldsInOrder(fields : TStringList);
begin
  inherited listFieldsInOrder(fields);
  fields.add('date');
  fields.add('year');
  fields.add('month');
  fields.add('day');
  fields.add('season');
  fields.add('text');
end;

function TFhirCitationCitedArtifactPublicationFormPeriodicReleaseDateOfPublication.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
end;

procedure TFhirCitationCitedArtifactPublicationFormPeriodicReleaseDateOfPublication.SetDate(value : TFhirDate);
begin
  FDate.free;
  FDate := value;
end;

function TFhirCitationCitedArtifactPublicationFormPeriodicReleaseDateOfPublication.GetDateST : TFslDateTime;
begin
  if FDate = nil then
    result := TFslDateTime.makeNull
  else
    result := FDate.value;
end;

procedure TFhirCitationCitedArtifactPublicationFormPeriodicReleaseDateOfPublication.SetDateST(value : TFslDateTime);
begin
  if FDate = nil then
    FDate := TFhirDate.create;
  FDate.value := value
end;

procedure TFhirCitationCitedArtifactPublicationFormPeriodicReleaseDateOfPublication.SetYear(value : TFhirString);
begin
  FYear.free;
  FYear := value;
end;

function TFhirCitationCitedArtifactPublicationFormPeriodicReleaseDateOfPublication.GetYearST : String;
begin
  if FYear = nil then
    result := ''
  else
    result := FYear.value;
end;

procedure TFhirCitationCitedArtifactPublicationFormPeriodicReleaseDateOfPublication.SetYearST(value : String);
begin
  if value <> '' then
  begin
    if FYear = nil then
      FYear := TFhirString.create;
    FYear.value := value
  end
  else if FYear <> nil then
    FYear.value := '';
end;

procedure TFhirCitationCitedArtifactPublicationFormPeriodicReleaseDateOfPublication.SetMonth(value : TFhirString);
begin
  FMonth.free;
  FMonth := value;
end;

function TFhirCitationCitedArtifactPublicationFormPeriodicReleaseDateOfPublication.GetMonthST : String;
begin
  if FMonth = nil then
    result := ''
  else
    result := FMonth.value;
end;

procedure TFhirCitationCitedArtifactPublicationFormPeriodicReleaseDateOfPublication.SetMonthST(value : String);
begin
  if value <> '' then
  begin
    if FMonth = nil then
      FMonth := TFhirString.create;
    FMonth.value := value
  end
  else if FMonth <> nil then
    FMonth.value := '';
end;

procedure TFhirCitationCitedArtifactPublicationFormPeriodicReleaseDateOfPublication.SetDay(value : TFhirString);
begin
  FDay.free;
  FDay := value;
end;

function TFhirCitationCitedArtifactPublicationFormPeriodicReleaseDateOfPublication.GetDayST : String;
begin
  if FDay = nil then
    result := ''
  else
    result := FDay.value;
end;

procedure TFhirCitationCitedArtifactPublicationFormPeriodicReleaseDateOfPublication.SetDayST(value : String);
begin
  if value <> '' then
  begin
    if FDay = nil then
      FDay := TFhirString.create;
    FDay.value := value
  end
  else if FDay <> nil then
    FDay.value := '';
end;

procedure TFhirCitationCitedArtifactPublicationFormPeriodicReleaseDateOfPublication.SetSeason(value : TFhirString);
begin
  FSeason.free;
  FSeason := value;
end;

function TFhirCitationCitedArtifactPublicationFormPeriodicReleaseDateOfPublication.GetSeasonST : String;
begin
  if FSeason = nil then
    result := ''
  else
    result := FSeason.value;
end;

procedure TFhirCitationCitedArtifactPublicationFormPeriodicReleaseDateOfPublication.SetSeasonST(value : String);
begin
  if value <> '' then
  begin
    if FSeason = nil then
      FSeason := TFhirString.create;
    FSeason.value := value
  end
  else if FSeason <> nil then
    FSeason.value := '';
end;

procedure TFhirCitationCitedArtifactPublicationFormPeriodicReleaseDateOfPublication.SetText(value : TFhirString);
begin
  FText.free;
  FText := value;
end;

function TFhirCitationCitedArtifactPublicationFormPeriodicReleaseDateOfPublication.GetTextST : String;
begin
  if FText = nil then
    result := ''
  else
    result := FText.value;
end;

procedure TFhirCitationCitedArtifactPublicationFormPeriodicReleaseDateOfPublication.SetTextST(value : String);
begin
  if value <> '' then
  begin
    if FText = nil then
      FText := TFhirString.create;
    FText.value := value
  end
  else if FText <> nil then
    FText.value := '';
end;

{ TFhirCitationCitedArtifactPublicationFormPeriodicReleaseDateOfPublicationListEnumerator }

constructor TFhirCitationCitedArtifactPublicationFormPeriodicReleaseDateOfPublicationListEnumerator.Create(list : TFhirCitationCitedArtifactPublicationFormPeriodicReleaseDateOfPublicationList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirCitationCitedArtifactPublicationFormPeriodicReleaseDateOfPublicationListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirCitationCitedArtifactPublicationFormPeriodicReleaseDateOfPublicationListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirCitationCitedArtifactPublicationFormPeriodicReleaseDateOfPublicationListEnumerator.GetCurrent : TFhirCitationCitedArtifactPublicationFormPeriodicReleaseDateOfPublication;
begin
  Result := FList[FIndex];
end;

function TFhirCitationCitedArtifactPublicationFormPeriodicReleaseDateOfPublicationListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirCitationCitedArtifactPublicationFormPeriodicReleaseDateOfPublicationList }

procedure TFhirCitationCitedArtifactPublicationFormPeriodicReleaseDateOfPublicationList.AddItem(value: TFhirCitationCitedArtifactPublicationFormPeriodicReleaseDateOfPublication);
begin
  assert(value.ClassName = 'TFhirCitationCitedArtifactPublicationFormPeriodicReleaseDateOfPublication', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirCitationCitedArtifactPublicationFormPeriodicReleaseDateOfPublication');
  add(value);
end;

function TFhirCitationCitedArtifactPublicationFormPeriodicReleaseDateOfPublicationList.Append: TFhirCitationCitedArtifactPublicationFormPeriodicReleaseDateOfPublication;
begin
  result := TFhirCitationCitedArtifactPublicationFormPeriodicReleaseDateOfPublication.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirCitationCitedArtifactPublicationFormPeriodicReleaseDateOfPublicationList.ClearItems;
begin
  Clear;
end;

function TFhirCitationCitedArtifactPublicationFormPeriodicReleaseDateOfPublicationList.GetEnumerator : TFhirCitationCitedArtifactPublicationFormPeriodicReleaseDateOfPublicationListEnumerator;
begin
  result := TFhirCitationCitedArtifactPublicationFormPeriodicReleaseDateOfPublicationListEnumerator.Create(self.link);
end;

function TFhirCitationCitedArtifactPublicationFormPeriodicReleaseDateOfPublicationList.Clone: TFhirCitationCitedArtifactPublicationFormPeriodicReleaseDateOfPublicationList;
begin
  result := TFhirCitationCitedArtifactPublicationFormPeriodicReleaseDateOfPublicationList(inherited Clone);
end;

function TFhirCitationCitedArtifactPublicationFormPeriodicReleaseDateOfPublicationList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirCitationCitedArtifactPublicationFormPeriodicReleaseDateOfPublicationList.GetItemN(index: Integer): TFhirCitationCitedArtifactPublicationFormPeriodicReleaseDateOfPublication;
begin
  result := TFhirCitationCitedArtifactPublicationFormPeriodicReleaseDateOfPublication(ObjectByIndex[index]);
end;

function TFhirCitationCitedArtifactPublicationFormPeriodicReleaseDateOfPublicationList.ItemClass: TFslObjectClass;
begin
  result := TFhirCitationCitedArtifactPublicationFormPeriodicReleaseDateOfPublication;
end;
function TFhirCitationCitedArtifactPublicationFormPeriodicReleaseDateOfPublicationList.IndexOf(value: TFhirCitationCitedArtifactPublicationFormPeriodicReleaseDateOfPublication): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirCitationCitedArtifactPublicationFormPeriodicReleaseDateOfPublicationList.Insert(index: Integer): TFhirCitationCitedArtifactPublicationFormPeriodicReleaseDateOfPublication;
begin
  result := TFhirCitationCitedArtifactPublicationFormPeriodicReleaseDateOfPublication.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirCitationCitedArtifactPublicationFormPeriodicReleaseDateOfPublicationList.InsertItem(index: Integer; value: TFhirCitationCitedArtifactPublicationFormPeriodicReleaseDateOfPublication);
begin
  assert(value is TFhirCitationCitedArtifactPublicationFormPeriodicReleaseDateOfPublication);
  Inherited Insert(index, value);
end;

function TFhirCitationCitedArtifactPublicationFormPeriodicReleaseDateOfPublicationList.Item(index: Integer): TFhirCitationCitedArtifactPublicationFormPeriodicReleaseDateOfPublication;
begin
  result := TFhirCitationCitedArtifactPublicationFormPeriodicReleaseDateOfPublication(ObjectByIndex[index]);
end;

function TFhirCitationCitedArtifactPublicationFormPeriodicReleaseDateOfPublicationList.Link: TFhirCitationCitedArtifactPublicationFormPeriodicReleaseDateOfPublicationList;
begin
  result := TFhirCitationCitedArtifactPublicationFormPeriodicReleaseDateOfPublicationList(inherited Link);
end;

procedure TFhirCitationCitedArtifactPublicationFormPeriodicReleaseDateOfPublicationList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirCitationCitedArtifactPublicationFormPeriodicReleaseDateOfPublicationList.SetItemByIndex(index: Integer; value: TFhirCitationCitedArtifactPublicationFormPeriodicReleaseDateOfPublication);
begin
  assert(value is TFhirCitationCitedArtifactPublicationFormPeriodicReleaseDateOfPublication);
  FhirCitationCitedArtifactPublicationFormPeriodicReleaseDateOfPublications[index] := value;
end;

procedure TFhirCitationCitedArtifactPublicationFormPeriodicReleaseDateOfPublicationList.SetItemN(index: Integer; value: TFhirCitationCitedArtifactPublicationFormPeriodicReleaseDateOfPublication);
begin
  assert(value is TFhirCitationCitedArtifactPublicationFormPeriodicReleaseDateOfPublication);
  ObjectByIndex[index] := value;
end;

{ TFhirCitationCitedArtifactWebLocation }

constructor TFhirCitationCitedArtifactWebLocation.Create;
begin
  inherited;
end;

destructor TFhirCitationCitedArtifactWebLocation.Destroy;
begin
  FType_.free;
  FUrl.free;
  inherited;
end;

procedure TFhirCitationCitedArtifactWebLocation.Assign(oSource : TFslObject);
begin
  inherited;
  type_ := TFhirCitationCitedArtifactWebLocation(oSource).type_.Clone;
  urlElement := TFhirCitationCitedArtifactWebLocation(oSource).urlElement.Clone;
end;

procedure TFhirCitationCitedArtifactWebLocation.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'type') Then
     list.add(self.link, 'type', FType_.Link);
  if (child_name = 'url') Then
     list.add(self.link, 'url', FUrl.Link);
end;

procedure TFhirCitationCitedArtifactWebLocation.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'type', 'CodeableConcept', false, TFhirCodeableConcept, FType_.Link));
  oList.add(TFHIRProperty.create(self, 'url', 'uri', false, TFhirUri, FUrl.Link));
end;

function TFhirCitationCitedArtifactWebLocation.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'type') then
  begin
    Type_ := propValue as TFhirCodeableConcept;
    result := propValue;
  end
  else if (propName = 'url') then
  begin
    UrlElement := asUri(propValue);
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirCitationCitedArtifactWebLocation.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirCitationCitedArtifactWebLocation.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'type') then result := TFhirCodeableConcept.create()
  else if (propName = 'url') then result := TFhirUri.create()
  else result := inherited createPropertyValue(propName);
end;

function TFhirCitationCitedArtifactWebLocation.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'type') then result := 'CodeableConcept'
  else if (propName = 'url') then result := 'uri'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirCitationCitedArtifactWebLocation.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'type') then Type_Element := nil
  else if (propName = 'url') then UrlElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirCitationCitedArtifactWebLocation.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'type') then Type_Element := new as TFhirCodeableConcept
  else if (propName = 'url') then UrlElement := asUri(new)
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirCitationCitedArtifactWebLocation.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirCitationCitedArtifactWebLocation.fhirType : string;
begin
  result := 'Citation.citedArtifact.webLocation';
end;

function TFhirCitationCitedArtifactWebLocation.Link : TFhirCitationCitedArtifactWebLocation;
begin
  result := TFhirCitationCitedArtifactWebLocation(inherited Link);
end;

function TFhirCitationCitedArtifactWebLocation.Clone : TFhirCitationCitedArtifactWebLocation;
begin
  result := TFhirCitationCitedArtifactWebLocation(inherited Clone);
end;

function TFhirCitationCitedArtifactWebLocation.equals(other : TObject) : boolean; 
var
  o : TFhirCitationCitedArtifactWebLocation;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirCitationCitedArtifactWebLocation)) then
    result := false
  else
  begin
    o := TFhirCitationCitedArtifactWebLocation(other);
    result := compareDeep(type_Element, o.type_Element, true) and compareDeep(urlElement, o.urlElement, true);
  end;
end;

function TFhirCitationCitedArtifactWebLocation.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FType_) and isEmptyProp(FUrl);
end;

procedure TFhirCitationCitedArtifactWebLocation.listFieldsInOrder(fields : TStringList);
begin
  inherited listFieldsInOrder(fields);
  fields.add('type');
  fields.add('url');
end;

function TFhirCitationCitedArtifactWebLocation.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
end;

procedure TFhirCitationCitedArtifactWebLocation.SetType_(value : TFhirCodeableConcept);
begin
  FType_.free;
  FType_ := value;
end;

procedure TFhirCitationCitedArtifactWebLocation.SetUrl(value : TFhirUri);
begin
  FUrl.free;
  FUrl := value;
end;

function TFhirCitationCitedArtifactWebLocation.GetUrlST : String;
begin
  if FUrl = nil then
    result := ''
  else
    result := FUrl.value;
end;

procedure TFhirCitationCitedArtifactWebLocation.SetUrlST(value : String);
begin
  if value <> '' then
  begin
    if FUrl = nil then
      FUrl := TFhirUri.create;
    FUrl.value := value
  end
  else if FUrl <> nil then
    FUrl.value := '';
end;

{ TFhirCitationCitedArtifactWebLocationListEnumerator }

constructor TFhirCitationCitedArtifactWebLocationListEnumerator.Create(list : TFhirCitationCitedArtifactWebLocationList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirCitationCitedArtifactWebLocationListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirCitationCitedArtifactWebLocationListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirCitationCitedArtifactWebLocationListEnumerator.GetCurrent : TFhirCitationCitedArtifactWebLocation;
begin
  Result := FList[FIndex];
end;

function TFhirCitationCitedArtifactWebLocationListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirCitationCitedArtifactWebLocationList }

procedure TFhirCitationCitedArtifactWebLocationList.AddItem(value: TFhirCitationCitedArtifactWebLocation);
begin
  assert(value.ClassName = 'TFhirCitationCitedArtifactWebLocation', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirCitationCitedArtifactWebLocation');
  add(value);
end;

function TFhirCitationCitedArtifactWebLocationList.Append: TFhirCitationCitedArtifactWebLocation;
begin
  result := TFhirCitationCitedArtifactWebLocation.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirCitationCitedArtifactWebLocationList.ClearItems;
begin
  Clear;
end;

function TFhirCitationCitedArtifactWebLocationList.GetEnumerator : TFhirCitationCitedArtifactWebLocationListEnumerator;
begin
  result := TFhirCitationCitedArtifactWebLocationListEnumerator.Create(self.link);
end;

function TFhirCitationCitedArtifactWebLocationList.Clone: TFhirCitationCitedArtifactWebLocationList;
begin
  result := TFhirCitationCitedArtifactWebLocationList(inherited Clone);
end;

function TFhirCitationCitedArtifactWebLocationList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirCitationCitedArtifactWebLocationList.GetItemN(index: Integer): TFhirCitationCitedArtifactWebLocation;
begin
  result := TFhirCitationCitedArtifactWebLocation(ObjectByIndex[index]);
end;

function TFhirCitationCitedArtifactWebLocationList.ItemClass: TFslObjectClass;
begin
  result := TFhirCitationCitedArtifactWebLocation;
end;
function TFhirCitationCitedArtifactWebLocationList.IndexOf(value: TFhirCitationCitedArtifactWebLocation): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirCitationCitedArtifactWebLocationList.Insert(index: Integer): TFhirCitationCitedArtifactWebLocation;
begin
  result := TFhirCitationCitedArtifactWebLocation.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirCitationCitedArtifactWebLocationList.InsertItem(index: Integer; value: TFhirCitationCitedArtifactWebLocation);
begin
  assert(value is TFhirCitationCitedArtifactWebLocation);
  Inherited Insert(index, value);
end;

function TFhirCitationCitedArtifactWebLocationList.Item(index: Integer): TFhirCitationCitedArtifactWebLocation;
begin
  result := TFhirCitationCitedArtifactWebLocation(ObjectByIndex[index]);
end;

function TFhirCitationCitedArtifactWebLocationList.Link: TFhirCitationCitedArtifactWebLocationList;
begin
  result := TFhirCitationCitedArtifactWebLocationList(inherited Link);
end;

procedure TFhirCitationCitedArtifactWebLocationList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirCitationCitedArtifactWebLocationList.SetItemByIndex(index: Integer; value: TFhirCitationCitedArtifactWebLocation);
begin
  assert(value is TFhirCitationCitedArtifactWebLocation);
  FhirCitationCitedArtifactWebLocations[index] := value;
end;

procedure TFhirCitationCitedArtifactWebLocationList.SetItemN(index: Integer; value: TFhirCitationCitedArtifactWebLocation);
begin
  assert(value is TFhirCitationCitedArtifactWebLocation);
  ObjectByIndex[index] := value;
end;

{ TFhirCitationCitedArtifactClassification }

constructor TFhirCitationCitedArtifactClassification.Create;
begin
  inherited;
end;

destructor TFhirCitationCitedArtifactClassification.Destroy;
begin
  FType_.free;
  FClassifierList.Free;
  FWhoClassified.free;
  inherited;
end;

procedure TFhirCitationCitedArtifactClassification.Assign(oSource : TFslObject);
begin
  inherited;
  type_ := TFhirCitationCitedArtifactClassification(oSource).type_.Clone;
  if (TFhirCitationCitedArtifactClassification(oSource).FClassifierList = nil) then
  begin
    FClassifierList.free;
    FClassifierList := nil;
  end
  else
  begin
    if FClassifierList = nil then
      FClassifierList := TFhirCodeableConceptList.Create;
    FClassifierList.Assign(TFhirCitationCitedArtifactClassification(oSource).FClassifierList);
  end;
  whoClassified := TFhirCitationCitedArtifactClassification(oSource).whoClassified.Clone;
end;

procedure TFhirCitationCitedArtifactClassification.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'type') Then
     list.add(self.link, 'type', FType_.Link);
  if (child_name = 'classifier') Then
    list.addAll(self, 'classifier', FClassifierList);
  if (child_name = 'whoClassified') Then
     list.add(self.link, 'whoClassified', FWhoClassified.Link);
end;

procedure TFhirCitationCitedArtifactClassification.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'type', 'CodeableConcept', false, TFhirCodeableConcept, FType_.Link));
  oList.add(TFHIRProperty.create(self, 'classifier', 'CodeableConcept', true, TFhirCodeableConcept, FClassifierList.Link));
  oList.add(TFHIRProperty.create(self, 'whoClassified', 'BackboneElement', false, TFhirCitationCitedArtifactClassificationWhoClassified, FWhoClassified.Link));
end;

function TFhirCitationCitedArtifactClassification.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'type') then
  begin
    Type_ := propValue as TFhirCodeableConcept;
    result := propValue;
  end
  else if (propName = 'classifier') then
  begin
    ClassifierList.add(propValue as TFhirCodeableConcept);
    result := propValue;
  end
  else if (propName = 'whoClassified') then
  begin
    WhoClassified := propValue as TFhirCitationCitedArtifactClassificationWhoClassified;
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirCitationCitedArtifactClassification.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'classifier') then ClassifierList.insertItem(index, propValue as TFhirCodeableConcept)
  else inherited;
end;

function TFhirCitationCitedArtifactClassification.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'type') then result := TFhirCodeableConcept.create()
  else if (propName = 'classifier') then result := ClassifierList.new()
  else if (propName = 'whoClassified') then result := TFhirCitationCitedArtifactClassificationWhoClassified.create()
  else result := inherited createPropertyValue(propName);
end;

function TFhirCitationCitedArtifactClassification.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'type') then result := 'CodeableConcept'
  else if (propName = 'classifier') then result := 'CodeableConcept'
  else if (propName = 'whoClassified') then result := 'BackboneElement'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirCitationCitedArtifactClassification.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'type') then Type_Element := nil
  else if (propName = 'classifier') then deletePropertyValue('classifier', ClassifierList, value)
  else if (propName = 'whoClassified') then WhoClassifiedElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirCitationCitedArtifactClassification.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'type') then Type_Element := new as TFhirCodeableConcept
  else if (propName = 'classifier') then replacePropertyValue('classifier', ClassifierList, existing, new)
  else if (propName = 'whoClassified') then WhoClassifiedElement := new as TFhirCitationCitedArtifactClassificationWhoClassified
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirCitationCitedArtifactClassification.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'classifier') then ClassifierList.move(source, destination)
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirCitationCitedArtifactClassification.fhirType : string;
begin
  result := 'Citation.citedArtifact.classification';
end;

function TFhirCitationCitedArtifactClassification.Link : TFhirCitationCitedArtifactClassification;
begin
  result := TFhirCitationCitedArtifactClassification(inherited Link);
end;

function TFhirCitationCitedArtifactClassification.Clone : TFhirCitationCitedArtifactClassification;
begin
  result := TFhirCitationCitedArtifactClassification(inherited Clone);
end;

function TFhirCitationCitedArtifactClassification.equals(other : TObject) : boolean; 
var
  o : TFhirCitationCitedArtifactClassification;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirCitationCitedArtifactClassification)) then
    result := false
  else
  begin
    o := TFhirCitationCitedArtifactClassification(other);
    result := compareDeep(type_Element, o.type_Element, true) and compareDeep(classifierList, o.classifierList, true) and 
      compareDeep(whoClassifiedElement, o.whoClassifiedElement, true);
  end;
end;

function TFhirCitationCitedArtifactClassification.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FType_) and isEmptyProp(FclassifierList) and isEmptyProp(FWhoClassified);
end;

procedure TFhirCitationCitedArtifactClassification.listFieldsInOrder(fields : TStringList);
begin
  inherited listFieldsInOrder(fields);
  fields.add('type');
  fields.add('classifier');
  fields.add('whoClassified');
end;

function TFhirCitationCitedArtifactClassification.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FClassifierList.sizeInBytes(magic));
end;

procedure TFhirCitationCitedArtifactClassification.SetType_(value : TFhirCodeableConcept);
begin
  FType_.free;
  FType_ := value;
end;

function TFhirCitationCitedArtifactClassification.GetClassifierList : TFhirCodeableConceptList;
begin
  if FClassifierList = nil then
    FClassifierList := TFhirCodeableConceptList.Create;
  result := FClassifierList;
end;

function TFhirCitationCitedArtifactClassification.GetHasClassifierList : boolean;
begin
  result := (FClassifierList <> nil) and (FClassifierList.count > 0);
end;

procedure TFhirCitationCitedArtifactClassification.SetWhoClassified(value : TFhirCitationCitedArtifactClassificationWhoClassified);
begin
  FWhoClassified.free;
  FWhoClassified := value;
end;

{ TFhirCitationCitedArtifactClassificationListEnumerator }

constructor TFhirCitationCitedArtifactClassificationListEnumerator.Create(list : TFhirCitationCitedArtifactClassificationList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirCitationCitedArtifactClassificationListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirCitationCitedArtifactClassificationListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirCitationCitedArtifactClassificationListEnumerator.GetCurrent : TFhirCitationCitedArtifactClassification;
begin
  Result := FList[FIndex];
end;

function TFhirCitationCitedArtifactClassificationListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirCitationCitedArtifactClassificationList }

procedure TFhirCitationCitedArtifactClassificationList.AddItem(value: TFhirCitationCitedArtifactClassification);
begin
  assert(value.ClassName = 'TFhirCitationCitedArtifactClassification', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirCitationCitedArtifactClassification');
  add(value);
end;

function TFhirCitationCitedArtifactClassificationList.Append: TFhirCitationCitedArtifactClassification;
begin
  result := TFhirCitationCitedArtifactClassification.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirCitationCitedArtifactClassificationList.ClearItems;
begin
  Clear;
end;

function TFhirCitationCitedArtifactClassificationList.GetEnumerator : TFhirCitationCitedArtifactClassificationListEnumerator;
begin
  result := TFhirCitationCitedArtifactClassificationListEnumerator.Create(self.link);
end;

function TFhirCitationCitedArtifactClassificationList.Clone: TFhirCitationCitedArtifactClassificationList;
begin
  result := TFhirCitationCitedArtifactClassificationList(inherited Clone);
end;

function TFhirCitationCitedArtifactClassificationList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirCitationCitedArtifactClassificationList.GetItemN(index: Integer): TFhirCitationCitedArtifactClassification;
begin
  result := TFhirCitationCitedArtifactClassification(ObjectByIndex[index]);
end;

function TFhirCitationCitedArtifactClassificationList.ItemClass: TFslObjectClass;
begin
  result := TFhirCitationCitedArtifactClassification;
end;
function TFhirCitationCitedArtifactClassificationList.IndexOf(value: TFhirCitationCitedArtifactClassification): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirCitationCitedArtifactClassificationList.Insert(index: Integer): TFhirCitationCitedArtifactClassification;
begin
  result := TFhirCitationCitedArtifactClassification.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirCitationCitedArtifactClassificationList.InsertItem(index: Integer; value: TFhirCitationCitedArtifactClassification);
begin
  assert(value is TFhirCitationCitedArtifactClassification);
  Inherited Insert(index, value);
end;

function TFhirCitationCitedArtifactClassificationList.Item(index: Integer): TFhirCitationCitedArtifactClassification;
begin
  result := TFhirCitationCitedArtifactClassification(ObjectByIndex[index]);
end;

function TFhirCitationCitedArtifactClassificationList.Link: TFhirCitationCitedArtifactClassificationList;
begin
  result := TFhirCitationCitedArtifactClassificationList(inherited Link);
end;

procedure TFhirCitationCitedArtifactClassificationList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirCitationCitedArtifactClassificationList.SetItemByIndex(index: Integer; value: TFhirCitationCitedArtifactClassification);
begin
  assert(value is TFhirCitationCitedArtifactClassification);
  FhirCitationCitedArtifactClassifications[index] := value;
end;

procedure TFhirCitationCitedArtifactClassificationList.SetItemN(index: Integer; value: TFhirCitationCitedArtifactClassification);
begin
  assert(value is TFhirCitationCitedArtifactClassification);
  ObjectByIndex[index] := value;
end;

{ TFhirCitationCitedArtifactClassificationWhoClassified }

constructor TFhirCitationCitedArtifactClassificationWhoClassified.Create;
begin
  inherited;
end;

destructor TFhirCitationCitedArtifactClassificationWhoClassified.Destroy;
begin
  FPerson.free;
  FOrganization.free;
  FPublisher.free;
  FClassifierCopyright.free;
  FFreeToShare.free;
  inherited;
end;

procedure TFhirCitationCitedArtifactClassificationWhoClassified.Assign(oSource : TFslObject);
begin
  inherited;
  person := TFhirCitationCitedArtifactClassificationWhoClassified(oSource).person.Clone;
  organization := TFhirCitationCitedArtifactClassificationWhoClassified(oSource).organization.Clone;
  publisher := TFhirCitationCitedArtifactClassificationWhoClassified(oSource).publisher.Clone;
  classifierCopyrightElement := TFhirCitationCitedArtifactClassificationWhoClassified(oSource).classifierCopyrightElement.Clone;
  freeToShareElement := TFhirCitationCitedArtifactClassificationWhoClassified(oSource).freeToShareElement.Clone;
end;

procedure TFhirCitationCitedArtifactClassificationWhoClassified.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'person') Then
     list.add(self.link, 'person', FPerson.Link);
  if (child_name = 'organization') Then
     list.add(self.link, 'organization', FOrganization.Link);
  if (child_name = 'publisher') Then
     list.add(self.link, 'publisher', FPublisher.Link);
  if (child_name = 'classifierCopyright') Then
     list.add(self.link, 'classifierCopyright', FClassifierCopyright.Link);
  if (child_name = 'freeToShare') Then
     list.add(self.link, 'freeToShare', FFreeToShare.Link);
end;

procedure TFhirCitationCitedArtifactClassificationWhoClassified.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'person', 'Reference', false, TFhirReference, FPerson.Link));
  oList.add(TFHIRProperty.create(self, 'organization', 'Reference', false, TFhirReference, FOrganization.Link));
  oList.add(TFHIRProperty.create(self, 'publisher', 'Reference', false, TFhirReference, FPublisher.Link));
  oList.add(TFHIRProperty.create(self, 'classifierCopyright', 'string', false, TFhirString, FClassifierCopyright.Link));
  oList.add(TFHIRProperty.create(self, 'freeToShare', 'boolean', false, TFhirBoolean, FFreeToShare.Link));
end;

function TFhirCitationCitedArtifactClassificationWhoClassified.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'person') then
  begin
    Person := propValue as TFhirReference;
    result := propValue;
  end
  else if (propName = 'organization') then
  begin
    Organization := propValue as TFhirReference;
    result := propValue;
  end
  else if (propName = 'publisher') then
  begin
    Publisher := propValue as TFhirReference;
    result := propValue;
  end
  else if (propName = 'classifierCopyright') then
  begin
    ClassifierCopyrightElement := asString(propValue);
    result := propValue;
  end
  else if (propName = 'freeToShare') then
  begin
    FreeToShareElement := asBoolean(propValue);
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirCitationCitedArtifactClassificationWhoClassified.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirCitationCitedArtifactClassificationWhoClassified.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'person') then result := TFhirReference.create()
  else if (propName = 'organization') then result := TFhirReference.create()
  else if (propName = 'publisher') then result := TFhirReference.create()
  else if (propName = 'classifierCopyright') then result := TFhirString.create()
  else if (propName = 'freeToShare') then result := TFhirBoolean.create()
  else result := inherited createPropertyValue(propName);
end;

function TFhirCitationCitedArtifactClassificationWhoClassified.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'person') then result := 'Reference'
  else if (propName = 'organization') then result := 'Reference'
  else if (propName = 'publisher') then result := 'Reference'
  else if (propName = 'classifierCopyright') then result := 'string'
  else if (propName = 'freeToShare') then result := 'boolean'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirCitationCitedArtifactClassificationWhoClassified.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'person') then PersonElement := nil
  else if (propName = 'organization') then OrganizationElement := nil
  else if (propName = 'publisher') then PublisherElement := nil
  else if (propName = 'classifierCopyright') then ClassifierCopyrightElement := nil
  else if (propName = 'freeToShare') then FreeToShareElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirCitationCitedArtifactClassificationWhoClassified.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'person') then PersonElement := new as TFhirReference
  else if (propName = 'organization') then OrganizationElement := new as TFhirReference
  else if (propName = 'publisher') then PublisherElement := new as TFhirReference
  else if (propName = 'classifierCopyright') then ClassifierCopyrightElement := asString(new)
  else if (propName = 'freeToShare') then FreeToShareElement := asBoolean(new)
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirCitationCitedArtifactClassificationWhoClassified.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirCitationCitedArtifactClassificationWhoClassified.fhirType : string;
begin
  result := 'Citation.citedArtifact.classification.whoClassified';
end;

function TFhirCitationCitedArtifactClassificationWhoClassified.Link : TFhirCitationCitedArtifactClassificationWhoClassified;
begin
  result := TFhirCitationCitedArtifactClassificationWhoClassified(inherited Link);
end;

function TFhirCitationCitedArtifactClassificationWhoClassified.Clone : TFhirCitationCitedArtifactClassificationWhoClassified;
begin
  result := TFhirCitationCitedArtifactClassificationWhoClassified(inherited Clone);
end;

function TFhirCitationCitedArtifactClassificationWhoClassified.equals(other : TObject) : boolean; 
var
  o : TFhirCitationCitedArtifactClassificationWhoClassified;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirCitationCitedArtifactClassificationWhoClassified)) then
    result := false
  else
  begin
    o := TFhirCitationCitedArtifactClassificationWhoClassified(other);
    result := compareDeep(personElement, o.personElement, true) and compareDeep(organizationElement, o.organizationElement, true) and 
      compareDeep(publisherElement, o.publisherElement, true) and compareDeep(classifierCopyrightElement, o.classifierCopyrightElement, true) and 
      compareDeep(freeToShareElement, o.freeToShareElement, true);
  end;
end;

function TFhirCitationCitedArtifactClassificationWhoClassified.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FPerson) and isEmptyProp(FOrganization) and isEmptyProp(FPublisher) and isEmptyProp(FClassifierCopyright) and isEmptyProp(FFreeToShare);
end;

procedure TFhirCitationCitedArtifactClassificationWhoClassified.listFieldsInOrder(fields : TStringList);
begin
  inherited listFieldsInOrder(fields);
  fields.add('person');
  fields.add('organization');
  fields.add('publisher');
  fields.add('classifierCopyright');
  fields.add('freeToShare');
end;

function TFhirCitationCitedArtifactClassificationWhoClassified.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
end;

procedure TFhirCitationCitedArtifactClassificationWhoClassified.SetPerson(value : TFhirReference);
begin
  FPerson.free;
  FPerson := value;
end;

procedure TFhirCitationCitedArtifactClassificationWhoClassified.SetOrganization(value : TFhirReference);
begin
  FOrganization.free;
  FOrganization := value;
end;

procedure TFhirCitationCitedArtifactClassificationWhoClassified.SetPublisher(value : TFhirReference);
begin
  FPublisher.free;
  FPublisher := value;
end;

procedure TFhirCitationCitedArtifactClassificationWhoClassified.SetClassifierCopyright(value : TFhirString);
begin
  FClassifierCopyright.free;
  FClassifierCopyright := value;
end;

function TFhirCitationCitedArtifactClassificationWhoClassified.GetClassifierCopyrightST : String;
begin
  if FClassifierCopyright = nil then
    result := ''
  else
    result := FClassifierCopyright.value;
end;

procedure TFhirCitationCitedArtifactClassificationWhoClassified.SetClassifierCopyrightST(value : String);
begin
  if value <> '' then
  begin
    if FClassifierCopyright = nil then
      FClassifierCopyright := TFhirString.create;
    FClassifierCopyright.value := value
  end
  else if FClassifierCopyright <> nil then
    FClassifierCopyright.value := '';
end;

procedure TFhirCitationCitedArtifactClassificationWhoClassified.SetFreeToShare(value : TFhirBoolean);
begin
  FFreeToShare.free;
  FFreeToShare := value;
end;

function TFhirCitationCitedArtifactClassificationWhoClassified.GetFreeToShareST : Boolean;
begin
  if FFreeToShare = nil then
    result := false
  else
    result := FFreeToShare.value;
end;

procedure TFhirCitationCitedArtifactClassificationWhoClassified.SetFreeToShareST(value : Boolean);
begin
  if FFreeToShare = nil then
    FFreeToShare := TFhirBoolean.create;
  FFreeToShare.value := value
end;

{ TFhirCitationCitedArtifactClassificationWhoClassifiedListEnumerator }

constructor TFhirCitationCitedArtifactClassificationWhoClassifiedListEnumerator.Create(list : TFhirCitationCitedArtifactClassificationWhoClassifiedList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirCitationCitedArtifactClassificationWhoClassifiedListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirCitationCitedArtifactClassificationWhoClassifiedListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirCitationCitedArtifactClassificationWhoClassifiedListEnumerator.GetCurrent : TFhirCitationCitedArtifactClassificationWhoClassified;
begin
  Result := FList[FIndex];
end;

function TFhirCitationCitedArtifactClassificationWhoClassifiedListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirCitationCitedArtifactClassificationWhoClassifiedList }

procedure TFhirCitationCitedArtifactClassificationWhoClassifiedList.AddItem(value: TFhirCitationCitedArtifactClassificationWhoClassified);
begin
  assert(value.ClassName = 'TFhirCitationCitedArtifactClassificationWhoClassified', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirCitationCitedArtifactClassificationWhoClassified');
  add(value);
end;

function TFhirCitationCitedArtifactClassificationWhoClassifiedList.Append: TFhirCitationCitedArtifactClassificationWhoClassified;
begin
  result := TFhirCitationCitedArtifactClassificationWhoClassified.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirCitationCitedArtifactClassificationWhoClassifiedList.ClearItems;
begin
  Clear;
end;

function TFhirCitationCitedArtifactClassificationWhoClassifiedList.GetEnumerator : TFhirCitationCitedArtifactClassificationWhoClassifiedListEnumerator;
begin
  result := TFhirCitationCitedArtifactClassificationWhoClassifiedListEnumerator.Create(self.link);
end;

function TFhirCitationCitedArtifactClassificationWhoClassifiedList.Clone: TFhirCitationCitedArtifactClassificationWhoClassifiedList;
begin
  result := TFhirCitationCitedArtifactClassificationWhoClassifiedList(inherited Clone);
end;

function TFhirCitationCitedArtifactClassificationWhoClassifiedList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirCitationCitedArtifactClassificationWhoClassifiedList.GetItemN(index: Integer): TFhirCitationCitedArtifactClassificationWhoClassified;
begin
  result := TFhirCitationCitedArtifactClassificationWhoClassified(ObjectByIndex[index]);
end;

function TFhirCitationCitedArtifactClassificationWhoClassifiedList.ItemClass: TFslObjectClass;
begin
  result := TFhirCitationCitedArtifactClassificationWhoClassified;
end;
function TFhirCitationCitedArtifactClassificationWhoClassifiedList.IndexOf(value: TFhirCitationCitedArtifactClassificationWhoClassified): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirCitationCitedArtifactClassificationWhoClassifiedList.Insert(index: Integer): TFhirCitationCitedArtifactClassificationWhoClassified;
begin
  result := TFhirCitationCitedArtifactClassificationWhoClassified.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirCitationCitedArtifactClassificationWhoClassifiedList.InsertItem(index: Integer; value: TFhirCitationCitedArtifactClassificationWhoClassified);
begin
  assert(value is TFhirCitationCitedArtifactClassificationWhoClassified);
  Inherited Insert(index, value);
end;

function TFhirCitationCitedArtifactClassificationWhoClassifiedList.Item(index: Integer): TFhirCitationCitedArtifactClassificationWhoClassified;
begin
  result := TFhirCitationCitedArtifactClassificationWhoClassified(ObjectByIndex[index]);
end;

function TFhirCitationCitedArtifactClassificationWhoClassifiedList.Link: TFhirCitationCitedArtifactClassificationWhoClassifiedList;
begin
  result := TFhirCitationCitedArtifactClassificationWhoClassifiedList(inherited Link);
end;

procedure TFhirCitationCitedArtifactClassificationWhoClassifiedList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirCitationCitedArtifactClassificationWhoClassifiedList.SetItemByIndex(index: Integer; value: TFhirCitationCitedArtifactClassificationWhoClassified);
begin
  assert(value is TFhirCitationCitedArtifactClassificationWhoClassified);
  FhirCitationCitedArtifactClassificationWhoClassifieds[index] := value;
end;

procedure TFhirCitationCitedArtifactClassificationWhoClassifiedList.SetItemN(index: Integer; value: TFhirCitationCitedArtifactClassificationWhoClassified);
begin
  assert(value is TFhirCitationCitedArtifactClassificationWhoClassified);
  ObjectByIndex[index] := value;
end;

{ TFhirCitationCitedArtifactContributorship }

constructor TFhirCitationCitedArtifactContributorship.Create;
begin
  inherited;
end;

destructor TFhirCitationCitedArtifactContributorship.Destroy;
begin
  FComplete.free;
  FEntryList.Free;
  FSummaryList.Free;
  inherited;
end;

procedure TFhirCitationCitedArtifactContributorship.Assign(oSource : TFslObject);
begin
  inherited;
  completeElement := TFhirCitationCitedArtifactContributorship(oSource).completeElement.Clone;
  if (TFhirCitationCitedArtifactContributorship(oSource).FEntryList = nil) then
  begin
    FEntryList.free;
    FEntryList := nil;
  end
  else
  begin
    if FEntryList = nil then
      FEntryList := TFhirCitationCitedArtifactContributorshipEntryList.Create;
    FEntryList.Assign(TFhirCitationCitedArtifactContributorship(oSource).FEntryList);
  end;
  if (TFhirCitationCitedArtifactContributorship(oSource).FSummaryList = nil) then
  begin
    FSummaryList.free;
    FSummaryList := nil;
  end
  else
  begin
    if FSummaryList = nil then
      FSummaryList := TFhirCitationCitedArtifactContributorshipSummaryList.Create;
    FSummaryList.Assign(TFhirCitationCitedArtifactContributorship(oSource).FSummaryList);
  end;
end;

procedure TFhirCitationCitedArtifactContributorship.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'complete') Then
     list.add(self.link, 'complete', FComplete.Link);
  if (child_name = 'entry') Then
    list.addAll(self, 'entry', FEntryList);
  if (child_name = 'summary') Then
    list.addAll(self, 'summary', FSummaryList);
end;

procedure TFhirCitationCitedArtifactContributorship.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'complete', 'boolean', false, TFhirBoolean, FComplete.Link));
  oList.add(TFHIRProperty.create(self, 'entry', 'BackboneElement', true, TFhirCitationCitedArtifactContributorshipEntry, FEntryList.Link));
  oList.add(TFHIRProperty.create(self, 'summary', 'BackboneElement', true, TFhirCitationCitedArtifactContributorshipSummary, FSummaryList.Link));
end;

function TFhirCitationCitedArtifactContributorship.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'complete') then
  begin
    CompleteElement := asBoolean(propValue);
    result := propValue;
  end
  else if (propName = 'entry') then
  begin
    EntryList.add(propValue as TFhirCitationCitedArtifactContributorshipEntry);
    result := propValue;
  end
  else if (propName = 'summary') then
  begin
    SummaryList.add(propValue as TFhirCitationCitedArtifactContributorshipSummary);
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirCitationCitedArtifactContributorship.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'entry') then EntryList.insertItem(index, propValue as TFhirCitationCitedArtifactContributorshipEntry)
  else if (propName = 'summary') then SummaryList.insertItem(index, propValue as TFhirCitationCitedArtifactContributorshipSummary)
  else inherited;
end;

function TFhirCitationCitedArtifactContributorship.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'complete') then result := TFhirBoolean.create()
  else if (propName = 'entry') then result := EntryList.new()
  else if (propName = 'summary') then result := SummaryList.new()
  else result := inherited createPropertyValue(propName);
end;

function TFhirCitationCitedArtifactContributorship.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'complete') then result := 'boolean'
  else if (propName = 'entry') then result := 'BackboneElement'
  else if (propName = 'summary') then result := 'BackboneElement'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirCitationCitedArtifactContributorship.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'complete') then CompleteElement := nil
  else if (propName = 'entry') then deletePropertyValue('entry', EntryList, value)
  else if (propName = 'summary') then deletePropertyValue('summary', SummaryList, value)
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirCitationCitedArtifactContributorship.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'complete') then CompleteElement := asBoolean(new)
  else if (propName = 'entry') then replacePropertyValue('entry', EntryList, existing, new)
  else if (propName = 'summary') then replacePropertyValue('summary', SummaryList, existing, new)
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirCitationCitedArtifactContributorship.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'entry') then EntryList.move(source, destination)
  else if (propName = 'summary') then SummaryList.move(source, destination)
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirCitationCitedArtifactContributorship.fhirType : string;
begin
  result := 'Citation.citedArtifact.contributorship';
end;

function TFhirCitationCitedArtifactContributorship.Link : TFhirCitationCitedArtifactContributorship;
begin
  result := TFhirCitationCitedArtifactContributorship(inherited Link);
end;

function TFhirCitationCitedArtifactContributorship.Clone : TFhirCitationCitedArtifactContributorship;
begin
  result := TFhirCitationCitedArtifactContributorship(inherited Clone);
end;

function TFhirCitationCitedArtifactContributorship.equals(other : TObject) : boolean; 
var
  o : TFhirCitationCitedArtifactContributorship;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirCitationCitedArtifactContributorship)) then
    result := false
  else
  begin
    o := TFhirCitationCitedArtifactContributorship(other);
    result := compareDeep(completeElement, o.completeElement, true) and compareDeep(entryList, o.entryList, true) and 
      compareDeep(summaryList, o.summaryList, true);
  end;
end;

function TFhirCitationCitedArtifactContributorship.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FComplete) and isEmptyProp(FentryList) and isEmptyProp(FsummaryList);
end;

procedure TFhirCitationCitedArtifactContributorship.listFieldsInOrder(fields : TStringList);
begin
  inherited listFieldsInOrder(fields);
  fields.add('complete');
  fields.add('entry');
  fields.add('summary');
end;

function TFhirCitationCitedArtifactContributorship.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FEntryList.sizeInBytes(magic));
  inc(result, FSummaryList.sizeInBytes(magic));
end;

procedure TFhirCitationCitedArtifactContributorship.SetComplete(value : TFhirBoolean);
begin
  FComplete.free;
  FComplete := value;
end;

function TFhirCitationCitedArtifactContributorship.GetCompleteST : Boolean;
begin
  if FComplete = nil then
    result := false
  else
    result := FComplete.value;
end;

procedure TFhirCitationCitedArtifactContributorship.SetCompleteST(value : Boolean);
begin
  if FComplete = nil then
    FComplete := TFhirBoolean.create;
  FComplete.value := value
end;

function TFhirCitationCitedArtifactContributorship.GetEntryList : TFhirCitationCitedArtifactContributorshipEntryList;
begin
  if FEntryList = nil then
    FEntryList := TFhirCitationCitedArtifactContributorshipEntryList.Create;
  result := FEntryList;
end;

function TFhirCitationCitedArtifactContributorship.GetHasEntryList : boolean;
begin
  result := (FEntryList <> nil) and (FEntryList.count > 0);
end;

function TFhirCitationCitedArtifactContributorship.GetSummaryList : TFhirCitationCitedArtifactContributorshipSummaryList;
begin
  if FSummaryList = nil then
    FSummaryList := TFhirCitationCitedArtifactContributorshipSummaryList.Create;
  result := FSummaryList;
end;

function TFhirCitationCitedArtifactContributorship.GetHasSummaryList : boolean;
begin
  result := (FSummaryList <> nil) and (FSummaryList.count > 0);
end;

{ TFhirCitationCitedArtifactContributorshipListEnumerator }

constructor TFhirCitationCitedArtifactContributorshipListEnumerator.Create(list : TFhirCitationCitedArtifactContributorshipList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirCitationCitedArtifactContributorshipListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirCitationCitedArtifactContributorshipListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirCitationCitedArtifactContributorshipListEnumerator.GetCurrent : TFhirCitationCitedArtifactContributorship;
begin
  Result := FList[FIndex];
end;

function TFhirCitationCitedArtifactContributorshipListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirCitationCitedArtifactContributorshipList }

procedure TFhirCitationCitedArtifactContributorshipList.AddItem(value: TFhirCitationCitedArtifactContributorship);
begin
  assert(value.ClassName = 'TFhirCitationCitedArtifactContributorship', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirCitationCitedArtifactContributorship');
  add(value);
end;

function TFhirCitationCitedArtifactContributorshipList.Append: TFhirCitationCitedArtifactContributorship;
begin
  result := TFhirCitationCitedArtifactContributorship.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirCitationCitedArtifactContributorshipList.ClearItems;
begin
  Clear;
end;

function TFhirCitationCitedArtifactContributorshipList.GetEnumerator : TFhirCitationCitedArtifactContributorshipListEnumerator;
begin
  result := TFhirCitationCitedArtifactContributorshipListEnumerator.Create(self.link);
end;

function TFhirCitationCitedArtifactContributorshipList.Clone: TFhirCitationCitedArtifactContributorshipList;
begin
  result := TFhirCitationCitedArtifactContributorshipList(inherited Clone);
end;

function TFhirCitationCitedArtifactContributorshipList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirCitationCitedArtifactContributorshipList.GetItemN(index: Integer): TFhirCitationCitedArtifactContributorship;
begin
  result := TFhirCitationCitedArtifactContributorship(ObjectByIndex[index]);
end;

function TFhirCitationCitedArtifactContributorshipList.ItemClass: TFslObjectClass;
begin
  result := TFhirCitationCitedArtifactContributorship;
end;
function TFhirCitationCitedArtifactContributorshipList.IndexOf(value: TFhirCitationCitedArtifactContributorship): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirCitationCitedArtifactContributorshipList.Insert(index: Integer): TFhirCitationCitedArtifactContributorship;
begin
  result := TFhirCitationCitedArtifactContributorship.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirCitationCitedArtifactContributorshipList.InsertItem(index: Integer; value: TFhirCitationCitedArtifactContributorship);
begin
  assert(value is TFhirCitationCitedArtifactContributorship);
  Inherited Insert(index, value);
end;

function TFhirCitationCitedArtifactContributorshipList.Item(index: Integer): TFhirCitationCitedArtifactContributorship;
begin
  result := TFhirCitationCitedArtifactContributorship(ObjectByIndex[index]);
end;

function TFhirCitationCitedArtifactContributorshipList.Link: TFhirCitationCitedArtifactContributorshipList;
begin
  result := TFhirCitationCitedArtifactContributorshipList(inherited Link);
end;

procedure TFhirCitationCitedArtifactContributorshipList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirCitationCitedArtifactContributorshipList.SetItemByIndex(index: Integer; value: TFhirCitationCitedArtifactContributorship);
begin
  assert(value is TFhirCitationCitedArtifactContributorship);
  FhirCitationCitedArtifactContributorships[index] := value;
end;

procedure TFhirCitationCitedArtifactContributorshipList.SetItemN(index: Integer; value: TFhirCitationCitedArtifactContributorship);
begin
  assert(value is TFhirCitationCitedArtifactContributorship);
  ObjectByIndex[index] := value;
end;

{ TFhirCitationCitedArtifactContributorshipEntry }

constructor TFhirCitationCitedArtifactContributorshipEntry.Create;
begin
  inherited;
end;

destructor TFhirCitationCitedArtifactContributorshipEntry.Destroy;
begin
  FName.free;
  FInitials.free;
  FCollectiveName.free;
  FIdentifierList.Free;
  FAffiliationInfoList.Free;
  FAddressList.Free;
  FTelecomList.Free;
  FContributionTypeList.Free;
  FRole.free;
  FContributionInstanceList.Free;
  FCorrespondingContact.free;
  FListOrder.free;
  inherited;
end;

procedure TFhirCitationCitedArtifactContributorshipEntry.Assign(oSource : TFslObject);
begin
  inherited;
  name := TFhirCitationCitedArtifactContributorshipEntry(oSource).name.Clone;
  initialsElement := TFhirCitationCitedArtifactContributorshipEntry(oSource).initialsElement.Clone;
  collectiveNameElement := TFhirCitationCitedArtifactContributorshipEntry(oSource).collectiveNameElement.Clone;
  if (TFhirCitationCitedArtifactContributorshipEntry(oSource).FIdentifierList = nil) then
  begin
    FIdentifierList.free;
    FIdentifierList := nil;
  end
  else
  begin
    if FIdentifierList = nil then
      FIdentifierList := TFhirIdentifierList.Create;
    FIdentifierList.Assign(TFhirCitationCitedArtifactContributorshipEntry(oSource).FIdentifierList);
  end;
  if (TFhirCitationCitedArtifactContributorshipEntry(oSource).FAffiliationInfoList = nil) then
  begin
    FAffiliationInfoList.free;
    FAffiliationInfoList := nil;
  end
  else
  begin
    if FAffiliationInfoList = nil then
      FAffiliationInfoList := TFhirCitationCitedArtifactContributorshipEntryAffiliationInfoList.Create;
    FAffiliationInfoList.Assign(TFhirCitationCitedArtifactContributorshipEntry(oSource).FAffiliationInfoList);
  end;
  if (TFhirCitationCitedArtifactContributorshipEntry(oSource).FAddressList = nil) then
  begin
    FAddressList.free;
    FAddressList := nil;
  end
  else
  begin
    if FAddressList = nil then
      FAddressList := TFhirAddressList.Create;
    FAddressList.Assign(TFhirCitationCitedArtifactContributorshipEntry(oSource).FAddressList);
  end;
  if (TFhirCitationCitedArtifactContributorshipEntry(oSource).FTelecomList = nil) then
  begin
    FTelecomList.free;
    FTelecomList := nil;
  end
  else
  begin
    if FTelecomList = nil then
      FTelecomList := TFhirContactPointList.Create;
    FTelecomList.Assign(TFhirCitationCitedArtifactContributorshipEntry(oSource).FTelecomList);
  end;
  if (TFhirCitationCitedArtifactContributorshipEntry(oSource).FContributionTypeList = nil) then
  begin
    FContributionTypeList.free;
    FContributionTypeList := nil;
  end
  else
  begin
    if FContributionTypeList = nil then
      FContributionTypeList := TFhirCodeableConceptList.Create;
    FContributionTypeList.Assign(TFhirCitationCitedArtifactContributorshipEntry(oSource).FContributionTypeList);
  end;
  role := TFhirCitationCitedArtifactContributorshipEntry(oSource).role.Clone;
  if (TFhirCitationCitedArtifactContributorshipEntry(oSource).FContributionInstanceList = nil) then
  begin
    FContributionInstanceList.free;
    FContributionInstanceList := nil;
  end
  else
  begin
    if FContributionInstanceList = nil then
      FContributionInstanceList := TFhirCitationCitedArtifactContributorshipEntryContributionInstanceList.Create;
    FContributionInstanceList.Assign(TFhirCitationCitedArtifactContributorshipEntry(oSource).FContributionInstanceList);
  end;
  correspondingContactElement := TFhirCitationCitedArtifactContributorshipEntry(oSource).correspondingContactElement.Clone;
  listOrderElement := TFhirCitationCitedArtifactContributorshipEntry(oSource).listOrderElement.Clone;
end;

procedure TFhirCitationCitedArtifactContributorshipEntry.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'name') Then
     list.add(self.link, 'name', FName.Link);
  if (child_name = 'initials') Then
     list.add(self.link, 'initials', FInitials.Link);
  if (child_name = 'collectiveName') Then
     list.add(self.link, 'collectiveName', FCollectiveName.Link);
  if (child_name = 'identifier') Then
    list.addAll(self, 'identifier', FIdentifierList);
  if (child_name = 'affiliationInfo') Then
    list.addAll(self, 'affiliationInfo', FAffiliationInfoList);
  if (child_name = 'address') Then
    list.addAll(self, 'address', FAddressList);
  if (child_name = 'telecom') Then
    list.addAll(self, 'telecom', FTelecomList);
  if (child_name = 'contributionType') Then
    list.addAll(self, 'contributionType', FContributionTypeList);
  if (child_name = 'role') Then
     list.add(self.link, 'role', FRole.Link);
  if (child_name = 'contributionInstance') Then
    list.addAll(self, 'contributionInstance', FContributionInstanceList);
  if (child_name = 'correspondingContact') Then
     list.add(self.link, 'correspondingContact', FCorrespondingContact.Link);
  if (child_name = 'listOrder') Then
     list.add(self.link, 'listOrder', FListOrder.Link);
end;

procedure TFhirCitationCitedArtifactContributorshipEntry.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'name', 'HumanName', false, TFhirHumanName, FName.Link));
  oList.add(TFHIRProperty.create(self, 'initials', 'string', false, TFhirString, FInitials.Link));
  oList.add(TFHIRProperty.create(self, 'collectiveName', 'string', false, TFhirString, FCollectiveName.Link));
  oList.add(TFHIRProperty.create(self, 'identifier', 'Identifier', true, TFhirIdentifier, FIdentifierList.Link));
  oList.add(TFHIRProperty.create(self, 'affiliationInfo', 'BackboneElement', true, TFhirCitationCitedArtifactContributorshipEntryAffiliationInfo, FAffiliationInfoList.Link));
  oList.add(TFHIRProperty.create(self, 'address', 'Address', true, TFhirAddress, FAddressList.Link));
  oList.add(TFHIRProperty.create(self, 'telecom', 'ContactPoint', true, TFhirContactPoint, FTelecomList.Link));
  oList.add(TFHIRProperty.create(self, 'contributionType', 'CodeableConcept', true, TFhirCodeableConcept, FContributionTypeList.Link));
  oList.add(TFHIRProperty.create(self, 'role', 'CodeableConcept', false, TFhirCodeableConcept, FRole.Link));
  oList.add(TFHIRProperty.create(self, 'contributionInstance', 'BackboneElement', true, TFhirCitationCitedArtifactContributorshipEntryContributionInstance, FContributionInstanceList.Link));
  oList.add(TFHIRProperty.create(self, 'correspondingContact', 'boolean', false, TFhirBoolean, FCorrespondingContact.Link));
  oList.add(TFHIRProperty.create(self, 'listOrder', 'positiveInt', false, TFhirPositiveInt, FListOrder.Link));
end;

function TFhirCitationCitedArtifactContributorshipEntry.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'name') then
  begin
    Name := propValue as TFhirHumanName;
    result := propValue;
  end
  else if (propName = 'initials') then
  begin
    InitialsElement := asString(propValue);
    result := propValue;
  end
  else if (propName = 'collectiveName') then
  begin
    CollectiveNameElement := asString(propValue);
    result := propValue;
  end
  else if (propName = 'identifier') then
  begin
    IdentifierList.add(propValue as TFhirIdentifier);
    result := propValue;
  end
  else if (propName = 'affiliationInfo') then
  begin
    AffiliationInfoList.add(propValue as TFhirCitationCitedArtifactContributorshipEntryAffiliationInfo);
    result := propValue;
  end
  else if (propName = 'address') then
  begin
    AddressList.add(propValue as TFhirAddress);
    result := propValue;
  end
  else if (propName = 'telecom') then
  begin
    TelecomList.add(propValue as TFhirContactPoint);
    result := propValue;
  end
  else if (propName = 'contributionType') then
  begin
    ContributionTypeList.add(propValue as TFhirCodeableConcept);
    result := propValue;
  end
  else if (propName = 'role') then
  begin
    Role := propValue as TFhirCodeableConcept;
    result := propValue;
  end
  else if (propName = 'contributionInstance') then
  begin
    ContributionInstanceList.add(propValue as TFhirCitationCitedArtifactContributorshipEntryContributionInstance);
    result := propValue;
  end
  else if (propName = 'correspondingContact') then
  begin
    CorrespondingContactElement := asBoolean(propValue);
    result := propValue;
  end
  else if (propName = 'listOrder') then
  begin
    ListOrderElement := asPositiveInt(propValue);
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirCitationCitedArtifactContributorshipEntry.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'identifier') then IdentifierList.insertItem(index, propValue as TFhirIdentifier)
  else if (propName = 'affiliationInfo') then AffiliationInfoList.insertItem(index, propValue as TFhirCitationCitedArtifactContributorshipEntryAffiliationInfo)
  else if (propName = 'address') then AddressList.insertItem(index, propValue as TFhirAddress)
  else if (propName = 'telecom') then TelecomList.insertItem(index, propValue as TFhirContactPoint)
  else if (propName = 'contributionType') then ContributionTypeList.insertItem(index, propValue as TFhirCodeableConcept)
  else if (propName = 'contributionInstance') then ContributionInstanceList.insertItem(index, propValue as TFhirCitationCitedArtifactContributorshipEntryContributionInstance)
  else inherited;
end;

function TFhirCitationCitedArtifactContributorshipEntry.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'name') then result := TFhirHumanName.create()
  else if (propName = 'initials') then result := TFhirString.create()
  else if (propName = 'collectiveName') then result := TFhirString.create()
  else if (propName = 'identifier') then result := IdentifierList.new()
  else if (propName = 'affiliationInfo') then result := AffiliationInfoList.new()
  else if (propName = 'address') then result := AddressList.new()
  else if (propName = 'telecom') then result := TelecomList.new()
  else if (propName = 'contributionType') then result := ContributionTypeList.new()
  else if (propName = 'role') then result := TFhirCodeableConcept.create()
  else if (propName = 'contributionInstance') then result := ContributionInstanceList.new()
  else if (propName = 'correspondingContact') then result := TFhirBoolean.create()
  else if (propName = 'listOrder') then result := TFhirPositiveInt.create()
  else result := inherited createPropertyValue(propName);
end;

function TFhirCitationCitedArtifactContributorshipEntry.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'name') then result := 'HumanName'
  else if (propName = 'initials') then result := 'string'
  else if (propName = 'collectiveName') then result := 'string'
  else if (propName = 'identifier') then result := 'Identifier'
  else if (propName = 'affiliationInfo') then result := 'BackboneElement'
  else if (propName = 'address') then result := 'Address'
  else if (propName = 'telecom') then result := 'ContactPoint'
  else if (propName = 'contributionType') then result := 'CodeableConcept'
  else if (propName = 'role') then result := 'CodeableConcept'
  else if (propName = 'contributionInstance') then result := 'BackboneElement'
  else if (propName = 'correspondingContact') then result := 'boolean'
  else if (propName = 'listOrder') then result := 'positiveInt'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirCitationCitedArtifactContributorshipEntry.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'name') then NameElement := nil
  else if (propName = 'initials') then InitialsElement := nil
  else if (propName = 'collectiveName') then CollectiveNameElement := nil
  else if (propName = 'identifier') then deletePropertyValue('identifier', IdentifierList, value)
  else if (propName = 'affiliationInfo') then deletePropertyValue('affiliationInfo', AffiliationInfoList, value)
  else if (propName = 'address') then deletePropertyValue('address', AddressList, value)
  else if (propName = 'telecom') then deletePropertyValue('telecom', TelecomList, value)
  else if (propName = 'contributionType') then deletePropertyValue('contributionType', ContributionTypeList, value)
  else if (propName = 'role') then RoleElement := nil
  else if (propName = 'contributionInstance') then deletePropertyValue('contributionInstance', ContributionInstanceList, value)
  else if (propName = 'correspondingContact') then CorrespondingContactElement := nil
  else if (propName = 'listOrder') then ListOrderElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirCitationCitedArtifactContributorshipEntry.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'name') then NameElement := new as TFhirHumanName
  else if (propName = 'initials') then InitialsElement := asString(new)
  else if (propName = 'collectiveName') then CollectiveNameElement := asString(new)
  else if (propName = 'identifier') then replacePropertyValue('identifier', IdentifierList, existing, new)
  else if (propName = 'affiliationInfo') then replacePropertyValue('affiliationInfo', AffiliationInfoList, existing, new)
  else if (propName = 'address') then replacePropertyValue('address', AddressList, existing, new)
  else if (propName = 'telecom') then replacePropertyValue('telecom', TelecomList, existing, new)
  else if (propName = 'contributionType') then replacePropertyValue('contributionType', ContributionTypeList, existing, new)
  else if (propName = 'role') then RoleElement := new as TFhirCodeableConcept
  else if (propName = 'contributionInstance') then replacePropertyValue('contributionInstance', ContributionInstanceList, existing, new)
  else if (propName = 'correspondingContact') then CorrespondingContactElement := asBoolean(new)
  else if (propName = 'listOrder') then ListOrderElement := asPositiveInt(new)
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirCitationCitedArtifactContributorshipEntry.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'identifier') then IdentifierList.move(source, destination)
  else if (propName = 'affiliationInfo') then AffiliationInfoList.move(source, destination)
  else if (propName = 'address') then AddressList.move(source, destination)
  else if (propName = 'telecom') then TelecomList.move(source, destination)
  else if (propName = 'contributionType') then ContributionTypeList.move(source, destination)
  else if (propName = 'contributionInstance') then ContributionInstanceList.move(source, destination)
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirCitationCitedArtifactContributorshipEntry.fhirType : string;
begin
  result := 'Citation.citedArtifact.contributorship.entry';
end;

function TFhirCitationCitedArtifactContributorshipEntry.Link : TFhirCitationCitedArtifactContributorshipEntry;
begin
  result := TFhirCitationCitedArtifactContributorshipEntry(inherited Link);
end;

function TFhirCitationCitedArtifactContributorshipEntry.Clone : TFhirCitationCitedArtifactContributorshipEntry;
begin
  result := TFhirCitationCitedArtifactContributorshipEntry(inherited Clone);
end;

function TFhirCitationCitedArtifactContributorshipEntry.equals(other : TObject) : boolean; 
var
  o : TFhirCitationCitedArtifactContributorshipEntry;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirCitationCitedArtifactContributorshipEntry)) then
    result := false
  else
  begin
    o := TFhirCitationCitedArtifactContributorshipEntry(other);
    result := compareDeep(nameElement, o.nameElement, true) and compareDeep(initialsElement, o.initialsElement, true) and 
      compareDeep(collectiveNameElement, o.collectiveNameElement, true) and compareDeep(identifierList, o.identifierList, true) and 
      compareDeep(affiliationInfoList, o.affiliationInfoList, true) and compareDeep(addressList, o.addressList, true) and 
      compareDeep(telecomList, o.telecomList, true) and compareDeep(contributionTypeList, o.contributionTypeList, true) and 
      compareDeep(roleElement, o.roleElement, true) and compareDeep(contributionInstanceList, o.contributionInstanceList, true) and 
      compareDeep(correspondingContactElement, o.correspondingContactElement, true) and 
      compareDeep(listOrderElement, o.listOrderElement, true);
  end;
end;

function TFhirCitationCitedArtifactContributorshipEntry.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FName) and isEmptyProp(FInitials) and isEmptyProp(FCollectiveName) and isEmptyProp(FidentifierList) and isEmptyProp(FaffiliationInfoList) and isEmptyProp(FaddressList) and isEmptyProp(FtelecomList) and isEmptyProp(FcontributionTypeList) and isEmptyProp(FRole) and isEmptyProp(FcontributionInstanceList) and isEmptyProp(FCorrespondingContact) and isEmptyProp(FListOrder);
end;

procedure TFhirCitationCitedArtifactContributorshipEntry.listFieldsInOrder(fields : TStringList);
begin
  inherited listFieldsInOrder(fields);
  fields.add('name');
  fields.add('initials');
  fields.add('collectiveName');
  fields.add('identifier');
  fields.add('affiliationInfo');
  fields.add('address');
  fields.add('telecom');
  fields.add('contributionType');
  fields.add('role');
  fields.add('contributionInstance');
  fields.add('correspondingContact');
  fields.add('listOrder');
end;

function TFhirCitationCitedArtifactContributorshipEntry.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FIdentifierList.sizeInBytes(magic));
  inc(result, FAffiliationInfoList.sizeInBytes(magic));
  inc(result, FAddressList.sizeInBytes(magic));
  inc(result, FTelecomList.sizeInBytes(magic));
  inc(result, FContributionTypeList.sizeInBytes(magic));
  inc(result, FContributionInstanceList.sizeInBytes(magic));
end;

procedure TFhirCitationCitedArtifactContributorshipEntry.SetName(value : TFhirHumanName);
begin
  FName.free;
  FName := value;
end;

procedure TFhirCitationCitedArtifactContributorshipEntry.SetInitials(value : TFhirString);
begin
  FInitials.free;
  FInitials := value;
end;

function TFhirCitationCitedArtifactContributorshipEntry.GetInitialsST : String;
begin
  if FInitials = nil then
    result := ''
  else
    result := FInitials.value;
end;

procedure TFhirCitationCitedArtifactContributorshipEntry.SetInitialsST(value : String);
begin
  if value <> '' then
  begin
    if FInitials = nil then
      FInitials := TFhirString.create;
    FInitials.value := value
  end
  else if FInitials <> nil then
    FInitials.value := '';
end;

procedure TFhirCitationCitedArtifactContributorshipEntry.SetCollectiveName(value : TFhirString);
begin
  FCollectiveName.free;
  FCollectiveName := value;
end;

function TFhirCitationCitedArtifactContributorshipEntry.GetCollectiveNameST : String;
begin
  if FCollectiveName = nil then
    result := ''
  else
    result := FCollectiveName.value;
end;

procedure TFhirCitationCitedArtifactContributorshipEntry.SetCollectiveNameST(value : String);
begin
  if value <> '' then
  begin
    if FCollectiveName = nil then
      FCollectiveName := TFhirString.create;
    FCollectiveName.value := value
  end
  else if FCollectiveName <> nil then
    FCollectiveName.value := '';
end;

function TFhirCitationCitedArtifactContributorshipEntry.GetIdentifierList : TFhirIdentifierList;
begin
  if FIdentifierList = nil then
    FIdentifierList := TFhirIdentifierList.Create;
  result := FIdentifierList;
end;

function TFhirCitationCitedArtifactContributorshipEntry.GetHasIdentifierList : boolean;
begin
  result := (FIdentifierList <> nil) and (FIdentifierList.count > 0);
end;

function TFhirCitationCitedArtifactContributorshipEntry.GetAffiliationInfoList : TFhirCitationCitedArtifactContributorshipEntryAffiliationInfoList;
begin
  if FAffiliationInfoList = nil then
    FAffiliationInfoList := TFhirCitationCitedArtifactContributorshipEntryAffiliationInfoList.Create;
  result := FAffiliationInfoList;
end;

function TFhirCitationCitedArtifactContributorshipEntry.GetHasAffiliationInfoList : boolean;
begin
  result := (FAffiliationInfoList <> nil) and (FAffiliationInfoList.count > 0);
end;

function TFhirCitationCitedArtifactContributorshipEntry.GetAddressList : TFhirAddressList;
begin
  if FAddressList = nil then
    FAddressList := TFhirAddressList.Create;
  result := FAddressList;
end;

function TFhirCitationCitedArtifactContributorshipEntry.GetHasAddressList : boolean;
begin
  result := (FAddressList <> nil) and (FAddressList.count > 0);
end;

function TFhirCitationCitedArtifactContributorshipEntry.GetTelecomList : TFhirContactPointList;
begin
  if FTelecomList = nil then
    FTelecomList := TFhirContactPointList.Create;
  result := FTelecomList;
end;

function TFhirCitationCitedArtifactContributorshipEntry.GetHasTelecomList : boolean;
begin
  result := (FTelecomList <> nil) and (FTelecomList.count > 0);
end;

function TFhirCitationCitedArtifactContributorshipEntry.GetContributionTypeList : TFhirCodeableConceptList;
begin
  if FContributionTypeList = nil then
    FContributionTypeList := TFhirCodeableConceptList.Create;
  result := FContributionTypeList;
end;

function TFhirCitationCitedArtifactContributorshipEntry.GetHasContributionTypeList : boolean;
begin
  result := (FContributionTypeList <> nil) and (FContributionTypeList.count > 0);
end;

procedure TFhirCitationCitedArtifactContributorshipEntry.SetRole(value : TFhirCodeableConcept);
begin
  FRole.free;
  FRole := value;
end;

function TFhirCitationCitedArtifactContributorshipEntry.GetContributionInstanceList : TFhirCitationCitedArtifactContributorshipEntryContributionInstanceList;
begin
  if FContributionInstanceList = nil then
    FContributionInstanceList := TFhirCitationCitedArtifactContributorshipEntryContributionInstanceList.Create;
  result := FContributionInstanceList;
end;

function TFhirCitationCitedArtifactContributorshipEntry.GetHasContributionInstanceList : boolean;
begin
  result := (FContributionInstanceList <> nil) and (FContributionInstanceList.count > 0);
end;

procedure TFhirCitationCitedArtifactContributorshipEntry.SetCorrespondingContact(value : TFhirBoolean);
begin
  FCorrespondingContact.free;
  FCorrespondingContact := value;
end;

function TFhirCitationCitedArtifactContributorshipEntry.GetCorrespondingContactST : Boolean;
begin
  if FCorrespondingContact = nil then
    result := false
  else
    result := FCorrespondingContact.value;
end;

procedure TFhirCitationCitedArtifactContributorshipEntry.SetCorrespondingContactST(value : Boolean);
begin
  if FCorrespondingContact = nil then
    FCorrespondingContact := TFhirBoolean.create;
  FCorrespondingContact.value := value
end;

procedure TFhirCitationCitedArtifactContributorshipEntry.SetListOrder(value : TFhirPositiveInt);
begin
  FListOrder.free;
  FListOrder := value;
end;

function TFhirCitationCitedArtifactContributorshipEntry.GetListOrderST : String;
begin
  if FListOrder = nil then
    result := ''
  else
    result := FListOrder.value;
end;

procedure TFhirCitationCitedArtifactContributorshipEntry.SetListOrderST(value : String);
begin
  if value <> '' then
  begin
    if FListOrder = nil then
      FListOrder := TFhirPositiveInt.create;
    FListOrder.value := value
  end
  else if FListOrder <> nil then
    FListOrder.value := '';
end;

{ TFhirCitationCitedArtifactContributorshipEntryListEnumerator }

constructor TFhirCitationCitedArtifactContributorshipEntryListEnumerator.Create(list : TFhirCitationCitedArtifactContributorshipEntryList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirCitationCitedArtifactContributorshipEntryListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirCitationCitedArtifactContributorshipEntryListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirCitationCitedArtifactContributorshipEntryListEnumerator.GetCurrent : TFhirCitationCitedArtifactContributorshipEntry;
begin
  Result := FList[FIndex];
end;

function TFhirCitationCitedArtifactContributorshipEntryListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirCitationCitedArtifactContributorshipEntryList }

procedure TFhirCitationCitedArtifactContributorshipEntryList.AddItem(value: TFhirCitationCitedArtifactContributorshipEntry);
begin
  assert(value.ClassName = 'TFhirCitationCitedArtifactContributorshipEntry', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirCitationCitedArtifactContributorshipEntry');
  add(value);
end;

function TFhirCitationCitedArtifactContributorshipEntryList.Append: TFhirCitationCitedArtifactContributorshipEntry;
begin
  result := TFhirCitationCitedArtifactContributorshipEntry.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirCitationCitedArtifactContributorshipEntryList.ClearItems;
begin
  Clear;
end;

function TFhirCitationCitedArtifactContributorshipEntryList.GetEnumerator : TFhirCitationCitedArtifactContributorshipEntryListEnumerator;
begin
  result := TFhirCitationCitedArtifactContributorshipEntryListEnumerator.Create(self.link);
end;

function TFhirCitationCitedArtifactContributorshipEntryList.Clone: TFhirCitationCitedArtifactContributorshipEntryList;
begin
  result := TFhirCitationCitedArtifactContributorshipEntryList(inherited Clone);
end;

function TFhirCitationCitedArtifactContributorshipEntryList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirCitationCitedArtifactContributorshipEntryList.GetItemN(index: Integer): TFhirCitationCitedArtifactContributorshipEntry;
begin
  result := TFhirCitationCitedArtifactContributorshipEntry(ObjectByIndex[index]);
end;

function TFhirCitationCitedArtifactContributorshipEntryList.ItemClass: TFslObjectClass;
begin
  result := TFhirCitationCitedArtifactContributorshipEntry;
end;
function TFhirCitationCitedArtifactContributorshipEntryList.IndexOf(value: TFhirCitationCitedArtifactContributorshipEntry): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirCitationCitedArtifactContributorshipEntryList.Insert(index: Integer): TFhirCitationCitedArtifactContributorshipEntry;
begin
  result := TFhirCitationCitedArtifactContributorshipEntry.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirCitationCitedArtifactContributorshipEntryList.InsertItem(index: Integer; value: TFhirCitationCitedArtifactContributorshipEntry);
begin
  assert(value is TFhirCitationCitedArtifactContributorshipEntry);
  Inherited Insert(index, value);
end;

function TFhirCitationCitedArtifactContributorshipEntryList.Item(index: Integer): TFhirCitationCitedArtifactContributorshipEntry;
begin
  result := TFhirCitationCitedArtifactContributorshipEntry(ObjectByIndex[index]);
end;

function TFhirCitationCitedArtifactContributorshipEntryList.Link: TFhirCitationCitedArtifactContributorshipEntryList;
begin
  result := TFhirCitationCitedArtifactContributorshipEntryList(inherited Link);
end;

procedure TFhirCitationCitedArtifactContributorshipEntryList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirCitationCitedArtifactContributorshipEntryList.SetItemByIndex(index: Integer; value: TFhirCitationCitedArtifactContributorshipEntry);
begin
  assert(value is TFhirCitationCitedArtifactContributorshipEntry);
  FhirCitationCitedArtifactContributorshipEntries[index] := value;
end;

procedure TFhirCitationCitedArtifactContributorshipEntryList.SetItemN(index: Integer; value: TFhirCitationCitedArtifactContributorshipEntry);
begin
  assert(value is TFhirCitationCitedArtifactContributorshipEntry);
  ObjectByIndex[index] := value;
end;

{ TFhirCitationCitedArtifactContributorshipEntryAffiliationInfo }

constructor TFhirCitationCitedArtifactContributorshipEntryAffiliationInfo.Create;
begin
  inherited;
end;

destructor TFhirCitationCitedArtifactContributorshipEntryAffiliationInfo.Destroy;
begin
  FAffiliation.free;
  FRole.free;
  FIdentifierList.Free;
  inherited;
end;

procedure TFhirCitationCitedArtifactContributorshipEntryAffiliationInfo.Assign(oSource : TFslObject);
begin
  inherited;
  affiliationElement := TFhirCitationCitedArtifactContributorshipEntryAffiliationInfo(oSource).affiliationElement.Clone;
  roleElement := TFhirCitationCitedArtifactContributorshipEntryAffiliationInfo(oSource).roleElement.Clone;
  if (TFhirCitationCitedArtifactContributorshipEntryAffiliationInfo(oSource).FIdentifierList = nil) then
  begin
    FIdentifierList.free;
    FIdentifierList := nil;
  end
  else
  begin
    if FIdentifierList = nil then
      FIdentifierList := TFhirIdentifierList.Create;
    FIdentifierList.Assign(TFhirCitationCitedArtifactContributorshipEntryAffiliationInfo(oSource).FIdentifierList);
  end;
end;

procedure TFhirCitationCitedArtifactContributorshipEntryAffiliationInfo.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'affiliation') Then
     list.add(self.link, 'affiliation', FAffiliation.Link);
  if (child_name = 'role') Then
     list.add(self.link, 'role', FRole.Link);
  if (child_name = 'identifier') Then
    list.addAll(self, 'identifier', FIdentifierList);
end;

procedure TFhirCitationCitedArtifactContributorshipEntryAffiliationInfo.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'affiliation', 'string', false, TFhirString, FAffiliation.Link));
  oList.add(TFHIRProperty.create(self, 'role', 'string', false, TFhirString, FRole.Link));
  oList.add(TFHIRProperty.create(self, 'identifier', 'Identifier', true, TFhirIdentifier, FIdentifierList.Link));
end;

function TFhirCitationCitedArtifactContributorshipEntryAffiliationInfo.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'affiliation') then
  begin
    AffiliationElement := asString(propValue);
    result := propValue;
  end
  else if (propName = 'role') then
  begin
    RoleElement := asString(propValue);
    result := propValue;
  end
  else if (propName = 'identifier') then
  begin
    IdentifierList.add(propValue as TFhirIdentifier);
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirCitationCitedArtifactContributorshipEntryAffiliationInfo.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'identifier') then IdentifierList.insertItem(index, propValue as TFhirIdentifier)
  else inherited;
end;

function TFhirCitationCitedArtifactContributorshipEntryAffiliationInfo.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'affiliation') then result := TFhirString.create()
  else if (propName = 'role') then result := TFhirString.create()
  else if (propName = 'identifier') then result := IdentifierList.new()
  else result := inherited createPropertyValue(propName);
end;

function TFhirCitationCitedArtifactContributorshipEntryAffiliationInfo.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'affiliation') then result := 'string'
  else if (propName = 'role') then result := 'string'
  else if (propName = 'identifier') then result := 'Identifier'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirCitationCitedArtifactContributorshipEntryAffiliationInfo.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'affiliation') then AffiliationElement := nil
  else if (propName = 'role') then RoleElement := nil
  else if (propName = 'identifier') then deletePropertyValue('identifier', IdentifierList, value)
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirCitationCitedArtifactContributorshipEntryAffiliationInfo.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'affiliation') then AffiliationElement := asString(new)
  else if (propName = 'role') then RoleElement := asString(new)
  else if (propName = 'identifier') then replacePropertyValue('identifier', IdentifierList, existing, new)
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirCitationCitedArtifactContributorshipEntryAffiliationInfo.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'identifier') then IdentifierList.move(source, destination)
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirCitationCitedArtifactContributorshipEntryAffiliationInfo.fhirType : string;
begin
  result := 'Citation.citedArtifact.contributorship.entry.affiliationInfo';
end;

function TFhirCitationCitedArtifactContributorshipEntryAffiliationInfo.Link : TFhirCitationCitedArtifactContributorshipEntryAffiliationInfo;
begin
  result := TFhirCitationCitedArtifactContributorshipEntryAffiliationInfo(inherited Link);
end;

function TFhirCitationCitedArtifactContributorshipEntryAffiliationInfo.Clone : TFhirCitationCitedArtifactContributorshipEntryAffiliationInfo;
begin
  result := TFhirCitationCitedArtifactContributorshipEntryAffiliationInfo(inherited Clone);
end;

function TFhirCitationCitedArtifactContributorshipEntryAffiliationInfo.equals(other : TObject) : boolean; 
var
  o : TFhirCitationCitedArtifactContributorshipEntryAffiliationInfo;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirCitationCitedArtifactContributorshipEntryAffiliationInfo)) then
    result := false
  else
  begin
    o := TFhirCitationCitedArtifactContributorshipEntryAffiliationInfo(other);
    result := compareDeep(affiliationElement, o.affiliationElement, true) and compareDeep(roleElement, o.roleElement, true) and 
      compareDeep(identifierList, o.identifierList, true);
  end;
end;

function TFhirCitationCitedArtifactContributorshipEntryAffiliationInfo.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FAffiliation) and isEmptyProp(FRole) and isEmptyProp(FidentifierList);
end;

procedure TFhirCitationCitedArtifactContributorshipEntryAffiliationInfo.listFieldsInOrder(fields : TStringList);
begin
  inherited listFieldsInOrder(fields);
  fields.add('affiliation');
  fields.add('role');
  fields.add('identifier');
end;

function TFhirCitationCitedArtifactContributorshipEntryAffiliationInfo.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FIdentifierList.sizeInBytes(magic));
end;

procedure TFhirCitationCitedArtifactContributorshipEntryAffiliationInfo.SetAffiliation(value : TFhirString);
begin
  FAffiliation.free;
  FAffiliation := value;
end;

function TFhirCitationCitedArtifactContributorshipEntryAffiliationInfo.GetAffiliationST : String;
begin
  if FAffiliation = nil then
    result := ''
  else
    result := FAffiliation.value;
end;

procedure TFhirCitationCitedArtifactContributorshipEntryAffiliationInfo.SetAffiliationST(value : String);
begin
  if value <> '' then
  begin
    if FAffiliation = nil then
      FAffiliation := TFhirString.create;
    FAffiliation.value := value
  end
  else if FAffiliation <> nil then
    FAffiliation.value := '';
end;

procedure TFhirCitationCitedArtifactContributorshipEntryAffiliationInfo.SetRole(value : TFhirString);
begin
  FRole.free;
  FRole := value;
end;

function TFhirCitationCitedArtifactContributorshipEntryAffiliationInfo.GetRoleST : String;
begin
  if FRole = nil then
    result := ''
  else
    result := FRole.value;
end;

procedure TFhirCitationCitedArtifactContributorshipEntryAffiliationInfo.SetRoleST(value : String);
begin
  if value <> '' then
  begin
    if FRole = nil then
      FRole := TFhirString.create;
    FRole.value := value
  end
  else if FRole <> nil then
    FRole.value := '';
end;

function TFhirCitationCitedArtifactContributorshipEntryAffiliationInfo.GetIdentifierList : TFhirIdentifierList;
begin
  if FIdentifierList = nil then
    FIdentifierList := TFhirIdentifierList.Create;
  result := FIdentifierList;
end;

function TFhirCitationCitedArtifactContributorshipEntryAffiliationInfo.GetHasIdentifierList : boolean;
begin
  result := (FIdentifierList <> nil) and (FIdentifierList.count > 0);
end;

{ TFhirCitationCitedArtifactContributorshipEntryAffiliationInfoListEnumerator }

constructor TFhirCitationCitedArtifactContributorshipEntryAffiliationInfoListEnumerator.Create(list : TFhirCitationCitedArtifactContributorshipEntryAffiliationInfoList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirCitationCitedArtifactContributorshipEntryAffiliationInfoListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirCitationCitedArtifactContributorshipEntryAffiliationInfoListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirCitationCitedArtifactContributorshipEntryAffiliationInfoListEnumerator.GetCurrent : TFhirCitationCitedArtifactContributorshipEntryAffiliationInfo;
begin
  Result := FList[FIndex];
end;

function TFhirCitationCitedArtifactContributorshipEntryAffiliationInfoListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirCitationCitedArtifactContributorshipEntryAffiliationInfoList }

procedure TFhirCitationCitedArtifactContributorshipEntryAffiliationInfoList.AddItem(value: TFhirCitationCitedArtifactContributorshipEntryAffiliationInfo);
begin
  assert(value.ClassName = 'TFhirCitationCitedArtifactContributorshipEntryAffiliationInfo', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirCitationCitedArtifactContributorshipEntryAffiliationInfo');
  add(value);
end;

function TFhirCitationCitedArtifactContributorshipEntryAffiliationInfoList.Append: TFhirCitationCitedArtifactContributorshipEntryAffiliationInfo;
begin
  result := TFhirCitationCitedArtifactContributorshipEntryAffiliationInfo.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirCitationCitedArtifactContributorshipEntryAffiliationInfoList.ClearItems;
begin
  Clear;
end;

function TFhirCitationCitedArtifactContributorshipEntryAffiliationInfoList.GetEnumerator : TFhirCitationCitedArtifactContributorshipEntryAffiliationInfoListEnumerator;
begin
  result := TFhirCitationCitedArtifactContributorshipEntryAffiliationInfoListEnumerator.Create(self.link);
end;

function TFhirCitationCitedArtifactContributorshipEntryAffiliationInfoList.Clone: TFhirCitationCitedArtifactContributorshipEntryAffiliationInfoList;
begin
  result := TFhirCitationCitedArtifactContributorshipEntryAffiliationInfoList(inherited Clone);
end;

function TFhirCitationCitedArtifactContributorshipEntryAffiliationInfoList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirCitationCitedArtifactContributorshipEntryAffiliationInfoList.GetItemN(index: Integer): TFhirCitationCitedArtifactContributorshipEntryAffiliationInfo;
begin
  result := TFhirCitationCitedArtifactContributorshipEntryAffiliationInfo(ObjectByIndex[index]);
end;

function TFhirCitationCitedArtifactContributorshipEntryAffiliationInfoList.ItemClass: TFslObjectClass;
begin
  result := TFhirCitationCitedArtifactContributorshipEntryAffiliationInfo;
end;
function TFhirCitationCitedArtifactContributorshipEntryAffiliationInfoList.IndexOf(value: TFhirCitationCitedArtifactContributorshipEntryAffiliationInfo): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirCitationCitedArtifactContributorshipEntryAffiliationInfoList.Insert(index: Integer): TFhirCitationCitedArtifactContributorshipEntryAffiliationInfo;
begin
  result := TFhirCitationCitedArtifactContributorshipEntryAffiliationInfo.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirCitationCitedArtifactContributorshipEntryAffiliationInfoList.InsertItem(index: Integer; value: TFhirCitationCitedArtifactContributorshipEntryAffiliationInfo);
begin
  assert(value is TFhirCitationCitedArtifactContributorshipEntryAffiliationInfo);
  Inherited Insert(index, value);
end;

function TFhirCitationCitedArtifactContributorshipEntryAffiliationInfoList.Item(index: Integer): TFhirCitationCitedArtifactContributorshipEntryAffiliationInfo;
begin
  result := TFhirCitationCitedArtifactContributorshipEntryAffiliationInfo(ObjectByIndex[index]);
end;

function TFhirCitationCitedArtifactContributorshipEntryAffiliationInfoList.Link: TFhirCitationCitedArtifactContributorshipEntryAffiliationInfoList;
begin
  result := TFhirCitationCitedArtifactContributorshipEntryAffiliationInfoList(inherited Link);
end;

procedure TFhirCitationCitedArtifactContributorshipEntryAffiliationInfoList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirCitationCitedArtifactContributorshipEntryAffiliationInfoList.SetItemByIndex(index: Integer; value: TFhirCitationCitedArtifactContributorshipEntryAffiliationInfo);
begin
  assert(value is TFhirCitationCitedArtifactContributorshipEntryAffiliationInfo);
  FhirCitationCitedArtifactContributorshipEntryAffiliationInfos[index] := value;
end;

procedure TFhirCitationCitedArtifactContributorshipEntryAffiliationInfoList.SetItemN(index: Integer; value: TFhirCitationCitedArtifactContributorshipEntryAffiliationInfo);
begin
  assert(value is TFhirCitationCitedArtifactContributorshipEntryAffiliationInfo);
  ObjectByIndex[index] := value;
end;

{ TFhirCitationCitedArtifactContributorshipEntryContributionInstance }

constructor TFhirCitationCitedArtifactContributorshipEntryContributionInstance.Create;
begin
  inherited;
end;

destructor TFhirCitationCitedArtifactContributorshipEntryContributionInstance.Destroy;
begin
  FType_.free;
  FTime.free;
  inherited;
end;

procedure TFhirCitationCitedArtifactContributorshipEntryContributionInstance.Assign(oSource : TFslObject);
begin
  inherited;
  type_ := TFhirCitationCitedArtifactContributorshipEntryContributionInstance(oSource).type_.Clone;
  timeElement := TFhirCitationCitedArtifactContributorshipEntryContributionInstance(oSource).timeElement.Clone;
end;

procedure TFhirCitationCitedArtifactContributorshipEntryContributionInstance.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'type') Then
     list.add(self.link, 'type', FType_.Link);
  if (child_name = 'time') Then
     list.add(self.link, 'time', FTime.Link);
end;

procedure TFhirCitationCitedArtifactContributorshipEntryContributionInstance.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'type', 'CodeableConcept', false, TFhirCodeableConcept, FType_.Link));
  oList.add(TFHIRProperty.create(self, 'time', 'dateTime', false, TFhirDateTime, FTime.Link));
end;

function TFhirCitationCitedArtifactContributorshipEntryContributionInstance.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'type') then
  begin
    Type_ := propValue as TFhirCodeableConcept;
    result := propValue;
  end
  else if (propName = 'time') then
  begin
    TimeElement := asDateTime(propValue);
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirCitationCitedArtifactContributorshipEntryContributionInstance.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirCitationCitedArtifactContributorshipEntryContributionInstance.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'type') then result := TFhirCodeableConcept.create()
  else if (propName = 'time') then result := TFhirDateTime.create()
  else result := inherited createPropertyValue(propName);
end;

function TFhirCitationCitedArtifactContributorshipEntryContributionInstance.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'type') then result := 'CodeableConcept'
  else if (propName = 'time') then result := 'dateTime'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirCitationCitedArtifactContributorshipEntryContributionInstance.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'type') then Type_Element := nil
  else if (propName = 'time') then TimeElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirCitationCitedArtifactContributorshipEntryContributionInstance.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'type') then Type_Element := new as TFhirCodeableConcept
  else if (propName = 'time') then TimeElement := asDateTime(new)
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirCitationCitedArtifactContributorshipEntryContributionInstance.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirCitationCitedArtifactContributorshipEntryContributionInstance.fhirType : string;
begin
  result := 'Citation.citedArtifact.contributorship.entry.contributionInstance';
end;

function TFhirCitationCitedArtifactContributorshipEntryContributionInstance.Link : TFhirCitationCitedArtifactContributorshipEntryContributionInstance;
begin
  result := TFhirCitationCitedArtifactContributorshipEntryContributionInstance(inherited Link);
end;

function TFhirCitationCitedArtifactContributorshipEntryContributionInstance.Clone : TFhirCitationCitedArtifactContributorshipEntryContributionInstance;
begin
  result := TFhirCitationCitedArtifactContributorshipEntryContributionInstance(inherited Clone);
end;

function TFhirCitationCitedArtifactContributorshipEntryContributionInstance.equals(other : TObject) : boolean; 
var
  o : TFhirCitationCitedArtifactContributorshipEntryContributionInstance;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirCitationCitedArtifactContributorshipEntryContributionInstance)) then
    result := false
  else
  begin
    o := TFhirCitationCitedArtifactContributorshipEntryContributionInstance(other);
    result := compareDeep(type_Element, o.type_Element, true) and compareDeep(timeElement, o.timeElement, true);
  end;
end;

function TFhirCitationCitedArtifactContributorshipEntryContributionInstance.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FType_) and isEmptyProp(FTime);
end;

procedure TFhirCitationCitedArtifactContributorshipEntryContributionInstance.listFieldsInOrder(fields : TStringList);
begin
  inherited listFieldsInOrder(fields);
  fields.add('type');
  fields.add('time');
end;

function TFhirCitationCitedArtifactContributorshipEntryContributionInstance.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
end;

procedure TFhirCitationCitedArtifactContributorshipEntryContributionInstance.SetType_(value : TFhirCodeableConcept);
begin
  FType_.free;
  FType_ := value;
end;

procedure TFhirCitationCitedArtifactContributorshipEntryContributionInstance.SetTime(value : TFhirDateTime);
begin
  FTime.free;
  FTime := value;
end;

function TFhirCitationCitedArtifactContributorshipEntryContributionInstance.GetTimeST : TFslDateTime;
begin
  if FTime = nil then
    result := TFslDateTime.makeNull
  else
    result := FTime.value;
end;

procedure TFhirCitationCitedArtifactContributorshipEntryContributionInstance.SetTimeST(value : TFslDateTime);
begin
  if FTime = nil then
    FTime := TFhirDateTime.create;
  FTime.value := value
end;

{ TFhirCitationCitedArtifactContributorshipEntryContributionInstanceListEnumerator }

constructor TFhirCitationCitedArtifactContributorshipEntryContributionInstanceListEnumerator.Create(list : TFhirCitationCitedArtifactContributorshipEntryContributionInstanceList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirCitationCitedArtifactContributorshipEntryContributionInstanceListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirCitationCitedArtifactContributorshipEntryContributionInstanceListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirCitationCitedArtifactContributorshipEntryContributionInstanceListEnumerator.GetCurrent : TFhirCitationCitedArtifactContributorshipEntryContributionInstance;
begin
  Result := FList[FIndex];
end;

function TFhirCitationCitedArtifactContributorshipEntryContributionInstanceListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirCitationCitedArtifactContributorshipEntryContributionInstanceList }

procedure TFhirCitationCitedArtifactContributorshipEntryContributionInstanceList.AddItem(value: TFhirCitationCitedArtifactContributorshipEntryContributionInstance);
begin
  assert(value.ClassName = 'TFhirCitationCitedArtifactContributorshipEntryContributionInstance', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirCitationCitedArtifactContributorshipEntryContributionInstance');
  add(value);
end;

function TFhirCitationCitedArtifactContributorshipEntryContributionInstanceList.Append: TFhirCitationCitedArtifactContributorshipEntryContributionInstance;
begin
  result := TFhirCitationCitedArtifactContributorshipEntryContributionInstance.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirCitationCitedArtifactContributorshipEntryContributionInstanceList.ClearItems;
begin
  Clear;
end;

function TFhirCitationCitedArtifactContributorshipEntryContributionInstanceList.GetEnumerator : TFhirCitationCitedArtifactContributorshipEntryContributionInstanceListEnumerator;
begin
  result := TFhirCitationCitedArtifactContributorshipEntryContributionInstanceListEnumerator.Create(self.link);
end;

function TFhirCitationCitedArtifactContributorshipEntryContributionInstanceList.Clone: TFhirCitationCitedArtifactContributorshipEntryContributionInstanceList;
begin
  result := TFhirCitationCitedArtifactContributorshipEntryContributionInstanceList(inherited Clone);
end;

function TFhirCitationCitedArtifactContributorshipEntryContributionInstanceList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirCitationCitedArtifactContributorshipEntryContributionInstanceList.GetItemN(index: Integer): TFhirCitationCitedArtifactContributorshipEntryContributionInstance;
begin
  result := TFhirCitationCitedArtifactContributorshipEntryContributionInstance(ObjectByIndex[index]);
end;

function TFhirCitationCitedArtifactContributorshipEntryContributionInstanceList.ItemClass: TFslObjectClass;
begin
  result := TFhirCitationCitedArtifactContributorshipEntryContributionInstance;
end;
function TFhirCitationCitedArtifactContributorshipEntryContributionInstanceList.IndexOf(value: TFhirCitationCitedArtifactContributorshipEntryContributionInstance): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirCitationCitedArtifactContributorshipEntryContributionInstanceList.Insert(index: Integer): TFhirCitationCitedArtifactContributorshipEntryContributionInstance;
begin
  result := TFhirCitationCitedArtifactContributorshipEntryContributionInstance.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirCitationCitedArtifactContributorshipEntryContributionInstanceList.InsertItem(index: Integer; value: TFhirCitationCitedArtifactContributorshipEntryContributionInstance);
begin
  assert(value is TFhirCitationCitedArtifactContributorshipEntryContributionInstance);
  Inherited Insert(index, value);
end;

function TFhirCitationCitedArtifactContributorshipEntryContributionInstanceList.Item(index: Integer): TFhirCitationCitedArtifactContributorshipEntryContributionInstance;
begin
  result := TFhirCitationCitedArtifactContributorshipEntryContributionInstance(ObjectByIndex[index]);
end;

function TFhirCitationCitedArtifactContributorshipEntryContributionInstanceList.Link: TFhirCitationCitedArtifactContributorshipEntryContributionInstanceList;
begin
  result := TFhirCitationCitedArtifactContributorshipEntryContributionInstanceList(inherited Link);
end;

procedure TFhirCitationCitedArtifactContributorshipEntryContributionInstanceList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirCitationCitedArtifactContributorshipEntryContributionInstanceList.SetItemByIndex(index: Integer; value: TFhirCitationCitedArtifactContributorshipEntryContributionInstance);
begin
  assert(value is TFhirCitationCitedArtifactContributorshipEntryContributionInstance);
  FhirCitationCitedArtifactContributorshipEntryContributionInstances[index] := value;
end;

procedure TFhirCitationCitedArtifactContributorshipEntryContributionInstanceList.SetItemN(index: Integer; value: TFhirCitationCitedArtifactContributorshipEntryContributionInstance);
begin
  assert(value is TFhirCitationCitedArtifactContributorshipEntryContributionInstance);
  ObjectByIndex[index] := value;
end;

{ TFhirCitationCitedArtifactContributorshipSummary }

constructor TFhirCitationCitedArtifactContributorshipSummary.Create;
begin
  inherited;
end;

destructor TFhirCitationCitedArtifactContributorshipSummary.Destroy;
begin
  FType_.free;
  FStyle.free;
  FSource.free;
  FValue.free;
  inherited;
end;

procedure TFhirCitationCitedArtifactContributorshipSummary.Assign(oSource : TFslObject);
begin
  inherited;
  type_ := TFhirCitationCitedArtifactContributorshipSummary(oSource).type_.Clone;
  style := TFhirCitationCitedArtifactContributorshipSummary(oSource).style.Clone;
  source := TFhirCitationCitedArtifactContributorshipSummary(oSource).source.Clone;
  valueElement := TFhirCitationCitedArtifactContributorshipSummary(oSource).valueElement.Clone;
end;

procedure TFhirCitationCitedArtifactContributorshipSummary.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'type') Then
     list.add(self.link, 'type', FType_.Link);
  if (child_name = 'style') Then
     list.add(self.link, 'style', FStyle.Link);
  if (child_name = 'source') Then
     list.add(self.link, 'source', FSource.Link);
  if (child_name = 'value') Then
     list.add(self.link, 'value', FValue.Link);
end;

procedure TFhirCitationCitedArtifactContributorshipSummary.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'type', 'CodeableConcept', false, TFhirCodeableConcept, FType_.Link));
  oList.add(TFHIRProperty.create(self, 'style', 'CodeableConcept', false, TFhirCodeableConcept, FStyle.Link));
  oList.add(TFHIRProperty.create(self, 'source', 'CodeableConcept', false, TFhirCodeableConcept, FSource.Link));
  oList.add(TFHIRProperty.create(self, 'value', 'markdown', false, TFhirMarkdown, FValue.Link));
end;

function TFhirCitationCitedArtifactContributorshipSummary.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'type') then
  begin
    Type_ := propValue as TFhirCodeableConcept;
    result := propValue;
  end
  else if (propName = 'style') then
  begin
    Style := propValue as TFhirCodeableConcept;
    result := propValue;
  end
  else if (propName = 'source') then
  begin
    Source := propValue as TFhirCodeableConcept;
    result := propValue;
  end
  else if (propName = 'value') then
  begin
    ValueElement := asMarkdown(propValue);
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirCitationCitedArtifactContributorshipSummary.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirCitationCitedArtifactContributorshipSummary.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'type') then result := TFhirCodeableConcept.create()
  else if (propName = 'style') then result := TFhirCodeableConcept.create()
  else if (propName = 'source') then result := TFhirCodeableConcept.create()
  else if (propName = 'value') then result := TFhirMarkdown.create()
  else result := inherited createPropertyValue(propName);
end;

function TFhirCitationCitedArtifactContributorshipSummary.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'type') then result := 'CodeableConcept'
  else if (propName = 'style') then result := 'CodeableConcept'
  else if (propName = 'source') then result := 'CodeableConcept'
  else if (propName = 'value') then result := 'markdown'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirCitationCitedArtifactContributorshipSummary.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'type') then Type_Element := nil
  else if (propName = 'style') then StyleElement := nil
  else if (propName = 'source') then SourceElement := nil
  else if (propName = 'value') then ValueElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirCitationCitedArtifactContributorshipSummary.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'type') then Type_Element := new as TFhirCodeableConcept
  else if (propName = 'style') then StyleElement := new as TFhirCodeableConcept
  else if (propName = 'source') then SourceElement := new as TFhirCodeableConcept
  else if (propName = 'value') then ValueElement := asMarkdown(new)
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirCitationCitedArtifactContributorshipSummary.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirCitationCitedArtifactContributorshipSummary.fhirType : string;
begin
  result := 'Citation.citedArtifact.contributorship.summary';
end;

function TFhirCitationCitedArtifactContributorshipSummary.Link : TFhirCitationCitedArtifactContributorshipSummary;
begin
  result := TFhirCitationCitedArtifactContributorshipSummary(inherited Link);
end;

function TFhirCitationCitedArtifactContributorshipSummary.Clone : TFhirCitationCitedArtifactContributorshipSummary;
begin
  result := TFhirCitationCitedArtifactContributorshipSummary(inherited Clone);
end;

function TFhirCitationCitedArtifactContributorshipSummary.equals(other : TObject) : boolean; 
var
  o : TFhirCitationCitedArtifactContributorshipSummary;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirCitationCitedArtifactContributorshipSummary)) then
    result := false
  else
  begin
    o := TFhirCitationCitedArtifactContributorshipSummary(other);
    result := compareDeep(type_Element, o.type_Element, true) and compareDeep(styleElement, o.styleElement, true) and 
      compareDeep(sourceElement, o.sourceElement, true) and compareDeep(valueElement, o.valueElement, true);
  end;
end;

function TFhirCitationCitedArtifactContributorshipSummary.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FType_) and isEmptyProp(FStyle) and isEmptyProp(FSource) and isEmptyProp(FValue);
end;

procedure TFhirCitationCitedArtifactContributorshipSummary.listFieldsInOrder(fields : TStringList);
begin
  inherited listFieldsInOrder(fields);
  fields.add('type');
  fields.add('style');
  fields.add('source');
  fields.add('value');
end;

function TFhirCitationCitedArtifactContributorshipSummary.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
end;

procedure TFhirCitationCitedArtifactContributorshipSummary.SetType_(value : TFhirCodeableConcept);
begin
  FType_.free;
  FType_ := value;
end;

procedure TFhirCitationCitedArtifactContributorshipSummary.SetStyle(value : TFhirCodeableConcept);
begin
  FStyle.free;
  FStyle := value;
end;

procedure TFhirCitationCitedArtifactContributorshipSummary.SetSource(value : TFhirCodeableConcept);
begin
  FSource.free;
  FSource := value;
end;

procedure TFhirCitationCitedArtifactContributorshipSummary.SetValue(value : TFhirMarkdown);
begin
  FValue.free;
  FValue := value;
end;

function TFhirCitationCitedArtifactContributorshipSummary.GetValueST : String;
begin
  if FValue = nil then
    result := ''
  else
    result := FValue.value;
end;

procedure TFhirCitationCitedArtifactContributorshipSummary.SetValueST(value : String);
begin
  if value <> '' then
  begin
    if FValue = nil then
      FValue := TFhirMarkdown.create;
    FValue.value := value
  end
  else if FValue <> nil then
    FValue.value := '';
end;

{ TFhirCitationCitedArtifactContributorshipSummaryListEnumerator }

constructor TFhirCitationCitedArtifactContributorshipSummaryListEnumerator.Create(list : TFhirCitationCitedArtifactContributorshipSummaryList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirCitationCitedArtifactContributorshipSummaryListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirCitationCitedArtifactContributorshipSummaryListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirCitationCitedArtifactContributorshipSummaryListEnumerator.GetCurrent : TFhirCitationCitedArtifactContributorshipSummary;
begin
  Result := FList[FIndex];
end;

function TFhirCitationCitedArtifactContributorshipSummaryListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirCitationCitedArtifactContributorshipSummaryList }

procedure TFhirCitationCitedArtifactContributorshipSummaryList.AddItem(value: TFhirCitationCitedArtifactContributorshipSummary);
begin
  assert(value.ClassName = 'TFhirCitationCitedArtifactContributorshipSummary', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirCitationCitedArtifactContributorshipSummary');
  add(value);
end;

function TFhirCitationCitedArtifactContributorshipSummaryList.Append: TFhirCitationCitedArtifactContributorshipSummary;
begin
  result := TFhirCitationCitedArtifactContributorshipSummary.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirCitationCitedArtifactContributorshipSummaryList.ClearItems;
begin
  Clear;
end;

function TFhirCitationCitedArtifactContributorshipSummaryList.GetEnumerator : TFhirCitationCitedArtifactContributorshipSummaryListEnumerator;
begin
  result := TFhirCitationCitedArtifactContributorshipSummaryListEnumerator.Create(self.link);
end;

function TFhirCitationCitedArtifactContributorshipSummaryList.Clone: TFhirCitationCitedArtifactContributorshipSummaryList;
begin
  result := TFhirCitationCitedArtifactContributorshipSummaryList(inherited Clone);
end;

function TFhirCitationCitedArtifactContributorshipSummaryList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirCitationCitedArtifactContributorshipSummaryList.GetItemN(index: Integer): TFhirCitationCitedArtifactContributorshipSummary;
begin
  result := TFhirCitationCitedArtifactContributorshipSummary(ObjectByIndex[index]);
end;

function TFhirCitationCitedArtifactContributorshipSummaryList.ItemClass: TFslObjectClass;
begin
  result := TFhirCitationCitedArtifactContributorshipSummary;
end;
function TFhirCitationCitedArtifactContributorshipSummaryList.IndexOf(value: TFhirCitationCitedArtifactContributorshipSummary): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirCitationCitedArtifactContributorshipSummaryList.Insert(index: Integer): TFhirCitationCitedArtifactContributorshipSummary;
begin
  result := TFhirCitationCitedArtifactContributorshipSummary.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirCitationCitedArtifactContributorshipSummaryList.InsertItem(index: Integer; value: TFhirCitationCitedArtifactContributorshipSummary);
begin
  assert(value is TFhirCitationCitedArtifactContributorshipSummary);
  Inherited Insert(index, value);
end;

function TFhirCitationCitedArtifactContributorshipSummaryList.Item(index: Integer): TFhirCitationCitedArtifactContributorshipSummary;
begin
  result := TFhirCitationCitedArtifactContributorshipSummary(ObjectByIndex[index]);
end;

function TFhirCitationCitedArtifactContributorshipSummaryList.Link: TFhirCitationCitedArtifactContributorshipSummaryList;
begin
  result := TFhirCitationCitedArtifactContributorshipSummaryList(inherited Link);
end;

procedure TFhirCitationCitedArtifactContributorshipSummaryList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirCitationCitedArtifactContributorshipSummaryList.SetItemByIndex(index: Integer; value: TFhirCitationCitedArtifactContributorshipSummary);
begin
  assert(value is TFhirCitationCitedArtifactContributorshipSummary);
  FhirCitationCitedArtifactContributorshipSummaries[index] := value;
end;

procedure TFhirCitationCitedArtifactContributorshipSummaryList.SetItemN(index: Integer; value: TFhirCitationCitedArtifactContributorshipSummary);
begin
  assert(value is TFhirCitationCitedArtifactContributorshipSummary);
  ObjectByIndex[index] := value;
end;

{ TFhirCitation }

constructor TFhirCitation.Create;
begin
  inherited;
end;

destructor TFhirCitation.Destroy;
begin
  FSummaryList.Free;
  FClassificationList.Free;
  FNoteList.Free;
  FCurrentStateList.Free;
  FStatusDateList.Free;
  FRelatesToList.Free;
  FCitedArtifact.free;
  inherited;
end;

procedure TFhirCitation.Assign(oSource : TFslObject);
begin
  inherited;
  if (TFhirCitation(oSource).FSummaryList = nil) then
  begin
    FSummaryList.free;
    FSummaryList := nil;
  end
  else
  begin
    if FSummaryList = nil then
      FSummaryList := TFhirContactDetailList.Create;
    FSummaryList.Assign(TFhirCitation(oSource).FSummaryList);
  end;
  if (TFhirCitation(oSource).FClassificationList = nil) then
  begin
    FClassificationList.free;
    FClassificationList := nil;
  end
  else
  begin
    if FClassificationList = nil then
      FClassificationList := TFhirCitationClassificationList.Create;
    FClassificationList.Assign(TFhirCitation(oSource).FClassificationList);
  end;
  if (TFhirCitation(oSource).FNoteList = nil) then
  begin
    FNoteList.free;
    FNoteList := nil;
  end
  else
  begin
    if FNoteList = nil then
      FNoteList := TFhirAnnotationList.Create;
    FNoteList.Assign(TFhirCitation(oSource).FNoteList);
  end;
  if (TFhirCitation(oSource).FCurrentStateList = nil) then
  begin
    FCurrentStateList.free;
    FCurrentStateList := nil;
  end
  else
  begin
    if FCurrentStateList = nil then
      FCurrentStateList := TFhirCodeableConceptList.Create;
    FCurrentStateList.Assign(TFhirCitation(oSource).FCurrentStateList);
  end;
  if (TFhirCitation(oSource).FStatusDateList = nil) then
  begin
    FStatusDateList.free;
    FStatusDateList := nil;
  end
  else
  begin
    if FStatusDateList = nil then
      FStatusDateList := TFhirCitationStatusDateList.Create;
    FStatusDateList.Assign(TFhirCitation(oSource).FStatusDateList);
  end;
  if (TFhirCitation(oSource).FRelatesToList = nil) then
  begin
    FRelatesToList.free;
    FRelatesToList := nil;
  end
  else
  begin
    if FRelatesToList = nil then
      FRelatesToList := TFhirCitationRelatesToList.Create;
    FRelatesToList.Assign(TFhirCitation(oSource).FRelatesToList);
  end;
  citedArtifact := TFhirCitation(oSource).citedArtifact.Clone;
end;

function TFhirCitation.GetResourceType : TFhirResourceType;
begin
  result := frtCitation;
end;

procedure TFhirCitation.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'summary') Then
    list.addAll(self, 'summary', FSummaryList);
  if (child_name = 'classification') Then
    list.addAll(self, 'classification', FClassificationList);
  if (child_name = 'note') Then
    list.addAll(self, 'note', FNoteList);
  if (child_name = 'currentState') Then
    list.addAll(self, 'currentState', FCurrentStateList);
  if (child_name = 'statusDate') Then
    list.addAll(self, 'statusDate', FStatusDateList);
  if (child_name = 'relatesTo') Then
    list.addAll(self, 'relatesTo', FRelatesToList);
  if (child_name = 'citedArtifact') Then
     list.add(self.link, 'citedArtifact', FCitedArtifact.Link);
end;

procedure TFhirCitation.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'summary', 'ContactDetail', true, TFhirContactDetail, FSummaryList.Link));
  oList.add(TFHIRProperty.create(self, 'classification', 'BackboneElement', true, TFhirCitationClassification, FClassificationList.Link));
  oList.add(TFHIRProperty.create(self, 'note', 'Annotation', true, TFhirAnnotation, FNoteList.Link));
  oList.add(TFHIRProperty.create(self, 'currentState', 'CodeableConcept', true, TFhirCodeableConcept, FCurrentStateList.Link));
  oList.add(TFHIRProperty.create(self, 'statusDate', 'BackboneElement', true, TFhirCitationStatusDate, FStatusDateList.Link));
  oList.add(TFHIRProperty.create(self, 'relatesTo', 'BackboneElement', true, TFhirCitationRelatesTo, FRelatesToList.Link));
  oList.add(TFHIRProperty.create(self, 'citedArtifact', 'BackboneElement', false, TFhirCitationCitedArtifact, FCitedArtifact.Link));
end;

function TFhirCitation.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'summary') then
  begin
    SummaryList.add(propValue as TFhirContactDetail);
    result := propValue;
  end
  else if (propName = 'classification') then
  begin
    ClassificationList.add(propValue as TFhirCitationClassification);
    result := propValue;
  end
  else if (propName = 'note') then
  begin
    NoteList.add(propValue as TFhirAnnotation);
    result := propValue;
  end
  else if (propName = 'currentState') then
  begin
    CurrentStateList.add(propValue as TFhirCodeableConcept);
    result := propValue;
  end
  else if (propName = 'statusDate') then
  begin
    StatusDateList.add(propValue as TFhirCitationStatusDate);
    result := propValue;
  end
  else if (propName = 'relatesTo') then
  begin
    RelatesToList.add(propValue as TFhirCitationRelatesTo);
    result := propValue;
  end
  else if (propName = 'citedArtifact') then
  begin
    CitedArtifact := propValue as TFhirCitationCitedArtifact;
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirCitation.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'summary') then SummaryList.insertItem(index, propValue as TFhirContactDetail)
  else if (propName = 'classification') then ClassificationList.insertItem(index, propValue as TFhirCitationClassification)
  else if (propName = 'note') then NoteList.insertItem(index, propValue as TFhirAnnotation)
  else if (propName = 'currentState') then CurrentStateList.insertItem(index, propValue as TFhirCodeableConcept)
  else if (propName = 'statusDate') then StatusDateList.insertItem(index, propValue as TFhirCitationStatusDate)
  else if (propName = 'relatesTo') then RelatesToList.insertItem(index, propValue as TFhirCitationRelatesTo)
  else inherited;
end;

function TFhirCitation.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'summary') then result := SummaryList.new()
  else if (propName = 'classification') then result := ClassificationList.new()
  else if (propName = 'note') then result := NoteList.new()
  else if (propName = 'currentState') then result := CurrentStateList.new()
  else if (propName = 'statusDate') then result := StatusDateList.new()
  else if (propName = 'relatesTo') then result := RelatesToList.new()
  else if (propName = 'citedArtifact') then result := TFhirCitationCitedArtifact.create()
  else result := inherited createPropertyValue(propName);
end;

function TFhirCitation.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'summary') then result := 'ContactDetail'
  else if (propName = 'classification') then result := 'BackboneElement'
  else if (propName = 'note') then result := 'Annotation'
  else if (propName = 'currentState') then result := 'CodeableConcept'
  else if (propName = 'statusDate') then result := 'BackboneElement'
  else if (propName = 'relatesTo') then result := 'BackboneElement'
  else if (propName = 'citedArtifact') then result := 'BackboneElement'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirCitation.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'summary') then deletePropertyValue('summary', SummaryList, value)
  else if (propName = 'classification') then deletePropertyValue('classification', ClassificationList, value)
  else if (propName = 'note') then deletePropertyValue('note', NoteList, value)
  else if (propName = 'currentState') then deletePropertyValue('currentState', CurrentStateList, value)
  else if (propName = 'statusDate') then deletePropertyValue('statusDate', StatusDateList, value)
  else if (propName = 'relatesTo') then deletePropertyValue('relatesTo', RelatesToList, value)
  else if (propName = 'citedArtifact') then CitedArtifactElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirCitation.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'summary') then replacePropertyValue('summary', SummaryList, existing, new)
  else if (propName = 'classification') then replacePropertyValue('classification', ClassificationList, existing, new)
  else if (propName = 'note') then replacePropertyValue('note', NoteList, existing, new)
  else if (propName = 'currentState') then replacePropertyValue('currentState', CurrentStateList, existing, new)
  else if (propName = 'statusDate') then replacePropertyValue('statusDate', StatusDateList, existing, new)
  else if (propName = 'relatesTo') then replacePropertyValue('relatesTo', RelatesToList, existing, new)
  else if (propName = 'citedArtifact') then CitedArtifactElement := new as TFhirCitationCitedArtifact
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirCitation.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'summary') then SummaryList.move(source, destination)
  else if (propName = 'classification') then ClassificationList.move(source, destination)
  else if (propName = 'note') then NoteList.move(source, destination)
  else if (propName = 'currentState') then CurrentStateList.move(source, destination)
  else if (propName = 'statusDate') then StatusDateList.move(source, destination)
  else if (propName = 'relatesTo') then RelatesToList.move(source, destination)
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirCitation.fhirType : string;
begin
  result := 'Citation';
end;

function TFhirCitation.Link : TFhirCitation;
begin
  result := TFhirCitation(inherited Link);
end;

function TFhirCitation.Clone : TFhirCitation;
begin
  result := TFhirCitation(inherited Clone);
end;

function TFhirCitation.equals(other : TObject) : boolean; 
var
  o : TFhirCitation;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirCitation)) then
    result := false
  else
  begin
    o := TFhirCitation(other);
    result := compareDeep(summaryList, o.summaryList, true) and compareDeep(classificationList, o.classificationList, true) and 
      compareDeep(noteList, o.noteList, true) and compareDeep(currentStateList, o.currentStateList, true) and 
      compareDeep(statusDateList, o.statusDateList, true) and compareDeep(relatesToList, o.relatesToList, true) and 
      compareDeep(citedArtifactElement, o.citedArtifactElement, true);
  end;
end;

function TFhirCitation.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FsummaryList) and isEmptyProp(FclassificationList) and isEmptyProp(FnoteList) and isEmptyProp(FcurrentStateList) and isEmptyProp(FstatusDateList) and isEmptyProp(FrelatesToList) and isEmptyProp(FCitedArtifact);
end;

procedure TFhirCitation.listFieldsInOrder(fields : TStringList);
begin
  inherited listFieldsInOrder(fields);
  fields.add('url');
  fields.add('identifier');
  fields.add('version');
  fields.add('name');
  fields.add('title');
  fields.add('status');
  fields.add('experimental');
  fields.add('date');
  fields.add('publisher');
  fields.add('contact');
  fields.add('description');
  fields.add('useContext');
  fields.add('jurisdiction');
  fields.add('purpose');
  fields.add('copyright');
  fields.add('approvalDate');
  fields.add('lastReviewDate');
  fields.add('effectivePeriod');
  fields.add('author');
  fields.add('editor');
  fields.add('reviewer');
  fields.add('endorser');
  fields.add('summary');
  fields.add('classification');
  fields.add('note');
  fields.add('currentState');
  fields.add('statusDate');
  fields.add('relatesTo');
  fields.add('citedArtifact');
end;

function TFhirCitation.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FSummaryList.sizeInBytes(magic));
  inc(result, FClassificationList.sizeInBytes(magic));
  inc(result, FNoteList.sizeInBytes(magic));
  inc(result, FCurrentStateList.sizeInBytes(magic));
  inc(result, FStatusDateList.sizeInBytes(magic));
  inc(result, FRelatesToList.sizeInBytes(magic));
end;

procedure TFhirCitation.SetUrl(value : TFhirUri);
begin
  FUrl.free;
  FUrl := value;
end;

function TFhirCitation.GetUrlST : String;
begin
  if FUrl = nil then
    result := ''
  else
    result := FUrl.value;
end;

procedure TFhirCitation.SetUrlST(value : String);
begin
  if value <> '' then
  begin
    if FUrl = nil then
      FUrl := TFhirUri.create;
    FUrl.value := value
  end
  else if FUrl <> nil then
    FUrl.value := '';
end;

function TFhirCitation.GetIdentifierList : TFhirIdentifierList;
begin
  if FIdentifierList = nil then
    FIdentifierList := TFhirIdentifierList.Create;
  result := FIdentifierList;
end;

function TFhirCitation.GetHasIdentifierList : boolean;
begin
  result := (FIdentifierList <> nil) and (FIdentifierList.count > 0);
end;

procedure TFhirCitation.SetVersion(value : TFhirString);
begin
  FVersion.free;
  FVersion := value;
end;

function TFhirCitation.GetVersionST : String;
begin
  if FVersion = nil then
    result := ''
  else
    result := FVersion.value;
end;

procedure TFhirCitation.SetVersionST(value : String);
begin
  if value <> '' then
  begin
    if FVersion = nil then
      FVersion := TFhirString.create;
    FVersion.value := value
  end
  else if FVersion <> nil then
    FVersion.value := '';
end;

procedure TFhirCitation.SetName(value : TFhirString);
begin
  FName.free;
  FName := value;
end;

function TFhirCitation.GetNameST : String;
begin
  if FName = nil then
    result := ''
  else
    result := FName.value;
end;

procedure TFhirCitation.SetNameST(value : String);
begin
  if value <> '' then
  begin
    if FName = nil then
      FName := TFhirString.create;
    FName.value := value
  end
  else if FName <> nil then
    FName.value := '';
end;

procedure TFhirCitation.SetTitle(value : TFhirString);
begin
  FTitle.free;
  FTitle := value;
end;

function TFhirCitation.GetTitleST : String;
begin
  if FTitle = nil then
    result := ''
  else
    result := FTitle.value;
end;

procedure TFhirCitation.SetTitleST(value : String);
begin
  if value <> '' then
  begin
    if FTitle = nil then
      FTitle := TFhirString.create;
    FTitle.value := value
  end
  else if FTitle <> nil then
    FTitle.value := '';
end;

procedure TFhirCitation.SetStatus(value : TFhirEnum);
begin
  FStatus.free;
  FStatus := value;
end;

function TFhirCitation.GetStatusST : TFhirPublicationStatusEnum;
begin
  if FStatus = nil then
    result := TFhirPublicationStatusEnum(0)
  else
    result := TFhirPublicationStatusEnum(StringArrayIndexOfSensitive(CODES_TFhirPublicationStatusEnum, FStatus.value));
end;

procedure TFhirCitation.SetStatusST(value : TFhirPublicationStatusEnum);
begin
  if ord(value) = 0 then
    StatusElement := nil
  else
    StatusElement := TFhirEnum.create(SYSTEMS_TFhirPublicationStatusEnum[value], CODES_TFhirPublicationStatusEnum[value]);
end;

procedure TFhirCitation.SetExperimental(value : TFhirBoolean);
begin
  FExperimental.free;
  FExperimental := value;
end;

function TFhirCitation.GetExperimentalST : Boolean;
begin
  if FExperimental = nil then
    result := false
  else
    result := FExperimental.value;
end;

procedure TFhirCitation.SetExperimentalST(value : Boolean);
begin
  if FExperimental = nil then
    FExperimental := TFhirBoolean.create;
  FExperimental.value := value
end;

procedure TFhirCitation.SetDate(value : TFhirDateTime);
begin
  FDate.free;
  FDate := value;
end;

function TFhirCitation.GetDateST : TFslDateTime;
begin
  if FDate = nil then
    result := TFslDateTime.makeNull
  else
    result := FDate.value;
end;

procedure TFhirCitation.SetDateST(value : TFslDateTime);
begin
  if FDate = nil then
    FDate := TFhirDateTime.create;
  FDate.value := value
end;

procedure TFhirCitation.SetPublisher(value : TFhirString);
begin
  FPublisher.free;
  FPublisher := value;
end;

function TFhirCitation.GetPublisherST : String;
begin
  if FPublisher = nil then
    result := ''
  else
    result := FPublisher.value;
end;

procedure TFhirCitation.SetPublisherST(value : String);
begin
  if value <> '' then
  begin
    if FPublisher = nil then
      FPublisher := TFhirString.create;
    FPublisher.value := value
  end
  else if FPublisher <> nil then
    FPublisher.value := '';
end;

function TFhirCitation.GetContactList : TFhirContactDetailList;
begin
  if FContactList = nil then
    FContactList := TFhirContactDetailList.Create;
  result := FContactList;
end;

function TFhirCitation.GetHasContactList : boolean;
begin
  result := (FContactList <> nil) and (FContactList.count > 0);
end;

procedure TFhirCitation.SetDescription(value : TFhirMarkdown);
begin
  FDescription.free;
  FDescription := value;
end;

function TFhirCitation.GetDescriptionST : String;
begin
  if FDescription = nil then
    result := ''
  else
    result := FDescription.value;
end;

procedure TFhirCitation.SetDescriptionST(value : String);
begin
  if value <> '' then
  begin
    if FDescription = nil then
      FDescription := TFhirMarkdown.create;
    FDescription.value := value
  end
  else if FDescription <> nil then
    FDescription.value := '';
end;

function TFhirCitation.GetUseContextList : TFhirUsageContextList;
begin
  if FUseContextList = nil then
    FUseContextList := TFhirUsageContextList.Create;
  result := FUseContextList;
end;

function TFhirCitation.GetHasUseContextList : boolean;
begin
  result := (FUseContextList <> nil) and (FUseContextList.count > 0);
end;

function TFhirCitation.GetJurisdictionList : TFhirCodeableConceptList;
begin
  if FJurisdictionList = nil then
    FJurisdictionList := TFhirCodeableConceptList.Create;
  result := FJurisdictionList;
end;

function TFhirCitation.GetHasJurisdictionList : boolean;
begin
  result := (FJurisdictionList <> nil) and (FJurisdictionList.count > 0);
end;

procedure TFhirCitation.SetPurpose(value : TFhirMarkdown);
begin
  FPurpose.free;
  FPurpose := value;
end;

function TFhirCitation.GetPurposeST : String;
begin
  if FPurpose = nil then
    result := ''
  else
    result := FPurpose.value;
end;

procedure TFhirCitation.SetPurposeST(value : String);
begin
  if value <> '' then
  begin
    if FPurpose = nil then
      FPurpose := TFhirMarkdown.create;
    FPurpose.value := value
  end
  else if FPurpose <> nil then
    FPurpose.value := '';
end;

procedure TFhirCitation.SetCopyright(value : TFhirMarkdown);
begin
  FCopyright.free;
  FCopyright := value;
end;

function TFhirCitation.GetCopyrightST : String;
begin
  if FCopyright = nil then
    result := ''
  else
    result := FCopyright.value;
end;

procedure TFhirCitation.SetCopyrightST(value : String);
begin
  if value <> '' then
  begin
    if FCopyright = nil then
      FCopyright := TFhirMarkdown.create;
    FCopyright.value := value
  end
  else if FCopyright <> nil then
    FCopyright.value := '';
end;

procedure TFhirCitation.SetApprovalDate(value : TFhirDate);
begin
  FApprovalDate.free;
  FApprovalDate := value;
end;

function TFhirCitation.GetApprovalDateST : TFslDateTime;
begin
  if FApprovalDate = nil then
    result := TFslDateTime.makeNull
  else
    result := FApprovalDate.value;
end;

procedure TFhirCitation.SetApprovalDateST(value : TFslDateTime);
begin
  if FApprovalDate = nil then
    FApprovalDate := TFhirDate.create;
  FApprovalDate.value := value
end;

procedure TFhirCitation.SetLastReviewDate(value : TFhirDate);
begin
  FLastReviewDate.free;
  FLastReviewDate := value;
end;

function TFhirCitation.GetLastReviewDateST : TFslDateTime;
begin
  if FLastReviewDate = nil then
    result := TFslDateTime.makeNull
  else
    result := FLastReviewDate.value;
end;

procedure TFhirCitation.SetLastReviewDateST(value : TFslDateTime);
begin
  if FLastReviewDate = nil then
    FLastReviewDate := TFhirDate.create;
  FLastReviewDate.value := value
end;

procedure TFhirCitation.SetEffectivePeriod(value : TFhirPeriod);
begin
  FEffectivePeriod.free;
  FEffectivePeriod := value;
end;

function TFhirCitation.GetAuthorList : TFhirContactDetailList;
begin
  if FAuthorList = nil then
    FAuthorList := TFhirContactDetailList.Create;
  result := FAuthorList;
end;

function TFhirCitation.GetHasAuthorList : boolean;
begin
  result := (FAuthorList <> nil) and (FAuthorList.count > 0);
end;

function TFhirCitation.GetEditorList : TFhirContactDetailList;
begin
  if FEditorList = nil then
    FEditorList := TFhirContactDetailList.Create;
  result := FEditorList;
end;

function TFhirCitation.GetHasEditorList : boolean;
begin
  result := (FEditorList <> nil) and (FEditorList.count > 0);
end;

function TFhirCitation.GetReviewerList : TFhirContactDetailList;
begin
  if FReviewerList = nil then
    FReviewerList := TFhirContactDetailList.Create;
  result := FReviewerList;
end;

function TFhirCitation.GetHasReviewerList : boolean;
begin
  result := (FReviewerList <> nil) and (FReviewerList.count > 0);
end;

function TFhirCitation.GetEndorserList : TFhirContactDetailList;
begin
  if FEndorserList = nil then
    FEndorserList := TFhirContactDetailList.Create;
  result := FEndorserList;
end;

function TFhirCitation.GetHasEndorserList : boolean;
begin
  result := (FEndorserList <> nil) and (FEndorserList.count > 0);
end;

function TFhirCitation.GetSummaryList : TFhirContactDetailList;
begin
  if FSummaryList = nil then
    FSummaryList := TFhirContactDetailList.Create;
  result := FSummaryList;
end;

function TFhirCitation.GetHasSummaryList : boolean;
begin
  result := (FSummaryList <> nil) and (FSummaryList.count > 0);
end;

function TFhirCitation.GetClassificationList : TFhirCitationClassificationList;
begin
  if FClassificationList = nil then
    FClassificationList := TFhirCitationClassificationList.Create;
  result := FClassificationList;
end;

function TFhirCitation.GetHasClassificationList : boolean;
begin
  result := (FClassificationList <> nil) and (FClassificationList.count > 0);
end;

function TFhirCitation.GetNoteList : TFhirAnnotationList;
begin
  if FNoteList = nil then
    FNoteList := TFhirAnnotationList.Create;
  result := FNoteList;
end;

function TFhirCitation.GetHasNoteList : boolean;
begin
  result := (FNoteList <> nil) and (FNoteList.count > 0);
end;

function TFhirCitation.GetCurrentStateList : TFhirCodeableConceptList;
begin
  if FCurrentStateList = nil then
    FCurrentStateList := TFhirCodeableConceptList.Create;
  result := FCurrentStateList;
end;

function TFhirCitation.GetHasCurrentStateList : boolean;
begin
  result := (FCurrentStateList <> nil) and (FCurrentStateList.count > 0);
end;

function TFhirCitation.GetStatusDateList : TFhirCitationStatusDateList;
begin
  if FStatusDateList = nil then
    FStatusDateList := TFhirCitationStatusDateList.Create;
  result := FStatusDateList;
end;

function TFhirCitation.GetHasStatusDateList : boolean;
begin
  result := (FStatusDateList <> nil) and (FStatusDateList.count > 0);
end;

function TFhirCitation.GetRelatesToList : TFhirCitationRelatesToList;
begin
  if FRelatesToList = nil then
    FRelatesToList := TFhirCitationRelatesToList.Create;
  result := FRelatesToList;
end;

function TFhirCitation.GetHasRelatesToList : boolean;
begin
  result := (FRelatesToList <> nil) and (FRelatesToList.count > 0);
end;

procedure TFhirCitation.SetCitedArtifact(value : TFhirCitationCitedArtifact);
begin
  FCitedArtifact.free;
  FCitedArtifact := value;
end;

{ TFhirCitationListEnumerator }

constructor TFhirCitationListEnumerator.Create(list : TFhirCitationList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirCitationListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirCitationListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirCitationListEnumerator.GetCurrent : TFhirCitation;
begin
  Result := FList[FIndex];
end;

function TFhirCitationListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirCitationList }

procedure TFhirCitationList.AddItem(value: TFhirCitation);
begin
  assert(value.ClassName = 'TFhirCitation', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirCitation');
  add(value);
end;

function TFhirCitationList.Append: TFhirCitation;
begin
  result := TFhirCitation.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirCitationList.ClearItems;
begin
  Clear;
end;

function TFhirCitationList.GetEnumerator : TFhirCitationListEnumerator;
begin
  result := TFhirCitationListEnumerator.Create(self.link);
end;

function TFhirCitationList.Clone: TFhirCitationList;
begin
  result := TFhirCitationList(inherited Clone);
end;

function TFhirCitationList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirCitationList.GetItemN(index: Integer): TFhirCitation;
begin
  result := TFhirCitation(ObjectByIndex[index]);
end;

function TFhirCitationList.ItemClass: TFslObjectClass;
begin
  result := TFhirCitation;
end;
function TFhirCitationList.IndexOf(value: TFhirCitation): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirCitationList.Insert(index: Integer): TFhirCitation;
begin
  result := TFhirCitation.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirCitationList.InsertItem(index: Integer; value: TFhirCitation);
begin
  assert(value is TFhirCitation);
  Inherited Insert(index, value);
end;

function TFhirCitationList.Item(index: Integer): TFhirCitation;
begin
  result := TFhirCitation(ObjectByIndex[index]);
end;

function TFhirCitationList.Link: TFhirCitationList;
begin
  result := TFhirCitationList(inherited Link);
end;

procedure TFhirCitationList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirCitationList.SetItemByIndex(index: Integer; value: TFhirCitation);
begin
  assert(value is TFhirCitation);
  FhirCitations[index] := value;
end;

procedure TFhirCitationList.SetItemN(index: Integer; value: TFhirCitation);
begin
  assert(value is TFhirCitation);
  ObjectByIndex[index] := value;
end;

{$ENDIF FHIR_CITATION}
{$IFDEF FHIR_CLAIM}
{ TFhirClaimRelated }

constructor TFhirClaimRelated.Create;
begin
  inherited;
end;

destructor TFhirClaimRelated.Destroy;
begin
  FClaim.free;
  FRelationship.free;
  FReference.free;
  inherited;
end;

procedure TFhirClaimRelated.Assign(oSource : TFslObject);
begin
  inherited;
  claim := TFhirClaimRelated(oSource).claim.Clone;
  relationship := TFhirClaimRelated(oSource).relationship.Clone;
  reference := TFhirClaimRelated(oSource).reference.Clone;
end;

procedure TFhirClaimRelated.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'claim') Then
     list.add(self.link, 'claim', FClaim.Link);
  if (child_name = 'relationship') Then
     list.add(self.link, 'relationship', FRelationship.Link);
  if (child_name = 'reference') Then
     list.add(self.link, 'reference', FReference.Link);
end;

procedure TFhirClaimRelated.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'claim', 'Reference', false, TFhirReference, FClaim.Link));
  oList.add(TFHIRProperty.create(self, 'relationship', 'CodeableConcept', false, TFhirCodeableConcept, FRelationship.Link));
  oList.add(TFHIRProperty.create(self, 'reference', 'Identifier', false, TFhirIdentifier, FReference.Link));
end;

function TFhirClaimRelated.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'claim') then
  begin
    Claim := propValue as TFhirReference;
    result := propValue;
  end
  else if (propName = 'relationship') then
  begin
    Relationship := propValue as TFhirCodeableConcept;
    result := propValue;
  end
  else if (propName = 'reference') then
  begin
    Reference := propValue as TFhirIdentifier;
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirClaimRelated.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirClaimRelated.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'claim') then result := TFhirReference.create()
  else if (propName = 'relationship') then result := TFhirCodeableConcept.create()
  else if (propName = 'reference') then result := TFhirIdentifier.create()
  else result := inherited createPropertyValue(propName);
end;

function TFhirClaimRelated.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'claim') then result := 'Reference'
  else if (propName = 'relationship') then result := 'CodeableConcept'
  else if (propName = 'reference') then result := 'Identifier'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirClaimRelated.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'claim') then ClaimElement := nil
  else if (propName = 'relationship') then RelationshipElement := nil
  else if (propName = 'reference') then ReferenceElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirClaimRelated.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'claim') then ClaimElement := new as TFhirReference
  else if (propName = 'relationship') then RelationshipElement := new as TFhirCodeableConcept
  else if (propName = 'reference') then ReferenceElement := new as TFhirIdentifier
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirClaimRelated.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirClaimRelated.fhirType : string;
begin
  result := 'Claim.related';
end;

function TFhirClaimRelated.Link : TFhirClaimRelated;
begin
  result := TFhirClaimRelated(inherited Link);
end;

function TFhirClaimRelated.Clone : TFhirClaimRelated;
begin
  result := TFhirClaimRelated(inherited Clone);
end;

function TFhirClaimRelated.equals(other : TObject) : boolean; 
var
  o : TFhirClaimRelated;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirClaimRelated)) then
    result := false
  else
  begin
    o := TFhirClaimRelated(other);
    result := compareDeep(claimElement, o.claimElement, true) and compareDeep(relationshipElement, o.relationshipElement, true) and 
      compareDeep(referenceElement, o.referenceElement, true);
  end;
end;

function TFhirClaimRelated.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FClaim) and isEmptyProp(FRelationship) and isEmptyProp(FReference);
end;

procedure TFhirClaimRelated.listFieldsInOrder(fields : TStringList);
begin
  inherited listFieldsInOrder(fields);
  fields.add('claim');
  fields.add('relationship');
  fields.add('reference');
end;

function TFhirClaimRelated.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
end;

procedure TFhirClaimRelated.SetClaim(value : TFhirReference);
begin
  FClaim.free;
  FClaim := value;
end;

procedure TFhirClaimRelated.SetRelationship(value : TFhirCodeableConcept);
begin
  FRelationship.free;
  FRelationship := value;
end;

procedure TFhirClaimRelated.SetReference(value : TFhirIdentifier);
begin
  FReference.free;
  FReference := value;
end;

{ TFhirClaimRelatedListEnumerator }

constructor TFhirClaimRelatedListEnumerator.Create(list : TFhirClaimRelatedList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirClaimRelatedListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirClaimRelatedListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirClaimRelatedListEnumerator.GetCurrent : TFhirClaimRelated;
begin
  Result := FList[FIndex];
end;

function TFhirClaimRelatedListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirClaimRelatedList }

procedure TFhirClaimRelatedList.AddItem(value: TFhirClaimRelated);
begin
  assert(value.ClassName = 'TFhirClaimRelated', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirClaimRelated');
  add(value);
end;

function TFhirClaimRelatedList.Append: TFhirClaimRelated;
begin
  result := TFhirClaimRelated.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirClaimRelatedList.ClearItems;
begin
  Clear;
end;

function TFhirClaimRelatedList.GetEnumerator : TFhirClaimRelatedListEnumerator;
begin
  result := TFhirClaimRelatedListEnumerator.Create(self.link);
end;

function TFhirClaimRelatedList.Clone: TFhirClaimRelatedList;
begin
  result := TFhirClaimRelatedList(inherited Clone);
end;

function TFhirClaimRelatedList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirClaimRelatedList.GetItemN(index: Integer): TFhirClaimRelated;
begin
  result := TFhirClaimRelated(ObjectByIndex[index]);
end;

function TFhirClaimRelatedList.ItemClass: TFslObjectClass;
begin
  result := TFhirClaimRelated;
end;
function TFhirClaimRelatedList.IndexOf(value: TFhirClaimRelated): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirClaimRelatedList.Insert(index: Integer): TFhirClaimRelated;
begin
  result := TFhirClaimRelated.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirClaimRelatedList.InsertItem(index: Integer; value: TFhirClaimRelated);
begin
  assert(value is TFhirClaimRelated);
  Inherited Insert(index, value);
end;

function TFhirClaimRelatedList.Item(index: Integer): TFhirClaimRelated;
begin
  result := TFhirClaimRelated(ObjectByIndex[index]);
end;

function TFhirClaimRelatedList.Link: TFhirClaimRelatedList;
begin
  result := TFhirClaimRelatedList(inherited Link);
end;

procedure TFhirClaimRelatedList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirClaimRelatedList.SetItemByIndex(index: Integer; value: TFhirClaimRelated);
begin
  assert(value is TFhirClaimRelated);
  FhirClaimRelateds[index] := value;
end;

procedure TFhirClaimRelatedList.SetItemN(index: Integer; value: TFhirClaimRelated);
begin
  assert(value is TFhirClaimRelated);
  ObjectByIndex[index] := value;
end;

{ TFhirClaimPayee }

constructor TFhirClaimPayee.Create;
begin
  inherited;
end;

destructor TFhirClaimPayee.Destroy;
begin
  FType_.free;
  FParty.free;
  inherited;
end;

procedure TFhirClaimPayee.Assign(oSource : TFslObject);
begin
  inherited;
  type_ := TFhirClaimPayee(oSource).type_.Clone;
  party := TFhirClaimPayee(oSource).party.Clone;
end;

procedure TFhirClaimPayee.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'type') Then
     list.add(self.link, 'type', FType_.Link);
  if (child_name = 'party') Then
     list.add(self.link, 'party', FParty.Link);
end;

procedure TFhirClaimPayee.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'type', 'CodeableConcept', false, TFhirCodeableConcept, FType_.Link));
  oList.add(TFHIRProperty.create(self, 'party', 'Reference', false, TFhirReference, FParty.Link));
end;

function TFhirClaimPayee.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'type') then
  begin
    Type_ := propValue as TFhirCodeableConcept;
    result := propValue;
  end
  else if (propName = 'party') then
  begin
    Party := propValue as TFhirReference;
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirClaimPayee.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirClaimPayee.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'type') then result := TFhirCodeableConcept.create()
  else if (propName = 'party') then result := TFhirReference.create()
  else result := inherited createPropertyValue(propName);
end;

function TFhirClaimPayee.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'type') then result := 'CodeableConcept'
  else if (propName = 'party') then result := 'Reference'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirClaimPayee.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'type') then Type_Element := nil
  else if (propName = 'party') then PartyElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirClaimPayee.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'type') then Type_Element := new as TFhirCodeableConcept
  else if (propName = 'party') then PartyElement := new as TFhirReference
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirClaimPayee.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirClaimPayee.fhirType : string;
begin
  result := 'Claim.payee';
end;

function TFhirClaimPayee.Link : TFhirClaimPayee;
begin
  result := TFhirClaimPayee(inherited Link);
end;

function TFhirClaimPayee.Clone : TFhirClaimPayee;
begin
  result := TFhirClaimPayee(inherited Clone);
end;

function TFhirClaimPayee.equals(other : TObject) : boolean; 
var
  o : TFhirClaimPayee;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirClaimPayee)) then
    result := false
  else
  begin
    o := TFhirClaimPayee(other);
    result := compareDeep(type_Element, o.type_Element, true) and compareDeep(partyElement, o.partyElement, true);
  end;
end;

function TFhirClaimPayee.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FType_) and isEmptyProp(FParty);
end;

procedure TFhirClaimPayee.listFieldsInOrder(fields : TStringList);
begin
  inherited listFieldsInOrder(fields);
  fields.add('type');
  fields.add('party');
end;

function TFhirClaimPayee.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
end;

procedure TFhirClaimPayee.SetType_(value : TFhirCodeableConcept);
begin
  FType_.free;
  FType_ := value;
end;

procedure TFhirClaimPayee.SetParty(value : TFhirReference);
begin
  FParty.free;
  FParty := value;
end;

{ TFhirClaimPayeeListEnumerator }

constructor TFhirClaimPayeeListEnumerator.Create(list : TFhirClaimPayeeList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirClaimPayeeListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirClaimPayeeListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirClaimPayeeListEnumerator.GetCurrent : TFhirClaimPayee;
begin
  Result := FList[FIndex];
end;

function TFhirClaimPayeeListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirClaimPayeeList }

procedure TFhirClaimPayeeList.AddItem(value: TFhirClaimPayee);
begin
  assert(value.ClassName = 'TFhirClaimPayee', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirClaimPayee');
  add(value);
end;

function TFhirClaimPayeeList.Append: TFhirClaimPayee;
begin
  result := TFhirClaimPayee.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirClaimPayeeList.ClearItems;
begin
  Clear;
end;

function TFhirClaimPayeeList.GetEnumerator : TFhirClaimPayeeListEnumerator;
begin
  result := TFhirClaimPayeeListEnumerator.Create(self.link);
end;

function TFhirClaimPayeeList.Clone: TFhirClaimPayeeList;
begin
  result := TFhirClaimPayeeList(inherited Clone);
end;

function TFhirClaimPayeeList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirClaimPayeeList.GetItemN(index: Integer): TFhirClaimPayee;
begin
  result := TFhirClaimPayee(ObjectByIndex[index]);
end;

function TFhirClaimPayeeList.ItemClass: TFslObjectClass;
begin
  result := TFhirClaimPayee;
end;
function TFhirClaimPayeeList.IndexOf(value: TFhirClaimPayee): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirClaimPayeeList.Insert(index: Integer): TFhirClaimPayee;
begin
  result := TFhirClaimPayee.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirClaimPayeeList.InsertItem(index: Integer; value: TFhirClaimPayee);
begin
  assert(value is TFhirClaimPayee);
  Inherited Insert(index, value);
end;

function TFhirClaimPayeeList.Item(index: Integer): TFhirClaimPayee;
begin
  result := TFhirClaimPayee(ObjectByIndex[index]);
end;

function TFhirClaimPayeeList.Link: TFhirClaimPayeeList;
begin
  result := TFhirClaimPayeeList(inherited Link);
end;

procedure TFhirClaimPayeeList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirClaimPayeeList.SetItemByIndex(index: Integer; value: TFhirClaimPayee);
begin
  assert(value is TFhirClaimPayee);
  FhirClaimPayees[index] := value;
end;

procedure TFhirClaimPayeeList.SetItemN(index: Integer; value: TFhirClaimPayee);
begin
  assert(value is TFhirClaimPayee);
  ObjectByIndex[index] := value;
end;

{ TFhirClaimCareTeam }

constructor TFhirClaimCareTeam.Create;
begin
  inherited;
end;

destructor TFhirClaimCareTeam.Destroy;
begin
  FSequence.free;
  FProvider.free;
  FResponsible.free;
  FRole.free;
  FQualification.free;
  inherited;
end;

procedure TFhirClaimCareTeam.Assign(oSource : TFslObject);
begin
  inherited;
  sequenceElement := TFhirClaimCareTeam(oSource).sequenceElement.Clone;
  provider := TFhirClaimCareTeam(oSource).provider.Clone;
  responsibleElement := TFhirClaimCareTeam(oSource).responsibleElement.Clone;
  role := TFhirClaimCareTeam(oSource).role.Clone;
  qualification := TFhirClaimCareTeam(oSource).qualification.Clone;
end;

procedure TFhirClaimCareTeam.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'sequence') Then
     list.add(self.link, 'sequence', FSequence.Link);
  if (child_name = 'provider') Then
     list.add(self.link, 'provider', FProvider.Link);
  if (child_name = 'responsible') Then
     list.add(self.link, 'responsible', FResponsible.Link);
  if (child_name = 'role') Then
     list.add(self.link, 'role', FRole.Link);
  if (child_name = 'qualification') Then
     list.add(self.link, 'qualification', FQualification.Link);
end;

procedure TFhirClaimCareTeam.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'sequence', 'positiveInt', false, TFhirPositiveInt, FSequence.Link));
  oList.add(TFHIRProperty.create(self, 'provider', 'Reference', false, TFhirReference, FProvider.Link));
  oList.add(TFHIRProperty.create(self, 'responsible', 'boolean', false, TFhirBoolean, FResponsible.Link));
  oList.add(TFHIRProperty.create(self, 'role', 'CodeableConcept', false, TFhirCodeableConcept, FRole.Link));
  oList.add(TFHIRProperty.create(self, 'qualification', 'CodeableConcept', false, TFhirCodeableConcept, FQualification.Link));
end;

function TFhirClaimCareTeam.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'sequence') then
  begin
    SequenceElement := asPositiveInt(propValue);
    result := propValue;
  end
  else if (propName = 'provider') then
  begin
    Provider := propValue as TFhirReference;
    result := propValue;
  end
  else if (propName = 'responsible') then
  begin
    ResponsibleElement := asBoolean(propValue);
    result := propValue;
  end
  else if (propName = 'role') then
  begin
    Role := propValue as TFhirCodeableConcept;
    result := propValue;
  end
  else if (propName = 'qualification') then
  begin
    Qualification := propValue as TFhirCodeableConcept;
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirClaimCareTeam.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirClaimCareTeam.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'sequence') then result := TFhirPositiveInt.create()
  else if (propName = 'provider') then result := TFhirReference.create()
  else if (propName = 'responsible') then result := TFhirBoolean.create()
  else if (propName = 'role') then result := TFhirCodeableConcept.create()
  else if (propName = 'qualification') then result := TFhirCodeableConcept.create()
  else result := inherited createPropertyValue(propName);
end;

function TFhirClaimCareTeam.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'sequence') then result := 'positiveInt'
  else if (propName = 'provider') then result := 'Reference'
  else if (propName = 'responsible') then result := 'boolean'
  else if (propName = 'role') then result := 'CodeableConcept'
  else if (propName = 'qualification') then result := 'CodeableConcept'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirClaimCareTeam.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'sequence') then SequenceElement := nil
  else if (propName = 'provider') then ProviderElement := nil
  else if (propName = 'responsible') then ResponsibleElement := nil
  else if (propName = 'role') then RoleElement := nil
  else if (propName = 'qualification') then QualificationElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirClaimCareTeam.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'sequence') then SequenceElement := asPositiveInt(new)
  else if (propName = 'provider') then ProviderElement := new as TFhirReference
  else if (propName = 'responsible') then ResponsibleElement := asBoolean(new)
  else if (propName = 'role') then RoleElement := new as TFhirCodeableConcept
  else if (propName = 'qualification') then QualificationElement := new as TFhirCodeableConcept
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirClaimCareTeam.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirClaimCareTeam.fhirType : string;
begin
  result := 'Claim.careTeam';
end;

function TFhirClaimCareTeam.Link : TFhirClaimCareTeam;
begin
  result := TFhirClaimCareTeam(inherited Link);
end;

function TFhirClaimCareTeam.Clone : TFhirClaimCareTeam;
begin
  result := TFhirClaimCareTeam(inherited Clone);
end;

function TFhirClaimCareTeam.equals(other : TObject) : boolean; 
var
  o : TFhirClaimCareTeam;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirClaimCareTeam)) then
    result := false
  else
  begin
    o := TFhirClaimCareTeam(other);
    result := compareDeep(sequenceElement, o.sequenceElement, true) and compareDeep(providerElement, o.providerElement, true) and 
      compareDeep(responsibleElement, o.responsibleElement, true) and compareDeep(roleElement, o.roleElement, true) and 
      compareDeep(qualificationElement, o.qualificationElement, true);
  end;
end;

function TFhirClaimCareTeam.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FSequence) and isEmptyProp(FProvider) and isEmptyProp(FResponsible) and isEmptyProp(FRole) and isEmptyProp(FQualification);
end;

procedure TFhirClaimCareTeam.listFieldsInOrder(fields : TStringList);
begin
  inherited listFieldsInOrder(fields);
  fields.add('sequence');
  fields.add('provider');
  fields.add('responsible');
  fields.add('role');
  fields.add('qualification');
end;

function TFhirClaimCareTeam.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
end;

procedure TFhirClaimCareTeam.SetSequence(value : TFhirPositiveInt);
begin
  FSequence.free;
  FSequence := value;
end;

function TFhirClaimCareTeam.GetSequenceST : String;
begin
  if FSequence = nil then
    result := ''
  else
    result := FSequence.value;
end;

procedure TFhirClaimCareTeam.SetSequenceST(value : String);
begin
  if value <> '' then
  begin
    if FSequence = nil then
      FSequence := TFhirPositiveInt.create;
    FSequence.value := value
  end
  else if FSequence <> nil then
    FSequence.value := '';
end;

procedure TFhirClaimCareTeam.SetProvider(value : TFhirReference);
begin
  FProvider.free;
  FProvider := value;
end;

procedure TFhirClaimCareTeam.SetResponsible(value : TFhirBoolean);
begin
  FResponsible.free;
  FResponsible := value;
end;

function TFhirClaimCareTeam.GetResponsibleST : Boolean;
begin
  if FResponsible = nil then
    result := false
  else
    result := FResponsible.value;
end;

procedure TFhirClaimCareTeam.SetResponsibleST(value : Boolean);
begin
  if FResponsible = nil then
    FResponsible := TFhirBoolean.create;
  FResponsible.value := value
end;

procedure TFhirClaimCareTeam.SetRole(value : TFhirCodeableConcept);
begin
  FRole.free;
  FRole := value;
end;

procedure TFhirClaimCareTeam.SetQualification(value : TFhirCodeableConcept);
begin
  FQualification.free;
  FQualification := value;
end;

{ TFhirClaimCareTeamListEnumerator }

constructor TFhirClaimCareTeamListEnumerator.Create(list : TFhirClaimCareTeamList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirClaimCareTeamListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirClaimCareTeamListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirClaimCareTeamListEnumerator.GetCurrent : TFhirClaimCareTeam;
begin
  Result := FList[FIndex];
end;

function TFhirClaimCareTeamListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirClaimCareTeamList }

procedure TFhirClaimCareTeamList.AddItem(value: TFhirClaimCareTeam);
begin
  assert(value.ClassName = 'TFhirClaimCareTeam', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirClaimCareTeam');
  add(value);
end;

function TFhirClaimCareTeamList.Append: TFhirClaimCareTeam;
begin
  result := TFhirClaimCareTeam.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirClaimCareTeamList.ClearItems;
begin
  Clear;
end;

function TFhirClaimCareTeamList.GetEnumerator : TFhirClaimCareTeamListEnumerator;
begin
  result := TFhirClaimCareTeamListEnumerator.Create(self.link);
end;

function TFhirClaimCareTeamList.Clone: TFhirClaimCareTeamList;
begin
  result := TFhirClaimCareTeamList(inherited Clone);
end;

function TFhirClaimCareTeamList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirClaimCareTeamList.GetItemN(index: Integer): TFhirClaimCareTeam;
begin
  result := TFhirClaimCareTeam(ObjectByIndex[index]);
end;

function TFhirClaimCareTeamList.ItemClass: TFslObjectClass;
begin
  result := TFhirClaimCareTeam;
end;
function TFhirClaimCareTeamList.IndexOf(value: TFhirClaimCareTeam): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirClaimCareTeamList.Insert(index: Integer): TFhirClaimCareTeam;
begin
  result := TFhirClaimCareTeam.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirClaimCareTeamList.InsertItem(index: Integer; value: TFhirClaimCareTeam);
begin
  assert(value is TFhirClaimCareTeam);
  Inherited Insert(index, value);
end;

function TFhirClaimCareTeamList.Item(index: Integer): TFhirClaimCareTeam;
begin
  result := TFhirClaimCareTeam(ObjectByIndex[index]);
end;

function TFhirClaimCareTeamList.Link: TFhirClaimCareTeamList;
begin
  result := TFhirClaimCareTeamList(inherited Link);
end;

procedure TFhirClaimCareTeamList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirClaimCareTeamList.SetItemByIndex(index: Integer; value: TFhirClaimCareTeam);
begin
  assert(value is TFhirClaimCareTeam);
  FhirClaimCareTeams[index] := value;
end;

procedure TFhirClaimCareTeamList.SetItemN(index: Integer; value: TFhirClaimCareTeam);
begin
  assert(value is TFhirClaimCareTeam);
  ObjectByIndex[index] := value;
end;

{ TFhirClaimSupportingInfo }

constructor TFhirClaimSupportingInfo.Create;
begin
  inherited;
end;

destructor TFhirClaimSupportingInfo.Destroy;
begin
  FSequence.free;
  FCategory.free;
  FCode.free;
  FTiming.free;
  FValue.free;
  FReason.free;
  inherited;
end;

procedure TFhirClaimSupportingInfo.Assign(oSource : TFslObject);
begin
  inherited;
  sequenceElement := TFhirClaimSupportingInfo(oSource).sequenceElement.Clone;
  category := TFhirClaimSupportingInfo(oSource).category.Clone;
  code := TFhirClaimSupportingInfo(oSource).code.Clone;
  timing := TFhirClaimSupportingInfo(oSource).timing.Clone;
  value := TFhirClaimSupportingInfo(oSource).value.Clone;
  reason := TFhirClaimSupportingInfo(oSource).reason.Clone;
end;

procedure TFhirClaimSupportingInfo.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'sequence') Then
     list.add(self.link, 'sequence', FSequence.Link);
  if (child_name = 'category') Then
     list.add(self.link, 'category', FCategory.Link);
  if (child_name = 'code') Then
     list.add(self.link, 'code', FCode.Link);
  if (child_name = 'timing[x]') or (child_name = 'timing') Then
     list.add(self.link, 'timing[x]', FTiming.Link);
  if (child_name = 'value[x]') or (child_name = 'value') Then
     list.add(self.link, 'value[x]', FValue.Link);
  if (child_name = 'reason') Then
     list.add(self.link, 'reason', FReason.Link);
end;

procedure TFhirClaimSupportingInfo.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'sequence', 'positiveInt', false, TFhirPositiveInt, FSequence.Link));
  oList.add(TFHIRProperty.create(self, 'category', 'CodeableConcept', false, TFhirCodeableConcept, FCategory.Link));
  oList.add(TFHIRProperty.create(self, 'code', 'CodeableConcept', false, TFhirCodeableConcept, FCode.Link));
  oList.add(TFHIRProperty.create(self, 'timing[x]', 'date|Period', false, TFhirDataType, FTiming.Link));
  oList.add(TFHIRProperty.create(self, 'value[x]', 'boolean|string|Quantity|Attachment|Reference', false, TFhirDataType, FValue.Link));
  oList.add(TFHIRProperty.create(self, 'reason', 'CodeableConcept', false, TFhirCodeableConcept, FReason.Link));
end;

function TFhirClaimSupportingInfo.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'sequence') then
  begin
    SequenceElement := asPositiveInt(propValue);
    result := propValue;
  end
  else if (propName = 'category') then
  begin
    Category := propValue as TFhirCodeableConcept;
    result := propValue;
  end
  else if (propName = 'code') then
  begin
    Code := propValue as TFhirCodeableConcept;
    result := propValue;
  end
  else if (isMatchingName(propName, 'timing', ['Date', 'Period'])) then
  begin
    Timing := propValue as TFhirDataType;
    result := propValue;
  end
  else if (isMatchingName(propName, 'value', ['Boolean', 'String', 'Quantity', 'Attachment', 'Reference'])) then
  begin
    Value := propValue as TFhirDataType;
    result := propValue;
  end
  else if (propName = 'reason') then
  begin
    Reason := propValue as TFhirCodeableConcept;
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirClaimSupportingInfo.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirClaimSupportingInfo.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'sequence') then result := TFhirPositiveInt.create()
  else if (propName = 'category') then result := TFhirCodeableConcept.create()
  else if (propName = 'code') then result := TFhirCodeableConcept.create()
  else if (isMatchingName(propName, 'timing', ['Date', 'Period'])) then raise EFHIRException.create('Cannot make property Timing')
  else if (isMatchingName(propName, 'value', ['Boolean', 'String', 'Quantity', 'Attachment', 'Reference'])) then raise EFHIRException.create('Cannot make property Value')
  else if (propName = 'reason') then result := TFhirCodeableConcept.create()
  else result := inherited createPropertyValue(propName);
end;

function TFhirClaimSupportingInfo.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'sequence') then result := 'positiveInt'
  else if (propName = 'category') then result := 'CodeableConcept'
  else if (propName = 'code') then result := 'CodeableConcept'
  else if (propName = 'timing[x]') then result := 'date|Period'
  else if (propName = 'value[x]') then result := 'boolean|string|Quantity|Attachment|Reference'
  else if (propName = 'reason') then result := 'CodeableConcept'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirClaimSupportingInfo.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'sequence') then SequenceElement := nil
  else if (propName = 'category') then CategoryElement := nil
  else if (propName = 'code') then CodeElement := nil
  else if (isMatchingName(propName, 'timing', ['Date', 'Period'])) then TimingElement := nil
  else if (isMatchingName(propName, 'value', ['Boolean', 'String', 'Quantity', 'Attachment', 'Reference'])) then ValueElement := nil
  else if (propName = 'reason') then ReasonElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirClaimSupportingInfo.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'sequence') then SequenceElement := asPositiveInt(new)
  else if (propName = 'category') then CategoryElement := new as TFhirCodeableConcept
  else if (propName = 'code') then CodeElement := new as TFhirCodeableConcept
  else if (isMatchingName(propName, 'timing', ['Date', 'Period'])) then TimingElement := new as TFhirDataType
  else if (isMatchingName(propName, 'value', ['Boolean', 'String', 'Quantity', 'Attachment', 'Reference'])) then ValueElement := new as TFhirDataType
  else if (propName = 'reason') then ReasonElement := new as TFhirCodeableConcept
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirClaimSupportingInfo.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirClaimSupportingInfo.fhirType : string;
begin
  result := 'Claim.supportingInfo';
end;

function TFhirClaimSupportingInfo.Link : TFhirClaimSupportingInfo;
begin
  result := TFhirClaimSupportingInfo(inherited Link);
end;

function TFhirClaimSupportingInfo.Clone : TFhirClaimSupportingInfo;
begin
  result := TFhirClaimSupportingInfo(inherited Clone);
end;

function TFhirClaimSupportingInfo.equals(other : TObject) : boolean; 
var
  o : TFhirClaimSupportingInfo;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirClaimSupportingInfo)) then
    result := false
  else
  begin
    o := TFhirClaimSupportingInfo(other);
    result := compareDeep(sequenceElement, o.sequenceElement, true) and compareDeep(categoryElement, o.categoryElement, true) and 
      compareDeep(codeElement, o.codeElement, true) and compareDeep(timingElement, o.timingElement, true) and 
      compareDeep(valueElement, o.valueElement, true) and compareDeep(reasonElement, o.reasonElement, true);
  end;
end;

function TFhirClaimSupportingInfo.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FSequence) and isEmptyProp(FCategory) and isEmptyProp(FCode) and isEmptyProp(FTiming) and isEmptyProp(FValue) and isEmptyProp(FReason);
end;

procedure TFhirClaimSupportingInfo.listFieldsInOrder(fields : TStringList);
begin
  inherited listFieldsInOrder(fields);
  fields.add('sequence');
  fields.add('category');
  fields.add('code');
  fields.add('timing[x]');
  fields.add('value[x]');
  fields.add('reason');
end;

function TFhirClaimSupportingInfo.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
end;

procedure TFhirClaimSupportingInfo.SetSequence(value : TFhirPositiveInt);
begin
  FSequence.free;
  FSequence := value;
end;

function TFhirClaimSupportingInfo.GetSequenceST : String;
begin
  if FSequence = nil then
    result := ''
  else
    result := FSequence.value;
end;

procedure TFhirClaimSupportingInfo.SetSequenceST(value : String);
begin
  if value <> '' then
  begin
    if FSequence = nil then
      FSequence := TFhirPositiveInt.create;
    FSequence.value := value
  end
  else if FSequence <> nil then
    FSequence.value := '';
end;

procedure TFhirClaimSupportingInfo.SetCategory(value : TFhirCodeableConcept);
begin
  FCategory.free;
  FCategory := value;
end;

procedure TFhirClaimSupportingInfo.SetCode(value : TFhirCodeableConcept);
begin
  FCode.free;
  FCode := value;
end;

procedure TFhirClaimSupportingInfo.SetTiming(value : TFhirDataType);
begin
  FTiming.free;
  FTiming := value;
end;

procedure TFhirClaimSupportingInfo.SetValue(value : TFhirDataType);
begin
  FValue.free;
  FValue := value;
end;

procedure TFhirClaimSupportingInfo.SetReason(value : TFhirCodeableConcept);
begin
  FReason.free;
  FReason := value;
end;

{ TFhirClaimSupportingInfoListEnumerator }

constructor TFhirClaimSupportingInfoListEnumerator.Create(list : TFhirClaimSupportingInfoList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirClaimSupportingInfoListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirClaimSupportingInfoListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirClaimSupportingInfoListEnumerator.GetCurrent : TFhirClaimSupportingInfo;
begin
  Result := FList[FIndex];
end;

function TFhirClaimSupportingInfoListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirClaimSupportingInfoList }

procedure TFhirClaimSupportingInfoList.AddItem(value: TFhirClaimSupportingInfo);
begin
  assert(value.ClassName = 'TFhirClaimSupportingInfo', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirClaimSupportingInfo');
  add(value);
end;

function TFhirClaimSupportingInfoList.Append: TFhirClaimSupportingInfo;
begin
  result := TFhirClaimSupportingInfo.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirClaimSupportingInfoList.ClearItems;
begin
  Clear;
end;

function TFhirClaimSupportingInfoList.GetEnumerator : TFhirClaimSupportingInfoListEnumerator;
begin
  result := TFhirClaimSupportingInfoListEnumerator.Create(self.link);
end;

function TFhirClaimSupportingInfoList.Clone: TFhirClaimSupportingInfoList;
begin
  result := TFhirClaimSupportingInfoList(inherited Clone);
end;

function TFhirClaimSupportingInfoList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirClaimSupportingInfoList.GetItemN(index: Integer): TFhirClaimSupportingInfo;
begin
  result := TFhirClaimSupportingInfo(ObjectByIndex[index]);
end;

function TFhirClaimSupportingInfoList.ItemClass: TFslObjectClass;
begin
  result := TFhirClaimSupportingInfo;
end;
function TFhirClaimSupportingInfoList.IndexOf(value: TFhirClaimSupportingInfo): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirClaimSupportingInfoList.Insert(index: Integer): TFhirClaimSupportingInfo;
begin
  result := TFhirClaimSupportingInfo.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirClaimSupportingInfoList.InsertItem(index: Integer; value: TFhirClaimSupportingInfo);
begin
  assert(value is TFhirClaimSupportingInfo);
  Inherited Insert(index, value);
end;

function TFhirClaimSupportingInfoList.Item(index: Integer): TFhirClaimSupportingInfo;
begin
  result := TFhirClaimSupportingInfo(ObjectByIndex[index]);
end;

function TFhirClaimSupportingInfoList.Link: TFhirClaimSupportingInfoList;
begin
  result := TFhirClaimSupportingInfoList(inherited Link);
end;

procedure TFhirClaimSupportingInfoList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirClaimSupportingInfoList.SetItemByIndex(index: Integer; value: TFhirClaimSupportingInfo);
begin
  assert(value is TFhirClaimSupportingInfo);
  FhirClaimSupportingInfos[index] := value;
end;

procedure TFhirClaimSupportingInfoList.SetItemN(index: Integer; value: TFhirClaimSupportingInfo);
begin
  assert(value is TFhirClaimSupportingInfo);
  ObjectByIndex[index] := value;
end;

{ TFhirClaimDiagnosis }

constructor TFhirClaimDiagnosis.Create;
begin
  inherited;
end;

destructor TFhirClaimDiagnosis.Destroy;
begin
  FSequence.free;
  FDiagnosis.free;
  FType_List.Free;
  FOnAdmission.free;
  FPackageCode.free;
  inherited;
end;

procedure TFhirClaimDiagnosis.Assign(oSource : TFslObject);
begin
  inherited;
  sequenceElement := TFhirClaimDiagnosis(oSource).sequenceElement.Clone;
  diagnosis := TFhirClaimDiagnosis(oSource).diagnosis.Clone;
  if (TFhirClaimDiagnosis(oSource).FType_List = nil) then
  begin
    FType_List.free;
    FType_List := nil;
  end
  else
  begin
    if FType_List = nil then
      FType_List := TFhirCodeableConceptList.Create;
    FType_List.Assign(TFhirClaimDiagnosis(oSource).FType_List);
  end;
  onAdmission := TFhirClaimDiagnosis(oSource).onAdmission.Clone;
  packageCode := TFhirClaimDiagnosis(oSource).packageCode.Clone;
end;

procedure TFhirClaimDiagnosis.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'sequence') Then
     list.add(self.link, 'sequence', FSequence.Link);
  if (child_name = 'diagnosis[x]') or (child_name = 'diagnosis') Then
     list.add(self.link, 'diagnosis[x]', FDiagnosis.Link);
  if (child_name = 'type') Then
    list.addAll(self, 'type', FType_List);
  if (child_name = 'onAdmission') Then
     list.add(self.link, 'onAdmission', FOnAdmission.Link);
  if (child_name = 'packageCode') Then
     list.add(self.link, 'packageCode', FPackageCode.Link);
end;

procedure TFhirClaimDiagnosis.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'sequence', 'positiveInt', false, TFhirPositiveInt, FSequence.Link));
  oList.add(TFHIRProperty.create(self, 'diagnosis[x]', 'CodeableConcept|Reference', false, TFhirDataType, FDiagnosis.Link));
  oList.add(TFHIRProperty.create(self, 'type', 'CodeableConcept', true, TFhirCodeableConcept, FType_List.Link));
  oList.add(TFHIRProperty.create(self, 'onAdmission', 'CodeableConcept', false, TFhirCodeableConcept, FOnAdmission.Link));
  oList.add(TFHIRProperty.create(self, 'packageCode', 'CodeableConcept', false, TFhirCodeableConcept, FPackageCode.Link));
end;

function TFhirClaimDiagnosis.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'sequence') then
  begin
    SequenceElement := asPositiveInt(propValue);
    result := propValue;
  end
  else if (isMatchingName(propName, 'diagnosis', ['CodeableConcept', 'Reference'])) then
  begin
    Diagnosis := propValue as TFhirDataType;
    result := propValue;
  end
  else if (propName = 'type') then
  begin
    Type_List.add(propValue as TFhirCodeableConcept);
    result := propValue;
  end
  else if (propName = 'onAdmission') then
  begin
    OnAdmission := propValue as TFhirCodeableConcept;
    result := propValue;
  end
  else if (propName = 'packageCode') then
  begin
    PackageCode := propValue as TFhirCodeableConcept;
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirClaimDiagnosis.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'type') then Type_List.insertItem(index, propValue as TFhirCodeableConcept)
  else inherited;
end;

function TFhirClaimDiagnosis.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'sequence') then result := TFhirPositiveInt.create()
  else if (isMatchingName(propName, 'diagnosis', ['CodeableConcept', 'Reference'])) then raise EFHIRException.create('Cannot make property Diagnosis')
  else if (propName = 'type') then result := Type_List.new()
  else if (propName = 'onAdmission') then result := TFhirCodeableConcept.create()
  else if (propName = 'packageCode') then result := TFhirCodeableConcept.create()
  else result := inherited createPropertyValue(propName);
end;

function TFhirClaimDiagnosis.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'sequence') then result := 'positiveInt'
  else if (propName = 'diagnosis[x]') then result := 'CodeableConcept|Reference'
  else if (propName = 'type') then result := 'CodeableConcept'
  else if (propName = 'onAdmission') then result := 'CodeableConcept'
  else if (propName = 'packageCode') then result := 'CodeableConcept'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirClaimDiagnosis.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'sequence') then SequenceElement := nil
  else if (isMatchingName(propName, 'diagnosis', ['CodeableConcept', 'Reference'])) then DiagnosisElement := nil
  else if (propName = 'type') then deletePropertyValue('type', Type_List, value)
  else if (propName = 'onAdmission') then OnAdmissionElement := nil
  else if (propName = 'packageCode') then PackageCodeElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirClaimDiagnosis.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'sequence') then SequenceElement := asPositiveInt(new)
  else if (isMatchingName(propName, 'diagnosis', ['CodeableConcept', 'Reference'])) then DiagnosisElement := new as TFhirDataType
  else if (propName = 'type') then replacePropertyValue('type', Type_List, existing, new)
  else if (propName = 'onAdmission') then OnAdmissionElement := new as TFhirCodeableConcept
  else if (propName = 'packageCode') then PackageCodeElement := new as TFhirCodeableConcept
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirClaimDiagnosis.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'type') then Type_List.move(source, destination)
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirClaimDiagnosis.fhirType : string;
begin
  result := 'Claim.diagnosis';
end;

function TFhirClaimDiagnosis.Link : TFhirClaimDiagnosis;
begin
  result := TFhirClaimDiagnosis(inherited Link);
end;

function TFhirClaimDiagnosis.Clone : TFhirClaimDiagnosis;
begin
  result := TFhirClaimDiagnosis(inherited Clone);
end;

function TFhirClaimDiagnosis.equals(other : TObject) : boolean; 
var
  o : TFhirClaimDiagnosis;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirClaimDiagnosis)) then
    result := false
  else
  begin
    o := TFhirClaimDiagnosis(other);
    result := compareDeep(sequenceElement, o.sequenceElement, true) and compareDeep(diagnosisElement, o.diagnosisElement, true) and 
      compareDeep(type_List, o.type_List, true) and compareDeep(onAdmissionElement, o.onAdmissionElement, true) and 
      compareDeep(packageCodeElement, o.packageCodeElement, true);
  end;
end;

function TFhirClaimDiagnosis.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FSequence) and isEmptyProp(FDiagnosis) and isEmptyProp(Ftype_List) and isEmptyProp(FOnAdmission) and isEmptyProp(FPackageCode);
end;

procedure TFhirClaimDiagnosis.listFieldsInOrder(fields : TStringList);
begin
  inherited listFieldsInOrder(fields);
  fields.add('sequence');
  fields.add('diagnosis[x]');
  fields.add('type');
  fields.add('onAdmission');
  fields.add('packageCode');
end;

function TFhirClaimDiagnosis.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FType_List.sizeInBytes(magic));
end;

procedure TFhirClaimDiagnosis.SetSequence(value : TFhirPositiveInt);
begin
  FSequence.free;
  FSequence := value;
end;

function TFhirClaimDiagnosis.GetSequenceST : String;
begin
  if FSequence = nil then
    result := ''
  else
    result := FSequence.value;
end;

procedure TFhirClaimDiagnosis.SetSequenceST(value : String);
begin
  if value <> '' then
  begin
    if FSequence = nil then
      FSequence := TFhirPositiveInt.create;
    FSequence.value := value
  end
  else if FSequence <> nil then
    FSequence.value := '';
end;

procedure TFhirClaimDiagnosis.SetDiagnosis(value : TFhirDataType);
begin
  FDiagnosis.free;
  FDiagnosis := value;
end;

function TFhirClaimDiagnosis.GetType_List : TFhirCodeableConceptList;
begin
  if FType_List = nil then
    FType_List := TFhirCodeableConceptList.Create;
  result := FType_List;
end;

function TFhirClaimDiagnosis.GetHasType_List : boolean;
begin
  result := (FType_List <> nil) and (FType_List.count > 0);
end;

procedure TFhirClaimDiagnosis.SetOnAdmission(value : TFhirCodeableConcept);
begin
  FOnAdmission.free;
  FOnAdmission := value;
end;

procedure TFhirClaimDiagnosis.SetPackageCode(value : TFhirCodeableConcept);
begin
  FPackageCode.free;
  FPackageCode := value;
end;

{ TFhirClaimDiagnosisListEnumerator }

constructor TFhirClaimDiagnosisListEnumerator.Create(list : TFhirClaimDiagnosisList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirClaimDiagnosisListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirClaimDiagnosisListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirClaimDiagnosisListEnumerator.GetCurrent : TFhirClaimDiagnosis;
begin
  Result := FList[FIndex];
end;

function TFhirClaimDiagnosisListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirClaimDiagnosisList }

procedure TFhirClaimDiagnosisList.AddItem(value: TFhirClaimDiagnosis);
begin
  assert(value.ClassName = 'TFhirClaimDiagnosis', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirClaimDiagnosis');
  add(value);
end;

function TFhirClaimDiagnosisList.Append: TFhirClaimDiagnosis;
begin
  result := TFhirClaimDiagnosis.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirClaimDiagnosisList.ClearItems;
begin
  Clear;
end;

function TFhirClaimDiagnosisList.GetEnumerator : TFhirClaimDiagnosisListEnumerator;
begin
  result := TFhirClaimDiagnosisListEnumerator.Create(self.link);
end;

function TFhirClaimDiagnosisList.Clone: TFhirClaimDiagnosisList;
begin
  result := TFhirClaimDiagnosisList(inherited Clone);
end;

function TFhirClaimDiagnosisList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirClaimDiagnosisList.GetItemN(index: Integer): TFhirClaimDiagnosis;
begin
  result := TFhirClaimDiagnosis(ObjectByIndex[index]);
end;

function TFhirClaimDiagnosisList.ItemClass: TFslObjectClass;
begin
  result := TFhirClaimDiagnosis;
end;
function TFhirClaimDiagnosisList.IndexOf(value: TFhirClaimDiagnosis): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirClaimDiagnosisList.Insert(index: Integer): TFhirClaimDiagnosis;
begin
  result := TFhirClaimDiagnosis.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirClaimDiagnosisList.InsertItem(index: Integer; value: TFhirClaimDiagnosis);
begin
  assert(value is TFhirClaimDiagnosis);
  Inherited Insert(index, value);
end;

function TFhirClaimDiagnosisList.Item(index: Integer): TFhirClaimDiagnosis;
begin
  result := TFhirClaimDiagnosis(ObjectByIndex[index]);
end;

function TFhirClaimDiagnosisList.Link: TFhirClaimDiagnosisList;
begin
  result := TFhirClaimDiagnosisList(inherited Link);
end;

procedure TFhirClaimDiagnosisList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirClaimDiagnosisList.SetItemByIndex(index: Integer; value: TFhirClaimDiagnosis);
begin
  assert(value is TFhirClaimDiagnosis);
  FhirClaimDiagnoses[index] := value;
end;

procedure TFhirClaimDiagnosisList.SetItemN(index: Integer; value: TFhirClaimDiagnosis);
begin
  assert(value is TFhirClaimDiagnosis);
  ObjectByIndex[index] := value;
end;

{ TFhirClaimProcedure }

constructor TFhirClaimProcedure.Create;
begin
  inherited;
end;

destructor TFhirClaimProcedure.Destroy;
begin
  FSequence.free;
  FType_List.Free;
  FDate.free;
  FProcedure_.free;
  FUdiList.Free;
  inherited;
end;

procedure TFhirClaimProcedure.Assign(oSource : TFslObject);
begin
  inherited;
  sequenceElement := TFhirClaimProcedure(oSource).sequenceElement.Clone;
  if (TFhirClaimProcedure(oSource).FType_List = nil) then
  begin
    FType_List.free;
    FType_List := nil;
  end
  else
  begin
    if FType_List = nil then
      FType_List := TFhirCodeableConceptList.Create;
    FType_List.Assign(TFhirClaimProcedure(oSource).FType_List);
  end;
  dateElement := TFhirClaimProcedure(oSource).dateElement.Clone;
  procedure_ := TFhirClaimProcedure(oSource).procedure_.Clone;
  if (TFhirClaimProcedure(oSource).FUdiList = nil) then
  begin
    FUdiList.free;
    FUdiList := nil;
  end
  else
  begin
    if FUdiList = nil then
      FUdiList := TFhirReferenceList.Create;
    FUdiList.Assign(TFhirClaimProcedure(oSource).FUdiList);
  end;
end;

procedure TFhirClaimProcedure.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'sequence') Then
     list.add(self.link, 'sequence', FSequence.Link);
  if (child_name = 'type') Then
    list.addAll(self, 'type', FType_List);
  if (child_name = 'date') Then
     list.add(self.link, 'date', FDate.Link);
  if (child_name = 'procedure[x]') or (child_name = 'procedure') Then
     list.add(self.link, 'procedure[x]', FProcedure_.Link);
  if (child_name = 'udi') Then
    list.addAll(self, 'udi', FUdiList);
end;

procedure TFhirClaimProcedure.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'sequence', 'positiveInt', false, TFhirPositiveInt, FSequence.Link));
  oList.add(TFHIRProperty.create(self, 'type', 'CodeableConcept', true, TFhirCodeableConcept, FType_List.Link));
  oList.add(TFHIRProperty.create(self, 'date', 'dateTime', false, TFhirDateTime, FDate.Link));
  oList.add(TFHIRProperty.create(self, 'procedure[x]', 'CodeableConcept|Reference', false, TFhirDataType, FProcedure_.Link));
  oList.add(TFHIRProperty.create(self, 'udi', 'Reference', true, TFhirReference, FUdiList.Link));
end;

function TFhirClaimProcedure.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'sequence') then
  begin
    SequenceElement := asPositiveInt(propValue);
    result := propValue;
  end
  else if (propName = 'type') then
  begin
    Type_List.add(propValue as TFhirCodeableConcept);
    result := propValue;
  end
  else if (propName = 'date') then
  begin
    DateElement := asDateTime(propValue);
    result := propValue;
  end
  else if (isMatchingName(propName, 'procedure', ['CodeableConcept', 'Reference'])) then
  begin
    Procedure_ := propValue as TFhirDataType;
    result := propValue;
  end
  else if (propName = 'udi') then
  begin
    UdiList.add(propValue as TFhirReference);
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirClaimProcedure.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'type') then Type_List.insertItem(index, propValue as TFhirCodeableConcept)
  else if (propName = 'udi') then UdiList.insertItem(index, propValue as TFhirReference)
  else inherited;
end;

function TFhirClaimProcedure.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'sequence') then result := TFhirPositiveInt.create()
  else if (propName = 'type') then result := Type_List.new()
  else if (propName = 'date') then result := TFhirDateTime.create()
  else if (isMatchingName(propName, 'procedure', ['CodeableConcept', 'Reference'])) then raise EFHIRException.create('Cannot make property Procedure_')
  else if (propName = 'udi') then result := UdiList.new()
  else result := inherited createPropertyValue(propName);
end;

function TFhirClaimProcedure.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'sequence') then result := 'positiveInt'
  else if (propName = 'type') then result := 'CodeableConcept'
  else if (propName = 'date') then result := 'dateTime'
  else if (propName = 'procedure[x]') then result := 'CodeableConcept|Reference'
  else if (propName = 'udi') then result := 'Reference'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirClaimProcedure.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'sequence') then SequenceElement := nil
  else if (propName = 'type') then deletePropertyValue('type', Type_List, value)
  else if (propName = 'date') then DateElement := nil
  else if (isMatchingName(propName, 'procedure', ['CodeableConcept', 'Reference'])) then Procedure_Element := nil
  else if (propName = 'udi') then deletePropertyValue('udi', UdiList, value)
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirClaimProcedure.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'sequence') then SequenceElement := asPositiveInt(new)
  else if (propName = 'type') then replacePropertyValue('type', Type_List, existing, new)
  else if (propName = 'date') then DateElement := asDateTime(new)
  else if (isMatchingName(propName, 'procedure', ['CodeableConcept', 'Reference'])) then Procedure_Element := new as TFhirDataType
  else if (propName = 'udi') then replacePropertyValue('udi', UdiList, existing, new)
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirClaimProcedure.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'type') then Type_List.move(source, destination)
  else if (propName = 'udi') then UdiList.move(source, destination)
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirClaimProcedure.fhirType : string;
begin
  result := 'Claim.procedure';
end;

function TFhirClaimProcedure.Link : TFhirClaimProcedure;
begin
  result := TFhirClaimProcedure(inherited Link);
end;

function TFhirClaimProcedure.Clone : TFhirClaimProcedure;
begin
  result := TFhirClaimProcedure(inherited Clone);
end;

function TFhirClaimProcedure.equals(other : TObject) : boolean; 
var
  o : TFhirClaimProcedure;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirClaimProcedure)) then
    result := false
  else
  begin
    o := TFhirClaimProcedure(other);
    result := compareDeep(sequenceElement, o.sequenceElement, true) and compareDeep(type_List, o.type_List, true) and 
      compareDeep(dateElement, o.dateElement, true) and compareDeep(procedure_Element, o.procedure_Element, true) and 
      compareDeep(udiList, o.udiList, true);
  end;
end;

function TFhirClaimProcedure.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FSequence) and isEmptyProp(Ftype_List) and isEmptyProp(FDate) and isEmptyProp(FProcedure_) and isEmptyProp(FudiList);
end;

procedure TFhirClaimProcedure.listFieldsInOrder(fields : TStringList);
begin
  inherited listFieldsInOrder(fields);
  fields.add('sequence');
  fields.add('type');
  fields.add('date');
  fields.add('procedure[x]');
  fields.add('udi');
end;

function TFhirClaimProcedure.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FType_List.sizeInBytes(magic));
  inc(result, FUdiList.sizeInBytes(magic));
end;

procedure TFhirClaimProcedure.SetSequence(value : TFhirPositiveInt);
begin
  FSequence.free;
  FSequence := value;
end;

function TFhirClaimProcedure.GetSequenceST : String;
begin
  if FSequence = nil then
    result := ''
  else
    result := FSequence.value;
end;

procedure TFhirClaimProcedure.SetSequenceST(value : String);
begin
  if value <> '' then
  begin
    if FSequence = nil then
      FSequence := TFhirPositiveInt.create;
    FSequence.value := value
  end
  else if FSequence <> nil then
    FSequence.value := '';
end;

function TFhirClaimProcedure.GetType_List : TFhirCodeableConceptList;
begin
  if FType_List = nil then
    FType_List := TFhirCodeableConceptList.Create;
  result := FType_List;
end;

function TFhirClaimProcedure.GetHasType_List : boolean;
begin
  result := (FType_List <> nil) and (FType_List.count > 0);
end;

procedure TFhirClaimProcedure.SetDate(value : TFhirDateTime);
begin
  FDate.free;
  FDate := value;
end;

function TFhirClaimProcedure.GetDateST : TFslDateTime;
begin
  if FDate = nil then
    result := TFslDateTime.makeNull
  else
    result := FDate.value;
end;

procedure TFhirClaimProcedure.SetDateST(value : TFslDateTime);
begin
  if FDate = nil then
    FDate := TFhirDateTime.create;
  FDate.value := value
end;

procedure TFhirClaimProcedure.SetProcedure_(value : TFhirDataType);
begin
  FProcedure_.free;
  FProcedure_ := value;
end;

function TFhirClaimProcedure.GetUdiList : TFhirReferenceList;
begin
  if FUdiList = nil then
    FUdiList := TFhirReferenceList.Create;
  result := FUdiList;
end;

function TFhirClaimProcedure.GetHasUdiList : boolean;
begin
  result := (FUdiList <> nil) and (FUdiList.count > 0);
end;

{ TFhirClaimProcedureListEnumerator }

constructor TFhirClaimProcedureListEnumerator.Create(list : TFhirClaimProcedureList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirClaimProcedureListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirClaimProcedureListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirClaimProcedureListEnumerator.GetCurrent : TFhirClaimProcedure;
begin
  Result := FList[FIndex];
end;

function TFhirClaimProcedureListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirClaimProcedureList }

procedure TFhirClaimProcedureList.AddItem(value: TFhirClaimProcedure);
begin
  assert(value.ClassName = 'TFhirClaimProcedure', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirClaimProcedure');
  add(value);
end;

function TFhirClaimProcedureList.Append: TFhirClaimProcedure;
begin
  result := TFhirClaimProcedure.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirClaimProcedureList.ClearItems;
begin
  Clear;
end;

function TFhirClaimProcedureList.GetEnumerator : TFhirClaimProcedureListEnumerator;
begin
  result := TFhirClaimProcedureListEnumerator.Create(self.link);
end;

function TFhirClaimProcedureList.Clone: TFhirClaimProcedureList;
begin
  result := TFhirClaimProcedureList(inherited Clone);
end;

function TFhirClaimProcedureList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirClaimProcedureList.GetItemN(index: Integer): TFhirClaimProcedure;
begin
  result := TFhirClaimProcedure(ObjectByIndex[index]);
end;

function TFhirClaimProcedureList.ItemClass: TFslObjectClass;
begin
  result := TFhirClaimProcedure;
end;
function TFhirClaimProcedureList.IndexOf(value: TFhirClaimProcedure): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirClaimProcedureList.Insert(index: Integer): TFhirClaimProcedure;
begin
  result := TFhirClaimProcedure.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirClaimProcedureList.InsertItem(index: Integer; value: TFhirClaimProcedure);
begin
  assert(value is TFhirClaimProcedure);
  Inherited Insert(index, value);
end;

function TFhirClaimProcedureList.Item(index: Integer): TFhirClaimProcedure;
begin
  result := TFhirClaimProcedure(ObjectByIndex[index]);
end;

function TFhirClaimProcedureList.Link: TFhirClaimProcedureList;
begin
  result := TFhirClaimProcedureList(inherited Link);
end;

procedure TFhirClaimProcedureList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirClaimProcedureList.SetItemByIndex(index: Integer; value: TFhirClaimProcedure);
begin
  assert(value is TFhirClaimProcedure);
  FhirClaimProcedures[index] := value;
end;

procedure TFhirClaimProcedureList.SetItemN(index: Integer; value: TFhirClaimProcedure);
begin
  assert(value is TFhirClaimProcedure);
  ObjectByIndex[index] := value;
end;

{ TFhirClaimInsurance }

constructor TFhirClaimInsurance.Create;
begin
  inherited;
end;

destructor TFhirClaimInsurance.Destroy;
begin
  FSequence.free;
  FFocal.free;
  FIdentifier.free;
  FCoverage.free;
  FBusinessArrangement.free;
  FPreAuthRefList.Free;
  FClaimResponse.free;
  inherited;
end;

procedure TFhirClaimInsurance.Assign(oSource : TFslObject);
begin
  inherited;
  sequenceElement := TFhirClaimInsurance(oSource).sequenceElement.Clone;
  focalElement := TFhirClaimInsurance(oSource).focalElement.Clone;
  identifier := TFhirClaimInsurance(oSource).identifier.Clone;
  coverage := TFhirClaimInsurance(oSource).coverage.Clone;
  businessArrangementElement := TFhirClaimInsurance(oSource).businessArrangementElement.Clone;
  if (TFhirClaimInsurance(oSource).FPreAuthRefList = nil) then
  begin
    FPreAuthRefList.free;
    FPreAuthRefList := nil;
  end
  else
  begin
    if FPreAuthRefList = nil then
      FPreAuthRefList := TFhirStringList.Create;
    FPreAuthRefList.Assign(TFhirClaimInsurance(oSource).FPreAuthRefList);
  end;
  claimResponse := TFhirClaimInsurance(oSource).claimResponse.Clone;
end;

procedure TFhirClaimInsurance.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'sequence') Then
     list.add(self.link, 'sequence', FSequence.Link);
  if (child_name = 'focal') Then
     list.add(self.link, 'focal', FFocal.Link);
  if (child_name = 'identifier') Then
     list.add(self.link, 'identifier', FIdentifier.Link);
  if (child_name = 'coverage') Then
     list.add(self.link, 'coverage', FCoverage.Link);
  if (child_name = 'businessArrangement') Then
     list.add(self.link, 'businessArrangement', FBusinessArrangement.Link);
  if (child_name = 'preAuthRef') Then
    list.addAll(self, 'preAuthRef', FPreAuthRefList);
  if (child_name = 'claimResponse') Then
     list.add(self.link, 'claimResponse', FClaimResponse.Link);
end;

procedure TFhirClaimInsurance.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'sequence', 'positiveInt', false, TFhirPositiveInt, FSequence.Link));
  oList.add(TFHIRProperty.create(self, 'focal', 'boolean', false, TFhirBoolean, FFocal.Link));
  oList.add(TFHIRProperty.create(self, 'identifier', 'Identifier', false, TFhirIdentifier, FIdentifier.Link));
  oList.add(TFHIRProperty.create(self, 'coverage', 'Reference', false, TFhirReference, FCoverage.Link));
  oList.add(TFHIRProperty.create(self, 'businessArrangement', 'string', false, TFhirString, FBusinessArrangement.Link));
  oList.add(TFHIRProperty.create(self, 'preAuthRef', 'string', true, TFhirString, FPreAuthRefList.Link));
  oList.add(TFHIRProperty.create(self, 'claimResponse', 'Reference', false, TFhirReference, FClaimResponse.Link));
end;

function TFhirClaimInsurance.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'sequence') then
  begin
    SequenceElement := asPositiveInt(propValue);
    result := propValue;
  end
  else if (propName = 'focal') then
  begin
    FocalElement := asBoolean(propValue);
    result := propValue;
  end
  else if (propName = 'identifier') then
  begin
    Identifier := propValue as TFhirIdentifier;
    result := propValue;
  end
  else if (propName = 'coverage') then
  begin
    Coverage := propValue as TFhirReference;
    result := propValue;
  end
  else if (propName = 'businessArrangement') then
  begin
    BusinessArrangementElement := asString(propValue);
    result := propValue;
  end
  else if (propName = 'preAuthRef') then
  begin
    PreAuthRefList.add(asString(propValue)){2};     result := propValue;

  end
  else if (propName = 'claimResponse') then
  begin
    ClaimResponse := propValue as TFhirReference;
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirClaimInsurance.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'preAuthRef') then PreAuthRefList.insertItem(index, asString(propValue))
  else inherited;
end;

function TFhirClaimInsurance.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'sequence') then result := TFhirPositiveInt.create()
  else if (propName = 'focal') then result := TFhirBoolean.create()
  else if (propName = 'identifier') then result := TFhirIdentifier.create()
  else if (propName = 'coverage') then result := TFhirReference.create()
  else if (propName = 'businessArrangement') then result := TFhirString.create()
  else if (propName = 'preAuthRef') then result := PreAuthRefList.new()
  else if (propName = 'claimResponse') then result := TFhirReference.create()
  else result := inherited createPropertyValue(propName);
end;

function TFhirClaimInsurance.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'sequence') then result := 'positiveInt'
  else if (propName = 'focal') then result := 'boolean'
  else if (propName = 'identifier') then result := 'Identifier'
  else if (propName = 'coverage') then result := 'Reference'
  else if (propName = 'businessArrangement') then result := 'string'
  else if (propName = 'preAuthRef') then result := 'string'
  else if (propName = 'claimResponse') then result := 'Reference'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirClaimInsurance.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'sequence') then SequenceElement := nil
  else if (propName = 'focal') then FocalElement := nil
  else if (propName = 'identifier') then IdentifierElement := nil
  else if (propName = 'coverage') then CoverageElement := nil
  else if (propName = 'businessArrangement') then BusinessArrangementElement := nil
  else if (propName = 'preAuthRef') then deletePropertyValue('preAuthRef', PreAuthRefList, value)
  else if (propName = 'claimResponse') then ClaimResponseElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirClaimInsurance.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'sequence') then SequenceElement := asPositiveInt(new)
  else if (propName = 'focal') then FocalElement := asBoolean(new)
  else if (propName = 'identifier') then IdentifierElement := new as TFhirIdentifier
  else if (propName = 'coverage') then CoverageElement := new as TFhirReference
  else if (propName = 'businessArrangement') then BusinessArrangementElement := asString(new)
  else if (propName = 'preAuthRef') then replacePropertyValue('preAuthRef', PreAuthRefList, existing, new)
  else if (propName = 'claimResponse') then ClaimResponseElement := new as TFhirReference
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirClaimInsurance.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'preAuthRef') then PreAuthRefList.move(source, destination)
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirClaimInsurance.fhirType : string;
begin
  result := 'Claim.insurance';
end;

function TFhirClaimInsurance.Link : TFhirClaimInsurance;
begin
  result := TFhirClaimInsurance(inherited Link);
end;

function TFhirClaimInsurance.Clone : TFhirClaimInsurance;
begin
  result := TFhirClaimInsurance(inherited Clone);
end;

function TFhirClaimInsurance.equals(other : TObject) : boolean; 
var
  o : TFhirClaimInsurance;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirClaimInsurance)) then
    result := false
  else
  begin
    o := TFhirClaimInsurance(other);
    result := compareDeep(sequenceElement, o.sequenceElement, true) and compareDeep(focalElement, o.focalElement, true) and 
      compareDeep(identifierElement, o.identifierElement, true) and compareDeep(coverageElement, o.coverageElement, true) and 
      compareDeep(businessArrangementElement, o.businessArrangementElement, true) and 
      compareDeep(preAuthRefList, o.preAuthRefList, true) and compareDeep(claimResponseElement, o.claimResponseElement, true);
  end;
end;

function TFhirClaimInsurance.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FSequence) and isEmptyProp(FFocal) and isEmptyProp(FIdentifier) and isEmptyProp(FCoverage) and isEmptyProp(FBusinessArrangement) and isEmptyProp(FpreAuthRefList) and isEmptyProp(FClaimResponse);
end;

procedure TFhirClaimInsurance.listFieldsInOrder(fields : TStringList);
begin
  inherited listFieldsInOrder(fields);
  fields.add('sequence');
  fields.add('focal');
  fields.add('identifier');
  fields.add('coverage');
  fields.add('businessArrangement');
  fields.add('preAuthRef');
  fields.add('claimResponse');
end;

function TFhirClaimInsurance.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FPreAuthRefList.sizeInBytes(magic));
end;

procedure TFhirClaimInsurance.SetSequence(value : TFhirPositiveInt);
begin
  FSequence.free;
  FSequence := value;
end;

function TFhirClaimInsurance.GetSequenceST : String;
begin
  if FSequence = nil then
    result := ''
  else
    result := FSequence.value;
end;

procedure TFhirClaimInsurance.SetSequenceST(value : String);
begin
  if value <> '' then
  begin
    if FSequence = nil then
      FSequence := TFhirPositiveInt.create;
    FSequence.value := value
  end
  else if FSequence <> nil then
    FSequence.value := '';
end;

procedure TFhirClaimInsurance.SetFocal(value : TFhirBoolean);
begin
  FFocal.free;
  FFocal := value;
end;

function TFhirClaimInsurance.GetFocalST : Boolean;
begin
  if FFocal = nil then
    result := false
  else
    result := FFocal.value;
end;

procedure TFhirClaimInsurance.SetFocalST(value : Boolean);
begin
  if FFocal = nil then
    FFocal := TFhirBoolean.create;
  FFocal.value := value
end;

procedure TFhirClaimInsurance.SetIdentifier(value : TFhirIdentifier);
begin
  FIdentifier.free;
  FIdentifier := value;
end;

procedure TFhirClaimInsurance.SetCoverage(value : TFhirReference);
begin
  FCoverage.free;
  FCoverage := value;
end;

procedure TFhirClaimInsurance.SetBusinessArrangement(value : TFhirString);
begin
  FBusinessArrangement.free;
  FBusinessArrangement := value;
end;

function TFhirClaimInsurance.GetBusinessArrangementST : String;
begin
  if FBusinessArrangement = nil then
    result := ''
  else
    result := FBusinessArrangement.value;
end;

procedure TFhirClaimInsurance.SetBusinessArrangementST(value : String);
begin
  if value <> '' then
  begin
    if FBusinessArrangement = nil then
      FBusinessArrangement := TFhirString.create;
    FBusinessArrangement.value := value
  end
  else if FBusinessArrangement <> nil then
    FBusinessArrangement.value := '';
end;

function TFhirClaimInsurance.GetPreAuthRefList : TFhirStringList;
begin
  if FPreAuthRefList = nil then
    FPreAuthRefList := TFhirStringList.Create;
  result := FPreAuthRefList;
end;

function TFhirClaimInsurance.GetHasPreAuthRefList : boolean;
begin
  result := (FPreAuthRefList <> nil) and (FPreAuthRefList.count > 0);
end;

procedure TFhirClaimInsurance.SetClaimResponse(value : TFhirReference);
begin
  FClaimResponse.free;
  FClaimResponse := value;
end;

{ TFhirClaimInsuranceListEnumerator }

constructor TFhirClaimInsuranceListEnumerator.Create(list : TFhirClaimInsuranceList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirClaimInsuranceListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirClaimInsuranceListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirClaimInsuranceListEnumerator.GetCurrent : TFhirClaimInsurance;
begin
  Result := FList[FIndex];
end;

function TFhirClaimInsuranceListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirClaimInsuranceList }

procedure TFhirClaimInsuranceList.AddItem(value: TFhirClaimInsurance);
begin
  assert(value.ClassName = 'TFhirClaimInsurance', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirClaimInsurance');
  add(value);
end;

function TFhirClaimInsuranceList.Append: TFhirClaimInsurance;
begin
  result := TFhirClaimInsurance.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirClaimInsuranceList.ClearItems;
begin
  Clear;
end;

function TFhirClaimInsuranceList.GetEnumerator : TFhirClaimInsuranceListEnumerator;
begin
  result := TFhirClaimInsuranceListEnumerator.Create(self.link);
end;

function TFhirClaimInsuranceList.Clone: TFhirClaimInsuranceList;
begin
  result := TFhirClaimInsuranceList(inherited Clone);
end;

function TFhirClaimInsuranceList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirClaimInsuranceList.GetItemN(index: Integer): TFhirClaimInsurance;
begin
  result := TFhirClaimInsurance(ObjectByIndex[index]);
end;

function TFhirClaimInsuranceList.ItemClass: TFslObjectClass;
begin
  result := TFhirClaimInsurance;
end;
function TFhirClaimInsuranceList.IndexOf(value: TFhirClaimInsurance): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirClaimInsuranceList.Insert(index: Integer): TFhirClaimInsurance;
begin
  result := TFhirClaimInsurance.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirClaimInsuranceList.InsertItem(index: Integer; value: TFhirClaimInsurance);
begin
  assert(value is TFhirClaimInsurance);
  Inherited Insert(index, value);
end;

function TFhirClaimInsuranceList.Item(index: Integer): TFhirClaimInsurance;
begin
  result := TFhirClaimInsurance(ObjectByIndex[index]);
end;

function TFhirClaimInsuranceList.Link: TFhirClaimInsuranceList;
begin
  result := TFhirClaimInsuranceList(inherited Link);
end;

procedure TFhirClaimInsuranceList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirClaimInsuranceList.SetItemByIndex(index: Integer; value: TFhirClaimInsurance);
begin
  assert(value is TFhirClaimInsurance);
  FhirClaimInsurances[index] := value;
end;

procedure TFhirClaimInsuranceList.SetItemN(index: Integer; value: TFhirClaimInsurance);
begin
  assert(value is TFhirClaimInsurance);
  ObjectByIndex[index] := value;
end;

{ TFhirClaimAccident }

constructor TFhirClaimAccident.Create;
begin
  inherited;
end;

destructor TFhirClaimAccident.Destroy;
begin
  FDate.free;
  FType_.free;
  FLocation.free;
  inherited;
end;

procedure TFhirClaimAccident.Assign(oSource : TFslObject);
begin
  inherited;
  dateElement := TFhirClaimAccident(oSource).dateElement.Clone;
  type_ := TFhirClaimAccident(oSource).type_.Clone;
  location := TFhirClaimAccident(oSource).location.Clone;
end;

procedure TFhirClaimAccident.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'date') Then
     list.add(self.link, 'date', FDate.Link);
  if (child_name = 'type') Then
     list.add(self.link, 'type', FType_.Link);
  if (child_name = 'location[x]') or (child_name = 'location') Then
     list.add(self.link, 'location[x]', FLocation.Link);
end;

procedure TFhirClaimAccident.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'date', 'date', false, TFhirDate, FDate.Link));
  oList.add(TFHIRProperty.create(self, 'type', 'CodeableConcept', false, TFhirCodeableConcept, FType_.Link));
  oList.add(TFHIRProperty.create(self, 'location[x]', 'Address|Reference', false, TFhirDataType, FLocation.Link));
end;

function TFhirClaimAccident.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'date') then
  begin
    DateElement := asDate(propValue);
    result := propValue;
  end
  else if (propName = 'type') then
  begin
    Type_ := propValue as TFhirCodeableConcept;
    result := propValue;
  end
  else if (isMatchingName(propName, 'location', ['Address', 'Reference'])) then
  begin
    Location := propValue as TFhirDataType;
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirClaimAccident.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirClaimAccident.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'date') then result := TFhirDate.create()
  else if (propName = 'type') then result := TFhirCodeableConcept.create()
  else if (isMatchingName(propName, 'location', ['Address', 'Reference'])) then raise EFHIRException.create('Cannot make property Location')
  else result := inherited createPropertyValue(propName);
end;

function TFhirClaimAccident.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'date') then result := 'date'
  else if (propName = 'type') then result := 'CodeableConcept'
  else if (propName = 'location[x]') then result := 'Address|Reference'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirClaimAccident.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'date') then DateElement := nil
  else if (propName = 'type') then Type_Element := nil
  else if (isMatchingName(propName, 'location', ['Address', 'Reference'])) then LocationElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirClaimAccident.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'date') then DateElement := asDate(new)
  else if (propName = 'type') then Type_Element := new as TFhirCodeableConcept
  else if (isMatchingName(propName, 'location', ['Address', 'Reference'])) then LocationElement := new as TFhirDataType
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirClaimAccident.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirClaimAccident.fhirType : string;
begin
  result := 'Claim.accident';
end;

function TFhirClaimAccident.Link : TFhirClaimAccident;
begin
  result := TFhirClaimAccident(inherited Link);
end;

function TFhirClaimAccident.Clone : TFhirClaimAccident;
begin
  result := TFhirClaimAccident(inherited Clone);
end;

function TFhirClaimAccident.equals(other : TObject) : boolean; 
var
  o : TFhirClaimAccident;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirClaimAccident)) then
    result := false
  else
  begin
    o := TFhirClaimAccident(other);
    result := compareDeep(dateElement, o.dateElement, true) and compareDeep(type_Element, o.type_Element, true) and 
      compareDeep(locationElement, o.locationElement, true);
  end;
end;

function TFhirClaimAccident.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FDate) and isEmptyProp(FType_) and isEmptyProp(FLocation);
end;

procedure TFhirClaimAccident.listFieldsInOrder(fields : TStringList);
begin
  inherited listFieldsInOrder(fields);
  fields.add('date');
  fields.add('type');
  fields.add('location[x]');
end;

function TFhirClaimAccident.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
end;

procedure TFhirClaimAccident.SetDate(value : TFhirDate);
begin
  FDate.free;
  FDate := value;
end;

function TFhirClaimAccident.GetDateST : TFslDateTime;
begin
  if FDate = nil then
    result := TFslDateTime.makeNull
  else
    result := FDate.value;
end;

procedure TFhirClaimAccident.SetDateST(value : TFslDateTime);
begin
  if FDate = nil then
    FDate := TFhirDate.create;
  FDate.value := value
end;

procedure TFhirClaimAccident.SetType_(value : TFhirCodeableConcept);
begin
  FType_.free;
  FType_ := value;
end;

procedure TFhirClaimAccident.SetLocation(value : TFhirDataType);
begin
  FLocation.free;
  FLocation := value;
end;

{ TFhirClaimAccidentListEnumerator }

constructor TFhirClaimAccidentListEnumerator.Create(list : TFhirClaimAccidentList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirClaimAccidentListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirClaimAccidentListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirClaimAccidentListEnumerator.GetCurrent : TFhirClaimAccident;
begin
  Result := FList[FIndex];
end;

function TFhirClaimAccidentListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirClaimAccidentList }

procedure TFhirClaimAccidentList.AddItem(value: TFhirClaimAccident);
begin
  assert(value.ClassName = 'TFhirClaimAccident', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirClaimAccident');
  add(value);
end;

function TFhirClaimAccidentList.Append: TFhirClaimAccident;
begin
  result := TFhirClaimAccident.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirClaimAccidentList.ClearItems;
begin
  Clear;
end;

function TFhirClaimAccidentList.GetEnumerator : TFhirClaimAccidentListEnumerator;
begin
  result := TFhirClaimAccidentListEnumerator.Create(self.link);
end;

function TFhirClaimAccidentList.Clone: TFhirClaimAccidentList;
begin
  result := TFhirClaimAccidentList(inherited Clone);
end;

function TFhirClaimAccidentList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirClaimAccidentList.GetItemN(index: Integer): TFhirClaimAccident;
begin
  result := TFhirClaimAccident(ObjectByIndex[index]);
end;

function TFhirClaimAccidentList.ItemClass: TFslObjectClass;
begin
  result := TFhirClaimAccident;
end;
function TFhirClaimAccidentList.IndexOf(value: TFhirClaimAccident): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirClaimAccidentList.Insert(index: Integer): TFhirClaimAccident;
begin
  result := TFhirClaimAccident.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirClaimAccidentList.InsertItem(index: Integer; value: TFhirClaimAccident);
begin
  assert(value is TFhirClaimAccident);
  Inherited Insert(index, value);
end;

function TFhirClaimAccidentList.Item(index: Integer): TFhirClaimAccident;
begin
  result := TFhirClaimAccident(ObjectByIndex[index]);
end;

function TFhirClaimAccidentList.Link: TFhirClaimAccidentList;
begin
  result := TFhirClaimAccidentList(inherited Link);
end;

procedure TFhirClaimAccidentList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirClaimAccidentList.SetItemByIndex(index: Integer; value: TFhirClaimAccident);
begin
  assert(value is TFhirClaimAccident);
  FhirClaimAccidents[index] := value;
end;

procedure TFhirClaimAccidentList.SetItemN(index: Integer; value: TFhirClaimAccident);
begin
  assert(value is TFhirClaimAccident);
  ObjectByIndex[index] := value;
end;

{ TFhirClaimItem }

constructor TFhirClaimItem.Create;
begin
  inherited;
end;

destructor TFhirClaimItem.Destroy;
begin
  FSequence.free;
  FCareTeamSequenceList.Free;
  FDiagnosisSequenceList.Free;
  FProcedureSequenceList.Free;
  FInformationSequenceList.Free;
  FRevenue.free;
  FCategory.free;
  FProductOrService.free;
  FModifierList.Free;
  FProgramCodeList.Free;
  FServiced.free;
  FLocation.free;
  FQuantity.free;
  FUnitPrice.free;
  FFactor.free;
  FNet.free;
  FUdiList.Free;
  FBodySite.free;
  FSubSiteList.Free;
  FEncounterList.Free;
  FDetailList.Free;
  inherited;
end;

procedure TFhirClaimItem.Assign(oSource : TFslObject);
begin
  inherited;
  sequenceElement := TFhirClaimItem(oSource).sequenceElement.Clone;
  if (TFhirClaimItem(oSource).FCareTeamSequenceList = nil) then
  begin
    FCareTeamSequenceList.free;
    FCareTeamSequenceList := nil;
  end
  else
  begin
    if FCareTeamSequenceList = nil then
      FCareTeamSequenceList := TFhirPositiveIntList.Create;
    FCareTeamSequenceList.Assign(TFhirClaimItem(oSource).FCareTeamSequenceList);
  end;
  if (TFhirClaimItem(oSource).FDiagnosisSequenceList = nil) then
  begin
    FDiagnosisSequenceList.free;
    FDiagnosisSequenceList := nil;
  end
  else
  begin
    if FDiagnosisSequenceList = nil then
      FDiagnosisSequenceList := TFhirPositiveIntList.Create;
    FDiagnosisSequenceList.Assign(TFhirClaimItem(oSource).FDiagnosisSequenceList);
  end;
  if (TFhirClaimItem(oSource).FProcedureSequenceList = nil) then
  begin
    FProcedureSequenceList.free;
    FProcedureSequenceList := nil;
  end
  else
  begin
    if FProcedureSequenceList = nil then
      FProcedureSequenceList := TFhirPositiveIntList.Create;
    FProcedureSequenceList.Assign(TFhirClaimItem(oSource).FProcedureSequenceList);
  end;
  if (TFhirClaimItem(oSource).FInformationSequenceList = nil) then
  begin
    FInformationSequenceList.free;
    FInformationSequenceList := nil;
  end
  else
  begin
    if FInformationSequenceList = nil then
      FInformationSequenceList := TFhirPositiveIntList.Create;
    FInformationSequenceList.Assign(TFhirClaimItem(oSource).FInformationSequenceList);
  end;
  revenue := TFhirClaimItem(oSource).revenue.Clone;
  category := TFhirClaimItem(oSource).category.Clone;
  productOrService := TFhirClaimItem(oSource).productOrService.Clone;
  if (TFhirClaimItem(oSource).FModifierList = nil) then
  begin
    FModifierList.free;
    FModifierList := nil;
  end
  else
  begin
    if FModifierList = nil then
      FModifierList := TFhirCodeableConceptList.Create;
    FModifierList.Assign(TFhirClaimItem(oSource).FModifierList);
  end;
  if (TFhirClaimItem(oSource).FProgramCodeList = nil) then
  begin
    FProgramCodeList.free;
    FProgramCodeList := nil;
  end
  else
  begin
    if FProgramCodeList = nil then
      FProgramCodeList := TFhirCodeableConceptList.Create;
    FProgramCodeList.Assign(TFhirClaimItem(oSource).FProgramCodeList);
  end;
  serviced := TFhirClaimItem(oSource).serviced.Clone;
  location := TFhirClaimItem(oSource).location.Clone;
  quantity := TFhirClaimItem(oSource).quantity.Clone;
  unitPrice := TFhirClaimItem(oSource).unitPrice.Clone;
  factorElement := TFhirClaimItem(oSource).factorElement.Clone;
  net := TFhirClaimItem(oSource).net.Clone;
  if (TFhirClaimItem(oSource).FUdiList = nil) then
  begin
    FUdiList.free;
    FUdiList := nil;
  end
  else
  begin
    if FUdiList = nil then
      FUdiList := TFhirReferenceList.Create;
    FUdiList.Assign(TFhirClaimItem(oSource).FUdiList);
  end;
  bodySite := TFhirClaimItem(oSource).bodySite.Clone;
  if (TFhirClaimItem(oSource).FSubSiteList = nil) then
  begin
    FSubSiteList.free;
    FSubSiteList := nil;
  end
  else
  begin
    if FSubSiteList = nil then
      FSubSiteList := TFhirCodeableConceptList.Create;
    FSubSiteList.Assign(TFhirClaimItem(oSource).FSubSiteList);
  end;
  if (TFhirClaimItem(oSource).FEncounterList = nil) then
  begin
    FEncounterList.free;
    FEncounterList := nil;
  end
  else
  begin
    if FEncounterList = nil then
      FEncounterList := TFhirReferenceList.Create;
    FEncounterList.Assign(TFhirClaimItem(oSource).FEncounterList);
  end;
  if (TFhirClaimItem(oSource).FDetailList = nil) then
  begin
    FDetailList.free;
    FDetailList := nil;
  end
  else
  begin
    if FDetailList = nil then
      FDetailList := TFhirClaimItemDetailList.Create;
    FDetailList.Assign(TFhirClaimItem(oSource).FDetailList);
  end;
end;

procedure TFhirClaimItem.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'sequence') Then
     list.add(self.link, 'sequence', FSequence.Link);
  if (child_name = 'careTeamSequence') Then
    list.addAll(self, 'careTeamSequence', FCareTeamSequenceList);
  if (child_name = 'diagnosisSequence') Then
    list.addAll(self, 'diagnosisSequence', FDiagnosisSequenceList);
  if (child_name = 'procedureSequence') Then
    list.addAll(self, 'procedureSequence', FProcedureSequenceList);
  if (child_name = 'informationSequence') Then
    list.addAll(self, 'informationSequence', FInformationSequenceList);
  if (child_name = 'revenue') Then
     list.add(self.link, 'revenue', FRevenue.Link);
  if (child_name = 'category') Then
     list.add(self.link, 'category', FCategory.Link);
  if (child_name = 'productOrService') Then
     list.add(self.link, 'productOrService', FProductOrService.Link);
  if (child_name = 'modifier') Then
    list.addAll(self, 'modifier', FModifierList);
  if (child_name = 'programCode') Then
    list.addAll(self, 'programCode', FProgramCodeList);
  if (child_name = 'serviced[x]') or (child_name = 'serviced') Then
     list.add(self.link, 'serviced[x]', FServiced.Link);
  if (child_name = 'location[x]') or (child_name = 'location') Then
     list.add(self.link, 'location[x]', FLocation.Link);
  if (child_name = 'quantity') Then
     list.add(self.link, 'quantity', FQuantity.Link);
  if (child_name = 'unitPrice') Then
     list.add(self.link, 'unitPrice', FUnitPrice.Link);
  if (child_name = 'factor') Then
     list.add(self.link, 'factor', FFactor.Link);
  if (child_name = 'net') Then
     list.add(self.link, 'net', FNet.Link);
  if (child_name = 'udi') Then
    list.addAll(self, 'udi', FUdiList);
  if (child_name = 'bodySite') Then
     list.add(self.link, 'bodySite', FBodySite.Link);
  if (child_name = 'subSite') Then
    list.addAll(self, 'subSite', FSubSiteList);
  if (child_name = 'encounter') Then
    list.addAll(self, 'encounter', FEncounterList);
  if (child_name = 'detail') Then
    list.addAll(self, 'detail', FDetailList);
end;

procedure TFhirClaimItem.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'sequence', 'positiveInt', false, TFhirPositiveInt, FSequence.Link));
  oList.add(TFHIRProperty.create(self, 'careTeamSequence', 'positiveInt', true, TFhirPositiveInt, FCareTeamSequenceList.Link));
  oList.add(TFHIRProperty.create(self, 'diagnosisSequence', 'positiveInt', true, TFhirPositiveInt, FDiagnosisSequenceList.Link));
  oList.add(TFHIRProperty.create(self, 'procedureSequence', 'positiveInt', true, TFhirPositiveInt, FProcedureSequenceList.Link));
  oList.add(TFHIRProperty.create(self, 'informationSequence', 'positiveInt', true, TFhirPositiveInt, FInformationSequenceList.Link));
  oList.add(TFHIRProperty.create(self, 'revenue', 'CodeableConcept', false, TFhirCodeableConcept, FRevenue.Link));
  oList.add(TFHIRProperty.create(self, 'category', 'CodeableConcept', false, TFhirCodeableConcept, FCategory.Link));
  oList.add(TFHIRProperty.create(self, 'productOrService', 'CodeableConcept', false, TFhirCodeableConcept, FProductOrService.Link));
  oList.add(TFHIRProperty.create(self, 'modifier', 'CodeableConcept', true, TFhirCodeableConcept, FModifierList.Link));
  oList.add(TFHIRProperty.create(self, 'programCode', 'CodeableConcept', true, TFhirCodeableConcept, FProgramCodeList.Link));
  oList.add(TFHIRProperty.create(self, 'serviced[x]', 'date|Period', false, TFhirDataType, FServiced.Link));
  oList.add(TFHIRProperty.create(self, 'location[x]', 'CodeableConcept|Address|Reference', false, TFhirDataType, FLocation.Link));
  oList.add(TFHIRProperty.create(self, 'quantity', 'Quantity', false, TFhirQuantity, FQuantity.Link));
  oList.add(TFHIRProperty.create(self, 'unitPrice', 'Money', false, TFhirMoney, FUnitPrice.Link));
  oList.add(TFHIRProperty.create(self, 'factor', 'decimal', false, TFhirDecimal, FFactor.Link));
  oList.add(TFHIRProperty.create(self, 'net', 'Money', false, TFhirMoney, FNet.Link));
  oList.add(TFHIRProperty.create(self, 'udi', 'Reference', true, TFhirReference, FUdiList.Link));
  oList.add(TFHIRProperty.create(self, 'bodySite', 'CodeableConcept', false, TFhirCodeableConcept, FBodySite.Link));
  oList.add(TFHIRProperty.create(self, 'subSite', 'CodeableConcept', true, TFhirCodeableConcept, FSubSiteList.Link));
  oList.add(TFHIRProperty.create(self, 'encounter', 'Reference', true, TFhirReference, FEncounterList.Link));
  oList.add(TFHIRProperty.create(self, 'detail', 'BackboneElement', true, TFhirClaimItemDetail, FDetailList.Link));
end;

function TFhirClaimItem.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'sequence') then
  begin
    SequenceElement := asPositiveInt(propValue);
    result := propValue;
  end
  else if (propName = 'careTeamSequence') then
  begin
    CareTeamSequenceList.add(asPositiveInt(propValue)){2};     result := propValue;

  end
  else if (propName = 'diagnosisSequence') then
  begin
    DiagnosisSequenceList.add(asPositiveInt(propValue)){2};     result := propValue;

  end
  else if (propName = 'procedureSequence') then
  begin
    ProcedureSequenceList.add(asPositiveInt(propValue)){2};     result := propValue;

  end
  else if (propName = 'informationSequence') then
  begin
    InformationSequenceList.add(asPositiveInt(propValue)){2};     result := propValue;

  end
  else if (propName = 'revenue') then
  begin
    Revenue := propValue as TFhirCodeableConcept;
    result := propValue;
  end
  else if (propName = 'category') then
  begin
    Category := propValue as TFhirCodeableConcept;
    result := propValue;
  end
  else if (propName = 'productOrService') then
  begin
    ProductOrService := propValue as TFhirCodeableConcept;
    result := propValue;
  end
  else if (propName = 'modifier') then
  begin
    ModifierList.add(propValue as TFhirCodeableConcept);
    result := propValue;
  end
  else if (propName = 'programCode') then
  begin
    ProgramCodeList.add(propValue as TFhirCodeableConcept);
    result := propValue;
  end
  else if (isMatchingName(propName, 'serviced', ['Date', 'Period'])) then
  begin
    Serviced := propValue as TFhirDataType;
    result := propValue;
  end
  else if (isMatchingName(propName, 'location', ['CodeableConcept', 'Address', 'Reference'])) then
  begin
    Location := propValue as TFhirDataType;
    result := propValue;
  end
  else if (propName = 'quantity') then
  begin
    Quantity := propValue as TFhirQuantity;
    result := propValue;
  end
  else if (propName = 'unitPrice') then
  begin
    UnitPrice := propValue as TFhirMoney;
    result := propValue;
  end
  else if (propName = 'factor') then
  begin
    FactorElement := asDecimal(propValue);
    result := propValue;
  end
  else if (propName = 'net') then
  begin
    Net := propValue as TFhirMoney;
    result := propValue;
  end
  else if (propName = 'udi') then
  begin
    UdiList.add(propValue as TFhirReference);
    result := propValue;
  end
  else if (propName = 'bodySite') then
  begin
    BodySite := propValue as TFhirCodeableConcept;
    result := propValue;
  end
  else if (propName = 'subSite') then
  begin
    SubSiteList.add(propValue as TFhirCodeableConcept);
    result := propValue;
  end
  else if (propName = 'encounter') then
  begin
    EncounterList.add(propValue as TFhirReference);
    result := propValue;
  end
  else if (propName = 'detail') then
  begin
    DetailList.add(propValue as TFhirClaimItemDetail);
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirClaimItem.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'careTeamSequence') then CareTeamSequenceList.insertItem(index, asPositiveInt(propValue))
  else if (propName = 'diagnosisSequence') then DiagnosisSequenceList.insertItem(index, asPositiveInt(propValue))
  else if (propName = 'procedureSequence') then ProcedureSequenceList.insertItem(index, asPositiveInt(propValue))
  else if (propName = 'informationSequence') then InformationSequenceList.insertItem(index, asPositiveInt(propValue))
  else if (propName = 'modifier') then ModifierList.insertItem(index, propValue as TFhirCodeableConcept)
  else if (propName = 'programCode') then ProgramCodeList.insertItem(index, propValue as TFhirCodeableConcept)
  else if (propName = 'udi') then UdiList.insertItem(index, propValue as TFhirReference)
  else if (propName = 'subSite') then SubSiteList.insertItem(index, propValue as TFhirCodeableConcept)
  else if (propName = 'encounter') then EncounterList.insertItem(index, propValue as TFhirReference)
  else if (propName = 'detail') then DetailList.insertItem(index, propValue as TFhirClaimItemDetail)
  else inherited;
end;

function TFhirClaimItem.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'sequence') then result := TFhirPositiveInt.create()
  else if (propName = 'careTeamSequence') then result := CareTeamSequenceList.new()
  else if (propName = 'diagnosisSequence') then result := DiagnosisSequenceList.new()
  else if (propName = 'procedureSequence') then result := ProcedureSequenceList.new()
  else if (propName = 'informationSequence') then result := InformationSequenceList.new()
  else if (propName = 'revenue') then result := TFhirCodeableConcept.create()
  else if (propName = 'category') then result := TFhirCodeableConcept.create()
  else if (propName = 'productOrService') then result := TFhirCodeableConcept.create()
  else if (propName = 'modifier') then result := ModifierList.new()
  else if (propName = 'programCode') then result := ProgramCodeList.new()
  else if (isMatchingName(propName, 'serviced', ['Date', 'Period'])) then raise EFHIRException.create('Cannot make property Serviced')
  else if (isMatchingName(propName, 'location', ['CodeableConcept', 'Address', 'Reference'])) then raise EFHIRException.create('Cannot make property Location')
  else if (propName = 'quantity') then result := TFhirQuantity.create()
  else if (propName = 'unitPrice') then result := TFhirMoney.create()
  else if (propName = 'factor') then result := TFhirDecimal.create()
  else if (propName = 'net') then result := TFhirMoney.create()
  else if (propName = 'udi') then result := UdiList.new()
  else if (propName = 'bodySite') then result := TFhirCodeableConcept.create()
  else if (propName = 'subSite') then result := SubSiteList.new()
  else if (propName = 'encounter') then result := EncounterList.new()
  else if (propName = 'detail') then result := DetailList.new()
  else result := inherited createPropertyValue(propName);
end;

function TFhirClaimItem.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'sequence') then result := 'positiveInt'
  else if (propName = 'careTeamSequence') then result := 'positiveInt'
  else if (propName = 'diagnosisSequence') then result := 'positiveInt'
  else if (propName = 'procedureSequence') then result := 'positiveInt'
  else if (propName = 'informationSequence') then result := 'positiveInt'
  else if (propName = 'revenue') then result := 'CodeableConcept'
  else if (propName = 'category') then result := 'CodeableConcept'
  else if (propName = 'productOrService') then result := 'CodeableConcept'
  else if (propName = 'modifier') then result := 'CodeableConcept'
  else if (propName = 'programCode') then result := 'CodeableConcept'
  else if (propName = 'serviced[x]') then result := 'date|Period'
  else if (propName = 'location[x]') then result := 'CodeableConcept|Address|Reference'
  else if (propName = 'quantity') then result := 'Quantity'
  else if (propName = 'unitPrice') then result := 'Money'
  else if (propName = 'factor') then result := 'decimal'
  else if (propName = 'net') then result := 'Money'
  else if (propName = 'udi') then result := 'Reference'
  else if (propName = 'bodySite') then result := 'CodeableConcept'
  else if (propName = 'subSite') then result := 'CodeableConcept'
  else if (propName = 'encounter') then result := 'Reference'
  else if (propName = 'detail') then result := 'BackboneElement'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirClaimItem.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'sequence') then SequenceElement := nil
  else if (propName = 'careTeamSequence') then deletePropertyValue('careTeamSequence', CareTeamSequenceList, value)
  else if (propName = 'diagnosisSequence') then deletePropertyValue('diagnosisSequence', DiagnosisSequenceList, value)
  else if (propName = 'procedureSequence') then deletePropertyValue('procedureSequence', ProcedureSequenceList, value)
  else if (propName = 'informationSequence') then deletePropertyValue('informationSequence', InformationSequenceList, value)
  else if (propName = 'revenue') then RevenueElement := nil
  else if (propName = 'category') then CategoryElement := nil
  else if (propName = 'productOrService') then ProductOrServiceElement := nil
  else if (propName = 'modifier') then deletePropertyValue('modifier', ModifierList, value)
  else if (propName = 'programCode') then deletePropertyValue('programCode', ProgramCodeList, value)
  else if (isMatchingName(propName, 'serviced', ['Date', 'Period'])) then ServicedElement := nil
  else if (isMatchingName(propName, 'location', ['CodeableConcept', 'Address', 'Reference'])) then LocationElement := nil
  else if (propName = 'quantity') then QuantityElement := nil
  else if (propName = 'unitPrice') then UnitPriceElement := nil
  else if (propName = 'factor') then FactorElement := nil
  else if (propName = 'net') then NetElement := nil
  else if (propName = 'udi') then deletePropertyValue('udi', UdiList, value)
  else if (propName = 'bodySite') then BodySiteElement := nil
  else if (propName = 'subSite') then deletePropertyValue('subSite', SubSiteList, value)
  else if (propName = 'encounter') then deletePropertyValue('encounter', EncounterList, value)
  else if (propName = 'detail') then deletePropertyValue('detail', DetailList, value)
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirClaimItem.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'sequence') then SequenceElement := asPositiveInt(new)
  else if (propName = 'careTeamSequence') then replacePropertyValue('careTeamSequence', CareTeamSequenceList, existing, new)
  else if (propName = 'diagnosisSequence') then replacePropertyValue('diagnosisSequence', DiagnosisSequenceList, existing, new)
  else if (propName = 'procedureSequence') then replacePropertyValue('procedureSequence', ProcedureSequenceList, existing, new)
  else if (propName = 'informationSequence') then replacePropertyValue('informationSequence', InformationSequenceList, existing, new)
  else if (propName = 'revenue') then RevenueElement := new as TFhirCodeableConcept
  else if (propName = 'category') then CategoryElement := new as TFhirCodeableConcept
  else if (propName = 'productOrService') then ProductOrServiceElement := new as TFhirCodeableConcept
  else if (propName = 'modifier') then replacePropertyValue('modifier', ModifierList, existing, new)
  else if (propName = 'programCode') then replacePropertyValue('programCode', ProgramCodeList, existing, new)
  else if (isMatchingName(propName, 'serviced', ['Date', 'Period'])) then ServicedElement := new as TFhirDataType
  else if (isMatchingName(propName, 'location', ['CodeableConcept', 'Address', 'Reference'])) then LocationElement := new as TFhirDataType
  else if (propName = 'quantity') then QuantityElement := new as TFhirQuantity
  else if (propName = 'unitPrice') then UnitPriceElement := new as TFhirMoney
  else if (propName = 'factor') then FactorElement := asDecimal(new)
  else if (propName = 'net') then NetElement := new as TFhirMoney
  else if (propName = 'udi') then replacePropertyValue('udi', UdiList, existing, new)
  else if (propName = 'bodySite') then BodySiteElement := new as TFhirCodeableConcept
  else if (propName = 'subSite') then replacePropertyValue('subSite', SubSiteList, existing, new)
  else if (propName = 'encounter') then replacePropertyValue('encounter', EncounterList, existing, new)
  else if (propName = 'detail') then replacePropertyValue('detail', DetailList, existing, new)
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirClaimItem.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'careTeamSequence') then CareTeamSequenceList.move(source, destination)
  else if (propName = 'diagnosisSequence') then DiagnosisSequenceList.move(source, destination)
  else if (propName = 'procedureSequence') then ProcedureSequenceList.move(source, destination)
  else if (propName = 'informationSequence') then InformationSequenceList.move(source, destination)
  else if (propName = 'modifier') then ModifierList.move(source, destination)
  else if (propName = 'programCode') then ProgramCodeList.move(source, destination)
  else if (propName = 'udi') then UdiList.move(source, destination)
  else if (propName = 'subSite') then SubSiteList.move(source, destination)
  else if (propName = 'encounter') then EncounterList.move(source, destination)
  else if (propName = 'detail') then DetailList.move(source, destination)
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirClaimItem.fhirType : string;
begin
  result := 'Claim.item';
end;

function TFhirClaimItem.Link : TFhirClaimItem;
begin
  result := TFhirClaimItem(inherited Link);
end;

function TFhirClaimItem.Clone : TFhirClaimItem;
begin
  result := TFhirClaimItem(inherited Clone);
end;

function TFhirClaimItem.equals(other : TObject) : boolean; 
var
  o : TFhirClaimItem;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirClaimItem)) then
    result := false
  else
  begin
    o := TFhirClaimItem(other);
    result := compareDeep(sequenceElement, o.sequenceElement, true) and compareDeep(careTeamSequenceList, o.careTeamSequenceList, true) and 
      compareDeep(diagnosisSequenceList, o.diagnosisSequenceList, true) and compareDeep(procedureSequenceList, o.procedureSequenceList, true) and 
      compareDeep(informationSequenceList, o.informationSequenceList, true) and compareDeep(revenueElement, o.revenueElement, true) and 
      compareDeep(categoryElement, o.categoryElement, true) and compareDeep(productOrServiceElement, o.productOrServiceElement, true) and 
      compareDeep(modifierList, o.modifierList, true) and compareDeep(programCodeList, o.programCodeList, true) and 
      compareDeep(servicedElement, o.servicedElement, true) and compareDeep(locationElement, o.locationElement, true) and 
      compareDeep(quantityElement, o.quantityElement, true) and compareDeep(unitPriceElement, o.unitPriceElement, true) and 
      compareDeep(factorElement, o.factorElement, true) and compareDeep(netElement, o.netElement, true) and 
      compareDeep(udiList, o.udiList, true) and compareDeep(bodySiteElement, o.bodySiteElement, true) and 
      compareDeep(subSiteList, o.subSiteList, true) and compareDeep(encounterList, o.encounterList, true) and 
      compareDeep(detailList, o.detailList, true);
  end;
end;

function TFhirClaimItem.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FSequence) and isEmptyProp(FcareTeamSequenceList) and isEmptyProp(FdiagnosisSequenceList) and isEmptyProp(FprocedureSequenceList) and isEmptyProp(FinformationSequenceList) and isEmptyProp(FRevenue) and isEmptyProp(FCategory) and isEmptyProp(FProductOrService) and isEmptyProp(FmodifierList) and isEmptyProp(FprogramCodeList) and isEmptyProp(FServiced) and isEmptyProp(FLocation) and isEmptyProp(FQuantity) and isEmptyProp(FUnitPrice) and isEmptyProp(FFactor) and isEmptyProp(FNet) and isEmptyProp(FudiList) and isEmptyProp(FBodySite) and isEmptyProp(FsubSiteList) and isEmptyProp(FencounterList) and isEmptyProp(FdetailList);
end;

procedure TFhirClaimItem.listFieldsInOrder(fields : TStringList);
begin
  inherited listFieldsInOrder(fields);
  fields.add('sequence');
  fields.add('careTeamSequence');
  fields.add('diagnosisSequence');
  fields.add('procedureSequence');
  fields.add('informationSequence');
  fields.add('revenue');
  fields.add('category');
  fields.add('productOrService');
  fields.add('modifier');
  fields.add('programCode');
  fields.add('serviced[x]');
  fields.add('location[x]');
  fields.add('quantity');
  fields.add('unitPrice');
  fields.add('factor');
  fields.add('net');
  fields.add('udi');
  fields.add('bodySite');
  fields.add('subSite');
  fields.add('encounter');
  fields.add('detail');
end;

function TFhirClaimItem.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FCareTeamSequenceList.sizeInBytes(magic));
  inc(result, FDiagnosisSequenceList.sizeInBytes(magic));
  inc(result, FProcedureSequenceList.sizeInBytes(magic));
  inc(result, FInformationSequenceList.sizeInBytes(magic));
  inc(result, FModifierList.sizeInBytes(magic));
  inc(result, FProgramCodeList.sizeInBytes(magic));
  inc(result, FUdiList.sizeInBytes(magic));
  inc(result, FSubSiteList.sizeInBytes(magic));
  inc(result, FEncounterList.sizeInBytes(magic));
  inc(result, FDetailList.sizeInBytes(magic));
end;

procedure TFhirClaimItem.SetSequence(value : TFhirPositiveInt);
begin
  FSequence.free;
  FSequence := value;
end;

function TFhirClaimItem.GetSequenceST : String;
begin
  if FSequence = nil then
    result := ''
  else
    result := FSequence.value;
end;

procedure TFhirClaimItem.SetSequenceST(value : String);
begin
  if value <> '' then
  begin
    if FSequence = nil then
      FSequence := TFhirPositiveInt.create;
    FSequence.value := value
  end
  else if FSequence <> nil then
    FSequence.value := '';
end;

function TFhirClaimItem.GetCareTeamSequenceList : TFhirPositiveIntList;
begin
  if FCareTeamSequenceList = nil then
    FCareTeamSequenceList := TFhirPositiveIntList.Create;
  result := FCareTeamSequenceList;
end;

function TFhirClaimItem.GetHasCareTeamSequenceList : boolean;
begin
  result := (FCareTeamSequenceList <> nil) and (FCareTeamSequenceList.count > 0);
end;

function TFhirClaimItem.GetDiagnosisSequenceList : TFhirPositiveIntList;
begin
  if FDiagnosisSequenceList = nil then
    FDiagnosisSequenceList := TFhirPositiveIntList.Create;
  result := FDiagnosisSequenceList;
end;

function TFhirClaimItem.GetHasDiagnosisSequenceList : boolean;
begin
  result := (FDiagnosisSequenceList <> nil) and (FDiagnosisSequenceList.count > 0);
end;

function TFhirClaimItem.GetProcedureSequenceList : TFhirPositiveIntList;
begin
  if FProcedureSequenceList = nil then
    FProcedureSequenceList := TFhirPositiveIntList.Create;
  result := FProcedureSequenceList;
end;

function TFhirClaimItem.GetHasProcedureSequenceList : boolean;
begin
  result := (FProcedureSequenceList <> nil) and (FProcedureSequenceList.count > 0);
end;

function TFhirClaimItem.GetInformationSequenceList : TFhirPositiveIntList;
begin
  if FInformationSequenceList = nil then
    FInformationSequenceList := TFhirPositiveIntList.Create;
  result := FInformationSequenceList;
end;

function TFhirClaimItem.GetHasInformationSequenceList : boolean;
begin
  result := (FInformationSequenceList <> nil) and (FInformationSequenceList.count > 0);
end;

procedure TFhirClaimItem.SetRevenue(value : TFhirCodeableConcept);
begin
  FRevenue.free;
  FRevenue := value;
end;

procedure TFhirClaimItem.SetCategory(value : TFhirCodeableConcept);
begin
  FCategory.free;
  FCategory := value;
end;

procedure TFhirClaimItem.SetProductOrService(value : TFhirCodeableConcept);
begin
  FProductOrService.free;
  FProductOrService := value;
end;

function TFhirClaimItem.GetModifierList : TFhirCodeableConceptList;
begin
  if FModifierList = nil then
    FModifierList := TFhirCodeableConceptList.Create;
  result := FModifierList;
end;

function TFhirClaimItem.GetHasModifierList : boolean;
begin
  result := (FModifierList <> nil) and (FModifierList.count > 0);
end;

function TFhirClaimItem.GetProgramCodeList : TFhirCodeableConceptList;
begin
  if FProgramCodeList = nil then
    FProgramCodeList := TFhirCodeableConceptList.Create;
  result := FProgramCodeList;
end;

function TFhirClaimItem.GetHasProgramCodeList : boolean;
begin
  result := (FProgramCodeList <> nil) and (FProgramCodeList.count > 0);
end;

procedure TFhirClaimItem.SetServiced(value : TFhirDataType);
begin
  FServiced.free;
  FServiced := value;
end;

procedure TFhirClaimItem.SetLocation(value : TFhirDataType);
begin
  FLocation.free;
  FLocation := value;
end;

procedure TFhirClaimItem.SetQuantity(value : TFhirQuantity);
begin
  FQuantity.free;
  FQuantity := value;
end;

procedure TFhirClaimItem.SetUnitPrice(value : TFhirMoney);
begin
  FUnitPrice.free;
  FUnitPrice := value;
end;

procedure TFhirClaimItem.SetFactor(value : TFhirDecimal);
begin
  FFactor.free;
  FFactor := value;
end;

function TFhirClaimItem.GetFactorST : String;
begin
  if FFactor = nil then
    result := ''
  else
    result := FFactor.value;
end;

procedure TFhirClaimItem.SetFactorST(value : String);
begin
  if value <> '' then
  begin
    if FFactor = nil then
      FFactor := TFhirDecimal.create;
    FFactor.value := value
  end
  else if FFactor <> nil then
    FFactor.value := '';
end;

procedure TFhirClaimItem.SetNet(value : TFhirMoney);
begin
  FNet.free;
  FNet := value;
end;

function TFhirClaimItem.GetUdiList : TFhirReferenceList;
begin
  if FUdiList = nil then
    FUdiList := TFhirReferenceList.Create;
  result := FUdiList;
end;

function TFhirClaimItem.GetHasUdiList : boolean;
begin
  result := (FUdiList <> nil) and (FUdiList.count > 0);
end;

procedure TFhirClaimItem.SetBodySite(value : TFhirCodeableConcept);
begin
  FBodySite.free;
  FBodySite := value;
end;

function TFhirClaimItem.GetSubSiteList : TFhirCodeableConceptList;
begin
  if FSubSiteList = nil then
    FSubSiteList := TFhirCodeableConceptList.Create;
  result := FSubSiteList;
end;

function TFhirClaimItem.GetHasSubSiteList : boolean;
begin
  result := (FSubSiteList <> nil) and (FSubSiteList.count > 0);
end;

function TFhirClaimItem.GetEncounterList : TFhirReferenceList;
begin
  if FEncounterList = nil then
    FEncounterList := TFhirReferenceList.Create;
  result := FEncounterList;
end;

function TFhirClaimItem.GetHasEncounterList : boolean;
begin
  result := (FEncounterList <> nil) and (FEncounterList.count > 0);
end;

function TFhirClaimItem.GetDetailList : TFhirClaimItemDetailList;
begin
  if FDetailList = nil then
    FDetailList := TFhirClaimItemDetailList.Create;
  result := FDetailList;
end;

function TFhirClaimItem.GetHasDetailList : boolean;
begin
  result := (FDetailList <> nil) and (FDetailList.count > 0);
end;

{ TFhirClaimItemListEnumerator }

constructor TFhirClaimItemListEnumerator.Create(list : TFhirClaimItemList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirClaimItemListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirClaimItemListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirClaimItemListEnumerator.GetCurrent : TFhirClaimItem;
begin
  Result := FList[FIndex];
end;

function TFhirClaimItemListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirClaimItemList }

procedure TFhirClaimItemList.AddItem(value: TFhirClaimItem);
begin
  assert(value.ClassName = 'TFhirClaimItem', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirClaimItem');
  add(value);
end;

function TFhirClaimItemList.Append: TFhirClaimItem;
begin
  result := TFhirClaimItem.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirClaimItemList.ClearItems;
begin
  Clear;
end;

function TFhirClaimItemList.GetEnumerator : TFhirClaimItemListEnumerator;
begin
  result := TFhirClaimItemListEnumerator.Create(self.link);
end;

function TFhirClaimItemList.Clone: TFhirClaimItemList;
begin
  result := TFhirClaimItemList(inherited Clone);
end;

function TFhirClaimItemList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirClaimItemList.GetItemN(index: Integer): TFhirClaimItem;
begin
  result := TFhirClaimItem(ObjectByIndex[index]);
end;

function TFhirClaimItemList.ItemClass: TFslObjectClass;
begin
  result := TFhirClaimItem;
end;
function TFhirClaimItemList.IndexOf(value: TFhirClaimItem): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirClaimItemList.Insert(index: Integer): TFhirClaimItem;
begin
  result := TFhirClaimItem.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirClaimItemList.InsertItem(index: Integer; value: TFhirClaimItem);
begin
  assert(value is TFhirClaimItem);
  Inherited Insert(index, value);
end;

function TFhirClaimItemList.Item(index: Integer): TFhirClaimItem;
begin
  result := TFhirClaimItem(ObjectByIndex[index]);
end;

function TFhirClaimItemList.Link: TFhirClaimItemList;
begin
  result := TFhirClaimItemList(inherited Link);
end;

procedure TFhirClaimItemList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirClaimItemList.SetItemByIndex(index: Integer; value: TFhirClaimItem);
begin
  assert(value is TFhirClaimItem);
  FhirClaimItems[index] := value;
end;

procedure TFhirClaimItemList.SetItemN(index: Integer; value: TFhirClaimItem);
begin
  assert(value is TFhirClaimItem);
  ObjectByIndex[index] := value;
end;

{ TFhirClaimItemDetail }

constructor TFhirClaimItemDetail.Create;
begin
  inherited;
end;

destructor TFhirClaimItemDetail.Destroy;
begin
  FSequence.free;
  FRevenue.free;
  FCategory.free;
  FProductOrService.free;
  FModifierList.Free;
  FProgramCodeList.Free;
  FQuantity.free;
  FUnitPrice.free;
  FFactor.free;
  FNet.free;
  FUdiList.Free;
  FSubDetailList.Free;
  inherited;
end;

procedure TFhirClaimItemDetail.Assign(oSource : TFslObject);
begin
  inherited;
  sequenceElement := TFhirClaimItemDetail(oSource).sequenceElement.Clone;
  revenue := TFhirClaimItemDetail(oSource).revenue.Clone;
  category := TFhirClaimItemDetail(oSource).category.Clone;
  productOrService := TFhirClaimItemDetail(oSource).productOrService.Clone;
  if (TFhirClaimItemDetail(oSource).FModifierList = nil) then
  begin
    FModifierList.free;
    FModifierList := nil;
  end
  else
  begin
    if FModifierList = nil then
      FModifierList := TFhirCodeableConceptList.Create;
    FModifierList.Assign(TFhirClaimItemDetail(oSource).FModifierList);
  end;
  if (TFhirClaimItemDetail(oSource).FProgramCodeList = nil) then
  begin
    FProgramCodeList.free;
    FProgramCodeList := nil;
  end
  else
  begin
    if FProgramCodeList = nil then
      FProgramCodeList := TFhirCodeableConceptList.Create;
    FProgramCodeList.Assign(TFhirClaimItemDetail(oSource).FProgramCodeList);
  end;
  quantity := TFhirClaimItemDetail(oSource).quantity.Clone;
  unitPrice := TFhirClaimItemDetail(oSource).unitPrice.Clone;
  factorElement := TFhirClaimItemDetail(oSource).factorElement.Clone;
  net := TFhirClaimItemDetail(oSource).net.Clone;
  if (TFhirClaimItemDetail(oSource).FUdiList = nil) then
  begin
    FUdiList.free;
    FUdiList := nil;
  end
  else
  begin
    if FUdiList = nil then
      FUdiList := TFhirReferenceList.Create;
    FUdiList.Assign(TFhirClaimItemDetail(oSource).FUdiList);
  end;
  if (TFhirClaimItemDetail(oSource).FSubDetailList = nil) then
  begin
    FSubDetailList.free;
    FSubDetailList := nil;
  end
  else
  begin
    if FSubDetailList = nil then
      FSubDetailList := TFhirClaimItemDetailSubDetailList.Create;
    FSubDetailList.Assign(TFhirClaimItemDetail(oSource).FSubDetailList);
  end;
end;

procedure TFhirClaimItemDetail.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'sequence') Then
     list.add(self.link, 'sequence', FSequence.Link);
  if (child_name = 'revenue') Then
     list.add(self.link, 'revenue', FRevenue.Link);
  if (child_name = 'category') Then
     list.add(self.link, 'category', FCategory.Link);
  if (child_name = 'productOrService') Then
     list.add(self.link, 'productOrService', FProductOrService.Link);
  if (child_name = 'modifier') Then
    list.addAll(self, 'modifier', FModifierList);
  if (child_name = 'programCode') Then
    list.addAll(self, 'programCode', FProgramCodeList);
  if (child_name = 'quantity') Then
     list.add(self.link, 'quantity', FQuantity.Link);
  if (child_name = 'unitPrice') Then
     list.add(self.link, 'unitPrice', FUnitPrice.Link);
  if (child_name = 'factor') Then
     list.add(self.link, 'factor', FFactor.Link);
  if (child_name = 'net') Then
     list.add(self.link, 'net', FNet.Link);
  if (child_name = 'udi') Then
    list.addAll(self, 'udi', FUdiList);
  if (child_name = 'subDetail') Then
    list.addAll(self, 'subDetail', FSubDetailList);
end;

procedure TFhirClaimItemDetail.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'sequence', 'positiveInt', false, TFhirPositiveInt, FSequence.Link));
  oList.add(TFHIRProperty.create(self, 'revenue', 'CodeableConcept', false, TFhirCodeableConcept, FRevenue.Link));
  oList.add(TFHIRProperty.create(self, 'category', 'CodeableConcept', false, TFhirCodeableConcept, FCategory.Link));
  oList.add(TFHIRProperty.create(self, 'productOrService', 'CodeableConcept', false, TFhirCodeableConcept, FProductOrService.Link));
  oList.add(TFHIRProperty.create(self, 'modifier', 'CodeableConcept', true, TFhirCodeableConcept, FModifierList.Link));
  oList.add(TFHIRProperty.create(self, 'programCode', 'CodeableConcept', true, TFhirCodeableConcept, FProgramCodeList.Link));
  oList.add(TFHIRProperty.create(self, 'quantity', 'Quantity', false, TFhirQuantity, FQuantity.Link));
  oList.add(TFHIRProperty.create(self, 'unitPrice', 'Money', false, TFhirMoney, FUnitPrice.Link));
  oList.add(TFHIRProperty.create(self, 'factor', 'decimal', false, TFhirDecimal, FFactor.Link));
  oList.add(TFHIRProperty.create(self, 'net', 'Money', false, TFhirMoney, FNet.Link));
  oList.add(TFHIRProperty.create(self, 'udi', 'Reference', true, TFhirReference, FUdiList.Link));
  oList.add(TFHIRProperty.create(self, 'subDetail', 'BackboneElement', true, TFhirClaimItemDetailSubDetail, FSubDetailList.Link));
end;

function TFhirClaimItemDetail.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'sequence') then
  begin
    SequenceElement := asPositiveInt(propValue);
    result := propValue;
  end
  else if (propName = 'revenue') then
  begin
    Revenue := propValue as TFhirCodeableConcept;
    result := propValue;
  end
  else if (propName = 'category') then
  begin
    Category := propValue as TFhirCodeableConcept;
    result := propValue;
  end
  else if (propName = 'productOrService') then
  begin
    ProductOrService := propValue as TFhirCodeableConcept;
    result := propValue;
  end
  else if (propName = 'modifier') then
  begin
    ModifierList.add(propValue as TFhirCodeableConcept);
    result := propValue;
  end
  else if (propName = 'programCode') then
  begin
    ProgramCodeList.add(propValue as TFhirCodeableConcept);
    result := propValue;
  end
  else if (propName = 'quantity') then
  begin
    Quantity := propValue as TFhirQuantity;
    result := propValue;
  end
  else if (propName = 'unitPrice') then
  begin
    UnitPrice := propValue as TFhirMoney;
    result := propValue;
  end
  else if (propName = 'factor') then
  begin
    FactorElement := asDecimal(propValue);
    result := propValue;
  end
  else if (propName = 'net') then
  begin
    Net := propValue as TFhirMoney;
    result := propValue;
  end
  else if (propName = 'udi') then
  begin
    UdiList.add(propValue as TFhirReference);
    result := propValue;
  end
  else if (propName = 'subDetail') then
  begin
    SubDetailList.add(propValue as TFhirClaimItemDetailSubDetail);
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirClaimItemDetail.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'modifier') then ModifierList.insertItem(index, propValue as TFhirCodeableConcept)
  else if (propName = 'programCode') then ProgramCodeList.insertItem(index, propValue as TFhirCodeableConcept)
  else if (propName = 'udi') then UdiList.insertItem(index, propValue as TFhirReference)
  else if (propName = 'subDetail') then SubDetailList.insertItem(index, propValue as TFhirClaimItemDetailSubDetail)
  else inherited;
end;

function TFhirClaimItemDetail.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'sequence') then result := TFhirPositiveInt.create()
  else if (propName = 'revenue') then result := TFhirCodeableConcept.create()
  else if (propName = 'category') then result := TFhirCodeableConcept.create()
  else if (propName = 'productOrService') then result := TFhirCodeableConcept.create()
  else if (propName = 'modifier') then result := ModifierList.new()
  else if (propName = 'programCode') then result := ProgramCodeList.new()
  else if (propName = 'quantity') then result := TFhirQuantity.create()
  else if (propName = 'unitPrice') then result := TFhirMoney.create()
  else if (propName = 'factor') then result := TFhirDecimal.create()
  else if (propName = 'net') then result := TFhirMoney.create()
  else if (propName = 'udi') then result := UdiList.new()
  else if (propName = 'subDetail') then result := SubDetailList.new()
  else result := inherited createPropertyValue(propName);
end;

function TFhirClaimItemDetail.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'sequence') then result := 'positiveInt'
  else if (propName = 'revenue') then result := 'CodeableConcept'
  else if (propName = 'category') then result := 'CodeableConcept'
  else if (propName = 'productOrService') then result := 'CodeableConcept'
  else if (propName = 'modifier') then result := 'CodeableConcept'
  else if (propName = 'programCode') then result := 'CodeableConcept'
  else if (propName = 'quantity') then result := 'Quantity'
  else if (propName = 'unitPrice') then result := 'Money'
  else if (propName = 'factor') then result := 'decimal'
  else if (propName = 'net') then result := 'Money'
  else if (propName = 'udi') then result := 'Reference'
  else if (propName = 'subDetail') then result := 'BackboneElement'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirClaimItemDetail.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'sequence') then SequenceElement := nil
  else if (propName = 'revenue') then RevenueElement := nil
  else if (propName = 'category') then CategoryElement := nil
  else if (propName = 'productOrService') then ProductOrServiceElement := nil
  else if (propName = 'modifier') then deletePropertyValue('modifier', ModifierList, value)
  else if (propName = 'programCode') then deletePropertyValue('programCode', ProgramCodeList, value)
  else if (propName = 'quantity') then QuantityElement := nil
  else if (propName = 'unitPrice') then UnitPriceElement := nil
  else if (propName = 'factor') then FactorElement := nil
  else if (propName = 'net') then NetElement := nil
  else if (propName = 'udi') then deletePropertyValue('udi', UdiList, value)
  else if (propName = 'subDetail') then deletePropertyValue('subDetail', SubDetailList, value)
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirClaimItemDetail.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'sequence') then SequenceElement := asPositiveInt(new)
  else if (propName = 'revenue') then RevenueElement := new as TFhirCodeableConcept
  else if (propName = 'category') then CategoryElement := new as TFhirCodeableConcept
  else if (propName = 'productOrService') then ProductOrServiceElement := new as TFhirCodeableConcept
  else if (propName = 'modifier') then replacePropertyValue('modifier', ModifierList, existing, new)
  else if (propName = 'programCode') then replacePropertyValue('programCode', ProgramCodeList, existing, new)
  else if (propName = 'quantity') then QuantityElement := new as TFhirQuantity
  else if (propName = 'unitPrice') then UnitPriceElement := new as TFhirMoney
  else if (propName = 'factor') then FactorElement := asDecimal(new)
  else if (propName = 'net') then NetElement := new as TFhirMoney
  else if (propName = 'udi') then replacePropertyValue('udi', UdiList, existing, new)
  else if (propName = 'subDetail') then replacePropertyValue('subDetail', SubDetailList, existing, new)
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirClaimItemDetail.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'modifier') then ModifierList.move(source, destination)
  else if (propName = 'programCode') then ProgramCodeList.move(source, destination)
  else if (propName = 'udi') then UdiList.move(source, destination)
  else if (propName = 'subDetail') then SubDetailList.move(source, destination)
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirClaimItemDetail.fhirType : string;
begin
  result := 'Claim.item.detail';
end;

function TFhirClaimItemDetail.Link : TFhirClaimItemDetail;
begin
  result := TFhirClaimItemDetail(inherited Link);
end;

function TFhirClaimItemDetail.Clone : TFhirClaimItemDetail;
begin
  result := TFhirClaimItemDetail(inherited Clone);
end;

function TFhirClaimItemDetail.equals(other : TObject) : boolean; 
var
  o : TFhirClaimItemDetail;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirClaimItemDetail)) then
    result := false
  else
  begin
    o := TFhirClaimItemDetail(other);
    result := compareDeep(sequenceElement, o.sequenceElement, true) and compareDeep(revenueElement, o.revenueElement, true) and 
      compareDeep(categoryElement, o.categoryElement, true) and compareDeep(productOrServiceElement, o.productOrServiceElement, true) and 
      compareDeep(modifierList, o.modifierList, true) and compareDeep(programCodeList, o.programCodeList, true) and 
      compareDeep(quantityElement, o.quantityElement, true) and compareDeep(unitPriceElement, o.unitPriceElement, true) and 
      compareDeep(factorElement, o.factorElement, true) and compareDeep(netElement, o.netElement, true) and 
      compareDeep(udiList, o.udiList, true) and compareDeep(subDetailList, o.subDetailList, true);
  end;
end;

function TFhirClaimItemDetail.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FSequence) and isEmptyProp(FRevenue) and isEmptyProp(FCategory) and isEmptyProp(FProductOrService) and isEmptyProp(FmodifierList) and isEmptyProp(FprogramCodeList) and isEmptyProp(FQuantity) and isEmptyProp(FUnitPrice) and isEmptyProp(FFactor) and isEmptyProp(FNet) and isEmptyProp(FudiList) and isEmptyProp(FsubDetailList);
end;

procedure TFhirClaimItemDetail.listFieldsInOrder(fields : TStringList);
begin
  inherited listFieldsInOrder(fields);
  fields.add('sequence');
  fields.add('revenue');
  fields.add('category');
  fields.add('productOrService');
  fields.add('modifier');
  fields.add('programCode');
  fields.add('quantity');
  fields.add('unitPrice');
  fields.add('factor');
  fields.add('net');
  fields.add('udi');
  fields.add('subDetail');
end;

function TFhirClaimItemDetail.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FModifierList.sizeInBytes(magic));
  inc(result, FProgramCodeList.sizeInBytes(magic));
  inc(result, FUdiList.sizeInBytes(magic));
  inc(result, FSubDetailList.sizeInBytes(magic));
end;

procedure TFhirClaimItemDetail.SetSequence(value : TFhirPositiveInt);
begin
  FSequence.free;
  FSequence := value;
end;

function TFhirClaimItemDetail.GetSequenceST : String;
begin
  if FSequence = nil then
    result := ''
  else
    result := FSequence.value;
end;

procedure TFhirClaimItemDetail.SetSequenceST(value : String);
begin
  if value <> '' then
  begin
    if FSequence = nil then
      FSequence := TFhirPositiveInt.create;
    FSequence.value := value
  end
  else if FSequence <> nil then
    FSequence.value := '';
end;

procedure TFhirClaimItemDetail.SetRevenue(value : TFhirCodeableConcept);
begin
  FRevenue.free;
  FRevenue := value;
end;

procedure TFhirClaimItemDetail.SetCategory(value : TFhirCodeableConcept);
begin
  FCategory.free;
  FCategory := value;
end;

procedure TFhirClaimItemDetail.SetProductOrService(value : TFhirCodeableConcept);
begin
  FProductOrService.free;
  FProductOrService := value;
end;

function TFhirClaimItemDetail.GetModifierList : TFhirCodeableConceptList;
begin
  if FModifierList = nil then
    FModifierList := TFhirCodeableConceptList.Create;
  result := FModifierList;
end;

function TFhirClaimItemDetail.GetHasModifierList : boolean;
begin
  result := (FModifierList <> nil) and (FModifierList.count > 0);
end;

function TFhirClaimItemDetail.GetProgramCodeList : TFhirCodeableConceptList;
begin
  if FProgramCodeList = nil then
    FProgramCodeList := TFhirCodeableConceptList.Create;
  result := FProgramCodeList;
end;

function TFhirClaimItemDetail.GetHasProgramCodeList : boolean;
begin
  result := (FProgramCodeList <> nil) and (FProgramCodeList.count > 0);
end;

procedure TFhirClaimItemDetail.SetQuantity(value : TFhirQuantity);
begin
  FQuantity.free;
  FQuantity := value;
end;

procedure TFhirClaimItemDetail.SetUnitPrice(value : TFhirMoney);
begin
  FUnitPrice.free;
  FUnitPrice := value;
end;

procedure TFhirClaimItemDetail.SetFactor(value : TFhirDecimal);
begin
  FFactor.free;
  FFactor := value;
end;

function TFhirClaimItemDetail.GetFactorST : String;
begin
  if FFactor = nil then
    result := ''
  else
    result := FFactor.value;
end;

procedure TFhirClaimItemDetail.SetFactorST(value : String);
begin
  if value <> '' then
  begin
    if FFactor = nil then
      FFactor := TFhirDecimal.create;
    FFactor.value := value
  end
  else if FFactor <> nil then
    FFactor.value := '';
end;

procedure TFhirClaimItemDetail.SetNet(value : TFhirMoney);
begin
  FNet.free;
  FNet := value;
end;

function TFhirClaimItemDetail.GetUdiList : TFhirReferenceList;
begin
  if FUdiList = nil then
    FUdiList := TFhirReferenceList.Create;
  result := FUdiList;
end;

function TFhirClaimItemDetail.GetHasUdiList : boolean;
begin
  result := (FUdiList <> nil) and (FUdiList.count > 0);
end;

function TFhirClaimItemDetail.GetSubDetailList : TFhirClaimItemDetailSubDetailList;
begin
  if FSubDetailList = nil then
    FSubDetailList := TFhirClaimItemDetailSubDetailList.Create;
  result := FSubDetailList;
end;

function TFhirClaimItemDetail.GetHasSubDetailList : boolean;
begin
  result := (FSubDetailList <> nil) and (FSubDetailList.count > 0);
end;

{ TFhirClaimItemDetailListEnumerator }

constructor TFhirClaimItemDetailListEnumerator.Create(list : TFhirClaimItemDetailList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirClaimItemDetailListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirClaimItemDetailListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirClaimItemDetailListEnumerator.GetCurrent : TFhirClaimItemDetail;
begin
  Result := FList[FIndex];
end;

function TFhirClaimItemDetailListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirClaimItemDetailList }

procedure TFhirClaimItemDetailList.AddItem(value: TFhirClaimItemDetail);
begin
  assert(value.ClassName = 'TFhirClaimItemDetail', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirClaimItemDetail');
  add(value);
end;

function TFhirClaimItemDetailList.Append: TFhirClaimItemDetail;
begin
  result := TFhirClaimItemDetail.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirClaimItemDetailList.ClearItems;
begin
  Clear;
end;

function TFhirClaimItemDetailList.GetEnumerator : TFhirClaimItemDetailListEnumerator;
begin
  result := TFhirClaimItemDetailListEnumerator.Create(self.link);
end;

function TFhirClaimItemDetailList.Clone: TFhirClaimItemDetailList;
begin
  result := TFhirClaimItemDetailList(inherited Clone);
end;

function TFhirClaimItemDetailList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirClaimItemDetailList.GetItemN(index: Integer): TFhirClaimItemDetail;
begin
  result := TFhirClaimItemDetail(ObjectByIndex[index]);
end;

function TFhirClaimItemDetailList.ItemClass: TFslObjectClass;
begin
  result := TFhirClaimItemDetail;
end;
function TFhirClaimItemDetailList.IndexOf(value: TFhirClaimItemDetail): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirClaimItemDetailList.Insert(index: Integer): TFhirClaimItemDetail;
begin
  result := TFhirClaimItemDetail.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirClaimItemDetailList.InsertItem(index: Integer; value: TFhirClaimItemDetail);
begin
  assert(value is TFhirClaimItemDetail);
  Inherited Insert(index, value);
end;

function TFhirClaimItemDetailList.Item(index: Integer): TFhirClaimItemDetail;
begin
  result := TFhirClaimItemDetail(ObjectByIndex[index]);
end;

function TFhirClaimItemDetailList.Link: TFhirClaimItemDetailList;
begin
  result := TFhirClaimItemDetailList(inherited Link);
end;

procedure TFhirClaimItemDetailList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirClaimItemDetailList.SetItemByIndex(index: Integer; value: TFhirClaimItemDetail);
begin
  assert(value is TFhirClaimItemDetail);
  FhirClaimItemDetails[index] := value;
end;

procedure TFhirClaimItemDetailList.SetItemN(index: Integer; value: TFhirClaimItemDetail);
begin
  assert(value is TFhirClaimItemDetail);
  ObjectByIndex[index] := value;
end;

{ TFhirClaimItemDetailSubDetail }

constructor TFhirClaimItemDetailSubDetail.Create;
begin
  inherited;
end;

destructor TFhirClaimItemDetailSubDetail.Destroy;
begin
  FSequence.free;
  FRevenue.free;
  FCategory.free;
  FProductOrService.free;
  FModifierList.Free;
  FProgramCodeList.Free;
  FQuantity.free;
  FUnitPrice.free;
  FFactor.free;
  FNet.free;
  FUdiList.Free;
  inherited;
end;

procedure TFhirClaimItemDetailSubDetail.Assign(oSource : TFslObject);
begin
  inherited;
  sequenceElement := TFhirClaimItemDetailSubDetail(oSource).sequenceElement.Clone;
  revenue := TFhirClaimItemDetailSubDetail(oSource).revenue.Clone;
  category := TFhirClaimItemDetailSubDetail(oSource).category.Clone;
  productOrService := TFhirClaimItemDetailSubDetail(oSource).productOrService.Clone;
  if (TFhirClaimItemDetailSubDetail(oSource).FModifierList = nil) then
  begin
    FModifierList.free;
    FModifierList := nil;
  end
  else
  begin
    if FModifierList = nil then
      FModifierList := TFhirCodeableConceptList.Create;
    FModifierList.Assign(TFhirClaimItemDetailSubDetail(oSource).FModifierList);
  end;
  if (TFhirClaimItemDetailSubDetail(oSource).FProgramCodeList = nil) then
  begin
    FProgramCodeList.free;
    FProgramCodeList := nil;
  end
  else
  begin
    if FProgramCodeList = nil then
      FProgramCodeList := TFhirCodeableConceptList.Create;
    FProgramCodeList.Assign(TFhirClaimItemDetailSubDetail(oSource).FProgramCodeList);
  end;
  quantity := TFhirClaimItemDetailSubDetail(oSource).quantity.Clone;
  unitPrice := TFhirClaimItemDetailSubDetail(oSource).unitPrice.Clone;
  factorElement := TFhirClaimItemDetailSubDetail(oSource).factorElement.Clone;
  net := TFhirClaimItemDetailSubDetail(oSource).net.Clone;
  if (TFhirClaimItemDetailSubDetail(oSource).FUdiList = nil) then
  begin
    FUdiList.free;
    FUdiList := nil;
  end
  else
  begin
    if FUdiList = nil then
      FUdiList := TFhirReferenceList.Create;
    FUdiList.Assign(TFhirClaimItemDetailSubDetail(oSource).FUdiList);
  end;
end;

procedure TFhirClaimItemDetailSubDetail.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'sequence') Then
     list.add(self.link, 'sequence', FSequence.Link);
  if (child_name = 'revenue') Then
     list.add(self.link, 'revenue', FRevenue.Link);
  if (child_name = 'category') Then
     list.add(self.link, 'category', FCategory.Link);
  if (child_name = 'productOrService') Then
     list.add(self.link, 'productOrService', FProductOrService.Link);
  if (child_name = 'modifier') Then
    list.addAll(self, 'modifier', FModifierList);
  if (child_name = 'programCode') Then
    list.addAll(self, 'programCode', FProgramCodeList);
  if (child_name = 'quantity') Then
     list.add(self.link, 'quantity', FQuantity.Link);
  if (child_name = 'unitPrice') Then
     list.add(self.link, 'unitPrice', FUnitPrice.Link);
  if (child_name = 'factor') Then
     list.add(self.link, 'factor', FFactor.Link);
  if (child_name = 'net') Then
     list.add(self.link, 'net', FNet.Link);
  if (child_name = 'udi') Then
    list.addAll(self, 'udi', FUdiList);
end;

procedure TFhirClaimItemDetailSubDetail.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'sequence', 'positiveInt', false, TFhirPositiveInt, FSequence.Link));
  oList.add(TFHIRProperty.create(self, 'revenue', 'CodeableConcept', false, TFhirCodeableConcept, FRevenue.Link));
  oList.add(TFHIRProperty.create(self, 'category', 'CodeableConcept', false, TFhirCodeableConcept, FCategory.Link));
  oList.add(TFHIRProperty.create(self, 'productOrService', 'CodeableConcept', false, TFhirCodeableConcept, FProductOrService.Link));
  oList.add(TFHIRProperty.create(self, 'modifier', 'CodeableConcept', true, TFhirCodeableConcept, FModifierList.Link));
  oList.add(TFHIRProperty.create(self, 'programCode', 'CodeableConcept', true, TFhirCodeableConcept, FProgramCodeList.Link));
  oList.add(TFHIRProperty.create(self, 'quantity', 'Quantity', false, TFhirQuantity, FQuantity.Link));
  oList.add(TFHIRProperty.create(self, 'unitPrice', 'Money', false, TFhirMoney, FUnitPrice.Link));
  oList.add(TFHIRProperty.create(self, 'factor', 'decimal', false, TFhirDecimal, FFactor.Link));
  oList.add(TFHIRProperty.create(self, 'net', 'Money', false, TFhirMoney, FNet.Link));
  oList.add(TFHIRProperty.create(self, 'udi', 'Reference', true, TFhirReference, FUdiList.Link));
end;

function TFhirClaimItemDetailSubDetail.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'sequence') then
  begin
    SequenceElement := asPositiveInt(propValue);
    result := propValue;
  end
  else if (propName = 'revenue') then
  begin
    Revenue := propValue as TFhirCodeableConcept;
    result := propValue;
  end
  else if (propName = 'category') then
  begin
    Category := propValue as TFhirCodeableConcept;
    result := propValue;
  end
  else if (propName = 'productOrService') then
  begin
    ProductOrService := propValue as TFhirCodeableConcept;
    result := propValue;
  end
  else if (propName = 'modifier') then
  begin
    ModifierList.add(propValue as TFhirCodeableConcept);
    result := propValue;
  end
  else if (propName = 'programCode') then
  begin
    ProgramCodeList.add(propValue as TFhirCodeableConcept);
    result := propValue;
  end
  else if (propName = 'quantity') then
  begin
    Quantity := propValue as TFhirQuantity;
    result := propValue;
  end
  else if (propName = 'unitPrice') then
  begin
    UnitPrice := propValue as TFhirMoney;
    result := propValue;
  end
  else if (propName = 'factor') then
  begin
    FactorElement := asDecimal(propValue);
    result := propValue;
  end
  else if (propName = 'net') then
  begin
    Net := propValue as TFhirMoney;
    result := propValue;
  end
  else if (propName = 'udi') then
  begin
    UdiList.add(propValue as TFhirReference);
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirClaimItemDetailSubDetail.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'modifier') then ModifierList.insertItem(index, propValue as TFhirCodeableConcept)
  else if (propName = 'programCode') then ProgramCodeList.insertItem(index, propValue as TFhirCodeableConcept)
  else if (propName = 'udi') then UdiList.insertItem(index, propValue as TFhirReference)
  else inherited;
end;

function TFhirClaimItemDetailSubDetail.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'sequence') then result := TFhirPositiveInt.create()
  else if (propName = 'revenue') then result := TFhirCodeableConcept.create()
  else if (propName = 'category') then result := TFhirCodeableConcept.create()
  else if (propName = 'productOrService') then result := TFhirCodeableConcept.create()
  else if (propName = 'modifier') then result := ModifierList.new()
  else if (propName = 'programCode') then result := ProgramCodeList.new()
  else if (propName = 'quantity') then result := TFhirQuantity.create()
  else if (propName = 'unitPrice') then result := TFhirMoney.create()
  else if (propName = 'factor') then result := TFhirDecimal.create()
  else if (propName = 'net') then result := TFhirMoney.create()
  else if (propName = 'udi') then result := UdiList.new()
  else result := inherited createPropertyValue(propName);
end;

function TFhirClaimItemDetailSubDetail.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'sequence') then result := 'positiveInt'
  else if (propName = 'revenue') then result := 'CodeableConcept'
  else if (propName = 'category') then result := 'CodeableConcept'
  else if (propName = 'productOrService') then result := 'CodeableConcept'
  else if (propName = 'modifier') then result := 'CodeableConcept'
  else if (propName = 'programCode') then result := 'CodeableConcept'
  else if (propName = 'quantity') then result := 'Quantity'
  else if (propName = 'unitPrice') then result := 'Money'
  else if (propName = 'factor') then result := 'decimal'
  else if (propName = 'net') then result := 'Money'
  else if (propName = 'udi') then result := 'Reference'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirClaimItemDetailSubDetail.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'sequence') then SequenceElement := nil
  else if (propName = 'revenue') then RevenueElement := nil
  else if (propName = 'category') then CategoryElement := nil
  else if (propName = 'productOrService') then ProductOrServiceElement := nil
  else if (propName = 'modifier') then deletePropertyValue('modifier', ModifierList, value)
  else if (propName = 'programCode') then deletePropertyValue('programCode', ProgramCodeList, value)
  else if (propName = 'quantity') then QuantityElement := nil
  else if (propName = 'unitPrice') then UnitPriceElement := nil
  else if (propName = 'factor') then FactorElement := nil
  else if (propName = 'net') then NetElement := nil
  else if (propName = 'udi') then deletePropertyValue('udi', UdiList, value)
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirClaimItemDetailSubDetail.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'sequence') then SequenceElement := asPositiveInt(new)
  else if (propName = 'revenue') then RevenueElement := new as TFhirCodeableConcept
  else if (propName = 'category') then CategoryElement := new as TFhirCodeableConcept
  else if (propName = 'productOrService') then ProductOrServiceElement := new as TFhirCodeableConcept
  else if (propName = 'modifier') then replacePropertyValue('modifier', ModifierList, existing, new)
  else if (propName = 'programCode') then replacePropertyValue('programCode', ProgramCodeList, existing, new)
  else if (propName = 'quantity') then QuantityElement := new as TFhirQuantity
  else if (propName = 'unitPrice') then UnitPriceElement := new as TFhirMoney
  else if (propName = 'factor') then FactorElement := asDecimal(new)
  else if (propName = 'net') then NetElement := new as TFhirMoney
  else if (propName = 'udi') then replacePropertyValue('udi', UdiList, existing, new)
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirClaimItemDetailSubDetail.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'modifier') then ModifierList.move(source, destination)
  else if (propName = 'programCode') then ProgramCodeList.move(source, destination)
  else if (propName = 'udi') then UdiList.move(source, destination)
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirClaimItemDetailSubDetail.fhirType : string;
begin
  result := 'Claim.item.detail.subDetail';
end;

function TFhirClaimItemDetailSubDetail.Link : TFhirClaimItemDetailSubDetail;
begin
  result := TFhirClaimItemDetailSubDetail(inherited Link);
end;

function TFhirClaimItemDetailSubDetail.Clone : TFhirClaimItemDetailSubDetail;
begin
  result := TFhirClaimItemDetailSubDetail(inherited Clone);
end;

function TFhirClaimItemDetailSubDetail.equals(other : TObject) : boolean; 
var
  o : TFhirClaimItemDetailSubDetail;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirClaimItemDetailSubDetail)) then
    result := false
  else
  begin
    o := TFhirClaimItemDetailSubDetail(other);
    result := compareDeep(sequenceElement, o.sequenceElement, true) and compareDeep(revenueElement, o.revenueElement, true) and 
      compareDeep(categoryElement, o.categoryElement, true) and compareDeep(productOrServiceElement, o.productOrServiceElement, true) and 
      compareDeep(modifierList, o.modifierList, true) and compareDeep(programCodeList, o.programCodeList, true) and 
      compareDeep(quantityElement, o.quantityElement, true) and compareDeep(unitPriceElement, o.unitPriceElement, true) and 
      compareDeep(factorElement, o.factorElement, true) and compareDeep(netElement, o.netElement, true) and 
      compareDeep(udiList, o.udiList, true);
  end;
end;

function TFhirClaimItemDetailSubDetail.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FSequence) and isEmptyProp(FRevenue) and isEmptyProp(FCategory) and isEmptyProp(FProductOrService) and isEmptyProp(FmodifierList) and isEmptyProp(FprogramCodeList) and isEmptyProp(FQuantity) and isEmptyProp(FUnitPrice) and isEmptyProp(FFactor) and isEmptyProp(FNet) and isEmptyProp(FudiList);
end;

procedure TFhirClaimItemDetailSubDetail.listFieldsInOrder(fields : TStringList);
begin
  inherited listFieldsInOrder(fields);
  fields.add('sequence');
  fields.add('revenue');
  fields.add('category');
  fields.add('productOrService');
  fields.add('modifier');
  fields.add('programCode');
  fields.add('quantity');
  fields.add('unitPrice');
  fields.add('factor');
  fields.add('net');
  fields.add('udi');
end;

function TFhirClaimItemDetailSubDetail.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FModifierList.sizeInBytes(magic));
  inc(result, FProgramCodeList.sizeInBytes(magic));
  inc(result, FUdiList.sizeInBytes(magic));
end;

procedure TFhirClaimItemDetailSubDetail.SetSequence(value : TFhirPositiveInt);
begin
  FSequence.free;
  FSequence := value;
end;

function TFhirClaimItemDetailSubDetail.GetSequenceST : String;
begin
  if FSequence = nil then
    result := ''
  else
    result := FSequence.value;
end;

procedure TFhirClaimItemDetailSubDetail.SetSequenceST(value : String);
begin
  if value <> '' then
  begin
    if FSequence = nil then
      FSequence := TFhirPositiveInt.create;
    FSequence.value := value
  end
  else if FSequence <> nil then
    FSequence.value := '';
end;

procedure TFhirClaimItemDetailSubDetail.SetRevenue(value : TFhirCodeableConcept);
begin
  FRevenue.free;
  FRevenue := value;
end;

procedure TFhirClaimItemDetailSubDetail.SetCategory(value : TFhirCodeableConcept);
begin
  FCategory.free;
  FCategory := value;
end;

procedure TFhirClaimItemDetailSubDetail.SetProductOrService(value : TFhirCodeableConcept);
begin
  FProductOrService.free;
  FProductOrService := value;
end;

function TFhirClaimItemDetailSubDetail.GetModifierList : TFhirCodeableConceptList;
begin
  if FModifierList = nil then
    FModifierList := TFhirCodeableConceptList.Create;
  result := FModifierList;
end;

function TFhirClaimItemDetailSubDetail.GetHasModifierList : boolean;
begin
  result := (FModifierList <> nil) and (FModifierList.count > 0);
end;

function TFhirClaimItemDetailSubDetail.GetProgramCodeList : TFhirCodeableConceptList;
begin
  if FProgramCodeList = nil then
    FProgramCodeList := TFhirCodeableConceptList.Create;
  result := FProgramCodeList;
end;

function TFhirClaimItemDetailSubDetail.GetHasProgramCodeList : boolean;
begin
  result := (FProgramCodeList <> nil) and (FProgramCodeList.count > 0);
end;

procedure TFhirClaimItemDetailSubDetail.SetQuantity(value : TFhirQuantity);
begin
  FQuantity.free;
  FQuantity := value;
end;

procedure TFhirClaimItemDetailSubDetail.SetUnitPrice(value : TFhirMoney);
begin
  FUnitPrice.free;
  FUnitPrice := value;
end;

procedure TFhirClaimItemDetailSubDetail.SetFactor(value : TFhirDecimal);
begin
  FFactor.free;
  FFactor := value;
end;

function TFhirClaimItemDetailSubDetail.GetFactorST : String;
begin
  if FFactor = nil then
    result := ''
  else
    result := FFactor.value;
end;

procedure TFhirClaimItemDetailSubDetail.SetFactorST(value : String);
begin
  if value <> '' then
  begin
    if FFactor = nil then
      FFactor := TFhirDecimal.create;
    FFactor.value := value
  end
  else if FFactor <> nil then
    FFactor.value := '';
end;

procedure TFhirClaimItemDetailSubDetail.SetNet(value : TFhirMoney);
begin
  FNet.free;
  FNet := value;
end;

function TFhirClaimItemDetailSubDetail.GetUdiList : TFhirReferenceList;
begin
  if FUdiList = nil then
    FUdiList := TFhirReferenceList.Create;
  result := FUdiList;
end;

function TFhirClaimItemDetailSubDetail.GetHasUdiList : boolean;
begin
  result := (FUdiList <> nil) and (FUdiList.count > 0);
end;

{ TFhirClaimItemDetailSubDetailListEnumerator }

constructor TFhirClaimItemDetailSubDetailListEnumerator.Create(list : TFhirClaimItemDetailSubDetailList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirClaimItemDetailSubDetailListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirClaimItemDetailSubDetailListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirClaimItemDetailSubDetailListEnumerator.GetCurrent : TFhirClaimItemDetailSubDetail;
begin
  Result := FList[FIndex];
end;

function TFhirClaimItemDetailSubDetailListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirClaimItemDetailSubDetailList }

procedure TFhirClaimItemDetailSubDetailList.AddItem(value: TFhirClaimItemDetailSubDetail);
begin
  assert(value.ClassName = 'TFhirClaimItemDetailSubDetail', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirClaimItemDetailSubDetail');
  add(value);
end;

function TFhirClaimItemDetailSubDetailList.Append: TFhirClaimItemDetailSubDetail;
begin
  result := TFhirClaimItemDetailSubDetail.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirClaimItemDetailSubDetailList.ClearItems;
begin
  Clear;
end;

function TFhirClaimItemDetailSubDetailList.GetEnumerator : TFhirClaimItemDetailSubDetailListEnumerator;
begin
  result := TFhirClaimItemDetailSubDetailListEnumerator.Create(self.link);
end;

function TFhirClaimItemDetailSubDetailList.Clone: TFhirClaimItemDetailSubDetailList;
begin
  result := TFhirClaimItemDetailSubDetailList(inherited Clone);
end;

function TFhirClaimItemDetailSubDetailList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirClaimItemDetailSubDetailList.GetItemN(index: Integer): TFhirClaimItemDetailSubDetail;
begin
  result := TFhirClaimItemDetailSubDetail(ObjectByIndex[index]);
end;

function TFhirClaimItemDetailSubDetailList.ItemClass: TFslObjectClass;
begin
  result := TFhirClaimItemDetailSubDetail;
end;
function TFhirClaimItemDetailSubDetailList.IndexOf(value: TFhirClaimItemDetailSubDetail): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirClaimItemDetailSubDetailList.Insert(index: Integer): TFhirClaimItemDetailSubDetail;
begin
  result := TFhirClaimItemDetailSubDetail.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirClaimItemDetailSubDetailList.InsertItem(index: Integer; value: TFhirClaimItemDetailSubDetail);
begin
  assert(value is TFhirClaimItemDetailSubDetail);
  Inherited Insert(index, value);
end;

function TFhirClaimItemDetailSubDetailList.Item(index: Integer): TFhirClaimItemDetailSubDetail;
begin
  result := TFhirClaimItemDetailSubDetail(ObjectByIndex[index]);
end;

function TFhirClaimItemDetailSubDetailList.Link: TFhirClaimItemDetailSubDetailList;
begin
  result := TFhirClaimItemDetailSubDetailList(inherited Link);
end;

procedure TFhirClaimItemDetailSubDetailList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirClaimItemDetailSubDetailList.SetItemByIndex(index: Integer; value: TFhirClaimItemDetailSubDetail);
begin
  assert(value is TFhirClaimItemDetailSubDetail);
  FhirClaimItemDetailSubDetails[index] := value;
end;

procedure TFhirClaimItemDetailSubDetailList.SetItemN(index: Integer; value: TFhirClaimItemDetailSubDetail);
begin
  assert(value is TFhirClaimItemDetailSubDetail);
  ObjectByIndex[index] := value;
end;

{ TFhirClaim }

constructor TFhirClaim.Create;
begin
  inherited;
end;

destructor TFhirClaim.Destroy;
begin
  FIdentifierList.Free;
  FStatus.free;
  FType_.free;
  FSubType.free;
  FUse.free;
  FPatient.free;
  FBillablePeriod.free;
  FCreated.free;
  FEnterer.free;
  FInsurer.free;
  FProvider.free;
  FPriority.free;
  FFundsReserve.free;
  FRelatedList.Free;
  FPrescription.free;
  FOriginalPrescription.free;
  FPayee.free;
  FReferral.free;
  FFacility.free;
  FCareTeamList.Free;
  FSupportingInfoList.Free;
  FDiagnosisList.Free;
  FProcedure_List.Free;
  FInsuranceList.Free;
  FAccident.free;
  FItemList.Free;
  FTotal.free;
  inherited;
end;

procedure TFhirClaim.Assign(oSource : TFslObject);
begin
  inherited;
  if (TFhirClaim(oSource).FIdentifierList = nil) then
  begin
    FIdentifierList.free;
    FIdentifierList := nil;
  end
  else
  begin
    if FIdentifierList = nil then
      FIdentifierList := TFhirIdentifierList.Create;
    FIdentifierList.Assign(TFhirClaim(oSource).FIdentifierList);
  end;
  statusElement := TFhirClaim(oSource).statusElement.Clone;
  type_ := TFhirClaim(oSource).type_.Clone;
  subType := TFhirClaim(oSource).subType.Clone;
  useElement := TFhirClaim(oSource).useElement.Clone;
  patient := TFhirClaim(oSource).patient.Clone;
  billablePeriod := TFhirClaim(oSource).billablePeriod.Clone;
  createdElement := TFhirClaim(oSource).createdElement.Clone;
  enterer := TFhirClaim(oSource).enterer.Clone;
  insurer := TFhirClaim(oSource).insurer.Clone;
  provider := TFhirClaim(oSource).provider.Clone;
  priority := TFhirClaim(oSource).priority.Clone;
  fundsReserve := TFhirClaim(oSource).fundsReserve.Clone;
  if (TFhirClaim(oSource).FRelatedList = nil) then
  begin
    FRelatedList.free;
    FRelatedList := nil;
  end
  else
  begin
    if FRelatedList = nil then
      FRelatedList := TFhirClaimRelatedList.Create;
    FRelatedList.Assign(TFhirClaim(oSource).FRelatedList);
  end;
  prescription := TFhirClaim(oSource).prescription.Clone;
  originalPrescription := TFhirClaim(oSource).originalPrescription.Clone;
  payee := TFhirClaim(oSource).payee.Clone;
  referral := TFhirClaim(oSource).referral.Clone;
  facility := TFhirClaim(oSource).facility.Clone;
  if (TFhirClaim(oSource).FCareTeamList = nil) then
  begin
    FCareTeamList.free;
    FCareTeamList := nil;
  end
  else
  begin
    if FCareTeamList = nil then
      FCareTeamList := TFhirClaimCareTeamList.Create;
    FCareTeamList.Assign(TFhirClaim(oSource).FCareTeamList);
  end;
  if (TFhirClaim(oSource).FSupportingInfoList = nil) then
  begin
    FSupportingInfoList.free;
    FSupportingInfoList := nil;
  end
  else
  begin
    if FSupportingInfoList = nil then
      FSupportingInfoList := TFhirClaimSupportingInfoList.Create;
    FSupportingInfoList.Assign(TFhirClaim(oSource).FSupportingInfoList);
  end;
  if (TFhirClaim(oSource).FDiagnosisList = nil) then
  begin
    FDiagnosisList.free;
    FDiagnosisList := nil;
  end
  else
  begin
    if FDiagnosisList = nil then
      FDiagnosisList := TFhirClaimDiagnosisList.Create;
    FDiagnosisList.Assign(TFhirClaim(oSource).FDiagnosisList);
  end;
  if (TFhirClaim(oSource).FProcedure_List = nil) then
  begin
    FProcedure_List.free;
    FProcedure_List := nil;
  end
  else
  begin
    if FProcedure_List = nil then
      FProcedure_List := TFhirClaimProcedureList.Create;
    FProcedure_List.Assign(TFhirClaim(oSource).FProcedure_List);
  end;
  if (TFhirClaim(oSource).FInsuranceList = nil) then
  begin
    FInsuranceList.free;
    FInsuranceList := nil;
  end
  else
  begin
    if FInsuranceList = nil then
      FInsuranceList := TFhirClaimInsuranceList.Create;
    FInsuranceList.Assign(TFhirClaim(oSource).FInsuranceList);
  end;
  accident := TFhirClaim(oSource).accident.Clone;
  if (TFhirClaim(oSource).FItemList = nil) then
  begin
    FItemList.free;
    FItemList := nil;
  end
  else
  begin
    if FItemList = nil then
      FItemList := TFhirClaimItemList.Create;
    FItemList.Assign(TFhirClaim(oSource).FItemList);
  end;
  total := TFhirClaim(oSource).total.Clone;
end;

function TFhirClaim.GetResourceType : TFhirResourceType;
begin
  result := frtClaim;
end;

procedure TFhirClaim.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'identifier') Then
    list.addAll(self, 'identifier', FIdentifierList);
  if (child_name = 'status') Then
     list.add(self.link, 'status', FStatus.Link);
  if (child_name = 'type') Then
     list.add(self.link, 'type', FType_.Link);
  if (child_name = 'subType') Then
     list.add(self.link, 'subType', FSubType.Link);
  if (child_name = 'use') Then
     list.add(self.link, 'use', FUse.Link);
  if (child_name = 'patient') Then
     list.add(self.link, 'patient', FPatient.Link);
  if (child_name = 'billablePeriod') Then
     list.add(self.link, 'billablePeriod', FBillablePeriod.Link);
  if (child_name = 'created') Then
     list.add(self.link, 'created', FCreated.Link);
  if (child_name = 'enterer') Then
     list.add(self.link, 'enterer', FEnterer.Link);
  if (child_name = 'insurer') Then
     list.add(self.link, 'insurer', FInsurer.Link);
  if (child_name = 'provider') Then
     list.add(self.link, 'provider', FProvider.Link);
  if (child_name = 'priority') Then
     list.add(self.link, 'priority', FPriority.Link);
  if (child_name = 'fundsReserve') Then
     list.add(self.link, 'fundsReserve', FFundsReserve.Link);
  if (child_name = 'related') Then
    list.addAll(self, 'related', FRelatedList);
  if (child_name = 'prescription') Then
     list.add(self.link, 'prescription', FPrescription.Link);
  if (child_name = 'originalPrescription') Then
     list.add(self.link, 'originalPrescription', FOriginalPrescription.Link);
  if (child_name = 'payee') Then
     list.add(self.link, 'payee', FPayee.Link);
  if (child_name = 'referral') Then
     list.add(self.link, 'referral', FReferral.Link);
  if (child_name = 'facility') Then
     list.add(self.link, 'facility', FFacility.Link);
  if (child_name = 'careTeam') Then
    list.addAll(self, 'careTeam', FCareTeamList);
  if (child_name = 'supportingInfo') Then
    list.addAll(self, 'supportingInfo', FSupportingInfoList);
  if (child_name = 'diagnosis') Then
    list.addAll(self, 'diagnosis', FDiagnosisList);
  if (child_name = 'procedure') Then
    list.addAll(self, 'procedure', FProcedure_List);
  if (child_name = 'insurance') Then
    list.addAll(self, 'insurance', FInsuranceList);
  if (child_name = 'accident') Then
     list.add(self.link, 'accident', FAccident.Link);
  if (child_name = 'item') Then
    list.addAll(self, 'item', FItemList);
  if (child_name = 'total') Then
     list.add(self.link, 'total', FTotal.Link);
end;

procedure TFhirClaim.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'identifier', 'Identifier', true, TFhirIdentifier, FIdentifierList.Link));
  oList.add(TFHIRProperty.create(self, 'status', 'code', false, TFhirEnum, FStatus.Link));
  oList.add(TFHIRProperty.create(self, 'type', 'CodeableConcept', false, TFhirCodeableConcept, FType_.Link));
  oList.add(TFHIRProperty.create(self, 'subType', 'CodeableConcept', false, TFhirCodeableConcept, FSubType.Link));
  oList.add(TFHIRProperty.create(self, 'use', 'code', false, TFhirEnum, FUse.Link));
  oList.add(TFHIRProperty.create(self, 'patient', 'Reference', false, TFhirReference, FPatient.Link));
  oList.add(TFHIRProperty.create(self, 'billablePeriod', 'Period', false, TFhirPeriod, FBillablePeriod.Link));
  oList.add(TFHIRProperty.create(self, 'created', 'dateTime', false, TFhirDateTime, FCreated.Link));
  oList.add(TFHIRProperty.create(self, 'enterer', 'Reference', false, TFhirReference, FEnterer.Link));
  oList.add(TFHIRProperty.create(self, 'insurer', 'Reference', false, TFhirReference, FInsurer.Link));
  oList.add(TFHIRProperty.create(self, 'provider', 'Reference', false, TFhirReference, FProvider.Link));
  oList.add(TFHIRProperty.create(self, 'priority', 'CodeableConcept', false, TFhirCodeableConcept, FPriority.Link));
  oList.add(TFHIRProperty.create(self, 'fundsReserve', 'CodeableConcept', false, TFhirCodeableConcept, FFundsReserve.Link));
  oList.add(TFHIRProperty.create(self, 'related', 'BackboneElement', true, TFhirClaimRelated, FRelatedList.Link));
  oList.add(TFHIRProperty.create(self, 'prescription', 'Reference', false, TFhirReference, FPrescription.Link));
  oList.add(TFHIRProperty.create(self, 'originalPrescription', 'Reference', false, TFhirReference, FOriginalPrescription.Link));
  oList.add(TFHIRProperty.create(self, 'payee', 'BackboneElement', false, TFhirClaimPayee, FPayee.Link));
  oList.add(TFHIRProperty.create(self, 'referral', 'Reference', false, TFhirReference, FReferral.Link));
  oList.add(TFHIRProperty.create(self, 'facility', 'Reference', false, TFhirReference, FFacility.Link));
  oList.add(TFHIRProperty.create(self, 'careTeam', 'BackboneElement', true, TFhirClaimCareTeam, FCareTeamList.Link));
  oList.add(TFHIRProperty.create(self, 'supportingInfo', 'BackboneElement', true, TFhirClaimSupportingInfo, FSupportingInfoList.Link));
  oList.add(TFHIRProperty.create(self, 'diagnosis', 'BackboneElement', true, TFhirClaimDiagnosis, FDiagnosisList.Link));
  oList.add(TFHIRProperty.create(self, 'procedure', 'BackboneElement', true, TFhirClaimProcedure, FProcedure_List.Link));
  oList.add(TFHIRProperty.create(self, 'insurance', 'BackboneElement', true, TFhirClaimInsurance, FInsuranceList.Link));
  oList.add(TFHIRProperty.create(self, 'accident', 'BackboneElement', false, TFhirClaimAccident, FAccident.Link));
  oList.add(TFHIRProperty.create(self, 'item', 'BackboneElement', true, TFhirClaimItem, FItemList.Link));
  oList.add(TFHIRProperty.create(self, 'total', 'Money', false, TFhirMoney, FTotal.Link));
end;

function TFhirClaim.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'identifier') then
  begin
    IdentifierList.add(propValue as TFhirIdentifier);
    result := propValue;
  end
  else if (propName = 'status') then
  begin
    StatusElement := asEnum(SYSTEMS_TFhirFinancialResourceStatusCodesEnum, CODES_TFhirFinancialResourceStatusCodesEnum, propValue);
    result := propValue;
  end
  else if (propName = 'type') then
  begin
    Type_ := propValue as TFhirCodeableConcept;
    result := propValue;
  end
  else if (propName = 'subType') then
  begin
    SubType := propValue as TFhirCodeableConcept;
    result := propValue;
  end
  else if (propName = 'use') then
  begin
    UseElement := asEnum(SYSTEMS_TFhirUseEnum, CODES_TFhirUseEnum, propValue);
    result := propValue;
  end
  else if (propName = 'patient') then
  begin
    Patient := propValue as TFhirReference;
    result := propValue;
  end
  else if (propName = 'billablePeriod') then
  begin
    BillablePeriod := propValue as TFhirPeriod;
    result := propValue;
  end
  else if (propName = 'created') then
  begin
    CreatedElement := asDateTime(propValue);
    result := propValue;
  end
  else if (propName = 'enterer') then
  begin
    Enterer := propValue as TFhirReference;
    result := propValue;
  end
  else if (propName = 'insurer') then
  begin
    Insurer := propValue as TFhirReference;
    result := propValue;
  end
  else if (propName = 'provider') then
  begin
    Provider := propValue as TFhirReference;
    result := propValue;
  end
  else if (propName = 'priority') then
  begin
    Priority := propValue as TFhirCodeableConcept;
    result := propValue;
  end
  else if (propName = 'fundsReserve') then
  begin
    FundsReserve := propValue as TFhirCodeableConcept;
    result := propValue;
  end
  else if (propName = 'related') then
  begin
    RelatedList.add(propValue as TFhirClaimRelated);
    result := propValue;
  end
  else if (propName = 'prescription') then
  begin
    Prescription := propValue as TFhirReference;
    result := propValue;
  end
  else if (propName = 'originalPrescription') then
  begin
    OriginalPrescription := propValue as TFhirReference;
    result := propValue;
  end
  else if (propName = 'payee') then
  begin
    Payee := propValue as TFhirClaimPayee;
    result := propValue;
  end
  else if (propName = 'referral') then
  begin
    Referral := propValue as TFhirReference;
    result := propValue;
  end
  else if (propName = 'facility') then
  begin
    Facility := propValue as TFhirReference;
    result := propValue;
  end
  else if (propName = 'careTeam') then
  begin
    CareTeamList.add(propValue as TFhirClaimCareTeam);
    result := propValue;
  end
  else if (propName = 'supportingInfo') then
  begin
    SupportingInfoList.add(propValue as TFhirClaimSupportingInfo);
    result := propValue;
  end
  else if (propName = 'diagnosis') then
  begin
    DiagnosisList.add(propValue as TFhirClaimDiagnosis);
    result := propValue;
  end
  else if (propName = 'procedure') then
  begin
    Procedure_List.add(propValue as TFhirClaimProcedure);
    result := propValue;
  end
  else if (propName = 'insurance') then
  begin
    InsuranceList.add(propValue as TFhirClaimInsurance);
    result := propValue;
  end
  else if (propName = 'accident') then
  begin
    Accident := propValue as TFhirClaimAccident;
    result := propValue;
  end
  else if (propName = 'item') then
  begin
    ItemList.add(propValue as TFhirClaimItem);
    result := propValue;
  end
  else if (propName = 'total') then
  begin
    Total := propValue as TFhirMoney;
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirClaim.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'identifier') then IdentifierList.insertItem(index, propValue as TFhirIdentifier)
  else if (propName = 'related') then RelatedList.insertItem(index, propValue as TFhirClaimRelated)
  else if (propName = 'careTeam') then CareTeamList.insertItem(index, propValue as TFhirClaimCareTeam)
  else if (propName = 'supportingInfo') then SupportingInfoList.insertItem(index, propValue as TFhirClaimSupportingInfo)
  else if (propName = 'diagnosis') then DiagnosisList.insertItem(index, propValue as TFhirClaimDiagnosis)
  else if (propName = 'procedure') then Procedure_List.insertItem(index, propValue as TFhirClaimProcedure)
  else if (propName = 'insurance') then InsuranceList.insertItem(index, propValue as TFhirClaimInsurance)
  else if (propName = 'item') then ItemList.insertItem(index, propValue as TFhirClaimItem)
  else inherited;
end;

function TFhirClaim.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'identifier') then result := IdentifierList.new()
  else if (propName = 'status') then result := TFhirEnum.create(SYSTEMS_TFhirFinancialResourceStatusCodesEnum[FinancialResourceStatusCodesNull], CODES_TFhirFinancialResourceStatusCodesEnum[FinancialResourceStatusCodesNull]) 
  else if (propName = 'type') then result := TFhirCodeableConcept.create()
  else if (propName = 'subType') then result := TFhirCodeableConcept.create()
  else if (propName = 'use') then result := TFhirEnum.create(SYSTEMS_TFhirUseEnum[UseNull], CODES_TFhirUseEnum[UseNull]) 
  else if (propName = 'patient') then result := TFhirReference.create()
  else if (propName = 'billablePeriod') then result := TFhirPeriod.create()
  else if (propName = 'created') then result := TFhirDateTime.create()
  else if (propName = 'enterer') then result := TFhirReference.create()
  else if (propName = 'insurer') then result := TFhirReference.create()
  else if (propName = 'provider') then result := TFhirReference.create()
  else if (propName = 'priority') then result := TFhirCodeableConcept.create()
  else if (propName = 'fundsReserve') then result := TFhirCodeableConcept.create()
  else if (propName = 'related') then result := RelatedList.new()
  else if (propName = 'prescription') then result := TFhirReference.create()
  else if (propName = 'originalPrescription') then result := TFhirReference.create()
  else if (propName = 'payee') then result := TFhirClaimPayee.create()
  else if (propName = 'referral') then result := TFhirReference.create()
  else if (propName = 'facility') then result := TFhirReference.create()
  else if (propName = 'careTeam') then result := CareTeamList.new()
  else if (propName = 'supportingInfo') then result := SupportingInfoList.new()
  else if (propName = 'diagnosis') then result := DiagnosisList.new()
  else if (propName = 'procedure') then result := Procedure_List.new()
  else if (propName = 'insurance') then result := InsuranceList.new()
  else if (propName = 'accident') then result := TFhirClaimAccident.create()
  else if (propName = 'item') then result := ItemList.new()
  else if (propName = 'total') then result := TFhirMoney.create()
  else result := inherited createPropertyValue(propName);
end;

function TFhirClaim.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'identifier') then result := 'Identifier'
  else if (propName = 'status') then result := 'code'
  else if (propName = 'type') then result := 'CodeableConcept'
  else if (propName = 'subType') then result := 'CodeableConcept'
  else if (propName = 'use') then result := 'code'
  else if (propName = 'patient') then result := 'Reference'
  else if (propName = 'billablePeriod') then result := 'Period'
  else if (propName = 'created') then result := 'dateTime'
  else if (propName = 'enterer') then result := 'Reference'
  else if (propName = 'insurer') then result := 'Reference'
  else if (propName = 'provider') then result := 'Reference'
  else if (propName = 'priority') then result := 'CodeableConcept'
  else if (propName = 'fundsReserve') then result := 'CodeableConcept'
  else if (propName = 'related') then result := 'BackboneElement'
  else if (propName = 'prescription') then result := 'Reference'
  else if (propName = 'originalPrescription') then result := 'Reference'
  else if (propName = 'payee') then result := 'BackboneElement'
  else if (propName = 'referral') then result := 'Reference'
  else if (propName = 'facility') then result := 'Reference'
  else if (propName = 'careTeam') then result := 'BackboneElement'
  else if (propName = 'supportingInfo') then result := 'BackboneElement'
  else if (propName = 'diagnosis') then result := 'BackboneElement'
  else if (propName = 'procedure') then result := 'BackboneElement'
  else if (propName = 'insurance') then result := 'BackboneElement'
  else if (propName = 'accident') then result := 'BackboneElement'
  else if (propName = 'item') then result := 'BackboneElement'
  else if (propName = 'total') then result := 'Money'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirClaim.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'identifier') then deletePropertyValue('identifier', IdentifierList, value)
  else if (propName = 'status') then StatusElement := nil
  else if (propName = 'type') then Type_Element := nil
  else if (propName = 'subType') then SubTypeElement := nil
  else if (propName = 'use') then UseElement := nil
  else if (propName = 'patient') then PatientElement := nil
  else if (propName = 'billablePeriod') then BillablePeriodElement := nil
  else if (propName = 'created') then CreatedElement := nil
  else if (propName = 'enterer') then EntererElement := nil
  else if (propName = 'insurer') then InsurerElement := nil
  else if (propName = 'provider') then ProviderElement := nil
  else if (propName = 'priority') then PriorityElement := nil
  else if (propName = 'fundsReserve') then FundsReserveElement := nil
  else if (propName = 'related') then deletePropertyValue('related', RelatedList, value)
  else if (propName = 'prescription') then PrescriptionElement := nil
  else if (propName = 'originalPrescription') then OriginalPrescriptionElement := nil
  else if (propName = 'payee') then PayeeElement := nil
  else if (propName = 'referral') then ReferralElement := nil
  else if (propName = 'facility') then FacilityElement := nil
  else if (propName = 'careTeam') then deletePropertyValue('careTeam', CareTeamList, value)
  else if (propName = 'supportingInfo') then deletePropertyValue('supportingInfo', SupportingInfoList, value)
  else if (propName = 'diagnosis') then deletePropertyValue('diagnosis', DiagnosisList, value)
  else if (propName = 'procedure') then deletePropertyValue('procedure', Procedure_List, value)
  else if (propName = 'insurance') then deletePropertyValue('insurance', InsuranceList, value)
  else if (propName = 'accident') then AccidentElement := nil
  else if (propName = 'item') then deletePropertyValue('item', ItemList, value)
  else if (propName = 'total') then TotalElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirClaim.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'identifier') then replacePropertyValue('identifier', IdentifierList, existing, new)
  else if (propName = 'status') then StatusElement := asEnum(SYSTEMS_TFhirFinancialResourceStatusCodesEnum, CODES_TFhirFinancialResourceStatusCodesEnum, new)
  else if (propName = 'type') then Type_Element := new as TFhirCodeableConcept
  else if (propName = 'subType') then SubTypeElement := new as TFhirCodeableConcept
  else if (propName = 'use') then UseElement := asEnum(SYSTEMS_TFhirUseEnum, CODES_TFhirUseEnum, new)
  else if (propName = 'patient') then PatientElement := new as TFhirReference
  else if (propName = 'billablePeriod') then BillablePeriodElement := new as TFhirPeriod
  else if (propName = 'created') then CreatedElement := asDateTime(new)
  else if (propName = 'enterer') then EntererElement := new as TFhirReference
  else if (propName = 'insurer') then InsurerElement := new as TFhirReference
  else if (propName = 'provider') then ProviderElement := new as TFhirReference
  else if (propName = 'priority') then PriorityElement := new as TFhirCodeableConcept
  else if (propName = 'fundsReserve') then FundsReserveElement := new as TFhirCodeableConcept
  else if (propName = 'related') then replacePropertyValue('related', RelatedList, existing, new)
  else if (propName = 'prescription') then PrescriptionElement := new as TFhirReference
  else if (propName = 'originalPrescription') then OriginalPrescriptionElement := new as TFhirReference
  else if (propName = 'payee') then PayeeElement := new as TFhirClaimPayee
  else if (propName = 'referral') then ReferralElement := new as TFhirReference
  else if (propName = 'facility') then FacilityElement := new as TFhirReference
  else if (propName = 'careTeam') then replacePropertyValue('careTeam', CareTeamList, existing, new)
  else if (propName = 'supportingInfo') then replacePropertyValue('supportingInfo', SupportingInfoList, existing, new)
  else if (propName = 'diagnosis') then replacePropertyValue('diagnosis', DiagnosisList, existing, new)
  else if (propName = 'procedure') then replacePropertyValue('procedure', Procedure_List, existing, new)
  else if (propName = 'insurance') then replacePropertyValue('insurance', InsuranceList, existing, new)
  else if (propName = 'accident') then AccidentElement := new as TFhirClaimAccident
  else if (propName = 'item') then replacePropertyValue('item', ItemList, existing, new)
  else if (propName = 'total') then TotalElement := new as TFhirMoney
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirClaim.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'identifier') then IdentifierList.move(source, destination)
  else if (propName = 'related') then RelatedList.move(source, destination)
  else if (propName = 'careTeam') then CareTeamList.move(source, destination)
  else if (propName = 'supportingInfo') then SupportingInfoList.move(source, destination)
  else if (propName = 'diagnosis') then DiagnosisList.move(source, destination)
  else if (propName = 'procedure') then Procedure_List.move(source, destination)
  else if (propName = 'insurance') then InsuranceList.move(source, destination)
  else if (propName = 'item') then ItemList.move(source, destination)
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirClaim.fhirType : string;
begin
  result := 'Claim';
end;

function TFhirClaim.Link : TFhirClaim;
begin
  result := TFhirClaim(inherited Link);
end;

function TFhirClaim.Clone : TFhirClaim;
begin
  result := TFhirClaim(inherited Clone);
end;

function TFhirClaim.equals(other : TObject) : boolean; 
var
  o : TFhirClaim;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirClaim)) then
    result := false
  else
  begin
    o := TFhirClaim(other);
    result := compareDeep(identifierList, o.identifierList, true) and compareDeep(statusElement, o.statusElement, true) and 
      compareDeep(type_Element, o.type_Element, true) and compareDeep(subTypeElement, o.subTypeElement, true) and 
      compareDeep(useElement, o.useElement, true) and compareDeep(patientElement, o.patientElement, true) and 
      compareDeep(billablePeriodElement, o.billablePeriodElement, true) and compareDeep(createdElement, o.createdElement, true) and 
      compareDeep(entererElement, o.entererElement, true) and compareDeep(insurerElement, o.insurerElement, true) and 
      compareDeep(providerElement, o.providerElement, true) and compareDeep(priorityElement, o.priorityElement, true) and 
      compareDeep(fundsReserveElement, o.fundsReserveElement, true) and compareDeep(relatedList, o.relatedList, true) and 
      compareDeep(prescriptionElement, o.prescriptionElement, true) and compareDeep(originalPrescriptionElement, o.originalPrescriptionElement, true) and 
      compareDeep(payeeElement, o.payeeElement, true) and compareDeep(referralElement, o.referralElement, true) and 
      compareDeep(facilityElement, o.facilityElement, true) and compareDeep(careTeamList, o.careTeamList, true) and 
      compareDeep(supportingInfoList, o.supportingInfoList, true) and compareDeep(diagnosisList, o.diagnosisList, true) and 
      compareDeep(procedure_List, o.procedure_List, true) and compareDeep(insuranceList, o.insuranceList, true) and 
      compareDeep(accidentElement, o.accidentElement, true) and compareDeep(itemList, o.itemList, true) and 
      compareDeep(totalElement, o.totalElement, true);
  end;
end;

function TFhirClaim.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FidentifierList) and isEmptyProp(FStatus) and isEmptyProp(FType_) and isEmptyProp(FSubType) and isEmptyProp(FUse) and isEmptyProp(FPatient) and isEmptyProp(FBillablePeriod) and isEmptyProp(FCreated) and isEmptyProp(FEnterer) and isEmptyProp(FInsurer) and isEmptyProp(FProvider) and isEmptyProp(FPriority) and isEmptyProp(FFundsReserve) and isEmptyProp(FrelatedList) and isEmptyProp(FPrescription) and isEmptyProp(FOriginalPrescription) and isEmptyProp(FPayee) and isEmptyProp(FReferral) and isEmptyProp(FFacility) and isEmptyProp(FcareTeamList) and isEmptyProp(FsupportingInfoList) and isEmptyProp(FdiagnosisList) and isEmptyProp(Fprocedure_List) and isEmptyProp(FinsuranceList) and isEmptyProp(FAccident) and isEmptyProp(FitemList) and isEmptyProp(FTotal);
end;

procedure TFhirClaim.listFieldsInOrder(fields : TStringList);
begin
  inherited listFieldsInOrder(fields);
  fields.add('identifier');
  fields.add('status');
  fields.add('type');
  fields.add('subType');
  fields.add('use');
  fields.add('patient');
  fields.add('billablePeriod');
  fields.add('created');
  fields.add('enterer');
  fields.add('insurer');
  fields.add('provider');
  fields.add('priority');
  fields.add('fundsReserve');
  fields.add('related');
  fields.add('prescription');
  fields.add('originalPrescription');
  fields.add('payee');
  fields.add('referral');
  fields.add('facility');
  fields.add('careTeam');
  fields.add('supportingInfo');
  fields.add('diagnosis');
  fields.add('procedure');
  fields.add('insurance');
  fields.add('accident');
  fields.add('item');
  fields.add('total');
end;

function TFhirClaim.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FIdentifierList.sizeInBytes(magic));
  inc(result, FRelatedList.sizeInBytes(magic));
  inc(result, FCareTeamList.sizeInBytes(magic));
  inc(result, FSupportingInfoList.sizeInBytes(magic));
  inc(result, FDiagnosisList.sizeInBytes(magic));
  inc(result, FProcedure_List.sizeInBytes(magic));
  inc(result, FInsuranceList.sizeInBytes(magic));
  inc(result, FItemList.sizeInBytes(magic));
end;

function TFhirClaim.GetIdentifierList : TFhirIdentifierList;
begin
  if FIdentifierList = nil then
    FIdentifierList := TFhirIdentifierList.Create;
  result := FIdentifierList;
end;

function TFhirClaim.GetHasIdentifierList : boolean;
begin
  result := (FIdentifierList <> nil) and (FIdentifierList.count > 0);
end;

procedure TFhirClaim.SetStatus(value : TFhirEnum);
begin
  FStatus.free;
  FStatus := value;
end;

function TFhirClaim.GetStatusST : TFhirFinancialResourceStatusCodesEnum;
begin
  if FStatus = nil then
    result := TFhirFinancialResourceStatusCodesEnum(0)
  else
    result := TFhirFinancialResourceStatusCodesEnum(StringArrayIndexOfSensitive(CODES_TFhirFinancialResourceStatusCodesEnum, FStatus.value));
end;

procedure TFhirClaim.SetStatusST(value : TFhirFinancialResourceStatusCodesEnum);
begin
  if ord(value) = 0 then
    StatusElement := nil
  else
    StatusElement := TFhirEnum.create(SYSTEMS_TFhirFinancialResourceStatusCodesEnum[value], CODES_TFhirFinancialResourceStatusCodesEnum[value]);
end;

procedure TFhirClaim.SetType_(value : TFhirCodeableConcept);
begin
  FType_.free;
  FType_ := value;
end;

procedure TFhirClaim.SetSubType(value : TFhirCodeableConcept);
begin
  FSubType.free;
  FSubType := value;
end;

procedure TFhirClaim.SetUse(value : TFhirEnum);
begin
  FUse.free;
  FUse := value;
end;

function TFhirClaim.GetUseST : TFhirUseEnum;
begin
  if FUse = nil then
    result := TFhirUseEnum(0)
  else
    result := TFhirUseEnum(StringArrayIndexOfSensitive(CODES_TFhirUseEnum, FUse.value));
end;

procedure TFhirClaim.SetUseST(value : TFhirUseEnum);
begin
  if ord(value) = 0 then
    UseElement := nil
  else
    UseElement := TFhirEnum.create(SYSTEMS_TFhirUseEnum[value], CODES_TFhirUseEnum[value]);
end;

procedure TFhirClaim.SetPatient(value : TFhirReference);
begin
  FPatient.free;
  FPatient := value;
end;

procedure TFhirClaim.SetBillablePeriod(value : TFhirPeriod);
begin
  FBillablePeriod.free;
  FBillablePeriod := value;
end;

procedure TFhirClaim.SetCreated(value : TFhirDateTime);
begin
  FCreated.free;
  FCreated := value;
end;

function TFhirClaim.GetCreatedST : TFslDateTime;
begin
  if FCreated = nil then
    result := TFslDateTime.makeNull
  else
    result := FCreated.value;
end;

procedure TFhirClaim.SetCreatedST(value : TFslDateTime);
begin
  if FCreated = nil then
    FCreated := TFhirDateTime.create;
  FCreated.value := value
end;

procedure TFhirClaim.SetEnterer(value : TFhirReference);
begin
  FEnterer.free;
  FEnterer := value;
end;

procedure TFhirClaim.SetInsurer(value : TFhirReference);
begin
  FInsurer.free;
  FInsurer := value;
end;

procedure TFhirClaim.SetProvider(value : TFhirReference);
begin
  FProvider.free;
  FProvider := value;
end;

procedure TFhirClaim.SetPriority(value : TFhirCodeableConcept);
begin
  FPriority.free;
  FPriority := value;
end;

procedure TFhirClaim.SetFundsReserve(value : TFhirCodeableConcept);
begin
  FFundsReserve.free;
  FFundsReserve := value;
end;

function TFhirClaim.GetRelatedList : TFhirClaimRelatedList;
begin
  if FRelatedList = nil then
    FRelatedList := TFhirClaimRelatedList.Create;
  result := FRelatedList;
end;

function TFhirClaim.GetHasRelatedList : boolean;
begin
  result := (FRelatedList <> nil) and (FRelatedList.count > 0);
end;

procedure TFhirClaim.SetPrescription(value : TFhirReference);
begin
  FPrescription.free;
  FPrescription := value;
end;

procedure TFhirClaim.SetOriginalPrescription(value : TFhirReference);
begin
  FOriginalPrescription.free;
  FOriginalPrescription := value;
end;

procedure TFhirClaim.SetPayee(value : TFhirClaimPayee);
begin
  FPayee.free;
  FPayee := value;
end;

procedure TFhirClaim.SetReferral(value : TFhirReference);
begin
  FReferral.free;
  FReferral := value;
end;

procedure TFhirClaim.SetFacility(value : TFhirReference);
begin
  FFacility.free;
  FFacility := value;
end;

function TFhirClaim.GetCareTeamList : TFhirClaimCareTeamList;
begin
  if FCareTeamList = nil then
    FCareTeamList := TFhirClaimCareTeamList.Create;
  result := FCareTeamList;
end;

function TFhirClaim.GetHasCareTeamList : boolean;
begin
  result := (FCareTeamList <> nil) and (FCareTeamList.count > 0);
end;

function TFhirClaim.GetSupportingInfoList : TFhirClaimSupportingInfoList;
begin
  if FSupportingInfoList = nil then
    FSupportingInfoList := TFhirClaimSupportingInfoList.Create;
  result := FSupportingInfoList;
end;

function TFhirClaim.GetHasSupportingInfoList : boolean;
begin
  result := (FSupportingInfoList <> nil) and (FSupportingInfoList.count > 0);
end;

function TFhirClaim.GetDiagnosisList : TFhirClaimDiagnosisList;
begin
  if FDiagnosisList = nil then
    FDiagnosisList := TFhirClaimDiagnosisList.Create;
  result := FDiagnosisList;
end;

function TFhirClaim.GetHasDiagnosisList : boolean;
begin
  result := (FDiagnosisList <> nil) and (FDiagnosisList.count > 0);
end;

function TFhirClaim.GetProcedure_List : TFhirClaimProcedureList;
begin
  if FProcedure_List = nil then
    FProcedure_List := TFhirClaimProcedureList.Create;
  result := FProcedure_List;
end;

function TFhirClaim.GetHasProcedure_List : boolean;
begin
  result := (FProcedure_List <> nil) and (FProcedure_List.count > 0);
end;

function TFhirClaim.GetInsuranceList : TFhirClaimInsuranceList;
begin
  if FInsuranceList = nil then
    FInsuranceList := TFhirClaimInsuranceList.Create;
  result := FInsuranceList;
end;

function TFhirClaim.GetHasInsuranceList : boolean;
begin
  result := (FInsuranceList <> nil) and (FInsuranceList.count > 0);
end;

procedure TFhirClaim.SetAccident(value : TFhirClaimAccident);
begin
  FAccident.free;
  FAccident := value;
end;

function TFhirClaim.GetItemList : TFhirClaimItemList;
begin
  if FItemList = nil then
    FItemList := TFhirClaimItemList.Create;
  result := FItemList;
end;

function TFhirClaim.GetHasItemList : boolean;
begin
  result := (FItemList <> nil) and (FItemList.count > 0);
end;

procedure TFhirClaim.SetTotal(value : TFhirMoney);
begin
  FTotal.free;
  FTotal := value;
end;

{ TFhirClaimListEnumerator }

constructor TFhirClaimListEnumerator.Create(list : TFhirClaimList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirClaimListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirClaimListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirClaimListEnumerator.GetCurrent : TFhirClaim;
begin
  Result := FList[FIndex];
end;

function TFhirClaimListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirClaimList }

procedure TFhirClaimList.AddItem(value: TFhirClaim);
begin
  assert(value.ClassName = 'TFhirClaim', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirClaim');
  add(value);
end;

function TFhirClaimList.Append: TFhirClaim;
begin
  result := TFhirClaim.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirClaimList.ClearItems;
begin
  Clear;
end;

function TFhirClaimList.GetEnumerator : TFhirClaimListEnumerator;
begin
  result := TFhirClaimListEnumerator.Create(self.link);
end;

function TFhirClaimList.Clone: TFhirClaimList;
begin
  result := TFhirClaimList(inherited Clone);
end;

function TFhirClaimList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirClaimList.GetItemN(index: Integer): TFhirClaim;
begin
  result := TFhirClaim(ObjectByIndex[index]);
end;

function TFhirClaimList.ItemClass: TFslObjectClass;
begin
  result := TFhirClaim;
end;
function TFhirClaimList.IndexOf(value: TFhirClaim): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirClaimList.Insert(index: Integer): TFhirClaim;
begin
  result := TFhirClaim.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirClaimList.InsertItem(index: Integer; value: TFhirClaim);
begin
  assert(value is TFhirClaim);
  Inherited Insert(index, value);
end;

function TFhirClaimList.Item(index: Integer): TFhirClaim;
begin
  result := TFhirClaim(ObjectByIndex[index]);
end;

function TFhirClaimList.Link: TFhirClaimList;
begin
  result := TFhirClaimList(inherited Link);
end;

procedure TFhirClaimList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirClaimList.SetItemByIndex(index: Integer; value: TFhirClaim);
begin
  assert(value is TFhirClaim);
  FhirClaims[index] := value;
end;

procedure TFhirClaimList.SetItemN(index: Integer; value: TFhirClaim);
begin
  assert(value is TFhirClaim);
  ObjectByIndex[index] := value;
end;

{$ENDIF FHIR_CLAIM}
{$IFDEF FHIR_CLAIMRESPONSE}
{ TFhirClaimResponseItem }

constructor TFhirClaimResponseItem.Create;
begin
  inherited;
end;

destructor TFhirClaimResponseItem.Destroy;
begin
  FItemSequence.free;
  FNoteNumberList.Free;
  FAdjudicationList.Free;
  FDetailList.Free;
  inherited;
end;

procedure TFhirClaimResponseItem.Assign(oSource : TFslObject);
begin
  inherited;
  itemSequenceElement := TFhirClaimResponseItem(oSource).itemSequenceElement.Clone;
  if (TFhirClaimResponseItem(oSource).FNoteNumberList = nil) then
  begin
    FNoteNumberList.free;
    FNoteNumberList := nil;
  end
  else
  begin
    if FNoteNumberList = nil then
      FNoteNumberList := TFhirPositiveIntList.Create;
    FNoteNumberList.Assign(TFhirClaimResponseItem(oSource).FNoteNumberList);
  end;
  if (TFhirClaimResponseItem(oSource).FAdjudicationList = nil) then
  begin
    FAdjudicationList.free;
    FAdjudicationList := nil;
  end
  else
  begin
    if FAdjudicationList = nil then
      FAdjudicationList := TFhirClaimResponseItemAdjudicationList.Create;
    FAdjudicationList.Assign(TFhirClaimResponseItem(oSource).FAdjudicationList);
  end;
  if (TFhirClaimResponseItem(oSource).FDetailList = nil) then
  begin
    FDetailList.free;
    FDetailList := nil;
  end
  else
  begin
    if FDetailList = nil then
      FDetailList := TFhirClaimResponseItemDetailList.Create;
    FDetailList.Assign(TFhirClaimResponseItem(oSource).FDetailList);
  end;
end;

procedure TFhirClaimResponseItem.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'itemSequence') Then
     list.add(self.link, 'itemSequence', FItemSequence.Link);
  if (child_name = 'noteNumber') Then
    list.addAll(self, 'noteNumber', FNoteNumberList);
  if (child_name = 'adjudication') Then
    list.addAll(self, 'adjudication', FAdjudicationList);
  if (child_name = 'detail') Then
    list.addAll(self, 'detail', FDetailList);
end;

procedure TFhirClaimResponseItem.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'itemSequence', 'positiveInt', false, TFhirPositiveInt, FItemSequence.Link));
  oList.add(TFHIRProperty.create(self, 'noteNumber', 'positiveInt', true, TFhirPositiveInt, FNoteNumberList.Link));
  oList.add(TFHIRProperty.create(self, 'adjudication', 'BackboneElement', true, TFhirClaimResponseItemAdjudication, FAdjudicationList.Link));
  oList.add(TFHIRProperty.create(self, 'detail', 'BackboneElement', true, TFhirClaimResponseItemDetail, FDetailList.Link));
end;

function TFhirClaimResponseItem.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'itemSequence') then
  begin
    ItemSequenceElement := asPositiveInt(propValue);
    result := propValue;
  end
  else if (propName = 'noteNumber') then
  begin
    NoteNumberList.add(asPositiveInt(propValue)){2};     result := propValue;

  end
  else if (propName = 'adjudication') then
  begin
    AdjudicationList.add(propValue as TFhirClaimResponseItemAdjudication);
    result := propValue;
  end
  else if (propName = 'detail') then
  begin
    DetailList.add(propValue as TFhirClaimResponseItemDetail);
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirClaimResponseItem.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'noteNumber') then NoteNumberList.insertItem(index, asPositiveInt(propValue))
  else if (propName = 'adjudication') then AdjudicationList.insertItem(index, propValue as TFhirClaimResponseItemAdjudication)
  else if (propName = 'detail') then DetailList.insertItem(index, propValue as TFhirClaimResponseItemDetail)
  else inherited;
end;

function TFhirClaimResponseItem.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'itemSequence') then result := TFhirPositiveInt.create()
  else if (propName = 'noteNumber') then result := NoteNumberList.new()
  else if (propName = 'adjudication') then result := AdjudicationList.new()
  else if (propName = 'detail') then result := DetailList.new()
  else result := inherited createPropertyValue(propName);
end;

function TFhirClaimResponseItem.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'itemSequence') then result := 'positiveInt'
  else if (propName = 'noteNumber') then result := 'positiveInt'
  else if (propName = 'adjudication') then result := 'BackboneElement'
  else if (propName = 'detail') then result := 'BackboneElement'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirClaimResponseItem.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'itemSequence') then ItemSequenceElement := nil
  else if (propName = 'noteNumber') then deletePropertyValue('noteNumber', NoteNumberList, value)
  else if (propName = 'adjudication') then deletePropertyValue('adjudication', AdjudicationList, value)
  else if (propName = 'detail') then deletePropertyValue('detail', DetailList, value)
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirClaimResponseItem.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'itemSequence') then ItemSequenceElement := asPositiveInt(new)
  else if (propName = 'noteNumber') then replacePropertyValue('noteNumber', NoteNumberList, existing, new)
  else if (propName = 'adjudication') then replacePropertyValue('adjudication', AdjudicationList, existing, new)
  else if (propName = 'detail') then replacePropertyValue('detail', DetailList, existing, new)
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirClaimResponseItem.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'noteNumber') then NoteNumberList.move(source, destination)
  else if (propName = 'adjudication') then AdjudicationList.move(source, destination)
  else if (propName = 'detail') then DetailList.move(source, destination)
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirClaimResponseItem.fhirType : string;
begin
  result := 'ClaimResponse.item';
end;

function TFhirClaimResponseItem.Link : TFhirClaimResponseItem;
begin
  result := TFhirClaimResponseItem(inherited Link);
end;

function TFhirClaimResponseItem.Clone : TFhirClaimResponseItem;
begin
  result := TFhirClaimResponseItem(inherited Clone);
end;

function TFhirClaimResponseItem.equals(other : TObject) : boolean; 
var
  o : TFhirClaimResponseItem;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirClaimResponseItem)) then
    result := false
  else
  begin
    o := TFhirClaimResponseItem(other);
    result := compareDeep(itemSequenceElement, o.itemSequenceElement, true) and 
      compareDeep(noteNumberList, o.noteNumberList, true) and compareDeep(adjudicationList, o.adjudicationList, true) and 
      compareDeep(detailList, o.detailList, true);
  end;
end;

function TFhirClaimResponseItem.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FItemSequence) and isEmptyProp(FnoteNumberList) and isEmptyProp(FadjudicationList) and isEmptyProp(FdetailList);
end;

procedure TFhirClaimResponseItem.listFieldsInOrder(fields : TStringList);
begin
  inherited listFieldsInOrder(fields);
  fields.add('itemSequence');
  fields.add('noteNumber');
  fields.add('adjudication');
  fields.add('detail');
end;

function TFhirClaimResponseItem.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FNoteNumberList.sizeInBytes(magic));
  inc(result, FAdjudicationList.sizeInBytes(magic));
  inc(result, FDetailList.sizeInBytes(magic));
end;

procedure TFhirClaimResponseItem.SetItemSequence(value : TFhirPositiveInt);
begin
  FItemSequence.free;
  FItemSequence := value;
end;

function TFhirClaimResponseItem.GetItemSequenceST : String;
begin
  if FItemSequence = nil then
    result := ''
  else
    result := FItemSequence.value;
end;

procedure TFhirClaimResponseItem.SetItemSequenceST(value : String);
begin
  if value <> '' then
  begin
    if FItemSequence = nil then
      FItemSequence := TFhirPositiveInt.create;
    FItemSequence.value := value
  end
  else if FItemSequence <> nil then
    FItemSequence.value := '';
end;

function TFhirClaimResponseItem.GetNoteNumberList : TFhirPositiveIntList;
begin
  if FNoteNumberList = nil then
    FNoteNumberList := TFhirPositiveIntList.Create;
  result := FNoteNumberList;
end;

function TFhirClaimResponseItem.GetHasNoteNumberList : boolean;
begin
  result := (FNoteNumberList <> nil) and (FNoteNumberList.count > 0);
end;

function TFhirClaimResponseItem.GetAdjudicationList : TFhirClaimResponseItemAdjudicationList;
begin
  if FAdjudicationList = nil then
    FAdjudicationList := TFhirClaimResponseItemAdjudicationList.Create;
  result := FAdjudicationList;
end;

function TFhirClaimResponseItem.GetHasAdjudicationList : boolean;
begin
  result := (FAdjudicationList <> nil) and (FAdjudicationList.count > 0);
end;

function TFhirClaimResponseItem.GetDetailList : TFhirClaimResponseItemDetailList;
begin
  if FDetailList = nil then
    FDetailList := TFhirClaimResponseItemDetailList.Create;
  result := FDetailList;
end;

function TFhirClaimResponseItem.GetHasDetailList : boolean;
begin
  result := (FDetailList <> nil) and (FDetailList.count > 0);
end;

{ TFhirClaimResponseItemListEnumerator }

constructor TFhirClaimResponseItemListEnumerator.Create(list : TFhirClaimResponseItemList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirClaimResponseItemListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirClaimResponseItemListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirClaimResponseItemListEnumerator.GetCurrent : TFhirClaimResponseItem;
begin
  Result := FList[FIndex];
end;

function TFhirClaimResponseItemListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirClaimResponseItemList }

procedure TFhirClaimResponseItemList.AddItem(value: TFhirClaimResponseItem);
begin
  assert(value.ClassName = 'TFhirClaimResponseItem', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirClaimResponseItem');
  add(value);
end;

function TFhirClaimResponseItemList.Append: TFhirClaimResponseItem;
begin
  result := TFhirClaimResponseItem.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirClaimResponseItemList.ClearItems;
begin
  Clear;
end;

function TFhirClaimResponseItemList.GetEnumerator : TFhirClaimResponseItemListEnumerator;
begin
  result := TFhirClaimResponseItemListEnumerator.Create(self.link);
end;

function TFhirClaimResponseItemList.Clone: TFhirClaimResponseItemList;
begin
  result := TFhirClaimResponseItemList(inherited Clone);
end;

function TFhirClaimResponseItemList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirClaimResponseItemList.GetItemN(index: Integer): TFhirClaimResponseItem;
begin
  result := TFhirClaimResponseItem(ObjectByIndex[index]);
end;

function TFhirClaimResponseItemList.ItemClass: TFslObjectClass;
begin
  result := TFhirClaimResponseItem;
end;
function TFhirClaimResponseItemList.IndexOf(value: TFhirClaimResponseItem): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirClaimResponseItemList.Insert(index: Integer): TFhirClaimResponseItem;
begin
  result := TFhirClaimResponseItem.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirClaimResponseItemList.InsertItem(index: Integer; value: TFhirClaimResponseItem);
begin
  assert(value is TFhirClaimResponseItem);
  Inherited Insert(index, value);
end;

function TFhirClaimResponseItemList.Item(index: Integer): TFhirClaimResponseItem;
begin
  result := TFhirClaimResponseItem(ObjectByIndex[index]);
end;

function TFhirClaimResponseItemList.Link: TFhirClaimResponseItemList;
begin
  result := TFhirClaimResponseItemList(inherited Link);
end;

procedure TFhirClaimResponseItemList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirClaimResponseItemList.SetItemByIndex(index: Integer; value: TFhirClaimResponseItem);
begin
  assert(value is TFhirClaimResponseItem);
  FhirClaimResponseItems[index] := value;
end;

procedure TFhirClaimResponseItemList.SetItemN(index: Integer; value: TFhirClaimResponseItem);
begin
  assert(value is TFhirClaimResponseItem);
  ObjectByIndex[index] := value;
end;

{ TFhirClaimResponseItemAdjudication }

constructor TFhirClaimResponseItemAdjudication.Create;
begin
  inherited;
end;

destructor TFhirClaimResponseItemAdjudication.Destroy;
begin
  FCategory.free;
  FReason.free;
  FAmount.free;
  FValue.free;
  inherited;
end;

procedure TFhirClaimResponseItemAdjudication.Assign(oSource : TFslObject);
begin
  inherited;
  category := TFhirClaimResponseItemAdjudication(oSource).category.Clone;
  reason := TFhirClaimResponseItemAdjudication(oSource).reason.Clone;
  amount := TFhirClaimResponseItemAdjudication(oSource).amount.Clone;
  valueElement := TFhirClaimResponseItemAdjudication(oSource).valueElement.Clone;
end;

procedure TFhirClaimResponseItemAdjudication.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'category') Then
     list.add(self.link, 'category', FCategory.Link);
  if (child_name = 'reason') Then
     list.add(self.link, 'reason', FReason.Link);
  if (child_name = 'amount') Then
     list.add(self.link, 'amount', FAmount.Link);
  if (child_name = 'value') Then
     list.add(self.link, 'value', FValue.Link);
end;

procedure TFhirClaimResponseItemAdjudication.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'category', 'CodeableConcept', false, TFhirCodeableConcept, FCategory.Link));
  oList.add(TFHIRProperty.create(self, 'reason', 'CodeableConcept', false, TFhirCodeableConcept, FReason.Link));
  oList.add(TFHIRProperty.create(self, 'amount', 'Money', false, TFhirMoney, FAmount.Link));
  oList.add(TFHIRProperty.create(self, 'value', 'decimal', false, TFhirDecimal, FValue.Link));
end;

function TFhirClaimResponseItemAdjudication.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'category') then
  begin
    Category := propValue as TFhirCodeableConcept;
    result := propValue;
  end
  else if (propName = 'reason') then
  begin
    Reason := propValue as TFhirCodeableConcept;
    result := propValue;
  end
  else if (propName = 'amount') then
  begin
    Amount := propValue as TFhirMoney;
    result := propValue;
  end
  else if (propName = 'value') then
  begin
    ValueElement := asDecimal(propValue);
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirClaimResponseItemAdjudication.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirClaimResponseItemAdjudication.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'category') then result := TFhirCodeableConcept.create()
  else if (propName = 'reason') then result := TFhirCodeableConcept.create()
  else if (propName = 'amount') then result := TFhirMoney.create()
  else if (propName = 'value') then result := TFhirDecimal.create()
  else result := inherited createPropertyValue(propName);
end;

function TFhirClaimResponseItemAdjudication.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'category') then result := 'CodeableConcept'
  else if (propName = 'reason') then result := 'CodeableConcept'
  else if (propName = 'amount') then result := 'Money'
  else if (propName = 'value') then result := 'decimal'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirClaimResponseItemAdjudication.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'category') then CategoryElement := nil
  else if (propName = 'reason') then ReasonElement := nil
  else if (propName = 'amount') then AmountElement := nil
  else if (propName = 'value') then ValueElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirClaimResponseItemAdjudication.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'category') then CategoryElement := new as TFhirCodeableConcept
  else if (propName = 'reason') then ReasonElement := new as TFhirCodeableConcept
  else if (propName = 'amount') then AmountElement := new as TFhirMoney
  else if (propName = 'value') then ValueElement := asDecimal(new)
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirClaimResponseItemAdjudication.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirClaimResponseItemAdjudication.fhirType : string;
begin
  result := 'ClaimResponse.item.adjudication';
end;

function TFhirClaimResponseItemAdjudication.Link : TFhirClaimResponseItemAdjudication;
begin
  result := TFhirClaimResponseItemAdjudication(inherited Link);
end;

function TFhirClaimResponseItemAdjudication.Clone : TFhirClaimResponseItemAdjudication;
begin
  result := TFhirClaimResponseItemAdjudication(inherited Clone);
end;

function TFhirClaimResponseItemAdjudication.equals(other : TObject) : boolean; 
var
  o : TFhirClaimResponseItemAdjudication;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirClaimResponseItemAdjudication)) then
    result := false
  else
  begin
    o := TFhirClaimResponseItemAdjudication(other);
    result := compareDeep(categoryElement, o.categoryElement, true) and compareDeep(reasonElement, o.reasonElement, true) and 
      compareDeep(amountElement, o.amountElement, true) and compareDeep(valueElement, o.valueElement, true);
  end;
end;

function TFhirClaimResponseItemAdjudication.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FCategory) and isEmptyProp(FReason) and isEmptyProp(FAmount) and isEmptyProp(FValue);
end;

procedure TFhirClaimResponseItemAdjudication.listFieldsInOrder(fields : TStringList);
begin
  inherited listFieldsInOrder(fields);
  fields.add('category');
  fields.add('reason');
  fields.add('amount');
  fields.add('value');
end;

function TFhirClaimResponseItemAdjudication.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
end;

procedure TFhirClaimResponseItemAdjudication.SetCategory(value : TFhirCodeableConcept);
begin
  FCategory.free;
  FCategory := value;
end;

procedure TFhirClaimResponseItemAdjudication.SetReason(value : TFhirCodeableConcept);
begin
  FReason.free;
  FReason := value;
end;

procedure TFhirClaimResponseItemAdjudication.SetAmount(value : TFhirMoney);
begin
  FAmount.free;
  FAmount := value;
end;

procedure TFhirClaimResponseItemAdjudication.SetValue(value : TFhirDecimal);
begin
  FValue.free;
  FValue := value;
end;

function TFhirClaimResponseItemAdjudication.GetValueST : String;
begin
  if FValue = nil then
    result := ''
  else
    result := FValue.value;
end;

procedure TFhirClaimResponseItemAdjudication.SetValueST(value : String);
begin
  if value <> '' then
  begin
    if FValue = nil then
      FValue := TFhirDecimal.create;
    FValue.value := value
  end
  else if FValue <> nil then
    FValue.value := '';
end;

{ TFhirClaimResponseItemAdjudicationListEnumerator }

constructor TFhirClaimResponseItemAdjudicationListEnumerator.Create(list : TFhirClaimResponseItemAdjudicationList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirClaimResponseItemAdjudicationListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirClaimResponseItemAdjudicationListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirClaimResponseItemAdjudicationListEnumerator.GetCurrent : TFhirClaimResponseItemAdjudication;
begin
  Result := FList[FIndex];
end;

function TFhirClaimResponseItemAdjudicationListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirClaimResponseItemAdjudicationList }

procedure TFhirClaimResponseItemAdjudicationList.AddItem(value: TFhirClaimResponseItemAdjudication);
begin
  assert(value.ClassName = 'TFhirClaimResponseItemAdjudication', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirClaimResponseItemAdjudication');
  add(value);
end;

function TFhirClaimResponseItemAdjudicationList.Append: TFhirClaimResponseItemAdjudication;
begin
  result := TFhirClaimResponseItemAdjudication.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirClaimResponseItemAdjudicationList.ClearItems;
begin
  Clear;
end;

function TFhirClaimResponseItemAdjudicationList.GetEnumerator : TFhirClaimResponseItemAdjudicationListEnumerator;
begin
  result := TFhirClaimResponseItemAdjudicationListEnumerator.Create(self.link);
end;

function TFhirClaimResponseItemAdjudicationList.Clone: TFhirClaimResponseItemAdjudicationList;
begin
  result := TFhirClaimResponseItemAdjudicationList(inherited Clone);
end;

function TFhirClaimResponseItemAdjudicationList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirClaimResponseItemAdjudicationList.GetItemN(index: Integer): TFhirClaimResponseItemAdjudication;
begin
  result := TFhirClaimResponseItemAdjudication(ObjectByIndex[index]);
end;

function TFhirClaimResponseItemAdjudicationList.ItemClass: TFslObjectClass;
begin
  result := TFhirClaimResponseItemAdjudication;
end;
function TFhirClaimResponseItemAdjudicationList.IndexOf(value: TFhirClaimResponseItemAdjudication): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirClaimResponseItemAdjudicationList.Insert(index: Integer): TFhirClaimResponseItemAdjudication;
begin
  result := TFhirClaimResponseItemAdjudication.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirClaimResponseItemAdjudicationList.InsertItem(index: Integer; value: TFhirClaimResponseItemAdjudication);
begin
  assert(value is TFhirClaimResponseItemAdjudication);
  Inherited Insert(index, value);
end;

function TFhirClaimResponseItemAdjudicationList.Item(index: Integer): TFhirClaimResponseItemAdjudication;
begin
  result := TFhirClaimResponseItemAdjudication(ObjectByIndex[index]);
end;

function TFhirClaimResponseItemAdjudicationList.Link: TFhirClaimResponseItemAdjudicationList;
begin
  result := TFhirClaimResponseItemAdjudicationList(inherited Link);
end;

procedure TFhirClaimResponseItemAdjudicationList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirClaimResponseItemAdjudicationList.SetItemByIndex(index: Integer; value: TFhirClaimResponseItemAdjudication);
begin
  assert(value is TFhirClaimResponseItemAdjudication);
  FhirClaimResponseItemAdjudications[index] := value;
end;

procedure TFhirClaimResponseItemAdjudicationList.SetItemN(index: Integer; value: TFhirClaimResponseItemAdjudication);
begin
  assert(value is TFhirClaimResponseItemAdjudication);
  ObjectByIndex[index] := value;
end;

{ TFhirClaimResponseItemDetail }

constructor TFhirClaimResponseItemDetail.Create;
begin
  inherited;
end;

destructor TFhirClaimResponseItemDetail.Destroy;
begin
  FDetailSequence.free;
  FNoteNumberList.Free;
  FAdjudicationList.Free;
  FSubDetailList.Free;
  inherited;
end;

procedure TFhirClaimResponseItemDetail.Assign(oSource : TFslObject);
begin
  inherited;
  detailSequenceElement := TFhirClaimResponseItemDetail(oSource).detailSequenceElement.Clone;
  if (TFhirClaimResponseItemDetail(oSource).FNoteNumberList = nil) then
  begin
    FNoteNumberList.free;
    FNoteNumberList := nil;
  end
  else
  begin
    if FNoteNumberList = nil then
      FNoteNumberList := TFhirPositiveIntList.Create;
    FNoteNumberList.Assign(TFhirClaimResponseItemDetail(oSource).FNoteNumberList);
  end;
  if (TFhirClaimResponseItemDetail(oSource).FAdjudicationList = nil) then
  begin
    FAdjudicationList.free;
    FAdjudicationList := nil;
  end
  else
  begin
    if FAdjudicationList = nil then
      FAdjudicationList := TFhirClaimResponseItemAdjudicationList.Create;
    FAdjudicationList.Assign(TFhirClaimResponseItemDetail(oSource).FAdjudicationList);
  end;
  if (TFhirClaimResponseItemDetail(oSource).FSubDetailList = nil) then
  begin
    FSubDetailList.free;
    FSubDetailList := nil;
  end
  else
  begin
    if FSubDetailList = nil then
      FSubDetailList := TFhirClaimResponseItemDetailSubDetailList.Create;
    FSubDetailList.Assign(TFhirClaimResponseItemDetail(oSource).FSubDetailList);
  end;
end;

procedure TFhirClaimResponseItemDetail.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'detailSequence') Then
     list.add(self.link, 'detailSequence', FDetailSequence.Link);
  if (child_name = 'noteNumber') Then
    list.addAll(self, 'noteNumber', FNoteNumberList);
  if (child_name = 'adjudication') Then
    list.addAll(self, 'adjudication', FAdjudicationList);
  if (child_name = 'subDetail') Then
    list.addAll(self, 'subDetail', FSubDetailList);
end;

procedure TFhirClaimResponseItemDetail.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'detailSequence', 'positiveInt', false, TFhirPositiveInt, FDetailSequence.Link));
  oList.add(TFHIRProperty.create(self, 'noteNumber', 'positiveInt', true, TFhirPositiveInt, FNoteNumberList.Link));
  oList.add(TFHIRProperty.create(self, 'adjudication', '', true, TFhirClaimResponseItemAdjudication, FAdjudicationList.Link));
  oList.add(TFHIRProperty.create(self, 'subDetail', 'BackboneElement', true, TFhirClaimResponseItemDetailSubDetail, FSubDetailList.Link));
end;

function TFhirClaimResponseItemDetail.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'detailSequence') then
  begin
    DetailSequenceElement := asPositiveInt(propValue);
    result := propValue;
  end
  else if (propName = 'noteNumber') then
  begin
    NoteNumberList.add(asPositiveInt(propValue)){2};     result := propValue;

  end
  else if (propName = 'adjudication') then
  begin
    AdjudicationList.add(propValue as TFhirClaimResponseItemAdjudication);
    result := propValue;
  end
  else if (propName = 'subDetail') then
  begin
    SubDetailList.add(propValue as TFhirClaimResponseItemDetailSubDetail);
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirClaimResponseItemDetail.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'noteNumber') then NoteNumberList.insertItem(index, asPositiveInt(propValue))
  else if (propName = 'adjudication') then AdjudicationList.insertItem(index, propValue as TFhirClaimResponseItemAdjudication)
  else if (propName = 'subDetail') then SubDetailList.insertItem(index, propValue as TFhirClaimResponseItemDetailSubDetail)
  else inherited;
end;

function TFhirClaimResponseItemDetail.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'detailSequence') then result := TFhirPositiveInt.create()
  else if (propName = 'noteNumber') then result := NoteNumberList.new()
  else if (propName = 'adjudication') then result := AdjudicationList.new()
  else if (propName = 'subDetail') then result := SubDetailList.new()
  else result := inherited createPropertyValue(propName);
end;

function TFhirClaimResponseItemDetail.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'detailSequence') then result := 'positiveInt'
  else if (propName = 'noteNumber') then result := 'positiveInt'
  else if (propName = 'adjudication') then result := ''
  else if (propName = 'subDetail') then result := 'BackboneElement'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirClaimResponseItemDetail.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'detailSequence') then DetailSequenceElement := nil
  else if (propName = 'noteNumber') then deletePropertyValue('noteNumber', NoteNumberList, value)
  else if (propName = 'adjudication') then deletePropertyValue('adjudication', AdjudicationList, value)
  else if (propName = 'subDetail') then deletePropertyValue('subDetail', SubDetailList, value)
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirClaimResponseItemDetail.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'detailSequence') then DetailSequenceElement := asPositiveInt(new)
  else if (propName = 'noteNumber') then replacePropertyValue('noteNumber', NoteNumberList, existing, new)
  else if (propName = 'adjudication') then replacePropertyValue('adjudication', AdjudicationList, existing, new)
  else if (propName = 'subDetail') then replacePropertyValue('subDetail', SubDetailList, existing, new)
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirClaimResponseItemDetail.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'noteNumber') then NoteNumberList.move(source, destination)
  else if (propName = 'adjudication') then AdjudicationList.move(source, destination)
  else if (propName = 'subDetail') then SubDetailList.move(source, destination)
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirClaimResponseItemDetail.fhirType : string;
begin
  result := 'ClaimResponse.item.detail';
end;

function TFhirClaimResponseItemDetail.Link : TFhirClaimResponseItemDetail;
begin
  result := TFhirClaimResponseItemDetail(inherited Link);
end;

function TFhirClaimResponseItemDetail.Clone : TFhirClaimResponseItemDetail;
begin
  result := TFhirClaimResponseItemDetail(inherited Clone);
end;

function TFhirClaimResponseItemDetail.equals(other : TObject) : boolean; 
var
  o : TFhirClaimResponseItemDetail;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirClaimResponseItemDetail)) then
    result := false
  else
  begin
    o := TFhirClaimResponseItemDetail(other);
    result := compareDeep(detailSequenceElement, o.detailSequenceElement, true) and 
      compareDeep(noteNumberList, o.noteNumberList, true) and compareDeep(adjudicationList, o.adjudicationList, true) and 
      compareDeep(subDetailList, o.subDetailList, true);
  end;
end;

function TFhirClaimResponseItemDetail.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FDetailSequence) and isEmptyProp(FnoteNumberList) and isEmptyProp(FadjudicationList) and isEmptyProp(FsubDetailList);
end;

procedure TFhirClaimResponseItemDetail.listFieldsInOrder(fields : TStringList);
begin
  inherited listFieldsInOrder(fields);
  fields.add('detailSequence');
  fields.add('noteNumber');
  fields.add('adjudication');
  fields.add('subDetail');
end;

function TFhirClaimResponseItemDetail.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FNoteNumberList.sizeInBytes(magic));
  inc(result, FAdjudicationList.sizeInBytes(magic));
  inc(result, FSubDetailList.sizeInBytes(magic));
end;

procedure TFhirClaimResponseItemDetail.SetDetailSequence(value : TFhirPositiveInt);
begin
  FDetailSequence.free;
  FDetailSequence := value;
end;

function TFhirClaimResponseItemDetail.GetDetailSequenceST : String;
begin
  if FDetailSequence = nil then
    result := ''
  else
    result := FDetailSequence.value;
end;

procedure TFhirClaimResponseItemDetail.SetDetailSequenceST(value : String);
begin
  if value <> '' then
  begin
    if FDetailSequence = nil then
      FDetailSequence := TFhirPositiveInt.create;
    FDetailSequence.value := value
  end
  else if FDetailSequence <> nil then
    FDetailSequence.value := '';
end;

function TFhirClaimResponseItemDetail.GetNoteNumberList : TFhirPositiveIntList;
begin
  if FNoteNumberList = nil then
    FNoteNumberList := TFhirPositiveIntList.Create;
  result := FNoteNumberList;
end;

function TFhirClaimResponseItemDetail.GetHasNoteNumberList : boolean;
begin
  result := (FNoteNumberList <> nil) and (FNoteNumberList.count > 0);
end;

function TFhirClaimResponseItemDetail.GetAdjudicationList : TFhirClaimResponseItemAdjudicationList;
begin
  if FAdjudicationList = nil then
    FAdjudicationList := TFhirClaimResponseItemAdjudicationList.Create;
  result := FAdjudicationList;
end;

function TFhirClaimResponseItemDetail.GetHasAdjudicationList : boolean;
begin
  result := (FAdjudicationList <> nil) and (FAdjudicationList.count > 0);
end;

function TFhirClaimResponseItemDetail.GetSubDetailList : TFhirClaimResponseItemDetailSubDetailList;
begin
  if FSubDetailList = nil then
    FSubDetailList := TFhirClaimResponseItemDetailSubDetailList.Create;
  result := FSubDetailList;
end;

function TFhirClaimResponseItemDetail.GetHasSubDetailList : boolean;
begin
  result := (FSubDetailList <> nil) and (FSubDetailList.count > 0);
end;

{ TFhirClaimResponseItemDetailListEnumerator }

constructor TFhirClaimResponseItemDetailListEnumerator.Create(list : TFhirClaimResponseItemDetailList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirClaimResponseItemDetailListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirClaimResponseItemDetailListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirClaimResponseItemDetailListEnumerator.GetCurrent : TFhirClaimResponseItemDetail;
begin
  Result := FList[FIndex];
end;

function TFhirClaimResponseItemDetailListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirClaimResponseItemDetailList }

procedure TFhirClaimResponseItemDetailList.AddItem(value: TFhirClaimResponseItemDetail);
begin
  assert(value.ClassName = 'TFhirClaimResponseItemDetail', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirClaimResponseItemDetail');
  add(value);
end;

function TFhirClaimResponseItemDetailList.Append: TFhirClaimResponseItemDetail;
begin
  result := TFhirClaimResponseItemDetail.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirClaimResponseItemDetailList.ClearItems;
begin
  Clear;
end;

function TFhirClaimResponseItemDetailList.GetEnumerator : TFhirClaimResponseItemDetailListEnumerator;
begin
  result := TFhirClaimResponseItemDetailListEnumerator.Create(self.link);
end;

function TFhirClaimResponseItemDetailList.Clone: TFhirClaimResponseItemDetailList;
begin
  result := TFhirClaimResponseItemDetailList(inherited Clone);
end;

function TFhirClaimResponseItemDetailList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirClaimResponseItemDetailList.GetItemN(index: Integer): TFhirClaimResponseItemDetail;
begin
  result := TFhirClaimResponseItemDetail(ObjectByIndex[index]);
end;

function TFhirClaimResponseItemDetailList.ItemClass: TFslObjectClass;
begin
  result := TFhirClaimResponseItemDetail;
end;
function TFhirClaimResponseItemDetailList.IndexOf(value: TFhirClaimResponseItemDetail): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirClaimResponseItemDetailList.Insert(index: Integer): TFhirClaimResponseItemDetail;
begin
  result := TFhirClaimResponseItemDetail.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirClaimResponseItemDetailList.InsertItem(index: Integer; value: TFhirClaimResponseItemDetail);
begin
  assert(value is TFhirClaimResponseItemDetail);
  Inherited Insert(index, value);
end;

function TFhirClaimResponseItemDetailList.Item(index: Integer): TFhirClaimResponseItemDetail;
begin
  result := TFhirClaimResponseItemDetail(ObjectByIndex[index]);
end;

function TFhirClaimResponseItemDetailList.Link: TFhirClaimResponseItemDetailList;
begin
  result := TFhirClaimResponseItemDetailList(inherited Link);
end;

procedure TFhirClaimResponseItemDetailList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirClaimResponseItemDetailList.SetItemByIndex(index: Integer; value: TFhirClaimResponseItemDetail);
begin
  assert(value is TFhirClaimResponseItemDetail);
  FhirClaimResponseItemDetails[index] := value;
end;

procedure TFhirClaimResponseItemDetailList.SetItemN(index: Integer; value: TFhirClaimResponseItemDetail);
begin
  assert(value is TFhirClaimResponseItemDetail);
  ObjectByIndex[index] := value;
end;

{ TFhirClaimResponseItemDetailSubDetail }

constructor TFhirClaimResponseItemDetailSubDetail.Create;
begin
  inherited;
end;

destructor TFhirClaimResponseItemDetailSubDetail.Destroy;
begin
  FSubDetailSequence.free;
  FNoteNumberList.Free;
  FAdjudicationList.Free;
  inherited;
end;

procedure TFhirClaimResponseItemDetailSubDetail.Assign(oSource : TFslObject);
begin
  inherited;
  subDetailSequenceElement := TFhirClaimResponseItemDetailSubDetail(oSource).subDetailSequenceElement.Clone;
  if (TFhirClaimResponseItemDetailSubDetail(oSource).FNoteNumberList = nil) then
  begin
    FNoteNumberList.free;
    FNoteNumberList := nil;
  end
  else
  begin
    if FNoteNumberList = nil then
      FNoteNumberList := TFhirPositiveIntList.Create;
    FNoteNumberList.Assign(TFhirClaimResponseItemDetailSubDetail(oSource).FNoteNumberList);
  end;
  if (TFhirClaimResponseItemDetailSubDetail(oSource).FAdjudicationList = nil) then
  begin
    FAdjudicationList.free;
    FAdjudicationList := nil;
  end
  else
  begin
    if FAdjudicationList = nil then
      FAdjudicationList := TFhirClaimResponseItemAdjudicationList.Create;
    FAdjudicationList.Assign(TFhirClaimResponseItemDetailSubDetail(oSource).FAdjudicationList);
  end;
end;

procedure TFhirClaimResponseItemDetailSubDetail.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'subDetailSequence') Then
     list.add(self.link, 'subDetailSequence', FSubDetailSequence.Link);
  if (child_name = 'noteNumber') Then
    list.addAll(self, 'noteNumber', FNoteNumberList);
  if (child_name = 'adjudication') Then
    list.addAll(self, 'adjudication', FAdjudicationList);
end;

procedure TFhirClaimResponseItemDetailSubDetail.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'subDetailSequence', 'positiveInt', false, TFhirPositiveInt, FSubDetailSequence.Link));
  oList.add(TFHIRProperty.create(self, 'noteNumber', 'positiveInt', true, TFhirPositiveInt, FNoteNumberList.Link));
  oList.add(TFHIRProperty.create(self, 'adjudication', '', true, TFhirClaimResponseItemAdjudication, FAdjudicationList.Link));
end;

function TFhirClaimResponseItemDetailSubDetail.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'subDetailSequence') then
  begin
    SubDetailSequenceElement := asPositiveInt(propValue);
    result := propValue;
  end
  else if (propName = 'noteNumber') then
  begin
    NoteNumberList.add(asPositiveInt(propValue)){2};     result := propValue;

  end
  else if (propName = 'adjudication') then
  begin
    AdjudicationList.add(propValue as TFhirClaimResponseItemAdjudication);
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirClaimResponseItemDetailSubDetail.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'noteNumber') then NoteNumberList.insertItem(index, asPositiveInt(propValue))
  else if (propName = 'adjudication') then AdjudicationList.insertItem(index, propValue as TFhirClaimResponseItemAdjudication)
  else inherited;
end;

function TFhirClaimResponseItemDetailSubDetail.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'subDetailSequence') then result := TFhirPositiveInt.create()
  else if (propName = 'noteNumber') then result := NoteNumberList.new()
  else if (propName = 'adjudication') then result := AdjudicationList.new()
  else result := inherited createPropertyValue(propName);
end;

function TFhirClaimResponseItemDetailSubDetail.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'subDetailSequence') then result := 'positiveInt'
  else if (propName = 'noteNumber') then result := 'positiveInt'
  else if (propName = 'adjudication') then result := ''
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirClaimResponseItemDetailSubDetail.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'subDetailSequence') then SubDetailSequenceElement := nil
  else if (propName = 'noteNumber') then deletePropertyValue('noteNumber', NoteNumberList, value)
  else if (propName = 'adjudication') then deletePropertyValue('adjudication', AdjudicationList, value)
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirClaimResponseItemDetailSubDetail.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'subDetailSequence') then SubDetailSequenceElement := asPositiveInt(new)
  else if (propName = 'noteNumber') then replacePropertyValue('noteNumber', NoteNumberList, existing, new)
  else if (propName = 'adjudication') then replacePropertyValue('adjudication', AdjudicationList, existing, new)
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirClaimResponseItemDetailSubDetail.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'noteNumber') then NoteNumberList.move(source, destination)
  else if (propName = 'adjudication') then AdjudicationList.move(source, destination)
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirClaimResponseItemDetailSubDetail.fhirType : string;
begin
  result := 'ClaimResponse.item.detail.subDetail';
end;

function TFhirClaimResponseItemDetailSubDetail.Link : TFhirClaimResponseItemDetailSubDetail;
begin
  result := TFhirClaimResponseItemDetailSubDetail(inherited Link);
end;

function TFhirClaimResponseItemDetailSubDetail.Clone : TFhirClaimResponseItemDetailSubDetail;
begin
  result := TFhirClaimResponseItemDetailSubDetail(inherited Clone);
end;

function TFhirClaimResponseItemDetailSubDetail.equals(other : TObject) : boolean; 
var
  o : TFhirClaimResponseItemDetailSubDetail;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirClaimResponseItemDetailSubDetail)) then
    result := false
  else
  begin
    o := TFhirClaimResponseItemDetailSubDetail(other);
    result := compareDeep(subDetailSequenceElement, o.subDetailSequenceElement, true) and 
      compareDeep(noteNumberList, o.noteNumberList, true) and compareDeep(adjudicationList, o.adjudicationList, true);
  end;
end;

function TFhirClaimResponseItemDetailSubDetail.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FSubDetailSequence) and isEmptyProp(FnoteNumberList) and isEmptyProp(FadjudicationList);
end;

procedure TFhirClaimResponseItemDetailSubDetail.listFieldsInOrder(fields : TStringList);
begin
  inherited listFieldsInOrder(fields);
  fields.add('subDetailSequence');
  fields.add('noteNumber');
  fields.add('adjudication');
end;

function TFhirClaimResponseItemDetailSubDetail.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FNoteNumberList.sizeInBytes(magic));
  inc(result, FAdjudicationList.sizeInBytes(magic));
end;

procedure TFhirClaimResponseItemDetailSubDetail.SetSubDetailSequence(value : TFhirPositiveInt);
begin
  FSubDetailSequence.free;
  FSubDetailSequence := value;
end;

function TFhirClaimResponseItemDetailSubDetail.GetSubDetailSequenceST : String;
begin
  if FSubDetailSequence = nil then
    result := ''
  else
    result := FSubDetailSequence.value;
end;

procedure TFhirClaimResponseItemDetailSubDetail.SetSubDetailSequenceST(value : String);
begin
  if value <> '' then
  begin
    if FSubDetailSequence = nil then
      FSubDetailSequence := TFhirPositiveInt.create;
    FSubDetailSequence.value := value
  end
  else if FSubDetailSequence <> nil then
    FSubDetailSequence.value := '';
end;

function TFhirClaimResponseItemDetailSubDetail.GetNoteNumberList : TFhirPositiveIntList;
begin
  if FNoteNumberList = nil then
    FNoteNumberList := TFhirPositiveIntList.Create;
  result := FNoteNumberList;
end;

function TFhirClaimResponseItemDetailSubDetail.GetHasNoteNumberList : boolean;
begin
  result := (FNoteNumberList <> nil) and (FNoteNumberList.count > 0);
end;

function TFhirClaimResponseItemDetailSubDetail.GetAdjudicationList : TFhirClaimResponseItemAdjudicationList;
begin
  if FAdjudicationList = nil then
    FAdjudicationList := TFhirClaimResponseItemAdjudicationList.Create;
  result := FAdjudicationList;
end;

function TFhirClaimResponseItemDetailSubDetail.GetHasAdjudicationList : boolean;
begin
  result := (FAdjudicationList <> nil) and (FAdjudicationList.count > 0);
end;

{ TFhirClaimResponseItemDetailSubDetailListEnumerator }

constructor TFhirClaimResponseItemDetailSubDetailListEnumerator.Create(list : TFhirClaimResponseItemDetailSubDetailList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirClaimResponseItemDetailSubDetailListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirClaimResponseItemDetailSubDetailListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirClaimResponseItemDetailSubDetailListEnumerator.GetCurrent : TFhirClaimResponseItemDetailSubDetail;
begin
  Result := FList[FIndex];
end;

function TFhirClaimResponseItemDetailSubDetailListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirClaimResponseItemDetailSubDetailList }

procedure TFhirClaimResponseItemDetailSubDetailList.AddItem(value: TFhirClaimResponseItemDetailSubDetail);
begin
  assert(value.ClassName = 'TFhirClaimResponseItemDetailSubDetail', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirClaimResponseItemDetailSubDetail');
  add(value);
end;

function TFhirClaimResponseItemDetailSubDetailList.Append: TFhirClaimResponseItemDetailSubDetail;
begin
  result := TFhirClaimResponseItemDetailSubDetail.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirClaimResponseItemDetailSubDetailList.ClearItems;
begin
  Clear;
end;

function TFhirClaimResponseItemDetailSubDetailList.GetEnumerator : TFhirClaimResponseItemDetailSubDetailListEnumerator;
begin
  result := TFhirClaimResponseItemDetailSubDetailListEnumerator.Create(self.link);
end;

function TFhirClaimResponseItemDetailSubDetailList.Clone: TFhirClaimResponseItemDetailSubDetailList;
begin
  result := TFhirClaimResponseItemDetailSubDetailList(inherited Clone);
end;

function TFhirClaimResponseItemDetailSubDetailList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirClaimResponseItemDetailSubDetailList.GetItemN(index: Integer): TFhirClaimResponseItemDetailSubDetail;
begin
  result := TFhirClaimResponseItemDetailSubDetail(ObjectByIndex[index]);
end;

function TFhirClaimResponseItemDetailSubDetailList.ItemClass: TFslObjectClass;
begin
  result := TFhirClaimResponseItemDetailSubDetail;
end;
function TFhirClaimResponseItemDetailSubDetailList.IndexOf(value: TFhirClaimResponseItemDetailSubDetail): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirClaimResponseItemDetailSubDetailList.Insert(index: Integer): TFhirClaimResponseItemDetailSubDetail;
begin
  result := TFhirClaimResponseItemDetailSubDetail.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirClaimResponseItemDetailSubDetailList.InsertItem(index: Integer; value: TFhirClaimResponseItemDetailSubDetail);
begin
  assert(value is TFhirClaimResponseItemDetailSubDetail);
  Inherited Insert(index, value);
end;

function TFhirClaimResponseItemDetailSubDetailList.Item(index: Integer): TFhirClaimResponseItemDetailSubDetail;
begin
  result := TFhirClaimResponseItemDetailSubDetail(ObjectByIndex[index]);
end;

function TFhirClaimResponseItemDetailSubDetailList.Link: TFhirClaimResponseItemDetailSubDetailList;
begin
  result := TFhirClaimResponseItemDetailSubDetailList(inherited Link);
end;

procedure TFhirClaimResponseItemDetailSubDetailList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirClaimResponseItemDetailSubDetailList.SetItemByIndex(index: Integer; value: TFhirClaimResponseItemDetailSubDetail);
begin
  assert(value is TFhirClaimResponseItemDetailSubDetail);
  FhirClaimResponseItemDetailSubDetails[index] := value;
end;

procedure TFhirClaimResponseItemDetailSubDetailList.SetItemN(index: Integer; value: TFhirClaimResponseItemDetailSubDetail);
begin
  assert(value is TFhirClaimResponseItemDetailSubDetail);
  ObjectByIndex[index] := value;
end;

{ TFhirClaimResponseAddItem }

constructor TFhirClaimResponseAddItem.Create;
begin
  inherited;
end;

destructor TFhirClaimResponseAddItem.Destroy;
begin
  FItemSequenceList.Free;
  FDetailSequenceList.Free;
  FSubdetailSequenceList.Free;
  FProviderList.Free;
  FProductOrService.free;
  FModifierList.Free;
  FProgramCodeList.Free;
  FServiced.free;
  FLocation.free;
  FQuantity.free;
  FUnitPrice.free;
  FFactor.free;
  FNet.free;
  FBodySite.free;
  FSubSiteList.Free;
  FNoteNumberList.Free;
  FAdjudicationList.Free;
  FDetailList.Free;
  inherited;
end;

procedure TFhirClaimResponseAddItem.Assign(oSource : TFslObject);
begin
  inherited;
  if (TFhirClaimResponseAddItem(oSource).FItemSequenceList = nil) then
  begin
    FItemSequenceList.free;
    FItemSequenceList := nil;
  end
  else
  begin
    if FItemSequenceList = nil then
      FItemSequenceList := TFhirPositiveIntList.Create;
    FItemSequenceList.Assign(TFhirClaimResponseAddItem(oSource).FItemSequenceList);
  end;
  if (TFhirClaimResponseAddItem(oSource).FDetailSequenceList = nil) then
  begin
    FDetailSequenceList.free;
    FDetailSequenceList := nil;
  end
  else
  begin
    if FDetailSequenceList = nil then
      FDetailSequenceList := TFhirPositiveIntList.Create;
    FDetailSequenceList.Assign(TFhirClaimResponseAddItem(oSource).FDetailSequenceList);
  end;
  if (TFhirClaimResponseAddItem(oSource).FSubdetailSequenceList = nil) then
  begin
    FSubdetailSequenceList.free;
    FSubdetailSequenceList := nil;
  end
  else
  begin
    if FSubdetailSequenceList = nil then
      FSubdetailSequenceList := TFhirPositiveIntList.Create;
    FSubdetailSequenceList.Assign(TFhirClaimResponseAddItem(oSource).FSubdetailSequenceList);
  end;
  if (TFhirClaimResponseAddItem(oSource).FProviderList = nil) then
  begin
    FProviderList.free;
    FProviderList := nil;
  end
  else
  begin
    if FProviderList = nil then
      FProviderList := TFhirReferenceList.Create;
    FProviderList.Assign(TFhirClaimResponseAddItem(oSource).FProviderList);
  end;
  productOrService := TFhirClaimResponseAddItem(oSource).productOrService.Clone;
  if (TFhirClaimResponseAddItem(oSource).FModifierList = nil) then
  begin
    FModifierList.free;
    FModifierList := nil;
  end
  else
  begin
    if FModifierList = nil then
      FModifierList := TFhirCodeableConceptList.Create;
    FModifierList.Assign(TFhirClaimResponseAddItem(oSource).FModifierList);
  end;
  if (TFhirClaimResponseAddItem(oSource).FProgramCodeList = nil) then
  begin
    FProgramCodeList.free;
    FProgramCodeList := nil;
  end
  else
  begin
    if FProgramCodeList = nil then
      FProgramCodeList := TFhirCodeableConceptList.Create;
    FProgramCodeList.Assign(TFhirClaimResponseAddItem(oSource).FProgramCodeList);
  end;
  serviced := TFhirClaimResponseAddItem(oSource).serviced.Clone;
  location := TFhirClaimResponseAddItem(oSource).location.Clone;
  quantity := TFhirClaimResponseAddItem(oSource).quantity.Clone;
  unitPrice := TFhirClaimResponseAddItem(oSource).unitPrice.Clone;
  factorElement := TFhirClaimResponseAddItem(oSource).factorElement.Clone;
  net := TFhirClaimResponseAddItem(oSource).net.Clone;
  bodySite := TFhirClaimResponseAddItem(oSource).bodySite.Clone;
  if (TFhirClaimResponseAddItem(oSource).FSubSiteList = nil) then
  begin
    FSubSiteList.free;
    FSubSiteList := nil;
  end
  else
  begin
    if FSubSiteList = nil then
      FSubSiteList := TFhirCodeableConceptList.Create;
    FSubSiteList.Assign(TFhirClaimResponseAddItem(oSource).FSubSiteList);
  end;
  if (TFhirClaimResponseAddItem(oSource).FNoteNumberList = nil) then
  begin
    FNoteNumberList.free;
    FNoteNumberList := nil;
  end
  else
  begin
    if FNoteNumberList = nil then
      FNoteNumberList := TFhirPositiveIntList.Create;
    FNoteNumberList.Assign(TFhirClaimResponseAddItem(oSource).FNoteNumberList);
  end;
  if (TFhirClaimResponseAddItem(oSource).FAdjudicationList = nil) then
  begin
    FAdjudicationList.free;
    FAdjudicationList := nil;
  end
  else
  begin
    if FAdjudicationList = nil then
      FAdjudicationList := TFhirClaimResponseItemAdjudicationList.Create;
    FAdjudicationList.Assign(TFhirClaimResponseAddItem(oSource).FAdjudicationList);
  end;
  if (TFhirClaimResponseAddItem(oSource).FDetailList = nil) then
  begin
    FDetailList.free;
    FDetailList := nil;
  end
  else
  begin
    if FDetailList = nil then
      FDetailList := TFhirClaimResponseAddItemDetailList.Create;
    FDetailList.Assign(TFhirClaimResponseAddItem(oSource).FDetailList);
  end;
end;

procedure TFhirClaimResponseAddItem.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'itemSequence') Then
    list.addAll(self, 'itemSequence', FItemSequenceList);
  if (child_name = 'detailSequence') Then
    list.addAll(self, 'detailSequence', FDetailSequenceList);
  if (child_name = 'subdetailSequence') Then
    list.addAll(self, 'subdetailSequence', FSubdetailSequenceList);
  if (child_name = 'provider') Then
    list.addAll(self, 'provider', FProviderList);
  if (child_name = 'productOrService') Then
     list.add(self.link, 'productOrService', FProductOrService.Link);
  if (child_name = 'modifier') Then
    list.addAll(self, 'modifier', FModifierList);
  if (child_name = 'programCode') Then
    list.addAll(self, 'programCode', FProgramCodeList);
  if (child_name = 'serviced[x]') or (child_name = 'serviced') Then
     list.add(self.link, 'serviced[x]', FServiced.Link);
  if (child_name = 'location[x]') or (child_name = 'location') Then
     list.add(self.link, 'location[x]', FLocation.Link);
  if (child_name = 'quantity') Then
     list.add(self.link, 'quantity', FQuantity.Link);
  if (child_name = 'unitPrice') Then
     list.add(self.link, 'unitPrice', FUnitPrice.Link);
  if (child_name = 'factor') Then
     list.add(self.link, 'factor', FFactor.Link);
  if (child_name = 'net') Then
     list.add(self.link, 'net', FNet.Link);
  if (child_name = 'bodySite') Then
     list.add(self.link, 'bodySite', FBodySite.Link);
  if (child_name = 'subSite') Then
    list.addAll(self, 'subSite', FSubSiteList);
  if (child_name = 'noteNumber') Then
    list.addAll(self, 'noteNumber', FNoteNumberList);
  if (child_name = 'adjudication') Then
    list.addAll(self, 'adjudication', FAdjudicationList);
  if (child_name = 'detail') Then
    list.addAll(self, 'detail', FDetailList);
end;

procedure TFhirClaimResponseAddItem.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'itemSequence', 'positiveInt', true, TFhirPositiveInt, FItemSequenceList.Link));
  oList.add(TFHIRProperty.create(self, 'detailSequence', 'positiveInt', true, TFhirPositiveInt, FDetailSequenceList.Link));
  oList.add(TFHIRProperty.create(self, 'subdetailSequence', 'positiveInt', true, TFhirPositiveInt, FSubdetailSequenceList.Link));
  oList.add(TFHIRProperty.create(self, 'provider', 'Reference', true, TFhirReference, FProviderList.Link));
  oList.add(TFHIRProperty.create(self, 'productOrService', 'CodeableConcept', false, TFhirCodeableConcept, FProductOrService.Link));
  oList.add(TFHIRProperty.create(self, 'modifier', 'CodeableConcept', true, TFhirCodeableConcept, FModifierList.Link));
  oList.add(TFHIRProperty.create(self, 'programCode', 'CodeableConcept', true, TFhirCodeableConcept, FProgramCodeList.Link));
  oList.add(TFHIRProperty.create(self, 'serviced[x]', 'date|Period', false, TFhirDataType, FServiced.Link));
  oList.add(TFHIRProperty.create(self, 'location[x]', 'CodeableConcept|Address|Reference', false, TFhirDataType, FLocation.Link));
  oList.add(TFHIRProperty.create(self, 'quantity', 'Quantity', false, TFhirQuantity, FQuantity.Link));
  oList.add(TFHIRProperty.create(self, 'unitPrice', 'Money', false, TFhirMoney, FUnitPrice.Link));
  oList.add(TFHIRProperty.create(self, 'factor', 'decimal', false, TFhirDecimal, FFactor.Link));
  oList.add(TFHIRProperty.create(self, 'net', 'Money', false, TFhirMoney, FNet.Link));
  oList.add(TFHIRProperty.create(self, 'bodySite', 'CodeableConcept', false, TFhirCodeableConcept, FBodySite.Link));
  oList.add(TFHIRProperty.create(self, 'subSite', 'CodeableConcept', true, TFhirCodeableConcept, FSubSiteList.Link));
  oList.add(TFHIRProperty.create(self, 'noteNumber', 'positiveInt', true, TFhirPositiveInt, FNoteNumberList.Link));
  oList.add(TFHIRProperty.create(self, 'adjudication', '', true, TFhirClaimResponseItemAdjudication, FAdjudicationList.Link));
  oList.add(TFHIRProperty.create(self, 'detail', 'BackboneElement', true, TFhirClaimResponseAddItemDetail, FDetailList.Link));
end;

function TFhirClaimResponseAddItem.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'itemSequence') then
  begin
    ItemSequenceList.add(asPositiveInt(propValue)){2};     result := propValue;

  end
  else if (propName = 'detailSequence') then
  begin
    DetailSequenceList.add(asPositiveInt(propValue)){2};     result := propValue;

  end
  else if (propName = 'subdetailSequence') then
  begin
    SubdetailSequenceList.add(asPositiveInt(propValue)){2};     result := propValue;

  end
  else if (propName = 'provider') then
  begin
    ProviderList.add(propValue as TFhirReference);
    result := propValue;
  end
  else if (propName = 'productOrService') then
  begin
    ProductOrService := propValue as TFhirCodeableConcept;
    result := propValue;
  end
  else if (propName = 'modifier') then
  begin
    ModifierList.add(propValue as TFhirCodeableConcept);
    result := propValue;
  end
  else if (propName = 'programCode') then
  begin
    ProgramCodeList.add(propValue as TFhirCodeableConcept);
    result := propValue;
  end
  else if (isMatchingName(propName, 'serviced', ['Date', 'Period'])) then
  begin
    Serviced := propValue as TFhirDataType;
    result := propValue;
  end
  else if (isMatchingName(propName, 'location', ['CodeableConcept', 'Address', 'Reference'])) then
  begin
    Location := propValue as TFhirDataType;
    result := propValue;
  end
  else if (propName = 'quantity') then
  begin
    Quantity := propValue as TFhirQuantity;
    result := propValue;
  end
  else if (propName = 'unitPrice') then
  begin
    UnitPrice := propValue as TFhirMoney;
    result := propValue;
  end
  else if (propName = 'factor') then
  begin
    FactorElement := asDecimal(propValue);
    result := propValue;
  end
  else if (propName = 'net') then
  begin
    Net := propValue as TFhirMoney;
    result := propValue;
  end
  else if (propName = 'bodySite') then
  begin
    BodySite := propValue as TFhirCodeableConcept;
    result := propValue;
  end
  else if (propName = 'subSite') then
  begin
    SubSiteList.add(propValue as TFhirCodeableConcept);
    result := propValue;
  end
  else if (propName = 'noteNumber') then
  begin
    NoteNumberList.add(asPositiveInt(propValue)){2};     result := propValue;

  end
  else if (propName = 'adjudication') then
  begin
    AdjudicationList.add(propValue as TFhirClaimResponseItemAdjudication);
    result := propValue;
  end
  else if (propName = 'detail') then
  begin
    DetailList.add(propValue as TFhirClaimResponseAddItemDetail);
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirClaimResponseAddItem.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'itemSequence') then ItemSequenceList.insertItem(index, asPositiveInt(propValue))
  else if (propName = 'detailSequence') then DetailSequenceList.insertItem(index, asPositiveInt(propValue))
  else if (propName = 'subdetailSequence') then SubdetailSequenceList.insertItem(index, asPositiveInt(propValue))
  else if (propName = 'provider') then ProviderList.insertItem(index, propValue as TFhirReference)
  else if (propName = 'modifier') then ModifierList.insertItem(index, propValue as TFhirCodeableConcept)
  else if (propName = 'programCode') then ProgramCodeList.insertItem(index, propValue as TFhirCodeableConcept)
  else if (propName = 'subSite') then SubSiteList.insertItem(index, propValue as TFhirCodeableConcept)
  else if (propName = 'noteNumber') then NoteNumberList.insertItem(index, asPositiveInt(propValue))
  else if (propName = 'adjudication') then AdjudicationList.insertItem(index, propValue as TFhirClaimResponseItemAdjudication)
  else if (propName = 'detail') then DetailList.insertItem(index, propValue as TFhirClaimResponseAddItemDetail)
  else inherited;
end;

function TFhirClaimResponseAddItem.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'itemSequence') then result := ItemSequenceList.new()
  else if (propName = 'detailSequence') then result := DetailSequenceList.new()
  else if (propName = 'subdetailSequence') then result := SubdetailSequenceList.new()
  else if (propName = 'provider') then result := ProviderList.new()
  else if (propName = 'productOrService') then result := TFhirCodeableConcept.create()
  else if (propName = 'modifier') then result := ModifierList.new()
  else if (propName = 'programCode') then result := ProgramCodeList.new()
  else if (isMatchingName(propName, 'serviced', ['Date', 'Period'])) then raise EFHIRException.create('Cannot make property Serviced')
  else if (isMatchingName(propName, 'location', ['CodeableConcept', 'Address', 'Reference'])) then raise EFHIRException.create('Cannot make property Location')
  else if (propName = 'quantity') then result := TFhirQuantity.create()
  else if (propName = 'unitPrice') then result := TFhirMoney.create()
  else if (propName = 'factor') then result := TFhirDecimal.create()
  else if (propName = 'net') then result := TFhirMoney.create()
  else if (propName = 'bodySite') then result := TFhirCodeableConcept.create()
  else if (propName = 'subSite') then result := SubSiteList.new()
  else if (propName = 'noteNumber') then result := NoteNumberList.new()
  else if (propName = 'adjudication') then result := AdjudicationList.new()
  else if (propName = 'detail') then result := DetailList.new()
  else result := inherited createPropertyValue(propName);
end;

function TFhirClaimResponseAddItem.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'itemSequence') then result := 'positiveInt'
  else if (propName = 'detailSequence') then result := 'positiveInt'
  else if (propName = 'subdetailSequence') then result := 'positiveInt'
  else if (propName = 'provider') then result := 'Reference'
  else if (propName = 'productOrService') then result := 'CodeableConcept'
  else if (propName = 'modifier') then result := 'CodeableConcept'
  else if (propName = 'programCode') then result := 'CodeableConcept'
  else if (propName = 'serviced[x]') then result := 'date|Period'
  else if (propName = 'location[x]') then result := 'CodeableConcept|Address|Reference'
  else if (propName = 'quantity') then result := 'Quantity'
  else if (propName = 'unitPrice') then result := 'Money'
  else if (propName = 'factor') then result := 'decimal'
  else if (propName = 'net') then result := 'Money'
  else if (propName = 'bodySite') then result := 'CodeableConcept'
  else if (propName = 'subSite') then result := 'CodeableConcept'
  else if (propName = 'noteNumber') then result := 'positiveInt'
  else if (propName = 'adjudication') then result := ''
  else if (propName = 'detail') then result := 'BackboneElement'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirClaimResponseAddItem.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'itemSequence') then deletePropertyValue('itemSequence', ItemSequenceList, value)
  else if (propName = 'detailSequence') then deletePropertyValue('detailSequence', DetailSequenceList, value)
  else if (propName = 'subdetailSequence') then deletePropertyValue('subdetailSequence', SubdetailSequenceList, value)
  else if (propName = 'provider') then deletePropertyValue('provider', ProviderList, value)
  else if (propName = 'productOrService') then ProductOrServiceElement := nil
  else if (propName = 'modifier') then deletePropertyValue('modifier', ModifierList, value)
  else if (propName = 'programCode') then deletePropertyValue('programCode', ProgramCodeList, value)
  else if (isMatchingName(propName, 'serviced', ['Date', 'Period'])) then ServicedElement := nil
  else if (isMatchingName(propName, 'location', ['CodeableConcept', 'Address', 'Reference'])) then LocationElement := nil
  else if (propName = 'quantity') then QuantityElement := nil
  else if (propName = 'unitPrice') then UnitPriceElement := nil
  else if (propName = 'factor') then FactorElement := nil
  else if (propName = 'net') then NetElement := nil
  else if (propName = 'bodySite') then BodySiteElement := nil
  else if (propName = 'subSite') then deletePropertyValue('subSite', SubSiteList, value)
  else if (propName = 'noteNumber') then deletePropertyValue('noteNumber', NoteNumberList, value)
  else if (propName = 'adjudication') then deletePropertyValue('adjudication', AdjudicationList, value)
  else if (propName = 'detail') then deletePropertyValue('detail', DetailList, value)
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirClaimResponseAddItem.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'itemSequence') then replacePropertyValue('itemSequence', ItemSequenceList, existing, new)
  else if (propName = 'detailSequence') then replacePropertyValue('detailSequence', DetailSequenceList, existing, new)
  else if (propName = 'subdetailSequence') then replacePropertyValue('subdetailSequence', SubdetailSequenceList, existing, new)
  else if (propName = 'provider') then replacePropertyValue('provider', ProviderList, existing, new)
  else if (propName = 'productOrService') then ProductOrServiceElement := new as TFhirCodeableConcept
  else if (propName = 'modifier') then replacePropertyValue('modifier', ModifierList, existing, new)
  else if (propName = 'programCode') then replacePropertyValue('programCode', ProgramCodeList, existing, new)
  else if (isMatchingName(propName, 'serviced', ['Date', 'Period'])) then ServicedElement := new as TFhirDataType
  else if (isMatchingName(propName, 'location', ['CodeableConcept', 'Address', 'Reference'])) then LocationElement := new as TFhirDataType
  else if (propName = 'quantity') then QuantityElement := new as TFhirQuantity
  else if (propName = 'unitPrice') then UnitPriceElement := new as TFhirMoney
  else if (propName = 'factor') then FactorElement := asDecimal(new)
  else if (propName = 'net') then NetElement := new as TFhirMoney
  else if (propName = 'bodySite') then BodySiteElement := new as TFhirCodeableConcept
  else if (propName = 'subSite') then replacePropertyValue('subSite', SubSiteList, existing, new)
  else if (propName = 'noteNumber') then replacePropertyValue('noteNumber', NoteNumberList, existing, new)
  else if (propName = 'adjudication') then replacePropertyValue('adjudication', AdjudicationList, existing, new)
  else if (propName = 'detail') then replacePropertyValue('detail', DetailList, existing, new)
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirClaimResponseAddItem.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'itemSequence') then ItemSequenceList.move(source, destination)
  else if (propName = 'detailSequence') then DetailSequenceList.move(source, destination)
  else if (propName = 'subdetailSequence') then SubdetailSequenceList.move(source, destination)
  else if (propName = 'provider') then ProviderList.move(source, destination)
  else if (propName = 'modifier') then ModifierList.move(source, destination)
  else if (propName = 'programCode') then ProgramCodeList.move(source, destination)
  else if (propName = 'subSite') then SubSiteList.move(source, destination)
  else if (propName = 'noteNumber') then NoteNumberList.move(source, destination)
  else if (propName = 'adjudication') then AdjudicationList.move(source, destination)
  else if (propName = 'detail') then DetailList.move(source, destination)
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirClaimResponseAddItem.fhirType : string;
begin
  result := 'ClaimResponse.addItem';
end;

function TFhirClaimResponseAddItem.Link : TFhirClaimResponseAddItem;
begin
  result := TFhirClaimResponseAddItem(inherited Link);
end;

function TFhirClaimResponseAddItem.Clone : TFhirClaimResponseAddItem;
begin
  result := TFhirClaimResponseAddItem(inherited Clone);
end;

function TFhirClaimResponseAddItem.equals(other : TObject) : boolean; 
var
  o : TFhirClaimResponseAddItem;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirClaimResponseAddItem)) then
    result := false
  else
  begin
    o := TFhirClaimResponseAddItem(other);
    result := compareDeep(itemSequenceList, o.itemSequenceList, true) and compareDeep(detailSequenceList, o.detailSequenceList, true) and 
      compareDeep(subdetailSequenceList, o.subdetailSequenceList, true) and compareDeep(providerList, o.providerList, true) and 
      compareDeep(productOrServiceElement, o.productOrServiceElement, true) and compareDeep(modifierList, o.modifierList, true) and 
      compareDeep(programCodeList, o.programCodeList, true) and compareDeep(servicedElement, o.servicedElement, true) and 
      compareDeep(locationElement, o.locationElement, true) and compareDeep(quantityElement, o.quantityElement, true) and 
      compareDeep(unitPriceElement, o.unitPriceElement, true) and compareDeep(factorElement, o.factorElement, true) and 
      compareDeep(netElement, o.netElement, true) and compareDeep(bodySiteElement, o.bodySiteElement, true) and 
      compareDeep(subSiteList, o.subSiteList, true) and compareDeep(noteNumberList, o.noteNumberList, true) and 
      compareDeep(adjudicationList, o.adjudicationList, true) and compareDeep(detailList, o.detailList, true);
  end;
end;

function TFhirClaimResponseAddItem.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FitemSequenceList) and isEmptyProp(FdetailSequenceList) and isEmptyProp(FsubdetailSequenceList) and isEmptyProp(FproviderList) and isEmptyProp(FProductOrService) and isEmptyProp(FmodifierList) and isEmptyProp(FprogramCodeList) and isEmptyProp(FServiced) and isEmptyProp(FLocation) and isEmptyProp(FQuantity) and isEmptyProp(FUnitPrice) and isEmptyProp(FFactor) and isEmptyProp(FNet) and isEmptyProp(FBodySite) and isEmptyProp(FsubSiteList) and isEmptyProp(FnoteNumberList) and isEmptyProp(FadjudicationList) and isEmptyProp(FdetailList);
end;

procedure TFhirClaimResponseAddItem.listFieldsInOrder(fields : TStringList);
begin
  inherited listFieldsInOrder(fields);
  fields.add('itemSequence');
  fields.add('detailSequence');
  fields.add('subdetailSequence');
  fields.add('provider');
  fields.add('productOrService');
  fields.add('modifier');
  fields.add('programCode');
  fields.add('serviced[x]');
  fields.add('location[x]');
  fields.add('quantity');
  fields.add('unitPrice');
  fields.add('factor');
  fields.add('net');
  fields.add('bodySite');
  fields.add('subSite');
  fields.add('noteNumber');
  fields.add('adjudication');
  fields.add('detail');
end;

function TFhirClaimResponseAddItem.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FItemSequenceList.sizeInBytes(magic));
  inc(result, FDetailSequenceList.sizeInBytes(magic));
  inc(result, FSubdetailSequenceList.sizeInBytes(magic));
  inc(result, FProviderList.sizeInBytes(magic));
  inc(result, FModifierList.sizeInBytes(magic));
  inc(result, FProgramCodeList.sizeInBytes(magic));
  inc(result, FSubSiteList.sizeInBytes(magic));
  inc(result, FNoteNumberList.sizeInBytes(magic));
  inc(result, FAdjudicationList.sizeInBytes(magic));
  inc(result, FDetailList.sizeInBytes(magic));
end;

function TFhirClaimResponseAddItem.GetItemSequenceList : TFhirPositiveIntList;
begin
  if FItemSequenceList = nil then
    FItemSequenceList := TFhirPositiveIntList.Create;
  result := FItemSequenceList;
end;

function TFhirClaimResponseAddItem.GetHasItemSequenceList : boolean;
begin
  result := (FItemSequenceList <> nil) and (FItemSequenceList.count > 0);
end;

function TFhirClaimResponseAddItem.GetDetailSequenceList : TFhirPositiveIntList;
begin
  if FDetailSequenceList = nil then
    FDetailSequenceList := TFhirPositiveIntList.Create;
  result := FDetailSequenceList;
end;

function TFhirClaimResponseAddItem.GetHasDetailSequenceList : boolean;
begin
  result := (FDetailSequenceList <> nil) and (FDetailSequenceList.count > 0);
end;

function TFhirClaimResponseAddItem.GetSubdetailSequenceList : TFhirPositiveIntList;
begin
  if FSubdetailSequenceList = nil then
    FSubdetailSequenceList := TFhirPositiveIntList.Create;
  result := FSubdetailSequenceList;
end;

function TFhirClaimResponseAddItem.GetHasSubdetailSequenceList : boolean;
begin
  result := (FSubdetailSequenceList <> nil) and (FSubdetailSequenceList.count > 0);
end;

function TFhirClaimResponseAddItem.GetProviderList : TFhirReferenceList;
begin
  if FProviderList = nil then
    FProviderList := TFhirReferenceList.Create;
  result := FProviderList;
end;

function TFhirClaimResponseAddItem.GetHasProviderList : boolean;
begin
  result := (FProviderList <> nil) and (FProviderList.count > 0);
end;

procedure TFhirClaimResponseAddItem.SetProductOrService(value : TFhirCodeableConcept);
begin
  FProductOrService.free;
  FProductOrService := value;
end;

function TFhirClaimResponseAddItem.GetModifierList : TFhirCodeableConceptList;
begin
  if FModifierList = nil then
    FModifierList := TFhirCodeableConceptList.Create;
  result := FModifierList;
end;

function TFhirClaimResponseAddItem.GetHasModifierList : boolean;
begin
  result := (FModifierList <> nil) and (FModifierList.count > 0);
end;

function TFhirClaimResponseAddItem.GetProgramCodeList : TFhirCodeableConceptList;
begin
  if FProgramCodeList = nil then
    FProgramCodeList := TFhirCodeableConceptList.Create;
  result := FProgramCodeList;
end;

function TFhirClaimResponseAddItem.GetHasProgramCodeList : boolean;
begin
  result := (FProgramCodeList <> nil) and (FProgramCodeList.count > 0);
end;

procedure TFhirClaimResponseAddItem.SetServiced(value : TFhirDataType);
begin
  FServiced.free;
  FServiced := value;
end;

procedure TFhirClaimResponseAddItem.SetLocation(value : TFhirDataType);
begin
  FLocation.free;
  FLocation := value;
end;

procedure TFhirClaimResponseAddItem.SetQuantity(value : TFhirQuantity);
begin
  FQuantity.free;
  FQuantity := value;
end;

procedure TFhirClaimResponseAddItem.SetUnitPrice(value : TFhirMoney);
begin
  FUnitPrice.free;
  FUnitPrice := value;
end;

procedure TFhirClaimResponseAddItem.SetFactor(value : TFhirDecimal);
begin
  FFactor.free;
  FFactor := value;
end;

function TFhirClaimResponseAddItem.GetFactorST : String;
begin
  if FFactor = nil then
    result := ''
  else
    result := FFactor.value;
end;

procedure TFhirClaimResponseAddItem.SetFactorST(value : String);
begin
  if value <> '' then
  begin
    if FFactor = nil then
      FFactor := TFhirDecimal.create;
    FFactor.value := value
  end
  else if FFactor <> nil then
    FFactor.value := '';
end;

procedure TFhirClaimResponseAddItem.SetNet(value : TFhirMoney);
begin
  FNet.free;
  FNet := value;
end;

procedure TFhirClaimResponseAddItem.SetBodySite(value : TFhirCodeableConcept);
begin
  FBodySite.free;
  FBodySite := value;
end;

function TFhirClaimResponseAddItem.GetSubSiteList : TFhirCodeableConceptList;
begin
  if FSubSiteList = nil then
    FSubSiteList := TFhirCodeableConceptList.Create;
  result := FSubSiteList;
end;

function TFhirClaimResponseAddItem.GetHasSubSiteList : boolean;
begin
  result := (FSubSiteList <> nil) and (FSubSiteList.count > 0);
end;

function TFhirClaimResponseAddItem.GetNoteNumberList : TFhirPositiveIntList;
begin
  if FNoteNumberList = nil then
    FNoteNumberList := TFhirPositiveIntList.Create;
  result := FNoteNumberList;
end;

function TFhirClaimResponseAddItem.GetHasNoteNumberList : boolean;
begin
  result := (FNoteNumberList <> nil) and (FNoteNumberList.count > 0);
end;

function TFhirClaimResponseAddItem.GetAdjudicationList : TFhirClaimResponseItemAdjudicationList;
begin
  if FAdjudicationList = nil then
    FAdjudicationList := TFhirClaimResponseItemAdjudicationList.Create;
  result := FAdjudicationList;
end;

function TFhirClaimResponseAddItem.GetHasAdjudicationList : boolean;
begin
  result := (FAdjudicationList <> nil) and (FAdjudicationList.count > 0);
end;

function TFhirClaimResponseAddItem.GetDetailList : TFhirClaimResponseAddItemDetailList;
begin
  if FDetailList = nil then
    FDetailList := TFhirClaimResponseAddItemDetailList.Create;
  result := FDetailList;
end;

function TFhirClaimResponseAddItem.GetHasDetailList : boolean;
begin
  result := (FDetailList <> nil) and (FDetailList.count > 0);
end;

{ TFhirClaimResponseAddItemListEnumerator }

constructor TFhirClaimResponseAddItemListEnumerator.Create(list : TFhirClaimResponseAddItemList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirClaimResponseAddItemListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirClaimResponseAddItemListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirClaimResponseAddItemListEnumerator.GetCurrent : TFhirClaimResponseAddItem;
begin
  Result := FList[FIndex];
end;

function TFhirClaimResponseAddItemListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirClaimResponseAddItemList }

procedure TFhirClaimResponseAddItemList.AddItem(value: TFhirClaimResponseAddItem);
begin
  assert(value.ClassName = 'TFhirClaimResponseAddItem', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirClaimResponseAddItem');
  add(value);
end;

function TFhirClaimResponseAddItemList.Append: TFhirClaimResponseAddItem;
begin
  result := TFhirClaimResponseAddItem.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirClaimResponseAddItemList.ClearItems;
begin
  Clear;
end;

function TFhirClaimResponseAddItemList.GetEnumerator : TFhirClaimResponseAddItemListEnumerator;
begin
  result := TFhirClaimResponseAddItemListEnumerator.Create(self.link);
end;

function TFhirClaimResponseAddItemList.Clone: TFhirClaimResponseAddItemList;
begin
  result := TFhirClaimResponseAddItemList(inherited Clone);
end;

function TFhirClaimResponseAddItemList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirClaimResponseAddItemList.GetItemN(index: Integer): TFhirClaimResponseAddItem;
begin
  result := TFhirClaimResponseAddItem(ObjectByIndex[index]);
end;

function TFhirClaimResponseAddItemList.ItemClass: TFslObjectClass;
begin
  result := TFhirClaimResponseAddItem;
end;
function TFhirClaimResponseAddItemList.IndexOf(value: TFhirClaimResponseAddItem): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirClaimResponseAddItemList.Insert(index: Integer): TFhirClaimResponseAddItem;
begin
  result := TFhirClaimResponseAddItem.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirClaimResponseAddItemList.InsertItem(index: Integer; value: TFhirClaimResponseAddItem);
begin
  assert(value is TFhirClaimResponseAddItem);
  Inherited Insert(index, value);
end;

function TFhirClaimResponseAddItemList.Item(index: Integer): TFhirClaimResponseAddItem;
begin
  result := TFhirClaimResponseAddItem(ObjectByIndex[index]);
end;

function TFhirClaimResponseAddItemList.Link: TFhirClaimResponseAddItemList;
begin
  result := TFhirClaimResponseAddItemList(inherited Link);
end;

procedure TFhirClaimResponseAddItemList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirClaimResponseAddItemList.SetItemByIndex(index: Integer; value: TFhirClaimResponseAddItem);
begin
  assert(value is TFhirClaimResponseAddItem);
  FhirClaimResponseAddItems[index] := value;
end;

procedure TFhirClaimResponseAddItemList.SetItemN(index: Integer; value: TFhirClaimResponseAddItem);
begin
  assert(value is TFhirClaimResponseAddItem);
  ObjectByIndex[index] := value;
end;

{ TFhirClaimResponseAddItemDetail }

constructor TFhirClaimResponseAddItemDetail.Create;
begin
  inherited;
end;

destructor TFhirClaimResponseAddItemDetail.Destroy;
begin
  FProductOrService.free;
  FModifierList.Free;
  FQuantity.free;
  FUnitPrice.free;
  FFactor.free;
  FNet.free;
  FNoteNumberList.Free;
  FAdjudicationList.Free;
  FSubDetailList.Free;
  inherited;
end;

procedure TFhirClaimResponseAddItemDetail.Assign(oSource : TFslObject);
begin
  inherited;
  productOrService := TFhirClaimResponseAddItemDetail(oSource).productOrService.Clone;
  if (TFhirClaimResponseAddItemDetail(oSource).FModifierList = nil) then
  begin
    FModifierList.free;
    FModifierList := nil;
  end
  else
  begin
    if FModifierList = nil then
      FModifierList := TFhirCodeableConceptList.Create;
    FModifierList.Assign(TFhirClaimResponseAddItemDetail(oSource).FModifierList);
  end;
  quantity := TFhirClaimResponseAddItemDetail(oSource).quantity.Clone;
  unitPrice := TFhirClaimResponseAddItemDetail(oSource).unitPrice.Clone;
  factorElement := TFhirClaimResponseAddItemDetail(oSource).factorElement.Clone;
  net := TFhirClaimResponseAddItemDetail(oSource).net.Clone;
  if (TFhirClaimResponseAddItemDetail(oSource).FNoteNumberList = nil) then
  begin
    FNoteNumberList.free;
    FNoteNumberList := nil;
  end
  else
  begin
    if FNoteNumberList = nil then
      FNoteNumberList := TFhirPositiveIntList.Create;
    FNoteNumberList.Assign(TFhirClaimResponseAddItemDetail(oSource).FNoteNumberList);
  end;
  if (TFhirClaimResponseAddItemDetail(oSource).FAdjudicationList = nil) then
  begin
    FAdjudicationList.free;
    FAdjudicationList := nil;
  end
  else
  begin
    if FAdjudicationList = nil then
      FAdjudicationList := TFhirClaimResponseItemAdjudicationList.Create;
    FAdjudicationList.Assign(TFhirClaimResponseAddItemDetail(oSource).FAdjudicationList);
  end;
  if (TFhirClaimResponseAddItemDetail(oSource).FSubDetailList = nil) then
  begin
    FSubDetailList.free;
    FSubDetailList := nil;
  end
  else
  begin
    if FSubDetailList = nil then
      FSubDetailList := TFhirClaimResponseAddItemDetailSubDetailList.Create;
    FSubDetailList.Assign(TFhirClaimResponseAddItemDetail(oSource).FSubDetailList);
  end;
end;

procedure TFhirClaimResponseAddItemDetail.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'productOrService') Then
     list.add(self.link, 'productOrService', FProductOrService.Link);
  if (child_name = 'modifier') Then
    list.addAll(self, 'modifier', FModifierList);
  if (child_name = 'quantity') Then
     list.add(self.link, 'quantity', FQuantity.Link);
  if (child_name = 'unitPrice') Then
     list.add(self.link, 'unitPrice', FUnitPrice.Link);
  if (child_name = 'factor') Then
     list.add(self.link, 'factor', FFactor.Link);
  if (child_name = 'net') Then
     list.add(self.link, 'net', FNet.Link);
  if (child_name = 'noteNumber') Then
    list.addAll(self, 'noteNumber', FNoteNumberList);
  if (child_name = 'adjudication') Then
    list.addAll(self, 'adjudication', FAdjudicationList);
  if (child_name = 'subDetail') Then
    list.addAll(self, 'subDetail', FSubDetailList);
end;

procedure TFhirClaimResponseAddItemDetail.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'productOrService', 'CodeableConcept', false, TFhirCodeableConcept, FProductOrService.Link));
  oList.add(TFHIRProperty.create(self, 'modifier', 'CodeableConcept', true, TFhirCodeableConcept, FModifierList.Link));
  oList.add(TFHIRProperty.create(self, 'quantity', 'Quantity', false, TFhirQuantity, FQuantity.Link));
  oList.add(TFHIRProperty.create(self, 'unitPrice', 'Money', false, TFhirMoney, FUnitPrice.Link));
  oList.add(TFHIRProperty.create(self, 'factor', 'decimal', false, TFhirDecimal, FFactor.Link));
  oList.add(TFHIRProperty.create(self, 'net', 'Money', false, TFhirMoney, FNet.Link));
  oList.add(TFHIRProperty.create(self, 'noteNumber', 'positiveInt', true, TFhirPositiveInt, FNoteNumberList.Link));
  oList.add(TFHIRProperty.create(self, 'adjudication', '', true, TFhirClaimResponseItemAdjudication, FAdjudicationList.Link));
  oList.add(TFHIRProperty.create(self, 'subDetail', 'BackboneElement', true, TFhirClaimResponseAddItemDetailSubDetail, FSubDetailList.Link));
end;

function TFhirClaimResponseAddItemDetail.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'productOrService') then
  begin
    ProductOrService := propValue as TFhirCodeableConcept;
    result := propValue;
  end
  else if (propName = 'modifier') then
  begin
    ModifierList.add(propValue as TFhirCodeableConcept);
    result := propValue;
  end
  else if (propName = 'quantity') then
  begin
    Quantity := propValue as TFhirQuantity;
    result := propValue;
  end
  else if (propName = 'unitPrice') then
  begin
    UnitPrice := propValue as TFhirMoney;
    result := propValue;
  end
  else if (propName = 'factor') then
  begin
    FactorElement := asDecimal(propValue);
    result := propValue;
  end
  else if (propName = 'net') then
  begin
    Net := propValue as TFhirMoney;
    result := propValue;
  end
  else if (propName = 'noteNumber') then
  begin
    NoteNumberList.add(asPositiveInt(propValue)){2};     result := propValue;

  end
  else if (propName = 'adjudication') then
  begin
    AdjudicationList.add(propValue as TFhirClaimResponseItemAdjudication);
    result := propValue;
  end
  else if (propName = 'subDetail') then
  begin
    SubDetailList.add(propValue as TFhirClaimResponseAddItemDetailSubDetail);
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirClaimResponseAddItemDetail.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'modifier') then ModifierList.insertItem(index, propValue as TFhirCodeableConcept)
  else if (propName = 'noteNumber') then NoteNumberList.insertItem(index, asPositiveInt(propValue))
  else if (propName = 'adjudication') then AdjudicationList.insertItem(index, propValue as TFhirClaimResponseItemAdjudication)
  else if (propName = 'subDetail') then SubDetailList.insertItem(index, propValue as TFhirClaimResponseAddItemDetailSubDetail)
  else inherited;
end;

function TFhirClaimResponseAddItemDetail.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'productOrService') then result := TFhirCodeableConcept.create()
  else if (propName = 'modifier') then result := ModifierList.new()
  else if (propName = 'quantity') then result := TFhirQuantity.create()
  else if (propName = 'unitPrice') then result := TFhirMoney.create()
  else if (propName = 'factor') then result := TFhirDecimal.create()
  else if (propName = 'net') then result := TFhirMoney.create()
  else if (propName = 'noteNumber') then result := NoteNumberList.new()
  else if (propName = 'adjudication') then result := AdjudicationList.new()
  else if (propName = 'subDetail') then result := SubDetailList.new()
  else result := inherited createPropertyValue(propName);
end;

function TFhirClaimResponseAddItemDetail.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'productOrService') then result := 'CodeableConcept'
  else if (propName = 'modifier') then result := 'CodeableConcept'
  else if (propName = 'quantity') then result := 'Quantity'
  else if (propName = 'unitPrice') then result := 'Money'
  else if (propName = 'factor') then result := 'decimal'
  else if (propName = 'net') then result := 'Money'
  else if (propName = 'noteNumber') then result := 'positiveInt'
  else if (propName = 'adjudication') then result := ''
  else if (propName = 'subDetail') then result := 'BackboneElement'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirClaimResponseAddItemDetail.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'productOrService') then ProductOrServiceElement := nil
  else if (propName = 'modifier') then deletePropertyValue('modifier', ModifierList, value)
  else if (propName = 'quantity') then QuantityElement := nil
  else if (propName = 'unitPrice') then UnitPriceElement := nil
  else if (propName = 'factor') then FactorElement := nil
  else if (propName = 'net') then NetElement := nil
  else if (propName = 'noteNumber') then deletePropertyValue('noteNumber', NoteNumberList, value)
  else if (propName = 'adjudication') then deletePropertyValue('adjudication', AdjudicationList, value)
  else if (propName = 'subDetail') then deletePropertyValue('subDetail', SubDetailList, value)
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirClaimResponseAddItemDetail.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'productOrService') then ProductOrServiceElement := new as TFhirCodeableConcept
  else if (propName = 'modifier') then replacePropertyValue('modifier', ModifierList, existing, new)
  else if (propName = 'quantity') then QuantityElement := new as TFhirQuantity
  else if (propName = 'unitPrice') then UnitPriceElement := new as TFhirMoney
  else if (propName = 'factor') then FactorElement := asDecimal(new)
  else if (propName = 'net') then NetElement := new as TFhirMoney
  else if (propName = 'noteNumber') then replacePropertyValue('noteNumber', NoteNumberList, existing, new)
  else if (propName = 'adjudication') then replacePropertyValue('adjudication', AdjudicationList, existing, new)
  else if (propName = 'subDetail') then replacePropertyValue('subDetail', SubDetailList, existing, new)
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirClaimResponseAddItemDetail.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'modifier') then ModifierList.move(source, destination)
  else if (propName = 'noteNumber') then NoteNumberList.move(source, destination)
  else if (propName = 'adjudication') then AdjudicationList.move(source, destination)
  else if (propName = 'subDetail') then SubDetailList.move(source, destination)
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirClaimResponseAddItemDetail.fhirType : string;
begin
  result := 'ClaimResponse.addItem.detail';
end;

function TFhirClaimResponseAddItemDetail.Link : TFhirClaimResponseAddItemDetail;
begin
  result := TFhirClaimResponseAddItemDetail(inherited Link);
end;

function TFhirClaimResponseAddItemDetail.Clone : TFhirClaimResponseAddItemDetail;
begin
  result := TFhirClaimResponseAddItemDetail(inherited Clone);
end;

function TFhirClaimResponseAddItemDetail.equals(other : TObject) : boolean; 
var
  o : TFhirClaimResponseAddItemDetail;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirClaimResponseAddItemDetail)) then
    result := false
  else
  begin
    o := TFhirClaimResponseAddItemDetail(other);
    result := compareDeep(productOrServiceElement, o.productOrServiceElement, true) and 
      compareDeep(modifierList, o.modifierList, true) and compareDeep(quantityElement, o.quantityElement, true) and 
      compareDeep(unitPriceElement, o.unitPriceElement, true) and compareDeep(factorElement, o.factorElement, true) and 
      compareDeep(netElement, o.netElement, true) and compareDeep(noteNumberList, o.noteNumberList, true) and 
      compareDeep(adjudicationList, o.adjudicationList, true) and compareDeep(subDetailList, o.subDetailList, true);
  end;
end;

function TFhirClaimResponseAddItemDetail.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FProductOrService) and isEmptyProp(FmodifierList) and isEmptyProp(FQuantity) and isEmptyProp(FUnitPrice) and isEmptyProp(FFactor) and isEmptyProp(FNet) and isEmptyProp(FnoteNumberList) and isEmptyProp(FadjudicationList) and isEmptyProp(FsubDetailList);
end;

procedure TFhirClaimResponseAddItemDetail.listFieldsInOrder(fields : TStringList);
begin
  inherited listFieldsInOrder(fields);
  fields.add('productOrService');
  fields.add('modifier');
  fields.add('quantity');
  fields.add('unitPrice');
  fields.add('factor');
  fields.add('net');
  fields.add('noteNumber');
  fields.add('adjudication');
  fields.add('subDetail');
end;

function TFhirClaimResponseAddItemDetail.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FModifierList.sizeInBytes(magic));
  inc(result, FNoteNumberList.sizeInBytes(magic));
  inc(result, FAdjudicationList.sizeInBytes(magic));
  inc(result, FSubDetailList.sizeInBytes(magic));
end;

procedure TFhirClaimResponseAddItemDetail.SetProductOrService(value : TFhirCodeableConcept);
begin
  FProductOrService.free;
  FProductOrService := value;
end;

function TFhirClaimResponseAddItemDetail.GetModifierList : TFhirCodeableConceptList;
begin
  if FModifierList = nil then
    FModifierList := TFhirCodeableConceptList.Create;
  result := FModifierList;
end;

function TFhirClaimResponseAddItemDetail.GetHasModifierList : boolean;
begin
  result := (FModifierList <> nil) and (FModifierList.count > 0);
end;

procedure TFhirClaimResponseAddItemDetail.SetQuantity(value : TFhirQuantity);
begin
  FQuantity.free;
  FQuantity := value;
end;

procedure TFhirClaimResponseAddItemDetail.SetUnitPrice(value : TFhirMoney);
begin
  FUnitPrice.free;
  FUnitPrice := value;
end;

procedure TFhirClaimResponseAddItemDetail.SetFactor(value : TFhirDecimal);
begin
  FFactor.free;
  FFactor := value;
end;

function TFhirClaimResponseAddItemDetail.GetFactorST : String;
begin
  if FFactor = nil then
    result := ''
  else
    result := FFactor.value;
end;

procedure TFhirClaimResponseAddItemDetail.SetFactorST(value : String);
begin
  if value <> '' then
  begin
    if FFactor = nil then
      FFactor := TFhirDecimal.create;
    FFactor.value := value
  end
  else if FFactor <> nil then
    FFactor.value := '';
end;

procedure TFhirClaimResponseAddItemDetail.SetNet(value : TFhirMoney);
begin
  FNet.free;
  FNet := value;
end;

function TFhirClaimResponseAddItemDetail.GetNoteNumberList : TFhirPositiveIntList;
begin
  if FNoteNumberList = nil then
    FNoteNumberList := TFhirPositiveIntList.Create;
  result := FNoteNumberList;
end;

function TFhirClaimResponseAddItemDetail.GetHasNoteNumberList : boolean;
begin
  result := (FNoteNumberList <> nil) and (FNoteNumberList.count > 0);
end;

function TFhirClaimResponseAddItemDetail.GetAdjudicationList : TFhirClaimResponseItemAdjudicationList;
begin
  if FAdjudicationList = nil then
    FAdjudicationList := TFhirClaimResponseItemAdjudicationList.Create;
  result := FAdjudicationList;
end;

function TFhirClaimResponseAddItemDetail.GetHasAdjudicationList : boolean;
begin
  result := (FAdjudicationList <> nil) and (FAdjudicationList.count > 0);
end;

function TFhirClaimResponseAddItemDetail.GetSubDetailList : TFhirClaimResponseAddItemDetailSubDetailList;
begin
  if FSubDetailList = nil then
    FSubDetailList := TFhirClaimResponseAddItemDetailSubDetailList.Create;
  result := FSubDetailList;
end;

function TFhirClaimResponseAddItemDetail.GetHasSubDetailList : boolean;
begin
  result := (FSubDetailList <> nil) and (FSubDetailList.count > 0);
end;

{ TFhirClaimResponseAddItemDetailListEnumerator }

constructor TFhirClaimResponseAddItemDetailListEnumerator.Create(list : TFhirClaimResponseAddItemDetailList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirClaimResponseAddItemDetailListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirClaimResponseAddItemDetailListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirClaimResponseAddItemDetailListEnumerator.GetCurrent : TFhirClaimResponseAddItemDetail;
begin
  Result := FList[FIndex];
end;

function TFhirClaimResponseAddItemDetailListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirClaimResponseAddItemDetailList }

procedure TFhirClaimResponseAddItemDetailList.AddItem(value: TFhirClaimResponseAddItemDetail);
begin
  assert(value.ClassName = 'TFhirClaimResponseAddItemDetail', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirClaimResponseAddItemDetail');
  add(value);
end;

function TFhirClaimResponseAddItemDetailList.Append: TFhirClaimResponseAddItemDetail;
begin
  result := TFhirClaimResponseAddItemDetail.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirClaimResponseAddItemDetailList.ClearItems;
begin
  Clear;
end;

function TFhirClaimResponseAddItemDetailList.GetEnumerator : TFhirClaimResponseAddItemDetailListEnumerator;
begin
  result := TFhirClaimResponseAddItemDetailListEnumerator.Create(self.link);
end;

function TFhirClaimResponseAddItemDetailList.Clone: TFhirClaimResponseAddItemDetailList;
begin
  result := TFhirClaimResponseAddItemDetailList(inherited Clone);
end;

function TFhirClaimResponseAddItemDetailList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirClaimResponseAddItemDetailList.GetItemN(index: Integer): TFhirClaimResponseAddItemDetail;
begin
  result := TFhirClaimResponseAddItemDetail(ObjectByIndex[index]);
end;

function TFhirClaimResponseAddItemDetailList.ItemClass: TFslObjectClass;
begin
  result := TFhirClaimResponseAddItemDetail;
end;
function TFhirClaimResponseAddItemDetailList.IndexOf(value: TFhirClaimResponseAddItemDetail): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirClaimResponseAddItemDetailList.Insert(index: Integer): TFhirClaimResponseAddItemDetail;
begin
  result := TFhirClaimResponseAddItemDetail.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirClaimResponseAddItemDetailList.InsertItem(index: Integer; value: TFhirClaimResponseAddItemDetail);
begin
  assert(value is TFhirClaimResponseAddItemDetail);
  Inherited Insert(index, value);
end;

function TFhirClaimResponseAddItemDetailList.Item(index: Integer): TFhirClaimResponseAddItemDetail;
begin
  result := TFhirClaimResponseAddItemDetail(ObjectByIndex[index]);
end;

function TFhirClaimResponseAddItemDetailList.Link: TFhirClaimResponseAddItemDetailList;
begin
  result := TFhirClaimResponseAddItemDetailList(inherited Link);
end;

procedure TFhirClaimResponseAddItemDetailList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirClaimResponseAddItemDetailList.SetItemByIndex(index: Integer; value: TFhirClaimResponseAddItemDetail);
begin
  assert(value is TFhirClaimResponseAddItemDetail);
  FhirClaimResponseAddItemDetails[index] := value;
end;

procedure TFhirClaimResponseAddItemDetailList.SetItemN(index: Integer; value: TFhirClaimResponseAddItemDetail);
begin
  assert(value is TFhirClaimResponseAddItemDetail);
  ObjectByIndex[index] := value;
end;

{ TFhirClaimResponseAddItemDetailSubDetail }

constructor TFhirClaimResponseAddItemDetailSubDetail.Create;
begin
  inherited;
end;

destructor TFhirClaimResponseAddItemDetailSubDetail.Destroy;
begin
  FProductOrService.free;
  FModifierList.Free;
  FQuantity.free;
  FUnitPrice.free;
  FFactor.free;
  FNet.free;
  FNoteNumberList.Free;
  FAdjudicationList.Free;
  inherited;
end;

procedure TFhirClaimResponseAddItemDetailSubDetail.Assign(oSource : TFslObject);
begin
  inherited;
  productOrService := TFhirClaimResponseAddItemDetailSubDetail(oSource).productOrService.Clone;
  if (TFhirClaimResponseAddItemDetailSubDetail(oSource).FModifierList = nil) then
  begin
    FModifierList.free;
    FModifierList := nil;
  end
  else
  begin
    if FModifierList = nil then
      FModifierList := TFhirCodeableConceptList.Create;
    FModifierList.Assign(TFhirClaimResponseAddItemDetailSubDetail(oSource).FModifierList);
  end;
  quantity := TFhirClaimResponseAddItemDetailSubDetail(oSource).quantity.Clone;
  unitPrice := TFhirClaimResponseAddItemDetailSubDetail(oSource).unitPrice.Clone;
  factorElement := TFhirClaimResponseAddItemDetailSubDetail(oSource).factorElement.Clone;
  net := TFhirClaimResponseAddItemDetailSubDetail(oSource).net.Clone;
  if (TFhirClaimResponseAddItemDetailSubDetail(oSource).FNoteNumberList = nil) then
  begin
    FNoteNumberList.free;
    FNoteNumberList := nil;
  end
  else
  begin
    if FNoteNumberList = nil then
      FNoteNumberList := TFhirPositiveIntList.Create;
    FNoteNumberList.Assign(TFhirClaimResponseAddItemDetailSubDetail(oSource).FNoteNumberList);
  end;
  if (TFhirClaimResponseAddItemDetailSubDetail(oSource).FAdjudicationList = nil) then
  begin
    FAdjudicationList.free;
    FAdjudicationList := nil;
  end
  else
  begin
    if FAdjudicationList = nil then
      FAdjudicationList := TFhirClaimResponseItemAdjudicationList.Create;
    FAdjudicationList.Assign(TFhirClaimResponseAddItemDetailSubDetail(oSource).FAdjudicationList);
  end;
end;

procedure TFhirClaimResponseAddItemDetailSubDetail.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'productOrService') Then
     list.add(self.link, 'productOrService', FProductOrService.Link);
  if (child_name = 'modifier') Then
    list.addAll(self, 'modifier', FModifierList);
  if (child_name = 'quantity') Then
     list.add(self.link, 'quantity', FQuantity.Link);
  if (child_name = 'unitPrice') Then
     list.add(self.link, 'unitPrice', FUnitPrice.Link);
  if (child_name = 'factor') Then
     list.add(self.link, 'factor', FFactor.Link);
  if (child_name = 'net') Then
     list.add(self.link, 'net', FNet.Link);
  if (child_name = 'noteNumber') Then
    list.addAll(self, 'noteNumber', FNoteNumberList);
  if (child_name = 'adjudication') Then
    list.addAll(self, 'adjudication', FAdjudicationList);
end;

procedure TFhirClaimResponseAddItemDetailSubDetail.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'productOrService', 'CodeableConcept', false, TFhirCodeableConcept, FProductOrService.Link));
  oList.add(TFHIRProperty.create(self, 'modifier', 'CodeableConcept', true, TFhirCodeableConcept, FModifierList.Link));
  oList.add(TFHIRProperty.create(self, 'quantity', 'Quantity', false, TFhirQuantity, FQuantity.Link));
  oList.add(TFHIRProperty.create(self, 'unitPrice', 'Money', false, TFhirMoney, FUnitPrice.Link));
  oList.add(TFHIRProperty.create(self, 'factor', 'decimal', false, TFhirDecimal, FFactor.Link));
  oList.add(TFHIRProperty.create(self, 'net', 'Money', false, TFhirMoney, FNet.Link));
  oList.add(TFHIRProperty.create(self, 'noteNumber', 'positiveInt', true, TFhirPositiveInt, FNoteNumberList.Link));
  oList.add(TFHIRProperty.create(self, 'adjudication', '', true, TFhirClaimResponseItemAdjudication, FAdjudicationList.Link));
end;

function TFhirClaimResponseAddItemDetailSubDetail.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'productOrService') then
  begin
    ProductOrService := propValue as TFhirCodeableConcept;
    result := propValue;
  end
  else if (propName = 'modifier') then
  begin
    ModifierList.add(propValue as TFhirCodeableConcept);
    result := propValue;
  end
  else if (propName = 'quantity') then
  begin
    Quantity := propValue as TFhirQuantity;
    result := propValue;
  end
  else if (propName = 'unitPrice') then
  begin
    UnitPrice := propValue as TFhirMoney;
    result := propValue;
  end
  else if (propName = 'factor') then
  begin
    FactorElement := asDecimal(propValue);
    result := propValue;
  end
  else if (propName = 'net') then
  begin
    Net := propValue as TFhirMoney;
    result := propValue;
  end
  else if (propName = 'noteNumber') then
  begin
    NoteNumberList.add(asPositiveInt(propValue)){2};     result := propValue;

  end
  else if (propName = 'adjudication') then
  begin
    AdjudicationList.add(propValue as TFhirClaimResponseItemAdjudication);
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirClaimResponseAddItemDetailSubDetail.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'modifier') then ModifierList.insertItem(index, propValue as TFhirCodeableConcept)
  else if (propName = 'noteNumber') then NoteNumberList.insertItem(index, asPositiveInt(propValue))
  else if (propName = 'adjudication') then AdjudicationList.insertItem(index, propValue as TFhirClaimResponseItemAdjudication)
  else inherited;
end;

function TFhirClaimResponseAddItemDetailSubDetail.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'productOrService') then result := TFhirCodeableConcept.create()
  else if (propName = 'modifier') then result := ModifierList.new()
  else if (propName = 'quantity') then result := TFhirQuantity.create()
  else if (propName = 'unitPrice') then result := TFhirMoney.create()
  else if (propName = 'factor') then result := TFhirDecimal.create()
  else if (propName = 'net') then result := TFhirMoney.create()
  else if (propName = 'noteNumber') then result := NoteNumberList.new()
  else if (propName = 'adjudication') then result := AdjudicationList.new()
  else result := inherited createPropertyValue(propName);
end;

function TFhirClaimResponseAddItemDetailSubDetail.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'productOrService') then result := 'CodeableConcept'
  else if (propName = 'modifier') then result := 'CodeableConcept'
  else if (propName = 'quantity') then result := 'Quantity'
  else if (propName = 'unitPrice') then result := 'Money'
  else if (propName = 'factor') then result := 'decimal'
  else if (propName = 'net') then result := 'Money'
  else if (propName = 'noteNumber') then result := 'positiveInt'
  else if (propName = 'adjudication') then result := ''
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirClaimResponseAddItemDetailSubDetail.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'productOrService') then ProductOrServiceElement := nil
  else if (propName = 'modifier') then deletePropertyValue('modifier', ModifierList, value)
  else if (propName = 'quantity') then QuantityElement := nil
  else if (propName = 'unitPrice') then UnitPriceElement := nil
  else if (propName = 'factor') then FactorElement := nil
  else if (propName = 'net') then NetElement := nil
  else if (propName = 'noteNumber') then deletePropertyValue('noteNumber', NoteNumberList, value)
  else if (propName = 'adjudication') then deletePropertyValue('adjudication', AdjudicationList, value)
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirClaimResponseAddItemDetailSubDetail.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'productOrService') then ProductOrServiceElement := new as TFhirCodeableConcept
  else if (propName = 'modifier') then replacePropertyValue('modifier', ModifierList, existing, new)
  else if (propName = 'quantity') then QuantityElement := new as TFhirQuantity
  else if (propName = 'unitPrice') then UnitPriceElement := new as TFhirMoney
  else if (propName = 'factor') then FactorElement := asDecimal(new)
  else if (propName = 'net') then NetElement := new as TFhirMoney
  else if (propName = 'noteNumber') then replacePropertyValue('noteNumber', NoteNumberList, existing, new)
  else if (propName = 'adjudication') then replacePropertyValue('adjudication', AdjudicationList, existing, new)
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirClaimResponseAddItemDetailSubDetail.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'modifier') then ModifierList.move(source, destination)
  else if (propName = 'noteNumber') then NoteNumberList.move(source, destination)
  else if (propName = 'adjudication') then AdjudicationList.move(source, destination)
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirClaimResponseAddItemDetailSubDetail.fhirType : string;
begin
  result := 'ClaimResponse.addItem.detail.subDetail';
end;

function TFhirClaimResponseAddItemDetailSubDetail.Link : TFhirClaimResponseAddItemDetailSubDetail;
begin
  result := TFhirClaimResponseAddItemDetailSubDetail(inherited Link);
end;

function TFhirClaimResponseAddItemDetailSubDetail.Clone : TFhirClaimResponseAddItemDetailSubDetail;
begin
  result := TFhirClaimResponseAddItemDetailSubDetail(inherited Clone);
end;

function TFhirClaimResponseAddItemDetailSubDetail.equals(other : TObject) : boolean; 
var
  o : TFhirClaimResponseAddItemDetailSubDetail;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirClaimResponseAddItemDetailSubDetail)) then
    result := false
  else
  begin
    o := TFhirClaimResponseAddItemDetailSubDetail(other);
    result := compareDeep(productOrServiceElement, o.productOrServiceElement, true) and 
      compareDeep(modifierList, o.modifierList, true) and compareDeep(quantityElement, o.quantityElement, true) and 
      compareDeep(unitPriceElement, o.unitPriceElement, true) and compareDeep(factorElement, o.factorElement, true) and 
      compareDeep(netElement, o.netElement, true) and compareDeep(noteNumberList, o.noteNumberList, true) and 
      compareDeep(adjudicationList, o.adjudicationList, true);
  end;
end;

function TFhirClaimResponseAddItemDetailSubDetail.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FProductOrService) and isEmptyProp(FmodifierList) and isEmptyProp(FQuantity) and isEmptyProp(FUnitPrice) and isEmptyProp(FFactor) and isEmptyProp(FNet) and isEmptyProp(FnoteNumberList) and isEmptyProp(FadjudicationList);
end;

procedure TFhirClaimResponseAddItemDetailSubDetail.listFieldsInOrder(fields : TStringList);
begin
  inherited listFieldsInOrder(fields);
  fields.add('productOrService');
  fields.add('modifier');
  fields.add('quantity');
  fields.add('unitPrice');
  fields.add('factor');
  fields.add('net');
  fields.add('noteNumber');
  fields.add('adjudication');
end;

function TFhirClaimResponseAddItemDetailSubDetail.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FModifierList.sizeInBytes(magic));
  inc(result, FNoteNumberList.sizeInBytes(magic));
  inc(result, FAdjudicationList.sizeInBytes(magic));
end;

procedure TFhirClaimResponseAddItemDetailSubDetail.SetProductOrService(value : TFhirCodeableConcept);
begin
  FProductOrService.free;
  FProductOrService := value;
end;

function TFhirClaimResponseAddItemDetailSubDetail.GetModifierList : TFhirCodeableConceptList;
begin
  if FModifierList = nil then
    FModifierList := TFhirCodeableConceptList.Create;
  result := FModifierList;
end;

function TFhirClaimResponseAddItemDetailSubDetail.GetHasModifierList : boolean;
begin
  result := (FModifierList <> nil) and (FModifierList.count > 0);
end;

procedure TFhirClaimResponseAddItemDetailSubDetail.SetQuantity(value : TFhirQuantity);
begin
  FQuantity.free;
  FQuantity := value;
end;

procedure TFhirClaimResponseAddItemDetailSubDetail.SetUnitPrice(value : TFhirMoney);
begin
  FUnitPrice.free;
  FUnitPrice := value;
end;

procedure TFhirClaimResponseAddItemDetailSubDetail.SetFactor(value : TFhirDecimal);
begin
  FFactor.free;
  FFactor := value;
end;

function TFhirClaimResponseAddItemDetailSubDetail.GetFactorST : String;
begin
  if FFactor = nil then
    result := ''
  else
    result := FFactor.value;
end;

procedure TFhirClaimResponseAddItemDetailSubDetail.SetFactorST(value : String);
begin
  if value <> '' then
  begin
    if FFactor = nil then
      FFactor := TFhirDecimal.create;
    FFactor.value := value
  end
  else if FFactor <> nil then
    FFactor.value := '';
end;

procedure TFhirClaimResponseAddItemDetailSubDetail.SetNet(value : TFhirMoney);
begin
  FNet.free;
  FNet := value;
end;

function TFhirClaimResponseAddItemDetailSubDetail.GetNoteNumberList : TFhirPositiveIntList;
begin
  if FNoteNumberList = nil then
    FNoteNumberList := TFhirPositiveIntList.Create;
  result := FNoteNumberList;
end;

function TFhirClaimResponseAddItemDetailSubDetail.GetHasNoteNumberList : boolean;
begin
  result := (FNoteNumberList <> nil) and (FNoteNumberList.count > 0);
end;

function TFhirClaimResponseAddItemDetailSubDetail.GetAdjudicationList : TFhirClaimResponseItemAdjudicationList;
begin
  if FAdjudicationList = nil then
    FAdjudicationList := TFhirClaimResponseItemAdjudicationList.Create;
  result := FAdjudicationList;
end;

function TFhirClaimResponseAddItemDetailSubDetail.GetHasAdjudicationList : boolean;
begin
  result := (FAdjudicationList <> nil) and (FAdjudicationList.count > 0);
end;

{ TFhirClaimResponseAddItemDetailSubDetailListEnumerator }

constructor TFhirClaimResponseAddItemDetailSubDetailListEnumerator.Create(list : TFhirClaimResponseAddItemDetailSubDetailList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirClaimResponseAddItemDetailSubDetailListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirClaimResponseAddItemDetailSubDetailListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirClaimResponseAddItemDetailSubDetailListEnumerator.GetCurrent : TFhirClaimResponseAddItemDetailSubDetail;
begin
  Result := FList[FIndex];
end;

function TFhirClaimResponseAddItemDetailSubDetailListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirClaimResponseAddItemDetailSubDetailList }

procedure TFhirClaimResponseAddItemDetailSubDetailList.AddItem(value: TFhirClaimResponseAddItemDetailSubDetail);
begin
  assert(value.ClassName = 'TFhirClaimResponseAddItemDetailSubDetail', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirClaimResponseAddItemDetailSubDetail');
  add(value);
end;

function TFhirClaimResponseAddItemDetailSubDetailList.Append: TFhirClaimResponseAddItemDetailSubDetail;
begin
  result := TFhirClaimResponseAddItemDetailSubDetail.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirClaimResponseAddItemDetailSubDetailList.ClearItems;
begin
  Clear;
end;

function TFhirClaimResponseAddItemDetailSubDetailList.GetEnumerator : TFhirClaimResponseAddItemDetailSubDetailListEnumerator;
begin
  result := TFhirClaimResponseAddItemDetailSubDetailListEnumerator.Create(self.link);
end;

function TFhirClaimResponseAddItemDetailSubDetailList.Clone: TFhirClaimResponseAddItemDetailSubDetailList;
begin
  result := TFhirClaimResponseAddItemDetailSubDetailList(inherited Clone);
end;

function TFhirClaimResponseAddItemDetailSubDetailList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirClaimResponseAddItemDetailSubDetailList.GetItemN(index: Integer): TFhirClaimResponseAddItemDetailSubDetail;
begin
  result := TFhirClaimResponseAddItemDetailSubDetail(ObjectByIndex[index]);
end;

function TFhirClaimResponseAddItemDetailSubDetailList.ItemClass: TFslObjectClass;
begin
  result := TFhirClaimResponseAddItemDetailSubDetail;
end;
function TFhirClaimResponseAddItemDetailSubDetailList.IndexOf(value: TFhirClaimResponseAddItemDetailSubDetail): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirClaimResponseAddItemDetailSubDetailList.Insert(index: Integer): TFhirClaimResponseAddItemDetailSubDetail;
begin
  result := TFhirClaimResponseAddItemDetailSubDetail.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirClaimResponseAddItemDetailSubDetailList.InsertItem(index: Integer; value: TFhirClaimResponseAddItemDetailSubDetail);
begin
  assert(value is TFhirClaimResponseAddItemDetailSubDetail);
  Inherited Insert(index, value);
end;

function TFhirClaimResponseAddItemDetailSubDetailList.Item(index: Integer): TFhirClaimResponseAddItemDetailSubDetail;
begin
  result := TFhirClaimResponseAddItemDetailSubDetail(ObjectByIndex[index]);
end;

function TFhirClaimResponseAddItemDetailSubDetailList.Link: TFhirClaimResponseAddItemDetailSubDetailList;
begin
  result := TFhirClaimResponseAddItemDetailSubDetailList(inherited Link);
end;

procedure TFhirClaimResponseAddItemDetailSubDetailList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirClaimResponseAddItemDetailSubDetailList.SetItemByIndex(index: Integer; value: TFhirClaimResponseAddItemDetailSubDetail);
begin
  assert(value is TFhirClaimResponseAddItemDetailSubDetail);
  FhirClaimResponseAddItemDetailSubDetails[index] := value;
end;

procedure TFhirClaimResponseAddItemDetailSubDetailList.SetItemN(index: Integer; value: TFhirClaimResponseAddItemDetailSubDetail);
begin
  assert(value is TFhirClaimResponseAddItemDetailSubDetail);
  ObjectByIndex[index] := value;
end;

{ TFhirClaimResponseTotal }

constructor TFhirClaimResponseTotal.Create;
begin
  inherited;
end;

destructor TFhirClaimResponseTotal.Destroy;
begin
  FCategory.free;
  FAmount.free;
  inherited;
end;

procedure TFhirClaimResponseTotal.Assign(oSource : TFslObject);
begin
  inherited;
  category := TFhirClaimResponseTotal(oSource).category.Clone;
  amount := TFhirClaimResponseTotal(oSource).amount.Clone;
end;

procedure TFhirClaimResponseTotal.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'category') Then
     list.add(self.link, 'category', FCategory.Link);
  if (child_name = 'amount') Then
     list.add(self.link, 'amount', FAmount.Link);
end;

procedure TFhirClaimResponseTotal.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'category', 'CodeableConcept', false, TFhirCodeableConcept, FCategory.Link));
  oList.add(TFHIRProperty.create(self, 'amount', 'Money', false, TFhirMoney, FAmount.Link));
end;

function TFhirClaimResponseTotal.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'category') then
  begin
    Category := propValue as TFhirCodeableConcept;
    result := propValue;
  end
  else if (propName = 'amount') then
  begin
    Amount := propValue as TFhirMoney;
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirClaimResponseTotal.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirClaimResponseTotal.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'category') then result := TFhirCodeableConcept.create()
  else if (propName = 'amount') then result := TFhirMoney.create()
  else result := inherited createPropertyValue(propName);
end;

function TFhirClaimResponseTotal.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'category') then result := 'CodeableConcept'
  else if (propName = 'amount') then result := 'Money'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirClaimResponseTotal.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'category') then CategoryElement := nil
  else if (propName = 'amount') then AmountElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirClaimResponseTotal.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'category') then CategoryElement := new as TFhirCodeableConcept
  else if (propName = 'amount') then AmountElement := new as TFhirMoney
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirClaimResponseTotal.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirClaimResponseTotal.fhirType : string;
begin
  result := 'ClaimResponse.total';
end;

function TFhirClaimResponseTotal.Link : TFhirClaimResponseTotal;
begin
  result := TFhirClaimResponseTotal(inherited Link);
end;

function TFhirClaimResponseTotal.Clone : TFhirClaimResponseTotal;
begin
  result := TFhirClaimResponseTotal(inherited Clone);
end;

function TFhirClaimResponseTotal.equals(other : TObject) : boolean; 
var
  o : TFhirClaimResponseTotal;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirClaimResponseTotal)) then
    result := false
  else
  begin
    o := TFhirClaimResponseTotal(other);
    result := compareDeep(categoryElement, o.categoryElement, true) and compareDeep(amountElement, o.amountElement, true);
  end;
end;

function TFhirClaimResponseTotal.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FCategory) and isEmptyProp(FAmount);
end;

procedure TFhirClaimResponseTotal.listFieldsInOrder(fields : TStringList);
begin
  inherited listFieldsInOrder(fields);
  fields.add('category');
  fields.add('amount');
end;

function TFhirClaimResponseTotal.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
end;

procedure TFhirClaimResponseTotal.SetCategory(value : TFhirCodeableConcept);
begin
  FCategory.free;
  FCategory := value;
end;

procedure TFhirClaimResponseTotal.SetAmount(value : TFhirMoney);
begin
  FAmount.free;
  FAmount := value;
end;

{ TFhirClaimResponseTotalListEnumerator }

constructor TFhirClaimResponseTotalListEnumerator.Create(list : TFhirClaimResponseTotalList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirClaimResponseTotalListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirClaimResponseTotalListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirClaimResponseTotalListEnumerator.GetCurrent : TFhirClaimResponseTotal;
begin
  Result := FList[FIndex];
end;

function TFhirClaimResponseTotalListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirClaimResponseTotalList }

procedure TFhirClaimResponseTotalList.AddItem(value: TFhirClaimResponseTotal);
begin
  assert(value.ClassName = 'TFhirClaimResponseTotal', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirClaimResponseTotal');
  add(value);
end;

function TFhirClaimResponseTotalList.Append: TFhirClaimResponseTotal;
begin
  result := TFhirClaimResponseTotal.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirClaimResponseTotalList.ClearItems;
begin
  Clear;
end;

function TFhirClaimResponseTotalList.GetEnumerator : TFhirClaimResponseTotalListEnumerator;
begin
  result := TFhirClaimResponseTotalListEnumerator.Create(self.link);
end;

function TFhirClaimResponseTotalList.Clone: TFhirClaimResponseTotalList;
begin
  result := TFhirClaimResponseTotalList(inherited Clone);
end;

function TFhirClaimResponseTotalList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirClaimResponseTotalList.GetItemN(index: Integer): TFhirClaimResponseTotal;
begin
  result := TFhirClaimResponseTotal(ObjectByIndex[index]);
end;

function TFhirClaimResponseTotalList.ItemClass: TFslObjectClass;
begin
  result := TFhirClaimResponseTotal;
end;
function TFhirClaimResponseTotalList.IndexOf(value: TFhirClaimResponseTotal): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirClaimResponseTotalList.Insert(index: Integer): TFhirClaimResponseTotal;
begin
  result := TFhirClaimResponseTotal.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirClaimResponseTotalList.InsertItem(index: Integer; value: TFhirClaimResponseTotal);
begin
  assert(value is TFhirClaimResponseTotal);
  Inherited Insert(index, value);
end;

function TFhirClaimResponseTotalList.Item(index: Integer): TFhirClaimResponseTotal;
begin
  result := TFhirClaimResponseTotal(ObjectByIndex[index]);
end;

function TFhirClaimResponseTotalList.Link: TFhirClaimResponseTotalList;
begin
  result := TFhirClaimResponseTotalList(inherited Link);
end;

procedure TFhirClaimResponseTotalList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirClaimResponseTotalList.SetItemByIndex(index: Integer; value: TFhirClaimResponseTotal);
begin
  assert(value is TFhirClaimResponseTotal);
  FhirClaimResponseTotals[index] := value;
end;

procedure TFhirClaimResponseTotalList.SetItemN(index: Integer; value: TFhirClaimResponseTotal);
begin
  assert(value is TFhirClaimResponseTotal);
  ObjectByIndex[index] := value;
end;

{ TFhirClaimResponsePayment }

constructor TFhirClaimResponsePayment.Create;
begin
  inherited;
end;

destructor TFhirClaimResponsePayment.Destroy;
begin
  FType_.free;
  FAdjustment.free;
  FAdjustmentReason.free;
  FDate.free;
  FAmount.free;
  FIdentifier.free;
  inherited;
end;

procedure TFhirClaimResponsePayment.Assign(oSource : TFslObject);
begin
  inherited;
  type_ := TFhirClaimResponsePayment(oSource).type_.Clone;
  adjustment := TFhirClaimResponsePayment(oSource).adjustment.Clone;
  adjustmentReason := TFhirClaimResponsePayment(oSource).adjustmentReason.Clone;
  dateElement := TFhirClaimResponsePayment(oSource).dateElement.Clone;
  amount := TFhirClaimResponsePayment(oSource).amount.Clone;
  identifier := TFhirClaimResponsePayment(oSource).identifier.Clone;
end;

procedure TFhirClaimResponsePayment.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'type') Then
     list.add(self.link, 'type', FType_.Link);
  if (child_name = 'adjustment') Then
     list.add(self.link, 'adjustment', FAdjustment.Link);
  if (child_name = 'adjustmentReason') Then
     list.add(self.link, 'adjustmentReason', FAdjustmentReason.Link);
  if (child_name = 'date') Then
     list.add(self.link, 'date', FDate.Link);
  if (child_name = 'amount') Then
     list.add(self.link, 'amount', FAmount.Link);
  if (child_name = 'identifier') Then
     list.add(self.link, 'identifier', FIdentifier.Link);
end;

procedure TFhirClaimResponsePayment.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'type', 'CodeableConcept', false, TFhirCodeableConcept, FType_.Link));
  oList.add(TFHIRProperty.create(self, 'adjustment', 'Money', false, TFhirMoney, FAdjustment.Link));
  oList.add(TFHIRProperty.create(self, 'adjustmentReason', 'CodeableConcept', false, TFhirCodeableConcept, FAdjustmentReason.Link));
  oList.add(TFHIRProperty.create(self, 'date', 'date', false, TFhirDate, FDate.Link));
  oList.add(TFHIRProperty.create(self, 'amount', 'Money', false, TFhirMoney, FAmount.Link));
  oList.add(TFHIRProperty.create(self, 'identifier', 'Identifier', false, TFhirIdentifier, FIdentifier.Link));
end;

function TFhirClaimResponsePayment.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'type') then
  begin
    Type_ := propValue as TFhirCodeableConcept;
    result := propValue;
  end
  else if (propName = 'adjustment') then
  begin
    Adjustment := propValue as TFhirMoney;
    result := propValue;
  end
  else if (propName = 'adjustmentReason') then
  begin
    AdjustmentReason := propValue as TFhirCodeableConcept;
    result := propValue;
  end
  else if (propName = 'date') then
  begin
    DateElement := asDate(propValue);
    result := propValue;
  end
  else if (propName = 'amount') then
  begin
    Amount := propValue as TFhirMoney;
    result := propValue;
  end
  else if (propName = 'identifier') then
  begin
    Identifier := propValue as TFhirIdentifier;
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirClaimResponsePayment.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirClaimResponsePayment.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'type') then result := TFhirCodeableConcept.create()
  else if (propName = 'adjustment') then result := TFhirMoney.create()
  else if (propName = 'adjustmentReason') then result := TFhirCodeableConcept.create()
  else if (propName = 'date') then result := TFhirDate.create()
  else if (propName = 'amount') then result := TFhirMoney.create()
  else if (propName = 'identifier') then result := TFhirIdentifier.create()
  else result := inherited createPropertyValue(propName);
end;

function TFhirClaimResponsePayment.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'type') then result := 'CodeableConcept'
  else if (propName = 'adjustment') then result := 'Money'
  else if (propName = 'adjustmentReason') then result := 'CodeableConcept'
  else if (propName = 'date') then result := 'date'
  else if (propName = 'amount') then result := 'Money'
  else if (propName = 'identifier') then result := 'Identifier'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirClaimResponsePayment.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'type') then Type_Element := nil
  else if (propName = 'adjustment') then AdjustmentElement := nil
  else if (propName = 'adjustmentReason') then AdjustmentReasonElement := nil
  else if (propName = 'date') then DateElement := nil
  else if (propName = 'amount') then AmountElement := nil
  else if (propName = 'identifier') then IdentifierElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirClaimResponsePayment.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'type') then Type_Element := new as TFhirCodeableConcept
  else if (propName = 'adjustment') then AdjustmentElement := new as TFhirMoney
  else if (propName = 'adjustmentReason') then AdjustmentReasonElement := new as TFhirCodeableConcept
  else if (propName = 'date') then DateElement := asDate(new)
  else if (propName = 'amount') then AmountElement := new as TFhirMoney
  else if (propName = 'identifier') then IdentifierElement := new as TFhirIdentifier
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirClaimResponsePayment.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirClaimResponsePayment.fhirType : string;
begin
  result := 'ClaimResponse.payment';
end;

function TFhirClaimResponsePayment.Link : TFhirClaimResponsePayment;
begin
  result := TFhirClaimResponsePayment(inherited Link);
end;

function TFhirClaimResponsePayment.Clone : TFhirClaimResponsePayment;
begin
  result := TFhirClaimResponsePayment(inherited Clone);
end;

function TFhirClaimResponsePayment.equals(other : TObject) : boolean; 
var
  o : TFhirClaimResponsePayment;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirClaimResponsePayment)) then
    result := false
  else
  begin
    o := TFhirClaimResponsePayment(other);
    result := compareDeep(type_Element, o.type_Element, true) and compareDeep(adjustmentElement, o.adjustmentElement, true) and 
      compareDeep(adjustmentReasonElement, o.adjustmentReasonElement, true) and compareDeep(dateElement, o.dateElement, true) and 
      compareDeep(amountElement, o.amountElement, true) and compareDeep(identifierElement, o.identifierElement, true);
  end;
end;

function TFhirClaimResponsePayment.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FType_) and isEmptyProp(FAdjustment) and isEmptyProp(FAdjustmentReason) and isEmptyProp(FDate) and isEmptyProp(FAmount) and isEmptyProp(FIdentifier);
end;

procedure TFhirClaimResponsePayment.listFieldsInOrder(fields : TStringList);
begin
  inherited listFieldsInOrder(fields);
  fields.add('type');
  fields.add('adjustment');
  fields.add('adjustmentReason');
  fields.add('date');
  fields.add('amount');
  fields.add('identifier');
end;

function TFhirClaimResponsePayment.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
end;

procedure TFhirClaimResponsePayment.SetType_(value : TFhirCodeableConcept);
begin
  FType_.free;
  FType_ := value;
end;

procedure TFhirClaimResponsePayment.SetAdjustment(value : TFhirMoney);
begin
  FAdjustment.free;
  FAdjustment := value;
end;

procedure TFhirClaimResponsePayment.SetAdjustmentReason(value : TFhirCodeableConcept);
begin
  FAdjustmentReason.free;
  FAdjustmentReason := value;
end;

procedure TFhirClaimResponsePayment.SetDate(value : TFhirDate);
begin
  FDate.free;
  FDate := value;
end;

function TFhirClaimResponsePayment.GetDateST : TFslDateTime;
begin
  if FDate = nil then
    result := TFslDateTime.makeNull
  else
    result := FDate.value;
end;

procedure TFhirClaimResponsePayment.SetDateST(value : TFslDateTime);
begin
  if FDate = nil then
    FDate := TFhirDate.create;
  FDate.value := value
end;

procedure TFhirClaimResponsePayment.SetAmount(value : TFhirMoney);
begin
  FAmount.free;
  FAmount := value;
end;

procedure TFhirClaimResponsePayment.SetIdentifier(value : TFhirIdentifier);
begin
  FIdentifier.free;
  FIdentifier := value;
end;

{ TFhirClaimResponsePaymentListEnumerator }

constructor TFhirClaimResponsePaymentListEnumerator.Create(list : TFhirClaimResponsePaymentList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirClaimResponsePaymentListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirClaimResponsePaymentListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirClaimResponsePaymentListEnumerator.GetCurrent : TFhirClaimResponsePayment;
begin
  Result := FList[FIndex];
end;

function TFhirClaimResponsePaymentListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirClaimResponsePaymentList }

procedure TFhirClaimResponsePaymentList.AddItem(value: TFhirClaimResponsePayment);
begin
  assert(value.ClassName = 'TFhirClaimResponsePayment', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirClaimResponsePayment');
  add(value);
end;

function TFhirClaimResponsePaymentList.Append: TFhirClaimResponsePayment;
begin
  result := TFhirClaimResponsePayment.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirClaimResponsePaymentList.ClearItems;
begin
  Clear;
end;

function TFhirClaimResponsePaymentList.GetEnumerator : TFhirClaimResponsePaymentListEnumerator;
begin
  result := TFhirClaimResponsePaymentListEnumerator.Create(self.link);
end;

function TFhirClaimResponsePaymentList.Clone: TFhirClaimResponsePaymentList;
begin
  result := TFhirClaimResponsePaymentList(inherited Clone);
end;

function TFhirClaimResponsePaymentList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirClaimResponsePaymentList.GetItemN(index: Integer): TFhirClaimResponsePayment;
begin
  result := TFhirClaimResponsePayment(ObjectByIndex[index]);
end;

function TFhirClaimResponsePaymentList.ItemClass: TFslObjectClass;
begin
  result := TFhirClaimResponsePayment;
end;
function TFhirClaimResponsePaymentList.IndexOf(value: TFhirClaimResponsePayment): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirClaimResponsePaymentList.Insert(index: Integer): TFhirClaimResponsePayment;
begin
  result := TFhirClaimResponsePayment.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirClaimResponsePaymentList.InsertItem(index: Integer; value: TFhirClaimResponsePayment);
begin
  assert(value is TFhirClaimResponsePayment);
  Inherited Insert(index, value);
end;

function TFhirClaimResponsePaymentList.Item(index: Integer): TFhirClaimResponsePayment;
begin
  result := TFhirClaimResponsePayment(ObjectByIndex[index]);
end;

function TFhirClaimResponsePaymentList.Link: TFhirClaimResponsePaymentList;
begin
  result := TFhirClaimResponsePaymentList(inherited Link);
end;

procedure TFhirClaimResponsePaymentList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirClaimResponsePaymentList.SetItemByIndex(index: Integer; value: TFhirClaimResponsePayment);
begin
  assert(value is TFhirClaimResponsePayment);
  FhirClaimResponsePayments[index] := value;
end;

procedure TFhirClaimResponsePaymentList.SetItemN(index: Integer; value: TFhirClaimResponsePayment);
begin
  assert(value is TFhirClaimResponsePayment);
  ObjectByIndex[index] := value;
end;

{ TFhirClaimResponseProcessNote }

constructor TFhirClaimResponseProcessNote.Create;
begin
  inherited;
end;

destructor TFhirClaimResponseProcessNote.Destroy;
begin
  FNumber.free;
  FType_.free;
  FText.free;
  FLanguage.free;
  inherited;
end;

procedure TFhirClaimResponseProcessNote.Assign(oSource : TFslObject);
begin
  inherited;
  numberElement := TFhirClaimResponseProcessNote(oSource).numberElement.Clone;
  type_Element := TFhirClaimResponseProcessNote(oSource).type_Element.Clone;
  textElement := TFhirClaimResponseProcessNote(oSource).textElement.Clone;
  language := TFhirClaimResponseProcessNote(oSource).language.Clone;
end;

procedure TFhirClaimResponseProcessNote.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'number') Then
     list.add(self.link, 'number', FNumber.Link);
  if (child_name = 'type') Then
     list.add(self.link, 'type', FType_.Link);
  if (child_name = 'text') Then
     list.add(self.link, 'text', FText.Link);
  if (child_name = 'language') Then
     list.add(self.link, 'language', FLanguage.Link);
end;

procedure TFhirClaimResponseProcessNote.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'number', 'positiveInt', false, TFhirPositiveInt, FNumber.Link));
  oList.add(TFHIRProperty.create(self, 'type', 'code', false, TFhirEnum, FType_.Link));
  oList.add(TFHIRProperty.create(self, 'text', 'string', false, TFhirString, FText.Link));
  oList.add(TFHIRProperty.create(self, 'language', 'CodeableConcept', false, TFhirCodeableConcept, FLanguage.Link));
end;

function TFhirClaimResponseProcessNote.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'number') then
  begin
    NumberElement := asPositiveInt(propValue);
    result := propValue;
  end
  else if (propName = 'type') then
  begin
    Type_Element := asEnum(SYSTEMS_TFhirNoteTypeEnum, CODES_TFhirNoteTypeEnum, propValue);
    result := propValue;
  end
  else if (propName = 'text') then
  begin
    TextElement := asString(propValue);
    result := propValue;
  end
  else if (propName = 'language') then
  begin
    Language := propValue as TFhirCodeableConcept;
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirClaimResponseProcessNote.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirClaimResponseProcessNote.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'number') then result := TFhirPositiveInt.create()
  else if (propName = 'type') then result := TFhirEnum.create(SYSTEMS_TFhirNoteTypeEnum[NoteTypeNull], CODES_TFhirNoteTypeEnum[NoteTypeNull]) 
  else if (propName = 'text') then result := TFhirString.create()
  else if (propName = 'language') then result := TFhirCodeableConcept.create()
  else result := inherited createPropertyValue(propName);
end;

function TFhirClaimResponseProcessNote.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'number') then result := 'positiveInt'
  else if (propName = 'type') then result := 'code'
  else if (propName = 'text') then result := 'string'
  else if (propName = 'language') then result := 'CodeableConcept'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirClaimResponseProcessNote.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'number') then NumberElement := nil
  else if (propName = 'type') then Type_Element := nil
  else if (propName = 'text') then TextElement := nil
  else if (propName = 'language') then LanguageElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirClaimResponseProcessNote.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'number') then NumberElement := asPositiveInt(new)
  else if (propName = 'type') then Type_Element := asEnum(SYSTEMS_TFhirNoteTypeEnum, CODES_TFhirNoteTypeEnum, new)
  else if (propName = 'text') then TextElement := asString(new)
  else if (propName = 'language') then LanguageElement := new as TFhirCodeableConcept
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirClaimResponseProcessNote.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirClaimResponseProcessNote.fhirType : string;
begin
  result := 'ClaimResponse.processNote';
end;

function TFhirClaimResponseProcessNote.Link : TFhirClaimResponseProcessNote;
begin
  result := TFhirClaimResponseProcessNote(inherited Link);
end;

function TFhirClaimResponseProcessNote.Clone : TFhirClaimResponseProcessNote;
begin
  result := TFhirClaimResponseProcessNote(inherited Clone);
end;

function TFhirClaimResponseProcessNote.equals(other : TObject) : boolean; 
var
  o : TFhirClaimResponseProcessNote;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirClaimResponseProcessNote)) then
    result := false
  else
  begin
    o := TFhirClaimResponseProcessNote(other);
    result := compareDeep(numberElement, o.numberElement, true) and compareDeep(type_Element, o.type_Element, true) and 
      compareDeep(textElement, o.textElement, true) and compareDeep(languageElement, o.languageElement, true);
  end;
end;

function TFhirClaimResponseProcessNote.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FNumber) and isEmptyProp(FType_) and isEmptyProp(FText) and isEmptyProp(FLanguage);
end;

procedure TFhirClaimResponseProcessNote.listFieldsInOrder(fields : TStringList);
begin
  inherited listFieldsInOrder(fields);
  fields.add('number');
  fields.add('type');
  fields.add('text');
  fields.add('language');
end;

function TFhirClaimResponseProcessNote.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
end;

procedure TFhirClaimResponseProcessNote.SetNumber(value : TFhirPositiveInt);
begin
  FNumber.free;
  FNumber := value;
end;

function TFhirClaimResponseProcessNote.GetNumberST : String;
begin
  if FNumber = nil then
    result := ''
  else
    result := FNumber.value;
end;

procedure TFhirClaimResponseProcessNote.SetNumberST(value : String);
begin
  if value <> '' then
  begin
    if FNumber = nil then
      FNumber := TFhirPositiveInt.create;
    FNumber.value := value
  end
  else if FNumber <> nil then
    FNumber.value := '';
end;

procedure TFhirClaimResponseProcessNote.SetType_(value : TFhirEnum);
begin
  FType_.free;
  FType_ := value;
end;

function TFhirClaimResponseProcessNote.GetType_ST : TFhirNoteTypeEnum;
begin
  if FType_ = nil then
    result := TFhirNoteTypeEnum(0)
  else
    result := TFhirNoteTypeEnum(StringArrayIndexOfSensitive(CODES_TFhirNoteTypeEnum, FType_.value));
end;

procedure TFhirClaimResponseProcessNote.SetType_ST(value : TFhirNoteTypeEnum);
begin
  if ord(value) = 0 then
    Type_Element := nil
  else
    Type_Element := TFhirEnum.create(SYSTEMS_TFhirNoteTypeEnum[value], CODES_TFhirNoteTypeEnum[value]);
end;

procedure TFhirClaimResponseProcessNote.SetText(value : TFhirString);
begin
  FText.free;
  FText := value;
end;

function TFhirClaimResponseProcessNote.GetTextST : String;
begin
  if FText = nil then
    result := ''
  else
    result := FText.value;
end;

procedure TFhirClaimResponseProcessNote.SetTextST(value : String);
begin
  if value <> '' then
  begin
    if FText = nil then
      FText := TFhirString.create;
    FText.value := value
  end
  else if FText <> nil then
    FText.value := '';
end;

procedure TFhirClaimResponseProcessNote.SetLanguage(value : TFhirCodeableConcept);
begin
  FLanguage.free;
  FLanguage := value;
end;

{ TFhirClaimResponseProcessNoteListEnumerator }

constructor TFhirClaimResponseProcessNoteListEnumerator.Create(list : TFhirClaimResponseProcessNoteList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirClaimResponseProcessNoteListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirClaimResponseProcessNoteListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirClaimResponseProcessNoteListEnumerator.GetCurrent : TFhirClaimResponseProcessNote;
begin
  Result := FList[FIndex];
end;

function TFhirClaimResponseProcessNoteListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirClaimResponseProcessNoteList }

procedure TFhirClaimResponseProcessNoteList.AddItem(value: TFhirClaimResponseProcessNote);
begin
  assert(value.ClassName = 'TFhirClaimResponseProcessNote', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirClaimResponseProcessNote');
  add(value);
end;

function TFhirClaimResponseProcessNoteList.Append: TFhirClaimResponseProcessNote;
begin
  result := TFhirClaimResponseProcessNote.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirClaimResponseProcessNoteList.ClearItems;
begin
  Clear;
end;

function TFhirClaimResponseProcessNoteList.GetEnumerator : TFhirClaimResponseProcessNoteListEnumerator;
begin
  result := TFhirClaimResponseProcessNoteListEnumerator.Create(self.link);
end;

function TFhirClaimResponseProcessNoteList.Clone: TFhirClaimResponseProcessNoteList;
begin
  result := TFhirClaimResponseProcessNoteList(inherited Clone);
end;

function TFhirClaimResponseProcessNoteList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirClaimResponseProcessNoteList.GetItemN(index: Integer): TFhirClaimResponseProcessNote;
begin
  result := TFhirClaimResponseProcessNote(ObjectByIndex[index]);
end;

function TFhirClaimResponseProcessNoteList.ItemClass: TFslObjectClass;
begin
  result := TFhirClaimResponseProcessNote;
end;
function TFhirClaimResponseProcessNoteList.IndexOf(value: TFhirClaimResponseProcessNote): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirClaimResponseProcessNoteList.Insert(index: Integer): TFhirClaimResponseProcessNote;
begin
  result := TFhirClaimResponseProcessNote.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirClaimResponseProcessNoteList.InsertItem(index: Integer; value: TFhirClaimResponseProcessNote);
begin
  assert(value is TFhirClaimResponseProcessNote);
  Inherited Insert(index, value);
end;

function TFhirClaimResponseProcessNoteList.Item(index: Integer): TFhirClaimResponseProcessNote;
begin
  result := TFhirClaimResponseProcessNote(ObjectByIndex[index]);
end;

function TFhirClaimResponseProcessNoteList.Link: TFhirClaimResponseProcessNoteList;
begin
  result := TFhirClaimResponseProcessNoteList(inherited Link);
end;

procedure TFhirClaimResponseProcessNoteList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirClaimResponseProcessNoteList.SetItemByIndex(index: Integer; value: TFhirClaimResponseProcessNote);
begin
  assert(value is TFhirClaimResponseProcessNote);
  FhirClaimResponseProcessNotes[index] := value;
end;

procedure TFhirClaimResponseProcessNoteList.SetItemN(index: Integer; value: TFhirClaimResponseProcessNote);
begin
  assert(value is TFhirClaimResponseProcessNote);
  ObjectByIndex[index] := value;
end;

{ TFhirClaimResponseInsurance }

constructor TFhirClaimResponseInsurance.Create;
begin
  inherited;
end;

destructor TFhirClaimResponseInsurance.Destroy;
begin
  FSequence.free;
  FFocal.free;
  FCoverage.free;
  FBusinessArrangement.free;
  FClaimResponse.free;
  inherited;
end;

procedure TFhirClaimResponseInsurance.Assign(oSource : TFslObject);
begin
  inherited;
  sequenceElement := TFhirClaimResponseInsurance(oSource).sequenceElement.Clone;
  focalElement := TFhirClaimResponseInsurance(oSource).focalElement.Clone;
  coverage := TFhirClaimResponseInsurance(oSource).coverage.Clone;
  businessArrangementElement := TFhirClaimResponseInsurance(oSource).businessArrangementElement.Clone;
  claimResponse := TFhirClaimResponseInsurance(oSource).claimResponse.Clone;
end;

procedure TFhirClaimResponseInsurance.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'sequence') Then
     list.add(self.link, 'sequence', FSequence.Link);
  if (child_name = 'focal') Then
     list.add(self.link, 'focal', FFocal.Link);
  if (child_name = 'coverage') Then
     list.add(self.link, 'coverage', FCoverage.Link);
  if (child_name = 'businessArrangement') Then
     list.add(self.link, 'businessArrangement', FBusinessArrangement.Link);
  if (child_name = 'claimResponse') Then
     list.add(self.link, 'claimResponse', FClaimResponse.Link);
end;

procedure TFhirClaimResponseInsurance.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'sequence', 'positiveInt', false, TFhirPositiveInt, FSequence.Link));
  oList.add(TFHIRProperty.create(self, 'focal', 'boolean', false, TFhirBoolean, FFocal.Link));
  oList.add(TFHIRProperty.create(self, 'coverage', 'Reference', false, TFhirReference, FCoverage.Link));
  oList.add(TFHIRProperty.create(self, 'businessArrangement', 'string', false, TFhirString, FBusinessArrangement.Link));
  oList.add(TFHIRProperty.create(self, 'claimResponse', 'Reference', false, TFhirReference, FClaimResponse.Link));
end;

function TFhirClaimResponseInsurance.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'sequence') then
  begin
    SequenceElement := asPositiveInt(propValue);
    result := propValue;
  end
  else if (propName = 'focal') then
  begin
    FocalElement := asBoolean(propValue);
    result := propValue;
  end
  else if (propName = 'coverage') then
  begin
    Coverage := propValue as TFhirReference;
    result := propValue;
  end
  else if (propName = 'businessArrangement') then
  begin
    BusinessArrangementElement := asString(propValue);
    result := propValue;
  end
  else if (propName = 'claimResponse') then
  begin
    ClaimResponse := propValue as TFhirReference;
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirClaimResponseInsurance.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirClaimResponseInsurance.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'sequence') then result := TFhirPositiveInt.create()
  else if (propName = 'focal') then result := TFhirBoolean.create()
  else if (propName = 'coverage') then result := TFhirReference.create()
  else if (propName = 'businessArrangement') then result := TFhirString.create()
  else if (propName = 'claimResponse') then result := TFhirReference.create()
  else result := inherited createPropertyValue(propName);
end;

function TFhirClaimResponseInsurance.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'sequence') then result := 'positiveInt'
  else if (propName = 'focal') then result := 'boolean'
  else if (propName = 'coverage') then result := 'Reference'
  else if (propName = 'businessArrangement') then result := 'string'
  else if (propName = 'claimResponse') then result := 'Reference'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirClaimResponseInsurance.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'sequence') then SequenceElement := nil
  else if (propName = 'focal') then FocalElement := nil
  else if (propName = 'coverage') then CoverageElement := nil
  else if (propName = 'businessArrangement') then BusinessArrangementElement := nil
  else if (propName = 'claimResponse') then ClaimResponseElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirClaimResponseInsurance.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'sequence') then SequenceElement := asPositiveInt(new)
  else if (propName = 'focal') then FocalElement := asBoolean(new)
  else if (propName = 'coverage') then CoverageElement := new as TFhirReference
  else if (propName = 'businessArrangement') then BusinessArrangementElement := asString(new)
  else if (propName = 'claimResponse') then ClaimResponseElement := new as TFhirReference
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirClaimResponseInsurance.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirClaimResponseInsurance.fhirType : string;
begin
  result := 'ClaimResponse.insurance';
end;

function TFhirClaimResponseInsurance.Link : TFhirClaimResponseInsurance;
begin
  result := TFhirClaimResponseInsurance(inherited Link);
end;

function TFhirClaimResponseInsurance.Clone : TFhirClaimResponseInsurance;
begin
  result := TFhirClaimResponseInsurance(inherited Clone);
end;

function TFhirClaimResponseInsurance.equals(other : TObject) : boolean; 
var
  o : TFhirClaimResponseInsurance;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirClaimResponseInsurance)) then
    result := false
  else
  begin
    o := TFhirClaimResponseInsurance(other);
    result := compareDeep(sequenceElement, o.sequenceElement, true) and compareDeep(focalElement, o.focalElement, true) and 
      compareDeep(coverageElement, o.coverageElement, true) and compareDeep(businessArrangementElement, o.businessArrangementElement, true) and 
      compareDeep(claimResponseElement, o.claimResponseElement, true);
  end;
end;

function TFhirClaimResponseInsurance.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FSequence) and isEmptyProp(FFocal) and isEmptyProp(FCoverage) and isEmptyProp(FBusinessArrangement) and isEmptyProp(FClaimResponse);
end;

procedure TFhirClaimResponseInsurance.listFieldsInOrder(fields : TStringList);
begin
  inherited listFieldsInOrder(fields);
  fields.add('sequence');
  fields.add('focal');
  fields.add('coverage');
  fields.add('businessArrangement');
  fields.add('claimResponse');
end;

function TFhirClaimResponseInsurance.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
end;

procedure TFhirClaimResponseInsurance.SetSequence(value : TFhirPositiveInt);
begin
  FSequence.free;
  FSequence := value;
end;

function TFhirClaimResponseInsurance.GetSequenceST : String;
begin
  if FSequence = nil then
    result := ''
  else
    result := FSequence.value;
end;

procedure TFhirClaimResponseInsurance.SetSequenceST(value : String);
begin
  if value <> '' then
  begin
    if FSequence = nil then
      FSequence := TFhirPositiveInt.create;
    FSequence.value := value
  end
  else if FSequence <> nil then
    FSequence.value := '';
end;

procedure TFhirClaimResponseInsurance.SetFocal(value : TFhirBoolean);
begin
  FFocal.free;
  FFocal := value;
end;

function TFhirClaimResponseInsurance.GetFocalST : Boolean;
begin
  if FFocal = nil then
    result := false
  else
    result := FFocal.value;
end;

procedure TFhirClaimResponseInsurance.SetFocalST(value : Boolean);
begin
  if FFocal = nil then
    FFocal := TFhirBoolean.create;
  FFocal.value := value
end;

procedure TFhirClaimResponseInsurance.SetCoverage(value : TFhirReference);
begin
  FCoverage.free;
  FCoverage := value;
end;

procedure TFhirClaimResponseInsurance.SetBusinessArrangement(value : TFhirString);
begin
  FBusinessArrangement.free;
  FBusinessArrangement := value;
end;

function TFhirClaimResponseInsurance.GetBusinessArrangementST : String;
begin
  if FBusinessArrangement = nil then
    result := ''
  else
    result := FBusinessArrangement.value;
end;

procedure TFhirClaimResponseInsurance.SetBusinessArrangementST(value : String);
begin
  if value <> '' then
  begin
    if FBusinessArrangement = nil then
      FBusinessArrangement := TFhirString.create;
    FBusinessArrangement.value := value
  end
  else if FBusinessArrangement <> nil then
    FBusinessArrangement.value := '';
end;

procedure TFhirClaimResponseInsurance.SetClaimResponse(value : TFhirReference);
begin
  FClaimResponse.free;
  FClaimResponse := value;
end;

{ TFhirClaimResponseInsuranceListEnumerator }

constructor TFhirClaimResponseInsuranceListEnumerator.Create(list : TFhirClaimResponseInsuranceList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirClaimResponseInsuranceListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirClaimResponseInsuranceListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirClaimResponseInsuranceListEnumerator.GetCurrent : TFhirClaimResponseInsurance;
begin
  Result := FList[FIndex];
end;

function TFhirClaimResponseInsuranceListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirClaimResponseInsuranceList }

procedure TFhirClaimResponseInsuranceList.AddItem(value: TFhirClaimResponseInsurance);
begin
  assert(value.ClassName = 'TFhirClaimResponseInsurance', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirClaimResponseInsurance');
  add(value);
end;

function TFhirClaimResponseInsuranceList.Append: TFhirClaimResponseInsurance;
begin
  result := TFhirClaimResponseInsurance.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirClaimResponseInsuranceList.ClearItems;
begin
  Clear;
end;

function TFhirClaimResponseInsuranceList.GetEnumerator : TFhirClaimResponseInsuranceListEnumerator;
begin
  result := TFhirClaimResponseInsuranceListEnumerator.Create(self.link);
end;

function TFhirClaimResponseInsuranceList.Clone: TFhirClaimResponseInsuranceList;
begin
  result := TFhirClaimResponseInsuranceList(inherited Clone);
end;

function TFhirClaimResponseInsuranceList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirClaimResponseInsuranceList.GetItemN(index: Integer): TFhirClaimResponseInsurance;
begin
  result := TFhirClaimResponseInsurance(ObjectByIndex[index]);
end;

function TFhirClaimResponseInsuranceList.ItemClass: TFslObjectClass;
begin
  result := TFhirClaimResponseInsurance;
end;
function TFhirClaimResponseInsuranceList.IndexOf(value: TFhirClaimResponseInsurance): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirClaimResponseInsuranceList.Insert(index: Integer): TFhirClaimResponseInsurance;
begin
  result := TFhirClaimResponseInsurance.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirClaimResponseInsuranceList.InsertItem(index: Integer; value: TFhirClaimResponseInsurance);
begin
  assert(value is TFhirClaimResponseInsurance);
  Inherited Insert(index, value);
end;

function TFhirClaimResponseInsuranceList.Item(index: Integer): TFhirClaimResponseInsurance;
begin
  result := TFhirClaimResponseInsurance(ObjectByIndex[index]);
end;

function TFhirClaimResponseInsuranceList.Link: TFhirClaimResponseInsuranceList;
begin
  result := TFhirClaimResponseInsuranceList(inherited Link);
end;

procedure TFhirClaimResponseInsuranceList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirClaimResponseInsuranceList.SetItemByIndex(index: Integer; value: TFhirClaimResponseInsurance);
begin
  assert(value is TFhirClaimResponseInsurance);
  FhirClaimResponseInsurances[index] := value;
end;

procedure TFhirClaimResponseInsuranceList.SetItemN(index: Integer; value: TFhirClaimResponseInsurance);
begin
  assert(value is TFhirClaimResponseInsurance);
  ObjectByIndex[index] := value;
end;

{ TFhirClaimResponseError }

constructor TFhirClaimResponseError.Create;
begin
  inherited;
end;

destructor TFhirClaimResponseError.Destroy;
begin
  FItemSequence.free;
  FDetailSequence.free;
  FSubDetailSequence.free;
  FCode.free;
  inherited;
end;

procedure TFhirClaimResponseError.Assign(oSource : TFslObject);
begin
  inherited;
  itemSequenceElement := TFhirClaimResponseError(oSource).itemSequenceElement.Clone;
  detailSequenceElement := TFhirClaimResponseError(oSource).detailSequenceElement.Clone;
  subDetailSequenceElement := TFhirClaimResponseError(oSource).subDetailSequenceElement.Clone;
  code := TFhirClaimResponseError(oSource).code.Clone;
end;

procedure TFhirClaimResponseError.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'itemSequence') Then
     list.add(self.link, 'itemSequence', FItemSequence.Link);
  if (child_name = 'detailSequence') Then
     list.add(self.link, 'detailSequence', FDetailSequence.Link);
  if (child_name = 'subDetailSequence') Then
     list.add(self.link, 'subDetailSequence', FSubDetailSequence.Link);
  if (child_name = 'code') Then
     list.add(self.link, 'code', FCode.Link);
end;

procedure TFhirClaimResponseError.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'itemSequence', 'positiveInt', false, TFhirPositiveInt, FItemSequence.Link));
  oList.add(TFHIRProperty.create(self, 'detailSequence', 'positiveInt', false, TFhirPositiveInt, FDetailSequence.Link));
  oList.add(TFHIRProperty.create(self, 'subDetailSequence', 'positiveInt', false, TFhirPositiveInt, FSubDetailSequence.Link));
  oList.add(TFHIRProperty.create(self, 'code', 'CodeableConcept', false, TFhirCodeableConcept, FCode.Link));
end;

function TFhirClaimResponseError.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'itemSequence') then
  begin
    ItemSequenceElement := asPositiveInt(propValue);
    result := propValue;
  end
  else if (propName = 'detailSequence') then
  begin
    DetailSequenceElement := asPositiveInt(propValue);
    result := propValue;
  end
  else if (propName = 'subDetailSequence') then
  begin
    SubDetailSequenceElement := asPositiveInt(propValue);
    result := propValue;
  end
  else if (propName = 'code') then
  begin
    Code := propValue as TFhirCodeableConcept;
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirClaimResponseError.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirClaimResponseError.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'itemSequence') then result := TFhirPositiveInt.create()
  else if (propName = 'detailSequence') then result := TFhirPositiveInt.create()
  else if (propName = 'subDetailSequence') then result := TFhirPositiveInt.create()
  else if (propName = 'code') then result := TFhirCodeableConcept.create()
  else result := inherited createPropertyValue(propName);
end;

function TFhirClaimResponseError.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'itemSequence') then result := 'positiveInt'
  else if (propName = 'detailSequence') then result := 'positiveInt'
  else if (propName = 'subDetailSequence') then result := 'positiveInt'
  else if (propName = 'code') then result := 'CodeableConcept'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirClaimResponseError.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'itemSequence') then ItemSequenceElement := nil
  else if (propName = 'detailSequence') then DetailSequenceElement := nil
  else if (propName = 'subDetailSequence') then SubDetailSequenceElement := nil
  else if (propName = 'code') then CodeElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirClaimResponseError.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'itemSequence') then ItemSequenceElement := asPositiveInt(new)
  else if (propName = 'detailSequence') then DetailSequenceElement := asPositiveInt(new)
  else if (propName = 'subDetailSequence') then SubDetailSequenceElement := asPositiveInt(new)
  else if (propName = 'code') then CodeElement := new as TFhirCodeableConcept
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirClaimResponseError.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirClaimResponseError.fhirType : string;
begin
  result := 'ClaimResponse.error';
end;

function TFhirClaimResponseError.Link : TFhirClaimResponseError;
begin
  result := TFhirClaimResponseError(inherited Link);
end;

function TFhirClaimResponseError.Clone : TFhirClaimResponseError;
begin
  result := TFhirClaimResponseError(inherited Clone);
end;

function TFhirClaimResponseError.equals(other : TObject) : boolean; 
var
  o : TFhirClaimResponseError;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirClaimResponseError)) then
    result := false
  else
  begin
    o := TFhirClaimResponseError(other);
    result := compareDeep(itemSequenceElement, o.itemSequenceElement, true) and 
      compareDeep(detailSequenceElement, o.detailSequenceElement, true) and compareDeep(subDetailSequenceElement, o.subDetailSequenceElement, true) and 
      compareDeep(codeElement, o.codeElement, true);
  end;
end;

function TFhirClaimResponseError.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FItemSequence) and isEmptyProp(FDetailSequence) and isEmptyProp(FSubDetailSequence) and isEmptyProp(FCode);
end;

procedure TFhirClaimResponseError.listFieldsInOrder(fields : TStringList);
begin
  inherited listFieldsInOrder(fields);
  fields.add('itemSequence');
  fields.add('detailSequence');
  fields.add('subDetailSequence');
  fields.add('code');
end;

function TFhirClaimResponseError.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
end;

procedure TFhirClaimResponseError.SetItemSequence(value : TFhirPositiveInt);
begin
  FItemSequence.free;
  FItemSequence := value;
end;

function TFhirClaimResponseError.GetItemSequenceST : String;
begin
  if FItemSequence = nil then
    result := ''
  else
    result := FItemSequence.value;
end;

procedure TFhirClaimResponseError.SetItemSequenceST(value : String);
begin
  if value <> '' then
  begin
    if FItemSequence = nil then
      FItemSequence := TFhirPositiveInt.create;
    FItemSequence.value := value
  end
  else if FItemSequence <> nil then
    FItemSequence.value := '';
end;

procedure TFhirClaimResponseError.SetDetailSequence(value : TFhirPositiveInt);
begin
  FDetailSequence.free;
  FDetailSequence := value;
end;

function TFhirClaimResponseError.GetDetailSequenceST : String;
begin
  if FDetailSequence = nil then
    result := ''
  else
    result := FDetailSequence.value;
end;

procedure TFhirClaimResponseError.SetDetailSequenceST(value : String);
begin
  if value <> '' then
  begin
    if FDetailSequence = nil then
      FDetailSequence := TFhirPositiveInt.create;
    FDetailSequence.value := value
  end
  else if FDetailSequence <> nil then
    FDetailSequence.value := '';
end;

procedure TFhirClaimResponseError.SetSubDetailSequence(value : TFhirPositiveInt);
begin
  FSubDetailSequence.free;
  FSubDetailSequence := value;
end;

function TFhirClaimResponseError.GetSubDetailSequenceST : String;
begin
  if FSubDetailSequence = nil then
    result := ''
  else
    result := FSubDetailSequence.value;
end;

procedure TFhirClaimResponseError.SetSubDetailSequenceST(value : String);
begin
  if value <> '' then
  begin
    if FSubDetailSequence = nil then
      FSubDetailSequence := TFhirPositiveInt.create;
    FSubDetailSequence.value := value
  end
  else if FSubDetailSequence <> nil then
    FSubDetailSequence.value := '';
end;

procedure TFhirClaimResponseError.SetCode(value : TFhirCodeableConcept);
begin
  FCode.free;
  FCode := value;
end;

{ TFhirClaimResponseErrorListEnumerator }

constructor TFhirClaimResponseErrorListEnumerator.Create(list : TFhirClaimResponseErrorList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirClaimResponseErrorListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirClaimResponseErrorListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirClaimResponseErrorListEnumerator.GetCurrent : TFhirClaimResponseError;
begin
  Result := FList[FIndex];
end;

function TFhirClaimResponseErrorListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirClaimResponseErrorList }

procedure TFhirClaimResponseErrorList.AddItem(value: TFhirClaimResponseError);
begin
  assert(value.ClassName = 'TFhirClaimResponseError', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirClaimResponseError');
  add(value);
end;

function TFhirClaimResponseErrorList.Append: TFhirClaimResponseError;
begin
  result := TFhirClaimResponseError.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirClaimResponseErrorList.ClearItems;
begin
  Clear;
end;

function TFhirClaimResponseErrorList.GetEnumerator : TFhirClaimResponseErrorListEnumerator;
begin
  result := TFhirClaimResponseErrorListEnumerator.Create(self.link);
end;

function TFhirClaimResponseErrorList.Clone: TFhirClaimResponseErrorList;
begin
  result := TFhirClaimResponseErrorList(inherited Clone);
end;

function TFhirClaimResponseErrorList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirClaimResponseErrorList.GetItemN(index: Integer): TFhirClaimResponseError;
begin
  result := TFhirClaimResponseError(ObjectByIndex[index]);
end;

function TFhirClaimResponseErrorList.ItemClass: TFslObjectClass;
begin
  result := TFhirClaimResponseError;
end;
function TFhirClaimResponseErrorList.IndexOf(value: TFhirClaimResponseError): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirClaimResponseErrorList.Insert(index: Integer): TFhirClaimResponseError;
begin
  result := TFhirClaimResponseError.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirClaimResponseErrorList.InsertItem(index: Integer; value: TFhirClaimResponseError);
begin
  assert(value is TFhirClaimResponseError);
  Inherited Insert(index, value);
end;

function TFhirClaimResponseErrorList.Item(index: Integer): TFhirClaimResponseError;
begin
  result := TFhirClaimResponseError(ObjectByIndex[index]);
end;

function TFhirClaimResponseErrorList.Link: TFhirClaimResponseErrorList;
begin
  result := TFhirClaimResponseErrorList(inherited Link);
end;

procedure TFhirClaimResponseErrorList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirClaimResponseErrorList.SetItemByIndex(index: Integer; value: TFhirClaimResponseError);
begin
  assert(value is TFhirClaimResponseError);
  FhirClaimResponseErrors[index] := value;
end;

procedure TFhirClaimResponseErrorList.SetItemN(index: Integer; value: TFhirClaimResponseError);
begin
  assert(value is TFhirClaimResponseError);
  ObjectByIndex[index] := value;
end;

{ TFhirClaimResponse }

constructor TFhirClaimResponse.Create;
begin
  inherited;
end;

destructor TFhirClaimResponse.Destroy;
begin
  FIdentifierList.Free;
  FStatus.free;
  FType_.free;
  FSubType.free;
  FUse.free;
  FPatient.free;
  FCreated.free;
  FInsurer.free;
  FRequestor.free;
  FRequest.free;
  FOutcome.free;
  FDisposition.free;
  FPreAuthRef.free;
  FPreAuthPeriod.free;
  FPayeeType.free;
  FItemList.Free;
  FAddItemList.Free;
  FAdjudicationList.Free;
  FTotalList.Free;
  FPayment.free;
  FFundsReserve.free;
  FFormCode.free;
  FForm.free;
  FProcessNoteList.Free;
  FCommunicationRequestList.Free;
  FInsuranceList.Free;
  FErrorList.Free;
  inherited;
end;

procedure TFhirClaimResponse.Assign(oSource : TFslObject);
begin
  inherited;
  if (TFhirClaimResponse(oSource).FIdentifierList = nil) then
  begin
    FIdentifierList.free;
    FIdentifierList := nil;
  end
  else
  begin
    if FIdentifierList = nil then
      FIdentifierList := TFhirIdentifierList.Create;
    FIdentifierList.Assign(TFhirClaimResponse(oSource).FIdentifierList);
  end;
  statusElement := TFhirClaimResponse(oSource).statusElement.Clone;
  type_ := TFhirClaimResponse(oSource).type_.Clone;
  subType := TFhirClaimResponse(oSource).subType.Clone;
  useElement := TFhirClaimResponse(oSource).useElement.Clone;
  patient := TFhirClaimResponse(oSource).patient.Clone;
  createdElement := TFhirClaimResponse(oSource).createdElement.Clone;
  insurer := TFhirClaimResponse(oSource).insurer.Clone;
  requestor := TFhirClaimResponse(oSource).requestor.Clone;
  request := TFhirClaimResponse(oSource).request.Clone;
  outcomeElement := TFhirClaimResponse(oSource).outcomeElement.Clone;
  dispositionElement := TFhirClaimResponse(oSource).dispositionElement.Clone;
  preAuthRefElement := TFhirClaimResponse(oSource).preAuthRefElement.Clone;
  preAuthPeriod := TFhirClaimResponse(oSource).preAuthPeriod.Clone;
  payeeType := TFhirClaimResponse(oSource).payeeType.Clone;
  if (TFhirClaimResponse(oSource).FItemList = nil) then
  begin
    FItemList.free;
    FItemList := nil;
  end
  else
  begin
    if FItemList = nil then
      FItemList := TFhirClaimResponseItemList.Create;
    FItemList.Assign(TFhirClaimResponse(oSource).FItemList);
  end;
  if (TFhirClaimResponse(oSource).FAddItemList = nil) then
  begin
    FAddItemList.free;
    FAddItemList := nil;
  end
  else
  begin
    if FAddItemList = nil then
      FAddItemList := TFhirClaimResponseAddItemList.Create;
    FAddItemList.Assign(TFhirClaimResponse(oSource).FAddItemList);
  end;
  if (TFhirClaimResponse(oSource).FAdjudicationList = nil) then
  begin
    FAdjudicationList.free;
    FAdjudicationList := nil;
  end
  else
  begin
    if FAdjudicationList = nil then
      FAdjudicationList := TFhirClaimResponseItemAdjudicationList.Create;
    FAdjudicationList.Assign(TFhirClaimResponse(oSource).FAdjudicationList);
  end;
  if (TFhirClaimResponse(oSource).FTotalList = nil) then
  begin
    FTotalList.free;
    FTotalList := nil;
  end
  else
  begin
    if FTotalList = nil then
      FTotalList := TFhirClaimResponseTotalList.Create;
    FTotalList.Assign(TFhirClaimResponse(oSource).FTotalList);
  end;
  payment := TFhirClaimResponse(oSource).payment.Clone;
  fundsReserve := TFhirClaimResponse(oSource).fundsReserve.Clone;
  formCode := TFhirClaimResponse(oSource).formCode.Clone;
  form := TFhirClaimResponse(oSource).form.Clone;
  if (TFhirClaimResponse(oSource).FProcessNoteList = nil) then
  begin
    FProcessNoteList.free;
    FProcessNoteList := nil;
  end
  else
  begin
    if FProcessNoteList = nil then
      FProcessNoteList := TFhirClaimResponseProcessNoteList.Create;
    FProcessNoteList.Assign(TFhirClaimResponse(oSource).FProcessNoteList);
  end;
  if (TFhirClaimResponse(oSource).FCommunicationRequestList = nil) then
  begin
    FCommunicationRequestList.free;
    FCommunicationRequestList := nil;
  end
  else
  begin
    if FCommunicationRequestList = nil then
      FCommunicationRequestList := TFhirReferenceList.Create;
    FCommunicationRequestList.Assign(TFhirClaimResponse(oSource).FCommunicationRequestList);
  end;
  if (TFhirClaimResponse(oSource).FInsuranceList = nil) then
  begin
    FInsuranceList.free;
    FInsuranceList := nil;
  end
  else
  begin
    if FInsuranceList = nil then
      FInsuranceList := TFhirClaimResponseInsuranceList.Create;
    FInsuranceList.Assign(TFhirClaimResponse(oSource).FInsuranceList);
  end;
  if (TFhirClaimResponse(oSource).FErrorList = nil) then
  begin
    FErrorList.free;
    FErrorList := nil;
  end
  else
  begin
    if FErrorList = nil then
      FErrorList := TFhirClaimResponseErrorList.Create;
    FErrorList.Assign(TFhirClaimResponse(oSource).FErrorList);
  end;
end;

function TFhirClaimResponse.GetResourceType : TFhirResourceType;
begin
  result := frtClaimResponse;
end;

procedure TFhirClaimResponse.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'identifier') Then
    list.addAll(self, 'identifier', FIdentifierList);
  if (child_name = 'status') Then
     list.add(self.link, 'status', FStatus.Link);
  if (child_name = 'type') Then
     list.add(self.link, 'type', FType_.Link);
  if (child_name = 'subType') Then
     list.add(self.link, 'subType', FSubType.Link);
  if (child_name = 'use') Then
     list.add(self.link, 'use', FUse.Link);
  if (child_name = 'patient') Then
     list.add(self.link, 'patient', FPatient.Link);
  if (child_name = 'created') Then
     list.add(self.link, 'created', FCreated.Link);
  if (child_name = 'insurer') Then
     list.add(self.link, 'insurer', FInsurer.Link);
  if (child_name = 'requestor') Then
     list.add(self.link, 'requestor', FRequestor.Link);
  if (child_name = 'request') Then
     list.add(self.link, 'request', FRequest.Link);
  if (child_name = 'outcome') Then
     list.add(self.link, 'outcome', FOutcome.Link);
  if (child_name = 'disposition') Then
     list.add(self.link, 'disposition', FDisposition.Link);
  if (child_name = 'preAuthRef') Then
     list.add(self.link, 'preAuthRef', FPreAuthRef.Link);
  if (child_name = 'preAuthPeriod') Then
     list.add(self.link, 'preAuthPeriod', FPreAuthPeriod.Link);
  if (child_name = 'payeeType') Then
     list.add(self.link, 'payeeType', FPayeeType.Link);
  if (child_name = 'item') Then
    list.addAll(self, 'item', FItemList);
  if (child_name = 'addItem') Then
    list.addAll(self, 'addItem', FAddItemList);
  if (child_name = 'adjudication') Then
    list.addAll(self, 'adjudication', FAdjudicationList);
  if (child_name = 'total') Then
    list.addAll(self, 'total', FTotalList);
  if (child_name = 'payment') Then
     list.add(self.link, 'payment', FPayment.Link);
  if (child_name = 'fundsReserve') Then
     list.add(self.link, 'fundsReserve', FFundsReserve.Link);
  if (child_name = 'formCode') Then
     list.add(self.link, 'formCode', FFormCode.Link);
  if (child_name = 'form') Then
     list.add(self.link, 'form', FForm.Link);
  if (child_name = 'processNote') Then
    list.addAll(self, 'processNote', FProcessNoteList);
  if (child_name = 'communicationRequest') Then
    list.addAll(self, 'communicationRequest', FCommunicationRequestList);
  if (child_name = 'insurance') Then
    list.addAll(self, 'insurance', FInsuranceList);
  if (child_name = 'error') Then
    list.addAll(self, 'error', FErrorList);
end;

procedure TFhirClaimResponse.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'identifier', 'Identifier', true, TFhirIdentifier, FIdentifierList.Link));
  oList.add(TFHIRProperty.create(self, 'status', 'code', false, TFhirEnum, FStatus.Link));
  oList.add(TFHIRProperty.create(self, 'type', 'CodeableConcept', false, TFhirCodeableConcept, FType_.Link));
  oList.add(TFHIRProperty.create(self, 'subType', 'CodeableConcept', false, TFhirCodeableConcept, FSubType.Link));
  oList.add(TFHIRProperty.create(self, 'use', 'code', false, TFhirEnum, FUse.Link));
  oList.add(TFHIRProperty.create(self, 'patient', 'Reference', false, TFhirReference, FPatient.Link));
  oList.add(TFHIRProperty.create(self, 'created', 'dateTime', false, TFhirDateTime, FCreated.Link));
  oList.add(TFHIRProperty.create(self, 'insurer', 'Reference', false, TFhirReference, FInsurer.Link));
  oList.add(TFHIRProperty.create(self, 'requestor', 'Reference', false, TFhirReference, FRequestor.Link));
  oList.add(TFHIRProperty.create(self, 'request', 'Reference', false, TFhirReference, FRequest.Link));
  oList.add(TFHIRProperty.create(self, 'outcome', 'code', false, TFhirEnum, FOutcome.Link));
  oList.add(TFHIRProperty.create(self, 'disposition', 'string', false, TFhirString, FDisposition.Link));
  oList.add(TFHIRProperty.create(self, 'preAuthRef', 'string', false, TFhirString, FPreAuthRef.Link));
  oList.add(TFHIRProperty.create(self, 'preAuthPeriod', 'Period', false, TFhirPeriod, FPreAuthPeriod.Link));
  oList.add(TFHIRProperty.create(self, 'payeeType', 'CodeableConcept', false, TFhirCodeableConcept, FPayeeType.Link));
  oList.add(TFHIRProperty.create(self, 'item', 'BackboneElement', true, TFhirClaimResponseItem, FItemList.Link));
  oList.add(TFHIRProperty.create(self, 'addItem', 'BackboneElement', true, TFhirClaimResponseAddItem, FAddItemList.Link));
  oList.add(TFHIRProperty.create(self, 'adjudication', '', true, TFhirClaimResponseItemAdjudication, FAdjudicationList.Link));
  oList.add(TFHIRProperty.create(self, 'total', 'BackboneElement', true, TFhirClaimResponseTotal, FTotalList.Link));
  oList.add(TFHIRProperty.create(self, 'payment', 'BackboneElement', false, TFhirClaimResponsePayment, FPayment.Link));
  oList.add(TFHIRProperty.create(self, 'fundsReserve', 'CodeableConcept', false, TFhirCodeableConcept, FFundsReserve.Link));
  oList.add(TFHIRProperty.create(self, 'formCode', 'CodeableConcept', false, TFhirCodeableConcept, FFormCode.Link));
  oList.add(TFHIRProperty.create(self, 'form', 'Attachment', false, TFhirAttachment, FForm.Link));
  oList.add(TFHIRProperty.create(self, 'processNote', 'BackboneElement', true, TFhirClaimResponseProcessNote, FProcessNoteList.Link));
  oList.add(TFHIRProperty.create(self, 'communicationRequest', 'Reference', true, TFhirReference, FCommunicationRequestList.Link));
  oList.add(TFHIRProperty.create(self, 'insurance', 'BackboneElement', true, TFhirClaimResponseInsurance, FInsuranceList.Link));
  oList.add(TFHIRProperty.create(self, 'error', 'BackboneElement', true, TFhirClaimResponseError, FErrorList.Link));
end;

function TFhirClaimResponse.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'identifier') then
  begin
    IdentifierList.add(propValue as TFhirIdentifier);
    result := propValue;
  end
  else if (propName = 'status') then
  begin
    StatusElement := asEnum(SYSTEMS_TFhirFinancialResourceStatusCodesEnum, CODES_TFhirFinancialResourceStatusCodesEnum, propValue);
    result := propValue;
  end
  else if (propName = 'type') then
  begin
    Type_ := propValue as TFhirCodeableConcept;
    result := propValue;
  end
  else if (propName = 'subType') then
  begin
    SubType := propValue as TFhirCodeableConcept;
    result := propValue;
  end
  else if (propName = 'use') then
  begin
    UseElement := asEnum(SYSTEMS_TFhirUseEnum, CODES_TFhirUseEnum, propValue);
    result := propValue;
  end
  else if (propName = 'patient') then
  begin
    Patient := propValue as TFhirReference;
    result := propValue;
  end
  else if (propName = 'created') then
  begin
    CreatedElement := asDateTime(propValue);
    result := propValue;
  end
  else if (propName = 'insurer') then
  begin
    Insurer := propValue as TFhirReference;
    result := propValue;
  end
  else if (propName = 'requestor') then
  begin
    Requestor := propValue as TFhirReference;
    result := propValue;
  end
  else if (propName = 'request') then
  begin
    Request := propValue as TFhirReference;
    result := propValue;
  end
  else if (propName = 'outcome') then
  begin
    OutcomeElement := asEnum(SYSTEMS_TFhirClaimProcessingCodesEnum, CODES_TFhirClaimProcessingCodesEnum, propValue);
    result := propValue;
  end
  else if (propName = 'disposition') then
  begin
    DispositionElement := asString(propValue);
    result := propValue;
  end
  else if (propName = 'preAuthRef') then
  begin
    PreAuthRefElement := asString(propValue);
    result := propValue;
  end
  else if (propName = 'preAuthPeriod') then
  begin
    PreAuthPeriod := propValue as TFhirPeriod;
    result := propValue;
  end
  else if (propName = 'payeeType') then
  begin
    PayeeType := propValue as TFhirCodeableConcept;
    result := propValue;
  end
  else if (propName = 'item') then
  begin
    ItemList.add(propValue as TFhirClaimResponseItem);
    result := propValue;
  end
  else if (propName = 'addItem') then
  begin
    AddItemList.add(propValue as TFhirClaimResponseAddItem);
    result := propValue;
  end
  else if (propName = 'adjudication') then
  begin
    AdjudicationList.add(propValue as TFhirClaimResponseItemAdjudication);
    result := propValue;
  end
  else if (propName = 'total') then
  begin
    TotalList.add(propValue as TFhirClaimResponseTotal);
    result := propValue;
  end
  else if (propName = 'payment') then
  begin
    Payment := propValue as TFhirClaimResponsePayment;
    result := propValue;
  end
  else if (propName = 'fundsReserve') then
  begin
    FundsReserve := propValue as TFhirCodeableConcept;
    result := propValue;
  end
  else if (propName = 'formCode') then
  begin
    FormCode := propValue as TFhirCodeableConcept;
    result := propValue;
  end
  else if (propName = 'form') then
  begin
    Form := propValue as TFhirAttachment;
    result := propValue;
  end
  else if (propName = 'processNote') then
  begin
    ProcessNoteList.add(propValue as TFhirClaimResponseProcessNote);
    result := propValue;
  end
  else if (propName = 'communicationRequest') then
  begin
    CommunicationRequestList.add(propValue as TFhirReference);
    result := propValue;
  end
  else if (propName = 'insurance') then
  begin
    InsuranceList.add(propValue as TFhirClaimResponseInsurance);
    result := propValue;
  end
  else if (propName = 'error') then
  begin
    ErrorList.add(propValue as TFhirClaimResponseError);
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirClaimResponse.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'identifier') then IdentifierList.insertItem(index, propValue as TFhirIdentifier)
  else if (propName = 'item') then ItemList.insertItem(index, propValue as TFhirClaimResponseItem)
  else if (propName = 'addItem') then AddItemList.insertItem(index, propValue as TFhirClaimResponseAddItem)
  else if (propName = 'adjudication') then AdjudicationList.insertItem(index, propValue as TFhirClaimResponseItemAdjudication)
  else if (propName = 'total') then TotalList.insertItem(index, propValue as TFhirClaimResponseTotal)
  else if (propName = 'processNote') then ProcessNoteList.insertItem(index, propValue as TFhirClaimResponseProcessNote)
  else if (propName = 'communicationRequest') then CommunicationRequestList.insertItem(index, propValue as TFhirReference)
  else if (propName = 'insurance') then InsuranceList.insertItem(index, propValue as TFhirClaimResponseInsurance)
  else if (propName = 'error') then ErrorList.insertItem(index, propValue as TFhirClaimResponseError)
  else inherited;
end;

function TFhirClaimResponse.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'identifier') then result := IdentifierList.new()
  else if (propName = 'status') then result := TFhirEnum.create(SYSTEMS_TFhirFinancialResourceStatusCodesEnum[FinancialResourceStatusCodesNull], CODES_TFhirFinancialResourceStatusCodesEnum[FinancialResourceStatusCodesNull]) 
  else if (propName = 'type') then result := TFhirCodeableConcept.create()
  else if (propName = 'subType') then result := TFhirCodeableConcept.create()
  else if (propName = 'use') then result := TFhirEnum.create(SYSTEMS_TFhirUseEnum[UseNull], CODES_TFhirUseEnum[UseNull]) 
  else if (propName = 'patient') then result := TFhirReference.create()
  else if (propName = 'created') then result := TFhirDateTime.create()
  else if (propName = 'insurer') then result := TFhirReference.create()
  else if (propName = 'requestor') then result := TFhirReference.create()
  else if (propName = 'request') then result := TFhirReference.create()
  else if (propName = 'outcome') then result := TFhirEnum.create(SYSTEMS_TFhirClaimProcessingCodesEnum[ClaimProcessingCodesNull], CODES_TFhirClaimProcessingCodesEnum[ClaimProcessingCodesNull]) 
  else if (propName = 'disposition') then result := TFhirString.create()
  else if (propName = 'preAuthRef') then result := TFhirString.create()
  else if (propName = 'preAuthPeriod') then result := TFhirPeriod.create()
  else if (propName = 'payeeType') then result := TFhirCodeableConcept.create()
  else if (propName = 'item') then result := ItemList.new()
  else if (propName = 'addItem') then result := AddItemList.new()
  else if (propName = 'adjudication') then result := AdjudicationList.new()
  else if (propName = 'total') then result := TotalList.new()
  else if (propName = 'payment') then result := TFhirClaimResponsePayment.create()
  else if (propName = 'fundsReserve') then result := TFhirCodeableConcept.create()
  else if (propName = 'formCode') then result := TFhirCodeableConcept.create()
  else if (propName = 'form') then result := TFhirAttachment.create()
  else if (propName = 'processNote') then result := ProcessNoteList.new()
  else if (propName = 'communicationRequest') then result := CommunicationRequestList.new()
  else if (propName = 'insurance') then result := InsuranceList.new()
  else if (propName = 'error') then result := ErrorList.new()
  else result := inherited createPropertyValue(propName);
end;

function TFhirClaimResponse.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'identifier') then result := 'Identifier'
  else if (propName = 'status') then result := 'code'
  else if (propName = 'type') then result := 'CodeableConcept'
  else if (propName = 'subType') then result := 'CodeableConcept'
  else if (propName = 'use') then result := 'code'
  else if (propName = 'patient') then result := 'Reference'
  else if (propName = 'created') then result := 'dateTime'
  else if (propName = 'insurer') then result := 'Reference'
  else if (propName = 'requestor') then result := 'Reference'
  else if (propName = 'request') then result := 'Reference'
  else if (propName = 'outcome') then result := 'code'
  else if (propName = 'disposition') then result := 'string'
  else if (propName = 'preAuthRef') then result := 'string'
  else if (propName = 'preAuthPeriod') then result := 'Period'
  else if (propName = 'payeeType') then result := 'CodeableConcept'
  else if (propName = 'item') then result := 'BackboneElement'
  else if (propName = 'addItem') then result := 'BackboneElement'
  else if (propName = 'adjudication') then result := ''
  else if (propName = 'total') then result := 'BackboneElement'
  else if (propName = 'payment') then result := 'BackboneElement'
  else if (propName = 'fundsReserve') then result := 'CodeableConcept'
  else if (propName = 'formCode') then result := 'CodeableConcept'
  else if (propName = 'form') then result := 'Attachment'
  else if (propName = 'processNote') then result := 'BackboneElement'
  else if (propName = 'communicationRequest') then result := 'Reference'
  else if (propName = 'insurance') then result := 'BackboneElement'
  else if (propName = 'error') then result := 'BackboneElement'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirClaimResponse.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'identifier') then deletePropertyValue('identifier', IdentifierList, value)
  else if (propName = 'status') then StatusElement := nil
  else if (propName = 'type') then Type_Element := nil
  else if (propName = 'subType') then SubTypeElement := nil
  else if (propName = 'use') then UseElement := nil
  else if (propName = 'patient') then PatientElement := nil
  else if (propName = 'created') then CreatedElement := nil
  else if (propName = 'insurer') then InsurerElement := nil
  else if (propName = 'requestor') then RequestorElement := nil
  else if (propName = 'request') then RequestElement := nil
  else if (propName = 'outcome') then OutcomeElement := nil
  else if (propName = 'disposition') then DispositionElement := nil
  else if (propName = 'preAuthRef') then PreAuthRefElement := nil
  else if (propName = 'preAuthPeriod') then PreAuthPeriodElement := nil
  else if (propName = 'payeeType') then PayeeTypeElement := nil
  else if (propName = 'item') then deletePropertyValue('item', ItemList, value)
  else if (propName = 'addItem') then deletePropertyValue('addItem', AddItemList, value)
  else if (propName = 'adjudication') then deletePropertyValue('adjudication', AdjudicationList, value)
  else if (propName = 'total') then deletePropertyValue('total', TotalList, value)
  else if (propName = 'payment') then PaymentElement := nil
  else if (propName = 'fundsReserve') then FundsReserveElement := nil
  else if (propName = 'formCode') then FormCodeElement := nil
  else if (propName = 'form') then FormElement := nil
  else if (propName = 'processNote') then deletePropertyValue('processNote', ProcessNoteList, value)
  else if (propName = 'communicationRequest') then deletePropertyValue('communicationRequest', CommunicationRequestList, value)
  else if (propName = 'insurance') then deletePropertyValue('insurance', InsuranceList, value)
  else if (propName = 'error') then deletePropertyValue('error', ErrorList, value)
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirClaimResponse.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'identifier') then replacePropertyValue('identifier', IdentifierList, existing, new)
  else if (propName = 'status') then StatusElement := asEnum(SYSTEMS_TFhirFinancialResourceStatusCodesEnum, CODES_TFhirFinancialResourceStatusCodesEnum, new)
  else if (propName = 'type') then Type_Element := new as TFhirCodeableConcept
  else if (propName = 'subType') then SubTypeElement := new as TFhirCodeableConcept
  else if (propName = 'use') then UseElement := asEnum(SYSTEMS_TFhirUseEnum, CODES_TFhirUseEnum, new)
  else if (propName = 'patient') then PatientElement := new as TFhirReference
  else if (propName = 'created') then CreatedElement := asDateTime(new)
  else if (propName = 'insurer') then InsurerElement := new as TFhirReference
  else if (propName = 'requestor') then RequestorElement := new as TFhirReference
  else if (propName = 'request') then RequestElement := new as TFhirReference
  else if (propName = 'outcome') then OutcomeElement := asEnum(SYSTEMS_TFhirClaimProcessingCodesEnum, CODES_TFhirClaimProcessingCodesEnum, new)
  else if (propName = 'disposition') then DispositionElement := asString(new)
  else if (propName = 'preAuthRef') then PreAuthRefElement := asString(new)
  else if (propName = 'preAuthPeriod') then PreAuthPeriodElement := new as TFhirPeriod
  else if (propName = 'payeeType') then PayeeTypeElement := new as TFhirCodeableConcept
  else if (propName = 'item') then replacePropertyValue('item', ItemList, existing, new)
  else if (propName = 'addItem') then replacePropertyValue('addItem', AddItemList, existing, new)
  else if (propName = 'adjudication') then replacePropertyValue('adjudication', AdjudicationList, existing, new)
  else if (propName = 'total') then replacePropertyValue('total', TotalList, existing, new)
  else if (propName = 'payment') then PaymentElement := new as TFhirClaimResponsePayment
  else if (propName = 'fundsReserve') then FundsReserveElement := new as TFhirCodeableConcept
  else if (propName = 'formCode') then FormCodeElement := new as TFhirCodeableConcept
  else if (propName = 'form') then FormElement := new as TFhirAttachment
  else if (propName = 'processNote') then replacePropertyValue('processNote', ProcessNoteList, existing, new)
  else if (propName = 'communicationRequest') then replacePropertyValue('communicationRequest', CommunicationRequestList, existing, new)
  else if (propName = 'insurance') then replacePropertyValue('insurance', InsuranceList, existing, new)
  else if (propName = 'error') then replacePropertyValue('error', ErrorList, existing, new)
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirClaimResponse.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'identifier') then IdentifierList.move(source, destination)
  else if (propName = 'item') then ItemList.move(source, destination)
  else if (propName = 'addItem') then AddItemList.move(source, destination)
  else if (propName = 'adjudication') then AdjudicationList.move(source, destination)
  else if (propName = 'total') then TotalList.move(source, destination)
  else if (propName = 'processNote') then ProcessNoteList.move(source, destination)
  else if (propName = 'communicationRequest') then CommunicationRequestList.move(source, destination)
  else if (propName = 'insurance') then InsuranceList.move(source, destination)
  else if (propName = 'error') then ErrorList.move(source, destination)
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirClaimResponse.fhirType : string;
begin
  result := 'ClaimResponse';
end;

function TFhirClaimResponse.Link : TFhirClaimResponse;
begin
  result := TFhirClaimResponse(inherited Link);
end;

function TFhirClaimResponse.Clone : TFhirClaimResponse;
begin
  result := TFhirClaimResponse(inherited Clone);
end;

function TFhirClaimResponse.equals(other : TObject) : boolean; 
var
  o : TFhirClaimResponse;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirClaimResponse)) then
    result := false
  else
  begin
    o := TFhirClaimResponse(other);
    result := compareDeep(identifierList, o.identifierList, true) and compareDeep(statusElement, o.statusElement, true) and 
      compareDeep(type_Element, o.type_Element, true) and compareDeep(subTypeElement, o.subTypeElement, true) and 
      compareDeep(useElement, o.useElement, true) and compareDeep(patientElement, o.patientElement, true) and 
      compareDeep(createdElement, o.createdElement, true) and compareDeep(insurerElement, o.insurerElement, true) and 
      compareDeep(requestorElement, o.requestorElement, true) and compareDeep(requestElement, o.requestElement, true) and 
      compareDeep(outcomeElement, o.outcomeElement, true) and compareDeep(dispositionElement, o.dispositionElement, true) and 
      compareDeep(preAuthRefElement, o.preAuthRefElement, true) and compareDeep(preAuthPeriodElement, o.preAuthPeriodElement, true) and 
      compareDeep(payeeTypeElement, o.payeeTypeElement, true) and compareDeep(itemList, o.itemList, true) and 
      compareDeep(addItemList, o.addItemList, true) and compareDeep(adjudicationList, o.adjudicationList, true) and 
      compareDeep(totalList, o.totalList, true) and compareDeep(paymentElement, o.paymentElement, true) and 
      compareDeep(fundsReserveElement, o.fundsReserveElement, true) and compareDeep(formCodeElement, o.formCodeElement, true) and 
      compareDeep(formElement, o.formElement, true) and compareDeep(processNoteList, o.processNoteList, true) and 
      compareDeep(communicationRequestList, o.communicationRequestList, true) and compareDeep(insuranceList, o.insuranceList, true) and 
      compareDeep(errorList, o.errorList, true);
  end;
end;

function TFhirClaimResponse.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FidentifierList) and isEmptyProp(FStatus) and isEmptyProp(FType_) and isEmptyProp(FSubType) and isEmptyProp(FUse) and isEmptyProp(FPatient) and isEmptyProp(FCreated) and isEmptyProp(FInsurer) and isEmptyProp(FRequestor) and isEmptyProp(FRequest) and isEmptyProp(FOutcome) and isEmptyProp(FDisposition) and isEmptyProp(FPreAuthRef) and isEmptyProp(FPreAuthPeriod) and isEmptyProp(FPayeeType) and isEmptyProp(FitemList) and isEmptyProp(FaddItemList) and isEmptyProp(FadjudicationList) and isEmptyProp(FtotalList) and isEmptyProp(FPayment) and isEmptyProp(FFundsReserve) and isEmptyProp(FFormCode) and isEmptyProp(FForm) and isEmptyProp(FprocessNoteList) and isEmptyProp(FcommunicationRequestList) and isEmptyProp(FinsuranceList) and isEmptyProp(FerrorList);
end;

procedure TFhirClaimResponse.listFieldsInOrder(fields : TStringList);
begin
  inherited listFieldsInOrder(fields);
  fields.add('identifier');
  fields.add('status');
  fields.add('type');
  fields.add('subType');
  fields.add('use');
  fields.add('patient');
  fields.add('created');
  fields.add('insurer');
  fields.add('requestor');
  fields.add('request');
  fields.add('outcome');
  fields.add('disposition');
  fields.add('preAuthRef');
  fields.add('preAuthPeriod');
  fields.add('payeeType');
  fields.add('item');
  fields.add('addItem');
  fields.add('adjudication');
  fields.add('total');
  fields.add('payment');
  fields.add('fundsReserve');
  fields.add('formCode');
  fields.add('form');
  fields.add('processNote');
  fields.add('communicationRequest');
  fields.add('insurance');
  fields.add('error');
end;

function TFhirClaimResponse.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FIdentifierList.sizeInBytes(magic));
  inc(result, FItemList.sizeInBytes(magic));
  inc(result, FAddItemList.sizeInBytes(magic));
  inc(result, FAdjudicationList.sizeInBytes(magic));
  inc(result, FTotalList.sizeInBytes(magic));
  inc(result, FProcessNoteList.sizeInBytes(magic));
  inc(result, FCommunicationRequestList.sizeInBytes(magic));
  inc(result, FInsuranceList.sizeInBytes(magic));
  inc(result, FErrorList.sizeInBytes(magic));
end;

function TFhirClaimResponse.GetIdentifierList : TFhirIdentifierList;
begin
  if FIdentifierList = nil then
    FIdentifierList := TFhirIdentifierList.Create;
  result := FIdentifierList;
end;

function TFhirClaimResponse.GetHasIdentifierList : boolean;
begin
  result := (FIdentifierList <> nil) and (FIdentifierList.count > 0);
end;

procedure TFhirClaimResponse.SetStatus(value : TFhirEnum);
begin
  FStatus.free;
  FStatus := value;
end;

function TFhirClaimResponse.GetStatusST : TFhirFinancialResourceStatusCodesEnum;
begin
  if FStatus = nil then
    result := TFhirFinancialResourceStatusCodesEnum(0)
  else
    result := TFhirFinancialResourceStatusCodesEnum(StringArrayIndexOfSensitive(CODES_TFhirFinancialResourceStatusCodesEnum, FStatus.value));
end;

procedure TFhirClaimResponse.SetStatusST(value : TFhirFinancialResourceStatusCodesEnum);
begin
  if ord(value) = 0 then
    StatusElement := nil
  else
    StatusElement := TFhirEnum.create(SYSTEMS_TFhirFinancialResourceStatusCodesEnum[value], CODES_TFhirFinancialResourceStatusCodesEnum[value]);
end;

procedure TFhirClaimResponse.SetType_(value : TFhirCodeableConcept);
begin
  FType_.free;
  FType_ := value;
end;

procedure TFhirClaimResponse.SetSubType(value : TFhirCodeableConcept);
begin
  FSubType.free;
  FSubType := value;
end;

procedure TFhirClaimResponse.SetUse(value : TFhirEnum);
begin
  FUse.free;
  FUse := value;
end;

function TFhirClaimResponse.GetUseST : TFhirUseEnum;
begin
  if FUse = nil then
    result := TFhirUseEnum(0)
  else
    result := TFhirUseEnum(StringArrayIndexOfSensitive(CODES_TFhirUseEnum, FUse.value));
end;

procedure TFhirClaimResponse.SetUseST(value : TFhirUseEnum);
begin
  if ord(value) = 0 then
    UseElement := nil
  else
    UseElement := TFhirEnum.create(SYSTEMS_TFhirUseEnum[value], CODES_TFhirUseEnum[value]);
end;

procedure TFhirClaimResponse.SetPatient(value : TFhirReference);
begin
  FPatient.free;
  FPatient := value;
end;

procedure TFhirClaimResponse.SetCreated(value : TFhirDateTime);
begin
  FCreated.free;
  FCreated := value;
end;

function TFhirClaimResponse.GetCreatedST : TFslDateTime;
begin
  if FCreated = nil then
    result := TFslDateTime.makeNull
  else
    result := FCreated.value;
end;

procedure TFhirClaimResponse.SetCreatedST(value : TFslDateTime);
begin
  if FCreated = nil then
    FCreated := TFhirDateTime.create;
  FCreated.value := value
end;

procedure TFhirClaimResponse.SetInsurer(value : TFhirReference);
begin
  FInsurer.free;
  FInsurer := value;
end;

procedure TFhirClaimResponse.SetRequestor(value : TFhirReference);
begin
  FRequestor.free;
  FRequestor := value;
end;

procedure TFhirClaimResponse.SetRequest(value : TFhirReference);
begin
  FRequest.free;
  FRequest := value;
end;

procedure TFhirClaimResponse.SetOutcome(value : TFhirEnum);
begin
  FOutcome.free;
  FOutcome := value;
end;

function TFhirClaimResponse.GetOutcomeST : TFhirClaimProcessingCodesEnum;
begin
  if FOutcome = nil then
    result := TFhirClaimProcessingCodesEnum(0)
  else
    result := TFhirClaimProcessingCodesEnum(StringArrayIndexOfSensitive(CODES_TFhirClaimProcessingCodesEnum, FOutcome.value));
end;

procedure TFhirClaimResponse.SetOutcomeST(value : TFhirClaimProcessingCodesEnum);
begin
  if ord(value) = 0 then
    OutcomeElement := nil
  else
    OutcomeElement := TFhirEnum.create(SYSTEMS_TFhirClaimProcessingCodesEnum[value], CODES_TFhirClaimProcessingCodesEnum[value]);
end;

procedure TFhirClaimResponse.SetDisposition(value : TFhirString);
begin
  FDisposition.free;
  FDisposition := value;
end;

function TFhirClaimResponse.GetDispositionST : String;
begin
  if FDisposition = nil then
    result := ''
  else
    result := FDisposition.value;
end;

procedure TFhirClaimResponse.SetDispositionST(value : String);
begin
  if value <> '' then
  begin
    if FDisposition = nil then
      FDisposition := TFhirString.create;
    FDisposition.value := value
  end
  else if FDisposition <> nil then
    FDisposition.value := '';
end;

procedure TFhirClaimResponse.SetPreAuthRef(value : TFhirString);
begin
  FPreAuthRef.free;
  FPreAuthRef := value;
end;

function TFhirClaimResponse.GetPreAuthRefST : String;
begin
  if FPreAuthRef = nil then
    result := ''
  else
    result := FPreAuthRef.value;
end;

procedure TFhirClaimResponse.SetPreAuthRefST(value : String);
begin
  if value <> '' then
  begin
    if FPreAuthRef = nil then
      FPreAuthRef := TFhirString.create;
    FPreAuthRef.value := value
  end
  else if FPreAuthRef <> nil then
    FPreAuthRef.value := '';
end;

procedure TFhirClaimResponse.SetPreAuthPeriod(value : TFhirPeriod);
begin
  FPreAuthPeriod.free;
  FPreAuthPeriod := value;
end;

procedure TFhirClaimResponse.SetPayeeType(value : TFhirCodeableConcept);
begin
  FPayeeType.free;
  FPayeeType := value;
end;

function TFhirClaimResponse.GetItemList : TFhirClaimResponseItemList;
begin
  if FItemList = nil then
    FItemList := TFhirClaimResponseItemList.Create;
  result := FItemList;
end;

function TFhirClaimResponse.GetHasItemList : boolean;
begin
  result := (FItemList <> nil) and (FItemList.count > 0);
end;

function TFhirClaimResponse.GetAddItemList : TFhirClaimResponseAddItemList;
begin
  if FAddItemList = nil then
    FAddItemList := TFhirClaimResponseAddItemList.Create;
  result := FAddItemList;
end;

function TFhirClaimResponse.GetHasAddItemList : boolean;
begin
  result := (FAddItemList <> nil) and (FAddItemList.count > 0);
end;

function TFhirClaimResponse.GetAdjudicationList : TFhirClaimResponseItemAdjudicationList;
begin
  if FAdjudicationList = nil then
    FAdjudicationList := TFhirClaimResponseItemAdjudicationList.Create;
  result := FAdjudicationList;
end;

function TFhirClaimResponse.GetHasAdjudicationList : boolean;
begin
  result := (FAdjudicationList <> nil) and (FAdjudicationList.count > 0);
end;

function TFhirClaimResponse.GetTotalList : TFhirClaimResponseTotalList;
begin
  if FTotalList = nil then
    FTotalList := TFhirClaimResponseTotalList.Create;
  result := FTotalList;
end;

function TFhirClaimResponse.GetHasTotalList : boolean;
begin
  result := (FTotalList <> nil) and (FTotalList.count > 0);
end;

procedure TFhirClaimResponse.SetPayment(value : TFhirClaimResponsePayment);
begin
  FPayment.free;
  FPayment := value;
end;

procedure TFhirClaimResponse.SetFundsReserve(value : TFhirCodeableConcept);
begin
  FFundsReserve.free;
  FFundsReserve := value;
end;

procedure TFhirClaimResponse.SetFormCode(value : TFhirCodeableConcept);
begin
  FFormCode.free;
  FFormCode := value;
end;

procedure TFhirClaimResponse.SetForm(value : TFhirAttachment);
begin
  FForm.free;
  FForm := value;
end;

function TFhirClaimResponse.GetProcessNoteList : TFhirClaimResponseProcessNoteList;
begin
  if FProcessNoteList = nil then
    FProcessNoteList := TFhirClaimResponseProcessNoteList.Create;
  result := FProcessNoteList;
end;

function TFhirClaimResponse.GetHasProcessNoteList : boolean;
begin
  result := (FProcessNoteList <> nil) and (FProcessNoteList.count > 0);
end;

function TFhirClaimResponse.GetCommunicationRequestList : TFhirReferenceList;
begin
  if FCommunicationRequestList = nil then
    FCommunicationRequestList := TFhirReferenceList.Create;
  result := FCommunicationRequestList;
end;

function TFhirClaimResponse.GetHasCommunicationRequestList : boolean;
begin
  result := (FCommunicationRequestList <> nil) and (FCommunicationRequestList.count > 0);
end;

function TFhirClaimResponse.GetInsuranceList : TFhirClaimResponseInsuranceList;
begin
  if FInsuranceList = nil then
    FInsuranceList := TFhirClaimResponseInsuranceList.Create;
  result := FInsuranceList;
end;

function TFhirClaimResponse.GetHasInsuranceList : boolean;
begin
  result := (FInsuranceList <> nil) and (FInsuranceList.count > 0);
end;

function TFhirClaimResponse.GetErrorList : TFhirClaimResponseErrorList;
begin
  if FErrorList = nil then
    FErrorList := TFhirClaimResponseErrorList.Create;
  result := FErrorList;
end;

function TFhirClaimResponse.GetHasErrorList : boolean;
begin
  result := (FErrorList <> nil) and (FErrorList.count > 0);
end;

{ TFhirClaimResponseListEnumerator }

constructor TFhirClaimResponseListEnumerator.Create(list : TFhirClaimResponseList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirClaimResponseListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirClaimResponseListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirClaimResponseListEnumerator.GetCurrent : TFhirClaimResponse;
begin
  Result := FList[FIndex];
end;

function TFhirClaimResponseListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirClaimResponseList }

procedure TFhirClaimResponseList.AddItem(value: TFhirClaimResponse);
begin
  assert(value.ClassName = 'TFhirClaimResponse', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirClaimResponse');
  add(value);
end;

function TFhirClaimResponseList.Append: TFhirClaimResponse;
begin
  result := TFhirClaimResponse.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirClaimResponseList.ClearItems;
begin
  Clear;
end;

function TFhirClaimResponseList.GetEnumerator : TFhirClaimResponseListEnumerator;
begin
  result := TFhirClaimResponseListEnumerator.Create(self.link);
end;

function TFhirClaimResponseList.Clone: TFhirClaimResponseList;
begin
  result := TFhirClaimResponseList(inherited Clone);
end;

function TFhirClaimResponseList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirClaimResponseList.GetItemN(index: Integer): TFhirClaimResponse;
begin
  result := TFhirClaimResponse(ObjectByIndex[index]);
end;

function TFhirClaimResponseList.ItemClass: TFslObjectClass;
begin
  result := TFhirClaimResponse;
end;
function TFhirClaimResponseList.IndexOf(value: TFhirClaimResponse): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirClaimResponseList.Insert(index: Integer): TFhirClaimResponse;
begin
  result := TFhirClaimResponse.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirClaimResponseList.InsertItem(index: Integer; value: TFhirClaimResponse);
begin
  assert(value is TFhirClaimResponse);
  Inherited Insert(index, value);
end;

function TFhirClaimResponseList.Item(index: Integer): TFhirClaimResponse;
begin
  result := TFhirClaimResponse(ObjectByIndex[index]);
end;

function TFhirClaimResponseList.Link: TFhirClaimResponseList;
begin
  result := TFhirClaimResponseList(inherited Link);
end;

procedure TFhirClaimResponseList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirClaimResponseList.SetItemByIndex(index: Integer; value: TFhirClaimResponse);
begin
  assert(value is TFhirClaimResponse);
  FhirClaimResponses[index] := value;
end;

procedure TFhirClaimResponseList.SetItemN(index: Integer; value: TFhirClaimResponse);
begin
  assert(value is TFhirClaimResponse);
  ObjectByIndex[index] := value;
end;

{$ENDIF FHIR_CLAIMRESPONSE}
{$IFDEF FHIR_COVERAGE}
{ TFhirCoverageClass }

constructor TFhirCoverageClass.Create;
begin
  inherited;
end;

destructor TFhirCoverageClass.Destroy;
begin
  FType_.free;
  FValue.free;
  FName.free;
  inherited;
end;

procedure TFhirCoverageClass.Assign(oSource : TFslObject);
begin
  inherited;
  type_ := TFhirCoverageClass(oSource).type_.Clone;
  valueElement := TFhirCoverageClass(oSource).valueElement.Clone;
  nameElement := TFhirCoverageClass(oSource).nameElement.Clone;
end;

procedure TFhirCoverageClass.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'type') Then
     list.add(self.link, 'type', FType_.Link);
  if (child_name = 'value') Then
     list.add(self.link, 'value', FValue.Link);
  if (child_name = 'name') Then
     list.add(self.link, 'name', FName.Link);
end;

procedure TFhirCoverageClass.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'type', 'CodeableConcept', false, TFhirCodeableConcept, FType_.Link));
  oList.add(TFHIRProperty.create(self, 'value', 'string', false, TFhirString, FValue.Link));
  oList.add(TFHIRProperty.create(self, 'name', 'string', false, TFhirString, FName.Link));
end;

function TFhirCoverageClass.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'type') then
  begin
    Type_ := propValue as TFhirCodeableConcept;
    result := propValue;
  end
  else if (propName = 'value') then
  begin
    ValueElement := asString(propValue);
    result := propValue;
  end
  else if (propName = 'name') then
  begin
    NameElement := asString(propValue);
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirCoverageClass.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirCoverageClass.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'type') then result := TFhirCodeableConcept.create()
  else if (propName = 'value') then result := TFhirString.create()
  else if (propName = 'name') then result := TFhirString.create()
  else result := inherited createPropertyValue(propName);
end;

function TFhirCoverageClass.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'type') then result := 'CodeableConcept'
  else if (propName = 'value') then result := 'string'
  else if (propName = 'name') then result := 'string'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirCoverageClass.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'type') then Type_Element := nil
  else if (propName = 'value') then ValueElement := nil
  else if (propName = 'name') then NameElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirCoverageClass.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'type') then Type_Element := new as TFhirCodeableConcept
  else if (propName = 'value') then ValueElement := asString(new)
  else if (propName = 'name') then NameElement := asString(new)
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirCoverageClass.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirCoverageClass.fhirType : string;
begin
  result := 'Coverage.class';
end;

function TFhirCoverageClass.Link : TFhirCoverageClass;
begin
  result := TFhirCoverageClass(inherited Link);
end;

function TFhirCoverageClass.Clone : TFhirCoverageClass;
begin
  result := TFhirCoverageClass(inherited Clone);
end;

function TFhirCoverageClass.equals(other : TObject) : boolean; 
var
  o : TFhirCoverageClass;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirCoverageClass)) then
    result := false
  else
  begin
    o := TFhirCoverageClass(other);
    result := compareDeep(type_Element, o.type_Element, true) and compareDeep(valueElement, o.valueElement, true) and 
      compareDeep(nameElement, o.nameElement, true);
  end;
end;

function TFhirCoverageClass.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FType_) and isEmptyProp(FValue) and isEmptyProp(FName);
end;

procedure TFhirCoverageClass.listFieldsInOrder(fields : TStringList);
begin
  inherited listFieldsInOrder(fields);
  fields.add('type');
  fields.add('value');
  fields.add('name');
end;

function TFhirCoverageClass.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
end;

procedure TFhirCoverageClass.SetType_(value : TFhirCodeableConcept);
begin
  FType_.free;
  FType_ := value;
end;

procedure TFhirCoverageClass.SetValue(value : TFhirString);
begin
  FValue.free;
  FValue := value;
end;

function TFhirCoverageClass.GetValueST : String;
begin
  if FValue = nil then
    result := ''
  else
    result := FValue.value;
end;

procedure TFhirCoverageClass.SetValueST(value : String);
begin
  if value <> '' then
  begin
    if FValue = nil then
      FValue := TFhirString.create;
    FValue.value := value
  end
  else if FValue <> nil then
    FValue.value := '';
end;

procedure TFhirCoverageClass.SetName(value : TFhirString);
begin
  FName.free;
  FName := value;
end;

function TFhirCoverageClass.GetNameST : String;
begin
  if FName = nil then
    result := ''
  else
    result := FName.value;
end;

procedure TFhirCoverageClass.SetNameST(value : String);
begin
  if value <> '' then
  begin
    if FName = nil then
      FName := TFhirString.create;
    FName.value := value
  end
  else if FName <> nil then
    FName.value := '';
end;

{ TFhirCoverageClassListEnumerator }

constructor TFhirCoverageClassListEnumerator.Create(list : TFhirCoverageClassList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirCoverageClassListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirCoverageClassListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirCoverageClassListEnumerator.GetCurrent : TFhirCoverageClass;
begin
  Result := FList[FIndex];
end;

function TFhirCoverageClassListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirCoverageClassList }

procedure TFhirCoverageClassList.AddItem(value: TFhirCoverageClass);
begin
  assert(value.ClassName = 'TFhirCoverageClass', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirCoverageClass');
  add(value);
end;

function TFhirCoverageClassList.Append: TFhirCoverageClass;
begin
  result := TFhirCoverageClass.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirCoverageClassList.ClearItems;
begin
  Clear;
end;

function TFhirCoverageClassList.GetEnumerator : TFhirCoverageClassListEnumerator;
begin
  result := TFhirCoverageClassListEnumerator.Create(self.link);
end;

function TFhirCoverageClassList.Clone: TFhirCoverageClassList;
begin
  result := TFhirCoverageClassList(inherited Clone);
end;

function TFhirCoverageClassList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirCoverageClassList.GetItemN(index: Integer): TFhirCoverageClass;
begin
  result := TFhirCoverageClass(ObjectByIndex[index]);
end;

function TFhirCoverageClassList.ItemClass: TFslObjectClass;
begin
  result := TFhirCoverageClass;
end;
function TFhirCoverageClassList.IndexOf(value: TFhirCoverageClass): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirCoverageClassList.Insert(index: Integer): TFhirCoverageClass;
begin
  result := TFhirCoverageClass.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirCoverageClassList.InsertItem(index: Integer; value: TFhirCoverageClass);
begin
  assert(value is TFhirCoverageClass);
  Inherited Insert(index, value);
end;

function TFhirCoverageClassList.Item(index: Integer): TFhirCoverageClass;
begin
  result := TFhirCoverageClass(ObjectByIndex[index]);
end;

function TFhirCoverageClassList.Link: TFhirCoverageClassList;
begin
  result := TFhirCoverageClassList(inherited Link);
end;

procedure TFhirCoverageClassList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirCoverageClassList.SetItemByIndex(index: Integer; value: TFhirCoverageClass);
begin
  assert(value is TFhirCoverageClass);
  FhirCoverageClasses[index] := value;
end;

procedure TFhirCoverageClassList.SetItemN(index: Integer; value: TFhirCoverageClass);
begin
  assert(value is TFhirCoverageClass);
  ObjectByIndex[index] := value;
end;

{ TFhirCoverageCostToBeneficiary }

constructor TFhirCoverageCostToBeneficiary.Create;
begin
  inherited;
end;

destructor TFhirCoverageCostToBeneficiary.Destroy;
begin
  FType_.free;
  FValue.free;
  FExceptionList.Free;
  inherited;
end;

procedure TFhirCoverageCostToBeneficiary.Assign(oSource : TFslObject);
begin
  inherited;
  type_ := TFhirCoverageCostToBeneficiary(oSource).type_.Clone;
  value := TFhirCoverageCostToBeneficiary(oSource).value.Clone;
  if (TFhirCoverageCostToBeneficiary(oSource).FExceptionList = nil) then
  begin
    FExceptionList.free;
    FExceptionList := nil;
  end
  else
  begin
    if FExceptionList = nil then
      FExceptionList := TFhirCoverageCostToBeneficiaryExceptionList.Create;
    FExceptionList.Assign(TFhirCoverageCostToBeneficiary(oSource).FExceptionList);
  end;
end;

procedure TFhirCoverageCostToBeneficiary.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'type') Then
     list.add(self.link, 'type', FType_.Link);
  if (child_name = 'value[x]') or (child_name = 'value') Then
     list.add(self.link, 'value[x]', FValue.Link);
  if (child_name = 'exception') Then
    list.addAll(self, 'exception', FExceptionList);
end;

procedure TFhirCoverageCostToBeneficiary.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'type', 'CodeableConcept', false, TFhirCodeableConcept, FType_.Link));
  oList.add(TFHIRProperty.create(self, 'value[x]', 'Quantity|Money', false, TFhirDataType, FValue.Link));
  oList.add(TFHIRProperty.create(self, 'exception', 'BackboneElement', true, TFhirCoverageCostToBeneficiaryException, FExceptionList.Link));
end;

function TFhirCoverageCostToBeneficiary.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'type') then
  begin
    Type_ := propValue as TFhirCodeableConcept;
    result := propValue;
  end
  else if (isMatchingName(propName, 'value', ['Quantity', 'Money'])) then
  begin
    Value := propValue as TFhirDataType;
    result := propValue;
  end
  else if (propName = 'exception') then
  begin
    ExceptionList.add(propValue as TFhirCoverageCostToBeneficiaryException);
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirCoverageCostToBeneficiary.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'exception') then ExceptionList.insertItem(index, propValue as TFhirCoverageCostToBeneficiaryException)
  else inherited;
end;

function TFhirCoverageCostToBeneficiary.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'type') then result := TFhirCodeableConcept.create()
  else if (isMatchingName(propName, 'value', ['Quantity', 'Money'])) then raise EFHIRException.create('Cannot make property Value')
  else if (propName = 'exception') then result := ExceptionList.new()
  else result := inherited createPropertyValue(propName);
end;

function TFhirCoverageCostToBeneficiary.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'type') then result := 'CodeableConcept'
  else if (propName = 'value[x]') then result := 'Quantity|Money'
  else if (propName = 'exception') then result := 'BackboneElement'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirCoverageCostToBeneficiary.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'type') then Type_Element := nil
  else if (isMatchingName(propName, 'value', ['Quantity', 'Money'])) then ValueElement := nil
  else if (propName = 'exception') then deletePropertyValue('exception', ExceptionList, value)
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirCoverageCostToBeneficiary.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'type') then Type_Element := new as TFhirCodeableConcept
  else if (isMatchingName(propName, 'value', ['Quantity', 'Money'])) then ValueElement := new as TFhirDataType
  else if (propName = 'exception') then replacePropertyValue('exception', ExceptionList, existing, new)
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirCoverageCostToBeneficiary.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'exception') then ExceptionList.move(source, destination)
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirCoverageCostToBeneficiary.fhirType : string;
begin
  result := 'Coverage.costToBeneficiary';
end;

function TFhirCoverageCostToBeneficiary.Link : TFhirCoverageCostToBeneficiary;
begin
  result := TFhirCoverageCostToBeneficiary(inherited Link);
end;

function TFhirCoverageCostToBeneficiary.Clone : TFhirCoverageCostToBeneficiary;
begin
  result := TFhirCoverageCostToBeneficiary(inherited Clone);
end;

function TFhirCoverageCostToBeneficiary.equals(other : TObject) : boolean; 
var
  o : TFhirCoverageCostToBeneficiary;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirCoverageCostToBeneficiary)) then
    result := false
  else
  begin
    o := TFhirCoverageCostToBeneficiary(other);
    result := compareDeep(type_Element, o.type_Element, true) and compareDeep(valueElement, o.valueElement, true) and 
      compareDeep(exceptionList, o.exceptionList, true);
  end;
end;

function TFhirCoverageCostToBeneficiary.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FType_) and isEmptyProp(FValue) and isEmptyProp(FexceptionList);
end;

procedure TFhirCoverageCostToBeneficiary.listFieldsInOrder(fields : TStringList);
begin
  inherited listFieldsInOrder(fields);
  fields.add('type');
  fields.add('value[x]');
  fields.add('exception');
end;

function TFhirCoverageCostToBeneficiary.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FExceptionList.sizeInBytes(magic));
end;

procedure TFhirCoverageCostToBeneficiary.SetType_(value : TFhirCodeableConcept);
begin
  FType_.free;
  FType_ := value;
end;

procedure TFhirCoverageCostToBeneficiary.SetValue(value : TFhirDataType);
begin
  FValue.free;
  FValue := value;
end;

function TFhirCoverageCostToBeneficiary.GetExceptionList : TFhirCoverageCostToBeneficiaryExceptionList;
begin
  if FExceptionList = nil then
    FExceptionList := TFhirCoverageCostToBeneficiaryExceptionList.Create;
  result := FExceptionList;
end;

function TFhirCoverageCostToBeneficiary.GetHasExceptionList : boolean;
begin
  result := (FExceptionList <> nil) and (FExceptionList.count > 0);
end;

{ TFhirCoverageCostToBeneficiaryListEnumerator }

constructor TFhirCoverageCostToBeneficiaryListEnumerator.Create(list : TFhirCoverageCostToBeneficiaryList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirCoverageCostToBeneficiaryListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirCoverageCostToBeneficiaryListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirCoverageCostToBeneficiaryListEnumerator.GetCurrent : TFhirCoverageCostToBeneficiary;
begin
  Result := FList[FIndex];
end;

function TFhirCoverageCostToBeneficiaryListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirCoverageCostToBeneficiaryList }

procedure TFhirCoverageCostToBeneficiaryList.AddItem(value: TFhirCoverageCostToBeneficiary);
begin
  assert(value.ClassName = 'TFhirCoverageCostToBeneficiary', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirCoverageCostToBeneficiary');
  add(value);
end;

function TFhirCoverageCostToBeneficiaryList.Append: TFhirCoverageCostToBeneficiary;
begin
  result := TFhirCoverageCostToBeneficiary.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirCoverageCostToBeneficiaryList.ClearItems;
begin
  Clear;
end;

function TFhirCoverageCostToBeneficiaryList.GetEnumerator : TFhirCoverageCostToBeneficiaryListEnumerator;
begin
  result := TFhirCoverageCostToBeneficiaryListEnumerator.Create(self.link);
end;

function TFhirCoverageCostToBeneficiaryList.Clone: TFhirCoverageCostToBeneficiaryList;
begin
  result := TFhirCoverageCostToBeneficiaryList(inherited Clone);
end;

function TFhirCoverageCostToBeneficiaryList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirCoverageCostToBeneficiaryList.GetItemN(index: Integer): TFhirCoverageCostToBeneficiary;
begin
  result := TFhirCoverageCostToBeneficiary(ObjectByIndex[index]);
end;

function TFhirCoverageCostToBeneficiaryList.ItemClass: TFslObjectClass;
begin
  result := TFhirCoverageCostToBeneficiary;
end;
function TFhirCoverageCostToBeneficiaryList.IndexOf(value: TFhirCoverageCostToBeneficiary): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirCoverageCostToBeneficiaryList.Insert(index: Integer): TFhirCoverageCostToBeneficiary;
begin
  result := TFhirCoverageCostToBeneficiary.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirCoverageCostToBeneficiaryList.InsertItem(index: Integer; value: TFhirCoverageCostToBeneficiary);
begin
  assert(value is TFhirCoverageCostToBeneficiary);
  Inherited Insert(index, value);
end;

function TFhirCoverageCostToBeneficiaryList.Item(index: Integer): TFhirCoverageCostToBeneficiary;
begin
  result := TFhirCoverageCostToBeneficiary(ObjectByIndex[index]);
end;

function TFhirCoverageCostToBeneficiaryList.Link: TFhirCoverageCostToBeneficiaryList;
begin
  result := TFhirCoverageCostToBeneficiaryList(inherited Link);
end;

procedure TFhirCoverageCostToBeneficiaryList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirCoverageCostToBeneficiaryList.SetItemByIndex(index: Integer; value: TFhirCoverageCostToBeneficiary);
begin
  assert(value is TFhirCoverageCostToBeneficiary);
  FhirCoverageCostToBeneficiaries[index] := value;
end;

procedure TFhirCoverageCostToBeneficiaryList.SetItemN(index: Integer; value: TFhirCoverageCostToBeneficiary);
begin
  assert(value is TFhirCoverageCostToBeneficiary);
  ObjectByIndex[index] := value;
end;

{ TFhirCoverageCostToBeneficiaryException }

constructor TFhirCoverageCostToBeneficiaryException.Create;
begin
  inherited;
end;

destructor TFhirCoverageCostToBeneficiaryException.Destroy;
begin
  FType_.free;
  FPeriod.free;
  inherited;
end;

procedure TFhirCoverageCostToBeneficiaryException.Assign(oSource : TFslObject);
begin
  inherited;
  type_ := TFhirCoverageCostToBeneficiaryException(oSource).type_.Clone;
  period := TFhirCoverageCostToBeneficiaryException(oSource).period.Clone;
end;

procedure TFhirCoverageCostToBeneficiaryException.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'type') Then
     list.add(self.link, 'type', FType_.Link);
  if (child_name = 'period') Then
     list.add(self.link, 'period', FPeriod.Link);
end;

procedure TFhirCoverageCostToBeneficiaryException.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'type', 'CodeableConcept', false, TFhirCodeableConcept, FType_.Link));
  oList.add(TFHIRProperty.create(self, 'period', 'Period', false, TFhirPeriod, FPeriod.Link));
end;

function TFhirCoverageCostToBeneficiaryException.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'type') then
  begin
    Type_ := propValue as TFhirCodeableConcept;
    result := propValue;
  end
  else if (propName = 'period') then
  begin
    Period := propValue as TFhirPeriod;
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirCoverageCostToBeneficiaryException.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirCoverageCostToBeneficiaryException.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'type') then result := TFhirCodeableConcept.create()
  else if (propName = 'period') then result := TFhirPeriod.create()
  else result := inherited createPropertyValue(propName);
end;

function TFhirCoverageCostToBeneficiaryException.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'type') then result := 'CodeableConcept'
  else if (propName = 'period') then result := 'Period'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirCoverageCostToBeneficiaryException.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'type') then Type_Element := nil
  else if (propName = 'period') then PeriodElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirCoverageCostToBeneficiaryException.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'type') then Type_Element := new as TFhirCodeableConcept
  else if (propName = 'period') then PeriodElement := new as TFhirPeriod
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirCoverageCostToBeneficiaryException.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirCoverageCostToBeneficiaryException.fhirType : string;
begin
  result := 'Coverage.costToBeneficiary.exception';
end;

function TFhirCoverageCostToBeneficiaryException.Link : TFhirCoverageCostToBeneficiaryException;
begin
  result := TFhirCoverageCostToBeneficiaryException(inherited Link);
end;

function TFhirCoverageCostToBeneficiaryException.Clone : TFhirCoverageCostToBeneficiaryException;
begin
  result := TFhirCoverageCostToBeneficiaryException(inherited Clone);
end;

function TFhirCoverageCostToBeneficiaryException.equals(other : TObject) : boolean; 
var
  o : TFhirCoverageCostToBeneficiaryException;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirCoverageCostToBeneficiaryException)) then
    result := false
  else
  begin
    o := TFhirCoverageCostToBeneficiaryException(other);
    result := compareDeep(type_Element, o.type_Element, true) and compareDeep(periodElement, o.periodElement, true);
  end;
end;

function TFhirCoverageCostToBeneficiaryException.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FType_) and isEmptyProp(FPeriod);
end;

procedure TFhirCoverageCostToBeneficiaryException.listFieldsInOrder(fields : TStringList);
begin
  inherited listFieldsInOrder(fields);
  fields.add('type');
  fields.add('period');
end;

function TFhirCoverageCostToBeneficiaryException.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
end;

procedure TFhirCoverageCostToBeneficiaryException.SetType_(value : TFhirCodeableConcept);
begin
  FType_.free;
  FType_ := value;
end;

procedure TFhirCoverageCostToBeneficiaryException.SetPeriod(value : TFhirPeriod);
begin
  FPeriod.free;
  FPeriod := value;
end;

{ TFhirCoverageCostToBeneficiaryExceptionListEnumerator }

constructor TFhirCoverageCostToBeneficiaryExceptionListEnumerator.Create(list : TFhirCoverageCostToBeneficiaryExceptionList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirCoverageCostToBeneficiaryExceptionListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirCoverageCostToBeneficiaryExceptionListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirCoverageCostToBeneficiaryExceptionListEnumerator.GetCurrent : TFhirCoverageCostToBeneficiaryException;
begin
  Result := FList[FIndex];
end;

function TFhirCoverageCostToBeneficiaryExceptionListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirCoverageCostToBeneficiaryExceptionList }

procedure TFhirCoverageCostToBeneficiaryExceptionList.AddItem(value: TFhirCoverageCostToBeneficiaryException);
begin
  assert(value.ClassName = 'TFhirCoverageCostToBeneficiaryException', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirCoverageCostToBeneficiaryException');
  add(value);
end;

function TFhirCoverageCostToBeneficiaryExceptionList.Append: TFhirCoverageCostToBeneficiaryException;
begin
  result := TFhirCoverageCostToBeneficiaryException.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirCoverageCostToBeneficiaryExceptionList.ClearItems;
begin
  Clear;
end;

function TFhirCoverageCostToBeneficiaryExceptionList.GetEnumerator : TFhirCoverageCostToBeneficiaryExceptionListEnumerator;
begin
  result := TFhirCoverageCostToBeneficiaryExceptionListEnumerator.Create(self.link);
end;

function TFhirCoverageCostToBeneficiaryExceptionList.Clone: TFhirCoverageCostToBeneficiaryExceptionList;
begin
  result := TFhirCoverageCostToBeneficiaryExceptionList(inherited Clone);
end;

function TFhirCoverageCostToBeneficiaryExceptionList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirCoverageCostToBeneficiaryExceptionList.GetItemN(index: Integer): TFhirCoverageCostToBeneficiaryException;
begin
  result := TFhirCoverageCostToBeneficiaryException(ObjectByIndex[index]);
end;

function TFhirCoverageCostToBeneficiaryExceptionList.ItemClass: TFslObjectClass;
begin
  result := TFhirCoverageCostToBeneficiaryException;
end;
function TFhirCoverageCostToBeneficiaryExceptionList.IndexOf(value: TFhirCoverageCostToBeneficiaryException): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirCoverageCostToBeneficiaryExceptionList.Insert(index: Integer): TFhirCoverageCostToBeneficiaryException;
begin
  result := TFhirCoverageCostToBeneficiaryException.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirCoverageCostToBeneficiaryExceptionList.InsertItem(index: Integer; value: TFhirCoverageCostToBeneficiaryException);
begin
  assert(value is TFhirCoverageCostToBeneficiaryException);
  Inherited Insert(index, value);
end;

function TFhirCoverageCostToBeneficiaryExceptionList.Item(index: Integer): TFhirCoverageCostToBeneficiaryException;
begin
  result := TFhirCoverageCostToBeneficiaryException(ObjectByIndex[index]);
end;

function TFhirCoverageCostToBeneficiaryExceptionList.Link: TFhirCoverageCostToBeneficiaryExceptionList;
begin
  result := TFhirCoverageCostToBeneficiaryExceptionList(inherited Link);
end;

procedure TFhirCoverageCostToBeneficiaryExceptionList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirCoverageCostToBeneficiaryExceptionList.SetItemByIndex(index: Integer; value: TFhirCoverageCostToBeneficiaryException);
begin
  assert(value is TFhirCoverageCostToBeneficiaryException);
  FhirCoverageCostToBeneficiaryExceptions[index] := value;
end;

procedure TFhirCoverageCostToBeneficiaryExceptionList.SetItemN(index: Integer; value: TFhirCoverageCostToBeneficiaryException);
begin
  assert(value is TFhirCoverageCostToBeneficiaryException);
  ObjectByIndex[index] := value;
end;

{ TFhirCoverage }

constructor TFhirCoverage.Create;
begin
  inherited;
end;

destructor TFhirCoverage.Destroy;
begin
  FIdentifierList.Free;
  FStatus.free;
  FType_.free;
  FPolicyHolder.free;
  FSubscriber.free;
  FSubscriberId.free;
  FBeneficiary.free;
  FDependent.free;
  FRelationship.free;
  FPeriod.free;
  FPayorList.Free;
  FClass_List.Free;
  FOrder.free;
  FNetwork.free;
  FCostToBeneficiaryList.Free;
  FSubrogation.free;
  FContractList.Free;
  inherited;
end;

procedure TFhirCoverage.Assign(oSource : TFslObject);
begin
  inherited;
  if (TFhirCoverage(oSource).FIdentifierList = nil) then
  begin
    FIdentifierList.free;
    FIdentifierList := nil;
  end
  else
  begin
    if FIdentifierList = nil then
      FIdentifierList := TFhirIdentifierList.Create;
    FIdentifierList.Assign(TFhirCoverage(oSource).FIdentifierList);
  end;
  statusElement := TFhirCoverage(oSource).statusElement.Clone;
  type_ := TFhirCoverage(oSource).type_.Clone;
  policyHolder := TFhirCoverage(oSource).policyHolder.Clone;
  subscriber := TFhirCoverage(oSource).subscriber.Clone;
  subscriberId := TFhirCoverage(oSource).subscriberId.Clone;
  beneficiary := TFhirCoverage(oSource).beneficiary.Clone;
  dependentElement := TFhirCoverage(oSource).dependentElement.Clone;
  relationship := TFhirCoverage(oSource).relationship.Clone;
  period := TFhirCoverage(oSource).period.Clone;
  if (TFhirCoverage(oSource).FPayorList = nil) then
  begin
    FPayorList.free;
    FPayorList := nil;
  end
  else
  begin
    if FPayorList = nil then
      FPayorList := TFhirReferenceList.Create;
    FPayorList.Assign(TFhirCoverage(oSource).FPayorList);
  end;
  if (TFhirCoverage(oSource).FClass_List = nil) then
  begin
    FClass_List.free;
    FClass_List := nil;
  end
  else
  begin
    if FClass_List = nil then
      FClass_List := TFhirCoverageClassList.Create;
    FClass_List.Assign(TFhirCoverage(oSource).FClass_List);
  end;
  orderElement := TFhirCoverage(oSource).orderElement.Clone;
  networkElement := TFhirCoverage(oSource).networkElement.Clone;
  if (TFhirCoverage(oSource).FCostToBeneficiaryList = nil) then
  begin
    FCostToBeneficiaryList.free;
    FCostToBeneficiaryList := nil;
  end
  else
  begin
    if FCostToBeneficiaryList = nil then
      FCostToBeneficiaryList := TFhirCoverageCostToBeneficiaryList.Create;
    FCostToBeneficiaryList.Assign(TFhirCoverage(oSource).FCostToBeneficiaryList);
  end;
  subrogationElement := TFhirCoverage(oSource).subrogationElement.Clone;
  if (TFhirCoverage(oSource).FContractList = nil) then
  begin
    FContractList.free;
    FContractList := nil;
  end
  else
  begin
    if FContractList = nil then
      FContractList := TFhirReferenceList.Create;
    FContractList.Assign(TFhirCoverage(oSource).FContractList);
  end;
end;

function TFhirCoverage.GetResourceType : TFhirResourceType;
begin
  result := frtCoverage;
end;

procedure TFhirCoverage.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'identifier') Then
    list.addAll(self, 'identifier', FIdentifierList);
  if (child_name = 'status') Then
     list.add(self.link, 'status', FStatus.Link);
  if (child_name = 'type') Then
     list.add(self.link, 'type', FType_.Link);
  if (child_name = 'policyHolder') Then
     list.add(self.link, 'policyHolder', FPolicyHolder.Link);
  if (child_name = 'subscriber') Then
     list.add(self.link, 'subscriber', FSubscriber.Link);
  if (child_name = 'subscriberId') Then
     list.add(self.link, 'subscriberId', FSubscriberId.Link);
  if (child_name = 'beneficiary') Then
     list.add(self.link, 'beneficiary', FBeneficiary.Link);
  if (child_name = 'dependent') Then
     list.add(self.link, 'dependent', FDependent.Link);
  if (child_name = 'relationship') Then
     list.add(self.link, 'relationship', FRelationship.Link);
  if (child_name = 'period') Then
     list.add(self.link, 'period', FPeriod.Link);
  if (child_name = 'payor') Then
    list.addAll(self, 'payor', FPayorList);
  if (child_name = 'class') Then
    list.addAll(self, 'class', FClass_List);
  if (child_name = 'order') Then
     list.add(self.link, 'order', FOrder.Link);
  if (child_name = 'network') Then
     list.add(self.link, 'network', FNetwork.Link);
  if (child_name = 'costToBeneficiary') Then
    list.addAll(self, 'costToBeneficiary', FCostToBeneficiaryList);
  if (child_name = 'subrogation') Then
     list.add(self.link, 'subrogation', FSubrogation.Link);
  if (child_name = 'contract') Then
    list.addAll(self, 'contract', FContractList);
end;

procedure TFhirCoverage.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'identifier', 'Identifier', true, TFhirIdentifier, FIdentifierList.Link));
  oList.add(TFHIRProperty.create(self, 'status', 'code', false, TFhirEnum, FStatus.Link));
  oList.add(TFHIRProperty.create(self, 'type', 'CodeableConcept', false, TFhirCodeableConcept, FType_.Link));
  oList.add(TFHIRProperty.create(self, 'policyHolder', 'Reference', false, TFhirReference, FPolicyHolder.Link));
  oList.add(TFHIRProperty.create(self, 'subscriber', 'Reference', false, TFhirReference, FSubscriber.Link));
  oList.add(TFHIRProperty.create(self, 'subscriberId', 'Identifier', false, TFhirIdentifier, FSubscriberId.Link));
  oList.add(TFHIRProperty.create(self, 'beneficiary', 'Reference', false, TFhirReference, FBeneficiary.Link));
  oList.add(TFHIRProperty.create(self, 'dependent', 'string', false, TFhirString, FDependent.Link));
  oList.add(TFHIRProperty.create(self, 'relationship', 'CodeableConcept', false, TFhirCodeableConcept, FRelationship.Link));
  oList.add(TFHIRProperty.create(self, 'period', 'Period', false, TFhirPeriod, FPeriod.Link));
  oList.add(TFHIRProperty.create(self, 'payor', 'Reference', true, TFhirReference, FPayorList.Link));
  oList.add(TFHIRProperty.create(self, 'class', 'BackboneElement', true, TFhirCoverageClass, FClass_List.Link));
  oList.add(TFHIRProperty.create(self, 'order', 'positiveInt', false, TFhirPositiveInt, FOrder.Link));
  oList.add(TFHIRProperty.create(self, 'network', 'string', false, TFhirString, FNetwork.Link));
  oList.add(TFHIRProperty.create(self, 'costToBeneficiary', 'BackboneElement', true, TFhirCoverageCostToBeneficiary, FCostToBeneficiaryList.Link));
  oList.add(TFHIRProperty.create(self, 'subrogation', 'boolean', false, TFhirBoolean, FSubrogation.Link));
  oList.add(TFHIRProperty.create(self, 'contract', 'Reference', true, TFhirReference, FContractList.Link));
end;

function TFhirCoverage.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'identifier') then
  begin
    IdentifierList.add(propValue as TFhirIdentifier);
    result := propValue;
  end
  else if (propName = 'status') then
  begin
    StatusElement := asEnum(SYSTEMS_TFhirFinancialResourceStatusCodesEnum, CODES_TFhirFinancialResourceStatusCodesEnum, propValue);
    result := propValue;
  end
  else if (propName = 'type') then
  begin
    Type_ := propValue as TFhirCodeableConcept;
    result := propValue;
  end
  else if (propName = 'policyHolder') then
  begin
    PolicyHolder := propValue as TFhirReference;
    result := propValue;
  end
  else if (propName = 'subscriber') then
  begin
    Subscriber := propValue as TFhirReference;
    result := propValue;
  end
  else if (propName = 'subscriberId') then
  begin
    SubscriberId := propValue as TFhirIdentifier;
    result := propValue;
  end
  else if (propName = 'beneficiary') then
  begin
    Beneficiary := propValue as TFhirReference;
    result := propValue;
  end
  else if (propName = 'dependent') then
  begin
    DependentElement := asString(propValue);
    result := propValue;
  end
  else if (propName = 'relationship') then
  begin
    Relationship := propValue as TFhirCodeableConcept;
    result := propValue;
  end
  else if (propName = 'period') then
  begin
    Period := propValue as TFhirPeriod;
    result := propValue;
  end
  else if (propName = 'payor') then
  begin
    PayorList.add(propValue as TFhirReference);
    result := propValue;
  end
  else if (propName = 'class') then
  begin
    Class_List.add(propValue as TFhirCoverageClass);
    result := propValue;
  end
  else if (propName = 'order') then
  begin
    OrderElement := asPositiveInt(propValue);
    result := propValue;
  end
  else if (propName = 'network') then
  begin
    NetworkElement := asString(propValue);
    result := propValue;
  end
  else if (propName = 'costToBeneficiary') then
  begin
    CostToBeneficiaryList.add(propValue as TFhirCoverageCostToBeneficiary);
    result := propValue;
  end
  else if (propName = 'subrogation') then
  begin
    SubrogationElement := asBoolean(propValue);
    result := propValue;
  end
  else if (propName = 'contract') then
  begin
    ContractList.add(propValue as TFhirReference);
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirCoverage.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'identifier') then IdentifierList.insertItem(index, propValue as TFhirIdentifier)
  else if (propName = 'payor') then PayorList.insertItem(index, propValue as TFhirReference)
  else if (propName = 'class') then Class_List.insertItem(index, propValue as TFhirCoverageClass)
  else if (propName = 'costToBeneficiary') then CostToBeneficiaryList.insertItem(index, propValue as TFhirCoverageCostToBeneficiary)
  else if (propName = 'contract') then ContractList.insertItem(index, propValue as TFhirReference)
  else inherited;
end;

function TFhirCoverage.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'identifier') then result := IdentifierList.new()
  else if (propName = 'status') then result := TFhirEnum.create(SYSTEMS_TFhirFinancialResourceStatusCodesEnum[FinancialResourceStatusCodesNull], CODES_TFhirFinancialResourceStatusCodesEnum[FinancialResourceStatusCodesNull]) 
  else if (propName = 'type') then result := TFhirCodeableConcept.create()
  else if (propName = 'policyHolder') then result := TFhirReference.create()
  else if (propName = 'subscriber') then result := TFhirReference.create()
  else if (propName = 'subscriberId') then result := TFhirIdentifier.create()
  else if (propName = 'beneficiary') then result := TFhirReference.create()
  else if (propName = 'dependent') then result := TFhirString.create()
  else if (propName = 'relationship') then result := TFhirCodeableConcept.create()
  else if (propName = 'period') then result := TFhirPeriod.create()
  else if (propName = 'payor') then result := PayorList.new()
  else if (propName = 'class') then result := Class_List.new()
  else if (propName = 'order') then result := TFhirPositiveInt.create()
  else if (propName = 'network') then result := TFhirString.create()
  else if (propName = 'costToBeneficiary') then result := CostToBeneficiaryList.new()
  else if (propName = 'subrogation') then result := TFhirBoolean.create()
  else if (propName = 'contract') then result := ContractList.new()
  else result := inherited createPropertyValue(propName);
end;

function TFhirCoverage.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'identifier') then result := 'Identifier'
  else if (propName = 'status') then result := 'code'
  else if (propName = 'type') then result := 'CodeableConcept'
  else if (propName = 'policyHolder') then result := 'Reference'
  else if (propName = 'subscriber') then result := 'Reference'
  else if (propName = 'subscriberId') then result := 'Identifier'
  else if (propName = 'beneficiary') then result := 'Reference'
  else if (propName = 'dependent') then result := 'string'
  else if (propName = 'relationship') then result := 'CodeableConcept'
  else if (propName = 'period') then result := 'Period'
  else if (propName = 'payor') then result := 'Reference'
  else if (propName = 'class') then result := 'BackboneElement'
  else if (propName = 'order') then result := 'positiveInt'
  else if (propName = 'network') then result := 'string'
  else if (propName = 'costToBeneficiary') then result := 'BackboneElement'
  else if (propName = 'subrogation') then result := 'boolean'
  else if (propName = 'contract') then result := 'Reference'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirCoverage.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'identifier') then deletePropertyValue('identifier', IdentifierList, value)
  else if (propName = 'status') then StatusElement := nil
  else if (propName = 'type') then Type_Element := nil
  else if (propName = 'policyHolder') then PolicyHolderElement := nil
  else if (propName = 'subscriber') then SubscriberElement := nil
  else if (propName = 'subscriberId') then SubscriberIdElement := nil
  else if (propName = 'beneficiary') then BeneficiaryElement := nil
  else if (propName = 'dependent') then DependentElement := nil
  else if (propName = 'relationship') then RelationshipElement := nil
  else if (propName = 'period') then PeriodElement := nil
  else if (propName = 'payor') then deletePropertyValue('payor', PayorList, value)
  else if (propName = 'class') then deletePropertyValue('class', Class_List, value)
  else if (propName = 'order') then OrderElement := nil
  else if (propName = 'network') then NetworkElement := nil
  else if (propName = 'costToBeneficiary') then deletePropertyValue('costToBeneficiary', CostToBeneficiaryList, value)
  else if (propName = 'subrogation') then SubrogationElement := nil
  else if (propName = 'contract') then deletePropertyValue('contract', ContractList, value)
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirCoverage.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'identifier') then replacePropertyValue('identifier', IdentifierList, existing, new)
  else if (propName = 'status') then StatusElement := asEnum(SYSTEMS_TFhirFinancialResourceStatusCodesEnum, CODES_TFhirFinancialResourceStatusCodesEnum, new)
  else if (propName = 'type') then Type_Element := new as TFhirCodeableConcept
  else if (propName = 'policyHolder') then PolicyHolderElement := new as TFhirReference
  else if (propName = 'subscriber') then SubscriberElement := new as TFhirReference
  else if (propName = 'subscriberId') then SubscriberIdElement := new as TFhirIdentifier
  else if (propName = 'beneficiary') then BeneficiaryElement := new as TFhirReference
  else if (propName = 'dependent') then DependentElement := asString(new)
  else if (propName = 'relationship') then RelationshipElement := new as TFhirCodeableConcept
  else if (propName = 'period') then PeriodElement := new as TFhirPeriod
  else if (propName = 'payor') then replacePropertyValue('payor', PayorList, existing, new)
  else if (propName = 'class') then replacePropertyValue('class', Class_List, existing, new)
  else if (propName = 'order') then OrderElement := asPositiveInt(new)
  else if (propName = 'network') then NetworkElement := asString(new)
  else if (propName = 'costToBeneficiary') then replacePropertyValue('costToBeneficiary', CostToBeneficiaryList, existing, new)
  else if (propName = 'subrogation') then SubrogationElement := asBoolean(new)
  else if (propName = 'contract') then replacePropertyValue('contract', ContractList, existing, new)
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirCoverage.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'identifier') then IdentifierList.move(source, destination)
  else if (propName = 'payor') then PayorList.move(source, destination)
  else if (propName = 'class') then Class_List.move(source, destination)
  else if (propName = 'costToBeneficiary') then CostToBeneficiaryList.move(source, destination)
  else if (propName = 'contract') then ContractList.move(source, destination)
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirCoverage.fhirType : string;
begin
  result := 'Coverage';
end;

function TFhirCoverage.Link : TFhirCoverage;
begin
  result := TFhirCoverage(inherited Link);
end;

function TFhirCoverage.Clone : TFhirCoverage;
begin
  result := TFhirCoverage(inherited Clone);
end;

function TFhirCoverage.equals(other : TObject) : boolean; 
var
  o : TFhirCoverage;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirCoverage)) then
    result := false
  else
  begin
    o := TFhirCoverage(other);
    result := compareDeep(identifierList, o.identifierList, true) and compareDeep(statusElement, o.statusElement, true) and 
      compareDeep(type_Element, o.type_Element, true) and compareDeep(policyHolderElement, o.policyHolderElement, true) and 
      compareDeep(subscriberElement, o.subscriberElement, true) and compareDeep(subscriberIdElement, o.subscriberIdElement, true) and 
      compareDeep(beneficiaryElement, o.beneficiaryElement, true) and compareDeep(dependentElement, o.dependentElement, true) and 
      compareDeep(relationshipElement, o.relationshipElement, true) and compareDeep(periodElement, o.periodElement, true) and 
      compareDeep(payorList, o.payorList, true) and compareDeep(class_List, o.class_List, true) and 
      compareDeep(orderElement, o.orderElement, true) and compareDeep(networkElement, o.networkElement, true) and 
      compareDeep(costToBeneficiaryList, o.costToBeneficiaryList, true) and compareDeep(subrogationElement, o.subrogationElement, true) and 
      compareDeep(contractList, o.contractList, true);
  end;
end;

function TFhirCoverage.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FidentifierList) and isEmptyProp(FStatus) and isEmptyProp(FType_) and isEmptyProp(FPolicyHolder) and isEmptyProp(FSubscriber) and isEmptyProp(FSubscriberId) and isEmptyProp(FBeneficiary) and isEmptyProp(FDependent) and isEmptyProp(FRelationship) and isEmptyProp(FPeriod) and isEmptyProp(FpayorList) and isEmptyProp(Fclass_List) and isEmptyProp(FOrder) and isEmptyProp(FNetwork) and isEmptyProp(FcostToBeneficiaryList) and isEmptyProp(FSubrogation) and isEmptyProp(FcontractList);
end;

procedure TFhirCoverage.listFieldsInOrder(fields : TStringList);
begin
  inherited listFieldsInOrder(fields);
  fields.add('identifier');
  fields.add('status');
  fields.add('type');
  fields.add('policyHolder');
  fields.add('subscriber');
  fields.add('subscriberId');
  fields.add('beneficiary');
  fields.add('dependent');
  fields.add('relationship');
  fields.add('period');
  fields.add('payor');
  fields.add('class');
  fields.add('order');
  fields.add('network');
  fields.add('costToBeneficiary');
  fields.add('subrogation');
  fields.add('contract');
end;

function TFhirCoverage.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FIdentifierList.sizeInBytes(magic));
  inc(result, FPayorList.sizeInBytes(magic));
  inc(result, FClass_List.sizeInBytes(magic));
  inc(result, FCostToBeneficiaryList.sizeInBytes(magic));
  inc(result, FContractList.sizeInBytes(magic));
end;

function TFhirCoverage.GetIdentifierList : TFhirIdentifierList;
begin
  if FIdentifierList = nil then
    FIdentifierList := TFhirIdentifierList.Create;
  result := FIdentifierList;
end;

function TFhirCoverage.GetHasIdentifierList : boolean;
begin
  result := (FIdentifierList <> nil) and (FIdentifierList.count > 0);
end;

procedure TFhirCoverage.SetStatus(value : TFhirEnum);
begin
  FStatus.free;
  FStatus := value;
end;

function TFhirCoverage.GetStatusST : TFhirFinancialResourceStatusCodesEnum;
begin
  if FStatus = nil then
    result := TFhirFinancialResourceStatusCodesEnum(0)
  else
    result := TFhirFinancialResourceStatusCodesEnum(StringArrayIndexOfSensitive(CODES_TFhirFinancialResourceStatusCodesEnum, FStatus.value));
end;

procedure TFhirCoverage.SetStatusST(value : TFhirFinancialResourceStatusCodesEnum);
begin
  if ord(value) = 0 then
    StatusElement := nil
  else
    StatusElement := TFhirEnum.create(SYSTEMS_TFhirFinancialResourceStatusCodesEnum[value], CODES_TFhirFinancialResourceStatusCodesEnum[value]);
end;

procedure TFhirCoverage.SetType_(value : TFhirCodeableConcept);
begin
  FType_.free;
  FType_ := value;
end;

procedure TFhirCoverage.SetPolicyHolder(value : TFhirReference);
begin
  FPolicyHolder.free;
  FPolicyHolder := value;
end;

procedure TFhirCoverage.SetSubscriber(value : TFhirReference);
begin
  FSubscriber.free;
  FSubscriber := value;
end;

procedure TFhirCoverage.SetSubscriberId(value : TFhirIdentifier);
begin
  FSubscriberId.free;
  FSubscriberId := value;
end;

procedure TFhirCoverage.SetBeneficiary(value : TFhirReference);
begin
  FBeneficiary.free;
  FBeneficiary := value;
end;

procedure TFhirCoverage.SetDependent(value : TFhirString);
begin
  FDependent.free;
  FDependent := value;
end;

function TFhirCoverage.GetDependentST : String;
begin
  if FDependent = nil then
    result := ''
  else
    result := FDependent.value;
end;

procedure TFhirCoverage.SetDependentST(value : String);
begin
  if value <> '' then
  begin
    if FDependent = nil then
      FDependent := TFhirString.create;
    FDependent.value := value
  end
  else if FDependent <> nil then
    FDependent.value := '';
end;

procedure TFhirCoverage.SetRelationship(value : TFhirCodeableConcept);
begin
  FRelationship.free;
  FRelationship := value;
end;

procedure TFhirCoverage.SetPeriod(value : TFhirPeriod);
begin
  FPeriod.free;
  FPeriod := value;
end;

function TFhirCoverage.GetPayorList : TFhirReferenceList;
begin
  if FPayorList = nil then
    FPayorList := TFhirReferenceList.Create;
  result := FPayorList;
end;

function TFhirCoverage.GetHasPayorList : boolean;
begin
  result := (FPayorList <> nil) and (FPayorList.count > 0);
end;

function TFhirCoverage.GetClass_List : TFhirCoverageClassList;
begin
  if FClass_List = nil then
    FClass_List := TFhirCoverageClassList.Create;
  result := FClass_List;
end;

function TFhirCoverage.GetHasClass_List : boolean;
begin
  result := (FClass_List <> nil) and (FClass_List.count > 0);
end;

procedure TFhirCoverage.SetOrder(value : TFhirPositiveInt);
begin
  FOrder.free;
  FOrder := value;
end;

function TFhirCoverage.GetOrderST : String;
begin
  if FOrder = nil then
    result := ''
  else
    result := FOrder.value;
end;

procedure TFhirCoverage.SetOrderST(value : String);
begin
  if value <> '' then
  begin
    if FOrder = nil then
      FOrder := TFhirPositiveInt.create;
    FOrder.value := value
  end
  else if FOrder <> nil then
    FOrder.value := '';
end;

procedure TFhirCoverage.SetNetwork(value : TFhirString);
begin
  FNetwork.free;
  FNetwork := value;
end;

function TFhirCoverage.GetNetworkST : String;
begin
  if FNetwork = nil then
    result := ''
  else
    result := FNetwork.value;
end;

procedure TFhirCoverage.SetNetworkST(value : String);
begin
  if value <> '' then
  begin
    if FNetwork = nil then
      FNetwork := TFhirString.create;
    FNetwork.value := value
  end
  else if FNetwork <> nil then
    FNetwork.value := '';
end;

function TFhirCoverage.GetCostToBeneficiaryList : TFhirCoverageCostToBeneficiaryList;
begin
  if FCostToBeneficiaryList = nil then
    FCostToBeneficiaryList := TFhirCoverageCostToBeneficiaryList.Create;
  result := FCostToBeneficiaryList;
end;

function TFhirCoverage.GetHasCostToBeneficiaryList : boolean;
begin
  result := (FCostToBeneficiaryList <> nil) and (FCostToBeneficiaryList.count > 0);
end;

procedure TFhirCoverage.SetSubrogation(value : TFhirBoolean);
begin
  FSubrogation.free;
  FSubrogation := value;
end;

function TFhirCoverage.GetSubrogationST : Boolean;
begin
  if FSubrogation = nil then
    result := false
  else
    result := FSubrogation.value;
end;

procedure TFhirCoverage.SetSubrogationST(value : Boolean);
begin
  if FSubrogation = nil then
    FSubrogation := TFhirBoolean.create;
  FSubrogation.value := value
end;

function TFhirCoverage.GetContractList : TFhirReferenceList;
begin
  if FContractList = nil then
    FContractList := TFhirReferenceList.Create;
  result := FContractList;
end;

function TFhirCoverage.GetHasContractList : boolean;
begin
  result := (FContractList <> nil) and (FContractList.count > 0);
end;

{ TFhirCoverageListEnumerator }

constructor TFhirCoverageListEnumerator.Create(list : TFhirCoverageList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirCoverageListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirCoverageListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirCoverageListEnumerator.GetCurrent : TFhirCoverage;
begin
  Result := FList[FIndex];
end;

function TFhirCoverageListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirCoverageList }

procedure TFhirCoverageList.AddItem(value: TFhirCoverage);
begin
  assert(value.ClassName = 'TFhirCoverage', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirCoverage');
  add(value);
end;

function TFhirCoverageList.Append: TFhirCoverage;
begin
  result := TFhirCoverage.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirCoverageList.ClearItems;
begin
  Clear;
end;

function TFhirCoverageList.GetEnumerator : TFhirCoverageListEnumerator;
begin
  result := TFhirCoverageListEnumerator.Create(self.link);
end;

function TFhirCoverageList.Clone: TFhirCoverageList;
begin
  result := TFhirCoverageList(inherited Clone);
end;

function TFhirCoverageList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirCoverageList.GetItemN(index: Integer): TFhirCoverage;
begin
  result := TFhirCoverage(ObjectByIndex[index]);
end;

function TFhirCoverageList.ItemClass: TFslObjectClass;
begin
  result := TFhirCoverage;
end;
function TFhirCoverageList.IndexOf(value: TFhirCoverage): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirCoverageList.Insert(index: Integer): TFhirCoverage;
begin
  result := TFhirCoverage.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirCoverageList.InsertItem(index: Integer; value: TFhirCoverage);
begin
  assert(value is TFhirCoverage);
  Inherited Insert(index, value);
end;

function TFhirCoverageList.Item(index: Integer): TFhirCoverage;
begin
  result := TFhirCoverage(ObjectByIndex[index]);
end;

function TFhirCoverageList.Link: TFhirCoverageList;
begin
  result := TFhirCoverageList(inherited Link);
end;

procedure TFhirCoverageList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirCoverageList.SetItemByIndex(index: Integer; value: TFhirCoverage);
begin
  assert(value is TFhirCoverage);
  FhirCoverages[index] := value;
end;

procedure TFhirCoverageList.SetItemN(index: Integer; value: TFhirCoverage);
begin
  assert(value is TFhirCoverage);
  ObjectByIndex[index] := value;
end;

{$ENDIF FHIR_COVERAGE}
{$IFDEF FHIR_COVERAGEELIGIBILITYREQUEST}
{ TFhirCoverageEligibilityRequestSupportingInfo }

constructor TFhirCoverageEligibilityRequestSupportingInfo.Create;
begin
  inherited;
end;

destructor TFhirCoverageEligibilityRequestSupportingInfo.Destroy;
begin
  FSequence.free;
  FInformation.free;
  FAppliesToAll.free;
  inherited;
end;

procedure TFhirCoverageEligibilityRequestSupportingInfo.Assign(oSource : TFslObject);
begin
  inherited;
  sequenceElement := TFhirCoverageEligibilityRequestSupportingInfo(oSource).sequenceElement.Clone;
  information := TFhirCoverageEligibilityRequestSupportingInfo(oSource).information.Clone;
  appliesToAllElement := TFhirCoverageEligibilityRequestSupportingInfo(oSource).appliesToAllElement.Clone;
end;

procedure TFhirCoverageEligibilityRequestSupportingInfo.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'sequence') Then
     list.add(self.link, 'sequence', FSequence.Link);
  if (child_name = 'information') Then
     list.add(self.link, 'information', FInformation.Link);
  if (child_name = 'appliesToAll') Then
     list.add(self.link, 'appliesToAll', FAppliesToAll.Link);
end;

procedure TFhirCoverageEligibilityRequestSupportingInfo.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'sequence', 'positiveInt', false, TFhirPositiveInt, FSequence.Link));
  oList.add(TFHIRProperty.create(self, 'information', 'Reference', false, TFhirReference, FInformation.Link));
  oList.add(TFHIRProperty.create(self, 'appliesToAll', 'boolean', false, TFhirBoolean, FAppliesToAll.Link));
end;

function TFhirCoverageEligibilityRequestSupportingInfo.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'sequence') then
  begin
    SequenceElement := asPositiveInt(propValue);
    result := propValue;
  end
  else if (propName = 'information') then
  begin
    Information := propValue as TFhirReference;
    result := propValue;
  end
  else if (propName = 'appliesToAll') then
  begin
    AppliesToAllElement := asBoolean(propValue);
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirCoverageEligibilityRequestSupportingInfo.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirCoverageEligibilityRequestSupportingInfo.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'sequence') then result := TFhirPositiveInt.create()
  else if (propName = 'information') then result := TFhirReference.create()
  else if (propName = 'appliesToAll') then result := TFhirBoolean.create()
  else result := inherited createPropertyValue(propName);
end;

function TFhirCoverageEligibilityRequestSupportingInfo.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'sequence') then result := 'positiveInt'
  else if (propName = 'information') then result := 'Reference'
  else if (propName = 'appliesToAll') then result := 'boolean'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirCoverageEligibilityRequestSupportingInfo.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'sequence') then SequenceElement := nil
  else if (propName = 'information') then InformationElement := nil
  else if (propName = 'appliesToAll') then AppliesToAllElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirCoverageEligibilityRequestSupportingInfo.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'sequence') then SequenceElement := asPositiveInt(new)
  else if (propName = 'information') then InformationElement := new as TFhirReference
  else if (propName = 'appliesToAll') then AppliesToAllElement := asBoolean(new)
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirCoverageEligibilityRequestSupportingInfo.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirCoverageEligibilityRequestSupportingInfo.fhirType : string;
begin
  result := 'CoverageEligibilityRequest.supportingInfo';
end;

function TFhirCoverageEligibilityRequestSupportingInfo.Link : TFhirCoverageEligibilityRequestSupportingInfo;
begin
  result := TFhirCoverageEligibilityRequestSupportingInfo(inherited Link);
end;

function TFhirCoverageEligibilityRequestSupportingInfo.Clone : TFhirCoverageEligibilityRequestSupportingInfo;
begin
  result := TFhirCoverageEligibilityRequestSupportingInfo(inherited Clone);
end;

function TFhirCoverageEligibilityRequestSupportingInfo.equals(other : TObject) : boolean; 
var
  o : TFhirCoverageEligibilityRequestSupportingInfo;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirCoverageEligibilityRequestSupportingInfo)) then
    result := false
  else
  begin
    o := TFhirCoverageEligibilityRequestSupportingInfo(other);
    result := compareDeep(sequenceElement, o.sequenceElement, true) and compareDeep(informationElement, o.informationElement, true) and 
      compareDeep(appliesToAllElement, o.appliesToAllElement, true);
  end;
end;

function TFhirCoverageEligibilityRequestSupportingInfo.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FSequence) and isEmptyProp(FInformation) and isEmptyProp(FAppliesToAll);
end;

procedure TFhirCoverageEligibilityRequestSupportingInfo.listFieldsInOrder(fields : TStringList);
begin
  inherited listFieldsInOrder(fields);
  fields.add('sequence');
  fields.add('information');
  fields.add('appliesToAll');
end;

function TFhirCoverageEligibilityRequestSupportingInfo.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
end;

procedure TFhirCoverageEligibilityRequestSupportingInfo.SetSequence(value : TFhirPositiveInt);
begin
  FSequence.free;
  FSequence := value;
end;

function TFhirCoverageEligibilityRequestSupportingInfo.GetSequenceST : String;
begin
  if FSequence = nil then
    result := ''
  else
    result := FSequence.value;
end;

procedure TFhirCoverageEligibilityRequestSupportingInfo.SetSequenceST(value : String);
begin
  if value <> '' then
  begin
    if FSequence = nil then
      FSequence := TFhirPositiveInt.create;
    FSequence.value := value
  end
  else if FSequence <> nil then
    FSequence.value := '';
end;

procedure TFhirCoverageEligibilityRequestSupportingInfo.SetInformation(value : TFhirReference);
begin
  FInformation.free;
  FInformation := value;
end;

procedure TFhirCoverageEligibilityRequestSupportingInfo.SetAppliesToAll(value : TFhirBoolean);
begin
  FAppliesToAll.free;
  FAppliesToAll := value;
end;

function TFhirCoverageEligibilityRequestSupportingInfo.GetAppliesToAllST : Boolean;
begin
  if FAppliesToAll = nil then
    result := false
  else
    result := FAppliesToAll.value;
end;

procedure TFhirCoverageEligibilityRequestSupportingInfo.SetAppliesToAllST(value : Boolean);
begin
  if FAppliesToAll = nil then
    FAppliesToAll := TFhirBoolean.create;
  FAppliesToAll.value := value
end;

{ TFhirCoverageEligibilityRequestSupportingInfoListEnumerator }

constructor TFhirCoverageEligibilityRequestSupportingInfoListEnumerator.Create(list : TFhirCoverageEligibilityRequestSupportingInfoList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirCoverageEligibilityRequestSupportingInfoListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirCoverageEligibilityRequestSupportingInfoListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirCoverageEligibilityRequestSupportingInfoListEnumerator.GetCurrent : TFhirCoverageEligibilityRequestSupportingInfo;
begin
  Result := FList[FIndex];
end;

function TFhirCoverageEligibilityRequestSupportingInfoListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirCoverageEligibilityRequestSupportingInfoList }

procedure TFhirCoverageEligibilityRequestSupportingInfoList.AddItem(value: TFhirCoverageEligibilityRequestSupportingInfo);
begin
  assert(value.ClassName = 'TFhirCoverageEligibilityRequestSupportingInfo', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirCoverageEligibilityRequestSupportingInfo');
  add(value);
end;

function TFhirCoverageEligibilityRequestSupportingInfoList.Append: TFhirCoverageEligibilityRequestSupportingInfo;
begin
  result := TFhirCoverageEligibilityRequestSupportingInfo.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirCoverageEligibilityRequestSupportingInfoList.ClearItems;
begin
  Clear;
end;

function TFhirCoverageEligibilityRequestSupportingInfoList.GetEnumerator : TFhirCoverageEligibilityRequestSupportingInfoListEnumerator;
begin
  result := TFhirCoverageEligibilityRequestSupportingInfoListEnumerator.Create(self.link);
end;

function TFhirCoverageEligibilityRequestSupportingInfoList.Clone: TFhirCoverageEligibilityRequestSupportingInfoList;
begin
  result := TFhirCoverageEligibilityRequestSupportingInfoList(inherited Clone);
end;

function TFhirCoverageEligibilityRequestSupportingInfoList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirCoverageEligibilityRequestSupportingInfoList.GetItemN(index: Integer): TFhirCoverageEligibilityRequestSupportingInfo;
begin
  result := TFhirCoverageEligibilityRequestSupportingInfo(ObjectByIndex[index]);
end;

function TFhirCoverageEligibilityRequestSupportingInfoList.ItemClass: TFslObjectClass;
begin
  result := TFhirCoverageEligibilityRequestSupportingInfo;
end;
function TFhirCoverageEligibilityRequestSupportingInfoList.IndexOf(value: TFhirCoverageEligibilityRequestSupportingInfo): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirCoverageEligibilityRequestSupportingInfoList.Insert(index: Integer): TFhirCoverageEligibilityRequestSupportingInfo;
begin
  result := TFhirCoverageEligibilityRequestSupportingInfo.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirCoverageEligibilityRequestSupportingInfoList.InsertItem(index: Integer; value: TFhirCoverageEligibilityRequestSupportingInfo);
begin
  assert(value is TFhirCoverageEligibilityRequestSupportingInfo);
  Inherited Insert(index, value);
end;

function TFhirCoverageEligibilityRequestSupportingInfoList.Item(index: Integer): TFhirCoverageEligibilityRequestSupportingInfo;
begin
  result := TFhirCoverageEligibilityRequestSupportingInfo(ObjectByIndex[index]);
end;

function TFhirCoverageEligibilityRequestSupportingInfoList.Link: TFhirCoverageEligibilityRequestSupportingInfoList;
begin
  result := TFhirCoverageEligibilityRequestSupportingInfoList(inherited Link);
end;

procedure TFhirCoverageEligibilityRequestSupportingInfoList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirCoverageEligibilityRequestSupportingInfoList.SetItemByIndex(index: Integer; value: TFhirCoverageEligibilityRequestSupportingInfo);
begin
  assert(value is TFhirCoverageEligibilityRequestSupportingInfo);
  FhirCoverageEligibilityRequestSupportingInfos[index] := value;
end;

procedure TFhirCoverageEligibilityRequestSupportingInfoList.SetItemN(index: Integer; value: TFhirCoverageEligibilityRequestSupportingInfo);
begin
  assert(value is TFhirCoverageEligibilityRequestSupportingInfo);
  ObjectByIndex[index] := value;
end;

{ TFhirCoverageEligibilityRequestInsurance }

constructor TFhirCoverageEligibilityRequestInsurance.Create;
begin
  inherited;
end;

destructor TFhirCoverageEligibilityRequestInsurance.Destroy;
begin
  FFocal.free;
  FCoverage.free;
  FBusinessArrangement.free;
  inherited;
end;

procedure TFhirCoverageEligibilityRequestInsurance.Assign(oSource : TFslObject);
begin
  inherited;
  focalElement := TFhirCoverageEligibilityRequestInsurance(oSource).focalElement.Clone;
  coverage := TFhirCoverageEligibilityRequestInsurance(oSource).coverage.Clone;
  businessArrangementElement := TFhirCoverageEligibilityRequestInsurance(oSource).businessArrangementElement.Clone;
end;

procedure TFhirCoverageEligibilityRequestInsurance.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'focal') Then
     list.add(self.link, 'focal', FFocal.Link);
  if (child_name = 'coverage') Then
     list.add(self.link, 'coverage', FCoverage.Link);
  if (child_name = 'businessArrangement') Then
     list.add(self.link, 'businessArrangement', FBusinessArrangement.Link);
end;

procedure TFhirCoverageEligibilityRequestInsurance.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'focal', 'boolean', false, TFhirBoolean, FFocal.Link));
  oList.add(TFHIRProperty.create(self, 'coverage', 'Reference', false, TFhirReference, FCoverage.Link));
  oList.add(TFHIRProperty.create(self, 'businessArrangement', 'string', false, TFhirString, FBusinessArrangement.Link));
end;

function TFhirCoverageEligibilityRequestInsurance.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'focal') then
  begin
    FocalElement := asBoolean(propValue);
    result := propValue;
  end
  else if (propName = 'coverage') then
  begin
    Coverage := propValue as TFhirReference;
    result := propValue;
  end
  else if (propName = 'businessArrangement') then
  begin
    BusinessArrangementElement := asString(propValue);
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirCoverageEligibilityRequestInsurance.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirCoverageEligibilityRequestInsurance.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'focal') then result := TFhirBoolean.create()
  else if (propName = 'coverage') then result := TFhirReference.create()
  else if (propName = 'businessArrangement') then result := TFhirString.create()
  else result := inherited createPropertyValue(propName);
end;

function TFhirCoverageEligibilityRequestInsurance.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'focal') then result := 'boolean'
  else if (propName = 'coverage') then result := 'Reference'
  else if (propName = 'businessArrangement') then result := 'string'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirCoverageEligibilityRequestInsurance.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'focal') then FocalElement := nil
  else if (propName = 'coverage') then CoverageElement := nil
  else if (propName = 'businessArrangement') then BusinessArrangementElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirCoverageEligibilityRequestInsurance.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'focal') then FocalElement := asBoolean(new)
  else if (propName = 'coverage') then CoverageElement := new as TFhirReference
  else if (propName = 'businessArrangement') then BusinessArrangementElement := asString(new)
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirCoverageEligibilityRequestInsurance.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirCoverageEligibilityRequestInsurance.fhirType : string;
begin
  result := 'CoverageEligibilityRequest.insurance';
end;

function TFhirCoverageEligibilityRequestInsurance.Link : TFhirCoverageEligibilityRequestInsurance;
begin
  result := TFhirCoverageEligibilityRequestInsurance(inherited Link);
end;

function TFhirCoverageEligibilityRequestInsurance.Clone : TFhirCoverageEligibilityRequestInsurance;
begin
  result := TFhirCoverageEligibilityRequestInsurance(inherited Clone);
end;

function TFhirCoverageEligibilityRequestInsurance.equals(other : TObject) : boolean; 
var
  o : TFhirCoverageEligibilityRequestInsurance;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirCoverageEligibilityRequestInsurance)) then
    result := false
  else
  begin
    o := TFhirCoverageEligibilityRequestInsurance(other);
    result := compareDeep(focalElement, o.focalElement, true) and compareDeep(coverageElement, o.coverageElement, true) and 
      compareDeep(businessArrangementElement, o.businessArrangementElement, true);
  end;
end;

function TFhirCoverageEligibilityRequestInsurance.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FFocal) and isEmptyProp(FCoverage) and isEmptyProp(FBusinessArrangement);
end;

procedure TFhirCoverageEligibilityRequestInsurance.listFieldsInOrder(fields : TStringList);
begin
  inherited listFieldsInOrder(fields);
  fields.add('focal');
  fields.add('coverage');
  fields.add('businessArrangement');
end;

function TFhirCoverageEligibilityRequestInsurance.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
end;

procedure TFhirCoverageEligibilityRequestInsurance.SetFocal(value : TFhirBoolean);
begin
  FFocal.free;
  FFocal := value;
end;

function TFhirCoverageEligibilityRequestInsurance.GetFocalST : Boolean;
begin
  if FFocal = nil then
    result := false
  else
    result := FFocal.value;
end;

procedure TFhirCoverageEligibilityRequestInsurance.SetFocalST(value : Boolean);
begin
  if FFocal = nil then
    FFocal := TFhirBoolean.create;
  FFocal.value := value
end;

procedure TFhirCoverageEligibilityRequestInsurance.SetCoverage(value : TFhirReference);
begin
  FCoverage.free;
  FCoverage := value;
end;

procedure TFhirCoverageEligibilityRequestInsurance.SetBusinessArrangement(value : TFhirString);
begin
  FBusinessArrangement.free;
  FBusinessArrangement := value;
end;

function TFhirCoverageEligibilityRequestInsurance.GetBusinessArrangementST : String;
begin
  if FBusinessArrangement = nil then
    result := ''
  else
    result := FBusinessArrangement.value;
end;

procedure TFhirCoverageEligibilityRequestInsurance.SetBusinessArrangementST(value : String);
begin
  if value <> '' then
  begin
    if FBusinessArrangement = nil then
      FBusinessArrangement := TFhirString.create;
    FBusinessArrangement.value := value
  end
  else if FBusinessArrangement <> nil then
    FBusinessArrangement.value := '';
end;

{ TFhirCoverageEligibilityRequestInsuranceListEnumerator }

constructor TFhirCoverageEligibilityRequestInsuranceListEnumerator.Create(list : TFhirCoverageEligibilityRequestInsuranceList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirCoverageEligibilityRequestInsuranceListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirCoverageEligibilityRequestInsuranceListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirCoverageEligibilityRequestInsuranceListEnumerator.GetCurrent : TFhirCoverageEligibilityRequestInsurance;
begin
  Result := FList[FIndex];
end;

function TFhirCoverageEligibilityRequestInsuranceListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirCoverageEligibilityRequestInsuranceList }

procedure TFhirCoverageEligibilityRequestInsuranceList.AddItem(value: TFhirCoverageEligibilityRequestInsurance);
begin
  assert(value.ClassName = 'TFhirCoverageEligibilityRequestInsurance', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirCoverageEligibilityRequestInsurance');
  add(value);
end;

function TFhirCoverageEligibilityRequestInsuranceList.Append: TFhirCoverageEligibilityRequestInsurance;
begin
  result := TFhirCoverageEligibilityRequestInsurance.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirCoverageEligibilityRequestInsuranceList.ClearItems;
begin
  Clear;
end;

function TFhirCoverageEligibilityRequestInsuranceList.GetEnumerator : TFhirCoverageEligibilityRequestInsuranceListEnumerator;
begin
  result := TFhirCoverageEligibilityRequestInsuranceListEnumerator.Create(self.link);
end;

function TFhirCoverageEligibilityRequestInsuranceList.Clone: TFhirCoverageEligibilityRequestInsuranceList;
begin
  result := TFhirCoverageEligibilityRequestInsuranceList(inherited Clone);
end;

function TFhirCoverageEligibilityRequestInsuranceList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirCoverageEligibilityRequestInsuranceList.GetItemN(index: Integer): TFhirCoverageEligibilityRequestInsurance;
begin
  result := TFhirCoverageEligibilityRequestInsurance(ObjectByIndex[index]);
end;

function TFhirCoverageEligibilityRequestInsuranceList.ItemClass: TFslObjectClass;
begin
  result := TFhirCoverageEligibilityRequestInsurance;
end;
function TFhirCoverageEligibilityRequestInsuranceList.IndexOf(value: TFhirCoverageEligibilityRequestInsurance): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirCoverageEligibilityRequestInsuranceList.Insert(index: Integer): TFhirCoverageEligibilityRequestInsurance;
begin
  result := TFhirCoverageEligibilityRequestInsurance.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirCoverageEligibilityRequestInsuranceList.InsertItem(index: Integer; value: TFhirCoverageEligibilityRequestInsurance);
begin
  assert(value is TFhirCoverageEligibilityRequestInsurance);
  Inherited Insert(index, value);
end;

function TFhirCoverageEligibilityRequestInsuranceList.Item(index: Integer): TFhirCoverageEligibilityRequestInsurance;
begin
  result := TFhirCoverageEligibilityRequestInsurance(ObjectByIndex[index]);
end;

function TFhirCoverageEligibilityRequestInsuranceList.Link: TFhirCoverageEligibilityRequestInsuranceList;
begin
  result := TFhirCoverageEligibilityRequestInsuranceList(inherited Link);
end;

procedure TFhirCoverageEligibilityRequestInsuranceList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirCoverageEligibilityRequestInsuranceList.SetItemByIndex(index: Integer; value: TFhirCoverageEligibilityRequestInsurance);
begin
  assert(value is TFhirCoverageEligibilityRequestInsurance);
  FhirCoverageEligibilityRequestInsurances[index] := value;
end;

procedure TFhirCoverageEligibilityRequestInsuranceList.SetItemN(index: Integer; value: TFhirCoverageEligibilityRequestInsurance);
begin
  assert(value is TFhirCoverageEligibilityRequestInsurance);
  ObjectByIndex[index] := value;
end;

{ TFhirCoverageEligibilityRequestItem }

constructor TFhirCoverageEligibilityRequestItem.Create;
begin
  inherited;
end;

destructor TFhirCoverageEligibilityRequestItem.Destroy;
begin
  FSupportingInfoSequenceList.Free;
  FCategory.free;
  FProductOrService.free;
  FModifierList.Free;
  FProvider.free;
  FQuantity.free;
  FUnitPrice.free;
  FFacility.free;
  FDiagnosisList.Free;
  FDetailList.Free;
  inherited;
end;

procedure TFhirCoverageEligibilityRequestItem.Assign(oSource : TFslObject);
begin
  inherited;
  if (TFhirCoverageEligibilityRequestItem(oSource).FSupportingInfoSequenceList = nil) then
  begin
    FSupportingInfoSequenceList.free;
    FSupportingInfoSequenceList := nil;
  end
  else
  begin
    if FSupportingInfoSequenceList = nil then
      FSupportingInfoSequenceList := TFhirPositiveIntList.Create;
    FSupportingInfoSequenceList.Assign(TFhirCoverageEligibilityRequestItem(oSource).FSupportingInfoSequenceList);
  end;
  category := TFhirCoverageEligibilityRequestItem(oSource).category.Clone;
  productOrService := TFhirCoverageEligibilityRequestItem(oSource).productOrService.Clone;
  if (TFhirCoverageEligibilityRequestItem(oSource).FModifierList = nil) then
  begin
    FModifierList.free;
    FModifierList := nil;
  end
  else
  begin
    if FModifierList = nil then
      FModifierList := TFhirCodeableConceptList.Create;
    FModifierList.Assign(TFhirCoverageEligibilityRequestItem(oSource).FModifierList);
  end;
  provider := TFhirCoverageEligibilityRequestItem(oSource).provider.Clone;
  quantity := TFhirCoverageEligibilityRequestItem(oSource).quantity.Clone;
  unitPrice := TFhirCoverageEligibilityRequestItem(oSource).unitPrice.Clone;
  facility := TFhirCoverageEligibilityRequestItem(oSource).facility.Clone;
  if (TFhirCoverageEligibilityRequestItem(oSource).FDiagnosisList = nil) then
  begin
    FDiagnosisList.free;
    FDiagnosisList := nil;
  end
  else
  begin
    if FDiagnosisList = nil then
      FDiagnosisList := TFhirCoverageEligibilityRequestItemDiagnosisList.Create;
    FDiagnosisList.Assign(TFhirCoverageEligibilityRequestItem(oSource).FDiagnosisList);
  end;
  if (TFhirCoverageEligibilityRequestItem(oSource).FDetailList = nil) then
  begin
    FDetailList.free;
    FDetailList := nil;
  end
  else
  begin
    if FDetailList = nil then
      FDetailList := TFhirReferenceList.Create;
    FDetailList.Assign(TFhirCoverageEligibilityRequestItem(oSource).FDetailList);
  end;
end;

procedure TFhirCoverageEligibilityRequestItem.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'supportingInfoSequence') Then
    list.addAll(self, 'supportingInfoSequence', FSupportingInfoSequenceList);
  if (child_name = 'category') Then
     list.add(self.link, 'category', FCategory.Link);
  if (child_name = 'productOrService') Then
     list.add(self.link, 'productOrService', FProductOrService.Link);
  if (child_name = 'modifier') Then
    list.addAll(self, 'modifier', FModifierList);
  if (child_name = 'provider') Then
     list.add(self.link, 'provider', FProvider.Link);
  if (child_name = 'quantity') Then
     list.add(self.link, 'quantity', FQuantity.Link);
  if (child_name = 'unitPrice') Then
     list.add(self.link, 'unitPrice', FUnitPrice.Link);
  if (child_name = 'facility') Then
     list.add(self.link, 'facility', FFacility.Link);
  if (child_name = 'diagnosis') Then
    list.addAll(self, 'diagnosis', FDiagnosisList);
  if (child_name = 'detail') Then
    list.addAll(self, 'detail', FDetailList);
end;

procedure TFhirCoverageEligibilityRequestItem.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'supportingInfoSequence', 'positiveInt', true, TFhirPositiveInt, FSupportingInfoSequenceList.Link));
  oList.add(TFHIRProperty.create(self, 'category', 'CodeableConcept', false, TFhirCodeableConcept, FCategory.Link));
  oList.add(TFHIRProperty.create(self, 'productOrService', 'CodeableConcept', false, TFhirCodeableConcept, FProductOrService.Link));
  oList.add(TFHIRProperty.create(self, 'modifier', 'CodeableConcept', true, TFhirCodeableConcept, FModifierList.Link));
  oList.add(TFHIRProperty.create(self, 'provider', 'Reference', false, TFhirReference, FProvider.Link));
  oList.add(TFHIRProperty.create(self, 'quantity', 'Quantity', false, TFhirQuantity, FQuantity.Link));
  oList.add(TFHIRProperty.create(self, 'unitPrice', 'Money', false, TFhirMoney, FUnitPrice.Link));
  oList.add(TFHIRProperty.create(self, 'facility', 'Reference', false, TFhirReference, FFacility.Link));
  oList.add(TFHIRProperty.create(self, 'diagnosis', 'BackboneElement', true, TFhirCoverageEligibilityRequestItemDiagnosis, FDiagnosisList.Link));
  oList.add(TFHIRProperty.create(self, 'detail', 'Reference', true, TFhirReference, FDetailList.Link));
end;

function TFhirCoverageEligibilityRequestItem.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'supportingInfoSequence') then
  begin
    SupportingInfoSequenceList.add(asPositiveInt(propValue)){2};     result := propValue;

  end
  else if (propName = 'category') then
  begin
    Category := propValue as TFhirCodeableConcept;
    result := propValue;
  end
  else if (propName = 'productOrService') then
  begin
    ProductOrService := propValue as TFhirCodeableConcept;
    result := propValue;
  end
  else if (propName = 'modifier') then
  begin
    ModifierList.add(propValue as TFhirCodeableConcept);
    result := propValue;
  end
  else if (propName = 'provider') then
  begin
    Provider := propValue as TFhirReference;
    result := propValue;
  end
  else if (propName = 'quantity') then
  begin
    Quantity := propValue as TFhirQuantity;
    result := propValue;
  end
  else if (propName = 'unitPrice') then
  begin
    UnitPrice := propValue as TFhirMoney;
    result := propValue;
  end
  else if (propName = 'facility') then
  begin
    Facility := propValue as TFhirReference;
    result := propValue;
  end
  else if (propName = 'diagnosis') then
  begin
    DiagnosisList.add(propValue as TFhirCoverageEligibilityRequestItemDiagnosis);
    result := propValue;
  end
  else if (propName = 'detail') then
  begin
    DetailList.add(propValue as TFhirReference);
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirCoverageEligibilityRequestItem.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'supportingInfoSequence') then SupportingInfoSequenceList.insertItem(index, asPositiveInt(propValue))
  else if (propName = 'modifier') then ModifierList.insertItem(index, propValue as TFhirCodeableConcept)
  else if (propName = 'diagnosis') then DiagnosisList.insertItem(index, propValue as TFhirCoverageEligibilityRequestItemDiagnosis)
  else if (propName = 'detail') then DetailList.insertItem(index, propValue as TFhirReference)
  else inherited;
end;

function TFhirCoverageEligibilityRequestItem.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'supportingInfoSequence') then result := SupportingInfoSequenceList.new()
  else if (propName = 'category') then result := TFhirCodeableConcept.create()
  else if (propName = 'productOrService') then result := TFhirCodeableConcept.create()
  else if (propName = 'modifier') then result := ModifierList.new()
  else if (propName = 'provider') then result := TFhirReference.create()
  else if (propName = 'quantity') then result := TFhirQuantity.create()
  else if (propName = 'unitPrice') then result := TFhirMoney.create()
  else if (propName = 'facility') then result := TFhirReference.create()
  else if (propName = 'diagnosis') then result := DiagnosisList.new()
  else if (propName = 'detail') then result := DetailList.new()
  else result := inherited createPropertyValue(propName);
end;

function TFhirCoverageEligibilityRequestItem.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'supportingInfoSequence') then result := 'positiveInt'
  else if (propName = 'category') then result := 'CodeableConcept'
  else if (propName = 'productOrService') then result := 'CodeableConcept'
  else if (propName = 'modifier') then result := 'CodeableConcept'
  else if (propName = 'provider') then result := 'Reference'
  else if (propName = 'quantity') then result := 'Quantity'
  else if (propName = 'unitPrice') then result := 'Money'
  else if (propName = 'facility') then result := 'Reference'
  else if (propName = 'diagnosis') then result := 'BackboneElement'
  else if (propName = 'detail') then result := 'Reference'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirCoverageEligibilityRequestItem.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'supportingInfoSequence') then deletePropertyValue('supportingInfoSequence', SupportingInfoSequenceList, value)
  else if (propName = 'category') then CategoryElement := nil
  else if (propName = 'productOrService') then ProductOrServiceElement := nil
  else if (propName = 'modifier') then deletePropertyValue('modifier', ModifierList, value)
  else if (propName = 'provider') then ProviderElement := nil
  else if (propName = 'quantity') then QuantityElement := nil
  else if (propName = 'unitPrice') then UnitPriceElement := nil
  else if (propName = 'facility') then FacilityElement := nil
  else if (propName = 'diagnosis') then deletePropertyValue('diagnosis', DiagnosisList, value)
  else if (propName = 'detail') then deletePropertyValue('detail', DetailList, value)
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirCoverageEligibilityRequestItem.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'supportingInfoSequence') then replacePropertyValue('supportingInfoSequence', SupportingInfoSequenceList, existing, new)
  else if (propName = 'category') then CategoryElement := new as TFhirCodeableConcept
  else if (propName = 'productOrService') then ProductOrServiceElement := new as TFhirCodeableConcept
  else if (propName = 'modifier') then replacePropertyValue('modifier', ModifierList, existing, new)
  else if (propName = 'provider') then ProviderElement := new as TFhirReference
  else if (propName = 'quantity') then QuantityElement := new as TFhirQuantity
  else if (propName = 'unitPrice') then UnitPriceElement := new as TFhirMoney
  else if (propName = 'facility') then FacilityElement := new as TFhirReference
  else if (propName = 'diagnosis') then replacePropertyValue('diagnosis', DiagnosisList, existing, new)
  else if (propName = 'detail') then replacePropertyValue('detail', DetailList, existing, new)
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirCoverageEligibilityRequestItem.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'supportingInfoSequence') then SupportingInfoSequenceList.move(source, destination)
  else if (propName = 'modifier') then ModifierList.move(source, destination)
  else if (propName = 'diagnosis') then DiagnosisList.move(source, destination)
  else if (propName = 'detail') then DetailList.move(source, destination)
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirCoverageEligibilityRequestItem.fhirType : string;
begin
  result := 'CoverageEligibilityRequest.item';
end;

function TFhirCoverageEligibilityRequestItem.Link : TFhirCoverageEligibilityRequestItem;
begin
  result := TFhirCoverageEligibilityRequestItem(inherited Link);
end;

function TFhirCoverageEligibilityRequestItem.Clone : TFhirCoverageEligibilityRequestItem;
begin
  result := TFhirCoverageEligibilityRequestItem(inherited Clone);
end;

function TFhirCoverageEligibilityRequestItem.equals(other : TObject) : boolean; 
var
  o : TFhirCoverageEligibilityRequestItem;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirCoverageEligibilityRequestItem)) then
    result := false
  else
  begin
    o := TFhirCoverageEligibilityRequestItem(other);
    result := compareDeep(supportingInfoSequenceList, o.supportingInfoSequenceList, true) and 
      compareDeep(categoryElement, o.categoryElement, true) and compareDeep(productOrServiceElement, o.productOrServiceElement, true) and 
      compareDeep(modifierList, o.modifierList, true) and compareDeep(providerElement, o.providerElement, true) and 
      compareDeep(quantityElement, o.quantityElement, true) and compareDeep(unitPriceElement, o.unitPriceElement, true) and 
      compareDeep(facilityElement, o.facilityElement, true) and compareDeep(diagnosisList, o.diagnosisList, true) and 
      compareDeep(detailList, o.detailList, true);
  end;
end;

function TFhirCoverageEligibilityRequestItem.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FsupportingInfoSequenceList) and isEmptyProp(FCategory) and isEmptyProp(FProductOrService) and isEmptyProp(FmodifierList) and isEmptyProp(FProvider) and isEmptyProp(FQuantity) and isEmptyProp(FUnitPrice) and isEmptyProp(FFacility) and isEmptyProp(FdiagnosisList) and isEmptyProp(FdetailList);
end;

procedure TFhirCoverageEligibilityRequestItem.listFieldsInOrder(fields : TStringList);
begin
  inherited listFieldsInOrder(fields);
  fields.add('supportingInfoSequence');
  fields.add('category');
  fields.add('productOrService');
  fields.add('modifier');
  fields.add('provider');
  fields.add('quantity');
  fields.add('unitPrice');
  fields.add('facility');
  fields.add('diagnosis');
  fields.add('detail');
end;

function TFhirCoverageEligibilityRequestItem.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FSupportingInfoSequenceList.sizeInBytes(magic));
  inc(result, FModifierList.sizeInBytes(magic));
  inc(result, FDiagnosisList.sizeInBytes(magic));
  inc(result, FDetailList.sizeInBytes(magic));
end;

function TFhirCoverageEligibilityRequestItem.GetSupportingInfoSequenceList : TFhirPositiveIntList;
begin
  if FSupportingInfoSequenceList = nil then
    FSupportingInfoSequenceList := TFhirPositiveIntList.Create;
  result := FSupportingInfoSequenceList;
end;

function TFhirCoverageEligibilityRequestItem.GetHasSupportingInfoSequenceList : boolean;
begin
  result := (FSupportingInfoSequenceList <> nil) and (FSupportingInfoSequenceList.count > 0);
end;

procedure TFhirCoverageEligibilityRequestItem.SetCategory(value : TFhirCodeableConcept);
begin
  FCategory.free;
  FCategory := value;
end;

procedure TFhirCoverageEligibilityRequestItem.SetProductOrService(value : TFhirCodeableConcept);
begin
  FProductOrService.free;
  FProductOrService := value;
end;

function TFhirCoverageEligibilityRequestItem.GetModifierList : TFhirCodeableConceptList;
begin
  if FModifierList = nil then
    FModifierList := TFhirCodeableConceptList.Create;
  result := FModifierList;
end;

function TFhirCoverageEligibilityRequestItem.GetHasModifierList : boolean;
begin
  result := (FModifierList <> nil) and (FModifierList.count > 0);
end;

procedure TFhirCoverageEligibilityRequestItem.SetProvider(value : TFhirReference);
begin
  FProvider.free;
  FProvider := value;
end;

procedure TFhirCoverageEligibilityRequestItem.SetQuantity(value : TFhirQuantity);
begin
  FQuantity.free;
  FQuantity := value;
end;

procedure TFhirCoverageEligibilityRequestItem.SetUnitPrice(value : TFhirMoney);
begin
  FUnitPrice.free;
  FUnitPrice := value;
end;

procedure TFhirCoverageEligibilityRequestItem.SetFacility(value : TFhirReference);
begin
  FFacility.free;
  FFacility := value;
end;

function TFhirCoverageEligibilityRequestItem.GetDiagnosisList : TFhirCoverageEligibilityRequestItemDiagnosisList;
begin
  if FDiagnosisList = nil then
    FDiagnosisList := TFhirCoverageEligibilityRequestItemDiagnosisList.Create;
  result := FDiagnosisList;
end;

function TFhirCoverageEligibilityRequestItem.GetHasDiagnosisList : boolean;
begin
  result := (FDiagnosisList <> nil) and (FDiagnosisList.count > 0);
end;

function TFhirCoverageEligibilityRequestItem.GetDetailList : TFhirReferenceList;
begin
  if FDetailList = nil then
    FDetailList := TFhirReferenceList.Create;
  result := FDetailList;
end;

function TFhirCoverageEligibilityRequestItem.GetHasDetailList : boolean;
begin
  result := (FDetailList <> nil) and (FDetailList.count > 0);
end;

{ TFhirCoverageEligibilityRequestItemListEnumerator }

constructor TFhirCoverageEligibilityRequestItemListEnumerator.Create(list : TFhirCoverageEligibilityRequestItemList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirCoverageEligibilityRequestItemListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirCoverageEligibilityRequestItemListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirCoverageEligibilityRequestItemListEnumerator.GetCurrent : TFhirCoverageEligibilityRequestItem;
begin
  Result := FList[FIndex];
end;

function TFhirCoverageEligibilityRequestItemListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirCoverageEligibilityRequestItemList }

procedure TFhirCoverageEligibilityRequestItemList.AddItem(value: TFhirCoverageEligibilityRequestItem);
begin
  assert(value.ClassName = 'TFhirCoverageEligibilityRequestItem', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirCoverageEligibilityRequestItem');
  add(value);
end;

function TFhirCoverageEligibilityRequestItemList.Append: TFhirCoverageEligibilityRequestItem;
begin
  result := TFhirCoverageEligibilityRequestItem.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirCoverageEligibilityRequestItemList.ClearItems;
begin
  Clear;
end;

function TFhirCoverageEligibilityRequestItemList.GetEnumerator : TFhirCoverageEligibilityRequestItemListEnumerator;
begin
  result := TFhirCoverageEligibilityRequestItemListEnumerator.Create(self.link);
end;

function TFhirCoverageEligibilityRequestItemList.Clone: TFhirCoverageEligibilityRequestItemList;
begin
  result := TFhirCoverageEligibilityRequestItemList(inherited Clone);
end;

function TFhirCoverageEligibilityRequestItemList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirCoverageEligibilityRequestItemList.GetItemN(index: Integer): TFhirCoverageEligibilityRequestItem;
begin
  result := TFhirCoverageEligibilityRequestItem(ObjectByIndex[index]);
end;

function TFhirCoverageEligibilityRequestItemList.ItemClass: TFslObjectClass;
begin
  result := TFhirCoverageEligibilityRequestItem;
end;
function TFhirCoverageEligibilityRequestItemList.IndexOf(value: TFhirCoverageEligibilityRequestItem): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirCoverageEligibilityRequestItemList.Insert(index: Integer): TFhirCoverageEligibilityRequestItem;
begin
  result := TFhirCoverageEligibilityRequestItem.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirCoverageEligibilityRequestItemList.InsertItem(index: Integer; value: TFhirCoverageEligibilityRequestItem);
begin
  assert(value is TFhirCoverageEligibilityRequestItem);
  Inherited Insert(index, value);
end;

function TFhirCoverageEligibilityRequestItemList.Item(index: Integer): TFhirCoverageEligibilityRequestItem;
begin
  result := TFhirCoverageEligibilityRequestItem(ObjectByIndex[index]);
end;

function TFhirCoverageEligibilityRequestItemList.Link: TFhirCoverageEligibilityRequestItemList;
begin
  result := TFhirCoverageEligibilityRequestItemList(inherited Link);
end;

procedure TFhirCoverageEligibilityRequestItemList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirCoverageEligibilityRequestItemList.SetItemByIndex(index: Integer; value: TFhirCoverageEligibilityRequestItem);
begin
  assert(value is TFhirCoverageEligibilityRequestItem);
  FhirCoverageEligibilityRequestItems[index] := value;
end;

procedure TFhirCoverageEligibilityRequestItemList.SetItemN(index: Integer; value: TFhirCoverageEligibilityRequestItem);
begin
  assert(value is TFhirCoverageEligibilityRequestItem);
  ObjectByIndex[index] := value;
end;

{ TFhirCoverageEligibilityRequestItemDiagnosis }

constructor TFhirCoverageEligibilityRequestItemDiagnosis.Create;
begin
  inherited;
end;

destructor TFhirCoverageEligibilityRequestItemDiagnosis.Destroy;
begin
  FDiagnosis.free;
  inherited;
end;

procedure TFhirCoverageEligibilityRequestItemDiagnosis.Assign(oSource : TFslObject);
begin
  inherited;
  diagnosis := TFhirCoverageEligibilityRequestItemDiagnosis(oSource).diagnosis.Clone;
end;

procedure TFhirCoverageEligibilityRequestItemDiagnosis.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'diagnosis[x]') or (child_name = 'diagnosis') Then
     list.add(self.link, 'diagnosis[x]', FDiagnosis.Link);
end;

procedure TFhirCoverageEligibilityRequestItemDiagnosis.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'diagnosis[x]', 'CodeableConcept|Reference', false, TFhirDataType, FDiagnosis.Link));
end;

function TFhirCoverageEligibilityRequestItemDiagnosis.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (isMatchingName(propName, 'diagnosis', ['CodeableConcept', 'Reference'])) then
  begin
    Diagnosis := propValue as TFhirDataType;
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirCoverageEligibilityRequestItemDiagnosis.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirCoverageEligibilityRequestItemDiagnosis.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (isMatchingName(propName, 'diagnosis', ['CodeableConcept', 'Reference'])) then raise EFHIRException.create('Cannot make property Diagnosis')
  else result := inherited createPropertyValue(propName);
end;

function TFhirCoverageEligibilityRequestItemDiagnosis.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'diagnosis[x]') then result := 'CodeableConcept|Reference'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirCoverageEligibilityRequestItemDiagnosis.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (isMatchingName(propName, 'diagnosis', ['CodeableConcept', 'Reference'])) then DiagnosisElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirCoverageEligibilityRequestItemDiagnosis.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (isMatchingName(propName, 'diagnosis', ['CodeableConcept', 'Reference'])) then DiagnosisElement := new as TFhirDataType
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirCoverageEligibilityRequestItemDiagnosis.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirCoverageEligibilityRequestItemDiagnosis.fhirType : string;
begin
  result := 'CoverageEligibilityRequest.item.diagnosis';
end;

function TFhirCoverageEligibilityRequestItemDiagnosis.Link : TFhirCoverageEligibilityRequestItemDiagnosis;
begin
  result := TFhirCoverageEligibilityRequestItemDiagnosis(inherited Link);
end;

function TFhirCoverageEligibilityRequestItemDiagnosis.Clone : TFhirCoverageEligibilityRequestItemDiagnosis;
begin
  result := TFhirCoverageEligibilityRequestItemDiagnosis(inherited Clone);
end;

function TFhirCoverageEligibilityRequestItemDiagnosis.equals(other : TObject) : boolean; 
var
  o : TFhirCoverageEligibilityRequestItemDiagnosis;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirCoverageEligibilityRequestItemDiagnosis)) then
    result := false
  else
  begin
    o := TFhirCoverageEligibilityRequestItemDiagnosis(other);
    result := compareDeep(diagnosisElement, o.diagnosisElement, true);
  end;
end;

function TFhirCoverageEligibilityRequestItemDiagnosis.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FDiagnosis);
end;

procedure TFhirCoverageEligibilityRequestItemDiagnosis.listFieldsInOrder(fields : TStringList);
begin
  inherited listFieldsInOrder(fields);
  fields.add('diagnosis[x]');
end;

function TFhirCoverageEligibilityRequestItemDiagnosis.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
end;

procedure TFhirCoverageEligibilityRequestItemDiagnosis.SetDiagnosis(value : TFhirDataType);
begin
  FDiagnosis.free;
  FDiagnosis := value;
end;

{ TFhirCoverageEligibilityRequestItemDiagnosisListEnumerator }

constructor TFhirCoverageEligibilityRequestItemDiagnosisListEnumerator.Create(list : TFhirCoverageEligibilityRequestItemDiagnosisList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirCoverageEligibilityRequestItemDiagnosisListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirCoverageEligibilityRequestItemDiagnosisListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirCoverageEligibilityRequestItemDiagnosisListEnumerator.GetCurrent : TFhirCoverageEligibilityRequestItemDiagnosis;
begin
  Result := FList[FIndex];
end;

function TFhirCoverageEligibilityRequestItemDiagnosisListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirCoverageEligibilityRequestItemDiagnosisList }

procedure TFhirCoverageEligibilityRequestItemDiagnosisList.AddItem(value: TFhirCoverageEligibilityRequestItemDiagnosis);
begin
  assert(value.ClassName = 'TFhirCoverageEligibilityRequestItemDiagnosis', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirCoverageEligibilityRequestItemDiagnosis');
  add(value);
end;

function TFhirCoverageEligibilityRequestItemDiagnosisList.Append: TFhirCoverageEligibilityRequestItemDiagnosis;
begin
  result := TFhirCoverageEligibilityRequestItemDiagnosis.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirCoverageEligibilityRequestItemDiagnosisList.ClearItems;
begin
  Clear;
end;

function TFhirCoverageEligibilityRequestItemDiagnosisList.GetEnumerator : TFhirCoverageEligibilityRequestItemDiagnosisListEnumerator;
begin
  result := TFhirCoverageEligibilityRequestItemDiagnosisListEnumerator.Create(self.link);
end;

function TFhirCoverageEligibilityRequestItemDiagnosisList.Clone: TFhirCoverageEligibilityRequestItemDiagnosisList;
begin
  result := TFhirCoverageEligibilityRequestItemDiagnosisList(inherited Clone);
end;

function TFhirCoverageEligibilityRequestItemDiagnosisList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirCoverageEligibilityRequestItemDiagnosisList.GetItemN(index: Integer): TFhirCoverageEligibilityRequestItemDiagnosis;
begin
  result := TFhirCoverageEligibilityRequestItemDiagnosis(ObjectByIndex[index]);
end;

function TFhirCoverageEligibilityRequestItemDiagnosisList.ItemClass: TFslObjectClass;
begin
  result := TFhirCoverageEligibilityRequestItemDiagnosis;
end;
function TFhirCoverageEligibilityRequestItemDiagnosisList.IndexOf(value: TFhirCoverageEligibilityRequestItemDiagnosis): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirCoverageEligibilityRequestItemDiagnosisList.Insert(index: Integer): TFhirCoverageEligibilityRequestItemDiagnosis;
begin
  result := TFhirCoverageEligibilityRequestItemDiagnosis.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirCoverageEligibilityRequestItemDiagnosisList.InsertItem(index: Integer; value: TFhirCoverageEligibilityRequestItemDiagnosis);
begin
  assert(value is TFhirCoverageEligibilityRequestItemDiagnosis);
  Inherited Insert(index, value);
end;

function TFhirCoverageEligibilityRequestItemDiagnosisList.Item(index: Integer): TFhirCoverageEligibilityRequestItemDiagnosis;
begin
  result := TFhirCoverageEligibilityRequestItemDiagnosis(ObjectByIndex[index]);
end;

function TFhirCoverageEligibilityRequestItemDiagnosisList.Link: TFhirCoverageEligibilityRequestItemDiagnosisList;
begin
  result := TFhirCoverageEligibilityRequestItemDiagnosisList(inherited Link);
end;

procedure TFhirCoverageEligibilityRequestItemDiagnosisList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirCoverageEligibilityRequestItemDiagnosisList.SetItemByIndex(index: Integer; value: TFhirCoverageEligibilityRequestItemDiagnosis);
begin
  assert(value is TFhirCoverageEligibilityRequestItemDiagnosis);
  FhirCoverageEligibilityRequestItemDiagnoses[index] := value;
end;

procedure TFhirCoverageEligibilityRequestItemDiagnosisList.SetItemN(index: Integer; value: TFhirCoverageEligibilityRequestItemDiagnosis);
begin
  assert(value is TFhirCoverageEligibilityRequestItemDiagnosis);
  ObjectByIndex[index] := value;
end;

{ TFhirCoverageEligibilityRequest }

constructor TFhirCoverageEligibilityRequest.Create;
begin
  inherited;
end;

destructor TFhirCoverageEligibilityRequest.Destroy;
begin
  FIdentifierList.Free;
  FStatus.free;
  FPriority.free;
  FPurpose.Free;
  FPatient.free;
  FServiced.free;
  FCreated.free;
  FEnterer.free;
  FProvider.free;
  FInsurer.free;
  FFacility.free;
  FSupportingInfoList.Free;
  FInsuranceList.Free;
  FItemList.Free;
  inherited;
end;

procedure TFhirCoverageEligibilityRequest.Assign(oSource : TFslObject);
begin
  inherited;
  if (TFhirCoverageEligibilityRequest(oSource).FIdentifierList = nil) then
  begin
    FIdentifierList.free;
    FIdentifierList := nil;
  end
  else
  begin
    if FIdentifierList = nil then
      FIdentifierList := TFhirIdentifierList.Create;
    FIdentifierList.Assign(TFhirCoverageEligibilityRequest(oSource).FIdentifierList);
  end;
  statusElement := TFhirCoverageEligibilityRequest(oSource).statusElement.Clone;
  priority := TFhirCoverageEligibilityRequest(oSource).priority.Clone;
  if (TFhirCoverageEligibilityRequest(oSource).FPurpose = nil) then
  begin
    FPurpose.free;
    FPurpose := nil;
  end
  else
  begin
    FPurpose := TFhirEnumList.Create(SYSTEMS_TFhirEligibilityRequestPurposeEnum, CODES_TFhirEligibilityRequestPurposeEnum);
    FPurpose.Assign(TFhirCoverageEligibilityRequest(oSource).FPurpose);
  end;
  patient := TFhirCoverageEligibilityRequest(oSource).patient.Clone;
  serviced := TFhirCoverageEligibilityRequest(oSource).serviced.Clone;
  createdElement := TFhirCoverageEligibilityRequest(oSource).createdElement.Clone;
  enterer := TFhirCoverageEligibilityRequest(oSource).enterer.Clone;
  provider := TFhirCoverageEligibilityRequest(oSource).provider.Clone;
  insurer := TFhirCoverageEligibilityRequest(oSource).insurer.Clone;
  facility := TFhirCoverageEligibilityRequest(oSource).facility.Clone;
  if (TFhirCoverageEligibilityRequest(oSource).FSupportingInfoList = nil) then
  begin
    FSupportingInfoList.free;
    FSupportingInfoList := nil;
  end
  else
  begin
    if FSupportingInfoList = nil then
      FSupportingInfoList := TFhirCoverageEligibilityRequestSupportingInfoList.Create;
    FSupportingInfoList.Assign(TFhirCoverageEligibilityRequest(oSource).FSupportingInfoList);
  end;
  if (TFhirCoverageEligibilityRequest(oSource).FInsuranceList = nil) then
  begin
    FInsuranceList.free;
    FInsuranceList := nil;
  end
  else
  begin
    if FInsuranceList = nil then
      FInsuranceList := TFhirCoverageEligibilityRequestInsuranceList.Create;
    FInsuranceList.Assign(TFhirCoverageEligibilityRequest(oSource).FInsuranceList);
  end;
  if (TFhirCoverageEligibilityRequest(oSource).FItemList = nil) then
  begin
    FItemList.free;
    FItemList := nil;
  end
  else
  begin
    if FItemList = nil then
      FItemList := TFhirCoverageEligibilityRequestItemList.Create;
    FItemList.Assign(TFhirCoverageEligibilityRequest(oSource).FItemList);
  end;
end;

function TFhirCoverageEligibilityRequest.GetResourceType : TFhirResourceType;
begin
  result := frtCoverageEligibilityRequest;
end;

procedure TFhirCoverageEligibilityRequest.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'identifier') Then
    list.addAll(self, 'identifier', FIdentifierList);
  if (child_name = 'status') Then
     list.add(self.link, 'status', FStatus.Link);
  if (child_name = 'priority') Then
     list.add(self.link, 'priority', FPriority.Link);
  if (child_name = 'purpose') Then
     list.addAll(self, 'purpose', FPurpose);
  if (child_name = 'patient') Then
     list.add(self.link, 'patient', FPatient.Link);
  if (child_name = 'serviced[x]') or (child_name = 'serviced') Then
     list.add(self.link, 'serviced[x]', FServiced.Link);
  if (child_name = 'created') Then
     list.add(self.link, 'created', FCreated.Link);
  if (child_name = 'enterer') Then
     list.add(self.link, 'enterer', FEnterer.Link);
  if (child_name = 'provider') Then
     list.add(self.link, 'provider', FProvider.Link);
  if (child_name = 'insurer') Then
     list.add(self.link, 'insurer', FInsurer.Link);
  if (child_name = 'facility') Then
     list.add(self.link, 'facility', FFacility.Link);
  if (child_name = 'supportingInfo') Then
    list.addAll(self, 'supportingInfo', FSupportingInfoList);
  if (child_name = 'insurance') Then
    list.addAll(self, 'insurance', FInsuranceList);
  if (child_name = 'item') Then
    list.addAll(self, 'item', FItemList);
end;

procedure TFhirCoverageEligibilityRequest.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'identifier', 'Identifier', true, TFhirIdentifier, FIdentifierList.Link));
  oList.add(TFHIRProperty.create(self, 'status', 'code', false, TFhirEnum, FStatus.Link));
  oList.add(TFHIRProperty.create(self, 'priority', 'CodeableConcept', false, TFhirCodeableConcept, FPriority.Link));
  oList.add(TFHIRProperty.create(self, 'purpose', 'code', true, TFhirEnum, FPurpose.Link));
  oList.add(TFHIRProperty.create(self, 'patient', 'Reference', false, TFhirReference, FPatient.Link));
  oList.add(TFHIRProperty.create(self, 'serviced[x]', 'date|Period', false, TFhirDataType, FServiced.Link));
  oList.add(TFHIRProperty.create(self, 'created', 'dateTime', false, TFhirDateTime, FCreated.Link));
  oList.add(TFHIRProperty.create(self, 'enterer', 'Reference', false, TFhirReference, FEnterer.Link));
  oList.add(TFHIRProperty.create(self, 'provider', 'Reference', false, TFhirReference, FProvider.Link));
  oList.add(TFHIRProperty.create(self, 'insurer', 'Reference', false, TFhirReference, FInsurer.Link));
  oList.add(TFHIRProperty.create(self, 'facility', 'Reference', false, TFhirReference, FFacility.Link));
  oList.add(TFHIRProperty.create(self, 'supportingInfo', 'BackboneElement', true, TFhirCoverageEligibilityRequestSupportingInfo, FSupportingInfoList.Link));
  oList.add(TFHIRProperty.create(self, 'insurance', 'BackboneElement', true, TFhirCoverageEligibilityRequestInsurance, FInsuranceList.Link));
  oList.add(TFHIRProperty.create(self, 'item', 'BackboneElement', true, TFhirCoverageEligibilityRequestItem, FItemList.Link));
end;

function TFhirCoverageEligibilityRequest.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'identifier') then
  begin
    IdentifierList.add(propValue as TFhirIdentifier);
    result := propValue;
  end
  else if (propName = 'status') then
  begin
    StatusElement := asEnum(SYSTEMS_TFhirFinancialResourceStatusCodesEnum, CODES_TFhirFinancialResourceStatusCodesEnum, propValue);
    result := propValue;
  end
  else if (propName = 'priority') then
  begin
    Priority := propValue as TFhirCodeableConcept;
    result := propValue;
  end
  else if (propName = 'purpose') then
  begin
    PurposeList.add(asEnum(SYSTEMS_TFhirEligibilityRequestPurposeEnum, CODES_TFhirEligibilityRequestPurposeEnum, propValue));
    result := propValue;
  end
  else if (propName = 'patient') then
  begin
    Patient := propValue as TFhirReference;
    result := propValue;
  end
  else if (isMatchingName(propName, 'serviced', ['Date', 'Period'])) then
  begin
    Serviced := propValue as TFhirDataType;
    result := propValue;
  end
  else if (propName = 'created') then
  begin
    CreatedElement := asDateTime(propValue);
    result := propValue;
  end
  else if (propName = 'enterer') then
  begin
    Enterer := propValue as TFhirReference;
    result := propValue;
  end
  else if (propName = 'provider') then
  begin
    Provider := propValue as TFhirReference;
    result := propValue;
  end
  else if (propName = 'insurer') then
  begin
    Insurer := propValue as TFhirReference;
    result := propValue;
  end
  else if (propName = 'facility') then
  begin
    Facility := propValue as TFhirReference;
    result := propValue;
  end
  else if (propName = 'supportingInfo') then
  begin
    SupportingInfoList.add(propValue as TFhirCoverageEligibilityRequestSupportingInfo);
    result := propValue;
  end
  else if (propName = 'insurance') then
  begin
    InsuranceList.add(propValue as TFhirCoverageEligibilityRequestInsurance);
    result := propValue;
  end
  else if (propName = 'item') then
  begin
    ItemList.add(propValue as TFhirCoverageEligibilityRequestItem);
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirCoverageEligibilityRequest.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'identifier') then IdentifierList.insertItem(index, propValue as TFhirIdentifier)
  else if (propName = 'purpose') then FPurpose.insertItem(index, asEnum(SYSTEMS_TFhirEligibilityRequestPurposeEnum, CODES_TFhirEligibilityRequestPurposeEnum, propValue))
  else if (propName = 'supportingInfo') then SupportingInfoList.insertItem(index, propValue as TFhirCoverageEligibilityRequestSupportingInfo)
  else if (propName = 'insurance') then InsuranceList.insertItem(index, propValue as TFhirCoverageEligibilityRequestInsurance)
  else if (propName = 'item') then ItemList.insertItem(index, propValue as TFhirCoverageEligibilityRequestItem)
  else inherited;
end;

function TFhirCoverageEligibilityRequest.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'identifier') then result := IdentifierList.new()
  else if (propName = 'status') then result := TFhirEnum.create(SYSTEMS_TFhirFinancialResourceStatusCodesEnum[FinancialResourceStatusCodesNull], CODES_TFhirFinancialResourceStatusCodesEnum[FinancialResourceStatusCodesNull]) 
  else if (propName = 'priority') then result := TFhirCodeableConcept.create()
  else if (propName = 'patient') then result := TFhirReference.create()
  else if (isMatchingName(propName, 'serviced', ['Date', 'Period'])) then raise EFHIRException.create('Cannot make property Serviced')
  else if (propName = 'created') then result := TFhirDateTime.create()
  else if (propName = 'enterer') then result := TFhirReference.create()
  else if (propName = 'provider') then result := TFhirReference.create()
  else if (propName = 'insurer') then result := TFhirReference.create()
  else if (propName = 'facility') then result := TFhirReference.create()
  else if (propName = 'supportingInfo') then result := SupportingInfoList.new()
  else if (propName = 'insurance') then result := InsuranceList.new()
  else if (propName = 'item') then result := ItemList.new()
  else result := inherited createPropertyValue(propName);
end;

function TFhirCoverageEligibilityRequest.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'identifier') then result := 'Identifier'
  else if (propName = 'status') then result := 'code'
  else if (propName = 'priority') then result := 'CodeableConcept'
  else if (propName = 'purpose') then result := 'code'
  else if (propName = 'patient') then result := 'Reference'
  else if (propName = 'serviced[x]') then result := 'date|Period'
  else if (propName = 'created') then result := 'dateTime'
  else if (propName = 'enterer') then result := 'Reference'
  else if (propName = 'provider') then result := 'Reference'
  else if (propName = 'insurer') then result := 'Reference'
  else if (propName = 'facility') then result := 'Reference'
  else if (propName = 'supportingInfo') then result := 'BackboneElement'
  else if (propName = 'insurance') then result := 'BackboneElement'
  else if (propName = 'item') then result := 'BackboneElement'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirCoverageEligibilityRequest.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'identifier') then deletePropertyValue('identifier', IdentifierList, value)
  else if (propName = 'status') then StatusElement := nil
  else if (propName = 'priority') then PriorityElement := nil
  else if (propName = 'patient') then PatientElement := nil
  else if (isMatchingName(propName, 'serviced', ['Date', 'Period'])) then ServicedElement := nil
  else if (propName = 'created') then CreatedElement := nil
  else if (propName = 'enterer') then EntererElement := nil
  else if (propName = 'provider') then ProviderElement := nil
  else if (propName = 'insurer') then InsurerElement := nil
  else if (propName = 'facility') then FacilityElement := nil
  else if (propName = 'supportingInfo') then deletePropertyValue('supportingInfo', SupportingInfoList, value)
  else if (propName = 'insurance') then deletePropertyValue('insurance', InsuranceList, value)
  else if (propName = 'item') then deletePropertyValue('item', ItemList, value)
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirCoverageEligibilityRequest.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'identifier') then replacePropertyValue('identifier', IdentifierList, existing, new)
  else if (propName = 'status') then StatusElement := asEnum(SYSTEMS_TFhirFinancialResourceStatusCodesEnum, CODES_TFhirFinancialResourceStatusCodesEnum, new)
  else if (propName = 'priority') then PriorityElement := new as TFhirCodeableConcept
  else if (propName = 'patient') then PatientElement := new as TFhirReference
  else if (isMatchingName(propName, 'serviced', ['Date', 'Period'])) then ServicedElement := new as TFhirDataType
  else if (propName = 'created') then CreatedElement := asDateTime(new)
  else if (propName = 'enterer') then EntererElement := new as TFhirReference
  else if (propName = 'provider') then ProviderElement := new as TFhirReference
  else if (propName = 'insurer') then InsurerElement := new as TFhirReference
  else if (propName = 'facility') then FacilityElement := new as TFhirReference
  else if (propName = 'supportingInfo') then replacePropertyValue('supportingInfo', SupportingInfoList, existing, new)
  else if (propName = 'insurance') then replacePropertyValue('insurance', InsuranceList, existing, new)
  else if (propName = 'item') then replacePropertyValue('item', ItemList, existing, new)
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirCoverageEligibilityRequest.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'identifier') then IdentifierList.move(source, destination)
  else if (propName = 'purpose') then FPurpose.move(source, destination)
  else if (propName = 'supportingInfo') then SupportingInfoList.move(source, destination)
  else if (propName = 'insurance') then InsuranceList.move(source, destination)
  else if (propName = 'item') then ItemList.move(source, destination)
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirCoverageEligibilityRequest.fhirType : string;
begin
  result := 'CoverageEligibilityRequest';
end;

function TFhirCoverageEligibilityRequest.Link : TFhirCoverageEligibilityRequest;
begin
  result := TFhirCoverageEligibilityRequest(inherited Link);
end;

function TFhirCoverageEligibilityRequest.Clone : TFhirCoverageEligibilityRequest;
begin
  result := TFhirCoverageEligibilityRequest(inherited Clone);
end;

function TFhirCoverageEligibilityRequest.equals(other : TObject) : boolean; 
var
  o : TFhirCoverageEligibilityRequest;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirCoverageEligibilityRequest)) then
    result := false
  else
  begin
    o := TFhirCoverageEligibilityRequest(other);
    result := compareDeep(identifierList, o.identifierList, true) and compareDeep(statusElement, o.statusElement, true) and 
      compareDeep(priorityElement, o.priorityElement, true) and compareDeep(purposeList, o.purposeList, true) and 
      compareDeep(patientElement, o.patientElement, true) and compareDeep(servicedElement, o.servicedElement, true) and 
      compareDeep(createdElement, o.createdElement, true) and compareDeep(entererElement, o.entererElement, true) and 
      compareDeep(providerElement, o.providerElement, true) and compareDeep(insurerElement, o.insurerElement, true) and 
      compareDeep(facilityElement, o.facilityElement, true) and compareDeep(supportingInfoList, o.supportingInfoList, true) and 
      compareDeep(insuranceList, o.insuranceList, true) and compareDeep(itemList, o.itemList, true);
  end;
end;

function TFhirCoverageEligibilityRequest.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FidentifierList) and isEmptyProp(FStatus) and isEmptyProp(FPriority) and isEmptyProp(FPurpose) and isEmptyProp(FPatient) and isEmptyProp(FServiced) and isEmptyProp(FCreated) and isEmptyProp(FEnterer) and isEmptyProp(FProvider) and isEmptyProp(FInsurer) and isEmptyProp(FFacility) and isEmptyProp(FsupportingInfoList) and isEmptyProp(FinsuranceList) and isEmptyProp(FitemList);
end;

procedure TFhirCoverageEligibilityRequest.listFieldsInOrder(fields : TStringList);
begin
  inherited listFieldsInOrder(fields);
  fields.add('identifier');
  fields.add('status');
  fields.add('priority');
  fields.add('purpose');
  fields.add('patient');
  fields.add('serviced[x]');
  fields.add('created');
  fields.add('enterer');
  fields.add('provider');
  fields.add('insurer');
  fields.add('facility');
  fields.add('supportingInfo');
  fields.add('insurance');
  fields.add('item');
end;

function TFhirCoverageEligibilityRequest.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FIdentifierList.sizeInBytes(magic));
  inc(result, FPurpose.sizeInBytes(magic));
  inc(result, FSupportingInfoList.sizeInBytes(magic));
  inc(result, FInsuranceList.sizeInBytes(magic));
  inc(result, FItemList.sizeInBytes(magic));
end;

function TFhirCoverageEligibilityRequest.GetIdentifierList : TFhirIdentifierList;
begin
  if FIdentifierList = nil then
    FIdentifierList := TFhirIdentifierList.Create;
  result := FIdentifierList;
end;

function TFhirCoverageEligibilityRequest.GetHasIdentifierList : boolean;
begin
  result := (FIdentifierList <> nil) and (FIdentifierList.count > 0);
end;

procedure TFhirCoverageEligibilityRequest.SetStatus(value : TFhirEnum);
begin
  FStatus.free;
  FStatus := value;
end;

function TFhirCoverageEligibilityRequest.GetStatusST : TFhirFinancialResourceStatusCodesEnum;
begin
  if FStatus = nil then
    result := TFhirFinancialResourceStatusCodesEnum(0)
  else
    result := TFhirFinancialResourceStatusCodesEnum(StringArrayIndexOfSensitive(CODES_TFhirFinancialResourceStatusCodesEnum, FStatus.value));
end;

procedure TFhirCoverageEligibilityRequest.SetStatusST(value : TFhirFinancialResourceStatusCodesEnum);
begin
  if ord(value) = 0 then
    StatusElement := nil
  else
    StatusElement := TFhirEnum.create(SYSTEMS_TFhirFinancialResourceStatusCodesEnum[value], CODES_TFhirFinancialResourceStatusCodesEnum[value]);
end;

procedure TFhirCoverageEligibilityRequest.SetPriority(value : TFhirCodeableConcept);
begin
  FPriority.free;
  FPriority := value;
end;

function TFhirCoverageEligibilityRequest.GetPurpose : TFhirEnumList;
begin
  if FPurpose = nil then
    FPurpose := TFhirEnumList.Create(SYSTEMS_TFhirEligibilityRequestPurposeEnum, CODES_TFhirEligibilityRequestPurposeEnum);
  result := FPurpose;
end;

function TFhirCoverageEligibilityRequest.GetHasPurpose : boolean;
begin
  result := (FPurpose <> nil) and (FPurpose.count > 0);
end;

function TFhirCoverageEligibilityRequest.GetPurposeST : TFhirEligibilityRequestPurposeEnumList;
  var i : integer;
begin
  result := [];
  if Fpurpose <> nil then
    for i := 0 to Fpurpose.count - 1 do
      result := result + [TFhirEligibilityRequestPurposeEnum(StringArrayIndexOfSensitive(CODES_TFhirEligibilityRequestPurposeEnum, Fpurpose[i].value))];
end;

procedure TFhirCoverageEligibilityRequest.SetPurposeST(value : TFhirEligibilityRequestPurposeEnumList);
var a : TFhirEligibilityRequestPurposeEnum;
begin
  if Fpurpose = nil then
    Fpurpose := TFhirEnumList.create(SYSTEMS_TFhirEligibilityRequestPurposeEnum, CODES_TFhirEligibilityRequestPurposeEnum);
  Fpurpose.clear;
  for a := low(TFhirEligibilityRequestPurposeEnum) to high(TFhirEligibilityRequestPurposeEnum) do
    if a in value then
      begin
         if Fpurpose = nil then
           Fpurpose := TFhirEnumList.create(SYSTEMS_TFhirEligibilityRequestPurposeEnum, CODES_TFhirEligibilityRequestPurposeEnum);
         Fpurpose.add(TFhirEnum.create(SYSTEMS_TFhirEligibilityRequestPurposeEnum[a], CODES_TFhirEligibilityRequestPurposeEnum[a]));
      end;
end;

procedure TFhirCoverageEligibilityRequest.SetPatient(value : TFhirReference);
begin
  FPatient.free;
  FPatient := value;
end;

procedure TFhirCoverageEligibilityRequest.SetServiced(value : TFhirDataType);
begin
  FServiced.free;
  FServiced := value;
end;

procedure TFhirCoverageEligibilityRequest.SetCreated(value : TFhirDateTime);
begin
  FCreated.free;
  FCreated := value;
end;

function TFhirCoverageEligibilityRequest.GetCreatedST : TFslDateTime;
begin
  if FCreated = nil then
    result := TFslDateTime.makeNull
  else
    result := FCreated.value;
end;

procedure TFhirCoverageEligibilityRequest.SetCreatedST(value : TFslDateTime);
begin
  if FCreated = nil then
    FCreated := TFhirDateTime.create;
  FCreated.value := value
end;

procedure TFhirCoverageEligibilityRequest.SetEnterer(value : TFhirReference);
begin
  FEnterer.free;
  FEnterer := value;
end;

procedure TFhirCoverageEligibilityRequest.SetProvider(value : TFhirReference);
begin
  FProvider.free;
  FProvider := value;
end;

procedure TFhirCoverageEligibilityRequest.SetInsurer(value : TFhirReference);
begin
  FInsurer.free;
  FInsurer := value;
end;

procedure TFhirCoverageEligibilityRequest.SetFacility(value : TFhirReference);
begin
  FFacility.free;
  FFacility := value;
end;

function TFhirCoverageEligibilityRequest.GetSupportingInfoList : TFhirCoverageEligibilityRequestSupportingInfoList;
begin
  if FSupportingInfoList = nil then
    FSupportingInfoList := TFhirCoverageEligibilityRequestSupportingInfoList.Create;
  result := FSupportingInfoList;
end;

function TFhirCoverageEligibilityRequest.GetHasSupportingInfoList : boolean;
begin
  result := (FSupportingInfoList <> nil) and (FSupportingInfoList.count > 0);
end;

function TFhirCoverageEligibilityRequest.GetInsuranceList : TFhirCoverageEligibilityRequestInsuranceList;
begin
  if FInsuranceList = nil then
    FInsuranceList := TFhirCoverageEligibilityRequestInsuranceList.Create;
  result := FInsuranceList;
end;

function TFhirCoverageEligibilityRequest.GetHasInsuranceList : boolean;
begin
  result := (FInsuranceList <> nil) and (FInsuranceList.count > 0);
end;

function TFhirCoverageEligibilityRequest.GetItemList : TFhirCoverageEligibilityRequestItemList;
begin
  if FItemList = nil then
    FItemList := TFhirCoverageEligibilityRequestItemList.Create;
  result := FItemList;
end;

function TFhirCoverageEligibilityRequest.GetHasItemList : boolean;
begin
  result := (FItemList <> nil) and (FItemList.count > 0);
end;

{ TFhirCoverageEligibilityRequestListEnumerator }

constructor TFhirCoverageEligibilityRequestListEnumerator.Create(list : TFhirCoverageEligibilityRequestList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirCoverageEligibilityRequestListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirCoverageEligibilityRequestListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirCoverageEligibilityRequestListEnumerator.GetCurrent : TFhirCoverageEligibilityRequest;
begin
  Result := FList[FIndex];
end;

function TFhirCoverageEligibilityRequestListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirCoverageEligibilityRequestList }

procedure TFhirCoverageEligibilityRequestList.AddItem(value: TFhirCoverageEligibilityRequest);
begin
  assert(value.ClassName = 'TFhirCoverageEligibilityRequest', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirCoverageEligibilityRequest');
  add(value);
end;

function TFhirCoverageEligibilityRequestList.Append: TFhirCoverageEligibilityRequest;
begin
  result := TFhirCoverageEligibilityRequest.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirCoverageEligibilityRequestList.ClearItems;
begin
  Clear;
end;

function TFhirCoverageEligibilityRequestList.GetEnumerator : TFhirCoverageEligibilityRequestListEnumerator;
begin
  result := TFhirCoverageEligibilityRequestListEnumerator.Create(self.link);
end;

function TFhirCoverageEligibilityRequestList.Clone: TFhirCoverageEligibilityRequestList;
begin
  result := TFhirCoverageEligibilityRequestList(inherited Clone);
end;

function TFhirCoverageEligibilityRequestList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirCoverageEligibilityRequestList.GetItemN(index: Integer): TFhirCoverageEligibilityRequest;
begin
  result := TFhirCoverageEligibilityRequest(ObjectByIndex[index]);
end;

function TFhirCoverageEligibilityRequestList.ItemClass: TFslObjectClass;
begin
  result := TFhirCoverageEligibilityRequest;
end;
function TFhirCoverageEligibilityRequestList.IndexOf(value: TFhirCoverageEligibilityRequest): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirCoverageEligibilityRequestList.Insert(index: Integer): TFhirCoverageEligibilityRequest;
begin
  result := TFhirCoverageEligibilityRequest.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirCoverageEligibilityRequestList.InsertItem(index: Integer; value: TFhirCoverageEligibilityRequest);
begin
  assert(value is TFhirCoverageEligibilityRequest);
  Inherited Insert(index, value);
end;

function TFhirCoverageEligibilityRequestList.Item(index: Integer): TFhirCoverageEligibilityRequest;
begin
  result := TFhirCoverageEligibilityRequest(ObjectByIndex[index]);
end;

function TFhirCoverageEligibilityRequestList.Link: TFhirCoverageEligibilityRequestList;
begin
  result := TFhirCoverageEligibilityRequestList(inherited Link);
end;

procedure TFhirCoverageEligibilityRequestList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirCoverageEligibilityRequestList.SetItemByIndex(index: Integer; value: TFhirCoverageEligibilityRequest);
begin
  assert(value is TFhirCoverageEligibilityRequest);
  FhirCoverageEligibilityRequests[index] := value;
end;

procedure TFhirCoverageEligibilityRequestList.SetItemN(index: Integer; value: TFhirCoverageEligibilityRequest);
begin
  assert(value is TFhirCoverageEligibilityRequest);
  ObjectByIndex[index] := value;
end;

{$ENDIF FHIR_COVERAGEELIGIBILITYREQUEST}
{$IFDEF FHIR_COVERAGEELIGIBILITYRESPONSE}
{ TFhirCoverageEligibilityResponseInsurance }

constructor TFhirCoverageEligibilityResponseInsurance.Create;
begin
  inherited;
end;

destructor TFhirCoverageEligibilityResponseInsurance.Destroy;
begin
  FCoverage.free;
  FInforce.free;
  FBenefitPeriod.free;
  FItemList.Free;
  inherited;
end;

procedure TFhirCoverageEligibilityResponseInsurance.Assign(oSource : TFslObject);
begin
  inherited;
  coverage := TFhirCoverageEligibilityResponseInsurance(oSource).coverage.Clone;
  inforceElement := TFhirCoverageEligibilityResponseInsurance(oSource).inforceElement.Clone;
  benefitPeriod := TFhirCoverageEligibilityResponseInsurance(oSource).benefitPeriod.Clone;
  if (TFhirCoverageEligibilityResponseInsurance(oSource).FItemList = nil) then
  begin
    FItemList.free;
    FItemList := nil;
  end
  else
  begin
    if FItemList = nil then
      FItemList := TFhirCoverageEligibilityResponseInsuranceItemList.Create;
    FItemList.Assign(TFhirCoverageEligibilityResponseInsurance(oSource).FItemList);
  end;
end;

procedure TFhirCoverageEligibilityResponseInsurance.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'coverage') Then
     list.add(self.link, 'coverage', FCoverage.Link);
  if (child_name = 'inforce') Then
     list.add(self.link, 'inforce', FInforce.Link);
  if (child_name = 'benefitPeriod') Then
     list.add(self.link, 'benefitPeriod', FBenefitPeriod.Link);
  if (child_name = 'item') Then
    list.addAll(self, 'item', FItemList);
end;

procedure TFhirCoverageEligibilityResponseInsurance.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'coverage', 'Reference', false, TFhirReference, FCoverage.Link));
  oList.add(TFHIRProperty.create(self, 'inforce', 'boolean', false, TFhirBoolean, FInforce.Link));
  oList.add(TFHIRProperty.create(self, 'benefitPeriod', 'Period', false, TFhirPeriod, FBenefitPeriod.Link));
  oList.add(TFHIRProperty.create(self, 'item', 'BackboneElement', true, TFhirCoverageEligibilityResponseInsuranceItem, FItemList.Link));
end;

function TFhirCoverageEligibilityResponseInsurance.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'coverage') then
  begin
    Coverage := propValue as TFhirReference;
    result := propValue;
  end
  else if (propName = 'inforce') then
  begin
    InforceElement := asBoolean(propValue);
    result := propValue;
  end
  else if (propName = 'benefitPeriod') then
  begin
    BenefitPeriod := propValue as TFhirPeriod;
    result := propValue;
  end
  else if (propName = 'item') then
  begin
    ItemList.add(propValue as TFhirCoverageEligibilityResponseInsuranceItem);
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirCoverageEligibilityResponseInsurance.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'item') then ItemList.insertItem(index, propValue as TFhirCoverageEligibilityResponseInsuranceItem)
  else inherited;
end;

function TFhirCoverageEligibilityResponseInsurance.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'coverage') then result := TFhirReference.create()
  else if (propName = 'inforce') then result := TFhirBoolean.create()
  else if (propName = 'benefitPeriod') then result := TFhirPeriod.create()
  else if (propName = 'item') then result := ItemList.new()
  else result := inherited createPropertyValue(propName);
end;

function TFhirCoverageEligibilityResponseInsurance.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'coverage') then result := 'Reference'
  else if (propName = 'inforce') then result := 'boolean'
  else if (propName = 'benefitPeriod') then result := 'Period'
  else if (propName = 'item') then result := 'BackboneElement'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirCoverageEligibilityResponseInsurance.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'coverage') then CoverageElement := nil
  else if (propName = 'inforce') then InforceElement := nil
  else if (propName = 'benefitPeriod') then BenefitPeriodElement := nil
  else if (propName = 'item') then deletePropertyValue('item', ItemList, value)
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirCoverageEligibilityResponseInsurance.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'coverage') then CoverageElement := new as TFhirReference
  else if (propName = 'inforce') then InforceElement := asBoolean(new)
  else if (propName = 'benefitPeriod') then BenefitPeriodElement := new as TFhirPeriod
  else if (propName = 'item') then replacePropertyValue('item', ItemList, existing, new)
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirCoverageEligibilityResponseInsurance.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'item') then ItemList.move(source, destination)
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirCoverageEligibilityResponseInsurance.fhirType : string;
begin
  result := 'CoverageEligibilityResponse.insurance';
end;

function TFhirCoverageEligibilityResponseInsurance.Link : TFhirCoverageEligibilityResponseInsurance;
begin
  result := TFhirCoverageEligibilityResponseInsurance(inherited Link);
end;

function TFhirCoverageEligibilityResponseInsurance.Clone : TFhirCoverageEligibilityResponseInsurance;
begin
  result := TFhirCoverageEligibilityResponseInsurance(inherited Clone);
end;

function TFhirCoverageEligibilityResponseInsurance.equals(other : TObject) : boolean; 
var
  o : TFhirCoverageEligibilityResponseInsurance;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirCoverageEligibilityResponseInsurance)) then
    result := false
  else
  begin
    o := TFhirCoverageEligibilityResponseInsurance(other);
    result := compareDeep(coverageElement, o.coverageElement, true) and compareDeep(inforceElement, o.inforceElement, true) and 
      compareDeep(benefitPeriodElement, o.benefitPeriodElement, true) and compareDeep(itemList, o.itemList, true);
  end;
end;

function TFhirCoverageEligibilityResponseInsurance.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FCoverage) and isEmptyProp(FInforce) and isEmptyProp(FBenefitPeriod) and isEmptyProp(FitemList);
end;

procedure TFhirCoverageEligibilityResponseInsurance.listFieldsInOrder(fields : TStringList);
begin
  inherited listFieldsInOrder(fields);
  fields.add('coverage');
  fields.add('inforce');
  fields.add('benefitPeriod');
  fields.add('item');
end;

function TFhirCoverageEligibilityResponseInsurance.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FItemList.sizeInBytes(magic));
end;

procedure TFhirCoverageEligibilityResponseInsurance.SetCoverage(value : TFhirReference);
begin
  FCoverage.free;
  FCoverage := value;
end;

procedure TFhirCoverageEligibilityResponseInsurance.SetInforce(value : TFhirBoolean);
begin
  FInforce.free;
  FInforce := value;
end;

function TFhirCoverageEligibilityResponseInsurance.GetInforceST : Boolean;
begin
  if FInforce = nil then
    result := false
  else
    result := FInforce.value;
end;

procedure TFhirCoverageEligibilityResponseInsurance.SetInforceST(value : Boolean);
begin
  if FInforce = nil then
    FInforce := TFhirBoolean.create;
  FInforce.value := value
end;

procedure TFhirCoverageEligibilityResponseInsurance.SetBenefitPeriod(value : TFhirPeriod);
begin
  FBenefitPeriod.free;
  FBenefitPeriod := value;
end;

function TFhirCoverageEligibilityResponseInsurance.GetItemList : TFhirCoverageEligibilityResponseInsuranceItemList;
begin
  if FItemList = nil then
    FItemList := TFhirCoverageEligibilityResponseInsuranceItemList.Create;
  result := FItemList;
end;

function TFhirCoverageEligibilityResponseInsurance.GetHasItemList : boolean;
begin
  result := (FItemList <> nil) and (FItemList.count > 0);
end;

{ TFhirCoverageEligibilityResponseInsuranceListEnumerator }

constructor TFhirCoverageEligibilityResponseInsuranceListEnumerator.Create(list : TFhirCoverageEligibilityResponseInsuranceList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirCoverageEligibilityResponseInsuranceListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirCoverageEligibilityResponseInsuranceListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirCoverageEligibilityResponseInsuranceListEnumerator.GetCurrent : TFhirCoverageEligibilityResponseInsurance;
begin
  Result := FList[FIndex];
end;

function TFhirCoverageEligibilityResponseInsuranceListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirCoverageEligibilityResponseInsuranceList }

procedure TFhirCoverageEligibilityResponseInsuranceList.AddItem(value: TFhirCoverageEligibilityResponseInsurance);
begin
  assert(value.ClassName = 'TFhirCoverageEligibilityResponseInsurance', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirCoverageEligibilityResponseInsurance');
  add(value);
end;

function TFhirCoverageEligibilityResponseInsuranceList.Append: TFhirCoverageEligibilityResponseInsurance;
begin
  result := TFhirCoverageEligibilityResponseInsurance.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirCoverageEligibilityResponseInsuranceList.ClearItems;
begin
  Clear;
end;

function TFhirCoverageEligibilityResponseInsuranceList.GetEnumerator : TFhirCoverageEligibilityResponseInsuranceListEnumerator;
begin
  result := TFhirCoverageEligibilityResponseInsuranceListEnumerator.Create(self.link);
end;

function TFhirCoverageEligibilityResponseInsuranceList.Clone: TFhirCoverageEligibilityResponseInsuranceList;
begin
  result := TFhirCoverageEligibilityResponseInsuranceList(inherited Clone);
end;

function TFhirCoverageEligibilityResponseInsuranceList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirCoverageEligibilityResponseInsuranceList.GetItemN(index: Integer): TFhirCoverageEligibilityResponseInsurance;
begin
  result := TFhirCoverageEligibilityResponseInsurance(ObjectByIndex[index]);
end;

function TFhirCoverageEligibilityResponseInsuranceList.ItemClass: TFslObjectClass;
begin
  result := TFhirCoverageEligibilityResponseInsurance;
end;
function TFhirCoverageEligibilityResponseInsuranceList.IndexOf(value: TFhirCoverageEligibilityResponseInsurance): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirCoverageEligibilityResponseInsuranceList.Insert(index: Integer): TFhirCoverageEligibilityResponseInsurance;
begin
  result := TFhirCoverageEligibilityResponseInsurance.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirCoverageEligibilityResponseInsuranceList.InsertItem(index: Integer; value: TFhirCoverageEligibilityResponseInsurance);
begin
  assert(value is TFhirCoverageEligibilityResponseInsurance);
  Inherited Insert(index, value);
end;

function TFhirCoverageEligibilityResponseInsuranceList.Item(index: Integer): TFhirCoverageEligibilityResponseInsurance;
begin
  result := TFhirCoverageEligibilityResponseInsurance(ObjectByIndex[index]);
end;

function TFhirCoverageEligibilityResponseInsuranceList.Link: TFhirCoverageEligibilityResponseInsuranceList;
begin
  result := TFhirCoverageEligibilityResponseInsuranceList(inherited Link);
end;

procedure TFhirCoverageEligibilityResponseInsuranceList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirCoverageEligibilityResponseInsuranceList.SetItemByIndex(index: Integer; value: TFhirCoverageEligibilityResponseInsurance);
begin
  assert(value is TFhirCoverageEligibilityResponseInsurance);
  FhirCoverageEligibilityResponseInsurances[index] := value;
end;

procedure TFhirCoverageEligibilityResponseInsuranceList.SetItemN(index: Integer; value: TFhirCoverageEligibilityResponseInsurance);
begin
  assert(value is TFhirCoverageEligibilityResponseInsurance);
  ObjectByIndex[index] := value;
end;

{ TFhirCoverageEligibilityResponseInsuranceItem }

constructor TFhirCoverageEligibilityResponseInsuranceItem.Create;
begin
  inherited;
end;

destructor TFhirCoverageEligibilityResponseInsuranceItem.Destroy;
begin
  FCategory.free;
  FProductOrService.free;
  FModifierList.Free;
  FProvider.free;
  FExcluded.free;
  FName.free;
  FDescription.free;
  FNetwork.free;
  FUnit_.free;
  FTerm.free;
  FBenefitList.Free;
  FAuthorizationRequired.free;
  FAuthorizationSupportingList.Free;
  FAuthorizationUrl.free;
  inherited;
end;

procedure TFhirCoverageEligibilityResponseInsuranceItem.Assign(oSource : TFslObject);
begin
  inherited;
  category := TFhirCoverageEligibilityResponseInsuranceItem(oSource).category.Clone;
  productOrService := TFhirCoverageEligibilityResponseInsuranceItem(oSource).productOrService.Clone;
  if (TFhirCoverageEligibilityResponseInsuranceItem(oSource).FModifierList = nil) then
  begin
    FModifierList.free;
    FModifierList := nil;
  end
  else
  begin
    if FModifierList = nil then
      FModifierList := TFhirCodeableConceptList.Create;
    FModifierList.Assign(TFhirCoverageEligibilityResponseInsuranceItem(oSource).FModifierList);
  end;
  provider := TFhirCoverageEligibilityResponseInsuranceItem(oSource).provider.Clone;
  excludedElement := TFhirCoverageEligibilityResponseInsuranceItem(oSource).excludedElement.Clone;
  nameElement := TFhirCoverageEligibilityResponseInsuranceItem(oSource).nameElement.Clone;
  descriptionElement := TFhirCoverageEligibilityResponseInsuranceItem(oSource).descriptionElement.Clone;
  network := TFhirCoverageEligibilityResponseInsuranceItem(oSource).network.Clone;
  unit_ := TFhirCoverageEligibilityResponseInsuranceItem(oSource).unit_.Clone;
  term := TFhirCoverageEligibilityResponseInsuranceItem(oSource).term.Clone;
  if (TFhirCoverageEligibilityResponseInsuranceItem(oSource).FBenefitList = nil) then
  begin
    FBenefitList.free;
    FBenefitList := nil;
  end
  else
  begin
    if FBenefitList = nil then
      FBenefitList := TFhirCoverageEligibilityResponseInsuranceItemBenefitList.Create;
    FBenefitList.Assign(TFhirCoverageEligibilityResponseInsuranceItem(oSource).FBenefitList);
  end;
  authorizationRequiredElement := TFhirCoverageEligibilityResponseInsuranceItem(oSource).authorizationRequiredElement.Clone;
  if (TFhirCoverageEligibilityResponseInsuranceItem(oSource).FAuthorizationSupportingList = nil) then
  begin
    FAuthorizationSupportingList.free;
    FAuthorizationSupportingList := nil;
  end
  else
  begin
    if FAuthorizationSupportingList = nil then
      FAuthorizationSupportingList := TFhirCodeableConceptList.Create;
    FAuthorizationSupportingList.Assign(TFhirCoverageEligibilityResponseInsuranceItem(oSource).FAuthorizationSupportingList);
  end;
  authorizationUrlElement := TFhirCoverageEligibilityResponseInsuranceItem(oSource).authorizationUrlElement.Clone;
end;

procedure TFhirCoverageEligibilityResponseInsuranceItem.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'category') Then
     list.add(self.link, 'category', FCategory.Link);
  if (child_name = 'productOrService') Then
     list.add(self.link, 'productOrService', FProductOrService.Link);
  if (child_name = 'modifier') Then
    list.addAll(self, 'modifier', FModifierList);
  if (child_name = 'provider') Then
     list.add(self.link, 'provider', FProvider.Link);
  if (child_name = 'excluded') Then
     list.add(self.link, 'excluded', FExcluded.Link);
  if (child_name = 'name') Then
     list.add(self.link, 'name', FName.Link);
  if (child_name = 'description') Then
     list.add(self.link, 'description', FDescription.Link);
  if (child_name = 'network') Then
     list.add(self.link, 'network', FNetwork.Link);
  if (child_name = 'unit') Then
     list.add(self.link, 'unit', FUnit_.Link);
  if (child_name = 'term') Then
     list.add(self.link, 'term', FTerm.Link);
  if (child_name = 'benefit') Then
    list.addAll(self, 'benefit', FBenefitList);
  if (child_name = 'authorizationRequired') Then
     list.add(self.link, 'authorizationRequired', FAuthorizationRequired.Link);
  if (child_name = 'authorizationSupporting') Then
    list.addAll(self, 'authorizationSupporting', FAuthorizationSupportingList);
  if (child_name = 'authorizationUrl') Then
     list.add(self.link, 'authorizationUrl', FAuthorizationUrl.Link);
end;

procedure TFhirCoverageEligibilityResponseInsuranceItem.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'category', 'CodeableConcept', false, TFhirCodeableConcept, FCategory.Link));
  oList.add(TFHIRProperty.create(self, 'productOrService', 'CodeableConcept', false, TFhirCodeableConcept, FProductOrService.Link));
  oList.add(TFHIRProperty.create(self, 'modifier', 'CodeableConcept', true, TFhirCodeableConcept, FModifierList.Link));
  oList.add(TFHIRProperty.create(self, 'provider', 'Reference', false, TFhirReference, FProvider.Link));
  oList.add(TFHIRProperty.create(self, 'excluded', 'boolean', false, TFhirBoolean, FExcluded.Link));
  oList.add(TFHIRProperty.create(self, 'name', 'string', false, TFhirString, FName.Link));
  oList.add(TFHIRProperty.create(self, 'description', 'string', false, TFhirString, FDescription.Link));
  oList.add(TFHIRProperty.create(self, 'network', 'CodeableConcept', false, TFhirCodeableConcept, FNetwork.Link));
  oList.add(TFHIRProperty.create(self, 'unit', 'CodeableConcept', false, TFhirCodeableConcept, FUnit_.Link));
  oList.add(TFHIRProperty.create(self, 'term', 'CodeableConcept', false, TFhirCodeableConcept, FTerm.Link));
  oList.add(TFHIRProperty.create(self, 'benefit', 'BackboneElement', true, TFhirCoverageEligibilityResponseInsuranceItemBenefit, FBenefitList.Link));
  oList.add(TFHIRProperty.create(self, 'authorizationRequired', 'boolean', false, TFhirBoolean, FAuthorizationRequired.Link));
  oList.add(TFHIRProperty.create(self, 'authorizationSupporting', 'CodeableConcept', true, TFhirCodeableConcept, FAuthorizationSupportingList.Link));
  oList.add(TFHIRProperty.create(self, 'authorizationUrl', 'uri', false, TFhirUri, FAuthorizationUrl.Link));
end;

function TFhirCoverageEligibilityResponseInsuranceItem.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'category') then
  begin
    Category := propValue as TFhirCodeableConcept;
    result := propValue;
  end
  else if (propName = 'productOrService') then
  begin
    ProductOrService := propValue as TFhirCodeableConcept;
    result := propValue;
  end
  else if (propName = 'modifier') then
  begin
    ModifierList.add(propValue as TFhirCodeableConcept);
    result := propValue;
  end
  else if (propName = 'provider') then
  begin
    Provider := propValue as TFhirReference;
    result := propValue;
  end
  else if (propName = 'excluded') then
  begin
    ExcludedElement := asBoolean(propValue);
    result := propValue;
  end
  else if (propName = 'name') then
  begin
    NameElement := asString(propValue);
    result := propValue;
  end
  else if (propName = 'description') then
  begin
    DescriptionElement := asString(propValue);
    result := propValue;
  end
  else if (propName = 'network') then
  begin
    Network := propValue as TFhirCodeableConcept;
    result := propValue;
  end
  else if (propName = 'unit') then
  begin
    Unit_ := propValue as TFhirCodeableConcept;
    result := propValue;
  end
  else if (propName = 'term') then
  begin
    Term := propValue as TFhirCodeableConcept;
    result := propValue;
  end
  else if (propName = 'benefit') then
  begin
    BenefitList.add(propValue as TFhirCoverageEligibilityResponseInsuranceItemBenefit);
    result := propValue;
  end
  else if (propName = 'authorizationRequired') then
  begin
    AuthorizationRequiredElement := asBoolean(propValue);
    result := propValue;
  end
  else if (propName = 'authorizationSupporting') then
  begin
    AuthorizationSupportingList.add(propValue as TFhirCodeableConcept);
    result := propValue;
  end
  else if (propName = 'authorizationUrl') then
  begin
    AuthorizationUrlElement := asUri(propValue);
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirCoverageEligibilityResponseInsuranceItem.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'modifier') then ModifierList.insertItem(index, propValue as TFhirCodeableConcept)
  else if (propName = 'benefit') then BenefitList.insertItem(index, propValue as TFhirCoverageEligibilityResponseInsuranceItemBenefit)
  else if (propName = 'authorizationSupporting') then AuthorizationSupportingList.insertItem(index, propValue as TFhirCodeableConcept)
  else inherited;
end;

function TFhirCoverageEligibilityResponseInsuranceItem.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'category') then result := TFhirCodeableConcept.create()
  else if (propName = 'productOrService') then result := TFhirCodeableConcept.create()
  else if (propName = 'modifier') then result := ModifierList.new()
  else if (propName = 'provider') then result := TFhirReference.create()
  else if (propName = 'excluded') then result := TFhirBoolean.create()
  else if (propName = 'name') then result := TFhirString.create()
  else if (propName = 'description') then result := TFhirString.create()
  else if (propName = 'network') then result := TFhirCodeableConcept.create()
  else if (propName = 'unit') then result := TFhirCodeableConcept.create()
  else if (propName = 'term') then result := TFhirCodeableConcept.create()
  else if (propName = 'benefit') then result := BenefitList.new()
  else if (propName = 'authorizationRequired') then result := TFhirBoolean.create()
  else if (propName = 'authorizationSupporting') then result := AuthorizationSupportingList.new()
  else if (propName = 'authorizationUrl') then result := TFhirUri.create()
  else result := inherited createPropertyValue(propName);
end;

function TFhirCoverageEligibilityResponseInsuranceItem.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'category') then result := 'CodeableConcept'
  else if (propName = 'productOrService') then result := 'CodeableConcept'
  else if (propName = 'modifier') then result := 'CodeableConcept'
  else if (propName = 'provider') then result := 'Reference'
  else if (propName = 'excluded') then result := 'boolean'
  else if (propName = 'name') then result := 'string'
  else if (propName = 'description') then result := 'string'
  else if (propName = 'network') then result := 'CodeableConcept'
  else if (propName = 'unit') then result := 'CodeableConcept'
  else if (propName = 'term') then result := 'CodeableConcept'
  else if (propName = 'benefit') then result := 'BackboneElement'
  else if (propName = 'authorizationRequired') then result := 'boolean'
  else if (propName = 'authorizationSupporting') then result := 'CodeableConcept'
  else if (propName = 'authorizationUrl') then result := 'uri'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirCoverageEligibilityResponseInsuranceItem.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'category') then CategoryElement := nil
  else if (propName = 'productOrService') then ProductOrServiceElement := nil
  else if (propName = 'modifier') then deletePropertyValue('modifier', ModifierList, value)
  else if (propName = 'provider') then ProviderElement := nil
  else if (propName = 'excluded') then ExcludedElement := nil
  else if (propName = 'name') then NameElement := nil
  else if (propName = 'description') then DescriptionElement := nil
  else if (propName = 'network') then NetworkElement := nil
  else if (propName = 'unit') then Unit_Element := nil
  else if (propName = 'term') then TermElement := nil
  else if (propName = 'benefit') then deletePropertyValue('benefit', BenefitList, value)
  else if (propName = 'authorizationRequired') then AuthorizationRequiredElement := nil
  else if (propName = 'authorizationSupporting') then deletePropertyValue('authorizationSupporting', AuthorizationSupportingList, value)
  else if (propName = 'authorizationUrl') then AuthorizationUrlElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirCoverageEligibilityResponseInsuranceItem.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'category') then CategoryElement := new as TFhirCodeableConcept
  else if (propName = 'productOrService') then ProductOrServiceElement := new as TFhirCodeableConcept
  else if (propName = 'modifier') then replacePropertyValue('modifier', ModifierList, existing, new)
  else if (propName = 'provider') then ProviderElement := new as TFhirReference
  else if (propName = 'excluded') then ExcludedElement := asBoolean(new)
  else if (propName = 'name') then NameElement := asString(new)
  else if (propName = 'description') then DescriptionElement := asString(new)
  else if (propName = 'network') then NetworkElement := new as TFhirCodeableConcept
  else if (propName = 'unit') then Unit_Element := new as TFhirCodeableConcept
  else if (propName = 'term') then TermElement := new as TFhirCodeableConcept
  else if (propName = 'benefit') then replacePropertyValue('benefit', BenefitList, existing, new)
  else if (propName = 'authorizationRequired') then AuthorizationRequiredElement := asBoolean(new)
  else if (propName = 'authorizationSupporting') then replacePropertyValue('authorizationSupporting', AuthorizationSupportingList, existing, new)
  else if (propName = 'authorizationUrl') then AuthorizationUrlElement := asUri(new)
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirCoverageEligibilityResponseInsuranceItem.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'modifier') then ModifierList.move(source, destination)
  else if (propName = 'benefit') then BenefitList.move(source, destination)
  else if (propName = 'authorizationSupporting') then AuthorizationSupportingList.move(source, destination)
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirCoverageEligibilityResponseInsuranceItem.fhirType : string;
begin
  result := 'CoverageEligibilityResponse.insurance.item';
end;

function TFhirCoverageEligibilityResponseInsuranceItem.Link : TFhirCoverageEligibilityResponseInsuranceItem;
begin
  result := TFhirCoverageEligibilityResponseInsuranceItem(inherited Link);
end;

function TFhirCoverageEligibilityResponseInsuranceItem.Clone : TFhirCoverageEligibilityResponseInsuranceItem;
begin
  result := TFhirCoverageEligibilityResponseInsuranceItem(inherited Clone);
end;

function TFhirCoverageEligibilityResponseInsuranceItem.equals(other : TObject) : boolean; 
var
  o : TFhirCoverageEligibilityResponseInsuranceItem;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirCoverageEligibilityResponseInsuranceItem)) then
    result := false
  else
  begin
    o := TFhirCoverageEligibilityResponseInsuranceItem(other);
    result := compareDeep(categoryElement, o.categoryElement, true) and compareDeep(productOrServiceElement, o.productOrServiceElement, true) and 
      compareDeep(modifierList, o.modifierList, true) and compareDeep(providerElement, o.providerElement, true) and 
      compareDeep(excludedElement, o.excludedElement, true) and compareDeep(nameElement, o.nameElement, true) and 
      compareDeep(descriptionElement, o.descriptionElement, true) and compareDeep(networkElement, o.networkElement, true) and 
      compareDeep(unit_Element, o.unit_Element, true) and compareDeep(termElement, o.termElement, true) and 
      compareDeep(benefitList, o.benefitList, true) and compareDeep(authorizationRequiredElement, o.authorizationRequiredElement, true) and 
      compareDeep(authorizationSupportingList, o.authorizationSupportingList, true) and 
      compareDeep(authorizationUrlElement, o.authorizationUrlElement, true);
  end;
end;

function TFhirCoverageEligibilityResponseInsuranceItem.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FCategory) and isEmptyProp(FProductOrService) and isEmptyProp(FmodifierList) and isEmptyProp(FProvider) and isEmptyProp(FExcluded) and isEmptyProp(FName) and isEmptyProp(FDescription) and isEmptyProp(FNetwork) and isEmptyProp(FUnit_) and isEmptyProp(FTerm) and isEmptyProp(FbenefitList) and isEmptyProp(FAuthorizationRequired) and isEmptyProp(FauthorizationSupportingList) and isEmptyProp(FAuthorizationUrl);
end;

procedure TFhirCoverageEligibilityResponseInsuranceItem.listFieldsInOrder(fields : TStringList);
begin
  inherited listFieldsInOrder(fields);
  fields.add('category');
  fields.add('productOrService');
  fields.add('modifier');
  fields.add('provider');
  fields.add('excluded');
  fields.add('name');
  fields.add('description');
  fields.add('network');
  fields.add('unit');
  fields.add('term');
  fields.add('benefit');
  fields.add('authorizationRequired');
  fields.add('authorizationSupporting');
  fields.add('authorizationUrl');
end;

function TFhirCoverageEligibilityResponseInsuranceItem.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FModifierList.sizeInBytes(magic));
  inc(result, FBenefitList.sizeInBytes(magic));
  inc(result, FAuthorizationSupportingList.sizeInBytes(magic));
end;

procedure TFhirCoverageEligibilityResponseInsuranceItem.SetCategory(value : TFhirCodeableConcept);
begin
  FCategory.free;
  FCategory := value;
end;

procedure TFhirCoverageEligibilityResponseInsuranceItem.SetProductOrService(value : TFhirCodeableConcept);
begin
  FProductOrService.free;
  FProductOrService := value;
end;

function TFhirCoverageEligibilityResponseInsuranceItem.GetModifierList : TFhirCodeableConceptList;
begin
  if FModifierList = nil then
    FModifierList := TFhirCodeableConceptList.Create;
  result := FModifierList;
end;

function TFhirCoverageEligibilityResponseInsuranceItem.GetHasModifierList : boolean;
begin
  result := (FModifierList <> nil) and (FModifierList.count > 0);
end;

procedure TFhirCoverageEligibilityResponseInsuranceItem.SetProvider(value : TFhirReference);
begin
  FProvider.free;
  FProvider := value;
end;

procedure TFhirCoverageEligibilityResponseInsuranceItem.SetExcluded(value : TFhirBoolean);
begin
  FExcluded.free;
  FExcluded := value;
end;

function TFhirCoverageEligibilityResponseInsuranceItem.GetExcludedST : Boolean;
begin
  if FExcluded = nil then
    result := false
  else
    result := FExcluded.value;
end;

procedure TFhirCoverageEligibilityResponseInsuranceItem.SetExcludedST(value : Boolean);
begin
  if FExcluded = nil then
    FExcluded := TFhirBoolean.create;
  FExcluded.value := value
end;

procedure TFhirCoverageEligibilityResponseInsuranceItem.SetName(value : TFhirString);
begin
  FName.free;
  FName := value;
end;

function TFhirCoverageEligibilityResponseInsuranceItem.GetNameST : String;
begin
  if FName = nil then
    result := ''
  else
    result := FName.value;
end;

procedure TFhirCoverageEligibilityResponseInsuranceItem.SetNameST(value : String);
begin
  if value <> '' then
  begin
    if FName = nil then
      FName := TFhirString.create;
    FName.value := value
  end
  else if FName <> nil then
    FName.value := '';
end;

procedure TFhirCoverageEligibilityResponseInsuranceItem.SetDescription(value : TFhirString);
begin
  FDescription.free;
  FDescription := value;
end;

function TFhirCoverageEligibilityResponseInsuranceItem.GetDescriptionST : String;
begin
  if FDescription = nil then
    result := ''
  else
    result := FDescription.value;
end;

procedure TFhirCoverageEligibilityResponseInsuranceItem.SetDescriptionST(value : String);
begin
  if value <> '' then
  begin
    if FDescription = nil then
      FDescription := TFhirString.create;
    FDescription.value := value
  end
  else if FDescription <> nil then
    FDescription.value := '';
end;

procedure TFhirCoverageEligibilityResponseInsuranceItem.SetNetwork(value : TFhirCodeableConcept);
begin
  FNetwork.free;
  FNetwork := value;
end;

procedure TFhirCoverageEligibilityResponseInsuranceItem.SetUnit_(value : TFhirCodeableConcept);
begin
  FUnit_.free;
  FUnit_ := value;
end;

procedure TFhirCoverageEligibilityResponseInsuranceItem.SetTerm(value : TFhirCodeableConcept);
begin
  FTerm.free;
  FTerm := value;
end;

function TFhirCoverageEligibilityResponseInsuranceItem.GetBenefitList : TFhirCoverageEligibilityResponseInsuranceItemBenefitList;
begin
  if FBenefitList = nil then
    FBenefitList := TFhirCoverageEligibilityResponseInsuranceItemBenefitList.Create;
  result := FBenefitList;
end;

function TFhirCoverageEligibilityResponseInsuranceItem.GetHasBenefitList : boolean;
begin
  result := (FBenefitList <> nil) and (FBenefitList.count > 0);
end;

procedure TFhirCoverageEligibilityResponseInsuranceItem.SetAuthorizationRequired(value : TFhirBoolean);
begin
  FAuthorizationRequired.free;
  FAuthorizationRequired := value;
end;

function TFhirCoverageEligibilityResponseInsuranceItem.GetAuthorizationRequiredST : Boolean;
begin
  if FAuthorizationRequired = nil then
    result := false
  else
    result := FAuthorizationRequired.value;
end;

procedure TFhirCoverageEligibilityResponseInsuranceItem.SetAuthorizationRequiredST(value : Boolean);
begin
  if FAuthorizationRequired = nil then
    FAuthorizationRequired := TFhirBoolean.create;
  FAuthorizationRequired.value := value
end;

function TFhirCoverageEligibilityResponseInsuranceItem.GetAuthorizationSupportingList : TFhirCodeableConceptList;
begin
  if FAuthorizationSupportingList = nil then
    FAuthorizationSupportingList := TFhirCodeableConceptList.Create;
  result := FAuthorizationSupportingList;
end;

function TFhirCoverageEligibilityResponseInsuranceItem.GetHasAuthorizationSupportingList : boolean;
begin
  result := (FAuthorizationSupportingList <> nil) and (FAuthorizationSupportingList.count > 0);
end;

procedure TFhirCoverageEligibilityResponseInsuranceItem.SetAuthorizationUrl(value : TFhirUri);
begin
  FAuthorizationUrl.free;
  FAuthorizationUrl := value;
end;

function TFhirCoverageEligibilityResponseInsuranceItem.GetAuthorizationUrlST : String;
begin
  if FAuthorizationUrl = nil then
    result := ''
  else
    result := FAuthorizationUrl.value;
end;

procedure TFhirCoverageEligibilityResponseInsuranceItem.SetAuthorizationUrlST(value : String);
begin
  if value <> '' then
  begin
    if FAuthorizationUrl = nil then
      FAuthorizationUrl := TFhirUri.create;
    FAuthorizationUrl.value := value
  end
  else if FAuthorizationUrl <> nil then
    FAuthorizationUrl.value := '';
end;

{ TFhirCoverageEligibilityResponseInsuranceItemListEnumerator }

constructor TFhirCoverageEligibilityResponseInsuranceItemListEnumerator.Create(list : TFhirCoverageEligibilityResponseInsuranceItemList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirCoverageEligibilityResponseInsuranceItemListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirCoverageEligibilityResponseInsuranceItemListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirCoverageEligibilityResponseInsuranceItemListEnumerator.GetCurrent : TFhirCoverageEligibilityResponseInsuranceItem;
begin
  Result := FList[FIndex];
end;

function TFhirCoverageEligibilityResponseInsuranceItemListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirCoverageEligibilityResponseInsuranceItemList }

procedure TFhirCoverageEligibilityResponseInsuranceItemList.AddItem(value: TFhirCoverageEligibilityResponseInsuranceItem);
begin
  assert(value.ClassName = 'TFhirCoverageEligibilityResponseInsuranceItem', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirCoverageEligibilityResponseInsuranceItem');
  add(value);
end;

function TFhirCoverageEligibilityResponseInsuranceItemList.Append: TFhirCoverageEligibilityResponseInsuranceItem;
begin
  result := TFhirCoverageEligibilityResponseInsuranceItem.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirCoverageEligibilityResponseInsuranceItemList.ClearItems;
begin
  Clear;
end;

function TFhirCoverageEligibilityResponseInsuranceItemList.GetEnumerator : TFhirCoverageEligibilityResponseInsuranceItemListEnumerator;
begin
  result := TFhirCoverageEligibilityResponseInsuranceItemListEnumerator.Create(self.link);
end;

function TFhirCoverageEligibilityResponseInsuranceItemList.Clone: TFhirCoverageEligibilityResponseInsuranceItemList;
begin
  result := TFhirCoverageEligibilityResponseInsuranceItemList(inherited Clone);
end;

function TFhirCoverageEligibilityResponseInsuranceItemList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirCoverageEligibilityResponseInsuranceItemList.GetItemN(index: Integer): TFhirCoverageEligibilityResponseInsuranceItem;
begin
  result := TFhirCoverageEligibilityResponseInsuranceItem(ObjectByIndex[index]);
end;

function TFhirCoverageEligibilityResponseInsuranceItemList.ItemClass: TFslObjectClass;
begin
  result := TFhirCoverageEligibilityResponseInsuranceItem;
end;
function TFhirCoverageEligibilityResponseInsuranceItemList.IndexOf(value: TFhirCoverageEligibilityResponseInsuranceItem): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirCoverageEligibilityResponseInsuranceItemList.Insert(index: Integer): TFhirCoverageEligibilityResponseInsuranceItem;
begin
  result := TFhirCoverageEligibilityResponseInsuranceItem.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirCoverageEligibilityResponseInsuranceItemList.InsertItem(index: Integer; value: TFhirCoverageEligibilityResponseInsuranceItem);
begin
  assert(value is TFhirCoverageEligibilityResponseInsuranceItem);
  Inherited Insert(index, value);
end;

function TFhirCoverageEligibilityResponseInsuranceItemList.Item(index: Integer): TFhirCoverageEligibilityResponseInsuranceItem;
begin
  result := TFhirCoverageEligibilityResponseInsuranceItem(ObjectByIndex[index]);
end;

function TFhirCoverageEligibilityResponseInsuranceItemList.Link: TFhirCoverageEligibilityResponseInsuranceItemList;
begin
  result := TFhirCoverageEligibilityResponseInsuranceItemList(inherited Link);
end;

procedure TFhirCoverageEligibilityResponseInsuranceItemList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirCoverageEligibilityResponseInsuranceItemList.SetItemByIndex(index: Integer; value: TFhirCoverageEligibilityResponseInsuranceItem);
begin
  assert(value is TFhirCoverageEligibilityResponseInsuranceItem);
  FhirCoverageEligibilityResponseInsuranceItems[index] := value;
end;

procedure TFhirCoverageEligibilityResponseInsuranceItemList.SetItemN(index: Integer; value: TFhirCoverageEligibilityResponseInsuranceItem);
begin
  assert(value is TFhirCoverageEligibilityResponseInsuranceItem);
  ObjectByIndex[index] := value;
end;

{ TFhirCoverageEligibilityResponseInsuranceItemBenefit }

constructor TFhirCoverageEligibilityResponseInsuranceItemBenefit.Create;
begin
  inherited;
end;

destructor TFhirCoverageEligibilityResponseInsuranceItemBenefit.Destroy;
begin
  FType_.free;
  FAllowed.free;
  FUsed.free;
  inherited;
end;

procedure TFhirCoverageEligibilityResponseInsuranceItemBenefit.Assign(oSource : TFslObject);
begin
  inherited;
  type_ := TFhirCoverageEligibilityResponseInsuranceItemBenefit(oSource).type_.Clone;
  allowed := TFhirCoverageEligibilityResponseInsuranceItemBenefit(oSource).allowed.Clone;
  used := TFhirCoverageEligibilityResponseInsuranceItemBenefit(oSource).used.Clone;
end;

procedure TFhirCoverageEligibilityResponseInsuranceItemBenefit.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'type') Then
     list.add(self.link, 'type', FType_.Link);
  if (child_name = 'allowed[x]') or (child_name = 'allowed') Then
     list.add(self.link, 'allowed[x]', FAllowed.Link);
  if (child_name = 'used[x]') or (child_name = 'used') Then
     list.add(self.link, 'used[x]', FUsed.Link);
end;

procedure TFhirCoverageEligibilityResponseInsuranceItemBenefit.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'type', 'CodeableConcept', false, TFhirCodeableConcept, FType_.Link));
  oList.add(TFHIRProperty.create(self, 'allowed[x]', 'unsignedInt|string|Money', false, TFhirDataType, FAllowed.Link));
  oList.add(TFHIRProperty.create(self, 'used[x]', 'unsignedInt|string|Money', false, TFhirDataType, FUsed.Link));
end;

function TFhirCoverageEligibilityResponseInsuranceItemBenefit.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'type') then
  begin
    Type_ := propValue as TFhirCodeableConcept;
    result := propValue;
  end
  else if (isMatchingName(propName, 'allowed', ['UnsignedInt', 'String', 'Money'])) then
  begin
    Allowed := propValue as TFhirDataType;
    result := propValue;
  end
  else if (isMatchingName(propName, 'used', ['UnsignedInt', 'String', 'Money'])) then
  begin
    Used := propValue as TFhirDataType;
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirCoverageEligibilityResponseInsuranceItemBenefit.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirCoverageEligibilityResponseInsuranceItemBenefit.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'type') then result := TFhirCodeableConcept.create()
  else if (isMatchingName(propName, 'allowed', ['UnsignedInt', 'String', 'Money'])) then raise EFHIRException.create('Cannot make property Allowed')
  else if (isMatchingName(propName, 'used', ['UnsignedInt', 'String', 'Money'])) then raise EFHIRException.create('Cannot make property Used')
  else result := inherited createPropertyValue(propName);
end;

function TFhirCoverageEligibilityResponseInsuranceItemBenefit.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'type') then result := 'CodeableConcept'
  else if (propName = 'allowed[x]') then result := 'unsignedInt|string|Money'
  else if (propName = 'used[x]') then result := 'unsignedInt|string|Money'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirCoverageEligibilityResponseInsuranceItemBenefit.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'type') then Type_Element := nil
  else if (isMatchingName(propName, 'allowed', ['UnsignedInt', 'String', 'Money'])) then AllowedElement := nil
  else if (isMatchingName(propName, 'used', ['UnsignedInt', 'String', 'Money'])) then UsedElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirCoverageEligibilityResponseInsuranceItemBenefit.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'type') then Type_Element := new as TFhirCodeableConcept
  else if (isMatchingName(propName, 'allowed', ['UnsignedInt', 'String', 'Money'])) then AllowedElement := new as TFhirDataType
  else if (isMatchingName(propName, 'used', ['UnsignedInt', 'String', 'Money'])) then UsedElement := new as TFhirDataType
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirCoverageEligibilityResponseInsuranceItemBenefit.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirCoverageEligibilityResponseInsuranceItemBenefit.fhirType : string;
begin
  result := 'CoverageEligibilityResponse.insurance.item.benefit';
end;

function TFhirCoverageEligibilityResponseInsuranceItemBenefit.Link : TFhirCoverageEligibilityResponseInsuranceItemBenefit;
begin
  result := TFhirCoverageEligibilityResponseInsuranceItemBenefit(inherited Link);
end;

function TFhirCoverageEligibilityResponseInsuranceItemBenefit.Clone : TFhirCoverageEligibilityResponseInsuranceItemBenefit;
begin
  result := TFhirCoverageEligibilityResponseInsuranceItemBenefit(inherited Clone);
end;

function TFhirCoverageEligibilityResponseInsuranceItemBenefit.equals(other : TObject) : boolean; 
var
  o : TFhirCoverageEligibilityResponseInsuranceItemBenefit;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirCoverageEligibilityResponseInsuranceItemBenefit)) then
    result := false
  else
  begin
    o := TFhirCoverageEligibilityResponseInsuranceItemBenefit(other);
    result := compareDeep(type_Element, o.type_Element, true) and compareDeep(allowedElement, o.allowedElement, true) and 
      compareDeep(usedElement, o.usedElement, true);
  end;
end;

function TFhirCoverageEligibilityResponseInsuranceItemBenefit.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FType_) and isEmptyProp(FAllowed) and isEmptyProp(FUsed);
end;

procedure TFhirCoverageEligibilityResponseInsuranceItemBenefit.listFieldsInOrder(fields : TStringList);
begin
  inherited listFieldsInOrder(fields);
  fields.add('type');
  fields.add('allowed[x]');
  fields.add('used[x]');
end;

function TFhirCoverageEligibilityResponseInsuranceItemBenefit.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
end;

procedure TFhirCoverageEligibilityResponseInsuranceItemBenefit.SetType_(value : TFhirCodeableConcept);
begin
  FType_.free;
  FType_ := value;
end;

procedure TFhirCoverageEligibilityResponseInsuranceItemBenefit.SetAllowed(value : TFhirDataType);
begin
  FAllowed.free;
  FAllowed := value;
end;

procedure TFhirCoverageEligibilityResponseInsuranceItemBenefit.SetUsed(value : TFhirDataType);
begin
  FUsed.free;
  FUsed := value;
end;

{ TFhirCoverageEligibilityResponseInsuranceItemBenefitListEnumerator }

constructor TFhirCoverageEligibilityResponseInsuranceItemBenefitListEnumerator.Create(list : TFhirCoverageEligibilityResponseInsuranceItemBenefitList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirCoverageEligibilityResponseInsuranceItemBenefitListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirCoverageEligibilityResponseInsuranceItemBenefitListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirCoverageEligibilityResponseInsuranceItemBenefitListEnumerator.GetCurrent : TFhirCoverageEligibilityResponseInsuranceItemBenefit;
begin
  Result := FList[FIndex];
end;

function TFhirCoverageEligibilityResponseInsuranceItemBenefitListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirCoverageEligibilityResponseInsuranceItemBenefitList }

procedure TFhirCoverageEligibilityResponseInsuranceItemBenefitList.AddItem(value: TFhirCoverageEligibilityResponseInsuranceItemBenefit);
begin
  assert(value.ClassName = 'TFhirCoverageEligibilityResponseInsuranceItemBenefit', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirCoverageEligibilityResponseInsuranceItemBenefit');
  add(value);
end;

function TFhirCoverageEligibilityResponseInsuranceItemBenefitList.Append: TFhirCoverageEligibilityResponseInsuranceItemBenefit;
begin
  result := TFhirCoverageEligibilityResponseInsuranceItemBenefit.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirCoverageEligibilityResponseInsuranceItemBenefitList.ClearItems;
begin
  Clear;
end;

function TFhirCoverageEligibilityResponseInsuranceItemBenefitList.GetEnumerator : TFhirCoverageEligibilityResponseInsuranceItemBenefitListEnumerator;
begin
  result := TFhirCoverageEligibilityResponseInsuranceItemBenefitListEnumerator.Create(self.link);
end;

function TFhirCoverageEligibilityResponseInsuranceItemBenefitList.Clone: TFhirCoverageEligibilityResponseInsuranceItemBenefitList;
begin
  result := TFhirCoverageEligibilityResponseInsuranceItemBenefitList(inherited Clone);
end;

function TFhirCoverageEligibilityResponseInsuranceItemBenefitList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirCoverageEligibilityResponseInsuranceItemBenefitList.GetItemN(index: Integer): TFhirCoverageEligibilityResponseInsuranceItemBenefit;
begin
  result := TFhirCoverageEligibilityResponseInsuranceItemBenefit(ObjectByIndex[index]);
end;

function TFhirCoverageEligibilityResponseInsuranceItemBenefitList.ItemClass: TFslObjectClass;
begin
  result := TFhirCoverageEligibilityResponseInsuranceItemBenefit;
end;
function TFhirCoverageEligibilityResponseInsuranceItemBenefitList.IndexOf(value: TFhirCoverageEligibilityResponseInsuranceItemBenefit): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirCoverageEligibilityResponseInsuranceItemBenefitList.Insert(index: Integer): TFhirCoverageEligibilityResponseInsuranceItemBenefit;
begin
  result := TFhirCoverageEligibilityResponseInsuranceItemBenefit.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirCoverageEligibilityResponseInsuranceItemBenefitList.InsertItem(index: Integer; value: TFhirCoverageEligibilityResponseInsuranceItemBenefit);
begin
  assert(value is TFhirCoverageEligibilityResponseInsuranceItemBenefit);
  Inherited Insert(index, value);
end;

function TFhirCoverageEligibilityResponseInsuranceItemBenefitList.Item(index: Integer): TFhirCoverageEligibilityResponseInsuranceItemBenefit;
begin
  result := TFhirCoverageEligibilityResponseInsuranceItemBenefit(ObjectByIndex[index]);
end;

function TFhirCoverageEligibilityResponseInsuranceItemBenefitList.Link: TFhirCoverageEligibilityResponseInsuranceItemBenefitList;
begin
  result := TFhirCoverageEligibilityResponseInsuranceItemBenefitList(inherited Link);
end;

procedure TFhirCoverageEligibilityResponseInsuranceItemBenefitList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirCoverageEligibilityResponseInsuranceItemBenefitList.SetItemByIndex(index: Integer; value: TFhirCoverageEligibilityResponseInsuranceItemBenefit);
begin
  assert(value is TFhirCoverageEligibilityResponseInsuranceItemBenefit);
  FhirCoverageEligibilityResponseInsuranceItemBenefits[index] := value;
end;

procedure TFhirCoverageEligibilityResponseInsuranceItemBenefitList.SetItemN(index: Integer; value: TFhirCoverageEligibilityResponseInsuranceItemBenefit);
begin
  assert(value is TFhirCoverageEligibilityResponseInsuranceItemBenefit);
  ObjectByIndex[index] := value;
end;

{ TFhirCoverageEligibilityResponseError }

constructor TFhirCoverageEligibilityResponseError.Create;
begin
  inherited;
end;

destructor TFhirCoverageEligibilityResponseError.Destroy;
begin
  FCode.free;
  inherited;
end;

procedure TFhirCoverageEligibilityResponseError.Assign(oSource : TFslObject);
begin
  inherited;
  code := TFhirCoverageEligibilityResponseError(oSource).code.Clone;
end;

procedure TFhirCoverageEligibilityResponseError.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'code') Then
     list.add(self.link, 'code', FCode.Link);
end;

procedure TFhirCoverageEligibilityResponseError.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'code', 'CodeableConcept', false, TFhirCodeableConcept, FCode.Link));
end;

function TFhirCoverageEligibilityResponseError.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'code') then
  begin
    Code := propValue as TFhirCodeableConcept;
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirCoverageEligibilityResponseError.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirCoverageEligibilityResponseError.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'code') then result := TFhirCodeableConcept.create()
  else result := inherited createPropertyValue(propName);
end;

function TFhirCoverageEligibilityResponseError.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'code') then result := 'CodeableConcept'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirCoverageEligibilityResponseError.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'code') then CodeElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirCoverageEligibilityResponseError.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'code') then CodeElement := new as TFhirCodeableConcept
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirCoverageEligibilityResponseError.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirCoverageEligibilityResponseError.fhirType : string;
begin
  result := 'CoverageEligibilityResponse.error';
end;

function TFhirCoverageEligibilityResponseError.Link : TFhirCoverageEligibilityResponseError;
begin
  result := TFhirCoverageEligibilityResponseError(inherited Link);
end;

function TFhirCoverageEligibilityResponseError.Clone : TFhirCoverageEligibilityResponseError;
begin
  result := TFhirCoverageEligibilityResponseError(inherited Clone);
end;

function TFhirCoverageEligibilityResponseError.equals(other : TObject) : boolean; 
var
  o : TFhirCoverageEligibilityResponseError;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirCoverageEligibilityResponseError)) then
    result := false
  else
  begin
    o := TFhirCoverageEligibilityResponseError(other);
    result := compareDeep(codeElement, o.codeElement, true);
  end;
end;

function TFhirCoverageEligibilityResponseError.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FCode);
end;

procedure TFhirCoverageEligibilityResponseError.listFieldsInOrder(fields : TStringList);
begin
  inherited listFieldsInOrder(fields);
  fields.add('code');
end;

function TFhirCoverageEligibilityResponseError.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
end;

procedure TFhirCoverageEligibilityResponseError.SetCode(value : TFhirCodeableConcept);
begin
  FCode.free;
  FCode := value;
end;

{ TFhirCoverageEligibilityResponseErrorListEnumerator }

constructor TFhirCoverageEligibilityResponseErrorListEnumerator.Create(list : TFhirCoverageEligibilityResponseErrorList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirCoverageEligibilityResponseErrorListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirCoverageEligibilityResponseErrorListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirCoverageEligibilityResponseErrorListEnumerator.GetCurrent : TFhirCoverageEligibilityResponseError;
begin
  Result := FList[FIndex];
end;

function TFhirCoverageEligibilityResponseErrorListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirCoverageEligibilityResponseErrorList }

procedure TFhirCoverageEligibilityResponseErrorList.AddItem(value: TFhirCoverageEligibilityResponseError);
begin
  assert(value.ClassName = 'TFhirCoverageEligibilityResponseError', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirCoverageEligibilityResponseError');
  add(value);
end;

function TFhirCoverageEligibilityResponseErrorList.Append: TFhirCoverageEligibilityResponseError;
begin
  result := TFhirCoverageEligibilityResponseError.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirCoverageEligibilityResponseErrorList.ClearItems;
begin
  Clear;
end;

function TFhirCoverageEligibilityResponseErrorList.GetEnumerator : TFhirCoverageEligibilityResponseErrorListEnumerator;
begin
  result := TFhirCoverageEligibilityResponseErrorListEnumerator.Create(self.link);
end;

function TFhirCoverageEligibilityResponseErrorList.Clone: TFhirCoverageEligibilityResponseErrorList;
begin
  result := TFhirCoverageEligibilityResponseErrorList(inherited Clone);
end;

function TFhirCoverageEligibilityResponseErrorList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirCoverageEligibilityResponseErrorList.GetItemN(index: Integer): TFhirCoverageEligibilityResponseError;
begin
  result := TFhirCoverageEligibilityResponseError(ObjectByIndex[index]);
end;

function TFhirCoverageEligibilityResponseErrorList.ItemClass: TFslObjectClass;
begin
  result := TFhirCoverageEligibilityResponseError;
end;
function TFhirCoverageEligibilityResponseErrorList.IndexOf(value: TFhirCoverageEligibilityResponseError): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirCoverageEligibilityResponseErrorList.Insert(index: Integer): TFhirCoverageEligibilityResponseError;
begin
  result := TFhirCoverageEligibilityResponseError.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirCoverageEligibilityResponseErrorList.InsertItem(index: Integer; value: TFhirCoverageEligibilityResponseError);
begin
  assert(value is TFhirCoverageEligibilityResponseError);
  Inherited Insert(index, value);
end;

function TFhirCoverageEligibilityResponseErrorList.Item(index: Integer): TFhirCoverageEligibilityResponseError;
begin
  result := TFhirCoverageEligibilityResponseError(ObjectByIndex[index]);
end;

function TFhirCoverageEligibilityResponseErrorList.Link: TFhirCoverageEligibilityResponseErrorList;
begin
  result := TFhirCoverageEligibilityResponseErrorList(inherited Link);
end;

procedure TFhirCoverageEligibilityResponseErrorList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirCoverageEligibilityResponseErrorList.SetItemByIndex(index: Integer; value: TFhirCoverageEligibilityResponseError);
begin
  assert(value is TFhirCoverageEligibilityResponseError);
  FhirCoverageEligibilityResponseErrors[index] := value;
end;

procedure TFhirCoverageEligibilityResponseErrorList.SetItemN(index: Integer; value: TFhirCoverageEligibilityResponseError);
begin
  assert(value is TFhirCoverageEligibilityResponseError);
  ObjectByIndex[index] := value;
end;

{ TFhirCoverageEligibilityResponse }

constructor TFhirCoverageEligibilityResponse.Create;
begin
  inherited;
end;

destructor TFhirCoverageEligibilityResponse.Destroy;
begin
  FIdentifierList.Free;
  FStatus.free;
  FPurpose.Free;
  FPatient.free;
  FServiced.free;
  FCreated.free;
  FRequestor.free;
  FRequest.free;
  FOutcome.free;
  FDisposition.free;
  FInsurer.free;
  FInsuranceList.Free;
  FPreAuthRef.free;
  FForm.free;
  FErrorList.Free;
  inherited;
end;

procedure TFhirCoverageEligibilityResponse.Assign(oSource : TFslObject);
begin
  inherited;
  if (TFhirCoverageEligibilityResponse(oSource).FIdentifierList = nil) then
  begin
    FIdentifierList.free;
    FIdentifierList := nil;
  end
  else
  begin
    if FIdentifierList = nil then
      FIdentifierList := TFhirIdentifierList.Create;
    FIdentifierList.Assign(TFhirCoverageEligibilityResponse(oSource).FIdentifierList);
  end;
  statusElement := TFhirCoverageEligibilityResponse(oSource).statusElement.Clone;
  if (TFhirCoverageEligibilityResponse(oSource).FPurpose = nil) then
  begin
    FPurpose.free;
    FPurpose := nil;
  end
  else
  begin
    FPurpose := TFhirEnumList.Create(SYSTEMS_TFhirEligibilityResponsePurposeEnum, CODES_TFhirEligibilityResponsePurposeEnum);
    FPurpose.Assign(TFhirCoverageEligibilityResponse(oSource).FPurpose);
  end;
  patient := TFhirCoverageEligibilityResponse(oSource).patient.Clone;
  serviced := TFhirCoverageEligibilityResponse(oSource).serviced.Clone;
  createdElement := TFhirCoverageEligibilityResponse(oSource).createdElement.Clone;
  requestor := TFhirCoverageEligibilityResponse(oSource).requestor.Clone;
  request := TFhirCoverageEligibilityResponse(oSource).request.Clone;
  outcomeElement := TFhirCoverageEligibilityResponse(oSource).outcomeElement.Clone;
  dispositionElement := TFhirCoverageEligibilityResponse(oSource).dispositionElement.Clone;
  insurer := TFhirCoverageEligibilityResponse(oSource).insurer.Clone;
  if (TFhirCoverageEligibilityResponse(oSource).FInsuranceList = nil) then
  begin
    FInsuranceList.free;
    FInsuranceList := nil;
  end
  else
  begin
    if FInsuranceList = nil then
      FInsuranceList := TFhirCoverageEligibilityResponseInsuranceList.Create;
    FInsuranceList.Assign(TFhirCoverageEligibilityResponse(oSource).FInsuranceList);
  end;
  preAuthRefElement := TFhirCoverageEligibilityResponse(oSource).preAuthRefElement.Clone;
  form := TFhirCoverageEligibilityResponse(oSource).form.Clone;
  if (TFhirCoverageEligibilityResponse(oSource).FErrorList = nil) then
  begin
    FErrorList.free;
    FErrorList := nil;
  end
  else
  begin
    if FErrorList = nil then
      FErrorList := TFhirCoverageEligibilityResponseErrorList.Create;
    FErrorList.Assign(TFhirCoverageEligibilityResponse(oSource).FErrorList);
  end;
end;

function TFhirCoverageEligibilityResponse.GetResourceType : TFhirResourceType;
begin
  result := frtCoverageEligibilityResponse;
end;

procedure TFhirCoverageEligibilityResponse.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'identifier') Then
    list.addAll(self, 'identifier', FIdentifierList);
  if (child_name = 'status') Then
     list.add(self.link, 'status', FStatus.Link);
  if (child_name = 'purpose') Then
     list.addAll(self, 'purpose', FPurpose);
  if (child_name = 'patient') Then
     list.add(self.link, 'patient', FPatient.Link);
  if (child_name = 'serviced[x]') or (child_name = 'serviced') Then
     list.add(self.link, 'serviced[x]', FServiced.Link);
  if (child_name = 'created') Then
     list.add(self.link, 'created', FCreated.Link);
  if (child_name = 'requestor') Then
     list.add(self.link, 'requestor', FRequestor.Link);
  if (child_name = 'request') Then
     list.add(self.link, 'request', FRequest.Link);
  if (child_name = 'outcome') Then
     list.add(self.link, 'outcome', FOutcome.Link);
  if (child_name = 'disposition') Then
     list.add(self.link, 'disposition', FDisposition.Link);
  if (child_name = 'insurer') Then
     list.add(self.link, 'insurer', FInsurer.Link);
  if (child_name = 'insurance') Then
    list.addAll(self, 'insurance', FInsuranceList);
  if (child_name = 'preAuthRef') Then
     list.add(self.link, 'preAuthRef', FPreAuthRef.Link);
  if (child_name = 'form') Then
     list.add(self.link, 'form', FForm.Link);
  if (child_name = 'error') Then
    list.addAll(self, 'error', FErrorList);
end;

procedure TFhirCoverageEligibilityResponse.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'identifier', 'Identifier', true, TFhirIdentifier, FIdentifierList.Link));
  oList.add(TFHIRProperty.create(self, 'status', 'code', false, TFhirEnum, FStatus.Link));
  oList.add(TFHIRProperty.create(self, 'purpose', 'code', true, TFhirEnum, FPurpose.Link));
  oList.add(TFHIRProperty.create(self, 'patient', 'Reference', false, TFhirReference, FPatient.Link));
  oList.add(TFHIRProperty.create(self, 'serviced[x]', 'date|Period', false, TFhirDataType, FServiced.Link));
  oList.add(TFHIRProperty.create(self, 'created', 'dateTime', false, TFhirDateTime, FCreated.Link));
  oList.add(TFHIRProperty.create(self, 'requestor', 'Reference', false, TFhirReference, FRequestor.Link));
  oList.add(TFHIRProperty.create(self, 'request', 'Reference', false, TFhirReference, FRequest.Link));
  oList.add(TFHIRProperty.create(self, 'outcome', 'code', false, TFhirEnum, FOutcome.Link));
  oList.add(TFHIRProperty.create(self, 'disposition', 'string', false, TFhirString, FDisposition.Link));
  oList.add(TFHIRProperty.create(self, 'insurer', 'Reference', false, TFhirReference, FInsurer.Link));
  oList.add(TFHIRProperty.create(self, 'insurance', 'BackboneElement', true, TFhirCoverageEligibilityResponseInsurance, FInsuranceList.Link));
  oList.add(TFHIRProperty.create(self, 'preAuthRef', 'string', false, TFhirString, FPreAuthRef.Link));
  oList.add(TFHIRProperty.create(self, 'form', 'CodeableConcept', false, TFhirCodeableConcept, FForm.Link));
  oList.add(TFHIRProperty.create(self, 'error', 'BackboneElement', true, TFhirCoverageEligibilityResponseError, FErrorList.Link));
end;

function TFhirCoverageEligibilityResponse.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'identifier') then
  begin
    IdentifierList.add(propValue as TFhirIdentifier);
    result := propValue;
  end
  else if (propName = 'status') then
  begin
    StatusElement := asEnum(SYSTEMS_TFhirFinancialResourceStatusCodesEnum, CODES_TFhirFinancialResourceStatusCodesEnum, propValue);
    result := propValue;
  end
  else if (propName = 'purpose') then
  begin
    PurposeList.add(asEnum(SYSTEMS_TFhirEligibilityResponsePurposeEnum, CODES_TFhirEligibilityResponsePurposeEnum, propValue));
    result := propValue;
  end
  else if (propName = 'patient') then
  begin
    Patient := propValue as TFhirReference;
    result := propValue;
  end
  else if (isMatchingName(propName, 'serviced', ['Date', 'Period'])) then
  begin
    Serviced := propValue as TFhirDataType;
    result := propValue;
  end
  else if (propName = 'created') then
  begin
    CreatedElement := asDateTime(propValue);
    result := propValue;
  end
  else if (propName = 'requestor') then
  begin
    Requestor := propValue as TFhirReference;
    result := propValue;
  end
  else if (propName = 'request') then
  begin
    Request := propValue as TFhirReference;
    result := propValue;
  end
  else if (propName = 'outcome') then
  begin
    OutcomeElement := asEnum(SYSTEMS_TFhirEligibilityOutcomeEnum, CODES_TFhirEligibilityOutcomeEnum, propValue);
    result := propValue;
  end
  else if (propName = 'disposition') then
  begin
    DispositionElement := asString(propValue);
    result := propValue;
  end
  else if (propName = 'insurer') then
  begin
    Insurer := propValue as TFhirReference;
    result := propValue;
  end
  else if (propName = 'insurance') then
  begin
    InsuranceList.add(propValue as TFhirCoverageEligibilityResponseInsurance);
    result := propValue;
  end
  else if (propName = 'preAuthRef') then
  begin
    PreAuthRefElement := asString(propValue);
    result := propValue;
  end
  else if (propName = 'form') then
  begin
    Form := propValue as TFhirCodeableConcept;
    result := propValue;
  end
  else if (propName = 'error') then
  begin
    ErrorList.add(propValue as TFhirCoverageEligibilityResponseError);
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirCoverageEligibilityResponse.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'identifier') then IdentifierList.insertItem(index, propValue as TFhirIdentifier)
  else if (propName = 'purpose') then FPurpose.insertItem(index, asEnum(SYSTEMS_TFhirEligibilityResponsePurposeEnum, CODES_TFhirEligibilityResponsePurposeEnum, propValue))
  else if (propName = 'insurance') then InsuranceList.insertItem(index, propValue as TFhirCoverageEligibilityResponseInsurance)
  else if (propName = 'error') then ErrorList.insertItem(index, propValue as TFhirCoverageEligibilityResponseError)
  else inherited;
end;

function TFhirCoverageEligibilityResponse.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'identifier') then result := IdentifierList.new()
  else if (propName = 'status') then result := TFhirEnum.create(SYSTEMS_TFhirFinancialResourceStatusCodesEnum[FinancialResourceStatusCodesNull], CODES_TFhirFinancialResourceStatusCodesEnum[FinancialResourceStatusCodesNull]) 
  else if (propName = 'patient') then result := TFhirReference.create()
  else if (isMatchingName(propName, 'serviced', ['Date', 'Period'])) then raise EFHIRException.create('Cannot make property Serviced')
  else if (propName = 'created') then result := TFhirDateTime.create()
  else if (propName = 'requestor') then result := TFhirReference.create()
  else if (propName = 'request') then result := TFhirReference.create()
  else if (propName = 'outcome') then result := TFhirEnum.create(SYSTEMS_TFhirEligibilityOutcomeEnum[EligibilityOutcomeNull], CODES_TFhirEligibilityOutcomeEnum[EligibilityOutcomeNull]) 
  else if (propName = 'disposition') then result := TFhirString.create()
  else if (propName = 'insurer') then result := TFhirReference.create()
  else if (propName = 'insurance') then result := InsuranceList.new()
  else if (propName = 'preAuthRef') then result := TFhirString.create()
  else if (propName = 'form') then result := TFhirCodeableConcept.create()
  else if (propName = 'error') then result := ErrorList.new()
  else result := inherited createPropertyValue(propName);
end;

function TFhirCoverageEligibilityResponse.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'identifier') then result := 'Identifier'
  else if (propName = 'status') then result := 'code'
  else if (propName = 'purpose') then result := 'code'
  else if (propName = 'patient') then result := 'Reference'
  else if (propName = 'serviced[x]') then result := 'date|Period'
  else if (propName = 'created') then result := 'dateTime'
  else if (propName = 'requestor') then result := 'Reference'
  else if (propName = 'request') then result := 'Reference'
  else if (propName = 'outcome') then result := 'code'
  else if (propName = 'disposition') then result := 'string'
  else if (propName = 'insurer') then result := 'Reference'
  else if (propName = 'insurance') then result := 'BackboneElement'
  else if (propName = 'preAuthRef') then result := 'string'
  else if (propName = 'form') then result := 'CodeableConcept'
  else if (propName = 'error') then result := 'BackboneElement'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirCoverageEligibilityResponse.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'identifier') then deletePropertyValue('identifier', IdentifierList, value)
  else if (propName = 'status') then StatusElement := nil
  else if (propName = 'patient') then PatientElement := nil
  else if (isMatchingName(propName, 'serviced', ['Date', 'Period'])) then ServicedElement := nil
  else if (propName = 'created') then CreatedElement := nil
  else if (propName = 'requestor') then RequestorElement := nil
  else if (propName = 'request') then RequestElement := nil
  else if (propName = 'outcome') then OutcomeElement := nil
  else if (propName = 'disposition') then DispositionElement := nil
  else if (propName = 'insurer') then InsurerElement := nil
  else if (propName = 'insurance') then deletePropertyValue('insurance', InsuranceList, value)
  else if (propName = 'preAuthRef') then PreAuthRefElement := nil
  else if (propName = 'form') then FormElement := nil
  else if (propName = 'error') then deletePropertyValue('error', ErrorList, value)
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirCoverageEligibilityResponse.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'identifier') then replacePropertyValue('identifier', IdentifierList, existing, new)
  else if (propName = 'status') then StatusElement := asEnum(SYSTEMS_TFhirFinancialResourceStatusCodesEnum, CODES_TFhirFinancialResourceStatusCodesEnum, new)
  else if (propName = 'patient') then PatientElement := new as TFhirReference
  else if (isMatchingName(propName, 'serviced', ['Date', 'Period'])) then ServicedElement := new as TFhirDataType
  else if (propName = 'created') then CreatedElement := asDateTime(new)
  else if (propName = 'requestor') then RequestorElement := new as TFhirReference
  else if (propName = 'request') then RequestElement := new as TFhirReference
  else if (propName = 'outcome') then OutcomeElement := asEnum(SYSTEMS_TFhirEligibilityOutcomeEnum, CODES_TFhirEligibilityOutcomeEnum, new)
  else if (propName = 'disposition') then DispositionElement := asString(new)
  else if (propName = 'insurer') then InsurerElement := new as TFhirReference
  else if (propName = 'insurance') then replacePropertyValue('insurance', InsuranceList, existing, new)
  else if (propName = 'preAuthRef') then PreAuthRefElement := asString(new)
  else if (propName = 'form') then FormElement := new as TFhirCodeableConcept
  else if (propName = 'error') then replacePropertyValue('error', ErrorList, existing, new)
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirCoverageEligibilityResponse.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'identifier') then IdentifierList.move(source, destination)
  else if (propName = 'purpose') then FPurpose.move(source, destination)
  else if (propName = 'insurance') then InsuranceList.move(source, destination)
  else if (propName = 'error') then ErrorList.move(source, destination)
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirCoverageEligibilityResponse.fhirType : string;
begin
  result := 'CoverageEligibilityResponse';
end;

function TFhirCoverageEligibilityResponse.Link : TFhirCoverageEligibilityResponse;
begin
  result := TFhirCoverageEligibilityResponse(inherited Link);
end;

function TFhirCoverageEligibilityResponse.Clone : TFhirCoverageEligibilityResponse;
begin
  result := TFhirCoverageEligibilityResponse(inherited Clone);
end;

function TFhirCoverageEligibilityResponse.equals(other : TObject) : boolean; 
var
  o : TFhirCoverageEligibilityResponse;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirCoverageEligibilityResponse)) then
    result := false
  else
  begin
    o := TFhirCoverageEligibilityResponse(other);
    result := compareDeep(identifierList, o.identifierList, true) and compareDeep(statusElement, o.statusElement, true) and 
      compareDeep(purposeList, o.purposeList, true) and compareDeep(patientElement, o.patientElement, true) and 
      compareDeep(servicedElement, o.servicedElement, true) and compareDeep(createdElement, o.createdElement, true) and 
      compareDeep(requestorElement, o.requestorElement, true) and compareDeep(requestElement, o.requestElement, true) and 
      compareDeep(outcomeElement, o.outcomeElement, true) and compareDeep(dispositionElement, o.dispositionElement, true) and 
      compareDeep(insurerElement, o.insurerElement, true) and compareDeep(insuranceList, o.insuranceList, true) and 
      compareDeep(preAuthRefElement, o.preAuthRefElement, true) and compareDeep(formElement, o.formElement, true) and 
      compareDeep(errorList, o.errorList, true);
  end;
end;

function TFhirCoverageEligibilityResponse.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FidentifierList) and isEmptyProp(FStatus) and isEmptyProp(FPurpose) and isEmptyProp(FPatient) and isEmptyProp(FServiced) and isEmptyProp(FCreated) and isEmptyProp(FRequestor) and isEmptyProp(FRequest) and isEmptyProp(FOutcome) and isEmptyProp(FDisposition) and isEmptyProp(FInsurer) and isEmptyProp(FinsuranceList) and isEmptyProp(FPreAuthRef) and isEmptyProp(FForm) and isEmptyProp(FerrorList);
end;

procedure TFhirCoverageEligibilityResponse.listFieldsInOrder(fields : TStringList);
begin
  inherited listFieldsInOrder(fields);
  fields.add('identifier');
  fields.add('status');
  fields.add('purpose');
  fields.add('patient');
  fields.add('serviced[x]');
  fields.add('created');
  fields.add('requestor');
  fields.add('request');
  fields.add('outcome');
  fields.add('disposition');
  fields.add('insurer');
  fields.add('insurance');
  fields.add('preAuthRef');
  fields.add('form');
  fields.add('error');
end;

function TFhirCoverageEligibilityResponse.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FIdentifierList.sizeInBytes(magic));
  inc(result, FPurpose.sizeInBytes(magic));
  inc(result, FInsuranceList.sizeInBytes(magic));
  inc(result, FErrorList.sizeInBytes(magic));
end;

function TFhirCoverageEligibilityResponse.GetIdentifierList : TFhirIdentifierList;
begin
  if FIdentifierList = nil then
    FIdentifierList := TFhirIdentifierList.Create;
  result := FIdentifierList;
end;

function TFhirCoverageEligibilityResponse.GetHasIdentifierList : boolean;
begin
  result := (FIdentifierList <> nil) and (FIdentifierList.count > 0);
end;

procedure TFhirCoverageEligibilityResponse.SetStatus(value : TFhirEnum);
begin
  FStatus.free;
  FStatus := value;
end;

function TFhirCoverageEligibilityResponse.GetStatusST : TFhirFinancialResourceStatusCodesEnum;
begin
  if FStatus = nil then
    result := TFhirFinancialResourceStatusCodesEnum(0)
  else
    result := TFhirFinancialResourceStatusCodesEnum(StringArrayIndexOfSensitive(CODES_TFhirFinancialResourceStatusCodesEnum, FStatus.value));
end;

procedure TFhirCoverageEligibilityResponse.SetStatusST(value : TFhirFinancialResourceStatusCodesEnum);
begin
  if ord(value) = 0 then
    StatusElement := nil
  else
    StatusElement := TFhirEnum.create(SYSTEMS_TFhirFinancialResourceStatusCodesEnum[value], CODES_TFhirFinancialResourceStatusCodesEnum[value]);
end;

function TFhirCoverageEligibilityResponse.GetPurpose : TFhirEnumList;
begin
  if FPurpose = nil then
    FPurpose := TFhirEnumList.Create(SYSTEMS_TFhirEligibilityResponsePurposeEnum, CODES_TFhirEligibilityResponsePurposeEnum);
  result := FPurpose;
end;

function TFhirCoverageEligibilityResponse.GetHasPurpose : boolean;
begin
  result := (FPurpose <> nil) and (FPurpose.count > 0);
end;

function TFhirCoverageEligibilityResponse.GetPurposeST : TFhirEligibilityResponsePurposeEnumList;
  var i : integer;
begin
  result := [];
  if Fpurpose <> nil then
    for i := 0 to Fpurpose.count - 1 do
      result := result + [TFhirEligibilityResponsePurposeEnum(StringArrayIndexOfSensitive(CODES_TFhirEligibilityResponsePurposeEnum, Fpurpose[i].value))];
end;

procedure TFhirCoverageEligibilityResponse.SetPurposeST(value : TFhirEligibilityResponsePurposeEnumList);
var a : TFhirEligibilityResponsePurposeEnum;
begin
  if Fpurpose = nil then
    Fpurpose := TFhirEnumList.create(SYSTEMS_TFhirEligibilityResponsePurposeEnum, CODES_TFhirEligibilityResponsePurposeEnum);
  Fpurpose.clear;
  for a := low(TFhirEligibilityResponsePurposeEnum) to high(TFhirEligibilityResponsePurposeEnum) do
    if a in value then
      begin
         if Fpurpose = nil then
           Fpurpose := TFhirEnumList.create(SYSTEMS_TFhirEligibilityResponsePurposeEnum, CODES_TFhirEligibilityResponsePurposeEnum);
         Fpurpose.add(TFhirEnum.create(SYSTEMS_TFhirEligibilityResponsePurposeEnum[a], CODES_TFhirEligibilityResponsePurposeEnum[a]));
      end;
end;

procedure TFhirCoverageEligibilityResponse.SetPatient(value : TFhirReference);
begin
  FPatient.free;
  FPatient := value;
end;

procedure TFhirCoverageEligibilityResponse.SetServiced(value : TFhirDataType);
begin
  FServiced.free;
  FServiced := value;
end;

procedure TFhirCoverageEligibilityResponse.SetCreated(value : TFhirDateTime);
begin
  FCreated.free;
  FCreated := value;
end;

function TFhirCoverageEligibilityResponse.GetCreatedST : TFslDateTime;
begin
  if FCreated = nil then
    result := TFslDateTime.makeNull
  else
    result := FCreated.value;
end;

procedure TFhirCoverageEligibilityResponse.SetCreatedST(value : TFslDateTime);
begin
  if FCreated = nil then
    FCreated := TFhirDateTime.create;
  FCreated.value := value
end;

procedure TFhirCoverageEligibilityResponse.SetRequestor(value : TFhirReference);
begin
  FRequestor.free;
  FRequestor := value;
end;

procedure TFhirCoverageEligibilityResponse.SetRequest(value : TFhirReference);
begin
  FRequest.free;
  FRequest := value;
end;

procedure TFhirCoverageEligibilityResponse.SetOutcome(value : TFhirEnum);
begin
  FOutcome.free;
  FOutcome := value;
end;

function TFhirCoverageEligibilityResponse.GetOutcomeST : TFhirEligibilityOutcomeEnum;
begin
  if FOutcome = nil then
    result := TFhirEligibilityOutcomeEnum(0)
  else
    result := TFhirEligibilityOutcomeEnum(StringArrayIndexOfSensitive(CODES_TFhirEligibilityOutcomeEnum, FOutcome.value));
end;

procedure TFhirCoverageEligibilityResponse.SetOutcomeST(value : TFhirEligibilityOutcomeEnum);
begin
  if ord(value) = 0 then
    OutcomeElement := nil
  else
    OutcomeElement := TFhirEnum.create(SYSTEMS_TFhirEligibilityOutcomeEnum[value], CODES_TFhirEligibilityOutcomeEnum[value]);
end;

procedure TFhirCoverageEligibilityResponse.SetDisposition(value : TFhirString);
begin
  FDisposition.free;
  FDisposition := value;
end;

function TFhirCoverageEligibilityResponse.GetDispositionST : String;
begin
  if FDisposition = nil then
    result := ''
  else
    result := FDisposition.value;
end;

procedure TFhirCoverageEligibilityResponse.SetDispositionST(value : String);
begin
  if value <> '' then
  begin
    if FDisposition = nil then
      FDisposition := TFhirString.create;
    FDisposition.value := value
  end
  else if FDisposition <> nil then
    FDisposition.value := '';
end;

procedure TFhirCoverageEligibilityResponse.SetInsurer(value : TFhirReference);
begin
  FInsurer.free;
  FInsurer := value;
end;

function TFhirCoverageEligibilityResponse.GetInsuranceList : TFhirCoverageEligibilityResponseInsuranceList;
begin
  if FInsuranceList = nil then
    FInsuranceList := TFhirCoverageEligibilityResponseInsuranceList.Create;
  result := FInsuranceList;
end;

function TFhirCoverageEligibilityResponse.GetHasInsuranceList : boolean;
begin
  result := (FInsuranceList <> nil) and (FInsuranceList.count > 0);
end;

procedure TFhirCoverageEligibilityResponse.SetPreAuthRef(value : TFhirString);
begin
  FPreAuthRef.free;
  FPreAuthRef := value;
end;

function TFhirCoverageEligibilityResponse.GetPreAuthRefST : String;
begin
  if FPreAuthRef = nil then
    result := ''
  else
    result := FPreAuthRef.value;
end;

procedure TFhirCoverageEligibilityResponse.SetPreAuthRefST(value : String);
begin
  if value <> '' then
  begin
    if FPreAuthRef = nil then
      FPreAuthRef := TFhirString.create;
    FPreAuthRef.value := value
  end
  else if FPreAuthRef <> nil then
    FPreAuthRef.value := '';
end;

procedure TFhirCoverageEligibilityResponse.SetForm(value : TFhirCodeableConcept);
begin
  FForm.free;
  FForm := value;
end;

function TFhirCoverageEligibilityResponse.GetErrorList : TFhirCoverageEligibilityResponseErrorList;
begin
  if FErrorList = nil then
    FErrorList := TFhirCoverageEligibilityResponseErrorList.Create;
  result := FErrorList;
end;

function TFhirCoverageEligibilityResponse.GetHasErrorList : boolean;
begin
  result := (FErrorList <> nil) and (FErrorList.count > 0);
end;

{ TFhirCoverageEligibilityResponseListEnumerator }

constructor TFhirCoverageEligibilityResponseListEnumerator.Create(list : TFhirCoverageEligibilityResponseList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirCoverageEligibilityResponseListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirCoverageEligibilityResponseListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirCoverageEligibilityResponseListEnumerator.GetCurrent : TFhirCoverageEligibilityResponse;
begin
  Result := FList[FIndex];
end;

function TFhirCoverageEligibilityResponseListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirCoverageEligibilityResponseList }

procedure TFhirCoverageEligibilityResponseList.AddItem(value: TFhirCoverageEligibilityResponse);
begin
  assert(value.ClassName = 'TFhirCoverageEligibilityResponse', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirCoverageEligibilityResponse');
  add(value);
end;

function TFhirCoverageEligibilityResponseList.Append: TFhirCoverageEligibilityResponse;
begin
  result := TFhirCoverageEligibilityResponse.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirCoverageEligibilityResponseList.ClearItems;
begin
  Clear;
end;

function TFhirCoverageEligibilityResponseList.GetEnumerator : TFhirCoverageEligibilityResponseListEnumerator;
begin
  result := TFhirCoverageEligibilityResponseListEnumerator.Create(self.link);
end;

function TFhirCoverageEligibilityResponseList.Clone: TFhirCoverageEligibilityResponseList;
begin
  result := TFhirCoverageEligibilityResponseList(inherited Clone);
end;

function TFhirCoverageEligibilityResponseList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirCoverageEligibilityResponseList.GetItemN(index: Integer): TFhirCoverageEligibilityResponse;
begin
  result := TFhirCoverageEligibilityResponse(ObjectByIndex[index]);
end;

function TFhirCoverageEligibilityResponseList.ItemClass: TFslObjectClass;
begin
  result := TFhirCoverageEligibilityResponse;
end;
function TFhirCoverageEligibilityResponseList.IndexOf(value: TFhirCoverageEligibilityResponse): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirCoverageEligibilityResponseList.Insert(index: Integer): TFhirCoverageEligibilityResponse;
begin
  result := TFhirCoverageEligibilityResponse.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirCoverageEligibilityResponseList.InsertItem(index: Integer; value: TFhirCoverageEligibilityResponse);
begin
  assert(value is TFhirCoverageEligibilityResponse);
  Inherited Insert(index, value);
end;

function TFhirCoverageEligibilityResponseList.Item(index: Integer): TFhirCoverageEligibilityResponse;
begin
  result := TFhirCoverageEligibilityResponse(ObjectByIndex[index]);
end;

function TFhirCoverageEligibilityResponseList.Link: TFhirCoverageEligibilityResponseList;
begin
  result := TFhirCoverageEligibilityResponseList(inherited Link);
end;

procedure TFhirCoverageEligibilityResponseList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirCoverageEligibilityResponseList.SetItemByIndex(index: Integer; value: TFhirCoverageEligibilityResponse);
begin
  assert(value is TFhirCoverageEligibilityResponse);
  FhirCoverageEligibilityResponses[index] := value;
end;

procedure TFhirCoverageEligibilityResponseList.SetItemN(index: Integer; value: TFhirCoverageEligibilityResponse);
begin
  assert(value is TFhirCoverageEligibilityResponse);
  ObjectByIndex[index] := value;
end;

{$ENDIF FHIR_COVERAGEELIGIBILITYRESPONSE}
{$IFDEF FHIR_ENROLLMENTREQUEST}
{ TFhirEnrollmentRequest }

constructor TFhirEnrollmentRequest.Create;
begin
  inherited;
end;

destructor TFhirEnrollmentRequest.Destroy;
begin
  FIdentifierList.Free;
  FStatus.free;
  FCreated.free;
  FInsurer.free;
  FProvider.free;
  FCandidate.free;
  FCoverage.free;
  inherited;
end;

procedure TFhirEnrollmentRequest.Assign(oSource : TFslObject);
begin
  inherited;
  if (TFhirEnrollmentRequest(oSource).FIdentifierList = nil) then
  begin
    FIdentifierList.free;
    FIdentifierList := nil;
  end
  else
  begin
    if FIdentifierList = nil then
      FIdentifierList := TFhirIdentifierList.Create;
    FIdentifierList.Assign(TFhirEnrollmentRequest(oSource).FIdentifierList);
  end;
  statusElement := TFhirEnrollmentRequest(oSource).statusElement.Clone;
  createdElement := TFhirEnrollmentRequest(oSource).createdElement.Clone;
  insurer := TFhirEnrollmentRequest(oSource).insurer.Clone;
  provider := TFhirEnrollmentRequest(oSource).provider.Clone;
  candidate := TFhirEnrollmentRequest(oSource).candidate.Clone;
  coverage := TFhirEnrollmentRequest(oSource).coverage.Clone;
end;

function TFhirEnrollmentRequest.GetResourceType : TFhirResourceType;
begin
  result := frtEnrollmentRequest;
end;

procedure TFhirEnrollmentRequest.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'identifier') Then
    list.addAll(self, 'identifier', FIdentifierList);
  if (child_name = 'status') Then
     list.add(self.link, 'status', FStatus.Link);
  if (child_name = 'created') Then
     list.add(self.link, 'created', FCreated.Link);
  if (child_name = 'insurer') Then
     list.add(self.link, 'insurer', FInsurer.Link);
  if (child_name = 'provider') Then
     list.add(self.link, 'provider', FProvider.Link);
  if (child_name = 'candidate') Then
     list.add(self.link, 'candidate', FCandidate.Link);
  if (child_name = 'coverage') Then
     list.add(self.link, 'coverage', FCoverage.Link);
end;

procedure TFhirEnrollmentRequest.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'identifier', 'Identifier', true, TFhirIdentifier, FIdentifierList.Link));
  oList.add(TFHIRProperty.create(self, 'status', 'code', false, TFhirEnum, FStatus.Link));
  oList.add(TFHIRProperty.create(self, 'created', 'dateTime', false, TFhirDateTime, FCreated.Link));
  oList.add(TFHIRProperty.create(self, 'insurer', 'Reference', false, TFhirReference, FInsurer.Link));
  oList.add(TFHIRProperty.create(self, 'provider', 'Reference', false, TFhirReference, FProvider.Link));
  oList.add(TFHIRProperty.create(self, 'candidate', 'Reference', false, TFhirReference, FCandidate.Link));
  oList.add(TFHIRProperty.create(self, 'coverage', 'Reference', false, TFhirReference, FCoverage.Link));
end;

function TFhirEnrollmentRequest.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'identifier') then
  begin
    IdentifierList.add(propValue as TFhirIdentifier);
    result := propValue;
  end
  else if (propName = 'status') then
  begin
    StatusElement := asEnum(SYSTEMS_TFhirFinancialResourceStatusCodesEnum, CODES_TFhirFinancialResourceStatusCodesEnum, propValue);
    result := propValue;
  end
  else if (propName = 'created') then
  begin
    CreatedElement := asDateTime(propValue);
    result := propValue;
  end
  else if (propName = 'insurer') then
  begin
    Insurer := propValue as TFhirReference;
    result := propValue;
  end
  else if (propName = 'provider') then
  begin
    Provider := propValue as TFhirReference;
    result := propValue;
  end
  else if (propName = 'candidate') then
  begin
    Candidate := propValue as TFhirReference;
    result := propValue;
  end
  else if (propName = 'coverage') then
  begin
    Coverage := propValue as TFhirReference;
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirEnrollmentRequest.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'identifier') then IdentifierList.insertItem(index, propValue as TFhirIdentifier)
  else inherited;
end;

function TFhirEnrollmentRequest.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'identifier') then result := IdentifierList.new()
  else if (propName = 'status') then result := TFhirEnum.create(SYSTEMS_TFhirFinancialResourceStatusCodesEnum[FinancialResourceStatusCodesNull], CODES_TFhirFinancialResourceStatusCodesEnum[FinancialResourceStatusCodesNull]) 
  else if (propName = 'created') then result := TFhirDateTime.create()
  else if (propName = 'insurer') then result := TFhirReference.create()
  else if (propName = 'provider') then result := TFhirReference.create()
  else if (propName = 'candidate') then result := TFhirReference.create()
  else if (propName = 'coverage') then result := TFhirReference.create()
  else result := inherited createPropertyValue(propName);
end;

function TFhirEnrollmentRequest.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'identifier') then result := 'Identifier'
  else if (propName = 'status') then result := 'code'
  else if (propName = 'created') then result := 'dateTime'
  else if (propName = 'insurer') then result := 'Reference'
  else if (propName = 'provider') then result := 'Reference'
  else if (propName = 'candidate') then result := 'Reference'
  else if (propName = 'coverage') then result := 'Reference'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirEnrollmentRequest.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'identifier') then deletePropertyValue('identifier', IdentifierList, value)
  else if (propName = 'status') then StatusElement := nil
  else if (propName = 'created') then CreatedElement := nil
  else if (propName = 'insurer') then InsurerElement := nil
  else if (propName = 'provider') then ProviderElement := nil
  else if (propName = 'candidate') then CandidateElement := nil
  else if (propName = 'coverage') then CoverageElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirEnrollmentRequest.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'identifier') then replacePropertyValue('identifier', IdentifierList, existing, new)
  else if (propName = 'status') then StatusElement := asEnum(SYSTEMS_TFhirFinancialResourceStatusCodesEnum, CODES_TFhirFinancialResourceStatusCodesEnum, new)
  else if (propName = 'created') then CreatedElement := asDateTime(new)
  else if (propName = 'insurer') then InsurerElement := new as TFhirReference
  else if (propName = 'provider') then ProviderElement := new as TFhirReference
  else if (propName = 'candidate') then CandidateElement := new as TFhirReference
  else if (propName = 'coverage') then CoverageElement := new as TFhirReference
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirEnrollmentRequest.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'identifier') then IdentifierList.move(source, destination)
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirEnrollmentRequest.fhirType : string;
begin
  result := 'EnrollmentRequest';
end;

function TFhirEnrollmentRequest.Link : TFhirEnrollmentRequest;
begin
  result := TFhirEnrollmentRequest(inherited Link);
end;

function TFhirEnrollmentRequest.Clone : TFhirEnrollmentRequest;
begin
  result := TFhirEnrollmentRequest(inherited Clone);
end;

function TFhirEnrollmentRequest.equals(other : TObject) : boolean; 
var
  o : TFhirEnrollmentRequest;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirEnrollmentRequest)) then
    result := false
  else
  begin
    o := TFhirEnrollmentRequest(other);
    result := compareDeep(identifierList, o.identifierList, true) and compareDeep(statusElement, o.statusElement, true) and 
      compareDeep(createdElement, o.createdElement, true) and compareDeep(insurerElement, o.insurerElement, true) and 
      compareDeep(providerElement, o.providerElement, true) and compareDeep(candidateElement, o.candidateElement, true) and 
      compareDeep(coverageElement, o.coverageElement, true);
  end;
end;

function TFhirEnrollmentRequest.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FidentifierList) and isEmptyProp(FStatus) and isEmptyProp(FCreated) and isEmptyProp(FInsurer) and isEmptyProp(FProvider) and isEmptyProp(FCandidate) and isEmptyProp(FCoverage);
end;

procedure TFhirEnrollmentRequest.listFieldsInOrder(fields : TStringList);
begin
  inherited listFieldsInOrder(fields);
  fields.add('identifier');
  fields.add('status');
  fields.add('created');
  fields.add('insurer');
  fields.add('provider');
  fields.add('candidate');
  fields.add('coverage');
end;

function TFhirEnrollmentRequest.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FIdentifierList.sizeInBytes(magic));
end;

function TFhirEnrollmentRequest.GetIdentifierList : TFhirIdentifierList;
begin
  if FIdentifierList = nil then
    FIdentifierList := TFhirIdentifierList.Create;
  result := FIdentifierList;
end;

function TFhirEnrollmentRequest.GetHasIdentifierList : boolean;
begin
  result := (FIdentifierList <> nil) and (FIdentifierList.count > 0);
end;

procedure TFhirEnrollmentRequest.SetStatus(value : TFhirEnum);
begin
  FStatus.free;
  FStatus := value;
end;

function TFhirEnrollmentRequest.GetStatusST : TFhirFinancialResourceStatusCodesEnum;
begin
  if FStatus = nil then
    result := TFhirFinancialResourceStatusCodesEnum(0)
  else
    result := TFhirFinancialResourceStatusCodesEnum(StringArrayIndexOfSensitive(CODES_TFhirFinancialResourceStatusCodesEnum, FStatus.value));
end;

procedure TFhirEnrollmentRequest.SetStatusST(value : TFhirFinancialResourceStatusCodesEnum);
begin
  if ord(value) = 0 then
    StatusElement := nil
  else
    StatusElement := TFhirEnum.create(SYSTEMS_TFhirFinancialResourceStatusCodesEnum[value], CODES_TFhirFinancialResourceStatusCodesEnum[value]);
end;

procedure TFhirEnrollmentRequest.SetCreated(value : TFhirDateTime);
begin
  FCreated.free;
  FCreated := value;
end;

function TFhirEnrollmentRequest.GetCreatedST : TFslDateTime;
begin
  if FCreated = nil then
    result := TFslDateTime.makeNull
  else
    result := FCreated.value;
end;

procedure TFhirEnrollmentRequest.SetCreatedST(value : TFslDateTime);
begin
  if FCreated = nil then
    FCreated := TFhirDateTime.create;
  FCreated.value := value
end;

procedure TFhirEnrollmentRequest.SetInsurer(value : TFhirReference);
begin
  FInsurer.free;
  FInsurer := value;
end;

procedure TFhirEnrollmentRequest.SetProvider(value : TFhirReference);
begin
  FProvider.free;
  FProvider := value;
end;

procedure TFhirEnrollmentRequest.SetCandidate(value : TFhirReference);
begin
  FCandidate.free;
  FCandidate := value;
end;

procedure TFhirEnrollmentRequest.SetCoverage(value : TFhirReference);
begin
  FCoverage.free;
  FCoverage := value;
end;

{ TFhirEnrollmentRequestListEnumerator }

constructor TFhirEnrollmentRequestListEnumerator.Create(list : TFhirEnrollmentRequestList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirEnrollmentRequestListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirEnrollmentRequestListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirEnrollmentRequestListEnumerator.GetCurrent : TFhirEnrollmentRequest;
begin
  Result := FList[FIndex];
end;

function TFhirEnrollmentRequestListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirEnrollmentRequestList }

procedure TFhirEnrollmentRequestList.AddItem(value: TFhirEnrollmentRequest);
begin
  assert(value.ClassName = 'TFhirEnrollmentRequest', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirEnrollmentRequest');
  add(value);
end;

function TFhirEnrollmentRequestList.Append: TFhirEnrollmentRequest;
begin
  result := TFhirEnrollmentRequest.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirEnrollmentRequestList.ClearItems;
begin
  Clear;
end;

function TFhirEnrollmentRequestList.GetEnumerator : TFhirEnrollmentRequestListEnumerator;
begin
  result := TFhirEnrollmentRequestListEnumerator.Create(self.link);
end;

function TFhirEnrollmentRequestList.Clone: TFhirEnrollmentRequestList;
begin
  result := TFhirEnrollmentRequestList(inherited Clone);
end;

function TFhirEnrollmentRequestList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirEnrollmentRequestList.GetItemN(index: Integer): TFhirEnrollmentRequest;
begin
  result := TFhirEnrollmentRequest(ObjectByIndex[index]);
end;

function TFhirEnrollmentRequestList.ItemClass: TFslObjectClass;
begin
  result := TFhirEnrollmentRequest;
end;
function TFhirEnrollmentRequestList.IndexOf(value: TFhirEnrollmentRequest): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirEnrollmentRequestList.Insert(index: Integer): TFhirEnrollmentRequest;
begin
  result := TFhirEnrollmentRequest.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirEnrollmentRequestList.InsertItem(index: Integer; value: TFhirEnrollmentRequest);
begin
  assert(value is TFhirEnrollmentRequest);
  Inherited Insert(index, value);
end;

function TFhirEnrollmentRequestList.Item(index: Integer): TFhirEnrollmentRequest;
begin
  result := TFhirEnrollmentRequest(ObjectByIndex[index]);
end;

function TFhirEnrollmentRequestList.Link: TFhirEnrollmentRequestList;
begin
  result := TFhirEnrollmentRequestList(inherited Link);
end;

procedure TFhirEnrollmentRequestList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirEnrollmentRequestList.SetItemByIndex(index: Integer; value: TFhirEnrollmentRequest);
begin
  assert(value is TFhirEnrollmentRequest);
  FhirEnrollmentRequests[index] := value;
end;

procedure TFhirEnrollmentRequestList.SetItemN(index: Integer; value: TFhirEnrollmentRequest);
begin
  assert(value is TFhirEnrollmentRequest);
  ObjectByIndex[index] := value;
end;

{$ENDIF FHIR_ENROLLMENTREQUEST}
{$IFDEF FHIR_ENROLLMENTRESPONSE}
{ TFhirEnrollmentResponse }

constructor TFhirEnrollmentResponse.Create;
begin
  inherited;
end;

destructor TFhirEnrollmentResponse.Destroy;
begin
  FIdentifierList.Free;
  FStatus.free;
  FRequest.free;
  FOutcome.free;
  FDisposition.free;
  FCreated.free;
  FOrganization.free;
  FRequestProvider.free;
  inherited;
end;

procedure TFhirEnrollmentResponse.Assign(oSource : TFslObject);
begin
  inherited;
  if (TFhirEnrollmentResponse(oSource).FIdentifierList = nil) then
  begin
    FIdentifierList.free;
    FIdentifierList := nil;
  end
  else
  begin
    if FIdentifierList = nil then
      FIdentifierList := TFhirIdentifierList.Create;
    FIdentifierList.Assign(TFhirEnrollmentResponse(oSource).FIdentifierList);
  end;
  statusElement := TFhirEnrollmentResponse(oSource).statusElement.Clone;
  request := TFhirEnrollmentResponse(oSource).request.Clone;
  outcomeElement := TFhirEnrollmentResponse(oSource).outcomeElement.Clone;
  dispositionElement := TFhirEnrollmentResponse(oSource).dispositionElement.Clone;
  createdElement := TFhirEnrollmentResponse(oSource).createdElement.Clone;
  organization := TFhirEnrollmentResponse(oSource).organization.Clone;
  requestProvider := TFhirEnrollmentResponse(oSource).requestProvider.Clone;
end;

function TFhirEnrollmentResponse.GetResourceType : TFhirResourceType;
begin
  result := frtEnrollmentResponse;
end;

procedure TFhirEnrollmentResponse.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'identifier') Then
    list.addAll(self, 'identifier', FIdentifierList);
  if (child_name = 'status') Then
     list.add(self.link, 'status', FStatus.Link);
  if (child_name = 'request') Then
     list.add(self.link, 'request', FRequest.Link);
  if (child_name = 'outcome') Then
     list.add(self.link, 'outcome', FOutcome.Link);
  if (child_name = 'disposition') Then
     list.add(self.link, 'disposition', FDisposition.Link);
  if (child_name = 'created') Then
     list.add(self.link, 'created', FCreated.Link);
  if (child_name = 'organization') Then
     list.add(self.link, 'organization', FOrganization.Link);
  if (child_name = 'requestProvider') Then
     list.add(self.link, 'requestProvider', FRequestProvider.Link);
end;

procedure TFhirEnrollmentResponse.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'identifier', 'Identifier', true, TFhirIdentifier, FIdentifierList.Link));
  oList.add(TFHIRProperty.create(self, 'status', 'code', false, TFhirEnum, FStatus.Link));
  oList.add(TFHIRProperty.create(self, 'request', 'Reference', false, TFhirReference, FRequest.Link));
  oList.add(TFHIRProperty.create(self, 'outcome', 'code', false, TFhirEnum, FOutcome.Link));
  oList.add(TFHIRProperty.create(self, 'disposition', 'string', false, TFhirString, FDisposition.Link));
  oList.add(TFHIRProperty.create(self, 'created', 'dateTime', false, TFhirDateTime, FCreated.Link));
  oList.add(TFHIRProperty.create(self, 'organization', 'Reference', false, TFhirReference, FOrganization.Link));
  oList.add(TFHIRProperty.create(self, 'requestProvider', 'Reference', false, TFhirReference, FRequestProvider.Link));
end;

function TFhirEnrollmentResponse.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'identifier') then
  begin
    IdentifierList.add(propValue as TFhirIdentifier);
    result := propValue;
  end
  else if (propName = 'status') then
  begin
    StatusElement := asEnum(SYSTEMS_TFhirFinancialResourceStatusCodesEnum, CODES_TFhirFinancialResourceStatusCodesEnum, propValue);
    result := propValue;
  end
  else if (propName = 'request') then
  begin
    Request := propValue as TFhirReference;
    result := propValue;
  end
  else if (propName = 'outcome') then
  begin
    OutcomeElement := asEnum(SYSTEMS_TFhirEnrollmentOutcomeEnum, CODES_TFhirEnrollmentOutcomeEnum, propValue);
    result := propValue;
  end
  else if (propName = 'disposition') then
  begin
    DispositionElement := asString(propValue);
    result := propValue;
  end
  else if (propName = 'created') then
  begin
    CreatedElement := asDateTime(propValue);
    result := propValue;
  end
  else if (propName = 'organization') then
  begin
    Organization := propValue as TFhirReference;
    result := propValue;
  end
  else if (propName = 'requestProvider') then
  begin
    RequestProvider := propValue as TFhirReference;
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirEnrollmentResponse.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'identifier') then IdentifierList.insertItem(index, propValue as TFhirIdentifier)
  else inherited;
end;

function TFhirEnrollmentResponse.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'identifier') then result := IdentifierList.new()
  else if (propName = 'status') then result := TFhirEnum.create(SYSTEMS_TFhirFinancialResourceStatusCodesEnum[FinancialResourceStatusCodesNull], CODES_TFhirFinancialResourceStatusCodesEnum[FinancialResourceStatusCodesNull]) 
  else if (propName = 'request') then result := TFhirReference.create()
  else if (propName = 'outcome') then result := TFhirEnum.create(SYSTEMS_TFhirEnrollmentOutcomeEnum[EnrollmentOutcomeNull], CODES_TFhirEnrollmentOutcomeEnum[EnrollmentOutcomeNull]) 
  else if (propName = 'disposition') then result := TFhirString.create()
  else if (propName = 'created') then result := TFhirDateTime.create()
  else if (propName = 'organization') then result := TFhirReference.create()
  else if (propName = 'requestProvider') then result := TFhirReference.create()
  else result := inherited createPropertyValue(propName);
end;

function TFhirEnrollmentResponse.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'identifier') then result := 'Identifier'
  else if (propName = 'status') then result := 'code'
  else if (propName = 'request') then result := 'Reference'
  else if (propName = 'outcome') then result := 'code'
  else if (propName = 'disposition') then result := 'string'
  else if (propName = 'created') then result := 'dateTime'
  else if (propName = 'organization') then result := 'Reference'
  else if (propName = 'requestProvider') then result := 'Reference'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirEnrollmentResponse.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'identifier') then deletePropertyValue('identifier', IdentifierList, value)
  else if (propName = 'status') then StatusElement := nil
  else if (propName = 'request') then RequestElement := nil
  else if (propName = 'outcome') then OutcomeElement := nil
  else if (propName = 'disposition') then DispositionElement := nil
  else if (propName = 'created') then CreatedElement := nil
  else if (propName = 'organization') then OrganizationElement := nil
  else if (propName = 'requestProvider') then RequestProviderElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirEnrollmentResponse.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'identifier') then replacePropertyValue('identifier', IdentifierList, existing, new)
  else if (propName = 'status') then StatusElement := asEnum(SYSTEMS_TFhirFinancialResourceStatusCodesEnum, CODES_TFhirFinancialResourceStatusCodesEnum, new)
  else if (propName = 'request') then RequestElement := new as TFhirReference
  else if (propName = 'outcome') then OutcomeElement := asEnum(SYSTEMS_TFhirEnrollmentOutcomeEnum, CODES_TFhirEnrollmentOutcomeEnum, new)
  else if (propName = 'disposition') then DispositionElement := asString(new)
  else if (propName = 'created') then CreatedElement := asDateTime(new)
  else if (propName = 'organization') then OrganizationElement := new as TFhirReference
  else if (propName = 'requestProvider') then RequestProviderElement := new as TFhirReference
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirEnrollmentResponse.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'identifier') then IdentifierList.move(source, destination)
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirEnrollmentResponse.fhirType : string;
begin
  result := 'EnrollmentResponse';
end;

function TFhirEnrollmentResponse.Link : TFhirEnrollmentResponse;
begin
  result := TFhirEnrollmentResponse(inherited Link);
end;

function TFhirEnrollmentResponse.Clone : TFhirEnrollmentResponse;
begin
  result := TFhirEnrollmentResponse(inherited Clone);
end;

function TFhirEnrollmentResponse.equals(other : TObject) : boolean; 
var
  o : TFhirEnrollmentResponse;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirEnrollmentResponse)) then
    result := false
  else
  begin
    o := TFhirEnrollmentResponse(other);
    result := compareDeep(identifierList, o.identifierList, true) and compareDeep(statusElement, o.statusElement, true) and 
      compareDeep(requestElement, o.requestElement, true) and compareDeep(outcomeElement, o.outcomeElement, true) and 
      compareDeep(dispositionElement, o.dispositionElement, true) and compareDeep(createdElement, o.createdElement, true) and 
      compareDeep(organizationElement, o.organizationElement, true) and compareDeep(requestProviderElement, o.requestProviderElement, true);
  end;
end;

function TFhirEnrollmentResponse.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FidentifierList) and isEmptyProp(FStatus) and isEmptyProp(FRequest) and isEmptyProp(FOutcome) and isEmptyProp(FDisposition) and isEmptyProp(FCreated) and isEmptyProp(FOrganization) and isEmptyProp(FRequestProvider);
end;

procedure TFhirEnrollmentResponse.listFieldsInOrder(fields : TStringList);
begin
  inherited listFieldsInOrder(fields);
  fields.add('identifier');
  fields.add('status');
  fields.add('request');
  fields.add('outcome');
  fields.add('disposition');
  fields.add('created');
  fields.add('organization');
  fields.add('requestProvider');
end;

function TFhirEnrollmentResponse.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FIdentifierList.sizeInBytes(magic));
end;

function TFhirEnrollmentResponse.GetIdentifierList : TFhirIdentifierList;
begin
  if FIdentifierList = nil then
    FIdentifierList := TFhirIdentifierList.Create;
  result := FIdentifierList;
end;

function TFhirEnrollmentResponse.GetHasIdentifierList : boolean;
begin
  result := (FIdentifierList <> nil) and (FIdentifierList.count > 0);
end;

procedure TFhirEnrollmentResponse.SetStatus(value : TFhirEnum);
begin
  FStatus.free;
  FStatus := value;
end;

function TFhirEnrollmentResponse.GetStatusST : TFhirFinancialResourceStatusCodesEnum;
begin
  if FStatus = nil then
    result := TFhirFinancialResourceStatusCodesEnum(0)
  else
    result := TFhirFinancialResourceStatusCodesEnum(StringArrayIndexOfSensitive(CODES_TFhirFinancialResourceStatusCodesEnum, FStatus.value));
end;

procedure TFhirEnrollmentResponse.SetStatusST(value : TFhirFinancialResourceStatusCodesEnum);
begin
  if ord(value) = 0 then
    StatusElement := nil
  else
    StatusElement := TFhirEnum.create(SYSTEMS_TFhirFinancialResourceStatusCodesEnum[value], CODES_TFhirFinancialResourceStatusCodesEnum[value]);
end;

procedure TFhirEnrollmentResponse.SetRequest(value : TFhirReference);
begin
  FRequest.free;
  FRequest := value;
end;

procedure TFhirEnrollmentResponse.SetOutcome(value : TFhirEnum);
begin
  FOutcome.free;
  FOutcome := value;
end;

function TFhirEnrollmentResponse.GetOutcomeST : TFhirEnrollmentOutcomeEnum;
begin
  if FOutcome = nil then
    result := TFhirEnrollmentOutcomeEnum(0)
  else
    result := TFhirEnrollmentOutcomeEnum(StringArrayIndexOfSensitive(CODES_TFhirEnrollmentOutcomeEnum, FOutcome.value));
end;

procedure TFhirEnrollmentResponse.SetOutcomeST(value : TFhirEnrollmentOutcomeEnum);
begin
  if ord(value) = 0 then
    OutcomeElement := nil
  else
    OutcomeElement := TFhirEnum.create(SYSTEMS_TFhirEnrollmentOutcomeEnum[value], CODES_TFhirEnrollmentOutcomeEnum[value]);
end;

procedure TFhirEnrollmentResponse.SetDisposition(value : TFhirString);
begin
  FDisposition.free;
  FDisposition := value;
end;

function TFhirEnrollmentResponse.GetDispositionST : String;
begin
  if FDisposition = nil then
    result := ''
  else
    result := FDisposition.value;
end;

procedure TFhirEnrollmentResponse.SetDispositionST(value : String);
begin
  if value <> '' then
  begin
    if FDisposition = nil then
      FDisposition := TFhirString.create;
    FDisposition.value := value
  end
  else if FDisposition <> nil then
    FDisposition.value := '';
end;

procedure TFhirEnrollmentResponse.SetCreated(value : TFhirDateTime);
begin
  FCreated.free;
  FCreated := value;
end;

function TFhirEnrollmentResponse.GetCreatedST : TFslDateTime;
begin
  if FCreated = nil then
    result := TFslDateTime.makeNull
  else
    result := FCreated.value;
end;

procedure TFhirEnrollmentResponse.SetCreatedST(value : TFslDateTime);
begin
  if FCreated = nil then
    FCreated := TFhirDateTime.create;
  FCreated.value := value
end;

procedure TFhirEnrollmentResponse.SetOrganization(value : TFhirReference);
begin
  FOrganization.free;
  FOrganization := value;
end;

procedure TFhirEnrollmentResponse.SetRequestProvider(value : TFhirReference);
begin
  FRequestProvider.free;
  FRequestProvider := value;
end;

{ TFhirEnrollmentResponseListEnumerator }

constructor TFhirEnrollmentResponseListEnumerator.Create(list : TFhirEnrollmentResponseList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirEnrollmentResponseListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirEnrollmentResponseListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirEnrollmentResponseListEnumerator.GetCurrent : TFhirEnrollmentResponse;
begin
  Result := FList[FIndex];
end;

function TFhirEnrollmentResponseListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirEnrollmentResponseList }

procedure TFhirEnrollmentResponseList.AddItem(value: TFhirEnrollmentResponse);
begin
  assert(value.ClassName = 'TFhirEnrollmentResponse', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirEnrollmentResponse');
  add(value);
end;

function TFhirEnrollmentResponseList.Append: TFhirEnrollmentResponse;
begin
  result := TFhirEnrollmentResponse.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirEnrollmentResponseList.ClearItems;
begin
  Clear;
end;

function TFhirEnrollmentResponseList.GetEnumerator : TFhirEnrollmentResponseListEnumerator;
begin
  result := TFhirEnrollmentResponseListEnumerator.Create(self.link);
end;

function TFhirEnrollmentResponseList.Clone: TFhirEnrollmentResponseList;
begin
  result := TFhirEnrollmentResponseList(inherited Clone);
end;

function TFhirEnrollmentResponseList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirEnrollmentResponseList.GetItemN(index: Integer): TFhirEnrollmentResponse;
begin
  result := TFhirEnrollmentResponse(ObjectByIndex[index]);
end;

function TFhirEnrollmentResponseList.ItemClass: TFslObjectClass;
begin
  result := TFhirEnrollmentResponse;
end;
function TFhirEnrollmentResponseList.IndexOf(value: TFhirEnrollmentResponse): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirEnrollmentResponseList.Insert(index: Integer): TFhirEnrollmentResponse;
begin
  result := TFhirEnrollmentResponse.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirEnrollmentResponseList.InsertItem(index: Integer; value: TFhirEnrollmentResponse);
begin
  assert(value is TFhirEnrollmentResponse);
  Inherited Insert(index, value);
end;

function TFhirEnrollmentResponseList.Item(index: Integer): TFhirEnrollmentResponse;
begin
  result := TFhirEnrollmentResponse(ObjectByIndex[index]);
end;

function TFhirEnrollmentResponseList.Link: TFhirEnrollmentResponseList;
begin
  result := TFhirEnrollmentResponseList(inherited Link);
end;

procedure TFhirEnrollmentResponseList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirEnrollmentResponseList.SetItemByIndex(index: Integer; value: TFhirEnrollmentResponse);
begin
  assert(value is TFhirEnrollmentResponse);
  FhirEnrollmentResponses[index] := value;
end;

procedure TFhirEnrollmentResponseList.SetItemN(index: Integer; value: TFhirEnrollmentResponse);
begin
  assert(value is TFhirEnrollmentResponse);
  ObjectByIndex[index] := value;
end;

{$ENDIF FHIR_ENROLLMENTRESPONSE}
{$IFDEF FHIR_EXPLANATIONOFBENEFIT}
{ TFhirExplanationOfBenefitRelated }

constructor TFhirExplanationOfBenefitRelated.Create;
begin
  inherited;
end;

destructor TFhirExplanationOfBenefitRelated.Destroy;
begin
  FClaim.free;
  FRelationship.free;
  FReference.free;
  inherited;
end;

procedure TFhirExplanationOfBenefitRelated.Assign(oSource : TFslObject);
begin
  inherited;
  claim := TFhirExplanationOfBenefitRelated(oSource).claim.Clone;
  relationship := TFhirExplanationOfBenefitRelated(oSource).relationship.Clone;
  reference := TFhirExplanationOfBenefitRelated(oSource).reference.Clone;
end;

procedure TFhirExplanationOfBenefitRelated.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'claim') Then
     list.add(self.link, 'claim', FClaim.Link);
  if (child_name = 'relationship') Then
     list.add(self.link, 'relationship', FRelationship.Link);
  if (child_name = 'reference') Then
     list.add(self.link, 'reference', FReference.Link);
end;

procedure TFhirExplanationOfBenefitRelated.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'claim', 'Reference', false, TFhirReference, FClaim.Link));
  oList.add(TFHIRProperty.create(self, 'relationship', 'CodeableConcept', false, TFhirCodeableConcept, FRelationship.Link));
  oList.add(TFHIRProperty.create(self, 'reference', 'Identifier', false, TFhirIdentifier, FReference.Link));
end;

function TFhirExplanationOfBenefitRelated.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'claim') then
  begin
    Claim := propValue as TFhirReference;
    result := propValue;
  end
  else if (propName = 'relationship') then
  begin
    Relationship := propValue as TFhirCodeableConcept;
    result := propValue;
  end
  else if (propName = 'reference') then
  begin
    Reference := propValue as TFhirIdentifier;
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirExplanationOfBenefitRelated.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirExplanationOfBenefitRelated.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'claim') then result := TFhirReference.create()
  else if (propName = 'relationship') then result := TFhirCodeableConcept.create()
  else if (propName = 'reference') then result := TFhirIdentifier.create()
  else result := inherited createPropertyValue(propName);
end;

function TFhirExplanationOfBenefitRelated.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'claim') then result := 'Reference'
  else if (propName = 'relationship') then result := 'CodeableConcept'
  else if (propName = 'reference') then result := 'Identifier'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirExplanationOfBenefitRelated.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'claim') then ClaimElement := nil
  else if (propName = 'relationship') then RelationshipElement := nil
  else if (propName = 'reference') then ReferenceElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirExplanationOfBenefitRelated.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'claim') then ClaimElement := new as TFhirReference
  else if (propName = 'relationship') then RelationshipElement := new as TFhirCodeableConcept
  else if (propName = 'reference') then ReferenceElement := new as TFhirIdentifier
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirExplanationOfBenefitRelated.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirExplanationOfBenefitRelated.fhirType : string;
begin
  result := 'ExplanationOfBenefit.related';
end;

function TFhirExplanationOfBenefitRelated.Link : TFhirExplanationOfBenefitRelated;
begin
  result := TFhirExplanationOfBenefitRelated(inherited Link);
end;

function TFhirExplanationOfBenefitRelated.Clone : TFhirExplanationOfBenefitRelated;
begin
  result := TFhirExplanationOfBenefitRelated(inherited Clone);
end;

function TFhirExplanationOfBenefitRelated.equals(other : TObject) : boolean; 
var
  o : TFhirExplanationOfBenefitRelated;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirExplanationOfBenefitRelated)) then
    result := false
  else
  begin
    o := TFhirExplanationOfBenefitRelated(other);
    result := compareDeep(claimElement, o.claimElement, true) and compareDeep(relationshipElement, o.relationshipElement, true) and 
      compareDeep(referenceElement, o.referenceElement, true);
  end;
end;

function TFhirExplanationOfBenefitRelated.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FClaim) and isEmptyProp(FRelationship) and isEmptyProp(FReference);
end;

procedure TFhirExplanationOfBenefitRelated.listFieldsInOrder(fields : TStringList);
begin
  inherited listFieldsInOrder(fields);
  fields.add('claim');
  fields.add('relationship');
  fields.add('reference');
end;

function TFhirExplanationOfBenefitRelated.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
end;

procedure TFhirExplanationOfBenefitRelated.SetClaim(value : TFhirReference);
begin
  FClaim.free;
  FClaim := value;
end;

procedure TFhirExplanationOfBenefitRelated.SetRelationship(value : TFhirCodeableConcept);
begin
  FRelationship.free;
  FRelationship := value;
end;

procedure TFhirExplanationOfBenefitRelated.SetReference(value : TFhirIdentifier);
begin
  FReference.free;
  FReference := value;
end;

{ TFhirExplanationOfBenefitRelatedListEnumerator }

constructor TFhirExplanationOfBenefitRelatedListEnumerator.Create(list : TFhirExplanationOfBenefitRelatedList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirExplanationOfBenefitRelatedListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirExplanationOfBenefitRelatedListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirExplanationOfBenefitRelatedListEnumerator.GetCurrent : TFhirExplanationOfBenefitRelated;
begin
  Result := FList[FIndex];
end;

function TFhirExplanationOfBenefitRelatedListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirExplanationOfBenefitRelatedList }

procedure TFhirExplanationOfBenefitRelatedList.AddItem(value: TFhirExplanationOfBenefitRelated);
begin
  assert(value.ClassName = 'TFhirExplanationOfBenefitRelated', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirExplanationOfBenefitRelated');
  add(value);
end;

function TFhirExplanationOfBenefitRelatedList.Append: TFhirExplanationOfBenefitRelated;
begin
  result := TFhirExplanationOfBenefitRelated.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirExplanationOfBenefitRelatedList.ClearItems;
begin
  Clear;
end;

function TFhirExplanationOfBenefitRelatedList.GetEnumerator : TFhirExplanationOfBenefitRelatedListEnumerator;
begin
  result := TFhirExplanationOfBenefitRelatedListEnumerator.Create(self.link);
end;

function TFhirExplanationOfBenefitRelatedList.Clone: TFhirExplanationOfBenefitRelatedList;
begin
  result := TFhirExplanationOfBenefitRelatedList(inherited Clone);
end;

function TFhirExplanationOfBenefitRelatedList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirExplanationOfBenefitRelatedList.GetItemN(index: Integer): TFhirExplanationOfBenefitRelated;
begin
  result := TFhirExplanationOfBenefitRelated(ObjectByIndex[index]);
end;

function TFhirExplanationOfBenefitRelatedList.ItemClass: TFslObjectClass;
begin
  result := TFhirExplanationOfBenefitRelated;
end;
function TFhirExplanationOfBenefitRelatedList.IndexOf(value: TFhirExplanationOfBenefitRelated): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirExplanationOfBenefitRelatedList.Insert(index: Integer): TFhirExplanationOfBenefitRelated;
begin
  result := TFhirExplanationOfBenefitRelated.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirExplanationOfBenefitRelatedList.InsertItem(index: Integer; value: TFhirExplanationOfBenefitRelated);
begin
  assert(value is TFhirExplanationOfBenefitRelated);
  Inherited Insert(index, value);
end;

function TFhirExplanationOfBenefitRelatedList.Item(index: Integer): TFhirExplanationOfBenefitRelated;
begin
  result := TFhirExplanationOfBenefitRelated(ObjectByIndex[index]);
end;

function TFhirExplanationOfBenefitRelatedList.Link: TFhirExplanationOfBenefitRelatedList;
begin
  result := TFhirExplanationOfBenefitRelatedList(inherited Link);
end;

procedure TFhirExplanationOfBenefitRelatedList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirExplanationOfBenefitRelatedList.SetItemByIndex(index: Integer; value: TFhirExplanationOfBenefitRelated);
begin
  assert(value is TFhirExplanationOfBenefitRelated);
  FhirExplanationOfBenefitRelateds[index] := value;
end;

procedure TFhirExplanationOfBenefitRelatedList.SetItemN(index: Integer; value: TFhirExplanationOfBenefitRelated);
begin
  assert(value is TFhirExplanationOfBenefitRelated);
  ObjectByIndex[index] := value;
end;

{ TFhirExplanationOfBenefitPayee }

constructor TFhirExplanationOfBenefitPayee.Create;
begin
  inherited;
end;

destructor TFhirExplanationOfBenefitPayee.Destroy;
begin
  FType_.free;
  FParty.free;
  inherited;
end;

procedure TFhirExplanationOfBenefitPayee.Assign(oSource : TFslObject);
begin
  inherited;
  type_ := TFhirExplanationOfBenefitPayee(oSource).type_.Clone;
  party := TFhirExplanationOfBenefitPayee(oSource).party.Clone;
end;

procedure TFhirExplanationOfBenefitPayee.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'type') Then
     list.add(self.link, 'type', FType_.Link);
  if (child_name = 'party') Then
     list.add(self.link, 'party', FParty.Link);
end;

procedure TFhirExplanationOfBenefitPayee.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'type', 'CodeableConcept', false, TFhirCodeableConcept, FType_.Link));
  oList.add(TFHIRProperty.create(self, 'party', 'Reference', false, TFhirReference, FParty.Link));
end;

function TFhirExplanationOfBenefitPayee.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'type') then
  begin
    Type_ := propValue as TFhirCodeableConcept;
    result := propValue;
  end
  else if (propName = 'party') then
  begin
    Party := propValue as TFhirReference;
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirExplanationOfBenefitPayee.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirExplanationOfBenefitPayee.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'type') then result := TFhirCodeableConcept.create()
  else if (propName = 'party') then result := TFhirReference.create()
  else result := inherited createPropertyValue(propName);
end;

function TFhirExplanationOfBenefitPayee.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'type') then result := 'CodeableConcept'
  else if (propName = 'party') then result := 'Reference'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirExplanationOfBenefitPayee.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'type') then Type_Element := nil
  else if (propName = 'party') then PartyElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirExplanationOfBenefitPayee.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'type') then Type_Element := new as TFhirCodeableConcept
  else if (propName = 'party') then PartyElement := new as TFhirReference
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirExplanationOfBenefitPayee.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirExplanationOfBenefitPayee.fhirType : string;
begin
  result := 'ExplanationOfBenefit.payee';
end;

function TFhirExplanationOfBenefitPayee.Link : TFhirExplanationOfBenefitPayee;
begin
  result := TFhirExplanationOfBenefitPayee(inherited Link);
end;

function TFhirExplanationOfBenefitPayee.Clone : TFhirExplanationOfBenefitPayee;
begin
  result := TFhirExplanationOfBenefitPayee(inherited Clone);
end;

function TFhirExplanationOfBenefitPayee.equals(other : TObject) : boolean; 
var
  o : TFhirExplanationOfBenefitPayee;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirExplanationOfBenefitPayee)) then
    result := false
  else
  begin
    o := TFhirExplanationOfBenefitPayee(other);
    result := compareDeep(type_Element, o.type_Element, true) and compareDeep(partyElement, o.partyElement, true);
  end;
end;

function TFhirExplanationOfBenefitPayee.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FType_) and isEmptyProp(FParty);
end;

procedure TFhirExplanationOfBenefitPayee.listFieldsInOrder(fields : TStringList);
begin
  inherited listFieldsInOrder(fields);
  fields.add('type');
  fields.add('party');
end;

function TFhirExplanationOfBenefitPayee.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
end;

procedure TFhirExplanationOfBenefitPayee.SetType_(value : TFhirCodeableConcept);
begin
  FType_.free;
  FType_ := value;
end;

procedure TFhirExplanationOfBenefitPayee.SetParty(value : TFhirReference);
begin
  FParty.free;
  FParty := value;
end;

{ TFhirExplanationOfBenefitPayeeListEnumerator }

constructor TFhirExplanationOfBenefitPayeeListEnumerator.Create(list : TFhirExplanationOfBenefitPayeeList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirExplanationOfBenefitPayeeListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirExplanationOfBenefitPayeeListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirExplanationOfBenefitPayeeListEnumerator.GetCurrent : TFhirExplanationOfBenefitPayee;
begin
  Result := FList[FIndex];
end;

function TFhirExplanationOfBenefitPayeeListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirExplanationOfBenefitPayeeList }

procedure TFhirExplanationOfBenefitPayeeList.AddItem(value: TFhirExplanationOfBenefitPayee);
begin
  assert(value.ClassName = 'TFhirExplanationOfBenefitPayee', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirExplanationOfBenefitPayee');
  add(value);
end;

function TFhirExplanationOfBenefitPayeeList.Append: TFhirExplanationOfBenefitPayee;
begin
  result := TFhirExplanationOfBenefitPayee.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirExplanationOfBenefitPayeeList.ClearItems;
begin
  Clear;
end;

function TFhirExplanationOfBenefitPayeeList.GetEnumerator : TFhirExplanationOfBenefitPayeeListEnumerator;
begin
  result := TFhirExplanationOfBenefitPayeeListEnumerator.Create(self.link);
end;

function TFhirExplanationOfBenefitPayeeList.Clone: TFhirExplanationOfBenefitPayeeList;
begin
  result := TFhirExplanationOfBenefitPayeeList(inherited Clone);
end;

function TFhirExplanationOfBenefitPayeeList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirExplanationOfBenefitPayeeList.GetItemN(index: Integer): TFhirExplanationOfBenefitPayee;
begin
  result := TFhirExplanationOfBenefitPayee(ObjectByIndex[index]);
end;

function TFhirExplanationOfBenefitPayeeList.ItemClass: TFslObjectClass;
begin
  result := TFhirExplanationOfBenefitPayee;
end;
function TFhirExplanationOfBenefitPayeeList.IndexOf(value: TFhirExplanationOfBenefitPayee): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirExplanationOfBenefitPayeeList.Insert(index: Integer): TFhirExplanationOfBenefitPayee;
begin
  result := TFhirExplanationOfBenefitPayee.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirExplanationOfBenefitPayeeList.InsertItem(index: Integer; value: TFhirExplanationOfBenefitPayee);
begin
  assert(value is TFhirExplanationOfBenefitPayee);
  Inherited Insert(index, value);
end;

function TFhirExplanationOfBenefitPayeeList.Item(index: Integer): TFhirExplanationOfBenefitPayee;
begin
  result := TFhirExplanationOfBenefitPayee(ObjectByIndex[index]);
end;

function TFhirExplanationOfBenefitPayeeList.Link: TFhirExplanationOfBenefitPayeeList;
begin
  result := TFhirExplanationOfBenefitPayeeList(inherited Link);
end;

procedure TFhirExplanationOfBenefitPayeeList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirExplanationOfBenefitPayeeList.SetItemByIndex(index: Integer; value: TFhirExplanationOfBenefitPayee);
begin
  assert(value is TFhirExplanationOfBenefitPayee);
  FhirExplanationOfBenefitPayees[index] := value;
end;

procedure TFhirExplanationOfBenefitPayeeList.SetItemN(index: Integer; value: TFhirExplanationOfBenefitPayee);
begin
  assert(value is TFhirExplanationOfBenefitPayee);
  ObjectByIndex[index] := value;
end;

{ TFhirExplanationOfBenefitCareTeam }

constructor TFhirExplanationOfBenefitCareTeam.Create;
begin
  inherited;
end;

destructor TFhirExplanationOfBenefitCareTeam.Destroy;
begin
  FSequence.free;
  FProvider.free;
  FResponsible.free;
  FRole.free;
  FQualification.free;
  inherited;
end;

procedure TFhirExplanationOfBenefitCareTeam.Assign(oSource : TFslObject);
begin
  inherited;
  sequenceElement := TFhirExplanationOfBenefitCareTeam(oSource).sequenceElement.Clone;
  provider := TFhirExplanationOfBenefitCareTeam(oSource).provider.Clone;
  responsibleElement := TFhirExplanationOfBenefitCareTeam(oSource).responsibleElement.Clone;
  role := TFhirExplanationOfBenefitCareTeam(oSource).role.Clone;
  qualification := TFhirExplanationOfBenefitCareTeam(oSource).qualification.Clone;
end;

procedure TFhirExplanationOfBenefitCareTeam.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'sequence') Then
     list.add(self.link, 'sequence', FSequence.Link);
  if (child_name = 'provider') Then
     list.add(self.link, 'provider', FProvider.Link);
  if (child_name = 'responsible') Then
     list.add(self.link, 'responsible', FResponsible.Link);
  if (child_name = 'role') Then
     list.add(self.link, 'role', FRole.Link);
  if (child_name = 'qualification') Then
     list.add(self.link, 'qualification', FQualification.Link);
end;

procedure TFhirExplanationOfBenefitCareTeam.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'sequence', 'positiveInt', false, TFhirPositiveInt, FSequence.Link));
  oList.add(TFHIRProperty.create(self, 'provider', 'Reference', false, TFhirReference, FProvider.Link));
  oList.add(TFHIRProperty.create(self, 'responsible', 'boolean', false, TFhirBoolean, FResponsible.Link));
  oList.add(TFHIRProperty.create(self, 'role', 'CodeableConcept', false, TFhirCodeableConcept, FRole.Link));
  oList.add(TFHIRProperty.create(self, 'qualification', 'CodeableConcept', false, TFhirCodeableConcept, FQualification.Link));
end;

function TFhirExplanationOfBenefitCareTeam.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'sequence') then
  begin
    SequenceElement := asPositiveInt(propValue);
    result := propValue;
  end
  else if (propName = 'provider') then
  begin
    Provider := propValue as TFhirReference;
    result := propValue;
  end
  else if (propName = 'responsible') then
  begin
    ResponsibleElement := asBoolean(propValue);
    result := propValue;
  end
  else if (propName = 'role') then
  begin
    Role := propValue as TFhirCodeableConcept;
    result := propValue;
  end
  else if (propName = 'qualification') then
  begin
    Qualification := propValue as TFhirCodeableConcept;
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirExplanationOfBenefitCareTeam.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirExplanationOfBenefitCareTeam.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'sequence') then result := TFhirPositiveInt.create()
  else if (propName = 'provider') then result := TFhirReference.create()
  else if (propName = 'responsible') then result := TFhirBoolean.create()
  else if (propName = 'role') then result := TFhirCodeableConcept.create()
  else if (propName = 'qualification') then result := TFhirCodeableConcept.create()
  else result := inherited createPropertyValue(propName);
end;

function TFhirExplanationOfBenefitCareTeam.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'sequence') then result := 'positiveInt'
  else if (propName = 'provider') then result := 'Reference'
  else if (propName = 'responsible') then result := 'boolean'
  else if (propName = 'role') then result := 'CodeableConcept'
  else if (propName = 'qualification') then result := 'CodeableConcept'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirExplanationOfBenefitCareTeam.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'sequence') then SequenceElement := nil
  else if (propName = 'provider') then ProviderElement := nil
  else if (propName = 'responsible') then ResponsibleElement := nil
  else if (propName = 'role') then RoleElement := nil
  else if (propName = 'qualification') then QualificationElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirExplanationOfBenefitCareTeam.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'sequence') then SequenceElement := asPositiveInt(new)
  else if (propName = 'provider') then ProviderElement := new as TFhirReference
  else if (propName = 'responsible') then ResponsibleElement := asBoolean(new)
  else if (propName = 'role') then RoleElement := new as TFhirCodeableConcept
  else if (propName = 'qualification') then QualificationElement := new as TFhirCodeableConcept
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirExplanationOfBenefitCareTeam.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirExplanationOfBenefitCareTeam.fhirType : string;
begin
  result := 'ExplanationOfBenefit.careTeam';
end;

function TFhirExplanationOfBenefitCareTeam.Link : TFhirExplanationOfBenefitCareTeam;
begin
  result := TFhirExplanationOfBenefitCareTeam(inherited Link);
end;

function TFhirExplanationOfBenefitCareTeam.Clone : TFhirExplanationOfBenefitCareTeam;
begin
  result := TFhirExplanationOfBenefitCareTeam(inherited Clone);
end;

function TFhirExplanationOfBenefitCareTeam.equals(other : TObject) : boolean; 
var
  o : TFhirExplanationOfBenefitCareTeam;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirExplanationOfBenefitCareTeam)) then
    result := false
  else
  begin
    o := TFhirExplanationOfBenefitCareTeam(other);
    result := compareDeep(sequenceElement, o.sequenceElement, true) and compareDeep(providerElement, o.providerElement, true) and 
      compareDeep(responsibleElement, o.responsibleElement, true) and compareDeep(roleElement, o.roleElement, true) and 
      compareDeep(qualificationElement, o.qualificationElement, true);
  end;
end;

function TFhirExplanationOfBenefitCareTeam.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FSequence) and isEmptyProp(FProvider) and isEmptyProp(FResponsible) and isEmptyProp(FRole) and isEmptyProp(FQualification);
end;

procedure TFhirExplanationOfBenefitCareTeam.listFieldsInOrder(fields : TStringList);
begin
  inherited listFieldsInOrder(fields);
  fields.add('sequence');
  fields.add('provider');
  fields.add('responsible');
  fields.add('role');
  fields.add('qualification');
end;

function TFhirExplanationOfBenefitCareTeam.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
end;

procedure TFhirExplanationOfBenefitCareTeam.SetSequence(value : TFhirPositiveInt);
begin
  FSequence.free;
  FSequence := value;
end;

function TFhirExplanationOfBenefitCareTeam.GetSequenceST : String;
begin
  if FSequence = nil then
    result := ''
  else
    result := FSequence.value;
end;

procedure TFhirExplanationOfBenefitCareTeam.SetSequenceST(value : String);
begin
  if value <> '' then
  begin
    if FSequence = nil then
      FSequence := TFhirPositiveInt.create;
    FSequence.value := value
  end
  else if FSequence <> nil then
    FSequence.value := '';
end;

procedure TFhirExplanationOfBenefitCareTeam.SetProvider(value : TFhirReference);
begin
  FProvider.free;
  FProvider := value;
end;

procedure TFhirExplanationOfBenefitCareTeam.SetResponsible(value : TFhirBoolean);
begin
  FResponsible.free;
  FResponsible := value;
end;

function TFhirExplanationOfBenefitCareTeam.GetResponsibleST : Boolean;
begin
  if FResponsible = nil then
    result := false
  else
    result := FResponsible.value;
end;

procedure TFhirExplanationOfBenefitCareTeam.SetResponsibleST(value : Boolean);
begin
  if FResponsible = nil then
    FResponsible := TFhirBoolean.create;
  FResponsible.value := value
end;

procedure TFhirExplanationOfBenefitCareTeam.SetRole(value : TFhirCodeableConcept);
begin
  FRole.free;
  FRole := value;
end;

procedure TFhirExplanationOfBenefitCareTeam.SetQualification(value : TFhirCodeableConcept);
begin
  FQualification.free;
  FQualification := value;
end;

{ TFhirExplanationOfBenefitCareTeamListEnumerator }

constructor TFhirExplanationOfBenefitCareTeamListEnumerator.Create(list : TFhirExplanationOfBenefitCareTeamList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirExplanationOfBenefitCareTeamListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirExplanationOfBenefitCareTeamListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirExplanationOfBenefitCareTeamListEnumerator.GetCurrent : TFhirExplanationOfBenefitCareTeam;
begin
  Result := FList[FIndex];
end;

function TFhirExplanationOfBenefitCareTeamListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirExplanationOfBenefitCareTeamList }

procedure TFhirExplanationOfBenefitCareTeamList.AddItem(value: TFhirExplanationOfBenefitCareTeam);
begin
  assert(value.ClassName = 'TFhirExplanationOfBenefitCareTeam', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirExplanationOfBenefitCareTeam');
  add(value);
end;

function TFhirExplanationOfBenefitCareTeamList.Append: TFhirExplanationOfBenefitCareTeam;
begin
  result := TFhirExplanationOfBenefitCareTeam.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirExplanationOfBenefitCareTeamList.ClearItems;
begin
  Clear;
end;

function TFhirExplanationOfBenefitCareTeamList.GetEnumerator : TFhirExplanationOfBenefitCareTeamListEnumerator;
begin
  result := TFhirExplanationOfBenefitCareTeamListEnumerator.Create(self.link);
end;

function TFhirExplanationOfBenefitCareTeamList.Clone: TFhirExplanationOfBenefitCareTeamList;
begin
  result := TFhirExplanationOfBenefitCareTeamList(inherited Clone);
end;

function TFhirExplanationOfBenefitCareTeamList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirExplanationOfBenefitCareTeamList.GetItemN(index: Integer): TFhirExplanationOfBenefitCareTeam;
begin
  result := TFhirExplanationOfBenefitCareTeam(ObjectByIndex[index]);
end;

function TFhirExplanationOfBenefitCareTeamList.ItemClass: TFslObjectClass;
begin
  result := TFhirExplanationOfBenefitCareTeam;
end;
function TFhirExplanationOfBenefitCareTeamList.IndexOf(value: TFhirExplanationOfBenefitCareTeam): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirExplanationOfBenefitCareTeamList.Insert(index: Integer): TFhirExplanationOfBenefitCareTeam;
begin
  result := TFhirExplanationOfBenefitCareTeam.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirExplanationOfBenefitCareTeamList.InsertItem(index: Integer; value: TFhirExplanationOfBenefitCareTeam);
begin
  assert(value is TFhirExplanationOfBenefitCareTeam);
  Inherited Insert(index, value);
end;

function TFhirExplanationOfBenefitCareTeamList.Item(index: Integer): TFhirExplanationOfBenefitCareTeam;
begin
  result := TFhirExplanationOfBenefitCareTeam(ObjectByIndex[index]);
end;

function TFhirExplanationOfBenefitCareTeamList.Link: TFhirExplanationOfBenefitCareTeamList;
begin
  result := TFhirExplanationOfBenefitCareTeamList(inherited Link);
end;

procedure TFhirExplanationOfBenefitCareTeamList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirExplanationOfBenefitCareTeamList.SetItemByIndex(index: Integer; value: TFhirExplanationOfBenefitCareTeam);
begin
  assert(value is TFhirExplanationOfBenefitCareTeam);
  FhirExplanationOfBenefitCareTeams[index] := value;
end;

procedure TFhirExplanationOfBenefitCareTeamList.SetItemN(index: Integer; value: TFhirExplanationOfBenefitCareTeam);
begin
  assert(value is TFhirExplanationOfBenefitCareTeam);
  ObjectByIndex[index] := value;
end;

{ TFhirExplanationOfBenefitSupportingInfo }

constructor TFhirExplanationOfBenefitSupportingInfo.Create;
begin
  inherited;
end;

destructor TFhirExplanationOfBenefitSupportingInfo.Destroy;
begin
  FSequence.free;
  FCategory.free;
  FCode.free;
  FTiming.free;
  FValue.free;
  FReason.free;
  inherited;
end;

procedure TFhirExplanationOfBenefitSupportingInfo.Assign(oSource : TFslObject);
begin
  inherited;
  sequenceElement := TFhirExplanationOfBenefitSupportingInfo(oSource).sequenceElement.Clone;
  category := TFhirExplanationOfBenefitSupportingInfo(oSource).category.Clone;
  code := TFhirExplanationOfBenefitSupportingInfo(oSource).code.Clone;
  timing := TFhirExplanationOfBenefitSupportingInfo(oSource).timing.Clone;
  value := TFhirExplanationOfBenefitSupportingInfo(oSource).value.Clone;
  reason := TFhirExplanationOfBenefitSupportingInfo(oSource).reason.Clone;
end;

procedure TFhirExplanationOfBenefitSupportingInfo.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'sequence') Then
     list.add(self.link, 'sequence', FSequence.Link);
  if (child_name = 'category') Then
     list.add(self.link, 'category', FCategory.Link);
  if (child_name = 'code') Then
     list.add(self.link, 'code', FCode.Link);
  if (child_name = 'timing[x]') or (child_name = 'timing') Then
     list.add(self.link, 'timing[x]', FTiming.Link);
  if (child_name = 'value[x]') or (child_name = 'value') Then
     list.add(self.link, 'value[x]', FValue.Link);
  if (child_name = 'reason') Then
     list.add(self.link, 'reason', FReason.Link);
end;

procedure TFhirExplanationOfBenefitSupportingInfo.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'sequence', 'positiveInt', false, TFhirPositiveInt, FSequence.Link));
  oList.add(TFHIRProperty.create(self, 'category', 'CodeableConcept', false, TFhirCodeableConcept, FCategory.Link));
  oList.add(TFHIRProperty.create(self, 'code', 'CodeableConcept', false, TFhirCodeableConcept, FCode.Link));
  oList.add(TFHIRProperty.create(self, 'timing[x]', 'date|Period', false, TFhirDataType, FTiming.Link));
  oList.add(TFHIRProperty.create(self, 'value[x]', 'boolean|string|Quantity|Attachment|Reference', false, TFhirDataType, FValue.Link));
  oList.add(TFHIRProperty.create(self, 'reason', 'Coding', false, TFhirCoding, FReason.Link));
end;

function TFhirExplanationOfBenefitSupportingInfo.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'sequence') then
  begin
    SequenceElement := asPositiveInt(propValue);
    result := propValue;
  end
  else if (propName = 'category') then
  begin
    Category := propValue as TFhirCodeableConcept;
    result := propValue;
  end
  else if (propName = 'code') then
  begin
    Code := propValue as TFhirCodeableConcept;
    result := propValue;
  end
  else if (isMatchingName(propName, 'timing', ['Date', 'Period'])) then
  begin
    Timing := propValue as TFhirDataType;
    result := propValue;
  end
  else if (isMatchingName(propName, 'value', ['Boolean', 'String', 'Quantity', 'Attachment', 'Reference'])) then
  begin
    Value := propValue as TFhirDataType;
    result := propValue;
  end
  else if (propName = 'reason') then
  begin
    Reason := propValue as TFhirCoding;
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirExplanationOfBenefitSupportingInfo.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirExplanationOfBenefitSupportingInfo.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'sequence') then result := TFhirPositiveInt.create()
  else if (propName = 'category') then result := TFhirCodeableConcept.create()
  else if (propName = 'code') then result := TFhirCodeableConcept.create()
  else if (isMatchingName(propName, 'timing', ['Date', 'Period'])) then raise EFHIRException.create('Cannot make property Timing')
  else if (isMatchingName(propName, 'value', ['Boolean', 'String', 'Quantity', 'Attachment', 'Reference'])) then raise EFHIRException.create('Cannot make property Value')
  else if (propName = 'reason') then result := TFhirCoding.create()
  else result := inherited createPropertyValue(propName);
end;

function TFhirExplanationOfBenefitSupportingInfo.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'sequence') then result := 'positiveInt'
  else if (propName = 'category') then result := 'CodeableConcept'
  else if (propName = 'code') then result := 'CodeableConcept'
  else if (propName = 'timing[x]') then result := 'date|Period'
  else if (propName = 'value[x]') then result := 'boolean|string|Quantity|Attachment|Reference'
  else if (propName = 'reason') then result := 'Coding'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirExplanationOfBenefitSupportingInfo.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'sequence') then SequenceElement := nil
  else if (propName = 'category') then CategoryElement := nil
  else if (propName = 'code') then CodeElement := nil
  else if (isMatchingName(propName, 'timing', ['Date', 'Period'])) then TimingElement := nil
  else if (isMatchingName(propName, 'value', ['Boolean', 'String', 'Quantity', 'Attachment', 'Reference'])) then ValueElement := nil
  else if (propName = 'reason') then ReasonElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirExplanationOfBenefitSupportingInfo.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'sequence') then SequenceElement := asPositiveInt(new)
  else if (propName = 'category') then CategoryElement := new as TFhirCodeableConcept
  else if (propName = 'code') then CodeElement := new as TFhirCodeableConcept
  else if (isMatchingName(propName, 'timing', ['Date', 'Period'])) then TimingElement := new as TFhirDataType
  else if (isMatchingName(propName, 'value', ['Boolean', 'String', 'Quantity', 'Attachment', 'Reference'])) then ValueElement := new as TFhirDataType
  else if (propName = 'reason') then ReasonElement := new as TFhirCoding
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirExplanationOfBenefitSupportingInfo.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirExplanationOfBenefitSupportingInfo.fhirType : string;
begin
  result := 'ExplanationOfBenefit.supportingInfo';
end;

function TFhirExplanationOfBenefitSupportingInfo.Link : TFhirExplanationOfBenefitSupportingInfo;
begin
  result := TFhirExplanationOfBenefitSupportingInfo(inherited Link);
end;

function TFhirExplanationOfBenefitSupportingInfo.Clone : TFhirExplanationOfBenefitSupportingInfo;
begin
  result := TFhirExplanationOfBenefitSupportingInfo(inherited Clone);
end;

function TFhirExplanationOfBenefitSupportingInfo.equals(other : TObject) : boolean; 
var
  o : TFhirExplanationOfBenefitSupportingInfo;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirExplanationOfBenefitSupportingInfo)) then
    result := false
  else
  begin
    o := TFhirExplanationOfBenefitSupportingInfo(other);
    result := compareDeep(sequenceElement, o.sequenceElement, true) and compareDeep(categoryElement, o.categoryElement, true) and 
      compareDeep(codeElement, o.codeElement, true) and compareDeep(timingElement, o.timingElement, true) and 
      compareDeep(valueElement, o.valueElement, true) and compareDeep(reasonElement, o.reasonElement, true);
  end;
end;

function TFhirExplanationOfBenefitSupportingInfo.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FSequence) and isEmptyProp(FCategory) and isEmptyProp(FCode) and isEmptyProp(FTiming) and isEmptyProp(FValue) and isEmptyProp(FReason);
end;

procedure TFhirExplanationOfBenefitSupportingInfo.listFieldsInOrder(fields : TStringList);
begin
  inherited listFieldsInOrder(fields);
  fields.add('sequence');
  fields.add('category');
  fields.add('code');
  fields.add('timing[x]');
  fields.add('value[x]');
  fields.add('reason');
end;

function TFhirExplanationOfBenefitSupportingInfo.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
end;

procedure TFhirExplanationOfBenefitSupportingInfo.SetSequence(value : TFhirPositiveInt);
begin
  FSequence.free;
  FSequence := value;
end;

function TFhirExplanationOfBenefitSupportingInfo.GetSequenceST : String;
begin
  if FSequence = nil then
    result := ''
  else
    result := FSequence.value;
end;

procedure TFhirExplanationOfBenefitSupportingInfo.SetSequenceST(value : String);
begin
  if value <> '' then
  begin
    if FSequence = nil then
      FSequence := TFhirPositiveInt.create;
    FSequence.value := value
  end
  else if FSequence <> nil then
    FSequence.value := '';
end;

procedure TFhirExplanationOfBenefitSupportingInfo.SetCategory(value : TFhirCodeableConcept);
begin
  FCategory.free;
  FCategory := value;
end;

procedure TFhirExplanationOfBenefitSupportingInfo.SetCode(value : TFhirCodeableConcept);
begin
  FCode.free;
  FCode := value;
end;

procedure TFhirExplanationOfBenefitSupportingInfo.SetTiming(value : TFhirDataType);
begin
  FTiming.free;
  FTiming := value;
end;

procedure TFhirExplanationOfBenefitSupportingInfo.SetValue(value : TFhirDataType);
begin
  FValue.free;
  FValue := value;
end;

procedure TFhirExplanationOfBenefitSupportingInfo.SetReason(value : TFhirCoding);
begin
  FReason.free;
  FReason := value;
end;

{ TFhirExplanationOfBenefitSupportingInfoListEnumerator }

constructor TFhirExplanationOfBenefitSupportingInfoListEnumerator.Create(list : TFhirExplanationOfBenefitSupportingInfoList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirExplanationOfBenefitSupportingInfoListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirExplanationOfBenefitSupportingInfoListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirExplanationOfBenefitSupportingInfoListEnumerator.GetCurrent : TFhirExplanationOfBenefitSupportingInfo;
begin
  Result := FList[FIndex];
end;

function TFhirExplanationOfBenefitSupportingInfoListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirExplanationOfBenefitSupportingInfoList }

procedure TFhirExplanationOfBenefitSupportingInfoList.AddItem(value: TFhirExplanationOfBenefitSupportingInfo);
begin
  assert(value.ClassName = 'TFhirExplanationOfBenefitSupportingInfo', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirExplanationOfBenefitSupportingInfo');
  add(value);
end;

function TFhirExplanationOfBenefitSupportingInfoList.Append: TFhirExplanationOfBenefitSupportingInfo;
begin
  result := TFhirExplanationOfBenefitSupportingInfo.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirExplanationOfBenefitSupportingInfoList.ClearItems;
begin
  Clear;
end;

function TFhirExplanationOfBenefitSupportingInfoList.GetEnumerator : TFhirExplanationOfBenefitSupportingInfoListEnumerator;
begin
  result := TFhirExplanationOfBenefitSupportingInfoListEnumerator.Create(self.link);
end;

function TFhirExplanationOfBenefitSupportingInfoList.Clone: TFhirExplanationOfBenefitSupportingInfoList;
begin
  result := TFhirExplanationOfBenefitSupportingInfoList(inherited Clone);
end;

function TFhirExplanationOfBenefitSupportingInfoList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirExplanationOfBenefitSupportingInfoList.GetItemN(index: Integer): TFhirExplanationOfBenefitSupportingInfo;
begin
  result := TFhirExplanationOfBenefitSupportingInfo(ObjectByIndex[index]);
end;

function TFhirExplanationOfBenefitSupportingInfoList.ItemClass: TFslObjectClass;
begin
  result := TFhirExplanationOfBenefitSupportingInfo;
end;
function TFhirExplanationOfBenefitSupportingInfoList.IndexOf(value: TFhirExplanationOfBenefitSupportingInfo): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirExplanationOfBenefitSupportingInfoList.Insert(index: Integer): TFhirExplanationOfBenefitSupportingInfo;
begin
  result := TFhirExplanationOfBenefitSupportingInfo.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirExplanationOfBenefitSupportingInfoList.InsertItem(index: Integer; value: TFhirExplanationOfBenefitSupportingInfo);
begin
  assert(value is TFhirExplanationOfBenefitSupportingInfo);
  Inherited Insert(index, value);
end;

function TFhirExplanationOfBenefitSupportingInfoList.Item(index: Integer): TFhirExplanationOfBenefitSupportingInfo;
begin
  result := TFhirExplanationOfBenefitSupportingInfo(ObjectByIndex[index]);
end;

function TFhirExplanationOfBenefitSupportingInfoList.Link: TFhirExplanationOfBenefitSupportingInfoList;
begin
  result := TFhirExplanationOfBenefitSupportingInfoList(inherited Link);
end;

procedure TFhirExplanationOfBenefitSupportingInfoList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirExplanationOfBenefitSupportingInfoList.SetItemByIndex(index: Integer; value: TFhirExplanationOfBenefitSupportingInfo);
begin
  assert(value is TFhirExplanationOfBenefitSupportingInfo);
  FhirExplanationOfBenefitSupportingInfos[index] := value;
end;

procedure TFhirExplanationOfBenefitSupportingInfoList.SetItemN(index: Integer; value: TFhirExplanationOfBenefitSupportingInfo);
begin
  assert(value is TFhirExplanationOfBenefitSupportingInfo);
  ObjectByIndex[index] := value;
end;

{ TFhirExplanationOfBenefitDiagnosis }

constructor TFhirExplanationOfBenefitDiagnosis.Create;
begin
  inherited;
end;

destructor TFhirExplanationOfBenefitDiagnosis.Destroy;
begin
  FSequence.free;
  FDiagnosis.free;
  FType_List.Free;
  FOnAdmission.free;
  FPackageCode.free;
  inherited;
end;

procedure TFhirExplanationOfBenefitDiagnosis.Assign(oSource : TFslObject);
begin
  inherited;
  sequenceElement := TFhirExplanationOfBenefitDiagnosis(oSource).sequenceElement.Clone;
  diagnosis := TFhirExplanationOfBenefitDiagnosis(oSource).diagnosis.Clone;
  if (TFhirExplanationOfBenefitDiagnosis(oSource).FType_List = nil) then
  begin
    FType_List.free;
    FType_List := nil;
  end
  else
  begin
    if FType_List = nil then
      FType_List := TFhirCodeableConceptList.Create;
    FType_List.Assign(TFhirExplanationOfBenefitDiagnosis(oSource).FType_List);
  end;
  onAdmission := TFhirExplanationOfBenefitDiagnosis(oSource).onAdmission.Clone;
  packageCode := TFhirExplanationOfBenefitDiagnosis(oSource).packageCode.Clone;
end;

procedure TFhirExplanationOfBenefitDiagnosis.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'sequence') Then
     list.add(self.link, 'sequence', FSequence.Link);
  if (child_name = 'diagnosis[x]') or (child_name = 'diagnosis') Then
     list.add(self.link, 'diagnosis[x]', FDiagnosis.Link);
  if (child_name = 'type') Then
    list.addAll(self, 'type', FType_List);
  if (child_name = 'onAdmission') Then
     list.add(self.link, 'onAdmission', FOnAdmission.Link);
  if (child_name = 'packageCode') Then
     list.add(self.link, 'packageCode', FPackageCode.Link);
end;

procedure TFhirExplanationOfBenefitDiagnosis.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'sequence', 'positiveInt', false, TFhirPositiveInt, FSequence.Link));
  oList.add(TFHIRProperty.create(self, 'diagnosis[x]', 'CodeableConcept|Reference', false, TFhirDataType, FDiagnosis.Link));
  oList.add(TFHIRProperty.create(self, 'type', 'CodeableConcept', true, TFhirCodeableConcept, FType_List.Link));
  oList.add(TFHIRProperty.create(self, 'onAdmission', 'CodeableConcept', false, TFhirCodeableConcept, FOnAdmission.Link));
  oList.add(TFHIRProperty.create(self, 'packageCode', 'CodeableConcept', false, TFhirCodeableConcept, FPackageCode.Link));
end;

function TFhirExplanationOfBenefitDiagnosis.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'sequence') then
  begin
    SequenceElement := asPositiveInt(propValue);
    result := propValue;
  end
  else if (isMatchingName(propName, 'diagnosis', ['CodeableConcept', 'Reference'])) then
  begin
    Diagnosis := propValue as TFhirDataType;
    result := propValue;
  end
  else if (propName = 'type') then
  begin
    Type_List.add(propValue as TFhirCodeableConcept);
    result := propValue;
  end
  else if (propName = 'onAdmission') then
  begin
    OnAdmission := propValue as TFhirCodeableConcept;
    result := propValue;
  end
  else if (propName = 'packageCode') then
  begin
    PackageCode := propValue as TFhirCodeableConcept;
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirExplanationOfBenefitDiagnosis.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'type') then Type_List.insertItem(index, propValue as TFhirCodeableConcept)
  else inherited;
end;

function TFhirExplanationOfBenefitDiagnosis.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'sequence') then result := TFhirPositiveInt.create()
  else if (isMatchingName(propName, 'diagnosis', ['CodeableConcept', 'Reference'])) then raise EFHIRException.create('Cannot make property Diagnosis')
  else if (propName = 'type') then result := Type_List.new()
  else if (propName = 'onAdmission') then result := TFhirCodeableConcept.create()
  else if (propName = 'packageCode') then result := TFhirCodeableConcept.create()
  else result := inherited createPropertyValue(propName);
end;

function TFhirExplanationOfBenefitDiagnosis.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'sequence') then result := 'positiveInt'
  else if (propName = 'diagnosis[x]') then result := 'CodeableConcept|Reference'
  else if (propName = 'type') then result := 'CodeableConcept'
  else if (propName = 'onAdmission') then result := 'CodeableConcept'
  else if (propName = 'packageCode') then result := 'CodeableConcept'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirExplanationOfBenefitDiagnosis.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'sequence') then SequenceElement := nil
  else if (isMatchingName(propName, 'diagnosis', ['CodeableConcept', 'Reference'])) then DiagnosisElement := nil
  else if (propName = 'type') then deletePropertyValue('type', Type_List, value)
  else if (propName = 'onAdmission') then OnAdmissionElement := nil
  else if (propName = 'packageCode') then PackageCodeElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirExplanationOfBenefitDiagnosis.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'sequence') then SequenceElement := asPositiveInt(new)
  else if (isMatchingName(propName, 'diagnosis', ['CodeableConcept', 'Reference'])) then DiagnosisElement := new as TFhirDataType
  else if (propName = 'type') then replacePropertyValue('type', Type_List, existing, new)
  else if (propName = 'onAdmission') then OnAdmissionElement := new as TFhirCodeableConcept
  else if (propName = 'packageCode') then PackageCodeElement := new as TFhirCodeableConcept
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirExplanationOfBenefitDiagnosis.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'type') then Type_List.move(source, destination)
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirExplanationOfBenefitDiagnosis.fhirType : string;
begin
  result := 'ExplanationOfBenefit.diagnosis';
end;

function TFhirExplanationOfBenefitDiagnosis.Link : TFhirExplanationOfBenefitDiagnosis;
begin
  result := TFhirExplanationOfBenefitDiagnosis(inherited Link);
end;

function TFhirExplanationOfBenefitDiagnosis.Clone : TFhirExplanationOfBenefitDiagnosis;
begin
  result := TFhirExplanationOfBenefitDiagnosis(inherited Clone);
end;

function TFhirExplanationOfBenefitDiagnosis.equals(other : TObject) : boolean; 
var
  o : TFhirExplanationOfBenefitDiagnosis;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirExplanationOfBenefitDiagnosis)) then
    result := false
  else
  begin
    o := TFhirExplanationOfBenefitDiagnosis(other);
    result := compareDeep(sequenceElement, o.sequenceElement, true) and compareDeep(diagnosisElement, o.diagnosisElement, true) and 
      compareDeep(type_List, o.type_List, true) and compareDeep(onAdmissionElement, o.onAdmissionElement, true) and 
      compareDeep(packageCodeElement, o.packageCodeElement, true);
  end;
end;

function TFhirExplanationOfBenefitDiagnosis.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FSequence) and isEmptyProp(FDiagnosis) and isEmptyProp(Ftype_List) and isEmptyProp(FOnAdmission) and isEmptyProp(FPackageCode);
end;

procedure TFhirExplanationOfBenefitDiagnosis.listFieldsInOrder(fields : TStringList);
begin
  inherited listFieldsInOrder(fields);
  fields.add('sequence');
  fields.add('diagnosis[x]');
  fields.add('type');
  fields.add('onAdmission');
  fields.add('packageCode');
end;

function TFhirExplanationOfBenefitDiagnosis.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FType_List.sizeInBytes(magic));
end;

procedure TFhirExplanationOfBenefitDiagnosis.SetSequence(value : TFhirPositiveInt);
begin
  FSequence.free;
  FSequence := value;
end;

function TFhirExplanationOfBenefitDiagnosis.GetSequenceST : String;
begin
  if FSequence = nil then
    result := ''
  else
    result := FSequence.value;
end;

procedure TFhirExplanationOfBenefitDiagnosis.SetSequenceST(value : String);
begin
  if value <> '' then
  begin
    if FSequence = nil then
      FSequence := TFhirPositiveInt.create;
    FSequence.value := value
  end
  else if FSequence <> nil then
    FSequence.value := '';
end;

procedure TFhirExplanationOfBenefitDiagnosis.SetDiagnosis(value : TFhirDataType);
begin
  FDiagnosis.free;
  FDiagnosis := value;
end;

function TFhirExplanationOfBenefitDiagnosis.GetType_List : TFhirCodeableConceptList;
begin
  if FType_List = nil then
    FType_List := TFhirCodeableConceptList.Create;
  result := FType_List;
end;

function TFhirExplanationOfBenefitDiagnosis.GetHasType_List : boolean;
begin
  result := (FType_List <> nil) and (FType_List.count > 0);
end;

procedure TFhirExplanationOfBenefitDiagnosis.SetOnAdmission(value : TFhirCodeableConcept);
begin
  FOnAdmission.free;
  FOnAdmission := value;
end;

procedure TFhirExplanationOfBenefitDiagnosis.SetPackageCode(value : TFhirCodeableConcept);
begin
  FPackageCode.free;
  FPackageCode := value;
end;

{ TFhirExplanationOfBenefitDiagnosisListEnumerator }

constructor TFhirExplanationOfBenefitDiagnosisListEnumerator.Create(list : TFhirExplanationOfBenefitDiagnosisList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirExplanationOfBenefitDiagnosisListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirExplanationOfBenefitDiagnosisListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirExplanationOfBenefitDiagnosisListEnumerator.GetCurrent : TFhirExplanationOfBenefitDiagnosis;
begin
  Result := FList[FIndex];
end;

function TFhirExplanationOfBenefitDiagnosisListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirExplanationOfBenefitDiagnosisList }

procedure TFhirExplanationOfBenefitDiagnosisList.AddItem(value: TFhirExplanationOfBenefitDiagnosis);
begin
  assert(value.ClassName = 'TFhirExplanationOfBenefitDiagnosis', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirExplanationOfBenefitDiagnosis');
  add(value);
end;

function TFhirExplanationOfBenefitDiagnosisList.Append: TFhirExplanationOfBenefitDiagnosis;
begin
  result := TFhirExplanationOfBenefitDiagnosis.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirExplanationOfBenefitDiagnosisList.ClearItems;
begin
  Clear;
end;

function TFhirExplanationOfBenefitDiagnosisList.GetEnumerator : TFhirExplanationOfBenefitDiagnosisListEnumerator;
begin
  result := TFhirExplanationOfBenefitDiagnosisListEnumerator.Create(self.link);
end;

function TFhirExplanationOfBenefitDiagnosisList.Clone: TFhirExplanationOfBenefitDiagnosisList;
begin
  result := TFhirExplanationOfBenefitDiagnosisList(inherited Clone);
end;

function TFhirExplanationOfBenefitDiagnosisList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirExplanationOfBenefitDiagnosisList.GetItemN(index: Integer): TFhirExplanationOfBenefitDiagnosis;
begin
  result := TFhirExplanationOfBenefitDiagnosis(ObjectByIndex[index]);
end;

function TFhirExplanationOfBenefitDiagnosisList.ItemClass: TFslObjectClass;
begin
  result := TFhirExplanationOfBenefitDiagnosis;
end;
function TFhirExplanationOfBenefitDiagnosisList.IndexOf(value: TFhirExplanationOfBenefitDiagnosis): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirExplanationOfBenefitDiagnosisList.Insert(index: Integer): TFhirExplanationOfBenefitDiagnosis;
begin
  result := TFhirExplanationOfBenefitDiagnosis.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirExplanationOfBenefitDiagnosisList.InsertItem(index: Integer; value: TFhirExplanationOfBenefitDiagnosis);
begin
  assert(value is TFhirExplanationOfBenefitDiagnosis);
  Inherited Insert(index, value);
end;

function TFhirExplanationOfBenefitDiagnosisList.Item(index: Integer): TFhirExplanationOfBenefitDiagnosis;
begin
  result := TFhirExplanationOfBenefitDiagnosis(ObjectByIndex[index]);
end;

function TFhirExplanationOfBenefitDiagnosisList.Link: TFhirExplanationOfBenefitDiagnosisList;
begin
  result := TFhirExplanationOfBenefitDiagnosisList(inherited Link);
end;

procedure TFhirExplanationOfBenefitDiagnosisList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirExplanationOfBenefitDiagnosisList.SetItemByIndex(index: Integer; value: TFhirExplanationOfBenefitDiagnosis);
begin
  assert(value is TFhirExplanationOfBenefitDiagnosis);
  FhirExplanationOfBenefitDiagnoses[index] := value;
end;

procedure TFhirExplanationOfBenefitDiagnosisList.SetItemN(index: Integer; value: TFhirExplanationOfBenefitDiagnosis);
begin
  assert(value is TFhirExplanationOfBenefitDiagnosis);
  ObjectByIndex[index] := value;
end;

{ TFhirExplanationOfBenefitProcedure }

constructor TFhirExplanationOfBenefitProcedure.Create;
begin
  inherited;
end;

destructor TFhirExplanationOfBenefitProcedure.Destroy;
begin
  FSequence.free;
  FType_List.Free;
  FDate.free;
  FProcedure_.free;
  FUdiList.Free;
  inherited;
end;

procedure TFhirExplanationOfBenefitProcedure.Assign(oSource : TFslObject);
begin
  inherited;
  sequenceElement := TFhirExplanationOfBenefitProcedure(oSource).sequenceElement.Clone;
  if (TFhirExplanationOfBenefitProcedure(oSource).FType_List = nil) then
  begin
    FType_List.free;
    FType_List := nil;
  end
  else
  begin
    if FType_List = nil then
      FType_List := TFhirCodeableConceptList.Create;
    FType_List.Assign(TFhirExplanationOfBenefitProcedure(oSource).FType_List);
  end;
  dateElement := TFhirExplanationOfBenefitProcedure(oSource).dateElement.Clone;
  procedure_ := TFhirExplanationOfBenefitProcedure(oSource).procedure_.Clone;
  if (TFhirExplanationOfBenefitProcedure(oSource).FUdiList = nil) then
  begin
    FUdiList.free;
    FUdiList := nil;
  end
  else
  begin
    if FUdiList = nil then
      FUdiList := TFhirReferenceList.Create;
    FUdiList.Assign(TFhirExplanationOfBenefitProcedure(oSource).FUdiList);
  end;
end;

procedure TFhirExplanationOfBenefitProcedure.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'sequence') Then
     list.add(self.link, 'sequence', FSequence.Link);
  if (child_name = 'type') Then
    list.addAll(self, 'type', FType_List);
  if (child_name = 'date') Then
     list.add(self.link, 'date', FDate.Link);
  if (child_name = 'procedure[x]') or (child_name = 'procedure') Then
     list.add(self.link, 'procedure[x]', FProcedure_.Link);
  if (child_name = 'udi') Then
    list.addAll(self, 'udi', FUdiList);
end;

procedure TFhirExplanationOfBenefitProcedure.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'sequence', 'positiveInt', false, TFhirPositiveInt, FSequence.Link));
  oList.add(TFHIRProperty.create(self, 'type', 'CodeableConcept', true, TFhirCodeableConcept, FType_List.Link));
  oList.add(TFHIRProperty.create(self, 'date', 'dateTime', false, TFhirDateTime, FDate.Link));
  oList.add(TFHIRProperty.create(self, 'procedure[x]', 'CodeableConcept|Reference', false, TFhirDataType, FProcedure_.Link));
  oList.add(TFHIRProperty.create(self, 'udi', 'Reference', true, TFhirReference, FUdiList.Link));
end;

function TFhirExplanationOfBenefitProcedure.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'sequence') then
  begin
    SequenceElement := asPositiveInt(propValue);
    result := propValue;
  end
  else if (propName = 'type') then
  begin
    Type_List.add(propValue as TFhirCodeableConcept);
    result := propValue;
  end
  else if (propName = 'date') then
  begin
    DateElement := asDateTime(propValue);
    result := propValue;
  end
  else if (isMatchingName(propName, 'procedure', ['CodeableConcept', 'Reference'])) then
  begin
    Procedure_ := propValue as TFhirDataType;
    result := propValue;
  end
  else if (propName = 'udi') then
  begin
    UdiList.add(propValue as TFhirReference);
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirExplanationOfBenefitProcedure.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'type') then Type_List.insertItem(index, propValue as TFhirCodeableConcept)
  else if (propName = 'udi') then UdiList.insertItem(index, propValue as TFhirReference)
  else inherited;
end;

function TFhirExplanationOfBenefitProcedure.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'sequence') then result := TFhirPositiveInt.create()
  else if (propName = 'type') then result := Type_List.new()
  else if (propName = 'date') then result := TFhirDateTime.create()
  else if (isMatchingName(propName, 'procedure', ['CodeableConcept', 'Reference'])) then raise EFHIRException.create('Cannot make property Procedure_')
  else if (propName = 'udi') then result := UdiList.new()
  else result := inherited createPropertyValue(propName);
end;

function TFhirExplanationOfBenefitProcedure.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'sequence') then result := 'positiveInt'
  else if (propName = 'type') then result := 'CodeableConcept'
  else if (propName = 'date') then result := 'dateTime'
  else if (propName = 'procedure[x]') then result := 'CodeableConcept|Reference'
  else if (propName = 'udi') then result := 'Reference'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirExplanationOfBenefitProcedure.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'sequence') then SequenceElement := nil
  else if (propName = 'type') then deletePropertyValue('type', Type_List, value)
  else if (propName = 'date') then DateElement := nil
  else if (isMatchingName(propName, 'procedure', ['CodeableConcept', 'Reference'])) then Procedure_Element := nil
  else if (propName = 'udi') then deletePropertyValue('udi', UdiList, value)
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirExplanationOfBenefitProcedure.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'sequence') then SequenceElement := asPositiveInt(new)
  else if (propName = 'type') then replacePropertyValue('type', Type_List, existing, new)
  else if (propName = 'date') then DateElement := asDateTime(new)
  else if (isMatchingName(propName, 'procedure', ['CodeableConcept', 'Reference'])) then Procedure_Element := new as TFhirDataType
  else if (propName = 'udi') then replacePropertyValue('udi', UdiList, existing, new)
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirExplanationOfBenefitProcedure.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'type') then Type_List.move(source, destination)
  else if (propName = 'udi') then UdiList.move(source, destination)
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirExplanationOfBenefitProcedure.fhirType : string;
begin
  result := 'ExplanationOfBenefit.procedure';
end;

function TFhirExplanationOfBenefitProcedure.Link : TFhirExplanationOfBenefitProcedure;
begin
  result := TFhirExplanationOfBenefitProcedure(inherited Link);
end;

function TFhirExplanationOfBenefitProcedure.Clone : TFhirExplanationOfBenefitProcedure;
begin
  result := TFhirExplanationOfBenefitProcedure(inherited Clone);
end;

function TFhirExplanationOfBenefitProcedure.equals(other : TObject) : boolean; 
var
  o : TFhirExplanationOfBenefitProcedure;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirExplanationOfBenefitProcedure)) then
    result := false
  else
  begin
    o := TFhirExplanationOfBenefitProcedure(other);
    result := compareDeep(sequenceElement, o.sequenceElement, true) and compareDeep(type_List, o.type_List, true) and 
      compareDeep(dateElement, o.dateElement, true) and compareDeep(procedure_Element, o.procedure_Element, true) and 
      compareDeep(udiList, o.udiList, true);
  end;
end;

function TFhirExplanationOfBenefitProcedure.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FSequence) and isEmptyProp(Ftype_List) and isEmptyProp(FDate) and isEmptyProp(FProcedure_) and isEmptyProp(FudiList);
end;

procedure TFhirExplanationOfBenefitProcedure.listFieldsInOrder(fields : TStringList);
begin
  inherited listFieldsInOrder(fields);
  fields.add('sequence');
  fields.add('type');
  fields.add('date');
  fields.add('procedure[x]');
  fields.add('udi');
end;

function TFhirExplanationOfBenefitProcedure.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FType_List.sizeInBytes(magic));
  inc(result, FUdiList.sizeInBytes(magic));
end;

procedure TFhirExplanationOfBenefitProcedure.SetSequence(value : TFhirPositiveInt);
begin
  FSequence.free;
  FSequence := value;
end;

function TFhirExplanationOfBenefitProcedure.GetSequenceST : String;
begin
  if FSequence = nil then
    result := ''
  else
    result := FSequence.value;
end;

procedure TFhirExplanationOfBenefitProcedure.SetSequenceST(value : String);
begin
  if value <> '' then
  begin
    if FSequence = nil then
      FSequence := TFhirPositiveInt.create;
    FSequence.value := value
  end
  else if FSequence <> nil then
    FSequence.value := '';
end;

function TFhirExplanationOfBenefitProcedure.GetType_List : TFhirCodeableConceptList;
begin
  if FType_List = nil then
    FType_List := TFhirCodeableConceptList.Create;
  result := FType_List;
end;

function TFhirExplanationOfBenefitProcedure.GetHasType_List : boolean;
begin
  result := (FType_List <> nil) and (FType_List.count > 0);
end;

procedure TFhirExplanationOfBenefitProcedure.SetDate(value : TFhirDateTime);
begin
  FDate.free;
  FDate := value;
end;

function TFhirExplanationOfBenefitProcedure.GetDateST : TFslDateTime;
begin
  if FDate = nil then
    result := TFslDateTime.makeNull
  else
    result := FDate.value;
end;

procedure TFhirExplanationOfBenefitProcedure.SetDateST(value : TFslDateTime);
begin
  if FDate = nil then
    FDate := TFhirDateTime.create;
  FDate.value := value
end;

procedure TFhirExplanationOfBenefitProcedure.SetProcedure_(value : TFhirDataType);
begin
  FProcedure_.free;
  FProcedure_ := value;
end;

function TFhirExplanationOfBenefitProcedure.GetUdiList : TFhirReferenceList;
begin
  if FUdiList = nil then
    FUdiList := TFhirReferenceList.Create;
  result := FUdiList;
end;

function TFhirExplanationOfBenefitProcedure.GetHasUdiList : boolean;
begin
  result := (FUdiList <> nil) and (FUdiList.count > 0);
end;

{ TFhirExplanationOfBenefitProcedureListEnumerator }

constructor TFhirExplanationOfBenefitProcedureListEnumerator.Create(list : TFhirExplanationOfBenefitProcedureList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirExplanationOfBenefitProcedureListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirExplanationOfBenefitProcedureListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirExplanationOfBenefitProcedureListEnumerator.GetCurrent : TFhirExplanationOfBenefitProcedure;
begin
  Result := FList[FIndex];
end;

function TFhirExplanationOfBenefitProcedureListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirExplanationOfBenefitProcedureList }

procedure TFhirExplanationOfBenefitProcedureList.AddItem(value: TFhirExplanationOfBenefitProcedure);
begin
  assert(value.ClassName = 'TFhirExplanationOfBenefitProcedure', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirExplanationOfBenefitProcedure');
  add(value);
end;

function TFhirExplanationOfBenefitProcedureList.Append: TFhirExplanationOfBenefitProcedure;
begin
  result := TFhirExplanationOfBenefitProcedure.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirExplanationOfBenefitProcedureList.ClearItems;
begin
  Clear;
end;

function TFhirExplanationOfBenefitProcedureList.GetEnumerator : TFhirExplanationOfBenefitProcedureListEnumerator;
begin
  result := TFhirExplanationOfBenefitProcedureListEnumerator.Create(self.link);
end;

function TFhirExplanationOfBenefitProcedureList.Clone: TFhirExplanationOfBenefitProcedureList;
begin
  result := TFhirExplanationOfBenefitProcedureList(inherited Clone);
end;

function TFhirExplanationOfBenefitProcedureList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirExplanationOfBenefitProcedureList.GetItemN(index: Integer): TFhirExplanationOfBenefitProcedure;
begin
  result := TFhirExplanationOfBenefitProcedure(ObjectByIndex[index]);
end;

function TFhirExplanationOfBenefitProcedureList.ItemClass: TFslObjectClass;
begin
  result := TFhirExplanationOfBenefitProcedure;
end;
function TFhirExplanationOfBenefitProcedureList.IndexOf(value: TFhirExplanationOfBenefitProcedure): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirExplanationOfBenefitProcedureList.Insert(index: Integer): TFhirExplanationOfBenefitProcedure;
begin
  result := TFhirExplanationOfBenefitProcedure.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirExplanationOfBenefitProcedureList.InsertItem(index: Integer; value: TFhirExplanationOfBenefitProcedure);
begin
  assert(value is TFhirExplanationOfBenefitProcedure);
  Inherited Insert(index, value);
end;

function TFhirExplanationOfBenefitProcedureList.Item(index: Integer): TFhirExplanationOfBenefitProcedure;
begin
  result := TFhirExplanationOfBenefitProcedure(ObjectByIndex[index]);
end;

function TFhirExplanationOfBenefitProcedureList.Link: TFhirExplanationOfBenefitProcedureList;
begin
  result := TFhirExplanationOfBenefitProcedureList(inherited Link);
end;

procedure TFhirExplanationOfBenefitProcedureList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirExplanationOfBenefitProcedureList.SetItemByIndex(index: Integer; value: TFhirExplanationOfBenefitProcedure);
begin
  assert(value is TFhirExplanationOfBenefitProcedure);
  FhirExplanationOfBenefitProcedures[index] := value;
end;

procedure TFhirExplanationOfBenefitProcedureList.SetItemN(index: Integer; value: TFhirExplanationOfBenefitProcedure);
begin
  assert(value is TFhirExplanationOfBenefitProcedure);
  ObjectByIndex[index] := value;
end;

{ TFhirExplanationOfBenefitInsurance }

constructor TFhirExplanationOfBenefitInsurance.Create;
begin
  inherited;
end;

destructor TFhirExplanationOfBenefitInsurance.Destroy;
begin
  FFocal.free;
  FCoverage.free;
  FPreAuthRefList.Free;
  inherited;
end;

procedure TFhirExplanationOfBenefitInsurance.Assign(oSource : TFslObject);
begin
  inherited;
  focalElement := TFhirExplanationOfBenefitInsurance(oSource).focalElement.Clone;
  coverage := TFhirExplanationOfBenefitInsurance(oSource).coverage.Clone;
  if (TFhirExplanationOfBenefitInsurance(oSource).FPreAuthRefList = nil) then
  begin
    FPreAuthRefList.free;
    FPreAuthRefList := nil;
  end
  else
  begin
    if FPreAuthRefList = nil then
      FPreAuthRefList := TFhirStringList.Create;
    FPreAuthRefList.Assign(TFhirExplanationOfBenefitInsurance(oSource).FPreAuthRefList);
  end;
end;

procedure TFhirExplanationOfBenefitInsurance.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'focal') Then
     list.add(self.link, 'focal', FFocal.Link);
  if (child_name = 'coverage') Then
     list.add(self.link, 'coverage', FCoverage.Link);
  if (child_name = 'preAuthRef') Then
    list.addAll(self, 'preAuthRef', FPreAuthRefList);
end;

procedure TFhirExplanationOfBenefitInsurance.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'focal', 'boolean', false, TFhirBoolean, FFocal.Link));
  oList.add(TFHIRProperty.create(self, 'coverage', 'Reference', false, TFhirReference, FCoverage.Link));
  oList.add(TFHIRProperty.create(self, 'preAuthRef', 'string', true, TFhirString, FPreAuthRefList.Link));
end;

function TFhirExplanationOfBenefitInsurance.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'focal') then
  begin
    FocalElement := asBoolean(propValue);
    result := propValue;
  end
  else if (propName = 'coverage') then
  begin
    Coverage := propValue as TFhirReference;
    result := propValue;
  end
  else if (propName = 'preAuthRef') then
  begin
    PreAuthRefList.add(asString(propValue)){2};     result := propValue;

  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirExplanationOfBenefitInsurance.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'preAuthRef') then PreAuthRefList.insertItem(index, asString(propValue))
  else inherited;
end;

function TFhirExplanationOfBenefitInsurance.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'focal') then result := TFhirBoolean.create()
  else if (propName = 'coverage') then result := TFhirReference.create()
  else if (propName = 'preAuthRef') then result := PreAuthRefList.new()
  else result := inherited createPropertyValue(propName);
end;

function TFhirExplanationOfBenefitInsurance.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'focal') then result := 'boolean'
  else if (propName = 'coverage') then result := 'Reference'
  else if (propName = 'preAuthRef') then result := 'string'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirExplanationOfBenefitInsurance.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'focal') then FocalElement := nil
  else if (propName = 'coverage') then CoverageElement := nil
  else if (propName = 'preAuthRef') then deletePropertyValue('preAuthRef', PreAuthRefList, value)
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirExplanationOfBenefitInsurance.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'focal') then FocalElement := asBoolean(new)
  else if (propName = 'coverage') then CoverageElement := new as TFhirReference
  else if (propName = 'preAuthRef') then replacePropertyValue('preAuthRef', PreAuthRefList, existing, new)
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirExplanationOfBenefitInsurance.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'preAuthRef') then PreAuthRefList.move(source, destination)
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirExplanationOfBenefitInsurance.fhirType : string;
begin
  result := 'ExplanationOfBenefit.insurance';
end;

function TFhirExplanationOfBenefitInsurance.Link : TFhirExplanationOfBenefitInsurance;
begin
  result := TFhirExplanationOfBenefitInsurance(inherited Link);
end;

function TFhirExplanationOfBenefitInsurance.Clone : TFhirExplanationOfBenefitInsurance;
begin
  result := TFhirExplanationOfBenefitInsurance(inherited Clone);
end;

function TFhirExplanationOfBenefitInsurance.equals(other : TObject) : boolean; 
var
  o : TFhirExplanationOfBenefitInsurance;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirExplanationOfBenefitInsurance)) then
    result := false
  else
  begin
    o := TFhirExplanationOfBenefitInsurance(other);
    result := compareDeep(focalElement, o.focalElement, true) and compareDeep(coverageElement, o.coverageElement, true) and 
      compareDeep(preAuthRefList, o.preAuthRefList, true);
  end;
end;

function TFhirExplanationOfBenefitInsurance.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FFocal) and isEmptyProp(FCoverage) and isEmptyProp(FpreAuthRefList);
end;

procedure TFhirExplanationOfBenefitInsurance.listFieldsInOrder(fields : TStringList);
begin
  inherited listFieldsInOrder(fields);
  fields.add('focal');
  fields.add('coverage');
  fields.add('preAuthRef');
end;

function TFhirExplanationOfBenefitInsurance.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FPreAuthRefList.sizeInBytes(magic));
end;

procedure TFhirExplanationOfBenefitInsurance.SetFocal(value : TFhirBoolean);
begin
  FFocal.free;
  FFocal := value;
end;

function TFhirExplanationOfBenefitInsurance.GetFocalST : Boolean;
begin
  if FFocal = nil then
    result := false
  else
    result := FFocal.value;
end;

procedure TFhirExplanationOfBenefitInsurance.SetFocalST(value : Boolean);
begin
  if FFocal = nil then
    FFocal := TFhirBoolean.create;
  FFocal.value := value
end;

procedure TFhirExplanationOfBenefitInsurance.SetCoverage(value : TFhirReference);
begin
  FCoverage.free;
  FCoverage := value;
end;

function TFhirExplanationOfBenefitInsurance.GetPreAuthRefList : TFhirStringList;
begin
  if FPreAuthRefList = nil then
    FPreAuthRefList := TFhirStringList.Create;
  result := FPreAuthRefList;
end;

function TFhirExplanationOfBenefitInsurance.GetHasPreAuthRefList : boolean;
begin
  result := (FPreAuthRefList <> nil) and (FPreAuthRefList.count > 0);
end;

{ TFhirExplanationOfBenefitInsuranceListEnumerator }

constructor TFhirExplanationOfBenefitInsuranceListEnumerator.Create(list : TFhirExplanationOfBenefitInsuranceList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirExplanationOfBenefitInsuranceListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirExplanationOfBenefitInsuranceListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirExplanationOfBenefitInsuranceListEnumerator.GetCurrent : TFhirExplanationOfBenefitInsurance;
begin
  Result := FList[FIndex];
end;

function TFhirExplanationOfBenefitInsuranceListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirExplanationOfBenefitInsuranceList }

procedure TFhirExplanationOfBenefitInsuranceList.AddItem(value: TFhirExplanationOfBenefitInsurance);
begin
  assert(value.ClassName = 'TFhirExplanationOfBenefitInsurance', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirExplanationOfBenefitInsurance');
  add(value);
end;

function TFhirExplanationOfBenefitInsuranceList.Append: TFhirExplanationOfBenefitInsurance;
begin
  result := TFhirExplanationOfBenefitInsurance.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirExplanationOfBenefitInsuranceList.ClearItems;
begin
  Clear;
end;

function TFhirExplanationOfBenefitInsuranceList.GetEnumerator : TFhirExplanationOfBenefitInsuranceListEnumerator;
begin
  result := TFhirExplanationOfBenefitInsuranceListEnumerator.Create(self.link);
end;

function TFhirExplanationOfBenefitInsuranceList.Clone: TFhirExplanationOfBenefitInsuranceList;
begin
  result := TFhirExplanationOfBenefitInsuranceList(inherited Clone);
end;

function TFhirExplanationOfBenefitInsuranceList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirExplanationOfBenefitInsuranceList.GetItemN(index: Integer): TFhirExplanationOfBenefitInsurance;
begin
  result := TFhirExplanationOfBenefitInsurance(ObjectByIndex[index]);
end;

function TFhirExplanationOfBenefitInsuranceList.ItemClass: TFslObjectClass;
begin
  result := TFhirExplanationOfBenefitInsurance;
end;
function TFhirExplanationOfBenefitInsuranceList.IndexOf(value: TFhirExplanationOfBenefitInsurance): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirExplanationOfBenefitInsuranceList.Insert(index: Integer): TFhirExplanationOfBenefitInsurance;
begin
  result := TFhirExplanationOfBenefitInsurance.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirExplanationOfBenefitInsuranceList.InsertItem(index: Integer; value: TFhirExplanationOfBenefitInsurance);
begin
  assert(value is TFhirExplanationOfBenefitInsurance);
  Inherited Insert(index, value);
end;

function TFhirExplanationOfBenefitInsuranceList.Item(index: Integer): TFhirExplanationOfBenefitInsurance;
begin
  result := TFhirExplanationOfBenefitInsurance(ObjectByIndex[index]);
end;

function TFhirExplanationOfBenefitInsuranceList.Link: TFhirExplanationOfBenefitInsuranceList;
begin
  result := TFhirExplanationOfBenefitInsuranceList(inherited Link);
end;

procedure TFhirExplanationOfBenefitInsuranceList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirExplanationOfBenefitInsuranceList.SetItemByIndex(index: Integer; value: TFhirExplanationOfBenefitInsurance);
begin
  assert(value is TFhirExplanationOfBenefitInsurance);
  FhirExplanationOfBenefitInsurances[index] := value;
end;

procedure TFhirExplanationOfBenefitInsuranceList.SetItemN(index: Integer; value: TFhirExplanationOfBenefitInsurance);
begin
  assert(value is TFhirExplanationOfBenefitInsurance);
  ObjectByIndex[index] := value;
end;

{ TFhirExplanationOfBenefitAccident }

constructor TFhirExplanationOfBenefitAccident.Create;
begin
  inherited;
end;

destructor TFhirExplanationOfBenefitAccident.Destroy;
begin
  FDate.free;
  FType_.free;
  FLocation.free;
  inherited;
end;

procedure TFhirExplanationOfBenefitAccident.Assign(oSource : TFslObject);
begin
  inherited;
  dateElement := TFhirExplanationOfBenefitAccident(oSource).dateElement.Clone;
  type_ := TFhirExplanationOfBenefitAccident(oSource).type_.Clone;
  location := TFhirExplanationOfBenefitAccident(oSource).location.Clone;
end;

procedure TFhirExplanationOfBenefitAccident.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'date') Then
     list.add(self.link, 'date', FDate.Link);
  if (child_name = 'type') Then
     list.add(self.link, 'type', FType_.Link);
  if (child_name = 'location[x]') or (child_name = 'location') Then
     list.add(self.link, 'location[x]', FLocation.Link);
end;

procedure TFhirExplanationOfBenefitAccident.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'date', 'date', false, TFhirDate, FDate.Link));
  oList.add(TFHIRProperty.create(self, 'type', 'CodeableConcept', false, TFhirCodeableConcept, FType_.Link));
  oList.add(TFHIRProperty.create(self, 'location[x]', 'Address|Reference', false, TFhirDataType, FLocation.Link));
end;

function TFhirExplanationOfBenefitAccident.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'date') then
  begin
    DateElement := asDate(propValue);
    result := propValue;
  end
  else if (propName = 'type') then
  begin
    Type_ := propValue as TFhirCodeableConcept;
    result := propValue;
  end
  else if (isMatchingName(propName, 'location', ['Address', 'Reference'])) then
  begin
    Location := propValue as TFhirDataType;
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirExplanationOfBenefitAccident.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirExplanationOfBenefitAccident.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'date') then result := TFhirDate.create()
  else if (propName = 'type') then result := TFhirCodeableConcept.create()
  else if (isMatchingName(propName, 'location', ['Address', 'Reference'])) then raise EFHIRException.create('Cannot make property Location')
  else result := inherited createPropertyValue(propName);
end;

function TFhirExplanationOfBenefitAccident.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'date') then result := 'date'
  else if (propName = 'type') then result := 'CodeableConcept'
  else if (propName = 'location[x]') then result := 'Address|Reference'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirExplanationOfBenefitAccident.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'date') then DateElement := nil
  else if (propName = 'type') then Type_Element := nil
  else if (isMatchingName(propName, 'location', ['Address', 'Reference'])) then LocationElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirExplanationOfBenefitAccident.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'date') then DateElement := asDate(new)
  else if (propName = 'type') then Type_Element := new as TFhirCodeableConcept
  else if (isMatchingName(propName, 'location', ['Address', 'Reference'])) then LocationElement := new as TFhirDataType
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirExplanationOfBenefitAccident.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirExplanationOfBenefitAccident.fhirType : string;
begin
  result := 'ExplanationOfBenefit.accident';
end;

function TFhirExplanationOfBenefitAccident.Link : TFhirExplanationOfBenefitAccident;
begin
  result := TFhirExplanationOfBenefitAccident(inherited Link);
end;

function TFhirExplanationOfBenefitAccident.Clone : TFhirExplanationOfBenefitAccident;
begin
  result := TFhirExplanationOfBenefitAccident(inherited Clone);
end;

function TFhirExplanationOfBenefitAccident.equals(other : TObject) : boolean; 
var
  o : TFhirExplanationOfBenefitAccident;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirExplanationOfBenefitAccident)) then
    result := false
  else
  begin
    o := TFhirExplanationOfBenefitAccident(other);
    result := compareDeep(dateElement, o.dateElement, true) and compareDeep(type_Element, o.type_Element, true) and 
      compareDeep(locationElement, o.locationElement, true);
  end;
end;

function TFhirExplanationOfBenefitAccident.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FDate) and isEmptyProp(FType_) and isEmptyProp(FLocation);
end;

procedure TFhirExplanationOfBenefitAccident.listFieldsInOrder(fields : TStringList);
begin
  inherited listFieldsInOrder(fields);
  fields.add('date');
  fields.add('type');
  fields.add('location[x]');
end;

function TFhirExplanationOfBenefitAccident.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
end;

procedure TFhirExplanationOfBenefitAccident.SetDate(value : TFhirDate);
begin
  FDate.free;
  FDate := value;
end;

function TFhirExplanationOfBenefitAccident.GetDateST : TFslDateTime;
begin
  if FDate = nil then
    result := TFslDateTime.makeNull
  else
    result := FDate.value;
end;

procedure TFhirExplanationOfBenefitAccident.SetDateST(value : TFslDateTime);
begin
  if FDate = nil then
    FDate := TFhirDate.create;
  FDate.value := value
end;

procedure TFhirExplanationOfBenefitAccident.SetType_(value : TFhirCodeableConcept);
begin
  FType_.free;
  FType_ := value;
end;

procedure TFhirExplanationOfBenefitAccident.SetLocation(value : TFhirDataType);
begin
  FLocation.free;
  FLocation := value;
end;

{ TFhirExplanationOfBenefitAccidentListEnumerator }

constructor TFhirExplanationOfBenefitAccidentListEnumerator.Create(list : TFhirExplanationOfBenefitAccidentList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirExplanationOfBenefitAccidentListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirExplanationOfBenefitAccidentListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirExplanationOfBenefitAccidentListEnumerator.GetCurrent : TFhirExplanationOfBenefitAccident;
begin
  Result := FList[FIndex];
end;

function TFhirExplanationOfBenefitAccidentListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirExplanationOfBenefitAccidentList }

procedure TFhirExplanationOfBenefitAccidentList.AddItem(value: TFhirExplanationOfBenefitAccident);
begin
  assert(value.ClassName = 'TFhirExplanationOfBenefitAccident', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirExplanationOfBenefitAccident');
  add(value);
end;

function TFhirExplanationOfBenefitAccidentList.Append: TFhirExplanationOfBenefitAccident;
begin
  result := TFhirExplanationOfBenefitAccident.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirExplanationOfBenefitAccidentList.ClearItems;
begin
  Clear;
end;

function TFhirExplanationOfBenefitAccidentList.GetEnumerator : TFhirExplanationOfBenefitAccidentListEnumerator;
begin
  result := TFhirExplanationOfBenefitAccidentListEnumerator.Create(self.link);
end;

function TFhirExplanationOfBenefitAccidentList.Clone: TFhirExplanationOfBenefitAccidentList;
begin
  result := TFhirExplanationOfBenefitAccidentList(inherited Clone);
end;

function TFhirExplanationOfBenefitAccidentList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirExplanationOfBenefitAccidentList.GetItemN(index: Integer): TFhirExplanationOfBenefitAccident;
begin
  result := TFhirExplanationOfBenefitAccident(ObjectByIndex[index]);
end;

function TFhirExplanationOfBenefitAccidentList.ItemClass: TFslObjectClass;
begin
  result := TFhirExplanationOfBenefitAccident;
end;
function TFhirExplanationOfBenefitAccidentList.IndexOf(value: TFhirExplanationOfBenefitAccident): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirExplanationOfBenefitAccidentList.Insert(index: Integer): TFhirExplanationOfBenefitAccident;
begin
  result := TFhirExplanationOfBenefitAccident.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirExplanationOfBenefitAccidentList.InsertItem(index: Integer; value: TFhirExplanationOfBenefitAccident);
begin
  assert(value is TFhirExplanationOfBenefitAccident);
  Inherited Insert(index, value);
end;

function TFhirExplanationOfBenefitAccidentList.Item(index: Integer): TFhirExplanationOfBenefitAccident;
begin
  result := TFhirExplanationOfBenefitAccident(ObjectByIndex[index]);
end;

function TFhirExplanationOfBenefitAccidentList.Link: TFhirExplanationOfBenefitAccidentList;
begin
  result := TFhirExplanationOfBenefitAccidentList(inherited Link);
end;

procedure TFhirExplanationOfBenefitAccidentList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirExplanationOfBenefitAccidentList.SetItemByIndex(index: Integer; value: TFhirExplanationOfBenefitAccident);
begin
  assert(value is TFhirExplanationOfBenefitAccident);
  FhirExplanationOfBenefitAccidents[index] := value;
end;

procedure TFhirExplanationOfBenefitAccidentList.SetItemN(index: Integer; value: TFhirExplanationOfBenefitAccident);
begin
  assert(value is TFhirExplanationOfBenefitAccident);
  ObjectByIndex[index] := value;
end;

{ TFhirExplanationOfBenefitItem }

constructor TFhirExplanationOfBenefitItem.Create;
begin
  inherited;
end;

destructor TFhirExplanationOfBenefitItem.Destroy;
begin
  FSequence.free;
  FCareTeamSequenceList.Free;
  FDiagnosisSequenceList.Free;
  FProcedureSequenceList.Free;
  FInformationSequenceList.Free;
  FRevenue.free;
  FCategory.free;
  FProductOrService.free;
  FModifierList.Free;
  FProgramCodeList.Free;
  FServiced.free;
  FLocation.free;
  FQuantity.free;
  FUnitPrice.free;
  FFactor.free;
  FNet.free;
  FUdiList.Free;
  FBodySite.free;
  FSubSiteList.Free;
  FEncounterList.Free;
  FNoteNumberList.Free;
  FAdjudicationList.Free;
  FDetailList.Free;
  inherited;
end;

procedure TFhirExplanationOfBenefitItem.Assign(oSource : TFslObject);
begin
  inherited;
  sequenceElement := TFhirExplanationOfBenefitItem(oSource).sequenceElement.Clone;
  if (TFhirExplanationOfBenefitItem(oSource).FCareTeamSequenceList = nil) then
  begin
    FCareTeamSequenceList.free;
    FCareTeamSequenceList := nil;
  end
  else
  begin
    if FCareTeamSequenceList = nil then
      FCareTeamSequenceList := TFhirPositiveIntList.Create;
    FCareTeamSequenceList.Assign(TFhirExplanationOfBenefitItem(oSource).FCareTeamSequenceList);
  end;
  if (TFhirExplanationOfBenefitItem(oSource).FDiagnosisSequenceList = nil) then
  begin
    FDiagnosisSequenceList.free;
    FDiagnosisSequenceList := nil;
  end
  else
  begin
    if FDiagnosisSequenceList = nil then
      FDiagnosisSequenceList := TFhirPositiveIntList.Create;
    FDiagnosisSequenceList.Assign(TFhirExplanationOfBenefitItem(oSource).FDiagnosisSequenceList);
  end;
  if (TFhirExplanationOfBenefitItem(oSource).FProcedureSequenceList = nil) then
  begin
    FProcedureSequenceList.free;
    FProcedureSequenceList := nil;
  end
  else
  begin
    if FProcedureSequenceList = nil then
      FProcedureSequenceList := TFhirPositiveIntList.Create;
    FProcedureSequenceList.Assign(TFhirExplanationOfBenefitItem(oSource).FProcedureSequenceList);
  end;
  if (TFhirExplanationOfBenefitItem(oSource).FInformationSequenceList = nil) then
  begin
    FInformationSequenceList.free;
    FInformationSequenceList := nil;
  end
  else
  begin
    if FInformationSequenceList = nil then
      FInformationSequenceList := TFhirPositiveIntList.Create;
    FInformationSequenceList.Assign(TFhirExplanationOfBenefitItem(oSource).FInformationSequenceList);
  end;
  revenue := TFhirExplanationOfBenefitItem(oSource).revenue.Clone;
  category := TFhirExplanationOfBenefitItem(oSource).category.Clone;
  productOrService := TFhirExplanationOfBenefitItem(oSource).productOrService.Clone;
  if (TFhirExplanationOfBenefitItem(oSource).FModifierList = nil) then
  begin
    FModifierList.free;
    FModifierList := nil;
  end
  else
  begin
    if FModifierList = nil then
      FModifierList := TFhirCodeableConceptList.Create;
    FModifierList.Assign(TFhirExplanationOfBenefitItem(oSource).FModifierList);
  end;
  if (TFhirExplanationOfBenefitItem(oSource).FProgramCodeList = nil) then
  begin
    FProgramCodeList.free;
    FProgramCodeList := nil;
  end
  else
  begin
    if FProgramCodeList = nil then
      FProgramCodeList := TFhirCodeableConceptList.Create;
    FProgramCodeList.Assign(TFhirExplanationOfBenefitItem(oSource).FProgramCodeList);
  end;
  serviced := TFhirExplanationOfBenefitItem(oSource).serviced.Clone;
  location := TFhirExplanationOfBenefitItem(oSource).location.Clone;
  quantity := TFhirExplanationOfBenefitItem(oSource).quantity.Clone;
  unitPrice := TFhirExplanationOfBenefitItem(oSource).unitPrice.Clone;
  factorElement := TFhirExplanationOfBenefitItem(oSource).factorElement.Clone;
  net := TFhirExplanationOfBenefitItem(oSource).net.Clone;
  if (TFhirExplanationOfBenefitItem(oSource).FUdiList = nil) then
  begin
    FUdiList.free;
    FUdiList := nil;
  end
  else
  begin
    if FUdiList = nil then
      FUdiList := TFhirReferenceList.Create;
    FUdiList.Assign(TFhirExplanationOfBenefitItem(oSource).FUdiList);
  end;
  bodySite := TFhirExplanationOfBenefitItem(oSource).bodySite.Clone;
  if (TFhirExplanationOfBenefitItem(oSource).FSubSiteList = nil) then
  begin
    FSubSiteList.free;
    FSubSiteList := nil;
  end
  else
  begin
    if FSubSiteList = nil then
      FSubSiteList := TFhirCodeableConceptList.Create;
    FSubSiteList.Assign(TFhirExplanationOfBenefitItem(oSource).FSubSiteList);
  end;
  if (TFhirExplanationOfBenefitItem(oSource).FEncounterList = nil) then
  begin
    FEncounterList.free;
    FEncounterList := nil;
  end
  else
  begin
    if FEncounterList = nil then
      FEncounterList := TFhirReferenceList.Create;
    FEncounterList.Assign(TFhirExplanationOfBenefitItem(oSource).FEncounterList);
  end;
  if (TFhirExplanationOfBenefitItem(oSource).FNoteNumberList = nil) then
  begin
    FNoteNumberList.free;
    FNoteNumberList := nil;
  end
  else
  begin
    if FNoteNumberList = nil then
      FNoteNumberList := TFhirPositiveIntList.Create;
    FNoteNumberList.Assign(TFhirExplanationOfBenefitItem(oSource).FNoteNumberList);
  end;
  if (TFhirExplanationOfBenefitItem(oSource).FAdjudicationList = nil) then
  begin
    FAdjudicationList.free;
    FAdjudicationList := nil;
  end
  else
  begin
    if FAdjudicationList = nil then
      FAdjudicationList := TFhirExplanationOfBenefitItemAdjudicationList.Create;
    FAdjudicationList.Assign(TFhirExplanationOfBenefitItem(oSource).FAdjudicationList);
  end;
  if (TFhirExplanationOfBenefitItem(oSource).FDetailList = nil) then
  begin
    FDetailList.free;
    FDetailList := nil;
  end
  else
  begin
    if FDetailList = nil then
      FDetailList := TFhirExplanationOfBenefitItemDetailList.Create;
    FDetailList.Assign(TFhirExplanationOfBenefitItem(oSource).FDetailList);
  end;
end;

procedure TFhirExplanationOfBenefitItem.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'sequence') Then
     list.add(self.link, 'sequence', FSequence.Link);
  if (child_name = 'careTeamSequence') Then
    list.addAll(self, 'careTeamSequence', FCareTeamSequenceList);
  if (child_name = 'diagnosisSequence') Then
    list.addAll(self, 'diagnosisSequence', FDiagnosisSequenceList);
  if (child_name = 'procedureSequence') Then
    list.addAll(self, 'procedureSequence', FProcedureSequenceList);
  if (child_name = 'informationSequence') Then
    list.addAll(self, 'informationSequence', FInformationSequenceList);
  if (child_name = 'revenue') Then
     list.add(self.link, 'revenue', FRevenue.Link);
  if (child_name = 'category') Then
     list.add(self.link, 'category', FCategory.Link);
  if (child_name = 'productOrService') Then
     list.add(self.link, 'productOrService', FProductOrService.Link);
  if (child_name = 'modifier') Then
    list.addAll(self, 'modifier', FModifierList);
  if (child_name = 'programCode') Then
    list.addAll(self, 'programCode', FProgramCodeList);
  if (child_name = 'serviced[x]') or (child_name = 'serviced') Then
     list.add(self.link, 'serviced[x]', FServiced.Link);
  if (child_name = 'location[x]') or (child_name = 'location') Then
     list.add(self.link, 'location[x]', FLocation.Link);
  if (child_name = 'quantity') Then
     list.add(self.link, 'quantity', FQuantity.Link);
  if (child_name = 'unitPrice') Then
     list.add(self.link, 'unitPrice', FUnitPrice.Link);
  if (child_name = 'factor') Then
     list.add(self.link, 'factor', FFactor.Link);
  if (child_name = 'net') Then
     list.add(self.link, 'net', FNet.Link);
  if (child_name = 'udi') Then
    list.addAll(self, 'udi', FUdiList);
  if (child_name = 'bodySite') Then
     list.add(self.link, 'bodySite', FBodySite.Link);
  if (child_name = 'subSite') Then
    list.addAll(self, 'subSite', FSubSiteList);
  if (child_name = 'encounter') Then
    list.addAll(self, 'encounter', FEncounterList);
  if (child_name = 'noteNumber') Then
    list.addAll(self, 'noteNumber', FNoteNumberList);
  if (child_name = 'adjudication') Then
    list.addAll(self, 'adjudication', FAdjudicationList);
  if (child_name = 'detail') Then
    list.addAll(self, 'detail', FDetailList);
end;

procedure TFhirExplanationOfBenefitItem.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'sequence', 'positiveInt', false, TFhirPositiveInt, FSequence.Link));
  oList.add(TFHIRProperty.create(self, 'careTeamSequence', 'positiveInt', true, TFhirPositiveInt, FCareTeamSequenceList.Link));
  oList.add(TFHIRProperty.create(self, 'diagnosisSequence', 'positiveInt', true, TFhirPositiveInt, FDiagnosisSequenceList.Link));
  oList.add(TFHIRProperty.create(self, 'procedureSequence', 'positiveInt', true, TFhirPositiveInt, FProcedureSequenceList.Link));
  oList.add(TFHIRProperty.create(self, 'informationSequence', 'positiveInt', true, TFhirPositiveInt, FInformationSequenceList.Link));
  oList.add(TFHIRProperty.create(self, 'revenue', 'CodeableConcept', false, TFhirCodeableConcept, FRevenue.Link));
  oList.add(TFHIRProperty.create(self, 'category', 'CodeableConcept', false, TFhirCodeableConcept, FCategory.Link));
  oList.add(TFHIRProperty.create(self, 'productOrService', 'CodeableConcept', false, TFhirCodeableConcept, FProductOrService.Link));
  oList.add(TFHIRProperty.create(self, 'modifier', 'CodeableConcept', true, TFhirCodeableConcept, FModifierList.Link));
  oList.add(TFHIRProperty.create(self, 'programCode', 'CodeableConcept', true, TFhirCodeableConcept, FProgramCodeList.Link));
  oList.add(TFHIRProperty.create(self, 'serviced[x]', 'date|Period', false, TFhirDataType, FServiced.Link));
  oList.add(TFHIRProperty.create(self, 'location[x]', 'CodeableConcept|Address|Reference', false, TFhirDataType, FLocation.Link));
  oList.add(TFHIRProperty.create(self, 'quantity', 'Quantity', false, TFhirQuantity, FQuantity.Link));
  oList.add(TFHIRProperty.create(self, 'unitPrice', 'Money', false, TFhirMoney, FUnitPrice.Link));
  oList.add(TFHIRProperty.create(self, 'factor', 'decimal', false, TFhirDecimal, FFactor.Link));
  oList.add(TFHIRProperty.create(self, 'net', 'Money', false, TFhirMoney, FNet.Link));
  oList.add(TFHIRProperty.create(self, 'udi', 'Reference', true, TFhirReference, FUdiList.Link));
  oList.add(TFHIRProperty.create(self, 'bodySite', 'CodeableConcept', false, TFhirCodeableConcept, FBodySite.Link));
  oList.add(TFHIRProperty.create(self, 'subSite', 'CodeableConcept', true, TFhirCodeableConcept, FSubSiteList.Link));
  oList.add(TFHIRProperty.create(self, 'encounter', 'Reference', true, TFhirReference, FEncounterList.Link));
  oList.add(TFHIRProperty.create(self, 'noteNumber', 'positiveInt', true, TFhirPositiveInt, FNoteNumberList.Link));
  oList.add(TFHIRProperty.create(self, 'adjudication', 'BackboneElement', true, TFhirExplanationOfBenefitItemAdjudication, FAdjudicationList.Link));
  oList.add(TFHIRProperty.create(self, 'detail', 'BackboneElement', true, TFhirExplanationOfBenefitItemDetail, FDetailList.Link));
end;

function TFhirExplanationOfBenefitItem.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'sequence') then
  begin
    SequenceElement := asPositiveInt(propValue);
    result := propValue;
  end
  else if (propName = 'careTeamSequence') then
  begin
    CareTeamSequenceList.add(asPositiveInt(propValue)){2};     result := propValue;

  end
  else if (propName = 'diagnosisSequence') then
  begin
    DiagnosisSequenceList.add(asPositiveInt(propValue)){2};     result := propValue;

  end
  else if (propName = 'procedureSequence') then
  begin
    ProcedureSequenceList.add(asPositiveInt(propValue)){2};     result := propValue;

  end
  else if (propName = 'informationSequence') then
  begin
    InformationSequenceList.add(asPositiveInt(propValue)){2};     result := propValue;

  end
  else if (propName = 'revenue') then
  begin
    Revenue := propValue as TFhirCodeableConcept;
    result := propValue;
  end
  else if (propName = 'category') then
  begin
    Category := propValue as TFhirCodeableConcept;
    result := propValue;
  end
  else if (propName = 'productOrService') then
  begin
    ProductOrService := propValue as TFhirCodeableConcept;
    result := propValue;
  end
  else if (propName = 'modifier') then
  begin
    ModifierList.add(propValue as TFhirCodeableConcept);
    result := propValue;
  end
  else if (propName = 'programCode') then
  begin
    ProgramCodeList.add(propValue as TFhirCodeableConcept);
    result := propValue;
  end
  else if (isMatchingName(propName, 'serviced', ['Date', 'Period'])) then
  begin
    Serviced := propValue as TFhirDataType;
    result := propValue;
  end
  else if (isMatchingName(propName, 'location', ['CodeableConcept', 'Address', 'Reference'])) then
  begin
    Location := propValue as TFhirDataType;
    result := propValue;
  end
  else if (propName = 'quantity') then
  begin
    Quantity := propValue as TFhirQuantity;
    result := propValue;
  end
  else if (propName = 'unitPrice') then
  begin
    UnitPrice := propValue as TFhirMoney;
    result := propValue;
  end
  else if (propName = 'factor') then
  begin
    FactorElement := asDecimal(propValue);
    result := propValue;
  end
  else if (propName = 'net') then
  begin
    Net := propValue as TFhirMoney;
    result := propValue;
  end
  else if (propName = 'udi') then
  begin
    UdiList.add(propValue as TFhirReference);
    result := propValue;
  end
  else if (propName = 'bodySite') then
  begin
    BodySite := propValue as TFhirCodeableConcept;
    result := propValue;
  end
  else if (propName = 'subSite') then
  begin
    SubSiteList.add(propValue as TFhirCodeableConcept);
    result := propValue;
  end
  else if (propName = 'encounter') then
  begin
    EncounterList.add(propValue as TFhirReference);
    result := propValue;
  end
  else if (propName = 'noteNumber') then
  begin
    NoteNumberList.add(asPositiveInt(propValue)){2};     result := propValue;

  end
  else if (propName = 'adjudication') then
  begin
    AdjudicationList.add(propValue as TFhirExplanationOfBenefitItemAdjudication);
    result := propValue;
  end
  else if (propName = 'detail') then
  begin
    DetailList.add(propValue as TFhirExplanationOfBenefitItemDetail);
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirExplanationOfBenefitItem.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'careTeamSequence') then CareTeamSequenceList.insertItem(index, asPositiveInt(propValue))
  else if (propName = 'diagnosisSequence') then DiagnosisSequenceList.insertItem(index, asPositiveInt(propValue))
  else if (propName = 'procedureSequence') then ProcedureSequenceList.insertItem(index, asPositiveInt(propValue))
  else if (propName = 'informationSequence') then InformationSequenceList.insertItem(index, asPositiveInt(propValue))
  else if (propName = 'modifier') then ModifierList.insertItem(index, propValue as TFhirCodeableConcept)
  else if (propName = 'programCode') then ProgramCodeList.insertItem(index, propValue as TFhirCodeableConcept)
  else if (propName = 'udi') then UdiList.insertItem(index, propValue as TFhirReference)
  else if (propName = 'subSite') then SubSiteList.insertItem(index, propValue as TFhirCodeableConcept)
  else if (propName = 'encounter') then EncounterList.insertItem(index, propValue as TFhirReference)
  else if (propName = 'noteNumber') then NoteNumberList.insertItem(index, asPositiveInt(propValue))
  else if (propName = 'adjudication') then AdjudicationList.insertItem(index, propValue as TFhirExplanationOfBenefitItemAdjudication)
  else if (propName = 'detail') then DetailList.insertItem(index, propValue as TFhirExplanationOfBenefitItemDetail)
  else inherited;
end;

function TFhirExplanationOfBenefitItem.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'sequence') then result := TFhirPositiveInt.create()
  else if (propName = 'careTeamSequence') then result := CareTeamSequenceList.new()
  else if (propName = 'diagnosisSequence') then result := DiagnosisSequenceList.new()
  else if (propName = 'procedureSequence') then result := ProcedureSequenceList.new()
  else if (propName = 'informationSequence') then result := InformationSequenceList.new()
  else if (propName = 'revenue') then result := TFhirCodeableConcept.create()
  else if (propName = 'category') then result := TFhirCodeableConcept.create()
  else if (propName = 'productOrService') then result := TFhirCodeableConcept.create()
  else if (propName = 'modifier') then result := ModifierList.new()
  else if (propName = 'programCode') then result := ProgramCodeList.new()
  else if (isMatchingName(propName, 'serviced', ['Date', 'Period'])) then raise EFHIRException.create('Cannot make property Serviced')
  else if (isMatchingName(propName, 'location', ['CodeableConcept', 'Address', 'Reference'])) then raise EFHIRException.create('Cannot make property Location')
  else if (propName = 'quantity') then result := TFhirQuantity.create()
  else if (propName = 'unitPrice') then result := TFhirMoney.create()
  else if (propName = 'factor') then result := TFhirDecimal.create()
  else if (propName = 'net') then result := TFhirMoney.create()
  else if (propName = 'udi') then result := UdiList.new()
  else if (propName = 'bodySite') then result := TFhirCodeableConcept.create()
  else if (propName = 'subSite') then result := SubSiteList.new()
  else if (propName = 'encounter') then result := EncounterList.new()
  else if (propName = 'noteNumber') then result := NoteNumberList.new()
  else if (propName = 'adjudication') then result := AdjudicationList.new()
  else if (propName = 'detail') then result := DetailList.new()
  else result := inherited createPropertyValue(propName);
end;

function TFhirExplanationOfBenefitItem.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'sequence') then result := 'positiveInt'
  else if (propName = 'careTeamSequence') then result := 'positiveInt'
  else if (propName = 'diagnosisSequence') then result := 'positiveInt'
  else if (propName = 'procedureSequence') then result := 'positiveInt'
  else if (propName = 'informationSequence') then result := 'positiveInt'
  else if (propName = 'revenue') then result := 'CodeableConcept'
  else if (propName = 'category') then result := 'CodeableConcept'
  else if (propName = 'productOrService') then result := 'CodeableConcept'
  else if (propName = 'modifier') then result := 'CodeableConcept'
  else if (propName = 'programCode') then result := 'CodeableConcept'
  else if (propName = 'serviced[x]') then result := 'date|Period'
  else if (propName = 'location[x]') then result := 'CodeableConcept|Address|Reference'
  else if (propName = 'quantity') then result := 'Quantity'
  else if (propName = 'unitPrice') then result := 'Money'
  else if (propName = 'factor') then result := 'decimal'
  else if (propName = 'net') then result := 'Money'
  else if (propName = 'udi') then result := 'Reference'
  else if (propName = 'bodySite') then result := 'CodeableConcept'
  else if (propName = 'subSite') then result := 'CodeableConcept'
  else if (propName = 'encounter') then result := 'Reference'
  else if (propName = 'noteNumber') then result := 'positiveInt'
  else if (propName = 'adjudication') then result := 'BackboneElement'
  else if (propName = 'detail') then result := 'BackboneElement'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirExplanationOfBenefitItem.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'sequence') then SequenceElement := nil
  else if (propName = 'careTeamSequence') then deletePropertyValue('careTeamSequence', CareTeamSequenceList, value)
  else if (propName = 'diagnosisSequence') then deletePropertyValue('diagnosisSequence', DiagnosisSequenceList, value)
  else if (propName = 'procedureSequence') then deletePropertyValue('procedureSequence', ProcedureSequenceList, value)
  else if (propName = 'informationSequence') then deletePropertyValue('informationSequence', InformationSequenceList, value)
  else if (propName = 'revenue') then RevenueElement := nil
  else if (propName = 'category') then CategoryElement := nil
  else if (propName = 'productOrService') then ProductOrServiceElement := nil
  else if (propName = 'modifier') then deletePropertyValue('modifier', ModifierList, value)
  else if (propName = 'programCode') then deletePropertyValue('programCode', ProgramCodeList, value)
  else if (isMatchingName(propName, 'serviced', ['Date', 'Period'])) then ServicedElement := nil
  else if (isMatchingName(propName, 'location', ['CodeableConcept', 'Address', 'Reference'])) then LocationElement := nil
  else if (propName = 'quantity') then QuantityElement := nil
  else if (propName = 'unitPrice') then UnitPriceElement := nil
  else if (propName = 'factor') then FactorElement := nil
  else if (propName = 'net') then NetElement := nil
  else if (propName = 'udi') then deletePropertyValue('udi', UdiList, value)
  else if (propName = 'bodySite') then BodySiteElement := nil
  else if (propName = 'subSite') then deletePropertyValue('subSite', SubSiteList, value)
  else if (propName = 'encounter') then deletePropertyValue('encounter', EncounterList, value)
  else if (propName = 'noteNumber') then deletePropertyValue('noteNumber', NoteNumberList, value)
  else if (propName = 'adjudication') then deletePropertyValue('adjudication', AdjudicationList, value)
  else if (propName = 'detail') then deletePropertyValue('detail', DetailList, value)
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirExplanationOfBenefitItem.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'sequence') then SequenceElement := asPositiveInt(new)
  else if (propName = 'careTeamSequence') then replacePropertyValue('careTeamSequence', CareTeamSequenceList, existing, new)
  else if (propName = 'diagnosisSequence') then replacePropertyValue('diagnosisSequence', DiagnosisSequenceList, existing, new)
  else if (propName = 'procedureSequence') then replacePropertyValue('procedureSequence', ProcedureSequenceList, existing, new)
  else if (propName = 'informationSequence') then replacePropertyValue('informationSequence', InformationSequenceList, existing, new)
  else if (propName = 'revenue') then RevenueElement := new as TFhirCodeableConcept
  else if (propName = 'category') then CategoryElement := new as TFhirCodeableConcept
  else if (propName = 'productOrService') then ProductOrServiceElement := new as TFhirCodeableConcept
  else if (propName = 'modifier') then replacePropertyValue('modifier', ModifierList, existing, new)
  else if (propName = 'programCode') then replacePropertyValue('programCode', ProgramCodeList, existing, new)
  else if (isMatchingName(propName, 'serviced', ['Date', 'Period'])) then ServicedElement := new as TFhirDataType
  else if (isMatchingName(propName, 'location', ['CodeableConcept', 'Address', 'Reference'])) then LocationElement := new as TFhirDataType
  else if (propName = 'quantity') then QuantityElement := new as TFhirQuantity
  else if (propName = 'unitPrice') then UnitPriceElement := new as TFhirMoney
  else if (propName = 'factor') then FactorElement := asDecimal(new)
  else if (propName = 'net') then NetElement := new as TFhirMoney
  else if (propName = 'udi') then replacePropertyValue('udi', UdiList, existing, new)
  else if (propName = 'bodySite') then BodySiteElement := new as TFhirCodeableConcept
  else if (propName = 'subSite') then replacePropertyValue('subSite', SubSiteList, existing, new)
  else if (propName = 'encounter') then replacePropertyValue('encounter', EncounterList, existing, new)
  else if (propName = 'noteNumber') then replacePropertyValue('noteNumber', NoteNumberList, existing, new)
  else if (propName = 'adjudication') then replacePropertyValue('adjudication', AdjudicationList, existing, new)
  else if (propName = 'detail') then replacePropertyValue('detail', DetailList, existing, new)
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirExplanationOfBenefitItem.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'careTeamSequence') then CareTeamSequenceList.move(source, destination)
  else if (propName = 'diagnosisSequence') then DiagnosisSequenceList.move(source, destination)
  else if (propName = 'procedureSequence') then ProcedureSequenceList.move(source, destination)
  else if (propName = 'informationSequence') then InformationSequenceList.move(source, destination)
  else if (propName = 'modifier') then ModifierList.move(source, destination)
  else if (propName = 'programCode') then ProgramCodeList.move(source, destination)
  else if (propName = 'udi') then UdiList.move(source, destination)
  else if (propName = 'subSite') then SubSiteList.move(source, destination)
  else if (propName = 'encounter') then EncounterList.move(source, destination)
  else if (propName = 'noteNumber') then NoteNumberList.move(source, destination)
  else if (propName = 'adjudication') then AdjudicationList.move(source, destination)
  else if (propName = 'detail') then DetailList.move(source, destination)
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirExplanationOfBenefitItem.fhirType : string;
begin
  result := 'ExplanationOfBenefit.item';
end;

function TFhirExplanationOfBenefitItem.Link : TFhirExplanationOfBenefitItem;
begin
  result := TFhirExplanationOfBenefitItem(inherited Link);
end;

function TFhirExplanationOfBenefitItem.Clone : TFhirExplanationOfBenefitItem;
begin
  result := TFhirExplanationOfBenefitItem(inherited Clone);
end;

function TFhirExplanationOfBenefitItem.equals(other : TObject) : boolean; 
var
  o : TFhirExplanationOfBenefitItem;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirExplanationOfBenefitItem)) then
    result := false
  else
  begin
    o := TFhirExplanationOfBenefitItem(other);
    result := compareDeep(sequenceElement, o.sequenceElement, true) and compareDeep(careTeamSequenceList, o.careTeamSequenceList, true) and 
      compareDeep(diagnosisSequenceList, o.diagnosisSequenceList, true) and compareDeep(procedureSequenceList, o.procedureSequenceList, true) and 
      compareDeep(informationSequenceList, o.informationSequenceList, true) and compareDeep(revenueElement, o.revenueElement, true) and 
      compareDeep(categoryElement, o.categoryElement, true) and compareDeep(productOrServiceElement, o.productOrServiceElement, true) and 
      compareDeep(modifierList, o.modifierList, true) and compareDeep(programCodeList, o.programCodeList, true) and 
      compareDeep(servicedElement, o.servicedElement, true) and compareDeep(locationElement, o.locationElement, true) and 
      compareDeep(quantityElement, o.quantityElement, true) and compareDeep(unitPriceElement, o.unitPriceElement, true) and 
      compareDeep(factorElement, o.factorElement, true) and compareDeep(netElement, o.netElement, true) and 
      compareDeep(udiList, o.udiList, true) and compareDeep(bodySiteElement, o.bodySiteElement, true) and 
      compareDeep(subSiteList, o.subSiteList, true) and compareDeep(encounterList, o.encounterList, true) and 
      compareDeep(noteNumberList, o.noteNumberList, true) and compareDeep(adjudicationList, o.adjudicationList, true) and 
      compareDeep(detailList, o.detailList, true);
  end;
end;

function TFhirExplanationOfBenefitItem.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FSequence) and isEmptyProp(FcareTeamSequenceList) and isEmptyProp(FdiagnosisSequenceList) and isEmptyProp(FprocedureSequenceList) and isEmptyProp(FinformationSequenceList) and isEmptyProp(FRevenue) and isEmptyProp(FCategory) and isEmptyProp(FProductOrService) and isEmptyProp(FmodifierList) and isEmptyProp(FprogramCodeList) and isEmptyProp(FServiced) and isEmptyProp(FLocation) and isEmptyProp(FQuantity) and isEmptyProp(FUnitPrice) and isEmptyProp(FFactor) and isEmptyProp(FNet) and isEmptyProp(FudiList) and isEmptyProp(FBodySite) and isEmptyProp(FsubSiteList) and isEmptyProp(FencounterList) and isEmptyProp(FnoteNumberList) and isEmptyProp(FadjudicationList) and isEmptyProp(FdetailList);
end;

procedure TFhirExplanationOfBenefitItem.listFieldsInOrder(fields : TStringList);
begin
  inherited listFieldsInOrder(fields);
  fields.add('sequence');
  fields.add('careTeamSequence');
  fields.add('diagnosisSequence');
  fields.add('procedureSequence');
  fields.add('informationSequence');
  fields.add('revenue');
  fields.add('category');
  fields.add('productOrService');
  fields.add('modifier');
  fields.add('programCode');
  fields.add('serviced[x]');
  fields.add('location[x]');
  fields.add('quantity');
  fields.add('unitPrice');
  fields.add('factor');
  fields.add('net');
  fields.add('udi');
  fields.add('bodySite');
  fields.add('subSite');
  fields.add('encounter');
  fields.add('noteNumber');
  fields.add('adjudication');
  fields.add('detail');
end;

function TFhirExplanationOfBenefitItem.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FCareTeamSequenceList.sizeInBytes(magic));
  inc(result, FDiagnosisSequenceList.sizeInBytes(magic));
  inc(result, FProcedureSequenceList.sizeInBytes(magic));
  inc(result, FInformationSequenceList.sizeInBytes(magic));
  inc(result, FModifierList.sizeInBytes(magic));
  inc(result, FProgramCodeList.sizeInBytes(magic));
  inc(result, FUdiList.sizeInBytes(magic));
  inc(result, FSubSiteList.sizeInBytes(magic));
  inc(result, FEncounterList.sizeInBytes(magic));
  inc(result, FNoteNumberList.sizeInBytes(magic));
  inc(result, FAdjudicationList.sizeInBytes(magic));
  inc(result, FDetailList.sizeInBytes(magic));
end;

procedure TFhirExplanationOfBenefitItem.SetSequence(value : TFhirPositiveInt);
begin
  FSequence.free;
  FSequence := value;
end;

function TFhirExplanationOfBenefitItem.GetSequenceST : String;
begin
  if FSequence = nil then
    result := ''
  else
    result := FSequence.value;
end;

procedure TFhirExplanationOfBenefitItem.SetSequenceST(value : String);
begin
  if value <> '' then
  begin
    if FSequence = nil then
      FSequence := TFhirPositiveInt.create;
    FSequence.value := value
  end
  else if FSequence <> nil then
    FSequence.value := '';
end;

function TFhirExplanationOfBenefitItem.GetCareTeamSequenceList : TFhirPositiveIntList;
begin
  if FCareTeamSequenceList = nil then
    FCareTeamSequenceList := TFhirPositiveIntList.Create;
  result := FCareTeamSequenceList;
end;

function TFhirExplanationOfBenefitItem.GetHasCareTeamSequenceList : boolean;
begin
  result := (FCareTeamSequenceList <> nil) and (FCareTeamSequenceList.count > 0);
end;

function TFhirExplanationOfBenefitItem.GetDiagnosisSequenceList : TFhirPositiveIntList;
begin
  if FDiagnosisSequenceList = nil then
    FDiagnosisSequenceList := TFhirPositiveIntList.Create;
  result := FDiagnosisSequenceList;
end;

function TFhirExplanationOfBenefitItem.GetHasDiagnosisSequenceList : boolean;
begin
  result := (FDiagnosisSequenceList <> nil) and (FDiagnosisSequenceList.count > 0);
end;

function TFhirExplanationOfBenefitItem.GetProcedureSequenceList : TFhirPositiveIntList;
begin
  if FProcedureSequenceList = nil then
    FProcedureSequenceList := TFhirPositiveIntList.Create;
  result := FProcedureSequenceList;
end;

function TFhirExplanationOfBenefitItem.GetHasProcedureSequenceList : boolean;
begin
  result := (FProcedureSequenceList <> nil) and (FProcedureSequenceList.count > 0);
end;

function TFhirExplanationOfBenefitItem.GetInformationSequenceList : TFhirPositiveIntList;
begin
  if FInformationSequenceList = nil then
    FInformationSequenceList := TFhirPositiveIntList.Create;
  result := FInformationSequenceList;
end;

function TFhirExplanationOfBenefitItem.GetHasInformationSequenceList : boolean;
begin
  result := (FInformationSequenceList <> nil) and (FInformationSequenceList.count > 0);
end;

procedure TFhirExplanationOfBenefitItem.SetRevenue(value : TFhirCodeableConcept);
begin
  FRevenue.free;
  FRevenue := value;
end;

procedure TFhirExplanationOfBenefitItem.SetCategory(value : TFhirCodeableConcept);
begin
  FCategory.free;
  FCategory := value;
end;

procedure TFhirExplanationOfBenefitItem.SetProductOrService(value : TFhirCodeableConcept);
begin
  FProductOrService.free;
  FProductOrService := value;
end;

function TFhirExplanationOfBenefitItem.GetModifierList : TFhirCodeableConceptList;
begin
  if FModifierList = nil then
    FModifierList := TFhirCodeableConceptList.Create;
  result := FModifierList;
end;

function TFhirExplanationOfBenefitItem.GetHasModifierList : boolean;
begin
  result := (FModifierList <> nil) and (FModifierList.count > 0);
end;

function TFhirExplanationOfBenefitItem.GetProgramCodeList : TFhirCodeableConceptList;
begin
  if FProgramCodeList = nil then
    FProgramCodeList := TFhirCodeableConceptList.Create;
  result := FProgramCodeList;
end;

function TFhirExplanationOfBenefitItem.GetHasProgramCodeList : boolean;
begin
  result := (FProgramCodeList <> nil) and (FProgramCodeList.count > 0);
end;

procedure TFhirExplanationOfBenefitItem.SetServiced(value : TFhirDataType);
begin
  FServiced.free;
  FServiced := value;
end;

procedure TFhirExplanationOfBenefitItem.SetLocation(value : TFhirDataType);
begin
  FLocation.free;
  FLocation := value;
end;

procedure TFhirExplanationOfBenefitItem.SetQuantity(value : TFhirQuantity);
begin
  FQuantity.free;
  FQuantity := value;
end;

procedure TFhirExplanationOfBenefitItem.SetUnitPrice(value : TFhirMoney);
begin
  FUnitPrice.free;
  FUnitPrice := value;
end;

procedure TFhirExplanationOfBenefitItem.SetFactor(value : TFhirDecimal);
begin
  FFactor.free;
  FFactor := value;
end;

function TFhirExplanationOfBenefitItem.GetFactorST : String;
begin
  if FFactor = nil then
    result := ''
  else
    result := FFactor.value;
end;

procedure TFhirExplanationOfBenefitItem.SetFactorST(value : String);
begin
  if value <> '' then
  begin
    if FFactor = nil then
      FFactor := TFhirDecimal.create;
    FFactor.value := value
  end
  else if FFactor <> nil then
    FFactor.value := '';
end;

procedure TFhirExplanationOfBenefitItem.SetNet(value : TFhirMoney);
begin
  FNet.free;
  FNet := value;
end;

function TFhirExplanationOfBenefitItem.GetUdiList : TFhirReferenceList;
begin
  if FUdiList = nil then
    FUdiList := TFhirReferenceList.Create;
  result := FUdiList;
end;

function TFhirExplanationOfBenefitItem.GetHasUdiList : boolean;
begin
  result := (FUdiList <> nil) and (FUdiList.count > 0);
end;

procedure TFhirExplanationOfBenefitItem.SetBodySite(value : TFhirCodeableConcept);
begin
  FBodySite.free;
  FBodySite := value;
end;

function TFhirExplanationOfBenefitItem.GetSubSiteList : TFhirCodeableConceptList;
begin
  if FSubSiteList = nil then
    FSubSiteList := TFhirCodeableConceptList.Create;
  result := FSubSiteList;
end;

function TFhirExplanationOfBenefitItem.GetHasSubSiteList : boolean;
begin
  result := (FSubSiteList <> nil) and (FSubSiteList.count > 0);
end;

function TFhirExplanationOfBenefitItem.GetEncounterList : TFhirReferenceList;
begin
  if FEncounterList = nil then
    FEncounterList := TFhirReferenceList.Create;
  result := FEncounterList;
end;

function TFhirExplanationOfBenefitItem.GetHasEncounterList : boolean;
begin
  result := (FEncounterList <> nil) and (FEncounterList.count > 0);
end;

function TFhirExplanationOfBenefitItem.GetNoteNumberList : TFhirPositiveIntList;
begin
  if FNoteNumberList = nil then
    FNoteNumberList := TFhirPositiveIntList.Create;
  result := FNoteNumberList;
end;

function TFhirExplanationOfBenefitItem.GetHasNoteNumberList : boolean;
begin
  result := (FNoteNumberList <> nil) and (FNoteNumberList.count > 0);
end;

function TFhirExplanationOfBenefitItem.GetAdjudicationList : TFhirExplanationOfBenefitItemAdjudicationList;
begin
  if FAdjudicationList = nil then
    FAdjudicationList := TFhirExplanationOfBenefitItemAdjudicationList.Create;
  result := FAdjudicationList;
end;

function TFhirExplanationOfBenefitItem.GetHasAdjudicationList : boolean;
begin
  result := (FAdjudicationList <> nil) and (FAdjudicationList.count > 0);
end;

function TFhirExplanationOfBenefitItem.GetDetailList : TFhirExplanationOfBenefitItemDetailList;
begin
  if FDetailList = nil then
    FDetailList := TFhirExplanationOfBenefitItemDetailList.Create;
  result := FDetailList;
end;

function TFhirExplanationOfBenefitItem.GetHasDetailList : boolean;
begin
  result := (FDetailList <> nil) and (FDetailList.count > 0);
end;

{ TFhirExplanationOfBenefitItemListEnumerator }

constructor TFhirExplanationOfBenefitItemListEnumerator.Create(list : TFhirExplanationOfBenefitItemList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirExplanationOfBenefitItemListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirExplanationOfBenefitItemListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirExplanationOfBenefitItemListEnumerator.GetCurrent : TFhirExplanationOfBenefitItem;
begin
  Result := FList[FIndex];
end;

function TFhirExplanationOfBenefitItemListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirExplanationOfBenefitItemList }

procedure TFhirExplanationOfBenefitItemList.AddItem(value: TFhirExplanationOfBenefitItem);
begin
  assert(value.ClassName = 'TFhirExplanationOfBenefitItem', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirExplanationOfBenefitItem');
  add(value);
end;

function TFhirExplanationOfBenefitItemList.Append: TFhirExplanationOfBenefitItem;
begin
  result := TFhirExplanationOfBenefitItem.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirExplanationOfBenefitItemList.ClearItems;
begin
  Clear;
end;

function TFhirExplanationOfBenefitItemList.GetEnumerator : TFhirExplanationOfBenefitItemListEnumerator;
begin
  result := TFhirExplanationOfBenefitItemListEnumerator.Create(self.link);
end;

function TFhirExplanationOfBenefitItemList.Clone: TFhirExplanationOfBenefitItemList;
begin
  result := TFhirExplanationOfBenefitItemList(inherited Clone);
end;

function TFhirExplanationOfBenefitItemList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirExplanationOfBenefitItemList.GetItemN(index: Integer): TFhirExplanationOfBenefitItem;
begin
  result := TFhirExplanationOfBenefitItem(ObjectByIndex[index]);
end;

function TFhirExplanationOfBenefitItemList.ItemClass: TFslObjectClass;
begin
  result := TFhirExplanationOfBenefitItem;
end;
function TFhirExplanationOfBenefitItemList.IndexOf(value: TFhirExplanationOfBenefitItem): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirExplanationOfBenefitItemList.Insert(index: Integer): TFhirExplanationOfBenefitItem;
begin
  result := TFhirExplanationOfBenefitItem.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirExplanationOfBenefitItemList.InsertItem(index: Integer; value: TFhirExplanationOfBenefitItem);
begin
  assert(value is TFhirExplanationOfBenefitItem);
  Inherited Insert(index, value);
end;

function TFhirExplanationOfBenefitItemList.Item(index: Integer): TFhirExplanationOfBenefitItem;
begin
  result := TFhirExplanationOfBenefitItem(ObjectByIndex[index]);
end;

function TFhirExplanationOfBenefitItemList.Link: TFhirExplanationOfBenefitItemList;
begin
  result := TFhirExplanationOfBenefitItemList(inherited Link);
end;

procedure TFhirExplanationOfBenefitItemList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirExplanationOfBenefitItemList.SetItemByIndex(index: Integer; value: TFhirExplanationOfBenefitItem);
begin
  assert(value is TFhirExplanationOfBenefitItem);
  FhirExplanationOfBenefitItems[index] := value;
end;

procedure TFhirExplanationOfBenefitItemList.SetItemN(index: Integer; value: TFhirExplanationOfBenefitItem);
begin
  assert(value is TFhirExplanationOfBenefitItem);
  ObjectByIndex[index] := value;
end;

{ TFhirExplanationOfBenefitItemAdjudication }

constructor TFhirExplanationOfBenefitItemAdjudication.Create;
begin
  inherited;
end;

destructor TFhirExplanationOfBenefitItemAdjudication.Destroy;
begin
  FCategory.free;
  FReason.free;
  FAmount.free;
  FValue.free;
  inherited;
end;

procedure TFhirExplanationOfBenefitItemAdjudication.Assign(oSource : TFslObject);
begin
  inherited;
  category := TFhirExplanationOfBenefitItemAdjudication(oSource).category.Clone;
  reason := TFhirExplanationOfBenefitItemAdjudication(oSource).reason.Clone;
  amount := TFhirExplanationOfBenefitItemAdjudication(oSource).amount.Clone;
  valueElement := TFhirExplanationOfBenefitItemAdjudication(oSource).valueElement.Clone;
end;

procedure TFhirExplanationOfBenefitItemAdjudication.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'category') Then
     list.add(self.link, 'category', FCategory.Link);
  if (child_name = 'reason') Then
     list.add(self.link, 'reason', FReason.Link);
  if (child_name = 'amount') Then
     list.add(self.link, 'amount', FAmount.Link);
  if (child_name = 'value') Then
     list.add(self.link, 'value', FValue.Link);
end;

procedure TFhirExplanationOfBenefitItemAdjudication.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'category', 'CodeableConcept', false, TFhirCodeableConcept, FCategory.Link));
  oList.add(TFHIRProperty.create(self, 'reason', 'CodeableConcept', false, TFhirCodeableConcept, FReason.Link));
  oList.add(TFHIRProperty.create(self, 'amount', 'Money', false, TFhirMoney, FAmount.Link));
  oList.add(TFHIRProperty.create(self, 'value', 'decimal', false, TFhirDecimal, FValue.Link));
end;

function TFhirExplanationOfBenefitItemAdjudication.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'category') then
  begin
    Category := propValue as TFhirCodeableConcept;
    result := propValue;
  end
  else if (propName = 'reason') then
  begin
    Reason := propValue as TFhirCodeableConcept;
    result := propValue;
  end
  else if (propName = 'amount') then
  begin
    Amount := propValue as TFhirMoney;
    result := propValue;
  end
  else if (propName = 'value') then
  begin
    ValueElement := asDecimal(propValue);
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirExplanationOfBenefitItemAdjudication.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirExplanationOfBenefitItemAdjudication.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'category') then result := TFhirCodeableConcept.create()
  else if (propName = 'reason') then result := TFhirCodeableConcept.create()
  else if (propName = 'amount') then result := TFhirMoney.create()
  else if (propName = 'value') then result := TFhirDecimal.create()
  else result := inherited createPropertyValue(propName);
end;

function TFhirExplanationOfBenefitItemAdjudication.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'category') then result := 'CodeableConcept'
  else if (propName = 'reason') then result := 'CodeableConcept'
  else if (propName = 'amount') then result := 'Money'
  else if (propName = 'value') then result := 'decimal'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirExplanationOfBenefitItemAdjudication.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'category') then CategoryElement := nil
  else if (propName = 'reason') then ReasonElement := nil
  else if (propName = 'amount') then AmountElement := nil
  else if (propName = 'value') then ValueElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirExplanationOfBenefitItemAdjudication.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'category') then CategoryElement := new as TFhirCodeableConcept
  else if (propName = 'reason') then ReasonElement := new as TFhirCodeableConcept
  else if (propName = 'amount') then AmountElement := new as TFhirMoney
  else if (propName = 'value') then ValueElement := asDecimal(new)
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirExplanationOfBenefitItemAdjudication.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirExplanationOfBenefitItemAdjudication.fhirType : string;
begin
  result := 'ExplanationOfBenefit.item.adjudication';
end;

function TFhirExplanationOfBenefitItemAdjudication.Link : TFhirExplanationOfBenefitItemAdjudication;
begin
  result := TFhirExplanationOfBenefitItemAdjudication(inherited Link);
end;

function TFhirExplanationOfBenefitItemAdjudication.Clone : TFhirExplanationOfBenefitItemAdjudication;
begin
  result := TFhirExplanationOfBenefitItemAdjudication(inherited Clone);
end;

function TFhirExplanationOfBenefitItemAdjudication.equals(other : TObject) : boolean; 
var
  o : TFhirExplanationOfBenefitItemAdjudication;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirExplanationOfBenefitItemAdjudication)) then
    result := false
  else
  begin
    o := TFhirExplanationOfBenefitItemAdjudication(other);
    result := compareDeep(categoryElement, o.categoryElement, true) and compareDeep(reasonElement, o.reasonElement, true) and 
      compareDeep(amountElement, o.amountElement, true) and compareDeep(valueElement, o.valueElement, true);
  end;
end;

function TFhirExplanationOfBenefitItemAdjudication.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FCategory) and isEmptyProp(FReason) and isEmptyProp(FAmount) and isEmptyProp(FValue);
end;

procedure TFhirExplanationOfBenefitItemAdjudication.listFieldsInOrder(fields : TStringList);
begin
  inherited listFieldsInOrder(fields);
  fields.add('category');
  fields.add('reason');
  fields.add('amount');
  fields.add('value');
end;

function TFhirExplanationOfBenefitItemAdjudication.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
end;

procedure TFhirExplanationOfBenefitItemAdjudication.SetCategory(value : TFhirCodeableConcept);
begin
  FCategory.free;
  FCategory := value;
end;

procedure TFhirExplanationOfBenefitItemAdjudication.SetReason(value : TFhirCodeableConcept);
begin
  FReason.free;
  FReason := value;
end;

procedure TFhirExplanationOfBenefitItemAdjudication.SetAmount(value : TFhirMoney);
begin
  FAmount.free;
  FAmount := value;
end;

procedure TFhirExplanationOfBenefitItemAdjudication.SetValue(value : TFhirDecimal);
begin
  FValue.free;
  FValue := value;
end;

function TFhirExplanationOfBenefitItemAdjudication.GetValueST : String;
begin
  if FValue = nil then
    result := ''
  else
    result := FValue.value;
end;

procedure TFhirExplanationOfBenefitItemAdjudication.SetValueST(value : String);
begin
  if value <> '' then
  begin
    if FValue = nil then
      FValue := TFhirDecimal.create;
    FValue.value := value
  end
  else if FValue <> nil then
    FValue.value := '';
end;

{ TFhirExplanationOfBenefitItemAdjudicationListEnumerator }

constructor TFhirExplanationOfBenefitItemAdjudicationListEnumerator.Create(list : TFhirExplanationOfBenefitItemAdjudicationList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirExplanationOfBenefitItemAdjudicationListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirExplanationOfBenefitItemAdjudicationListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirExplanationOfBenefitItemAdjudicationListEnumerator.GetCurrent : TFhirExplanationOfBenefitItemAdjudication;
begin
  Result := FList[FIndex];
end;

function TFhirExplanationOfBenefitItemAdjudicationListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirExplanationOfBenefitItemAdjudicationList }

procedure TFhirExplanationOfBenefitItemAdjudicationList.AddItem(value: TFhirExplanationOfBenefitItemAdjudication);
begin
  assert(value.ClassName = 'TFhirExplanationOfBenefitItemAdjudication', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirExplanationOfBenefitItemAdjudication');
  add(value);
end;

function TFhirExplanationOfBenefitItemAdjudicationList.Append: TFhirExplanationOfBenefitItemAdjudication;
begin
  result := TFhirExplanationOfBenefitItemAdjudication.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirExplanationOfBenefitItemAdjudicationList.ClearItems;
begin
  Clear;
end;

function TFhirExplanationOfBenefitItemAdjudicationList.GetEnumerator : TFhirExplanationOfBenefitItemAdjudicationListEnumerator;
begin
  result := TFhirExplanationOfBenefitItemAdjudicationListEnumerator.Create(self.link);
end;

function TFhirExplanationOfBenefitItemAdjudicationList.Clone: TFhirExplanationOfBenefitItemAdjudicationList;
begin
  result := TFhirExplanationOfBenefitItemAdjudicationList(inherited Clone);
end;

function TFhirExplanationOfBenefitItemAdjudicationList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirExplanationOfBenefitItemAdjudicationList.GetItemN(index: Integer): TFhirExplanationOfBenefitItemAdjudication;
begin
  result := TFhirExplanationOfBenefitItemAdjudication(ObjectByIndex[index]);
end;

function TFhirExplanationOfBenefitItemAdjudicationList.ItemClass: TFslObjectClass;
begin
  result := TFhirExplanationOfBenefitItemAdjudication;
end;
function TFhirExplanationOfBenefitItemAdjudicationList.IndexOf(value: TFhirExplanationOfBenefitItemAdjudication): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirExplanationOfBenefitItemAdjudicationList.Insert(index: Integer): TFhirExplanationOfBenefitItemAdjudication;
begin
  result := TFhirExplanationOfBenefitItemAdjudication.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirExplanationOfBenefitItemAdjudicationList.InsertItem(index: Integer; value: TFhirExplanationOfBenefitItemAdjudication);
begin
  assert(value is TFhirExplanationOfBenefitItemAdjudication);
  Inherited Insert(index, value);
end;

function TFhirExplanationOfBenefitItemAdjudicationList.Item(index: Integer): TFhirExplanationOfBenefitItemAdjudication;
begin
  result := TFhirExplanationOfBenefitItemAdjudication(ObjectByIndex[index]);
end;

function TFhirExplanationOfBenefitItemAdjudicationList.Link: TFhirExplanationOfBenefitItemAdjudicationList;
begin
  result := TFhirExplanationOfBenefitItemAdjudicationList(inherited Link);
end;

procedure TFhirExplanationOfBenefitItemAdjudicationList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirExplanationOfBenefitItemAdjudicationList.SetItemByIndex(index: Integer; value: TFhirExplanationOfBenefitItemAdjudication);
begin
  assert(value is TFhirExplanationOfBenefitItemAdjudication);
  FhirExplanationOfBenefitItemAdjudications[index] := value;
end;

procedure TFhirExplanationOfBenefitItemAdjudicationList.SetItemN(index: Integer; value: TFhirExplanationOfBenefitItemAdjudication);
begin
  assert(value is TFhirExplanationOfBenefitItemAdjudication);
  ObjectByIndex[index] := value;
end;

{ TFhirExplanationOfBenefitItemDetail }

constructor TFhirExplanationOfBenefitItemDetail.Create;
begin
  inherited;
end;

destructor TFhirExplanationOfBenefitItemDetail.Destroy;
begin
  FSequence.free;
  FRevenue.free;
  FCategory.free;
  FProductOrService.free;
  FModifierList.Free;
  FProgramCodeList.Free;
  FQuantity.free;
  FUnitPrice.free;
  FFactor.free;
  FNet.free;
  FUdiList.Free;
  FNoteNumberList.Free;
  FAdjudicationList.Free;
  FSubDetailList.Free;
  inherited;
end;

procedure TFhirExplanationOfBenefitItemDetail.Assign(oSource : TFslObject);
begin
  inherited;
  sequenceElement := TFhirExplanationOfBenefitItemDetail(oSource).sequenceElement.Clone;
  revenue := TFhirExplanationOfBenefitItemDetail(oSource).revenue.Clone;
  category := TFhirExplanationOfBenefitItemDetail(oSource).category.Clone;
  productOrService := TFhirExplanationOfBenefitItemDetail(oSource).productOrService.Clone;
  if (TFhirExplanationOfBenefitItemDetail(oSource).FModifierList = nil) then
  begin
    FModifierList.free;
    FModifierList := nil;
  end
  else
  begin
    if FModifierList = nil then
      FModifierList := TFhirCodeableConceptList.Create;
    FModifierList.Assign(TFhirExplanationOfBenefitItemDetail(oSource).FModifierList);
  end;
  if (TFhirExplanationOfBenefitItemDetail(oSource).FProgramCodeList = nil) then
  begin
    FProgramCodeList.free;
    FProgramCodeList := nil;
  end
  else
  begin
    if FProgramCodeList = nil then
      FProgramCodeList := TFhirCodeableConceptList.Create;
    FProgramCodeList.Assign(TFhirExplanationOfBenefitItemDetail(oSource).FProgramCodeList);
  end;
  quantity := TFhirExplanationOfBenefitItemDetail(oSource).quantity.Clone;
  unitPrice := TFhirExplanationOfBenefitItemDetail(oSource).unitPrice.Clone;
  factorElement := TFhirExplanationOfBenefitItemDetail(oSource).factorElement.Clone;
  net := TFhirExplanationOfBenefitItemDetail(oSource).net.Clone;
  if (TFhirExplanationOfBenefitItemDetail(oSource).FUdiList = nil) then
  begin
    FUdiList.free;
    FUdiList := nil;
  end
  else
  begin
    if FUdiList = nil then
      FUdiList := TFhirReferenceList.Create;
    FUdiList.Assign(TFhirExplanationOfBenefitItemDetail(oSource).FUdiList);
  end;
  if (TFhirExplanationOfBenefitItemDetail(oSource).FNoteNumberList = nil) then
  begin
    FNoteNumberList.free;
    FNoteNumberList := nil;
  end
  else
  begin
    if FNoteNumberList = nil then
      FNoteNumberList := TFhirPositiveIntList.Create;
    FNoteNumberList.Assign(TFhirExplanationOfBenefitItemDetail(oSource).FNoteNumberList);
  end;
  if (TFhirExplanationOfBenefitItemDetail(oSource).FAdjudicationList = nil) then
  begin
    FAdjudicationList.free;
    FAdjudicationList := nil;
  end
  else
  begin
    if FAdjudicationList = nil then
      FAdjudicationList := TFhirExplanationOfBenefitItemAdjudicationList.Create;
    FAdjudicationList.Assign(TFhirExplanationOfBenefitItemDetail(oSource).FAdjudicationList);
  end;
  if (TFhirExplanationOfBenefitItemDetail(oSource).FSubDetailList = nil) then
  begin
    FSubDetailList.free;
    FSubDetailList := nil;
  end
  else
  begin
    if FSubDetailList = nil then
      FSubDetailList := TFhirExplanationOfBenefitItemDetailSubDetailList.Create;
    FSubDetailList.Assign(TFhirExplanationOfBenefitItemDetail(oSource).FSubDetailList);
  end;
end;

procedure TFhirExplanationOfBenefitItemDetail.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'sequence') Then
     list.add(self.link, 'sequence', FSequence.Link);
  if (child_name = 'revenue') Then
     list.add(self.link, 'revenue', FRevenue.Link);
  if (child_name = 'category') Then
     list.add(self.link, 'category', FCategory.Link);
  if (child_name = 'productOrService') Then
     list.add(self.link, 'productOrService', FProductOrService.Link);
  if (child_name = 'modifier') Then
    list.addAll(self, 'modifier', FModifierList);
  if (child_name = 'programCode') Then
    list.addAll(self, 'programCode', FProgramCodeList);
  if (child_name = 'quantity') Then
     list.add(self.link, 'quantity', FQuantity.Link);
  if (child_name = 'unitPrice') Then
     list.add(self.link, 'unitPrice', FUnitPrice.Link);
  if (child_name = 'factor') Then
     list.add(self.link, 'factor', FFactor.Link);
  if (child_name = 'net') Then
     list.add(self.link, 'net', FNet.Link);
  if (child_name = 'udi') Then
    list.addAll(self, 'udi', FUdiList);
  if (child_name = 'noteNumber') Then
    list.addAll(self, 'noteNumber', FNoteNumberList);
  if (child_name = 'adjudication') Then
    list.addAll(self, 'adjudication', FAdjudicationList);
  if (child_name = 'subDetail') Then
    list.addAll(self, 'subDetail', FSubDetailList);
end;

procedure TFhirExplanationOfBenefitItemDetail.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'sequence', 'positiveInt', false, TFhirPositiveInt, FSequence.Link));
  oList.add(TFHIRProperty.create(self, 'revenue', 'CodeableConcept', false, TFhirCodeableConcept, FRevenue.Link));
  oList.add(TFHIRProperty.create(self, 'category', 'CodeableConcept', false, TFhirCodeableConcept, FCategory.Link));
  oList.add(TFHIRProperty.create(self, 'productOrService', 'CodeableConcept', false, TFhirCodeableConcept, FProductOrService.Link));
  oList.add(TFHIRProperty.create(self, 'modifier', 'CodeableConcept', true, TFhirCodeableConcept, FModifierList.Link));
  oList.add(TFHIRProperty.create(self, 'programCode', 'CodeableConcept', true, TFhirCodeableConcept, FProgramCodeList.Link));
  oList.add(TFHIRProperty.create(self, 'quantity', 'Quantity', false, TFhirQuantity, FQuantity.Link));
  oList.add(TFHIRProperty.create(self, 'unitPrice', 'Money', false, TFhirMoney, FUnitPrice.Link));
  oList.add(TFHIRProperty.create(self, 'factor', 'decimal', false, TFhirDecimal, FFactor.Link));
  oList.add(TFHIRProperty.create(self, 'net', 'Money', false, TFhirMoney, FNet.Link));
  oList.add(TFHIRProperty.create(self, 'udi', 'Reference', true, TFhirReference, FUdiList.Link));
  oList.add(TFHIRProperty.create(self, 'noteNumber', 'positiveInt', true, TFhirPositiveInt, FNoteNumberList.Link));
  oList.add(TFHIRProperty.create(self, 'adjudication', '', true, TFhirExplanationOfBenefitItemAdjudication, FAdjudicationList.Link));
  oList.add(TFHIRProperty.create(self, 'subDetail', 'BackboneElement', true, TFhirExplanationOfBenefitItemDetailSubDetail, FSubDetailList.Link));
end;

function TFhirExplanationOfBenefitItemDetail.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'sequence') then
  begin
    SequenceElement := asPositiveInt(propValue);
    result := propValue;
  end
  else if (propName = 'revenue') then
  begin
    Revenue := propValue as TFhirCodeableConcept;
    result := propValue;
  end
  else if (propName = 'category') then
  begin
    Category := propValue as TFhirCodeableConcept;
    result := propValue;
  end
  else if (propName = 'productOrService') then
  begin
    ProductOrService := propValue as TFhirCodeableConcept;
    result := propValue;
  end
  else if (propName = 'modifier') then
  begin
    ModifierList.add(propValue as TFhirCodeableConcept);
    result := propValue;
  end
  else if (propName = 'programCode') then
  begin
    ProgramCodeList.add(propValue as TFhirCodeableConcept);
    result := propValue;
  end
  else if (propName = 'quantity') then
  begin
    Quantity := propValue as TFhirQuantity;
    result := propValue;
  end
  else if (propName = 'unitPrice') then
  begin
    UnitPrice := propValue as TFhirMoney;
    result := propValue;
  end
  else if (propName = 'factor') then
  begin
    FactorElement := asDecimal(propValue);
    result := propValue;
  end
  else if (propName = 'net') then
  begin
    Net := propValue as TFhirMoney;
    result := propValue;
  end
  else if (propName = 'udi') then
  begin
    UdiList.add(propValue as TFhirReference);
    result := propValue;
  end
  else if (propName = 'noteNumber') then
  begin
    NoteNumberList.add(asPositiveInt(propValue)){2};     result := propValue;

  end
  else if (propName = 'adjudication') then
  begin
    AdjudicationList.add(propValue as TFhirExplanationOfBenefitItemAdjudication);
    result := propValue;
  end
  else if (propName = 'subDetail') then
  begin
    SubDetailList.add(propValue as TFhirExplanationOfBenefitItemDetailSubDetail);
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirExplanationOfBenefitItemDetail.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'modifier') then ModifierList.insertItem(index, propValue as TFhirCodeableConcept)
  else if (propName = 'programCode') then ProgramCodeList.insertItem(index, propValue as TFhirCodeableConcept)
  else if (propName = 'udi') then UdiList.insertItem(index, propValue as TFhirReference)
  else if (propName = 'noteNumber') then NoteNumberList.insertItem(index, asPositiveInt(propValue))
  else if (propName = 'adjudication') then AdjudicationList.insertItem(index, propValue as TFhirExplanationOfBenefitItemAdjudication)
  else if (propName = 'subDetail') then SubDetailList.insertItem(index, propValue as TFhirExplanationOfBenefitItemDetailSubDetail)
  else inherited;
end;

function TFhirExplanationOfBenefitItemDetail.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'sequence') then result := TFhirPositiveInt.create()
  else if (propName = 'revenue') then result := TFhirCodeableConcept.create()
  else if (propName = 'category') then result := TFhirCodeableConcept.create()
  else if (propName = 'productOrService') then result := TFhirCodeableConcept.create()
  else if (propName = 'modifier') then result := ModifierList.new()
  else if (propName = 'programCode') then result := ProgramCodeList.new()
  else if (propName = 'quantity') then result := TFhirQuantity.create()
  else if (propName = 'unitPrice') then result := TFhirMoney.create()
  else if (propName = 'factor') then result := TFhirDecimal.create()
  else if (propName = 'net') then result := TFhirMoney.create()
  else if (propName = 'udi') then result := UdiList.new()
  else if (propName = 'noteNumber') then result := NoteNumberList.new()
  else if (propName = 'adjudication') then result := AdjudicationList.new()
  else if (propName = 'subDetail') then result := SubDetailList.new()
  else result := inherited createPropertyValue(propName);
end;

function TFhirExplanationOfBenefitItemDetail.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'sequence') then result := 'positiveInt'
  else if (propName = 'revenue') then result := 'CodeableConcept'
  else if (propName = 'category') then result := 'CodeableConcept'
  else if (propName = 'productOrService') then result := 'CodeableConcept'
  else if (propName = 'modifier') then result := 'CodeableConcept'
  else if (propName = 'programCode') then result := 'CodeableConcept'
  else if (propName = 'quantity') then result := 'Quantity'
  else if (propName = 'unitPrice') then result := 'Money'
  else if (propName = 'factor') then result := 'decimal'
  else if (propName = 'net') then result := 'Money'
  else if (propName = 'udi') then result := 'Reference'
  else if (propName = 'noteNumber') then result := 'positiveInt'
  else if (propName = 'adjudication') then result := ''
  else if (propName = 'subDetail') then result := 'BackboneElement'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirExplanationOfBenefitItemDetail.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'sequence') then SequenceElement := nil
  else if (propName = 'revenue') then RevenueElement := nil
  else if (propName = 'category') then CategoryElement := nil
  else if (propName = 'productOrService') then ProductOrServiceElement := nil
  else if (propName = 'modifier') then deletePropertyValue('modifier', ModifierList, value)
  else if (propName = 'programCode') then deletePropertyValue('programCode', ProgramCodeList, value)
  else if (propName = 'quantity') then QuantityElement := nil
  else if (propName = 'unitPrice') then UnitPriceElement := nil
  else if (propName = 'factor') then FactorElement := nil
  else if (propName = 'net') then NetElement := nil
  else if (propName = 'udi') then deletePropertyValue('udi', UdiList, value)
  else if (propName = 'noteNumber') then deletePropertyValue('noteNumber', NoteNumberList, value)
  else if (propName = 'adjudication') then deletePropertyValue('adjudication', AdjudicationList, value)
  else if (propName = 'subDetail') then deletePropertyValue('subDetail', SubDetailList, value)
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirExplanationOfBenefitItemDetail.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'sequence') then SequenceElement := asPositiveInt(new)
  else if (propName = 'revenue') then RevenueElement := new as TFhirCodeableConcept
  else if (propName = 'category') then CategoryElement := new as TFhirCodeableConcept
  else if (propName = 'productOrService') then ProductOrServiceElement := new as TFhirCodeableConcept
  else if (propName = 'modifier') then replacePropertyValue('modifier', ModifierList, existing, new)
  else if (propName = 'programCode') then replacePropertyValue('programCode', ProgramCodeList, existing, new)
  else if (propName = 'quantity') then QuantityElement := new as TFhirQuantity
  else if (propName = 'unitPrice') then UnitPriceElement := new as TFhirMoney
  else if (propName = 'factor') then FactorElement := asDecimal(new)
  else if (propName = 'net') then NetElement := new as TFhirMoney
  else if (propName = 'udi') then replacePropertyValue('udi', UdiList, existing, new)
  else if (propName = 'noteNumber') then replacePropertyValue('noteNumber', NoteNumberList, existing, new)
  else if (propName = 'adjudication') then replacePropertyValue('adjudication', AdjudicationList, existing, new)
  else if (propName = 'subDetail') then replacePropertyValue('subDetail', SubDetailList, existing, new)
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirExplanationOfBenefitItemDetail.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'modifier') then ModifierList.move(source, destination)
  else if (propName = 'programCode') then ProgramCodeList.move(source, destination)
  else if (propName = 'udi') then UdiList.move(source, destination)
  else if (propName = 'noteNumber') then NoteNumberList.move(source, destination)
  else if (propName = 'adjudication') then AdjudicationList.move(source, destination)
  else if (propName = 'subDetail') then SubDetailList.move(source, destination)
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirExplanationOfBenefitItemDetail.fhirType : string;
begin
  result := 'ExplanationOfBenefit.item.detail';
end;

function TFhirExplanationOfBenefitItemDetail.Link : TFhirExplanationOfBenefitItemDetail;
begin
  result := TFhirExplanationOfBenefitItemDetail(inherited Link);
end;

function TFhirExplanationOfBenefitItemDetail.Clone : TFhirExplanationOfBenefitItemDetail;
begin
  result := TFhirExplanationOfBenefitItemDetail(inherited Clone);
end;

function TFhirExplanationOfBenefitItemDetail.equals(other : TObject) : boolean; 
var
  o : TFhirExplanationOfBenefitItemDetail;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirExplanationOfBenefitItemDetail)) then
    result := false
  else
  begin
    o := TFhirExplanationOfBenefitItemDetail(other);
    result := compareDeep(sequenceElement, o.sequenceElement, true) and compareDeep(revenueElement, o.revenueElement, true) and 
      compareDeep(categoryElement, o.categoryElement, true) and compareDeep(productOrServiceElement, o.productOrServiceElement, true) and 
      compareDeep(modifierList, o.modifierList, true) and compareDeep(programCodeList, o.programCodeList, true) and 
      compareDeep(quantityElement, o.quantityElement, true) and compareDeep(unitPriceElement, o.unitPriceElement, true) and 
      compareDeep(factorElement, o.factorElement, true) and compareDeep(netElement, o.netElement, true) and 
      compareDeep(udiList, o.udiList, true) and compareDeep(noteNumberList, o.noteNumberList, true) and 
      compareDeep(adjudicationList, o.adjudicationList, true) and compareDeep(subDetailList, o.subDetailList, true);
  end;
end;

function TFhirExplanationOfBenefitItemDetail.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FSequence) and isEmptyProp(FRevenue) and isEmptyProp(FCategory) and isEmptyProp(FProductOrService) and isEmptyProp(FmodifierList) and isEmptyProp(FprogramCodeList) and isEmptyProp(FQuantity) and isEmptyProp(FUnitPrice) and isEmptyProp(FFactor) and isEmptyProp(FNet) and isEmptyProp(FudiList) and isEmptyProp(FnoteNumberList) and isEmptyProp(FadjudicationList) and isEmptyProp(FsubDetailList);
end;

procedure TFhirExplanationOfBenefitItemDetail.listFieldsInOrder(fields : TStringList);
begin
  inherited listFieldsInOrder(fields);
  fields.add('sequence');
  fields.add('revenue');
  fields.add('category');
  fields.add('productOrService');
  fields.add('modifier');
  fields.add('programCode');
  fields.add('quantity');
  fields.add('unitPrice');
  fields.add('factor');
  fields.add('net');
  fields.add('udi');
  fields.add('noteNumber');
  fields.add('adjudication');
  fields.add('subDetail');
end;

function TFhirExplanationOfBenefitItemDetail.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FModifierList.sizeInBytes(magic));
  inc(result, FProgramCodeList.sizeInBytes(magic));
  inc(result, FUdiList.sizeInBytes(magic));
  inc(result, FNoteNumberList.sizeInBytes(magic));
  inc(result, FAdjudicationList.sizeInBytes(magic));
  inc(result, FSubDetailList.sizeInBytes(magic));
end;

procedure TFhirExplanationOfBenefitItemDetail.SetSequence(value : TFhirPositiveInt);
begin
  FSequence.free;
  FSequence := value;
end;

function TFhirExplanationOfBenefitItemDetail.GetSequenceST : String;
begin
  if FSequence = nil then
    result := ''
  else
    result := FSequence.value;
end;

procedure TFhirExplanationOfBenefitItemDetail.SetSequenceST(value : String);
begin
  if value <> '' then
  begin
    if FSequence = nil then
      FSequence := TFhirPositiveInt.create;
    FSequence.value := value
  end
  else if FSequence <> nil then
    FSequence.value := '';
end;

procedure TFhirExplanationOfBenefitItemDetail.SetRevenue(value : TFhirCodeableConcept);
begin
  FRevenue.free;
  FRevenue := value;
end;

procedure TFhirExplanationOfBenefitItemDetail.SetCategory(value : TFhirCodeableConcept);
begin
  FCategory.free;
  FCategory := value;
end;

procedure TFhirExplanationOfBenefitItemDetail.SetProductOrService(value : TFhirCodeableConcept);
begin
  FProductOrService.free;
  FProductOrService := value;
end;

function TFhirExplanationOfBenefitItemDetail.GetModifierList : TFhirCodeableConceptList;
begin
  if FModifierList = nil then
    FModifierList := TFhirCodeableConceptList.Create;
  result := FModifierList;
end;

function TFhirExplanationOfBenefitItemDetail.GetHasModifierList : boolean;
begin
  result := (FModifierList <> nil) and (FModifierList.count > 0);
end;

function TFhirExplanationOfBenefitItemDetail.GetProgramCodeList : TFhirCodeableConceptList;
begin
  if FProgramCodeList = nil then
    FProgramCodeList := TFhirCodeableConceptList.Create;
  result := FProgramCodeList;
end;

function TFhirExplanationOfBenefitItemDetail.GetHasProgramCodeList : boolean;
begin
  result := (FProgramCodeList <> nil) and (FProgramCodeList.count > 0);
end;

procedure TFhirExplanationOfBenefitItemDetail.SetQuantity(value : TFhirQuantity);
begin
  FQuantity.free;
  FQuantity := value;
end;

procedure TFhirExplanationOfBenefitItemDetail.SetUnitPrice(value : TFhirMoney);
begin
  FUnitPrice.free;
  FUnitPrice := value;
end;

procedure TFhirExplanationOfBenefitItemDetail.SetFactor(value : TFhirDecimal);
begin
  FFactor.free;
  FFactor := value;
end;

function TFhirExplanationOfBenefitItemDetail.GetFactorST : String;
begin
  if FFactor = nil then
    result := ''
  else
    result := FFactor.value;
end;

procedure TFhirExplanationOfBenefitItemDetail.SetFactorST(value : String);
begin
  if value <> '' then
  begin
    if FFactor = nil then
      FFactor := TFhirDecimal.create;
    FFactor.value := value
  end
  else if FFactor <> nil then
    FFactor.value := '';
end;

procedure TFhirExplanationOfBenefitItemDetail.SetNet(value : TFhirMoney);
begin
  FNet.free;
  FNet := value;
end;

function TFhirExplanationOfBenefitItemDetail.GetUdiList : TFhirReferenceList;
begin
  if FUdiList = nil then
    FUdiList := TFhirReferenceList.Create;
  result := FUdiList;
end;

function TFhirExplanationOfBenefitItemDetail.GetHasUdiList : boolean;
begin
  result := (FUdiList <> nil) and (FUdiList.count > 0);
end;

function TFhirExplanationOfBenefitItemDetail.GetNoteNumberList : TFhirPositiveIntList;
begin
  if FNoteNumberList = nil then
    FNoteNumberList := TFhirPositiveIntList.Create;
  result := FNoteNumberList;
end;

function TFhirExplanationOfBenefitItemDetail.GetHasNoteNumberList : boolean;
begin
  result := (FNoteNumberList <> nil) and (FNoteNumberList.count > 0);
end;

function TFhirExplanationOfBenefitItemDetail.GetAdjudicationList : TFhirExplanationOfBenefitItemAdjudicationList;
begin
  if FAdjudicationList = nil then
    FAdjudicationList := TFhirExplanationOfBenefitItemAdjudicationList.Create;
  result := FAdjudicationList;
end;

function TFhirExplanationOfBenefitItemDetail.GetHasAdjudicationList : boolean;
begin
  result := (FAdjudicationList <> nil) and (FAdjudicationList.count > 0);
end;

function TFhirExplanationOfBenefitItemDetail.GetSubDetailList : TFhirExplanationOfBenefitItemDetailSubDetailList;
begin
  if FSubDetailList = nil then
    FSubDetailList := TFhirExplanationOfBenefitItemDetailSubDetailList.Create;
  result := FSubDetailList;
end;

function TFhirExplanationOfBenefitItemDetail.GetHasSubDetailList : boolean;
begin
  result := (FSubDetailList <> nil) and (FSubDetailList.count > 0);
end;

{ TFhirExplanationOfBenefitItemDetailListEnumerator }

constructor TFhirExplanationOfBenefitItemDetailListEnumerator.Create(list : TFhirExplanationOfBenefitItemDetailList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirExplanationOfBenefitItemDetailListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirExplanationOfBenefitItemDetailListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirExplanationOfBenefitItemDetailListEnumerator.GetCurrent : TFhirExplanationOfBenefitItemDetail;
begin
  Result := FList[FIndex];
end;

function TFhirExplanationOfBenefitItemDetailListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirExplanationOfBenefitItemDetailList }

procedure TFhirExplanationOfBenefitItemDetailList.AddItem(value: TFhirExplanationOfBenefitItemDetail);
begin
  assert(value.ClassName = 'TFhirExplanationOfBenefitItemDetail', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirExplanationOfBenefitItemDetail');
  add(value);
end;

function TFhirExplanationOfBenefitItemDetailList.Append: TFhirExplanationOfBenefitItemDetail;
begin
  result := TFhirExplanationOfBenefitItemDetail.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirExplanationOfBenefitItemDetailList.ClearItems;
begin
  Clear;
end;

function TFhirExplanationOfBenefitItemDetailList.GetEnumerator : TFhirExplanationOfBenefitItemDetailListEnumerator;
begin
  result := TFhirExplanationOfBenefitItemDetailListEnumerator.Create(self.link);
end;

function TFhirExplanationOfBenefitItemDetailList.Clone: TFhirExplanationOfBenefitItemDetailList;
begin
  result := TFhirExplanationOfBenefitItemDetailList(inherited Clone);
end;

function TFhirExplanationOfBenefitItemDetailList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirExplanationOfBenefitItemDetailList.GetItemN(index: Integer): TFhirExplanationOfBenefitItemDetail;
begin
  result := TFhirExplanationOfBenefitItemDetail(ObjectByIndex[index]);
end;

function TFhirExplanationOfBenefitItemDetailList.ItemClass: TFslObjectClass;
begin
  result := TFhirExplanationOfBenefitItemDetail;
end;
function TFhirExplanationOfBenefitItemDetailList.IndexOf(value: TFhirExplanationOfBenefitItemDetail): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirExplanationOfBenefitItemDetailList.Insert(index: Integer): TFhirExplanationOfBenefitItemDetail;
begin
  result := TFhirExplanationOfBenefitItemDetail.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirExplanationOfBenefitItemDetailList.InsertItem(index: Integer; value: TFhirExplanationOfBenefitItemDetail);
begin
  assert(value is TFhirExplanationOfBenefitItemDetail);
  Inherited Insert(index, value);
end;

function TFhirExplanationOfBenefitItemDetailList.Item(index: Integer): TFhirExplanationOfBenefitItemDetail;
begin
  result := TFhirExplanationOfBenefitItemDetail(ObjectByIndex[index]);
end;

function TFhirExplanationOfBenefitItemDetailList.Link: TFhirExplanationOfBenefitItemDetailList;
begin
  result := TFhirExplanationOfBenefitItemDetailList(inherited Link);
end;

procedure TFhirExplanationOfBenefitItemDetailList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirExplanationOfBenefitItemDetailList.SetItemByIndex(index: Integer; value: TFhirExplanationOfBenefitItemDetail);
begin
  assert(value is TFhirExplanationOfBenefitItemDetail);
  FhirExplanationOfBenefitItemDetails[index] := value;
end;

procedure TFhirExplanationOfBenefitItemDetailList.SetItemN(index: Integer; value: TFhirExplanationOfBenefitItemDetail);
begin
  assert(value is TFhirExplanationOfBenefitItemDetail);
  ObjectByIndex[index] := value;
end;

{ TFhirExplanationOfBenefitItemDetailSubDetail }

constructor TFhirExplanationOfBenefitItemDetailSubDetail.Create;
begin
  inherited;
end;

destructor TFhirExplanationOfBenefitItemDetailSubDetail.Destroy;
begin
  FSequence.free;
  FRevenue.free;
  FCategory.free;
  FProductOrService.free;
  FModifierList.Free;
  FProgramCodeList.Free;
  FQuantity.free;
  FUnitPrice.free;
  FFactor.free;
  FNet.free;
  FUdiList.Free;
  FNoteNumberList.Free;
  FAdjudicationList.Free;
  inherited;
end;

procedure TFhirExplanationOfBenefitItemDetailSubDetail.Assign(oSource : TFslObject);
begin
  inherited;
  sequenceElement := TFhirExplanationOfBenefitItemDetailSubDetail(oSource).sequenceElement.Clone;
  revenue := TFhirExplanationOfBenefitItemDetailSubDetail(oSource).revenue.Clone;
  category := TFhirExplanationOfBenefitItemDetailSubDetail(oSource).category.Clone;
  productOrService := TFhirExplanationOfBenefitItemDetailSubDetail(oSource).productOrService.Clone;
  if (TFhirExplanationOfBenefitItemDetailSubDetail(oSource).FModifierList = nil) then
  begin
    FModifierList.free;
    FModifierList := nil;
  end
  else
  begin
    if FModifierList = nil then
      FModifierList := TFhirCodeableConceptList.Create;
    FModifierList.Assign(TFhirExplanationOfBenefitItemDetailSubDetail(oSource).FModifierList);
  end;
  if (TFhirExplanationOfBenefitItemDetailSubDetail(oSource).FProgramCodeList = nil) then
  begin
    FProgramCodeList.free;
    FProgramCodeList := nil;
  end
  else
  begin
    if FProgramCodeList = nil then
      FProgramCodeList := TFhirCodeableConceptList.Create;
    FProgramCodeList.Assign(TFhirExplanationOfBenefitItemDetailSubDetail(oSource).FProgramCodeList);
  end;
  quantity := TFhirExplanationOfBenefitItemDetailSubDetail(oSource).quantity.Clone;
  unitPrice := TFhirExplanationOfBenefitItemDetailSubDetail(oSource).unitPrice.Clone;
  factorElement := TFhirExplanationOfBenefitItemDetailSubDetail(oSource).factorElement.Clone;
  net := TFhirExplanationOfBenefitItemDetailSubDetail(oSource).net.Clone;
  if (TFhirExplanationOfBenefitItemDetailSubDetail(oSource).FUdiList = nil) then
  begin
    FUdiList.free;
    FUdiList := nil;
  end
  else
  begin
    if FUdiList = nil then
      FUdiList := TFhirReferenceList.Create;
    FUdiList.Assign(TFhirExplanationOfBenefitItemDetailSubDetail(oSource).FUdiList);
  end;
  if (TFhirExplanationOfBenefitItemDetailSubDetail(oSource).FNoteNumberList = nil) then
  begin
    FNoteNumberList.free;
    FNoteNumberList := nil;
  end
  else
  begin
    if FNoteNumberList = nil then
      FNoteNumberList := TFhirPositiveIntList.Create;
    FNoteNumberList.Assign(TFhirExplanationOfBenefitItemDetailSubDetail(oSource).FNoteNumberList);
  end;
  if (TFhirExplanationOfBenefitItemDetailSubDetail(oSource).FAdjudicationList = nil) then
  begin
    FAdjudicationList.free;
    FAdjudicationList := nil;
  end
  else
  begin
    if FAdjudicationList = nil then
      FAdjudicationList := TFhirExplanationOfBenefitItemAdjudicationList.Create;
    FAdjudicationList.Assign(TFhirExplanationOfBenefitItemDetailSubDetail(oSource).FAdjudicationList);
  end;
end;

procedure TFhirExplanationOfBenefitItemDetailSubDetail.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'sequence') Then
     list.add(self.link, 'sequence', FSequence.Link);
  if (child_name = 'revenue') Then
     list.add(self.link, 'revenue', FRevenue.Link);
  if (child_name = 'category') Then
     list.add(self.link, 'category', FCategory.Link);
  if (child_name = 'productOrService') Then
     list.add(self.link, 'productOrService', FProductOrService.Link);
  if (child_name = 'modifier') Then
    list.addAll(self, 'modifier', FModifierList);
  if (child_name = 'programCode') Then
    list.addAll(self, 'programCode', FProgramCodeList);
  if (child_name = 'quantity') Then
     list.add(self.link, 'quantity', FQuantity.Link);
  if (child_name = 'unitPrice') Then
     list.add(self.link, 'unitPrice', FUnitPrice.Link);
  if (child_name = 'factor') Then
     list.add(self.link, 'factor', FFactor.Link);
  if (child_name = 'net') Then
     list.add(self.link, 'net', FNet.Link);
  if (child_name = 'udi') Then
    list.addAll(self, 'udi', FUdiList);
  if (child_name = 'noteNumber') Then
    list.addAll(self, 'noteNumber', FNoteNumberList);
  if (child_name = 'adjudication') Then
    list.addAll(self, 'adjudication', FAdjudicationList);
end;

procedure TFhirExplanationOfBenefitItemDetailSubDetail.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'sequence', 'positiveInt', false, TFhirPositiveInt, FSequence.Link));
  oList.add(TFHIRProperty.create(self, 'revenue', 'CodeableConcept', false, TFhirCodeableConcept, FRevenue.Link));
  oList.add(TFHIRProperty.create(self, 'category', 'CodeableConcept', false, TFhirCodeableConcept, FCategory.Link));
  oList.add(TFHIRProperty.create(self, 'productOrService', 'CodeableConcept', false, TFhirCodeableConcept, FProductOrService.Link));
  oList.add(TFHIRProperty.create(self, 'modifier', 'CodeableConcept', true, TFhirCodeableConcept, FModifierList.Link));
  oList.add(TFHIRProperty.create(self, 'programCode', 'CodeableConcept', true, TFhirCodeableConcept, FProgramCodeList.Link));
  oList.add(TFHIRProperty.create(self, 'quantity', 'Quantity', false, TFhirQuantity, FQuantity.Link));
  oList.add(TFHIRProperty.create(self, 'unitPrice', 'Money', false, TFhirMoney, FUnitPrice.Link));
  oList.add(TFHIRProperty.create(self, 'factor', 'decimal', false, TFhirDecimal, FFactor.Link));
  oList.add(TFHIRProperty.create(self, 'net', 'Money', false, TFhirMoney, FNet.Link));
  oList.add(TFHIRProperty.create(self, 'udi', 'Reference', true, TFhirReference, FUdiList.Link));
  oList.add(TFHIRProperty.create(self, 'noteNumber', 'positiveInt', true, TFhirPositiveInt, FNoteNumberList.Link));
  oList.add(TFHIRProperty.create(self, 'adjudication', '', true, TFhirExplanationOfBenefitItemAdjudication, FAdjudicationList.Link));
end;

function TFhirExplanationOfBenefitItemDetailSubDetail.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'sequence') then
  begin
    SequenceElement := asPositiveInt(propValue);
    result := propValue;
  end
  else if (propName = 'revenue') then
  begin
    Revenue := propValue as TFhirCodeableConcept;
    result := propValue;
  end
  else if (propName = 'category') then
  begin
    Category := propValue as TFhirCodeableConcept;
    result := propValue;
  end
  else if (propName = 'productOrService') then
  begin
    ProductOrService := propValue as TFhirCodeableConcept;
    result := propValue;
  end
  else if (propName = 'modifier') then
  begin
    ModifierList.add(propValue as TFhirCodeableConcept);
    result := propValue;
  end
  else if (propName = 'programCode') then
  begin
    ProgramCodeList.add(propValue as TFhirCodeableConcept);
    result := propValue;
  end
  else if (propName = 'quantity') then
  begin
    Quantity := propValue as TFhirQuantity;
    result := propValue;
  end
  else if (propName = 'unitPrice') then
  begin
    UnitPrice := propValue as TFhirMoney;
    result := propValue;
  end
  else if (propName = 'factor') then
  begin
    FactorElement := asDecimal(propValue);
    result := propValue;
  end
  else if (propName = 'net') then
  begin
    Net := propValue as TFhirMoney;
    result := propValue;
  end
  else if (propName = 'udi') then
  begin
    UdiList.add(propValue as TFhirReference);
    result := propValue;
  end
  else if (propName = 'noteNumber') then
  begin
    NoteNumberList.add(asPositiveInt(propValue)){2};     result := propValue;

  end
  else if (propName = 'adjudication') then
  begin
    AdjudicationList.add(propValue as TFhirExplanationOfBenefitItemAdjudication);
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirExplanationOfBenefitItemDetailSubDetail.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'modifier') then ModifierList.insertItem(index, propValue as TFhirCodeableConcept)
  else if (propName = 'programCode') then ProgramCodeList.insertItem(index, propValue as TFhirCodeableConcept)
  else if (propName = 'udi') then UdiList.insertItem(index, propValue as TFhirReference)
  else if (propName = 'noteNumber') then NoteNumberList.insertItem(index, asPositiveInt(propValue))
  else if (propName = 'adjudication') then AdjudicationList.insertItem(index, propValue as TFhirExplanationOfBenefitItemAdjudication)
  else inherited;
end;

function TFhirExplanationOfBenefitItemDetailSubDetail.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'sequence') then result := TFhirPositiveInt.create()
  else if (propName = 'revenue') then result := TFhirCodeableConcept.create()
  else if (propName = 'category') then result := TFhirCodeableConcept.create()
  else if (propName = 'productOrService') then result := TFhirCodeableConcept.create()
  else if (propName = 'modifier') then result := ModifierList.new()
  else if (propName = 'programCode') then result := ProgramCodeList.new()
  else if (propName = 'quantity') then result := TFhirQuantity.create()
  else if (propName = 'unitPrice') then result := TFhirMoney.create()
  else if (propName = 'factor') then result := TFhirDecimal.create()
  else if (propName = 'net') then result := TFhirMoney.create()
  else if (propName = 'udi') then result := UdiList.new()
  else if (propName = 'noteNumber') then result := NoteNumberList.new()
  else if (propName = 'adjudication') then result := AdjudicationList.new()
  else result := inherited createPropertyValue(propName);
end;

function TFhirExplanationOfBenefitItemDetailSubDetail.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'sequence') then result := 'positiveInt'
  else if (propName = 'revenue') then result := 'CodeableConcept'
  else if (propName = 'category') then result := 'CodeableConcept'
  else if (propName = 'productOrService') then result := 'CodeableConcept'
  else if (propName = 'modifier') then result := 'CodeableConcept'
  else if (propName = 'programCode') then result := 'CodeableConcept'
  else if (propName = 'quantity') then result := 'Quantity'
  else if (propName = 'unitPrice') then result := 'Money'
  else if (propName = 'factor') then result := 'decimal'
  else if (propName = 'net') then result := 'Money'
  else if (propName = 'udi') then result := 'Reference'
  else if (propName = 'noteNumber') then result := 'positiveInt'
  else if (propName = 'adjudication') then result := ''
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirExplanationOfBenefitItemDetailSubDetail.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'sequence') then SequenceElement := nil
  else if (propName = 'revenue') then RevenueElement := nil
  else if (propName = 'category') then CategoryElement := nil
  else if (propName = 'productOrService') then ProductOrServiceElement := nil
  else if (propName = 'modifier') then deletePropertyValue('modifier', ModifierList, value)
  else if (propName = 'programCode') then deletePropertyValue('programCode', ProgramCodeList, value)
  else if (propName = 'quantity') then QuantityElement := nil
  else if (propName = 'unitPrice') then UnitPriceElement := nil
  else if (propName = 'factor') then FactorElement := nil
  else if (propName = 'net') then NetElement := nil
  else if (propName = 'udi') then deletePropertyValue('udi', UdiList, value)
  else if (propName = 'noteNumber') then deletePropertyValue('noteNumber', NoteNumberList, value)
  else if (propName = 'adjudication') then deletePropertyValue('adjudication', AdjudicationList, value)
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirExplanationOfBenefitItemDetailSubDetail.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'sequence') then SequenceElement := asPositiveInt(new)
  else if (propName = 'revenue') then RevenueElement := new as TFhirCodeableConcept
  else if (propName = 'category') then CategoryElement := new as TFhirCodeableConcept
  else if (propName = 'productOrService') then ProductOrServiceElement := new as TFhirCodeableConcept
  else if (propName = 'modifier') then replacePropertyValue('modifier', ModifierList, existing, new)
  else if (propName = 'programCode') then replacePropertyValue('programCode', ProgramCodeList, existing, new)
  else if (propName = 'quantity') then QuantityElement := new as TFhirQuantity
  else if (propName = 'unitPrice') then UnitPriceElement := new as TFhirMoney
  else if (propName = 'factor') then FactorElement := asDecimal(new)
  else if (propName = 'net') then NetElement := new as TFhirMoney
  else if (propName = 'udi') then replacePropertyValue('udi', UdiList, existing, new)
  else if (propName = 'noteNumber') then replacePropertyValue('noteNumber', NoteNumberList, existing, new)
  else if (propName = 'adjudication') then replacePropertyValue('adjudication', AdjudicationList, existing, new)
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirExplanationOfBenefitItemDetailSubDetail.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'modifier') then ModifierList.move(source, destination)
  else if (propName = 'programCode') then ProgramCodeList.move(source, destination)
  else if (propName = 'udi') then UdiList.move(source, destination)
  else if (propName = 'noteNumber') then NoteNumberList.move(source, destination)
  else if (propName = 'adjudication') then AdjudicationList.move(source, destination)
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirExplanationOfBenefitItemDetailSubDetail.fhirType : string;
begin
  result := 'ExplanationOfBenefit.item.detail.subDetail';
end;

function TFhirExplanationOfBenefitItemDetailSubDetail.Link : TFhirExplanationOfBenefitItemDetailSubDetail;
begin
  result := TFhirExplanationOfBenefitItemDetailSubDetail(inherited Link);
end;

function TFhirExplanationOfBenefitItemDetailSubDetail.Clone : TFhirExplanationOfBenefitItemDetailSubDetail;
begin
  result := TFhirExplanationOfBenefitItemDetailSubDetail(inherited Clone);
end;

function TFhirExplanationOfBenefitItemDetailSubDetail.equals(other : TObject) : boolean; 
var
  o : TFhirExplanationOfBenefitItemDetailSubDetail;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirExplanationOfBenefitItemDetailSubDetail)) then
    result := false
  else
  begin
    o := TFhirExplanationOfBenefitItemDetailSubDetail(other);
    result := compareDeep(sequenceElement, o.sequenceElement, true) and compareDeep(revenueElement, o.revenueElement, true) and 
      compareDeep(categoryElement, o.categoryElement, true) and compareDeep(productOrServiceElement, o.productOrServiceElement, true) and 
      compareDeep(modifierList, o.modifierList, true) and compareDeep(programCodeList, o.programCodeList, true) and 
      compareDeep(quantityElement, o.quantityElement, true) and compareDeep(unitPriceElement, o.unitPriceElement, true) and 
      compareDeep(factorElement, o.factorElement, true) and compareDeep(netElement, o.netElement, true) and 
      compareDeep(udiList, o.udiList, true) and compareDeep(noteNumberList, o.noteNumberList, true) and 
      compareDeep(adjudicationList, o.adjudicationList, true);
  end;
end;

function TFhirExplanationOfBenefitItemDetailSubDetail.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FSequence) and isEmptyProp(FRevenue) and isEmptyProp(FCategory) and isEmptyProp(FProductOrService) and isEmptyProp(FmodifierList) and isEmptyProp(FprogramCodeList) and isEmptyProp(FQuantity) and isEmptyProp(FUnitPrice) and isEmptyProp(FFactor) and isEmptyProp(FNet) and isEmptyProp(FudiList) and isEmptyProp(FnoteNumberList) and isEmptyProp(FadjudicationList);
end;

procedure TFhirExplanationOfBenefitItemDetailSubDetail.listFieldsInOrder(fields : TStringList);
begin
  inherited listFieldsInOrder(fields);
  fields.add('sequence');
  fields.add('revenue');
  fields.add('category');
  fields.add('productOrService');
  fields.add('modifier');
  fields.add('programCode');
  fields.add('quantity');
  fields.add('unitPrice');
  fields.add('factor');
  fields.add('net');
  fields.add('udi');
  fields.add('noteNumber');
  fields.add('adjudication');
end;

function TFhirExplanationOfBenefitItemDetailSubDetail.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FModifierList.sizeInBytes(magic));
  inc(result, FProgramCodeList.sizeInBytes(magic));
  inc(result, FUdiList.sizeInBytes(magic));
  inc(result, FNoteNumberList.sizeInBytes(magic));
  inc(result, FAdjudicationList.sizeInBytes(magic));
end;

procedure TFhirExplanationOfBenefitItemDetailSubDetail.SetSequence(value : TFhirPositiveInt);
begin
  FSequence.free;
  FSequence := value;
end;

function TFhirExplanationOfBenefitItemDetailSubDetail.GetSequenceST : String;
begin
  if FSequence = nil then
    result := ''
  else
    result := FSequence.value;
end;

procedure TFhirExplanationOfBenefitItemDetailSubDetail.SetSequenceST(value : String);
begin
  if value <> '' then
  begin
    if FSequence = nil then
      FSequence := TFhirPositiveInt.create;
    FSequence.value := value
  end
  else if FSequence <> nil then
    FSequence.value := '';
end;

procedure TFhirExplanationOfBenefitItemDetailSubDetail.SetRevenue(value : TFhirCodeableConcept);
begin
  FRevenue.free;
  FRevenue := value;
end;

procedure TFhirExplanationOfBenefitItemDetailSubDetail.SetCategory(value : TFhirCodeableConcept);
begin
  FCategory.free;
  FCategory := value;
end;

procedure TFhirExplanationOfBenefitItemDetailSubDetail.SetProductOrService(value : TFhirCodeableConcept);
begin
  FProductOrService.free;
  FProductOrService := value;
end;

function TFhirExplanationOfBenefitItemDetailSubDetail.GetModifierList : TFhirCodeableConceptList;
begin
  if FModifierList = nil then
    FModifierList := TFhirCodeableConceptList.Create;
  result := FModifierList;
end;

function TFhirExplanationOfBenefitItemDetailSubDetail.GetHasModifierList : boolean;
begin
  result := (FModifierList <> nil) and (FModifierList.count > 0);
end;

function TFhirExplanationOfBenefitItemDetailSubDetail.GetProgramCodeList : TFhirCodeableConceptList;
begin
  if FProgramCodeList = nil then
    FProgramCodeList := TFhirCodeableConceptList.Create;
  result := FProgramCodeList;
end;

function TFhirExplanationOfBenefitItemDetailSubDetail.GetHasProgramCodeList : boolean;
begin
  result := (FProgramCodeList <> nil) and (FProgramCodeList.count > 0);
end;

procedure TFhirExplanationOfBenefitItemDetailSubDetail.SetQuantity(value : TFhirQuantity);
begin
  FQuantity.free;
  FQuantity := value;
end;

procedure TFhirExplanationOfBenefitItemDetailSubDetail.SetUnitPrice(value : TFhirMoney);
begin
  FUnitPrice.free;
  FUnitPrice := value;
end;

procedure TFhirExplanationOfBenefitItemDetailSubDetail.SetFactor(value : TFhirDecimal);
begin
  FFactor.free;
  FFactor := value;
end;

function TFhirExplanationOfBenefitItemDetailSubDetail.GetFactorST : String;
begin
  if FFactor = nil then
    result := ''
  else
    result := FFactor.value;
end;

procedure TFhirExplanationOfBenefitItemDetailSubDetail.SetFactorST(value : String);
begin
  if value <> '' then
  begin
    if FFactor = nil then
      FFactor := TFhirDecimal.create;
    FFactor.value := value
  end
  else if FFactor <> nil then
    FFactor.value := '';
end;

procedure TFhirExplanationOfBenefitItemDetailSubDetail.SetNet(value : TFhirMoney);
begin
  FNet.free;
  FNet := value;
end;

function TFhirExplanationOfBenefitItemDetailSubDetail.GetUdiList : TFhirReferenceList;
begin
  if FUdiList = nil then
    FUdiList := TFhirReferenceList.Create;
  result := FUdiList;
end;

function TFhirExplanationOfBenefitItemDetailSubDetail.GetHasUdiList : boolean;
begin
  result := (FUdiList <> nil) and (FUdiList.count > 0);
end;

function TFhirExplanationOfBenefitItemDetailSubDetail.GetNoteNumberList : TFhirPositiveIntList;
begin
  if FNoteNumberList = nil then
    FNoteNumberList := TFhirPositiveIntList.Create;
  result := FNoteNumberList;
end;

function TFhirExplanationOfBenefitItemDetailSubDetail.GetHasNoteNumberList : boolean;
begin
  result := (FNoteNumberList <> nil) and (FNoteNumberList.count > 0);
end;

function TFhirExplanationOfBenefitItemDetailSubDetail.GetAdjudicationList : TFhirExplanationOfBenefitItemAdjudicationList;
begin
  if FAdjudicationList = nil then
    FAdjudicationList := TFhirExplanationOfBenefitItemAdjudicationList.Create;
  result := FAdjudicationList;
end;

function TFhirExplanationOfBenefitItemDetailSubDetail.GetHasAdjudicationList : boolean;
begin
  result := (FAdjudicationList <> nil) and (FAdjudicationList.count > 0);
end;

{ TFhirExplanationOfBenefitItemDetailSubDetailListEnumerator }

constructor TFhirExplanationOfBenefitItemDetailSubDetailListEnumerator.Create(list : TFhirExplanationOfBenefitItemDetailSubDetailList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirExplanationOfBenefitItemDetailSubDetailListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirExplanationOfBenefitItemDetailSubDetailListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirExplanationOfBenefitItemDetailSubDetailListEnumerator.GetCurrent : TFhirExplanationOfBenefitItemDetailSubDetail;
begin
  Result := FList[FIndex];
end;

function TFhirExplanationOfBenefitItemDetailSubDetailListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirExplanationOfBenefitItemDetailSubDetailList }

procedure TFhirExplanationOfBenefitItemDetailSubDetailList.AddItem(value: TFhirExplanationOfBenefitItemDetailSubDetail);
begin
  assert(value.ClassName = 'TFhirExplanationOfBenefitItemDetailSubDetail', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirExplanationOfBenefitItemDetailSubDetail');
  add(value);
end;

function TFhirExplanationOfBenefitItemDetailSubDetailList.Append: TFhirExplanationOfBenefitItemDetailSubDetail;
begin
  result := TFhirExplanationOfBenefitItemDetailSubDetail.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirExplanationOfBenefitItemDetailSubDetailList.ClearItems;
begin
  Clear;
end;

function TFhirExplanationOfBenefitItemDetailSubDetailList.GetEnumerator : TFhirExplanationOfBenefitItemDetailSubDetailListEnumerator;
begin
  result := TFhirExplanationOfBenefitItemDetailSubDetailListEnumerator.Create(self.link);
end;

function TFhirExplanationOfBenefitItemDetailSubDetailList.Clone: TFhirExplanationOfBenefitItemDetailSubDetailList;
begin
  result := TFhirExplanationOfBenefitItemDetailSubDetailList(inherited Clone);
end;

function TFhirExplanationOfBenefitItemDetailSubDetailList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirExplanationOfBenefitItemDetailSubDetailList.GetItemN(index: Integer): TFhirExplanationOfBenefitItemDetailSubDetail;
begin
  result := TFhirExplanationOfBenefitItemDetailSubDetail(ObjectByIndex[index]);
end;

function TFhirExplanationOfBenefitItemDetailSubDetailList.ItemClass: TFslObjectClass;
begin
  result := TFhirExplanationOfBenefitItemDetailSubDetail;
end;
function TFhirExplanationOfBenefitItemDetailSubDetailList.IndexOf(value: TFhirExplanationOfBenefitItemDetailSubDetail): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirExplanationOfBenefitItemDetailSubDetailList.Insert(index: Integer): TFhirExplanationOfBenefitItemDetailSubDetail;
begin
  result := TFhirExplanationOfBenefitItemDetailSubDetail.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirExplanationOfBenefitItemDetailSubDetailList.InsertItem(index: Integer; value: TFhirExplanationOfBenefitItemDetailSubDetail);
begin
  assert(value is TFhirExplanationOfBenefitItemDetailSubDetail);
  Inherited Insert(index, value);
end;

function TFhirExplanationOfBenefitItemDetailSubDetailList.Item(index: Integer): TFhirExplanationOfBenefitItemDetailSubDetail;
begin
  result := TFhirExplanationOfBenefitItemDetailSubDetail(ObjectByIndex[index]);
end;

function TFhirExplanationOfBenefitItemDetailSubDetailList.Link: TFhirExplanationOfBenefitItemDetailSubDetailList;
begin
  result := TFhirExplanationOfBenefitItemDetailSubDetailList(inherited Link);
end;

procedure TFhirExplanationOfBenefitItemDetailSubDetailList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirExplanationOfBenefitItemDetailSubDetailList.SetItemByIndex(index: Integer; value: TFhirExplanationOfBenefitItemDetailSubDetail);
begin
  assert(value is TFhirExplanationOfBenefitItemDetailSubDetail);
  FhirExplanationOfBenefitItemDetailSubDetails[index] := value;
end;

procedure TFhirExplanationOfBenefitItemDetailSubDetailList.SetItemN(index: Integer; value: TFhirExplanationOfBenefitItemDetailSubDetail);
begin
  assert(value is TFhirExplanationOfBenefitItemDetailSubDetail);
  ObjectByIndex[index] := value;
end;

{ TFhirExplanationOfBenefitAddItem }

constructor TFhirExplanationOfBenefitAddItem.Create;
begin
  inherited;
end;

destructor TFhirExplanationOfBenefitAddItem.Destroy;
begin
  FItemSequenceList.Free;
  FDetailSequenceList.Free;
  FSubDetailSequenceList.Free;
  FProviderList.Free;
  FProductOrService.free;
  FModifierList.Free;
  FProgramCodeList.Free;
  FServiced.free;
  FLocation.free;
  FQuantity.free;
  FUnitPrice.free;
  FFactor.free;
  FNet.free;
  FBodySite.free;
  FSubSiteList.Free;
  FNoteNumberList.Free;
  FAdjudicationList.Free;
  FDetailList.Free;
  inherited;
end;

procedure TFhirExplanationOfBenefitAddItem.Assign(oSource : TFslObject);
begin
  inherited;
  if (TFhirExplanationOfBenefitAddItem(oSource).FItemSequenceList = nil) then
  begin
    FItemSequenceList.free;
    FItemSequenceList := nil;
  end
  else
  begin
    if FItemSequenceList = nil then
      FItemSequenceList := TFhirPositiveIntList.Create;
    FItemSequenceList.Assign(TFhirExplanationOfBenefitAddItem(oSource).FItemSequenceList);
  end;
  if (TFhirExplanationOfBenefitAddItem(oSource).FDetailSequenceList = nil) then
  begin
    FDetailSequenceList.free;
    FDetailSequenceList := nil;
  end
  else
  begin
    if FDetailSequenceList = nil then
      FDetailSequenceList := TFhirPositiveIntList.Create;
    FDetailSequenceList.Assign(TFhirExplanationOfBenefitAddItem(oSource).FDetailSequenceList);
  end;
  if (TFhirExplanationOfBenefitAddItem(oSource).FSubDetailSequenceList = nil) then
  begin
    FSubDetailSequenceList.free;
    FSubDetailSequenceList := nil;
  end
  else
  begin
    if FSubDetailSequenceList = nil then
      FSubDetailSequenceList := TFhirPositiveIntList.Create;
    FSubDetailSequenceList.Assign(TFhirExplanationOfBenefitAddItem(oSource).FSubDetailSequenceList);
  end;
  if (TFhirExplanationOfBenefitAddItem(oSource).FProviderList = nil) then
  begin
    FProviderList.free;
    FProviderList := nil;
  end
  else
  begin
    if FProviderList = nil then
      FProviderList := TFhirReferenceList.Create;
    FProviderList.Assign(TFhirExplanationOfBenefitAddItem(oSource).FProviderList);
  end;
  productOrService := TFhirExplanationOfBenefitAddItem(oSource).productOrService.Clone;
  if (TFhirExplanationOfBenefitAddItem(oSource).FModifierList = nil) then
  begin
    FModifierList.free;
    FModifierList := nil;
  end
  else
  begin
    if FModifierList = nil then
      FModifierList := TFhirCodeableConceptList.Create;
    FModifierList.Assign(TFhirExplanationOfBenefitAddItem(oSource).FModifierList);
  end;
  if (TFhirExplanationOfBenefitAddItem(oSource).FProgramCodeList = nil) then
  begin
    FProgramCodeList.free;
    FProgramCodeList := nil;
  end
  else
  begin
    if FProgramCodeList = nil then
      FProgramCodeList := TFhirCodeableConceptList.Create;
    FProgramCodeList.Assign(TFhirExplanationOfBenefitAddItem(oSource).FProgramCodeList);
  end;
  serviced := TFhirExplanationOfBenefitAddItem(oSource).serviced.Clone;
  location := TFhirExplanationOfBenefitAddItem(oSource).location.Clone;
  quantity := TFhirExplanationOfBenefitAddItem(oSource).quantity.Clone;
  unitPrice := TFhirExplanationOfBenefitAddItem(oSource).unitPrice.Clone;
  factorElement := TFhirExplanationOfBenefitAddItem(oSource).factorElement.Clone;
  net := TFhirExplanationOfBenefitAddItem(oSource).net.Clone;
  bodySite := TFhirExplanationOfBenefitAddItem(oSource).bodySite.Clone;
  if (TFhirExplanationOfBenefitAddItem(oSource).FSubSiteList = nil) then
  begin
    FSubSiteList.free;
    FSubSiteList := nil;
  end
  else
  begin
    if FSubSiteList = nil then
      FSubSiteList := TFhirCodeableConceptList.Create;
    FSubSiteList.Assign(TFhirExplanationOfBenefitAddItem(oSource).FSubSiteList);
  end;
  if (TFhirExplanationOfBenefitAddItem(oSource).FNoteNumberList = nil) then
  begin
    FNoteNumberList.free;
    FNoteNumberList := nil;
  end
  else
  begin
    if FNoteNumberList = nil then
      FNoteNumberList := TFhirPositiveIntList.Create;
    FNoteNumberList.Assign(TFhirExplanationOfBenefitAddItem(oSource).FNoteNumberList);
  end;
  if (TFhirExplanationOfBenefitAddItem(oSource).FAdjudicationList = nil) then
  begin
    FAdjudicationList.free;
    FAdjudicationList := nil;
  end
  else
  begin
    if FAdjudicationList = nil then
      FAdjudicationList := TFhirExplanationOfBenefitItemAdjudicationList.Create;
    FAdjudicationList.Assign(TFhirExplanationOfBenefitAddItem(oSource).FAdjudicationList);
  end;
  if (TFhirExplanationOfBenefitAddItem(oSource).FDetailList = nil) then
  begin
    FDetailList.free;
    FDetailList := nil;
  end
  else
  begin
    if FDetailList = nil then
      FDetailList := TFhirExplanationOfBenefitAddItemDetailList.Create;
    FDetailList.Assign(TFhirExplanationOfBenefitAddItem(oSource).FDetailList);
  end;
end;

procedure TFhirExplanationOfBenefitAddItem.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'itemSequence') Then
    list.addAll(self, 'itemSequence', FItemSequenceList);
  if (child_name = 'detailSequence') Then
    list.addAll(self, 'detailSequence', FDetailSequenceList);
  if (child_name = 'subDetailSequence') Then
    list.addAll(self, 'subDetailSequence', FSubDetailSequenceList);
  if (child_name = 'provider') Then
    list.addAll(self, 'provider', FProviderList);
  if (child_name = 'productOrService') Then
     list.add(self.link, 'productOrService', FProductOrService.Link);
  if (child_name = 'modifier') Then
    list.addAll(self, 'modifier', FModifierList);
  if (child_name = 'programCode') Then
    list.addAll(self, 'programCode', FProgramCodeList);
  if (child_name = 'serviced[x]') or (child_name = 'serviced') Then
     list.add(self.link, 'serviced[x]', FServiced.Link);
  if (child_name = 'location[x]') or (child_name = 'location') Then
     list.add(self.link, 'location[x]', FLocation.Link);
  if (child_name = 'quantity') Then
     list.add(self.link, 'quantity', FQuantity.Link);
  if (child_name = 'unitPrice') Then
     list.add(self.link, 'unitPrice', FUnitPrice.Link);
  if (child_name = 'factor') Then
     list.add(self.link, 'factor', FFactor.Link);
  if (child_name = 'net') Then
     list.add(self.link, 'net', FNet.Link);
  if (child_name = 'bodySite') Then
     list.add(self.link, 'bodySite', FBodySite.Link);
  if (child_name = 'subSite') Then
    list.addAll(self, 'subSite', FSubSiteList);
  if (child_name = 'noteNumber') Then
    list.addAll(self, 'noteNumber', FNoteNumberList);
  if (child_name = 'adjudication') Then
    list.addAll(self, 'adjudication', FAdjudicationList);
  if (child_name = 'detail') Then
    list.addAll(self, 'detail', FDetailList);
end;

procedure TFhirExplanationOfBenefitAddItem.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'itemSequence', 'positiveInt', true, TFhirPositiveInt, FItemSequenceList.Link));
  oList.add(TFHIRProperty.create(self, 'detailSequence', 'positiveInt', true, TFhirPositiveInt, FDetailSequenceList.Link));
  oList.add(TFHIRProperty.create(self, 'subDetailSequence', 'positiveInt', true, TFhirPositiveInt, FSubDetailSequenceList.Link));
  oList.add(TFHIRProperty.create(self, 'provider', 'Reference', true, TFhirReference, FProviderList.Link));
  oList.add(TFHIRProperty.create(self, 'productOrService', 'CodeableConcept', false, TFhirCodeableConcept, FProductOrService.Link));
  oList.add(TFHIRProperty.create(self, 'modifier', 'CodeableConcept', true, TFhirCodeableConcept, FModifierList.Link));
  oList.add(TFHIRProperty.create(self, 'programCode', 'CodeableConcept', true, TFhirCodeableConcept, FProgramCodeList.Link));
  oList.add(TFHIRProperty.create(self, 'serviced[x]', 'date|Period', false, TFhirDataType, FServiced.Link));
  oList.add(TFHIRProperty.create(self, 'location[x]', 'CodeableConcept|Address|Reference', false, TFhirDataType, FLocation.Link));
  oList.add(TFHIRProperty.create(self, 'quantity', 'Quantity', false, TFhirQuantity, FQuantity.Link));
  oList.add(TFHIRProperty.create(self, 'unitPrice', 'Money', false, TFhirMoney, FUnitPrice.Link));
  oList.add(TFHIRProperty.create(self, 'factor', 'decimal', false, TFhirDecimal, FFactor.Link));
  oList.add(TFHIRProperty.create(self, 'net', 'Money', false, TFhirMoney, FNet.Link));
  oList.add(TFHIRProperty.create(self, 'bodySite', 'CodeableConcept', false, TFhirCodeableConcept, FBodySite.Link));
  oList.add(TFHIRProperty.create(self, 'subSite', 'CodeableConcept', true, TFhirCodeableConcept, FSubSiteList.Link));
  oList.add(TFHIRProperty.create(self, 'noteNumber', 'positiveInt', true, TFhirPositiveInt, FNoteNumberList.Link));
  oList.add(TFHIRProperty.create(self, 'adjudication', '', true, TFhirExplanationOfBenefitItemAdjudication, FAdjudicationList.Link));
  oList.add(TFHIRProperty.create(self, 'detail', 'BackboneElement', true, TFhirExplanationOfBenefitAddItemDetail, FDetailList.Link));
end;

function TFhirExplanationOfBenefitAddItem.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'itemSequence') then
  begin
    ItemSequenceList.add(asPositiveInt(propValue)){2};     result := propValue;

  end
  else if (propName = 'detailSequence') then
  begin
    DetailSequenceList.add(asPositiveInt(propValue)){2};     result := propValue;

  end
  else if (propName = 'subDetailSequence') then
  begin
    SubDetailSequenceList.add(asPositiveInt(propValue)){2};     result := propValue;

  end
  else if (propName = 'provider') then
  begin
    ProviderList.add(propValue as TFhirReference);
    result := propValue;
  end
  else if (propName = 'productOrService') then
  begin
    ProductOrService := propValue as TFhirCodeableConcept;
    result := propValue;
  end
  else if (propName = 'modifier') then
  begin
    ModifierList.add(propValue as TFhirCodeableConcept);
    result := propValue;
  end
  else if (propName = 'programCode') then
  begin
    ProgramCodeList.add(propValue as TFhirCodeableConcept);
    result := propValue;
  end
  else if (isMatchingName(propName, 'serviced', ['Date', 'Period'])) then
  begin
    Serviced := propValue as TFhirDataType;
    result := propValue;
  end
  else if (isMatchingName(propName, 'location', ['CodeableConcept', 'Address', 'Reference'])) then
  begin
    Location := propValue as TFhirDataType;
    result := propValue;
  end
  else if (propName = 'quantity') then
  begin
    Quantity := propValue as TFhirQuantity;
    result := propValue;
  end
  else if (propName = 'unitPrice') then
  begin
    UnitPrice := propValue as TFhirMoney;
    result := propValue;
  end
  else if (propName = 'factor') then
  begin
    FactorElement := asDecimal(propValue);
    result := propValue;
  end
  else if (propName = 'net') then
  begin
    Net := propValue as TFhirMoney;
    result := propValue;
  end
  else if (propName = 'bodySite') then
  begin
    BodySite := propValue as TFhirCodeableConcept;
    result := propValue;
  end
  else if (propName = 'subSite') then
  begin
    SubSiteList.add(propValue as TFhirCodeableConcept);
    result := propValue;
  end
  else if (propName = 'noteNumber') then
  begin
    NoteNumberList.add(asPositiveInt(propValue)){2};     result := propValue;

  end
  else if (propName = 'adjudication') then
  begin
    AdjudicationList.add(propValue as TFhirExplanationOfBenefitItemAdjudication);
    result := propValue;
  end
  else if (propName = 'detail') then
  begin
    DetailList.add(propValue as TFhirExplanationOfBenefitAddItemDetail);
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirExplanationOfBenefitAddItem.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'itemSequence') then ItemSequenceList.insertItem(index, asPositiveInt(propValue))
  else if (propName = 'detailSequence') then DetailSequenceList.insertItem(index, asPositiveInt(propValue))
  else if (propName = 'subDetailSequence') then SubDetailSequenceList.insertItem(index, asPositiveInt(propValue))
  else if (propName = 'provider') then ProviderList.insertItem(index, propValue as TFhirReference)
  else if (propName = 'modifier') then ModifierList.insertItem(index, propValue as TFhirCodeableConcept)
  else if (propName = 'programCode') then ProgramCodeList.insertItem(index, propValue as TFhirCodeableConcept)
  else if (propName = 'subSite') then SubSiteList.insertItem(index, propValue as TFhirCodeableConcept)
  else if (propName = 'noteNumber') then NoteNumberList.insertItem(index, asPositiveInt(propValue))
  else if (propName = 'adjudication') then AdjudicationList.insertItem(index, propValue as TFhirExplanationOfBenefitItemAdjudication)
  else if (propName = 'detail') then DetailList.insertItem(index, propValue as TFhirExplanationOfBenefitAddItemDetail)
  else inherited;
end;

function TFhirExplanationOfBenefitAddItem.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'itemSequence') then result := ItemSequenceList.new()
  else if (propName = 'detailSequence') then result := DetailSequenceList.new()
  else if (propName = 'subDetailSequence') then result := SubDetailSequenceList.new()
  else if (propName = 'provider') then result := ProviderList.new()
  else if (propName = 'productOrService') then result := TFhirCodeableConcept.create()
  else if (propName = 'modifier') then result := ModifierList.new()
  else if (propName = 'programCode') then result := ProgramCodeList.new()
  else if (isMatchingName(propName, 'serviced', ['Date', 'Period'])) then raise EFHIRException.create('Cannot make property Serviced')
  else if (isMatchingName(propName, 'location', ['CodeableConcept', 'Address', 'Reference'])) then raise EFHIRException.create('Cannot make property Location')
  else if (propName = 'quantity') then result := TFhirQuantity.create()
  else if (propName = 'unitPrice') then result := TFhirMoney.create()
  else if (propName = 'factor') then result := TFhirDecimal.create()
  else if (propName = 'net') then result := TFhirMoney.create()
  else if (propName = 'bodySite') then result := TFhirCodeableConcept.create()
  else if (propName = 'subSite') then result := SubSiteList.new()
  else if (propName = 'noteNumber') then result := NoteNumberList.new()
  else if (propName = 'adjudication') then result := AdjudicationList.new()
  else if (propName = 'detail') then result := DetailList.new()
  else result := inherited createPropertyValue(propName);
end;

function TFhirExplanationOfBenefitAddItem.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'itemSequence') then result := 'positiveInt'
  else if (propName = 'detailSequence') then result := 'positiveInt'
  else if (propName = 'subDetailSequence') then result := 'positiveInt'
  else if (propName = 'provider') then result := 'Reference'
  else if (propName = 'productOrService') then result := 'CodeableConcept'
  else if (propName = 'modifier') then result := 'CodeableConcept'
  else if (propName = 'programCode') then result := 'CodeableConcept'
  else if (propName = 'serviced[x]') then result := 'date|Period'
  else if (propName = 'location[x]') then result := 'CodeableConcept|Address|Reference'
  else if (propName = 'quantity') then result := 'Quantity'
  else if (propName = 'unitPrice') then result := 'Money'
  else if (propName = 'factor') then result := 'decimal'
  else if (propName = 'net') then result := 'Money'
  else if (propName = 'bodySite') then result := 'CodeableConcept'
  else if (propName = 'subSite') then result := 'CodeableConcept'
  else if (propName = 'noteNumber') then result := 'positiveInt'
  else if (propName = 'adjudication') then result := ''
  else if (propName = 'detail') then result := 'BackboneElement'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirExplanationOfBenefitAddItem.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'itemSequence') then deletePropertyValue('itemSequence', ItemSequenceList, value)
  else if (propName = 'detailSequence') then deletePropertyValue('detailSequence', DetailSequenceList, value)
  else if (propName = 'subDetailSequence') then deletePropertyValue('subDetailSequence', SubDetailSequenceList, value)
  else if (propName = 'provider') then deletePropertyValue('provider', ProviderList, value)
  else if (propName = 'productOrService') then ProductOrServiceElement := nil
  else if (propName = 'modifier') then deletePropertyValue('modifier', ModifierList, value)
  else if (propName = 'programCode') then deletePropertyValue('programCode', ProgramCodeList, value)
  else if (isMatchingName(propName, 'serviced', ['Date', 'Period'])) then ServicedElement := nil
  else if (isMatchingName(propName, 'location', ['CodeableConcept', 'Address', 'Reference'])) then LocationElement := nil
  else if (propName = 'quantity') then QuantityElement := nil
  else if (propName = 'unitPrice') then UnitPriceElement := nil
  else if (propName = 'factor') then FactorElement := nil
  else if (propName = 'net') then NetElement := nil
  else if (propName = 'bodySite') then BodySiteElement := nil
  else if (propName = 'subSite') then deletePropertyValue('subSite', SubSiteList, value)
  else if (propName = 'noteNumber') then deletePropertyValue('noteNumber', NoteNumberList, value)
  else if (propName = 'adjudication') then deletePropertyValue('adjudication', AdjudicationList, value)
  else if (propName = 'detail') then deletePropertyValue('detail', DetailList, value)
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirExplanationOfBenefitAddItem.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'itemSequence') then replacePropertyValue('itemSequence', ItemSequenceList, existing, new)
  else if (propName = 'detailSequence') then replacePropertyValue('detailSequence', DetailSequenceList, existing, new)
  else if (propName = 'subDetailSequence') then replacePropertyValue('subDetailSequence', SubDetailSequenceList, existing, new)
  else if (propName = 'provider') then replacePropertyValue('provider', ProviderList, existing, new)
  else if (propName = 'productOrService') then ProductOrServiceElement := new as TFhirCodeableConcept
  else if (propName = 'modifier') then replacePropertyValue('modifier', ModifierList, existing, new)
  else if (propName = 'programCode') then replacePropertyValue('programCode', ProgramCodeList, existing, new)
  else if (isMatchingName(propName, 'serviced', ['Date', 'Period'])) then ServicedElement := new as TFhirDataType
  else if (isMatchingName(propName, 'location', ['CodeableConcept', 'Address', 'Reference'])) then LocationElement := new as TFhirDataType
  else if (propName = 'quantity') then QuantityElement := new as TFhirQuantity
  else if (propName = 'unitPrice') then UnitPriceElement := new as TFhirMoney
  else if (propName = 'factor') then FactorElement := asDecimal(new)
  else if (propName = 'net') then NetElement := new as TFhirMoney
  else if (propName = 'bodySite') then BodySiteElement := new as TFhirCodeableConcept
  else if (propName = 'subSite') then replacePropertyValue('subSite', SubSiteList, existing, new)
  else if (propName = 'noteNumber') then replacePropertyValue('noteNumber', NoteNumberList, existing, new)
  else if (propName = 'adjudication') then replacePropertyValue('adjudication', AdjudicationList, existing, new)
  else if (propName = 'detail') then replacePropertyValue('detail', DetailList, existing, new)
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirExplanationOfBenefitAddItem.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'itemSequence') then ItemSequenceList.move(source, destination)
  else if (propName = 'detailSequence') then DetailSequenceList.move(source, destination)
  else if (propName = 'subDetailSequence') then SubDetailSequenceList.move(source, destination)
  else if (propName = 'provider') then ProviderList.move(source, destination)
  else if (propName = 'modifier') then ModifierList.move(source, destination)
  else if (propName = 'programCode') then ProgramCodeList.move(source, destination)
  else if (propName = 'subSite') then SubSiteList.move(source, destination)
  else if (propName = 'noteNumber') then NoteNumberList.move(source, destination)
  else if (propName = 'adjudication') then AdjudicationList.move(source, destination)
  else if (propName = 'detail') then DetailList.move(source, destination)
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirExplanationOfBenefitAddItem.fhirType : string;
begin
  result := 'ExplanationOfBenefit.addItem';
end;

function TFhirExplanationOfBenefitAddItem.Link : TFhirExplanationOfBenefitAddItem;
begin
  result := TFhirExplanationOfBenefitAddItem(inherited Link);
end;

function TFhirExplanationOfBenefitAddItem.Clone : TFhirExplanationOfBenefitAddItem;
begin
  result := TFhirExplanationOfBenefitAddItem(inherited Clone);
end;

function TFhirExplanationOfBenefitAddItem.equals(other : TObject) : boolean; 
var
  o : TFhirExplanationOfBenefitAddItem;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirExplanationOfBenefitAddItem)) then
    result := false
  else
  begin
    o := TFhirExplanationOfBenefitAddItem(other);
    result := compareDeep(itemSequenceList, o.itemSequenceList, true) and compareDeep(detailSequenceList, o.detailSequenceList, true) and 
      compareDeep(subDetailSequenceList, o.subDetailSequenceList, true) and compareDeep(providerList, o.providerList, true) and 
      compareDeep(productOrServiceElement, o.productOrServiceElement, true) and compareDeep(modifierList, o.modifierList, true) and 
      compareDeep(programCodeList, o.programCodeList, true) and compareDeep(servicedElement, o.servicedElement, true) and 
      compareDeep(locationElement, o.locationElement, true) and compareDeep(quantityElement, o.quantityElement, true) and 
      compareDeep(unitPriceElement, o.unitPriceElement, true) and compareDeep(factorElement, o.factorElement, true) and 
      compareDeep(netElement, o.netElement, true) and compareDeep(bodySiteElement, o.bodySiteElement, true) and 
      compareDeep(subSiteList, o.subSiteList, true) and compareDeep(noteNumberList, o.noteNumberList, true) and 
      compareDeep(adjudicationList, o.adjudicationList, true) and compareDeep(detailList, o.detailList, true);
  end;
end;

function TFhirExplanationOfBenefitAddItem.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FitemSequenceList) and isEmptyProp(FdetailSequenceList) and isEmptyProp(FsubDetailSequenceList) and isEmptyProp(FproviderList) and isEmptyProp(FProductOrService) and isEmptyProp(FmodifierList) and isEmptyProp(FprogramCodeList) and isEmptyProp(FServiced) and isEmptyProp(FLocation) and isEmptyProp(FQuantity) and isEmptyProp(FUnitPrice) and isEmptyProp(FFactor) and isEmptyProp(FNet) and isEmptyProp(FBodySite) and isEmptyProp(FsubSiteList) and isEmptyProp(FnoteNumberList) and isEmptyProp(FadjudicationList) and isEmptyProp(FdetailList);
end;

procedure TFhirExplanationOfBenefitAddItem.listFieldsInOrder(fields : TStringList);
begin
  inherited listFieldsInOrder(fields);
  fields.add('itemSequence');
  fields.add('detailSequence');
  fields.add('subDetailSequence');
  fields.add('provider');
  fields.add('productOrService');
  fields.add('modifier');
  fields.add('programCode');
  fields.add('serviced[x]');
  fields.add('location[x]');
  fields.add('quantity');
  fields.add('unitPrice');
  fields.add('factor');
  fields.add('net');
  fields.add('bodySite');
  fields.add('subSite');
  fields.add('noteNumber');
  fields.add('adjudication');
  fields.add('detail');
end;

function TFhirExplanationOfBenefitAddItem.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FItemSequenceList.sizeInBytes(magic));
  inc(result, FDetailSequenceList.sizeInBytes(magic));
  inc(result, FSubDetailSequenceList.sizeInBytes(magic));
  inc(result, FProviderList.sizeInBytes(magic));
  inc(result, FModifierList.sizeInBytes(magic));
  inc(result, FProgramCodeList.sizeInBytes(magic));
  inc(result, FSubSiteList.sizeInBytes(magic));
  inc(result, FNoteNumberList.sizeInBytes(magic));
  inc(result, FAdjudicationList.sizeInBytes(magic));
  inc(result, FDetailList.sizeInBytes(magic));
end;

function TFhirExplanationOfBenefitAddItem.GetItemSequenceList : TFhirPositiveIntList;
begin
  if FItemSequenceList = nil then
    FItemSequenceList := TFhirPositiveIntList.Create;
  result := FItemSequenceList;
end;

function TFhirExplanationOfBenefitAddItem.GetHasItemSequenceList : boolean;
begin
  result := (FItemSequenceList <> nil) and (FItemSequenceList.count > 0);
end;

function TFhirExplanationOfBenefitAddItem.GetDetailSequenceList : TFhirPositiveIntList;
begin
  if FDetailSequenceList = nil then
    FDetailSequenceList := TFhirPositiveIntList.Create;
  result := FDetailSequenceList;
end;

function TFhirExplanationOfBenefitAddItem.GetHasDetailSequenceList : boolean;
begin
  result := (FDetailSequenceList <> nil) and (FDetailSequenceList.count > 0);
end;

function TFhirExplanationOfBenefitAddItem.GetSubDetailSequenceList : TFhirPositiveIntList;
begin
  if FSubDetailSequenceList = nil then
    FSubDetailSequenceList := TFhirPositiveIntList.Create;
  result := FSubDetailSequenceList;
end;

function TFhirExplanationOfBenefitAddItem.GetHasSubDetailSequenceList : boolean;
begin
  result := (FSubDetailSequenceList <> nil) and (FSubDetailSequenceList.count > 0);
end;

function TFhirExplanationOfBenefitAddItem.GetProviderList : TFhirReferenceList;
begin
  if FProviderList = nil then
    FProviderList := TFhirReferenceList.Create;
  result := FProviderList;
end;

function TFhirExplanationOfBenefitAddItem.GetHasProviderList : boolean;
begin
  result := (FProviderList <> nil) and (FProviderList.count > 0);
end;

procedure TFhirExplanationOfBenefitAddItem.SetProductOrService(value : TFhirCodeableConcept);
begin
  FProductOrService.free;
  FProductOrService := value;
end;

function TFhirExplanationOfBenefitAddItem.GetModifierList : TFhirCodeableConceptList;
begin
  if FModifierList = nil then
    FModifierList := TFhirCodeableConceptList.Create;
  result := FModifierList;
end;

function TFhirExplanationOfBenefitAddItem.GetHasModifierList : boolean;
begin
  result := (FModifierList <> nil) and (FModifierList.count > 0);
end;

function TFhirExplanationOfBenefitAddItem.GetProgramCodeList : TFhirCodeableConceptList;
begin
  if FProgramCodeList = nil then
    FProgramCodeList := TFhirCodeableConceptList.Create;
  result := FProgramCodeList;
end;

function TFhirExplanationOfBenefitAddItem.GetHasProgramCodeList : boolean;
begin
  result := (FProgramCodeList <> nil) and (FProgramCodeList.count > 0);
end;

procedure TFhirExplanationOfBenefitAddItem.SetServiced(value : TFhirDataType);
begin
  FServiced.free;
  FServiced := value;
end;

procedure TFhirExplanationOfBenefitAddItem.SetLocation(value : TFhirDataType);
begin
  FLocation.free;
  FLocation := value;
end;

procedure TFhirExplanationOfBenefitAddItem.SetQuantity(value : TFhirQuantity);
begin
  FQuantity.free;
  FQuantity := value;
end;

procedure TFhirExplanationOfBenefitAddItem.SetUnitPrice(value : TFhirMoney);
begin
  FUnitPrice.free;
  FUnitPrice := value;
end;

procedure TFhirExplanationOfBenefitAddItem.SetFactor(value : TFhirDecimal);
begin
  FFactor.free;
  FFactor := value;
end;

function TFhirExplanationOfBenefitAddItem.GetFactorST : String;
begin
  if FFactor = nil then
    result := ''
  else
    result := FFactor.value;
end;

procedure TFhirExplanationOfBenefitAddItem.SetFactorST(value : String);
begin
  if value <> '' then
  begin
    if FFactor = nil then
      FFactor := TFhirDecimal.create;
    FFactor.value := value
  end
  else if FFactor <> nil then
    FFactor.value := '';
end;

procedure TFhirExplanationOfBenefitAddItem.SetNet(value : TFhirMoney);
begin
  FNet.free;
  FNet := value;
end;

procedure TFhirExplanationOfBenefitAddItem.SetBodySite(value : TFhirCodeableConcept);
begin
  FBodySite.free;
  FBodySite := value;
end;

function TFhirExplanationOfBenefitAddItem.GetSubSiteList : TFhirCodeableConceptList;
begin
  if FSubSiteList = nil then
    FSubSiteList := TFhirCodeableConceptList.Create;
  result := FSubSiteList;
end;

function TFhirExplanationOfBenefitAddItem.GetHasSubSiteList : boolean;
begin
  result := (FSubSiteList <> nil) and (FSubSiteList.count > 0);
end;

function TFhirExplanationOfBenefitAddItem.GetNoteNumberList : TFhirPositiveIntList;
begin
  if FNoteNumberList = nil then
    FNoteNumberList := TFhirPositiveIntList.Create;
  result := FNoteNumberList;
end;

function TFhirExplanationOfBenefitAddItem.GetHasNoteNumberList : boolean;
begin
  result := (FNoteNumberList <> nil) and (FNoteNumberList.count > 0);
end;

function TFhirExplanationOfBenefitAddItem.GetAdjudicationList : TFhirExplanationOfBenefitItemAdjudicationList;
begin
  if FAdjudicationList = nil then
    FAdjudicationList := TFhirExplanationOfBenefitItemAdjudicationList.Create;
  result := FAdjudicationList;
end;

function TFhirExplanationOfBenefitAddItem.GetHasAdjudicationList : boolean;
begin
  result := (FAdjudicationList <> nil) and (FAdjudicationList.count > 0);
end;

function TFhirExplanationOfBenefitAddItem.GetDetailList : TFhirExplanationOfBenefitAddItemDetailList;
begin
  if FDetailList = nil then
    FDetailList := TFhirExplanationOfBenefitAddItemDetailList.Create;
  result := FDetailList;
end;

function TFhirExplanationOfBenefitAddItem.GetHasDetailList : boolean;
begin
  result := (FDetailList <> nil) and (FDetailList.count > 0);
end;

{ TFhirExplanationOfBenefitAddItemListEnumerator }

constructor TFhirExplanationOfBenefitAddItemListEnumerator.Create(list : TFhirExplanationOfBenefitAddItemList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirExplanationOfBenefitAddItemListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirExplanationOfBenefitAddItemListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirExplanationOfBenefitAddItemListEnumerator.GetCurrent : TFhirExplanationOfBenefitAddItem;
begin
  Result := FList[FIndex];
end;

function TFhirExplanationOfBenefitAddItemListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirExplanationOfBenefitAddItemList }

procedure TFhirExplanationOfBenefitAddItemList.AddItem(value: TFhirExplanationOfBenefitAddItem);
begin
  assert(value.ClassName = 'TFhirExplanationOfBenefitAddItem', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirExplanationOfBenefitAddItem');
  add(value);
end;

function TFhirExplanationOfBenefitAddItemList.Append: TFhirExplanationOfBenefitAddItem;
begin
  result := TFhirExplanationOfBenefitAddItem.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirExplanationOfBenefitAddItemList.ClearItems;
begin
  Clear;
end;

function TFhirExplanationOfBenefitAddItemList.GetEnumerator : TFhirExplanationOfBenefitAddItemListEnumerator;
begin
  result := TFhirExplanationOfBenefitAddItemListEnumerator.Create(self.link);
end;

function TFhirExplanationOfBenefitAddItemList.Clone: TFhirExplanationOfBenefitAddItemList;
begin
  result := TFhirExplanationOfBenefitAddItemList(inherited Clone);
end;

function TFhirExplanationOfBenefitAddItemList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirExplanationOfBenefitAddItemList.GetItemN(index: Integer): TFhirExplanationOfBenefitAddItem;
begin
  result := TFhirExplanationOfBenefitAddItem(ObjectByIndex[index]);
end;

function TFhirExplanationOfBenefitAddItemList.ItemClass: TFslObjectClass;
begin
  result := TFhirExplanationOfBenefitAddItem;
end;
function TFhirExplanationOfBenefitAddItemList.IndexOf(value: TFhirExplanationOfBenefitAddItem): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirExplanationOfBenefitAddItemList.Insert(index: Integer): TFhirExplanationOfBenefitAddItem;
begin
  result := TFhirExplanationOfBenefitAddItem.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirExplanationOfBenefitAddItemList.InsertItem(index: Integer; value: TFhirExplanationOfBenefitAddItem);
begin
  assert(value is TFhirExplanationOfBenefitAddItem);
  Inherited Insert(index, value);
end;

function TFhirExplanationOfBenefitAddItemList.Item(index: Integer): TFhirExplanationOfBenefitAddItem;
begin
  result := TFhirExplanationOfBenefitAddItem(ObjectByIndex[index]);
end;

function TFhirExplanationOfBenefitAddItemList.Link: TFhirExplanationOfBenefitAddItemList;
begin
  result := TFhirExplanationOfBenefitAddItemList(inherited Link);
end;

procedure TFhirExplanationOfBenefitAddItemList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirExplanationOfBenefitAddItemList.SetItemByIndex(index: Integer; value: TFhirExplanationOfBenefitAddItem);
begin
  assert(value is TFhirExplanationOfBenefitAddItem);
  FhirExplanationOfBenefitAddItems[index] := value;
end;

procedure TFhirExplanationOfBenefitAddItemList.SetItemN(index: Integer; value: TFhirExplanationOfBenefitAddItem);
begin
  assert(value is TFhirExplanationOfBenefitAddItem);
  ObjectByIndex[index] := value;
end;

{ TFhirExplanationOfBenefitAddItemDetail }

constructor TFhirExplanationOfBenefitAddItemDetail.Create;
begin
  inherited;
end;

destructor TFhirExplanationOfBenefitAddItemDetail.Destroy;
begin
  FProductOrService.free;
  FModifierList.Free;
  FQuantity.free;
  FUnitPrice.free;
  FFactor.free;
  FNet.free;
  FNoteNumberList.Free;
  FAdjudicationList.Free;
  FSubDetailList.Free;
  inherited;
end;

procedure TFhirExplanationOfBenefitAddItemDetail.Assign(oSource : TFslObject);
begin
  inherited;
  productOrService := TFhirExplanationOfBenefitAddItemDetail(oSource).productOrService.Clone;
  if (TFhirExplanationOfBenefitAddItemDetail(oSource).FModifierList = nil) then
  begin
    FModifierList.free;
    FModifierList := nil;
  end
  else
  begin
    if FModifierList = nil then
      FModifierList := TFhirCodeableConceptList.Create;
    FModifierList.Assign(TFhirExplanationOfBenefitAddItemDetail(oSource).FModifierList);
  end;
  quantity := TFhirExplanationOfBenefitAddItemDetail(oSource).quantity.Clone;
  unitPrice := TFhirExplanationOfBenefitAddItemDetail(oSource).unitPrice.Clone;
  factorElement := TFhirExplanationOfBenefitAddItemDetail(oSource).factorElement.Clone;
  net := TFhirExplanationOfBenefitAddItemDetail(oSource).net.Clone;
  if (TFhirExplanationOfBenefitAddItemDetail(oSource).FNoteNumberList = nil) then
  begin
    FNoteNumberList.free;
    FNoteNumberList := nil;
  end
  else
  begin
    if FNoteNumberList = nil then
      FNoteNumberList := TFhirPositiveIntList.Create;
    FNoteNumberList.Assign(TFhirExplanationOfBenefitAddItemDetail(oSource).FNoteNumberList);
  end;
  if (TFhirExplanationOfBenefitAddItemDetail(oSource).FAdjudicationList = nil) then
  begin
    FAdjudicationList.free;
    FAdjudicationList := nil;
  end
  else
  begin
    if FAdjudicationList = nil then
      FAdjudicationList := TFhirExplanationOfBenefitItemAdjudicationList.Create;
    FAdjudicationList.Assign(TFhirExplanationOfBenefitAddItemDetail(oSource).FAdjudicationList);
  end;
  if (TFhirExplanationOfBenefitAddItemDetail(oSource).FSubDetailList = nil) then
  begin
    FSubDetailList.free;
    FSubDetailList := nil;
  end
  else
  begin
    if FSubDetailList = nil then
      FSubDetailList := TFhirExplanationOfBenefitAddItemDetailSubDetailList.Create;
    FSubDetailList.Assign(TFhirExplanationOfBenefitAddItemDetail(oSource).FSubDetailList);
  end;
end;

procedure TFhirExplanationOfBenefitAddItemDetail.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'productOrService') Then
     list.add(self.link, 'productOrService', FProductOrService.Link);
  if (child_name = 'modifier') Then
    list.addAll(self, 'modifier', FModifierList);
  if (child_name = 'quantity') Then
     list.add(self.link, 'quantity', FQuantity.Link);
  if (child_name = 'unitPrice') Then
     list.add(self.link, 'unitPrice', FUnitPrice.Link);
  if (child_name = 'factor') Then
     list.add(self.link, 'factor', FFactor.Link);
  if (child_name = 'net') Then
     list.add(self.link, 'net', FNet.Link);
  if (child_name = 'noteNumber') Then
    list.addAll(self, 'noteNumber', FNoteNumberList);
  if (child_name = 'adjudication') Then
    list.addAll(self, 'adjudication', FAdjudicationList);
  if (child_name = 'subDetail') Then
    list.addAll(self, 'subDetail', FSubDetailList);
end;

procedure TFhirExplanationOfBenefitAddItemDetail.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'productOrService', 'CodeableConcept', false, TFhirCodeableConcept, FProductOrService.Link));
  oList.add(TFHIRProperty.create(self, 'modifier', 'CodeableConcept', true, TFhirCodeableConcept, FModifierList.Link));
  oList.add(TFHIRProperty.create(self, 'quantity', 'Quantity', false, TFhirQuantity, FQuantity.Link));
  oList.add(TFHIRProperty.create(self, 'unitPrice', 'Money', false, TFhirMoney, FUnitPrice.Link));
  oList.add(TFHIRProperty.create(self, 'factor', 'decimal', false, TFhirDecimal, FFactor.Link));
  oList.add(TFHIRProperty.create(self, 'net', 'Money', false, TFhirMoney, FNet.Link));
  oList.add(TFHIRProperty.create(self, 'noteNumber', 'positiveInt', true, TFhirPositiveInt, FNoteNumberList.Link));
  oList.add(TFHIRProperty.create(self, 'adjudication', '', true, TFhirExplanationOfBenefitItemAdjudication, FAdjudicationList.Link));
  oList.add(TFHIRProperty.create(self, 'subDetail', 'BackboneElement', true, TFhirExplanationOfBenefitAddItemDetailSubDetail, FSubDetailList.Link));
end;

function TFhirExplanationOfBenefitAddItemDetail.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'productOrService') then
  begin
    ProductOrService := propValue as TFhirCodeableConcept;
    result := propValue;
  end
  else if (propName = 'modifier') then
  begin
    ModifierList.add(propValue as TFhirCodeableConcept);
    result := propValue;
  end
  else if (propName = 'quantity') then
  begin
    Quantity := propValue as TFhirQuantity;
    result := propValue;
  end
  else if (propName = 'unitPrice') then
  begin
    UnitPrice := propValue as TFhirMoney;
    result := propValue;
  end
  else if (propName = 'factor') then
  begin
    FactorElement := asDecimal(propValue);
    result := propValue;
  end
  else if (propName = 'net') then
  begin
    Net := propValue as TFhirMoney;
    result := propValue;
  end
  else if (propName = 'noteNumber') then
  begin
    NoteNumberList.add(asPositiveInt(propValue)){2};     result := propValue;

  end
  else if (propName = 'adjudication') then
  begin
    AdjudicationList.add(propValue as TFhirExplanationOfBenefitItemAdjudication);
    result := propValue;
  end
  else if (propName = 'subDetail') then
  begin
    SubDetailList.add(propValue as TFhirExplanationOfBenefitAddItemDetailSubDetail);
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirExplanationOfBenefitAddItemDetail.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'modifier') then ModifierList.insertItem(index, propValue as TFhirCodeableConcept)
  else if (propName = 'noteNumber') then NoteNumberList.insertItem(index, asPositiveInt(propValue))
  else if (propName = 'adjudication') then AdjudicationList.insertItem(index, propValue as TFhirExplanationOfBenefitItemAdjudication)
  else if (propName = 'subDetail') then SubDetailList.insertItem(index, propValue as TFhirExplanationOfBenefitAddItemDetailSubDetail)
  else inherited;
end;

function TFhirExplanationOfBenefitAddItemDetail.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'productOrService') then result := TFhirCodeableConcept.create()
  else if (propName = 'modifier') then result := ModifierList.new()
  else if (propName = 'quantity') then result := TFhirQuantity.create()
  else if (propName = 'unitPrice') then result := TFhirMoney.create()
  else if (propName = 'factor') then result := TFhirDecimal.create()
  else if (propName = 'net') then result := TFhirMoney.create()
  else if (propName = 'noteNumber') then result := NoteNumberList.new()
  else if (propName = 'adjudication') then result := AdjudicationList.new()
  else if (propName = 'subDetail') then result := SubDetailList.new()
  else result := inherited createPropertyValue(propName);
end;

function TFhirExplanationOfBenefitAddItemDetail.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'productOrService') then result := 'CodeableConcept'
  else if (propName = 'modifier') then result := 'CodeableConcept'
  else if (propName = 'quantity') then result := 'Quantity'
  else if (propName = 'unitPrice') then result := 'Money'
  else if (propName = 'factor') then result := 'decimal'
  else if (propName = 'net') then result := 'Money'
  else if (propName = 'noteNumber') then result := 'positiveInt'
  else if (propName = 'adjudication') then result := ''
  else if (propName = 'subDetail') then result := 'BackboneElement'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirExplanationOfBenefitAddItemDetail.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'productOrService') then ProductOrServiceElement := nil
  else if (propName = 'modifier') then deletePropertyValue('modifier', ModifierList, value)
  else if (propName = 'quantity') then QuantityElement := nil
  else if (propName = 'unitPrice') then UnitPriceElement := nil
  else if (propName = 'factor') then FactorElement := nil
  else if (propName = 'net') then NetElement := nil
  else if (propName = 'noteNumber') then deletePropertyValue('noteNumber', NoteNumberList, value)
  else if (propName = 'adjudication') then deletePropertyValue('adjudication', AdjudicationList, value)
  else if (propName = 'subDetail') then deletePropertyValue('subDetail', SubDetailList, value)
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirExplanationOfBenefitAddItemDetail.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'productOrService') then ProductOrServiceElement := new as TFhirCodeableConcept
  else if (propName = 'modifier') then replacePropertyValue('modifier', ModifierList, existing, new)
  else if (propName = 'quantity') then QuantityElement := new as TFhirQuantity
  else if (propName = 'unitPrice') then UnitPriceElement := new as TFhirMoney
  else if (propName = 'factor') then FactorElement := asDecimal(new)
  else if (propName = 'net') then NetElement := new as TFhirMoney
  else if (propName = 'noteNumber') then replacePropertyValue('noteNumber', NoteNumberList, existing, new)
  else if (propName = 'adjudication') then replacePropertyValue('adjudication', AdjudicationList, existing, new)
  else if (propName = 'subDetail') then replacePropertyValue('subDetail', SubDetailList, existing, new)
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirExplanationOfBenefitAddItemDetail.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'modifier') then ModifierList.move(source, destination)
  else if (propName = 'noteNumber') then NoteNumberList.move(source, destination)
  else if (propName = 'adjudication') then AdjudicationList.move(source, destination)
  else if (propName = 'subDetail') then SubDetailList.move(source, destination)
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirExplanationOfBenefitAddItemDetail.fhirType : string;
begin
  result := 'ExplanationOfBenefit.addItem.detail';
end;

function TFhirExplanationOfBenefitAddItemDetail.Link : TFhirExplanationOfBenefitAddItemDetail;
begin
  result := TFhirExplanationOfBenefitAddItemDetail(inherited Link);
end;

function TFhirExplanationOfBenefitAddItemDetail.Clone : TFhirExplanationOfBenefitAddItemDetail;
begin
  result := TFhirExplanationOfBenefitAddItemDetail(inherited Clone);
end;

function TFhirExplanationOfBenefitAddItemDetail.equals(other : TObject) : boolean; 
var
  o : TFhirExplanationOfBenefitAddItemDetail;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirExplanationOfBenefitAddItemDetail)) then
    result := false
  else
  begin
    o := TFhirExplanationOfBenefitAddItemDetail(other);
    result := compareDeep(productOrServiceElement, o.productOrServiceElement, true) and 
      compareDeep(modifierList, o.modifierList, true) and compareDeep(quantityElement, o.quantityElement, true) and 
      compareDeep(unitPriceElement, o.unitPriceElement, true) and compareDeep(factorElement, o.factorElement, true) and 
      compareDeep(netElement, o.netElement, true) and compareDeep(noteNumberList, o.noteNumberList, true) and 
      compareDeep(adjudicationList, o.adjudicationList, true) and compareDeep(subDetailList, o.subDetailList, true);
  end;
end;

function TFhirExplanationOfBenefitAddItemDetail.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FProductOrService) and isEmptyProp(FmodifierList) and isEmptyProp(FQuantity) and isEmptyProp(FUnitPrice) and isEmptyProp(FFactor) and isEmptyProp(FNet) and isEmptyProp(FnoteNumberList) and isEmptyProp(FadjudicationList) and isEmptyProp(FsubDetailList);
end;

procedure TFhirExplanationOfBenefitAddItemDetail.listFieldsInOrder(fields : TStringList);
begin
  inherited listFieldsInOrder(fields);
  fields.add('productOrService');
  fields.add('modifier');
  fields.add('quantity');
  fields.add('unitPrice');
  fields.add('factor');
  fields.add('net');
  fields.add('noteNumber');
  fields.add('adjudication');
  fields.add('subDetail');
end;

function TFhirExplanationOfBenefitAddItemDetail.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FModifierList.sizeInBytes(magic));
  inc(result, FNoteNumberList.sizeInBytes(magic));
  inc(result, FAdjudicationList.sizeInBytes(magic));
  inc(result, FSubDetailList.sizeInBytes(magic));
end;

procedure TFhirExplanationOfBenefitAddItemDetail.SetProductOrService(value : TFhirCodeableConcept);
begin
  FProductOrService.free;
  FProductOrService := value;
end;

function TFhirExplanationOfBenefitAddItemDetail.GetModifierList : TFhirCodeableConceptList;
begin
  if FModifierList = nil then
    FModifierList := TFhirCodeableConceptList.Create;
  result := FModifierList;
end;

function TFhirExplanationOfBenefitAddItemDetail.GetHasModifierList : boolean;
begin
  result := (FModifierList <> nil) and (FModifierList.count > 0);
end;

procedure TFhirExplanationOfBenefitAddItemDetail.SetQuantity(value : TFhirQuantity);
begin
  FQuantity.free;
  FQuantity := value;
end;

procedure TFhirExplanationOfBenefitAddItemDetail.SetUnitPrice(value : TFhirMoney);
begin
  FUnitPrice.free;
  FUnitPrice := value;
end;

procedure TFhirExplanationOfBenefitAddItemDetail.SetFactor(value : TFhirDecimal);
begin
  FFactor.free;
  FFactor := value;
end;

function TFhirExplanationOfBenefitAddItemDetail.GetFactorST : String;
begin
  if FFactor = nil then
    result := ''
  else
    result := FFactor.value;
end;

procedure TFhirExplanationOfBenefitAddItemDetail.SetFactorST(value : String);
begin
  if value <> '' then
  begin
    if FFactor = nil then
      FFactor := TFhirDecimal.create;
    FFactor.value := value
  end
  else if FFactor <> nil then
    FFactor.value := '';
end;

procedure TFhirExplanationOfBenefitAddItemDetail.SetNet(value : TFhirMoney);
begin
  FNet.free;
  FNet := value;
end;

function TFhirExplanationOfBenefitAddItemDetail.GetNoteNumberList : TFhirPositiveIntList;
begin
  if FNoteNumberList = nil then
    FNoteNumberList := TFhirPositiveIntList.Create;
  result := FNoteNumberList;
end;

function TFhirExplanationOfBenefitAddItemDetail.GetHasNoteNumberList : boolean;
begin
  result := (FNoteNumberList <> nil) and (FNoteNumberList.count > 0);
end;

function TFhirExplanationOfBenefitAddItemDetail.GetAdjudicationList : TFhirExplanationOfBenefitItemAdjudicationList;
begin
  if FAdjudicationList = nil then
    FAdjudicationList := TFhirExplanationOfBenefitItemAdjudicationList.Create;
  result := FAdjudicationList;
end;

function TFhirExplanationOfBenefitAddItemDetail.GetHasAdjudicationList : boolean;
begin
  result := (FAdjudicationList <> nil) and (FAdjudicationList.count > 0);
end;

function TFhirExplanationOfBenefitAddItemDetail.GetSubDetailList : TFhirExplanationOfBenefitAddItemDetailSubDetailList;
begin
  if FSubDetailList = nil then
    FSubDetailList := TFhirExplanationOfBenefitAddItemDetailSubDetailList.Create;
  result := FSubDetailList;
end;

function TFhirExplanationOfBenefitAddItemDetail.GetHasSubDetailList : boolean;
begin
  result := (FSubDetailList <> nil) and (FSubDetailList.count > 0);
end;

{ TFhirExplanationOfBenefitAddItemDetailListEnumerator }

constructor TFhirExplanationOfBenefitAddItemDetailListEnumerator.Create(list : TFhirExplanationOfBenefitAddItemDetailList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirExplanationOfBenefitAddItemDetailListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirExplanationOfBenefitAddItemDetailListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirExplanationOfBenefitAddItemDetailListEnumerator.GetCurrent : TFhirExplanationOfBenefitAddItemDetail;
begin
  Result := FList[FIndex];
end;

function TFhirExplanationOfBenefitAddItemDetailListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirExplanationOfBenefitAddItemDetailList }

procedure TFhirExplanationOfBenefitAddItemDetailList.AddItem(value: TFhirExplanationOfBenefitAddItemDetail);
begin
  assert(value.ClassName = 'TFhirExplanationOfBenefitAddItemDetail', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirExplanationOfBenefitAddItemDetail');
  add(value);
end;

function TFhirExplanationOfBenefitAddItemDetailList.Append: TFhirExplanationOfBenefitAddItemDetail;
begin
  result := TFhirExplanationOfBenefitAddItemDetail.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirExplanationOfBenefitAddItemDetailList.ClearItems;
begin
  Clear;
end;

function TFhirExplanationOfBenefitAddItemDetailList.GetEnumerator : TFhirExplanationOfBenefitAddItemDetailListEnumerator;
begin
  result := TFhirExplanationOfBenefitAddItemDetailListEnumerator.Create(self.link);
end;

function TFhirExplanationOfBenefitAddItemDetailList.Clone: TFhirExplanationOfBenefitAddItemDetailList;
begin
  result := TFhirExplanationOfBenefitAddItemDetailList(inherited Clone);
end;

function TFhirExplanationOfBenefitAddItemDetailList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirExplanationOfBenefitAddItemDetailList.GetItemN(index: Integer): TFhirExplanationOfBenefitAddItemDetail;
begin
  result := TFhirExplanationOfBenefitAddItemDetail(ObjectByIndex[index]);
end;

function TFhirExplanationOfBenefitAddItemDetailList.ItemClass: TFslObjectClass;
begin
  result := TFhirExplanationOfBenefitAddItemDetail;
end;
function TFhirExplanationOfBenefitAddItemDetailList.IndexOf(value: TFhirExplanationOfBenefitAddItemDetail): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirExplanationOfBenefitAddItemDetailList.Insert(index: Integer): TFhirExplanationOfBenefitAddItemDetail;
begin
  result := TFhirExplanationOfBenefitAddItemDetail.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirExplanationOfBenefitAddItemDetailList.InsertItem(index: Integer; value: TFhirExplanationOfBenefitAddItemDetail);
begin
  assert(value is TFhirExplanationOfBenefitAddItemDetail);
  Inherited Insert(index, value);
end;

function TFhirExplanationOfBenefitAddItemDetailList.Item(index: Integer): TFhirExplanationOfBenefitAddItemDetail;
begin
  result := TFhirExplanationOfBenefitAddItemDetail(ObjectByIndex[index]);
end;

function TFhirExplanationOfBenefitAddItemDetailList.Link: TFhirExplanationOfBenefitAddItemDetailList;
begin
  result := TFhirExplanationOfBenefitAddItemDetailList(inherited Link);
end;

procedure TFhirExplanationOfBenefitAddItemDetailList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirExplanationOfBenefitAddItemDetailList.SetItemByIndex(index: Integer; value: TFhirExplanationOfBenefitAddItemDetail);
begin
  assert(value is TFhirExplanationOfBenefitAddItemDetail);
  FhirExplanationOfBenefitAddItemDetails[index] := value;
end;

procedure TFhirExplanationOfBenefitAddItemDetailList.SetItemN(index: Integer; value: TFhirExplanationOfBenefitAddItemDetail);
begin
  assert(value is TFhirExplanationOfBenefitAddItemDetail);
  ObjectByIndex[index] := value;
end;

{ TFhirExplanationOfBenefitAddItemDetailSubDetail }

constructor TFhirExplanationOfBenefitAddItemDetailSubDetail.Create;
begin
  inherited;
end;

destructor TFhirExplanationOfBenefitAddItemDetailSubDetail.Destroy;
begin
  FProductOrService.free;
  FModifierList.Free;
  FQuantity.free;
  FUnitPrice.free;
  FFactor.free;
  FNet.free;
  FNoteNumberList.Free;
  FAdjudicationList.Free;
  inherited;
end;

procedure TFhirExplanationOfBenefitAddItemDetailSubDetail.Assign(oSource : TFslObject);
begin
  inherited;
  productOrService := TFhirExplanationOfBenefitAddItemDetailSubDetail(oSource).productOrService.Clone;
  if (TFhirExplanationOfBenefitAddItemDetailSubDetail(oSource).FModifierList = nil) then
  begin
    FModifierList.free;
    FModifierList := nil;
  end
  else
  begin
    if FModifierList = nil then
      FModifierList := TFhirCodeableConceptList.Create;
    FModifierList.Assign(TFhirExplanationOfBenefitAddItemDetailSubDetail(oSource).FModifierList);
  end;
  quantity := TFhirExplanationOfBenefitAddItemDetailSubDetail(oSource).quantity.Clone;
  unitPrice := TFhirExplanationOfBenefitAddItemDetailSubDetail(oSource).unitPrice.Clone;
  factorElement := TFhirExplanationOfBenefitAddItemDetailSubDetail(oSource).factorElement.Clone;
  net := TFhirExplanationOfBenefitAddItemDetailSubDetail(oSource).net.Clone;
  if (TFhirExplanationOfBenefitAddItemDetailSubDetail(oSource).FNoteNumberList = nil) then
  begin
    FNoteNumberList.free;
    FNoteNumberList := nil;
  end
  else
  begin
    if FNoteNumberList = nil then
      FNoteNumberList := TFhirPositiveIntList.Create;
    FNoteNumberList.Assign(TFhirExplanationOfBenefitAddItemDetailSubDetail(oSource).FNoteNumberList);
  end;
  if (TFhirExplanationOfBenefitAddItemDetailSubDetail(oSource).FAdjudicationList = nil) then
  begin
    FAdjudicationList.free;
    FAdjudicationList := nil;
  end
  else
  begin
    if FAdjudicationList = nil then
      FAdjudicationList := TFhirExplanationOfBenefitItemAdjudicationList.Create;
    FAdjudicationList.Assign(TFhirExplanationOfBenefitAddItemDetailSubDetail(oSource).FAdjudicationList);
  end;
end;

procedure TFhirExplanationOfBenefitAddItemDetailSubDetail.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'productOrService') Then
     list.add(self.link, 'productOrService', FProductOrService.Link);
  if (child_name = 'modifier') Then
    list.addAll(self, 'modifier', FModifierList);
  if (child_name = 'quantity') Then
     list.add(self.link, 'quantity', FQuantity.Link);
  if (child_name = 'unitPrice') Then
     list.add(self.link, 'unitPrice', FUnitPrice.Link);
  if (child_name = 'factor') Then
     list.add(self.link, 'factor', FFactor.Link);
  if (child_name = 'net') Then
     list.add(self.link, 'net', FNet.Link);
  if (child_name = 'noteNumber') Then
    list.addAll(self, 'noteNumber', FNoteNumberList);
  if (child_name = 'adjudication') Then
    list.addAll(self, 'adjudication', FAdjudicationList);
end;

procedure TFhirExplanationOfBenefitAddItemDetailSubDetail.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'productOrService', 'CodeableConcept', false, TFhirCodeableConcept, FProductOrService.Link));
  oList.add(TFHIRProperty.create(self, 'modifier', 'CodeableConcept', true, TFhirCodeableConcept, FModifierList.Link));
  oList.add(TFHIRProperty.create(self, 'quantity', 'Quantity', false, TFhirQuantity, FQuantity.Link));
  oList.add(TFHIRProperty.create(self, 'unitPrice', 'Money', false, TFhirMoney, FUnitPrice.Link));
  oList.add(TFHIRProperty.create(self, 'factor', 'decimal', false, TFhirDecimal, FFactor.Link));
  oList.add(TFHIRProperty.create(self, 'net', 'Money', false, TFhirMoney, FNet.Link));
  oList.add(TFHIRProperty.create(self, 'noteNumber', 'positiveInt', true, TFhirPositiveInt, FNoteNumberList.Link));
  oList.add(TFHIRProperty.create(self, 'adjudication', '', true, TFhirExplanationOfBenefitItemAdjudication, FAdjudicationList.Link));
end;

function TFhirExplanationOfBenefitAddItemDetailSubDetail.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'productOrService') then
  begin
    ProductOrService := propValue as TFhirCodeableConcept;
    result := propValue;
  end
  else if (propName = 'modifier') then
  begin
    ModifierList.add(propValue as TFhirCodeableConcept);
    result := propValue;
  end
  else if (propName = 'quantity') then
  begin
    Quantity := propValue as TFhirQuantity;
    result := propValue;
  end
  else if (propName = 'unitPrice') then
  begin
    UnitPrice := propValue as TFhirMoney;
    result := propValue;
  end
  else if (propName = 'factor') then
  begin
    FactorElement := asDecimal(propValue);
    result := propValue;
  end
  else if (propName = 'net') then
  begin
    Net := propValue as TFhirMoney;
    result := propValue;
  end
  else if (propName = 'noteNumber') then
  begin
    NoteNumberList.add(asPositiveInt(propValue)){2};     result := propValue;

  end
  else if (propName = 'adjudication') then
  begin
    AdjudicationList.add(propValue as TFhirExplanationOfBenefitItemAdjudication);
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirExplanationOfBenefitAddItemDetailSubDetail.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'modifier') then ModifierList.insertItem(index, propValue as TFhirCodeableConcept)
  else if (propName = 'noteNumber') then NoteNumberList.insertItem(index, asPositiveInt(propValue))
  else if (propName = 'adjudication') then AdjudicationList.insertItem(index, propValue as TFhirExplanationOfBenefitItemAdjudication)
  else inherited;
end;

function TFhirExplanationOfBenefitAddItemDetailSubDetail.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'productOrService') then result := TFhirCodeableConcept.create()
  else if (propName = 'modifier') then result := ModifierList.new()
  else if (propName = 'quantity') then result := TFhirQuantity.create()
  else if (propName = 'unitPrice') then result := TFhirMoney.create()
  else if (propName = 'factor') then result := TFhirDecimal.create()
  else if (propName = 'net') then result := TFhirMoney.create()
  else if (propName = 'noteNumber') then result := NoteNumberList.new()
  else if (propName = 'adjudication') then result := AdjudicationList.new()
  else result := inherited createPropertyValue(propName);
end;

function TFhirExplanationOfBenefitAddItemDetailSubDetail.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'productOrService') then result := 'CodeableConcept'
  else if (propName = 'modifier') then result := 'CodeableConcept'
  else if (propName = 'quantity') then result := 'Quantity'
  else if (propName = 'unitPrice') then result := 'Money'
  else if (propName = 'factor') then result := 'decimal'
  else if (propName = 'net') then result := 'Money'
  else if (propName = 'noteNumber') then result := 'positiveInt'
  else if (propName = 'adjudication') then result := ''
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirExplanationOfBenefitAddItemDetailSubDetail.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'productOrService') then ProductOrServiceElement := nil
  else if (propName = 'modifier') then deletePropertyValue('modifier', ModifierList, value)
  else if (propName = 'quantity') then QuantityElement := nil
  else if (propName = 'unitPrice') then UnitPriceElement := nil
  else if (propName = 'factor') then FactorElement := nil
  else if (propName = 'net') then NetElement := nil
  else if (propName = 'noteNumber') then deletePropertyValue('noteNumber', NoteNumberList, value)
  else if (propName = 'adjudication') then deletePropertyValue('adjudication', AdjudicationList, value)
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirExplanationOfBenefitAddItemDetailSubDetail.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'productOrService') then ProductOrServiceElement := new as TFhirCodeableConcept
  else if (propName = 'modifier') then replacePropertyValue('modifier', ModifierList, existing, new)
  else if (propName = 'quantity') then QuantityElement := new as TFhirQuantity
  else if (propName = 'unitPrice') then UnitPriceElement := new as TFhirMoney
  else if (propName = 'factor') then FactorElement := asDecimal(new)
  else if (propName = 'net') then NetElement := new as TFhirMoney
  else if (propName = 'noteNumber') then replacePropertyValue('noteNumber', NoteNumberList, existing, new)
  else if (propName = 'adjudication') then replacePropertyValue('adjudication', AdjudicationList, existing, new)
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirExplanationOfBenefitAddItemDetailSubDetail.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'modifier') then ModifierList.move(source, destination)
  else if (propName = 'noteNumber') then NoteNumberList.move(source, destination)
  else if (propName = 'adjudication') then AdjudicationList.move(source, destination)
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirExplanationOfBenefitAddItemDetailSubDetail.fhirType : string;
begin
  result := 'ExplanationOfBenefit.addItem.detail.subDetail';
end;

function TFhirExplanationOfBenefitAddItemDetailSubDetail.Link : TFhirExplanationOfBenefitAddItemDetailSubDetail;
begin
  result := TFhirExplanationOfBenefitAddItemDetailSubDetail(inherited Link);
end;

function TFhirExplanationOfBenefitAddItemDetailSubDetail.Clone : TFhirExplanationOfBenefitAddItemDetailSubDetail;
begin
  result := TFhirExplanationOfBenefitAddItemDetailSubDetail(inherited Clone);
end;

function TFhirExplanationOfBenefitAddItemDetailSubDetail.equals(other : TObject) : boolean; 
var
  o : TFhirExplanationOfBenefitAddItemDetailSubDetail;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirExplanationOfBenefitAddItemDetailSubDetail)) then
    result := false
  else
  begin
    o := TFhirExplanationOfBenefitAddItemDetailSubDetail(other);
    result := compareDeep(productOrServiceElement, o.productOrServiceElement, true) and 
      compareDeep(modifierList, o.modifierList, true) and compareDeep(quantityElement, o.quantityElement, true) and 
      compareDeep(unitPriceElement, o.unitPriceElement, true) and compareDeep(factorElement, o.factorElement, true) and 
      compareDeep(netElement, o.netElement, true) and compareDeep(noteNumberList, o.noteNumberList, true) and 
      compareDeep(adjudicationList, o.adjudicationList, true);
  end;
end;

function TFhirExplanationOfBenefitAddItemDetailSubDetail.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FProductOrService) and isEmptyProp(FmodifierList) and isEmptyProp(FQuantity) and isEmptyProp(FUnitPrice) and isEmptyProp(FFactor) and isEmptyProp(FNet) and isEmptyProp(FnoteNumberList) and isEmptyProp(FadjudicationList);
end;

procedure TFhirExplanationOfBenefitAddItemDetailSubDetail.listFieldsInOrder(fields : TStringList);
begin
  inherited listFieldsInOrder(fields);
  fields.add('productOrService');
  fields.add('modifier');
  fields.add('quantity');
  fields.add('unitPrice');
  fields.add('factor');
  fields.add('net');
  fields.add('noteNumber');
  fields.add('adjudication');
end;

function TFhirExplanationOfBenefitAddItemDetailSubDetail.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FModifierList.sizeInBytes(magic));
  inc(result, FNoteNumberList.sizeInBytes(magic));
  inc(result, FAdjudicationList.sizeInBytes(magic));
end;

procedure TFhirExplanationOfBenefitAddItemDetailSubDetail.SetProductOrService(value : TFhirCodeableConcept);
begin
  FProductOrService.free;
  FProductOrService := value;
end;

function TFhirExplanationOfBenefitAddItemDetailSubDetail.GetModifierList : TFhirCodeableConceptList;
begin
  if FModifierList = nil then
    FModifierList := TFhirCodeableConceptList.Create;
  result := FModifierList;
end;

function TFhirExplanationOfBenefitAddItemDetailSubDetail.GetHasModifierList : boolean;
begin
  result := (FModifierList <> nil) and (FModifierList.count > 0);
end;

procedure TFhirExplanationOfBenefitAddItemDetailSubDetail.SetQuantity(value : TFhirQuantity);
begin
  FQuantity.free;
  FQuantity := value;
end;

procedure TFhirExplanationOfBenefitAddItemDetailSubDetail.SetUnitPrice(value : TFhirMoney);
begin
  FUnitPrice.free;
  FUnitPrice := value;
end;

procedure TFhirExplanationOfBenefitAddItemDetailSubDetail.SetFactor(value : TFhirDecimal);
begin
  FFactor.free;
  FFactor := value;
end;

function TFhirExplanationOfBenefitAddItemDetailSubDetail.GetFactorST : String;
begin
  if FFactor = nil then
    result := ''
  else
    result := FFactor.value;
end;

procedure TFhirExplanationOfBenefitAddItemDetailSubDetail.SetFactorST(value : String);
begin
  if value <> '' then
  begin
    if FFactor = nil then
      FFactor := TFhirDecimal.create;
    FFactor.value := value
  end
  else if FFactor <> nil then
    FFactor.value := '';
end;

procedure TFhirExplanationOfBenefitAddItemDetailSubDetail.SetNet(value : TFhirMoney);
begin
  FNet.free;
  FNet := value;
end;

function TFhirExplanationOfBenefitAddItemDetailSubDetail.GetNoteNumberList : TFhirPositiveIntList;
begin
  if FNoteNumberList = nil then
    FNoteNumberList := TFhirPositiveIntList.Create;
  result := FNoteNumberList;
end;

function TFhirExplanationOfBenefitAddItemDetailSubDetail.GetHasNoteNumberList : boolean;
begin
  result := (FNoteNumberList <> nil) and (FNoteNumberList.count > 0);
end;

function TFhirExplanationOfBenefitAddItemDetailSubDetail.GetAdjudicationList : TFhirExplanationOfBenefitItemAdjudicationList;
begin
  if FAdjudicationList = nil then
    FAdjudicationList := TFhirExplanationOfBenefitItemAdjudicationList.Create;
  result := FAdjudicationList;
end;

function TFhirExplanationOfBenefitAddItemDetailSubDetail.GetHasAdjudicationList : boolean;
begin
  result := (FAdjudicationList <> nil) and (FAdjudicationList.count > 0);
end;

{ TFhirExplanationOfBenefitAddItemDetailSubDetailListEnumerator }

constructor TFhirExplanationOfBenefitAddItemDetailSubDetailListEnumerator.Create(list : TFhirExplanationOfBenefitAddItemDetailSubDetailList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirExplanationOfBenefitAddItemDetailSubDetailListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirExplanationOfBenefitAddItemDetailSubDetailListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirExplanationOfBenefitAddItemDetailSubDetailListEnumerator.GetCurrent : TFhirExplanationOfBenefitAddItemDetailSubDetail;
begin
  Result := FList[FIndex];
end;

function TFhirExplanationOfBenefitAddItemDetailSubDetailListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirExplanationOfBenefitAddItemDetailSubDetailList }

procedure TFhirExplanationOfBenefitAddItemDetailSubDetailList.AddItem(value: TFhirExplanationOfBenefitAddItemDetailSubDetail);
begin
  assert(value.ClassName = 'TFhirExplanationOfBenefitAddItemDetailSubDetail', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirExplanationOfBenefitAddItemDetailSubDetail');
  add(value);
end;

function TFhirExplanationOfBenefitAddItemDetailSubDetailList.Append: TFhirExplanationOfBenefitAddItemDetailSubDetail;
begin
  result := TFhirExplanationOfBenefitAddItemDetailSubDetail.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirExplanationOfBenefitAddItemDetailSubDetailList.ClearItems;
begin
  Clear;
end;

function TFhirExplanationOfBenefitAddItemDetailSubDetailList.GetEnumerator : TFhirExplanationOfBenefitAddItemDetailSubDetailListEnumerator;
begin
  result := TFhirExplanationOfBenefitAddItemDetailSubDetailListEnumerator.Create(self.link);
end;

function TFhirExplanationOfBenefitAddItemDetailSubDetailList.Clone: TFhirExplanationOfBenefitAddItemDetailSubDetailList;
begin
  result := TFhirExplanationOfBenefitAddItemDetailSubDetailList(inherited Clone);
end;

function TFhirExplanationOfBenefitAddItemDetailSubDetailList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirExplanationOfBenefitAddItemDetailSubDetailList.GetItemN(index: Integer): TFhirExplanationOfBenefitAddItemDetailSubDetail;
begin
  result := TFhirExplanationOfBenefitAddItemDetailSubDetail(ObjectByIndex[index]);
end;

function TFhirExplanationOfBenefitAddItemDetailSubDetailList.ItemClass: TFslObjectClass;
begin
  result := TFhirExplanationOfBenefitAddItemDetailSubDetail;
end;
function TFhirExplanationOfBenefitAddItemDetailSubDetailList.IndexOf(value: TFhirExplanationOfBenefitAddItemDetailSubDetail): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirExplanationOfBenefitAddItemDetailSubDetailList.Insert(index: Integer): TFhirExplanationOfBenefitAddItemDetailSubDetail;
begin
  result := TFhirExplanationOfBenefitAddItemDetailSubDetail.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirExplanationOfBenefitAddItemDetailSubDetailList.InsertItem(index: Integer; value: TFhirExplanationOfBenefitAddItemDetailSubDetail);
begin
  assert(value is TFhirExplanationOfBenefitAddItemDetailSubDetail);
  Inherited Insert(index, value);
end;

function TFhirExplanationOfBenefitAddItemDetailSubDetailList.Item(index: Integer): TFhirExplanationOfBenefitAddItemDetailSubDetail;
begin
  result := TFhirExplanationOfBenefitAddItemDetailSubDetail(ObjectByIndex[index]);
end;

function TFhirExplanationOfBenefitAddItemDetailSubDetailList.Link: TFhirExplanationOfBenefitAddItemDetailSubDetailList;
begin
  result := TFhirExplanationOfBenefitAddItemDetailSubDetailList(inherited Link);
end;

procedure TFhirExplanationOfBenefitAddItemDetailSubDetailList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirExplanationOfBenefitAddItemDetailSubDetailList.SetItemByIndex(index: Integer; value: TFhirExplanationOfBenefitAddItemDetailSubDetail);
begin
  assert(value is TFhirExplanationOfBenefitAddItemDetailSubDetail);
  FhirExplanationOfBenefitAddItemDetailSubDetails[index] := value;
end;

procedure TFhirExplanationOfBenefitAddItemDetailSubDetailList.SetItemN(index: Integer; value: TFhirExplanationOfBenefitAddItemDetailSubDetail);
begin
  assert(value is TFhirExplanationOfBenefitAddItemDetailSubDetail);
  ObjectByIndex[index] := value;
end;

{ TFhirExplanationOfBenefitTotal }

constructor TFhirExplanationOfBenefitTotal.Create;
begin
  inherited;
end;

destructor TFhirExplanationOfBenefitTotal.Destroy;
begin
  FCategory.free;
  FAmount.free;
  inherited;
end;

procedure TFhirExplanationOfBenefitTotal.Assign(oSource : TFslObject);
begin
  inherited;
  category := TFhirExplanationOfBenefitTotal(oSource).category.Clone;
  amount := TFhirExplanationOfBenefitTotal(oSource).amount.Clone;
end;

procedure TFhirExplanationOfBenefitTotal.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'category') Then
     list.add(self.link, 'category', FCategory.Link);
  if (child_name = 'amount') Then
     list.add(self.link, 'amount', FAmount.Link);
end;

procedure TFhirExplanationOfBenefitTotal.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'category', 'CodeableConcept', false, TFhirCodeableConcept, FCategory.Link));
  oList.add(TFHIRProperty.create(self, 'amount', 'Money', false, TFhirMoney, FAmount.Link));
end;

function TFhirExplanationOfBenefitTotal.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'category') then
  begin
    Category := propValue as TFhirCodeableConcept;
    result := propValue;
  end
  else if (propName = 'amount') then
  begin
    Amount := propValue as TFhirMoney;
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirExplanationOfBenefitTotal.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirExplanationOfBenefitTotal.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'category') then result := TFhirCodeableConcept.create()
  else if (propName = 'amount') then result := TFhirMoney.create()
  else result := inherited createPropertyValue(propName);
end;

function TFhirExplanationOfBenefitTotal.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'category') then result := 'CodeableConcept'
  else if (propName = 'amount') then result := 'Money'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirExplanationOfBenefitTotal.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'category') then CategoryElement := nil
  else if (propName = 'amount') then AmountElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirExplanationOfBenefitTotal.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'category') then CategoryElement := new as TFhirCodeableConcept
  else if (propName = 'amount') then AmountElement := new as TFhirMoney
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirExplanationOfBenefitTotal.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirExplanationOfBenefitTotal.fhirType : string;
begin
  result := 'ExplanationOfBenefit.total';
end;

function TFhirExplanationOfBenefitTotal.Link : TFhirExplanationOfBenefitTotal;
begin
  result := TFhirExplanationOfBenefitTotal(inherited Link);
end;

function TFhirExplanationOfBenefitTotal.Clone : TFhirExplanationOfBenefitTotal;
begin
  result := TFhirExplanationOfBenefitTotal(inherited Clone);
end;

function TFhirExplanationOfBenefitTotal.equals(other : TObject) : boolean; 
var
  o : TFhirExplanationOfBenefitTotal;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirExplanationOfBenefitTotal)) then
    result := false
  else
  begin
    o := TFhirExplanationOfBenefitTotal(other);
    result := compareDeep(categoryElement, o.categoryElement, true) and compareDeep(amountElement, o.amountElement, true);
  end;
end;

function TFhirExplanationOfBenefitTotal.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FCategory) and isEmptyProp(FAmount);
end;

procedure TFhirExplanationOfBenefitTotal.listFieldsInOrder(fields : TStringList);
begin
  inherited listFieldsInOrder(fields);
  fields.add('category');
  fields.add('amount');
end;

function TFhirExplanationOfBenefitTotal.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
end;

procedure TFhirExplanationOfBenefitTotal.SetCategory(value : TFhirCodeableConcept);
begin
  FCategory.free;
  FCategory := value;
end;

procedure TFhirExplanationOfBenefitTotal.SetAmount(value : TFhirMoney);
begin
  FAmount.free;
  FAmount := value;
end;

{ TFhirExplanationOfBenefitTotalListEnumerator }

constructor TFhirExplanationOfBenefitTotalListEnumerator.Create(list : TFhirExplanationOfBenefitTotalList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirExplanationOfBenefitTotalListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirExplanationOfBenefitTotalListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirExplanationOfBenefitTotalListEnumerator.GetCurrent : TFhirExplanationOfBenefitTotal;
begin
  Result := FList[FIndex];
end;

function TFhirExplanationOfBenefitTotalListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirExplanationOfBenefitTotalList }

procedure TFhirExplanationOfBenefitTotalList.AddItem(value: TFhirExplanationOfBenefitTotal);
begin
  assert(value.ClassName = 'TFhirExplanationOfBenefitTotal', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirExplanationOfBenefitTotal');
  add(value);
end;

function TFhirExplanationOfBenefitTotalList.Append: TFhirExplanationOfBenefitTotal;
begin
  result := TFhirExplanationOfBenefitTotal.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirExplanationOfBenefitTotalList.ClearItems;
begin
  Clear;
end;

function TFhirExplanationOfBenefitTotalList.GetEnumerator : TFhirExplanationOfBenefitTotalListEnumerator;
begin
  result := TFhirExplanationOfBenefitTotalListEnumerator.Create(self.link);
end;

function TFhirExplanationOfBenefitTotalList.Clone: TFhirExplanationOfBenefitTotalList;
begin
  result := TFhirExplanationOfBenefitTotalList(inherited Clone);
end;

function TFhirExplanationOfBenefitTotalList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirExplanationOfBenefitTotalList.GetItemN(index: Integer): TFhirExplanationOfBenefitTotal;
begin
  result := TFhirExplanationOfBenefitTotal(ObjectByIndex[index]);
end;

function TFhirExplanationOfBenefitTotalList.ItemClass: TFslObjectClass;
begin
  result := TFhirExplanationOfBenefitTotal;
end;
function TFhirExplanationOfBenefitTotalList.IndexOf(value: TFhirExplanationOfBenefitTotal): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirExplanationOfBenefitTotalList.Insert(index: Integer): TFhirExplanationOfBenefitTotal;
begin
  result := TFhirExplanationOfBenefitTotal.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirExplanationOfBenefitTotalList.InsertItem(index: Integer; value: TFhirExplanationOfBenefitTotal);
begin
  assert(value is TFhirExplanationOfBenefitTotal);
  Inherited Insert(index, value);
end;

function TFhirExplanationOfBenefitTotalList.Item(index: Integer): TFhirExplanationOfBenefitTotal;
begin
  result := TFhirExplanationOfBenefitTotal(ObjectByIndex[index]);
end;

function TFhirExplanationOfBenefitTotalList.Link: TFhirExplanationOfBenefitTotalList;
begin
  result := TFhirExplanationOfBenefitTotalList(inherited Link);
end;

procedure TFhirExplanationOfBenefitTotalList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirExplanationOfBenefitTotalList.SetItemByIndex(index: Integer; value: TFhirExplanationOfBenefitTotal);
begin
  assert(value is TFhirExplanationOfBenefitTotal);
  FhirExplanationOfBenefitTotals[index] := value;
end;

procedure TFhirExplanationOfBenefitTotalList.SetItemN(index: Integer; value: TFhirExplanationOfBenefitTotal);
begin
  assert(value is TFhirExplanationOfBenefitTotal);
  ObjectByIndex[index] := value;
end;

{ TFhirExplanationOfBenefitPayment }

constructor TFhirExplanationOfBenefitPayment.Create;
begin
  inherited;
end;

destructor TFhirExplanationOfBenefitPayment.Destroy;
begin
  FType_.free;
  FAdjustment.free;
  FAdjustmentReason.free;
  FDate.free;
  FAmount.free;
  FIdentifier.free;
  inherited;
end;

procedure TFhirExplanationOfBenefitPayment.Assign(oSource : TFslObject);
begin
  inherited;
  type_ := TFhirExplanationOfBenefitPayment(oSource).type_.Clone;
  adjustment := TFhirExplanationOfBenefitPayment(oSource).adjustment.Clone;
  adjustmentReason := TFhirExplanationOfBenefitPayment(oSource).adjustmentReason.Clone;
  dateElement := TFhirExplanationOfBenefitPayment(oSource).dateElement.Clone;
  amount := TFhirExplanationOfBenefitPayment(oSource).amount.Clone;
  identifier := TFhirExplanationOfBenefitPayment(oSource).identifier.Clone;
end;

procedure TFhirExplanationOfBenefitPayment.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'type') Then
     list.add(self.link, 'type', FType_.Link);
  if (child_name = 'adjustment') Then
     list.add(self.link, 'adjustment', FAdjustment.Link);
  if (child_name = 'adjustmentReason') Then
     list.add(self.link, 'adjustmentReason', FAdjustmentReason.Link);
  if (child_name = 'date') Then
     list.add(self.link, 'date', FDate.Link);
  if (child_name = 'amount') Then
     list.add(self.link, 'amount', FAmount.Link);
  if (child_name = 'identifier') Then
     list.add(self.link, 'identifier', FIdentifier.Link);
end;

procedure TFhirExplanationOfBenefitPayment.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'type', 'CodeableConcept', false, TFhirCodeableConcept, FType_.Link));
  oList.add(TFHIRProperty.create(self, 'adjustment', 'Money', false, TFhirMoney, FAdjustment.Link));
  oList.add(TFHIRProperty.create(self, 'adjustmentReason', 'CodeableConcept', false, TFhirCodeableConcept, FAdjustmentReason.Link));
  oList.add(TFHIRProperty.create(self, 'date', 'date', false, TFhirDate, FDate.Link));
  oList.add(TFHIRProperty.create(self, 'amount', 'Money', false, TFhirMoney, FAmount.Link));
  oList.add(TFHIRProperty.create(self, 'identifier', 'Identifier', false, TFhirIdentifier, FIdentifier.Link));
end;

function TFhirExplanationOfBenefitPayment.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'type') then
  begin
    Type_ := propValue as TFhirCodeableConcept;
    result := propValue;
  end
  else if (propName = 'adjustment') then
  begin
    Adjustment := propValue as TFhirMoney;
    result := propValue;
  end
  else if (propName = 'adjustmentReason') then
  begin
    AdjustmentReason := propValue as TFhirCodeableConcept;
    result := propValue;
  end
  else if (propName = 'date') then
  begin
    DateElement := asDate(propValue);
    result := propValue;
  end
  else if (propName = 'amount') then
  begin
    Amount := propValue as TFhirMoney;
    result := propValue;
  end
  else if (propName = 'identifier') then
  begin
    Identifier := propValue as TFhirIdentifier;
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirExplanationOfBenefitPayment.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirExplanationOfBenefitPayment.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'type') then result := TFhirCodeableConcept.create()
  else if (propName = 'adjustment') then result := TFhirMoney.create()
  else if (propName = 'adjustmentReason') then result := TFhirCodeableConcept.create()
  else if (propName = 'date') then result := TFhirDate.create()
  else if (propName = 'amount') then result := TFhirMoney.create()
  else if (propName = 'identifier') then result := TFhirIdentifier.create()
  else result := inherited createPropertyValue(propName);
end;

function TFhirExplanationOfBenefitPayment.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'type') then result := 'CodeableConcept'
  else if (propName = 'adjustment') then result := 'Money'
  else if (propName = 'adjustmentReason') then result := 'CodeableConcept'
  else if (propName = 'date') then result := 'date'
  else if (propName = 'amount') then result := 'Money'
  else if (propName = 'identifier') then result := 'Identifier'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirExplanationOfBenefitPayment.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'type') then Type_Element := nil
  else if (propName = 'adjustment') then AdjustmentElement := nil
  else if (propName = 'adjustmentReason') then AdjustmentReasonElement := nil
  else if (propName = 'date') then DateElement := nil
  else if (propName = 'amount') then AmountElement := nil
  else if (propName = 'identifier') then IdentifierElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirExplanationOfBenefitPayment.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'type') then Type_Element := new as TFhirCodeableConcept
  else if (propName = 'adjustment') then AdjustmentElement := new as TFhirMoney
  else if (propName = 'adjustmentReason') then AdjustmentReasonElement := new as TFhirCodeableConcept
  else if (propName = 'date') then DateElement := asDate(new)
  else if (propName = 'amount') then AmountElement := new as TFhirMoney
  else if (propName = 'identifier') then IdentifierElement := new as TFhirIdentifier
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirExplanationOfBenefitPayment.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirExplanationOfBenefitPayment.fhirType : string;
begin
  result := 'ExplanationOfBenefit.payment';
end;

function TFhirExplanationOfBenefitPayment.Link : TFhirExplanationOfBenefitPayment;
begin
  result := TFhirExplanationOfBenefitPayment(inherited Link);
end;

function TFhirExplanationOfBenefitPayment.Clone : TFhirExplanationOfBenefitPayment;
begin
  result := TFhirExplanationOfBenefitPayment(inherited Clone);
end;

function TFhirExplanationOfBenefitPayment.equals(other : TObject) : boolean; 
var
  o : TFhirExplanationOfBenefitPayment;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirExplanationOfBenefitPayment)) then
    result := false
  else
  begin
    o := TFhirExplanationOfBenefitPayment(other);
    result := compareDeep(type_Element, o.type_Element, true) and compareDeep(adjustmentElement, o.adjustmentElement, true) and 
      compareDeep(adjustmentReasonElement, o.adjustmentReasonElement, true) and compareDeep(dateElement, o.dateElement, true) and 
      compareDeep(amountElement, o.amountElement, true) and compareDeep(identifierElement, o.identifierElement, true);
  end;
end;

function TFhirExplanationOfBenefitPayment.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FType_) and isEmptyProp(FAdjustment) and isEmptyProp(FAdjustmentReason) and isEmptyProp(FDate) and isEmptyProp(FAmount) and isEmptyProp(FIdentifier);
end;

procedure TFhirExplanationOfBenefitPayment.listFieldsInOrder(fields : TStringList);
begin
  inherited listFieldsInOrder(fields);
  fields.add('type');
  fields.add('adjustment');
  fields.add('adjustmentReason');
  fields.add('date');
  fields.add('amount');
  fields.add('identifier');
end;

function TFhirExplanationOfBenefitPayment.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
end;

procedure TFhirExplanationOfBenefitPayment.SetType_(value : TFhirCodeableConcept);
begin
  FType_.free;
  FType_ := value;
end;

procedure TFhirExplanationOfBenefitPayment.SetAdjustment(value : TFhirMoney);
begin
  FAdjustment.free;
  FAdjustment := value;
end;

procedure TFhirExplanationOfBenefitPayment.SetAdjustmentReason(value : TFhirCodeableConcept);
begin
  FAdjustmentReason.free;
  FAdjustmentReason := value;
end;

procedure TFhirExplanationOfBenefitPayment.SetDate(value : TFhirDate);
begin
  FDate.free;
  FDate := value;
end;

function TFhirExplanationOfBenefitPayment.GetDateST : TFslDateTime;
begin
  if FDate = nil then
    result := TFslDateTime.makeNull
  else
    result := FDate.value;
end;

procedure TFhirExplanationOfBenefitPayment.SetDateST(value : TFslDateTime);
begin
  if FDate = nil then
    FDate := TFhirDate.create;
  FDate.value := value
end;

procedure TFhirExplanationOfBenefitPayment.SetAmount(value : TFhirMoney);
begin
  FAmount.free;
  FAmount := value;
end;

procedure TFhirExplanationOfBenefitPayment.SetIdentifier(value : TFhirIdentifier);
begin
  FIdentifier.free;
  FIdentifier := value;
end;

{ TFhirExplanationOfBenefitPaymentListEnumerator }

constructor TFhirExplanationOfBenefitPaymentListEnumerator.Create(list : TFhirExplanationOfBenefitPaymentList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirExplanationOfBenefitPaymentListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirExplanationOfBenefitPaymentListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirExplanationOfBenefitPaymentListEnumerator.GetCurrent : TFhirExplanationOfBenefitPayment;
begin
  Result := FList[FIndex];
end;

function TFhirExplanationOfBenefitPaymentListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirExplanationOfBenefitPaymentList }

procedure TFhirExplanationOfBenefitPaymentList.AddItem(value: TFhirExplanationOfBenefitPayment);
begin
  assert(value.ClassName = 'TFhirExplanationOfBenefitPayment', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirExplanationOfBenefitPayment');
  add(value);
end;

function TFhirExplanationOfBenefitPaymentList.Append: TFhirExplanationOfBenefitPayment;
begin
  result := TFhirExplanationOfBenefitPayment.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirExplanationOfBenefitPaymentList.ClearItems;
begin
  Clear;
end;

function TFhirExplanationOfBenefitPaymentList.GetEnumerator : TFhirExplanationOfBenefitPaymentListEnumerator;
begin
  result := TFhirExplanationOfBenefitPaymentListEnumerator.Create(self.link);
end;

function TFhirExplanationOfBenefitPaymentList.Clone: TFhirExplanationOfBenefitPaymentList;
begin
  result := TFhirExplanationOfBenefitPaymentList(inherited Clone);
end;

function TFhirExplanationOfBenefitPaymentList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirExplanationOfBenefitPaymentList.GetItemN(index: Integer): TFhirExplanationOfBenefitPayment;
begin
  result := TFhirExplanationOfBenefitPayment(ObjectByIndex[index]);
end;

function TFhirExplanationOfBenefitPaymentList.ItemClass: TFslObjectClass;
begin
  result := TFhirExplanationOfBenefitPayment;
end;
function TFhirExplanationOfBenefitPaymentList.IndexOf(value: TFhirExplanationOfBenefitPayment): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirExplanationOfBenefitPaymentList.Insert(index: Integer): TFhirExplanationOfBenefitPayment;
begin
  result := TFhirExplanationOfBenefitPayment.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirExplanationOfBenefitPaymentList.InsertItem(index: Integer; value: TFhirExplanationOfBenefitPayment);
begin
  assert(value is TFhirExplanationOfBenefitPayment);
  Inherited Insert(index, value);
end;

function TFhirExplanationOfBenefitPaymentList.Item(index: Integer): TFhirExplanationOfBenefitPayment;
begin
  result := TFhirExplanationOfBenefitPayment(ObjectByIndex[index]);
end;

function TFhirExplanationOfBenefitPaymentList.Link: TFhirExplanationOfBenefitPaymentList;
begin
  result := TFhirExplanationOfBenefitPaymentList(inherited Link);
end;

procedure TFhirExplanationOfBenefitPaymentList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirExplanationOfBenefitPaymentList.SetItemByIndex(index: Integer; value: TFhirExplanationOfBenefitPayment);
begin
  assert(value is TFhirExplanationOfBenefitPayment);
  FhirExplanationOfBenefitPayments[index] := value;
end;

procedure TFhirExplanationOfBenefitPaymentList.SetItemN(index: Integer; value: TFhirExplanationOfBenefitPayment);
begin
  assert(value is TFhirExplanationOfBenefitPayment);
  ObjectByIndex[index] := value;
end;

{ TFhirExplanationOfBenefitProcessNote }

constructor TFhirExplanationOfBenefitProcessNote.Create;
begin
  inherited;
end;

destructor TFhirExplanationOfBenefitProcessNote.Destroy;
begin
  FNumber.free;
  FType_.free;
  FText.free;
  FLanguage.free;
  inherited;
end;

procedure TFhirExplanationOfBenefitProcessNote.Assign(oSource : TFslObject);
begin
  inherited;
  numberElement := TFhirExplanationOfBenefitProcessNote(oSource).numberElement.Clone;
  type_Element := TFhirExplanationOfBenefitProcessNote(oSource).type_Element.Clone;
  textElement := TFhirExplanationOfBenefitProcessNote(oSource).textElement.Clone;
  language := TFhirExplanationOfBenefitProcessNote(oSource).language.Clone;
end;

procedure TFhirExplanationOfBenefitProcessNote.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'number') Then
     list.add(self.link, 'number', FNumber.Link);
  if (child_name = 'type') Then
     list.add(self.link, 'type', FType_.Link);
  if (child_name = 'text') Then
     list.add(self.link, 'text', FText.Link);
  if (child_name = 'language') Then
     list.add(self.link, 'language', FLanguage.Link);
end;

procedure TFhirExplanationOfBenefitProcessNote.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'number', 'positiveInt', false, TFhirPositiveInt, FNumber.Link));
  oList.add(TFHIRProperty.create(self, 'type', 'code', false, TFhirEnum, FType_.Link));
  oList.add(TFHIRProperty.create(self, 'text', 'string', false, TFhirString, FText.Link));
  oList.add(TFHIRProperty.create(self, 'language', 'CodeableConcept', false, TFhirCodeableConcept, FLanguage.Link));
end;

function TFhirExplanationOfBenefitProcessNote.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'number') then
  begin
    NumberElement := asPositiveInt(propValue);
    result := propValue;
  end
  else if (propName = 'type') then
  begin
    Type_Element := asEnum(SYSTEMS_TFhirNoteTypeEnum, CODES_TFhirNoteTypeEnum, propValue);
    result := propValue;
  end
  else if (propName = 'text') then
  begin
    TextElement := asString(propValue);
    result := propValue;
  end
  else if (propName = 'language') then
  begin
    Language := propValue as TFhirCodeableConcept;
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirExplanationOfBenefitProcessNote.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirExplanationOfBenefitProcessNote.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'number') then result := TFhirPositiveInt.create()
  else if (propName = 'type') then result := TFhirEnum.create(SYSTEMS_TFhirNoteTypeEnum[NoteTypeNull], CODES_TFhirNoteTypeEnum[NoteTypeNull]) 
  else if (propName = 'text') then result := TFhirString.create()
  else if (propName = 'language') then result := TFhirCodeableConcept.create()
  else result := inherited createPropertyValue(propName);
end;

function TFhirExplanationOfBenefitProcessNote.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'number') then result := 'positiveInt'
  else if (propName = 'type') then result := 'code'
  else if (propName = 'text') then result := 'string'
  else if (propName = 'language') then result := 'CodeableConcept'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirExplanationOfBenefitProcessNote.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'number') then NumberElement := nil
  else if (propName = 'type') then Type_Element := nil
  else if (propName = 'text') then TextElement := nil
  else if (propName = 'language') then LanguageElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirExplanationOfBenefitProcessNote.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'number') then NumberElement := asPositiveInt(new)
  else if (propName = 'type') then Type_Element := asEnum(SYSTEMS_TFhirNoteTypeEnum, CODES_TFhirNoteTypeEnum, new)
  else if (propName = 'text') then TextElement := asString(new)
  else if (propName = 'language') then LanguageElement := new as TFhirCodeableConcept
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirExplanationOfBenefitProcessNote.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirExplanationOfBenefitProcessNote.fhirType : string;
begin
  result := 'ExplanationOfBenefit.processNote';
end;

function TFhirExplanationOfBenefitProcessNote.Link : TFhirExplanationOfBenefitProcessNote;
begin
  result := TFhirExplanationOfBenefitProcessNote(inherited Link);
end;

function TFhirExplanationOfBenefitProcessNote.Clone : TFhirExplanationOfBenefitProcessNote;
begin
  result := TFhirExplanationOfBenefitProcessNote(inherited Clone);
end;

function TFhirExplanationOfBenefitProcessNote.equals(other : TObject) : boolean; 
var
  o : TFhirExplanationOfBenefitProcessNote;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirExplanationOfBenefitProcessNote)) then
    result := false
  else
  begin
    o := TFhirExplanationOfBenefitProcessNote(other);
    result := compareDeep(numberElement, o.numberElement, true) and compareDeep(type_Element, o.type_Element, true) and 
      compareDeep(textElement, o.textElement, true) and compareDeep(languageElement, o.languageElement, true);
  end;
end;

function TFhirExplanationOfBenefitProcessNote.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FNumber) and isEmptyProp(FType_) and isEmptyProp(FText) and isEmptyProp(FLanguage);
end;

procedure TFhirExplanationOfBenefitProcessNote.listFieldsInOrder(fields : TStringList);
begin
  inherited listFieldsInOrder(fields);
  fields.add('number');
  fields.add('type');
  fields.add('text');
  fields.add('language');
end;

function TFhirExplanationOfBenefitProcessNote.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
end;

procedure TFhirExplanationOfBenefitProcessNote.SetNumber(value : TFhirPositiveInt);
begin
  FNumber.free;
  FNumber := value;
end;

function TFhirExplanationOfBenefitProcessNote.GetNumberST : String;
begin
  if FNumber = nil then
    result := ''
  else
    result := FNumber.value;
end;

procedure TFhirExplanationOfBenefitProcessNote.SetNumberST(value : String);
begin
  if value <> '' then
  begin
    if FNumber = nil then
      FNumber := TFhirPositiveInt.create;
    FNumber.value := value
  end
  else if FNumber <> nil then
    FNumber.value := '';
end;

procedure TFhirExplanationOfBenefitProcessNote.SetType_(value : TFhirEnum);
begin
  FType_.free;
  FType_ := value;
end;

function TFhirExplanationOfBenefitProcessNote.GetType_ST : TFhirNoteTypeEnum;
begin
  if FType_ = nil then
    result := TFhirNoteTypeEnum(0)
  else
    result := TFhirNoteTypeEnum(StringArrayIndexOfSensitive(CODES_TFhirNoteTypeEnum, FType_.value));
end;

procedure TFhirExplanationOfBenefitProcessNote.SetType_ST(value : TFhirNoteTypeEnum);
begin
  if ord(value) = 0 then
    Type_Element := nil
  else
    Type_Element := TFhirEnum.create(SYSTEMS_TFhirNoteTypeEnum[value], CODES_TFhirNoteTypeEnum[value]);
end;

procedure TFhirExplanationOfBenefitProcessNote.SetText(value : TFhirString);
begin
  FText.free;
  FText := value;
end;

function TFhirExplanationOfBenefitProcessNote.GetTextST : String;
begin
  if FText = nil then
    result := ''
  else
    result := FText.value;
end;

procedure TFhirExplanationOfBenefitProcessNote.SetTextST(value : String);
begin
  if value <> '' then
  begin
    if FText = nil then
      FText := TFhirString.create;
    FText.value := value
  end
  else if FText <> nil then
    FText.value := '';
end;

procedure TFhirExplanationOfBenefitProcessNote.SetLanguage(value : TFhirCodeableConcept);
begin
  FLanguage.free;
  FLanguage := value;
end;

{ TFhirExplanationOfBenefitProcessNoteListEnumerator }

constructor TFhirExplanationOfBenefitProcessNoteListEnumerator.Create(list : TFhirExplanationOfBenefitProcessNoteList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirExplanationOfBenefitProcessNoteListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirExplanationOfBenefitProcessNoteListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirExplanationOfBenefitProcessNoteListEnumerator.GetCurrent : TFhirExplanationOfBenefitProcessNote;
begin
  Result := FList[FIndex];
end;

function TFhirExplanationOfBenefitProcessNoteListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirExplanationOfBenefitProcessNoteList }

procedure TFhirExplanationOfBenefitProcessNoteList.AddItem(value: TFhirExplanationOfBenefitProcessNote);
begin
  assert(value.ClassName = 'TFhirExplanationOfBenefitProcessNote', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirExplanationOfBenefitProcessNote');
  add(value);
end;

function TFhirExplanationOfBenefitProcessNoteList.Append: TFhirExplanationOfBenefitProcessNote;
begin
  result := TFhirExplanationOfBenefitProcessNote.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirExplanationOfBenefitProcessNoteList.ClearItems;
begin
  Clear;
end;

function TFhirExplanationOfBenefitProcessNoteList.GetEnumerator : TFhirExplanationOfBenefitProcessNoteListEnumerator;
begin
  result := TFhirExplanationOfBenefitProcessNoteListEnumerator.Create(self.link);
end;

function TFhirExplanationOfBenefitProcessNoteList.Clone: TFhirExplanationOfBenefitProcessNoteList;
begin
  result := TFhirExplanationOfBenefitProcessNoteList(inherited Clone);
end;

function TFhirExplanationOfBenefitProcessNoteList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirExplanationOfBenefitProcessNoteList.GetItemN(index: Integer): TFhirExplanationOfBenefitProcessNote;
begin
  result := TFhirExplanationOfBenefitProcessNote(ObjectByIndex[index]);
end;

function TFhirExplanationOfBenefitProcessNoteList.ItemClass: TFslObjectClass;
begin
  result := TFhirExplanationOfBenefitProcessNote;
end;
function TFhirExplanationOfBenefitProcessNoteList.IndexOf(value: TFhirExplanationOfBenefitProcessNote): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirExplanationOfBenefitProcessNoteList.Insert(index: Integer): TFhirExplanationOfBenefitProcessNote;
begin
  result := TFhirExplanationOfBenefitProcessNote.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirExplanationOfBenefitProcessNoteList.InsertItem(index: Integer; value: TFhirExplanationOfBenefitProcessNote);
begin
  assert(value is TFhirExplanationOfBenefitProcessNote);
  Inherited Insert(index, value);
end;

function TFhirExplanationOfBenefitProcessNoteList.Item(index: Integer): TFhirExplanationOfBenefitProcessNote;
begin
  result := TFhirExplanationOfBenefitProcessNote(ObjectByIndex[index]);
end;

function TFhirExplanationOfBenefitProcessNoteList.Link: TFhirExplanationOfBenefitProcessNoteList;
begin
  result := TFhirExplanationOfBenefitProcessNoteList(inherited Link);
end;

procedure TFhirExplanationOfBenefitProcessNoteList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirExplanationOfBenefitProcessNoteList.SetItemByIndex(index: Integer; value: TFhirExplanationOfBenefitProcessNote);
begin
  assert(value is TFhirExplanationOfBenefitProcessNote);
  FhirExplanationOfBenefitProcessNotes[index] := value;
end;

procedure TFhirExplanationOfBenefitProcessNoteList.SetItemN(index: Integer; value: TFhirExplanationOfBenefitProcessNote);
begin
  assert(value is TFhirExplanationOfBenefitProcessNote);
  ObjectByIndex[index] := value;
end;

{ TFhirExplanationOfBenefitBenefitBalance }

constructor TFhirExplanationOfBenefitBenefitBalance.Create;
begin
  inherited;
end;

destructor TFhirExplanationOfBenefitBenefitBalance.Destroy;
begin
  FCategory.free;
  FExcluded.free;
  FName.free;
  FDescription.free;
  FNetwork.free;
  FUnit_.free;
  FTerm.free;
  FFinancialList.Free;
  inherited;
end;

procedure TFhirExplanationOfBenefitBenefitBalance.Assign(oSource : TFslObject);
begin
  inherited;
  category := TFhirExplanationOfBenefitBenefitBalance(oSource).category.Clone;
  excludedElement := TFhirExplanationOfBenefitBenefitBalance(oSource).excludedElement.Clone;
  nameElement := TFhirExplanationOfBenefitBenefitBalance(oSource).nameElement.Clone;
  descriptionElement := TFhirExplanationOfBenefitBenefitBalance(oSource).descriptionElement.Clone;
  network := TFhirExplanationOfBenefitBenefitBalance(oSource).network.Clone;
  unit_ := TFhirExplanationOfBenefitBenefitBalance(oSource).unit_.Clone;
  term := TFhirExplanationOfBenefitBenefitBalance(oSource).term.Clone;
  if (TFhirExplanationOfBenefitBenefitBalance(oSource).FFinancialList = nil) then
  begin
    FFinancialList.free;
    FFinancialList := nil;
  end
  else
  begin
    if FFinancialList = nil then
      FFinancialList := TFhirExplanationOfBenefitBenefitBalanceFinancialList.Create;
    FFinancialList.Assign(TFhirExplanationOfBenefitBenefitBalance(oSource).FFinancialList);
  end;
end;

procedure TFhirExplanationOfBenefitBenefitBalance.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'category') Then
     list.add(self.link, 'category', FCategory.Link);
  if (child_name = 'excluded') Then
     list.add(self.link, 'excluded', FExcluded.Link);
  if (child_name = 'name') Then
     list.add(self.link, 'name', FName.Link);
  if (child_name = 'description') Then
     list.add(self.link, 'description', FDescription.Link);
  if (child_name = 'network') Then
     list.add(self.link, 'network', FNetwork.Link);
  if (child_name = 'unit') Then
     list.add(self.link, 'unit', FUnit_.Link);
  if (child_name = 'term') Then
     list.add(self.link, 'term', FTerm.Link);
  if (child_name = 'financial') Then
    list.addAll(self, 'financial', FFinancialList);
end;

procedure TFhirExplanationOfBenefitBenefitBalance.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'category', 'CodeableConcept', false, TFhirCodeableConcept, FCategory.Link));
  oList.add(TFHIRProperty.create(self, 'excluded', 'boolean', false, TFhirBoolean, FExcluded.Link));
  oList.add(TFHIRProperty.create(self, 'name', 'string', false, TFhirString, FName.Link));
  oList.add(TFHIRProperty.create(self, 'description', 'string', false, TFhirString, FDescription.Link));
  oList.add(TFHIRProperty.create(self, 'network', 'CodeableConcept', false, TFhirCodeableConcept, FNetwork.Link));
  oList.add(TFHIRProperty.create(self, 'unit', 'CodeableConcept', false, TFhirCodeableConcept, FUnit_.Link));
  oList.add(TFHIRProperty.create(self, 'term', 'CodeableConcept', false, TFhirCodeableConcept, FTerm.Link));
  oList.add(TFHIRProperty.create(self, 'financial', 'BackboneElement', true, TFhirExplanationOfBenefitBenefitBalanceFinancial, FFinancialList.Link));
end;

function TFhirExplanationOfBenefitBenefitBalance.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'category') then
  begin
    Category := propValue as TFhirCodeableConcept;
    result := propValue;
  end
  else if (propName = 'excluded') then
  begin
    ExcludedElement := asBoolean(propValue);
    result := propValue;
  end
  else if (propName = 'name') then
  begin
    NameElement := asString(propValue);
    result := propValue;
  end
  else if (propName = 'description') then
  begin
    DescriptionElement := asString(propValue);
    result := propValue;
  end
  else if (propName = 'network') then
  begin
    Network := propValue as TFhirCodeableConcept;
    result := propValue;
  end
  else if (propName = 'unit') then
  begin
    Unit_ := propValue as TFhirCodeableConcept;
    result := propValue;
  end
  else if (propName = 'term') then
  begin
    Term := propValue as TFhirCodeableConcept;
    result := propValue;
  end
  else if (propName = 'financial') then
  begin
    FinancialList.add(propValue as TFhirExplanationOfBenefitBenefitBalanceFinancial);
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirExplanationOfBenefitBenefitBalance.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'financial') then FinancialList.insertItem(index, propValue as TFhirExplanationOfBenefitBenefitBalanceFinancial)
  else inherited;
end;

function TFhirExplanationOfBenefitBenefitBalance.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'category') then result := TFhirCodeableConcept.create()
  else if (propName = 'excluded') then result := TFhirBoolean.create()
  else if (propName = 'name') then result := TFhirString.create()
  else if (propName = 'description') then result := TFhirString.create()
  else if (propName = 'network') then result := TFhirCodeableConcept.create()
  else if (propName = 'unit') then result := TFhirCodeableConcept.create()
  else if (propName = 'term') then result := TFhirCodeableConcept.create()
  else if (propName = 'financial') then result := FinancialList.new()
  else result := inherited createPropertyValue(propName);
end;

function TFhirExplanationOfBenefitBenefitBalance.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'category') then result := 'CodeableConcept'
  else if (propName = 'excluded') then result := 'boolean'
  else if (propName = 'name') then result := 'string'
  else if (propName = 'description') then result := 'string'
  else if (propName = 'network') then result := 'CodeableConcept'
  else if (propName = 'unit') then result := 'CodeableConcept'
  else if (propName = 'term') then result := 'CodeableConcept'
  else if (propName = 'financial') then result := 'BackboneElement'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirExplanationOfBenefitBenefitBalance.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'category') then CategoryElement := nil
  else if (propName = 'excluded') then ExcludedElement := nil
  else if (propName = 'name') then NameElement := nil
  else if (propName = 'description') then DescriptionElement := nil
  else if (propName = 'network') then NetworkElement := nil
  else if (propName = 'unit') then Unit_Element := nil
  else if (propName = 'term') then TermElement := nil
  else if (propName = 'financial') then deletePropertyValue('financial', FinancialList, value)
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirExplanationOfBenefitBenefitBalance.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'category') then CategoryElement := new as TFhirCodeableConcept
  else if (propName = 'excluded') then ExcludedElement := asBoolean(new)
  else if (propName = 'name') then NameElement := asString(new)
  else if (propName = 'description') then DescriptionElement := asString(new)
  else if (propName = 'network') then NetworkElement := new as TFhirCodeableConcept
  else if (propName = 'unit') then Unit_Element := new as TFhirCodeableConcept
  else if (propName = 'term') then TermElement := new as TFhirCodeableConcept
  else if (propName = 'financial') then replacePropertyValue('financial', FinancialList, existing, new)
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirExplanationOfBenefitBenefitBalance.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'financial') then FinancialList.move(source, destination)
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirExplanationOfBenefitBenefitBalance.fhirType : string;
begin
  result := 'ExplanationOfBenefit.benefitBalance';
end;

function TFhirExplanationOfBenefitBenefitBalance.Link : TFhirExplanationOfBenefitBenefitBalance;
begin
  result := TFhirExplanationOfBenefitBenefitBalance(inherited Link);
end;

function TFhirExplanationOfBenefitBenefitBalance.Clone : TFhirExplanationOfBenefitBenefitBalance;
begin
  result := TFhirExplanationOfBenefitBenefitBalance(inherited Clone);
end;

function TFhirExplanationOfBenefitBenefitBalance.equals(other : TObject) : boolean; 
var
  o : TFhirExplanationOfBenefitBenefitBalance;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirExplanationOfBenefitBenefitBalance)) then
    result := false
  else
  begin
    o := TFhirExplanationOfBenefitBenefitBalance(other);
    result := compareDeep(categoryElement, o.categoryElement, true) and compareDeep(excludedElement, o.excludedElement, true) and 
      compareDeep(nameElement, o.nameElement, true) and compareDeep(descriptionElement, o.descriptionElement, true) and 
      compareDeep(networkElement, o.networkElement, true) and compareDeep(unit_Element, o.unit_Element, true) and 
      compareDeep(termElement, o.termElement, true) and compareDeep(financialList, o.financialList, true);
  end;
end;

function TFhirExplanationOfBenefitBenefitBalance.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FCategory) and isEmptyProp(FExcluded) and isEmptyProp(FName) and isEmptyProp(FDescription) and isEmptyProp(FNetwork) and isEmptyProp(FUnit_) and isEmptyProp(FTerm) and isEmptyProp(FfinancialList);
end;

procedure TFhirExplanationOfBenefitBenefitBalance.listFieldsInOrder(fields : TStringList);
begin
  inherited listFieldsInOrder(fields);
  fields.add('category');
  fields.add('excluded');
  fields.add('name');
  fields.add('description');
  fields.add('network');
  fields.add('unit');
  fields.add('term');
  fields.add('financial');
end;

function TFhirExplanationOfBenefitBenefitBalance.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FFinancialList.sizeInBytes(magic));
end;

procedure TFhirExplanationOfBenefitBenefitBalance.SetCategory(value : TFhirCodeableConcept);
begin
  FCategory.free;
  FCategory := value;
end;

procedure TFhirExplanationOfBenefitBenefitBalance.SetExcluded(value : TFhirBoolean);
begin
  FExcluded.free;
  FExcluded := value;
end;

function TFhirExplanationOfBenefitBenefitBalance.GetExcludedST : Boolean;
begin
  if FExcluded = nil then
    result := false
  else
    result := FExcluded.value;
end;

procedure TFhirExplanationOfBenefitBenefitBalance.SetExcludedST(value : Boolean);
begin
  if FExcluded = nil then
    FExcluded := TFhirBoolean.create;
  FExcluded.value := value
end;

procedure TFhirExplanationOfBenefitBenefitBalance.SetName(value : TFhirString);
begin
  FName.free;
  FName := value;
end;

function TFhirExplanationOfBenefitBenefitBalance.GetNameST : String;
begin
  if FName = nil then
    result := ''
  else
    result := FName.value;
end;

procedure TFhirExplanationOfBenefitBenefitBalance.SetNameST(value : String);
begin
  if value <> '' then
  begin
    if FName = nil then
      FName := TFhirString.create;
    FName.value := value
  end
  else if FName <> nil then
    FName.value := '';
end;

procedure TFhirExplanationOfBenefitBenefitBalance.SetDescription(value : TFhirString);
begin
  FDescription.free;
  FDescription := value;
end;

function TFhirExplanationOfBenefitBenefitBalance.GetDescriptionST : String;
begin
  if FDescription = nil then
    result := ''
  else
    result := FDescription.value;
end;

procedure TFhirExplanationOfBenefitBenefitBalance.SetDescriptionST(value : String);
begin
  if value <> '' then
  begin
    if FDescription = nil then
      FDescription := TFhirString.create;
    FDescription.value := value
  end
  else if FDescription <> nil then
    FDescription.value := '';
end;

procedure TFhirExplanationOfBenefitBenefitBalance.SetNetwork(value : TFhirCodeableConcept);
begin
  FNetwork.free;
  FNetwork := value;
end;

procedure TFhirExplanationOfBenefitBenefitBalance.SetUnit_(value : TFhirCodeableConcept);
begin
  FUnit_.free;
  FUnit_ := value;
end;

procedure TFhirExplanationOfBenefitBenefitBalance.SetTerm(value : TFhirCodeableConcept);
begin
  FTerm.free;
  FTerm := value;
end;

function TFhirExplanationOfBenefitBenefitBalance.GetFinancialList : TFhirExplanationOfBenefitBenefitBalanceFinancialList;
begin
  if FFinancialList = nil then
    FFinancialList := TFhirExplanationOfBenefitBenefitBalanceFinancialList.Create;
  result := FFinancialList;
end;

function TFhirExplanationOfBenefitBenefitBalance.GetHasFinancialList : boolean;
begin
  result := (FFinancialList <> nil) and (FFinancialList.count > 0);
end;

{ TFhirExplanationOfBenefitBenefitBalanceListEnumerator }

constructor TFhirExplanationOfBenefitBenefitBalanceListEnumerator.Create(list : TFhirExplanationOfBenefitBenefitBalanceList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirExplanationOfBenefitBenefitBalanceListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirExplanationOfBenefitBenefitBalanceListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirExplanationOfBenefitBenefitBalanceListEnumerator.GetCurrent : TFhirExplanationOfBenefitBenefitBalance;
begin
  Result := FList[FIndex];
end;

function TFhirExplanationOfBenefitBenefitBalanceListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirExplanationOfBenefitBenefitBalanceList }

procedure TFhirExplanationOfBenefitBenefitBalanceList.AddItem(value: TFhirExplanationOfBenefitBenefitBalance);
begin
  assert(value.ClassName = 'TFhirExplanationOfBenefitBenefitBalance', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirExplanationOfBenefitBenefitBalance');
  add(value);
end;

function TFhirExplanationOfBenefitBenefitBalanceList.Append: TFhirExplanationOfBenefitBenefitBalance;
begin
  result := TFhirExplanationOfBenefitBenefitBalance.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirExplanationOfBenefitBenefitBalanceList.ClearItems;
begin
  Clear;
end;

function TFhirExplanationOfBenefitBenefitBalanceList.GetEnumerator : TFhirExplanationOfBenefitBenefitBalanceListEnumerator;
begin
  result := TFhirExplanationOfBenefitBenefitBalanceListEnumerator.Create(self.link);
end;

function TFhirExplanationOfBenefitBenefitBalanceList.Clone: TFhirExplanationOfBenefitBenefitBalanceList;
begin
  result := TFhirExplanationOfBenefitBenefitBalanceList(inherited Clone);
end;

function TFhirExplanationOfBenefitBenefitBalanceList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirExplanationOfBenefitBenefitBalanceList.GetItemN(index: Integer): TFhirExplanationOfBenefitBenefitBalance;
begin
  result := TFhirExplanationOfBenefitBenefitBalance(ObjectByIndex[index]);
end;

function TFhirExplanationOfBenefitBenefitBalanceList.ItemClass: TFslObjectClass;
begin
  result := TFhirExplanationOfBenefitBenefitBalance;
end;
function TFhirExplanationOfBenefitBenefitBalanceList.IndexOf(value: TFhirExplanationOfBenefitBenefitBalance): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirExplanationOfBenefitBenefitBalanceList.Insert(index: Integer): TFhirExplanationOfBenefitBenefitBalance;
begin
  result := TFhirExplanationOfBenefitBenefitBalance.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirExplanationOfBenefitBenefitBalanceList.InsertItem(index: Integer; value: TFhirExplanationOfBenefitBenefitBalance);
begin
  assert(value is TFhirExplanationOfBenefitBenefitBalance);
  Inherited Insert(index, value);
end;

function TFhirExplanationOfBenefitBenefitBalanceList.Item(index: Integer): TFhirExplanationOfBenefitBenefitBalance;
begin
  result := TFhirExplanationOfBenefitBenefitBalance(ObjectByIndex[index]);
end;

function TFhirExplanationOfBenefitBenefitBalanceList.Link: TFhirExplanationOfBenefitBenefitBalanceList;
begin
  result := TFhirExplanationOfBenefitBenefitBalanceList(inherited Link);
end;

procedure TFhirExplanationOfBenefitBenefitBalanceList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirExplanationOfBenefitBenefitBalanceList.SetItemByIndex(index: Integer; value: TFhirExplanationOfBenefitBenefitBalance);
begin
  assert(value is TFhirExplanationOfBenefitBenefitBalance);
  FhirExplanationOfBenefitBenefitBalances[index] := value;
end;

procedure TFhirExplanationOfBenefitBenefitBalanceList.SetItemN(index: Integer; value: TFhirExplanationOfBenefitBenefitBalance);
begin
  assert(value is TFhirExplanationOfBenefitBenefitBalance);
  ObjectByIndex[index] := value;
end;

{ TFhirExplanationOfBenefitBenefitBalanceFinancial }

constructor TFhirExplanationOfBenefitBenefitBalanceFinancial.Create;
begin
  inherited;
end;

destructor TFhirExplanationOfBenefitBenefitBalanceFinancial.Destroy;
begin
  FType_.free;
  FAllowed.free;
  FUsed.free;
  inherited;
end;

procedure TFhirExplanationOfBenefitBenefitBalanceFinancial.Assign(oSource : TFslObject);
begin
  inherited;
  type_ := TFhirExplanationOfBenefitBenefitBalanceFinancial(oSource).type_.Clone;
  allowed := TFhirExplanationOfBenefitBenefitBalanceFinancial(oSource).allowed.Clone;
  used := TFhirExplanationOfBenefitBenefitBalanceFinancial(oSource).used.Clone;
end;

procedure TFhirExplanationOfBenefitBenefitBalanceFinancial.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'type') Then
     list.add(self.link, 'type', FType_.Link);
  if (child_name = 'allowed[x]') or (child_name = 'allowed') Then
     list.add(self.link, 'allowed[x]', FAllowed.Link);
  if (child_name = 'used[x]') or (child_name = 'used') Then
     list.add(self.link, 'used[x]', FUsed.Link);
end;

procedure TFhirExplanationOfBenefitBenefitBalanceFinancial.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'type', 'CodeableConcept', false, TFhirCodeableConcept, FType_.Link));
  oList.add(TFHIRProperty.create(self, 'allowed[x]', 'unsignedInt|string|Money', false, TFhirDataType, FAllowed.Link));
  oList.add(TFHIRProperty.create(self, 'used[x]', 'unsignedInt|Money', false, TFhirDataType, FUsed.Link));
end;

function TFhirExplanationOfBenefitBenefitBalanceFinancial.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'type') then
  begin
    Type_ := propValue as TFhirCodeableConcept;
    result := propValue;
  end
  else if (isMatchingName(propName, 'allowed', ['UnsignedInt', 'String', 'Money'])) then
  begin
    Allowed := propValue as TFhirDataType;
    result := propValue;
  end
  else if (isMatchingName(propName, 'used', ['UnsignedInt', 'Money'])) then
  begin
    Used := propValue as TFhirDataType;
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirExplanationOfBenefitBenefitBalanceFinancial.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirExplanationOfBenefitBenefitBalanceFinancial.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'type') then result := TFhirCodeableConcept.create()
  else if (isMatchingName(propName, 'allowed', ['UnsignedInt', 'String', 'Money'])) then raise EFHIRException.create('Cannot make property Allowed')
  else if (isMatchingName(propName, 'used', ['UnsignedInt', 'Money'])) then raise EFHIRException.create('Cannot make property Used')
  else result := inherited createPropertyValue(propName);
end;

function TFhirExplanationOfBenefitBenefitBalanceFinancial.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'type') then result := 'CodeableConcept'
  else if (propName = 'allowed[x]') then result := 'unsignedInt|string|Money'
  else if (propName = 'used[x]') then result := 'unsignedInt|Money'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirExplanationOfBenefitBenefitBalanceFinancial.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'type') then Type_Element := nil
  else if (isMatchingName(propName, 'allowed', ['UnsignedInt', 'String', 'Money'])) then AllowedElement := nil
  else if (isMatchingName(propName, 'used', ['UnsignedInt', 'Money'])) then UsedElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirExplanationOfBenefitBenefitBalanceFinancial.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'type') then Type_Element := new as TFhirCodeableConcept
  else if (isMatchingName(propName, 'allowed', ['UnsignedInt', 'String', 'Money'])) then AllowedElement := new as TFhirDataType
  else if (isMatchingName(propName, 'used', ['UnsignedInt', 'Money'])) then UsedElement := new as TFhirDataType
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirExplanationOfBenefitBenefitBalanceFinancial.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirExplanationOfBenefitBenefitBalanceFinancial.fhirType : string;
begin
  result := 'ExplanationOfBenefit.benefitBalance.financial';
end;

function TFhirExplanationOfBenefitBenefitBalanceFinancial.Link : TFhirExplanationOfBenefitBenefitBalanceFinancial;
begin
  result := TFhirExplanationOfBenefitBenefitBalanceFinancial(inherited Link);
end;

function TFhirExplanationOfBenefitBenefitBalanceFinancial.Clone : TFhirExplanationOfBenefitBenefitBalanceFinancial;
begin
  result := TFhirExplanationOfBenefitBenefitBalanceFinancial(inherited Clone);
end;

function TFhirExplanationOfBenefitBenefitBalanceFinancial.equals(other : TObject) : boolean; 
var
  o : TFhirExplanationOfBenefitBenefitBalanceFinancial;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirExplanationOfBenefitBenefitBalanceFinancial)) then
    result := false
  else
  begin
    o := TFhirExplanationOfBenefitBenefitBalanceFinancial(other);
    result := compareDeep(type_Element, o.type_Element, true) and compareDeep(allowedElement, o.allowedElement, true) and 
      compareDeep(usedElement, o.usedElement, true);
  end;
end;

function TFhirExplanationOfBenefitBenefitBalanceFinancial.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FType_) and isEmptyProp(FAllowed) and isEmptyProp(FUsed);
end;

procedure TFhirExplanationOfBenefitBenefitBalanceFinancial.listFieldsInOrder(fields : TStringList);
begin
  inherited listFieldsInOrder(fields);
  fields.add('type');
  fields.add('allowed[x]');
  fields.add('used[x]');
end;

function TFhirExplanationOfBenefitBenefitBalanceFinancial.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
end;

procedure TFhirExplanationOfBenefitBenefitBalanceFinancial.SetType_(value : TFhirCodeableConcept);
begin
  FType_.free;
  FType_ := value;
end;

procedure TFhirExplanationOfBenefitBenefitBalanceFinancial.SetAllowed(value : TFhirDataType);
begin
  FAllowed.free;
  FAllowed := value;
end;

procedure TFhirExplanationOfBenefitBenefitBalanceFinancial.SetUsed(value : TFhirDataType);
begin
  FUsed.free;
  FUsed := value;
end;

{ TFhirExplanationOfBenefitBenefitBalanceFinancialListEnumerator }

constructor TFhirExplanationOfBenefitBenefitBalanceFinancialListEnumerator.Create(list : TFhirExplanationOfBenefitBenefitBalanceFinancialList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirExplanationOfBenefitBenefitBalanceFinancialListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirExplanationOfBenefitBenefitBalanceFinancialListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirExplanationOfBenefitBenefitBalanceFinancialListEnumerator.GetCurrent : TFhirExplanationOfBenefitBenefitBalanceFinancial;
begin
  Result := FList[FIndex];
end;

function TFhirExplanationOfBenefitBenefitBalanceFinancialListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirExplanationOfBenefitBenefitBalanceFinancialList }

procedure TFhirExplanationOfBenefitBenefitBalanceFinancialList.AddItem(value: TFhirExplanationOfBenefitBenefitBalanceFinancial);
begin
  assert(value.ClassName = 'TFhirExplanationOfBenefitBenefitBalanceFinancial', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirExplanationOfBenefitBenefitBalanceFinancial');
  add(value);
end;

function TFhirExplanationOfBenefitBenefitBalanceFinancialList.Append: TFhirExplanationOfBenefitBenefitBalanceFinancial;
begin
  result := TFhirExplanationOfBenefitBenefitBalanceFinancial.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirExplanationOfBenefitBenefitBalanceFinancialList.ClearItems;
begin
  Clear;
end;

function TFhirExplanationOfBenefitBenefitBalanceFinancialList.GetEnumerator : TFhirExplanationOfBenefitBenefitBalanceFinancialListEnumerator;
begin
  result := TFhirExplanationOfBenefitBenefitBalanceFinancialListEnumerator.Create(self.link);
end;

function TFhirExplanationOfBenefitBenefitBalanceFinancialList.Clone: TFhirExplanationOfBenefitBenefitBalanceFinancialList;
begin
  result := TFhirExplanationOfBenefitBenefitBalanceFinancialList(inherited Clone);
end;

function TFhirExplanationOfBenefitBenefitBalanceFinancialList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirExplanationOfBenefitBenefitBalanceFinancialList.GetItemN(index: Integer): TFhirExplanationOfBenefitBenefitBalanceFinancial;
begin
  result := TFhirExplanationOfBenefitBenefitBalanceFinancial(ObjectByIndex[index]);
end;

function TFhirExplanationOfBenefitBenefitBalanceFinancialList.ItemClass: TFslObjectClass;
begin
  result := TFhirExplanationOfBenefitBenefitBalanceFinancial;
end;
function TFhirExplanationOfBenefitBenefitBalanceFinancialList.IndexOf(value: TFhirExplanationOfBenefitBenefitBalanceFinancial): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirExplanationOfBenefitBenefitBalanceFinancialList.Insert(index: Integer): TFhirExplanationOfBenefitBenefitBalanceFinancial;
begin
  result := TFhirExplanationOfBenefitBenefitBalanceFinancial.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirExplanationOfBenefitBenefitBalanceFinancialList.InsertItem(index: Integer; value: TFhirExplanationOfBenefitBenefitBalanceFinancial);
begin
  assert(value is TFhirExplanationOfBenefitBenefitBalanceFinancial);
  Inherited Insert(index, value);
end;

function TFhirExplanationOfBenefitBenefitBalanceFinancialList.Item(index: Integer): TFhirExplanationOfBenefitBenefitBalanceFinancial;
begin
  result := TFhirExplanationOfBenefitBenefitBalanceFinancial(ObjectByIndex[index]);
end;

function TFhirExplanationOfBenefitBenefitBalanceFinancialList.Link: TFhirExplanationOfBenefitBenefitBalanceFinancialList;
begin
  result := TFhirExplanationOfBenefitBenefitBalanceFinancialList(inherited Link);
end;

procedure TFhirExplanationOfBenefitBenefitBalanceFinancialList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirExplanationOfBenefitBenefitBalanceFinancialList.SetItemByIndex(index: Integer; value: TFhirExplanationOfBenefitBenefitBalanceFinancial);
begin
  assert(value is TFhirExplanationOfBenefitBenefitBalanceFinancial);
  FhirExplanationOfBenefitBenefitBalanceFinancials[index] := value;
end;

procedure TFhirExplanationOfBenefitBenefitBalanceFinancialList.SetItemN(index: Integer; value: TFhirExplanationOfBenefitBenefitBalanceFinancial);
begin
  assert(value is TFhirExplanationOfBenefitBenefitBalanceFinancial);
  ObjectByIndex[index] := value;
end;

{ TFhirExplanationOfBenefit }

constructor TFhirExplanationOfBenefit.Create;
begin
  inherited;
end;

destructor TFhirExplanationOfBenefit.Destroy;
begin
  FIdentifierList.Free;
  FStatus.free;
  FType_.free;
  FSubType.free;
  FUse.free;
  FPatient.free;
  FBillablePeriod.free;
  FCreated.free;
  FEnterer.free;
  FInsurer.free;
  FProvider.free;
  FPriority.free;
  FFundsReserveRequested.free;
  FFundsReserve.free;
  FRelatedList.Free;
  FPrescription.free;
  FOriginalPrescription.free;
  FPayee.free;
  FReferral.free;
  FFacility.free;
  FClaim.free;
  FClaimResponse.free;
  FOutcome.free;
  FDisposition.free;
  FPreAuthRefList.Free;
  FPreAuthRefPeriodList.Free;
  FCareTeamList.Free;
  FSupportingInfoList.Free;
  FDiagnosisList.Free;
  FProcedure_List.Free;
  FPrecedence.free;
  FInsuranceList.Free;
  FAccident.free;
  FItemList.Free;
  FAddItemList.Free;
  FAdjudicationList.Free;
  FTotalList.Free;
  FPayment.free;
  FFormCode.free;
  FForm.free;
  FProcessNoteList.Free;
  FBenefitPeriod.free;
  FBenefitBalanceList.Free;
  inherited;
end;

procedure TFhirExplanationOfBenefit.Assign(oSource : TFslObject);
begin
  inherited;
  if (TFhirExplanationOfBenefit(oSource).FIdentifierList = nil) then
  begin
    FIdentifierList.free;
    FIdentifierList := nil;
  end
  else
  begin
    if FIdentifierList = nil then
      FIdentifierList := TFhirIdentifierList.Create;
    FIdentifierList.Assign(TFhirExplanationOfBenefit(oSource).FIdentifierList);
  end;
  statusElement := TFhirExplanationOfBenefit(oSource).statusElement.Clone;
  type_ := TFhirExplanationOfBenefit(oSource).type_.Clone;
  subType := TFhirExplanationOfBenefit(oSource).subType.Clone;
  useElement := TFhirExplanationOfBenefit(oSource).useElement.Clone;
  patient := TFhirExplanationOfBenefit(oSource).patient.Clone;
  billablePeriod := TFhirExplanationOfBenefit(oSource).billablePeriod.Clone;
  createdElement := TFhirExplanationOfBenefit(oSource).createdElement.Clone;
  enterer := TFhirExplanationOfBenefit(oSource).enterer.Clone;
  insurer := TFhirExplanationOfBenefit(oSource).insurer.Clone;
  provider := TFhirExplanationOfBenefit(oSource).provider.Clone;
  priority := TFhirExplanationOfBenefit(oSource).priority.Clone;
  fundsReserveRequested := TFhirExplanationOfBenefit(oSource).fundsReserveRequested.Clone;
  fundsReserve := TFhirExplanationOfBenefit(oSource).fundsReserve.Clone;
  if (TFhirExplanationOfBenefit(oSource).FRelatedList = nil) then
  begin
    FRelatedList.free;
    FRelatedList := nil;
  end
  else
  begin
    if FRelatedList = nil then
      FRelatedList := TFhirExplanationOfBenefitRelatedList.Create;
    FRelatedList.Assign(TFhirExplanationOfBenefit(oSource).FRelatedList);
  end;
  prescription := TFhirExplanationOfBenefit(oSource).prescription.Clone;
  originalPrescription := TFhirExplanationOfBenefit(oSource).originalPrescription.Clone;
  payee := TFhirExplanationOfBenefit(oSource).payee.Clone;
  referral := TFhirExplanationOfBenefit(oSource).referral.Clone;
  facility := TFhirExplanationOfBenefit(oSource).facility.Clone;
  claim := TFhirExplanationOfBenefit(oSource).claim.Clone;
  claimResponse := TFhirExplanationOfBenefit(oSource).claimResponse.Clone;
  outcomeElement := TFhirExplanationOfBenefit(oSource).outcomeElement.Clone;
  dispositionElement := TFhirExplanationOfBenefit(oSource).dispositionElement.Clone;
  if (TFhirExplanationOfBenefit(oSource).FPreAuthRefList = nil) then
  begin
    FPreAuthRefList.free;
    FPreAuthRefList := nil;
  end
  else
  begin
    if FPreAuthRefList = nil then
      FPreAuthRefList := TFhirStringList.Create;
    FPreAuthRefList.Assign(TFhirExplanationOfBenefit(oSource).FPreAuthRefList);
  end;
  if (TFhirExplanationOfBenefit(oSource).FPreAuthRefPeriodList = nil) then
  begin
    FPreAuthRefPeriodList.free;
    FPreAuthRefPeriodList := nil;
  end
  else
  begin
    if FPreAuthRefPeriodList = nil then
      FPreAuthRefPeriodList := TFhirPeriodList.Create;
    FPreAuthRefPeriodList.Assign(TFhirExplanationOfBenefit(oSource).FPreAuthRefPeriodList);
  end;
  if (TFhirExplanationOfBenefit(oSource).FCareTeamList = nil) then
  begin
    FCareTeamList.free;
    FCareTeamList := nil;
  end
  else
  begin
    if FCareTeamList = nil then
      FCareTeamList := TFhirExplanationOfBenefitCareTeamList.Create;
    FCareTeamList.Assign(TFhirExplanationOfBenefit(oSource).FCareTeamList);
  end;
  if (TFhirExplanationOfBenefit(oSource).FSupportingInfoList = nil) then
  begin
    FSupportingInfoList.free;
    FSupportingInfoList := nil;
  end
  else
  begin
    if FSupportingInfoList = nil then
      FSupportingInfoList := TFhirExplanationOfBenefitSupportingInfoList.Create;
    FSupportingInfoList.Assign(TFhirExplanationOfBenefit(oSource).FSupportingInfoList);
  end;
  if (TFhirExplanationOfBenefit(oSource).FDiagnosisList = nil) then
  begin
    FDiagnosisList.free;
    FDiagnosisList := nil;
  end
  else
  begin
    if FDiagnosisList = nil then
      FDiagnosisList := TFhirExplanationOfBenefitDiagnosisList.Create;
    FDiagnosisList.Assign(TFhirExplanationOfBenefit(oSource).FDiagnosisList);
  end;
  if (TFhirExplanationOfBenefit(oSource).FProcedure_List = nil) then
  begin
    FProcedure_List.free;
    FProcedure_List := nil;
  end
  else
  begin
    if FProcedure_List = nil then
      FProcedure_List := TFhirExplanationOfBenefitProcedureList.Create;
    FProcedure_List.Assign(TFhirExplanationOfBenefit(oSource).FProcedure_List);
  end;
  precedenceElement := TFhirExplanationOfBenefit(oSource).precedenceElement.Clone;
  if (TFhirExplanationOfBenefit(oSource).FInsuranceList = nil) then
  begin
    FInsuranceList.free;
    FInsuranceList := nil;
  end
  else
  begin
    if FInsuranceList = nil then
      FInsuranceList := TFhirExplanationOfBenefitInsuranceList.Create;
    FInsuranceList.Assign(TFhirExplanationOfBenefit(oSource).FInsuranceList);
  end;
  accident := TFhirExplanationOfBenefit(oSource).accident.Clone;
  if (TFhirExplanationOfBenefit(oSource).FItemList = nil) then
  begin
    FItemList.free;
    FItemList := nil;
  end
  else
  begin
    if FItemList = nil then
      FItemList := TFhirExplanationOfBenefitItemList.Create;
    FItemList.Assign(TFhirExplanationOfBenefit(oSource).FItemList);
  end;
  if (TFhirExplanationOfBenefit(oSource).FAddItemList = nil) then
  begin
    FAddItemList.free;
    FAddItemList := nil;
  end
  else
  begin
    if FAddItemList = nil then
      FAddItemList := TFhirExplanationOfBenefitAddItemList.Create;
    FAddItemList.Assign(TFhirExplanationOfBenefit(oSource).FAddItemList);
  end;
  if (TFhirExplanationOfBenefit(oSource).FAdjudicationList = nil) then
  begin
    FAdjudicationList.free;
    FAdjudicationList := nil;
  end
  else
  begin
    if FAdjudicationList = nil then
      FAdjudicationList := TFhirExplanationOfBenefitItemAdjudicationList.Create;
    FAdjudicationList.Assign(TFhirExplanationOfBenefit(oSource).FAdjudicationList);
  end;
  if (TFhirExplanationOfBenefit(oSource).FTotalList = nil) then
  begin
    FTotalList.free;
    FTotalList := nil;
  end
  else
  begin
    if FTotalList = nil then
      FTotalList := TFhirExplanationOfBenefitTotalList.Create;
    FTotalList.Assign(TFhirExplanationOfBenefit(oSource).FTotalList);
  end;
  payment := TFhirExplanationOfBenefit(oSource).payment.Clone;
  formCode := TFhirExplanationOfBenefit(oSource).formCode.Clone;
  form := TFhirExplanationOfBenefit(oSource).form.Clone;
  if (TFhirExplanationOfBenefit(oSource).FProcessNoteList = nil) then
  begin
    FProcessNoteList.free;
    FProcessNoteList := nil;
  end
  else
  begin
    if FProcessNoteList = nil then
      FProcessNoteList := TFhirExplanationOfBenefitProcessNoteList.Create;
    FProcessNoteList.Assign(TFhirExplanationOfBenefit(oSource).FProcessNoteList);
  end;
  benefitPeriod := TFhirExplanationOfBenefit(oSource).benefitPeriod.Clone;
  if (TFhirExplanationOfBenefit(oSource).FBenefitBalanceList = nil) then
  begin
    FBenefitBalanceList.free;
    FBenefitBalanceList := nil;
  end
  else
  begin
    if FBenefitBalanceList = nil then
      FBenefitBalanceList := TFhirExplanationOfBenefitBenefitBalanceList.Create;
    FBenefitBalanceList.Assign(TFhirExplanationOfBenefit(oSource).FBenefitBalanceList);
  end;
end;

function TFhirExplanationOfBenefit.GetResourceType : TFhirResourceType;
begin
  result := frtExplanationOfBenefit;
end;

procedure TFhirExplanationOfBenefit.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'identifier') Then
    list.addAll(self, 'identifier', FIdentifierList);
  if (child_name = 'status') Then
     list.add(self.link, 'status', FStatus.Link);
  if (child_name = 'type') Then
     list.add(self.link, 'type', FType_.Link);
  if (child_name = 'subType') Then
     list.add(self.link, 'subType', FSubType.Link);
  if (child_name = 'use') Then
     list.add(self.link, 'use', FUse.Link);
  if (child_name = 'patient') Then
     list.add(self.link, 'patient', FPatient.Link);
  if (child_name = 'billablePeriod') Then
     list.add(self.link, 'billablePeriod', FBillablePeriod.Link);
  if (child_name = 'created') Then
     list.add(self.link, 'created', FCreated.Link);
  if (child_name = 'enterer') Then
     list.add(self.link, 'enterer', FEnterer.Link);
  if (child_name = 'insurer') Then
     list.add(self.link, 'insurer', FInsurer.Link);
  if (child_name = 'provider') Then
     list.add(self.link, 'provider', FProvider.Link);
  if (child_name = 'priority') Then
     list.add(self.link, 'priority', FPriority.Link);
  if (child_name = 'fundsReserveRequested') Then
     list.add(self.link, 'fundsReserveRequested', FFundsReserveRequested.Link);
  if (child_name = 'fundsReserve') Then
     list.add(self.link, 'fundsReserve', FFundsReserve.Link);
  if (child_name = 'related') Then
    list.addAll(self, 'related', FRelatedList);
  if (child_name = 'prescription') Then
     list.add(self.link, 'prescription', FPrescription.Link);
  if (child_name = 'originalPrescription') Then
     list.add(self.link, 'originalPrescription', FOriginalPrescription.Link);
  if (child_name = 'payee') Then
     list.add(self.link, 'payee', FPayee.Link);
  if (child_name = 'referral') Then
     list.add(self.link, 'referral', FReferral.Link);
  if (child_name = 'facility') Then
     list.add(self.link, 'facility', FFacility.Link);
  if (child_name = 'claim') Then
     list.add(self.link, 'claim', FClaim.Link);
  if (child_name = 'claimResponse') Then
     list.add(self.link, 'claimResponse', FClaimResponse.Link);
  if (child_name = 'outcome') Then
     list.add(self.link, 'outcome', FOutcome.Link);
  if (child_name = 'disposition') Then
     list.add(self.link, 'disposition', FDisposition.Link);
  if (child_name = 'preAuthRef') Then
    list.addAll(self, 'preAuthRef', FPreAuthRefList);
  if (child_name = 'preAuthRefPeriod') Then
    list.addAll(self, 'preAuthRefPeriod', FPreAuthRefPeriodList);
  if (child_name = 'careTeam') Then
    list.addAll(self, 'careTeam', FCareTeamList);
  if (child_name = 'supportingInfo') Then
    list.addAll(self, 'supportingInfo', FSupportingInfoList);
  if (child_name = 'diagnosis') Then
    list.addAll(self, 'diagnosis', FDiagnosisList);
  if (child_name = 'procedure') Then
    list.addAll(self, 'procedure', FProcedure_List);
  if (child_name = 'precedence') Then
     list.add(self.link, 'precedence', FPrecedence.Link);
  if (child_name = 'insurance') Then
    list.addAll(self, 'insurance', FInsuranceList);
  if (child_name = 'accident') Then
     list.add(self.link, 'accident', FAccident.Link);
  if (child_name = 'item') Then
    list.addAll(self, 'item', FItemList);
  if (child_name = 'addItem') Then
    list.addAll(self, 'addItem', FAddItemList);
  if (child_name = 'adjudication') Then
    list.addAll(self, 'adjudication', FAdjudicationList);
  if (child_name = 'total') Then
    list.addAll(self, 'total', FTotalList);
  if (child_name = 'payment') Then
     list.add(self.link, 'payment', FPayment.Link);
  if (child_name = 'formCode') Then
     list.add(self.link, 'formCode', FFormCode.Link);
  if (child_name = 'form') Then
     list.add(self.link, 'form', FForm.Link);
  if (child_name = 'processNote') Then
    list.addAll(self, 'processNote', FProcessNoteList);
  if (child_name = 'benefitPeriod') Then
     list.add(self.link, 'benefitPeriod', FBenefitPeriod.Link);
  if (child_name = 'benefitBalance') Then
    list.addAll(self, 'benefitBalance', FBenefitBalanceList);
end;

procedure TFhirExplanationOfBenefit.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'identifier', 'Identifier', true, TFhirIdentifier, FIdentifierList.Link));
  oList.add(TFHIRProperty.create(self, 'status', 'code', false, TFhirEnum, FStatus.Link));
  oList.add(TFHIRProperty.create(self, 'type', 'CodeableConcept', false, TFhirCodeableConcept, FType_.Link));
  oList.add(TFHIRProperty.create(self, 'subType', 'CodeableConcept', false, TFhirCodeableConcept, FSubType.Link));
  oList.add(TFHIRProperty.create(self, 'use', 'code', false, TFhirEnum, FUse.Link));
  oList.add(TFHIRProperty.create(self, 'patient', 'Reference', false, TFhirReference, FPatient.Link));
  oList.add(TFHIRProperty.create(self, 'billablePeriod', 'Period', false, TFhirPeriod, FBillablePeriod.Link));
  oList.add(TFHIRProperty.create(self, 'created', 'dateTime', false, TFhirDateTime, FCreated.Link));
  oList.add(TFHIRProperty.create(self, 'enterer', 'Reference', false, TFhirReference, FEnterer.Link));
  oList.add(TFHIRProperty.create(self, 'insurer', 'Reference', false, TFhirReference, FInsurer.Link));
  oList.add(TFHIRProperty.create(self, 'provider', 'Reference', false, TFhirReference, FProvider.Link));
  oList.add(TFHIRProperty.create(self, 'priority', 'CodeableConcept', false, TFhirCodeableConcept, FPriority.Link));
  oList.add(TFHIRProperty.create(self, 'fundsReserveRequested', 'CodeableConcept', false, TFhirCodeableConcept, FFundsReserveRequested.Link));
  oList.add(TFHIRProperty.create(self, 'fundsReserve', 'CodeableConcept', false, TFhirCodeableConcept, FFundsReserve.Link));
  oList.add(TFHIRProperty.create(self, 'related', 'BackboneElement', true, TFhirExplanationOfBenefitRelated, FRelatedList.Link));
  oList.add(TFHIRProperty.create(self, 'prescription', 'Reference', false, TFhirReference, FPrescription.Link));
  oList.add(TFHIRProperty.create(self, 'originalPrescription', 'Reference', false, TFhirReference, FOriginalPrescription.Link));
  oList.add(TFHIRProperty.create(self, 'payee', 'BackboneElement', false, TFhirExplanationOfBenefitPayee, FPayee.Link));
  oList.add(TFHIRProperty.create(self, 'referral', 'Reference', false, TFhirReference, FReferral.Link));
  oList.add(TFHIRProperty.create(self, 'facility', 'Reference', false, TFhirReference, FFacility.Link));
  oList.add(TFHIRProperty.create(self, 'claim', 'Reference', false, TFhirReference, FClaim.Link));
  oList.add(TFHIRProperty.create(self, 'claimResponse', 'Reference', false, TFhirReference, FClaimResponse.Link));
  oList.add(TFHIRProperty.create(self, 'outcome', 'code', false, TFhirEnum, FOutcome.Link));
  oList.add(TFHIRProperty.create(self, 'disposition', 'string', false, TFhirString, FDisposition.Link));
  oList.add(TFHIRProperty.create(self, 'preAuthRef', 'string', true, TFhirString, FPreAuthRefList.Link));
  oList.add(TFHIRProperty.create(self, 'preAuthRefPeriod', 'Period', true, TFhirPeriod, FPreAuthRefPeriodList.Link));
  oList.add(TFHIRProperty.create(self, 'careTeam', 'BackboneElement', true, TFhirExplanationOfBenefitCareTeam, FCareTeamList.Link));
  oList.add(TFHIRProperty.create(self, 'supportingInfo', 'BackboneElement', true, TFhirExplanationOfBenefitSupportingInfo, FSupportingInfoList.Link));
  oList.add(TFHIRProperty.create(self, 'diagnosis', 'BackboneElement', true, TFhirExplanationOfBenefitDiagnosis, FDiagnosisList.Link));
  oList.add(TFHIRProperty.create(self, 'procedure', 'BackboneElement', true, TFhirExplanationOfBenefitProcedure, FProcedure_List.Link));
  oList.add(TFHIRProperty.create(self, 'precedence', 'positiveInt', false, TFhirPositiveInt, FPrecedence.Link));
  oList.add(TFHIRProperty.create(self, 'insurance', 'BackboneElement', true, TFhirExplanationOfBenefitInsurance, FInsuranceList.Link));
  oList.add(TFHIRProperty.create(self, 'accident', 'BackboneElement', false, TFhirExplanationOfBenefitAccident, FAccident.Link));
  oList.add(TFHIRProperty.create(self, 'item', 'BackboneElement', true, TFhirExplanationOfBenefitItem, FItemList.Link));
  oList.add(TFHIRProperty.create(self, 'addItem', 'BackboneElement', true, TFhirExplanationOfBenefitAddItem, FAddItemList.Link));
  oList.add(TFHIRProperty.create(self, 'adjudication', '', true, TFhirExplanationOfBenefitItemAdjudication, FAdjudicationList.Link));
  oList.add(TFHIRProperty.create(self, 'total', 'BackboneElement', true, TFhirExplanationOfBenefitTotal, FTotalList.Link));
  oList.add(TFHIRProperty.create(self, 'payment', 'BackboneElement', false, TFhirExplanationOfBenefitPayment, FPayment.Link));
  oList.add(TFHIRProperty.create(self, 'formCode', 'CodeableConcept', false, TFhirCodeableConcept, FFormCode.Link));
  oList.add(TFHIRProperty.create(self, 'form', 'Attachment', false, TFhirAttachment, FForm.Link));
  oList.add(TFHIRProperty.create(self, 'processNote', 'BackboneElement', true, TFhirExplanationOfBenefitProcessNote, FProcessNoteList.Link));
  oList.add(TFHIRProperty.create(self, 'benefitPeriod', 'Period', false, TFhirPeriod, FBenefitPeriod.Link));
  oList.add(TFHIRProperty.create(self, 'benefitBalance', 'BackboneElement', true, TFhirExplanationOfBenefitBenefitBalance, FBenefitBalanceList.Link));
end;

function TFhirExplanationOfBenefit.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'identifier') then
  begin
    IdentifierList.add(propValue as TFhirIdentifier);
    result := propValue;
  end
  else if (propName = 'status') then
  begin
    StatusElement := asEnum(SYSTEMS_TFhirExplanationOfBenefitStatusEnum, CODES_TFhirExplanationOfBenefitStatusEnum, propValue);
    result := propValue;
  end
  else if (propName = 'type') then
  begin
    Type_ := propValue as TFhirCodeableConcept;
    result := propValue;
  end
  else if (propName = 'subType') then
  begin
    SubType := propValue as TFhirCodeableConcept;
    result := propValue;
  end
  else if (propName = 'use') then
  begin
    UseElement := asEnum(SYSTEMS_TFhirUseEnum, CODES_TFhirUseEnum, propValue);
    result := propValue;
  end
  else if (propName = 'patient') then
  begin
    Patient := propValue as TFhirReference;
    result := propValue;
  end
  else if (propName = 'billablePeriod') then
  begin
    BillablePeriod := propValue as TFhirPeriod;
    result := propValue;
  end
  else if (propName = 'created') then
  begin
    CreatedElement := asDateTime(propValue);
    result := propValue;
  end
  else if (propName = 'enterer') then
  begin
    Enterer := propValue as TFhirReference;
    result := propValue;
  end
  else if (propName = 'insurer') then
  begin
    Insurer := propValue as TFhirReference;
    result := propValue;
  end
  else if (propName = 'provider') then
  begin
    Provider := propValue as TFhirReference;
    result := propValue;
  end
  else if (propName = 'priority') then
  begin
    Priority := propValue as TFhirCodeableConcept;
    result := propValue;
  end
  else if (propName = 'fundsReserveRequested') then
  begin
    FundsReserveRequested := propValue as TFhirCodeableConcept;
    result := propValue;
  end
  else if (propName = 'fundsReserve') then
  begin
    FundsReserve := propValue as TFhirCodeableConcept;
    result := propValue;
  end
  else if (propName = 'related') then
  begin
    RelatedList.add(propValue as TFhirExplanationOfBenefitRelated);
    result := propValue;
  end
  else if (propName = 'prescription') then
  begin
    Prescription := propValue as TFhirReference;
    result := propValue;
  end
  else if (propName = 'originalPrescription') then
  begin
    OriginalPrescription := propValue as TFhirReference;
    result := propValue;
  end
  else if (propName = 'payee') then
  begin
    Payee := propValue as TFhirExplanationOfBenefitPayee;
    result := propValue;
  end
  else if (propName = 'referral') then
  begin
    Referral := propValue as TFhirReference;
    result := propValue;
  end
  else if (propName = 'facility') then
  begin
    Facility := propValue as TFhirReference;
    result := propValue;
  end
  else if (propName = 'claim') then
  begin
    Claim := propValue as TFhirReference;
    result := propValue;
  end
  else if (propName = 'claimResponse') then
  begin
    ClaimResponse := propValue as TFhirReference;
    result := propValue;
  end
  else if (propName = 'outcome') then
  begin
    OutcomeElement := asEnum(SYSTEMS_TFhirClaimProcessingCodesEnum, CODES_TFhirClaimProcessingCodesEnum, propValue);
    result := propValue;
  end
  else if (propName = 'disposition') then
  begin
    DispositionElement := asString(propValue);
    result := propValue;
  end
  else if (propName = 'preAuthRef') then
  begin
    PreAuthRefList.add(asString(propValue)){2};     result := propValue;

  end
  else if (propName = 'preAuthRefPeriod') then
  begin
    PreAuthRefPeriodList.add(propValue as TFhirPeriod);
    result := propValue;
  end
  else if (propName = 'careTeam') then
  begin
    CareTeamList.add(propValue as TFhirExplanationOfBenefitCareTeam);
    result := propValue;
  end
  else if (propName = 'supportingInfo') then
  begin
    SupportingInfoList.add(propValue as TFhirExplanationOfBenefitSupportingInfo);
    result := propValue;
  end
  else if (propName = 'diagnosis') then
  begin
    DiagnosisList.add(propValue as TFhirExplanationOfBenefitDiagnosis);
    result := propValue;
  end
  else if (propName = 'procedure') then
  begin
    Procedure_List.add(propValue as TFhirExplanationOfBenefitProcedure);
    result := propValue;
  end
  else if (propName = 'precedence') then
  begin
    PrecedenceElement := asPositiveInt(propValue);
    result := propValue;
  end
  else if (propName = 'insurance') then
  begin
    InsuranceList.add(propValue as TFhirExplanationOfBenefitInsurance);
    result := propValue;
  end
  else if (propName = 'accident') then
  begin
    Accident := propValue as TFhirExplanationOfBenefitAccident;
    result := propValue;
  end
  else if (propName = 'item') then
  begin
    ItemList.add(propValue as TFhirExplanationOfBenefitItem);
    result := propValue;
  end
  else if (propName = 'addItem') then
  begin
    AddItemList.add(propValue as TFhirExplanationOfBenefitAddItem);
    result := propValue;
  end
  else if (propName = 'adjudication') then
  begin
    AdjudicationList.add(propValue as TFhirExplanationOfBenefitItemAdjudication);
    result := propValue;
  end
  else if (propName = 'total') then
  begin
    TotalList.add(propValue as TFhirExplanationOfBenefitTotal);
    result := propValue;
  end
  else if (propName = 'payment') then
  begin
    Payment := propValue as TFhirExplanationOfBenefitPayment;
    result := propValue;
  end
  else if (propName = 'formCode') then
  begin
    FormCode := propValue as TFhirCodeableConcept;
    result := propValue;
  end
  else if (propName = 'form') then
  begin
    Form := propValue as TFhirAttachment;
    result := propValue;
  end
  else if (propName = 'processNote') then
  begin
    ProcessNoteList.add(propValue as TFhirExplanationOfBenefitProcessNote);
    result := propValue;
  end
  else if (propName = 'benefitPeriod') then
  begin
    BenefitPeriod := propValue as TFhirPeriod;
    result := propValue;
  end
  else if (propName = 'benefitBalance') then
  begin
    BenefitBalanceList.add(propValue as TFhirExplanationOfBenefitBenefitBalance);
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirExplanationOfBenefit.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'identifier') then IdentifierList.insertItem(index, propValue as TFhirIdentifier)
  else if (propName = 'related') then RelatedList.insertItem(index, propValue as TFhirExplanationOfBenefitRelated)
  else if (propName = 'preAuthRef') then PreAuthRefList.insertItem(index, asString(propValue))
  else if (propName = 'preAuthRefPeriod') then PreAuthRefPeriodList.insertItem(index, propValue as TFhirPeriod)
  else if (propName = 'careTeam') then CareTeamList.insertItem(index, propValue as TFhirExplanationOfBenefitCareTeam)
  else if (propName = 'supportingInfo') then SupportingInfoList.insertItem(index, propValue as TFhirExplanationOfBenefitSupportingInfo)
  else if (propName = 'diagnosis') then DiagnosisList.insertItem(index, propValue as TFhirExplanationOfBenefitDiagnosis)
  else if (propName = 'procedure') then Procedure_List.insertItem(index, propValue as TFhirExplanationOfBenefitProcedure)
  else if (propName = 'insurance') then InsuranceList.insertItem(index, propValue as TFhirExplanationOfBenefitInsurance)
  else if (propName = 'item') then ItemList.insertItem(index, propValue as TFhirExplanationOfBenefitItem)
  else if (propName = 'addItem') then AddItemList.insertItem(index, propValue as TFhirExplanationOfBenefitAddItem)
  else if (propName = 'adjudication') then AdjudicationList.insertItem(index, propValue as TFhirExplanationOfBenefitItemAdjudication)
  else if (propName = 'total') then TotalList.insertItem(index, propValue as TFhirExplanationOfBenefitTotal)
  else if (propName = 'processNote') then ProcessNoteList.insertItem(index, propValue as TFhirExplanationOfBenefitProcessNote)
  else if (propName = 'benefitBalance') then BenefitBalanceList.insertItem(index, propValue as TFhirExplanationOfBenefitBenefitBalance)
  else inherited;
end;

function TFhirExplanationOfBenefit.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'identifier') then result := IdentifierList.new()
  else if (propName = 'status') then result := TFhirEnum.create(SYSTEMS_TFhirExplanationOfBenefitStatusEnum[ExplanationOfBenefitStatusNull], CODES_TFhirExplanationOfBenefitStatusEnum[ExplanationOfBenefitStatusNull]) 
  else if (propName = 'type') then result := TFhirCodeableConcept.create()
  else if (propName = 'subType') then result := TFhirCodeableConcept.create()
  else if (propName = 'use') then result := TFhirEnum.create(SYSTEMS_TFhirUseEnum[UseNull], CODES_TFhirUseEnum[UseNull]) 
  else if (propName = 'patient') then result := TFhirReference.create()
  else if (propName = 'billablePeriod') then result := TFhirPeriod.create()
  else if (propName = 'created') then result := TFhirDateTime.create()
  else if (propName = 'enterer') then result := TFhirReference.create()
  else if (propName = 'insurer') then result := TFhirReference.create()
  else if (propName = 'provider') then result := TFhirReference.create()
  else if (propName = 'priority') then result := TFhirCodeableConcept.create()
  else if (propName = 'fundsReserveRequested') then result := TFhirCodeableConcept.create()
  else if (propName = 'fundsReserve') then result := TFhirCodeableConcept.create()
  else if (propName = 'related') then result := RelatedList.new()
  else if (propName = 'prescription') then result := TFhirReference.create()
  else if (propName = 'originalPrescription') then result := TFhirReference.create()
  else if (propName = 'payee') then result := TFhirExplanationOfBenefitPayee.create()
  else if (propName = 'referral') then result := TFhirReference.create()
  else if (propName = 'facility') then result := TFhirReference.create()
  else if (propName = 'claim') then result := TFhirReference.create()
  else if (propName = 'claimResponse') then result := TFhirReference.create()
  else if (propName = 'outcome') then result := TFhirEnum.create(SYSTEMS_TFhirClaimProcessingCodesEnum[ClaimProcessingCodesNull], CODES_TFhirClaimProcessingCodesEnum[ClaimProcessingCodesNull]) 
  else if (propName = 'disposition') then result := TFhirString.create()
  else if (propName = 'preAuthRef') then result := PreAuthRefList.new()
  else if (propName = 'preAuthRefPeriod') then result := PreAuthRefPeriodList.new()
  else if (propName = 'careTeam') then result := CareTeamList.new()
  else if (propName = 'supportingInfo') then result := SupportingInfoList.new()
  else if (propName = 'diagnosis') then result := DiagnosisList.new()
  else if (propName = 'procedure') then result := Procedure_List.new()
  else if (propName = 'precedence') then result := TFhirPositiveInt.create()
  else if (propName = 'insurance') then result := InsuranceList.new()
  else if (propName = 'accident') then result := TFhirExplanationOfBenefitAccident.create()
  else if (propName = 'item') then result := ItemList.new()
  else if (propName = 'addItem') then result := AddItemList.new()
  else if (propName = 'adjudication') then result := AdjudicationList.new()
  else if (propName = 'total') then result := TotalList.new()
  else if (propName = 'payment') then result := TFhirExplanationOfBenefitPayment.create()
  else if (propName = 'formCode') then result := TFhirCodeableConcept.create()
  else if (propName = 'form') then result := TFhirAttachment.create()
  else if (propName = 'processNote') then result := ProcessNoteList.new()
  else if (propName = 'benefitPeriod') then result := TFhirPeriod.create()
  else if (propName = 'benefitBalance') then result := BenefitBalanceList.new()
  else result := inherited createPropertyValue(propName);
end;

function TFhirExplanationOfBenefit.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'identifier') then result := 'Identifier'
  else if (propName = 'status') then result := 'code'
  else if (propName = 'type') then result := 'CodeableConcept'
  else if (propName = 'subType') then result := 'CodeableConcept'
  else if (propName = 'use') then result := 'code'
  else if (propName = 'patient') then result := 'Reference'
  else if (propName = 'billablePeriod') then result := 'Period'
  else if (propName = 'created') then result := 'dateTime'
  else if (propName = 'enterer') then result := 'Reference'
  else if (propName = 'insurer') then result := 'Reference'
  else if (propName = 'provider') then result := 'Reference'
  else if (propName = 'priority') then result := 'CodeableConcept'
  else if (propName = 'fundsReserveRequested') then result := 'CodeableConcept'
  else if (propName = 'fundsReserve') then result := 'CodeableConcept'
  else if (propName = 'related') then result := 'BackboneElement'
  else if (propName = 'prescription') then result := 'Reference'
  else if (propName = 'originalPrescription') then result := 'Reference'
  else if (propName = 'payee') then result := 'BackboneElement'
  else if (propName = 'referral') then result := 'Reference'
  else if (propName = 'facility') then result := 'Reference'
  else if (propName = 'claim') then result := 'Reference'
  else if (propName = 'claimResponse') then result := 'Reference'
  else if (propName = 'outcome') then result := 'code'
  else if (propName = 'disposition') then result := 'string'
  else if (propName = 'preAuthRef') then result := 'string'
  else if (propName = 'preAuthRefPeriod') then result := 'Period'
  else if (propName = 'careTeam') then result := 'BackboneElement'
  else if (propName = 'supportingInfo') then result := 'BackboneElement'
  else if (propName = 'diagnosis') then result := 'BackboneElement'
  else if (propName = 'procedure') then result := 'BackboneElement'
  else if (propName = 'precedence') then result := 'positiveInt'
  else if (propName = 'insurance') then result := 'BackboneElement'
  else if (propName = 'accident') then result := 'BackboneElement'
  else if (propName = 'item') then result := 'BackboneElement'
  else if (propName = 'addItem') then result := 'BackboneElement'
  else if (propName = 'adjudication') then result := ''
  else if (propName = 'total') then result := 'BackboneElement'
  else if (propName = 'payment') then result := 'BackboneElement'
  else if (propName = 'formCode') then result := 'CodeableConcept'
  else if (propName = 'form') then result := 'Attachment'
  else if (propName = 'processNote') then result := 'BackboneElement'
  else if (propName = 'benefitPeriod') then result := 'Period'
  else if (propName = 'benefitBalance') then result := 'BackboneElement'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirExplanationOfBenefit.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'identifier') then deletePropertyValue('identifier', IdentifierList, value)
  else if (propName = 'status') then StatusElement := nil
  else if (propName = 'type') then Type_Element := nil
  else if (propName = 'subType') then SubTypeElement := nil
  else if (propName = 'use') then UseElement := nil
  else if (propName = 'patient') then PatientElement := nil
  else if (propName = 'billablePeriod') then BillablePeriodElement := nil
  else if (propName = 'created') then CreatedElement := nil
  else if (propName = 'enterer') then EntererElement := nil
  else if (propName = 'insurer') then InsurerElement := nil
  else if (propName = 'provider') then ProviderElement := nil
  else if (propName = 'priority') then PriorityElement := nil
  else if (propName = 'fundsReserveRequested') then FundsReserveRequestedElement := nil
  else if (propName = 'fundsReserve') then FundsReserveElement := nil
  else if (propName = 'related') then deletePropertyValue('related', RelatedList, value)
  else if (propName = 'prescription') then PrescriptionElement := nil
  else if (propName = 'originalPrescription') then OriginalPrescriptionElement := nil
  else if (propName = 'payee') then PayeeElement := nil
  else if (propName = 'referral') then ReferralElement := nil
  else if (propName = 'facility') then FacilityElement := nil
  else if (propName = 'claim') then ClaimElement := nil
  else if (propName = 'claimResponse') then ClaimResponseElement := nil
  else if (propName = 'outcome') then OutcomeElement := nil
  else if (propName = 'disposition') then DispositionElement := nil
  else if (propName = 'preAuthRef') then deletePropertyValue('preAuthRef', PreAuthRefList, value)
  else if (propName = 'preAuthRefPeriod') then deletePropertyValue('preAuthRefPeriod', PreAuthRefPeriodList, value)
  else if (propName = 'careTeam') then deletePropertyValue('careTeam', CareTeamList, value)
  else if (propName = 'supportingInfo') then deletePropertyValue('supportingInfo', SupportingInfoList, value)
  else if (propName = 'diagnosis') then deletePropertyValue('diagnosis', DiagnosisList, value)
  else if (propName = 'procedure') then deletePropertyValue('procedure', Procedure_List, value)
  else if (propName = 'precedence') then PrecedenceElement := nil
  else if (propName = 'insurance') then deletePropertyValue('insurance', InsuranceList, value)
  else if (propName = 'accident') then AccidentElement := nil
  else if (propName = 'item') then deletePropertyValue('item', ItemList, value)
  else if (propName = 'addItem') then deletePropertyValue('addItem', AddItemList, value)
  else if (propName = 'adjudication') then deletePropertyValue('adjudication', AdjudicationList, value)
  else if (propName = 'total') then deletePropertyValue('total', TotalList, value)
  else if (propName = 'payment') then PaymentElement := nil
  else if (propName = 'formCode') then FormCodeElement := nil
  else if (propName = 'form') then FormElement := nil
  else if (propName = 'processNote') then deletePropertyValue('processNote', ProcessNoteList, value)
  else if (propName = 'benefitPeriod') then BenefitPeriodElement := nil
  else if (propName = 'benefitBalance') then deletePropertyValue('benefitBalance', BenefitBalanceList, value)
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirExplanationOfBenefit.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'identifier') then replacePropertyValue('identifier', IdentifierList, existing, new)
  else if (propName = 'status') then StatusElement := asEnum(SYSTEMS_TFhirExplanationOfBenefitStatusEnum, CODES_TFhirExplanationOfBenefitStatusEnum, new)
  else if (propName = 'type') then Type_Element := new as TFhirCodeableConcept
  else if (propName = 'subType') then SubTypeElement := new as TFhirCodeableConcept
  else if (propName = 'use') then UseElement := asEnum(SYSTEMS_TFhirUseEnum, CODES_TFhirUseEnum, new)
  else if (propName = 'patient') then PatientElement := new as TFhirReference
  else if (propName = 'billablePeriod') then BillablePeriodElement := new as TFhirPeriod
  else if (propName = 'created') then CreatedElement := asDateTime(new)
  else if (propName = 'enterer') then EntererElement := new as TFhirReference
  else if (propName = 'insurer') then InsurerElement := new as TFhirReference
  else if (propName = 'provider') then ProviderElement := new as TFhirReference
  else if (propName = 'priority') then PriorityElement := new as TFhirCodeableConcept
  else if (propName = 'fundsReserveRequested') then FundsReserveRequestedElement := new as TFhirCodeableConcept
  else if (propName = 'fundsReserve') then FundsReserveElement := new as TFhirCodeableConcept
  else if (propName = 'related') then replacePropertyValue('related', RelatedList, existing, new)
  else if (propName = 'prescription') then PrescriptionElement := new as TFhirReference
  else if (propName = 'originalPrescription') then OriginalPrescriptionElement := new as TFhirReference
  else if (propName = 'payee') then PayeeElement := new as TFhirExplanationOfBenefitPayee
  else if (propName = 'referral') then ReferralElement := new as TFhirReference
  else if (propName = 'facility') then FacilityElement := new as TFhirReference
  else if (propName = 'claim') then ClaimElement := new as TFhirReference
  else if (propName = 'claimResponse') then ClaimResponseElement := new as TFhirReference
  else if (propName = 'outcome') then OutcomeElement := asEnum(SYSTEMS_TFhirClaimProcessingCodesEnum, CODES_TFhirClaimProcessingCodesEnum, new)
  else if (propName = 'disposition') then DispositionElement := asString(new)
  else if (propName = 'preAuthRef') then replacePropertyValue('preAuthRef', PreAuthRefList, existing, new)
  else if (propName = 'preAuthRefPeriod') then replacePropertyValue('preAuthRefPeriod', PreAuthRefPeriodList, existing, new)
  else if (propName = 'careTeam') then replacePropertyValue('careTeam', CareTeamList, existing, new)
  else if (propName = 'supportingInfo') then replacePropertyValue('supportingInfo', SupportingInfoList, existing, new)
  else if (propName = 'diagnosis') then replacePropertyValue('diagnosis', DiagnosisList, existing, new)
  else if (propName = 'procedure') then replacePropertyValue('procedure', Procedure_List, existing, new)
  else if (propName = 'precedence') then PrecedenceElement := asPositiveInt(new)
  else if (propName = 'insurance') then replacePropertyValue('insurance', InsuranceList, existing, new)
  else if (propName = 'accident') then AccidentElement := new as TFhirExplanationOfBenefitAccident
  else if (propName = 'item') then replacePropertyValue('item', ItemList, existing, new)
  else if (propName = 'addItem') then replacePropertyValue('addItem', AddItemList, existing, new)
  else if (propName = 'adjudication') then replacePropertyValue('adjudication', AdjudicationList, existing, new)
  else if (propName = 'total') then replacePropertyValue('total', TotalList, existing, new)
  else if (propName = 'payment') then PaymentElement := new as TFhirExplanationOfBenefitPayment
  else if (propName = 'formCode') then FormCodeElement := new as TFhirCodeableConcept
  else if (propName = 'form') then FormElement := new as TFhirAttachment
  else if (propName = 'processNote') then replacePropertyValue('processNote', ProcessNoteList, existing, new)
  else if (propName = 'benefitPeriod') then BenefitPeriodElement := new as TFhirPeriod
  else if (propName = 'benefitBalance') then replacePropertyValue('benefitBalance', BenefitBalanceList, existing, new)
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirExplanationOfBenefit.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'identifier') then IdentifierList.move(source, destination)
  else if (propName = 'related') then RelatedList.move(source, destination)
  else if (propName = 'preAuthRef') then PreAuthRefList.move(source, destination)
  else if (propName = 'preAuthRefPeriod') then PreAuthRefPeriodList.move(source, destination)
  else if (propName = 'careTeam') then CareTeamList.move(source, destination)
  else if (propName = 'supportingInfo') then SupportingInfoList.move(source, destination)
  else if (propName = 'diagnosis') then DiagnosisList.move(source, destination)
  else if (propName = 'procedure') then Procedure_List.move(source, destination)
  else if (propName = 'insurance') then InsuranceList.move(source, destination)
  else if (propName = 'item') then ItemList.move(source, destination)
  else if (propName = 'addItem') then AddItemList.move(source, destination)
  else if (propName = 'adjudication') then AdjudicationList.move(source, destination)
  else if (propName = 'total') then TotalList.move(source, destination)
  else if (propName = 'processNote') then ProcessNoteList.move(source, destination)
  else if (propName = 'benefitBalance') then BenefitBalanceList.move(source, destination)
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirExplanationOfBenefit.fhirType : string;
begin
  result := 'ExplanationOfBenefit';
end;

function TFhirExplanationOfBenefit.Link : TFhirExplanationOfBenefit;
begin
  result := TFhirExplanationOfBenefit(inherited Link);
end;

function TFhirExplanationOfBenefit.Clone : TFhirExplanationOfBenefit;
begin
  result := TFhirExplanationOfBenefit(inherited Clone);
end;

function TFhirExplanationOfBenefit.equals(other : TObject) : boolean; 
var
  o : TFhirExplanationOfBenefit;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirExplanationOfBenefit)) then
    result := false
  else
  begin
    o := TFhirExplanationOfBenefit(other);
    result := compareDeep(identifierList, o.identifierList, true) and compareDeep(statusElement, o.statusElement, true) and 
      compareDeep(type_Element, o.type_Element, true) and compareDeep(subTypeElement, o.subTypeElement, true) and 
      compareDeep(useElement, o.useElement, true) and compareDeep(patientElement, o.patientElement, true) and 
      compareDeep(billablePeriodElement, o.billablePeriodElement, true) and compareDeep(createdElement, o.createdElement, true) and 
      compareDeep(entererElement, o.entererElement, true) and compareDeep(insurerElement, o.insurerElement, true) and 
      compareDeep(providerElement, o.providerElement, true) and compareDeep(priorityElement, o.priorityElement, true) and 
      compareDeep(fundsReserveRequestedElement, o.fundsReserveRequestedElement, true) and 
      compareDeep(fundsReserveElement, o.fundsReserveElement, true) and compareDeep(relatedList, o.relatedList, true) and 
      compareDeep(prescriptionElement, o.prescriptionElement, true) and compareDeep(originalPrescriptionElement, o.originalPrescriptionElement, true) and 
      compareDeep(payeeElement, o.payeeElement, true) and compareDeep(referralElement, o.referralElement, true) and 
      compareDeep(facilityElement, o.facilityElement, true) and compareDeep(claimElement, o.claimElement, true) and 
      compareDeep(claimResponseElement, o.claimResponseElement, true) and compareDeep(outcomeElement, o.outcomeElement, true) and 
      compareDeep(dispositionElement, o.dispositionElement, true) and compareDeep(preAuthRefList, o.preAuthRefList, true) and 
      compareDeep(preAuthRefPeriodList, o.preAuthRefPeriodList, true) and compareDeep(careTeamList, o.careTeamList, true) and 
      compareDeep(supportingInfoList, o.supportingInfoList, true) and compareDeep(diagnosisList, o.diagnosisList, true) and 
      compareDeep(procedure_List, o.procedure_List, true) and compareDeep(precedenceElement, o.precedenceElement, true) and 
      compareDeep(insuranceList, o.insuranceList, true) and compareDeep(accidentElement, o.accidentElement, true) and 
      compareDeep(itemList, o.itemList, true) and compareDeep(addItemList, o.addItemList, true) and 
      compareDeep(adjudicationList, o.adjudicationList, true) and compareDeep(totalList, o.totalList, true) and 
      compareDeep(paymentElement, o.paymentElement, true) and compareDeep(formCodeElement, o.formCodeElement, true) and 
      compareDeep(formElement, o.formElement, true) and compareDeep(processNoteList, o.processNoteList, true) and 
      compareDeep(benefitPeriodElement, o.benefitPeriodElement, true) and compareDeep(benefitBalanceList, o.benefitBalanceList, true);
  end;
end;

function TFhirExplanationOfBenefit.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FidentifierList) and isEmptyProp(FStatus) and isEmptyProp(FType_) and isEmptyProp(FSubType) and isEmptyProp(FUse) and isEmptyProp(FPatient) and isEmptyProp(FBillablePeriod) and isEmptyProp(FCreated) and isEmptyProp(FEnterer) and isEmptyProp(FInsurer) and isEmptyProp(FProvider) and isEmptyProp(FPriority) and isEmptyProp(FFundsReserveRequested) and isEmptyProp(FFundsReserve) and isEmptyProp(FrelatedList) and isEmptyProp(FPrescription) and isEmptyProp(FOriginalPrescription) and isEmptyProp(FPayee) and isEmptyProp(FReferral) and isEmptyProp(FFacility) and isEmptyProp(FClaim) and isEmptyProp(FClaimResponse) and isEmptyProp(FOutcome) and isEmptyProp(FDisposition) and isEmptyProp(FpreAuthRefList) and isEmptyProp(FpreAuthRefPeriodList) and isEmptyProp(FcareTeamList) and isEmptyProp(FsupportingInfoList) and isEmptyProp(FdiagnosisList) and isEmptyProp(Fprocedure_List) and isEmptyProp(FPrecedence) and isEmptyProp(FinsuranceList) and isEmptyProp(FAccident)
       and isEmptyProp(FitemList) and isEmptyProp(FaddItemList) and isEmptyProp(FadjudicationList) and isEmptyProp(FtotalList) and isEmptyProp(FPayment) and isEmptyProp(FFormCode) and isEmptyProp(FForm) and isEmptyProp(FprocessNoteList) and isEmptyProp(FBenefitPeriod) and isEmptyProp(FbenefitBalanceList);
end;

procedure TFhirExplanationOfBenefit.listFieldsInOrder(fields : TStringList);
begin
  inherited listFieldsInOrder(fields);
  fields.add('identifier');
  fields.add('status');
  fields.add('type');
  fields.add('subType');
  fields.add('use');
  fields.add('patient');
  fields.add('billablePeriod');
  fields.add('created');
  fields.add('enterer');
  fields.add('insurer');
  fields.add('provider');
  fields.add('priority');
  fields.add('fundsReserveRequested');
  fields.add('fundsReserve');
  fields.add('related');
  fields.add('prescription');
  fields.add('originalPrescription');
  fields.add('payee');
  fields.add('referral');
  fields.add('facility');
  fields.add('claim');
  fields.add('claimResponse');
  fields.add('outcome');
  fields.add('disposition');
  fields.add('preAuthRef');
  fields.add('preAuthRefPeriod');
  fields.add('careTeam');
  fields.add('supportingInfo');
  fields.add('diagnosis');
  fields.add('procedure');
  fields.add('precedence');
  fields.add('insurance');
  fields.add('accident');
  fields.add('item');
  fields.add('addItem');
  fields.add('adjudication');
  fields.add('total');
  fields.add('payment');
  fields.add('formCode');
  fields.add('form');
  fields.add('processNote');
  fields.add('benefitPeriod');
  fields.add('benefitBalance');
end;

function TFhirExplanationOfBenefit.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FIdentifierList.sizeInBytes(magic));
  inc(result, FRelatedList.sizeInBytes(magic));
  inc(result, FPreAuthRefList.sizeInBytes(magic));
  inc(result, FPreAuthRefPeriodList.sizeInBytes(magic));
  inc(result, FCareTeamList.sizeInBytes(magic));
  inc(result, FSupportingInfoList.sizeInBytes(magic));
  inc(result, FDiagnosisList.sizeInBytes(magic));
  inc(result, FProcedure_List.sizeInBytes(magic));
  inc(result, FInsuranceList.sizeInBytes(magic));
  inc(result, FItemList.sizeInBytes(magic));
  inc(result, FAddItemList.sizeInBytes(magic));
  inc(result, FAdjudicationList.sizeInBytes(magic));
  inc(result, FTotalList.sizeInBytes(magic));
  inc(result, FProcessNoteList.sizeInBytes(magic));
  inc(result, FBenefitBalanceList.sizeInBytes(magic));
end;

function TFhirExplanationOfBenefit.GetIdentifierList : TFhirIdentifierList;
begin
  if FIdentifierList = nil then
    FIdentifierList := TFhirIdentifierList.Create;
  result := FIdentifierList;
end;

function TFhirExplanationOfBenefit.GetHasIdentifierList : boolean;
begin
  result := (FIdentifierList <> nil) and (FIdentifierList.count > 0);
end;

procedure TFhirExplanationOfBenefit.SetStatus(value : TFhirEnum);
begin
  FStatus.free;
  FStatus := value;
end;

function TFhirExplanationOfBenefit.GetStatusST : TFhirExplanationOfBenefitStatusEnum;
begin
  if FStatus = nil then
    result := TFhirExplanationOfBenefitStatusEnum(0)
  else
    result := TFhirExplanationOfBenefitStatusEnum(StringArrayIndexOfSensitive(CODES_TFhirExplanationOfBenefitStatusEnum, FStatus.value));
end;

procedure TFhirExplanationOfBenefit.SetStatusST(value : TFhirExplanationOfBenefitStatusEnum);
begin
  if ord(value) = 0 then
    StatusElement := nil
  else
    StatusElement := TFhirEnum.create(SYSTEMS_TFhirExplanationOfBenefitStatusEnum[value], CODES_TFhirExplanationOfBenefitStatusEnum[value]);
end;

procedure TFhirExplanationOfBenefit.SetType_(value : TFhirCodeableConcept);
begin
  FType_.free;
  FType_ := value;
end;

procedure TFhirExplanationOfBenefit.SetSubType(value : TFhirCodeableConcept);
begin
  FSubType.free;
  FSubType := value;
end;

procedure TFhirExplanationOfBenefit.SetUse(value : TFhirEnum);
begin
  FUse.free;
  FUse := value;
end;

function TFhirExplanationOfBenefit.GetUseST : TFhirUseEnum;
begin
  if FUse = nil then
    result := TFhirUseEnum(0)
  else
    result := TFhirUseEnum(StringArrayIndexOfSensitive(CODES_TFhirUseEnum, FUse.value));
end;

procedure TFhirExplanationOfBenefit.SetUseST(value : TFhirUseEnum);
begin
  if ord(value) = 0 then
    UseElement := nil
  else
    UseElement := TFhirEnum.create(SYSTEMS_TFhirUseEnum[value], CODES_TFhirUseEnum[value]);
end;

procedure TFhirExplanationOfBenefit.SetPatient(value : TFhirReference);
begin
  FPatient.free;
  FPatient := value;
end;

procedure TFhirExplanationOfBenefit.SetBillablePeriod(value : TFhirPeriod);
begin
  FBillablePeriod.free;
  FBillablePeriod := value;
end;

procedure TFhirExplanationOfBenefit.SetCreated(value : TFhirDateTime);
begin
  FCreated.free;
  FCreated := value;
end;

function TFhirExplanationOfBenefit.GetCreatedST : TFslDateTime;
begin
  if FCreated = nil then
    result := TFslDateTime.makeNull
  else
    result := FCreated.value;
end;

procedure TFhirExplanationOfBenefit.SetCreatedST(value : TFslDateTime);
begin
  if FCreated = nil then
    FCreated := TFhirDateTime.create;
  FCreated.value := value
end;

procedure TFhirExplanationOfBenefit.SetEnterer(value : TFhirReference);
begin
  FEnterer.free;
  FEnterer := value;
end;

procedure TFhirExplanationOfBenefit.SetInsurer(value : TFhirReference);
begin
  FInsurer.free;
  FInsurer := value;
end;

procedure TFhirExplanationOfBenefit.SetProvider(value : TFhirReference);
begin
  FProvider.free;
  FProvider := value;
end;

procedure TFhirExplanationOfBenefit.SetPriority(value : TFhirCodeableConcept);
begin
  FPriority.free;
  FPriority := value;
end;

procedure TFhirExplanationOfBenefit.SetFundsReserveRequested(value : TFhirCodeableConcept);
begin
  FFundsReserveRequested.free;
  FFundsReserveRequested := value;
end;

procedure TFhirExplanationOfBenefit.SetFundsReserve(value : TFhirCodeableConcept);
begin
  FFundsReserve.free;
  FFundsReserve := value;
end;

function TFhirExplanationOfBenefit.GetRelatedList : TFhirExplanationOfBenefitRelatedList;
begin
  if FRelatedList = nil then
    FRelatedList := TFhirExplanationOfBenefitRelatedList.Create;
  result := FRelatedList;
end;

function TFhirExplanationOfBenefit.GetHasRelatedList : boolean;
begin
  result := (FRelatedList <> nil) and (FRelatedList.count > 0);
end;

procedure TFhirExplanationOfBenefit.SetPrescription(value : TFhirReference);
begin
  FPrescription.free;
  FPrescription := value;
end;

procedure TFhirExplanationOfBenefit.SetOriginalPrescription(value : TFhirReference);
begin
  FOriginalPrescription.free;
  FOriginalPrescription := value;
end;

procedure TFhirExplanationOfBenefit.SetPayee(value : TFhirExplanationOfBenefitPayee);
begin
  FPayee.free;
  FPayee := value;
end;

procedure TFhirExplanationOfBenefit.SetReferral(value : TFhirReference);
begin
  FReferral.free;
  FReferral := value;
end;

procedure TFhirExplanationOfBenefit.SetFacility(value : TFhirReference);
begin
  FFacility.free;
  FFacility := value;
end;

procedure TFhirExplanationOfBenefit.SetClaim(value : TFhirReference);
begin
  FClaim.free;
  FClaim := value;
end;

procedure TFhirExplanationOfBenefit.SetClaimResponse(value : TFhirReference);
begin
  FClaimResponse.free;
  FClaimResponse := value;
end;

procedure TFhirExplanationOfBenefit.SetOutcome(value : TFhirEnum);
begin
  FOutcome.free;
  FOutcome := value;
end;

function TFhirExplanationOfBenefit.GetOutcomeST : TFhirClaimProcessingCodesEnum;
begin
  if FOutcome = nil then
    result := TFhirClaimProcessingCodesEnum(0)
  else
    result := TFhirClaimProcessingCodesEnum(StringArrayIndexOfSensitive(CODES_TFhirClaimProcessingCodesEnum, FOutcome.value));
end;

procedure TFhirExplanationOfBenefit.SetOutcomeST(value : TFhirClaimProcessingCodesEnum);
begin
  if ord(value) = 0 then
    OutcomeElement := nil
  else
    OutcomeElement := TFhirEnum.create(SYSTEMS_TFhirClaimProcessingCodesEnum[value], CODES_TFhirClaimProcessingCodesEnum[value]);
end;

procedure TFhirExplanationOfBenefit.SetDisposition(value : TFhirString);
begin
  FDisposition.free;
  FDisposition := value;
end;

function TFhirExplanationOfBenefit.GetDispositionST : String;
begin
  if FDisposition = nil then
    result := ''
  else
    result := FDisposition.value;
end;

procedure TFhirExplanationOfBenefit.SetDispositionST(value : String);
begin
  if value <> '' then
  begin
    if FDisposition = nil then
      FDisposition := TFhirString.create;
    FDisposition.value := value
  end
  else if FDisposition <> nil then
    FDisposition.value := '';
end;

function TFhirExplanationOfBenefit.GetPreAuthRefList : TFhirStringList;
begin
  if FPreAuthRefList = nil then
    FPreAuthRefList := TFhirStringList.Create;
  result := FPreAuthRefList;
end;

function TFhirExplanationOfBenefit.GetHasPreAuthRefList : boolean;
begin
  result := (FPreAuthRefList <> nil) and (FPreAuthRefList.count > 0);
end;

function TFhirExplanationOfBenefit.GetPreAuthRefPeriodList : TFhirPeriodList;
begin
  if FPreAuthRefPeriodList = nil then
    FPreAuthRefPeriodList := TFhirPeriodList.Create;
  result := FPreAuthRefPeriodList;
end;

function TFhirExplanationOfBenefit.GetHasPreAuthRefPeriodList : boolean;
begin
  result := (FPreAuthRefPeriodList <> nil) and (FPreAuthRefPeriodList.count > 0);
end;

function TFhirExplanationOfBenefit.GetCareTeamList : TFhirExplanationOfBenefitCareTeamList;
begin
  if FCareTeamList = nil then
    FCareTeamList := TFhirExplanationOfBenefitCareTeamList.Create;
  result := FCareTeamList;
end;

function TFhirExplanationOfBenefit.GetHasCareTeamList : boolean;
begin
  result := (FCareTeamList <> nil) and (FCareTeamList.count > 0);
end;

function TFhirExplanationOfBenefit.GetSupportingInfoList : TFhirExplanationOfBenefitSupportingInfoList;
begin
  if FSupportingInfoList = nil then
    FSupportingInfoList := TFhirExplanationOfBenefitSupportingInfoList.Create;
  result := FSupportingInfoList;
end;

function TFhirExplanationOfBenefit.GetHasSupportingInfoList : boolean;
begin
  result := (FSupportingInfoList <> nil) and (FSupportingInfoList.count > 0);
end;

function TFhirExplanationOfBenefit.GetDiagnosisList : TFhirExplanationOfBenefitDiagnosisList;
begin
  if FDiagnosisList = nil then
    FDiagnosisList := TFhirExplanationOfBenefitDiagnosisList.Create;
  result := FDiagnosisList;
end;

function TFhirExplanationOfBenefit.GetHasDiagnosisList : boolean;
begin
  result := (FDiagnosisList <> nil) and (FDiagnosisList.count > 0);
end;

function TFhirExplanationOfBenefit.GetProcedure_List : TFhirExplanationOfBenefitProcedureList;
begin
  if FProcedure_List = nil then
    FProcedure_List := TFhirExplanationOfBenefitProcedureList.Create;
  result := FProcedure_List;
end;

function TFhirExplanationOfBenefit.GetHasProcedure_List : boolean;
begin
  result := (FProcedure_List <> nil) and (FProcedure_List.count > 0);
end;

procedure TFhirExplanationOfBenefit.SetPrecedence(value : TFhirPositiveInt);
begin
  FPrecedence.free;
  FPrecedence := value;
end;

function TFhirExplanationOfBenefit.GetPrecedenceST : String;
begin
  if FPrecedence = nil then
    result := ''
  else
    result := FPrecedence.value;
end;

procedure TFhirExplanationOfBenefit.SetPrecedenceST(value : String);
begin
  if value <> '' then
  begin
    if FPrecedence = nil then
      FPrecedence := TFhirPositiveInt.create;
    FPrecedence.value := value
  end
  else if FPrecedence <> nil then
    FPrecedence.value := '';
end;

function TFhirExplanationOfBenefit.GetInsuranceList : TFhirExplanationOfBenefitInsuranceList;
begin
  if FInsuranceList = nil then
    FInsuranceList := TFhirExplanationOfBenefitInsuranceList.Create;
  result := FInsuranceList;
end;

function TFhirExplanationOfBenefit.GetHasInsuranceList : boolean;
begin
  result := (FInsuranceList <> nil) and (FInsuranceList.count > 0);
end;

procedure TFhirExplanationOfBenefit.SetAccident(value : TFhirExplanationOfBenefitAccident);
begin
  FAccident.free;
  FAccident := value;
end;

function TFhirExplanationOfBenefit.GetItemList : TFhirExplanationOfBenefitItemList;
begin
  if FItemList = nil then
    FItemList := TFhirExplanationOfBenefitItemList.Create;
  result := FItemList;
end;

function TFhirExplanationOfBenefit.GetHasItemList : boolean;
begin
  result := (FItemList <> nil) and (FItemList.count > 0);
end;

function TFhirExplanationOfBenefit.GetAddItemList : TFhirExplanationOfBenefitAddItemList;
begin
  if FAddItemList = nil then
    FAddItemList := TFhirExplanationOfBenefitAddItemList.Create;
  result := FAddItemList;
end;

function TFhirExplanationOfBenefit.GetHasAddItemList : boolean;
begin
  result := (FAddItemList <> nil) and (FAddItemList.count > 0);
end;

function TFhirExplanationOfBenefit.GetAdjudicationList : TFhirExplanationOfBenefitItemAdjudicationList;
begin
  if FAdjudicationList = nil then
    FAdjudicationList := TFhirExplanationOfBenefitItemAdjudicationList.Create;
  result := FAdjudicationList;
end;

function TFhirExplanationOfBenefit.GetHasAdjudicationList : boolean;
begin
  result := (FAdjudicationList <> nil) and (FAdjudicationList.count > 0);
end;

function TFhirExplanationOfBenefit.GetTotalList : TFhirExplanationOfBenefitTotalList;
begin
  if FTotalList = nil then
    FTotalList := TFhirExplanationOfBenefitTotalList.Create;
  result := FTotalList;
end;

function TFhirExplanationOfBenefit.GetHasTotalList : boolean;
begin
  result := (FTotalList <> nil) and (FTotalList.count > 0);
end;

procedure TFhirExplanationOfBenefit.SetPayment(value : TFhirExplanationOfBenefitPayment);
begin
  FPayment.free;
  FPayment := value;
end;

procedure TFhirExplanationOfBenefit.SetFormCode(value : TFhirCodeableConcept);
begin
  FFormCode.free;
  FFormCode := value;
end;

procedure TFhirExplanationOfBenefit.SetForm(value : TFhirAttachment);
begin
  FForm.free;
  FForm := value;
end;

function TFhirExplanationOfBenefit.GetProcessNoteList : TFhirExplanationOfBenefitProcessNoteList;
begin
  if FProcessNoteList = nil then
    FProcessNoteList := TFhirExplanationOfBenefitProcessNoteList.Create;
  result := FProcessNoteList;
end;

function TFhirExplanationOfBenefit.GetHasProcessNoteList : boolean;
begin
  result := (FProcessNoteList <> nil) and (FProcessNoteList.count > 0);
end;

procedure TFhirExplanationOfBenefit.SetBenefitPeriod(value : TFhirPeriod);
begin
  FBenefitPeriod.free;
  FBenefitPeriod := value;
end;

function TFhirExplanationOfBenefit.GetBenefitBalanceList : TFhirExplanationOfBenefitBenefitBalanceList;
begin
  if FBenefitBalanceList = nil then
    FBenefitBalanceList := TFhirExplanationOfBenefitBenefitBalanceList.Create;
  result := FBenefitBalanceList;
end;

function TFhirExplanationOfBenefit.GetHasBenefitBalanceList : boolean;
begin
  result := (FBenefitBalanceList <> nil) and (FBenefitBalanceList.count > 0);
end;

{ TFhirExplanationOfBenefitListEnumerator }

constructor TFhirExplanationOfBenefitListEnumerator.Create(list : TFhirExplanationOfBenefitList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirExplanationOfBenefitListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirExplanationOfBenefitListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirExplanationOfBenefitListEnumerator.GetCurrent : TFhirExplanationOfBenefit;
begin
  Result := FList[FIndex];
end;

function TFhirExplanationOfBenefitListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirExplanationOfBenefitList }

procedure TFhirExplanationOfBenefitList.AddItem(value: TFhirExplanationOfBenefit);
begin
  assert(value.ClassName = 'TFhirExplanationOfBenefit', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirExplanationOfBenefit');
  add(value);
end;

function TFhirExplanationOfBenefitList.Append: TFhirExplanationOfBenefit;
begin
  result := TFhirExplanationOfBenefit.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirExplanationOfBenefitList.ClearItems;
begin
  Clear;
end;

function TFhirExplanationOfBenefitList.GetEnumerator : TFhirExplanationOfBenefitListEnumerator;
begin
  result := TFhirExplanationOfBenefitListEnumerator.Create(self.link);
end;

function TFhirExplanationOfBenefitList.Clone: TFhirExplanationOfBenefitList;
begin
  result := TFhirExplanationOfBenefitList(inherited Clone);
end;

function TFhirExplanationOfBenefitList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirExplanationOfBenefitList.GetItemN(index: Integer): TFhirExplanationOfBenefit;
begin
  result := TFhirExplanationOfBenefit(ObjectByIndex[index]);
end;

function TFhirExplanationOfBenefitList.ItemClass: TFslObjectClass;
begin
  result := TFhirExplanationOfBenefit;
end;
function TFhirExplanationOfBenefitList.IndexOf(value: TFhirExplanationOfBenefit): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirExplanationOfBenefitList.Insert(index: Integer): TFhirExplanationOfBenefit;
begin
  result := TFhirExplanationOfBenefit.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirExplanationOfBenefitList.InsertItem(index: Integer; value: TFhirExplanationOfBenefit);
begin
  assert(value is TFhirExplanationOfBenefit);
  Inherited Insert(index, value);
end;

function TFhirExplanationOfBenefitList.Item(index: Integer): TFhirExplanationOfBenefit;
begin
  result := TFhirExplanationOfBenefit(ObjectByIndex[index]);
end;

function TFhirExplanationOfBenefitList.Link: TFhirExplanationOfBenefitList;
begin
  result := TFhirExplanationOfBenefitList(inherited Link);
end;

procedure TFhirExplanationOfBenefitList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirExplanationOfBenefitList.SetItemByIndex(index: Integer; value: TFhirExplanationOfBenefit);
begin
  assert(value is TFhirExplanationOfBenefit);
  FhirExplanationOfBenefits[index] := value;
end;

procedure TFhirExplanationOfBenefitList.SetItemN(index: Integer; value: TFhirExplanationOfBenefit);
begin
  assert(value is TFhirExplanationOfBenefit);
  ObjectByIndex[index] := value;
end;

{$ENDIF FHIR_EXPLANATIONOFBENEFIT}
{$IFDEF FHIR_INSURANCEPLAN}
{ TFhirInsurancePlanContact }

constructor TFhirInsurancePlanContact.Create;
begin
  inherited;
end;

destructor TFhirInsurancePlanContact.Destroy;
begin
  FPurpose.free;
  FName.free;
  FTelecomList.Free;
  FAddress.free;
  inherited;
end;

procedure TFhirInsurancePlanContact.Assign(oSource : TFslObject);
begin
  inherited;
  purpose := TFhirInsurancePlanContact(oSource).purpose.Clone;
  name := TFhirInsurancePlanContact(oSource).name.Clone;
  if (TFhirInsurancePlanContact(oSource).FTelecomList = nil) then
  begin
    FTelecomList.free;
    FTelecomList := nil;
  end
  else
  begin
    if FTelecomList = nil then
      FTelecomList := TFhirContactPointList.Create;
    FTelecomList.Assign(TFhirInsurancePlanContact(oSource).FTelecomList);
  end;
  address := TFhirInsurancePlanContact(oSource).address.Clone;
end;

procedure TFhirInsurancePlanContact.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'purpose') Then
     list.add(self.link, 'purpose', FPurpose.Link);
  if (child_name = 'name') Then
     list.add(self.link, 'name', FName.Link);
  if (child_name = 'telecom') Then
    list.addAll(self, 'telecom', FTelecomList);
  if (child_name = 'address') Then
     list.add(self.link, 'address', FAddress.Link);
end;

procedure TFhirInsurancePlanContact.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'purpose', 'CodeableConcept', false, TFhirCodeableConcept, FPurpose.Link));
  oList.add(TFHIRProperty.create(self, 'name', 'HumanName', false, TFhirHumanName, FName.Link));
  oList.add(TFHIRProperty.create(self, 'telecom', 'ContactPoint', true, TFhirContactPoint, FTelecomList.Link));
  oList.add(TFHIRProperty.create(self, 'address', 'Address', false, TFhirAddress, FAddress.Link));
end;

function TFhirInsurancePlanContact.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'purpose') then
  begin
    Purpose := propValue as TFhirCodeableConcept;
    result := propValue;
  end
  else if (propName = 'name') then
  begin
    Name := propValue as TFhirHumanName;
    result := propValue;
  end
  else if (propName = 'telecom') then
  begin
    TelecomList.add(propValue as TFhirContactPoint);
    result := propValue;
  end
  else if (propName = 'address') then
  begin
    Address := propValue as TFhirAddress;
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirInsurancePlanContact.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'telecom') then TelecomList.insertItem(index, propValue as TFhirContactPoint)
  else inherited;
end;

function TFhirInsurancePlanContact.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'purpose') then result := TFhirCodeableConcept.create()
  else if (propName = 'name') then result := TFhirHumanName.create()
  else if (propName = 'telecom') then result := TelecomList.new()
  else if (propName = 'address') then result := TFhirAddress.create()
  else result := inherited createPropertyValue(propName);
end;

function TFhirInsurancePlanContact.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'purpose') then result := 'CodeableConcept'
  else if (propName = 'name') then result := 'HumanName'
  else if (propName = 'telecom') then result := 'ContactPoint'
  else if (propName = 'address') then result := 'Address'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirInsurancePlanContact.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'purpose') then PurposeElement := nil
  else if (propName = 'name') then NameElement := nil
  else if (propName = 'telecom') then deletePropertyValue('telecom', TelecomList, value)
  else if (propName = 'address') then AddressElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirInsurancePlanContact.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'purpose') then PurposeElement := new as TFhirCodeableConcept
  else if (propName = 'name') then NameElement := new as TFhirHumanName
  else if (propName = 'telecom') then replacePropertyValue('telecom', TelecomList, existing, new)
  else if (propName = 'address') then AddressElement := new as TFhirAddress
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirInsurancePlanContact.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'telecom') then TelecomList.move(source, destination)
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirInsurancePlanContact.fhirType : string;
begin
  result := 'InsurancePlan.contact';
end;

function TFhirInsurancePlanContact.Link : TFhirInsurancePlanContact;
begin
  result := TFhirInsurancePlanContact(inherited Link);
end;

function TFhirInsurancePlanContact.Clone : TFhirInsurancePlanContact;
begin
  result := TFhirInsurancePlanContact(inherited Clone);
end;

function TFhirInsurancePlanContact.equals(other : TObject) : boolean; 
var
  o : TFhirInsurancePlanContact;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirInsurancePlanContact)) then
    result := false
  else
  begin
    o := TFhirInsurancePlanContact(other);
    result := compareDeep(purposeElement, o.purposeElement, true) and compareDeep(nameElement, o.nameElement, true) and 
      compareDeep(telecomList, o.telecomList, true) and compareDeep(addressElement, o.addressElement, true);
  end;
end;

function TFhirInsurancePlanContact.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FPurpose) and isEmptyProp(FName) and isEmptyProp(FtelecomList) and isEmptyProp(FAddress);
end;

procedure TFhirInsurancePlanContact.listFieldsInOrder(fields : TStringList);
begin
  inherited listFieldsInOrder(fields);
  fields.add('purpose');
  fields.add('name');
  fields.add('telecom');
  fields.add('address');
end;

function TFhirInsurancePlanContact.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FTelecomList.sizeInBytes(magic));
end;

procedure TFhirInsurancePlanContact.SetPurpose(value : TFhirCodeableConcept);
begin
  FPurpose.free;
  FPurpose := value;
end;

procedure TFhirInsurancePlanContact.SetName(value : TFhirHumanName);
begin
  FName.free;
  FName := value;
end;

function TFhirInsurancePlanContact.GetTelecomList : TFhirContactPointList;
begin
  if FTelecomList = nil then
    FTelecomList := TFhirContactPointList.Create;
  result := FTelecomList;
end;

function TFhirInsurancePlanContact.GetHasTelecomList : boolean;
begin
  result := (FTelecomList <> nil) and (FTelecomList.count > 0);
end;

procedure TFhirInsurancePlanContact.SetAddress(value : TFhirAddress);
begin
  FAddress.free;
  FAddress := value;
end;

{ TFhirInsurancePlanContactListEnumerator }

constructor TFhirInsurancePlanContactListEnumerator.Create(list : TFhirInsurancePlanContactList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirInsurancePlanContactListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirInsurancePlanContactListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirInsurancePlanContactListEnumerator.GetCurrent : TFhirInsurancePlanContact;
begin
  Result := FList[FIndex];
end;

function TFhirInsurancePlanContactListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirInsurancePlanContactList }

procedure TFhirInsurancePlanContactList.AddItem(value: TFhirInsurancePlanContact);
begin
  assert(value.ClassName = 'TFhirInsurancePlanContact', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirInsurancePlanContact');
  add(value);
end;

function TFhirInsurancePlanContactList.Append: TFhirInsurancePlanContact;
begin
  result := TFhirInsurancePlanContact.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirInsurancePlanContactList.ClearItems;
begin
  Clear;
end;

function TFhirInsurancePlanContactList.GetEnumerator : TFhirInsurancePlanContactListEnumerator;
begin
  result := TFhirInsurancePlanContactListEnumerator.Create(self.link);
end;

function TFhirInsurancePlanContactList.Clone: TFhirInsurancePlanContactList;
begin
  result := TFhirInsurancePlanContactList(inherited Clone);
end;

function TFhirInsurancePlanContactList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirInsurancePlanContactList.GetItemN(index: Integer): TFhirInsurancePlanContact;
begin
  result := TFhirInsurancePlanContact(ObjectByIndex[index]);
end;

function TFhirInsurancePlanContactList.ItemClass: TFslObjectClass;
begin
  result := TFhirInsurancePlanContact;
end;
function TFhirInsurancePlanContactList.IndexOf(value: TFhirInsurancePlanContact): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirInsurancePlanContactList.Insert(index: Integer): TFhirInsurancePlanContact;
begin
  result := TFhirInsurancePlanContact.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirInsurancePlanContactList.InsertItem(index: Integer; value: TFhirInsurancePlanContact);
begin
  assert(value is TFhirInsurancePlanContact);
  Inherited Insert(index, value);
end;

function TFhirInsurancePlanContactList.Item(index: Integer): TFhirInsurancePlanContact;
begin
  result := TFhirInsurancePlanContact(ObjectByIndex[index]);
end;

function TFhirInsurancePlanContactList.Link: TFhirInsurancePlanContactList;
begin
  result := TFhirInsurancePlanContactList(inherited Link);
end;

procedure TFhirInsurancePlanContactList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirInsurancePlanContactList.SetItemByIndex(index: Integer; value: TFhirInsurancePlanContact);
begin
  assert(value is TFhirInsurancePlanContact);
  FhirInsurancePlanContacts[index] := value;
end;

procedure TFhirInsurancePlanContactList.SetItemN(index: Integer; value: TFhirInsurancePlanContact);
begin
  assert(value is TFhirInsurancePlanContact);
  ObjectByIndex[index] := value;
end;

{ TFhirInsurancePlanCoverage }

constructor TFhirInsurancePlanCoverage.Create;
begin
  inherited;
end;

destructor TFhirInsurancePlanCoverage.Destroy;
begin
  FType_.free;
  FNetworkList.Free;
  FBenefitList.Free;
  inherited;
end;

procedure TFhirInsurancePlanCoverage.Assign(oSource : TFslObject);
begin
  inherited;
  type_ := TFhirInsurancePlanCoverage(oSource).type_.Clone;
  if (TFhirInsurancePlanCoverage(oSource).FNetworkList = nil) then
  begin
    FNetworkList.free;
    FNetworkList := nil;
  end
  else
  begin
    if FNetworkList = nil then
      FNetworkList := TFhirReferenceList.Create;
    FNetworkList.Assign(TFhirInsurancePlanCoverage(oSource).FNetworkList);
  end;
  if (TFhirInsurancePlanCoverage(oSource).FBenefitList = nil) then
  begin
    FBenefitList.free;
    FBenefitList := nil;
  end
  else
  begin
    if FBenefitList = nil then
      FBenefitList := TFhirInsurancePlanCoverageBenefitList.Create;
    FBenefitList.Assign(TFhirInsurancePlanCoverage(oSource).FBenefitList);
  end;
end;

procedure TFhirInsurancePlanCoverage.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'type') Then
     list.add(self.link, 'type', FType_.Link);
  if (child_name = 'network') Then
    list.addAll(self, 'network', FNetworkList);
  if (child_name = 'benefit') Then
    list.addAll(self, 'benefit', FBenefitList);
end;

procedure TFhirInsurancePlanCoverage.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'type', 'CodeableConcept', false, TFhirCodeableConcept, FType_.Link));
  oList.add(TFHIRProperty.create(self, 'network', 'Reference', true, TFhirReference, FNetworkList.Link));
  oList.add(TFHIRProperty.create(self, 'benefit', 'BackboneElement', true, TFhirInsurancePlanCoverageBenefit, FBenefitList.Link));
end;

function TFhirInsurancePlanCoverage.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'type') then
  begin
    Type_ := propValue as TFhirCodeableConcept;
    result := propValue;
  end
  else if (propName = 'network') then
  begin
    NetworkList.add(propValue as TFhirReference);
    result := propValue;
  end
  else if (propName = 'benefit') then
  begin
    BenefitList.add(propValue as TFhirInsurancePlanCoverageBenefit);
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirInsurancePlanCoverage.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'network') then NetworkList.insertItem(index, propValue as TFhirReference)
  else if (propName = 'benefit') then BenefitList.insertItem(index, propValue as TFhirInsurancePlanCoverageBenefit)
  else inherited;
end;

function TFhirInsurancePlanCoverage.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'type') then result := TFhirCodeableConcept.create()
  else if (propName = 'network') then result := NetworkList.new()
  else if (propName = 'benefit') then result := BenefitList.new()
  else result := inherited createPropertyValue(propName);
end;

function TFhirInsurancePlanCoverage.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'type') then result := 'CodeableConcept'
  else if (propName = 'network') then result := 'Reference'
  else if (propName = 'benefit') then result := 'BackboneElement'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirInsurancePlanCoverage.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'type') then Type_Element := nil
  else if (propName = 'network') then deletePropertyValue('network', NetworkList, value)
  else if (propName = 'benefit') then deletePropertyValue('benefit', BenefitList, value)
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirInsurancePlanCoverage.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'type') then Type_Element := new as TFhirCodeableConcept
  else if (propName = 'network') then replacePropertyValue('network', NetworkList, existing, new)
  else if (propName = 'benefit') then replacePropertyValue('benefit', BenefitList, existing, new)
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirInsurancePlanCoverage.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'network') then NetworkList.move(source, destination)
  else if (propName = 'benefit') then BenefitList.move(source, destination)
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirInsurancePlanCoverage.fhirType : string;
begin
  result := 'InsurancePlan.coverage';
end;

function TFhirInsurancePlanCoverage.Link : TFhirInsurancePlanCoverage;
begin
  result := TFhirInsurancePlanCoverage(inherited Link);
end;

function TFhirInsurancePlanCoverage.Clone : TFhirInsurancePlanCoverage;
begin
  result := TFhirInsurancePlanCoverage(inherited Clone);
end;

function TFhirInsurancePlanCoverage.equals(other : TObject) : boolean; 
var
  o : TFhirInsurancePlanCoverage;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirInsurancePlanCoverage)) then
    result := false
  else
  begin
    o := TFhirInsurancePlanCoverage(other);
    result := compareDeep(type_Element, o.type_Element, true) and compareDeep(networkList, o.networkList, true) and 
      compareDeep(benefitList, o.benefitList, true);
  end;
end;

function TFhirInsurancePlanCoverage.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FType_) and isEmptyProp(FnetworkList) and isEmptyProp(FbenefitList);
end;

procedure TFhirInsurancePlanCoverage.listFieldsInOrder(fields : TStringList);
begin
  inherited listFieldsInOrder(fields);
  fields.add('type');
  fields.add('network');
  fields.add('benefit');
end;

function TFhirInsurancePlanCoverage.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FNetworkList.sizeInBytes(magic));
  inc(result, FBenefitList.sizeInBytes(magic));
end;

procedure TFhirInsurancePlanCoverage.SetType_(value : TFhirCodeableConcept);
begin
  FType_.free;
  FType_ := value;
end;

function TFhirInsurancePlanCoverage.GetNetworkList : TFhirReferenceList;
begin
  if FNetworkList = nil then
    FNetworkList := TFhirReferenceList.Create;
  result := FNetworkList;
end;

function TFhirInsurancePlanCoverage.GetHasNetworkList : boolean;
begin
  result := (FNetworkList <> nil) and (FNetworkList.count > 0);
end;

function TFhirInsurancePlanCoverage.GetBenefitList : TFhirInsurancePlanCoverageBenefitList;
begin
  if FBenefitList = nil then
    FBenefitList := TFhirInsurancePlanCoverageBenefitList.Create;
  result := FBenefitList;
end;

function TFhirInsurancePlanCoverage.GetHasBenefitList : boolean;
begin
  result := (FBenefitList <> nil) and (FBenefitList.count > 0);
end;

{ TFhirInsurancePlanCoverageListEnumerator }

constructor TFhirInsurancePlanCoverageListEnumerator.Create(list : TFhirInsurancePlanCoverageList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirInsurancePlanCoverageListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirInsurancePlanCoverageListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirInsurancePlanCoverageListEnumerator.GetCurrent : TFhirInsurancePlanCoverage;
begin
  Result := FList[FIndex];
end;

function TFhirInsurancePlanCoverageListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirInsurancePlanCoverageList }

procedure TFhirInsurancePlanCoverageList.AddItem(value: TFhirInsurancePlanCoverage);
begin
  assert(value.ClassName = 'TFhirInsurancePlanCoverage', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirInsurancePlanCoverage');
  add(value);
end;

function TFhirInsurancePlanCoverageList.Append: TFhirInsurancePlanCoverage;
begin
  result := TFhirInsurancePlanCoverage.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirInsurancePlanCoverageList.ClearItems;
begin
  Clear;
end;

function TFhirInsurancePlanCoverageList.GetEnumerator : TFhirInsurancePlanCoverageListEnumerator;
begin
  result := TFhirInsurancePlanCoverageListEnumerator.Create(self.link);
end;

function TFhirInsurancePlanCoverageList.Clone: TFhirInsurancePlanCoverageList;
begin
  result := TFhirInsurancePlanCoverageList(inherited Clone);
end;

function TFhirInsurancePlanCoverageList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirInsurancePlanCoverageList.GetItemN(index: Integer): TFhirInsurancePlanCoverage;
begin
  result := TFhirInsurancePlanCoverage(ObjectByIndex[index]);
end;

function TFhirInsurancePlanCoverageList.ItemClass: TFslObjectClass;
begin
  result := TFhirInsurancePlanCoverage;
end;
function TFhirInsurancePlanCoverageList.IndexOf(value: TFhirInsurancePlanCoverage): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirInsurancePlanCoverageList.Insert(index: Integer): TFhirInsurancePlanCoverage;
begin
  result := TFhirInsurancePlanCoverage.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirInsurancePlanCoverageList.InsertItem(index: Integer; value: TFhirInsurancePlanCoverage);
begin
  assert(value is TFhirInsurancePlanCoverage);
  Inherited Insert(index, value);
end;

function TFhirInsurancePlanCoverageList.Item(index: Integer): TFhirInsurancePlanCoverage;
begin
  result := TFhirInsurancePlanCoverage(ObjectByIndex[index]);
end;

function TFhirInsurancePlanCoverageList.Link: TFhirInsurancePlanCoverageList;
begin
  result := TFhirInsurancePlanCoverageList(inherited Link);
end;

procedure TFhirInsurancePlanCoverageList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirInsurancePlanCoverageList.SetItemByIndex(index: Integer; value: TFhirInsurancePlanCoverage);
begin
  assert(value is TFhirInsurancePlanCoverage);
  FhirInsurancePlanCoverages[index] := value;
end;

procedure TFhirInsurancePlanCoverageList.SetItemN(index: Integer; value: TFhirInsurancePlanCoverage);
begin
  assert(value is TFhirInsurancePlanCoverage);
  ObjectByIndex[index] := value;
end;

{ TFhirInsurancePlanCoverageBenefit }

constructor TFhirInsurancePlanCoverageBenefit.Create;
begin
  inherited;
end;

destructor TFhirInsurancePlanCoverageBenefit.Destroy;
begin
  FType_.free;
  FRequirement.free;
  FLimitList.Free;
  inherited;
end;

procedure TFhirInsurancePlanCoverageBenefit.Assign(oSource : TFslObject);
begin
  inherited;
  type_ := TFhirInsurancePlanCoverageBenefit(oSource).type_.Clone;
  requirementElement := TFhirInsurancePlanCoverageBenefit(oSource).requirementElement.Clone;
  if (TFhirInsurancePlanCoverageBenefit(oSource).FLimitList = nil) then
  begin
    FLimitList.free;
    FLimitList := nil;
  end
  else
  begin
    if FLimitList = nil then
      FLimitList := TFhirInsurancePlanCoverageBenefitLimitList.Create;
    FLimitList.Assign(TFhirInsurancePlanCoverageBenefit(oSource).FLimitList);
  end;
end;

procedure TFhirInsurancePlanCoverageBenefit.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'type') Then
     list.add(self.link, 'type', FType_.Link);
  if (child_name = 'requirement') Then
     list.add(self.link, 'requirement', FRequirement.Link);
  if (child_name = 'limit') Then
    list.addAll(self, 'limit', FLimitList);
end;

procedure TFhirInsurancePlanCoverageBenefit.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'type', 'CodeableConcept', false, TFhirCodeableConcept, FType_.Link));
  oList.add(TFHIRProperty.create(self, 'requirement', 'string', false, TFhirString, FRequirement.Link));
  oList.add(TFHIRProperty.create(self, 'limit', 'BackboneElement', true, TFhirInsurancePlanCoverageBenefitLimit, FLimitList.Link));
end;

function TFhirInsurancePlanCoverageBenefit.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'type') then
  begin
    Type_ := propValue as TFhirCodeableConcept;
    result := propValue;
  end
  else if (propName = 'requirement') then
  begin
    RequirementElement := asString(propValue);
    result := propValue;
  end
  else if (propName = 'limit') then
  begin
    LimitList.add(propValue as TFhirInsurancePlanCoverageBenefitLimit);
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirInsurancePlanCoverageBenefit.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'limit') then LimitList.insertItem(index, propValue as TFhirInsurancePlanCoverageBenefitLimit)
  else inherited;
end;

function TFhirInsurancePlanCoverageBenefit.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'type') then result := TFhirCodeableConcept.create()
  else if (propName = 'requirement') then result := TFhirString.create()
  else if (propName = 'limit') then result := LimitList.new()
  else result := inherited createPropertyValue(propName);
end;

function TFhirInsurancePlanCoverageBenefit.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'type') then result := 'CodeableConcept'
  else if (propName = 'requirement') then result := 'string'
  else if (propName = 'limit') then result := 'BackboneElement'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirInsurancePlanCoverageBenefit.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'type') then Type_Element := nil
  else if (propName = 'requirement') then RequirementElement := nil
  else if (propName = 'limit') then deletePropertyValue('limit', LimitList, value)
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirInsurancePlanCoverageBenefit.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'type') then Type_Element := new as TFhirCodeableConcept
  else if (propName = 'requirement') then RequirementElement := asString(new)
  else if (propName = 'limit') then replacePropertyValue('limit', LimitList, existing, new)
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirInsurancePlanCoverageBenefit.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'limit') then LimitList.move(source, destination)
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirInsurancePlanCoverageBenefit.fhirType : string;
begin
  result := 'InsurancePlan.coverage.benefit';
end;

function TFhirInsurancePlanCoverageBenefit.Link : TFhirInsurancePlanCoverageBenefit;
begin
  result := TFhirInsurancePlanCoverageBenefit(inherited Link);
end;

function TFhirInsurancePlanCoverageBenefit.Clone : TFhirInsurancePlanCoverageBenefit;
begin
  result := TFhirInsurancePlanCoverageBenefit(inherited Clone);
end;

function TFhirInsurancePlanCoverageBenefit.equals(other : TObject) : boolean; 
var
  o : TFhirInsurancePlanCoverageBenefit;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirInsurancePlanCoverageBenefit)) then
    result := false
  else
  begin
    o := TFhirInsurancePlanCoverageBenefit(other);
    result := compareDeep(type_Element, o.type_Element, true) and compareDeep(requirementElement, o.requirementElement, true) and 
      compareDeep(limitList, o.limitList, true);
  end;
end;

function TFhirInsurancePlanCoverageBenefit.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FType_) and isEmptyProp(FRequirement) and isEmptyProp(FlimitList);
end;

procedure TFhirInsurancePlanCoverageBenefit.listFieldsInOrder(fields : TStringList);
begin
  inherited listFieldsInOrder(fields);
  fields.add('type');
  fields.add('requirement');
  fields.add('limit');
end;

function TFhirInsurancePlanCoverageBenefit.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FLimitList.sizeInBytes(magic));
end;

procedure TFhirInsurancePlanCoverageBenefit.SetType_(value : TFhirCodeableConcept);
begin
  FType_.free;
  FType_ := value;
end;

procedure TFhirInsurancePlanCoverageBenefit.SetRequirement(value : TFhirString);
begin
  FRequirement.free;
  FRequirement := value;
end;

function TFhirInsurancePlanCoverageBenefit.GetRequirementST : String;
begin
  if FRequirement = nil then
    result := ''
  else
    result := FRequirement.value;
end;

procedure TFhirInsurancePlanCoverageBenefit.SetRequirementST(value : String);
begin
  if value <> '' then
  begin
    if FRequirement = nil then
      FRequirement := TFhirString.create;
    FRequirement.value := value
  end
  else if FRequirement <> nil then
    FRequirement.value := '';
end;

function TFhirInsurancePlanCoverageBenefit.GetLimitList : TFhirInsurancePlanCoverageBenefitLimitList;
begin
  if FLimitList = nil then
    FLimitList := TFhirInsurancePlanCoverageBenefitLimitList.Create;
  result := FLimitList;
end;

function TFhirInsurancePlanCoverageBenefit.GetHasLimitList : boolean;
begin
  result := (FLimitList <> nil) and (FLimitList.count > 0);
end;

{ TFhirInsurancePlanCoverageBenefitListEnumerator }

constructor TFhirInsurancePlanCoverageBenefitListEnumerator.Create(list : TFhirInsurancePlanCoverageBenefitList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirInsurancePlanCoverageBenefitListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirInsurancePlanCoverageBenefitListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirInsurancePlanCoverageBenefitListEnumerator.GetCurrent : TFhirInsurancePlanCoverageBenefit;
begin
  Result := FList[FIndex];
end;

function TFhirInsurancePlanCoverageBenefitListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirInsurancePlanCoverageBenefitList }

procedure TFhirInsurancePlanCoverageBenefitList.AddItem(value: TFhirInsurancePlanCoverageBenefit);
begin
  assert(value.ClassName = 'TFhirInsurancePlanCoverageBenefit', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirInsurancePlanCoverageBenefit');
  add(value);
end;

function TFhirInsurancePlanCoverageBenefitList.Append: TFhirInsurancePlanCoverageBenefit;
begin
  result := TFhirInsurancePlanCoverageBenefit.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirInsurancePlanCoverageBenefitList.ClearItems;
begin
  Clear;
end;

function TFhirInsurancePlanCoverageBenefitList.GetEnumerator : TFhirInsurancePlanCoverageBenefitListEnumerator;
begin
  result := TFhirInsurancePlanCoverageBenefitListEnumerator.Create(self.link);
end;

function TFhirInsurancePlanCoverageBenefitList.Clone: TFhirInsurancePlanCoverageBenefitList;
begin
  result := TFhirInsurancePlanCoverageBenefitList(inherited Clone);
end;

function TFhirInsurancePlanCoverageBenefitList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirInsurancePlanCoverageBenefitList.GetItemN(index: Integer): TFhirInsurancePlanCoverageBenefit;
begin
  result := TFhirInsurancePlanCoverageBenefit(ObjectByIndex[index]);
end;

function TFhirInsurancePlanCoverageBenefitList.ItemClass: TFslObjectClass;
begin
  result := TFhirInsurancePlanCoverageBenefit;
end;
function TFhirInsurancePlanCoverageBenefitList.IndexOf(value: TFhirInsurancePlanCoverageBenefit): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirInsurancePlanCoverageBenefitList.Insert(index: Integer): TFhirInsurancePlanCoverageBenefit;
begin
  result := TFhirInsurancePlanCoverageBenefit.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirInsurancePlanCoverageBenefitList.InsertItem(index: Integer; value: TFhirInsurancePlanCoverageBenefit);
begin
  assert(value is TFhirInsurancePlanCoverageBenefit);
  Inherited Insert(index, value);
end;

function TFhirInsurancePlanCoverageBenefitList.Item(index: Integer): TFhirInsurancePlanCoverageBenefit;
begin
  result := TFhirInsurancePlanCoverageBenefit(ObjectByIndex[index]);
end;

function TFhirInsurancePlanCoverageBenefitList.Link: TFhirInsurancePlanCoverageBenefitList;
begin
  result := TFhirInsurancePlanCoverageBenefitList(inherited Link);
end;

procedure TFhirInsurancePlanCoverageBenefitList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirInsurancePlanCoverageBenefitList.SetItemByIndex(index: Integer; value: TFhirInsurancePlanCoverageBenefit);
begin
  assert(value is TFhirInsurancePlanCoverageBenefit);
  FhirInsurancePlanCoverageBenefits[index] := value;
end;

procedure TFhirInsurancePlanCoverageBenefitList.SetItemN(index: Integer; value: TFhirInsurancePlanCoverageBenefit);
begin
  assert(value is TFhirInsurancePlanCoverageBenefit);
  ObjectByIndex[index] := value;
end;

{ TFhirInsurancePlanCoverageBenefitLimit }

constructor TFhirInsurancePlanCoverageBenefitLimit.Create;
begin
  inherited;
end;

destructor TFhirInsurancePlanCoverageBenefitLimit.Destroy;
begin
  FValue.free;
  FCode.free;
  inherited;
end;

procedure TFhirInsurancePlanCoverageBenefitLimit.Assign(oSource : TFslObject);
begin
  inherited;
  value := TFhirInsurancePlanCoverageBenefitLimit(oSource).value.Clone;
  code := TFhirInsurancePlanCoverageBenefitLimit(oSource).code.Clone;
end;

procedure TFhirInsurancePlanCoverageBenefitLimit.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'value') Then
     list.add(self.link, 'value', FValue.Link);
  if (child_name = 'code') Then
     list.add(self.link, 'code', FCode.Link);
end;

procedure TFhirInsurancePlanCoverageBenefitLimit.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'value', 'Quantity', false, TFhirQuantity, FValue.Link));
  oList.add(TFHIRProperty.create(self, 'code', 'CodeableConcept', false, TFhirCodeableConcept, FCode.Link));
end;

function TFhirInsurancePlanCoverageBenefitLimit.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'value') then
  begin
    Value := propValue as TFhirQuantity;
    result := propValue;
  end
  else if (propName = 'code') then
  begin
    Code := propValue as TFhirCodeableConcept;
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirInsurancePlanCoverageBenefitLimit.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirInsurancePlanCoverageBenefitLimit.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'value') then result := TFhirQuantity.create()
  else if (propName = 'code') then result := TFhirCodeableConcept.create()
  else result := inherited createPropertyValue(propName);
end;

function TFhirInsurancePlanCoverageBenefitLimit.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'value') then result := 'Quantity'
  else if (propName = 'code') then result := 'CodeableConcept'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirInsurancePlanCoverageBenefitLimit.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'value') then ValueElement := nil
  else if (propName = 'code') then CodeElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirInsurancePlanCoverageBenefitLimit.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'value') then ValueElement := new as TFhirQuantity
  else if (propName = 'code') then CodeElement := new as TFhirCodeableConcept
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirInsurancePlanCoverageBenefitLimit.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirInsurancePlanCoverageBenefitLimit.fhirType : string;
begin
  result := 'InsurancePlan.coverage.benefit.limit';
end;

function TFhirInsurancePlanCoverageBenefitLimit.Link : TFhirInsurancePlanCoverageBenefitLimit;
begin
  result := TFhirInsurancePlanCoverageBenefitLimit(inherited Link);
end;

function TFhirInsurancePlanCoverageBenefitLimit.Clone : TFhirInsurancePlanCoverageBenefitLimit;
begin
  result := TFhirInsurancePlanCoverageBenefitLimit(inherited Clone);
end;

function TFhirInsurancePlanCoverageBenefitLimit.equals(other : TObject) : boolean; 
var
  o : TFhirInsurancePlanCoverageBenefitLimit;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirInsurancePlanCoverageBenefitLimit)) then
    result := false
  else
  begin
    o := TFhirInsurancePlanCoverageBenefitLimit(other);
    result := compareDeep(valueElement, o.valueElement, true) and compareDeep(codeElement, o.codeElement, true);
  end;
end;

function TFhirInsurancePlanCoverageBenefitLimit.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FValue) and isEmptyProp(FCode);
end;

procedure TFhirInsurancePlanCoverageBenefitLimit.listFieldsInOrder(fields : TStringList);
begin
  inherited listFieldsInOrder(fields);
  fields.add('value');
  fields.add('code');
end;

function TFhirInsurancePlanCoverageBenefitLimit.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
end;

procedure TFhirInsurancePlanCoverageBenefitLimit.SetValue(value : TFhirQuantity);
begin
  FValue.free;
  FValue := value;
end;

procedure TFhirInsurancePlanCoverageBenefitLimit.SetCode(value : TFhirCodeableConcept);
begin
  FCode.free;
  FCode := value;
end;

{ TFhirInsurancePlanCoverageBenefitLimitListEnumerator }

constructor TFhirInsurancePlanCoverageBenefitLimitListEnumerator.Create(list : TFhirInsurancePlanCoverageBenefitLimitList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirInsurancePlanCoverageBenefitLimitListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirInsurancePlanCoverageBenefitLimitListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirInsurancePlanCoverageBenefitLimitListEnumerator.GetCurrent : TFhirInsurancePlanCoverageBenefitLimit;
begin
  Result := FList[FIndex];
end;

function TFhirInsurancePlanCoverageBenefitLimitListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirInsurancePlanCoverageBenefitLimitList }

procedure TFhirInsurancePlanCoverageBenefitLimitList.AddItem(value: TFhirInsurancePlanCoverageBenefitLimit);
begin
  assert(value.ClassName = 'TFhirInsurancePlanCoverageBenefitLimit', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirInsurancePlanCoverageBenefitLimit');
  add(value);
end;

function TFhirInsurancePlanCoverageBenefitLimitList.Append: TFhirInsurancePlanCoverageBenefitLimit;
begin
  result := TFhirInsurancePlanCoverageBenefitLimit.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirInsurancePlanCoverageBenefitLimitList.ClearItems;
begin
  Clear;
end;

function TFhirInsurancePlanCoverageBenefitLimitList.GetEnumerator : TFhirInsurancePlanCoverageBenefitLimitListEnumerator;
begin
  result := TFhirInsurancePlanCoverageBenefitLimitListEnumerator.Create(self.link);
end;

function TFhirInsurancePlanCoverageBenefitLimitList.Clone: TFhirInsurancePlanCoverageBenefitLimitList;
begin
  result := TFhirInsurancePlanCoverageBenefitLimitList(inherited Clone);
end;

function TFhirInsurancePlanCoverageBenefitLimitList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirInsurancePlanCoverageBenefitLimitList.GetItemN(index: Integer): TFhirInsurancePlanCoverageBenefitLimit;
begin
  result := TFhirInsurancePlanCoverageBenefitLimit(ObjectByIndex[index]);
end;

function TFhirInsurancePlanCoverageBenefitLimitList.ItemClass: TFslObjectClass;
begin
  result := TFhirInsurancePlanCoverageBenefitLimit;
end;
function TFhirInsurancePlanCoverageBenefitLimitList.IndexOf(value: TFhirInsurancePlanCoverageBenefitLimit): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirInsurancePlanCoverageBenefitLimitList.Insert(index: Integer): TFhirInsurancePlanCoverageBenefitLimit;
begin
  result := TFhirInsurancePlanCoverageBenefitLimit.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirInsurancePlanCoverageBenefitLimitList.InsertItem(index: Integer; value: TFhirInsurancePlanCoverageBenefitLimit);
begin
  assert(value is TFhirInsurancePlanCoverageBenefitLimit);
  Inherited Insert(index, value);
end;

function TFhirInsurancePlanCoverageBenefitLimitList.Item(index: Integer): TFhirInsurancePlanCoverageBenefitLimit;
begin
  result := TFhirInsurancePlanCoverageBenefitLimit(ObjectByIndex[index]);
end;

function TFhirInsurancePlanCoverageBenefitLimitList.Link: TFhirInsurancePlanCoverageBenefitLimitList;
begin
  result := TFhirInsurancePlanCoverageBenefitLimitList(inherited Link);
end;

procedure TFhirInsurancePlanCoverageBenefitLimitList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirInsurancePlanCoverageBenefitLimitList.SetItemByIndex(index: Integer; value: TFhirInsurancePlanCoverageBenefitLimit);
begin
  assert(value is TFhirInsurancePlanCoverageBenefitLimit);
  FhirInsurancePlanCoverageBenefitLimits[index] := value;
end;

procedure TFhirInsurancePlanCoverageBenefitLimitList.SetItemN(index: Integer; value: TFhirInsurancePlanCoverageBenefitLimit);
begin
  assert(value is TFhirInsurancePlanCoverageBenefitLimit);
  ObjectByIndex[index] := value;
end;

{ TFhirInsurancePlanPlan }

constructor TFhirInsurancePlanPlan.Create;
begin
  inherited;
end;

destructor TFhirInsurancePlanPlan.Destroy;
begin
  FIdentifierList.Free;
  FType_.free;
  FCoverageAreaList.Free;
  FNetworkList.Free;
  FGeneralCostList.Free;
  FSpecificCostList.Free;
  inherited;
end;

procedure TFhirInsurancePlanPlan.Assign(oSource : TFslObject);
begin
  inherited;
  if (TFhirInsurancePlanPlan(oSource).FIdentifierList = nil) then
  begin
    FIdentifierList.free;
    FIdentifierList := nil;
  end
  else
  begin
    if FIdentifierList = nil then
      FIdentifierList := TFhirIdentifierList.Create;
    FIdentifierList.Assign(TFhirInsurancePlanPlan(oSource).FIdentifierList);
  end;
  type_ := TFhirInsurancePlanPlan(oSource).type_.Clone;
  if (TFhirInsurancePlanPlan(oSource).FCoverageAreaList = nil) then
  begin
    FCoverageAreaList.free;
    FCoverageAreaList := nil;
  end
  else
  begin
    if FCoverageAreaList = nil then
      FCoverageAreaList := TFhirReferenceList.Create;
    FCoverageAreaList.Assign(TFhirInsurancePlanPlan(oSource).FCoverageAreaList);
  end;
  if (TFhirInsurancePlanPlan(oSource).FNetworkList = nil) then
  begin
    FNetworkList.free;
    FNetworkList := nil;
  end
  else
  begin
    if FNetworkList = nil then
      FNetworkList := TFhirReferenceList.Create;
    FNetworkList.Assign(TFhirInsurancePlanPlan(oSource).FNetworkList);
  end;
  if (TFhirInsurancePlanPlan(oSource).FGeneralCostList = nil) then
  begin
    FGeneralCostList.free;
    FGeneralCostList := nil;
  end
  else
  begin
    if FGeneralCostList = nil then
      FGeneralCostList := TFhirInsurancePlanPlanGeneralCostList.Create;
    FGeneralCostList.Assign(TFhirInsurancePlanPlan(oSource).FGeneralCostList);
  end;
  if (TFhirInsurancePlanPlan(oSource).FSpecificCostList = nil) then
  begin
    FSpecificCostList.free;
    FSpecificCostList := nil;
  end
  else
  begin
    if FSpecificCostList = nil then
      FSpecificCostList := TFhirInsurancePlanPlanSpecificCostList.Create;
    FSpecificCostList.Assign(TFhirInsurancePlanPlan(oSource).FSpecificCostList);
  end;
end;

procedure TFhirInsurancePlanPlan.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'identifier') Then
    list.addAll(self, 'identifier', FIdentifierList);
  if (child_name = 'type') Then
     list.add(self.link, 'type', FType_.Link);
  if (child_name = 'coverageArea') Then
    list.addAll(self, 'coverageArea', FCoverageAreaList);
  if (child_name = 'network') Then
    list.addAll(self, 'network', FNetworkList);
  if (child_name = 'generalCost') Then
    list.addAll(self, 'generalCost', FGeneralCostList);
  if (child_name = 'specificCost') Then
    list.addAll(self, 'specificCost', FSpecificCostList);
end;

procedure TFhirInsurancePlanPlan.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'identifier', 'Identifier', true, TFhirIdentifier, FIdentifierList.Link));
  oList.add(TFHIRProperty.create(self, 'type', 'CodeableConcept', false, TFhirCodeableConcept, FType_.Link));
  oList.add(TFHIRProperty.create(self, 'coverageArea', 'Reference', true, TFhirReference, FCoverageAreaList.Link));
  oList.add(TFHIRProperty.create(self, 'network', 'Reference', true, TFhirReference, FNetworkList.Link));
  oList.add(TFHIRProperty.create(self, 'generalCost', 'BackboneElement', true, TFhirInsurancePlanPlanGeneralCost, FGeneralCostList.Link));
  oList.add(TFHIRProperty.create(self, 'specificCost', 'BackboneElement', true, TFhirInsurancePlanPlanSpecificCost, FSpecificCostList.Link));
end;

function TFhirInsurancePlanPlan.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'identifier') then
  begin
    IdentifierList.add(propValue as TFhirIdentifier);
    result := propValue;
  end
  else if (propName = 'type') then
  begin
    Type_ := propValue as TFhirCodeableConcept;
    result := propValue;
  end
  else if (propName = 'coverageArea') then
  begin
    CoverageAreaList.add(propValue as TFhirReference);
    result := propValue;
  end
  else if (propName = 'network') then
  begin
    NetworkList.add(propValue as TFhirReference);
    result := propValue;
  end
  else if (propName = 'generalCost') then
  begin
    GeneralCostList.add(propValue as TFhirInsurancePlanPlanGeneralCost);
    result := propValue;
  end
  else if (propName = 'specificCost') then
  begin
    SpecificCostList.add(propValue as TFhirInsurancePlanPlanSpecificCost);
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirInsurancePlanPlan.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'identifier') then IdentifierList.insertItem(index, propValue as TFhirIdentifier)
  else if (propName = 'coverageArea') then CoverageAreaList.insertItem(index, propValue as TFhirReference)
  else if (propName = 'network') then NetworkList.insertItem(index, propValue as TFhirReference)
  else if (propName = 'generalCost') then GeneralCostList.insertItem(index, propValue as TFhirInsurancePlanPlanGeneralCost)
  else if (propName = 'specificCost') then SpecificCostList.insertItem(index, propValue as TFhirInsurancePlanPlanSpecificCost)
  else inherited;
end;

function TFhirInsurancePlanPlan.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'identifier') then result := IdentifierList.new()
  else if (propName = 'type') then result := TFhirCodeableConcept.create()
  else if (propName = 'coverageArea') then result := CoverageAreaList.new()
  else if (propName = 'network') then result := NetworkList.new()
  else if (propName = 'generalCost') then result := GeneralCostList.new()
  else if (propName = 'specificCost') then result := SpecificCostList.new()
  else result := inherited createPropertyValue(propName);
end;

function TFhirInsurancePlanPlan.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'identifier') then result := 'Identifier'
  else if (propName = 'type') then result := 'CodeableConcept'
  else if (propName = 'coverageArea') then result := 'Reference'
  else if (propName = 'network') then result := 'Reference'
  else if (propName = 'generalCost') then result := 'BackboneElement'
  else if (propName = 'specificCost') then result := 'BackboneElement'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirInsurancePlanPlan.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'identifier') then deletePropertyValue('identifier', IdentifierList, value)
  else if (propName = 'type') then Type_Element := nil
  else if (propName = 'coverageArea') then deletePropertyValue('coverageArea', CoverageAreaList, value)
  else if (propName = 'network') then deletePropertyValue('network', NetworkList, value)
  else if (propName = 'generalCost') then deletePropertyValue('generalCost', GeneralCostList, value)
  else if (propName = 'specificCost') then deletePropertyValue('specificCost', SpecificCostList, value)
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirInsurancePlanPlan.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'identifier') then replacePropertyValue('identifier', IdentifierList, existing, new)
  else if (propName = 'type') then Type_Element := new as TFhirCodeableConcept
  else if (propName = 'coverageArea') then replacePropertyValue('coverageArea', CoverageAreaList, existing, new)
  else if (propName = 'network') then replacePropertyValue('network', NetworkList, existing, new)
  else if (propName = 'generalCost') then replacePropertyValue('generalCost', GeneralCostList, existing, new)
  else if (propName = 'specificCost') then replacePropertyValue('specificCost', SpecificCostList, existing, new)
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirInsurancePlanPlan.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'identifier') then IdentifierList.move(source, destination)
  else if (propName = 'coverageArea') then CoverageAreaList.move(source, destination)
  else if (propName = 'network') then NetworkList.move(source, destination)
  else if (propName = 'generalCost') then GeneralCostList.move(source, destination)
  else if (propName = 'specificCost') then SpecificCostList.move(source, destination)
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirInsurancePlanPlan.fhirType : string;
begin
  result := 'InsurancePlan.plan';
end;

function TFhirInsurancePlanPlan.Link : TFhirInsurancePlanPlan;
begin
  result := TFhirInsurancePlanPlan(inherited Link);
end;

function TFhirInsurancePlanPlan.Clone : TFhirInsurancePlanPlan;
begin
  result := TFhirInsurancePlanPlan(inherited Clone);
end;

function TFhirInsurancePlanPlan.equals(other : TObject) : boolean; 
var
  o : TFhirInsurancePlanPlan;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirInsurancePlanPlan)) then
    result := false
  else
  begin
    o := TFhirInsurancePlanPlan(other);
    result := compareDeep(identifierList, o.identifierList, true) and compareDeep(type_Element, o.type_Element, true) and 
      compareDeep(coverageAreaList, o.coverageAreaList, true) and compareDeep(networkList, o.networkList, true) and 
      compareDeep(generalCostList, o.generalCostList, true) and compareDeep(specificCostList, o.specificCostList, true);
  end;
end;

function TFhirInsurancePlanPlan.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FidentifierList) and isEmptyProp(FType_) and isEmptyProp(FcoverageAreaList) and isEmptyProp(FnetworkList) and isEmptyProp(FgeneralCostList) and isEmptyProp(FspecificCostList);
end;

procedure TFhirInsurancePlanPlan.listFieldsInOrder(fields : TStringList);
begin
  inherited listFieldsInOrder(fields);
  fields.add('identifier');
  fields.add('type');
  fields.add('coverageArea');
  fields.add('network');
  fields.add('generalCost');
  fields.add('specificCost');
end;

function TFhirInsurancePlanPlan.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FIdentifierList.sizeInBytes(magic));
  inc(result, FCoverageAreaList.sizeInBytes(magic));
  inc(result, FNetworkList.sizeInBytes(magic));
  inc(result, FGeneralCostList.sizeInBytes(magic));
  inc(result, FSpecificCostList.sizeInBytes(magic));
end;

function TFhirInsurancePlanPlan.GetIdentifierList : TFhirIdentifierList;
begin
  if FIdentifierList = nil then
    FIdentifierList := TFhirIdentifierList.Create;
  result := FIdentifierList;
end;

function TFhirInsurancePlanPlan.GetHasIdentifierList : boolean;
begin
  result := (FIdentifierList <> nil) and (FIdentifierList.count > 0);
end;

procedure TFhirInsurancePlanPlan.SetType_(value : TFhirCodeableConcept);
begin
  FType_.free;
  FType_ := value;
end;

function TFhirInsurancePlanPlan.GetCoverageAreaList : TFhirReferenceList;
begin
  if FCoverageAreaList = nil then
    FCoverageAreaList := TFhirReferenceList.Create;
  result := FCoverageAreaList;
end;

function TFhirInsurancePlanPlan.GetHasCoverageAreaList : boolean;
begin
  result := (FCoverageAreaList <> nil) and (FCoverageAreaList.count > 0);
end;

function TFhirInsurancePlanPlan.GetNetworkList : TFhirReferenceList;
begin
  if FNetworkList = nil then
    FNetworkList := TFhirReferenceList.Create;
  result := FNetworkList;
end;

function TFhirInsurancePlanPlan.GetHasNetworkList : boolean;
begin
  result := (FNetworkList <> nil) and (FNetworkList.count > 0);
end;

function TFhirInsurancePlanPlan.GetGeneralCostList : TFhirInsurancePlanPlanGeneralCostList;
begin
  if FGeneralCostList = nil then
    FGeneralCostList := TFhirInsurancePlanPlanGeneralCostList.Create;
  result := FGeneralCostList;
end;

function TFhirInsurancePlanPlan.GetHasGeneralCostList : boolean;
begin
  result := (FGeneralCostList <> nil) and (FGeneralCostList.count > 0);
end;

function TFhirInsurancePlanPlan.GetSpecificCostList : TFhirInsurancePlanPlanSpecificCostList;
begin
  if FSpecificCostList = nil then
    FSpecificCostList := TFhirInsurancePlanPlanSpecificCostList.Create;
  result := FSpecificCostList;
end;

function TFhirInsurancePlanPlan.GetHasSpecificCostList : boolean;
begin
  result := (FSpecificCostList <> nil) and (FSpecificCostList.count > 0);
end;

{ TFhirInsurancePlanPlanListEnumerator }

constructor TFhirInsurancePlanPlanListEnumerator.Create(list : TFhirInsurancePlanPlanList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirInsurancePlanPlanListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirInsurancePlanPlanListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirInsurancePlanPlanListEnumerator.GetCurrent : TFhirInsurancePlanPlan;
begin
  Result := FList[FIndex];
end;

function TFhirInsurancePlanPlanListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirInsurancePlanPlanList }

procedure TFhirInsurancePlanPlanList.AddItem(value: TFhirInsurancePlanPlan);
begin
  assert(value.ClassName = 'TFhirInsurancePlanPlan', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirInsurancePlanPlan');
  add(value);
end;

function TFhirInsurancePlanPlanList.Append: TFhirInsurancePlanPlan;
begin
  result := TFhirInsurancePlanPlan.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirInsurancePlanPlanList.ClearItems;
begin
  Clear;
end;

function TFhirInsurancePlanPlanList.GetEnumerator : TFhirInsurancePlanPlanListEnumerator;
begin
  result := TFhirInsurancePlanPlanListEnumerator.Create(self.link);
end;

function TFhirInsurancePlanPlanList.Clone: TFhirInsurancePlanPlanList;
begin
  result := TFhirInsurancePlanPlanList(inherited Clone);
end;

function TFhirInsurancePlanPlanList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirInsurancePlanPlanList.GetItemN(index: Integer): TFhirInsurancePlanPlan;
begin
  result := TFhirInsurancePlanPlan(ObjectByIndex[index]);
end;

function TFhirInsurancePlanPlanList.ItemClass: TFslObjectClass;
begin
  result := TFhirInsurancePlanPlan;
end;
function TFhirInsurancePlanPlanList.IndexOf(value: TFhirInsurancePlanPlan): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirInsurancePlanPlanList.Insert(index: Integer): TFhirInsurancePlanPlan;
begin
  result := TFhirInsurancePlanPlan.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirInsurancePlanPlanList.InsertItem(index: Integer; value: TFhirInsurancePlanPlan);
begin
  assert(value is TFhirInsurancePlanPlan);
  Inherited Insert(index, value);
end;

function TFhirInsurancePlanPlanList.Item(index: Integer): TFhirInsurancePlanPlan;
begin
  result := TFhirInsurancePlanPlan(ObjectByIndex[index]);
end;

function TFhirInsurancePlanPlanList.Link: TFhirInsurancePlanPlanList;
begin
  result := TFhirInsurancePlanPlanList(inherited Link);
end;

procedure TFhirInsurancePlanPlanList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirInsurancePlanPlanList.SetItemByIndex(index: Integer; value: TFhirInsurancePlanPlan);
begin
  assert(value is TFhirInsurancePlanPlan);
  FhirInsurancePlanPlans[index] := value;
end;

procedure TFhirInsurancePlanPlanList.SetItemN(index: Integer; value: TFhirInsurancePlanPlan);
begin
  assert(value is TFhirInsurancePlanPlan);
  ObjectByIndex[index] := value;
end;

{ TFhirInsurancePlanPlanGeneralCost }

constructor TFhirInsurancePlanPlanGeneralCost.Create;
begin
  inherited;
end;

destructor TFhirInsurancePlanPlanGeneralCost.Destroy;
begin
  FType_.free;
  FGroupSize.free;
  FCost.free;
  FComment.free;
  inherited;
end;

procedure TFhirInsurancePlanPlanGeneralCost.Assign(oSource : TFslObject);
begin
  inherited;
  type_ := TFhirInsurancePlanPlanGeneralCost(oSource).type_.Clone;
  groupSizeElement := TFhirInsurancePlanPlanGeneralCost(oSource).groupSizeElement.Clone;
  cost := TFhirInsurancePlanPlanGeneralCost(oSource).cost.Clone;
  commentElement := TFhirInsurancePlanPlanGeneralCost(oSource).commentElement.Clone;
end;

procedure TFhirInsurancePlanPlanGeneralCost.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'type') Then
     list.add(self.link, 'type', FType_.Link);
  if (child_name = 'groupSize') Then
     list.add(self.link, 'groupSize', FGroupSize.Link);
  if (child_name = 'cost') Then
     list.add(self.link, 'cost', FCost.Link);
  if (child_name = 'comment') Then
     list.add(self.link, 'comment', FComment.Link);
end;

procedure TFhirInsurancePlanPlanGeneralCost.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'type', 'CodeableConcept', false, TFhirCodeableConcept, FType_.Link));
  oList.add(TFHIRProperty.create(self, 'groupSize', 'positiveInt', false, TFhirPositiveInt, FGroupSize.Link));
  oList.add(TFHIRProperty.create(self, 'cost', 'Money', false, TFhirMoney, FCost.Link));
  oList.add(TFHIRProperty.create(self, 'comment', 'string', false, TFhirString, FComment.Link));
end;

function TFhirInsurancePlanPlanGeneralCost.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'type') then
  begin
    Type_ := propValue as TFhirCodeableConcept;
    result := propValue;
  end
  else if (propName = 'groupSize') then
  begin
    GroupSizeElement := asPositiveInt(propValue);
    result := propValue;
  end
  else if (propName = 'cost') then
  begin
    Cost := propValue as TFhirMoney;
    result := propValue;
  end
  else if (propName = 'comment') then
  begin
    CommentElement := asString(propValue);
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirInsurancePlanPlanGeneralCost.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirInsurancePlanPlanGeneralCost.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'type') then result := TFhirCodeableConcept.create()
  else if (propName = 'groupSize') then result := TFhirPositiveInt.create()
  else if (propName = 'cost') then result := TFhirMoney.create()
  else if (propName = 'comment') then result := TFhirString.create()
  else result := inherited createPropertyValue(propName);
end;

function TFhirInsurancePlanPlanGeneralCost.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'type') then result := 'CodeableConcept'
  else if (propName = 'groupSize') then result := 'positiveInt'
  else if (propName = 'cost') then result := 'Money'
  else if (propName = 'comment') then result := 'string'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirInsurancePlanPlanGeneralCost.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'type') then Type_Element := nil
  else if (propName = 'groupSize') then GroupSizeElement := nil
  else if (propName = 'cost') then CostElement := nil
  else if (propName = 'comment') then CommentElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirInsurancePlanPlanGeneralCost.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'type') then Type_Element := new as TFhirCodeableConcept
  else if (propName = 'groupSize') then GroupSizeElement := asPositiveInt(new)
  else if (propName = 'cost') then CostElement := new as TFhirMoney
  else if (propName = 'comment') then CommentElement := asString(new)
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirInsurancePlanPlanGeneralCost.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirInsurancePlanPlanGeneralCost.fhirType : string;
begin
  result := 'InsurancePlan.plan.generalCost';
end;

function TFhirInsurancePlanPlanGeneralCost.Link : TFhirInsurancePlanPlanGeneralCost;
begin
  result := TFhirInsurancePlanPlanGeneralCost(inherited Link);
end;

function TFhirInsurancePlanPlanGeneralCost.Clone : TFhirInsurancePlanPlanGeneralCost;
begin
  result := TFhirInsurancePlanPlanGeneralCost(inherited Clone);
end;

function TFhirInsurancePlanPlanGeneralCost.equals(other : TObject) : boolean; 
var
  o : TFhirInsurancePlanPlanGeneralCost;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirInsurancePlanPlanGeneralCost)) then
    result := false
  else
  begin
    o := TFhirInsurancePlanPlanGeneralCost(other);
    result := compareDeep(type_Element, o.type_Element, true) and compareDeep(groupSizeElement, o.groupSizeElement, true) and 
      compareDeep(costElement, o.costElement, true) and compareDeep(commentElement, o.commentElement, true);
  end;
end;

function TFhirInsurancePlanPlanGeneralCost.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FType_) and isEmptyProp(FGroupSize) and isEmptyProp(FCost) and isEmptyProp(FComment);
end;

procedure TFhirInsurancePlanPlanGeneralCost.listFieldsInOrder(fields : TStringList);
begin
  inherited listFieldsInOrder(fields);
  fields.add('type');
  fields.add('groupSize');
  fields.add('cost');
  fields.add('comment');
end;

function TFhirInsurancePlanPlanGeneralCost.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
end;

procedure TFhirInsurancePlanPlanGeneralCost.SetType_(value : TFhirCodeableConcept);
begin
  FType_.free;
  FType_ := value;
end;

procedure TFhirInsurancePlanPlanGeneralCost.SetGroupSize(value : TFhirPositiveInt);
begin
  FGroupSize.free;
  FGroupSize := value;
end;

function TFhirInsurancePlanPlanGeneralCost.GetGroupSizeST : String;
begin
  if FGroupSize = nil then
    result := ''
  else
    result := FGroupSize.value;
end;

procedure TFhirInsurancePlanPlanGeneralCost.SetGroupSizeST(value : String);
begin
  if value <> '' then
  begin
    if FGroupSize = nil then
      FGroupSize := TFhirPositiveInt.create;
    FGroupSize.value := value
  end
  else if FGroupSize <> nil then
    FGroupSize.value := '';
end;

procedure TFhirInsurancePlanPlanGeneralCost.SetCost(value : TFhirMoney);
begin
  FCost.free;
  FCost := value;
end;

procedure TFhirInsurancePlanPlanGeneralCost.SetComment(value : TFhirString);
begin
  FComment.free;
  FComment := value;
end;

function TFhirInsurancePlanPlanGeneralCost.GetCommentST : String;
begin
  if FComment = nil then
    result := ''
  else
    result := FComment.value;
end;

procedure TFhirInsurancePlanPlanGeneralCost.SetCommentST(value : String);
begin
  if value <> '' then
  begin
    if FComment = nil then
      FComment := TFhirString.create;
    FComment.value := value
  end
  else if FComment <> nil then
    FComment.value := '';
end;

{ TFhirInsurancePlanPlanGeneralCostListEnumerator }

constructor TFhirInsurancePlanPlanGeneralCostListEnumerator.Create(list : TFhirInsurancePlanPlanGeneralCostList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirInsurancePlanPlanGeneralCostListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirInsurancePlanPlanGeneralCostListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirInsurancePlanPlanGeneralCostListEnumerator.GetCurrent : TFhirInsurancePlanPlanGeneralCost;
begin
  Result := FList[FIndex];
end;

function TFhirInsurancePlanPlanGeneralCostListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirInsurancePlanPlanGeneralCostList }

procedure TFhirInsurancePlanPlanGeneralCostList.AddItem(value: TFhirInsurancePlanPlanGeneralCost);
begin
  assert(value.ClassName = 'TFhirInsurancePlanPlanGeneralCost', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirInsurancePlanPlanGeneralCost');
  add(value);
end;

function TFhirInsurancePlanPlanGeneralCostList.Append: TFhirInsurancePlanPlanGeneralCost;
begin
  result := TFhirInsurancePlanPlanGeneralCost.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirInsurancePlanPlanGeneralCostList.ClearItems;
begin
  Clear;
end;

function TFhirInsurancePlanPlanGeneralCostList.GetEnumerator : TFhirInsurancePlanPlanGeneralCostListEnumerator;
begin
  result := TFhirInsurancePlanPlanGeneralCostListEnumerator.Create(self.link);
end;

function TFhirInsurancePlanPlanGeneralCostList.Clone: TFhirInsurancePlanPlanGeneralCostList;
begin
  result := TFhirInsurancePlanPlanGeneralCostList(inherited Clone);
end;

function TFhirInsurancePlanPlanGeneralCostList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirInsurancePlanPlanGeneralCostList.GetItemN(index: Integer): TFhirInsurancePlanPlanGeneralCost;
begin
  result := TFhirInsurancePlanPlanGeneralCost(ObjectByIndex[index]);
end;

function TFhirInsurancePlanPlanGeneralCostList.ItemClass: TFslObjectClass;
begin
  result := TFhirInsurancePlanPlanGeneralCost;
end;
function TFhirInsurancePlanPlanGeneralCostList.IndexOf(value: TFhirInsurancePlanPlanGeneralCost): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirInsurancePlanPlanGeneralCostList.Insert(index: Integer): TFhirInsurancePlanPlanGeneralCost;
begin
  result := TFhirInsurancePlanPlanGeneralCost.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirInsurancePlanPlanGeneralCostList.InsertItem(index: Integer; value: TFhirInsurancePlanPlanGeneralCost);
begin
  assert(value is TFhirInsurancePlanPlanGeneralCost);
  Inherited Insert(index, value);
end;

function TFhirInsurancePlanPlanGeneralCostList.Item(index: Integer): TFhirInsurancePlanPlanGeneralCost;
begin
  result := TFhirInsurancePlanPlanGeneralCost(ObjectByIndex[index]);
end;

function TFhirInsurancePlanPlanGeneralCostList.Link: TFhirInsurancePlanPlanGeneralCostList;
begin
  result := TFhirInsurancePlanPlanGeneralCostList(inherited Link);
end;

procedure TFhirInsurancePlanPlanGeneralCostList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirInsurancePlanPlanGeneralCostList.SetItemByIndex(index: Integer; value: TFhirInsurancePlanPlanGeneralCost);
begin
  assert(value is TFhirInsurancePlanPlanGeneralCost);
  FhirInsurancePlanPlanGeneralCosts[index] := value;
end;

procedure TFhirInsurancePlanPlanGeneralCostList.SetItemN(index: Integer; value: TFhirInsurancePlanPlanGeneralCost);
begin
  assert(value is TFhirInsurancePlanPlanGeneralCost);
  ObjectByIndex[index] := value;
end;

{ TFhirInsurancePlanPlanSpecificCost }

constructor TFhirInsurancePlanPlanSpecificCost.Create;
begin
  inherited;
end;

destructor TFhirInsurancePlanPlanSpecificCost.Destroy;
begin
  FCategory.free;
  FBenefitList.Free;
  inherited;
end;

procedure TFhirInsurancePlanPlanSpecificCost.Assign(oSource : TFslObject);
begin
  inherited;
  category := TFhirInsurancePlanPlanSpecificCost(oSource).category.Clone;
  if (TFhirInsurancePlanPlanSpecificCost(oSource).FBenefitList = nil) then
  begin
    FBenefitList.free;
    FBenefitList := nil;
  end
  else
  begin
    if FBenefitList = nil then
      FBenefitList := TFhirInsurancePlanPlanSpecificCostBenefitList.Create;
    FBenefitList.Assign(TFhirInsurancePlanPlanSpecificCost(oSource).FBenefitList);
  end;
end;

procedure TFhirInsurancePlanPlanSpecificCost.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'category') Then
     list.add(self.link, 'category', FCategory.Link);
  if (child_name = 'benefit') Then
    list.addAll(self, 'benefit', FBenefitList);
end;

procedure TFhirInsurancePlanPlanSpecificCost.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'category', 'CodeableConcept', false, TFhirCodeableConcept, FCategory.Link));
  oList.add(TFHIRProperty.create(self, 'benefit', 'BackboneElement', true, TFhirInsurancePlanPlanSpecificCostBenefit, FBenefitList.Link));
end;

function TFhirInsurancePlanPlanSpecificCost.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'category') then
  begin
    Category := propValue as TFhirCodeableConcept;
    result := propValue;
  end
  else if (propName = 'benefit') then
  begin
    BenefitList.add(propValue as TFhirInsurancePlanPlanSpecificCostBenefit);
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirInsurancePlanPlanSpecificCost.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'benefit') then BenefitList.insertItem(index, propValue as TFhirInsurancePlanPlanSpecificCostBenefit)
  else inherited;
end;

function TFhirInsurancePlanPlanSpecificCost.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'category') then result := TFhirCodeableConcept.create()
  else if (propName = 'benefit') then result := BenefitList.new()
  else result := inherited createPropertyValue(propName);
end;

function TFhirInsurancePlanPlanSpecificCost.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'category') then result := 'CodeableConcept'
  else if (propName = 'benefit') then result := 'BackboneElement'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirInsurancePlanPlanSpecificCost.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'category') then CategoryElement := nil
  else if (propName = 'benefit') then deletePropertyValue('benefit', BenefitList, value)
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirInsurancePlanPlanSpecificCost.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'category') then CategoryElement := new as TFhirCodeableConcept
  else if (propName = 'benefit') then replacePropertyValue('benefit', BenefitList, existing, new)
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirInsurancePlanPlanSpecificCost.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'benefit') then BenefitList.move(source, destination)
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirInsurancePlanPlanSpecificCost.fhirType : string;
begin
  result := 'InsurancePlan.plan.specificCost';
end;

function TFhirInsurancePlanPlanSpecificCost.Link : TFhirInsurancePlanPlanSpecificCost;
begin
  result := TFhirInsurancePlanPlanSpecificCost(inherited Link);
end;

function TFhirInsurancePlanPlanSpecificCost.Clone : TFhirInsurancePlanPlanSpecificCost;
begin
  result := TFhirInsurancePlanPlanSpecificCost(inherited Clone);
end;

function TFhirInsurancePlanPlanSpecificCost.equals(other : TObject) : boolean; 
var
  o : TFhirInsurancePlanPlanSpecificCost;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirInsurancePlanPlanSpecificCost)) then
    result := false
  else
  begin
    o := TFhirInsurancePlanPlanSpecificCost(other);
    result := compareDeep(categoryElement, o.categoryElement, true) and compareDeep(benefitList, o.benefitList, true);
  end;
end;

function TFhirInsurancePlanPlanSpecificCost.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FCategory) and isEmptyProp(FbenefitList);
end;

procedure TFhirInsurancePlanPlanSpecificCost.listFieldsInOrder(fields : TStringList);
begin
  inherited listFieldsInOrder(fields);
  fields.add('category');
  fields.add('benefit');
end;

function TFhirInsurancePlanPlanSpecificCost.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FBenefitList.sizeInBytes(magic));
end;

procedure TFhirInsurancePlanPlanSpecificCost.SetCategory(value : TFhirCodeableConcept);
begin
  FCategory.free;
  FCategory := value;
end;

function TFhirInsurancePlanPlanSpecificCost.GetBenefitList : TFhirInsurancePlanPlanSpecificCostBenefitList;
begin
  if FBenefitList = nil then
    FBenefitList := TFhirInsurancePlanPlanSpecificCostBenefitList.Create;
  result := FBenefitList;
end;

function TFhirInsurancePlanPlanSpecificCost.GetHasBenefitList : boolean;
begin
  result := (FBenefitList <> nil) and (FBenefitList.count > 0);
end;

{ TFhirInsurancePlanPlanSpecificCostListEnumerator }

constructor TFhirInsurancePlanPlanSpecificCostListEnumerator.Create(list : TFhirInsurancePlanPlanSpecificCostList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirInsurancePlanPlanSpecificCostListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirInsurancePlanPlanSpecificCostListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirInsurancePlanPlanSpecificCostListEnumerator.GetCurrent : TFhirInsurancePlanPlanSpecificCost;
begin
  Result := FList[FIndex];
end;

function TFhirInsurancePlanPlanSpecificCostListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirInsurancePlanPlanSpecificCostList }

procedure TFhirInsurancePlanPlanSpecificCostList.AddItem(value: TFhirInsurancePlanPlanSpecificCost);
begin
  assert(value.ClassName = 'TFhirInsurancePlanPlanSpecificCost', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirInsurancePlanPlanSpecificCost');
  add(value);
end;

function TFhirInsurancePlanPlanSpecificCostList.Append: TFhirInsurancePlanPlanSpecificCost;
begin
  result := TFhirInsurancePlanPlanSpecificCost.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirInsurancePlanPlanSpecificCostList.ClearItems;
begin
  Clear;
end;

function TFhirInsurancePlanPlanSpecificCostList.GetEnumerator : TFhirInsurancePlanPlanSpecificCostListEnumerator;
begin
  result := TFhirInsurancePlanPlanSpecificCostListEnumerator.Create(self.link);
end;

function TFhirInsurancePlanPlanSpecificCostList.Clone: TFhirInsurancePlanPlanSpecificCostList;
begin
  result := TFhirInsurancePlanPlanSpecificCostList(inherited Clone);
end;

function TFhirInsurancePlanPlanSpecificCostList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirInsurancePlanPlanSpecificCostList.GetItemN(index: Integer): TFhirInsurancePlanPlanSpecificCost;
begin
  result := TFhirInsurancePlanPlanSpecificCost(ObjectByIndex[index]);
end;

function TFhirInsurancePlanPlanSpecificCostList.ItemClass: TFslObjectClass;
begin
  result := TFhirInsurancePlanPlanSpecificCost;
end;
function TFhirInsurancePlanPlanSpecificCostList.IndexOf(value: TFhirInsurancePlanPlanSpecificCost): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirInsurancePlanPlanSpecificCostList.Insert(index: Integer): TFhirInsurancePlanPlanSpecificCost;
begin
  result := TFhirInsurancePlanPlanSpecificCost.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirInsurancePlanPlanSpecificCostList.InsertItem(index: Integer; value: TFhirInsurancePlanPlanSpecificCost);
begin
  assert(value is TFhirInsurancePlanPlanSpecificCost);
  Inherited Insert(index, value);
end;

function TFhirInsurancePlanPlanSpecificCostList.Item(index: Integer): TFhirInsurancePlanPlanSpecificCost;
begin
  result := TFhirInsurancePlanPlanSpecificCost(ObjectByIndex[index]);
end;

function TFhirInsurancePlanPlanSpecificCostList.Link: TFhirInsurancePlanPlanSpecificCostList;
begin
  result := TFhirInsurancePlanPlanSpecificCostList(inherited Link);
end;

procedure TFhirInsurancePlanPlanSpecificCostList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirInsurancePlanPlanSpecificCostList.SetItemByIndex(index: Integer; value: TFhirInsurancePlanPlanSpecificCost);
begin
  assert(value is TFhirInsurancePlanPlanSpecificCost);
  FhirInsurancePlanPlanSpecificCosts[index] := value;
end;

procedure TFhirInsurancePlanPlanSpecificCostList.SetItemN(index: Integer; value: TFhirInsurancePlanPlanSpecificCost);
begin
  assert(value is TFhirInsurancePlanPlanSpecificCost);
  ObjectByIndex[index] := value;
end;

{ TFhirInsurancePlanPlanSpecificCostBenefit }

constructor TFhirInsurancePlanPlanSpecificCostBenefit.Create;
begin
  inherited;
end;

destructor TFhirInsurancePlanPlanSpecificCostBenefit.Destroy;
begin
  FType_.free;
  FCostList.Free;
  inherited;
end;

procedure TFhirInsurancePlanPlanSpecificCostBenefit.Assign(oSource : TFslObject);
begin
  inherited;
  type_ := TFhirInsurancePlanPlanSpecificCostBenefit(oSource).type_.Clone;
  if (TFhirInsurancePlanPlanSpecificCostBenefit(oSource).FCostList = nil) then
  begin
    FCostList.free;
    FCostList := nil;
  end
  else
  begin
    if FCostList = nil then
      FCostList := TFhirInsurancePlanPlanSpecificCostBenefitCostList.Create;
    FCostList.Assign(TFhirInsurancePlanPlanSpecificCostBenefit(oSource).FCostList);
  end;
end;

procedure TFhirInsurancePlanPlanSpecificCostBenefit.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'type') Then
     list.add(self.link, 'type', FType_.Link);
  if (child_name = 'cost') Then
    list.addAll(self, 'cost', FCostList);
end;

procedure TFhirInsurancePlanPlanSpecificCostBenefit.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'type', 'CodeableConcept', false, TFhirCodeableConcept, FType_.Link));
  oList.add(TFHIRProperty.create(self, 'cost', 'BackboneElement', true, TFhirInsurancePlanPlanSpecificCostBenefitCost, FCostList.Link));
end;

function TFhirInsurancePlanPlanSpecificCostBenefit.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'type') then
  begin
    Type_ := propValue as TFhirCodeableConcept;
    result := propValue;
  end
  else if (propName = 'cost') then
  begin
    CostList.add(propValue as TFhirInsurancePlanPlanSpecificCostBenefitCost);
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirInsurancePlanPlanSpecificCostBenefit.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'cost') then CostList.insertItem(index, propValue as TFhirInsurancePlanPlanSpecificCostBenefitCost)
  else inherited;
end;

function TFhirInsurancePlanPlanSpecificCostBenefit.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'type') then result := TFhirCodeableConcept.create()
  else if (propName = 'cost') then result := CostList.new()
  else result := inherited createPropertyValue(propName);
end;

function TFhirInsurancePlanPlanSpecificCostBenefit.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'type') then result := 'CodeableConcept'
  else if (propName = 'cost') then result := 'BackboneElement'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirInsurancePlanPlanSpecificCostBenefit.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'type') then Type_Element := nil
  else if (propName = 'cost') then deletePropertyValue('cost', CostList, value)
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirInsurancePlanPlanSpecificCostBenefit.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'type') then Type_Element := new as TFhirCodeableConcept
  else if (propName = 'cost') then replacePropertyValue('cost', CostList, existing, new)
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirInsurancePlanPlanSpecificCostBenefit.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'cost') then CostList.move(source, destination)
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirInsurancePlanPlanSpecificCostBenefit.fhirType : string;
begin
  result := 'InsurancePlan.plan.specificCost.benefit';
end;

function TFhirInsurancePlanPlanSpecificCostBenefit.Link : TFhirInsurancePlanPlanSpecificCostBenefit;
begin
  result := TFhirInsurancePlanPlanSpecificCostBenefit(inherited Link);
end;

function TFhirInsurancePlanPlanSpecificCostBenefit.Clone : TFhirInsurancePlanPlanSpecificCostBenefit;
begin
  result := TFhirInsurancePlanPlanSpecificCostBenefit(inherited Clone);
end;

function TFhirInsurancePlanPlanSpecificCostBenefit.equals(other : TObject) : boolean; 
var
  o : TFhirInsurancePlanPlanSpecificCostBenefit;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirInsurancePlanPlanSpecificCostBenefit)) then
    result := false
  else
  begin
    o := TFhirInsurancePlanPlanSpecificCostBenefit(other);
    result := compareDeep(type_Element, o.type_Element, true) and compareDeep(costList, o.costList, true);
  end;
end;

function TFhirInsurancePlanPlanSpecificCostBenefit.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FType_) and isEmptyProp(FcostList);
end;

procedure TFhirInsurancePlanPlanSpecificCostBenefit.listFieldsInOrder(fields : TStringList);
begin
  inherited listFieldsInOrder(fields);
  fields.add('type');
  fields.add('cost');
end;

function TFhirInsurancePlanPlanSpecificCostBenefit.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FCostList.sizeInBytes(magic));
end;

procedure TFhirInsurancePlanPlanSpecificCostBenefit.SetType_(value : TFhirCodeableConcept);
begin
  FType_.free;
  FType_ := value;
end;

function TFhirInsurancePlanPlanSpecificCostBenefit.GetCostList : TFhirInsurancePlanPlanSpecificCostBenefitCostList;
begin
  if FCostList = nil then
    FCostList := TFhirInsurancePlanPlanSpecificCostBenefitCostList.Create;
  result := FCostList;
end;

function TFhirInsurancePlanPlanSpecificCostBenefit.GetHasCostList : boolean;
begin
  result := (FCostList <> nil) and (FCostList.count > 0);
end;

{ TFhirInsurancePlanPlanSpecificCostBenefitListEnumerator }

constructor TFhirInsurancePlanPlanSpecificCostBenefitListEnumerator.Create(list : TFhirInsurancePlanPlanSpecificCostBenefitList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirInsurancePlanPlanSpecificCostBenefitListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirInsurancePlanPlanSpecificCostBenefitListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirInsurancePlanPlanSpecificCostBenefitListEnumerator.GetCurrent : TFhirInsurancePlanPlanSpecificCostBenefit;
begin
  Result := FList[FIndex];
end;

function TFhirInsurancePlanPlanSpecificCostBenefitListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirInsurancePlanPlanSpecificCostBenefitList }

procedure TFhirInsurancePlanPlanSpecificCostBenefitList.AddItem(value: TFhirInsurancePlanPlanSpecificCostBenefit);
begin
  assert(value.ClassName = 'TFhirInsurancePlanPlanSpecificCostBenefit', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirInsurancePlanPlanSpecificCostBenefit');
  add(value);
end;

function TFhirInsurancePlanPlanSpecificCostBenefitList.Append: TFhirInsurancePlanPlanSpecificCostBenefit;
begin
  result := TFhirInsurancePlanPlanSpecificCostBenefit.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirInsurancePlanPlanSpecificCostBenefitList.ClearItems;
begin
  Clear;
end;

function TFhirInsurancePlanPlanSpecificCostBenefitList.GetEnumerator : TFhirInsurancePlanPlanSpecificCostBenefitListEnumerator;
begin
  result := TFhirInsurancePlanPlanSpecificCostBenefitListEnumerator.Create(self.link);
end;

function TFhirInsurancePlanPlanSpecificCostBenefitList.Clone: TFhirInsurancePlanPlanSpecificCostBenefitList;
begin
  result := TFhirInsurancePlanPlanSpecificCostBenefitList(inherited Clone);
end;

function TFhirInsurancePlanPlanSpecificCostBenefitList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirInsurancePlanPlanSpecificCostBenefitList.GetItemN(index: Integer): TFhirInsurancePlanPlanSpecificCostBenefit;
begin
  result := TFhirInsurancePlanPlanSpecificCostBenefit(ObjectByIndex[index]);
end;

function TFhirInsurancePlanPlanSpecificCostBenefitList.ItemClass: TFslObjectClass;
begin
  result := TFhirInsurancePlanPlanSpecificCostBenefit;
end;
function TFhirInsurancePlanPlanSpecificCostBenefitList.IndexOf(value: TFhirInsurancePlanPlanSpecificCostBenefit): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirInsurancePlanPlanSpecificCostBenefitList.Insert(index: Integer): TFhirInsurancePlanPlanSpecificCostBenefit;
begin
  result := TFhirInsurancePlanPlanSpecificCostBenefit.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirInsurancePlanPlanSpecificCostBenefitList.InsertItem(index: Integer; value: TFhirInsurancePlanPlanSpecificCostBenefit);
begin
  assert(value is TFhirInsurancePlanPlanSpecificCostBenefit);
  Inherited Insert(index, value);
end;

function TFhirInsurancePlanPlanSpecificCostBenefitList.Item(index: Integer): TFhirInsurancePlanPlanSpecificCostBenefit;
begin
  result := TFhirInsurancePlanPlanSpecificCostBenefit(ObjectByIndex[index]);
end;

function TFhirInsurancePlanPlanSpecificCostBenefitList.Link: TFhirInsurancePlanPlanSpecificCostBenefitList;
begin
  result := TFhirInsurancePlanPlanSpecificCostBenefitList(inherited Link);
end;

procedure TFhirInsurancePlanPlanSpecificCostBenefitList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirInsurancePlanPlanSpecificCostBenefitList.SetItemByIndex(index: Integer; value: TFhirInsurancePlanPlanSpecificCostBenefit);
begin
  assert(value is TFhirInsurancePlanPlanSpecificCostBenefit);
  FhirInsurancePlanPlanSpecificCostBenefits[index] := value;
end;

procedure TFhirInsurancePlanPlanSpecificCostBenefitList.SetItemN(index: Integer; value: TFhirInsurancePlanPlanSpecificCostBenefit);
begin
  assert(value is TFhirInsurancePlanPlanSpecificCostBenefit);
  ObjectByIndex[index] := value;
end;

{ TFhirInsurancePlanPlanSpecificCostBenefitCost }

constructor TFhirInsurancePlanPlanSpecificCostBenefitCost.Create;
begin
  inherited;
end;

destructor TFhirInsurancePlanPlanSpecificCostBenefitCost.Destroy;
begin
  FType_.free;
  FApplicability.free;
  FQualifiersList.Free;
  FValue.free;
  inherited;
end;

procedure TFhirInsurancePlanPlanSpecificCostBenefitCost.Assign(oSource : TFslObject);
begin
  inherited;
  type_ := TFhirInsurancePlanPlanSpecificCostBenefitCost(oSource).type_.Clone;
  applicability := TFhirInsurancePlanPlanSpecificCostBenefitCost(oSource).applicability.Clone;
  if (TFhirInsurancePlanPlanSpecificCostBenefitCost(oSource).FQualifiersList = nil) then
  begin
    FQualifiersList.free;
    FQualifiersList := nil;
  end
  else
  begin
    if FQualifiersList = nil then
      FQualifiersList := TFhirCodeableConceptList.Create;
    FQualifiersList.Assign(TFhirInsurancePlanPlanSpecificCostBenefitCost(oSource).FQualifiersList);
  end;
  value := TFhirInsurancePlanPlanSpecificCostBenefitCost(oSource).value.Clone;
end;

procedure TFhirInsurancePlanPlanSpecificCostBenefitCost.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'type') Then
     list.add(self.link, 'type', FType_.Link);
  if (child_name = 'applicability') Then
     list.add(self.link, 'applicability', FApplicability.Link);
  if (child_name = 'qualifiers') Then
    list.addAll(self, 'qualifiers', FQualifiersList);
  if (child_name = 'value') Then
     list.add(self.link, 'value', FValue.Link);
end;

procedure TFhirInsurancePlanPlanSpecificCostBenefitCost.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'type', 'CodeableConcept', false, TFhirCodeableConcept, FType_.Link));
  oList.add(TFHIRProperty.create(self, 'applicability', 'CodeableConcept', false, TFhirCodeableConcept, FApplicability.Link));
  oList.add(TFHIRProperty.create(self, 'qualifiers', 'CodeableConcept', true, TFhirCodeableConcept, FQualifiersList.Link));
  oList.add(TFHIRProperty.create(self, 'value', 'Quantity', false, TFhirQuantity, FValue.Link));
end;

function TFhirInsurancePlanPlanSpecificCostBenefitCost.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'type') then
  begin
    Type_ := propValue as TFhirCodeableConcept;
    result := propValue;
  end
  else if (propName = 'applicability') then
  begin
    Applicability := propValue as TFhirCodeableConcept;
    result := propValue;
  end
  else if (propName = 'qualifiers') then
  begin
    QualifiersList.add(propValue as TFhirCodeableConcept);
    result := propValue;
  end
  else if (propName = 'value') then
  begin
    Value := propValue as TFhirQuantity;
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirInsurancePlanPlanSpecificCostBenefitCost.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'qualifiers') then QualifiersList.insertItem(index, propValue as TFhirCodeableConcept)
  else inherited;
end;

function TFhirInsurancePlanPlanSpecificCostBenefitCost.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'type') then result := TFhirCodeableConcept.create()
  else if (propName = 'applicability') then result := TFhirCodeableConcept.create()
  else if (propName = 'qualifiers') then result := QualifiersList.new()
  else if (propName = 'value') then result := TFhirQuantity.create()
  else result := inherited createPropertyValue(propName);
end;

function TFhirInsurancePlanPlanSpecificCostBenefitCost.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'type') then result := 'CodeableConcept'
  else if (propName = 'applicability') then result := 'CodeableConcept'
  else if (propName = 'qualifiers') then result := 'CodeableConcept'
  else if (propName = 'value') then result := 'Quantity'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirInsurancePlanPlanSpecificCostBenefitCost.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'type') then Type_Element := nil
  else if (propName = 'applicability') then ApplicabilityElement := nil
  else if (propName = 'qualifiers') then deletePropertyValue('qualifiers', QualifiersList, value)
  else if (propName = 'value') then ValueElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirInsurancePlanPlanSpecificCostBenefitCost.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'type') then Type_Element := new as TFhirCodeableConcept
  else if (propName = 'applicability') then ApplicabilityElement := new as TFhirCodeableConcept
  else if (propName = 'qualifiers') then replacePropertyValue('qualifiers', QualifiersList, existing, new)
  else if (propName = 'value') then ValueElement := new as TFhirQuantity
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirInsurancePlanPlanSpecificCostBenefitCost.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'qualifiers') then QualifiersList.move(source, destination)
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirInsurancePlanPlanSpecificCostBenefitCost.fhirType : string;
begin
  result := 'InsurancePlan.plan.specificCost.benefit.cost';
end;

function TFhirInsurancePlanPlanSpecificCostBenefitCost.Link : TFhirInsurancePlanPlanSpecificCostBenefitCost;
begin
  result := TFhirInsurancePlanPlanSpecificCostBenefitCost(inherited Link);
end;

function TFhirInsurancePlanPlanSpecificCostBenefitCost.Clone : TFhirInsurancePlanPlanSpecificCostBenefitCost;
begin
  result := TFhirInsurancePlanPlanSpecificCostBenefitCost(inherited Clone);
end;

function TFhirInsurancePlanPlanSpecificCostBenefitCost.equals(other : TObject) : boolean; 
var
  o : TFhirInsurancePlanPlanSpecificCostBenefitCost;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirInsurancePlanPlanSpecificCostBenefitCost)) then
    result := false
  else
  begin
    o := TFhirInsurancePlanPlanSpecificCostBenefitCost(other);
    result := compareDeep(type_Element, o.type_Element, true) and compareDeep(applicabilityElement, o.applicabilityElement, true) and 
      compareDeep(qualifiersList, o.qualifiersList, true) and compareDeep(valueElement, o.valueElement, true);
  end;
end;

function TFhirInsurancePlanPlanSpecificCostBenefitCost.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FType_) and isEmptyProp(FApplicability) and isEmptyProp(FqualifiersList) and isEmptyProp(FValue);
end;

procedure TFhirInsurancePlanPlanSpecificCostBenefitCost.listFieldsInOrder(fields : TStringList);
begin
  inherited listFieldsInOrder(fields);
  fields.add('type');
  fields.add('applicability');
  fields.add('qualifiers');
  fields.add('value');
end;

function TFhirInsurancePlanPlanSpecificCostBenefitCost.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FQualifiersList.sizeInBytes(magic));
end;

procedure TFhirInsurancePlanPlanSpecificCostBenefitCost.SetType_(value : TFhirCodeableConcept);
begin
  FType_.free;
  FType_ := value;
end;

procedure TFhirInsurancePlanPlanSpecificCostBenefitCost.SetApplicability(value : TFhirCodeableConcept);
begin
  FApplicability.free;
  FApplicability := value;
end;

function TFhirInsurancePlanPlanSpecificCostBenefitCost.GetQualifiersList : TFhirCodeableConceptList;
begin
  if FQualifiersList = nil then
    FQualifiersList := TFhirCodeableConceptList.Create;
  result := FQualifiersList;
end;

function TFhirInsurancePlanPlanSpecificCostBenefitCost.GetHasQualifiersList : boolean;
begin
  result := (FQualifiersList <> nil) and (FQualifiersList.count > 0);
end;

procedure TFhirInsurancePlanPlanSpecificCostBenefitCost.SetValue(value : TFhirQuantity);
begin
  FValue.free;
  FValue := value;
end;

{ TFhirInsurancePlanPlanSpecificCostBenefitCostListEnumerator }

constructor TFhirInsurancePlanPlanSpecificCostBenefitCostListEnumerator.Create(list : TFhirInsurancePlanPlanSpecificCostBenefitCostList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirInsurancePlanPlanSpecificCostBenefitCostListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirInsurancePlanPlanSpecificCostBenefitCostListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirInsurancePlanPlanSpecificCostBenefitCostListEnumerator.GetCurrent : TFhirInsurancePlanPlanSpecificCostBenefitCost;
begin
  Result := FList[FIndex];
end;

function TFhirInsurancePlanPlanSpecificCostBenefitCostListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirInsurancePlanPlanSpecificCostBenefitCostList }

procedure TFhirInsurancePlanPlanSpecificCostBenefitCostList.AddItem(value: TFhirInsurancePlanPlanSpecificCostBenefitCost);
begin
  assert(value.ClassName = 'TFhirInsurancePlanPlanSpecificCostBenefitCost', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirInsurancePlanPlanSpecificCostBenefitCost');
  add(value);
end;

function TFhirInsurancePlanPlanSpecificCostBenefitCostList.Append: TFhirInsurancePlanPlanSpecificCostBenefitCost;
begin
  result := TFhirInsurancePlanPlanSpecificCostBenefitCost.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirInsurancePlanPlanSpecificCostBenefitCostList.ClearItems;
begin
  Clear;
end;

function TFhirInsurancePlanPlanSpecificCostBenefitCostList.GetEnumerator : TFhirInsurancePlanPlanSpecificCostBenefitCostListEnumerator;
begin
  result := TFhirInsurancePlanPlanSpecificCostBenefitCostListEnumerator.Create(self.link);
end;

function TFhirInsurancePlanPlanSpecificCostBenefitCostList.Clone: TFhirInsurancePlanPlanSpecificCostBenefitCostList;
begin
  result := TFhirInsurancePlanPlanSpecificCostBenefitCostList(inherited Clone);
end;

function TFhirInsurancePlanPlanSpecificCostBenefitCostList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirInsurancePlanPlanSpecificCostBenefitCostList.GetItemN(index: Integer): TFhirInsurancePlanPlanSpecificCostBenefitCost;
begin
  result := TFhirInsurancePlanPlanSpecificCostBenefitCost(ObjectByIndex[index]);
end;

function TFhirInsurancePlanPlanSpecificCostBenefitCostList.ItemClass: TFslObjectClass;
begin
  result := TFhirInsurancePlanPlanSpecificCostBenefitCost;
end;
function TFhirInsurancePlanPlanSpecificCostBenefitCostList.IndexOf(value: TFhirInsurancePlanPlanSpecificCostBenefitCost): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirInsurancePlanPlanSpecificCostBenefitCostList.Insert(index: Integer): TFhirInsurancePlanPlanSpecificCostBenefitCost;
begin
  result := TFhirInsurancePlanPlanSpecificCostBenefitCost.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirInsurancePlanPlanSpecificCostBenefitCostList.InsertItem(index: Integer; value: TFhirInsurancePlanPlanSpecificCostBenefitCost);
begin
  assert(value is TFhirInsurancePlanPlanSpecificCostBenefitCost);
  Inherited Insert(index, value);
end;

function TFhirInsurancePlanPlanSpecificCostBenefitCostList.Item(index: Integer): TFhirInsurancePlanPlanSpecificCostBenefitCost;
begin
  result := TFhirInsurancePlanPlanSpecificCostBenefitCost(ObjectByIndex[index]);
end;

function TFhirInsurancePlanPlanSpecificCostBenefitCostList.Link: TFhirInsurancePlanPlanSpecificCostBenefitCostList;
begin
  result := TFhirInsurancePlanPlanSpecificCostBenefitCostList(inherited Link);
end;

procedure TFhirInsurancePlanPlanSpecificCostBenefitCostList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirInsurancePlanPlanSpecificCostBenefitCostList.SetItemByIndex(index: Integer; value: TFhirInsurancePlanPlanSpecificCostBenefitCost);
begin
  assert(value is TFhirInsurancePlanPlanSpecificCostBenefitCost);
  FhirInsurancePlanPlanSpecificCostBenefitCosts[index] := value;
end;

procedure TFhirInsurancePlanPlanSpecificCostBenefitCostList.SetItemN(index: Integer; value: TFhirInsurancePlanPlanSpecificCostBenefitCost);
begin
  assert(value is TFhirInsurancePlanPlanSpecificCostBenefitCost);
  ObjectByIndex[index] := value;
end;

{ TFhirInsurancePlan }

constructor TFhirInsurancePlan.Create;
begin
  inherited;
end;

destructor TFhirInsurancePlan.Destroy;
begin
  FIdentifierList.Free;
  FStatus.free;
  FType_List.Free;
  FName.free;
  FAliasList.Free;
  FPeriod.free;
  FOwnedBy.free;
  FAdministeredBy.free;
  FCoverageAreaList.Free;
  FContactList.Free;
  FEndpointList.Free;
  FNetworkList.Free;
  FCoverageList.Free;
  FPlanList.Free;
  inherited;
end;

procedure TFhirInsurancePlan.Assign(oSource : TFslObject);
begin
  inherited;
  if (TFhirInsurancePlan(oSource).FIdentifierList = nil) then
  begin
    FIdentifierList.free;
    FIdentifierList := nil;
  end
  else
  begin
    if FIdentifierList = nil then
      FIdentifierList := TFhirIdentifierList.Create;
    FIdentifierList.Assign(TFhirInsurancePlan(oSource).FIdentifierList);
  end;
  statusElement := TFhirInsurancePlan(oSource).statusElement.Clone;
  if (TFhirInsurancePlan(oSource).FType_List = nil) then
  begin
    FType_List.free;
    FType_List := nil;
  end
  else
  begin
    if FType_List = nil then
      FType_List := TFhirCodeableConceptList.Create;
    FType_List.Assign(TFhirInsurancePlan(oSource).FType_List);
  end;
  nameElement := TFhirInsurancePlan(oSource).nameElement.Clone;
  if (TFhirInsurancePlan(oSource).FAliasList = nil) then
  begin
    FAliasList.free;
    FAliasList := nil;
  end
  else
  begin
    if FAliasList = nil then
      FAliasList := TFhirStringList.Create;
    FAliasList.Assign(TFhirInsurancePlan(oSource).FAliasList);
  end;
  period := TFhirInsurancePlan(oSource).period.Clone;
  ownedBy := TFhirInsurancePlan(oSource).ownedBy.Clone;
  administeredBy := TFhirInsurancePlan(oSource).administeredBy.Clone;
  if (TFhirInsurancePlan(oSource).FCoverageAreaList = nil) then
  begin
    FCoverageAreaList.free;
    FCoverageAreaList := nil;
  end
  else
  begin
    if FCoverageAreaList = nil then
      FCoverageAreaList := TFhirReferenceList.Create;
    FCoverageAreaList.Assign(TFhirInsurancePlan(oSource).FCoverageAreaList);
  end;
  if (TFhirInsurancePlan(oSource).FContactList = nil) then
  begin
    FContactList.free;
    FContactList := nil;
  end
  else
  begin
    if FContactList = nil then
      FContactList := TFhirInsurancePlanContactList.Create;
    FContactList.Assign(TFhirInsurancePlan(oSource).FContactList);
  end;
  if (TFhirInsurancePlan(oSource).FEndpointList = nil) then
  begin
    FEndpointList.free;
    FEndpointList := nil;
  end
  else
  begin
    if FEndpointList = nil then
      FEndpointList := TFhirReferenceList.Create;
    FEndpointList.Assign(TFhirInsurancePlan(oSource).FEndpointList);
  end;
  if (TFhirInsurancePlan(oSource).FNetworkList = nil) then
  begin
    FNetworkList.free;
    FNetworkList := nil;
  end
  else
  begin
    if FNetworkList = nil then
      FNetworkList := TFhirReferenceList.Create;
    FNetworkList.Assign(TFhirInsurancePlan(oSource).FNetworkList);
  end;
  if (TFhirInsurancePlan(oSource).FCoverageList = nil) then
  begin
    FCoverageList.free;
    FCoverageList := nil;
  end
  else
  begin
    if FCoverageList = nil then
      FCoverageList := TFhirInsurancePlanCoverageList.Create;
    FCoverageList.Assign(TFhirInsurancePlan(oSource).FCoverageList);
  end;
  if (TFhirInsurancePlan(oSource).FPlanList = nil) then
  begin
    FPlanList.free;
    FPlanList := nil;
  end
  else
  begin
    if FPlanList = nil then
      FPlanList := TFhirInsurancePlanPlanList.Create;
    FPlanList.Assign(TFhirInsurancePlan(oSource).FPlanList);
  end;
end;

function TFhirInsurancePlan.GetResourceType : TFhirResourceType;
begin
  result := frtInsurancePlan;
end;

procedure TFhirInsurancePlan.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'identifier') Then
    list.addAll(self, 'identifier', FIdentifierList);
  if (child_name = 'status') Then
     list.add(self.link, 'status', FStatus.Link);
  if (child_name = 'type') Then
    list.addAll(self, 'type', FType_List);
  if (child_name = 'name') Then
     list.add(self.link, 'name', FName.Link);
  if (child_name = 'alias') Then
    list.addAll(self, 'alias', FAliasList);
  if (child_name = 'period') Then
     list.add(self.link, 'period', FPeriod.Link);
  if (child_name = 'ownedBy') Then
     list.add(self.link, 'ownedBy', FOwnedBy.Link);
  if (child_name = 'administeredBy') Then
     list.add(self.link, 'administeredBy', FAdministeredBy.Link);
  if (child_name = 'coverageArea') Then
    list.addAll(self, 'coverageArea', FCoverageAreaList);
  if (child_name = 'contact') Then
    list.addAll(self, 'contact', FContactList);
  if (child_name = 'endpoint') Then
    list.addAll(self, 'endpoint', FEndpointList);
  if (child_name = 'network') Then
    list.addAll(self, 'network', FNetworkList);
  if (child_name = 'coverage') Then
    list.addAll(self, 'coverage', FCoverageList);
  if (child_name = 'plan') Then
    list.addAll(self, 'plan', FPlanList);
end;

procedure TFhirInsurancePlan.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'identifier', 'Identifier', true, TFhirIdentifier, FIdentifierList.Link));
  oList.add(TFHIRProperty.create(self, 'status', 'code', false, TFhirEnum, FStatus.Link));
  oList.add(TFHIRProperty.create(self, 'type', 'CodeableConcept', true, TFhirCodeableConcept, FType_List.Link));
  oList.add(TFHIRProperty.create(self, 'name', 'string', false, TFhirString, FName.Link));
  oList.add(TFHIRProperty.create(self, 'alias', 'string', true, TFhirString, FAliasList.Link));
  oList.add(TFHIRProperty.create(self, 'period', 'Period', false, TFhirPeriod, FPeriod.Link));
  oList.add(TFHIRProperty.create(self, 'ownedBy', 'Reference', false, TFhirReference, FOwnedBy.Link));
  oList.add(TFHIRProperty.create(self, 'administeredBy', 'Reference', false, TFhirReference, FAdministeredBy.Link));
  oList.add(TFHIRProperty.create(self, 'coverageArea', 'Reference', true, TFhirReference, FCoverageAreaList.Link));
  oList.add(TFHIRProperty.create(self, 'contact', 'BackboneElement', true, TFhirInsurancePlanContact, FContactList.Link));
  oList.add(TFHIRProperty.create(self, 'endpoint', 'Reference', true, TFhirReference, FEndpointList.Link));
  oList.add(TFHIRProperty.create(self, 'network', 'Reference', true, TFhirReference, FNetworkList.Link));
  oList.add(TFHIRProperty.create(self, 'coverage', 'BackboneElement', true, TFhirInsurancePlanCoverage, FCoverageList.Link));
  oList.add(TFHIRProperty.create(self, 'plan', 'BackboneElement', true, TFhirInsurancePlanPlan, FPlanList.Link));
end;

function TFhirInsurancePlan.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'identifier') then
  begin
    IdentifierList.add(propValue as TFhirIdentifier);
    result := propValue;
  end
  else if (propName = 'status') then
  begin
    StatusElement := asEnum(SYSTEMS_TFhirPublicationStatusEnum, CODES_TFhirPublicationStatusEnum, propValue);
    result := propValue;
  end
  else if (propName = 'type') then
  begin
    Type_List.add(propValue as TFhirCodeableConcept);
    result := propValue;
  end
  else if (propName = 'name') then
  begin
    NameElement := asString(propValue);
    result := propValue;
  end
  else if (propName = 'alias') then
  begin
    AliasList.add(asString(propValue)){2};     result := propValue;

  end
  else if (propName = 'period') then
  begin
    Period := propValue as TFhirPeriod;
    result := propValue;
  end
  else if (propName = 'ownedBy') then
  begin
    OwnedBy := propValue as TFhirReference;
    result := propValue;
  end
  else if (propName = 'administeredBy') then
  begin
    AdministeredBy := propValue as TFhirReference;
    result := propValue;
  end
  else if (propName = 'coverageArea') then
  begin
    CoverageAreaList.add(propValue as TFhirReference);
    result := propValue;
  end
  else if (propName = 'contact') then
  begin
    ContactList.add(propValue as TFhirInsurancePlanContact);
    result := propValue;
  end
  else if (propName = 'endpoint') then
  begin
    EndpointList.add(propValue as TFhirReference);
    result := propValue;
  end
  else if (propName = 'network') then
  begin
    NetworkList.add(propValue as TFhirReference);
    result := propValue;
  end
  else if (propName = 'coverage') then
  begin
    CoverageList.add(propValue as TFhirInsurancePlanCoverage);
    result := propValue;
  end
  else if (propName = 'plan') then
  begin
    PlanList.add(propValue as TFhirInsurancePlanPlan);
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirInsurancePlan.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'identifier') then IdentifierList.insertItem(index, propValue as TFhirIdentifier)
  else if (propName = 'type') then Type_List.insertItem(index, propValue as TFhirCodeableConcept)
  else if (propName = 'alias') then AliasList.insertItem(index, asString(propValue))
  else if (propName = 'coverageArea') then CoverageAreaList.insertItem(index, propValue as TFhirReference)
  else if (propName = 'contact') then ContactList.insertItem(index, propValue as TFhirInsurancePlanContact)
  else if (propName = 'endpoint') then EndpointList.insertItem(index, propValue as TFhirReference)
  else if (propName = 'network') then NetworkList.insertItem(index, propValue as TFhirReference)
  else if (propName = 'coverage') then CoverageList.insertItem(index, propValue as TFhirInsurancePlanCoverage)
  else if (propName = 'plan') then PlanList.insertItem(index, propValue as TFhirInsurancePlanPlan)
  else inherited;
end;

function TFhirInsurancePlan.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'identifier') then result := IdentifierList.new()
  else if (propName = 'status') then result := TFhirEnum.create(SYSTEMS_TFhirPublicationStatusEnum[PublicationStatusNull], CODES_TFhirPublicationStatusEnum[PublicationStatusNull]) 
  else if (propName = 'type') then result := Type_List.new()
  else if (propName = 'name') then result := TFhirString.create()
  else if (propName = 'alias') then result := AliasList.new()
  else if (propName = 'period') then result := TFhirPeriod.create()
  else if (propName = 'ownedBy') then result := TFhirReference.create()
  else if (propName = 'administeredBy') then result := TFhirReference.create()
  else if (propName = 'coverageArea') then result := CoverageAreaList.new()
  else if (propName = 'contact') then result := ContactList.new()
  else if (propName = 'endpoint') then result := EndpointList.new()
  else if (propName = 'network') then result := NetworkList.new()
  else if (propName = 'coverage') then result := CoverageList.new()
  else if (propName = 'plan') then result := PlanList.new()
  else result := inherited createPropertyValue(propName);
end;

function TFhirInsurancePlan.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'identifier') then result := 'Identifier'
  else if (propName = 'status') then result := 'code'
  else if (propName = 'type') then result := 'CodeableConcept'
  else if (propName = 'name') then result := 'string'
  else if (propName = 'alias') then result := 'string'
  else if (propName = 'period') then result := 'Period'
  else if (propName = 'ownedBy') then result := 'Reference'
  else if (propName = 'administeredBy') then result := 'Reference'
  else if (propName = 'coverageArea') then result := 'Reference'
  else if (propName = 'contact') then result := 'BackboneElement'
  else if (propName = 'endpoint') then result := 'Reference'
  else if (propName = 'network') then result := 'Reference'
  else if (propName = 'coverage') then result := 'BackboneElement'
  else if (propName = 'plan') then result := 'BackboneElement'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirInsurancePlan.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'identifier') then deletePropertyValue('identifier', IdentifierList, value)
  else if (propName = 'status') then StatusElement := nil
  else if (propName = 'type') then deletePropertyValue('type', Type_List, value)
  else if (propName = 'name') then NameElement := nil
  else if (propName = 'alias') then deletePropertyValue('alias', AliasList, value)
  else if (propName = 'period') then PeriodElement := nil
  else if (propName = 'ownedBy') then OwnedByElement := nil
  else if (propName = 'administeredBy') then AdministeredByElement := nil
  else if (propName = 'coverageArea') then deletePropertyValue('coverageArea', CoverageAreaList, value)
  else if (propName = 'contact') then deletePropertyValue('contact', ContactList, value)
  else if (propName = 'endpoint') then deletePropertyValue('endpoint', EndpointList, value)
  else if (propName = 'network') then deletePropertyValue('network', NetworkList, value)
  else if (propName = 'coverage') then deletePropertyValue('coverage', CoverageList, value)
  else if (propName = 'plan') then deletePropertyValue('plan', PlanList, value)
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirInsurancePlan.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'identifier') then replacePropertyValue('identifier', IdentifierList, existing, new)
  else if (propName = 'status') then StatusElement := asEnum(SYSTEMS_TFhirPublicationStatusEnum, CODES_TFhirPublicationStatusEnum, new)
  else if (propName = 'type') then replacePropertyValue('type', Type_List, existing, new)
  else if (propName = 'name') then NameElement := asString(new)
  else if (propName = 'alias') then replacePropertyValue('alias', AliasList, existing, new)
  else if (propName = 'period') then PeriodElement := new as TFhirPeriod
  else if (propName = 'ownedBy') then OwnedByElement := new as TFhirReference
  else if (propName = 'administeredBy') then AdministeredByElement := new as TFhirReference
  else if (propName = 'coverageArea') then replacePropertyValue('coverageArea', CoverageAreaList, existing, new)
  else if (propName = 'contact') then replacePropertyValue('contact', ContactList, existing, new)
  else if (propName = 'endpoint') then replacePropertyValue('endpoint', EndpointList, existing, new)
  else if (propName = 'network') then replacePropertyValue('network', NetworkList, existing, new)
  else if (propName = 'coverage') then replacePropertyValue('coverage', CoverageList, existing, new)
  else if (propName = 'plan') then replacePropertyValue('plan', PlanList, existing, new)
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirInsurancePlan.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'identifier') then IdentifierList.move(source, destination)
  else if (propName = 'type') then Type_List.move(source, destination)
  else if (propName = 'alias') then AliasList.move(source, destination)
  else if (propName = 'coverageArea') then CoverageAreaList.move(source, destination)
  else if (propName = 'contact') then ContactList.move(source, destination)
  else if (propName = 'endpoint') then EndpointList.move(source, destination)
  else if (propName = 'network') then NetworkList.move(source, destination)
  else if (propName = 'coverage') then CoverageList.move(source, destination)
  else if (propName = 'plan') then PlanList.move(source, destination)
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirInsurancePlan.fhirType : string;
begin
  result := 'InsurancePlan';
end;

function TFhirInsurancePlan.Link : TFhirInsurancePlan;
begin
  result := TFhirInsurancePlan(inherited Link);
end;

function TFhirInsurancePlan.Clone : TFhirInsurancePlan;
begin
  result := TFhirInsurancePlan(inherited Clone);
end;

function TFhirInsurancePlan.equals(other : TObject) : boolean; 
var
  o : TFhirInsurancePlan;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirInsurancePlan)) then
    result := false
  else
  begin
    o := TFhirInsurancePlan(other);
    result := compareDeep(identifierList, o.identifierList, true) and compareDeep(statusElement, o.statusElement, true) and 
      compareDeep(type_List, o.type_List, true) and compareDeep(nameElement, o.nameElement, true) and 
      compareDeep(aliasList, o.aliasList, true) and compareDeep(periodElement, o.periodElement, true) and 
      compareDeep(ownedByElement, o.ownedByElement, true) and compareDeep(administeredByElement, o.administeredByElement, true) and 
      compareDeep(coverageAreaList, o.coverageAreaList, true) and compareDeep(contactList, o.contactList, true) and 
      compareDeep(endpointList, o.endpointList, true) and compareDeep(networkList, o.networkList, true) and 
      compareDeep(coverageList, o.coverageList, true) and compareDeep(planList, o.planList, true);
  end;
end;

function TFhirInsurancePlan.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FidentifierList) and isEmptyProp(FStatus) and isEmptyProp(Ftype_List) and isEmptyProp(FName) and isEmptyProp(FaliasList) and isEmptyProp(FPeriod) and isEmptyProp(FOwnedBy) and isEmptyProp(FAdministeredBy) and isEmptyProp(FcoverageAreaList) and isEmptyProp(FcontactList) and isEmptyProp(FendpointList) and isEmptyProp(FnetworkList) and isEmptyProp(FcoverageList) and isEmptyProp(FplanList);
end;

procedure TFhirInsurancePlan.listFieldsInOrder(fields : TStringList);
begin
  inherited listFieldsInOrder(fields);
  fields.add('identifier');
  fields.add('status');
  fields.add('type');
  fields.add('name');
  fields.add('alias');
  fields.add('period');
  fields.add('ownedBy');
  fields.add('administeredBy');
  fields.add('coverageArea');
  fields.add('contact');
  fields.add('endpoint');
  fields.add('network');
  fields.add('coverage');
  fields.add('plan');
end;

function TFhirInsurancePlan.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FIdentifierList.sizeInBytes(magic));
  inc(result, FType_List.sizeInBytes(magic));
  inc(result, FAliasList.sizeInBytes(magic));
  inc(result, FCoverageAreaList.sizeInBytes(magic));
  inc(result, FContactList.sizeInBytes(magic));
  inc(result, FEndpointList.sizeInBytes(magic));
  inc(result, FNetworkList.sizeInBytes(magic));
  inc(result, FCoverageList.sizeInBytes(magic));
  inc(result, FPlanList.sizeInBytes(magic));
end;

function TFhirInsurancePlan.GetIdentifierList : TFhirIdentifierList;
begin
  if FIdentifierList = nil then
    FIdentifierList := TFhirIdentifierList.Create;
  result := FIdentifierList;
end;

function TFhirInsurancePlan.GetHasIdentifierList : boolean;
begin
  result := (FIdentifierList <> nil) and (FIdentifierList.count > 0);
end;

procedure TFhirInsurancePlan.SetStatus(value : TFhirEnum);
begin
  FStatus.free;
  FStatus := value;
end;

function TFhirInsurancePlan.GetStatusST : TFhirPublicationStatusEnum;
begin
  if FStatus = nil then
    result := TFhirPublicationStatusEnum(0)
  else
    result := TFhirPublicationStatusEnum(StringArrayIndexOfSensitive(CODES_TFhirPublicationStatusEnum, FStatus.value));
end;

procedure TFhirInsurancePlan.SetStatusST(value : TFhirPublicationStatusEnum);
begin
  if ord(value) = 0 then
    StatusElement := nil
  else
    StatusElement := TFhirEnum.create(SYSTEMS_TFhirPublicationStatusEnum[value], CODES_TFhirPublicationStatusEnum[value]);
end;

function TFhirInsurancePlan.GetType_List : TFhirCodeableConceptList;
begin
  if FType_List = nil then
    FType_List := TFhirCodeableConceptList.Create;
  result := FType_List;
end;

function TFhirInsurancePlan.GetHasType_List : boolean;
begin
  result := (FType_List <> nil) and (FType_List.count > 0);
end;

procedure TFhirInsurancePlan.SetName(value : TFhirString);
begin
  FName.free;
  FName := value;
end;

function TFhirInsurancePlan.GetNameST : String;
begin
  if FName = nil then
    result := ''
  else
    result := FName.value;
end;

procedure TFhirInsurancePlan.SetNameST(value : String);
begin
  if value <> '' then
  begin
    if FName = nil then
      FName := TFhirString.create;
    FName.value := value
  end
  else if FName <> nil then
    FName.value := '';
end;

function TFhirInsurancePlan.GetAliasList : TFhirStringList;
begin
  if FAliasList = nil then
    FAliasList := TFhirStringList.Create;
  result := FAliasList;
end;

function TFhirInsurancePlan.GetHasAliasList : boolean;
begin
  result := (FAliasList <> nil) and (FAliasList.count > 0);
end;

procedure TFhirInsurancePlan.SetPeriod(value : TFhirPeriod);
begin
  FPeriod.free;
  FPeriod := value;
end;

procedure TFhirInsurancePlan.SetOwnedBy(value : TFhirReference);
begin
  FOwnedBy.free;
  FOwnedBy := value;
end;

procedure TFhirInsurancePlan.SetAdministeredBy(value : TFhirReference);
begin
  FAdministeredBy.free;
  FAdministeredBy := value;
end;

function TFhirInsurancePlan.GetCoverageAreaList : TFhirReferenceList;
begin
  if FCoverageAreaList = nil then
    FCoverageAreaList := TFhirReferenceList.Create;
  result := FCoverageAreaList;
end;

function TFhirInsurancePlan.GetHasCoverageAreaList : boolean;
begin
  result := (FCoverageAreaList <> nil) and (FCoverageAreaList.count > 0);
end;

function TFhirInsurancePlan.GetContactList : TFhirInsurancePlanContactList;
begin
  if FContactList = nil then
    FContactList := TFhirInsurancePlanContactList.Create;
  result := FContactList;
end;

function TFhirInsurancePlan.GetHasContactList : boolean;
begin
  result := (FContactList <> nil) and (FContactList.count > 0);
end;

function TFhirInsurancePlan.GetEndpointList : TFhirReferenceList;
begin
  if FEndpointList = nil then
    FEndpointList := TFhirReferenceList.Create;
  result := FEndpointList;
end;

function TFhirInsurancePlan.GetHasEndpointList : boolean;
begin
  result := (FEndpointList <> nil) and (FEndpointList.count > 0);
end;

function TFhirInsurancePlan.GetNetworkList : TFhirReferenceList;
begin
  if FNetworkList = nil then
    FNetworkList := TFhirReferenceList.Create;
  result := FNetworkList;
end;

function TFhirInsurancePlan.GetHasNetworkList : boolean;
begin
  result := (FNetworkList <> nil) and (FNetworkList.count > 0);
end;

function TFhirInsurancePlan.GetCoverageList : TFhirInsurancePlanCoverageList;
begin
  if FCoverageList = nil then
    FCoverageList := TFhirInsurancePlanCoverageList.Create;
  result := FCoverageList;
end;

function TFhirInsurancePlan.GetHasCoverageList : boolean;
begin
  result := (FCoverageList <> nil) and (FCoverageList.count > 0);
end;

function TFhirInsurancePlan.GetPlanList : TFhirInsurancePlanPlanList;
begin
  if FPlanList = nil then
    FPlanList := TFhirInsurancePlanPlanList.Create;
  result := FPlanList;
end;

function TFhirInsurancePlan.GetHasPlanList : boolean;
begin
  result := (FPlanList <> nil) and (FPlanList.count > 0);
end;

{ TFhirInsurancePlanListEnumerator }

constructor TFhirInsurancePlanListEnumerator.Create(list : TFhirInsurancePlanList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirInsurancePlanListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirInsurancePlanListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirInsurancePlanListEnumerator.GetCurrent : TFhirInsurancePlan;
begin
  Result := FList[FIndex];
end;

function TFhirInsurancePlanListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirInsurancePlanList }

procedure TFhirInsurancePlanList.AddItem(value: TFhirInsurancePlan);
begin
  assert(value.ClassName = 'TFhirInsurancePlan', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirInsurancePlan');
  add(value);
end;

function TFhirInsurancePlanList.Append: TFhirInsurancePlan;
begin
  result := TFhirInsurancePlan.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirInsurancePlanList.ClearItems;
begin
  Clear;
end;

function TFhirInsurancePlanList.GetEnumerator : TFhirInsurancePlanListEnumerator;
begin
  result := TFhirInsurancePlanListEnumerator.Create(self.link);
end;

function TFhirInsurancePlanList.Clone: TFhirInsurancePlanList;
begin
  result := TFhirInsurancePlanList(inherited Clone);
end;

function TFhirInsurancePlanList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirInsurancePlanList.GetItemN(index: Integer): TFhirInsurancePlan;
begin
  result := TFhirInsurancePlan(ObjectByIndex[index]);
end;

function TFhirInsurancePlanList.ItemClass: TFslObjectClass;
begin
  result := TFhirInsurancePlan;
end;
function TFhirInsurancePlanList.IndexOf(value: TFhirInsurancePlan): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirInsurancePlanList.Insert(index: Integer): TFhirInsurancePlan;
begin
  result := TFhirInsurancePlan.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirInsurancePlanList.InsertItem(index: Integer; value: TFhirInsurancePlan);
begin
  assert(value is TFhirInsurancePlan);
  Inherited Insert(index, value);
end;

function TFhirInsurancePlanList.Item(index: Integer): TFhirInsurancePlan;
begin
  result := TFhirInsurancePlan(ObjectByIndex[index]);
end;

function TFhirInsurancePlanList.Link: TFhirInsurancePlanList;
begin
  result := TFhirInsurancePlanList(inherited Link);
end;

procedure TFhirInsurancePlanList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirInsurancePlanList.SetItemByIndex(index: Integer; value: TFhirInsurancePlan);
begin
  assert(value is TFhirInsurancePlan);
  FhirInsurancePlans[index] := value;
end;

procedure TFhirInsurancePlanList.SetItemN(index: Integer; value: TFhirInsurancePlan);
begin
  assert(value is TFhirInsurancePlan);
  ObjectByIndex[index] := value;
end;

{$ENDIF FHIR_INSURANCEPLAN}
{$IFDEF FHIR_INVOICE}
{ TFhirInvoiceParticipant }

constructor TFhirInvoiceParticipant.Create;
begin
  inherited;
end;

destructor TFhirInvoiceParticipant.Destroy;
begin
  FRole.free;
  FActor.free;
  inherited;
end;

procedure TFhirInvoiceParticipant.Assign(oSource : TFslObject);
begin
  inherited;
  role := TFhirInvoiceParticipant(oSource).role.Clone;
  actor := TFhirInvoiceParticipant(oSource).actor.Clone;
end;

procedure TFhirInvoiceParticipant.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'role') Then
     list.add(self.link, 'role', FRole.Link);
  if (child_name = 'actor') Then
     list.add(self.link, 'actor', FActor.Link);
end;

procedure TFhirInvoiceParticipant.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'role', 'CodeableConcept', false, TFhirCodeableConcept, FRole.Link));
  oList.add(TFHIRProperty.create(self, 'actor', 'Reference', false, TFhirReference, FActor.Link));
end;

function TFhirInvoiceParticipant.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'role') then
  begin
    Role := propValue as TFhirCodeableConcept;
    result := propValue;
  end
  else if (propName = 'actor') then
  begin
    Actor := propValue as TFhirReference;
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirInvoiceParticipant.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirInvoiceParticipant.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'role') then result := TFhirCodeableConcept.create()
  else if (propName = 'actor') then result := TFhirReference.create()
  else result := inherited createPropertyValue(propName);
end;

function TFhirInvoiceParticipant.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'role') then result := 'CodeableConcept'
  else if (propName = 'actor') then result := 'Reference'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirInvoiceParticipant.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'role') then RoleElement := nil
  else if (propName = 'actor') then ActorElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirInvoiceParticipant.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'role') then RoleElement := new as TFhirCodeableConcept
  else if (propName = 'actor') then ActorElement := new as TFhirReference
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirInvoiceParticipant.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirInvoiceParticipant.fhirType : string;
begin
  result := 'Invoice.participant';
end;

function TFhirInvoiceParticipant.Link : TFhirInvoiceParticipant;
begin
  result := TFhirInvoiceParticipant(inherited Link);
end;

function TFhirInvoiceParticipant.Clone : TFhirInvoiceParticipant;
begin
  result := TFhirInvoiceParticipant(inherited Clone);
end;

function TFhirInvoiceParticipant.equals(other : TObject) : boolean; 
var
  o : TFhirInvoiceParticipant;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirInvoiceParticipant)) then
    result := false
  else
  begin
    o := TFhirInvoiceParticipant(other);
    result := compareDeep(roleElement, o.roleElement, true) and compareDeep(actorElement, o.actorElement, true);
  end;
end;

function TFhirInvoiceParticipant.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FRole) and isEmptyProp(FActor);
end;

procedure TFhirInvoiceParticipant.listFieldsInOrder(fields : TStringList);
begin
  inherited listFieldsInOrder(fields);
  fields.add('role');
  fields.add('actor');
end;

function TFhirInvoiceParticipant.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
end;

procedure TFhirInvoiceParticipant.SetRole(value : TFhirCodeableConcept);
begin
  FRole.free;
  FRole := value;
end;

procedure TFhirInvoiceParticipant.SetActor(value : TFhirReference);
begin
  FActor.free;
  FActor := value;
end;

{ TFhirInvoiceParticipantListEnumerator }

constructor TFhirInvoiceParticipantListEnumerator.Create(list : TFhirInvoiceParticipantList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirInvoiceParticipantListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirInvoiceParticipantListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirInvoiceParticipantListEnumerator.GetCurrent : TFhirInvoiceParticipant;
begin
  Result := FList[FIndex];
end;

function TFhirInvoiceParticipantListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirInvoiceParticipantList }

procedure TFhirInvoiceParticipantList.AddItem(value: TFhirInvoiceParticipant);
begin
  assert(value.ClassName = 'TFhirInvoiceParticipant', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirInvoiceParticipant');
  add(value);
end;

function TFhirInvoiceParticipantList.Append: TFhirInvoiceParticipant;
begin
  result := TFhirInvoiceParticipant.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirInvoiceParticipantList.ClearItems;
begin
  Clear;
end;

function TFhirInvoiceParticipantList.GetEnumerator : TFhirInvoiceParticipantListEnumerator;
begin
  result := TFhirInvoiceParticipantListEnumerator.Create(self.link);
end;

function TFhirInvoiceParticipantList.Clone: TFhirInvoiceParticipantList;
begin
  result := TFhirInvoiceParticipantList(inherited Clone);
end;

function TFhirInvoiceParticipantList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirInvoiceParticipantList.GetItemN(index: Integer): TFhirInvoiceParticipant;
begin
  result := TFhirInvoiceParticipant(ObjectByIndex[index]);
end;

function TFhirInvoiceParticipantList.ItemClass: TFslObjectClass;
begin
  result := TFhirInvoiceParticipant;
end;
function TFhirInvoiceParticipantList.IndexOf(value: TFhirInvoiceParticipant): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirInvoiceParticipantList.Insert(index: Integer): TFhirInvoiceParticipant;
begin
  result := TFhirInvoiceParticipant.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirInvoiceParticipantList.InsertItem(index: Integer; value: TFhirInvoiceParticipant);
begin
  assert(value is TFhirInvoiceParticipant);
  Inherited Insert(index, value);
end;

function TFhirInvoiceParticipantList.Item(index: Integer): TFhirInvoiceParticipant;
begin
  result := TFhirInvoiceParticipant(ObjectByIndex[index]);
end;

function TFhirInvoiceParticipantList.Link: TFhirInvoiceParticipantList;
begin
  result := TFhirInvoiceParticipantList(inherited Link);
end;

procedure TFhirInvoiceParticipantList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirInvoiceParticipantList.SetItemByIndex(index: Integer; value: TFhirInvoiceParticipant);
begin
  assert(value is TFhirInvoiceParticipant);
  FhirInvoiceParticipants[index] := value;
end;

procedure TFhirInvoiceParticipantList.SetItemN(index: Integer; value: TFhirInvoiceParticipant);
begin
  assert(value is TFhirInvoiceParticipant);
  ObjectByIndex[index] := value;
end;

{ TFhirInvoiceLineItem }

constructor TFhirInvoiceLineItem.Create;
begin
  inherited;
end;

destructor TFhirInvoiceLineItem.Destroy;
begin
  FSequence.free;
  FChargeItem.free;
  FPriceComponentList.Free;
  inherited;
end;

procedure TFhirInvoiceLineItem.Assign(oSource : TFslObject);
begin
  inherited;
  sequenceElement := TFhirInvoiceLineItem(oSource).sequenceElement.Clone;
  chargeItem := TFhirInvoiceLineItem(oSource).chargeItem.Clone;
  if (TFhirInvoiceLineItem(oSource).FPriceComponentList = nil) then
  begin
    FPriceComponentList.free;
    FPriceComponentList := nil;
  end
  else
  begin
    if FPriceComponentList = nil then
      FPriceComponentList := TFhirInvoiceLineItemPriceComponentList.Create;
    FPriceComponentList.Assign(TFhirInvoiceLineItem(oSource).FPriceComponentList);
  end;
end;

procedure TFhirInvoiceLineItem.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'sequence') Then
     list.add(self.link, 'sequence', FSequence.Link);
  if (child_name = 'chargeItem[x]') or (child_name = 'chargeItem') Then
     list.add(self.link, 'chargeItem[x]', FChargeItem.Link);
  if (child_name = 'priceComponent') Then
    list.addAll(self, 'priceComponent', FPriceComponentList);
end;

procedure TFhirInvoiceLineItem.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'sequence', 'positiveInt', false, TFhirPositiveInt, FSequence.Link));
  oList.add(TFHIRProperty.create(self, 'chargeItem[x]', 'Reference|CodeableConcept', false, TFhirDataType, FChargeItem.Link));
  oList.add(TFHIRProperty.create(self, 'priceComponent', 'BackboneElement', true, TFhirInvoiceLineItemPriceComponent, FPriceComponentList.Link));
end;

function TFhirInvoiceLineItem.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'sequence') then
  begin
    SequenceElement := asPositiveInt(propValue);
    result := propValue;
  end
  else if (isMatchingName(propName, 'chargeItem', ['Reference', 'CodeableConcept'])) then
  begin
    ChargeItem := propValue as TFhirDataType;
    result := propValue;
  end
  else if (propName = 'priceComponent') then
  begin
    PriceComponentList.add(propValue as TFhirInvoiceLineItemPriceComponent);
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirInvoiceLineItem.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'priceComponent') then PriceComponentList.insertItem(index, propValue as TFhirInvoiceLineItemPriceComponent)
  else inherited;
end;

function TFhirInvoiceLineItem.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'sequence') then result := TFhirPositiveInt.create()
  else if (isMatchingName(propName, 'chargeItem', ['Reference', 'CodeableConcept'])) then raise EFHIRException.create('Cannot make property ChargeItem')
  else if (propName = 'priceComponent') then result := PriceComponentList.new()
  else result := inherited createPropertyValue(propName);
end;

function TFhirInvoiceLineItem.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'sequence') then result := 'positiveInt'
  else if (propName = 'chargeItem[x]') then result := 'Reference|CodeableConcept'
  else if (propName = 'priceComponent') then result := 'BackboneElement'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirInvoiceLineItem.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'sequence') then SequenceElement := nil
  else if (isMatchingName(propName, 'chargeItem', ['Reference', 'CodeableConcept'])) then ChargeItemElement := nil
  else if (propName = 'priceComponent') then deletePropertyValue('priceComponent', PriceComponentList, value)
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirInvoiceLineItem.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'sequence') then SequenceElement := asPositiveInt(new)
  else if (isMatchingName(propName, 'chargeItem', ['Reference', 'CodeableConcept'])) then ChargeItemElement := new as TFhirDataType
  else if (propName = 'priceComponent') then replacePropertyValue('priceComponent', PriceComponentList, existing, new)
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirInvoiceLineItem.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'priceComponent') then PriceComponentList.move(source, destination)
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirInvoiceLineItem.fhirType : string;
begin
  result := 'Invoice.lineItem';
end;

function TFhirInvoiceLineItem.Link : TFhirInvoiceLineItem;
begin
  result := TFhirInvoiceLineItem(inherited Link);
end;

function TFhirInvoiceLineItem.Clone : TFhirInvoiceLineItem;
begin
  result := TFhirInvoiceLineItem(inherited Clone);
end;

function TFhirInvoiceLineItem.equals(other : TObject) : boolean; 
var
  o : TFhirInvoiceLineItem;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirInvoiceLineItem)) then
    result := false
  else
  begin
    o := TFhirInvoiceLineItem(other);
    result := compareDeep(sequenceElement, o.sequenceElement, true) and compareDeep(chargeItemElement, o.chargeItemElement, true) and 
      compareDeep(priceComponentList, o.priceComponentList, true);
  end;
end;

function TFhirInvoiceLineItem.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FSequence) and isEmptyProp(FChargeItem) and isEmptyProp(FpriceComponentList);
end;

procedure TFhirInvoiceLineItem.listFieldsInOrder(fields : TStringList);
begin
  inherited listFieldsInOrder(fields);
  fields.add('sequence');
  fields.add('chargeItem[x]');
  fields.add('priceComponent');
end;

function TFhirInvoiceLineItem.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FPriceComponentList.sizeInBytes(magic));
end;

procedure TFhirInvoiceLineItem.SetSequence(value : TFhirPositiveInt);
begin
  FSequence.free;
  FSequence := value;
end;

function TFhirInvoiceLineItem.GetSequenceST : String;
begin
  if FSequence = nil then
    result := ''
  else
    result := FSequence.value;
end;

procedure TFhirInvoiceLineItem.SetSequenceST(value : String);
begin
  if value <> '' then
  begin
    if FSequence = nil then
      FSequence := TFhirPositiveInt.create;
    FSequence.value := value
  end
  else if FSequence <> nil then
    FSequence.value := '';
end;

procedure TFhirInvoiceLineItem.SetChargeItem(value : TFhirDataType);
begin
  FChargeItem.free;
  FChargeItem := value;
end;

function TFhirInvoiceLineItem.GetPriceComponentList : TFhirInvoiceLineItemPriceComponentList;
begin
  if FPriceComponentList = nil then
    FPriceComponentList := TFhirInvoiceLineItemPriceComponentList.Create;
  result := FPriceComponentList;
end;

function TFhirInvoiceLineItem.GetHasPriceComponentList : boolean;
begin
  result := (FPriceComponentList <> nil) and (FPriceComponentList.count > 0);
end;

{ TFhirInvoiceLineItemListEnumerator }

constructor TFhirInvoiceLineItemListEnumerator.Create(list : TFhirInvoiceLineItemList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirInvoiceLineItemListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirInvoiceLineItemListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirInvoiceLineItemListEnumerator.GetCurrent : TFhirInvoiceLineItem;
begin
  Result := FList[FIndex];
end;

function TFhirInvoiceLineItemListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirInvoiceLineItemList }

procedure TFhirInvoiceLineItemList.AddItem(value: TFhirInvoiceLineItem);
begin
  assert(value.ClassName = 'TFhirInvoiceLineItem', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirInvoiceLineItem');
  add(value);
end;

function TFhirInvoiceLineItemList.Append: TFhirInvoiceLineItem;
begin
  result := TFhirInvoiceLineItem.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirInvoiceLineItemList.ClearItems;
begin
  Clear;
end;

function TFhirInvoiceLineItemList.GetEnumerator : TFhirInvoiceLineItemListEnumerator;
begin
  result := TFhirInvoiceLineItemListEnumerator.Create(self.link);
end;

function TFhirInvoiceLineItemList.Clone: TFhirInvoiceLineItemList;
begin
  result := TFhirInvoiceLineItemList(inherited Clone);
end;

function TFhirInvoiceLineItemList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirInvoiceLineItemList.GetItemN(index: Integer): TFhirInvoiceLineItem;
begin
  result := TFhirInvoiceLineItem(ObjectByIndex[index]);
end;

function TFhirInvoiceLineItemList.ItemClass: TFslObjectClass;
begin
  result := TFhirInvoiceLineItem;
end;
function TFhirInvoiceLineItemList.IndexOf(value: TFhirInvoiceLineItem): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirInvoiceLineItemList.Insert(index: Integer): TFhirInvoiceLineItem;
begin
  result := TFhirInvoiceLineItem.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirInvoiceLineItemList.InsertItem(index: Integer; value: TFhirInvoiceLineItem);
begin
  assert(value is TFhirInvoiceLineItem);
  Inherited Insert(index, value);
end;

function TFhirInvoiceLineItemList.Item(index: Integer): TFhirInvoiceLineItem;
begin
  result := TFhirInvoiceLineItem(ObjectByIndex[index]);
end;

function TFhirInvoiceLineItemList.Link: TFhirInvoiceLineItemList;
begin
  result := TFhirInvoiceLineItemList(inherited Link);
end;

procedure TFhirInvoiceLineItemList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirInvoiceLineItemList.SetItemByIndex(index: Integer; value: TFhirInvoiceLineItem);
begin
  assert(value is TFhirInvoiceLineItem);
  FhirInvoiceLineItems[index] := value;
end;

procedure TFhirInvoiceLineItemList.SetItemN(index: Integer; value: TFhirInvoiceLineItem);
begin
  assert(value is TFhirInvoiceLineItem);
  ObjectByIndex[index] := value;
end;

{ TFhirInvoiceLineItemPriceComponent }

constructor TFhirInvoiceLineItemPriceComponent.Create;
begin
  inherited;
end;

destructor TFhirInvoiceLineItemPriceComponent.Destroy;
begin
  FType_.free;
  FCode.free;
  FFactor.free;
  FAmount.free;
  inherited;
end;

procedure TFhirInvoiceLineItemPriceComponent.Assign(oSource : TFslObject);
begin
  inherited;
  type_Element := TFhirInvoiceLineItemPriceComponent(oSource).type_Element.Clone;
  code := TFhirInvoiceLineItemPriceComponent(oSource).code.Clone;
  factorElement := TFhirInvoiceLineItemPriceComponent(oSource).factorElement.Clone;
  amount := TFhirInvoiceLineItemPriceComponent(oSource).amount.Clone;
end;

procedure TFhirInvoiceLineItemPriceComponent.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'type') Then
     list.add(self.link, 'type', FType_.Link);
  if (child_name = 'code') Then
     list.add(self.link, 'code', FCode.Link);
  if (child_name = 'factor') Then
     list.add(self.link, 'factor', FFactor.Link);
  if (child_name = 'amount') Then
     list.add(self.link, 'amount', FAmount.Link);
end;

procedure TFhirInvoiceLineItemPriceComponent.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'type', 'code', false, TFhirEnum, FType_.Link));
  oList.add(TFHIRProperty.create(self, 'code', 'CodeableConcept', false, TFhirCodeableConcept, FCode.Link));
  oList.add(TFHIRProperty.create(self, 'factor', 'decimal', false, TFhirDecimal, FFactor.Link));
  oList.add(TFHIRProperty.create(self, 'amount', 'Money', false, TFhirMoney, FAmount.Link));
end;

function TFhirInvoiceLineItemPriceComponent.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'type') then
  begin
    Type_Element := asEnum(SYSTEMS_TFhirInvoicePriceComponentTypeEnum, CODES_TFhirInvoicePriceComponentTypeEnum, propValue);
    result := propValue;
  end
  else if (propName = 'code') then
  begin
    Code := propValue as TFhirCodeableConcept;
    result := propValue;
  end
  else if (propName = 'factor') then
  begin
    FactorElement := asDecimal(propValue);
    result := propValue;
  end
  else if (propName = 'amount') then
  begin
    Amount := propValue as TFhirMoney;
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirInvoiceLineItemPriceComponent.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirInvoiceLineItemPriceComponent.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'type') then result := TFhirEnum.create(SYSTEMS_TFhirInvoicePriceComponentTypeEnum[InvoicePriceComponentTypeNull], CODES_TFhirInvoicePriceComponentTypeEnum[InvoicePriceComponentTypeNull]) 
  else if (propName = 'code') then result := TFhirCodeableConcept.create()
  else if (propName = 'factor') then result := TFhirDecimal.create()
  else if (propName = 'amount') then result := TFhirMoney.create()
  else result := inherited createPropertyValue(propName);
end;

function TFhirInvoiceLineItemPriceComponent.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'type') then result := 'code'
  else if (propName = 'code') then result := 'CodeableConcept'
  else if (propName = 'factor') then result := 'decimal'
  else if (propName = 'amount') then result := 'Money'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirInvoiceLineItemPriceComponent.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'type') then Type_Element := nil
  else if (propName = 'code') then CodeElement := nil
  else if (propName = 'factor') then FactorElement := nil
  else if (propName = 'amount') then AmountElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirInvoiceLineItemPriceComponent.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'type') then Type_Element := asEnum(SYSTEMS_TFhirInvoicePriceComponentTypeEnum, CODES_TFhirInvoicePriceComponentTypeEnum, new)
  else if (propName = 'code') then CodeElement := new as TFhirCodeableConcept
  else if (propName = 'factor') then FactorElement := asDecimal(new)
  else if (propName = 'amount') then AmountElement := new as TFhirMoney
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirInvoiceLineItemPriceComponent.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirInvoiceLineItemPriceComponent.fhirType : string;
begin
  result := 'Invoice.lineItem.priceComponent';
end;

function TFhirInvoiceLineItemPriceComponent.Link : TFhirInvoiceLineItemPriceComponent;
begin
  result := TFhirInvoiceLineItemPriceComponent(inherited Link);
end;

function TFhirInvoiceLineItemPriceComponent.Clone : TFhirInvoiceLineItemPriceComponent;
begin
  result := TFhirInvoiceLineItemPriceComponent(inherited Clone);
end;

function TFhirInvoiceLineItemPriceComponent.equals(other : TObject) : boolean; 
var
  o : TFhirInvoiceLineItemPriceComponent;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirInvoiceLineItemPriceComponent)) then
    result := false
  else
  begin
    o := TFhirInvoiceLineItemPriceComponent(other);
    result := compareDeep(type_Element, o.type_Element, true) and compareDeep(codeElement, o.codeElement, true) and 
      compareDeep(factorElement, o.factorElement, true) and compareDeep(amountElement, o.amountElement, true);
  end;
end;

function TFhirInvoiceLineItemPriceComponent.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FType_) and isEmptyProp(FCode) and isEmptyProp(FFactor) and isEmptyProp(FAmount);
end;

procedure TFhirInvoiceLineItemPriceComponent.listFieldsInOrder(fields : TStringList);
begin
  inherited listFieldsInOrder(fields);
  fields.add('type');
  fields.add('code');
  fields.add('factor');
  fields.add('amount');
end;

function TFhirInvoiceLineItemPriceComponent.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
end;

procedure TFhirInvoiceLineItemPriceComponent.SetType_(value : TFhirEnum);
begin
  FType_.free;
  FType_ := value;
end;

function TFhirInvoiceLineItemPriceComponent.GetType_ST : TFhirInvoicePriceComponentTypeEnum;
begin
  if FType_ = nil then
    result := TFhirInvoicePriceComponentTypeEnum(0)
  else
    result := TFhirInvoicePriceComponentTypeEnum(StringArrayIndexOfSensitive(CODES_TFhirInvoicePriceComponentTypeEnum, FType_.value));
end;

procedure TFhirInvoiceLineItemPriceComponent.SetType_ST(value : TFhirInvoicePriceComponentTypeEnum);
begin
  if ord(value) = 0 then
    Type_Element := nil
  else
    Type_Element := TFhirEnum.create(SYSTEMS_TFhirInvoicePriceComponentTypeEnum[value], CODES_TFhirInvoicePriceComponentTypeEnum[value]);
end;

procedure TFhirInvoiceLineItemPriceComponent.SetCode(value : TFhirCodeableConcept);
begin
  FCode.free;
  FCode := value;
end;

procedure TFhirInvoiceLineItemPriceComponent.SetFactor(value : TFhirDecimal);
begin
  FFactor.free;
  FFactor := value;
end;

function TFhirInvoiceLineItemPriceComponent.GetFactorST : String;
begin
  if FFactor = nil then
    result := ''
  else
    result := FFactor.value;
end;

procedure TFhirInvoiceLineItemPriceComponent.SetFactorST(value : String);
begin
  if value <> '' then
  begin
    if FFactor = nil then
      FFactor := TFhirDecimal.create;
    FFactor.value := value
  end
  else if FFactor <> nil then
    FFactor.value := '';
end;

procedure TFhirInvoiceLineItemPriceComponent.SetAmount(value : TFhirMoney);
begin
  FAmount.free;
  FAmount := value;
end;

{ TFhirInvoiceLineItemPriceComponentListEnumerator }

constructor TFhirInvoiceLineItemPriceComponentListEnumerator.Create(list : TFhirInvoiceLineItemPriceComponentList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirInvoiceLineItemPriceComponentListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirInvoiceLineItemPriceComponentListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirInvoiceLineItemPriceComponentListEnumerator.GetCurrent : TFhirInvoiceLineItemPriceComponent;
begin
  Result := FList[FIndex];
end;

function TFhirInvoiceLineItemPriceComponentListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirInvoiceLineItemPriceComponentList }

procedure TFhirInvoiceLineItemPriceComponentList.AddItem(value: TFhirInvoiceLineItemPriceComponent);
begin
  assert(value.ClassName = 'TFhirInvoiceLineItemPriceComponent', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirInvoiceLineItemPriceComponent');
  add(value);
end;

function TFhirInvoiceLineItemPriceComponentList.Append: TFhirInvoiceLineItemPriceComponent;
begin
  result := TFhirInvoiceLineItemPriceComponent.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirInvoiceLineItemPriceComponentList.ClearItems;
begin
  Clear;
end;

function TFhirInvoiceLineItemPriceComponentList.GetEnumerator : TFhirInvoiceLineItemPriceComponentListEnumerator;
begin
  result := TFhirInvoiceLineItemPriceComponentListEnumerator.Create(self.link);
end;

function TFhirInvoiceLineItemPriceComponentList.Clone: TFhirInvoiceLineItemPriceComponentList;
begin
  result := TFhirInvoiceLineItemPriceComponentList(inherited Clone);
end;

function TFhirInvoiceLineItemPriceComponentList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirInvoiceLineItemPriceComponentList.GetItemN(index: Integer): TFhirInvoiceLineItemPriceComponent;
begin
  result := TFhirInvoiceLineItemPriceComponent(ObjectByIndex[index]);
end;

function TFhirInvoiceLineItemPriceComponentList.ItemClass: TFslObjectClass;
begin
  result := TFhirInvoiceLineItemPriceComponent;
end;
function TFhirInvoiceLineItemPriceComponentList.IndexOf(value: TFhirInvoiceLineItemPriceComponent): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirInvoiceLineItemPriceComponentList.Insert(index: Integer): TFhirInvoiceLineItemPriceComponent;
begin
  result := TFhirInvoiceLineItemPriceComponent.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirInvoiceLineItemPriceComponentList.InsertItem(index: Integer; value: TFhirInvoiceLineItemPriceComponent);
begin
  assert(value is TFhirInvoiceLineItemPriceComponent);
  Inherited Insert(index, value);
end;

function TFhirInvoiceLineItemPriceComponentList.Item(index: Integer): TFhirInvoiceLineItemPriceComponent;
begin
  result := TFhirInvoiceLineItemPriceComponent(ObjectByIndex[index]);
end;

function TFhirInvoiceLineItemPriceComponentList.Link: TFhirInvoiceLineItemPriceComponentList;
begin
  result := TFhirInvoiceLineItemPriceComponentList(inherited Link);
end;

procedure TFhirInvoiceLineItemPriceComponentList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirInvoiceLineItemPriceComponentList.SetItemByIndex(index: Integer; value: TFhirInvoiceLineItemPriceComponent);
begin
  assert(value is TFhirInvoiceLineItemPriceComponent);
  FhirInvoiceLineItemPriceComponents[index] := value;
end;

procedure TFhirInvoiceLineItemPriceComponentList.SetItemN(index: Integer; value: TFhirInvoiceLineItemPriceComponent);
begin
  assert(value is TFhirInvoiceLineItemPriceComponent);
  ObjectByIndex[index] := value;
end;

{ TFhirInvoice }

constructor TFhirInvoice.Create;
begin
  inherited;
end;

destructor TFhirInvoice.Destroy;
begin
  FIdentifierList.Free;
  FStatus.free;
  FCancelledReason.free;
  FType_.free;
  FSubject.free;
  FRecipient.free;
  FDate.free;
  FParticipantList.Free;
  FIssuer.free;
  FAccount.free;
  FLineItemList.Free;
  FTotalPriceComponentList.Free;
  FTotalNet.free;
  FTotalGross.free;
  FPaymentTerms.free;
  FNoteList.Free;
  inherited;
end;

procedure TFhirInvoice.Assign(oSource : TFslObject);
begin
  inherited;
  if (TFhirInvoice(oSource).FIdentifierList = nil) then
  begin
    FIdentifierList.free;
    FIdentifierList := nil;
  end
  else
  begin
    if FIdentifierList = nil then
      FIdentifierList := TFhirIdentifierList.Create;
    FIdentifierList.Assign(TFhirInvoice(oSource).FIdentifierList);
  end;
  statusElement := TFhirInvoice(oSource).statusElement.Clone;
  cancelledReasonElement := TFhirInvoice(oSource).cancelledReasonElement.Clone;
  type_ := TFhirInvoice(oSource).type_.Clone;
  subject := TFhirInvoice(oSource).subject.Clone;
  recipient := TFhirInvoice(oSource).recipient.Clone;
  dateElement := TFhirInvoice(oSource).dateElement.Clone;
  if (TFhirInvoice(oSource).FParticipantList = nil) then
  begin
    FParticipantList.free;
    FParticipantList := nil;
  end
  else
  begin
    if FParticipantList = nil then
      FParticipantList := TFhirInvoiceParticipantList.Create;
    FParticipantList.Assign(TFhirInvoice(oSource).FParticipantList);
  end;
  issuer := TFhirInvoice(oSource).issuer.Clone;
  account := TFhirInvoice(oSource).account.Clone;
  if (TFhirInvoice(oSource).FLineItemList = nil) then
  begin
    FLineItemList.free;
    FLineItemList := nil;
  end
  else
  begin
    if FLineItemList = nil then
      FLineItemList := TFhirInvoiceLineItemList.Create;
    FLineItemList.Assign(TFhirInvoice(oSource).FLineItemList);
  end;
  if (TFhirInvoice(oSource).FTotalPriceComponentList = nil) then
  begin
    FTotalPriceComponentList.free;
    FTotalPriceComponentList := nil;
  end
  else
  begin
    if FTotalPriceComponentList = nil then
      FTotalPriceComponentList := TFhirInvoiceLineItemPriceComponentList.Create;
    FTotalPriceComponentList.Assign(TFhirInvoice(oSource).FTotalPriceComponentList);
  end;
  totalNet := TFhirInvoice(oSource).totalNet.Clone;
  totalGross := TFhirInvoice(oSource).totalGross.Clone;
  paymentTermsElement := TFhirInvoice(oSource).paymentTermsElement.Clone;
  if (TFhirInvoice(oSource).FNoteList = nil) then
  begin
    FNoteList.free;
    FNoteList := nil;
  end
  else
  begin
    if FNoteList = nil then
      FNoteList := TFhirAnnotationList.Create;
    FNoteList.Assign(TFhirInvoice(oSource).FNoteList);
  end;
end;

function TFhirInvoice.GetResourceType : TFhirResourceType;
begin
  result := frtInvoice;
end;

procedure TFhirInvoice.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'identifier') Then
    list.addAll(self, 'identifier', FIdentifierList);
  if (child_name = 'status') Then
     list.add(self.link, 'status', FStatus.Link);
  if (child_name = 'cancelledReason') Then
     list.add(self.link, 'cancelledReason', FCancelledReason.Link);
  if (child_name = 'type') Then
     list.add(self.link, 'type', FType_.Link);
  if (child_name = 'subject') Then
     list.add(self.link, 'subject', FSubject.Link);
  if (child_name = 'recipient') Then
     list.add(self.link, 'recipient', FRecipient.Link);
  if (child_name = 'date') Then
     list.add(self.link, 'date', FDate.Link);
  if (child_name = 'participant') Then
    list.addAll(self, 'participant', FParticipantList);
  if (child_name = 'issuer') Then
     list.add(self.link, 'issuer', FIssuer.Link);
  if (child_name = 'account') Then
     list.add(self.link, 'account', FAccount.Link);
  if (child_name = 'lineItem') Then
    list.addAll(self, 'lineItem', FLineItemList);
  if (child_name = 'totalPriceComponent') Then
    list.addAll(self, 'totalPriceComponent', FTotalPriceComponentList);
  if (child_name = 'totalNet') Then
     list.add(self.link, 'totalNet', FTotalNet.Link);
  if (child_name = 'totalGross') Then
     list.add(self.link, 'totalGross', FTotalGross.Link);
  if (child_name = 'paymentTerms') Then
     list.add(self.link, 'paymentTerms', FPaymentTerms.Link);
  if (child_name = 'note') Then
    list.addAll(self, 'note', FNoteList);
end;

procedure TFhirInvoice.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'identifier', 'Identifier', true, TFhirIdentifier, FIdentifierList.Link));
  oList.add(TFHIRProperty.create(self, 'status', 'code', false, TFhirEnum, FStatus.Link));
  oList.add(TFHIRProperty.create(self, 'cancelledReason', 'string', false, TFhirString, FCancelledReason.Link));
  oList.add(TFHIRProperty.create(self, 'type', 'CodeableConcept', false, TFhirCodeableConcept, FType_.Link));
  oList.add(TFHIRProperty.create(self, 'subject', 'Reference', false, TFhirReference, FSubject.Link));
  oList.add(TFHIRProperty.create(self, 'recipient', 'Reference', false, TFhirReference, FRecipient.Link));
  oList.add(TFHIRProperty.create(self, 'date', 'dateTime', false, TFhirDateTime, FDate.Link));
  oList.add(TFHIRProperty.create(self, 'participant', 'BackboneElement', true, TFhirInvoiceParticipant, FParticipantList.Link));
  oList.add(TFHIRProperty.create(self, 'issuer', 'Reference', false, TFhirReference, FIssuer.Link));
  oList.add(TFHIRProperty.create(self, 'account', 'Reference', false, TFhirReference, FAccount.Link));
  oList.add(TFHIRProperty.create(self, 'lineItem', 'BackboneElement', true, TFhirInvoiceLineItem, FLineItemList.Link));
  oList.add(TFHIRProperty.create(self, 'totalPriceComponent', '', true, TFhirInvoiceLineItemPriceComponent, FTotalPriceComponentList.Link));
  oList.add(TFHIRProperty.create(self, 'totalNet', 'Money', false, TFhirMoney, FTotalNet.Link));
  oList.add(TFHIRProperty.create(self, 'totalGross', 'Money', false, TFhirMoney, FTotalGross.Link));
  oList.add(TFHIRProperty.create(self, 'paymentTerms', 'markdown', false, TFhirMarkdown, FPaymentTerms.Link));
  oList.add(TFHIRProperty.create(self, 'note', 'Annotation', true, TFhirAnnotation, FNoteList.Link));
end;

function TFhirInvoice.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'identifier') then
  begin
    IdentifierList.add(propValue as TFhirIdentifier);
    result := propValue;
  end
  else if (propName = 'status') then
  begin
    StatusElement := asEnum(SYSTEMS_TFhirInvoiceStatusEnum, CODES_TFhirInvoiceStatusEnum, propValue);
    result := propValue;
  end
  else if (propName = 'cancelledReason') then
  begin
    CancelledReasonElement := asString(propValue);
    result := propValue;
  end
  else if (propName = 'type') then
  begin
    Type_ := propValue as TFhirCodeableConcept;
    result := propValue;
  end
  else if (propName = 'subject') then
  begin
    Subject := propValue as TFhirReference;
    result := propValue;
  end
  else if (propName = 'recipient') then
  begin
    Recipient := propValue as TFhirReference;
    result := propValue;
  end
  else if (propName = 'date') then
  begin
    DateElement := asDateTime(propValue);
    result := propValue;
  end
  else if (propName = 'participant') then
  begin
    ParticipantList.add(propValue as TFhirInvoiceParticipant);
    result := propValue;
  end
  else if (propName = 'issuer') then
  begin
    Issuer := propValue as TFhirReference;
    result := propValue;
  end
  else if (propName = 'account') then
  begin
    Account := propValue as TFhirReference;
    result := propValue;
  end
  else if (propName = 'lineItem') then
  begin
    LineItemList.add(propValue as TFhirInvoiceLineItem);
    result := propValue;
  end
  else if (propName = 'totalPriceComponent') then
  begin
    TotalPriceComponentList.add(propValue as TFhirInvoiceLineItemPriceComponent);
    result := propValue;
  end
  else if (propName = 'totalNet') then
  begin
    TotalNet := propValue as TFhirMoney;
    result := propValue;
  end
  else if (propName = 'totalGross') then
  begin
    TotalGross := propValue as TFhirMoney;
    result := propValue;
  end
  else if (propName = 'paymentTerms') then
  begin
    PaymentTermsElement := asMarkdown(propValue);
    result := propValue;
  end
  else if (propName = 'note') then
  begin
    NoteList.add(propValue as TFhirAnnotation);
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirInvoice.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'identifier') then IdentifierList.insertItem(index, propValue as TFhirIdentifier)
  else if (propName = 'participant') then ParticipantList.insertItem(index, propValue as TFhirInvoiceParticipant)
  else if (propName = 'lineItem') then LineItemList.insertItem(index, propValue as TFhirInvoiceLineItem)
  else if (propName = 'totalPriceComponent') then TotalPriceComponentList.insertItem(index, propValue as TFhirInvoiceLineItemPriceComponent)
  else if (propName = 'note') then NoteList.insertItem(index, propValue as TFhirAnnotation)
  else inherited;
end;

function TFhirInvoice.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'identifier') then result := IdentifierList.new()
  else if (propName = 'status') then result := TFhirEnum.create(SYSTEMS_TFhirInvoiceStatusEnum[InvoiceStatusNull], CODES_TFhirInvoiceStatusEnum[InvoiceStatusNull]) 
  else if (propName = 'cancelledReason') then result := TFhirString.create()
  else if (propName = 'type') then result := TFhirCodeableConcept.create()
  else if (propName = 'subject') then result := TFhirReference.create()
  else if (propName = 'recipient') then result := TFhirReference.create()
  else if (propName = 'date') then result := TFhirDateTime.create()
  else if (propName = 'participant') then result := ParticipantList.new()
  else if (propName = 'issuer') then result := TFhirReference.create()
  else if (propName = 'account') then result := TFhirReference.create()
  else if (propName = 'lineItem') then result := LineItemList.new()
  else if (propName = 'totalPriceComponent') then result := TotalPriceComponentList.new()
  else if (propName = 'totalNet') then result := TFhirMoney.create()
  else if (propName = 'totalGross') then result := TFhirMoney.create()
  else if (propName = 'paymentTerms') then result := TFhirMarkdown.create()
  else if (propName = 'note') then result := NoteList.new()
  else result := inherited createPropertyValue(propName);
end;

function TFhirInvoice.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'identifier') then result := 'Identifier'
  else if (propName = 'status') then result := 'code'
  else if (propName = 'cancelledReason') then result := 'string'
  else if (propName = 'type') then result := 'CodeableConcept'
  else if (propName = 'subject') then result := 'Reference'
  else if (propName = 'recipient') then result := 'Reference'
  else if (propName = 'date') then result := 'dateTime'
  else if (propName = 'participant') then result := 'BackboneElement'
  else if (propName = 'issuer') then result := 'Reference'
  else if (propName = 'account') then result := 'Reference'
  else if (propName = 'lineItem') then result := 'BackboneElement'
  else if (propName = 'totalPriceComponent') then result := ''
  else if (propName = 'totalNet') then result := 'Money'
  else if (propName = 'totalGross') then result := 'Money'
  else if (propName = 'paymentTerms') then result := 'markdown'
  else if (propName = 'note') then result := 'Annotation'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirInvoice.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'identifier') then deletePropertyValue('identifier', IdentifierList, value)
  else if (propName = 'status') then StatusElement := nil
  else if (propName = 'cancelledReason') then CancelledReasonElement := nil
  else if (propName = 'type') then Type_Element := nil
  else if (propName = 'subject') then SubjectElement := nil
  else if (propName = 'recipient') then RecipientElement := nil
  else if (propName = 'date') then DateElement := nil
  else if (propName = 'participant') then deletePropertyValue('participant', ParticipantList, value)
  else if (propName = 'issuer') then IssuerElement := nil
  else if (propName = 'account') then AccountElement := nil
  else if (propName = 'lineItem') then deletePropertyValue('lineItem', LineItemList, value)
  else if (propName = 'totalPriceComponent') then deletePropertyValue('totalPriceComponent', TotalPriceComponentList, value)
  else if (propName = 'totalNet') then TotalNetElement := nil
  else if (propName = 'totalGross') then TotalGrossElement := nil
  else if (propName = 'paymentTerms') then PaymentTermsElement := nil
  else if (propName = 'note') then deletePropertyValue('note', NoteList, value)
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirInvoice.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'identifier') then replacePropertyValue('identifier', IdentifierList, existing, new)
  else if (propName = 'status') then StatusElement := asEnum(SYSTEMS_TFhirInvoiceStatusEnum, CODES_TFhirInvoiceStatusEnum, new)
  else if (propName = 'cancelledReason') then CancelledReasonElement := asString(new)
  else if (propName = 'type') then Type_Element := new as TFhirCodeableConcept
  else if (propName = 'subject') then SubjectElement := new as TFhirReference
  else if (propName = 'recipient') then RecipientElement := new as TFhirReference
  else if (propName = 'date') then DateElement := asDateTime(new)
  else if (propName = 'participant') then replacePropertyValue('participant', ParticipantList, existing, new)
  else if (propName = 'issuer') then IssuerElement := new as TFhirReference
  else if (propName = 'account') then AccountElement := new as TFhirReference
  else if (propName = 'lineItem') then replacePropertyValue('lineItem', LineItemList, existing, new)
  else if (propName = 'totalPriceComponent') then replacePropertyValue('totalPriceComponent', TotalPriceComponentList, existing, new)
  else if (propName = 'totalNet') then TotalNetElement := new as TFhirMoney
  else if (propName = 'totalGross') then TotalGrossElement := new as TFhirMoney
  else if (propName = 'paymentTerms') then PaymentTermsElement := asMarkdown(new)
  else if (propName = 'note') then replacePropertyValue('note', NoteList, existing, new)
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirInvoice.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'identifier') then IdentifierList.move(source, destination)
  else if (propName = 'participant') then ParticipantList.move(source, destination)
  else if (propName = 'lineItem') then LineItemList.move(source, destination)
  else if (propName = 'totalPriceComponent') then TotalPriceComponentList.move(source, destination)
  else if (propName = 'note') then NoteList.move(source, destination)
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirInvoice.fhirType : string;
begin
  result := 'Invoice';
end;

function TFhirInvoice.Link : TFhirInvoice;
begin
  result := TFhirInvoice(inherited Link);
end;

function TFhirInvoice.Clone : TFhirInvoice;
begin
  result := TFhirInvoice(inherited Clone);
end;

function TFhirInvoice.equals(other : TObject) : boolean; 
var
  o : TFhirInvoice;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirInvoice)) then
    result := false
  else
  begin
    o := TFhirInvoice(other);
    result := compareDeep(identifierList, o.identifierList, true) and compareDeep(statusElement, o.statusElement, true) and 
      compareDeep(cancelledReasonElement, o.cancelledReasonElement, true) and compareDeep(type_Element, o.type_Element, true) and 
      compareDeep(subjectElement, o.subjectElement, true) and compareDeep(recipientElement, o.recipientElement, true) and 
      compareDeep(dateElement, o.dateElement, true) and compareDeep(participantList, o.participantList, true) and 
      compareDeep(issuerElement, o.issuerElement, true) and compareDeep(accountElement, o.accountElement, true) and 
      compareDeep(lineItemList, o.lineItemList, true) and compareDeep(totalPriceComponentList, o.totalPriceComponentList, true) and 
      compareDeep(totalNetElement, o.totalNetElement, true) and compareDeep(totalGrossElement, o.totalGrossElement, true) and 
      compareDeep(paymentTermsElement, o.paymentTermsElement, true) and compareDeep(noteList, o.noteList, true);
  end;
end;

function TFhirInvoice.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FidentifierList) and isEmptyProp(FStatus) and isEmptyProp(FCancelledReason) and isEmptyProp(FType_) and isEmptyProp(FSubject) and isEmptyProp(FRecipient) and isEmptyProp(FDate) and isEmptyProp(FparticipantList) and isEmptyProp(FIssuer) and isEmptyProp(FAccount) and isEmptyProp(FlineItemList) and isEmptyProp(FtotalPriceComponentList) and isEmptyProp(FTotalNet) and isEmptyProp(FTotalGross) and isEmptyProp(FPaymentTerms) and isEmptyProp(FnoteList);
end;

procedure TFhirInvoice.listFieldsInOrder(fields : TStringList);
begin
  inherited listFieldsInOrder(fields);
  fields.add('identifier');
  fields.add('status');
  fields.add('cancelledReason');
  fields.add('type');
  fields.add('subject');
  fields.add('recipient');
  fields.add('date');
  fields.add('participant');
  fields.add('issuer');
  fields.add('account');
  fields.add('lineItem');
  fields.add('totalPriceComponent');
  fields.add('totalNet');
  fields.add('totalGross');
  fields.add('paymentTerms');
  fields.add('note');
end;

function TFhirInvoice.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FIdentifierList.sizeInBytes(magic));
  inc(result, FParticipantList.sizeInBytes(magic));
  inc(result, FLineItemList.sizeInBytes(magic));
  inc(result, FTotalPriceComponentList.sizeInBytes(magic));
  inc(result, FNoteList.sizeInBytes(magic));
end;

function TFhirInvoice.GetIdentifierList : TFhirIdentifierList;
begin
  if FIdentifierList = nil then
    FIdentifierList := TFhirIdentifierList.Create;
  result := FIdentifierList;
end;

function TFhirInvoice.GetHasIdentifierList : boolean;
begin
  result := (FIdentifierList <> nil) and (FIdentifierList.count > 0);
end;

procedure TFhirInvoice.SetStatus(value : TFhirEnum);
begin
  FStatus.free;
  FStatus := value;
end;

function TFhirInvoice.GetStatusST : TFhirInvoiceStatusEnum;
begin
  if FStatus = nil then
    result := TFhirInvoiceStatusEnum(0)
  else
    result := TFhirInvoiceStatusEnum(StringArrayIndexOfSensitive(CODES_TFhirInvoiceStatusEnum, FStatus.value));
end;

procedure TFhirInvoice.SetStatusST(value : TFhirInvoiceStatusEnum);
begin
  if ord(value) = 0 then
    StatusElement := nil
  else
    StatusElement := TFhirEnum.create(SYSTEMS_TFhirInvoiceStatusEnum[value], CODES_TFhirInvoiceStatusEnum[value]);
end;

procedure TFhirInvoice.SetCancelledReason(value : TFhirString);
begin
  FCancelledReason.free;
  FCancelledReason := value;
end;

function TFhirInvoice.GetCancelledReasonST : String;
begin
  if FCancelledReason = nil then
    result := ''
  else
    result := FCancelledReason.value;
end;

procedure TFhirInvoice.SetCancelledReasonST(value : String);
begin
  if value <> '' then
  begin
    if FCancelledReason = nil then
      FCancelledReason := TFhirString.create;
    FCancelledReason.value := value
  end
  else if FCancelledReason <> nil then
    FCancelledReason.value := '';
end;

procedure TFhirInvoice.SetType_(value : TFhirCodeableConcept);
begin
  FType_.free;
  FType_ := value;
end;

procedure TFhirInvoice.SetSubject(value : TFhirReference);
begin
  FSubject.free;
  FSubject := value;
end;

procedure TFhirInvoice.SetRecipient(value : TFhirReference);
begin
  FRecipient.free;
  FRecipient := value;
end;

procedure TFhirInvoice.SetDate(value : TFhirDateTime);
begin
  FDate.free;
  FDate := value;
end;

function TFhirInvoice.GetDateST : TFslDateTime;
begin
  if FDate = nil then
    result := TFslDateTime.makeNull
  else
    result := FDate.value;
end;

procedure TFhirInvoice.SetDateST(value : TFslDateTime);
begin
  if FDate = nil then
    FDate := TFhirDateTime.create;
  FDate.value := value
end;

function TFhirInvoice.GetParticipantList : TFhirInvoiceParticipantList;
begin
  if FParticipantList = nil then
    FParticipantList := TFhirInvoiceParticipantList.Create;
  result := FParticipantList;
end;

function TFhirInvoice.GetHasParticipantList : boolean;
begin
  result := (FParticipantList <> nil) and (FParticipantList.count > 0);
end;

procedure TFhirInvoice.SetIssuer(value : TFhirReference);
begin
  FIssuer.free;
  FIssuer := value;
end;

procedure TFhirInvoice.SetAccount(value : TFhirReference);
begin
  FAccount.free;
  FAccount := value;
end;

function TFhirInvoice.GetLineItemList : TFhirInvoiceLineItemList;
begin
  if FLineItemList = nil then
    FLineItemList := TFhirInvoiceLineItemList.Create;
  result := FLineItemList;
end;

function TFhirInvoice.GetHasLineItemList : boolean;
begin
  result := (FLineItemList <> nil) and (FLineItemList.count > 0);
end;

function TFhirInvoice.GetTotalPriceComponentList : TFhirInvoiceLineItemPriceComponentList;
begin
  if FTotalPriceComponentList = nil then
    FTotalPriceComponentList := TFhirInvoiceLineItemPriceComponentList.Create;
  result := FTotalPriceComponentList;
end;

function TFhirInvoice.GetHasTotalPriceComponentList : boolean;
begin
  result := (FTotalPriceComponentList <> nil) and (FTotalPriceComponentList.count > 0);
end;

procedure TFhirInvoice.SetTotalNet(value : TFhirMoney);
begin
  FTotalNet.free;
  FTotalNet := value;
end;

procedure TFhirInvoice.SetTotalGross(value : TFhirMoney);
begin
  FTotalGross.free;
  FTotalGross := value;
end;

procedure TFhirInvoice.SetPaymentTerms(value : TFhirMarkdown);
begin
  FPaymentTerms.free;
  FPaymentTerms := value;
end;

function TFhirInvoice.GetPaymentTermsST : String;
begin
  if FPaymentTerms = nil then
    result := ''
  else
    result := FPaymentTerms.value;
end;

procedure TFhirInvoice.SetPaymentTermsST(value : String);
begin
  if value <> '' then
  begin
    if FPaymentTerms = nil then
      FPaymentTerms := TFhirMarkdown.create;
    FPaymentTerms.value := value
  end
  else if FPaymentTerms <> nil then
    FPaymentTerms.value := '';
end;

function TFhirInvoice.GetNoteList : TFhirAnnotationList;
begin
  if FNoteList = nil then
    FNoteList := TFhirAnnotationList.Create;
  result := FNoteList;
end;

function TFhirInvoice.GetHasNoteList : boolean;
begin
  result := (FNoteList <> nil) and (FNoteList.count > 0);
end;

{ TFhirInvoiceListEnumerator }

constructor TFhirInvoiceListEnumerator.Create(list : TFhirInvoiceList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirInvoiceListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirInvoiceListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirInvoiceListEnumerator.GetCurrent : TFhirInvoice;
begin
  Result := FList[FIndex];
end;

function TFhirInvoiceListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirInvoiceList }

procedure TFhirInvoiceList.AddItem(value: TFhirInvoice);
begin
  assert(value.ClassName = 'TFhirInvoice', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirInvoice');
  add(value);
end;

function TFhirInvoiceList.Append: TFhirInvoice;
begin
  result := TFhirInvoice.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirInvoiceList.ClearItems;
begin
  Clear;
end;

function TFhirInvoiceList.GetEnumerator : TFhirInvoiceListEnumerator;
begin
  result := TFhirInvoiceListEnumerator.Create(self.link);
end;

function TFhirInvoiceList.Clone: TFhirInvoiceList;
begin
  result := TFhirInvoiceList(inherited Clone);
end;

function TFhirInvoiceList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirInvoiceList.GetItemN(index: Integer): TFhirInvoice;
begin
  result := TFhirInvoice(ObjectByIndex[index]);
end;

function TFhirInvoiceList.ItemClass: TFslObjectClass;
begin
  result := TFhirInvoice;
end;
function TFhirInvoiceList.IndexOf(value: TFhirInvoice): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirInvoiceList.Insert(index: Integer): TFhirInvoice;
begin
  result := TFhirInvoice.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirInvoiceList.InsertItem(index: Integer; value: TFhirInvoice);
begin
  assert(value is TFhirInvoice);
  Inherited Insert(index, value);
end;

function TFhirInvoiceList.Item(index: Integer): TFhirInvoice;
begin
  result := TFhirInvoice(ObjectByIndex[index]);
end;

function TFhirInvoiceList.Link: TFhirInvoiceList;
begin
  result := TFhirInvoiceList(inherited Link);
end;

procedure TFhirInvoiceList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirInvoiceList.SetItemByIndex(index: Integer; value: TFhirInvoice);
begin
  assert(value is TFhirInvoice);
  FhirInvoices[index] := value;
end;

procedure TFhirInvoiceList.SetItemN(index: Integer; value: TFhirInvoice);
begin
  assert(value is TFhirInvoice);
  ObjectByIndex[index] := value;
end;

{$ENDIF FHIR_INVOICE}
{$IFDEF FHIR_PAYMENTNOTICE}
{ TFhirPaymentNotice }

constructor TFhirPaymentNotice.Create;
begin
  inherited;
end;

destructor TFhirPaymentNotice.Destroy;
begin
  FIdentifierList.Free;
  FStatus.free;
  FRequest.free;
  FResponse.free;
  FCreated.free;
  FProvider.free;
  FPayment.free;
  FPaymentDate.free;
  FPayee.free;
  FRecipient.free;
  FAmount.free;
  FPaymentStatus.free;
  inherited;
end;

procedure TFhirPaymentNotice.Assign(oSource : TFslObject);
begin
  inherited;
  if (TFhirPaymentNotice(oSource).FIdentifierList = nil) then
  begin
    FIdentifierList.free;
    FIdentifierList := nil;
  end
  else
  begin
    if FIdentifierList = nil then
      FIdentifierList := TFhirIdentifierList.Create;
    FIdentifierList.Assign(TFhirPaymentNotice(oSource).FIdentifierList);
  end;
  statusElement := TFhirPaymentNotice(oSource).statusElement.Clone;
  request := TFhirPaymentNotice(oSource).request.Clone;
  response := TFhirPaymentNotice(oSource).response.Clone;
  createdElement := TFhirPaymentNotice(oSource).createdElement.Clone;
  provider := TFhirPaymentNotice(oSource).provider.Clone;
  payment := TFhirPaymentNotice(oSource).payment.Clone;
  paymentDateElement := TFhirPaymentNotice(oSource).paymentDateElement.Clone;
  payee := TFhirPaymentNotice(oSource).payee.Clone;
  recipient := TFhirPaymentNotice(oSource).recipient.Clone;
  amount := TFhirPaymentNotice(oSource).amount.Clone;
  paymentStatus := TFhirPaymentNotice(oSource).paymentStatus.Clone;
end;

function TFhirPaymentNotice.GetResourceType : TFhirResourceType;
begin
  result := frtPaymentNotice;
end;

procedure TFhirPaymentNotice.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'identifier') Then
    list.addAll(self, 'identifier', FIdentifierList);
  if (child_name = 'status') Then
     list.add(self.link, 'status', FStatus.Link);
  if (child_name = 'request') Then
     list.add(self.link, 'request', FRequest.Link);
  if (child_name = 'response') Then
     list.add(self.link, 'response', FResponse.Link);
  if (child_name = 'created') Then
     list.add(self.link, 'created', FCreated.Link);
  if (child_name = 'provider') Then
     list.add(self.link, 'provider', FProvider.Link);
  if (child_name = 'payment') Then
     list.add(self.link, 'payment', FPayment.Link);
  if (child_name = 'paymentDate') Then
     list.add(self.link, 'paymentDate', FPaymentDate.Link);
  if (child_name = 'payee') Then
     list.add(self.link, 'payee', FPayee.Link);
  if (child_name = 'recipient') Then
     list.add(self.link, 'recipient', FRecipient.Link);
  if (child_name = 'amount') Then
     list.add(self.link, 'amount', FAmount.Link);
  if (child_name = 'paymentStatus') Then
     list.add(self.link, 'paymentStatus', FPaymentStatus.Link);
end;

procedure TFhirPaymentNotice.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'identifier', 'Identifier', true, TFhirIdentifier, FIdentifierList.Link));
  oList.add(TFHIRProperty.create(self, 'status', 'code', false, TFhirEnum, FStatus.Link));
  oList.add(TFHIRProperty.create(self, 'request', 'Reference', false, TFhirReference, FRequest.Link));
  oList.add(TFHIRProperty.create(self, 'response', 'Reference', false, TFhirReference, FResponse.Link));
  oList.add(TFHIRProperty.create(self, 'created', 'dateTime', false, TFhirDateTime, FCreated.Link));
  oList.add(TFHIRProperty.create(self, 'provider', 'Reference', false, TFhirReference, FProvider.Link));
  oList.add(TFHIRProperty.create(self, 'payment', 'Reference', false, TFhirReference, FPayment.Link));
  oList.add(TFHIRProperty.create(self, 'paymentDate', 'date', false, TFhirDate, FPaymentDate.Link));
  oList.add(TFHIRProperty.create(self, 'payee', 'Reference', false, TFhirReference, FPayee.Link));
  oList.add(TFHIRProperty.create(self, 'recipient', 'Reference', false, TFhirReference, FRecipient.Link));
  oList.add(TFHIRProperty.create(self, 'amount', 'Money', false, TFhirMoney, FAmount.Link));
  oList.add(TFHIRProperty.create(self, 'paymentStatus', 'CodeableConcept', false, TFhirCodeableConcept, FPaymentStatus.Link));
end;

function TFhirPaymentNotice.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'identifier') then
  begin
    IdentifierList.add(propValue as TFhirIdentifier);
    result := propValue;
  end
  else if (propName = 'status') then
  begin
    StatusElement := asEnum(SYSTEMS_TFhirFinancialResourceStatusCodesEnum, CODES_TFhirFinancialResourceStatusCodesEnum, propValue);
    result := propValue;
  end
  else if (propName = 'request') then
  begin
    Request := propValue as TFhirReference;
    result := propValue;
  end
  else if (propName = 'response') then
  begin
    Response := propValue as TFhirReference;
    result := propValue;
  end
  else if (propName = 'created') then
  begin
    CreatedElement := asDateTime(propValue);
    result := propValue;
  end
  else if (propName = 'provider') then
  begin
    Provider := propValue as TFhirReference;
    result := propValue;
  end
  else if (propName = 'payment') then
  begin
    Payment := propValue as TFhirReference;
    result := propValue;
  end
  else if (propName = 'paymentDate') then
  begin
    PaymentDateElement := asDate(propValue);
    result := propValue;
  end
  else if (propName = 'payee') then
  begin
    Payee := propValue as TFhirReference;
    result := propValue;
  end
  else if (propName = 'recipient') then
  begin
    Recipient := propValue as TFhirReference;
    result := propValue;
  end
  else if (propName = 'amount') then
  begin
    Amount := propValue as TFhirMoney;
    result := propValue;
  end
  else if (propName = 'paymentStatus') then
  begin
    PaymentStatus := propValue as TFhirCodeableConcept;
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirPaymentNotice.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'identifier') then IdentifierList.insertItem(index, propValue as TFhirIdentifier)
  else inherited;
end;

function TFhirPaymentNotice.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'identifier') then result := IdentifierList.new()
  else if (propName = 'status') then result := TFhirEnum.create(SYSTEMS_TFhirFinancialResourceStatusCodesEnum[FinancialResourceStatusCodesNull], CODES_TFhirFinancialResourceStatusCodesEnum[FinancialResourceStatusCodesNull]) 
  else if (propName = 'request') then result := TFhirReference.create()
  else if (propName = 'response') then result := TFhirReference.create()
  else if (propName = 'created') then result := TFhirDateTime.create()
  else if (propName = 'provider') then result := TFhirReference.create()
  else if (propName = 'payment') then result := TFhirReference.create()
  else if (propName = 'paymentDate') then result := TFhirDate.create()
  else if (propName = 'payee') then result := TFhirReference.create()
  else if (propName = 'recipient') then result := TFhirReference.create()
  else if (propName = 'amount') then result := TFhirMoney.create()
  else if (propName = 'paymentStatus') then result := TFhirCodeableConcept.create()
  else result := inherited createPropertyValue(propName);
end;

function TFhirPaymentNotice.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'identifier') then result := 'Identifier'
  else if (propName = 'status') then result := 'code'
  else if (propName = 'request') then result := 'Reference'
  else if (propName = 'response') then result := 'Reference'
  else if (propName = 'created') then result := 'dateTime'
  else if (propName = 'provider') then result := 'Reference'
  else if (propName = 'payment') then result := 'Reference'
  else if (propName = 'paymentDate') then result := 'date'
  else if (propName = 'payee') then result := 'Reference'
  else if (propName = 'recipient') then result := 'Reference'
  else if (propName = 'amount') then result := 'Money'
  else if (propName = 'paymentStatus') then result := 'CodeableConcept'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirPaymentNotice.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'identifier') then deletePropertyValue('identifier', IdentifierList, value)
  else if (propName = 'status') then StatusElement := nil
  else if (propName = 'request') then RequestElement := nil
  else if (propName = 'response') then ResponseElement := nil
  else if (propName = 'created') then CreatedElement := nil
  else if (propName = 'provider') then ProviderElement := nil
  else if (propName = 'payment') then PaymentElement := nil
  else if (propName = 'paymentDate') then PaymentDateElement := nil
  else if (propName = 'payee') then PayeeElement := nil
  else if (propName = 'recipient') then RecipientElement := nil
  else if (propName = 'amount') then AmountElement := nil
  else if (propName = 'paymentStatus') then PaymentStatusElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirPaymentNotice.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'identifier') then replacePropertyValue('identifier', IdentifierList, existing, new)
  else if (propName = 'status') then StatusElement := asEnum(SYSTEMS_TFhirFinancialResourceStatusCodesEnum, CODES_TFhirFinancialResourceStatusCodesEnum, new)
  else if (propName = 'request') then RequestElement := new as TFhirReference
  else if (propName = 'response') then ResponseElement := new as TFhirReference
  else if (propName = 'created') then CreatedElement := asDateTime(new)
  else if (propName = 'provider') then ProviderElement := new as TFhirReference
  else if (propName = 'payment') then PaymentElement := new as TFhirReference
  else if (propName = 'paymentDate') then PaymentDateElement := asDate(new)
  else if (propName = 'payee') then PayeeElement := new as TFhirReference
  else if (propName = 'recipient') then RecipientElement := new as TFhirReference
  else if (propName = 'amount') then AmountElement := new as TFhirMoney
  else if (propName = 'paymentStatus') then PaymentStatusElement := new as TFhirCodeableConcept
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirPaymentNotice.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'identifier') then IdentifierList.move(source, destination)
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirPaymentNotice.fhirType : string;
begin
  result := 'PaymentNotice';
end;

function TFhirPaymentNotice.Link : TFhirPaymentNotice;
begin
  result := TFhirPaymentNotice(inherited Link);
end;

function TFhirPaymentNotice.Clone : TFhirPaymentNotice;
begin
  result := TFhirPaymentNotice(inherited Clone);
end;

function TFhirPaymentNotice.equals(other : TObject) : boolean; 
var
  o : TFhirPaymentNotice;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirPaymentNotice)) then
    result := false
  else
  begin
    o := TFhirPaymentNotice(other);
    result := compareDeep(identifierList, o.identifierList, true) and compareDeep(statusElement, o.statusElement, true) and 
      compareDeep(requestElement, o.requestElement, true) and compareDeep(responseElement, o.responseElement, true) and 
      compareDeep(createdElement, o.createdElement, true) and compareDeep(providerElement, o.providerElement, true) and 
      compareDeep(paymentElement, o.paymentElement, true) and compareDeep(paymentDateElement, o.paymentDateElement, true) and 
      compareDeep(payeeElement, o.payeeElement, true) and compareDeep(recipientElement, o.recipientElement, true) and 
      compareDeep(amountElement, o.amountElement, true) and compareDeep(paymentStatusElement, o.paymentStatusElement, true);
  end;
end;

function TFhirPaymentNotice.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FidentifierList) and isEmptyProp(FStatus) and isEmptyProp(FRequest) and isEmptyProp(FResponse) and isEmptyProp(FCreated) and isEmptyProp(FProvider) and isEmptyProp(FPayment) and isEmptyProp(FPaymentDate) and isEmptyProp(FPayee) and isEmptyProp(FRecipient) and isEmptyProp(FAmount) and isEmptyProp(FPaymentStatus);
end;

procedure TFhirPaymentNotice.listFieldsInOrder(fields : TStringList);
begin
  inherited listFieldsInOrder(fields);
  fields.add('identifier');
  fields.add('status');
  fields.add('request');
  fields.add('response');
  fields.add('created');
  fields.add('provider');
  fields.add('payment');
  fields.add('paymentDate');
  fields.add('payee');
  fields.add('recipient');
  fields.add('amount');
  fields.add('paymentStatus');
end;

function TFhirPaymentNotice.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FIdentifierList.sizeInBytes(magic));
end;

function TFhirPaymentNotice.GetIdentifierList : TFhirIdentifierList;
begin
  if FIdentifierList = nil then
    FIdentifierList := TFhirIdentifierList.Create;
  result := FIdentifierList;
end;

function TFhirPaymentNotice.GetHasIdentifierList : boolean;
begin
  result := (FIdentifierList <> nil) and (FIdentifierList.count > 0);
end;

procedure TFhirPaymentNotice.SetStatus(value : TFhirEnum);
begin
  FStatus.free;
  FStatus := value;
end;

function TFhirPaymentNotice.GetStatusST : TFhirFinancialResourceStatusCodesEnum;
begin
  if FStatus = nil then
    result := TFhirFinancialResourceStatusCodesEnum(0)
  else
    result := TFhirFinancialResourceStatusCodesEnum(StringArrayIndexOfSensitive(CODES_TFhirFinancialResourceStatusCodesEnum, FStatus.value));
end;

procedure TFhirPaymentNotice.SetStatusST(value : TFhirFinancialResourceStatusCodesEnum);
begin
  if ord(value) = 0 then
    StatusElement := nil
  else
    StatusElement := TFhirEnum.create(SYSTEMS_TFhirFinancialResourceStatusCodesEnum[value], CODES_TFhirFinancialResourceStatusCodesEnum[value]);
end;

procedure TFhirPaymentNotice.SetRequest(value : TFhirReference);
begin
  FRequest.free;
  FRequest := value;
end;

procedure TFhirPaymentNotice.SetResponse(value : TFhirReference);
begin
  FResponse.free;
  FResponse := value;
end;

procedure TFhirPaymentNotice.SetCreated(value : TFhirDateTime);
begin
  FCreated.free;
  FCreated := value;
end;

function TFhirPaymentNotice.GetCreatedST : TFslDateTime;
begin
  if FCreated = nil then
    result := TFslDateTime.makeNull
  else
    result := FCreated.value;
end;

procedure TFhirPaymentNotice.SetCreatedST(value : TFslDateTime);
begin
  if FCreated = nil then
    FCreated := TFhirDateTime.create;
  FCreated.value := value
end;

procedure TFhirPaymentNotice.SetProvider(value : TFhirReference);
begin
  FProvider.free;
  FProvider := value;
end;

procedure TFhirPaymentNotice.SetPayment(value : TFhirReference);
begin
  FPayment.free;
  FPayment := value;
end;

procedure TFhirPaymentNotice.SetPaymentDate(value : TFhirDate);
begin
  FPaymentDate.free;
  FPaymentDate := value;
end;

function TFhirPaymentNotice.GetPaymentDateST : TFslDateTime;
begin
  if FPaymentDate = nil then
    result := TFslDateTime.makeNull
  else
    result := FPaymentDate.value;
end;

procedure TFhirPaymentNotice.SetPaymentDateST(value : TFslDateTime);
begin
  if FPaymentDate = nil then
    FPaymentDate := TFhirDate.create;
  FPaymentDate.value := value
end;

procedure TFhirPaymentNotice.SetPayee(value : TFhirReference);
begin
  FPayee.free;
  FPayee := value;
end;

procedure TFhirPaymentNotice.SetRecipient(value : TFhirReference);
begin
  FRecipient.free;
  FRecipient := value;
end;

procedure TFhirPaymentNotice.SetAmount(value : TFhirMoney);
begin
  FAmount.free;
  FAmount := value;
end;

procedure TFhirPaymentNotice.SetPaymentStatus(value : TFhirCodeableConcept);
begin
  FPaymentStatus.free;
  FPaymentStatus := value;
end;

{ TFhirPaymentNoticeListEnumerator }

constructor TFhirPaymentNoticeListEnumerator.Create(list : TFhirPaymentNoticeList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirPaymentNoticeListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirPaymentNoticeListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirPaymentNoticeListEnumerator.GetCurrent : TFhirPaymentNotice;
begin
  Result := FList[FIndex];
end;

function TFhirPaymentNoticeListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirPaymentNoticeList }

procedure TFhirPaymentNoticeList.AddItem(value: TFhirPaymentNotice);
begin
  assert(value.ClassName = 'TFhirPaymentNotice', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirPaymentNotice');
  add(value);
end;

function TFhirPaymentNoticeList.Append: TFhirPaymentNotice;
begin
  result := TFhirPaymentNotice.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirPaymentNoticeList.ClearItems;
begin
  Clear;
end;

function TFhirPaymentNoticeList.GetEnumerator : TFhirPaymentNoticeListEnumerator;
begin
  result := TFhirPaymentNoticeListEnumerator.Create(self.link);
end;

function TFhirPaymentNoticeList.Clone: TFhirPaymentNoticeList;
begin
  result := TFhirPaymentNoticeList(inherited Clone);
end;

function TFhirPaymentNoticeList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirPaymentNoticeList.GetItemN(index: Integer): TFhirPaymentNotice;
begin
  result := TFhirPaymentNotice(ObjectByIndex[index]);
end;

function TFhirPaymentNoticeList.ItemClass: TFslObjectClass;
begin
  result := TFhirPaymentNotice;
end;
function TFhirPaymentNoticeList.IndexOf(value: TFhirPaymentNotice): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirPaymentNoticeList.Insert(index: Integer): TFhirPaymentNotice;
begin
  result := TFhirPaymentNotice.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirPaymentNoticeList.InsertItem(index: Integer; value: TFhirPaymentNotice);
begin
  assert(value is TFhirPaymentNotice);
  Inherited Insert(index, value);
end;

function TFhirPaymentNoticeList.Item(index: Integer): TFhirPaymentNotice;
begin
  result := TFhirPaymentNotice(ObjectByIndex[index]);
end;

function TFhirPaymentNoticeList.Link: TFhirPaymentNoticeList;
begin
  result := TFhirPaymentNoticeList(inherited Link);
end;

procedure TFhirPaymentNoticeList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirPaymentNoticeList.SetItemByIndex(index: Integer; value: TFhirPaymentNotice);
begin
  assert(value is TFhirPaymentNotice);
  FhirPaymentNotices[index] := value;
end;

procedure TFhirPaymentNoticeList.SetItemN(index: Integer; value: TFhirPaymentNotice);
begin
  assert(value is TFhirPaymentNotice);
  ObjectByIndex[index] := value;
end;

{$ENDIF FHIR_PAYMENTNOTICE}
{$IFDEF FHIR_PAYMENTRECONCILIATION}
{ TFhirPaymentReconciliationDetail }

constructor TFhirPaymentReconciliationDetail.Create;
begin
  inherited;
end;

destructor TFhirPaymentReconciliationDetail.Destroy;
begin
  FIdentifier.free;
  FPredecessor.free;
  FType_.free;
  FRequest.free;
  FSubmitter.free;
  FResponse.free;
  FDate.free;
  FResponsible.free;
  FPayee.free;
  FAmount.free;
  inherited;
end;

procedure TFhirPaymentReconciliationDetail.Assign(oSource : TFslObject);
begin
  inherited;
  identifier := TFhirPaymentReconciliationDetail(oSource).identifier.Clone;
  predecessor := TFhirPaymentReconciliationDetail(oSource).predecessor.Clone;
  type_ := TFhirPaymentReconciliationDetail(oSource).type_.Clone;
  request := TFhirPaymentReconciliationDetail(oSource).request.Clone;
  submitter := TFhirPaymentReconciliationDetail(oSource).submitter.Clone;
  response := TFhirPaymentReconciliationDetail(oSource).response.Clone;
  dateElement := TFhirPaymentReconciliationDetail(oSource).dateElement.Clone;
  responsible := TFhirPaymentReconciliationDetail(oSource).responsible.Clone;
  payee := TFhirPaymentReconciliationDetail(oSource).payee.Clone;
  amount := TFhirPaymentReconciliationDetail(oSource).amount.Clone;
end;

procedure TFhirPaymentReconciliationDetail.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'identifier') Then
     list.add(self.link, 'identifier', FIdentifier.Link);
  if (child_name = 'predecessor') Then
     list.add(self.link, 'predecessor', FPredecessor.Link);
  if (child_name = 'type') Then
     list.add(self.link, 'type', FType_.Link);
  if (child_name = 'request') Then
     list.add(self.link, 'request', FRequest.Link);
  if (child_name = 'submitter') Then
     list.add(self.link, 'submitter', FSubmitter.Link);
  if (child_name = 'response') Then
     list.add(self.link, 'response', FResponse.Link);
  if (child_name = 'date') Then
     list.add(self.link, 'date', FDate.Link);
  if (child_name = 'responsible') Then
     list.add(self.link, 'responsible', FResponsible.Link);
  if (child_name = 'payee') Then
     list.add(self.link, 'payee', FPayee.Link);
  if (child_name = 'amount') Then
     list.add(self.link, 'amount', FAmount.Link);
end;

procedure TFhirPaymentReconciliationDetail.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'identifier', 'Identifier', false, TFhirIdentifier, FIdentifier.Link));
  oList.add(TFHIRProperty.create(self, 'predecessor', 'Identifier', false, TFhirIdentifier, FPredecessor.Link));
  oList.add(TFHIRProperty.create(self, 'type', 'CodeableConcept', false, TFhirCodeableConcept, FType_.Link));
  oList.add(TFHIRProperty.create(self, 'request', 'Reference', false, TFhirReference, FRequest.Link));
  oList.add(TFHIRProperty.create(self, 'submitter', 'Reference', false, TFhirReference, FSubmitter.Link));
  oList.add(TFHIRProperty.create(self, 'response', 'Reference', false, TFhirReference, FResponse.Link));
  oList.add(TFHIRProperty.create(self, 'date', 'date', false, TFhirDate, FDate.Link));
  oList.add(TFHIRProperty.create(self, 'responsible', 'Reference', false, TFhirReference, FResponsible.Link));
  oList.add(TFHIRProperty.create(self, 'payee', 'Reference', false, TFhirReference, FPayee.Link));
  oList.add(TFHIRProperty.create(self, 'amount', 'Money', false, TFhirMoney, FAmount.Link));
end;

function TFhirPaymentReconciliationDetail.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'identifier') then
  begin
    Identifier := propValue as TFhirIdentifier;
    result := propValue;
  end
  else if (propName = 'predecessor') then
  begin
    Predecessor := propValue as TFhirIdentifier;
    result := propValue;
  end
  else if (propName = 'type') then
  begin
    Type_ := propValue as TFhirCodeableConcept;
    result := propValue;
  end
  else if (propName = 'request') then
  begin
    Request := propValue as TFhirReference;
    result := propValue;
  end
  else if (propName = 'submitter') then
  begin
    Submitter := propValue as TFhirReference;
    result := propValue;
  end
  else if (propName = 'response') then
  begin
    Response := propValue as TFhirReference;
    result := propValue;
  end
  else if (propName = 'date') then
  begin
    DateElement := asDate(propValue);
    result := propValue;
  end
  else if (propName = 'responsible') then
  begin
    Responsible := propValue as TFhirReference;
    result := propValue;
  end
  else if (propName = 'payee') then
  begin
    Payee := propValue as TFhirReference;
    result := propValue;
  end
  else if (propName = 'amount') then
  begin
    Amount := propValue as TFhirMoney;
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirPaymentReconciliationDetail.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirPaymentReconciliationDetail.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'identifier') then result := TFhirIdentifier.create()
  else if (propName = 'predecessor') then result := TFhirIdentifier.create()
  else if (propName = 'type') then result := TFhirCodeableConcept.create()
  else if (propName = 'request') then result := TFhirReference.create()
  else if (propName = 'submitter') then result := TFhirReference.create()
  else if (propName = 'response') then result := TFhirReference.create()
  else if (propName = 'date') then result := TFhirDate.create()
  else if (propName = 'responsible') then result := TFhirReference.create()
  else if (propName = 'payee') then result := TFhirReference.create()
  else if (propName = 'amount') then result := TFhirMoney.create()
  else result := inherited createPropertyValue(propName);
end;

function TFhirPaymentReconciliationDetail.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'identifier') then result := 'Identifier'
  else if (propName = 'predecessor') then result := 'Identifier'
  else if (propName = 'type') then result := 'CodeableConcept'
  else if (propName = 'request') then result := 'Reference'
  else if (propName = 'submitter') then result := 'Reference'
  else if (propName = 'response') then result := 'Reference'
  else if (propName = 'date') then result := 'date'
  else if (propName = 'responsible') then result := 'Reference'
  else if (propName = 'payee') then result := 'Reference'
  else if (propName = 'amount') then result := 'Money'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirPaymentReconciliationDetail.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'identifier') then IdentifierElement := nil
  else if (propName = 'predecessor') then PredecessorElement := nil
  else if (propName = 'type') then Type_Element := nil
  else if (propName = 'request') then RequestElement := nil
  else if (propName = 'submitter') then SubmitterElement := nil
  else if (propName = 'response') then ResponseElement := nil
  else if (propName = 'date') then DateElement := nil
  else if (propName = 'responsible') then ResponsibleElement := nil
  else if (propName = 'payee') then PayeeElement := nil
  else if (propName = 'amount') then AmountElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirPaymentReconciliationDetail.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'identifier') then IdentifierElement := new as TFhirIdentifier
  else if (propName = 'predecessor') then PredecessorElement := new as TFhirIdentifier
  else if (propName = 'type') then Type_Element := new as TFhirCodeableConcept
  else if (propName = 'request') then RequestElement := new as TFhirReference
  else if (propName = 'submitter') then SubmitterElement := new as TFhirReference
  else if (propName = 'response') then ResponseElement := new as TFhirReference
  else if (propName = 'date') then DateElement := asDate(new)
  else if (propName = 'responsible') then ResponsibleElement := new as TFhirReference
  else if (propName = 'payee') then PayeeElement := new as TFhirReference
  else if (propName = 'amount') then AmountElement := new as TFhirMoney
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirPaymentReconciliationDetail.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirPaymentReconciliationDetail.fhirType : string;
begin
  result := 'PaymentReconciliation.detail';
end;

function TFhirPaymentReconciliationDetail.Link : TFhirPaymentReconciliationDetail;
begin
  result := TFhirPaymentReconciliationDetail(inherited Link);
end;

function TFhirPaymentReconciliationDetail.Clone : TFhirPaymentReconciliationDetail;
begin
  result := TFhirPaymentReconciliationDetail(inherited Clone);
end;

function TFhirPaymentReconciliationDetail.equals(other : TObject) : boolean; 
var
  o : TFhirPaymentReconciliationDetail;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirPaymentReconciliationDetail)) then
    result := false
  else
  begin
    o := TFhirPaymentReconciliationDetail(other);
    result := compareDeep(identifierElement, o.identifierElement, true) and compareDeep(predecessorElement, o.predecessorElement, true) and 
      compareDeep(type_Element, o.type_Element, true) and compareDeep(requestElement, o.requestElement, true) and 
      compareDeep(submitterElement, o.submitterElement, true) and compareDeep(responseElement, o.responseElement, true) and 
      compareDeep(dateElement, o.dateElement, true) and compareDeep(responsibleElement, o.responsibleElement, true) and 
      compareDeep(payeeElement, o.payeeElement, true) and compareDeep(amountElement, o.amountElement, true);
  end;
end;

function TFhirPaymentReconciliationDetail.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FIdentifier) and isEmptyProp(FPredecessor) and isEmptyProp(FType_) and isEmptyProp(FRequest) and isEmptyProp(FSubmitter) and isEmptyProp(FResponse) and isEmptyProp(FDate) and isEmptyProp(FResponsible) and isEmptyProp(FPayee) and isEmptyProp(FAmount);
end;

procedure TFhirPaymentReconciliationDetail.listFieldsInOrder(fields : TStringList);
begin
  inherited listFieldsInOrder(fields);
  fields.add('identifier');
  fields.add('predecessor');
  fields.add('type');
  fields.add('request');
  fields.add('submitter');
  fields.add('response');
  fields.add('date');
  fields.add('responsible');
  fields.add('payee');
  fields.add('amount');
end;

function TFhirPaymentReconciliationDetail.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
end;

procedure TFhirPaymentReconciliationDetail.SetIdentifier(value : TFhirIdentifier);
begin
  FIdentifier.free;
  FIdentifier := value;
end;

procedure TFhirPaymentReconciliationDetail.SetPredecessor(value : TFhirIdentifier);
begin
  FPredecessor.free;
  FPredecessor := value;
end;

procedure TFhirPaymentReconciliationDetail.SetType_(value : TFhirCodeableConcept);
begin
  FType_.free;
  FType_ := value;
end;

procedure TFhirPaymentReconciliationDetail.SetRequest(value : TFhirReference);
begin
  FRequest.free;
  FRequest := value;
end;

procedure TFhirPaymentReconciliationDetail.SetSubmitter(value : TFhirReference);
begin
  FSubmitter.free;
  FSubmitter := value;
end;

procedure TFhirPaymentReconciliationDetail.SetResponse(value : TFhirReference);
begin
  FResponse.free;
  FResponse := value;
end;

procedure TFhirPaymentReconciliationDetail.SetDate(value : TFhirDate);
begin
  FDate.free;
  FDate := value;
end;

function TFhirPaymentReconciliationDetail.GetDateST : TFslDateTime;
begin
  if FDate = nil then
    result := TFslDateTime.makeNull
  else
    result := FDate.value;
end;

procedure TFhirPaymentReconciliationDetail.SetDateST(value : TFslDateTime);
begin
  if FDate = nil then
    FDate := TFhirDate.create;
  FDate.value := value
end;

procedure TFhirPaymentReconciliationDetail.SetResponsible(value : TFhirReference);
begin
  FResponsible.free;
  FResponsible := value;
end;

procedure TFhirPaymentReconciliationDetail.SetPayee(value : TFhirReference);
begin
  FPayee.free;
  FPayee := value;
end;

procedure TFhirPaymentReconciliationDetail.SetAmount(value : TFhirMoney);
begin
  FAmount.free;
  FAmount := value;
end;

{ TFhirPaymentReconciliationDetailListEnumerator }

constructor TFhirPaymentReconciliationDetailListEnumerator.Create(list : TFhirPaymentReconciliationDetailList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirPaymentReconciliationDetailListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirPaymentReconciliationDetailListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirPaymentReconciliationDetailListEnumerator.GetCurrent : TFhirPaymentReconciliationDetail;
begin
  Result := FList[FIndex];
end;

function TFhirPaymentReconciliationDetailListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirPaymentReconciliationDetailList }

procedure TFhirPaymentReconciliationDetailList.AddItem(value: TFhirPaymentReconciliationDetail);
begin
  assert(value.ClassName = 'TFhirPaymentReconciliationDetail', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirPaymentReconciliationDetail');
  add(value);
end;

function TFhirPaymentReconciliationDetailList.Append: TFhirPaymentReconciliationDetail;
begin
  result := TFhirPaymentReconciliationDetail.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirPaymentReconciliationDetailList.ClearItems;
begin
  Clear;
end;

function TFhirPaymentReconciliationDetailList.GetEnumerator : TFhirPaymentReconciliationDetailListEnumerator;
begin
  result := TFhirPaymentReconciliationDetailListEnumerator.Create(self.link);
end;

function TFhirPaymentReconciliationDetailList.Clone: TFhirPaymentReconciliationDetailList;
begin
  result := TFhirPaymentReconciliationDetailList(inherited Clone);
end;

function TFhirPaymentReconciliationDetailList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirPaymentReconciliationDetailList.GetItemN(index: Integer): TFhirPaymentReconciliationDetail;
begin
  result := TFhirPaymentReconciliationDetail(ObjectByIndex[index]);
end;

function TFhirPaymentReconciliationDetailList.ItemClass: TFslObjectClass;
begin
  result := TFhirPaymentReconciliationDetail;
end;
function TFhirPaymentReconciliationDetailList.IndexOf(value: TFhirPaymentReconciliationDetail): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirPaymentReconciliationDetailList.Insert(index: Integer): TFhirPaymentReconciliationDetail;
begin
  result := TFhirPaymentReconciliationDetail.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirPaymentReconciliationDetailList.InsertItem(index: Integer; value: TFhirPaymentReconciliationDetail);
begin
  assert(value is TFhirPaymentReconciliationDetail);
  Inherited Insert(index, value);
end;

function TFhirPaymentReconciliationDetailList.Item(index: Integer): TFhirPaymentReconciliationDetail;
begin
  result := TFhirPaymentReconciliationDetail(ObjectByIndex[index]);
end;

function TFhirPaymentReconciliationDetailList.Link: TFhirPaymentReconciliationDetailList;
begin
  result := TFhirPaymentReconciliationDetailList(inherited Link);
end;

procedure TFhirPaymentReconciliationDetailList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirPaymentReconciliationDetailList.SetItemByIndex(index: Integer; value: TFhirPaymentReconciliationDetail);
begin
  assert(value is TFhirPaymentReconciliationDetail);
  FhirPaymentReconciliationDetails[index] := value;
end;

procedure TFhirPaymentReconciliationDetailList.SetItemN(index: Integer; value: TFhirPaymentReconciliationDetail);
begin
  assert(value is TFhirPaymentReconciliationDetail);
  ObjectByIndex[index] := value;
end;

{ TFhirPaymentReconciliationProcessNote }

constructor TFhirPaymentReconciliationProcessNote.Create;
begin
  inherited;
end;

destructor TFhirPaymentReconciliationProcessNote.Destroy;
begin
  FType_.free;
  FText.free;
  inherited;
end;

procedure TFhirPaymentReconciliationProcessNote.Assign(oSource : TFslObject);
begin
  inherited;
  type_Element := TFhirPaymentReconciliationProcessNote(oSource).type_Element.Clone;
  textElement := TFhirPaymentReconciliationProcessNote(oSource).textElement.Clone;
end;

procedure TFhirPaymentReconciliationProcessNote.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'type') Then
     list.add(self.link, 'type', FType_.Link);
  if (child_name = 'text') Then
     list.add(self.link, 'text', FText.Link);
end;

procedure TFhirPaymentReconciliationProcessNote.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'type', 'code', false, TFhirEnum, FType_.Link));
  oList.add(TFHIRProperty.create(self, 'text', 'string', false, TFhirString, FText.Link));
end;

function TFhirPaymentReconciliationProcessNote.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'type') then
  begin
    Type_Element := asEnum(SYSTEMS_TFhirNoteTypeEnum, CODES_TFhirNoteTypeEnum, propValue);
    result := propValue;
  end
  else if (propName = 'text') then
  begin
    TextElement := asString(propValue);
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirPaymentReconciliationProcessNote.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirPaymentReconciliationProcessNote.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'type') then result := TFhirEnum.create(SYSTEMS_TFhirNoteTypeEnum[NoteTypeNull], CODES_TFhirNoteTypeEnum[NoteTypeNull]) 
  else if (propName = 'text') then result := TFhirString.create()
  else result := inherited createPropertyValue(propName);
end;

function TFhirPaymentReconciliationProcessNote.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'type') then result := 'code'
  else if (propName = 'text') then result := 'string'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirPaymentReconciliationProcessNote.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'type') then Type_Element := nil
  else if (propName = 'text') then TextElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirPaymentReconciliationProcessNote.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'type') then Type_Element := asEnum(SYSTEMS_TFhirNoteTypeEnum, CODES_TFhirNoteTypeEnum, new)
  else if (propName = 'text') then TextElement := asString(new)
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirPaymentReconciliationProcessNote.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirPaymentReconciliationProcessNote.fhirType : string;
begin
  result := 'PaymentReconciliation.processNote';
end;

function TFhirPaymentReconciliationProcessNote.Link : TFhirPaymentReconciliationProcessNote;
begin
  result := TFhirPaymentReconciliationProcessNote(inherited Link);
end;

function TFhirPaymentReconciliationProcessNote.Clone : TFhirPaymentReconciliationProcessNote;
begin
  result := TFhirPaymentReconciliationProcessNote(inherited Clone);
end;

function TFhirPaymentReconciliationProcessNote.equals(other : TObject) : boolean; 
var
  o : TFhirPaymentReconciliationProcessNote;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirPaymentReconciliationProcessNote)) then
    result := false
  else
  begin
    o := TFhirPaymentReconciliationProcessNote(other);
    result := compareDeep(type_Element, o.type_Element, true) and compareDeep(textElement, o.textElement, true);
  end;
end;

function TFhirPaymentReconciliationProcessNote.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FType_) and isEmptyProp(FText);
end;

procedure TFhirPaymentReconciliationProcessNote.listFieldsInOrder(fields : TStringList);
begin
  inherited listFieldsInOrder(fields);
  fields.add('type');
  fields.add('text');
end;

function TFhirPaymentReconciliationProcessNote.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
end;

procedure TFhirPaymentReconciliationProcessNote.SetType_(value : TFhirEnum);
begin
  FType_.free;
  FType_ := value;
end;

function TFhirPaymentReconciliationProcessNote.GetType_ST : TFhirNoteTypeEnum;
begin
  if FType_ = nil then
    result := TFhirNoteTypeEnum(0)
  else
    result := TFhirNoteTypeEnum(StringArrayIndexOfSensitive(CODES_TFhirNoteTypeEnum, FType_.value));
end;

procedure TFhirPaymentReconciliationProcessNote.SetType_ST(value : TFhirNoteTypeEnum);
begin
  if ord(value) = 0 then
    Type_Element := nil
  else
    Type_Element := TFhirEnum.create(SYSTEMS_TFhirNoteTypeEnum[value], CODES_TFhirNoteTypeEnum[value]);
end;

procedure TFhirPaymentReconciliationProcessNote.SetText(value : TFhirString);
begin
  FText.free;
  FText := value;
end;

function TFhirPaymentReconciliationProcessNote.GetTextST : String;
begin
  if FText = nil then
    result := ''
  else
    result := FText.value;
end;

procedure TFhirPaymentReconciliationProcessNote.SetTextST(value : String);
begin
  if value <> '' then
  begin
    if FText = nil then
      FText := TFhirString.create;
    FText.value := value
  end
  else if FText <> nil then
    FText.value := '';
end;

{ TFhirPaymentReconciliationProcessNoteListEnumerator }

constructor TFhirPaymentReconciliationProcessNoteListEnumerator.Create(list : TFhirPaymentReconciliationProcessNoteList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirPaymentReconciliationProcessNoteListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirPaymentReconciliationProcessNoteListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirPaymentReconciliationProcessNoteListEnumerator.GetCurrent : TFhirPaymentReconciliationProcessNote;
begin
  Result := FList[FIndex];
end;

function TFhirPaymentReconciliationProcessNoteListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirPaymentReconciliationProcessNoteList }

procedure TFhirPaymentReconciliationProcessNoteList.AddItem(value: TFhirPaymentReconciliationProcessNote);
begin
  assert(value.ClassName = 'TFhirPaymentReconciliationProcessNote', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirPaymentReconciliationProcessNote');
  add(value);
end;

function TFhirPaymentReconciliationProcessNoteList.Append: TFhirPaymentReconciliationProcessNote;
begin
  result := TFhirPaymentReconciliationProcessNote.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirPaymentReconciliationProcessNoteList.ClearItems;
begin
  Clear;
end;

function TFhirPaymentReconciliationProcessNoteList.GetEnumerator : TFhirPaymentReconciliationProcessNoteListEnumerator;
begin
  result := TFhirPaymentReconciliationProcessNoteListEnumerator.Create(self.link);
end;

function TFhirPaymentReconciliationProcessNoteList.Clone: TFhirPaymentReconciliationProcessNoteList;
begin
  result := TFhirPaymentReconciliationProcessNoteList(inherited Clone);
end;

function TFhirPaymentReconciliationProcessNoteList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirPaymentReconciliationProcessNoteList.GetItemN(index: Integer): TFhirPaymentReconciliationProcessNote;
begin
  result := TFhirPaymentReconciliationProcessNote(ObjectByIndex[index]);
end;

function TFhirPaymentReconciliationProcessNoteList.ItemClass: TFslObjectClass;
begin
  result := TFhirPaymentReconciliationProcessNote;
end;
function TFhirPaymentReconciliationProcessNoteList.IndexOf(value: TFhirPaymentReconciliationProcessNote): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirPaymentReconciliationProcessNoteList.Insert(index: Integer): TFhirPaymentReconciliationProcessNote;
begin
  result := TFhirPaymentReconciliationProcessNote.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirPaymentReconciliationProcessNoteList.InsertItem(index: Integer; value: TFhirPaymentReconciliationProcessNote);
begin
  assert(value is TFhirPaymentReconciliationProcessNote);
  Inherited Insert(index, value);
end;

function TFhirPaymentReconciliationProcessNoteList.Item(index: Integer): TFhirPaymentReconciliationProcessNote;
begin
  result := TFhirPaymentReconciliationProcessNote(ObjectByIndex[index]);
end;

function TFhirPaymentReconciliationProcessNoteList.Link: TFhirPaymentReconciliationProcessNoteList;
begin
  result := TFhirPaymentReconciliationProcessNoteList(inherited Link);
end;

procedure TFhirPaymentReconciliationProcessNoteList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirPaymentReconciliationProcessNoteList.SetItemByIndex(index: Integer; value: TFhirPaymentReconciliationProcessNote);
begin
  assert(value is TFhirPaymentReconciliationProcessNote);
  FhirPaymentReconciliationProcessNotes[index] := value;
end;

procedure TFhirPaymentReconciliationProcessNoteList.SetItemN(index: Integer; value: TFhirPaymentReconciliationProcessNote);
begin
  assert(value is TFhirPaymentReconciliationProcessNote);
  ObjectByIndex[index] := value;
end;

{ TFhirPaymentReconciliation }

constructor TFhirPaymentReconciliation.Create;
begin
  inherited;
end;

destructor TFhirPaymentReconciliation.Destroy;
begin
  FIdentifierList.Free;
  FStatus.free;
  FPeriod.free;
  FCreated.free;
  FPaymentIssuer.free;
  FRequest.free;
  FRequestor.free;
  FOutcome.free;
  FDisposition.free;
  FPaymentDate.free;
  FPaymentAmount.free;
  FPaymentIdentifier.free;
  FDetailList.Free;
  FFormCode.free;
  FProcessNoteList.Free;
  inherited;
end;

procedure TFhirPaymentReconciliation.Assign(oSource : TFslObject);
begin
  inherited;
  if (TFhirPaymentReconciliation(oSource).FIdentifierList = nil) then
  begin
    FIdentifierList.free;
    FIdentifierList := nil;
  end
  else
  begin
    if FIdentifierList = nil then
      FIdentifierList := TFhirIdentifierList.Create;
    FIdentifierList.Assign(TFhirPaymentReconciliation(oSource).FIdentifierList);
  end;
  statusElement := TFhirPaymentReconciliation(oSource).statusElement.Clone;
  period := TFhirPaymentReconciliation(oSource).period.Clone;
  createdElement := TFhirPaymentReconciliation(oSource).createdElement.Clone;
  paymentIssuer := TFhirPaymentReconciliation(oSource).paymentIssuer.Clone;
  request := TFhirPaymentReconciliation(oSource).request.Clone;
  requestor := TFhirPaymentReconciliation(oSource).requestor.Clone;
  outcomeElement := TFhirPaymentReconciliation(oSource).outcomeElement.Clone;
  dispositionElement := TFhirPaymentReconciliation(oSource).dispositionElement.Clone;
  paymentDateElement := TFhirPaymentReconciliation(oSource).paymentDateElement.Clone;
  paymentAmount := TFhirPaymentReconciliation(oSource).paymentAmount.Clone;
  paymentIdentifier := TFhirPaymentReconciliation(oSource).paymentIdentifier.Clone;
  if (TFhirPaymentReconciliation(oSource).FDetailList = nil) then
  begin
    FDetailList.free;
    FDetailList := nil;
  end
  else
  begin
    if FDetailList = nil then
      FDetailList := TFhirPaymentReconciliationDetailList.Create;
    FDetailList.Assign(TFhirPaymentReconciliation(oSource).FDetailList);
  end;
  formCode := TFhirPaymentReconciliation(oSource).formCode.Clone;
  if (TFhirPaymentReconciliation(oSource).FProcessNoteList = nil) then
  begin
    FProcessNoteList.free;
    FProcessNoteList := nil;
  end
  else
  begin
    if FProcessNoteList = nil then
      FProcessNoteList := TFhirPaymentReconciliationProcessNoteList.Create;
    FProcessNoteList.Assign(TFhirPaymentReconciliation(oSource).FProcessNoteList);
  end;
end;

function TFhirPaymentReconciliation.GetResourceType : TFhirResourceType;
begin
  result := frtPaymentReconciliation;
end;

procedure TFhirPaymentReconciliation.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'identifier') Then
    list.addAll(self, 'identifier', FIdentifierList);
  if (child_name = 'status') Then
     list.add(self.link, 'status', FStatus.Link);
  if (child_name = 'period') Then
     list.add(self.link, 'period', FPeriod.Link);
  if (child_name = 'created') Then
     list.add(self.link, 'created', FCreated.Link);
  if (child_name = 'paymentIssuer') Then
     list.add(self.link, 'paymentIssuer', FPaymentIssuer.Link);
  if (child_name = 'request') Then
     list.add(self.link, 'request', FRequest.Link);
  if (child_name = 'requestor') Then
     list.add(self.link, 'requestor', FRequestor.Link);
  if (child_name = 'outcome') Then
     list.add(self.link, 'outcome', FOutcome.Link);
  if (child_name = 'disposition') Then
     list.add(self.link, 'disposition', FDisposition.Link);
  if (child_name = 'paymentDate') Then
     list.add(self.link, 'paymentDate', FPaymentDate.Link);
  if (child_name = 'paymentAmount') Then
     list.add(self.link, 'paymentAmount', FPaymentAmount.Link);
  if (child_name = 'paymentIdentifier') Then
     list.add(self.link, 'paymentIdentifier', FPaymentIdentifier.Link);
  if (child_name = 'detail') Then
    list.addAll(self, 'detail', FDetailList);
  if (child_name = 'formCode') Then
     list.add(self.link, 'formCode', FFormCode.Link);
  if (child_name = 'processNote') Then
    list.addAll(self, 'processNote', FProcessNoteList);
end;

procedure TFhirPaymentReconciliation.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'identifier', 'Identifier', true, TFhirIdentifier, FIdentifierList.Link));
  oList.add(TFHIRProperty.create(self, 'status', 'code', false, TFhirEnum, FStatus.Link));
  oList.add(TFHIRProperty.create(self, 'period', 'Period', false, TFhirPeriod, FPeriod.Link));
  oList.add(TFHIRProperty.create(self, 'created', 'dateTime', false, TFhirDateTime, FCreated.Link));
  oList.add(TFHIRProperty.create(self, 'paymentIssuer', 'Reference', false, TFhirReference, FPaymentIssuer.Link));
  oList.add(TFHIRProperty.create(self, 'request', 'Reference', false, TFhirReference, FRequest.Link));
  oList.add(TFHIRProperty.create(self, 'requestor', 'Reference', false, TFhirReference, FRequestor.Link));
  oList.add(TFHIRProperty.create(self, 'outcome', 'code', false, TFhirEnum, FOutcome.Link));
  oList.add(TFHIRProperty.create(self, 'disposition', 'string', false, TFhirString, FDisposition.Link));
  oList.add(TFHIRProperty.create(self, 'paymentDate', 'date', false, TFhirDate, FPaymentDate.Link));
  oList.add(TFHIRProperty.create(self, 'paymentAmount', 'Money', false, TFhirMoney, FPaymentAmount.Link));
  oList.add(TFHIRProperty.create(self, 'paymentIdentifier', 'Identifier', false, TFhirIdentifier, FPaymentIdentifier.Link));
  oList.add(TFHIRProperty.create(self, 'detail', 'BackboneElement', true, TFhirPaymentReconciliationDetail, FDetailList.Link));
  oList.add(TFHIRProperty.create(self, 'formCode', 'CodeableConcept', false, TFhirCodeableConcept, FFormCode.Link));
  oList.add(TFHIRProperty.create(self, 'processNote', 'BackboneElement', true, TFhirPaymentReconciliationProcessNote, FProcessNoteList.Link));
end;

function TFhirPaymentReconciliation.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'identifier') then
  begin
    IdentifierList.add(propValue as TFhirIdentifier);
    result := propValue;
  end
  else if (propName = 'status') then
  begin
    StatusElement := asEnum(SYSTEMS_TFhirFinancialResourceStatusCodesEnum, CODES_TFhirFinancialResourceStatusCodesEnum, propValue);
    result := propValue;
  end
  else if (propName = 'period') then
  begin
    Period := propValue as TFhirPeriod;
    result := propValue;
  end
  else if (propName = 'created') then
  begin
    CreatedElement := asDateTime(propValue);
    result := propValue;
  end
  else if (propName = 'paymentIssuer') then
  begin
    PaymentIssuer := propValue as TFhirReference;
    result := propValue;
  end
  else if (propName = 'request') then
  begin
    Request := propValue as TFhirReference;
    result := propValue;
  end
  else if (propName = 'requestor') then
  begin
    Requestor := propValue as TFhirReference;
    result := propValue;
  end
  else if (propName = 'outcome') then
  begin
    OutcomeElement := asEnum(SYSTEMS_TFhirPaymentOutcomeEnum, CODES_TFhirPaymentOutcomeEnum, propValue);
    result := propValue;
  end
  else if (propName = 'disposition') then
  begin
    DispositionElement := asString(propValue);
    result := propValue;
  end
  else if (propName = 'paymentDate') then
  begin
    PaymentDateElement := asDate(propValue);
    result := propValue;
  end
  else if (propName = 'paymentAmount') then
  begin
    PaymentAmount := propValue as TFhirMoney;
    result := propValue;
  end
  else if (propName = 'paymentIdentifier') then
  begin
    PaymentIdentifier := propValue as TFhirIdentifier;
    result := propValue;
  end
  else if (propName = 'detail') then
  begin
    DetailList.add(propValue as TFhirPaymentReconciliationDetail);
    result := propValue;
  end
  else if (propName = 'formCode') then
  begin
    FormCode := propValue as TFhirCodeableConcept;
    result := propValue;
  end
  else if (propName = 'processNote') then
  begin
    ProcessNoteList.add(propValue as TFhirPaymentReconciliationProcessNote);
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirPaymentReconciliation.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'identifier') then IdentifierList.insertItem(index, propValue as TFhirIdentifier)
  else if (propName = 'detail') then DetailList.insertItem(index, propValue as TFhirPaymentReconciliationDetail)
  else if (propName = 'processNote') then ProcessNoteList.insertItem(index, propValue as TFhirPaymentReconciliationProcessNote)
  else inherited;
end;

function TFhirPaymentReconciliation.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'identifier') then result := IdentifierList.new()
  else if (propName = 'status') then result := TFhirEnum.create(SYSTEMS_TFhirFinancialResourceStatusCodesEnum[FinancialResourceStatusCodesNull], CODES_TFhirFinancialResourceStatusCodesEnum[FinancialResourceStatusCodesNull]) 
  else if (propName = 'period') then result := TFhirPeriod.create()
  else if (propName = 'created') then result := TFhirDateTime.create()
  else if (propName = 'paymentIssuer') then result := TFhirReference.create()
  else if (propName = 'request') then result := TFhirReference.create()
  else if (propName = 'requestor') then result := TFhirReference.create()
  else if (propName = 'outcome') then result := TFhirEnum.create(SYSTEMS_TFhirPaymentOutcomeEnum[PaymentOutcomeNull], CODES_TFhirPaymentOutcomeEnum[PaymentOutcomeNull]) 
  else if (propName = 'disposition') then result := TFhirString.create()
  else if (propName = 'paymentDate') then result := TFhirDate.create()
  else if (propName = 'paymentAmount') then result := TFhirMoney.create()
  else if (propName = 'paymentIdentifier') then result := TFhirIdentifier.create()
  else if (propName = 'detail') then result := DetailList.new()
  else if (propName = 'formCode') then result := TFhirCodeableConcept.create()
  else if (propName = 'processNote') then result := ProcessNoteList.new()
  else result := inherited createPropertyValue(propName);
end;

function TFhirPaymentReconciliation.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'identifier') then result := 'Identifier'
  else if (propName = 'status') then result := 'code'
  else if (propName = 'period') then result := 'Period'
  else if (propName = 'created') then result := 'dateTime'
  else if (propName = 'paymentIssuer') then result := 'Reference'
  else if (propName = 'request') then result := 'Reference'
  else if (propName = 'requestor') then result := 'Reference'
  else if (propName = 'outcome') then result := 'code'
  else if (propName = 'disposition') then result := 'string'
  else if (propName = 'paymentDate') then result := 'date'
  else if (propName = 'paymentAmount') then result := 'Money'
  else if (propName = 'paymentIdentifier') then result := 'Identifier'
  else if (propName = 'detail') then result := 'BackboneElement'
  else if (propName = 'formCode') then result := 'CodeableConcept'
  else if (propName = 'processNote') then result := 'BackboneElement'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirPaymentReconciliation.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'identifier') then deletePropertyValue('identifier', IdentifierList, value)
  else if (propName = 'status') then StatusElement := nil
  else if (propName = 'period') then PeriodElement := nil
  else if (propName = 'created') then CreatedElement := nil
  else if (propName = 'paymentIssuer') then PaymentIssuerElement := nil
  else if (propName = 'request') then RequestElement := nil
  else if (propName = 'requestor') then RequestorElement := nil
  else if (propName = 'outcome') then OutcomeElement := nil
  else if (propName = 'disposition') then DispositionElement := nil
  else if (propName = 'paymentDate') then PaymentDateElement := nil
  else if (propName = 'paymentAmount') then PaymentAmountElement := nil
  else if (propName = 'paymentIdentifier') then PaymentIdentifierElement := nil
  else if (propName = 'detail') then deletePropertyValue('detail', DetailList, value)
  else if (propName = 'formCode') then FormCodeElement := nil
  else if (propName = 'processNote') then deletePropertyValue('processNote', ProcessNoteList, value)
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirPaymentReconciliation.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'identifier') then replacePropertyValue('identifier', IdentifierList, existing, new)
  else if (propName = 'status') then StatusElement := asEnum(SYSTEMS_TFhirFinancialResourceStatusCodesEnum, CODES_TFhirFinancialResourceStatusCodesEnum, new)
  else if (propName = 'period') then PeriodElement := new as TFhirPeriod
  else if (propName = 'created') then CreatedElement := asDateTime(new)
  else if (propName = 'paymentIssuer') then PaymentIssuerElement := new as TFhirReference
  else if (propName = 'request') then RequestElement := new as TFhirReference
  else if (propName = 'requestor') then RequestorElement := new as TFhirReference
  else if (propName = 'outcome') then OutcomeElement := asEnum(SYSTEMS_TFhirPaymentOutcomeEnum, CODES_TFhirPaymentOutcomeEnum, new)
  else if (propName = 'disposition') then DispositionElement := asString(new)
  else if (propName = 'paymentDate') then PaymentDateElement := asDate(new)
  else if (propName = 'paymentAmount') then PaymentAmountElement := new as TFhirMoney
  else if (propName = 'paymentIdentifier') then PaymentIdentifierElement := new as TFhirIdentifier
  else if (propName = 'detail') then replacePropertyValue('detail', DetailList, existing, new)
  else if (propName = 'formCode') then FormCodeElement := new as TFhirCodeableConcept
  else if (propName = 'processNote') then replacePropertyValue('processNote', ProcessNoteList, existing, new)
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirPaymentReconciliation.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'identifier') then IdentifierList.move(source, destination)
  else if (propName = 'detail') then DetailList.move(source, destination)
  else if (propName = 'processNote') then ProcessNoteList.move(source, destination)
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirPaymentReconciliation.fhirType : string;
begin
  result := 'PaymentReconciliation';
end;

function TFhirPaymentReconciliation.Link : TFhirPaymentReconciliation;
begin
  result := TFhirPaymentReconciliation(inherited Link);
end;

function TFhirPaymentReconciliation.Clone : TFhirPaymentReconciliation;
begin
  result := TFhirPaymentReconciliation(inherited Clone);
end;

function TFhirPaymentReconciliation.equals(other : TObject) : boolean; 
var
  o : TFhirPaymentReconciliation;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirPaymentReconciliation)) then
    result := false
  else
  begin
    o := TFhirPaymentReconciliation(other);
    result := compareDeep(identifierList, o.identifierList, true) and compareDeep(statusElement, o.statusElement, true) and 
      compareDeep(periodElement, o.periodElement, true) and compareDeep(createdElement, o.createdElement, true) and 
      compareDeep(paymentIssuerElement, o.paymentIssuerElement, true) and compareDeep(requestElement, o.requestElement, true) and 
      compareDeep(requestorElement, o.requestorElement, true) and compareDeep(outcomeElement, o.outcomeElement, true) and 
      compareDeep(dispositionElement, o.dispositionElement, true) and compareDeep(paymentDateElement, o.paymentDateElement, true) and 
      compareDeep(paymentAmountElement, o.paymentAmountElement, true) and compareDeep(paymentIdentifierElement, o.paymentIdentifierElement, true) and 
      compareDeep(detailList, o.detailList, true) and compareDeep(formCodeElement, o.formCodeElement, true) and 
      compareDeep(processNoteList, o.processNoteList, true);
  end;
end;

function TFhirPaymentReconciliation.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FidentifierList) and isEmptyProp(FStatus) and isEmptyProp(FPeriod) and isEmptyProp(FCreated) and isEmptyProp(FPaymentIssuer) and isEmptyProp(FRequest) and isEmptyProp(FRequestor) and isEmptyProp(FOutcome) and isEmptyProp(FDisposition) and isEmptyProp(FPaymentDate) and isEmptyProp(FPaymentAmount) and isEmptyProp(FPaymentIdentifier) and isEmptyProp(FdetailList) and isEmptyProp(FFormCode) and isEmptyProp(FprocessNoteList);
end;

procedure TFhirPaymentReconciliation.listFieldsInOrder(fields : TStringList);
begin
  inherited listFieldsInOrder(fields);
  fields.add('identifier');
  fields.add('status');
  fields.add('period');
  fields.add('created');
  fields.add('paymentIssuer');
  fields.add('request');
  fields.add('requestor');
  fields.add('outcome');
  fields.add('disposition');
  fields.add('paymentDate');
  fields.add('paymentAmount');
  fields.add('paymentIdentifier');
  fields.add('detail');
  fields.add('formCode');
  fields.add('processNote');
end;

function TFhirPaymentReconciliation.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FIdentifierList.sizeInBytes(magic));
  inc(result, FDetailList.sizeInBytes(magic));
  inc(result, FProcessNoteList.sizeInBytes(magic));
end;

function TFhirPaymentReconciliation.GetIdentifierList : TFhirIdentifierList;
begin
  if FIdentifierList = nil then
    FIdentifierList := TFhirIdentifierList.Create;
  result := FIdentifierList;
end;

function TFhirPaymentReconciliation.GetHasIdentifierList : boolean;
begin
  result := (FIdentifierList <> nil) and (FIdentifierList.count > 0);
end;

procedure TFhirPaymentReconciliation.SetStatus(value : TFhirEnum);
begin
  FStatus.free;
  FStatus := value;
end;

function TFhirPaymentReconciliation.GetStatusST : TFhirFinancialResourceStatusCodesEnum;
begin
  if FStatus = nil then
    result := TFhirFinancialResourceStatusCodesEnum(0)
  else
    result := TFhirFinancialResourceStatusCodesEnum(StringArrayIndexOfSensitive(CODES_TFhirFinancialResourceStatusCodesEnum, FStatus.value));
end;

procedure TFhirPaymentReconciliation.SetStatusST(value : TFhirFinancialResourceStatusCodesEnum);
begin
  if ord(value) = 0 then
    StatusElement := nil
  else
    StatusElement := TFhirEnum.create(SYSTEMS_TFhirFinancialResourceStatusCodesEnum[value], CODES_TFhirFinancialResourceStatusCodesEnum[value]);
end;

procedure TFhirPaymentReconciliation.SetPeriod(value : TFhirPeriod);
begin
  FPeriod.free;
  FPeriod := value;
end;

procedure TFhirPaymentReconciliation.SetCreated(value : TFhirDateTime);
begin
  FCreated.free;
  FCreated := value;
end;

function TFhirPaymentReconciliation.GetCreatedST : TFslDateTime;
begin
  if FCreated = nil then
    result := TFslDateTime.makeNull
  else
    result := FCreated.value;
end;

procedure TFhirPaymentReconciliation.SetCreatedST(value : TFslDateTime);
begin
  if FCreated = nil then
    FCreated := TFhirDateTime.create;
  FCreated.value := value
end;

procedure TFhirPaymentReconciliation.SetPaymentIssuer(value : TFhirReference);
begin
  FPaymentIssuer.free;
  FPaymentIssuer := value;
end;

procedure TFhirPaymentReconciliation.SetRequest(value : TFhirReference);
begin
  FRequest.free;
  FRequest := value;
end;

procedure TFhirPaymentReconciliation.SetRequestor(value : TFhirReference);
begin
  FRequestor.free;
  FRequestor := value;
end;

procedure TFhirPaymentReconciliation.SetOutcome(value : TFhirEnum);
begin
  FOutcome.free;
  FOutcome := value;
end;

function TFhirPaymentReconciliation.GetOutcomeST : TFhirPaymentOutcomeEnum;
begin
  if FOutcome = nil then
    result := TFhirPaymentOutcomeEnum(0)
  else
    result := TFhirPaymentOutcomeEnum(StringArrayIndexOfSensitive(CODES_TFhirPaymentOutcomeEnum, FOutcome.value));
end;

procedure TFhirPaymentReconciliation.SetOutcomeST(value : TFhirPaymentOutcomeEnum);
begin
  if ord(value) = 0 then
    OutcomeElement := nil
  else
    OutcomeElement := TFhirEnum.create(SYSTEMS_TFhirPaymentOutcomeEnum[value], CODES_TFhirPaymentOutcomeEnum[value]);
end;

procedure TFhirPaymentReconciliation.SetDisposition(value : TFhirString);
begin
  FDisposition.free;
  FDisposition := value;
end;

function TFhirPaymentReconciliation.GetDispositionST : String;
begin
  if FDisposition = nil then
    result := ''
  else
    result := FDisposition.value;
end;

procedure TFhirPaymentReconciliation.SetDispositionST(value : String);
begin
  if value <> '' then
  begin
    if FDisposition = nil then
      FDisposition := TFhirString.create;
    FDisposition.value := value
  end
  else if FDisposition <> nil then
    FDisposition.value := '';
end;

procedure TFhirPaymentReconciliation.SetPaymentDate(value : TFhirDate);
begin
  FPaymentDate.free;
  FPaymentDate := value;
end;

function TFhirPaymentReconciliation.GetPaymentDateST : TFslDateTime;
begin
  if FPaymentDate = nil then
    result := TFslDateTime.makeNull
  else
    result := FPaymentDate.value;
end;

procedure TFhirPaymentReconciliation.SetPaymentDateST(value : TFslDateTime);
begin
  if FPaymentDate = nil then
    FPaymentDate := TFhirDate.create;
  FPaymentDate.value := value
end;

procedure TFhirPaymentReconciliation.SetPaymentAmount(value : TFhirMoney);
begin
  FPaymentAmount.free;
  FPaymentAmount := value;
end;

procedure TFhirPaymentReconciliation.SetPaymentIdentifier(value : TFhirIdentifier);
begin
  FPaymentIdentifier.free;
  FPaymentIdentifier := value;
end;

function TFhirPaymentReconciliation.GetDetailList : TFhirPaymentReconciliationDetailList;
begin
  if FDetailList = nil then
    FDetailList := TFhirPaymentReconciliationDetailList.Create;
  result := FDetailList;
end;

function TFhirPaymentReconciliation.GetHasDetailList : boolean;
begin
  result := (FDetailList <> nil) and (FDetailList.count > 0);
end;

procedure TFhirPaymentReconciliation.SetFormCode(value : TFhirCodeableConcept);
begin
  FFormCode.free;
  FFormCode := value;
end;

function TFhirPaymentReconciliation.GetProcessNoteList : TFhirPaymentReconciliationProcessNoteList;
begin
  if FProcessNoteList = nil then
    FProcessNoteList := TFhirPaymentReconciliationProcessNoteList.Create;
  result := FProcessNoteList;
end;

function TFhirPaymentReconciliation.GetHasProcessNoteList : boolean;
begin
  result := (FProcessNoteList <> nil) and (FProcessNoteList.count > 0);
end;

{ TFhirPaymentReconciliationListEnumerator }

constructor TFhirPaymentReconciliationListEnumerator.Create(list : TFhirPaymentReconciliationList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirPaymentReconciliationListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirPaymentReconciliationListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirPaymentReconciliationListEnumerator.GetCurrent : TFhirPaymentReconciliation;
begin
  Result := FList[FIndex];
end;

function TFhirPaymentReconciliationListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirPaymentReconciliationList }

procedure TFhirPaymentReconciliationList.AddItem(value: TFhirPaymentReconciliation);
begin
  assert(value.ClassName = 'TFhirPaymentReconciliation', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirPaymentReconciliation');
  add(value);
end;

function TFhirPaymentReconciliationList.Append: TFhirPaymentReconciliation;
begin
  result := TFhirPaymentReconciliation.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirPaymentReconciliationList.ClearItems;
begin
  Clear;
end;

function TFhirPaymentReconciliationList.GetEnumerator : TFhirPaymentReconciliationListEnumerator;
begin
  result := TFhirPaymentReconciliationListEnumerator.Create(self.link);
end;

function TFhirPaymentReconciliationList.Clone: TFhirPaymentReconciliationList;
begin
  result := TFhirPaymentReconciliationList(inherited Clone);
end;

function TFhirPaymentReconciliationList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirPaymentReconciliationList.GetItemN(index: Integer): TFhirPaymentReconciliation;
begin
  result := TFhirPaymentReconciliation(ObjectByIndex[index]);
end;

function TFhirPaymentReconciliationList.ItemClass: TFslObjectClass;
begin
  result := TFhirPaymentReconciliation;
end;
function TFhirPaymentReconciliationList.IndexOf(value: TFhirPaymentReconciliation): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirPaymentReconciliationList.Insert(index: Integer): TFhirPaymentReconciliation;
begin
  result := TFhirPaymentReconciliation.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirPaymentReconciliationList.InsertItem(index: Integer; value: TFhirPaymentReconciliation);
begin
  assert(value is TFhirPaymentReconciliation);
  Inherited Insert(index, value);
end;

function TFhirPaymentReconciliationList.Item(index: Integer): TFhirPaymentReconciliation;
begin
  result := TFhirPaymentReconciliation(ObjectByIndex[index]);
end;

function TFhirPaymentReconciliationList.Link: TFhirPaymentReconciliationList;
begin
  result := TFhirPaymentReconciliationList(inherited Link);
end;

procedure TFhirPaymentReconciliationList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirPaymentReconciliationList.SetItemByIndex(index: Integer; value: TFhirPaymentReconciliation);
begin
  assert(value is TFhirPaymentReconciliation);
  FhirPaymentReconciliations[index] := value;
end;

procedure TFhirPaymentReconciliationList.SetItemN(index: Integer; value: TFhirPaymentReconciliation);
begin
  assert(value is TFhirPaymentReconciliation);
  ObjectByIndex[index] := value;
end;

{$ENDIF FHIR_PAYMENTRECONCILIATION}


end.

