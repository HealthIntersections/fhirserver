unit fhir5_resources_admin;

{
  Copyright (c) 2011+, HL7 and Health Intersections Pty Ltd (http://www.healthintersections.com.au)
  All rights reserved.
  
  Redistribution and use in source and binary forms, with or without modification, 
  are permitted provided that the following conditions are met:
  
   * Redistributions of source code must retain the above copyright notice, this 
     list of conditions and the following disclaimer.
   * Redistributions in binary form must reproduce the above copyright notice, 
     this list of conditions and the following disclaimer in the documentation 
     and/or other materials provided with the distribution.
   * Neither the name of HL7 nor the names of its contributors may be used to 
     endorse or promote products derived from this software without specific 
     prior written permission.
  
  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND 
  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED 
  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. 
  IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, 
  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT 
  NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR 
  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, 
  WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) 
  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE 
  POSSIBILITY OF SUCH DAMAGE.
  
}

{$i fhir.inc}
{$i fhir5.inc}

interface

// Generated on Thu, Nov 10, 2022 for FHIR v5.0.0



uses
  SysUtils, Classes, 
  fsl_base, fsl_utilities, fsl_stream, 
  fhir_objects, fhir_utilities,  
  fhir5_base, fhir5_enums, fhir5_types, fhir5_resources_base, fhir5_resources_canonical;



type
{$IFDEF FHIR_DEVICE}
  TFhirDeviceUdiCarrier = class;
  TFhirDeviceUdiCarrierList = class;
  TFhirDeviceDeviceName = class;
  TFhirDeviceDeviceNameList = class;
  TFhirDeviceVersion = class;
  TFhirDeviceVersionList = class;
  TFhirDeviceSpecialization = class;
  TFhirDeviceSpecializationList = class;
  TFhirDeviceProperty = class;
  TFhirDevicePropertyList = class;
  TFhirDeviceOperation = class;
  TFhirDeviceOperationList = class;
  TFhirDeviceAssociation = class;
  TFhirDeviceAssociationList = class;
  TFhirDevice = class;
  TFhirDeviceList = class;
{$ENDIF FHIR_DEVICE}
{$IFDEF FHIR_DEVICEDEFINITION}
  TFhirDeviceDefinitionUdiDeviceIdentifier = class;
  TFhirDeviceDefinitionUdiDeviceIdentifierList = class;
  TFhirDeviceDefinitionUdiDeviceIdentifierMarketDistribution = class;
  TFhirDeviceDefinitionUdiDeviceIdentifierMarketDistributionList = class;
  TFhirDeviceDefinitionRegulatoryIdentifier = class;
  TFhirDeviceDefinitionRegulatoryIdentifierList = class;
  TFhirDeviceDefinitionDeviceName = class;
  TFhirDeviceDefinitionDeviceNameList = class;
  TFhirDeviceDefinitionClassification = class;
  TFhirDeviceDefinitionClassificationList = class;
  TFhirDeviceDefinitionHasPart = class;
  TFhirDeviceDefinitionHasPartList = class;
  TFhirDeviceDefinitionPackaging = class;
  TFhirDeviceDefinitionPackagingList = class;
  TFhirDeviceDefinitionPackagingDistributor = class;
  TFhirDeviceDefinitionPackagingDistributorList = class;
  TFhirDeviceDefinitionVersion = class;
  TFhirDeviceDefinitionVersionList = class;
  TFhirDeviceDefinitionProperty = class;
  TFhirDeviceDefinitionPropertyList = class;
  TFhirDeviceDefinitionLink = class;
  TFhirDeviceDefinitionLinkList = class;
  TFhirDeviceDefinitionMaterial = class;
  TFhirDeviceDefinitionMaterialList = class;
  TFhirDeviceDefinitionGuideline = class;
  TFhirDeviceDefinitionGuidelineList = class;
  TFhirDeviceDefinitionCorrectiveAction = class;
  TFhirDeviceDefinitionCorrectiveActionList = class;
  TFhirDeviceDefinitionChargeItem = class;
  TFhirDeviceDefinitionChargeItemList = class;
  TFhirDeviceDefinition = class;
  TFhirDeviceDefinitionList = class;
{$ENDIF FHIR_DEVICEDEFINITION}
{$IFDEF FHIR_DEVICEMETRIC}
  TFhirDeviceMetricCalibration = class;
  TFhirDeviceMetricCalibrationList = class;
  TFhirDeviceMetric = class;
  TFhirDeviceMetricList = class;
{$ENDIF FHIR_DEVICEMETRIC}
{$IFDEF FHIR_ENCOUNTER}
  TFhirEncounterStatusHistory = class;
  TFhirEncounterStatusHistoryList = class;
  TFhirEncounterClassHistory = class;
  TFhirEncounterClassHistoryList = class;
  TFhirEncounterParticipant = class;
  TFhirEncounterParticipantList = class;
  TFhirEncounterDiagnosis = class;
  TFhirEncounterDiagnosisList = class;
  TFhirEncounterAdmission = class;
  TFhirEncounterAdmissionList = class;
  TFhirEncounterLocation = class;
  TFhirEncounterLocationList = class;
  TFhirEncounter = class;
  TFhirEncounterList = class;
{$ENDIF FHIR_ENCOUNTER}
{$IFDEF FHIR_ENDPOINT}
  TFhirEndpoint = class;
  TFhirEndpointList = class;
{$ENDIF FHIR_ENDPOINT}
{$IFDEF FHIR_GROUP}
  TFhirGroupCharacteristic = class;
  TFhirGroupCharacteristicList = class;
  TFhirGroupMember = class;
  TFhirGroupMemberList = class;
  TFhirGroup = class;
  TFhirGroupList = class;
{$ENDIF FHIR_GROUP}
{$IFDEF FHIR_HEALTHCARESERVICE}
  TFhirHealthcareServiceEligibility = class;
  TFhirHealthcareServiceEligibilityList = class;
  TFhirHealthcareService = class;
  TFhirHealthcareServiceList = class;
{$ENDIF FHIR_HEALTHCARESERVICE}
{$IFDEF FHIR_LOCATION}
  TFhirLocationPosition = class;
  TFhirLocationPositionList = class;
  TFhirLocation = class;
  TFhirLocationList = class;
{$ENDIF FHIR_LOCATION}
{$IFDEF FHIR_ORGANIZATION}
  TFhirOrganizationQualification = class;
  TFhirOrganizationQualificationList = class;
  TFhirOrganization = class;
  TFhirOrganizationList = class;
{$ENDIF FHIR_ORGANIZATION}
{$IFDEF FHIR_ORGANIZATIONAFFILIATION}
  TFhirOrganizationAffiliation = class;
  TFhirOrganizationAffiliationList = class;
{$ENDIF FHIR_ORGANIZATIONAFFILIATION}
{$IFDEF FHIR_PATIENT}
  TFhirPatientContact = class;
  TFhirPatientContactList = class;
  TFhirPatientCommunication = class;
  TFhirPatientCommunicationList = class;
  TFhirPatientLink = class;
  TFhirPatientLinkList = class;
  TFhirPatient = class;
  TFhirPatientList = class;
{$ENDIF FHIR_PATIENT}
{$IFDEF FHIR_PERSON}
  TFhirPersonCommunication = class;
  TFhirPersonCommunicationList = class;
  TFhirPersonLink = class;
  TFhirPersonLinkList = class;
  TFhirPerson = class;
  TFhirPersonList = class;
{$ENDIF FHIR_PERSON}
{$IFDEF FHIR_PRACTITIONER}
  TFhirPractitionerQualification = class;
  TFhirPractitionerQualificationList = class;
  TFhirPractitioner = class;
  TFhirPractitionerList = class;
{$ENDIF FHIR_PRACTITIONER}
{$IFDEF FHIR_PRACTITIONERROLE}
  TFhirPractitionerRole = class;
  TFhirPractitionerRoleList = class;
{$ENDIF FHIR_PRACTITIONERROLE}
{$IFDEF FHIR_RELATEDPERSON}
  TFhirRelatedPersonCommunication = class;
  TFhirRelatedPersonCommunicationList = class;
  TFhirRelatedPerson = class;
  TFhirRelatedPersonList = class;
{$ENDIF FHIR_RELATEDPERSON}
{$IFDEF FHIR_SCHEDULE}
  TFhirSchedule = class;
  TFhirScheduleList = class;
{$ENDIF FHIR_SCHEDULE}
{$IFDEF FHIR_SLOT}
  TFhirSlot = class;
  TFhirSlotList = class;
{$ENDIF FHIR_SLOT}




{$IFDEF FHIR_DEVICE}
  // Unique device identifier (UDI) assigned to device label or package.  Note that the Device may include multiple udiCarriers as it either may include just the udiCarrier for the jurisdiction it is sold, or for multiple jurisdictions it could have been sold.
  TFhirDeviceUdiCarrier = class (TFhirBackboneElement)
  protected
    FDeviceIdentifier : TFhirString;
    FIssuer : TFhirUri;
    FJurisdiction : TFhirUri;
    FCarrierAIDC : TFhirBase64Binary;
    FCarrierHRF : TFhirString;
    FEntryType : TFhirEnum;
    procedure SetDeviceIdentifier(value : TFhirString);
    function GetDeviceIdentifierST : String;
    procedure SetDeviceIdentifierST(value : String);
    procedure SetIssuer(value : TFhirUri);
    function GetIssuerST : String;
    procedure SetIssuerST(value : String);
    procedure SetJurisdiction(value : TFhirUri);
    function GetJurisdictionST : String;
    procedure SetJurisdictionST(value : String);
    procedure SetCarrierAIDC(value : TFhirBase64Binary);
    function GetCarrierAIDCST : TBytes;
    procedure SetCarrierAIDCST(value : TBytes);
    procedure SetCarrierHRF(value : TFhirString);
    function GetCarrierHRFST : String;
    procedure SetCarrierHRFST(value : String);
    procedure SetEntryType(value : TFhirEnum);
    function GetEntryTypeST : TFhirUDIEntryTypeEnum;
    procedure SetEntryTypeST(value : TFhirUDIEntryTypeEnum);
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirDeviceUdiCarrier; overload;
    function Clone : TFhirDeviceUdiCarrier; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to The device identifier (DI) is a mandatory, fixed portion of a UDI that identifies the labeler and the specific version or model of a device.
    property deviceIdentifier : String read GetDeviceIdentifierST write SetDeviceIdentifierST;
    // The device identifier (DI) is a mandatory, fixed portion of a UDI that identifies the labeler and the specific version or model of a device.
    property deviceIdentifierElement : TFhirString read FDeviceIdentifier write SetDeviceIdentifier;

    // Typed access to Organization that is charged with issuing UDIs for devices. For example, the US FDA issuers include:  1) GS1: http://hl7.org/fhir/NamingSystem/gs1-di,  2) HIBCC: http://hl7.org/fhir/NamingSystem/hibcc-diI,  3) ICCBBA for blood containers: http://hl7.org/fhir/NamingSystem/iccbba-blood-di,  4) ICCBA for other devices: http://hl7.org/fhir/NamingSystem/iccbba-other-di # Informationsstelle für Arzneispezialitäten (IFA GmbH) (EU only): http://hl7.org/fhir/NamingSystem/ifa-gmbh-di.
    property issuer : String read GetIssuerST write SetIssuerST;
    // Organization that is charged with issuing UDIs for devices. For example, the US FDA issuers include:  1) GS1: http://hl7.org/fhir/NamingSystem/gs1-di,  2) HIBCC: http://hl7.org/fhir/NamingSystem/hibcc-diI,  3) ICCBBA for blood containers: http://hl7.org/fhir/NamingSystem/iccbba-blood-di,  4) ICCBA for other devices: http://hl7.org/fhir/NamingSystem/iccbba-other-di # Informationsstelle für Arzneispezialitäten (IFA GmbH) (EU only): http://hl7.org/fhir/NamingSystem/ifa-gmbh-di.
    property issuerElement : TFhirUri read FIssuer write SetIssuer;

    // Typed access to The identity of the authoritative source for UDI generation within a jurisdiction. All UDIs are globally unique within a single namespace with the appropriate repository uri as the system. For example, UDIs of devices managed in the U.S. by the FDA, the value is http://hl7.org/fhir/NamingSystem/us-fda-udi or in the European Union by the European Commission http://hl7.org/fhir/NamingSystem/eu-ec-udi.
    property jurisdiction : String read GetJurisdictionST write SetJurisdictionST;
    // The identity of the authoritative source for UDI generation within a jurisdiction. All UDIs are globally unique within a single namespace with the appropriate repository uri as the system. For example, UDIs of devices managed in the U.S. by the FDA, the value is http://hl7.org/fhir/NamingSystem/us-fda-udi or in the European Union by the European Commission http://hl7.org/fhir/NamingSystem/eu-ec-udi.
    property jurisdictionElement : TFhirUri read FJurisdiction write SetJurisdiction;

    // Typed access to The full UDI carrier of the Automatic Identification and Data Capture (AIDC) technology representation of the barcode string as printed on the packaging of the device - e.g., a barcode or RFID.   Because of limitations on character sets in XML and the need to round-trip JSON data through XML, AIDC Formats *SHALL* be base64 encoded.
    property carrierAIDC : TBytes read GetCarrierAIDCST write SetCarrierAIDCST;
    // The full UDI carrier of the Automatic Identification and Data Capture (AIDC) technology representation of the barcode string as printed on the packaging of the device - e.g., a barcode or RFID.   Because of limitations on character sets in XML and the need to round-trip JSON data through XML, AIDC Formats *SHALL* be base64 encoded.
    property carrierAIDCElement : TFhirBase64Binary read FCarrierAIDC write SetCarrierAIDC;

    // Typed access to The full UDI carrier as the human readable form (HRF) representation of the barcode string as printed on the packaging of the device.
    property carrierHRF : String read GetCarrierHRFST write SetCarrierHRFST;
    // The full UDI carrier as the human readable form (HRF) representation of the barcode string as printed on the packaging of the device.
    property carrierHRFElement : TFhirString read FCarrierHRF write SetCarrierHRF;

    // A coded entry to indicate how the data was entered.
    property entryType : TFhirUDIEntryTypeEnum read GetEntryTypeST write SetEntryTypeST;
    property entryTypeElement : TFhirEnum read FEntryType write SetEntryType;

  end;

  TFhirDeviceUdiCarrierListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirDeviceUdiCarrierList;
    function GetCurrent : TFhirDeviceUdiCarrier;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirDeviceUdiCarrierList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirDeviceUdiCarrier read GetCurrent;
  end;

  TFhirDeviceUdiCarrierList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirDeviceUdiCarrier;
    procedure SetItemN(index : Integer; value : TFhirDeviceUdiCarrier);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirDeviceUdiCarrierList; overload;
    function Clone : TFhirDeviceUdiCarrierList; overload;
    function GetEnumerator : TFhirDeviceUdiCarrierListEnumerator;
    
    //  Add a FhirDeviceUdiCarrier to the end of the list.
    function Append : TFhirDeviceUdiCarrier;
    
    // Add an already existing FhirDeviceUdiCarrier to the end of the list.
    function AddItem(value : TFhirDeviceUdiCarrier) : TFhirDeviceUdiCarrier; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirDeviceUdiCarrier) : Integer;
    
    // Insert FhirDeviceUdiCarrier before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirDeviceUdiCarrier;
    
    // Insert an existing FhirDeviceUdiCarrier before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirDeviceUdiCarrier);
    
    // Get the iIndexth FhirDeviceUdiCarrier. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirDeviceUdiCarrier);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirDeviceUdiCarrier;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirDeviceUdiCarriers[index : Integer] : TFhirDeviceUdiCarrier read GetItemN write SetItemN; default;
  End;

  // This represents the manufacturer's name of the device as provided by the device, from a UDI label, or by a person describing the Device.  This typically would be used when a person provides the name(s) or when the device represents one of the names available from DeviceDefinition.
  TFhirDeviceDeviceName = class (TFhirBackboneElement)
  protected
    FName : TFhirString;
    FType_ : TFhirEnum;
    procedure SetName(value : TFhirString);
    function GetNameST : String;
    procedure SetNameST(value : String);
    procedure SetType_(value : TFhirEnum);
    function GetType_ST : TFhirDeviceNameTypeEnum;
    procedure SetType_ST(value : TFhirDeviceNameTypeEnum);
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirDeviceDeviceName; overload;
    function Clone : TFhirDeviceDeviceName; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to The name that identifies the device.
    property name : String read GetNameST write SetNameST;
    // The name that identifies the device.
    property nameElement : TFhirString read FName write SetName;

    // The type of deviceName. Note that ManufactureDeviceName means that the name is the name as given by the manufacturer, not the name of the manufacturer. RegisteredName | UserFriendlyName | PatientReportedName.
    property type_ : TFhirDeviceNameTypeEnum read GetType_ST write SetType_ST;
    property type_Element : TFhirEnum read FType_ write SetType_;

  end;

  TFhirDeviceDeviceNameListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirDeviceDeviceNameList;
    function GetCurrent : TFhirDeviceDeviceName;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirDeviceDeviceNameList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirDeviceDeviceName read GetCurrent;
  end;

  TFhirDeviceDeviceNameList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirDeviceDeviceName;
    procedure SetItemN(index : Integer; value : TFhirDeviceDeviceName);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirDeviceDeviceNameList; overload;
    function Clone : TFhirDeviceDeviceNameList; overload;
    function GetEnumerator : TFhirDeviceDeviceNameListEnumerator;
    
    //  Add a FhirDeviceDeviceName to the end of the list.
    function Append : TFhirDeviceDeviceName;
    
    // Add an already existing FhirDeviceDeviceName to the end of the list.
    function AddItem(value : TFhirDeviceDeviceName) : TFhirDeviceDeviceName; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirDeviceDeviceName) : Integer;
    
    // Insert FhirDeviceDeviceName before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirDeviceDeviceName;
    
    // Insert an existing FhirDeviceDeviceName before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirDeviceDeviceName);
    
    // Get the iIndexth FhirDeviceDeviceName. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirDeviceDeviceName);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirDeviceDeviceName;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirDeviceDeviceNames[index : Integer] : TFhirDeviceDeviceName read GetItemN write SetItemN; default;
  End;

  // The actual design of the device or software version running on the device.
  TFhirDeviceVersion = class (TFhirBackboneElement)
  protected
    FType_ : TFhirCodeableConcept;
    FComponent : TFhirIdentifier;
    FInstallDate : TFhirDateTime;
    FValue : TFhirString;
    procedure SetType_(value : TFhirCodeableConcept);
    procedure SetComponent(value : TFhirIdentifier);
    procedure SetInstallDate(value : TFhirDateTime);
    function GetInstallDateST : TFslDateTime;
    procedure SetInstallDateST(value : TFslDateTime);
    procedure SetValue(value : TFhirString);
    function GetValueST : String;
    procedure SetValueST(value : String);
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirDeviceVersion; overload;
    function Clone : TFhirDeviceVersion; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to The type of the device version, e.g. manufacturer, approved, internal. (defined for API consistency)
    property type_ : TFhirCodeableConcept read FType_ write SetType_;
    // The type of the device version, e.g. manufacturer, approved, internal.
    property type_Element : TFhirCodeableConcept read FType_ write SetType_;

    // Typed access to The hardware or software module of the device to which the version applies. (defined for API consistency)
    property component : TFhirIdentifier read FComponent write SetComponent;
    // The hardware or software module of the device to which the version applies.
    property componentElement : TFhirIdentifier read FComponent write SetComponent;

    // Typed access to The date the version was installed on the device.
    property installDate : TFslDateTime read GetInstallDateST write SetInstallDateST;
    // The date the version was installed on the device.
    property installDateElement : TFhirDateTime read FInstallDate write SetInstallDate;

    // Typed access to The version text.
    property value : String read GetValueST write SetValueST;
    // The version text.
    property valueElement : TFhirString read FValue write SetValue;

  end;

  TFhirDeviceVersionListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirDeviceVersionList;
    function GetCurrent : TFhirDeviceVersion;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirDeviceVersionList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirDeviceVersion read GetCurrent;
  end;

  TFhirDeviceVersionList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirDeviceVersion;
    procedure SetItemN(index : Integer; value : TFhirDeviceVersion);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirDeviceVersionList; overload;
    function Clone : TFhirDeviceVersionList; overload;
    function GetEnumerator : TFhirDeviceVersionListEnumerator;
    
    //  Add a FhirDeviceVersion to the end of the list.
    function Append : TFhirDeviceVersion;
    
    // Add an already existing FhirDeviceVersion to the end of the list.
    function AddItem(value : TFhirDeviceVersion) : TFhirDeviceVersion; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirDeviceVersion) : Integer;
    
    // Insert FhirDeviceVersion before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirDeviceVersion;
    
    // Insert an existing FhirDeviceVersion before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirDeviceVersion);
    
    // Get the iIndexth FhirDeviceVersion. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirDeviceVersion);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirDeviceVersion;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirDeviceVersions[index : Integer] : TFhirDeviceVersion read GetItemN write SetItemN; default;
  End;

  // The standards to which the device adheres and may be certified to in support of its capabilities, e.g., communication, performance, process, or measurement standards.
  TFhirDeviceSpecialization = class (TFhirBackboneElement)
  protected
    FSystemType : TFhirCodeableConcept;
    FVersion : TFhirString;
    FCategory : TFhirCoding;
    procedure SetSystemType(value : TFhirCodeableConcept);
    procedure SetVersion(value : TFhirString);
    function GetVersionST : String;
    procedure SetVersionST(value : String);
    procedure SetCategory(value : TFhirCoding);
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirDeviceSpecialization; overload;
    function Clone : TFhirDeviceSpecialization; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to Code that specifies the system that identifies the specific standard that the device adheres to. (defined for API consistency)
    property systemType : TFhirCodeableConcept read FSystemType write SetSystemType;
    // Code that specifies the system that identifies the specific standard that the device adheres to.
    property systemTypeElement : TFhirCodeableConcept read FSystemType write SetSystemType;

    // Typed access to The version of the standard that is used to operate and communicate.
    property version : String read GetVersionST write SetVersionST;
    // The version of the standard that is used to operate and communicate.
    property versionElement : TFhirString read FVersion write SetVersion;

    // Typed access to Kind of standards that the device adheres to, e.g., communication, performance or communication. (defined for API consistency)
    property category : TFhirCoding read FCategory write SetCategory;
    // Kind of standards that the device adheres to, e.g., communication, performance or communication.
    property categoryElement : TFhirCoding read FCategory write SetCategory;

  end;

  TFhirDeviceSpecializationListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirDeviceSpecializationList;
    function GetCurrent : TFhirDeviceSpecialization;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirDeviceSpecializationList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirDeviceSpecialization read GetCurrent;
  end;

  TFhirDeviceSpecializationList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirDeviceSpecialization;
    procedure SetItemN(index : Integer; value : TFhirDeviceSpecialization);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirDeviceSpecializationList; overload;
    function Clone : TFhirDeviceSpecializationList; overload;
    function GetEnumerator : TFhirDeviceSpecializationListEnumerator;
    
    //  Add a FhirDeviceSpecialization to the end of the list.
    function Append : TFhirDeviceSpecialization;
    
    // Add an already existing FhirDeviceSpecialization to the end of the list.
    function AddItem(value : TFhirDeviceSpecialization) : TFhirDeviceSpecialization; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirDeviceSpecialization) : Integer;
    
    // Insert FhirDeviceSpecialization before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirDeviceSpecialization;
    
    // Insert an existing FhirDeviceSpecialization before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirDeviceSpecialization);
    
    // Get the iIndexth FhirDeviceSpecialization. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirDeviceSpecialization);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirDeviceSpecialization;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirDeviceSpecializations[index : Integer] : TFhirDeviceSpecialization read GetItemN write SetItemN; default;
  End;

  // Characteristics or features of the device that are otherwise not captured in available attributes, e.g., actual configuration settings, time or timing attributes, resolution, accuracy, and physical attributes.  The focus is on properties of the device actually in use while DeviceDefinition focuses on properties that are available to be used.
  TFhirDeviceProperty = class (TFhirBackboneElement)
  protected
    FType_ : TFhirCodeableConcept;
    FValue : TFhirDataType;
    procedure SetType_(value : TFhirCodeableConcept);
    procedure SetValue(value : TFhirDataType);
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirDeviceProperty; overload;
    function Clone : TFhirDeviceProperty; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to Code that specifies the property being represented. No codes are specified but the MDC codes are an example: https://terminology.hl7.org/MDC.html. (defined for API consistency)
    property type_ : TFhirCodeableConcept read FType_ write SetType_;
    // Code that specifies the property being represented. No codes are specified but the MDC codes are an example: https://terminology.hl7.org/MDC.html.
    property type_Element : TFhirCodeableConcept read FType_ write SetType_;

    // Typed access to Property value - can be a code, quantity, boolean, string or attachment. (defined for API consistency)
    property value : TFhirDataType read FValue write SetValue;
    // Property value - can be a code, quantity, boolean, string or attachment.
    property valueElement : TFhirDataType read FValue write SetValue;

  end;

  TFhirDevicePropertyListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirDevicePropertyList;
    function GetCurrent : TFhirDeviceProperty;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirDevicePropertyList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirDeviceProperty read GetCurrent;
  end;

  TFhirDevicePropertyList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirDeviceProperty;
    procedure SetItemN(index : Integer; value : TFhirDeviceProperty);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirDevicePropertyList; overload;
    function Clone : TFhirDevicePropertyList; overload;
    function GetEnumerator : TFhirDevicePropertyListEnumerator;
    
    //  Add a FhirDeviceProperty to the end of the list.
    function Append : TFhirDeviceProperty;
    
    // Add an already existing FhirDeviceProperty to the end of the list.
    function AddItem(value : TFhirDeviceProperty) : TFhirDeviceProperty; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirDeviceProperty) : Integer;
    
    // Insert FhirDeviceProperty before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirDeviceProperty;
    
    // Insert an existing FhirDeviceProperty before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirDeviceProperty);
    
    // Get the iIndexth FhirDeviceProperty. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirDeviceProperty);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirDeviceProperty;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirDeviceProperties[index : Integer] : TFhirDeviceProperty read GetItemN write SetItemN; default;
  End;

  // The status of the device itself - whether it is switched on, or activated, etc.
  TFhirDeviceOperation = class (TFhirBackboneElement)
  protected
    FStatus : TFhirCodeableConcept;
    FstatusReasonList : TFhirCodeableConceptList;
    FoperatorList : TFhirReferenceList;
    FMode : TFhirCodeableConcept;
    FCycle : TFhirCount;
    FDuration : TFhirDuration;
    procedure SetStatus(value : TFhirCodeableConcept);
    function GetStatusReasonList : TFhirCodeableConceptList;
    function GetHasStatusReasonList : Boolean;
    function GetOperatorList : TFhirReferenceList;
    function GetHasOperatorList : Boolean;
    procedure SetMode(value : TFhirCodeableConcept);
    procedure SetCycle(value : TFhirCount);
    procedure SetDuration(value : TFhirDuration);
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirDeviceOperation; overload;
    function Clone : TFhirDeviceOperation; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to The state or condition of the device's operation. (defined for API consistency)
    property status : TFhirCodeableConcept read FStatus write SetStatus;
    // The state or condition of the device's operation.
    property statusElement : TFhirCodeableConcept read FStatus write SetStatus;

    // The reasons given for the current operational status - i.e. why is the device switched on etc.
    property statusReasonList : TFhirCodeableConceptList read GetStatusReasonList;
    property hasStatusReasonList : boolean read GetHasStatusReasonList;

    // The individual performing the action enabled by the device.
    property operatorList : TFhirReferenceList read GetOperatorList;
    property hasOperatorList : boolean read GetHasOperatorList;

    // Typed access to The designated condition for performing a task with the device. (defined for API consistency)
    property mode : TFhirCodeableConcept read FMode write SetMode;
    // The designated condition for performing a task with the device.
    property modeElement : TFhirCodeableConcept read FMode write SetMode;

    // Typed access to The series of occurrences that repeats during the operation of the device. (defined for API consistency)
    property cycle : TFhirCount read FCycle write SetCycle;
    // The series of occurrences that repeats during the operation of the device.
    property cycleElement : TFhirCount read FCycle write SetCycle;

    // Typed access to A measurement of time during the device's operation (e.g., days, hours, mins, etc). (defined for API consistency)
    property duration : TFhirDuration read FDuration write SetDuration;
    // A measurement of time during the device's operation (e.g., days, hours, mins, etc).
    property durationElement : TFhirDuration read FDuration write SetDuration;

  end;

  TFhirDeviceOperationListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirDeviceOperationList;
    function GetCurrent : TFhirDeviceOperation;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirDeviceOperationList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirDeviceOperation read GetCurrent;
  end;

  TFhirDeviceOperationList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirDeviceOperation;
    procedure SetItemN(index : Integer; value : TFhirDeviceOperation);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirDeviceOperationList; overload;
    function Clone : TFhirDeviceOperationList; overload;
    function GetEnumerator : TFhirDeviceOperationListEnumerator;
    
    //  Add a FhirDeviceOperation to the end of the list.
    function Append : TFhirDeviceOperation;
    
    // Add an already existing FhirDeviceOperation to the end of the list.
    function AddItem(value : TFhirDeviceOperation) : TFhirDeviceOperation; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirDeviceOperation) : Integer;
    
    // Insert FhirDeviceOperation before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirDeviceOperation;
    
    // Insert an existing FhirDeviceOperation before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirDeviceOperation);
    
    // Get the iIndexth FhirDeviceOperation. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirDeviceOperation);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirDeviceOperation;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirDeviceOperations[index : Integer] : TFhirDeviceOperation read GetItemN write SetItemN; default;
  End;

  // The details about the device when it is affixed or inside of a patient.
  TFhirDeviceAssociation = class (TFhirBackboneElement)
  protected
    FStatus : TFhirCodeableConcept;
    FstatusReasonList : TFhirCodeableConceptList;
    FHumanSubject : TFhirReference;
    FBodyStructure : TFhirCodeableReference;
    procedure SetStatus(value : TFhirCodeableConcept);
    function GetStatusReasonList : TFhirCodeableConceptList;
    function GetHasStatusReasonList : Boolean;
    procedure SetHumanSubject(value : TFhirReference);
    procedure SetBodyStructure(value : TFhirCodeableReference);
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirDeviceAssociation; overload;
    function Clone : TFhirDeviceAssociation; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to The state of the usage or application of the device. (defined for API consistency)
    property status : TFhirCodeableConcept read FStatus write SetStatus;
    // The state of the usage or application of the device.
    property statusElement : TFhirCodeableConcept read FStatus write SetStatus;

    // The reasons given for the current association status - i.e. why is the device explanted, or attached to the patient, etc.
    property statusReasonList : TFhirCodeableConceptList read GetStatusReasonList;
    property hasStatusReasonList : boolean read GetHasStatusReasonList;

    // Typed access to The individual to whom the device is affixed or inserted in their body. (defined for API consistency)
    property humanSubject : TFhirReference read FHumanSubject write SetHumanSubject;
    // The individual to whom the device is affixed or inserted in their body.
    property humanSubjectElement : TFhirReference read FHumanSubject write SetHumanSubject;

    // Typed access to The current anatomical location of the device in/on the humanSubject where it is attached or placed. (defined for API consistency)
    property bodyStructure : TFhirCodeableReference read FBodyStructure write SetBodyStructure;
    // The current anatomical location of the device in/on the humanSubject where it is attached or placed.
    property bodyStructureElement : TFhirCodeableReference read FBodyStructure write SetBodyStructure;

  end;

  TFhirDeviceAssociationListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirDeviceAssociationList;
    function GetCurrent : TFhirDeviceAssociation;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirDeviceAssociationList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirDeviceAssociation read GetCurrent;
  end;

  TFhirDeviceAssociationList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirDeviceAssociation;
    procedure SetItemN(index : Integer; value : TFhirDeviceAssociation);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirDeviceAssociationList; overload;
    function Clone : TFhirDeviceAssociationList; overload;
    function GetEnumerator : TFhirDeviceAssociationListEnumerator;
    
    //  Add a FhirDeviceAssociation to the end of the list.
    function Append : TFhirDeviceAssociation;
    
    // Add an already existing FhirDeviceAssociation to the end of the list.
    function AddItem(value : TFhirDeviceAssociation) : TFhirDeviceAssociation; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirDeviceAssociation) : Integer;
    
    // Insert FhirDeviceAssociation before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirDeviceAssociation;
    
    // Insert an existing FhirDeviceAssociation before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirDeviceAssociation);
    
    // Get the iIndexth FhirDeviceAssociation. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirDeviceAssociation);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirDeviceAssociation;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirDeviceAssociations[index : Integer] : TFhirDeviceAssociation read GetItemN write SetItemN; default;
  End;

  // A type of a manufactured item that is used in the provision of healthcare without being substantially changed through that activity. The device may be a medical or non-medical device.
  TFhirDevice = class (TFhirDomainResource)
  protected
    FidentifierList : TFhirIdentifierList;
    FDisplayName : TFhirString;
    FDefinition : TFhirCodeableReference;
    FudiCarrierList : TFhirDeviceUdiCarrierList;
    FStatus : TFhirEnum;
    FAvailabilityStatus : TFhirCodeableConcept;
    FBiologicalSourceEvent : TFhirIdentifier;
    FManufacturer : TFhirString;
    FManufactureDate : TFhirDateTime;
    FExpirationDate : TFhirDateTime;
    FLotNumber : TFhirString;
    FSerialNumber : TFhirString;
    FdeviceNameList : TFhirDeviceDeviceNameList;
    FModelNumber : TFhirString;
    FPartNumber : TFhirString;
    FcategoryList : TFhirCodeableConceptList;
    Ftype_List : TFhirCodeableConceptList;
    FversionList : TFhirDeviceVersionList;
    FspecializationList : TFhirDeviceSpecializationList;
    Fproperty_List : TFhirDevicePropertyList;
    FoperationList : TFhirDeviceOperationList;
    FassociationList : TFhirDeviceAssociationList;
    FOwner : TFhirReference;
    FcontactList : TFhirContactPointList;
    FLocation : TFhirReference;
    FUrl : TFhirUri;
    FendpointList : TFhirReferenceList;
    FgatewayList : TFhirCodeableReferenceList;
    FnoteList : TFhirAnnotationList;
    FsafetyList : TFhirCodeableConceptList;
    FParent : TFhirReference;
    function GetIdentifierList : TFhirIdentifierList;
    function GetHasIdentifierList : Boolean;
    procedure SetDisplayName(value : TFhirString);
    function GetDisplayNameST : String;
    procedure SetDisplayNameST(value : String);
    procedure SetDefinition(value : TFhirCodeableReference);
    function GetUdiCarrierList : TFhirDeviceUdiCarrierList;
    function GetHasUdiCarrierList : Boolean;
    procedure SetStatus(value : TFhirEnum);
    function GetStatusST : TFhirFHIRDeviceStatusEnum;
    procedure SetStatusST(value : TFhirFHIRDeviceStatusEnum);
    procedure SetAvailabilityStatus(value : TFhirCodeableConcept);
    procedure SetBiologicalSourceEvent(value : TFhirIdentifier);
    procedure SetManufacturer(value : TFhirString);
    function GetManufacturerST : String;
    procedure SetManufacturerST(value : String);
    procedure SetManufactureDate(value : TFhirDateTime);
    function GetManufactureDateST : TFslDateTime;
    procedure SetManufactureDateST(value : TFslDateTime);
    procedure SetExpirationDate(value : TFhirDateTime);
    function GetExpirationDateST : TFslDateTime;
    procedure SetExpirationDateST(value : TFslDateTime);
    procedure SetLotNumber(value : TFhirString);
    function GetLotNumberST : String;
    procedure SetLotNumberST(value : String);
    procedure SetSerialNumber(value : TFhirString);
    function GetSerialNumberST : String;
    procedure SetSerialNumberST(value : String);
    function GetDeviceNameList : TFhirDeviceDeviceNameList;
    function GetHasDeviceNameList : Boolean;
    procedure SetModelNumber(value : TFhirString);
    function GetModelNumberST : String;
    procedure SetModelNumberST(value : String);
    procedure SetPartNumber(value : TFhirString);
    function GetPartNumberST : String;
    procedure SetPartNumberST(value : String);
    function GetCategoryList : TFhirCodeableConceptList;
    function GetHasCategoryList : Boolean;
    function GetType_List : TFhirCodeableConceptList;
    function GetHasType_List : Boolean;
    function GetVersionList : TFhirDeviceVersionList;
    function GetHasVersionList : Boolean;
    function GetSpecializationList : TFhirDeviceSpecializationList;
    function GetHasSpecializationList : Boolean;
    function GetProperty_List : TFhirDevicePropertyList;
    function GetHasProperty_List : Boolean;
    function GetOperationList : TFhirDeviceOperationList;
    function GetHasOperationList : Boolean;
    function GetAssociationList : TFhirDeviceAssociationList;
    function GetHasAssociationList : Boolean;
    procedure SetOwner(value : TFhirReference);
    function GetContactList : TFhirContactPointList;
    function GetHasContactList : Boolean;
    procedure SetLocation(value : TFhirReference);
    procedure SetUrl(value : TFhirUri);
    function GetUrlST : String;
    procedure SetUrlST(value : String);
    function GetEndpointList : TFhirReferenceList;
    function GetHasEndpointList : Boolean;
    function GetGatewayList : TFhirCodeableReferenceList;
    function GetHasGatewayList : Boolean;
    function GetNoteList : TFhirAnnotationList;
    function GetHasNoteList : Boolean;
    function GetSafetyList : TFhirCodeableConceptList;
    function GetHasSafetyList : Boolean;
    procedure SetParent(value : TFhirReference);
  
    function GetResourceType : TFhirResourceType; override;
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirDevice; overload;
    function Clone : TFhirDevice; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Unique instance identifiers assigned to a device by manufacturers other organizations or owners.
    property identifierList : TFhirIdentifierList read GetIdentifierList;
    property hasIdentifierList : boolean read GetHasIdentifierList;

    // Typed access to The name used to display by default when the device is referenced. Based on intent of use by the resource creator, this may reflect one of the names in Device.deviceName, or may be another simple name.
    property displayName : String read GetDisplayNameST write SetDisplayNameST;
    // The name used to display by default when the device is referenced. Based on intent of use by the resource creator, this may reflect one of the names in Device.deviceName, or may be another simple name.
    property displayNameElement : TFhirString read FDisplayName write SetDisplayName;

    // Typed access to The reference to the definition for the device. (defined for API consistency)
    property definition : TFhirCodeableReference read FDefinition write SetDefinition;
    // The reference to the definition for the device.
    property definitionElement : TFhirCodeableReference read FDefinition write SetDefinition;

    // Unique device identifier (UDI) assigned to device label or package.  Note that the Device may include multiple udiCarriers as it either may include just the udiCarrier for the jurisdiction it is sold, or for multiple jurisdictions it could have been sold.
    property udiCarrierList : TFhirDeviceUdiCarrierList read GetUdiCarrierList;
    property hasUdiCarrierList : boolean read GetHasUdiCarrierList;

    // The Device record status. This is not the status of the device like availability.
    property status : TFhirFHIRDeviceStatusEnum read GetStatusST write SetStatusST;
    property statusElement : TFhirEnum read FStatus write SetStatus;

    // Typed access to The availability of the device. (defined for API consistency)
    property availabilityStatus : TFhirCodeableConcept read FAvailabilityStatus write SetAvailabilityStatus;
    // The availability of the device.
    property availabilityStatusElement : TFhirCodeableConcept read FAvailabilityStatus write SetAvailabilityStatus;

    // Typed access to An identifier that supports traceability to the event during which material in this product from one or more biological entities was obtained or pooled. (defined for API consistency)
    property biologicalSourceEvent : TFhirIdentifier read FBiologicalSourceEvent write SetBiologicalSourceEvent;
    // An identifier that supports traceability to the event during which material in this product from one or more biological entities was obtained or pooled.
    property biologicalSourceEventElement : TFhirIdentifier read FBiologicalSourceEvent write SetBiologicalSourceEvent;

    // Typed access to A name of the manufacturer or entity legally responsible for the device.
    property manufacturer : String read GetManufacturerST write SetManufacturerST;
    // A name of the manufacturer or entity legally responsible for the device.
    property manufacturerElement : TFhirString read FManufacturer write SetManufacturer;

    // Typed access to The date and time when the device was manufactured.
    property manufactureDate : TFslDateTime read GetManufactureDateST write SetManufactureDateST;
    // The date and time when the device was manufactured.
    property manufactureDateElement : TFhirDateTime read FManufactureDate write SetManufactureDate;

    // Typed access to The date and time beyond which this device is no longer valid or should not be used (if applicable).
    property expirationDate : TFslDateTime read GetExpirationDateST write SetExpirationDateST;
    // The date and time beyond which this device is no longer valid or should not be used (if applicable).
    property expirationDateElement : TFhirDateTime read FExpirationDate write SetExpirationDate;

    // Typed access to Lot number assigned by the manufacturer.
    property lotNumber : String read GetLotNumberST write SetLotNumberST;
    // Lot number assigned by the manufacturer.
    property lotNumberElement : TFhirString read FLotNumber write SetLotNumber;

    // Typed access to The serial number assigned by the organization when the device was manufactured.
    property serialNumber : String read GetSerialNumberST write SetSerialNumberST;
    // The serial number assigned by the organization when the device was manufactured.
    property serialNumberElement : TFhirString read FSerialNumber write SetSerialNumber;

    // This represents the manufacturer's name of the device as provided by the device, from a UDI label, or by a person describing the Device.  This typically would be used when a person provides the name(s) or when the device represents one of the names available from DeviceDefinition.
    property deviceNameList : TFhirDeviceDeviceNameList read GetDeviceNameList;
    property hasDeviceNameList : boolean read GetHasDeviceNameList;

    // Typed access to The manufacturer's model number for the device.
    property modelNumber : String read GetModelNumberST write SetModelNumberST;
    // The manufacturer's model number for the device.
    property modelNumberElement : TFhirString read FModelNumber write SetModelNumber;

    // Typed access to The part number or catalog number of the device.
    property partNumber : String read GetPartNumberST write SetPartNumberST;
    // The part number or catalog number of the device.
    property partNumberElement : TFhirString read FPartNumber write SetPartNumber;

    // Devices may be associated with one or more categories.
    property categoryList : TFhirCodeableConceptList read GetCategoryList;
    property hasCategoryList : boolean read GetHasCategoryList;

    // The kind or type of device. A device instance may have more than one type - in which case those are the types that apply to the specific instance of the device.
    property type_List : TFhirCodeableConceptList read GetType_List;
    property hasType_List : boolean read GetHasType_List;

    // The actual design of the device or software version running on the device.
    property versionList : TFhirDeviceVersionList read GetVersionList;
    property hasVersionList : boolean read GetHasVersionList;

    // The standards to which the device adheres and may be certified to in support of its capabilities, e.g., communication, performance, process, or measurement standards.
    property specializationList : TFhirDeviceSpecializationList read GetSpecializationList;
    property hasSpecializationList : boolean read GetHasSpecializationList;

    // Characteristics or features of the device that are otherwise not captured in available attributes, e.g., actual configuration settings, time or timing attributes, resolution, accuracy, and physical attributes.  The focus is on properties of the device actually in use while DeviceDefinition focuses on properties that are available to be used.
    property property_List : TFhirDevicePropertyList read GetProperty_List;
    property hasProperty_List : boolean read GetHasProperty_List;

    // The status of the device itself - whether it is switched on, or activated, etc.
    property operationList : TFhirDeviceOperationList read GetOperationList;
    property hasOperationList : boolean read GetHasOperationList;

    // The details about the device when it is affixed or inside of a patient.
    property associationList : TFhirDeviceAssociationList read GetAssociationList;
    property hasAssociationList : boolean read GetHasAssociationList;

    // Typed access to An organization that is responsible for the provision and ongoing maintenance of the device. (defined for API consistency)
    property owner : TFhirReference read FOwner write SetOwner;
    // An organization that is responsible for the provision and ongoing maintenance of the device.
    property ownerElement : TFhirReference read FOwner write SetOwner;

    // Contact details for an organization or a particular human that is responsible for the device.
    property contactList : TFhirContactPointList read GetContactList;
    property hasContactList : boolean read GetHasContactList;

    // Typed access to The place where the device can be found. (defined for API consistency)
    property location : TFhirReference read FLocation write SetLocation;
    // The place where the device can be found.
    property locationElement : TFhirReference read FLocation write SetLocation;

    // Typed access to A network address on which the device may be contacted directly.
    property url : String read GetUrlST write SetUrlST;
    // A network address on which the device may be contacted directly.
    property urlElement : TFhirUri read FUrl write SetUrl;

    // Technical endpoints providing access to services provided by the device defined at this resource.
    property endpointList : TFhirReferenceList read GetEndpointList;
    property hasEndpointList : boolean read GetHasEndpointList;

    // The linked device acting as a communication/data collector, translator or controller for the current device (e.g., mobile phone application that relays a blood pressure device's data).
    property gatewayList : TFhirCodeableReferenceList read GetGatewayList;
    property hasGatewayList : boolean read GetHasGatewayList;

    // Descriptive information, usage information or implantation information that is not captured in an existing element.
    property noteList : TFhirAnnotationList read GetNoteList;
    property hasNoteList : boolean read GetHasNoteList;

    // Provides additional safety characteristics about a medical device.  For example devices containing latex.
    property safetyList : TFhirCodeableConceptList read GetSafetyList;
    property hasSafetyList : boolean read GetHasSafetyList;

    // Typed access to The higher level or encompassing device that this device is a logical part of. (defined for API consistency)
    property parent : TFhirReference read FParent write SetParent;
    // The higher level or encompassing device that this device is a logical part of.
    property parentElement : TFhirReference read FParent write SetParent;

  end;

  TFhirDeviceListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirDeviceList;
    function GetCurrent : TFhirDevice;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirDeviceList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirDevice read GetCurrent;
  end;

  TFhirDeviceList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirDevice;
    procedure SetItemN(index : Integer; value : TFhirDevice);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirDeviceList; overload;
    function Clone : TFhirDeviceList; overload;
    function GetEnumerator : TFhirDeviceListEnumerator;
    
    //  Add a FhirDevice to the end of the list.
    function Append : TFhirDevice;
    
    // Add an already existing FhirDevice to the end of the list.
    function AddItem(value : TFhirDevice) : TFhirDevice; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirDevice) : Integer;
    
    // Insert FhirDevice before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirDevice;
    
    // Insert an existing FhirDevice before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirDevice);
    
    // Get the iIndexth FhirDevice. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirDevice);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirDevice;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirDevices[index : Integer] : TFhirDevice read GetItemN write SetItemN; default;
  End;

{$ENDIF FHIR_DEVICE}
{$IFDEF FHIR_DEVICEDEFINITION}
  // Unique device identifier (UDI) assigned to device label or package.  Note that the Device may include multiple udiCarriers as it either may include just the udiCarrier for the jurisdiction it is sold, or for multiple jurisdictions it could have been sold.
  TFhirDeviceDefinitionUdiDeviceIdentifier = class (TFhirBackboneElement)
  protected
    FDeviceIdentifier : TFhirString;
    FIssuer : TFhirUri;
    FJurisdiction : TFhirUri;
    FmarketDistributionList : TFhirDeviceDefinitionUdiDeviceIdentifierMarketDistributionList;
    procedure SetDeviceIdentifier(value : TFhirString);
    function GetDeviceIdentifierST : String;
    procedure SetDeviceIdentifierST(value : String);
    procedure SetIssuer(value : TFhirUri);
    function GetIssuerST : String;
    procedure SetIssuerST(value : String);
    procedure SetJurisdiction(value : TFhirUri);
    function GetJurisdictionST : String;
    procedure SetJurisdictionST(value : String);
    function GetMarketDistributionList : TFhirDeviceDefinitionUdiDeviceIdentifierMarketDistributionList;
    function GetHasMarketDistributionList : Boolean;
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirDeviceDefinitionUdiDeviceIdentifier; overload;
    function Clone : TFhirDeviceDefinitionUdiDeviceIdentifier; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to The identifier that is to be associated with every Device that references this DeviceDefintiion for the issuer and jurisdiction provided in the DeviceDefinition.udiDeviceIdentifier.
    property deviceIdentifier : String read GetDeviceIdentifierST write SetDeviceIdentifierST;
    // The identifier that is to be associated with every Device that references this DeviceDefintiion for the issuer and jurisdiction provided in the DeviceDefinition.udiDeviceIdentifier.
    property deviceIdentifierElement : TFhirString read FDeviceIdentifier write SetDeviceIdentifier;

    // Typed access to The organization that assigns the identifier algorithm.
    property issuer : String read GetIssuerST write SetIssuerST;
    // The organization that assigns the identifier algorithm.
    property issuerElement : TFhirUri read FIssuer write SetIssuer;

    // Typed access to The jurisdiction to which the deviceIdentifier applies.
    property jurisdiction : String read GetJurisdictionST write SetJurisdictionST;
    // The jurisdiction to which the deviceIdentifier applies.
    property jurisdictionElement : TFhirUri read FJurisdiction write SetJurisdiction;

    // Indicates where and when the device is available on the market.
    property marketDistributionList : TFhirDeviceDefinitionUdiDeviceIdentifierMarketDistributionList read GetMarketDistributionList;
    property hasMarketDistributionList : boolean read GetHasMarketDistributionList;

  end;

  TFhirDeviceDefinitionUdiDeviceIdentifierListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirDeviceDefinitionUdiDeviceIdentifierList;
    function GetCurrent : TFhirDeviceDefinitionUdiDeviceIdentifier;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirDeviceDefinitionUdiDeviceIdentifierList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirDeviceDefinitionUdiDeviceIdentifier read GetCurrent;
  end;

  TFhirDeviceDefinitionUdiDeviceIdentifierList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirDeviceDefinitionUdiDeviceIdentifier;
    procedure SetItemN(index : Integer; value : TFhirDeviceDefinitionUdiDeviceIdentifier);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirDeviceDefinitionUdiDeviceIdentifierList; overload;
    function Clone : TFhirDeviceDefinitionUdiDeviceIdentifierList; overload;
    function GetEnumerator : TFhirDeviceDefinitionUdiDeviceIdentifierListEnumerator;
    
    //  Add a FhirDeviceDefinitionUdiDeviceIdentifier to the end of the list.
    function Append : TFhirDeviceDefinitionUdiDeviceIdentifier;
    
    // Add an already existing FhirDeviceDefinitionUdiDeviceIdentifier to the end of the list.
    function AddItem(value : TFhirDeviceDefinitionUdiDeviceIdentifier) : TFhirDeviceDefinitionUdiDeviceIdentifier; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirDeviceDefinitionUdiDeviceIdentifier) : Integer;
    
    // Insert FhirDeviceDefinitionUdiDeviceIdentifier before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirDeviceDefinitionUdiDeviceIdentifier;
    
    // Insert an existing FhirDeviceDefinitionUdiDeviceIdentifier before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirDeviceDefinitionUdiDeviceIdentifier);
    
    // Get the iIndexth FhirDeviceDefinitionUdiDeviceIdentifier. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirDeviceDefinitionUdiDeviceIdentifier);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirDeviceDefinitionUdiDeviceIdentifier;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirDeviceDefinitionUdiDeviceIdentifiers[index : Integer] : TFhirDeviceDefinitionUdiDeviceIdentifier read GetItemN write SetItemN; default;
  End;

  // Indicates where and when the device is available on the market.
  TFhirDeviceDefinitionUdiDeviceIdentifierMarketDistribution = class (TFhirBackboneElement)
  protected
    FMarketPeriod : TFhirPeriod;
    FSubJurisdiction : TFhirUri;
    procedure SetMarketPeriod(value : TFhirPeriod);
    procedure SetSubJurisdiction(value : TFhirUri);
    function GetSubJurisdictionST : String;
    procedure SetSubJurisdictionST(value : String);
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirDeviceDefinitionUdiDeviceIdentifierMarketDistribution; overload;
    function Clone : TFhirDeviceDefinitionUdiDeviceIdentifierMarketDistribution; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to Begin and end dates for the commercial distribution of the device. (defined for API consistency)
    property marketPeriod : TFhirPeriod read FMarketPeriod write SetMarketPeriod;
    // Begin and end dates for the commercial distribution of the device.
    property marketPeriodElement : TFhirPeriod read FMarketPeriod write SetMarketPeriod;

    // Typed access to National state or territory to which the marketDistribution recers, typically where the device is commercialized.
    property subJurisdiction : String read GetSubJurisdictionST write SetSubJurisdictionST;
    // National state or territory to which the marketDistribution recers, typically where the device is commercialized.
    property subJurisdictionElement : TFhirUri read FSubJurisdiction write SetSubJurisdiction;

  end;

  TFhirDeviceDefinitionUdiDeviceIdentifierMarketDistributionListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirDeviceDefinitionUdiDeviceIdentifierMarketDistributionList;
    function GetCurrent : TFhirDeviceDefinitionUdiDeviceIdentifierMarketDistribution;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirDeviceDefinitionUdiDeviceIdentifierMarketDistributionList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirDeviceDefinitionUdiDeviceIdentifierMarketDistribution read GetCurrent;
  end;

  TFhirDeviceDefinitionUdiDeviceIdentifierMarketDistributionList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirDeviceDefinitionUdiDeviceIdentifierMarketDistribution;
    procedure SetItemN(index : Integer; value : TFhirDeviceDefinitionUdiDeviceIdentifierMarketDistribution);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirDeviceDefinitionUdiDeviceIdentifierMarketDistributionList; overload;
    function Clone : TFhirDeviceDefinitionUdiDeviceIdentifierMarketDistributionList; overload;
    function GetEnumerator : TFhirDeviceDefinitionUdiDeviceIdentifierMarketDistributionListEnumerator;
    
    //  Add a FhirDeviceDefinitionUdiDeviceIdentifierMarketDistribution to the end of the list.
    function Append : TFhirDeviceDefinitionUdiDeviceIdentifierMarketDistribution;
    
    // Add an already existing FhirDeviceDefinitionUdiDeviceIdentifierMarketDistribution to the end of the list.
    function AddItem(value : TFhirDeviceDefinitionUdiDeviceIdentifierMarketDistribution) : TFhirDeviceDefinitionUdiDeviceIdentifierMarketDistribution; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirDeviceDefinitionUdiDeviceIdentifierMarketDistribution) : Integer;
    
    // Insert FhirDeviceDefinitionUdiDeviceIdentifierMarketDistribution before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirDeviceDefinitionUdiDeviceIdentifierMarketDistribution;
    
    // Insert an existing FhirDeviceDefinitionUdiDeviceIdentifierMarketDistribution before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirDeviceDefinitionUdiDeviceIdentifierMarketDistribution);
    
    // Get the iIndexth FhirDeviceDefinitionUdiDeviceIdentifierMarketDistribution. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirDeviceDefinitionUdiDeviceIdentifierMarketDistribution);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirDeviceDefinitionUdiDeviceIdentifierMarketDistribution;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirDeviceDefinitionUdiDeviceIdentifierMarketDistributions[index : Integer] : TFhirDeviceDefinitionUdiDeviceIdentifierMarketDistribution read GetItemN write SetItemN; default;
  End;

  // Identifier associated with the regulatory documentation (certificates, technical documentation, post-market surveillance documentation and reports) of a set of device models sharing the same intended purpose, risk class and essential design and manufacturing characteristics. One example is the Basic UDI-DI in Europe.
  TFhirDeviceDefinitionRegulatoryIdentifier = class (TFhirBackboneElement)
  protected
    FType_ : TFhirEnum;
    FDeviceIdentifier : TFhirString;
    FIssuer : TFhirUri;
    FJurisdiction : TFhirUri;
    procedure SetType_(value : TFhirEnum);
    function GetType_ST : TFhirDeviceDefinitionRegulatoryIdentifierTypeEnum;
    procedure SetType_ST(value : TFhirDeviceDefinitionRegulatoryIdentifierTypeEnum);
    procedure SetDeviceIdentifier(value : TFhirString);
    function GetDeviceIdentifierST : String;
    procedure SetDeviceIdentifierST(value : String);
    procedure SetIssuer(value : TFhirUri);
    function GetIssuerST : String;
    procedure SetIssuerST(value : String);
    procedure SetJurisdiction(value : TFhirUri);
    function GetJurisdictionST : String;
    procedure SetJurisdictionST(value : String);
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirDeviceDefinitionRegulatoryIdentifier; overload;
    function Clone : TFhirDeviceDefinitionRegulatoryIdentifier; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // The type of identifier itself.
    property type_ : TFhirDeviceDefinitionRegulatoryIdentifierTypeEnum read GetType_ST write SetType_ST;
    property type_Element : TFhirEnum read FType_ write SetType_;

    // Typed access to The identifier itself.
    property deviceIdentifier : String read GetDeviceIdentifierST write SetDeviceIdentifierST;
    // The identifier itself.
    property deviceIdentifierElement : TFhirString read FDeviceIdentifier write SetDeviceIdentifier;

    // Typed access to The organization that issued this identifier.
    property issuer : String read GetIssuerST write SetIssuerST;
    // The organization that issued this identifier.
    property issuerElement : TFhirUri read FIssuer write SetIssuer;

    // Typed access to The jurisdiction to which the deviceIdentifier applies.
    property jurisdiction : String read GetJurisdictionST write SetJurisdictionST;
    // The jurisdiction to which the deviceIdentifier applies.
    property jurisdictionElement : TFhirUri read FJurisdiction write SetJurisdiction;

  end;

  TFhirDeviceDefinitionRegulatoryIdentifierListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirDeviceDefinitionRegulatoryIdentifierList;
    function GetCurrent : TFhirDeviceDefinitionRegulatoryIdentifier;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirDeviceDefinitionRegulatoryIdentifierList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirDeviceDefinitionRegulatoryIdentifier read GetCurrent;
  end;

  TFhirDeviceDefinitionRegulatoryIdentifierList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirDeviceDefinitionRegulatoryIdentifier;
    procedure SetItemN(index : Integer; value : TFhirDeviceDefinitionRegulatoryIdentifier);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirDeviceDefinitionRegulatoryIdentifierList; overload;
    function Clone : TFhirDeviceDefinitionRegulatoryIdentifierList; overload;
    function GetEnumerator : TFhirDeviceDefinitionRegulatoryIdentifierListEnumerator;
    
    //  Add a FhirDeviceDefinitionRegulatoryIdentifier to the end of the list.
    function Append : TFhirDeviceDefinitionRegulatoryIdentifier;
    
    // Add an already existing FhirDeviceDefinitionRegulatoryIdentifier to the end of the list.
    function AddItem(value : TFhirDeviceDefinitionRegulatoryIdentifier) : TFhirDeviceDefinitionRegulatoryIdentifier; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirDeviceDefinitionRegulatoryIdentifier) : Integer;
    
    // Insert FhirDeviceDefinitionRegulatoryIdentifier before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirDeviceDefinitionRegulatoryIdentifier;
    
    // Insert an existing FhirDeviceDefinitionRegulatoryIdentifier before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirDeviceDefinitionRegulatoryIdentifier);
    
    // Get the iIndexth FhirDeviceDefinitionRegulatoryIdentifier. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirDeviceDefinitionRegulatoryIdentifier);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirDeviceDefinitionRegulatoryIdentifier;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirDeviceDefinitionRegulatoryIdentifiers[index : Integer] : TFhirDeviceDefinitionRegulatoryIdentifier read GetItemN write SetItemN; default;
  End;

  // The name or names of the device as given by the manufacturer.
  TFhirDeviceDefinitionDeviceName = class (TFhirBackboneElement)
  protected
    FName : TFhirString;
    FType_ : TFhirEnum;
    procedure SetName(value : TFhirString);
    function GetNameST : String;
    procedure SetNameST(value : String);
    procedure SetType_(value : TFhirEnum);
    function GetType_ST : TFhirDeviceNameTypeEnum;
    procedure SetType_ST(value : TFhirDeviceNameTypeEnum);
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirDeviceDefinitionDeviceName; overload;
    function Clone : TFhirDeviceDefinitionDeviceName; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to A human-friendly name that is used to refer to the device - depending on the type, it can be the brand name, the common name or alias, or other.
    property name : String read GetNameST write SetNameST;
    // A human-friendly name that is used to refer to the device - depending on the type, it can be the brand name, the common name or alias, or other.
    property nameElement : TFhirString read FName write SetName;

    // The type of deviceName. RegisteredName | UserFriendlyName | PatientReportedName.
    property type_ : TFhirDeviceNameTypeEnum read GetType_ST write SetType_ST;
    property type_Element : TFhirEnum read FType_ write SetType_;

  end;

  TFhirDeviceDefinitionDeviceNameListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirDeviceDefinitionDeviceNameList;
    function GetCurrent : TFhirDeviceDefinitionDeviceName;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirDeviceDefinitionDeviceNameList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirDeviceDefinitionDeviceName read GetCurrent;
  end;

  TFhirDeviceDefinitionDeviceNameList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirDeviceDefinitionDeviceName;
    procedure SetItemN(index : Integer; value : TFhirDeviceDefinitionDeviceName);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirDeviceDefinitionDeviceNameList; overload;
    function Clone : TFhirDeviceDefinitionDeviceNameList; overload;
    function GetEnumerator : TFhirDeviceDefinitionDeviceNameListEnumerator;
    
    //  Add a FhirDeviceDefinitionDeviceName to the end of the list.
    function Append : TFhirDeviceDefinitionDeviceName;
    
    // Add an already existing FhirDeviceDefinitionDeviceName to the end of the list.
    function AddItem(value : TFhirDeviceDefinitionDeviceName) : TFhirDeviceDefinitionDeviceName; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirDeviceDefinitionDeviceName) : Integer;
    
    // Insert FhirDeviceDefinitionDeviceName before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirDeviceDefinitionDeviceName;
    
    // Insert an existing FhirDeviceDefinitionDeviceName before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirDeviceDefinitionDeviceName);
    
    // Get the iIndexth FhirDeviceDefinitionDeviceName. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirDeviceDefinitionDeviceName);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirDeviceDefinitionDeviceName;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirDeviceDefinitionDeviceNames[index : Integer] : TFhirDeviceDefinitionDeviceName read GetItemN write SetItemN; default;
  End;

  // What kind of device or device system this is.
  TFhirDeviceDefinitionClassification = class (TFhirBackboneElement)
  protected
    FType_ : TFhirCodeableConcept;
    FjustificationList : TFhirRelatedArtifactList;
    procedure SetType_(value : TFhirCodeableConcept);
    function GetJustificationList : TFhirRelatedArtifactList;
    function GetHasJustificationList : Boolean;
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirDeviceDefinitionClassification; overload;
    function Clone : TFhirDeviceDefinitionClassification; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to A classification or risk class of the device model. (defined for API consistency)
    property type_ : TFhirCodeableConcept read FType_ write SetType_;
    // A classification or risk class of the device model.
    property type_Element : TFhirCodeableConcept read FType_ write SetType_;

    // Further information qualifying this classification of the device model.
    property justificationList : TFhirRelatedArtifactList read GetJustificationList;
    property hasJustificationList : boolean read GetHasJustificationList;

  end;

  TFhirDeviceDefinitionClassificationListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirDeviceDefinitionClassificationList;
    function GetCurrent : TFhirDeviceDefinitionClassification;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirDeviceDefinitionClassificationList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirDeviceDefinitionClassification read GetCurrent;
  end;

  TFhirDeviceDefinitionClassificationList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirDeviceDefinitionClassification;
    procedure SetItemN(index : Integer; value : TFhirDeviceDefinitionClassification);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirDeviceDefinitionClassificationList; overload;
    function Clone : TFhirDeviceDefinitionClassificationList; overload;
    function GetEnumerator : TFhirDeviceDefinitionClassificationListEnumerator;
    
    //  Add a FhirDeviceDefinitionClassification to the end of the list.
    function Append : TFhirDeviceDefinitionClassification;
    
    // Add an already existing FhirDeviceDefinitionClassification to the end of the list.
    function AddItem(value : TFhirDeviceDefinitionClassification) : TFhirDeviceDefinitionClassification; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirDeviceDefinitionClassification) : Integer;
    
    // Insert FhirDeviceDefinitionClassification before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirDeviceDefinitionClassification;
    
    // Insert an existing FhirDeviceDefinitionClassification before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirDeviceDefinitionClassification);
    
    // Get the iIndexth FhirDeviceDefinitionClassification. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirDeviceDefinitionClassification);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirDeviceDefinitionClassification;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirDeviceDefinitionClassifications[index : Integer] : TFhirDeviceDefinitionClassification read GetItemN write SetItemN; default;
  End;

  // A device that is part (for example a component) of the present device.
  TFhirDeviceDefinitionHasPart = class (TFhirBackboneElement)
  protected
    FReference : TFhirReference;
    FCount : TFhirInteger;
    procedure SetReference(value : TFhirReference);
    procedure SetCount(value : TFhirInteger);
    function GetCountST : String;
    procedure SetCountST(value : String);
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirDeviceDefinitionHasPart; overload;
    function Clone : TFhirDeviceDefinitionHasPart; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to Reference to the device that is part of the current device. (defined for API consistency)
    property reference : TFhirReference read FReference write SetReference;
    // Reference to the device that is part of the current device.
    property referenceElement : TFhirReference read FReference write SetReference;

    // Typed access to Number of instances of the component device in the current device.
    property count : String read GetCountST write SetCountST;
    // Number of instances of the component device in the current device.
    property countElement : TFhirInteger read FCount write SetCount;

  end;

  TFhirDeviceDefinitionHasPartListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirDeviceDefinitionHasPartList;
    function GetCurrent : TFhirDeviceDefinitionHasPart;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirDeviceDefinitionHasPartList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirDeviceDefinitionHasPart read GetCurrent;
  end;

  TFhirDeviceDefinitionHasPartList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirDeviceDefinitionHasPart;
    procedure SetItemN(index : Integer; value : TFhirDeviceDefinitionHasPart);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirDeviceDefinitionHasPartList; overload;
    function Clone : TFhirDeviceDefinitionHasPartList; overload;
    function GetEnumerator : TFhirDeviceDefinitionHasPartListEnumerator;
    
    //  Add a FhirDeviceDefinitionHasPart to the end of the list.
    function Append : TFhirDeviceDefinitionHasPart;
    
    // Add an already existing FhirDeviceDefinitionHasPart to the end of the list.
    function AddItem(value : TFhirDeviceDefinitionHasPart) : TFhirDeviceDefinitionHasPart; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirDeviceDefinitionHasPart) : Integer;
    
    // Insert FhirDeviceDefinitionHasPart before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirDeviceDefinitionHasPart;
    
    // Insert an existing FhirDeviceDefinitionHasPart before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirDeviceDefinitionHasPart);
    
    // Get the iIndexth FhirDeviceDefinitionHasPart. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirDeviceDefinitionHasPart);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirDeviceDefinitionHasPart;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirDeviceDefinitionHasParts[index : Integer] : TFhirDeviceDefinitionHasPart read GetItemN write SetItemN; default;
  End;

  // Information about the packaging of the device, i.e. how the device is packaged.
  TFhirDeviceDefinitionPackaging = class (TFhirBackboneElement)
  protected
    FIdentifier : TFhirIdentifier;
    FType_ : TFhirCodeableConcept;
    FCount : TFhirInteger;
    FdistributorList : TFhirDeviceDefinitionPackagingDistributorList;
    FudiDeviceIdentifierList : TFhirDeviceDefinitionUdiDeviceIdentifierList;
    FpackagingList : TFhirDeviceDefinitionPackagingList;
    procedure SetIdentifier(value : TFhirIdentifier);
    procedure SetType_(value : TFhirCodeableConcept);
    procedure SetCount(value : TFhirInteger);
    function GetCountST : String;
    procedure SetCountST(value : String);
    function GetDistributorList : TFhirDeviceDefinitionPackagingDistributorList;
    function GetHasDistributorList : Boolean;
    function GetUdiDeviceIdentifierList : TFhirDeviceDefinitionUdiDeviceIdentifierList;
    function GetHasUdiDeviceIdentifierList : Boolean;
    function GetPackagingList : TFhirDeviceDefinitionPackagingList;
    function GetHasPackagingList : Boolean;
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirDeviceDefinitionPackaging; overload;
    function Clone : TFhirDeviceDefinitionPackaging; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to The business identifier of the packaged medication. (defined for API consistency)
    property identifier : TFhirIdentifier read FIdentifier write SetIdentifier;
    // The business identifier of the packaged medication.
    property identifierElement : TFhirIdentifier read FIdentifier write SetIdentifier;

    // Typed access to A code that defines the specific type of packaging. (defined for API consistency)
    property type_ : TFhirCodeableConcept read FType_ write SetType_;
    // A code that defines the specific type of packaging.
    property type_Element : TFhirCodeableConcept read FType_ write SetType_;

    // Typed access to The number of items contained in the package (devices or sub-packages).
    property count : String read GetCountST write SetCountST;
    // The number of items contained in the package (devices or sub-packages).
    property countElement : TFhirInteger read FCount write SetCount;

    // An organization that distributes the packaged device.
    property distributorList : TFhirDeviceDefinitionPackagingDistributorList read GetDistributorList;
    property hasDistributorList : boolean read GetHasDistributorList;

    // Unique Device Identifier (UDI) Barcode string on the packaging.
    property udiDeviceIdentifierList : TFhirDeviceDefinitionUdiDeviceIdentifierList read GetUdiDeviceIdentifierList;
    property hasUdiDeviceIdentifierList : boolean read GetHasUdiDeviceIdentifierList;

    // Allows packages within packages.
    property packagingList : TFhirDeviceDefinitionPackagingList read GetPackagingList;
    property hasPackagingList : boolean read GetHasPackagingList;

  end;

  TFhirDeviceDefinitionPackagingListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirDeviceDefinitionPackagingList;
    function GetCurrent : TFhirDeviceDefinitionPackaging;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirDeviceDefinitionPackagingList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirDeviceDefinitionPackaging read GetCurrent;
  end;

  TFhirDeviceDefinitionPackagingList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirDeviceDefinitionPackaging;
    procedure SetItemN(index : Integer; value : TFhirDeviceDefinitionPackaging);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirDeviceDefinitionPackagingList; overload;
    function Clone : TFhirDeviceDefinitionPackagingList; overload;
    function GetEnumerator : TFhirDeviceDefinitionPackagingListEnumerator;
    
    //  Add a FhirDeviceDefinitionPackaging to the end of the list.
    function Append : TFhirDeviceDefinitionPackaging;
    
    // Add an already existing FhirDeviceDefinitionPackaging to the end of the list.
    function AddItem(value : TFhirDeviceDefinitionPackaging) : TFhirDeviceDefinitionPackaging; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirDeviceDefinitionPackaging) : Integer;
    
    // Insert FhirDeviceDefinitionPackaging before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirDeviceDefinitionPackaging;
    
    // Insert an existing FhirDeviceDefinitionPackaging before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirDeviceDefinitionPackaging);
    
    // Get the iIndexth FhirDeviceDefinitionPackaging. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirDeviceDefinitionPackaging);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirDeviceDefinitionPackaging;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirDeviceDefinitionPackagings[index : Integer] : TFhirDeviceDefinitionPackaging read GetItemN write SetItemN; default;
  End;

  // An organization that distributes the packaged device.
  TFhirDeviceDefinitionPackagingDistributor = class (TFhirBackboneElement)
  protected
    FName : TFhirString;
    ForganizationReferenceList : TFhirReferenceList;
    procedure SetName(value : TFhirString);
    function GetNameST : String;
    procedure SetNameST(value : String);
    function GetOrganizationReferenceList : TFhirReferenceList;
    function GetHasOrganizationReferenceList : Boolean;
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirDeviceDefinitionPackagingDistributor; overload;
    function Clone : TFhirDeviceDefinitionPackagingDistributor; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to Distributor's human-readable name.
    property name : String read GetNameST write SetNameST;
    // Distributor's human-readable name.
    property nameElement : TFhirString read FName write SetName;

    // Distributor as an Organization resource.
    property organizationReferenceList : TFhirReferenceList read GetOrganizationReferenceList;
    property hasOrganizationReferenceList : boolean read GetHasOrganizationReferenceList;

  end;

  TFhirDeviceDefinitionPackagingDistributorListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirDeviceDefinitionPackagingDistributorList;
    function GetCurrent : TFhirDeviceDefinitionPackagingDistributor;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirDeviceDefinitionPackagingDistributorList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirDeviceDefinitionPackagingDistributor read GetCurrent;
  end;

  TFhirDeviceDefinitionPackagingDistributorList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirDeviceDefinitionPackagingDistributor;
    procedure SetItemN(index : Integer; value : TFhirDeviceDefinitionPackagingDistributor);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirDeviceDefinitionPackagingDistributorList; overload;
    function Clone : TFhirDeviceDefinitionPackagingDistributorList; overload;
    function GetEnumerator : TFhirDeviceDefinitionPackagingDistributorListEnumerator;
    
    //  Add a FhirDeviceDefinitionPackagingDistributor to the end of the list.
    function Append : TFhirDeviceDefinitionPackagingDistributor;
    
    // Add an already existing FhirDeviceDefinitionPackagingDistributor to the end of the list.
    function AddItem(value : TFhirDeviceDefinitionPackagingDistributor) : TFhirDeviceDefinitionPackagingDistributor; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirDeviceDefinitionPackagingDistributor) : Integer;
    
    // Insert FhirDeviceDefinitionPackagingDistributor before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirDeviceDefinitionPackagingDistributor;
    
    // Insert an existing FhirDeviceDefinitionPackagingDistributor before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirDeviceDefinitionPackagingDistributor);
    
    // Get the iIndexth FhirDeviceDefinitionPackagingDistributor. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirDeviceDefinitionPackagingDistributor);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirDeviceDefinitionPackagingDistributor;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirDeviceDefinitionPackagingDistributors[index : Integer] : TFhirDeviceDefinitionPackagingDistributor read GetItemN write SetItemN; default;
  End;

  // The version of the device or software.
  TFhirDeviceDefinitionVersion = class (TFhirBackboneElement)
  protected
    FType_ : TFhirCodeableConcept;
    FComponent : TFhirIdentifier;
    FValue : TFhirString;
    procedure SetType_(value : TFhirCodeableConcept);
    procedure SetComponent(value : TFhirIdentifier);
    procedure SetValue(value : TFhirString);
    function GetValueST : String;
    procedure SetValueST(value : String);
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirDeviceDefinitionVersion; overload;
    function Clone : TFhirDeviceDefinitionVersion; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to The type of the device version, e.g. manufacturer, approved, internal. (defined for API consistency)
    property type_ : TFhirCodeableConcept read FType_ write SetType_;
    // The type of the device version, e.g. manufacturer, approved, internal.
    property type_Element : TFhirCodeableConcept read FType_ write SetType_;

    // Typed access to The hardware or software module of the device to which the version applies. (defined for API consistency)
    property component : TFhirIdentifier read FComponent write SetComponent;
    // The hardware or software module of the device to which the version applies.
    property componentElement : TFhirIdentifier read FComponent write SetComponent;

    // Typed access to The version text.
    property value : String read GetValueST write SetValueST;
    // The version text.
    property valueElement : TFhirString read FValue write SetValue;

  end;

  TFhirDeviceDefinitionVersionListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirDeviceDefinitionVersionList;
    function GetCurrent : TFhirDeviceDefinitionVersion;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirDeviceDefinitionVersionList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirDeviceDefinitionVersion read GetCurrent;
  end;

  TFhirDeviceDefinitionVersionList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirDeviceDefinitionVersion;
    procedure SetItemN(index : Integer; value : TFhirDeviceDefinitionVersion);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirDeviceDefinitionVersionList; overload;
    function Clone : TFhirDeviceDefinitionVersionList; overload;
    function GetEnumerator : TFhirDeviceDefinitionVersionListEnumerator;
    
    //  Add a FhirDeviceDefinitionVersion to the end of the list.
    function Append : TFhirDeviceDefinitionVersion;
    
    // Add an already existing FhirDeviceDefinitionVersion to the end of the list.
    function AddItem(value : TFhirDeviceDefinitionVersion) : TFhirDeviceDefinitionVersion; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirDeviceDefinitionVersion) : Integer;
    
    // Insert FhirDeviceDefinitionVersion before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirDeviceDefinitionVersion;
    
    // Insert an existing FhirDeviceDefinitionVersion before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirDeviceDefinitionVersion);
    
    // Get the iIndexth FhirDeviceDefinitionVersion. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirDeviceDefinitionVersion);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirDeviceDefinitionVersion;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirDeviceDefinitionVersions[index : Integer] : TFhirDeviceDefinitionVersion read GetItemN write SetItemN; default;
  End;

  // The potential, valid configuration settings of a device, e.g., regulation status, time properties.
  TFhirDeviceDefinitionProperty = class (TFhirBackboneElement)
  protected
    FType_ : TFhirCodeableConcept;
    FValue : TFhirDataType;
    procedure SetType_(value : TFhirCodeableConcept);
    procedure SetValue(value : TFhirDataType);
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirDeviceDefinitionProperty; overload;
    function Clone : TFhirDeviceDefinitionProperty; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to Code that specifies the property. (defined for API consistency)
    property type_ : TFhirCodeableConcept read FType_ write SetType_;
    // Code that specifies the property.
    property type_Element : TFhirCodeableConcept read FType_ write SetType_;

    // Typed access to Property value - the data type depends on the property type. (defined for API consistency)
    property value : TFhirDataType read FValue write SetValue;
    // Property value - the data type depends on the property type.
    property valueElement : TFhirDataType read FValue write SetValue;

  end;

  TFhirDeviceDefinitionPropertyListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirDeviceDefinitionPropertyList;
    function GetCurrent : TFhirDeviceDefinitionProperty;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirDeviceDefinitionPropertyList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirDeviceDefinitionProperty read GetCurrent;
  end;

  TFhirDeviceDefinitionPropertyList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirDeviceDefinitionProperty;
    procedure SetItemN(index : Integer; value : TFhirDeviceDefinitionProperty);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirDeviceDefinitionPropertyList; overload;
    function Clone : TFhirDeviceDefinitionPropertyList; overload;
    function GetEnumerator : TFhirDeviceDefinitionPropertyListEnumerator;
    
    //  Add a FhirDeviceDefinitionProperty to the end of the list.
    function Append : TFhirDeviceDefinitionProperty;
    
    // Add an already existing FhirDeviceDefinitionProperty to the end of the list.
    function AddItem(value : TFhirDeviceDefinitionProperty) : TFhirDeviceDefinitionProperty; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirDeviceDefinitionProperty) : Integer;
    
    // Insert FhirDeviceDefinitionProperty before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirDeviceDefinitionProperty;
    
    // Insert an existing FhirDeviceDefinitionProperty before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirDeviceDefinitionProperty);
    
    // Get the iIndexth FhirDeviceDefinitionProperty. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirDeviceDefinitionProperty);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirDeviceDefinitionProperty;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirDeviceDefinitionProperties[index : Integer] : TFhirDeviceDefinitionProperty read GetItemN write SetItemN; default;
  End;

  // An associated device, attached to, used with, communicating with or linking a previous or new device model to the focal device.
  TFhirDeviceDefinitionLink = class (TFhirBackboneElement)
  protected
    FRelation : TFhirCoding;
    FRelatedDevice : TFhirCodeableReference;
    procedure SetRelation(value : TFhirCoding);
    procedure SetRelatedDevice(value : TFhirCodeableReference);
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirDeviceDefinitionLink; overload;
    function Clone : TFhirDeviceDefinitionLink; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to The type indicates the relationship of the related device to the device instance. (defined for API consistency)
    property relation : TFhirCoding read FRelation write SetRelation;
    // The type indicates the relationship of the related device to the device instance.
    property relationElement : TFhirCoding read FRelation write SetRelation;

    // Typed access to A reference to the linked device. (defined for API consistency)
    property relatedDevice : TFhirCodeableReference read FRelatedDevice write SetRelatedDevice;
    // A reference to the linked device.
    property relatedDeviceElement : TFhirCodeableReference read FRelatedDevice write SetRelatedDevice;

  end;

  TFhirDeviceDefinitionLinkListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirDeviceDefinitionLinkList;
    function GetCurrent : TFhirDeviceDefinitionLink;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirDeviceDefinitionLinkList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirDeviceDefinitionLink read GetCurrent;
  end;

  TFhirDeviceDefinitionLinkList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirDeviceDefinitionLink;
    procedure SetItemN(index : Integer; value : TFhirDeviceDefinitionLink);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirDeviceDefinitionLinkList; overload;
    function Clone : TFhirDeviceDefinitionLinkList; overload;
    function GetEnumerator : TFhirDeviceDefinitionLinkListEnumerator;
    
    //  Add a FhirDeviceDefinitionLink to the end of the list.
    function Append : TFhirDeviceDefinitionLink;
    
    // Add an already existing FhirDeviceDefinitionLink to the end of the list.
    function AddItem(value : TFhirDeviceDefinitionLink) : TFhirDeviceDefinitionLink; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirDeviceDefinitionLink) : Integer;
    
    // Insert FhirDeviceDefinitionLink before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirDeviceDefinitionLink;
    
    // Insert an existing FhirDeviceDefinitionLink before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirDeviceDefinitionLink);
    
    // Get the iIndexth FhirDeviceDefinitionLink. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirDeviceDefinitionLink);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirDeviceDefinitionLink;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirDeviceDefinitionLinks[index : Integer] : TFhirDeviceDefinitionLink read GetItemN write SetItemN; default;
  End;

  // A substance used to create the material(s) of which the device is made.
  TFhirDeviceDefinitionMaterial = class (TFhirBackboneElement)
  protected
    FSubstance : TFhirCodeableConcept;
    FAlternate : TFhirBoolean;
    FAllergenicIndicator : TFhirBoolean;
    procedure SetSubstance(value : TFhirCodeableConcept);
    procedure SetAlternate(value : TFhirBoolean);
    function GetAlternateST : Boolean;
    procedure SetAlternateST(value : Boolean);
    procedure SetAllergenicIndicator(value : TFhirBoolean);
    function GetAllergenicIndicatorST : Boolean;
    procedure SetAllergenicIndicatorST(value : Boolean);
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirDeviceDefinitionMaterial; overload;
    function Clone : TFhirDeviceDefinitionMaterial; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to A substance that the device contains, may contain, or is made of - for example latex - to be used to determine patient compatibility. This is not intended to represent the composition of the device, only the clinically relevant materials. (defined for API consistency)
    property substance : TFhirCodeableConcept read FSubstance write SetSubstance;
    // A substance that the device contains, may contain, or is made of - for example latex - to be used to determine patient compatibility. This is not intended to represent the composition of the device, only the clinically relevant materials.
    property substanceElement : TFhirCodeableConcept read FSubstance write SetSubstance;

    // Typed access to Indicates an alternative material of the device.
    property alternate : Boolean read GetAlternateST write SetAlternateST;
    // Indicates an alternative material of the device.
    property alternateElement : TFhirBoolean read FAlternate write SetAlternate;

    // Typed access to Whether the substance is a known or suspected allergen.
    property allergenicIndicator : Boolean read GetAllergenicIndicatorST write SetAllergenicIndicatorST;
    // Whether the substance is a known or suspected allergen.
    property allergenicIndicatorElement : TFhirBoolean read FAllergenicIndicator write SetAllergenicIndicator;

  end;

  TFhirDeviceDefinitionMaterialListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirDeviceDefinitionMaterialList;
    function GetCurrent : TFhirDeviceDefinitionMaterial;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirDeviceDefinitionMaterialList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirDeviceDefinitionMaterial read GetCurrent;
  end;

  TFhirDeviceDefinitionMaterialList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirDeviceDefinitionMaterial;
    procedure SetItemN(index : Integer; value : TFhirDeviceDefinitionMaterial);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirDeviceDefinitionMaterialList; overload;
    function Clone : TFhirDeviceDefinitionMaterialList; overload;
    function GetEnumerator : TFhirDeviceDefinitionMaterialListEnumerator;
    
    //  Add a FhirDeviceDefinitionMaterial to the end of the list.
    function Append : TFhirDeviceDefinitionMaterial;
    
    // Add an already existing FhirDeviceDefinitionMaterial to the end of the list.
    function AddItem(value : TFhirDeviceDefinitionMaterial) : TFhirDeviceDefinitionMaterial; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirDeviceDefinitionMaterial) : Integer;
    
    // Insert FhirDeviceDefinitionMaterial before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirDeviceDefinitionMaterial;
    
    // Insert an existing FhirDeviceDefinitionMaterial before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirDeviceDefinitionMaterial);
    
    // Get the iIndexth FhirDeviceDefinitionMaterial. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirDeviceDefinitionMaterial);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirDeviceDefinitionMaterial;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirDeviceDefinitionMaterials[index : Integer] : TFhirDeviceDefinitionMaterial read GetItemN write SetItemN; default;
  End;

  // Information aimed at providing directions for the usage of this model of device.
  TFhirDeviceDefinitionGuideline = class (TFhirBackboneElement)
  protected
    FuseContextList : TFhirUsageContextList;
    FUsageInstruction : TFhirMarkdown;
    FrelatedArtifactList : TFhirRelatedArtifactList;
    FindicationList : TFhirCodeableReferenceList;
    FcontraindicationList : TFhirCodeableReferenceList;
    FwarningList : TFhirCodeableReferenceList;
    FIntendedUse : TFhirString;
    function GetUseContextList : TFhirUsageContextList;
    function GetHasUseContextList : Boolean;
    procedure SetUsageInstruction(value : TFhirMarkdown);
    function GetUsageInstructionST : String;
    procedure SetUsageInstructionST(value : String);
    function GetRelatedArtifactList : TFhirRelatedArtifactList;
    function GetHasRelatedArtifactList : Boolean;
    function GetIndicationList : TFhirCodeableReferenceList;
    function GetHasIndicationList : Boolean;
    function GetContraindicationList : TFhirCodeableReferenceList;
    function GetHasContraindicationList : Boolean;
    function GetWarningList : TFhirCodeableReferenceList;
    function GetHasWarningList : Boolean;
    procedure SetIntendedUse(value : TFhirString);
    function GetIntendedUseST : String;
    procedure SetIntendedUseST(value : String);
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirDeviceDefinitionGuideline; overload;
    function Clone : TFhirDeviceDefinitionGuideline; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // The circumstances that form the setting for using the device.
    property useContextList : TFhirUsageContextList read GetUseContextList;
    property hasUseContextList : boolean read GetHasUseContextList;

    // Typed access to Detailed written and visual directions for the user on how to use the device.
    property usageInstruction : String read GetUsageInstructionST write SetUsageInstructionST;
    // Detailed written and visual directions for the user on how to use the device.
    property usageInstructionElement : TFhirMarkdown read FUsageInstruction write SetUsageInstruction;

    // A source of information or reference for this guideline.
    property relatedArtifactList : TFhirRelatedArtifactList read GetRelatedArtifactList;
    property hasRelatedArtifactList : boolean read GetHasRelatedArtifactList;

    // A clinical condition for which the device was designed to be used.
    property indicationList : TFhirCodeableReferenceList read GetIndicationList;
    property hasIndicationList : boolean read GetHasIndicationList;

    // A specific situation when a device should not be used because it may cause harm.
    property contraindicationList : TFhirCodeableReferenceList read GetContraindicationList;
    property hasContraindicationList : boolean read GetHasContraindicationList;

    // Specific hazard alert information that a user needs to know before using the device.
    property warningList : TFhirCodeableReferenceList read GetWarningList;
    property hasWarningList : boolean read GetHasWarningList;

    // Typed access to A description of the general purpose or medical use of the device or its function.
    property intendedUse : String read GetIntendedUseST write SetIntendedUseST;
    // A description of the general purpose or medical use of the device or its function.
    property intendedUseElement : TFhirString read FIntendedUse write SetIntendedUse;

  end;

  TFhirDeviceDefinitionGuidelineListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirDeviceDefinitionGuidelineList;
    function GetCurrent : TFhirDeviceDefinitionGuideline;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirDeviceDefinitionGuidelineList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirDeviceDefinitionGuideline read GetCurrent;
  end;

  TFhirDeviceDefinitionGuidelineList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirDeviceDefinitionGuideline;
    procedure SetItemN(index : Integer; value : TFhirDeviceDefinitionGuideline);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirDeviceDefinitionGuidelineList; overload;
    function Clone : TFhirDeviceDefinitionGuidelineList; overload;
    function GetEnumerator : TFhirDeviceDefinitionGuidelineListEnumerator;
    
    //  Add a FhirDeviceDefinitionGuideline to the end of the list.
    function Append : TFhirDeviceDefinitionGuideline;
    
    // Add an already existing FhirDeviceDefinitionGuideline to the end of the list.
    function AddItem(value : TFhirDeviceDefinitionGuideline) : TFhirDeviceDefinitionGuideline; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirDeviceDefinitionGuideline) : Integer;
    
    // Insert FhirDeviceDefinitionGuideline before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirDeviceDefinitionGuideline;
    
    // Insert an existing FhirDeviceDefinitionGuideline before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirDeviceDefinitionGuideline);
    
    // Get the iIndexth FhirDeviceDefinitionGuideline. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirDeviceDefinitionGuideline);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirDeviceDefinitionGuideline;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirDeviceDefinitionGuidelines[index : Integer] : TFhirDeviceDefinitionGuideline read GetItemN write SetItemN; default;
  End;

  // Tracking of latest field safety corrective action.
  TFhirDeviceDefinitionCorrectiveAction = class (TFhirBackboneElement)
  protected
    FRecall : TFhirBoolean;
    FScope : TFhirEnum;
    FPeriod : TFhirPeriod;
    procedure SetRecall(value : TFhirBoolean);
    function GetRecallST : Boolean;
    procedure SetRecallST(value : Boolean);
    procedure SetScope(value : TFhirEnum);
    function GetScopeST : TFhirDeviceCorrectiveActionScopeEnum;
    procedure SetScopeST(value : TFhirDeviceCorrectiveActionScopeEnum);
    procedure SetPeriod(value : TFhirPeriod);
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirDeviceDefinitionCorrectiveAction; overload;
    function Clone : TFhirDeviceDefinitionCorrectiveAction; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to Whether the last corrective action known for this device was a recall.
    property recall : Boolean read GetRecallST write SetRecallST;
    // Whether the last corrective action known for this device was a recall.
    property recallElement : TFhirBoolean read FRecall write SetRecall;

    // The scope of the corrective action - whether the action targeted all units of a given device model, or only a specific set of batches identified by lot numbers, or individually identified devices identified by the serial name.
    property scope : TFhirDeviceCorrectiveActionScopeEnum read GetScopeST write SetScopeST;
    property scopeElement : TFhirEnum read FScope write SetScope;

    // Typed access to Start and end dates of the  corrective action. (defined for API consistency)
    property period : TFhirPeriod read FPeriod write SetPeriod;
    // Start and end dates of the  corrective action.
    property periodElement : TFhirPeriod read FPeriod write SetPeriod;

  end;

  TFhirDeviceDefinitionCorrectiveActionListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirDeviceDefinitionCorrectiveActionList;
    function GetCurrent : TFhirDeviceDefinitionCorrectiveAction;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirDeviceDefinitionCorrectiveActionList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirDeviceDefinitionCorrectiveAction read GetCurrent;
  end;

  TFhirDeviceDefinitionCorrectiveActionList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirDeviceDefinitionCorrectiveAction;
    procedure SetItemN(index : Integer; value : TFhirDeviceDefinitionCorrectiveAction);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirDeviceDefinitionCorrectiveActionList; overload;
    function Clone : TFhirDeviceDefinitionCorrectiveActionList; overload;
    function GetEnumerator : TFhirDeviceDefinitionCorrectiveActionListEnumerator;
    
    //  Add a FhirDeviceDefinitionCorrectiveAction to the end of the list.
    function Append : TFhirDeviceDefinitionCorrectiveAction;
    
    // Add an already existing FhirDeviceDefinitionCorrectiveAction to the end of the list.
    function AddItem(value : TFhirDeviceDefinitionCorrectiveAction) : TFhirDeviceDefinitionCorrectiveAction; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirDeviceDefinitionCorrectiveAction) : Integer;
    
    // Insert FhirDeviceDefinitionCorrectiveAction before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirDeviceDefinitionCorrectiveAction;
    
    // Insert an existing FhirDeviceDefinitionCorrectiveAction before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirDeviceDefinitionCorrectiveAction);
    
    // Get the iIndexth FhirDeviceDefinitionCorrectiveAction. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirDeviceDefinitionCorrectiveAction);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirDeviceDefinitionCorrectiveAction;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirDeviceDefinitionCorrectiveActions[index : Integer] : TFhirDeviceDefinitionCorrectiveAction read GetItemN write SetItemN; default;
  End;

  // Billing code or reference associated with the device.
  TFhirDeviceDefinitionChargeItem = class (TFhirBackboneElement)
  protected
    FChargeItemCode : TFhirCodeableReference;
    FCount : TFhirQuantity;
    FEffectivePeriod : TFhirPeriod;
    FuseContextList : TFhirUsageContextList;
    procedure SetChargeItemCode(value : TFhirCodeableReference);
    procedure SetCount(value : TFhirQuantity);
    procedure SetEffectivePeriod(value : TFhirPeriod);
    function GetUseContextList : TFhirUsageContextList;
    function GetHasUseContextList : Boolean;
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirDeviceDefinitionChargeItem; overload;
    function Clone : TFhirDeviceDefinitionChargeItem; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to The code or reference for the charge item. (defined for API consistency)
    property chargeItemCode : TFhirCodeableReference read FChargeItemCode write SetChargeItemCode;
    // The code or reference for the charge item.
    property chargeItemCodeElement : TFhirCodeableReference read FChargeItemCode write SetChargeItemCode;

    // Typed access to Coefficient applicable to the billing code. (defined for API consistency)
    property count : TFhirQuantity read FCount write SetCount;
    // Coefficient applicable to the billing code.
    property countElement : TFhirQuantity read FCount write SetCount;

    // Typed access to A specific time period in which this charge item applies. (defined for API consistency)
    property effectivePeriod : TFhirPeriod read FEffectivePeriod write SetEffectivePeriod;
    // A specific time period in which this charge item applies.
    property effectivePeriodElement : TFhirPeriod read FEffectivePeriod write SetEffectivePeriod;

    // The context to which this charge item applies.
    property useContextList : TFhirUsageContextList read GetUseContextList;
    property hasUseContextList : boolean read GetHasUseContextList;

  end;

  TFhirDeviceDefinitionChargeItemListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirDeviceDefinitionChargeItemList;
    function GetCurrent : TFhirDeviceDefinitionChargeItem;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirDeviceDefinitionChargeItemList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirDeviceDefinitionChargeItem read GetCurrent;
  end;

  TFhirDeviceDefinitionChargeItemList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirDeviceDefinitionChargeItem;
    procedure SetItemN(index : Integer; value : TFhirDeviceDefinitionChargeItem);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirDeviceDefinitionChargeItemList; overload;
    function Clone : TFhirDeviceDefinitionChargeItemList; overload;
    function GetEnumerator : TFhirDeviceDefinitionChargeItemListEnumerator;
    
    //  Add a FhirDeviceDefinitionChargeItem to the end of the list.
    function Append : TFhirDeviceDefinitionChargeItem;
    
    // Add an already existing FhirDeviceDefinitionChargeItem to the end of the list.
    function AddItem(value : TFhirDeviceDefinitionChargeItem) : TFhirDeviceDefinitionChargeItem; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirDeviceDefinitionChargeItem) : Integer;
    
    // Insert FhirDeviceDefinitionChargeItem before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirDeviceDefinitionChargeItem;
    
    // Insert an existing FhirDeviceDefinitionChargeItem before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirDeviceDefinitionChargeItem);
    
    // Get the iIndexth FhirDeviceDefinitionChargeItem. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirDeviceDefinitionChargeItem);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirDeviceDefinitionChargeItem;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirDeviceDefinitionChargeItems[index : Integer] : TFhirDeviceDefinitionChargeItem read GetItemN write SetItemN; default;
  End;

  // The characteristics, operational status and capabilities of a medical-related component of a medical device.
  TFhirDeviceDefinition = class (TFhirDomainResource)
  protected
    FDescription : TFhirMarkdown;
    FidentifierList : TFhirIdentifierList;
    FudiDeviceIdentifierList : TFhirDeviceDefinitionUdiDeviceIdentifierList;
    FregulatoryIdentifierList : TFhirDeviceDefinitionRegulatoryIdentifierList;
    FPartNumber : TFhirString;
    FManufacturer : TFhirReference;
    FdeviceNameList : TFhirDeviceDefinitionDeviceNameList;
    FModelNumber : TFhirString;
    FclassificationList : TFhirDeviceDefinitionClassificationList;
    FspecializationList : TFhirRelatedArtifactList;
    FhasPartList : TFhirDeviceDefinitionHasPartList;
    FpackagingList : TFhirDeviceDefinitionPackagingList;
    FversionList : TFhirDeviceDefinitionVersionList;
    FsafetyList : TFhirCodeableConceptList;
    FshelfLifeStorageList : TFhirProductShelfLifeList;
    FlanguageCodeList : TFhirCodeableConceptList;
    Fproperty_List : TFhirDeviceDefinitionPropertyList;
    FOwner : TFhirReference;
    FcontactList : TFhirContactPointList;
    Flink_List : TFhirDeviceDefinitionLinkList;
    FnoteList : TFhirAnnotationList;
    FParentDevice : TFhirReference;
    FmaterialList : TFhirDeviceDefinitionMaterialList;
    FProductionIdentifierInUDI : TFhirEnumList;
    FGuideline : TFhirDeviceDefinitionGuideline;
    FCorrectiveAction : TFhirDeviceDefinitionCorrectiveAction;
    FchargeItemList : TFhirDeviceDefinitionChargeItemList;
    procedure SetDescription(value : TFhirMarkdown);
    function GetDescriptionST : String;
    procedure SetDescriptionST(value : String);
    function GetIdentifierList : TFhirIdentifierList;
    function GetHasIdentifierList : Boolean;
    function GetUdiDeviceIdentifierList : TFhirDeviceDefinitionUdiDeviceIdentifierList;
    function GetHasUdiDeviceIdentifierList : Boolean;
    function GetRegulatoryIdentifierList : TFhirDeviceDefinitionRegulatoryIdentifierList;
    function GetHasRegulatoryIdentifierList : Boolean;
    procedure SetPartNumber(value : TFhirString);
    function GetPartNumberST : String;
    procedure SetPartNumberST(value : String);
    procedure SetManufacturer(value : TFhirReference);
    function GetDeviceNameList : TFhirDeviceDefinitionDeviceNameList;
    function GetHasDeviceNameList : Boolean;
    procedure SetModelNumber(value : TFhirString);
    function GetModelNumberST : String;
    procedure SetModelNumberST(value : String);
    function GetClassificationList : TFhirDeviceDefinitionClassificationList;
    function GetHasClassificationList : Boolean;
    function GetSpecializationList : TFhirRelatedArtifactList;
    function GetHasSpecializationList : Boolean;
    function GetHasPartList : TFhirDeviceDefinitionHasPartList;
    function GetHasHasPartList : Boolean;
    function GetPackagingList : TFhirDeviceDefinitionPackagingList;
    function GetHasPackagingList : Boolean;
    function GetVersionList : TFhirDeviceDefinitionVersionList;
    function GetHasVersionList : Boolean;
    function GetSafetyList : TFhirCodeableConceptList;
    function GetHasSafetyList : Boolean;
    function GetShelfLifeStorageList : TFhirProductShelfLifeList;
    function GetHasShelfLifeStorageList : Boolean;
    function GetLanguageCodeList : TFhirCodeableConceptList;
    function GetHasLanguageCodeList : Boolean;
    function GetProperty_List : TFhirDeviceDefinitionPropertyList;
    function GetHasProperty_List : Boolean;
    procedure SetOwner(value : TFhirReference);
    function GetContactList : TFhirContactPointList;
    function GetHasContactList : Boolean;
    function GetLink_List : TFhirDeviceDefinitionLinkList;
    function GetHasLink_List : Boolean;
    function GetNoteList : TFhirAnnotationList;
    function GetHasNoteList : Boolean;
    procedure SetParentDevice(value : TFhirReference);
    function GetMaterialList : TFhirDeviceDefinitionMaterialList;
    function GetHasMaterialList : Boolean;
    function GetProductionIdentifierInUDI : TFhirEnumList;
    function GetHasProductionIdentifierInUDI : Boolean;
    function GetProductionIdentifierInUDIST : TFhirDeviceProductionIdentifierInUDIEnumList;
    procedure SetProductionIdentifierInUDIST(value : TFhirDeviceProductionIdentifierInUDIEnumList);
    procedure SetGuideline(value : TFhirDeviceDefinitionGuideline);
    procedure SetCorrectiveAction(value : TFhirDeviceDefinitionCorrectiveAction);
    function GetChargeItemList : TFhirDeviceDefinitionChargeItemList;
    function GetHasChargeItemList : Boolean;
  
    function GetResourceType : TFhirResourceType; override;
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirDeviceDefinition; overload;
    function Clone : TFhirDeviceDefinition; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to Additional information to describe the device.
    property description : String read GetDescriptionST write SetDescriptionST;
    // Additional information to describe the device.
    property descriptionElement : TFhirMarkdown read FDescription write SetDescription;

    // Unique instance identifiers assigned to a device by the software, manufacturers, other organizations or owners. For example: handle ID. The identifier is typically valued if the udiDeviceIdentifier, partNumber or modelNumber is not valued and represents a different type of identifier.  However, it is permissible to still include those identifiers in DeviceDefinition.identifier with the appropriate identifier.type.
    property identifierList : TFhirIdentifierList read GetIdentifierList;
    property hasIdentifierList : boolean read GetHasIdentifierList;

    // Unique device identifier (UDI) assigned to device label or package.  Note that the Device may include multiple udiCarriers as it either may include just the udiCarrier for the jurisdiction it is sold, or for multiple jurisdictions it could have been sold.
    property udiDeviceIdentifierList : TFhirDeviceDefinitionUdiDeviceIdentifierList read GetUdiDeviceIdentifierList;
    property hasUdiDeviceIdentifierList : boolean read GetHasUdiDeviceIdentifierList;

    // Identifier associated with the regulatory documentation (certificates, technical documentation, post-market surveillance documentation and reports) of a set of device models sharing the same intended purpose, risk class and essential design and manufacturing characteristics. One example is the Basic UDI-DI in Europe.
    property regulatoryIdentifierList : TFhirDeviceDefinitionRegulatoryIdentifierList read GetRegulatoryIdentifierList;
    property hasRegulatoryIdentifierList : boolean read GetHasRegulatoryIdentifierList;

    // Typed access to The part number or catalog number of the device.
    property partNumber : String read GetPartNumberST write SetPartNumberST;
    // The part number or catalog number of the device.
    property partNumberElement : TFhirString read FPartNumber write SetPartNumber;

    // Typed access to A name of the manufacturer  or legal representative e.g. labeler. Whether this is the actual manufacturer or the labeler or responsible depends on implementation and jurisdiction. (defined for API consistency)
    property manufacturer : TFhirReference read FManufacturer write SetManufacturer;
    // A name of the manufacturer  or legal representative e.g. labeler. Whether this is the actual manufacturer or the labeler or responsible depends on implementation and jurisdiction.
    property manufacturerElement : TFhirReference read FManufacturer write SetManufacturer;

    // The name or names of the device as given by the manufacturer.
    property deviceNameList : TFhirDeviceDefinitionDeviceNameList read GetDeviceNameList;
    property hasDeviceNameList : boolean read GetHasDeviceNameList;

    // Typed access to The model number for the device for example as defined by the manufacturer or labeler, or other agency.
    property modelNumber : String read GetModelNumberST write SetModelNumberST;
    // The model number for the device for example as defined by the manufacturer or labeler, or other agency.
    property modelNumberElement : TFhirString read FModelNumber write SetModelNumber;

    // What kind of device or device system this is.
    property classificationList : TFhirDeviceDefinitionClassificationList read GetClassificationList;
    property hasClassificationList : boolean read GetHasClassificationList;

    // The capabilities supported on a  device, the standards to which the device conforms for a particular purpose, and used for the communication.
    property specializationList : TFhirRelatedArtifactList read GetSpecializationList;
    property hasSpecializationList : boolean read GetHasSpecializationList;

    // A device that is part (for example a component) of the present device.
    property hasPartList : TFhirDeviceDefinitionHasPartList read GetHasPartList;
    property hasHasPartList : boolean read GetHasHasPartList;

    // Information about the packaging of the device, i.e. how the device is packaged.
    property packagingList : TFhirDeviceDefinitionPackagingList read GetPackagingList;
    property hasPackagingList : boolean read GetHasPackagingList;

    // The version of the device or software.
    property versionList : TFhirDeviceDefinitionVersionList read GetVersionList;
    property hasVersionList : boolean read GetHasVersionList;

    // Safety characteristics of the device.
    property safetyList : TFhirCodeableConceptList read GetSafetyList;
    property hasSafetyList : boolean read GetHasSafetyList;

    // Shelf Life and storage information.
    property shelfLifeStorageList : TFhirProductShelfLifeList read GetShelfLifeStorageList;
    property hasShelfLifeStorageList : boolean read GetHasShelfLifeStorageList;

    // Language code for the human-readable text strings produced by the device (all supported).
    property languageCodeList : TFhirCodeableConceptList read GetLanguageCodeList;
    property hasLanguageCodeList : boolean read GetHasLanguageCodeList;

    // The potential, valid configuration settings of a device, e.g., regulation status, time properties.
    property property_List : TFhirDeviceDefinitionPropertyList read GetProperty_List;
    property hasProperty_List : boolean read GetHasProperty_List;

    // Typed access to An organization that is responsible for the provision and ongoing maintenance of the device. (defined for API consistency)
    property owner : TFhirReference read FOwner write SetOwner;
    // An organization that is responsible for the provision and ongoing maintenance of the device.
    property ownerElement : TFhirReference read FOwner write SetOwner;

    // Contact details for an organization or a particular human that is responsible for the device.
    property contactList : TFhirContactPointList read GetContactList;
    property hasContactList : boolean read GetHasContactList;

    // An associated device, attached to, used with, communicating with or linking a previous or new device model to the focal device.
    property link_List : TFhirDeviceDefinitionLinkList read GetLink_List;
    property hasLink_List : boolean read GetHasLink_List;

    // Descriptive information, usage information or implantation information that is not captured in an existing element.
    property noteList : TFhirAnnotationList read GetNoteList;
    property hasNoteList : boolean read GetHasNoteList;

    // Typed access to The parent device it can be part of. (defined for API consistency)
    property parentDevice : TFhirReference read FParentDevice write SetParentDevice;
    // The parent device it can be part of.
    property parentDeviceElement : TFhirReference read FParentDevice write SetParentDevice;

    // A substance used to create the material(s) of which the device is made.
    property materialList : TFhirDeviceDefinitionMaterialList read GetMaterialList;
    property hasMaterialList : boolean read GetHasMaterialList;

    // Indicates the production identifier(s) that are expected to appear in the UDI carrier on the device label.
    property productionIdentifierInUDI : TFhirDeviceProductionIdentifierInUDIEnumList read GetProductionIdentifierInUDIST write SetProductionIdentifierInUDIST;
    property productionIdentifierInUDIList : TFhirEnumList read GetProductionIdentifierInUDI;
    property hasProductionIdentifierInUDI : boolean read GetHasProductionIdentifierInUDI;
    // Typed access to Information aimed at providing directions for the usage of this model of device. (defined for API consistency)
    property guideline : TFhirDeviceDefinitionGuideline read FGuideline write SetGuideline;
    // Information aimed at providing directions for the usage of this model of device.
    property guidelineElement : TFhirDeviceDefinitionGuideline read FGuideline write SetGuideline;

    // Typed access to Tracking of latest field safety corrective action. (defined for API consistency)
    property correctiveAction : TFhirDeviceDefinitionCorrectiveAction read FCorrectiveAction write SetCorrectiveAction;
    // Tracking of latest field safety corrective action.
    property correctiveActionElement : TFhirDeviceDefinitionCorrectiveAction read FCorrectiveAction write SetCorrectiveAction;

    // Billing code or reference associated with the device.
    property chargeItemList : TFhirDeviceDefinitionChargeItemList read GetChargeItemList;
    property hasChargeItemList : boolean read GetHasChargeItemList;

  end;

  TFhirDeviceDefinitionListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirDeviceDefinitionList;
    function GetCurrent : TFhirDeviceDefinition;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirDeviceDefinitionList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirDeviceDefinition read GetCurrent;
  end;

  TFhirDeviceDefinitionList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirDeviceDefinition;
    procedure SetItemN(index : Integer; value : TFhirDeviceDefinition);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirDeviceDefinitionList; overload;
    function Clone : TFhirDeviceDefinitionList; overload;
    function GetEnumerator : TFhirDeviceDefinitionListEnumerator;
    
    //  Add a FhirDeviceDefinition to the end of the list.
    function Append : TFhirDeviceDefinition;
    
    // Add an already existing FhirDeviceDefinition to the end of the list.
    function AddItem(value : TFhirDeviceDefinition) : TFhirDeviceDefinition; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirDeviceDefinition) : Integer;
    
    // Insert FhirDeviceDefinition before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirDeviceDefinition;
    
    // Insert an existing FhirDeviceDefinition before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirDeviceDefinition);
    
    // Get the iIndexth FhirDeviceDefinition. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirDeviceDefinition);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirDeviceDefinition;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirDeviceDefinitions[index : Integer] : TFhirDeviceDefinition read GetItemN write SetItemN; default;
  End;

{$ENDIF FHIR_DEVICEDEFINITION}
{$IFDEF FHIR_DEVICEMETRIC}
  // Describes the calibrations that have been performed or that are required to be performed.
  TFhirDeviceMetricCalibration = class (TFhirBackboneElement)
  protected
    FType_ : TFhirEnum;
    FState : TFhirEnum;
    FTime : TFhirInstant;
    procedure SetType_(value : TFhirEnum);
    function GetType_ST : TFhirDeviceMetricCalibrationTypeEnum;
    procedure SetType_ST(value : TFhirDeviceMetricCalibrationTypeEnum);
    procedure SetState(value : TFhirEnum);
    function GetStateST : TFhirDeviceMetricCalibrationStateEnum;
    procedure SetStateST(value : TFhirDeviceMetricCalibrationStateEnum);
    procedure SetTime(value : TFhirInstant);
    function GetTimeST : TFslDateTime;
    procedure SetTimeST(value : TFslDateTime);
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirDeviceMetricCalibration; overload;
    function Clone : TFhirDeviceMetricCalibration; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Describes the type of the calibration method.
    property type_ : TFhirDeviceMetricCalibrationTypeEnum read GetType_ST write SetType_ST;
    property type_Element : TFhirEnum read FType_ write SetType_;

    // Describes the state of the calibration.
    property state : TFhirDeviceMetricCalibrationStateEnum read GetStateST write SetStateST;
    property stateElement : TFhirEnum read FState write SetState;

    // Typed access to Describes the time last calibration has been performed.
    property time : TFslDateTime read GetTimeST write SetTimeST;
    // Describes the time last calibration has been performed.
    property timeElement : TFhirInstant read FTime write SetTime;

  end;

  TFhirDeviceMetricCalibrationListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirDeviceMetricCalibrationList;
    function GetCurrent : TFhirDeviceMetricCalibration;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirDeviceMetricCalibrationList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirDeviceMetricCalibration read GetCurrent;
  end;

  TFhirDeviceMetricCalibrationList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirDeviceMetricCalibration;
    procedure SetItemN(index : Integer; value : TFhirDeviceMetricCalibration);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirDeviceMetricCalibrationList; overload;
    function Clone : TFhirDeviceMetricCalibrationList; overload;
    function GetEnumerator : TFhirDeviceMetricCalibrationListEnumerator;
    
    //  Add a FhirDeviceMetricCalibration to the end of the list.
    function Append : TFhirDeviceMetricCalibration;
    
    // Add an already existing FhirDeviceMetricCalibration to the end of the list.
    function AddItem(value : TFhirDeviceMetricCalibration) : TFhirDeviceMetricCalibration; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirDeviceMetricCalibration) : Integer;
    
    // Insert FhirDeviceMetricCalibration before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirDeviceMetricCalibration;
    
    // Insert an existing FhirDeviceMetricCalibration before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirDeviceMetricCalibration);
    
    // Get the iIndexth FhirDeviceMetricCalibration. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirDeviceMetricCalibration);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirDeviceMetricCalibration;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirDeviceMetricCalibrations[index : Integer] : TFhirDeviceMetricCalibration read GetItemN write SetItemN; default;
  End;

  // Describes a measurement, calculation or setting capability of a medical device.
  TFhirDeviceMetric = class (TFhirDomainResource)
  protected
    FidentifierList : TFhirIdentifierList;
    FType_ : TFhirCodeableConcept;
    FUnit_ : TFhirCodeableConcept;
    FSource : TFhirReference;
    FParent : TFhirReference;
    FOperationalStatus : TFhirEnum;
    FColor : TFhirEnum;
    FCategory : TFhirEnum;
    FMeasurementPeriod : TFhirTiming;
    FcalibrationList : TFhirDeviceMetricCalibrationList;
    function GetIdentifierList : TFhirIdentifierList;
    function GetHasIdentifierList : Boolean;
    procedure SetType_(value : TFhirCodeableConcept);
    procedure SetUnit_(value : TFhirCodeableConcept);
    procedure SetSource(value : TFhirReference);
    procedure SetParent(value : TFhirReference);
    procedure SetOperationalStatus(value : TFhirEnum);
    function GetOperationalStatusST : TFhirDeviceMetricOperationalStatusEnum;
    procedure SetOperationalStatusST(value : TFhirDeviceMetricOperationalStatusEnum);
    procedure SetColor(value : TFhirEnum);
    function GetColorST : TFhirDeviceMetricColorEnum;
    procedure SetColorST(value : TFhirDeviceMetricColorEnum);
    procedure SetCategory(value : TFhirEnum);
    function GetCategoryST : TFhirDeviceMetricCategoryEnum;
    procedure SetCategoryST(value : TFhirDeviceMetricCategoryEnum);
    procedure SetMeasurementPeriod(value : TFhirTiming);
    function GetCalibrationList : TFhirDeviceMetricCalibrationList;
    function GetHasCalibrationList : Boolean;
  
    function GetResourceType : TFhirResourceType; override;
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirDeviceMetric; overload;
    function Clone : TFhirDeviceMetric; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Unique instance identifiers assigned to a device by the device or gateway software, manufacturers, other organizations or owners. For example: handle ID.
    property identifierList : TFhirIdentifierList read GetIdentifierList;
    property hasIdentifierList : boolean read GetHasIdentifierList;

    // Typed access to Describes the type of the metric. For example: Heart Rate, PEEP Setting, etc. (defined for API consistency)
    property type_ : TFhirCodeableConcept read FType_ write SetType_;
    // Describes the type of the metric. For example: Heart Rate, PEEP Setting, etc.
    property type_Element : TFhirCodeableConcept read FType_ write SetType_;

    // Typed access to Describes the unit that an observed value determined for this metric will have. For example: Percent, Seconds, etc. (defined for API consistency)
    property unit_ : TFhirCodeableConcept read FUnit_ write SetUnit_;
    // Describes the unit that an observed value determined for this metric will have. For example: Percent, Seconds, etc.
    property unit_Element : TFhirCodeableConcept read FUnit_ write SetUnit_;

    // Typed access to Describes the link to the  Device that this DeviceMetric belongs to and that contains administrative device information such as manufacturer, serial number, etc. (defined for API consistency)
    property source : TFhirReference read FSource write SetSource;
    // Describes the link to the  Device that this DeviceMetric belongs to and that contains administrative device information such as manufacturer, serial number, etc.
    property sourceElement : TFhirReference read FSource write SetSource;

    // Typed access to Describes the link to the  Device that this DeviceMetric belongs to and that provide information about the location of this DeviceMetric in the containment structure of the parent Device. An example would be a Device that represents a Channel. This reference can be used by a client application to distinguish DeviceMetrics that have the same type, but should be interpreted based on their containment location. (defined for API consistency)
    property parent : TFhirReference read FParent write SetParent;
    // Describes the link to the  Device that this DeviceMetric belongs to and that provide information about the location of this DeviceMetric in the containment structure of the parent Device. An example would be a Device that represents a Channel. This reference can be used by a client application to distinguish DeviceMetrics that have the same type, but should be interpreted based on their containment location.
    property parentElement : TFhirReference read FParent write SetParent;

    // Indicates current operational state of the device. For example: On, Off, Standby, etc.
    property operationalStatus : TFhirDeviceMetricOperationalStatusEnum read GetOperationalStatusST write SetOperationalStatusST;
    property operationalStatusElement : TFhirEnum read FOperationalStatus write SetOperationalStatus;

    // Describes the color representation for the metric. This is often used to aid clinicians to track and identify parameter types by color. In practice, consider a Patient Monitor that has ECG/HR and Pleth for example; the parameters are displayed in different characteristic colors, such as HR-blue, BP-green, and PR and SpO2- magenta.
    property color : TFhirDeviceMetricColorEnum read GetColorST write SetColorST;
    property colorElement : TFhirEnum read FColor write SetColor;

    // Indicates the category of the observation generation process. A DeviceMetric can be for example a setting, measurement, or calculation.
    property category : TFhirDeviceMetricCategoryEnum read GetCategoryST write SetCategoryST;
    property categoryElement : TFhirEnum read FCategory write SetCategory;

    // Typed access to Describes the measurement repetition time. This is not necessarily the same as the update period. The measurement repetition time can range from milliseconds up to hours. An example for a measurement repetition time in the range of milliseconds is the sampling rate of an ECG. An example for a measurement repetition time in the range of hours is a NIBP that is triggered automatically every hour. The update period may be different than the measurement repetition time, if the device does not update the published observed value with the same frequency as it was measured. (defined for API consistency)
    property measurementPeriod : TFhirTiming read FMeasurementPeriod write SetMeasurementPeriod;
    // Describes the measurement repetition time. This is not necessarily the same as the update period. The measurement repetition time can range from milliseconds up to hours. An example for a measurement repetition time in the range of milliseconds is the sampling rate of an ECG. An example for a measurement repetition time in the range of hours is a NIBP that is triggered automatically every hour. The update period may be different than the measurement repetition time, if the device does not update the published observed value with the same frequency as it was measured.
    property measurementPeriodElement : TFhirTiming read FMeasurementPeriod write SetMeasurementPeriod;

    // Describes the calibrations that have been performed or that are required to be performed.
    property calibrationList : TFhirDeviceMetricCalibrationList read GetCalibrationList;
    property hasCalibrationList : boolean read GetHasCalibrationList;

  end;

  TFhirDeviceMetricListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirDeviceMetricList;
    function GetCurrent : TFhirDeviceMetric;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirDeviceMetricList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirDeviceMetric read GetCurrent;
  end;

  TFhirDeviceMetricList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirDeviceMetric;
    procedure SetItemN(index : Integer; value : TFhirDeviceMetric);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirDeviceMetricList; overload;
    function Clone : TFhirDeviceMetricList; overload;
    function GetEnumerator : TFhirDeviceMetricListEnumerator;
    
    //  Add a FhirDeviceMetric to the end of the list.
    function Append : TFhirDeviceMetric;
    
    // Add an already existing FhirDeviceMetric to the end of the list.
    function AddItem(value : TFhirDeviceMetric) : TFhirDeviceMetric; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirDeviceMetric) : Integer;
    
    // Insert FhirDeviceMetric before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirDeviceMetric;
    
    // Insert an existing FhirDeviceMetric before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirDeviceMetric);
    
    // Get the iIndexth FhirDeviceMetric. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirDeviceMetric);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirDeviceMetric;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirDeviceMetrics[index : Integer] : TFhirDeviceMetric read GetItemN write SetItemN; default;
  End;

{$ENDIF FHIR_DEVICEMETRIC}
{$IFDEF FHIR_ENCOUNTER}
  // The status history permits the encounter resource to contain the status history without needing to read through the historical versions of the resource, or even have the server store them.
  TFhirEncounterStatusHistory = class (TFhirBackboneElement)
  protected
    FStatus : TFhirEnum;
    FPeriod : TFhirPeriod;
    procedure SetStatus(value : TFhirEnum);
    function GetStatusST : TFhirEncounterStatusEnum;
    procedure SetStatusST(value : TFhirEncounterStatusEnum);
    procedure SetPeriod(value : TFhirPeriod);
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirEncounterStatusHistory; overload;
    function Clone : TFhirEncounterStatusHistory; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // planned | in-progress | onhold | discharged | completed | cancelled | discontinued | entered-in-error | unknown.
    property status : TFhirEncounterStatusEnum read GetStatusST write SetStatusST;
    property statusElement : TFhirEnum read FStatus write SetStatus;

    // Typed access to The time that the episode was in the specified status. (defined for API consistency)
    property period : TFhirPeriod read FPeriod write SetPeriod;
    // The time that the episode was in the specified status.
    property periodElement : TFhirPeriod read FPeriod write SetPeriod;

  end;

  TFhirEncounterStatusHistoryListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirEncounterStatusHistoryList;
    function GetCurrent : TFhirEncounterStatusHistory;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirEncounterStatusHistoryList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirEncounterStatusHistory read GetCurrent;
  end;

  TFhirEncounterStatusHistoryList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirEncounterStatusHistory;
    procedure SetItemN(index : Integer; value : TFhirEncounterStatusHistory);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirEncounterStatusHistoryList; overload;
    function Clone : TFhirEncounterStatusHistoryList; overload;
    function GetEnumerator : TFhirEncounterStatusHistoryListEnumerator;
    
    //  Add a FhirEncounterStatusHistory to the end of the list.
    function Append : TFhirEncounterStatusHistory;
    
    // Add an already existing FhirEncounterStatusHistory to the end of the list.
    function AddItem(value : TFhirEncounterStatusHistory) : TFhirEncounterStatusHistory; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirEncounterStatusHistory) : Integer;
    
    // Insert FhirEncounterStatusHistory before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirEncounterStatusHistory;
    
    // Insert an existing FhirEncounterStatusHistory before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirEncounterStatusHistory);
    
    // Get the iIndexth FhirEncounterStatusHistory. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirEncounterStatusHistory);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirEncounterStatusHistory;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirEncounterStatusHistories[index : Integer] : TFhirEncounterStatusHistory read GetItemN write SetItemN; default;
  End;

  // The class history permits the tracking of the encounters transitions without needing to go  through the resource history.  This would be used for a case where an admission starts of as an emergency encounter, then transitions into an inpatient scenario. Doing this and not restarting a new encounter ensures that any lab/diagnostic results can more easily follow the patient and not require re-processing and not get lost or cancelled during a kind of discharge from emergency to inpatient.
  TFhirEncounterClassHistory = class (TFhirBackboneElement)
  protected
    FClass_ : TFhirCoding;
    FPeriod : TFhirPeriod;
    procedure SetClass_(value : TFhirCoding);
    procedure SetPeriod(value : TFhirPeriod);
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirEncounterClassHistory; overload;
    function Clone : TFhirEncounterClassHistory; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to inpatient | outpatient | ambulatory | emergency +. (defined for API consistency)
    property class_ : TFhirCoding read FClass_ write SetClass_;
    // inpatient | outpatient | ambulatory | emergency +.
    property class_Element : TFhirCoding read FClass_ write SetClass_;

    // Typed access to The time that the episode was in the specified class. (defined for API consistency)
    property period : TFhirPeriod read FPeriod write SetPeriod;
    // The time that the episode was in the specified class.
    property periodElement : TFhirPeriod read FPeriod write SetPeriod;

  end;

  TFhirEncounterClassHistoryListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirEncounterClassHistoryList;
    function GetCurrent : TFhirEncounterClassHistory;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirEncounterClassHistoryList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirEncounterClassHistory read GetCurrent;
  end;

  TFhirEncounterClassHistoryList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirEncounterClassHistory;
    procedure SetItemN(index : Integer; value : TFhirEncounterClassHistory);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirEncounterClassHistoryList; overload;
    function Clone : TFhirEncounterClassHistoryList; overload;
    function GetEnumerator : TFhirEncounterClassHistoryListEnumerator;
    
    //  Add a FhirEncounterClassHistory to the end of the list.
    function Append : TFhirEncounterClassHistory;
    
    // Add an already existing FhirEncounterClassHistory to the end of the list.
    function AddItem(value : TFhirEncounterClassHistory) : TFhirEncounterClassHistory; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirEncounterClassHistory) : Integer;
    
    // Insert FhirEncounterClassHistory before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirEncounterClassHistory;
    
    // Insert an existing FhirEncounterClassHistory before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirEncounterClassHistory);
    
    // Get the iIndexth FhirEncounterClassHistory. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirEncounterClassHistory);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirEncounterClassHistory;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirEncounterClassHistories[index : Integer] : TFhirEncounterClassHistory read GetItemN write SetItemN; default;
  End;

  // The list of people responsible for providing the service.
  TFhirEncounterParticipant = class (TFhirBackboneElement)
  protected
    Ftype_List : TFhirCodeableConceptList;
    FPeriod : TFhirPeriod;
    FActor : TFhirReference;
    function GetType_List : TFhirCodeableConceptList;
    function GetHasType_List : Boolean;
    procedure SetPeriod(value : TFhirPeriod);
    procedure SetActor(value : TFhirReference);
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirEncounterParticipant; overload;
    function Clone : TFhirEncounterParticipant; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Role of participant in encounter.
    property type_List : TFhirCodeableConceptList read GetType_List;
    property hasType_List : boolean read GetHasType_List;

    // Typed access to The period of time that the specified participant participated in the encounter. These can overlap or be sub-sets of the overall encounter's period. (defined for API consistency)
    property period : TFhirPeriod read FPeriod write SetPeriod;
    // The period of time that the specified participant participated in the encounter. These can overlap or be sub-sets of the overall encounter's period.
    property periodElement : TFhirPeriod read FPeriod write SetPeriod;

    // Typed access to Person involved in the encounter, the patient/group is also included here to indicate that the patient was actually participating in the encounter. Not including the patient here covers use cases such as a case meeting between practitioners about a patient - non contact times. (defined for API consistency)
    property actor : TFhirReference read FActor write SetActor;
    // Person involved in the encounter, the patient/group is also included here to indicate that the patient was actually participating in the encounter. Not including the patient here covers use cases such as a case meeting between practitioners about a patient - non contact times.
    property actorElement : TFhirReference read FActor write SetActor;

  end;

  TFhirEncounterParticipantListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirEncounterParticipantList;
    function GetCurrent : TFhirEncounterParticipant;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirEncounterParticipantList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirEncounterParticipant read GetCurrent;
  end;

  TFhirEncounterParticipantList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirEncounterParticipant;
    procedure SetItemN(index : Integer; value : TFhirEncounterParticipant);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirEncounterParticipantList; overload;
    function Clone : TFhirEncounterParticipantList; overload;
    function GetEnumerator : TFhirEncounterParticipantListEnumerator;
    
    //  Add a FhirEncounterParticipant to the end of the list.
    function Append : TFhirEncounterParticipant;
    
    // Add an already existing FhirEncounterParticipant to the end of the list.
    function AddItem(value : TFhirEncounterParticipant) : TFhirEncounterParticipant; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirEncounterParticipant) : Integer;
    
    // Insert FhirEncounterParticipant before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirEncounterParticipant;
    
    // Insert an existing FhirEncounterParticipant before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirEncounterParticipant);
    
    // Get the iIndexth FhirEncounterParticipant. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirEncounterParticipant);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirEncounterParticipant;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirEncounterParticipants[index : Integer] : TFhirEncounterParticipant read GetItemN write SetItemN; default;
  End;

  // The list of diagnosis relevant to this encounter.
  TFhirEncounterDiagnosis = class (TFhirBackboneElement)
  protected
    FCondition : TFhirReference;
    FUse : TFhirCodeableConcept;
    FRank : TFhirPositiveInt;
    procedure SetCondition(value : TFhirReference);
    procedure SetUse(value : TFhirCodeableConcept);
    procedure SetRank(value : TFhirPositiveInt);
    function GetRankST : String;
    procedure SetRankST(value : String);
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirEncounterDiagnosis; overload;
    function Clone : TFhirEncounterDiagnosis; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to Reason the encounter takes place, as specified using information from another resource. For admissions, this is the admission diagnosis. The indication will typically be a Condition (with other resources referenced in the evidence.detail), or a Procedure. (defined for API consistency)
    property condition : TFhirReference read FCondition write SetCondition;
    // Reason the encounter takes place, as specified using information from another resource. For admissions, this is the admission diagnosis. The indication will typically be a Condition (with other resources referenced in the evidence.detail), or a Procedure.
    property conditionElement : TFhirReference read FCondition write SetCondition;

    // Typed access to Role that this diagnosis has within the encounter (e.g. admission, billing, discharge …). (defined for API consistency)
    property use : TFhirCodeableConcept read FUse write SetUse;
    // Role that this diagnosis has within the encounter (e.g. admission, billing, discharge …).
    property useElement : TFhirCodeableConcept read FUse write SetUse;

    // Typed access to Ranking of the diagnosis (for each role type).
    property rank : String read GetRankST write SetRankST;
    // Ranking of the diagnosis (for each role type).
    property rankElement : TFhirPositiveInt read FRank write SetRank;

  end;

  TFhirEncounterDiagnosisListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirEncounterDiagnosisList;
    function GetCurrent : TFhirEncounterDiagnosis;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirEncounterDiagnosisList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirEncounterDiagnosis read GetCurrent;
  end;

  TFhirEncounterDiagnosisList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirEncounterDiagnosis;
    procedure SetItemN(index : Integer; value : TFhirEncounterDiagnosis);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirEncounterDiagnosisList; overload;
    function Clone : TFhirEncounterDiagnosisList; overload;
    function GetEnumerator : TFhirEncounterDiagnosisListEnumerator;
    
    //  Add a FhirEncounterDiagnosis to the end of the list.
    function Append : TFhirEncounterDiagnosis;
    
    // Add an already existing FhirEncounterDiagnosis to the end of the list.
    function AddItem(value : TFhirEncounterDiagnosis) : TFhirEncounterDiagnosis; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirEncounterDiagnosis) : Integer;
    
    // Insert FhirEncounterDiagnosis before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirEncounterDiagnosis;
    
    // Insert an existing FhirEncounterDiagnosis before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirEncounterDiagnosis);
    
    // Get the iIndexth FhirEncounterDiagnosis. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirEncounterDiagnosis);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirEncounterDiagnosis;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirEncounterDiagnoses[index : Integer] : TFhirEncounterDiagnosis read GetItemN write SetItemN; default;
  End;

  // Details about the admission to a healthcare service.
  TFhirEncounterAdmission = class (TFhirBackboneElement)
  protected
    FPreAdmissionIdentifier : TFhirIdentifier;
    FOrigin : TFhirReference;
    FAdmitSource : TFhirCodeableConcept;
    FReAdmission : TFhirCodeableConcept;
    FdietPreferenceList : TFhirCodeableConceptList;
    FspecialCourtesyList : TFhirCodeableConceptList;
    FspecialArrangementList : TFhirCodeableConceptList;
    FDestination : TFhirReference;
    FDischargeDisposition : TFhirCodeableConcept;
    procedure SetPreAdmissionIdentifier(value : TFhirIdentifier);
    procedure SetOrigin(value : TFhirReference);
    procedure SetAdmitSource(value : TFhirCodeableConcept);
    procedure SetReAdmission(value : TFhirCodeableConcept);
    function GetDietPreferenceList : TFhirCodeableConceptList;
    function GetHasDietPreferenceList : Boolean;
    function GetSpecialCourtesyList : TFhirCodeableConceptList;
    function GetHasSpecialCourtesyList : Boolean;
    function GetSpecialArrangementList : TFhirCodeableConceptList;
    function GetHasSpecialArrangementList : Boolean;
    procedure SetDestination(value : TFhirReference);
    procedure SetDischargeDisposition(value : TFhirCodeableConcept);
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirEncounterAdmission; overload;
    function Clone : TFhirEncounterAdmission; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to Pre-admission identifier. (defined for API consistency)
    property preAdmissionIdentifier : TFhirIdentifier read FPreAdmissionIdentifier write SetPreAdmissionIdentifier;
    // Pre-admission identifier.
    property preAdmissionIdentifierElement : TFhirIdentifier read FPreAdmissionIdentifier write SetPreAdmissionIdentifier;

    // Typed access to The location/organization from which the patient came before admission. (defined for API consistency)
    property origin : TFhirReference read FOrigin write SetOrigin;
    // The location/organization from which the patient came before admission.
    property originElement : TFhirReference read FOrigin write SetOrigin;

    // Typed access to From where patient was admitted (physician referral, transfer). (defined for API consistency)
    property admitSource : TFhirCodeableConcept read FAdmitSource write SetAdmitSource;
    // From where patient was admitted (physician referral, transfer).
    property admitSourceElement : TFhirCodeableConcept read FAdmitSource write SetAdmitSource;

    // Typed access to Whether this admission is a readmission and why if known. (defined for API consistency)
    property reAdmission : TFhirCodeableConcept read FReAdmission write SetReAdmission;
    // Whether this admission is a readmission and why if known.
    property reAdmissionElement : TFhirCodeableConcept read FReAdmission write SetReAdmission;

    // Diet preferences reported by the patient.
    property dietPreferenceList : TFhirCodeableConceptList read GetDietPreferenceList;
    property hasDietPreferenceList : boolean read GetHasDietPreferenceList;

    // Special courtesies (VIP, board member).
    property specialCourtesyList : TFhirCodeableConceptList read GetSpecialCourtesyList;
    property hasSpecialCourtesyList : boolean read GetHasSpecialCourtesyList;

    // Any special requests that have been made for this admission encounter, such as the provision of specific equipment or other things.
    property specialArrangementList : TFhirCodeableConceptList read GetSpecialArrangementList;
    property hasSpecialArrangementList : boolean read GetHasSpecialArrangementList;

    // Typed access to Location/organization to which the patient is discharged. (defined for API consistency)
    property destination : TFhirReference read FDestination write SetDestination;
    // Location/organization to which the patient is discharged.
    property destinationElement : TFhirReference read FDestination write SetDestination;

    // Typed access to Category or kind of location after discharge. (defined for API consistency)
    property dischargeDisposition : TFhirCodeableConcept read FDischargeDisposition write SetDischargeDisposition;
    // Category or kind of location after discharge.
    property dischargeDispositionElement : TFhirCodeableConcept read FDischargeDisposition write SetDischargeDisposition;

  end;

  TFhirEncounterAdmissionListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirEncounterAdmissionList;
    function GetCurrent : TFhirEncounterAdmission;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirEncounterAdmissionList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirEncounterAdmission read GetCurrent;
  end;

  TFhirEncounterAdmissionList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirEncounterAdmission;
    procedure SetItemN(index : Integer; value : TFhirEncounterAdmission);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirEncounterAdmissionList; overload;
    function Clone : TFhirEncounterAdmissionList; overload;
    function GetEnumerator : TFhirEncounterAdmissionListEnumerator;
    
    //  Add a FhirEncounterAdmission to the end of the list.
    function Append : TFhirEncounterAdmission;
    
    // Add an already existing FhirEncounterAdmission to the end of the list.
    function AddItem(value : TFhirEncounterAdmission) : TFhirEncounterAdmission; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirEncounterAdmission) : Integer;
    
    // Insert FhirEncounterAdmission before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirEncounterAdmission;
    
    // Insert an existing FhirEncounterAdmission before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirEncounterAdmission);
    
    // Get the iIndexth FhirEncounterAdmission. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirEncounterAdmission);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirEncounterAdmission;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirEncounterAdmissions[index : Integer] : TFhirEncounterAdmission read GetItemN write SetItemN; default;
  End;

  // List of locations where  the patient has been during this encounter.
  TFhirEncounterLocation = class (TFhirBackboneElement)
  protected
    FLocation : TFhirReference;
    FStatus : TFhirEnum;
    FForm : TFhirCodeableConcept;
    FPeriod : TFhirPeriod;
    procedure SetLocation(value : TFhirReference);
    procedure SetStatus(value : TFhirEnum);
    function GetStatusST : TFhirEncounterLocationStatusEnum;
    procedure SetStatusST(value : TFhirEncounterLocationStatusEnum);
    procedure SetForm(value : TFhirCodeableConcept);
    procedure SetPeriod(value : TFhirPeriod);
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirEncounterLocation; overload;
    function Clone : TFhirEncounterLocation; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to The location where the encounter takes place. (defined for API consistency)
    property location : TFhirReference read FLocation write SetLocation;
    // The location where the encounter takes place.
    property locationElement : TFhirReference read FLocation write SetLocation;

    // The status of the participants' presence at the specified location during the period specified. If the participant is no longer at the location, then the period will have an end date/time.
    property status : TFhirEncounterLocationStatusEnum read GetStatusST write SetStatusST;
    property statusElement : TFhirEnum read FStatus write SetStatus;

    // Typed access to This will be used to specify the required levels (bed/ward/room/etc.) desired to be recorded to simplify either messaging or query. (defined for API consistency)
    property form : TFhirCodeableConcept read FForm write SetForm;
    // This will be used to specify the required levels (bed/ward/room/etc.) desired to be recorded to simplify either messaging or query.
    property formElement : TFhirCodeableConcept read FForm write SetForm;

    // Typed access to Time period during which the patient was present at the location. (defined for API consistency)
    property period : TFhirPeriod read FPeriod write SetPeriod;
    // Time period during which the patient was present at the location.
    property periodElement : TFhirPeriod read FPeriod write SetPeriod;

  end;

  TFhirEncounterLocationListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirEncounterLocationList;
    function GetCurrent : TFhirEncounterLocation;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirEncounterLocationList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirEncounterLocation read GetCurrent;
  end;

  TFhirEncounterLocationList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirEncounterLocation;
    procedure SetItemN(index : Integer; value : TFhirEncounterLocation);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirEncounterLocationList; overload;
    function Clone : TFhirEncounterLocationList; overload;
    function GetEnumerator : TFhirEncounterLocationListEnumerator;
    
    //  Add a FhirEncounterLocation to the end of the list.
    function Append : TFhirEncounterLocation;
    
    // Add an already existing FhirEncounterLocation to the end of the list.
    function AddItem(value : TFhirEncounterLocation) : TFhirEncounterLocation; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirEncounterLocation) : Integer;
    
    // Insert FhirEncounterLocation before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirEncounterLocation;
    
    // Insert an existing FhirEncounterLocation before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirEncounterLocation);
    
    // Get the iIndexth FhirEncounterLocation. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirEncounterLocation);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirEncounterLocation;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirEncounterLocations[index : Integer] : TFhirEncounterLocation read GetItemN write SetItemN; default;
  End;

  // An interaction between a patient and healthcare provider(s) for the purpose of providing healthcare service(s) or assessing the health status of a patient.  Encounter is primarily used to record information about the actual activities that occurred, where Appointment is used to record planned activities.
  TFhirEncounter = class (TFhirDomainResource)
  protected
    FidentifierList : TFhirIdentifierList;
    FStatus : TFhirEnum;
    FstatusHistoryList : TFhirEncounterStatusHistoryList;
    Fclass_List : TFhirCodeableConceptList;
    FclassHistoryList : TFhirEncounterClassHistoryList;
    FPriority : TFhirCodeableConcept;
    Ftype_List : TFhirCodeableConceptList;
    FserviceTypeList : TFhirCodeableReferenceList;
    FSubject : TFhirReference;
    FSubjectStatus : TFhirCodeableConcept;
    FepisodeOfCareList : TFhirReferenceList;
    FbasedOnList : TFhirReferenceList;
    FcareTeamList : TFhirReferenceList;
    FPartOf : TFhirReference;
    FServiceProvider : TFhirReference;
    FparticipantList : TFhirEncounterParticipantList;
    FappointmentList : TFhirReferenceList;
    FvirtualServiceList : TFhirVirtualServiceDetailList;
    FActualPeriod : TFhirPeriod;
    FPlannedStartDate : TFhirDateTime;
    FPlannedEndDate : TFhirDateTime;
    FLength : TFhirDuration;
    FreasonList : TFhirCodeableReferenceList;
    FdiagnosisList : TFhirEncounterDiagnosisList;
    FaccountList : TFhirReferenceList;
    FAdmission : TFhirEncounterAdmission;
    FlocationList : TFhirEncounterLocationList;
    function GetIdentifierList : TFhirIdentifierList;
    function GetHasIdentifierList : Boolean;
    procedure SetStatus(value : TFhirEnum);
    function GetStatusST : TFhirEncounterStatusEnum;
    procedure SetStatusST(value : TFhirEncounterStatusEnum);
    function GetStatusHistoryList : TFhirEncounterStatusHistoryList;
    function GetHasStatusHistoryList : Boolean;
    function GetClass_List : TFhirCodeableConceptList;
    function GetHasClass_List : Boolean;
    function GetClassHistoryList : TFhirEncounterClassHistoryList;
    function GetHasClassHistoryList : Boolean;
    procedure SetPriority(value : TFhirCodeableConcept);
    function GetType_List : TFhirCodeableConceptList;
    function GetHasType_List : Boolean;
    function GetServiceTypeList : TFhirCodeableReferenceList;
    function GetHasServiceTypeList : Boolean;
    procedure SetSubject(value : TFhirReference);
    procedure SetSubjectStatus(value : TFhirCodeableConcept);
    function GetEpisodeOfCareList : TFhirReferenceList;
    function GetHasEpisodeOfCareList : Boolean;
    function GetBasedOnList : TFhirReferenceList;
    function GetHasBasedOnList : Boolean;
    function GetCareTeamList : TFhirReferenceList;
    function GetHasCareTeamList : Boolean;
    procedure SetPartOf(value : TFhirReference);
    procedure SetServiceProvider(value : TFhirReference);
    function GetParticipantList : TFhirEncounterParticipantList;
    function GetHasParticipantList : Boolean;
    function GetAppointmentList : TFhirReferenceList;
    function GetHasAppointmentList : Boolean;
    function GetVirtualServiceList : TFhirVirtualServiceDetailList;
    function GetHasVirtualServiceList : Boolean;
    procedure SetActualPeriod(value : TFhirPeriod);
    procedure SetPlannedStartDate(value : TFhirDateTime);
    function GetPlannedStartDateST : TFslDateTime;
    procedure SetPlannedStartDateST(value : TFslDateTime);
    procedure SetPlannedEndDate(value : TFhirDateTime);
    function GetPlannedEndDateST : TFslDateTime;
    procedure SetPlannedEndDateST(value : TFslDateTime);
    procedure SetLength(value : TFhirDuration);
    function GetReasonList : TFhirCodeableReferenceList;
    function GetHasReasonList : Boolean;
    function GetDiagnosisList : TFhirEncounterDiagnosisList;
    function GetHasDiagnosisList : Boolean;
    function GetAccountList : TFhirReferenceList;
    function GetHasAccountList : Boolean;
    procedure SetAdmission(value : TFhirEncounterAdmission);
    function GetLocationList : TFhirEncounterLocationList;
    function GetHasLocationList : Boolean;
  
    function GetResourceType : TFhirResourceType; override;
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirEncounter; overload;
    function Clone : TFhirEncounter; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Identifier(s) by which this encounter is known.
    property identifierList : TFhirIdentifierList read GetIdentifierList;
    property hasIdentifierList : boolean read GetHasIdentifierList;

    // planned | in-progress | onhold | discharged | completed | cancelled | discontinued | entered-in-error | unknown.
    property status : TFhirEncounterStatusEnum read GetStatusST write SetStatusST;
    property statusElement : TFhirEnum read FStatus write SetStatus;

    // The status history permits the encounter resource to contain the status history without needing to read through the historical versions of the resource, or even have the server store them.
    property statusHistoryList : TFhirEncounterStatusHistoryList read GetStatusHistoryList;
    property hasStatusHistoryList : boolean read GetHasStatusHistoryList;

    // Concepts representing classification of patient encounter such as ambulatory (outpatient), inpatient, emergency, home health or others due to local variations.
    property class_List : TFhirCodeableConceptList read GetClass_List;
    property hasClass_List : boolean read GetHasClass_List;

    // The class history permits the tracking of the encounters transitions without needing to go  through the resource history.  This would be used for a case where an admission starts of as an emergency encounter, then transitions into an inpatient scenario. Doing this and not restarting a new encounter ensures that any lab/diagnostic results can more easily follow the patient and not require re-processing and not get lost or cancelled during a kind of discharge from emergency to inpatient.
    property classHistoryList : TFhirEncounterClassHistoryList read GetClassHistoryList;
    property hasClassHistoryList : boolean read GetHasClassHistoryList;

    // Typed access to Indicates the urgency of the encounter. (defined for API consistency)
    property priority : TFhirCodeableConcept read FPriority write SetPriority;
    // Indicates the urgency of the encounter.
    property priorityElement : TFhirCodeableConcept read FPriority write SetPriority;

    // Specific type of encounter (e.g. e-mail consultation, surgical day-care, skilled nursing, rehabilitation).
    property type_List : TFhirCodeableConceptList read GetType_List;
    property hasType_List : boolean read GetHasType_List;

    // Broad categorization of the service that is to be provided (e.g. cardiology).
    property serviceTypeList : TFhirCodeableReferenceList read GetServiceTypeList;
    property hasServiceTypeList : boolean read GetHasServiceTypeList;

    // Typed access to The patient or group related to this encounter. In some use-cases the patient MAY not be present, such as a case meeting about a patient between several practitioners or a careteam. (defined for API consistency)
    property subject : TFhirReference read FSubject write SetSubject;
    // The patient or group related to this encounter. In some use-cases the patient MAY not be present, such as a case meeting about a patient between several practitioners or a careteam.
    property subjectElement : TFhirReference read FSubject write SetSubject;

    // Typed access to The subjectStatus value can be used to track the patient's status within the encounter. It details whether the patient has arrived or departed, has been triaged or is currently in a waiting status. (defined for API consistency)
    property subjectStatus : TFhirCodeableConcept read FSubjectStatus write SetSubjectStatus;
    // The subjectStatus value can be used to track the patient's status within the encounter. It details whether the patient has arrived or departed, has been triaged or is currently in a waiting status.
    property subjectStatusElement : TFhirCodeableConcept read FSubjectStatus write SetSubjectStatus;

    // Where a specific encounter should be classified as a part of a specific episode(s) of care this field should be used. This association can facilitate grouping of related encounters together for a specific purpose, such as government reporting, issue tracking, association via a common problem.  The association is recorded on the encounter as these are typically created after the episode of care and grouped on entry rather than editing the episode of care to append another encounter to it (the episode of care could span years).
    property episodeOfCareList : TFhirReferenceList read GetEpisodeOfCareList;
    property hasEpisodeOfCareList : boolean read GetHasEpisodeOfCareList;

    // The request this encounter satisfies (e.g. incoming referral or procedure request).
    property basedOnList : TFhirReferenceList read GetBasedOnList;
    property hasBasedOnList : boolean read GetHasBasedOnList;

    // The group(s) of individuals, organizations that are allocated to participate in this encounter. The participants backbone will record the actuals of when these individuals participated during the encounter.
    property careTeamList : TFhirReferenceList read GetCareTeamList;
    property hasCareTeamList : boolean read GetHasCareTeamList;

    // Typed access to Another Encounter of which this encounter is a part of (administratively or in time). (defined for API consistency)
    property partOf : TFhirReference read FPartOf write SetPartOf;
    // Another Encounter of which this encounter is a part of (administratively or in time).
    property partOfElement : TFhirReference read FPartOf write SetPartOf;

    // Typed access to The organization that is primarily responsible for this Encounter's services. This MAY be the same as the organization on the Patient record, however it could be different, such as if the actor performing the services was from an external organization (which may be billed seperately) for an external consultation.  Refer to the example bundle showing an abbreviated set of Encounters for a colonoscopy. (defined for API consistency)
    property serviceProvider : TFhirReference read FServiceProvider write SetServiceProvider;
    // The organization that is primarily responsible for this Encounter's services. This MAY be the same as the organization on the Patient record, however it could be different, such as if the actor performing the services was from an external organization (which may be billed seperately) for an external consultation.  Refer to the example bundle showing an abbreviated set of Encounters for a colonoscopy.
    property serviceProviderElement : TFhirReference read FServiceProvider write SetServiceProvider;

    // The list of people responsible for providing the service.
    property participantList : TFhirEncounterParticipantList read GetParticipantList;
    property hasParticipantList : boolean read GetHasParticipantList;

    // The appointment that scheduled this encounter.
    property appointmentList : TFhirReferenceList read GetAppointmentList;
    property hasAppointmentList : boolean read GetHasAppointmentList;

    // Connection details of a virtual service (e.g. conference call).
    property virtualServiceList : TFhirVirtualServiceDetailList read GetVirtualServiceList;
    property hasVirtualServiceList : boolean read GetHasVirtualServiceList;

    // Typed access to The actual start and end time of the encounter. (defined for API consistency)
    property actualPeriod : TFhirPeriod read FActualPeriod write SetActualPeriod;
    // The actual start and end time of the encounter.
    property actualPeriodElement : TFhirPeriod read FActualPeriod write SetActualPeriod;

    // Typed access to The planned start date/time (or admission date) of the encounter.
    property plannedStartDate : TFslDateTime read GetPlannedStartDateST write SetPlannedStartDateST;
    // The planned start date/time (or admission date) of the encounter.
    property plannedStartDateElement : TFhirDateTime read FPlannedStartDate write SetPlannedStartDate;

    // Typed access to The planned end date/time (or discharge date) of the encounter.
    property plannedEndDate : TFslDateTime read GetPlannedEndDateST write SetPlannedEndDateST;
    // The planned end date/time (or discharge date) of the encounter.
    property plannedEndDateElement : TFhirDateTime read FPlannedEndDate write SetPlannedEndDate;

    // Typed access to Actual quantity of time the encounter lasted. This excludes the time during leaves of absence.  When missing it is the time in between the start and end values. (defined for API consistency)
    property length : TFhirDuration read FLength write SetLength;
    // Actual quantity of time the encounter lasted. This excludes the time during leaves of absence.  When missing it is the time in between the start and end values.
    property lengthElement : TFhirDuration read FLength write SetLength;

    // Reason the encounter takes place, expressed as a code or a reference to another resource. For admissions, this can be used for a coded admission diagnosis.
    property reasonList : TFhirCodeableReferenceList read GetReasonList;
    property hasReasonList : boolean read GetHasReasonList;

    // The list of diagnosis relevant to this encounter.
    property diagnosisList : TFhirEncounterDiagnosisList read GetDiagnosisList;
    property hasDiagnosisList : boolean read GetHasDiagnosisList;

    // The set of accounts that may be used for billing for this Encounter.
    property accountList : TFhirReferenceList read GetAccountList;
    property hasAccountList : boolean read GetHasAccountList;

    // Typed access to Details about the admission to a healthcare service. (defined for API consistency)
    property admission : TFhirEncounterAdmission read FAdmission write SetAdmission;
    // Details about the admission to a healthcare service.
    property admissionElement : TFhirEncounterAdmission read FAdmission write SetAdmission;

    // List of locations where  the patient has been during this encounter.
    property locationList : TFhirEncounterLocationList read GetLocationList;
    property hasLocationList : boolean read GetHasLocationList;

  end;

  TFhirEncounterListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirEncounterList;
    function GetCurrent : TFhirEncounter;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirEncounterList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirEncounter read GetCurrent;
  end;

  TFhirEncounterList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirEncounter;
    procedure SetItemN(index : Integer; value : TFhirEncounter);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirEncounterList; overload;
    function Clone : TFhirEncounterList; overload;
    function GetEnumerator : TFhirEncounterListEnumerator;
    
    //  Add a FhirEncounter to the end of the list.
    function Append : TFhirEncounter;
    
    // Add an already existing FhirEncounter to the end of the list.
    function AddItem(value : TFhirEncounter) : TFhirEncounter; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirEncounter) : Integer;
    
    // Insert FhirEncounter before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirEncounter;
    
    // Insert an existing FhirEncounter before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirEncounter);
    
    // Get the iIndexth FhirEncounter. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirEncounter);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirEncounter;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirEncounters[index : Integer] : TFhirEncounter read GetItemN write SetItemN; default;
  End;

{$ENDIF FHIR_ENCOUNTER}
{$IFDEF FHIR_ENDPOINT}
  // The technical details of an endpoint that can be used for electronic services, such as for web services providing XDS.b, a REST endpoint for another FHIR server, or a s/Mime email address. This may include any security context information.
  TFhirEndpoint = class (TFhirDomainResource)
  protected
    FidentifierList : TFhirIdentifierList;
    FStatus : TFhirEnum;
    FconnectionTypeList : TFhirCodeableConceptList;
    FName : TFhirString;
    FDescription : TFhirString;
    FenvironmentTypeList : TFhirCodeableConceptList;
    FManagingOrganization : TFhirReference;
    FcontactList : TFhirContactPointList;
    FPeriod : TFhirPeriod;
    FpayloadTypeList : TFhirCodeableConceptList;
    FpayloadMimeTypeList : TFhirCodeList;
    FAddress : TFhirUrl;
    FheaderList : TFhirStringList;
    function GetIdentifierList : TFhirIdentifierList;
    function GetHasIdentifierList : Boolean;
    procedure SetStatus(value : TFhirEnum);
    function GetStatusST : TFhirEndpointStatusEnum;
    procedure SetStatusST(value : TFhirEndpointStatusEnum);
    function GetConnectionTypeList : TFhirCodeableConceptList;
    function GetHasConnectionTypeList : Boolean;
    procedure SetName(value : TFhirString);
    function GetNameST : String;
    procedure SetNameST(value : String);
    procedure SetDescription(value : TFhirString);
    function GetDescriptionST : String;
    procedure SetDescriptionST(value : String);
    function GetEnvironmentTypeList : TFhirCodeableConceptList;
    function GetHasEnvironmentTypeList : Boolean;
    procedure SetManagingOrganization(value : TFhirReference);
    function GetContactList : TFhirContactPointList;
    function GetHasContactList : Boolean;
    procedure SetPeriod(value : TFhirPeriod);
    function GetPayloadTypeList : TFhirCodeableConceptList;
    function GetHasPayloadTypeList : Boolean;
    function GetPayloadMimeTypeList : TFhirCodeList;
    function GetHasPayloadMimeTypeList : Boolean;
    procedure SetAddress(value : TFhirUrl);
    function GetAddressST : String;
    procedure SetAddressST(value : String);
    function GetHeaderList : TFhirStringList;
    function GetHasHeaderList : Boolean;
  
    function GetResourceType : TFhirResourceType; override;
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirEndpoint; overload;
    function Clone : TFhirEndpoint; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Identifier for the organization that is used to identify the endpoint across multiple disparate systems.
    property identifierList : TFhirIdentifierList read GetIdentifierList;
    property hasIdentifierList : boolean read GetHasIdentifierList;

    // The endpoint status represents the general expected availability of an endpoint.
    property status : TFhirEndpointStatusEnum read GetStatusST write SetStatusST;
    property statusElement : TFhirEnum read FStatus write SetStatus;

    // A coded value that represents the technical details of the usage of this endpoint, such as what WSDLs should be used in what way. (e.g. XDS.b/DICOM/cds-hook).
    property connectionTypeList : TFhirCodeableConceptList read GetConnectionTypeList;
    property hasConnectionTypeList : boolean read GetHasConnectionTypeList;

    // Typed access to A friendly name that this endpoint can be referred to with.
    property name : String read GetNameST write SetNameST;
    // A friendly name that this endpoint can be referred to with.
    property nameElement : TFhirString read FName write SetName;

    // Typed access to The description of the endpoint and what it is for (typically used as supplemental information in an endpoint directory describing it's usage/purpose).
    property description : String read GetDescriptionST write SetDescriptionST;
    // The description of the endpoint and what it is for (typically used as supplemental information in an endpoint directory describing it's usage/purpose).
    property descriptionElement : TFhirString read FDescription write SetDescription;

    // The type of environment(s) exposed at this endpoint (dev, prod, test, etc).
    property environmentTypeList : TFhirCodeableConceptList read GetEnvironmentTypeList;
    property hasEnvironmentTypeList : boolean read GetHasEnvironmentTypeList;

    // Typed access to The organization that manages this endpoint (even if technically another organization is hosting this in the cloud, it is the organization associated with the data). (defined for API consistency)
    property managingOrganization : TFhirReference read FManagingOrganization write SetManagingOrganization;
    // The organization that manages this endpoint (even if technically another organization is hosting this in the cloud, it is the organization associated with the data).
    property managingOrganizationElement : TFhirReference read FManagingOrganization write SetManagingOrganization;

    // Contact details for a human to contact about the endpoint. The primary use of this for system administrator troubleshooting.
    property contactList : TFhirContactPointList read GetContactList;
    property hasContactList : boolean read GetHasContactList;

    // Typed access to The interval during which the endpoint is expected to be operational. (defined for API consistency)
    property period : TFhirPeriod read FPeriod write SetPeriod;
    // The interval during which the endpoint is expected to be operational.
    property periodElement : TFhirPeriod read FPeriod write SetPeriod;

    // The payload type describes the acceptable content that can be communicated on the endpoint.
    property payloadTypeList : TFhirCodeableConceptList read GetPayloadTypeList;
    property hasPayloadTypeList : boolean read GetHasPayloadTypeList;

    // The mime type to send the payload in - e.g. application/fhir+xml, application/fhir+json. If the mime type is not specified, then the sender could send any content (including no content depending on the connectionType).
    property payloadMimeTypeList : TFhirCodeList read GetPayloadMimeTypeList;
    property hasPayloadMimeTypeList : boolean read GetHasPayloadMimeTypeList;

    // Typed access to The uri that describes the actual end-point to connect to.
    property address : String read GetAddressST write SetAddressST;
    // The uri that describes the actual end-point to connect to.
    property addressElement : TFhirUrl read FAddress write SetAddress;

    // Additional headers / information to send as part of the notification.
    property headerList : TFhirStringList read GetHeaderList;
    property hasHeaderList : boolean read GetHasHeaderList;

  end;

  TFhirEndpointListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirEndpointList;
    function GetCurrent : TFhirEndpoint;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirEndpointList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirEndpoint read GetCurrent;
  end;

  TFhirEndpointList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirEndpoint;
    procedure SetItemN(index : Integer; value : TFhirEndpoint);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirEndpointList; overload;
    function Clone : TFhirEndpointList; overload;
    function GetEnumerator : TFhirEndpointListEnumerator;
    
    //  Add a FhirEndpoint to the end of the list.
    function Append : TFhirEndpoint;
    
    // Add an already existing FhirEndpoint to the end of the list.
    function AddItem(value : TFhirEndpoint) : TFhirEndpoint; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirEndpoint) : Integer;
    
    // Insert FhirEndpoint before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirEndpoint;
    
    // Insert an existing FhirEndpoint before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirEndpoint);
    
    // Get the iIndexth FhirEndpoint. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirEndpoint);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirEndpoint;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirEndpoints[index : Integer] : TFhirEndpoint read GetItemN write SetItemN; default;
  End;

{$ENDIF FHIR_ENDPOINT}
{$IFDEF FHIR_GROUP}
  // Identifies traits whose presence r absence is shared by members of the group.
  TFhirGroupCharacteristic = class (TFhirBackboneElement)
  protected
    FCode : TFhirCodeableConcept;
    FValue : TFhirDataType;
    FExclude : TFhirBoolean;
    FPeriod : TFhirPeriod;
    procedure SetCode(value : TFhirCodeableConcept);
    procedure SetValue(value : TFhirDataType);
    procedure SetExclude(value : TFhirBoolean);
    function GetExcludeST : Boolean;
    procedure SetExcludeST(value : Boolean);
    procedure SetPeriod(value : TFhirPeriod);
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirGroupCharacteristic; overload;
    function Clone : TFhirGroupCharacteristic; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to A code that identifies the kind of trait being asserted. (defined for API consistency)
    property code : TFhirCodeableConcept read FCode write SetCode;
    // A code that identifies the kind of trait being asserted.
    property codeElement : TFhirCodeableConcept read FCode write SetCode;

    // Typed access to The value of the trait that holds (or does not hold - see 'exclude') for members of the group. (defined for API consistency)
    property value : TFhirDataType read FValue write SetValue;
    // The value of the trait that holds (or does not hold - see 'exclude') for members of the group.
    property valueElement : TFhirDataType read FValue write SetValue;

    // Typed access to If true, indicates the characteristic is one that is NOT held by members of the group.
    property exclude : Boolean read GetExcludeST write SetExcludeST;
    // If true, indicates the characteristic is one that is NOT held by members of the group.
    property excludeElement : TFhirBoolean read FExclude write SetExclude;

    // Typed access to The period over which the characteristic is tested; e.g. the patient had an operation during the month of June. (defined for API consistency)
    property period : TFhirPeriod read FPeriod write SetPeriod;
    // The period over which the characteristic is tested; e.g. the patient had an operation during the month of June.
    property periodElement : TFhirPeriod read FPeriod write SetPeriod;

  end;

  TFhirGroupCharacteristicListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirGroupCharacteristicList;
    function GetCurrent : TFhirGroupCharacteristic;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirGroupCharacteristicList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirGroupCharacteristic read GetCurrent;
  end;

  TFhirGroupCharacteristicList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirGroupCharacteristic;
    procedure SetItemN(index : Integer; value : TFhirGroupCharacteristic);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirGroupCharacteristicList; overload;
    function Clone : TFhirGroupCharacteristicList; overload;
    function GetEnumerator : TFhirGroupCharacteristicListEnumerator;
    
    //  Add a FhirGroupCharacteristic to the end of the list.
    function Append : TFhirGroupCharacteristic;
    
    // Add an already existing FhirGroupCharacteristic to the end of the list.
    function AddItem(value : TFhirGroupCharacteristic) : TFhirGroupCharacteristic; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirGroupCharacteristic) : Integer;
    
    // Insert FhirGroupCharacteristic before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirGroupCharacteristic;
    
    // Insert an existing FhirGroupCharacteristic before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirGroupCharacteristic);
    
    // Get the iIndexth FhirGroupCharacteristic. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirGroupCharacteristic);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirGroupCharacteristic;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirGroupCharacteristics[index : Integer] : TFhirGroupCharacteristic read GetItemN write SetItemN; default;
  End;

  // Identifies the resource instances that are members of the group.
  TFhirGroupMember = class (TFhirBackboneElement)
  protected
    FEntity : TFhirReference;
    FPeriod : TFhirPeriod;
    FInactive : TFhirBoolean;
    procedure SetEntity(value : TFhirReference);
    procedure SetPeriod(value : TFhirPeriod);
    procedure SetInactive(value : TFhirBoolean);
    function GetInactiveST : Boolean;
    procedure SetInactiveST(value : Boolean);
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirGroupMember; overload;
    function Clone : TFhirGroupMember; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to A reference to the entity that is a member of the group. Must be consistent with Group.type. If the entity is another group, then the type must be the same. (defined for API consistency)
    property entity : TFhirReference read FEntity write SetEntity;
    // A reference to the entity that is a member of the group. Must be consistent with Group.type. If the entity is another group, then the type must be the same.
    property entityElement : TFhirReference read FEntity write SetEntity;

    // Typed access to The period that the member was in the group, if known. (defined for API consistency)
    property period : TFhirPeriod read FPeriod write SetPeriod;
    // The period that the member was in the group, if known.
    property periodElement : TFhirPeriod read FPeriod write SetPeriod;

    // Typed access to A flag to indicate that the member is no longer in the group, but previously may have been a member.
    property inactive : Boolean read GetInactiveST write SetInactiveST;
    // A flag to indicate that the member is no longer in the group, but previously may have been a member.
    property inactiveElement : TFhirBoolean read FInactive write SetInactive;

  end;

  TFhirGroupMemberListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirGroupMemberList;
    function GetCurrent : TFhirGroupMember;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirGroupMemberList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirGroupMember read GetCurrent;
  end;

  TFhirGroupMemberList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirGroupMember;
    procedure SetItemN(index : Integer; value : TFhirGroupMember);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirGroupMemberList; overload;
    function Clone : TFhirGroupMemberList; overload;
    function GetEnumerator : TFhirGroupMemberListEnumerator;
    
    //  Add a FhirGroupMember to the end of the list.
    function Append : TFhirGroupMember;
    
    // Add an already existing FhirGroupMember to the end of the list.
    function AddItem(value : TFhirGroupMember) : TFhirGroupMember; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirGroupMember) : Integer;
    
    // Insert FhirGroupMember before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirGroupMember;
    
    // Insert an existing FhirGroupMember before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirGroupMember);
    
    // Get the iIndexth FhirGroupMember. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirGroupMember);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirGroupMember;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirGroupMembers[index : Integer] : TFhirGroupMember read GetItemN write SetItemN; default;
  End;

  // Represents a defined collection of entities that may be discussed or acted upon collectively but which are not expected to act collectively, and are not formally or legally recognized; i.e. a collection of entities that isn't an Organization.
  TFhirGroup = class (TFhirDomainResource)
  protected
    FidentifierList : TFhirIdentifierList;
    FActive : TFhirBoolean;
    FType_ : TFhirEnum;
    FMembership : TFhirEnum;
    FCode : TFhirCodeableConcept;
    FName : TFhirString;
    FDescription : TFhirMarkdown;
    FQuantity : TFhirUnsignedInt;
    FManagingEntity : TFhirReference;
    FcharacteristicList : TFhirGroupCharacteristicList;
    FmemberList : TFhirGroupMemberList;
    function GetIdentifierList : TFhirIdentifierList;
    function GetHasIdentifierList : Boolean;
    procedure SetActive(value : TFhirBoolean);
    function GetActiveST : Boolean;
    procedure SetActiveST(value : Boolean);
    procedure SetType_(value : TFhirEnum);
    function GetType_ST : TFhirGroupTypeEnum;
    procedure SetType_ST(value : TFhirGroupTypeEnum);
    procedure SetMembership(value : TFhirEnum);
    function GetMembershipST : TFhirGroupMembershipBasisEnum;
    procedure SetMembershipST(value : TFhirGroupMembershipBasisEnum);
    procedure SetCode(value : TFhirCodeableConcept);
    procedure SetName(value : TFhirString);
    function GetNameST : String;
    procedure SetNameST(value : String);
    procedure SetDescription(value : TFhirMarkdown);
    function GetDescriptionST : String;
    procedure SetDescriptionST(value : String);
    procedure SetQuantity(value : TFhirUnsignedInt);
    function GetQuantityST : String;
    procedure SetQuantityST(value : String);
    procedure SetManagingEntity(value : TFhirReference);
    function GetCharacteristicList : TFhirGroupCharacteristicList;
    function GetHasCharacteristicList : Boolean;
    function GetMemberList : TFhirGroupMemberList;
    function GetHasMemberList : Boolean;
  
    function GetResourceType : TFhirResourceType; override;
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirGroup; overload;
    function Clone : TFhirGroup; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // A unique business identifier for this group.
    property identifierList : TFhirIdentifierList read GetIdentifierList;
    property hasIdentifierList : boolean read GetHasIdentifierList;

    // Typed access to Indicates whether the record for the group is available for use or is merely being retained for historical purposes.
    property active : Boolean read GetActiveST write SetActiveST;
    // Indicates whether the record for the group is available for use or is merely being retained for historical purposes.
    property activeElement : TFhirBoolean read FActive write SetActive;

    // Identifies the broad classification of the kind of resources the group includes.
    property type_ : TFhirGroupTypeEnum read GetType_ST write SetType_ST;
    property type_Element : TFhirEnum read FType_ write SetType_;

    // Basis for membership in the Group:  * 'definitional': The Group.characteristics specified are both necessary and sufficient to determine membership. All entities that meet the criteria are considered to be members of the group, whether referenced by the group or not. If members are present, they are individuals that happen to be known as meeting the Group.characteristics. The list cannot be presumed to be complete. * 'enumerated': The Group.characteristics are necessary but not sufficient to determine membership. Membership is determined by being listed as one of the Group.member.
    property membership : TFhirGroupMembershipBasisEnum read GetMembershipST write SetMembershipST;
    property membershipElement : TFhirEnum read FMembership write SetMembership;

    // Typed access to Provides a specific type of resource the group includes; e.g. "cow", "syringe", etc. (defined for API consistency)
    property code : TFhirCodeableConcept read FCode write SetCode;
    // Provides a specific type of resource the group includes; e.g. "cow", "syringe", etc.
    property codeElement : TFhirCodeableConcept read FCode write SetCode;

    // Typed access to A label assigned to the group for human identification and communication.
    property name : String read GetNameST write SetNameST;
    // A label assigned to the group for human identification and communication.
    property nameElement : TFhirString read FName write SetName;

    // Typed access to Explanation of what the group represents and how it is intended to be used.
    property description : String read GetDescriptionST write SetDescriptionST;
    // Explanation of what the group represents and how it is intended to be used.
    property descriptionElement : TFhirMarkdown read FDescription write SetDescription;

    // Typed access to A count of the number of resource instances that are part of the group.
    property quantity : String read GetQuantityST write SetQuantityST;
    // A count of the number of resource instances that are part of the group.
    property quantityElement : TFhirUnsignedInt read FQuantity write SetQuantity;

    // Typed access to Entity responsible for defining and maintaining Group characteristics and/or registered members. (defined for API consistency)
    property managingEntity : TFhirReference read FManagingEntity write SetManagingEntity;
    // Entity responsible for defining and maintaining Group characteristics and/or registered members.
    property managingEntityElement : TFhirReference read FManagingEntity write SetManagingEntity;

    // Identifies traits whose presence r absence is shared by members of the group.
    property characteristicList : TFhirGroupCharacteristicList read GetCharacteristicList;
    property hasCharacteristicList : boolean read GetHasCharacteristicList;

    // Identifies the resource instances that are members of the group.
    property memberList : TFhirGroupMemberList read GetMemberList;
    property hasMemberList : boolean read GetHasMemberList;

  end;

  TFhirGroupListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirGroupList;
    function GetCurrent : TFhirGroup;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirGroupList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirGroup read GetCurrent;
  end;

  TFhirGroupList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirGroup;
    procedure SetItemN(index : Integer; value : TFhirGroup);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirGroupList; overload;
    function Clone : TFhirGroupList; overload;
    function GetEnumerator : TFhirGroupListEnumerator;
    
    //  Add a FhirGroup to the end of the list.
    function Append : TFhirGroup;
    
    // Add an already existing FhirGroup to the end of the list.
    function AddItem(value : TFhirGroup) : TFhirGroup; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirGroup) : Integer;
    
    // Insert FhirGroup before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirGroup;
    
    // Insert an existing FhirGroup before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirGroup);
    
    // Get the iIndexth FhirGroup. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirGroup);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirGroup;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirGroups[index : Integer] : TFhirGroup read GetItemN write SetItemN; default;
  End;

{$ENDIF FHIR_GROUP}
{$IFDEF FHIR_HEALTHCARESERVICE}
  // Does this service have specific eligibility requirements that need to be met in order to use the service?
  TFhirHealthcareServiceEligibility = class (TFhirBackboneElement)
  protected
    FCode : TFhirCodeableConcept;
    FComment : TFhirMarkdown;
    procedure SetCode(value : TFhirCodeableConcept);
    procedure SetComment(value : TFhirMarkdown);
    function GetCommentST : String;
    procedure SetCommentST(value : String);
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirHealthcareServiceEligibility; overload;
    function Clone : TFhirHealthcareServiceEligibility; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to Coded value for the eligibility. (defined for API consistency)
    property code : TFhirCodeableConcept read FCode write SetCode;
    // Coded value for the eligibility.
    property codeElement : TFhirCodeableConcept read FCode write SetCode;

    // Typed access to Describes the eligibility conditions for the service.
    property comment : String read GetCommentST write SetCommentST;
    // Describes the eligibility conditions for the service.
    property commentElement : TFhirMarkdown read FComment write SetComment;

  end;

  TFhirHealthcareServiceEligibilityListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirHealthcareServiceEligibilityList;
    function GetCurrent : TFhirHealthcareServiceEligibility;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirHealthcareServiceEligibilityList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirHealthcareServiceEligibility read GetCurrent;
  end;

  TFhirHealthcareServiceEligibilityList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirHealthcareServiceEligibility;
    procedure SetItemN(index : Integer; value : TFhirHealthcareServiceEligibility);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirHealthcareServiceEligibilityList; overload;
    function Clone : TFhirHealthcareServiceEligibilityList; overload;
    function GetEnumerator : TFhirHealthcareServiceEligibilityListEnumerator;
    
    //  Add a FhirHealthcareServiceEligibility to the end of the list.
    function Append : TFhirHealthcareServiceEligibility;
    
    // Add an already existing FhirHealthcareServiceEligibility to the end of the list.
    function AddItem(value : TFhirHealthcareServiceEligibility) : TFhirHealthcareServiceEligibility; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirHealthcareServiceEligibility) : Integer;
    
    // Insert FhirHealthcareServiceEligibility before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirHealthcareServiceEligibility;
    
    // Insert an existing FhirHealthcareServiceEligibility before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirHealthcareServiceEligibility);
    
    // Get the iIndexth FhirHealthcareServiceEligibility. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirHealthcareServiceEligibility);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirHealthcareServiceEligibility;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirHealthcareServiceEligibilities[index : Integer] : TFhirHealthcareServiceEligibility read GetItemN write SetItemN; default;
  End;

  // The details of a healthcare service available at a location.
  TFhirHealthcareService = class (TFhirDomainResource)
  protected
    FidentifierList : TFhirIdentifierList;
    FActive : TFhirBoolean;
    FProvidedBy : TFhirReference;
    FofferedInList : TFhirReferenceList;
    FcategoryList : TFhirCodeableConceptList;
    Ftype_List : TFhirCodeableConceptList;
    FspecialtyList : TFhirCodeableConceptList;
    FlocationList : TFhirReferenceList;
    FName : TFhirString;
    FComment : TFhirString;
    FExtraDetails : TFhirMarkdown;
    FPhoto : TFhirAttachment;
    FcontactList : TFhirExtendedContactDetailList;
    FcoverageAreaList : TFhirReferenceList;
    FserviceProvisionCodeList : TFhirCodeableConceptList;
    FeligibilityList : TFhirHealthcareServiceEligibilityList;
    Fprogram_List : TFhirCodeableConceptList;
    FcharacteristicList : TFhirCodeableConceptList;
    FcommunicationList : TFhirCodeableConceptList;
    FreferralMethodList : TFhirCodeableConceptList;
    FAppointmentRequired : TFhirBoolean;
    FavailabilityList : TFhirAvailabilityList;
    FendpointList : TFhirReferenceList;
    function GetIdentifierList : TFhirIdentifierList;
    function GetHasIdentifierList : Boolean;
    procedure SetActive(value : TFhirBoolean);
    function GetActiveST : Boolean;
    procedure SetActiveST(value : Boolean);
    procedure SetProvidedBy(value : TFhirReference);
    function GetOfferedInList : TFhirReferenceList;
    function GetHasOfferedInList : Boolean;
    function GetCategoryList : TFhirCodeableConceptList;
    function GetHasCategoryList : Boolean;
    function GetType_List : TFhirCodeableConceptList;
    function GetHasType_List : Boolean;
    function GetSpecialtyList : TFhirCodeableConceptList;
    function GetHasSpecialtyList : Boolean;
    function GetLocationList : TFhirReferenceList;
    function GetHasLocationList : Boolean;
    procedure SetName(value : TFhirString);
    function GetNameST : String;
    procedure SetNameST(value : String);
    procedure SetComment(value : TFhirString);
    function GetCommentST : String;
    procedure SetCommentST(value : String);
    procedure SetExtraDetails(value : TFhirMarkdown);
    function GetExtraDetailsST : String;
    procedure SetExtraDetailsST(value : String);
    procedure SetPhoto(value : TFhirAttachment);
    function GetContactList : TFhirExtendedContactDetailList;
    function GetHasContactList : Boolean;
    function GetCoverageAreaList : TFhirReferenceList;
    function GetHasCoverageAreaList : Boolean;
    function GetServiceProvisionCodeList : TFhirCodeableConceptList;
    function GetHasServiceProvisionCodeList : Boolean;
    function GetEligibilityList : TFhirHealthcareServiceEligibilityList;
    function GetHasEligibilityList : Boolean;
    function GetProgram_List : TFhirCodeableConceptList;
    function GetHasProgram_List : Boolean;
    function GetCharacteristicList : TFhirCodeableConceptList;
    function GetHasCharacteristicList : Boolean;
    function GetCommunicationList : TFhirCodeableConceptList;
    function GetHasCommunicationList : Boolean;
    function GetReferralMethodList : TFhirCodeableConceptList;
    function GetHasReferralMethodList : Boolean;
    procedure SetAppointmentRequired(value : TFhirBoolean);
    function GetAppointmentRequiredST : Boolean;
    procedure SetAppointmentRequiredST(value : Boolean);
    function GetAvailabilityList : TFhirAvailabilityList;
    function GetHasAvailabilityList : Boolean;
    function GetEndpointList : TFhirReferenceList;
    function GetHasEndpointList : Boolean;
  
    function GetResourceType : TFhirResourceType; override;
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirHealthcareService; overload;
    function Clone : TFhirHealthcareService; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // External identifiers for this item.
    property identifierList : TFhirIdentifierList read GetIdentifierList;
    property hasIdentifierList : boolean read GetHasIdentifierList;

    // Typed access to This flag is used to mark the record to not be used. This is not used when a center is closed for maintenance, or for holidays, the notAvailable period is to be used for this.
    property active : Boolean read GetActiveST write SetActiveST;
    // This flag is used to mark the record to not be used. This is not used when a center is closed for maintenance, or for holidays, the notAvailable period is to be used for this.
    property activeElement : TFhirBoolean read FActive write SetActive;

    // Typed access to The organization that provides this healthcare service. (defined for API consistency)
    property providedBy : TFhirReference read FProvidedBy write SetProvidedBy;
    // The organization that provides this healthcare service.
    property providedByElement : TFhirReference read FProvidedBy write SetProvidedBy;

    // When the HealthcareService is representing a specific, schedulable service, the availableIn property can refer to a generic service.
    property offeredInList : TFhirReferenceList read GetOfferedInList;
    property hasOfferedInList : boolean read GetHasOfferedInList;

    // Identifies the broad category of service being performed or delivered.
    property categoryList : TFhirCodeableConceptList read GetCategoryList;
    property hasCategoryList : boolean read GetHasCategoryList;

    // The specific type of service that may be delivered or performed.
    property type_List : TFhirCodeableConceptList read GetType_List;
    property hasType_List : boolean read GetHasType_List;

    // Collection of specialties handled by the Healthcare service. This is more of a medical term.
    property specialtyList : TFhirCodeableConceptList read GetSpecialtyList;
    property hasSpecialtyList : boolean read GetHasSpecialtyList;

    // The location(s) where this healthcare service may be provided.
    property locationList : TFhirReferenceList read GetLocationList;
    property hasLocationList : boolean read GetHasLocationList;

    // Typed access to Further description of the service as it would be presented to a consumer while searching.
    property name : String read GetNameST write SetNameST;
    // Further description of the service as it would be presented to a consumer while searching.
    property nameElement : TFhirString read FName write SetName;

    // Typed access to Any additional description of the service and/or any specific issues not covered by the other attributes, which can be displayed as further detail under the serviceName.
    property comment : String read GetCommentST write SetCommentST;
    // Any additional description of the service and/or any specific issues not covered by the other attributes, which can be displayed as further detail under the serviceName.
    property commentElement : TFhirString read FComment write SetComment;

    // Typed access to Extra details about the service that can't be placed in the other fields.
    property extraDetails : String read GetExtraDetailsST write SetExtraDetailsST;
    // Extra details about the service that can't be placed in the other fields.
    property extraDetailsElement : TFhirMarkdown read FExtraDetails write SetExtraDetails;

    // Typed access to If there is a photo/symbol associated with this HealthcareService, it may be included here to facilitate quick identification of the service in a list. (defined for API consistency)
    property photo : TFhirAttachment read FPhoto write SetPhoto;
    // If there is a photo/symbol associated with this HealthcareService, it may be included here to facilitate quick identification of the service in a list.
    property photoElement : TFhirAttachment read FPhoto write SetPhoto;

    // The contact details of communication devices available relevant to the specific HealthcareService. This can include addresses, phone numbers, fax numbers, mobile numbers, email addresses and web sites.
    property contactList : TFhirExtendedContactDetailList read GetContactList;
    property hasContactList : boolean read GetHasContactList;

    // The location(s) that this service is available to (not where the service is provided).
    property coverageAreaList : TFhirReferenceList read GetCoverageAreaList;
    property hasCoverageAreaList : boolean read GetHasCoverageAreaList;

    // The code(s) that detail the conditions under which the healthcare service is available/offered.
    property serviceProvisionCodeList : TFhirCodeableConceptList read GetServiceProvisionCodeList;
    property hasServiceProvisionCodeList : boolean read GetHasServiceProvisionCodeList;

    // Does this service have specific eligibility requirements that need to be met in order to use the service?
    property eligibilityList : TFhirHealthcareServiceEligibilityList read GetEligibilityList;
    property hasEligibilityList : boolean read GetHasEligibilityList;

    // Programs that this service is applicable to.
    property program_List : TFhirCodeableConceptList read GetProgram_List;
    property hasProgram_List : boolean read GetHasProgram_List;

    // Collection of characteristics (attributes).
    property characteristicList : TFhirCodeableConceptList read GetCharacteristicList;
    property hasCharacteristicList : boolean read GetHasCharacteristicList;

    // Some services are specifically made available in multiple languages, this property permits a directory to declare the languages this is offered in. Typically this is only provided where a service operates in communities with mixed languages used.
    property communicationList : TFhirCodeableConceptList read GetCommunicationList;
    property hasCommunicationList : boolean read GetHasCommunicationList;

    // Ways that the service accepts referrals, if this is not provided then it is implied that no referral is required.
    property referralMethodList : TFhirCodeableConceptList read GetReferralMethodList;
    property hasReferralMethodList : boolean read GetHasReferralMethodList;

    // Typed access to Indicates whether or not a prospective consumer will require an appointment for a particular service at a site to be provided by the Organization. Indicates if an appointment is required for access to this service.
    property appointmentRequired : Boolean read GetAppointmentRequiredST write SetAppointmentRequiredST;
    // Indicates whether or not a prospective consumer will require an appointment for a particular service at a site to be provided by the Organization. Indicates if an appointment is required for access to this service.
    property appointmentRequiredElement : TFhirBoolean read FAppointmentRequired write SetAppointmentRequired;

    // A collection of times that the healthcare service is available.
    property availabilityList : TFhirAvailabilityList read GetAvailabilityList;
    property hasAvailabilityList : boolean read GetHasAvailabilityList;

    // Technical endpoints providing access to services operated for the specific healthcare services defined at this resource.
    property endpointList : TFhirReferenceList read GetEndpointList;
    property hasEndpointList : boolean read GetHasEndpointList;

  end;

  TFhirHealthcareServiceListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirHealthcareServiceList;
    function GetCurrent : TFhirHealthcareService;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirHealthcareServiceList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirHealthcareService read GetCurrent;
  end;

  TFhirHealthcareServiceList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirHealthcareService;
    procedure SetItemN(index : Integer; value : TFhirHealthcareService);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirHealthcareServiceList; overload;
    function Clone : TFhirHealthcareServiceList; overload;
    function GetEnumerator : TFhirHealthcareServiceListEnumerator;
    
    //  Add a FhirHealthcareService to the end of the list.
    function Append : TFhirHealthcareService;
    
    // Add an already existing FhirHealthcareService to the end of the list.
    function AddItem(value : TFhirHealthcareService) : TFhirHealthcareService; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirHealthcareService) : Integer;
    
    // Insert FhirHealthcareService before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirHealthcareService;
    
    // Insert an existing FhirHealthcareService before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirHealthcareService);
    
    // Get the iIndexth FhirHealthcareService. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirHealthcareService);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirHealthcareService;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirHealthcareServices[index : Integer] : TFhirHealthcareService read GetItemN write SetItemN; default;
  End;

{$ENDIF FHIR_HEALTHCARESERVICE}
{$IFDEF FHIR_LOCATION}
  // The absolute geographic location of the Location, expressed using the WGS84 datum (This is the same co-ordinate system used in KML).
  TFhirLocationPosition = class (TFhirBackboneElement)
  protected
    FLongitude : TFhirDecimal;
    FLatitude : TFhirDecimal;
    FAltitude : TFhirDecimal;
    procedure SetLongitude(value : TFhirDecimal);
    function GetLongitudeST : String;
    procedure SetLongitudeST(value : String);
    procedure SetLatitude(value : TFhirDecimal);
    function GetLatitudeST : String;
    procedure SetLatitudeST(value : String);
    procedure SetAltitude(value : TFhirDecimal);
    function GetAltitudeST : String;
    procedure SetAltitudeST(value : String);
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirLocationPosition; overload;
    function Clone : TFhirLocationPosition; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to Longitude. The value domain and the interpretation are the same as for the text of the longitude element in KML (see notes on Location main page).
    property longitude : String read GetLongitudeST write SetLongitudeST;
    // Longitude. The value domain and the interpretation are the same as for the text of the longitude element in KML (see notes on Location main page).
    property longitudeElement : TFhirDecimal read FLongitude write SetLongitude;

    // Typed access to Latitude. The value domain and the interpretation are the same as for the text of the latitude element in KML (see notes on Location main page).
    property latitude : String read GetLatitudeST write SetLatitudeST;
    // Latitude. The value domain and the interpretation are the same as for the text of the latitude element in KML (see notes on Location main page).
    property latitudeElement : TFhirDecimal read FLatitude write SetLatitude;

    // Typed access to Altitude. The value domain and the interpretation are the same as for the text of the altitude element in KML (see notes on Location main page).
    property altitude : String read GetAltitudeST write SetAltitudeST;
    // Altitude. The value domain and the interpretation are the same as for the text of the altitude element in KML (see notes on Location main page).
    property altitudeElement : TFhirDecimal read FAltitude write SetAltitude;

  end;

  TFhirLocationPositionListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirLocationPositionList;
    function GetCurrent : TFhirLocationPosition;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirLocationPositionList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirLocationPosition read GetCurrent;
  end;

  TFhirLocationPositionList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirLocationPosition;
    procedure SetItemN(index : Integer; value : TFhirLocationPosition);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirLocationPositionList; overload;
    function Clone : TFhirLocationPositionList; overload;
    function GetEnumerator : TFhirLocationPositionListEnumerator;
    
    //  Add a FhirLocationPosition to the end of the list.
    function Append : TFhirLocationPosition;
    
    // Add an already existing FhirLocationPosition to the end of the list.
    function AddItem(value : TFhirLocationPosition) : TFhirLocationPosition; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirLocationPosition) : Integer;
    
    // Insert FhirLocationPosition before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirLocationPosition;
    
    // Insert an existing FhirLocationPosition before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirLocationPosition);
    
    // Get the iIndexth FhirLocationPosition. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirLocationPosition);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirLocationPosition;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirLocationPositions[index : Integer] : TFhirLocationPosition read GetItemN write SetItemN; default;
  End;

  // Details and position information for a physical place where services are provided and resources and participants may be stored, found, contained, or accommodated.
  TFhirLocation = class (TFhirDomainResource)
  protected
    FidentifierList : TFhirIdentifierList;
    FStatus : TFhirEnum;
    FOperationalStatus : TFhirCoding;
    FName : TFhirString;
    FaliasList : TFhirStringList;
    FDescription : TFhirString;
    FMode : TFhirEnum;
    Ftype_List : TFhirCodeableConceptList;
    FcontactList : TFhirExtendedContactDetailList;
    FAddress : TFhirAddress;
    FForm : TFhirCodeableConcept;
    FPosition : TFhirLocationPosition;
    FManagingOrganization : TFhirReference;
    FPartOf : TFhirReference;
    FcharacteristicList : TFhirCodeableConceptList;
    FhoursOfOperationList : TFhirAvailabilityList;
    FvirtualServiceList : TFhirVirtualServiceDetailList;
    FendpointList : TFhirReferenceList;
    function GetIdentifierList : TFhirIdentifierList;
    function GetHasIdentifierList : Boolean;
    procedure SetStatus(value : TFhirEnum);
    function GetStatusST : TFhirLocationStatusEnum;
    procedure SetStatusST(value : TFhirLocationStatusEnum);
    procedure SetOperationalStatus(value : TFhirCoding);
    procedure SetName(value : TFhirString);
    function GetNameST : String;
    procedure SetNameST(value : String);
    function GetAliasList : TFhirStringList;
    function GetHasAliasList : Boolean;
    procedure SetDescription(value : TFhirString);
    function GetDescriptionST : String;
    procedure SetDescriptionST(value : String);
    procedure SetMode(value : TFhirEnum);
    function GetModeST : TFhirLocationModeEnum;
    procedure SetModeST(value : TFhirLocationModeEnum);
    function GetType_List : TFhirCodeableConceptList;
    function GetHasType_List : Boolean;
    function GetContactList : TFhirExtendedContactDetailList;
    function GetHasContactList : Boolean;
    procedure SetAddress(value : TFhirAddress);
    procedure SetForm(value : TFhirCodeableConcept);
    procedure SetPosition(value : TFhirLocationPosition);
    procedure SetManagingOrganization(value : TFhirReference);
    procedure SetPartOf(value : TFhirReference);
    function GetCharacteristicList : TFhirCodeableConceptList;
    function GetHasCharacteristicList : Boolean;
    function GetHoursOfOperationList : TFhirAvailabilityList;
    function GetHasHoursOfOperationList : Boolean;
    function GetVirtualServiceList : TFhirVirtualServiceDetailList;
    function GetHasVirtualServiceList : Boolean;
    function GetEndpointList : TFhirReferenceList;
    function GetHasEndpointList : Boolean;
  
    function GetResourceType : TFhirResourceType; override;
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirLocation; overload;
    function Clone : TFhirLocation; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Unique code or number identifying the location to its users.
    property identifierList : TFhirIdentifierList read GetIdentifierList;
    property hasIdentifierList : boolean read GetHasIdentifierList;

    // The status property covers the general availability of the resource, not the current value which may be covered by the operationStatus, or by a schedule/slots if they are configured for the location.
    property status : TFhirLocationStatusEnum read GetStatusST write SetStatusST;
    property statusElement : TFhirEnum read FStatus write SetStatus;

    // Typed access to The operational status covers operation values most relevant to beds (but can also apply to rooms/units/chairs/etc. such as an isolation unit/dialysis chair). This typically covers concepts such as contamination, housekeeping, and other activities like maintenance. (defined for API consistency)
    property operationalStatus : TFhirCoding read FOperationalStatus write SetOperationalStatus;
    // The operational status covers operation values most relevant to beds (but can also apply to rooms/units/chairs/etc. such as an isolation unit/dialysis chair). This typically covers concepts such as contamination, housekeeping, and other activities like maintenance.
    property operationalStatusElement : TFhirCoding read FOperationalStatus write SetOperationalStatus;

    // Typed access to Name of the location as used by humans. Does not need to be unique.
    property name : String read GetNameST write SetNameST;
    // Name of the location as used by humans. Does not need to be unique.
    property nameElement : TFhirString read FName write SetName;

    // A list of alternate names that the location is known as, or was known as, in the past.
    property aliasList : TFhirStringList read GetAliasList;
    property hasAliasList : boolean read GetHasAliasList;

    // Typed access to Description of the Location, which helps in finding or referencing the place.
    property description : String read GetDescriptionST write SetDescriptionST;
    // Description of the Location, which helps in finding or referencing the place.
    property descriptionElement : TFhirString read FDescription write SetDescription;

    // Indicates whether a resource instance represents a specific location or a class of locations.
    property mode : TFhirLocationModeEnum read GetModeST write SetModeST;
    property modeElement : TFhirEnum read FMode write SetMode;

    // Indicates the type of function performed at the location.
    property type_List : TFhirCodeableConceptList read GetType_List;
    property hasType_List : boolean read GetHasType_List;

    // The contact details of communication devices available at the location. This can include addresses, phone numbers, fax numbers, mobile numbers, email addresses and web sites.
    property contactList : TFhirExtendedContactDetailList read GetContactList;
    property hasContactList : boolean read GetHasContactList;

    // Typed access to Physical location. (defined for API consistency)
    property address : TFhirAddress read FAddress write SetAddress;
    // Physical location.
    property addressElement : TFhirAddress read FAddress write SetAddress;

    // Typed access to Physical form of the location, e.g. building, room, vehicle, road, virtual. (defined for API consistency)
    property form : TFhirCodeableConcept read FForm write SetForm;
    // Physical form of the location, e.g. building, room, vehicle, road, virtual.
    property formElement : TFhirCodeableConcept read FForm write SetForm;

    // Typed access to The absolute geographic location of the Location, expressed using the WGS84 datum (This is the same co-ordinate system used in KML). (defined for API consistency)
    property position : TFhirLocationPosition read FPosition write SetPosition;
    // The absolute geographic location of the Location, expressed using the WGS84 datum (This is the same co-ordinate system used in KML).
    property positionElement : TFhirLocationPosition read FPosition write SetPosition;

    // Typed access to The organization responsible for the provisioning and upkeep of the location. (defined for API consistency)
    property managingOrganization : TFhirReference read FManagingOrganization write SetManagingOrganization;
    // The organization responsible for the provisioning and upkeep of the location.
    property managingOrganizationElement : TFhirReference read FManagingOrganization write SetManagingOrganization;

    // Typed access to Another Location of which this Location is physically a part of. (defined for API consistency)
    property partOf : TFhirReference read FPartOf write SetPartOf;
    // Another Location of which this Location is physically a part of.
    property partOfElement : TFhirReference read FPartOf write SetPartOf;

    // Collection of characteristics (attributes).
    property characteristicList : TFhirCodeableConceptList read GetCharacteristicList;
    property hasCharacteristicList : boolean read GetHasCharacteristicList;

    // What days/times during a week is this location usually open, and any exceptions where the location is not available.
    property hoursOfOperationList : TFhirAvailabilityList read GetHoursOfOperationList;
    property hasHoursOfOperationList : boolean read GetHasHoursOfOperationList;

    // Connection details of a virtual service (e.g. shared conference call facility with dedicated number/details).
    property virtualServiceList : TFhirVirtualServiceDetailList read GetVirtualServiceList;
    property hasVirtualServiceList : boolean read GetHasVirtualServiceList;

    // Technical endpoints providing access to services operated for the location.
    property endpointList : TFhirReferenceList read GetEndpointList;
    property hasEndpointList : boolean read GetHasEndpointList;

  end;

  TFhirLocationListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirLocationList;
    function GetCurrent : TFhirLocation;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirLocationList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirLocation read GetCurrent;
  end;

  TFhirLocationList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirLocation;
    procedure SetItemN(index : Integer; value : TFhirLocation);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirLocationList; overload;
    function Clone : TFhirLocationList; overload;
    function GetEnumerator : TFhirLocationListEnumerator;
    
    //  Add a FhirLocation to the end of the list.
    function Append : TFhirLocation;
    
    // Add an already existing FhirLocation to the end of the list.
    function AddItem(value : TFhirLocation) : TFhirLocation; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirLocation) : Integer;
    
    // Insert FhirLocation before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirLocation;
    
    // Insert an existing FhirLocation before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirLocation);
    
    // Get the iIndexth FhirLocation. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirLocation);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirLocation;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirLocations[index : Integer] : TFhirLocation read GetItemN write SetItemN; default;
  End;

{$ENDIF FHIR_LOCATION}
{$IFDEF FHIR_ORGANIZATION}
  // The official certifications, accreditations, training, designations and licenses that authorize and/or otherwise endorse the provision of care by the organization.  For example, an approval to provide a type of services issued by a certifying body (such as the US Joint Commission) to an organization.
  TFhirOrganizationQualification = class (TFhirBackboneElement)
  protected
    FidentifierList : TFhirIdentifierList;
    FCode : TFhirCodeableConcept;
    FPeriod : TFhirPeriod;
    FIssuer : TFhirReference;
    function GetIdentifierList : TFhirIdentifierList;
    function GetHasIdentifierList : Boolean;
    procedure SetCode(value : TFhirCodeableConcept);
    procedure SetPeriod(value : TFhirPeriod);
    procedure SetIssuer(value : TFhirReference);
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirOrganizationQualification; overload;
    function Clone : TFhirOrganizationQualification; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // An identifier allocated to this qualification for this organization.
    property identifierList : TFhirIdentifierList read GetIdentifierList;
    property hasIdentifierList : boolean read GetHasIdentifierList;

    // Typed access to Coded representation of the qualification. (defined for API consistency)
    property code : TFhirCodeableConcept read FCode write SetCode;
    // Coded representation of the qualification.
    property codeElement : TFhirCodeableConcept read FCode write SetCode;

    // Typed access to Period during which the qualification is valid. (defined for API consistency)
    property period : TFhirPeriod read FPeriod write SetPeriod;
    // Period during which the qualification is valid.
    property periodElement : TFhirPeriod read FPeriod write SetPeriod;

    // Typed access to Organization that regulates and issues the qualification. (defined for API consistency)
    property issuer : TFhirReference read FIssuer write SetIssuer;
    // Organization that regulates and issues the qualification.
    property issuerElement : TFhirReference read FIssuer write SetIssuer;

  end;

  TFhirOrganizationQualificationListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirOrganizationQualificationList;
    function GetCurrent : TFhirOrganizationQualification;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirOrganizationQualificationList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirOrganizationQualification read GetCurrent;
  end;

  TFhirOrganizationQualificationList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirOrganizationQualification;
    procedure SetItemN(index : Integer; value : TFhirOrganizationQualification);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirOrganizationQualificationList; overload;
    function Clone : TFhirOrganizationQualificationList; overload;
    function GetEnumerator : TFhirOrganizationQualificationListEnumerator;
    
    //  Add a FhirOrganizationQualification to the end of the list.
    function Append : TFhirOrganizationQualification;
    
    // Add an already existing FhirOrganizationQualification to the end of the list.
    function AddItem(value : TFhirOrganizationQualification) : TFhirOrganizationQualification; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirOrganizationQualification) : Integer;
    
    // Insert FhirOrganizationQualification before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirOrganizationQualification;
    
    // Insert an existing FhirOrganizationQualification before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirOrganizationQualification);
    
    // Get the iIndexth FhirOrganizationQualification. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirOrganizationQualification);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirOrganizationQualification;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirOrganizationQualifications[index : Integer] : TFhirOrganizationQualification read GetItemN write SetItemN; default;
  End;

  // A formally or informally recognized grouping of people or organizations formed for the purpose of achieving some form of collective action.  Includes companies, institutions, corporations, departments, community groups, healthcare practice groups, payer/insurer, etc.
  TFhirOrganization = class (TFhirDomainResource)
  protected
    FidentifierList : TFhirIdentifierList;
    FActive : TFhirBoolean;
    Ftype_List : TFhirCodeableConceptList;
    FName : TFhirString;
    FaliasList : TFhirStringList;
    FDescription : TFhirString;
    FcontactList : TFhirExtendedContactDetailList;
    FPartOf : TFhirReference;
    FendpointList : TFhirReferenceList;
    FqualificationList : TFhirOrganizationQualificationList;
    function GetIdentifierList : TFhirIdentifierList;
    function GetHasIdentifierList : Boolean;
    procedure SetActive(value : TFhirBoolean);
    function GetActiveST : Boolean;
    procedure SetActiveST(value : Boolean);
    function GetType_List : TFhirCodeableConceptList;
    function GetHasType_List : Boolean;
    procedure SetName(value : TFhirString);
    function GetNameST : String;
    procedure SetNameST(value : String);
    function GetAliasList : TFhirStringList;
    function GetHasAliasList : Boolean;
    procedure SetDescription(value : TFhirString);
    function GetDescriptionST : String;
    procedure SetDescriptionST(value : String);
    function GetContactList : TFhirExtendedContactDetailList;
    function GetHasContactList : Boolean;
    procedure SetPartOf(value : TFhirReference);
    function GetEndpointList : TFhirReferenceList;
    function GetHasEndpointList : Boolean;
    function GetQualificationList : TFhirOrganizationQualificationList;
    function GetHasQualificationList : Boolean;
  
    function GetResourceType : TFhirResourceType; override;
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirOrganization; overload;
    function Clone : TFhirOrganization; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Identifier for the organization that is used to identify the organization across multiple disparate systems.
    property identifierList : TFhirIdentifierList read GetIdentifierList;
    property hasIdentifierList : boolean read GetHasIdentifierList;

    // Typed access to Whether the organization's record is still in active use.
    property active : Boolean read GetActiveST write SetActiveST;
    // Whether the organization's record is still in active use.
    property activeElement : TFhirBoolean read FActive write SetActive;

    // The kind(s) of organization that this is.
    property type_List : TFhirCodeableConceptList read GetType_List;
    property hasType_List : boolean read GetHasType_List;

    // Typed access to A name associated with the organization.
    property name : String read GetNameST write SetNameST;
    // A name associated with the organization.
    property nameElement : TFhirString read FName write SetName;

    // A list of alternate names that the organization is known as, or was known as in the past.
    property aliasList : TFhirStringList read GetAliasList;
    property hasAliasList : boolean read GetHasAliasList;

    // Typed access to Description of the organization, which helps provide additional general context on the organization to ensure that the correct organization is selected.
    property description : String read GetDescriptionST write SetDescriptionST;
    // Description of the organization, which helps provide additional general context on the organization to ensure that the correct organization is selected.
    property descriptionElement : TFhirString read FDescription write SetDescription;

    // The contact details of communication devices available relevant to the specific Organization. This can include addresses, phone numbers, fax numbers, mobile numbers, email addresses and web sites.
    property contactList : TFhirExtendedContactDetailList read GetContactList;
    property hasContactList : boolean read GetHasContactList;

    // Typed access to The organization of which this organization forms a part. (defined for API consistency)
    property partOf : TFhirReference read FPartOf write SetPartOf;
    // The organization of which this organization forms a part.
    property partOfElement : TFhirReference read FPartOf write SetPartOf;

    // Technical endpoints providing access to services operated for the organization.
    property endpointList : TFhirReferenceList read GetEndpointList;
    property hasEndpointList : boolean read GetHasEndpointList;

    // The official certifications, accreditations, training, designations and licenses that authorize and/or otherwise endorse the provision of care by the organization.  For example, an approval to provide a type of services issued by a certifying body (such as the US Joint Commission) to an organization.
    property qualificationList : TFhirOrganizationQualificationList read GetQualificationList;
    property hasQualificationList : boolean read GetHasQualificationList;

  end;

  TFhirOrganizationListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirOrganizationList;
    function GetCurrent : TFhirOrganization;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirOrganizationList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirOrganization read GetCurrent;
  end;

  TFhirOrganizationList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirOrganization;
    procedure SetItemN(index : Integer; value : TFhirOrganization);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirOrganizationList; overload;
    function Clone : TFhirOrganizationList; overload;
    function GetEnumerator : TFhirOrganizationListEnumerator;
    
    //  Add a FhirOrganization to the end of the list.
    function Append : TFhirOrganization;
    
    // Add an already existing FhirOrganization to the end of the list.
    function AddItem(value : TFhirOrganization) : TFhirOrganization; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirOrganization) : Integer;
    
    // Insert FhirOrganization before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirOrganization;
    
    // Insert an existing FhirOrganization before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirOrganization);
    
    // Get the iIndexth FhirOrganization. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirOrganization);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirOrganization;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirOrganizations[index : Integer] : TFhirOrganization read GetItemN write SetItemN; default;
  End;

{$ENDIF FHIR_ORGANIZATION}
{$IFDEF FHIR_ORGANIZATIONAFFILIATION}
  // Defines an affiliation/assotiation/relationship between 2 distinct organizations, that is not a part-of relationship/sub-division relationship.
  TFhirOrganizationAffiliation = class (TFhirDomainResource)
  protected
    FidentifierList : TFhirIdentifierList;
    FActive : TFhirBoolean;
    FPeriod : TFhirPeriod;
    FOrganization : TFhirReference;
    FParticipatingOrganization : TFhirReference;
    FnetworkList : TFhirReferenceList;
    FcodeList : TFhirCodeableConceptList;
    FspecialtyList : TFhirCodeableConceptList;
    FlocationList : TFhirReferenceList;
    FhealthcareServiceList : TFhirReferenceList;
    FcontactList : TFhirExtendedContactDetailList;
    FendpointList : TFhirReferenceList;
    function GetIdentifierList : TFhirIdentifierList;
    function GetHasIdentifierList : Boolean;
    procedure SetActive(value : TFhirBoolean);
    function GetActiveST : Boolean;
    procedure SetActiveST(value : Boolean);
    procedure SetPeriod(value : TFhirPeriod);
    procedure SetOrganization(value : TFhirReference);
    procedure SetParticipatingOrganization(value : TFhirReference);
    function GetNetworkList : TFhirReferenceList;
    function GetHasNetworkList : Boolean;
    function GetCodeList : TFhirCodeableConceptList;
    function GetHasCodeList : Boolean;
    function GetSpecialtyList : TFhirCodeableConceptList;
    function GetHasSpecialtyList : Boolean;
    function GetLocationList : TFhirReferenceList;
    function GetHasLocationList : Boolean;
    function GetHealthcareServiceList : TFhirReferenceList;
    function GetHasHealthcareServiceList : Boolean;
    function GetContactList : TFhirExtendedContactDetailList;
    function GetHasContactList : Boolean;
    function GetEndpointList : TFhirReferenceList;
    function GetHasEndpointList : Boolean;
  
    function GetResourceType : TFhirResourceType; override;
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirOrganizationAffiliation; overload;
    function Clone : TFhirOrganizationAffiliation; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Business identifiers that are specific to this role.
    property identifierList : TFhirIdentifierList read GetIdentifierList;
    property hasIdentifierList : boolean read GetHasIdentifierList;

    // Typed access to Whether this organization affiliation record is in active use.
    property active : Boolean read GetActiveST write SetActiveST;
    // Whether this organization affiliation record is in active use.
    property activeElement : TFhirBoolean read FActive write SetActive;

    // Typed access to The period during which the participatingOrganization is affiliated with the primary organization. (defined for API consistency)
    property period : TFhirPeriod read FPeriod write SetPeriod;
    // The period during which the participatingOrganization is affiliated with the primary organization.
    property periodElement : TFhirPeriod read FPeriod write SetPeriod;

    // Typed access to Organization where the role is available (primary organization/has members). (defined for API consistency)
    property organization : TFhirReference read FOrganization write SetOrganization;
    // Organization where the role is available (primary organization/has members).
    property organizationElement : TFhirReference read FOrganization write SetOrganization;

    // Typed access to The Participating Organization provides/performs the role(s) defined by the code to the Primary Organization (e.g. providing services or is a member of). (defined for API consistency)
    property participatingOrganization : TFhirReference read FParticipatingOrganization write SetParticipatingOrganization;
    // The Participating Organization provides/performs the role(s) defined by the code to the Primary Organization (e.g. providing services or is a member of).
    property participatingOrganizationElement : TFhirReference read FParticipatingOrganization write SetParticipatingOrganization;

    // The network in which the participatingOrganization provides the role's services (if defined) at the indicated locations (if defined).
    property networkList : TFhirReferenceList read GetNetworkList;
    property hasNetworkList : boolean read GetHasNetworkList;

    // Definition of the role the participatingOrganization plays in the association.
    property codeList : TFhirCodeableConceptList read GetCodeList;
    property hasCodeList : boolean read GetHasCodeList;

    // Specific specialty of the participatingOrganization in the context of the role.
    property specialtyList : TFhirCodeableConceptList read GetSpecialtyList;
    property hasSpecialtyList : boolean read GetHasSpecialtyList;

    // The location(s) at which the role occurs.
    property locationList : TFhirReferenceList read GetLocationList;
    property hasLocationList : boolean read GetHasLocationList;

    // Healthcare services provided through the role.
    property healthcareServiceList : TFhirReferenceList read GetHealthcareServiceList;
    property hasHealthcareServiceList : boolean read GetHasHealthcareServiceList;

    // The contact details of communication devices available at the participatingOrganization relevant to this Affiliation.
    property contactList : TFhirExtendedContactDetailList read GetContactList;
    property hasContactList : boolean read GetHasContactList;

    // Technical endpoints providing access to services operated for this role.
    property endpointList : TFhirReferenceList read GetEndpointList;
    property hasEndpointList : boolean read GetHasEndpointList;

  end;

  TFhirOrganizationAffiliationListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirOrganizationAffiliationList;
    function GetCurrent : TFhirOrganizationAffiliation;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirOrganizationAffiliationList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirOrganizationAffiliation read GetCurrent;
  end;

  TFhirOrganizationAffiliationList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirOrganizationAffiliation;
    procedure SetItemN(index : Integer; value : TFhirOrganizationAffiliation);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirOrganizationAffiliationList; overload;
    function Clone : TFhirOrganizationAffiliationList; overload;
    function GetEnumerator : TFhirOrganizationAffiliationListEnumerator;
    
    //  Add a FhirOrganizationAffiliation to the end of the list.
    function Append : TFhirOrganizationAffiliation;
    
    // Add an already existing FhirOrganizationAffiliation to the end of the list.
    function AddItem(value : TFhirOrganizationAffiliation) : TFhirOrganizationAffiliation; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirOrganizationAffiliation) : Integer;
    
    // Insert FhirOrganizationAffiliation before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirOrganizationAffiliation;
    
    // Insert an existing FhirOrganizationAffiliation before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirOrganizationAffiliation);
    
    // Get the iIndexth FhirOrganizationAffiliation. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirOrganizationAffiliation);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirOrganizationAffiliation;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirOrganizationAffiliations[index : Integer] : TFhirOrganizationAffiliation read GetItemN write SetItemN; default;
  End;

{$ENDIF FHIR_ORGANIZATIONAFFILIATION}
{$IFDEF FHIR_PATIENT}
  // A contact party (e.g. guardian, partner, friend) for the patient.
  TFhirPatientContact = class (TFhirBackboneElement)
  protected
    FrelationshipList : TFhirCodeableConceptList;
    FName : TFhirHumanName;
    FtelecomList : TFhirContactPointList;
    FAddress : TFhirAddress;
    FGender : TFhirEnum;
    FOrganization : TFhirReference;
    FPeriod : TFhirPeriod;
    function GetRelationshipList : TFhirCodeableConceptList;
    function GetHasRelationshipList : Boolean;
    procedure SetName(value : TFhirHumanName);
    function GetTelecomList : TFhirContactPointList;
    function GetHasTelecomList : Boolean;
    procedure SetAddress(value : TFhirAddress);
    procedure SetGender(value : TFhirEnum);
    function GetGenderST : TFhirAdministrativeGenderEnum;
    procedure SetGenderST(value : TFhirAdministrativeGenderEnum);
    procedure SetOrganization(value : TFhirReference);
    procedure SetPeriod(value : TFhirPeriod);
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirPatientContact; overload;
    function Clone : TFhirPatientContact; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // The nature of the relationship between the patient and the contact person.
    property relationshipList : TFhirCodeableConceptList read GetRelationshipList;
    property hasRelationshipList : boolean read GetHasRelationshipList;

    // Typed access to A name associated with the contact person. (defined for API consistency)
    property name : TFhirHumanName read FName write SetName;
    // A name associated with the contact person.
    property nameElement : TFhirHumanName read FName write SetName;

    // A contact detail for the person, e.g. a telephone number or an email address.
    property telecomList : TFhirContactPointList read GetTelecomList;
    property hasTelecomList : boolean read GetHasTelecomList;

    // Typed access to Address for the contact person. (defined for API consistency)
    property address : TFhirAddress read FAddress write SetAddress;
    // Address for the contact person.
    property addressElement : TFhirAddress read FAddress write SetAddress;

    // Administrative Gender - the gender that the contact person is considered to have for administration and record keeping purposes.
    property gender : TFhirAdministrativeGenderEnum read GetGenderST write SetGenderST;
    property genderElement : TFhirEnum read FGender write SetGender;

    // Typed access to Organization on behalf of which the contact is acting or for which the contact is working. (defined for API consistency)
    property organization : TFhirReference read FOrganization write SetOrganization;
    // Organization on behalf of which the contact is acting or for which the contact is working.
    property organizationElement : TFhirReference read FOrganization write SetOrganization;

    // Typed access to The period during which this contact person or organization is valid to be contacted relating to this patient. (defined for API consistency)
    property period : TFhirPeriod read FPeriod write SetPeriod;
    // The period during which this contact person or organization is valid to be contacted relating to this patient.
    property periodElement : TFhirPeriod read FPeriod write SetPeriod;

  end;

  TFhirPatientContactListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirPatientContactList;
    function GetCurrent : TFhirPatientContact;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirPatientContactList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirPatientContact read GetCurrent;
  end;

  TFhirPatientContactList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirPatientContact;
    procedure SetItemN(index : Integer; value : TFhirPatientContact);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirPatientContactList; overload;
    function Clone : TFhirPatientContactList; overload;
    function GetEnumerator : TFhirPatientContactListEnumerator;
    
    //  Add a FhirPatientContact to the end of the list.
    function Append : TFhirPatientContact;
    
    // Add an already existing FhirPatientContact to the end of the list.
    function AddItem(value : TFhirPatientContact) : TFhirPatientContact; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirPatientContact) : Integer;
    
    // Insert FhirPatientContact before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirPatientContact;
    
    // Insert an existing FhirPatientContact before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirPatientContact);
    
    // Get the iIndexth FhirPatientContact. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirPatientContact);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirPatientContact;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirPatientContacts[index : Integer] : TFhirPatientContact read GetItemN write SetItemN; default;
  End;

  // A language which may be used to communicate with the patient about his or her health.
  TFhirPatientCommunication = class (TFhirBackboneElement)
  protected
    FLanguage : TFhirCodeableConcept;
    FPreferred : TFhirBoolean;
    procedure SetLanguage(value : TFhirCodeableConcept);
    procedure SetPreferred(value : TFhirBoolean);
    function GetPreferredST : Boolean;
    procedure SetPreferredST(value : Boolean);
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirPatientCommunication; overload;
    function Clone : TFhirPatientCommunication; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to The ISO-639-1 alpha 2 code in lower case for the language, optionally followed by a hyphen and the ISO-3166-1 alpha 2 code for the region in upper case; e.g. "en" for English, or "en-US" for American English versus "en-AU" for Australian English. (defined for API consistency)
    property language : TFhirCodeableConcept read FLanguage write SetLanguage;
    // The ISO-639-1 alpha 2 code in lower case for the language, optionally followed by a hyphen and the ISO-3166-1 alpha 2 code for the region in upper case; e.g. "en" for English, or "en-US" for American English versus "en-AU" for Australian English.
    property languageElement : TFhirCodeableConcept read FLanguage write SetLanguage;

    // Typed access to Indicates whether or not the patient prefers this language (over other languages he masters up a certain level).
    property preferred : Boolean read GetPreferredST write SetPreferredST;
    // Indicates whether or not the patient prefers this language (over other languages he masters up a certain level).
    property preferredElement : TFhirBoolean read FPreferred write SetPreferred;

  end;

  TFhirPatientCommunicationListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirPatientCommunicationList;
    function GetCurrent : TFhirPatientCommunication;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirPatientCommunicationList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirPatientCommunication read GetCurrent;
  end;

  TFhirPatientCommunicationList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirPatientCommunication;
    procedure SetItemN(index : Integer; value : TFhirPatientCommunication);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirPatientCommunicationList; overload;
    function Clone : TFhirPatientCommunicationList; overload;
    function GetEnumerator : TFhirPatientCommunicationListEnumerator;
    
    //  Add a FhirPatientCommunication to the end of the list.
    function Append : TFhirPatientCommunication;
    
    // Add an already existing FhirPatientCommunication to the end of the list.
    function AddItem(value : TFhirPatientCommunication) : TFhirPatientCommunication; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirPatientCommunication) : Integer;
    
    // Insert FhirPatientCommunication before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirPatientCommunication;
    
    // Insert an existing FhirPatientCommunication before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirPatientCommunication);
    
    // Get the iIndexth FhirPatientCommunication. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirPatientCommunication);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirPatientCommunication;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirPatientCommunications[index : Integer] : TFhirPatientCommunication read GetItemN write SetItemN; default;
  End;

  // Link to a Patient or RelatedPerson resource that concerns the same actual individual.
  TFhirPatientLink = class (TFhirBackboneElement)
  protected
    FOther : TFhirReference;
    FType_ : TFhirEnum;
    procedure SetOther(value : TFhirReference);
    procedure SetType_(value : TFhirEnum);
    function GetType_ST : TFhirLinkTypeEnum;
    procedure SetType_ST(value : TFhirLinkTypeEnum);
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirPatientLink; overload;
    function Clone : TFhirPatientLink; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to Link to a Patient or RelatedPerson resource that concerns the same actual individual. (defined for API consistency)
    property other : TFhirReference read FOther write SetOther;
    // Link to a Patient or RelatedPerson resource that concerns the same actual individual.
    property otherElement : TFhirReference read FOther write SetOther;

    // The type of link between this patient resource and another patient resource.
    property type_ : TFhirLinkTypeEnum read GetType_ST write SetType_ST;
    property type_Element : TFhirEnum read FType_ write SetType_;

  end;

  TFhirPatientLinkListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirPatientLinkList;
    function GetCurrent : TFhirPatientLink;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirPatientLinkList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirPatientLink read GetCurrent;
  end;

  TFhirPatientLinkList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirPatientLink;
    procedure SetItemN(index : Integer; value : TFhirPatientLink);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirPatientLinkList; overload;
    function Clone : TFhirPatientLinkList; overload;
    function GetEnumerator : TFhirPatientLinkListEnumerator;
    
    //  Add a FhirPatientLink to the end of the list.
    function Append : TFhirPatientLink;
    
    // Add an already existing FhirPatientLink to the end of the list.
    function AddItem(value : TFhirPatientLink) : TFhirPatientLink; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirPatientLink) : Integer;
    
    // Insert FhirPatientLink before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirPatientLink;
    
    // Insert an existing FhirPatientLink before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirPatientLink);
    
    // Get the iIndexth FhirPatientLink. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirPatientLink);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirPatientLink;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirPatientLinks[index : Integer] : TFhirPatientLink read GetItemN write SetItemN; default;
  End;

  // Demographics and other administrative information about an individual or animal receiving care or other health-related services.
  TFhirPatient = class (TFhirDomainResource)
  protected
    FidentifierList : TFhirIdentifierList;
    FActive : TFhirBoolean;
    FnameList : TFhirHumanNameList;
    FtelecomList : TFhirContactPointList;
    FGender : TFhirEnum;
    FBirthDate : TFhirDate;
    FDeceased : TFhirDataType;
    FaddressList : TFhirAddressList;
    FMaritalStatus : TFhirCodeableConcept;
    FMultipleBirth : TFhirDataType;
    FphotoList : TFhirAttachmentList;
    FcontactList : TFhirPatientContactList;
    FcommunicationList : TFhirPatientCommunicationList;
    FgeneralPractitionerList : TFhirReferenceList;
    FManagingOrganization : TFhirReference;
    Flink_List : TFhirPatientLinkList;
    function GetIdentifierList : TFhirIdentifierList;
    function GetHasIdentifierList : Boolean;
    procedure SetActive(value : TFhirBoolean);
    function GetActiveST : Boolean;
    procedure SetActiveST(value : Boolean);
    function GetNameList : TFhirHumanNameList;
    function GetHasNameList : Boolean;
    function GetTelecomList : TFhirContactPointList;
    function GetHasTelecomList : Boolean;
    procedure SetGender(value : TFhirEnum);
    function GetGenderST : TFhirAdministrativeGenderEnum;
    procedure SetGenderST(value : TFhirAdministrativeGenderEnum);
    procedure SetBirthDate(value : TFhirDate);
    function GetBirthDateST : TFslDateTime;
    procedure SetBirthDateST(value : TFslDateTime);
    procedure SetDeceased(value : TFhirDataType);
    function GetAddressList : TFhirAddressList;
    function GetHasAddressList : Boolean;
    procedure SetMaritalStatus(value : TFhirCodeableConcept);
    procedure SetMultipleBirth(value : TFhirDataType);
    function GetPhotoList : TFhirAttachmentList;
    function GetHasPhotoList : Boolean;
    function GetContactList : TFhirPatientContactList;
    function GetHasContactList : Boolean;
    function GetCommunicationList : TFhirPatientCommunicationList;
    function GetHasCommunicationList : Boolean;
    function GetGeneralPractitionerList : TFhirReferenceList;
    function GetHasGeneralPractitionerList : Boolean;
    procedure SetManagingOrganization(value : TFhirReference);
    function GetLink_List : TFhirPatientLinkList;
    function GetHasLink_List : Boolean;
  
    function GetResourceType : TFhirResourceType; override;
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirPatient; overload;
    function Clone : TFhirPatient; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // An identifier for this patient.
    property identifierList : TFhirIdentifierList read GetIdentifierList;
    property hasIdentifierList : boolean read GetHasIdentifierList;

    // Typed access to Whether this patient record is in active use.  Many systems use this property to mark as non-current patients, such as those that have not been seen for a period of time based on an organization's business rules.  It is often used to filter patient lists to exclude inactive patients  Deceased patients may also be marked as inactive for the same reasons, but may be active for some time after death.
    property active : Boolean read GetActiveST write SetActiveST;
    // Whether this patient record is in active use.  Many systems use this property to mark as non-current patients, such as those that have not been seen for a period of time based on an organization's business rules.  It is often used to filter patient lists to exclude inactive patients  Deceased patients may also be marked as inactive for the same reasons, but may be active for some time after death.
    property activeElement : TFhirBoolean read FActive write SetActive;

    // A name associated with the individual.
    property nameList : TFhirHumanNameList read GetNameList;
    property hasNameList : boolean read GetHasNameList;

    // A contact detail (e.g. a telephone number or an email address) by which the individual may be contacted.
    property telecomList : TFhirContactPointList read GetTelecomList;
    property hasTelecomList : boolean read GetHasTelecomList;

    // Administrative Gender - the gender that the patient is considered to have for administration and record keeping purposes.
    property gender : TFhirAdministrativeGenderEnum read GetGenderST write SetGenderST;
    property genderElement : TFhirEnum read FGender write SetGender;

    // Typed access to The date of birth for the individual.
    property birthDate : TFslDateTime read GetBirthDateST write SetBirthDateST;
    // The date of birth for the individual.
    property birthDateElement : TFhirDate read FBirthDate write SetBirthDate;

    // Typed access to Indicates if the individual is deceased or not. (defined for API consistency)
    property deceased : TFhirDataType read FDeceased write SetDeceased;
    // Indicates if the individual is deceased or not.
    property deceasedElement : TFhirDataType read FDeceased write SetDeceased;

    // An address for the individual.
    property addressList : TFhirAddressList read GetAddressList;
    property hasAddressList : boolean read GetHasAddressList;

    // Typed access to This field contains a patient's most recent marital (civil) status. (defined for API consistency)
    property maritalStatus : TFhirCodeableConcept read FMaritalStatus write SetMaritalStatus;
    // This field contains a patient's most recent marital (civil) status.
    property maritalStatusElement : TFhirCodeableConcept read FMaritalStatus write SetMaritalStatus;

    // Typed access to Indicates whether the patient is part of a multiple (boolean) or indicates the actual birth order (integer). (defined for API consistency)
    property multipleBirth : TFhirDataType read FMultipleBirth write SetMultipleBirth;
    // Indicates whether the patient is part of a multiple (boolean) or indicates the actual birth order (integer).
    property multipleBirthElement : TFhirDataType read FMultipleBirth write SetMultipleBirth;

    // Image of the patient.
    property photoList : TFhirAttachmentList read GetPhotoList;
    property hasPhotoList : boolean read GetHasPhotoList;

    // A contact party (e.g. guardian, partner, friend) for the patient.
    property contactList : TFhirPatientContactList read GetContactList;
    property hasContactList : boolean read GetHasContactList;

    // A language which may be used to communicate with the patient about his or her health.
    property communicationList : TFhirPatientCommunicationList read GetCommunicationList;
    property hasCommunicationList : boolean read GetHasCommunicationList;

    // Patient's nominated care provider.
    property generalPractitionerList : TFhirReferenceList read GetGeneralPractitionerList;
    property hasGeneralPractitionerList : boolean read GetHasGeneralPractitionerList;

    // Typed access to Organization that is the custodian of the patient record. (defined for API consistency)
    property managingOrganization : TFhirReference read FManagingOrganization write SetManagingOrganization;
    // Organization that is the custodian of the patient record.
    property managingOrganizationElement : TFhirReference read FManagingOrganization write SetManagingOrganization;

    // Link to a Patient or RelatedPerson resource that concerns the same actual individual.
    property link_List : TFhirPatientLinkList read GetLink_List;
    property hasLink_List : boolean read GetHasLink_List;

  end;

  TFhirPatientListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirPatientList;
    function GetCurrent : TFhirPatient;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirPatientList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirPatient read GetCurrent;
  end;

  TFhirPatientList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirPatient;
    procedure SetItemN(index : Integer; value : TFhirPatient);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirPatientList; overload;
    function Clone : TFhirPatientList; overload;
    function GetEnumerator : TFhirPatientListEnumerator;
    
    //  Add a FhirPatient to the end of the list.
    function Append : TFhirPatient;
    
    // Add an already existing FhirPatient to the end of the list.
    function AddItem(value : TFhirPatient) : TFhirPatient; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirPatient) : Integer;
    
    // Insert FhirPatient before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirPatient;
    
    // Insert an existing FhirPatient before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirPatient);
    
    // Get the iIndexth FhirPatient. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirPatient);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirPatient;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirPatients[index : Integer] : TFhirPatient read GetItemN write SetItemN; default;
  End;

{$ENDIF FHIR_PATIENT}
{$IFDEF FHIR_PERSON}
  // A language which may be used to communicate with the person about his or her health.
  TFhirPersonCommunication = class (TFhirBackboneElement)
  protected
    FLanguage : TFhirCodeableConcept;
    FPreferred : TFhirBoolean;
    procedure SetLanguage(value : TFhirCodeableConcept);
    procedure SetPreferred(value : TFhirBoolean);
    function GetPreferredST : Boolean;
    procedure SetPreferredST(value : Boolean);
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirPersonCommunication; overload;
    function Clone : TFhirPersonCommunication; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to The ISO-639-1 alpha 2 code in lower case for the language, optionally followed by a hyphen and the ISO-3166-1 alpha 2 code for the region in upper case; e.g. "en" for English, or "en-US" for American English versus "en-AU" for Australian English. (defined for API consistency)
    property language : TFhirCodeableConcept read FLanguage write SetLanguage;
    // The ISO-639-1 alpha 2 code in lower case for the language, optionally followed by a hyphen and the ISO-3166-1 alpha 2 code for the region in upper case; e.g. "en" for English, or "en-US" for American English versus "en-AU" for Australian English.
    property languageElement : TFhirCodeableConcept read FLanguage write SetLanguage;

    // Typed access to Indicates whether or not the person prefers this language (over other languages he masters up a certain level).
    property preferred : Boolean read GetPreferredST write SetPreferredST;
    // Indicates whether or not the person prefers this language (over other languages he masters up a certain level).
    property preferredElement : TFhirBoolean read FPreferred write SetPreferred;

  end;

  TFhirPersonCommunicationListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirPersonCommunicationList;
    function GetCurrent : TFhirPersonCommunication;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirPersonCommunicationList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirPersonCommunication read GetCurrent;
  end;

  TFhirPersonCommunicationList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirPersonCommunication;
    procedure SetItemN(index : Integer; value : TFhirPersonCommunication);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirPersonCommunicationList; overload;
    function Clone : TFhirPersonCommunicationList; overload;
    function GetEnumerator : TFhirPersonCommunicationListEnumerator;
    
    //  Add a FhirPersonCommunication to the end of the list.
    function Append : TFhirPersonCommunication;
    
    // Add an already existing FhirPersonCommunication to the end of the list.
    function AddItem(value : TFhirPersonCommunication) : TFhirPersonCommunication; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirPersonCommunication) : Integer;
    
    // Insert FhirPersonCommunication before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirPersonCommunication;
    
    // Insert an existing FhirPersonCommunication before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirPersonCommunication);
    
    // Get the iIndexth FhirPersonCommunication. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirPersonCommunication);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirPersonCommunication;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirPersonCommunications[index : Integer] : TFhirPersonCommunication read GetItemN write SetItemN; default;
  End;

  // Link to a resource that concerns the same actual person.
  TFhirPersonLink = class (TFhirBackboneElement)
  protected
    FTarget : TFhirReference;
    FAssurance : TFhirEnum;
    procedure SetTarget(value : TFhirReference);
    procedure SetAssurance(value : TFhirEnum);
    function GetAssuranceST : TFhirIdentityAssuranceLevelEnum;
    procedure SetAssuranceST(value : TFhirIdentityAssuranceLevelEnum);
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirPersonLink; overload;
    function Clone : TFhirPersonLink; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to The resource to which this actual person is associated. (defined for API consistency)
    property target : TFhirReference read FTarget write SetTarget;
    // The resource to which this actual person is associated.
    property targetElement : TFhirReference read FTarget write SetTarget;

    // Level of assurance that this link is associated with the target resource.
    property assurance : TFhirIdentityAssuranceLevelEnum read GetAssuranceST write SetAssuranceST;
    property assuranceElement : TFhirEnum read FAssurance write SetAssurance;

  end;

  TFhirPersonLinkListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirPersonLinkList;
    function GetCurrent : TFhirPersonLink;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirPersonLinkList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirPersonLink read GetCurrent;
  end;

  TFhirPersonLinkList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirPersonLink;
    procedure SetItemN(index : Integer; value : TFhirPersonLink);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirPersonLinkList; overload;
    function Clone : TFhirPersonLinkList; overload;
    function GetEnumerator : TFhirPersonLinkListEnumerator;
    
    //  Add a FhirPersonLink to the end of the list.
    function Append : TFhirPersonLink;
    
    // Add an already existing FhirPersonLink to the end of the list.
    function AddItem(value : TFhirPersonLink) : TFhirPersonLink; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirPersonLink) : Integer;
    
    // Insert FhirPersonLink before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirPersonLink;
    
    // Insert an existing FhirPersonLink before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirPersonLink);
    
    // Get the iIndexth FhirPersonLink. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirPersonLink);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirPersonLink;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirPersonLinks[index : Integer] : TFhirPersonLink read GetItemN write SetItemN; default;
  End;

  // Demographics and administrative information about a person independent of a specific health-related context.
  TFhirPerson = class (TFhirDomainResource)
  protected
    FidentifierList : TFhirIdentifierList;
    FActive : TFhirBoolean;
    FnameList : TFhirHumanNameList;
    FtelecomList : TFhirContactPointList;
    FGender : TFhirEnum;
    FBirthDate : TFhirDate;
    FDeceased : TFhirDataType;
    FaddressList : TFhirAddressList;
    FMaritalStatus : TFhirCodeableConcept;
    FphotoList : TFhirAttachmentList;
    FcommunicationList : TFhirPersonCommunicationList;
    FManagingOrganization : TFhirReference;
    Flink_List : TFhirPersonLinkList;
    function GetIdentifierList : TFhirIdentifierList;
    function GetHasIdentifierList : Boolean;
    procedure SetActive(value : TFhirBoolean);
    function GetActiveST : Boolean;
    procedure SetActiveST(value : Boolean);
    function GetNameList : TFhirHumanNameList;
    function GetHasNameList : Boolean;
    function GetTelecomList : TFhirContactPointList;
    function GetHasTelecomList : Boolean;
    procedure SetGender(value : TFhirEnum);
    function GetGenderST : TFhirAdministrativeGenderEnum;
    procedure SetGenderST(value : TFhirAdministrativeGenderEnum);
    procedure SetBirthDate(value : TFhirDate);
    function GetBirthDateST : TFslDateTime;
    procedure SetBirthDateST(value : TFslDateTime);
    procedure SetDeceased(value : TFhirDataType);
    function GetAddressList : TFhirAddressList;
    function GetHasAddressList : Boolean;
    procedure SetMaritalStatus(value : TFhirCodeableConcept);
    function GetPhotoList : TFhirAttachmentList;
    function GetHasPhotoList : Boolean;
    function GetCommunicationList : TFhirPersonCommunicationList;
    function GetHasCommunicationList : Boolean;
    procedure SetManagingOrganization(value : TFhirReference);
    function GetLink_List : TFhirPersonLinkList;
    function GetHasLink_List : Boolean;
  
    function GetResourceType : TFhirResourceType; override;
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirPerson; overload;
    function Clone : TFhirPerson; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Identifier for a person within a particular scope.
    property identifierList : TFhirIdentifierList read GetIdentifierList;
    property hasIdentifierList : boolean read GetHasIdentifierList;

    // Typed access to Whether this person's record is in active use.
    property active : Boolean read GetActiveST write SetActiveST;
    // Whether this person's record is in active use.
    property activeElement : TFhirBoolean read FActive write SetActive;

    // A name associated with the person.
    property nameList : TFhirHumanNameList read GetNameList;
    property hasNameList : boolean read GetHasNameList;

    // A contact detail for the person, e.g. a telephone number or an email address.
    property telecomList : TFhirContactPointList read GetTelecomList;
    property hasTelecomList : boolean read GetHasTelecomList;

    // Administrative Gender.
    property gender : TFhirAdministrativeGenderEnum read GetGenderST write SetGenderST;
    property genderElement : TFhirEnum read FGender write SetGender;

    // Typed access to The birth date for the person.
    property birthDate : TFslDateTime read GetBirthDateST write SetBirthDateST;
    // The birth date for the person.
    property birthDateElement : TFhirDate read FBirthDate write SetBirthDate;

    // Typed access to Indicates if the individual is deceased or not. (defined for API consistency)
    property deceased : TFhirDataType read FDeceased write SetDeceased;
    // Indicates if the individual is deceased or not.
    property deceasedElement : TFhirDataType read FDeceased write SetDeceased;

    // One or more addresses for the person.
    property addressList : TFhirAddressList read GetAddressList;
    property hasAddressList : boolean read GetHasAddressList;

    // Typed access to This field contains a person's most recent marital (civil) status. (defined for API consistency)
    property maritalStatus : TFhirCodeableConcept read FMaritalStatus write SetMaritalStatus;
    // This field contains a person's most recent marital (civil) status.
    property maritalStatusElement : TFhirCodeableConcept read FMaritalStatus write SetMaritalStatus;

    // An image that can be displayed as a thumbnail of the person to enhance the identification of the individual.
    property photoList : TFhirAttachmentList read GetPhotoList;
    property hasPhotoList : boolean read GetHasPhotoList;

    // A language which may be used to communicate with the person about his or her health.
    property communicationList : TFhirPersonCommunicationList read GetCommunicationList;
    property hasCommunicationList : boolean read GetHasCommunicationList;

    // Typed access to The organization that is the custodian of the person record. (defined for API consistency)
    property managingOrganization : TFhirReference read FManagingOrganization write SetManagingOrganization;
    // The organization that is the custodian of the person record.
    property managingOrganizationElement : TFhirReference read FManagingOrganization write SetManagingOrganization;

    // Link to a resource that concerns the same actual person.
    property link_List : TFhirPersonLinkList read GetLink_List;
    property hasLink_List : boolean read GetHasLink_List;

  end;

  TFhirPersonListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirPersonList;
    function GetCurrent : TFhirPerson;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirPersonList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirPerson read GetCurrent;
  end;

  TFhirPersonList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirPerson;
    procedure SetItemN(index : Integer; value : TFhirPerson);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirPersonList; overload;
    function Clone : TFhirPersonList; overload;
    function GetEnumerator : TFhirPersonListEnumerator;
    
    //  Add a FhirPerson to the end of the list.
    function Append : TFhirPerson;
    
    // Add an already existing FhirPerson to the end of the list.
    function AddItem(value : TFhirPerson) : TFhirPerson; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirPerson) : Integer;
    
    // Insert FhirPerson before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirPerson;
    
    // Insert an existing FhirPerson before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirPerson);
    
    // Get the iIndexth FhirPerson. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirPerson);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirPerson;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirPeople[index : Integer] : TFhirPerson read GetItemN write SetItemN; default;
  End;

{$ENDIF FHIR_PERSON}
{$IFDEF FHIR_PRACTITIONER}
  // The official qualifications, certifications, accreditations, training, licenses (and other types of educations/skills/capabilities) that authorize or otherwise pertain to the provision of care by the practitioner.  For example, a medical license issued by a medical board of licensure authorizing the practitioner to practice medicine within a certain locality.
  TFhirPractitionerQualification = class (TFhirBackboneElement)
  protected
    FidentifierList : TFhirIdentifierList;
    FCode : TFhirCodeableConcept;
    FPeriod : TFhirPeriod;
    FIssuer : TFhirReference;
    function GetIdentifierList : TFhirIdentifierList;
    function GetHasIdentifierList : Boolean;
    procedure SetCode(value : TFhirCodeableConcept);
    procedure SetPeriod(value : TFhirPeriod);
    procedure SetIssuer(value : TFhirReference);
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirPractitionerQualification; overload;
    function Clone : TFhirPractitionerQualification; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // An identifier that applies to this person's qualification.
    property identifierList : TFhirIdentifierList read GetIdentifierList;
    property hasIdentifierList : boolean read GetHasIdentifierList;

    // Typed access to Coded representation of the qualification. (defined for API consistency)
    property code : TFhirCodeableConcept read FCode write SetCode;
    // Coded representation of the qualification.
    property codeElement : TFhirCodeableConcept read FCode write SetCode;

    // Typed access to Period during which the qualification is valid. (defined for API consistency)
    property period : TFhirPeriod read FPeriod write SetPeriod;
    // Period during which the qualification is valid.
    property periodElement : TFhirPeriod read FPeriod write SetPeriod;

    // Typed access to Organization that regulates and issues the qualification. (defined for API consistency)
    property issuer : TFhirReference read FIssuer write SetIssuer;
    // Organization that regulates and issues the qualification.
    property issuerElement : TFhirReference read FIssuer write SetIssuer;

  end;

  TFhirPractitionerQualificationListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirPractitionerQualificationList;
    function GetCurrent : TFhirPractitionerQualification;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirPractitionerQualificationList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirPractitionerQualification read GetCurrent;
  end;

  TFhirPractitionerQualificationList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirPractitionerQualification;
    procedure SetItemN(index : Integer; value : TFhirPractitionerQualification);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirPractitionerQualificationList; overload;
    function Clone : TFhirPractitionerQualificationList; overload;
    function GetEnumerator : TFhirPractitionerQualificationListEnumerator;
    
    //  Add a FhirPractitionerQualification to the end of the list.
    function Append : TFhirPractitionerQualification;
    
    // Add an already existing FhirPractitionerQualification to the end of the list.
    function AddItem(value : TFhirPractitionerQualification) : TFhirPractitionerQualification; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirPractitionerQualification) : Integer;
    
    // Insert FhirPractitionerQualification before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirPractitionerQualification;
    
    // Insert an existing FhirPractitionerQualification before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirPractitionerQualification);
    
    // Get the iIndexth FhirPractitionerQualification. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirPractitionerQualification);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirPractitionerQualification;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirPractitionerQualifications[index : Integer] : TFhirPractitionerQualification read GetItemN write SetItemN; default;
  End;

  // A person who is directly or indirectly involved in the provisioning of healthcare or related services.
  TFhirPractitioner = class (TFhirDomainResource)
  protected
    FidentifierList : TFhirIdentifierList;
    FActive : TFhirBoolean;
    FnameList : TFhirHumanNameList;
    FtelecomList : TFhirContactPointList;
    FGender : TFhirEnum;
    FBirthDate : TFhirDate;
    FDeceased : TFhirDataType;
    FaddressList : TFhirAddressList;
    FphotoList : TFhirAttachmentList;
    FqualificationList : TFhirPractitionerQualificationList;
    FcommunicationList : TFhirCodeableConceptList;
    function GetIdentifierList : TFhirIdentifierList;
    function GetHasIdentifierList : Boolean;
    procedure SetActive(value : TFhirBoolean);
    function GetActiveST : Boolean;
    procedure SetActiveST(value : Boolean);
    function GetNameList : TFhirHumanNameList;
    function GetHasNameList : Boolean;
    function GetTelecomList : TFhirContactPointList;
    function GetHasTelecomList : Boolean;
    procedure SetGender(value : TFhirEnum);
    function GetGenderST : TFhirAdministrativeGenderEnum;
    procedure SetGenderST(value : TFhirAdministrativeGenderEnum);
    procedure SetBirthDate(value : TFhirDate);
    function GetBirthDateST : TFslDateTime;
    procedure SetBirthDateST(value : TFslDateTime);
    procedure SetDeceased(value : TFhirDataType);
    function GetAddressList : TFhirAddressList;
    function GetHasAddressList : Boolean;
    function GetPhotoList : TFhirAttachmentList;
    function GetHasPhotoList : Boolean;
    function GetQualificationList : TFhirPractitionerQualificationList;
    function GetHasQualificationList : Boolean;
    function GetCommunicationList : TFhirCodeableConceptList;
    function GetHasCommunicationList : Boolean;
  
    function GetResourceType : TFhirResourceType; override;
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirPractitioner; overload;
    function Clone : TFhirPractitioner; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // An identifier that applies to this person in this role.
    property identifierList : TFhirIdentifierList read GetIdentifierList;
    property hasIdentifierList : boolean read GetHasIdentifierList;

    // Typed access to Whether this practitioner's record is in active use.
    property active : Boolean read GetActiveST write SetActiveST;
    // Whether this practitioner's record is in active use.
    property activeElement : TFhirBoolean read FActive write SetActive;

    // The name(s) associated with the practitioner.
    property nameList : TFhirHumanNameList read GetNameList;
    property hasNameList : boolean read GetHasNameList;

    // A contact detail for the practitioner, e.g. a telephone number or an email address.
    property telecomList : TFhirContactPointList read GetTelecomList;
    property hasTelecomList : boolean read GetHasTelecomList;

    // Administrative Gender - the gender that the person is considered to have for administration and record keeping purposes.
    property gender : TFhirAdministrativeGenderEnum read GetGenderST write SetGenderST;
    property genderElement : TFhirEnum read FGender write SetGender;

    // Typed access to The date of birth for the practitioner.
    property birthDate : TFslDateTime read GetBirthDateST write SetBirthDateST;
    // The date of birth for the practitioner.
    property birthDateElement : TFhirDate read FBirthDate write SetBirthDate;

    // Typed access to Indicates if the practitioner is deceased or not. (defined for API consistency)
    property deceased : TFhirDataType read FDeceased write SetDeceased;
    // Indicates if the practitioner is deceased or not.
    property deceasedElement : TFhirDataType read FDeceased write SetDeceased;

    // Address(es) of the practitioner that are not role specific (typically home address).  Work addresses are not typically entered in this property as they are usually role dependent.
    property addressList : TFhirAddressList read GetAddressList;
    property hasAddressList : boolean read GetHasAddressList;

    // Image of the person.
    property photoList : TFhirAttachmentList read GetPhotoList;
    property hasPhotoList : boolean read GetHasPhotoList;

    // The official qualifications, certifications, accreditations, training, licenses (and other types of educations/skills/capabilities) that authorize or otherwise pertain to the provision of care by the practitioner.  For example, a medical license issued by a medical board of licensure authorizing the practitioner to practice medicine within a certain locality.
    property qualificationList : TFhirPractitionerQualificationList read GetQualificationList;
    property hasQualificationList : boolean read GetHasQualificationList;

    // A language the practitioner can use in patient communication.
    property communicationList : TFhirCodeableConceptList read GetCommunicationList;
    property hasCommunicationList : boolean read GetHasCommunicationList;

  end;

  TFhirPractitionerListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirPractitionerList;
    function GetCurrent : TFhirPractitioner;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirPractitionerList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirPractitioner read GetCurrent;
  end;

  TFhirPractitionerList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirPractitioner;
    procedure SetItemN(index : Integer; value : TFhirPractitioner);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirPractitionerList; overload;
    function Clone : TFhirPractitionerList; overload;
    function GetEnumerator : TFhirPractitionerListEnumerator;
    
    //  Add a FhirPractitioner to the end of the list.
    function Append : TFhirPractitioner;
    
    // Add an already existing FhirPractitioner to the end of the list.
    function AddItem(value : TFhirPractitioner) : TFhirPractitioner; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirPractitioner) : Integer;
    
    // Insert FhirPractitioner before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirPractitioner;
    
    // Insert an existing FhirPractitioner before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirPractitioner);
    
    // Get the iIndexth FhirPractitioner. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirPractitioner);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirPractitioner;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirPractitioners[index : Integer] : TFhirPractitioner read GetItemN write SetItemN; default;
  End;

{$ENDIF FHIR_PRACTITIONER}
{$IFDEF FHIR_PRACTITIONERROLE}
  // A specific set of Roles/Locations/specialties/services that a practitioner may perform at an organization for a period of time.
  TFhirPractitionerRole = class (TFhirDomainResource)
  protected
    FidentifierList : TFhirIdentifierList;
    FActive : TFhirBoolean;
    FPeriod : TFhirPeriod;
    FPractitioner : TFhirReference;
    FOrganization : TFhirReference;
    FcodeList : TFhirCodeableConceptList;
    FspecialtyList : TFhirCodeableConceptList;
    FlocationList : TFhirReferenceList;
    FhealthcareServiceList : TFhirReferenceList;
    FcontactList : TFhirExtendedContactDetailList;
    FavailabilityList : TFhirAvailabilityList;
    FendpointList : TFhirReferenceList;
    function GetIdentifierList : TFhirIdentifierList;
    function GetHasIdentifierList : Boolean;
    procedure SetActive(value : TFhirBoolean);
    function GetActiveST : Boolean;
    procedure SetActiveST(value : Boolean);
    procedure SetPeriod(value : TFhirPeriod);
    procedure SetPractitioner(value : TFhirReference);
    procedure SetOrganization(value : TFhirReference);
    function GetCodeList : TFhirCodeableConceptList;
    function GetHasCodeList : Boolean;
    function GetSpecialtyList : TFhirCodeableConceptList;
    function GetHasSpecialtyList : Boolean;
    function GetLocationList : TFhirReferenceList;
    function GetHasLocationList : Boolean;
    function GetHealthcareServiceList : TFhirReferenceList;
    function GetHasHealthcareServiceList : Boolean;
    function GetContactList : TFhirExtendedContactDetailList;
    function GetHasContactList : Boolean;
    function GetAvailabilityList : TFhirAvailabilityList;
    function GetHasAvailabilityList : Boolean;
    function GetEndpointList : TFhirReferenceList;
    function GetHasEndpointList : Boolean;
  
    function GetResourceType : TFhirResourceType; override;
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirPractitionerRole; overload;
    function Clone : TFhirPractitionerRole; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Business Identifiers that are specific to a role/location.
    property identifierList : TFhirIdentifierList read GetIdentifierList;
    property hasIdentifierList : boolean read GetHasIdentifierList;

    // Typed access to Whether this practitioner role record is in active use.
    property active : Boolean read GetActiveST write SetActiveST;
    // Whether this practitioner role record is in active use.
    property activeElement : TFhirBoolean read FActive write SetActive;

    // Typed access to The period during which the person is authorized to act as a practitioner in these role(s) for the organization. (defined for API consistency)
    property period : TFhirPeriod read FPeriod write SetPeriod;
    // The period during which the person is authorized to act as a practitioner in these role(s) for the organization.
    property periodElement : TFhirPeriod read FPeriod write SetPeriod;

    // Typed access to Practitioner that is able to provide the defined services for the organization. (defined for API consistency)
    property practitioner : TFhirReference read FPractitioner write SetPractitioner;
    // Practitioner that is able to provide the defined services for the organization.
    property practitionerElement : TFhirReference read FPractitioner write SetPractitioner;

    // Typed access to The organization where the Practitioner performs the roles associated. (defined for API consistency)
    property organization : TFhirReference read FOrganization write SetOrganization;
    // The organization where the Practitioner performs the roles associated.
    property organizationElement : TFhirReference read FOrganization write SetOrganization;

    // Roles which this practitioner is authorized to perform for the organization.
    property codeList : TFhirCodeableConceptList read GetCodeList;
    property hasCodeList : boolean read GetHasCodeList;

    // The specialty of a practitioner that describes the functional role they are practicing at a given organization or location.
    property specialtyList : TFhirCodeableConceptList read GetSpecialtyList;
    property hasSpecialtyList : boolean read GetHasSpecialtyList;

    // The location(s) at which this practitioner provides care.
    property locationList : TFhirReferenceList read GetLocationList;
    property hasLocationList : boolean read GetHasLocationList;

    // The list of healthcare services that this worker provides for this role's Organization/Location(s).
    property healthcareServiceList : TFhirReferenceList read GetHealthcareServiceList;
    property hasHealthcareServiceList : boolean read GetHasHealthcareServiceList;

    // The contact details of communication devices available relevant to the specific PractitionerRole. This can include addresses, phone numbers, fax numbers, mobile numbers, email addresses and web sites.
    property contactList : TFhirExtendedContactDetailList read GetContactList;
    property hasContactList : boolean read GetHasContactList;

    // A collection of times the practitioner is available or performing this role at the location and/or healthcareservice.
    property availabilityList : TFhirAvailabilityList read GetAvailabilityList;
    property hasAvailabilityList : boolean read GetHasAvailabilityList;

    // Technical endpoints providing access to services operated for the practitioner with this role.
    property endpointList : TFhirReferenceList read GetEndpointList;
    property hasEndpointList : boolean read GetHasEndpointList;

  end;

  TFhirPractitionerRoleListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirPractitionerRoleList;
    function GetCurrent : TFhirPractitionerRole;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirPractitionerRoleList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirPractitionerRole read GetCurrent;
  end;

  TFhirPractitionerRoleList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirPractitionerRole;
    procedure SetItemN(index : Integer; value : TFhirPractitionerRole);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirPractitionerRoleList; overload;
    function Clone : TFhirPractitionerRoleList; overload;
    function GetEnumerator : TFhirPractitionerRoleListEnumerator;
    
    //  Add a FhirPractitionerRole to the end of the list.
    function Append : TFhirPractitionerRole;
    
    // Add an already existing FhirPractitionerRole to the end of the list.
    function AddItem(value : TFhirPractitionerRole) : TFhirPractitionerRole; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirPractitionerRole) : Integer;
    
    // Insert FhirPractitionerRole before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirPractitionerRole;
    
    // Insert an existing FhirPractitionerRole before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirPractitionerRole);
    
    // Get the iIndexth FhirPractitionerRole. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirPractitionerRole);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirPractitionerRole;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirPractitionerRoles[index : Integer] : TFhirPractitionerRole read GetItemN write SetItemN; default;
  End;

{$ENDIF FHIR_PRACTITIONERROLE}
{$IFDEF FHIR_RELATEDPERSON}
  // A language which may be used to communicate with the related person about the patient's health.
  TFhirRelatedPersonCommunication = class (TFhirBackboneElement)
  protected
    FLanguage : TFhirCodeableConcept;
    FPreferred : TFhirBoolean;
    procedure SetLanguage(value : TFhirCodeableConcept);
    procedure SetPreferred(value : TFhirBoolean);
    function GetPreferredST : Boolean;
    procedure SetPreferredST(value : Boolean);
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirRelatedPersonCommunication; overload;
    function Clone : TFhirRelatedPersonCommunication; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to The ISO-639-1 alpha 2 code in lower case for the language, optionally followed by a hyphen and the ISO-3166-1 alpha 2 code for the region in upper case; e.g. "en" for English, or "en-US" for American English versus "en-AU" for Australian English. (defined for API consistency)
    property language : TFhirCodeableConcept read FLanguage write SetLanguage;
    // The ISO-639-1 alpha 2 code in lower case for the language, optionally followed by a hyphen and the ISO-3166-1 alpha 2 code for the region in upper case; e.g. "en" for English, or "en-US" for American English versus "en-AU" for Australian English.
    property languageElement : TFhirCodeableConcept read FLanguage write SetLanguage;

    // Typed access to Indicates whether or not the related person prefers this language (over other languages he or she masters up a certain level).
    property preferred : Boolean read GetPreferredST write SetPreferredST;
    // Indicates whether or not the related person prefers this language (over other languages he or she masters up a certain level).
    property preferredElement : TFhirBoolean read FPreferred write SetPreferred;

  end;

  TFhirRelatedPersonCommunicationListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirRelatedPersonCommunicationList;
    function GetCurrent : TFhirRelatedPersonCommunication;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirRelatedPersonCommunicationList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirRelatedPersonCommunication read GetCurrent;
  end;

  TFhirRelatedPersonCommunicationList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirRelatedPersonCommunication;
    procedure SetItemN(index : Integer; value : TFhirRelatedPersonCommunication);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirRelatedPersonCommunicationList; overload;
    function Clone : TFhirRelatedPersonCommunicationList; overload;
    function GetEnumerator : TFhirRelatedPersonCommunicationListEnumerator;
    
    //  Add a FhirRelatedPersonCommunication to the end of the list.
    function Append : TFhirRelatedPersonCommunication;
    
    // Add an already existing FhirRelatedPersonCommunication to the end of the list.
    function AddItem(value : TFhirRelatedPersonCommunication) : TFhirRelatedPersonCommunication; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirRelatedPersonCommunication) : Integer;
    
    // Insert FhirRelatedPersonCommunication before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirRelatedPersonCommunication;
    
    // Insert an existing FhirRelatedPersonCommunication before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirRelatedPersonCommunication);
    
    // Get the iIndexth FhirRelatedPersonCommunication. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirRelatedPersonCommunication);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirRelatedPersonCommunication;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirRelatedPersonCommunications[index : Integer] : TFhirRelatedPersonCommunication read GetItemN write SetItemN; default;
  End;

  // Information about a person that is involved in a patient's health or the care for a patient, but who is not the target of healthcare, nor has a formal responsibility in the care process.
  TFhirRelatedPerson = class (TFhirDomainResource)
  protected
    FidentifierList : TFhirIdentifierList;
    FActive : TFhirBoolean;
    FPatient : TFhirReference;
    FrelationshipList : TFhirCodeableConceptList;
    FnameList : TFhirHumanNameList;
    FtelecomList : TFhirContactPointList;
    FGender : TFhirEnum;
    FBirthDate : TFhirDate;
    FaddressList : TFhirAddressList;
    FphotoList : TFhirAttachmentList;
    FPeriod : TFhirPeriod;
    FcommunicationList : TFhirRelatedPersonCommunicationList;
    function GetIdentifierList : TFhirIdentifierList;
    function GetHasIdentifierList : Boolean;
    procedure SetActive(value : TFhirBoolean);
    function GetActiveST : Boolean;
    procedure SetActiveST(value : Boolean);
    procedure SetPatient(value : TFhirReference);
    function GetRelationshipList : TFhirCodeableConceptList;
    function GetHasRelationshipList : Boolean;
    function GetNameList : TFhirHumanNameList;
    function GetHasNameList : Boolean;
    function GetTelecomList : TFhirContactPointList;
    function GetHasTelecomList : Boolean;
    procedure SetGender(value : TFhirEnum);
    function GetGenderST : TFhirAdministrativeGenderEnum;
    procedure SetGenderST(value : TFhirAdministrativeGenderEnum);
    procedure SetBirthDate(value : TFhirDate);
    function GetBirthDateST : TFslDateTime;
    procedure SetBirthDateST(value : TFslDateTime);
    function GetAddressList : TFhirAddressList;
    function GetHasAddressList : Boolean;
    function GetPhotoList : TFhirAttachmentList;
    function GetHasPhotoList : Boolean;
    procedure SetPeriod(value : TFhirPeriod);
    function GetCommunicationList : TFhirRelatedPersonCommunicationList;
    function GetHasCommunicationList : Boolean;
  
    function GetResourceType : TFhirResourceType; override;
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirRelatedPerson; overload;
    function Clone : TFhirRelatedPerson; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Identifier for a person within a particular scope.
    property identifierList : TFhirIdentifierList read GetIdentifierList;
    property hasIdentifierList : boolean read GetHasIdentifierList;

    // Typed access to Whether this related person record is in active use.
    property active : Boolean read GetActiveST write SetActiveST;
    // Whether this related person record is in active use.
    property activeElement : TFhirBoolean read FActive write SetActive;

    // Typed access to The patient this person is related to. (defined for API consistency)
    property patient : TFhirReference read FPatient write SetPatient;
    // The patient this person is related to.
    property patientElement : TFhirReference read FPatient write SetPatient;

    // The nature of the relationship between the related person and the patient.
    property relationshipList : TFhirCodeableConceptList read GetRelationshipList;
    property hasRelationshipList : boolean read GetHasRelationshipList;

    // A name associated with the person.
    property nameList : TFhirHumanNameList read GetNameList;
    property hasNameList : boolean read GetHasNameList;

    // A contact detail for the person, e.g. a telephone number or an email address.
    property telecomList : TFhirContactPointList read GetTelecomList;
    property hasTelecomList : boolean read GetHasTelecomList;

    // Administrative Gender - the gender that the person is considered to have for administration and record keeping purposes.
    property gender : TFhirAdministrativeGenderEnum read GetGenderST write SetGenderST;
    property genderElement : TFhirEnum read FGender write SetGender;

    // Typed access to The date on which the related person was born.
    property birthDate : TFslDateTime read GetBirthDateST write SetBirthDateST;
    // The date on which the related person was born.
    property birthDateElement : TFhirDate read FBirthDate write SetBirthDate;

    // Address where the related person can be contacted or visited.
    property addressList : TFhirAddressList read GetAddressList;
    property hasAddressList : boolean read GetHasAddressList;

    // Image of the person.
    property photoList : TFhirAttachmentList read GetPhotoList;
    property hasPhotoList : boolean read GetHasPhotoList;

    // Typed access to The period of time during which this relationship is or was active. If there are no dates defined, then the interval is unknown. (defined for API consistency)
    property period : TFhirPeriod read FPeriod write SetPeriod;
    // The period of time during which this relationship is or was active. If there are no dates defined, then the interval is unknown.
    property periodElement : TFhirPeriod read FPeriod write SetPeriod;

    // A language which may be used to communicate with the related person about the patient's health.
    property communicationList : TFhirRelatedPersonCommunicationList read GetCommunicationList;
    property hasCommunicationList : boolean read GetHasCommunicationList;

  end;

  TFhirRelatedPersonListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirRelatedPersonList;
    function GetCurrent : TFhirRelatedPerson;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirRelatedPersonList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirRelatedPerson read GetCurrent;
  end;

  TFhirRelatedPersonList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirRelatedPerson;
    procedure SetItemN(index : Integer; value : TFhirRelatedPerson);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirRelatedPersonList; overload;
    function Clone : TFhirRelatedPersonList; overload;
    function GetEnumerator : TFhirRelatedPersonListEnumerator;
    
    //  Add a FhirRelatedPerson to the end of the list.
    function Append : TFhirRelatedPerson;
    
    // Add an already existing FhirRelatedPerson to the end of the list.
    function AddItem(value : TFhirRelatedPerson) : TFhirRelatedPerson; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirRelatedPerson) : Integer;
    
    // Insert FhirRelatedPerson before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirRelatedPerson;
    
    // Insert an existing FhirRelatedPerson before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirRelatedPerson);
    
    // Get the iIndexth FhirRelatedPerson. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirRelatedPerson);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirRelatedPerson;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirRelatedPeople[index : Integer] : TFhirRelatedPerson read GetItemN write SetItemN; default;
  End;

{$ENDIF FHIR_RELATEDPERSON}
{$IFDEF FHIR_SCHEDULE}
  // A container for slots of time that may be available for booking appointments.
  TFhirSchedule = class (TFhirDomainResource)
  protected
    FidentifierList : TFhirIdentifierList;
    FActive : TFhirBoolean;
    FserviceCategoryList : TFhirCodeableConceptList;
    FserviceTypeList : TFhirCodeableReferenceList;
    FspecialtyList : TFhirCodeableConceptList;
    FName : TFhirString;
    FactorList : TFhirReferenceList;
    FPlanningHorizon : TFhirPeriod;
    FComment : TFhirString;
    function GetIdentifierList : TFhirIdentifierList;
    function GetHasIdentifierList : Boolean;
    procedure SetActive(value : TFhirBoolean);
    function GetActiveST : Boolean;
    procedure SetActiveST(value : Boolean);
    function GetServiceCategoryList : TFhirCodeableConceptList;
    function GetHasServiceCategoryList : Boolean;
    function GetServiceTypeList : TFhirCodeableReferenceList;
    function GetHasServiceTypeList : Boolean;
    function GetSpecialtyList : TFhirCodeableConceptList;
    function GetHasSpecialtyList : Boolean;
    procedure SetName(value : TFhirString);
    function GetNameST : String;
    procedure SetNameST(value : String);
    function GetActorList : TFhirReferenceList;
    function GetHasActorList : Boolean;
    procedure SetPlanningHorizon(value : TFhirPeriod);
    procedure SetComment(value : TFhirString);
    function GetCommentST : String;
    procedure SetCommentST(value : String);
  
    function GetResourceType : TFhirResourceType; override;
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirSchedule; overload;
    function Clone : TFhirSchedule; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // External Ids for this item.
    property identifierList : TFhirIdentifierList read GetIdentifierList;
    property hasIdentifierList : boolean read GetHasIdentifierList;

    // Typed access to Whether this schedule record is in active use or should not be used (such as was entered in error).
    property active : Boolean read GetActiveST write SetActiveST;
    // Whether this schedule record is in active use or should not be used (such as was entered in error).
    property activeElement : TFhirBoolean read FActive write SetActive;

    // A broad categorization of the service that is to be performed during this appointment.
    property serviceCategoryList : TFhirCodeableConceptList read GetServiceCategoryList;
    property hasServiceCategoryList : boolean read GetHasServiceCategoryList;

    // The specific service that is to be performed during this appointment.
    property serviceTypeList : TFhirCodeableReferenceList read GetServiceTypeList;
    property hasServiceTypeList : boolean read GetHasServiceTypeList;

    // The specialty of a practitioner that would be required to perform the service requested in this appointment.
    property specialtyList : TFhirCodeableConceptList read GetSpecialtyList;
    property hasSpecialtyList : boolean read GetHasSpecialtyList;

    // Typed access to Further description of the schedule as it would be presented to a consumer while searching.
    property name : String read GetNameST write SetNameST;
    // Further description of the schedule as it would be presented to a consumer while searching.
    property nameElement : TFhirString read FName write SetName;

    // Slots that reference this schedule resource provide the availability details to these referenced resource(s).
    property actorList : TFhirReferenceList read GetActorList;
    property hasActorList : boolean read GetHasActorList;

    // Typed access to The period of time that the slots that reference this Schedule resource cover (even if none exist). These  cover the amount of time that an organization's planning horizon; the interval for which they are currently accepting appointments. This does not define a "template" for planning outside these dates. (defined for API consistency)
    property planningHorizon : TFhirPeriod read FPlanningHorizon write SetPlanningHorizon;
    // The period of time that the slots that reference this Schedule resource cover (even if none exist). These  cover the amount of time that an organization's planning horizon; the interval for which they are currently accepting appointments. This does not define a "template" for planning outside these dates.
    property planningHorizonElement : TFhirPeriod read FPlanningHorizon write SetPlanningHorizon;

    // Typed access to Comments on the availability to describe any extended information. Such as custom constraints on the slots that may be associated.
    property comment : String read GetCommentST write SetCommentST;
    // Comments on the availability to describe any extended information. Such as custom constraints on the slots that may be associated.
    property commentElement : TFhirString read FComment write SetComment;

  end;

  TFhirScheduleListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirScheduleList;
    function GetCurrent : TFhirSchedule;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirScheduleList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirSchedule read GetCurrent;
  end;

  TFhirScheduleList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirSchedule;
    procedure SetItemN(index : Integer; value : TFhirSchedule);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirScheduleList; overload;
    function Clone : TFhirScheduleList; overload;
    function GetEnumerator : TFhirScheduleListEnumerator;
    
    //  Add a FhirSchedule to the end of the list.
    function Append : TFhirSchedule;
    
    // Add an already existing FhirSchedule to the end of the list.
    function AddItem(value : TFhirSchedule) : TFhirSchedule; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirSchedule) : Integer;
    
    // Insert FhirSchedule before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirSchedule;
    
    // Insert an existing FhirSchedule before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirSchedule);
    
    // Get the iIndexth FhirSchedule. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirSchedule);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirSchedule;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirSchedules[index : Integer] : TFhirSchedule read GetItemN write SetItemN; default;
  End;

{$ENDIF FHIR_SCHEDULE}
{$IFDEF FHIR_SLOT}
  // A slot of time on a schedule that may be available for booking appointments.
  TFhirSlot = class (TFhirDomainResource)
  protected
    FidentifierList : TFhirIdentifierList;
    FserviceCategoryList : TFhirCodeableConceptList;
    FserviceTypeList : TFhirCodeableReferenceList;
    FspecialtyList : TFhirCodeableConceptList;
    FappointmentTypeList : TFhirCodeableConceptList;
    FSchedule : TFhirReference;
    FStatus : TFhirEnum;
    FStart : TFhirInstant;
    FEnd_ : TFhirInstant;
    FOverbooked : TFhirBoolean;
    FComment : TFhirString;
    function GetIdentifierList : TFhirIdentifierList;
    function GetHasIdentifierList : Boolean;
    function GetServiceCategoryList : TFhirCodeableConceptList;
    function GetHasServiceCategoryList : Boolean;
    function GetServiceTypeList : TFhirCodeableReferenceList;
    function GetHasServiceTypeList : Boolean;
    function GetSpecialtyList : TFhirCodeableConceptList;
    function GetHasSpecialtyList : Boolean;
    function GetAppointmentTypeList : TFhirCodeableConceptList;
    function GetHasAppointmentTypeList : Boolean;
    procedure SetSchedule(value : TFhirReference);
    procedure SetStatus(value : TFhirEnum);
    function GetStatusST : TFhirSlotStatusEnum;
    procedure SetStatusST(value : TFhirSlotStatusEnum);
    procedure SetStart(value : TFhirInstant);
    function GetStartST : TFslDateTime;
    procedure SetStartST(value : TFslDateTime);
    procedure SetEnd_(value : TFhirInstant);
    function GetEnd_ST : TFslDateTime;
    procedure SetEnd_ST(value : TFslDateTime);
    procedure SetOverbooked(value : TFhirBoolean);
    function GetOverbookedST : Boolean;
    procedure SetOverbookedST(value : Boolean);
    procedure SetComment(value : TFhirString);
    function GetCommentST : String;
    procedure SetCommentST(value : String);
  
    function GetResourceType : TFhirResourceType; override;
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirSlot; overload;
    function Clone : TFhirSlot; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // External Ids for this item.
    property identifierList : TFhirIdentifierList read GetIdentifierList;
    property hasIdentifierList : boolean read GetHasIdentifierList;

    // A broad categorization of the service that is to be performed during this appointment.
    property serviceCategoryList : TFhirCodeableConceptList read GetServiceCategoryList;
    property hasServiceCategoryList : boolean read GetHasServiceCategoryList;

    // The type of appointments that can be booked into this slot (ideally this would be an identifiable service - which is at a location, rather than the location itself). If provided then this overrides the value provided on the Schedule resource.
    property serviceTypeList : TFhirCodeableReferenceList read GetServiceTypeList;
    property hasServiceTypeList : boolean read GetHasServiceTypeList;

    // The specialty of a practitioner that would be required to perform the service requested in this appointment.
    property specialtyList : TFhirCodeableConceptList read GetSpecialtyList;
    property hasSpecialtyList : boolean read GetHasSpecialtyList;

    // The style of appointment or patient that may be booked in the slot (not service type).
    property appointmentTypeList : TFhirCodeableConceptList read GetAppointmentTypeList;
    property hasAppointmentTypeList : boolean read GetHasAppointmentTypeList;

    // Typed access to The schedule resource that this slot defines an interval of status information. (defined for API consistency)
    property schedule : TFhirReference read FSchedule write SetSchedule;
    // The schedule resource that this slot defines an interval of status information.
    property scheduleElement : TFhirReference read FSchedule write SetSchedule;

    // busy | free | busy-unavailable | busy-tentative | entered-in-error.
    property status : TFhirSlotStatusEnum read GetStatusST write SetStatusST;
    property statusElement : TFhirEnum read FStatus write SetStatus;

    // Typed access to Date/Time that the slot is to begin.
    property start : TFslDateTime read GetStartST write SetStartST;
    // Date/Time that the slot is to begin.
    property startElement : TFhirInstant read FStart write SetStart;

    // Typed access to Date/Time that the slot is to conclude.
    property end_ : TFslDateTime read GetEnd_ST write SetEnd_ST;
    // Date/Time that the slot is to conclude.
    property end_Element : TFhirInstant read FEnd_ write SetEnd_;

    // Typed access to This slot has already been overbooked, appointments are unlikely to be accepted for this time.
    property overbooked : Boolean read GetOverbookedST write SetOverbookedST;
    // This slot has already been overbooked, appointments are unlikely to be accepted for this time.
    property overbookedElement : TFhirBoolean read FOverbooked write SetOverbooked;

    // Typed access to Comments on the slot to describe any extended information. Such as custom constraints on the slot.
    property comment : String read GetCommentST write SetCommentST;
    // Comments on the slot to describe any extended information. Such as custom constraints on the slot.
    property commentElement : TFhirString read FComment write SetComment;

  end;

  TFhirSlotListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirSlotList;
    function GetCurrent : TFhirSlot;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirSlotList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirSlot read GetCurrent;
  end;

  TFhirSlotList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirSlot;
    procedure SetItemN(index : Integer; value : TFhirSlot);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirSlotList; overload;
    function Clone : TFhirSlotList; overload;
    function GetEnumerator : TFhirSlotListEnumerator;
    
    //  Add a FhirSlot to the end of the list.
    function Append : TFhirSlot;
    
    // Add an already existing FhirSlot to the end of the list.
    function AddItem(value : TFhirSlot) : TFhirSlot; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirSlot) : Integer;
    
    // Insert FhirSlot before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirSlot;
    
    // Insert an existing FhirSlot before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirSlot);
    
    // Get the iIndexth FhirSlot. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirSlot);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirSlot;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirSlots[index : Integer] : TFhirSlot read GetItemN write SetItemN; default;
  End;

{$ENDIF FHIR_SLOT}



implementation

uses
  fhir5_utilities;



{$IFDEF FHIR_DEVICE}
{ TFhirDeviceUdiCarrier }

constructor TFhirDeviceUdiCarrier.Create;
begin
  inherited;
end;

destructor TFhirDeviceUdiCarrier.Destroy;
begin
  FDeviceIdentifier.free;
  FIssuer.free;
  FJurisdiction.free;
  FCarrierAIDC.free;
  FCarrierHRF.free;
  FEntryType.free;
  inherited;
end;

procedure TFhirDeviceUdiCarrier.Assign(oSource : TFslObject);
begin
  inherited;
  deviceIdentifierElement := TFhirDeviceUdiCarrier(oSource).deviceIdentifierElement.Clone;
  issuerElement := TFhirDeviceUdiCarrier(oSource).issuerElement.Clone;
  jurisdictionElement := TFhirDeviceUdiCarrier(oSource).jurisdictionElement.Clone;
  carrierAIDCElement := TFhirDeviceUdiCarrier(oSource).carrierAIDCElement.Clone;
  carrierHRFElement := TFhirDeviceUdiCarrier(oSource).carrierHRFElement.Clone;
  entryTypeElement := TFhirDeviceUdiCarrier(oSource).entryTypeElement.Clone;
end;

procedure TFhirDeviceUdiCarrier.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'deviceIdentifier') Then
     list.add(self.link, 'deviceIdentifier', FDeviceIdentifier.Link);
  if (child_name = 'issuer') Then
     list.add(self.link, 'issuer', FIssuer.Link);
  if (child_name = 'jurisdiction') Then
     list.add(self.link, 'jurisdiction', FJurisdiction.Link);
  if (child_name = 'carrierAIDC') Then
     list.add(self.link, 'carrierAIDC', FCarrierAIDC.Link);
  if (child_name = 'carrierHRF') Then
     list.add(self.link, 'carrierHRF', FCarrierHRF.Link);
  if (child_name = 'entryType') Then
     list.add(self.link, 'entryType', FEntryType.Link);
end;

procedure TFhirDeviceUdiCarrier.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'deviceIdentifier', 'string', false, TFhirString, FDeviceIdentifier.Link));
  oList.add(TFHIRProperty.create(self, 'issuer', 'uri', false, TFhirUri, FIssuer.Link));
  oList.add(TFHIRProperty.create(self, 'jurisdiction', 'uri', false, TFhirUri, FJurisdiction.Link));
  oList.add(TFHIRProperty.create(self, 'carrierAIDC', 'base64Binary', false, TFhirBase64Binary, FCarrierAIDC.Link));
  oList.add(TFHIRProperty.create(self, 'carrierHRF', 'string', false, TFhirString, FCarrierHRF.Link));
  oList.add(TFHIRProperty.create(self, 'entryType', 'code', false, TFhirEnum, FEntryType.Link));
end;

function TFhirDeviceUdiCarrier.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'deviceIdentifier') then
  begin
    DeviceIdentifierElement := asString(propValue);
    result := propValue;
  end
  else if (propName = 'issuer') then
  begin
    IssuerElement := asUri(propValue);
    result := propValue;
  end
  else if (propName = 'jurisdiction') then
  begin
    JurisdictionElement := asUri(propValue);
    result := propValue;
  end
  else if (propName = 'carrierAIDC') then
  begin
    CarrierAIDCElement := asBase64Binary(propValue);
    result := propValue;
  end
  else if (propName = 'carrierHRF') then
  begin
    CarrierHRFElement := asString(propValue);
    result := propValue;
  end
  else if (propName = 'entryType') then
  begin
    EntryTypeElement := asEnum(SYSTEMS_TFhirUDIEntryTypeEnum, CODES_TFhirUDIEntryTypeEnum, propValue);
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirDeviceUdiCarrier.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirDeviceUdiCarrier.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'deviceIdentifier') then result := TFhirString.create()
  else if (propName = 'issuer') then result := TFhirUri.create()
  else if (propName = 'jurisdiction') then result := TFhirUri.create()
  else if (propName = 'carrierAIDC') then result := TFhirBase64Binary.create()
  else if (propName = 'carrierHRF') then result := TFhirString.create()
  else if (propName = 'entryType') then result := TFhirEnum.create(SYSTEMS_TFhirUDIEntryTypeEnum[UDIEntryTypeNull], CODES_TFhirUDIEntryTypeEnum[UDIEntryTypeNull]) 
  else result := inherited createPropertyValue(propName);
end;

function TFhirDeviceUdiCarrier.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'deviceIdentifier') then result := 'string'
  else if (propName = 'issuer') then result := 'uri'
  else if (propName = 'jurisdiction') then result := 'uri'
  else if (propName = 'carrierAIDC') then result := 'base64Binary'
  else if (propName = 'carrierHRF') then result := 'string'
  else if (propName = 'entryType') then result := 'code'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirDeviceUdiCarrier.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'deviceIdentifier') then DeviceIdentifierElement := nil
  else if (propName = 'issuer') then IssuerElement := nil
  else if (propName = 'jurisdiction') then JurisdictionElement := nil
  else if (propName = 'carrierAIDC') then CarrierAIDCElement := nil
  else if (propName = 'carrierHRF') then CarrierHRFElement := nil
  else if (propName = 'entryType') then EntryTypeElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirDeviceUdiCarrier.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'deviceIdentifier') then DeviceIdentifierElement := asString(new)
  else if (propName = 'issuer') then IssuerElement := asUri(new)
  else if (propName = 'jurisdiction') then JurisdictionElement := asUri(new)
  else if (propName = 'carrierAIDC') then CarrierAIDCElement := asBase64Binary(new)
  else if (propName = 'carrierHRF') then CarrierHRFElement := asString(new)
  else if (propName = 'entryType') then EntryTypeElement := asEnum(SYSTEMS_TFhirUDIEntryTypeEnum, CODES_TFhirUDIEntryTypeEnum, new)
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirDeviceUdiCarrier.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirDeviceUdiCarrier.fhirType : string;
begin
  result := 'Device.udiCarrier';
end;

function TFhirDeviceUdiCarrier.Link : TFhirDeviceUdiCarrier;
begin
  result := TFhirDeviceUdiCarrier(inherited Link);
end;

function TFhirDeviceUdiCarrier.Clone : TFhirDeviceUdiCarrier;
begin
  result := TFhirDeviceUdiCarrier(inherited Clone);
end;

function TFhirDeviceUdiCarrier.equals(other : TObject) : boolean; 
var
  o : TFhirDeviceUdiCarrier;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirDeviceUdiCarrier)) then
    result := false
  else
  begin
    o := TFhirDeviceUdiCarrier(other);
    result := compareDeep(deviceIdentifierElement, o.deviceIdentifierElement, true) and 
      compareDeep(issuerElement, o.issuerElement, true) and compareDeep(jurisdictionElement, o.jurisdictionElement, true) and 
      compareDeep(carrierAIDCElement, o.carrierAIDCElement, true) and compareDeep(carrierHRFElement, o.carrierHRFElement, true) and 
      compareDeep(entryTypeElement, o.entryTypeElement, true);
  end;
end;

function TFhirDeviceUdiCarrier.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FDeviceIdentifier) and isEmptyProp(FIssuer) and isEmptyProp(FJurisdiction) and isEmptyProp(FCarrierAIDC) and isEmptyProp(FCarrierHRF) and isEmptyProp(FEntryType);
end;

procedure TFhirDeviceUdiCarrier.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('deviceIdentifier');
  fields.add('issuer');
  fields.add('jurisdiction');
  fields.add('carrierAIDC');
  fields.add('carrierHRF');
  fields.add('entryType');
end;

function TFhirDeviceUdiCarrier.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
end;

procedure TFhirDeviceUdiCarrier.SetDeviceIdentifier(value : TFhirString);
begin
  FDeviceIdentifier.free;
  FDeviceIdentifier := value;
end;

function TFhirDeviceUdiCarrier.GetDeviceIdentifierST : String;
begin
  if FDeviceIdentifier = nil then
    result := ''
  else
    result := FDeviceIdentifier.value;
end;

procedure TFhirDeviceUdiCarrier.SetDeviceIdentifierST(value : String);
begin
  if value <> '' then
  begin
    if FDeviceIdentifier = nil then
      FDeviceIdentifier := TFhirString.create;
    FDeviceIdentifier.value := value
  end
  else if FDeviceIdentifier <> nil then
    FDeviceIdentifier.value := '';
end;

procedure TFhirDeviceUdiCarrier.SetIssuer(value : TFhirUri);
begin
  FIssuer.free;
  FIssuer := value;
end;

function TFhirDeviceUdiCarrier.GetIssuerST : String;
begin
  if FIssuer = nil then
    result := ''
  else
    result := FIssuer.value;
end;

procedure TFhirDeviceUdiCarrier.SetIssuerST(value : String);
begin
  if value <> '' then
  begin
    if FIssuer = nil then
      FIssuer := TFhirUri.create;
    FIssuer.value := value
  end
  else if FIssuer <> nil then
    FIssuer.value := '';
end;

procedure TFhirDeviceUdiCarrier.SetJurisdiction(value : TFhirUri);
begin
  FJurisdiction.free;
  FJurisdiction := value;
end;

function TFhirDeviceUdiCarrier.GetJurisdictionST : String;
begin
  if FJurisdiction = nil then
    result := ''
  else
    result := FJurisdiction.value;
end;

procedure TFhirDeviceUdiCarrier.SetJurisdictionST(value : String);
begin
  if value <> '' then
  begin
    if FJurisdiction = nil then
      FJurisdiction := TFhirUri.create;
    FJurisdiction.value := value
  end
  else if FJurisdiction <> nil then
    FJurisdiction.value := '';
end;

procedure TFhirDeviceUdiCarrier.SetCarrierAIDC(value : TFhirBase64Binary);
begin
  FCarrierAIDC.free;
  FCarrierAIDC := value;
end;

function TFhirDeviceUdiCarrier.GetCarrierAIDCST : TBytes;
begin
  if FCarrierAIDC = nil then
    result := nil
  else
    result := FCarrierAIDC.value;
end;

procedure TFhirDeviceUdiCarrier.SetCarrierAIDCST(value : TBytes);
begin
  if value <> nil then
  begin
    if FCarrierAIDC = nil then
      FCarrierAIDC := TFhirBase64Binary.create;
    FCarrierAIDC.value := value
  end
  else if FCarrierAIDC <> nil then
    FCarrierAIDC.value := nil;
end;

procedure TFhirDeviceUdiCarrier.SetCarrierHRF(value : TFhirString);
begin
  FCarrierHRF.free;
  FCarrierHRF := value;
end;

function TFhirDeviceUdiCarrier.GetCarrierHRFST : String;
begin
  if FCarrierHRF = nil then
    result := ''
  else
    result := FCarrierHRF.value;
end;

procedure TFhirDeviceUdiCarrier.SetCarrierHRFST(value : String);
begin
  if value <> '' then
  begin
    if FCarrierHRF = nil then
      FCarrierHRF := TFhirString.create;
    FCarrierHRF.value := value
  end
  else if FCarrierHRF <> nil then
    FCarrierHRF.value := '';
end;

procedure TFhirDeviceUdiCarrier.SetEntryType(value : TFhirEnum);
begin
  FEntryType.free;
  FEntryType := value;
end;

function TFhirDeviceUdiCarrier.GetEntryTypeST : TFhirUDIEntryTypeEnum;
begin
  if FEntryType = nil then
    result := TFhirUDIEntryTypeEnum(0)
  else
    result := TFhirUDIEntryTypeEnum(StringArrayIndexOfSensitive(CODES_TFhirUDIEntryTypeEnum, FEntryType.value));
end;

procedure TFhirDeviceUdiCarrier.SetEntryTypeST(value : TFhirUDIEntryTypeEnum);
begin
  if ord(value) = 0 then
    EntryTypeElement := nil
  else
    EntryTypeElement := TFhirEnum.create(SYSTEMS_TFhirUDIEntryTypeEnum[value], CODES_TFhirUDIEntryTypeEnum[value]);
end;

{ TFhirDeviceUdiCarrierListEnumerator }

constructor TFhirDeviceUdiCarrierListEnumerator.Create(list : TFhirDeviceUdiCarrierList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirDeviceUdiCarrierListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirDeviceUdiCarrierListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirDeviceUdiCarrierListEnumerator.GetCurrent : TFhirDeviceUdiCarrier;
begin
  Result := FList[FIndex];
end;

function TFhirDeviceUdiCarrierListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirDeviceUdiCarrierList }

function TFhirDeviceUdiCarrierList.AddItem(value: TFhirDeviceUdiCarrier): TFhirDeviceUdiCarrier;
begin
  assert(value.ClassName = 'TFhirDeviceUdiCarrier', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirDeviceUdiCarrier');
  add(value);
  result := value;
end;

function TFhirDeviceUdiCarrierList.Append: TFhirDeviceUdiCarrier;
begin
  result := TFhirDeviceUdiCarrier.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirDeviceUdiCarrierList.ClearItems;
begin
  Clear;
end;

function TFhirDeviceUdiCarrierList.GetEnumerator : TFhirDeviceUdiCarrierListEnumerator;
begin
  result := TFhirDeviceUdiCarrierListEnumerator.Create(self.link);
end;

function TFhirDeviceUdiCarrierList.Clone: TFhirDeviceUdiCarrierList;
begin
  result := TFhirDeviceUdiCarrierList(inherited Clone);
end;

function TFhirDeviceUdiCarrierList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirDeviceUdiCarrierList.GetItemN(index: Integer): TFhirDeviceUdiCarrier;
begin
  result := TFhirDeviceUdiCarrier(ObjectByIndex[index]);
end;

function TFhirDeviceUdiCarrierList.ItemClass: TFslObjectClass;
begin
  result := TFhirDeviceUdiCarrier;
end;
function TFhirDeviceUdiCarrierList.IndexOf(value: TFhirDeviceUdiCarrier): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirDeviceUdiCarrierList.Insert(index: Integer): TFhirDeviceUdiCarrier;
begin
  result := TFhirDeviceUdiCarrier.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirDeviceUdiCarrierList.InsertItem(index: Integer; value: TFhirDeviceUdiCarrier);
begin
  assert(value is TFhirDeviceUdiCarrier);
  Inherited Insert(index, value);
end;

function TFhirDeviceUdiCarrierList.Item(index: Integer): TFhirDeviceUdiCarrier;
begin
  result := TFhirDeviceUdiCarrier(ObjectByIndex[index]);
end;

function TFhirDeviceUdiCarrierList.Link: TFhirDeviceUdiCarrierList;
begin
  result := TFhirDeviceUdiCarrierList(inherited Link);
end;

procedure TFhirDeviceUdiCarrierList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirDeviceUdiCarrierList.SetItemByIndex(index: Integer; value: TFhirDeviceUdiCarrier);
begin
  assert(value is TFhirDeviceUdiCarrier);
  FhirDeviceUdiCarriers[index] := value;
end;

procedure TFhirDeviceUdiCarrierList.SetItemN(index: Integer; value: TFhirDeviceUdiCarrier);
begin
  assert(value is TFhirDeviceUdiCarrier);
  ObjectByIndex[index] := value;
end;

{ TFhirDeviceDeviceName }

constructor TFhirDeviceDeviceName.Create;
begin
  inherited;
end;

destructor TFhirDeviceDeviceName.Destroy;
begin
  FName.free;
  FType_.free;
  inherited;
end;

procedure TFhirDeviceDeviceName.Assign(oSource : TFslObject);
begin
  inherited;
  nameElement := TFhirDeviceDeviceName(oSource).nameElement.Clone;
  type_Element := TFhirDeviceDeviceName(oSource).type_Element.Clone;
end;

procedure TFhirDeviceDeviceName.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'name') Then
     list.add(self.link, 'name', FName.Link);
  if (child_name = 'type') Then
     list.add(self.link, 'type', FType_.Link);
end;

procedure TFhirDeviceDeviceName.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'name', 'string', false, TFhirString, FName.Link));
  oList.add(TFHIRProperty.create(self, 'type', 'code', false, TFhirEnum, FType_.Link));
end;

function TFhirDeviceDeviceName.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'name') then
  begin
    NameElement := asString(propValue);
    result := propValue;
  end
  else if (propName = 'type') then
  begin
    Type_Element := asEnum(SYSTEMS_TFhirDeviceNameTypeEnum, CODES_TFhirDeviceNameTypeEnum, propValue);
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirDeviceDeviceName.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirDeviceDeviceName.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'name') then result := TFhirString.create()
  else if (propName = 'type') then result := TFhirEnum.create(SYSTEMS_TFhirDeviceNameTypeEnum[DeviceNameTypeNull], CODES_TFhirDeviceNameTypeEnum[DeviceNameTypeNull]) 
  else result := inherited createPropertyValue(propName);
end;

function TFhirDeviceDeviceName.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'name') then result := 'string'
  else if (propName = 'type') then result := 'code'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirDeviceDeviceName.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'name') then NameElement := nil
  else if (propName = 'type') then Type_Element := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirDeviceDeviceName.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'name') then NameElement := asString(new)
  else if (propName = 'type') then Type_Element := asEnum(SYSTEMS_TFhirDeviceNameTypeEnum, CODES_TFhirDeviceNameTypeEnum, new)
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirDeviceDeviceName.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirDeviceDeviceName.fhirType : string;
begin
  result := 'Device.deviceName';
end;

function TFhirDeviceDeviceName.Link : TFhirDeviceDeviceName;
begin
  result := TFhirDeviceDeviceName(inherited Link);
end;

function TFhirDeviceDeviceName.Clone : TFhirDeviceDeviceName;
begin
  result := TFhirDeviceDeviceName(inherited Clone);
end;

function TFhirDeviceDeviceName.equals(other : TObject) : boolean; 
var
  o : TFhirDeviceDeviceName;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirDeviceDeviceName)) then
    result := false
  else
  begin
    o := TFhirDeviceDeviceName(other);
    result := compareDeep(nameElement, o.nameElement, true) and compareDeep(type_Element, o.type_Element, true);
  end;
end;

function TFhirDeviceDeviceName.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FName) and isEmptyProp(FType_);
end;

procedure TFhirDeviceDeviceName.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('name');
  fields.add('type');
end;

function TFhirDeviceDeviceName.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
end;

procedure TFhirDeviceDeviceName.SetName(value : TFhirString);
begin
  FName.free;
  FName := value;
end;

function TFhirDeviceDeviceName.GetNameST : String;
begin
  if FName = nil then
    result := ''
  else
    result := FName.value;
end;

procedure TFhirDeviceDeviceName.SetNameST(value : String);
begin
  if value <> '' then
  begin
    if FName = nil then
      FName := TFhirString.create;
    FName.value := value
  end
  else if FName <> nil then
    FName.value := '';
end;

procedure TFhirDeviceDeviceName.SetType_(value : TFhirEnum);
begin
  FType_.free;
  FType_ := value;
end;

function TFhirDeviceDeviceName.GetType_ST : TFhirDeviceNameTypeEnum;
begin
  if FType_ = nil then
    result := TFhirDeviceNameTypeEnum(0)
  else
    result := TFhirDeviceNameTypeEnum(StringArrayIndexOfSensitive(CODES_TFhirDeviceNameTypeEnum, FType_.value));
end;

procedure TFhirDeviceDeviceName.SetType_ST(value : TFhirDeviceNameTypeEnum);
begin
  if ord(value) = 0 then
    Type_Element := nil
  else
    Type_Element := TFhirEnum.create(SYSTEMS_TFhirDeviceNameTypeEnum[value], CODES_TFhirDeviceNameTypeEnum[value]);
end;

{ TFhirDeviceDeviceNameListEnumerator }

constructor TFhirDeviceDeviceNameListEnumerator.Create(list : TFhirDeviceDeviceNameList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirDeviceDeviceNameListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirDeviceDeviceNameListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirDeviceDeviceNameListEnumerator.GetCurrent : TFhirDeviceDeviceName;
begin
  Result := FList[FIndex];
end;

function TFhirDeviceDeviceNameListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirDeviceDeviceNameList }

function TFhirDeviceDeviceNameList.AddItem(value: TFhirDeviceDeviceName): TFhirDeviceDeviceName;
begin
  assert(value.ClassName = 'TFhirDeviceDeviceName', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirDeviceDeviceName');
  add(value);
  result := value;
end;

function TFhirDeviceDeviceNameList.Append: TFhirDeviceDeviceName;
begin
  result := TFhirDeviceDeviceName.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirDeviceDeviceNameList.ClearItems;
begin
  Clear;
end;

function TFhirDeviceDeviceNameList.GetEnumerator : TFhirDeviceDeviceNameListEnumerator;
begin
  result := TFhirDeviceDeviceNameListEnumerator.Create(self.link);
end;

function TFhirDeviceDeviceNameList.Clone: TFhirDeviceDeviceNameList;
begin
  result := TFhirDeviceDeviceNameList(inherited Clone);
end;

function TFhirDeviceDeviceNameList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirDeviceDeviceNameList.GetItemN(index: Integer): TFhirDeviceDeviceName;
begin
  result := TFhirDeviceDeviceName(ObjectByIndex[index]);
end;

function TFhirDeviceDeviceNameList.ItemClass: TFslObjectClass;
begin
  result := TFhirDeviceDeviceName;
end;
function TFhirDeviceDeviceNameList.IndexOf(value: TFhirDeviceDeviceName): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirDeviceDeviceNameList.Insert(index: Integer): TFhirDeviceDeviceName;
begin
  result := TFhirDeviceDeviceName.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirDeviceDeviceNameList.InsertItem(index: Integer; value: TFhirDeviceDeviceName);
begin
  assert(value is TFhirDeviceDeviceName);
  Inherited Insert(index, value);
end;

function TFhirDeviceDeviceNameList.Item(index: Integer): TFhirDeviceDeviceName;
begin
  result := TFhirDeviceDeviceName(ObjectByIndex[index]);
end;

function TFhirDeviceDeviceNameList.Link: TFhirDeviceDeviceNameList;
begin
  result := TFhirDeviceDeviceNameList(inherited Link);
end;

procedure TFhirDeviceDeviceNameList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirDeviceDeviceNameList.SetItemByIndex(index: Integer; value: TFhirDeviceDeviceName);
begin
  assert(value is TFhirDeviceDeviceName);
  FhirDeviceDeviceNames[index] := value;
end;

procedure TFhirDeviceDeviceNameList.SetItemN(index: Integer; value: TFhirDeviceDeviceName);
begin
  assert(value is TFhirDeviceDeviceName);
  ObjectByIndex[index] := value;
end;

{ TFhirDeviceVersion }

constructor TFhirDeviceVersion.Create;
begin
  inherited;
end;

destructor TFhirDeviceVersion.Destroy;
begin
  FType_.free;
  FComponent.free;
  FInstallDate.free;
  FValue.free;
  inherited;
end;

procedure TFhirDeviceVersion.Assign(oSource : TFslObject);
begin
  inherited;
  type_ := TFhirDeviceVersion(oSource).type_.Clone;
  component := TFhirDeviceVersion(oSource).component.Clone;
  installDateElement := TFhirDeviceVersion(oSource).installDateElement.Clone;
  valueElement := TFhirDeviceVersion(oSource).valueElement.Clone;
end;

procedure TFhirDeviceVersion.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'type') Then
     list.add(self.link, 'type', FType_.Link);
  if (child_name = 'component') Then
     list.add(self.link, 'component', FComponent.Link);
  if (child_name = 'installDate') Then
     list.add(self.link, 'installDate', FInstallDate.Link);
  if (child_name = 'value') Then
     list.add(self.link, 'value', FValue.Link);
end;

procedure TFhirDeviceVersion.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'type', 'CodeableConcept', false, TFhirCodeableConcept, FType_.Link));
  oList.add(TFHIRProperty.create(self, 'component', 'Identifier', false, TFhirIdentifier, FComponent.Link));
  oList.add(TFHIRProperty.create(self, 'installDate', 'dateTime', false, TFhirDateTime, FInstallDate.Link));
  oList.add(TFHIRProperty.create(self, 'value', 'string', false, TFhirString, FValue.Link));
end;

function TFhirDeviceVersion.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'type') then
  begin
    Type_ := propValue as TFhirCodeableConcept;
    result := propValue;
  end
  else if (propName = 'component') then
  begin
    Component := propValue as TFhirIdentifier;
    result := propValue;
  end
  else if (propName = 'installDate') then
  begin
    InstallDateElement := asDateTime(propValue);
    result := propValue;
  end
  else if (propName = 'value') then
  begin
    ValueElement := asString(propValue);
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirDeviceVersion.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirDeviceVersion.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'type') then result := TFhirCodeableConcept.create()
  else if (propName = 'component') then result := TFhirIdentifier.create()
  else if (propName = 'installDate') then result := TFhirDateTime.create()
  else if (propName = 'value') then result := TFhirString.create()
  else result := inherited createPropertyValue(propName);
end;

function TFhirDeviceVersion.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'type') then result := 'CodeableConcept'
  else if (propName = 'component') then result := 'Identifier'
  else if (propName = 'installDate') then result := 'dateTime'
  else if (propName = 'value') then result := 'string'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirDeviceVersion.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'type') then Type_Element := nil
  else if (propName = 'component') then ComponentElement := nil
  else if (propName = 'installDate') then InstallDateElement := nil
  else if (propName = 'value') then ValueElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirDeviceVersion.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'type') then Type_Element := new as TFhirCodeableConcept
  else if (propName = 'component') then ComponentElement := new as TFhirIdentifier
  else if (propName = 'installDate') then InstallDateElement := asDateTime(new)
  else if (propName = 'value') then ValueElement := asString(new)
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirDeviceVersion.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirDeviceVersion.fhirType : string;
begin
  result := 'Device.version';
end;

function TFhirDeviceVersion.Link : TFhirDeviceVersion;
begin
  result := TFhirDeviceVersion(inherited Link);
end;

function TFhirDeviceVersion.Clone : TFhirDeviceVersion;
begin
  result := TFhirDeviceVersion(inherited Clone);
end;

function TFhirDeviceVersion.equals(other : TObject) : boolean; 
var
  o : TFhirDeviceVersion;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirDeviceVersion)) then
    result := false
  else
  begin
    o := TFhirDeviceVersion(other);
    result := compareDeep(type_Element, o.type_Element, true) and compareDeep(componentElement, o.componentElement, true) and 
      compareDeep(installDateElement, o.installDateElement, true) and compareDeep(valueElement, o.valueElement, true);
  end;
end;

function TFhirDeviceVersion.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FType_) and isEmptyProp(FComponent) and isEmptyProp(FInstallDate) and isEmptyProp(FValue);
end;

procedure TFhirDeviceVersion.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('type');
  fields.add('component');
  fields.add('installDate');
  fields.add('value');
end;

function TFhirDeviceVersion.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
end;

procedure TFhirDeviceVersion.SetType_(value : TFhirCodeableConcept);
begin
  FType_.free;
  FType_ := value;
end;

procedure TFhirDeviceVersion.SetComponent(value : TFhirIdentifier);
begin
  FComponent.free;
  FComponent := value;
end;

procedure TFhirDeviceVersion.SetInstallDate(value : TFhirDateTime);
begin
  FInstallDate.free;
  FInstallDate := value;
end;

function TFhirDeviceVersion.GetInstallDateST : TFslDateTime;
begin
  if FInstallDate = nil then
    result := TFslDateTime.makeNull
  else
    result := FInstallDate.value;
end;

procedure TFhirDeviceVersion.SetInstallDateST(value : TFslDateTime);
begin
  if FInstallDate = nil then
    FInstallDate := TFhirDateTime.create;
  FInstallDate.value := value
end;

procedure TFhirDeviceVersion.SetValue(value : TFhirString);
begin
  FValue.free;
  FValue := value;
end;

function TFhirDeviceVersion.GetValueST : String;
begin
  if FValue = nil then
    result := ''
  else
    result := FValue.value;
end;

procedure TFhirDeviceVersion.SetValueST(value : String);
begin
  if value <> '' then
  begin
    if FValue = nil then
      FValue := TFhirString.create;
    FValue.value := value
  end
  else if FValue <> nil then
    FValue.value := '';
end;

{ TFhirDeviceVersionListEnumerator }

constructor TFhirDeviceVersionListEnumerator.Create(list : TFhirDeviceVersionList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirDeviceVersionListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirDeviceVersionListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirDeviceVersionListEnumerator.GetCurrent : TFhirDeviceVersion;
begin
  Result := FList[FIndex];
end;

function TFhirDeviceVersionListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirDeviceVersionList }

function TFhirDeviceVersionList.AddItem(value: TFhirDeviceVersion): TFhirDeviceVersion;
begin
  assert(value.ClassName = 'TFhirDeviceVersion', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirDeviceVersion');
  add(value);
  result := value;
end;

function TFhirDeviceVersionList.Append: TFhirDeviceVersion;
begin
  result := TFhirDeviceVersion.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirDeviceVersionList.ClearItems;
begin
  Clear;
end;

function TFhirDeviceVersionList.GetEnumerator : TFhirDeviceVersionListEnumerator;
begin
  result := TFhirDeviceVersionListEnumerator.Create(self.link);
end;

function TFhirDeviceVersionList.Clone: TFhirDeviceVersionList;
begin
  result := TFhirDeviceVersionList(inherited Clone);
end;

function TFhirDeviceVersionList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirDeviceVersionList.GetItemN(index: Integer): TFhirDeviceVersion;
begin
  result := TFhirDeviceVersion(ObjectByIndex[index]);
end;

function TFhirDeviceVersionList.ItemClass: TFslObjectClass;
begin
  result := TFhirDeviceVersion;
end;
function TFhirDeviceVersionList.IndexOf(value: TFhirDeviceVersion): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirDeviceVersionList.Insert(index: Integer): TFhirDeviceVersion;
begin
  result := TFhirDeviceVersion.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirDeviceVersionList.InsertItem(index: Integer; value: TFhirDeviceVersion);
begin
  assert(value is TFhirDeviceVersion);
  Inherited Insert(index, value);
end;

function TFhirDeviceVersionList.Item(index: Integer): TFhirDeviceVersion;
begin
  result := TFhirDeviceVersion(ObjectByIndex[index]);
end;

function TFhirDeviceVersionList.Link: TFhirDeviceVersionList;
begin
  result := TFhirDeviceVersionList(inherited Link);
end;

procedure TFhirDeviceVersionList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirDeviceVersionList.SetItemByIndex(index: Integer; value: TFhirDeviceVersion);
begin
  assert(value is TFhirDeviceVersion);
  FhirDeviceVersions[index] := value;
end;

procedure TFhirDeviceVersionList.SetItemN(index: Integer; value: TFhirDeviceVersion);
begin
  assert(value is TFhirDeviceVersion);
  ObjectByIndex[index] := value;
end;

{ TFhirDeviceSpecialization }

constructor TFhirDeviceSpecialization.Create;
begin
  inherited;
end;

destructor TFhirDeviceSpecialization.Destroy;
begin
  FSystemType.free;
  FVersion.free;
  FCategory.free;
  inherited;
end;

procedure TFhirDeviceSpecialization.Assign(oSource : TFslObject);
begin
  inherited;
  systemType := TFhirDeviceSpecialization(oSource).systemType.Clone;
  versionElement := TFhirDeviceSpecialization(oSource).versionElement.Clone;
  category := TFhirDeviceSpecialization(oSource).category.Clone;
end;

procedure TFhirDeviceSpecialization.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'systemType') Then
     list.add(self.link, 'systemType', FSystemType.Link);
  if (child_name = 'version') Then
     list.add(self.link, 'version', FVersion.Link);
  if (child_name = 'category') Then
     list.add(self.link, 'category', FCategory.Link);
end;

procedure TFhirDeviceSpecialization.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'systemType', 'CodeableConcept', false, TFhirCodeableConcept, FSystemType.Link));
  oList.add(TFHIRProperty.create(self, 'version', 'string', false, TFhirString, FVersion.Link));
  oList.add(TFHIRProperty.create(self, 'category', 'Coding', false, TFhirCoding, FCategory.Link));
end;

function TFhirDeviceSpecialization.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'systemType') then
  begin
    SystemType := propValue as TFhirCodeableConcept;
    result := propValue;
  end
  else if (propName = 'version') then
  begin
    VersionElement := asString(propValue);
    result := propValue;
  end
  else if (propName = 'category') then
  begin
    Category := propValue as TFhirCoding;
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirDeviceSpecialization.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirDeviceSpecialization.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'systemType') then result := TFhirCodeableConcept.create()
  else if (propName = 'version') then result := TFhirString.create()
  else if (propName = 'category') then result := TFhirCoding.create()
  else result := inherited createPropertyValue(propName);
end;

function TFhirDeviceSpecialization.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'systemType') then result := 'CodeableConcept'
  else if (propName = 'version') then result := 'string'
  else if (propName = 'category') then result := 'Coding'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirDeviceSpecialization.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'systemType') then SystemTypeElement := nil
  else if (propName = 'version') then VersionElement := nil
  else if (propName = 'category') then CategoryElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirDeviceSpecialization.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'systemType') then SystemTypeElement := new as TFhirCodeableConcept
  else if (propName = 'version') then VersionElement := asString(new)
  else if (propName = 'category') then CategoryElement := new as TFhirCoding
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirDeviceSpecialization.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirDeviceSpecialization.fhirType : string;
begin
  result := 'Device.specialization';
end;

function TFhirDeviceSpecialization.Link : TFhirDeviceSpecialization;
begin
  result := TFhirDeviceSpecialization(inherited Link);
end;

function TFhirDeviceSpecialization.Clone : TFhirDeviceSpecialization;
begin
  result := TFhirDeviceSpecialization(inherited Clone);
end;

function TFhirDeviceSpecialization.equals(other : TObject) : boolean; 
var
  o : TFhirDeviceSpecialization;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirDeviceSpecialization)) then
    result := false
  else
  begin
    o := TFhirDeviceSpecialization(other);
    result := compareDeep(systemTypeElement, o.systemTypeElement, true) and compareDeep(versionElement, o.versionElement, true) and 
      compareDeep(categoryElement, o.categoryElement, true);
  end;
end;

function TFhirDeviceSpecialization.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FSystemType) and isEmptyProp(FVersion) and isEmptyProp(FCategory);
end;

procedure TFhirDeviceSpecialization.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('systemType');
  fields.add('version');
  fields.add('category');
end;

function TFhirDeviceSpecialization.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
end;

procedure TFhirDeviceSpecialization.SetSystemType(value : TFhirCodeableConcept);
begin
  FSystemType.free;
  FSystemType := value;
end;

procedure TFhirDeviceSpecialization.SetVersion(value : TFhirString);
begin
  FVersion.free;
  FVersion := value;
end;

function TFhirDeviceSpecialization.GetVersionST : String;
begin
  if FVersion = nil then
    result := ''
  else
    result := FVersion.value;
end;

procedure TFhirDeviceSpecialization.SetVersionST(value : String);
begin
  if value <> '' then
  begin
    if FVersion = nil then
      FVersion := TFhirString.create;
    FVersion.value := value
  end
  else if FVersion <> nil then
    FVersion.value := '';
end;

procedure TFhirDeviceSpecialization.SetCategory(value : TFhirCoding);
begin
  FCategory.free;
  FCategory := value;
end;

{ TFhirDeviceSpecializationListEnumerator }

constructor TFhirDeviceSpecializationListEnumerator.Create(list : TFhirDeviceSpecializationList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirDeviceSpecializationListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirDeviceSpecializationListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirDeviceSpecializationListEnumerator.GetCurrent : TFhirDeviceSpecialization;
begin
  Result := FList[FIndex];
end;

function TFhirDeviceSpecializationListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirDeviceSpecializationList }

function TFhirDeviceSpecializationList.AddItem(value: TFhirDeviceSpecialization): TFhirDeviceSpecialization;
begin
  assert(value.ClassName = 'TFhirDeviceSpecialization', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirDeviceSpecialization');
  add(value);
  result := value;
end;

function TFhirDeviceSpecializationList.Append: TFhirDeviceSpecialization;
begin
  result := TFhirDeviceSpecialization.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirDeviceSpecializationList.ClearItems;
begin
  Clear;
end;

function TFhirDeviceSpecializationList.GetEnumerator : TFhirDeviceSpecializationListEnumerator;
begin
  result := TFhirDeviceSpecializationListEnumerator.Create(self.link);
end;

function TFhirDeviceSpecializationList.Clone: TFhirDeviceSpecializationList;
begin
  result := TFhirDeviceSpecializationList(inherited Clone);
end;

function TFhirDeviceSpecializationList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirDeviceSpecializationList.GetItemN(index: Integer): TFhirDeviceSpecialization;
begin
  result := TFhirDeviceSpecialization(ObjectByIndex[index]);
end;

function TFhirDeviceSpecializationList.ItemClass: TFslObjectClass;
begin
  result := TFhirDeviceSpecialization;
end;
function TFhirDeviceSpecializationList.IndexOf(value: TFhirDeviceSpecialization): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirDeviceSpecializationList.Insert(index: Integer): TFhirDeviceSpecialization;
begin
  result := TFhirDeviceSpecialization.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirDeviceSpecializationList.InsertItem(index: Integer; value: TFhirDeviceSpecialization);
begin
  assert(value is TFhirDeviceSpecialization);
  Inherited Insert(index, value);
end;

function TFhirDeviceSpecializationList.Item(index: Integer): TFhirDeviceSpecialization;
begin
  result := TFhirDeviceSpecialization(ObjectByIndex[index]);
end;

function TFhirDeviceSpecializationList.Link: TFhirDeviceSpecializationList;
begin
  result := TFhirDeviceSpecializationList(inherited Link);
end;

procedure TFhirDeviceSpecializationList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirDeviceSpecializationList.SetItemByIndex(index: Integer; value: TFhirDeviceSpecialization);
begin
  assert(value is TFhirDeviceSpecialization);
  FhirDeviceSpecializations[index] := value;
end;

procedure TFhirDeviceSpecializationList.SetItemN(index: Integer; value: TFhirDeviceSpecialization);
begin
  assert(value is TFhirDeviceSpecialization);
  ObjectByIndex[index] := value;
end;

{ TFhirDeviceProperty }

constructor TFhirDeviceProperty.Create;
begin
  inherited;
end;

destructor TFhirDeviceProperty.Destroy;
begin
  FType_.free;
  FValue.free;
  inherited;
end;

procedure TFhirDeviceProperty.Assign(oSource : TFslObject);
begin
  inherited;
  type_ := TFhirDeviceProperty(oSource).type_.Clone;
  value := TFhirDeviceProperty(oSource).value.Clone;
end;

procedure TFhirDeviceProperty.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'type') Then
     list.add(self.link, 'type', FType_.Link);
  if (child_name = 'value[x]') or (child_name = 'value') Then
     list.add(self.link, 'value[x]', FValue.Link);
end;

procedure TFhirDeviceProperty.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'type', 'CodeableConcept', false, TFhirCodeableConcept, FType_.Link));
  oList.add(TFHIRProperty.create(self, 'value[x]', 'Quantity|CodeableConcept|string|boolean|integer|Range|Attachment', false, TFhirDataType, FValue.Link));
end;

function TFhirDeviceProperty.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'type') then
  begin
    Type_ := propValue as TFhirCodeableConcept;
    result := propValue;
  end
  else if (isMatchingName(propName, 'value', ['Quantity', 'CodeableConcept', 'String', 'Boolean', 'Integer', 'Range', 'Attachment'])) then
  begin
    Value := propValue as TFhirDataType;
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirDeviceProperty.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirDeviceProperty.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'type') then result := TFhirCodeableConcept.create()
  else if (isMatchingName(propName, 'value', ['Quantity', 'CodeableConcept', 'String', 'Boolean', 'Integer', 'Range', 'Attachment'])) then raise EFHIRException.create('Cannot make property Value')
  else result := inherited createPropertyValue(propName);
end;

function TFhirDeviceProperty.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'type') then result := 'CodeableConcept'
  else if (propName = 'value[x]') then result := 'Quantity|CodeableConcept|string|boolean|integer|Range|Attachment'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirDeviceProperty.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'type') then Type_Element := nil
  else if (isMatchingName(propName, 'value', ['Quantity', 'CodeableConcept', 'String', 'Boolean', 'Integer', 'Range', 'Attachment'])) then ValueElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirDeviceProperty.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'type') then Type_Element := new as TFhirCodeableConcept
  else if (isMatchingName(propName, 'value', ['Quantity', 'CodeableConcept', 'String', 'Boolean', 'Integer', 'Range', 'Attachment'])) then ValueElement := new as TFhirDataType
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirDeviceProperty.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirDeviceProperty.fhirType : string;
begin
  result := 'Device.property';
end;

function TFhirDeviceProperty.Link : TFhirDeviceProperty;
begin
  result := TFhirDeviceProperty(inherited Link);
end;

function TFhirDeviceProperty.Clone : TFhirDeviceProperty;
begin
  result := TFhirDeviceProperty(inherited Clone);
end;

function TFhirDeviceProperty.equals(other : TObject) : boolean; 
var
  o : TFhirDeviceProperty;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirDeviceProperty)) then
    result := false
  else
  begin
    o := TFhirDeviceProperty(other);
    result := compareDeep(type_Element, o.type_Element, true) and compareDeep(valueElement, o.valueElement, true);
  end;
end;

function TFhirDeviceProperty.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FType_) and isEmptyProp(FValue);
end;

procedure TFhirDeviceProperty.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('type');
  fields.add('value[x]');
end;

function TFhirDeviceProperty.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
end;

procedure TFhirDeviceProperty.SetType_(value : TFhirCodeableConcept);
begin
  FType_.free;
  FType_ := value;
end;

procedure TFhirDeviceProperty.SetValue(value : TFhirDataType);
begin
  FValue.free;
  FValue := value;
end;

{ TFhirDevicePropertyListEnumerator }

constructor TFhirDevicePropertyListEnumerator.Create(list : TFhirDevicePropertyList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirDevicePropertyListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirDevicePropertyListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirDevicePropertyListEnumerator.GetCurrent : TFhirDeviceProperty;
begin
  Result := FList[FIndex];
end;

function TFhirDevicePropertyListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirDevicePropertyList }

function TFhirDevicePropertyList.AddItem(value: TFhirDeviceProperty): TFhirDeviceProperty;
begin
  assert(value.ClassName = 'TFhirDeviceProperty', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirDeviceProperty');
  add(value);
  result := value;
end;

function TFhirDevicePropertyList.Append: TFhirDeviceProperty;
begin
  result := TFhirDeviceProperty.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirDevicePropertyList.ClearItems;
begin
  Clear;
end;

function TFhirDevicePropertyList.GetEnumerator : TFhirDevicePropertyListEnumerator;
begin
  result := TFhirDevicePropertyListEnumerator.Create(self.link);
end;

function TFhirDevicePropertyList.Clone: TFhirDevicePropertyList;
begin
  result := TFhirDevicePropertyList(inherited Clone);
end;

function TFhirDevicePropertyList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirDevicePropertyList.GetItemN(index: Integer): TFhirDeviceProperty;
begin
  result := TFhirDeviceProperty(ObjectByIndex[index]);
end;

function TFhirDevicePropertyList.ItemClass: TFslObjectClass;
begin
  result := TFhirDeviceProperty;
end;
function TFhirDevicePropertyList.IndexOf(value: TFhirDeviceProperty): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirDevicePropertyList.Insert(index: Integer): TFhirDeviceProperty;
begin
  result := TFhirDeviceProperty.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirDevicePropertyList.InsertItem(index: Integer; value: TFhirDeviceProperty);
begin
  assert(value is TFhirDeviceProperty);
  Inherited Insert(index, value);
end;

function TFhirDevicePropertyList.Item(index: Integer): TFhirDeviceProperty;
begin
  result := TFhirDeviceProperty(ObjectByIndex[index]);
end;

function TFhirDevicePropertyList.Link: TFhirDevicePropertyList;
begin
  result := TFhirDevicePropertyList(inherited Link);
end;

procedure TFhirDevicePropertyList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirDevicePropertyList.SetItemByIndex(index: Integer; value: TFhirDeviceProperty);
begin
  assert(value is TFhirDeviceProperty);
  FhirDeviceProperties[index] := value;
end;

procedure TFhirDevicePropertyList.SetItemN(index: Integer; value: TFhirDeviceProperty);
begin
  assert(value is TFhirDeviceProperty);
  ObjectByIndex[index] := value;
end;

{ TFhirDeviceOperation }

constructor TFhirDeviceOperation.Create;
begin
  inherited;
end;

destructor TFhirDeviceOperation.Destroy;
begin
  FStatus.free;
  FStatusReasonList.Free;
  FOperatorList.Free;
  FMode.free;
  FCycle.free;
  FDuration.free;
  inherited;
end;

procedure TFhirDeviceOperation.Assign(oSource : TFslObject);
begin
  inherited;
  status := TFhirDeviceOperation(oSource).status.Clone;
  if (TFhirDeviceOperation(oSource).FStatusReasonList = nil) then
  begin
    FStatusReasonList.free;
    FStatusReasonList := nil;
  end
  else
  begin
    if FStatusReasonList = nil then
      FStatusReasonList := TFhirCodeableConceptList.Create;
    FStatusReasonList.Assign(TFhirDeviceOperation(oSource).FStatusReasonList);
  end;
  if (TFhirDeviceOperation(oSource).FOperatorList = nil) then
  begin
    FOperatorList.free;
    FOperatorList := nil;
  end
  else
  begin
    if FOperatorList = nil then
      FOperatorList := TFhirReferenceList.Create;
    FOperatorList.Assign(TFhirDeviceOperation(oSource).FOperatorList);
  end;
  mode := TFhirDeviceOperation(oSource).mode.Clone;
  cycle := TFhirDeviceOperation(oSource).cycle.Clone;
  duration := TFhirDeviceOperation(oSource).duration.Clone;
end;

procedure TFhirDeviceOperation.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'status') Then
     list.add(self.link, 'status', FStatus.Link);
  if (child_name = 'statusReason') Then
    list.addAll(self, 'statusReason', FStatusReasonList);
  if (child_name = 'operator') Then
    list.addAll(self, 'operator', FOperatorList);
  if (child_name = 'mode') Then
     list.add(self.link, 'mode', FMode.Link);
  if (child_name = 'cycle') Then
     list.add(self.link, 'cycle', FCycle.Link);
  if (child_name = 'duration') Then
     list.add(self.link, 'duration', FDuration.Link);
end;

procedure TFhirDeviceOperation.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'status', 'CodeableConcept', false, TFhirCodeableConcept, FStatus.Link));
  oList.add(TFHIRProperty.create(self, 'statusReason', 'CodeableConcept', true, TFhirCodeableConcept, FStatusReasonList.Link));
  oList.add(TFHIRProperty.create(self, 'operator', 'Reference', true, TFhirReference, FOperatorList.Link));
  oList.add(TFHIRProperty.create(self, 'mode', 'CodeableConcept', false, TFhirCodeableConcept, FMode.Link));
  oList.add(TFHIRProperty.create(self, 'cycle', 'Count', false, TFhirCount, FCycle.Link));
  oList.add(TFHIRProperty.create(self, 'duration', 'Duration', false, TFhirDuration, FDuration.Link));
end;

function TFhirDeviceOperation.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'status') then
  begin
    Status := propValue as TFhirCodeableConcept;
    result := propValue;
  end
  else if (propName = 'statusReason') then
  begin
    StatusReasonList.add(propValue as TFhirCodeableConcept);
    result := propValue;
  end
  else if (propName = 'operator') then
  begin
    OperatorList.add(propValue as TFhirReference);
    result := propValue;
  end
  else if (propName = 'mode') then
  begin
    Mode := propValue as TFhirCodeableConcept;
    result := propValue;
  end
  else if (propName = 'cycle') then
  begin
    Cycle := propValue as TFhirCount;
    result := propValue;
  end
  else if (propName = 'duration') then
  begin
    Duration := propValue as TFhirDuration;
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirDeviceOperation.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'statusReason') then StatusReasonList.insertItem(index, propValue as TFhirCodeableConcept)
  else if (propName = 'operator') then OperatorList.insertItem(index, propValue as TFhirReference)
  else inherited;
end;

function TFhirDeviceOperation.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'status') then result := TFhirCodeableConcept.create()
  else if (propName = 'statusReason') then result := StatusReasonList.new()
  else if (propName = 'operator') then result := OperatorList.new()
  else if (propName = 'mode') then result := TFhirCodeableConcept.create()
  else if (propName = 'cycle') then result := TFhirCount.create()
  else if (propName = 'duration') then result := TFhirDuration.create()
  else result := inherited createPropertyValue(propName);
end;

function TFhirDeviceOperation.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'status') then result := 'CodeableConcept'
  else if (propName = 'statusReason') then result := 'CodeableConcept'
  else if (propName = 'operator') then result := 'Reference'
  else if (propName = 'mode') then result := 'CodeableConcept'
  else if (propName = 'cycle') then result := 'Count'
  else if (propName = 'duration') then result := 'Duration'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirDeviceOperation.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'status') then StatusElement := nil
  else if (propName = 'statusReason') then deletePropertyValue('statusReason', StatusReasonList, value)
  else if (propName = 'operator') then deletePropertyValue('operator', OperatorList, value)
  else if (propName = 'mode') then ModeElement := nil
  else if (propName = 'cycle') then CycleElement := nil
  else if (propName = 'duration') then DurationElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirDeviceOperation.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'status') then StatusElement := new as TFhirCodeableConcept
  else if (propName = 'statusReason') then replacePropertyValue('statusReason', StatusReasonList, existing, new)
  else if (propName = 'operator') then replacePropertyValue('operator', OperatorList, existing, new)
  else if (propName = 'mode') then ModeElement := new as TFhirCodeableConcept
  else if (propName = 'cycle') then CycleElement := new as TFhirCount
  else if (propName = 'duration') then DurationElement := new as TFhirDuration
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirDeviceOperation.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'statusReason') then StatusReasonList.move(source, destination)
  else if (propName = 'operator') then OperatorList.move(source, destination)
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirDeviceOperation.fhirType : string;
begin
  result := 'Device.operation';
end;

function TFhirDeviceOperation.Link : TFhirDeviceOperation;
begin
  result := TFhirDeviceOperation(inherited Link);
end;

function TFhirDeviceOperation.Clone : TFhirDeviceOperation;
begin
  result := TFhirDeviceOperation(inherited Clone);
end;

function TFhirDeviceOperation.equals(other : TObject) : boolean; 
var
  o : TFhirDeviceOperation;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirDeviceOperation)) then
    result := false
  else
  begin
    o := TFhirDeviceOperation(other);
    result := compareDeep(statusElement, o.statusElement, true) and compareDeep(statusReasonList, o.statusReasonList, true) and 
      compareDeep(operatorList, o.operatorList, true) and compareDeep(modeElement, o.modeElement, true) and 
      compareDeep(cycleElement, o.cycleElement, true) and compareDeep(durationElement, o.durationElement, true);
  end;
end;

function TFhirDeviceOperation.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FStatus) and isEmptyProp(FstatusReasonList) and isEmptyProp(FoperatorList) and isEmptyProp(FMode) and isEmptyProp(FCycle) and isEmptyProp(FDuration);
end;

procedure TFhirDeviceOperation.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('status');
  fields.add('statusReason');
  fields.add('operator');
  fields.add('mode');
  fields.add('cycle');
  fields.add('duration');
end;

function TFhirDeviceOperation.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
  inc(result, FStatusReasonList.sizeInBytes(magic));
  inc(result, FOperatorList.sizeInBytes(magic));
end;

procedure TFhirDeviceOperation.SetStatus(value : TFhirCodeableConcept);
begin
  FStatus.free;
  FStatus := value;
end;

function TFhirDeviceOperation.GetStatusReasonList : TFhirCodeableConceptList;
begin
  if FStatusReasonList = nil then
    FStatusReasonList := TFhirCodeableConceptList.Create;
  result := FStatusReasonList;
end;

function TFhirDeviceOperation.GetHasStatusReasonList : boolean;
begin
  result := (FStatusReasonList <> nil) and (FStatusReasonList.count > 0);
end;

function TFhirDeviceOperation.GetOperatorList : TFhirReferenceList;
begin
  if FOperatorList = nil then
    FOperatorList := TFhirReferenceList.Create;
  result := FOperatorList;
end;

function TFhirDeviceOperation.GetHasOperatorList : boolean;
begin
  result := (FOperatorList <> nil) and (FOperatorList.count > 0);
end;

procedure TFhirDeviceOperation.SetMode(value : TFhirCodeableConcept);
begin
  FMode.free;
  FMode := value;
end;

procedure TFhirDeviceOperation.SetCycle(value : TFhirCount);
begin
  FCycle.free;
  FCycle := value;
end;

procedure TFhirDeviceOperation.SetDuration(value : TFhirDuration);
begin
  FDuration.free;
  FDuration := value;
end;

{ TFhirDeviceOperationListEnumerator }

constructor TFhirDeviceOperationListEnumerator.Create(list : TFhirDeviceOperationList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirDeviceOperationListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirDeviceOperationListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirDeviceOperationListEnumerator.GetCurrent : TFhirDeviceOperation;
begin
  Result := FList[FIndex];
end;

function TFhirDeviceOperationListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirDeviceOperationList }

function TFhirDeviceOperationList.AddItem(value: TFhirDeviceOperation): TFhirDeviceOperation;
begin
  assert(value.ClassName = 'TFhirDeviceOperation', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirDeviceOperation');
  add(value);
  result := value;
end;

function TFhirDeviceOperationList.Append: TFhirDeviceOperation;
begin
  result := TFhirDeviceOperation.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirDeviceOperationList.ClearItems;
begin
  Clear;
end;

function TFhirDeviceOperationList.GetEnumerator : TFhirDeviceOperationListEnumerator;
begin
  result := TFhirDeviceOperationListEnumerator.Create(self.link);
end;

function TFhirDeviceOperationList.Clone: TFhirDeviceOperationList;
begin
  result := TFhirDeviceOperationList(inherited Clone);
end;

function TFhirDeviceOperationList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirDeviceOperationList.GetItemN(index: Integer): TFhirDeviceOperation;
begin
  result := TFhirDeviceOperation(ObjectByIndex[index]);
end;

function TFhirDeviceOperationList.ItemClass: TFslObjectClass;
begin
  result := TFhirDeviceOperation;
end;
function TFhirDeviceOperationList.IndexOf(value: TFhirDeviceOperation): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirDeviceOperationList.Insert(index: Integer): TFhirDeviceOperation;
begin
  result := TFhirDeviceOperation.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirDeviceOperationList.InsertItem(index: Integer; value: TFhirDeviceOperation);
begin
  assert(value is TFhirDeviceOperation);
  Inherited Insert(index, value);
end;

function TFhirDeviceOperationList.Item(index: Integer): TFhirDeviceOperation;
begin
  result := TFhirDeviceOperation(ObjectByIndex[index]);
end;

function TFhirDeviceOperationList.Link: TFhirDeviceOperationList;
begin
  result := TFhirDeviceOperationList(inherited Link);
end;

procedure TFhirDeviceOperationList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirDeviceOperationList.SetItemByIndex(index: Integer; value: TFhirDeviceOperation);
begin
  assert(value is TFhirDeviceOperation);
  FhirDeviceOperations[index] := value;
end;

procedure TFhirDeviceOperationList.SetItemN(index: Integer; value: TFhirDeviceOperation);
begin
  assert(value is TFhirDeviceOperation);
  ObjectByIndex[index] := value;
end;

{ TFhirDeviceAssociation }

constructor TFhirDeviceAssociation.Create;
begin
  inherited;
end;

destructor TFhirDeviceAssociation.Destroy;
begin
  FStatus.free;
  FStatusReasonList.Free;
  FHumanSubject.free;
  FBodyStructure.free;
  inherited;
end;

procedure TFhirDeviceAssociation.Assign(oSource : TFslObject);
begin
  inherited;
  status := TFhirDeviceAssociation(oSource).status.Clone;
  if (TFhirDeviceAssociation(oSource).FStatusReasonList = nil) then
  begin
    FStatusReasonList.free;
    FStatusReasonList := nil;
  end
  else
  begin
    if FStatusReasonList = nil then
      FStatusReasonList := TFhirCodeableConceptList.Create;
    FStatusReasonList.Assign(TFhirDeviceAssociation(oSource).FStatusReasonList);
  end;
  humanSubject := TFhirDeviceAssociation(oSource).humanSubject.Clone;
  bodyStructure := TFhirDeviceAssociation(oSource).bodyStructure.Clone;
end;

procedure TFhirDeviceAssociation.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'status') Then
     list.add(self.link, 'status', FStatus.Link);
  if (child_name = 'statusReason') Then
    list.addAll(self, 'statusReason', FStatusReasonList);
  if (child_name = 'humanSubject') Then
     list.add(self.link, 'humanSubject', FHumanSubject.Link);
  if (child_name = 'bodyStructure') Then
     list.add(self.link, 'bodyStructure', FBodyStructure.Link);
end;

procedure TFhirDeviceAssociation.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'status', 'CodeableConcept', false, TFhirCodeableConcept, FStatus.Link));
  oList.add(TFHIRProperty.create(self, 'statusReason', 'CodeableConcept', true, TFhirCodeableConcept, FStatusReasonList.Link));
  oList.add(TFHIRProperty.create(self, 'humanSubject', 'Reference', false, TFhirReference, FHumanSubject.Link));
  oList.add(TFHIRProperty.create(self, 'bodyStructure', 'CodeableReference', false, TFhirCodeableReference, FBodyStructure.Link));
end;

function TFhirDeviceAssociation.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'status') then
  begin
    Status := propValue as TFhirCodeableConcept;
    result := propValue;
  end
  else if (propName = 'statusReason') then
  begin
    StatusReasonList.add(propValue as TFhirCodeableConcept);
    result := propValue;
  end
  else if (propName = 'humanSubject') then
  begin
    HumanSubject := propValue as TFhirReference;
    result := propValue;
  end
  else if (propName = 'bodyStructure') then
  begin
    BodyStructure := propValue as TFhirCodeableReference;
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirDeviceAssociation.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'statusReason') then StatusReasonList.insertItem(index, propValue as TFhirCodeableConcept)
  else inherited;
end;

function TFhirDeviceAssociation.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'status') then result := TFhirCodeableConcept.create()
  else if (propName = 'statusReason') then result := StatusReasonList.new()
  else if (propName = 'humanSubject') then result := TFhirReference.create()
  else if (propName = 'bodyStructure') then result := TFhirCodeableReference.create()
  else result := inherited createPropertyValue(propName);
end;

function TFhirDeviceAssociation.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'status') then result := 'CodeableConcept'
  else if (propName = 'statusReason') then result := 'CodeableConcept'
  else if (propName = 'humanSubject') then result := 'Reference'
  else if (propName = 'bodyStructure') then result := 'CodeableReference'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirDeviceAssociation.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'status') then StatusElement := nil
  else if (propName = 'statusReason') then deletePropertyValue('statusReason', StatusReasonList, value)
  else if (propName = 'humanSubject') then HumanSubjectElement := nil
  else if (propName = 'bodyStructure') then BodyStructureElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirDeviceAssociation.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'status') then StatusElement := new as TFhirCodeableConcept
  else if (propName = 'statusReason') then replacePropertyValue('statusReason', StatusReasonList, existing, new)
  else if (propName = 'humanSubject') then HumanSubjectElement := new as TFhirReference
  else if (propName = 'bodyStructure') then BodyStructureElement := new as TFhirCodeableReference
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirDeviceAssociation.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'statusReason') then StatusReasonList.move(source, destination)
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirDeviceAssociation.fhirType : string;
begin
  result := 'Device.association';
end;

function TFhirDeviceAssociation.Link : TFhirDeviceAssociation;
begin
  result := TFhirDeviceAssociation(inherited Link);
end;

function TFhirDeviceAssociation.Clone : TFhirDeviceAssociation;
begin
  result := TFhirDeviceAssociation(inherited Clone);
end;

function TFhirDeviceAssociation.equals(other : TObject) : boolean; 
var
  o : TFhirDeviceAssociation;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirDeviceAssociation)) then
    result := false
  else
  begin
    o := TFhirDeviceAssociation(other);
    result := compareDeep(statusElement, o.statusElement, true) and compareDeep(statusReasonList, o.statusReasonList, true) and 
      compareDeep(humanSubjectElement, o.humanSubjectElement, true) and compareDeep(bodyStructureElement, o.bodyStructureElement, true);
  end;
end;

function TFhirDeviceAssociation.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FStatus) and isEmptyProp(FstatusReasonList) and isEmptyProp(FHumanSubject) and isEmptyProp(FBodyStructure);
end;

procedure TFhirDeviceAssociation.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('status');
  fields.add('statusReason');
  fields.add('humanSubject');
  fields.add('bodyStructure');
end;

function TFhirDeviceAssociation.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
  inc(result, FStatusReasonList.sizeInBytes(magic));
end;

procedure TFhirDeviceAssociation.SetStatus(value : TFhirCodeableConcept);
begin
  FStatus.free;
  FStatus := value;
end;

function TFhirDeviceAssociation.GetStatusReasonList : TFhirCodeableConceptList;
begin
  if FStatusReasonList = nil then
    FStatusReasonList := TFhirCodeableConceptList.Create;
  result := FStatusReasonList;
end;

function TFhirDeviceAssociation.GetHasStatusReasonList : boolean;
begin
  result := (FStatusReasonList <> nil) and (FStatusReasonList.count > 0);
end;

procedure TFhirDeviceAssociation.SetHumanSubject(value : TFhirReference);
begin
  FHumanSubject.free;
  FHumanSubject := value;
end;

procedure TFhirDeviceAssociation.SetBodyStructure(value : TFhirCodeableReference);
begin
  FBodyStructure.free;
  FBodyStructure := value;
end;

{ TFhirDeviceAssociationListEnumerator }

constructor TFhirDeviceAssociationListEnumerator.Create(list : TFhirDeviceAssociationList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirDeviceAssociationListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirDeviceAssociationListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirDeviceAssociationListEnumerator.GetCurrent : TFhirDeviceAssociation;
begin
  Result := FList[FIndex];
end;

function TFhirDeviceAssociationListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirDeviceAssociationList }

function TFhirDeviceAssociationList.AddItem(value: TFhirDeviceAssociation): TFhirDeviceAssociation;
begin
  assert(value.ClassName = 'TFhirDeviceAssociation', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirDeviceAssociation');
  add(value);
  result := value;
end;

function TFhirDeviceAssociationList.Append: TFhirDeviceAssociation;
begin
  result := TFhirDeviceAssociation.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirDeviceAssociationList.ClearItems;
begin
  Clear;
end;

function TFhirDeviceAssociationList.GetEnumerator : TFhirDeviceAssociationListEnumerator;
begin
  result := TFhirDeviceAssociationListEnumerator.Create(self.link);
end;

function TFhirDeviceAssociationList.Clone: TFhirDeviceAssociationList;
begin
  result := TFhirDeviceAssociationList(inherited Clone);
end;

function TFhirDeviceAssociationList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirDeviceAssociationList.GetItemN(index: Integer): TFhirDeviceAssociation;
begin
  result := TFhirDeviceAssociation(ObjectByIndex[index]);
end;

function TFhirDeviceAssociationList.ItemClass: TFslObjectClass;
begin
  result := TFhirDeviceAssociation;
end;
function TFhirDeviceAssociationList.IndexOf(value: TFhirDeviceAssociation): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirDeviceAssociationList.Insert(index: Integer): TFhirDeviceAssociation;
begin
  result := TFhirDeviceAssociation.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirDeviceAssociationList.InsertItem(index: Integer; value: TFhirDeviceAssociation);
begin
  assert(value is TFhirDeviceAssociation);
  Inherited Insert(index, value);
end;

function TFhirDeviceAssociationList.Item(index: Integer): TFhirDeviceAssociation;
begin
  result := TFhirDeviceAssociation(ObjectByIndex[index]);
end;

function TFhirDeviceAssociationList.Link: TFhirDeviceAssociationList;
begin
  result := TFhirDeviceAssociationList(inherited Link);
end;

procedure TFhirDeviceAssociationList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirDeviceAssociationList.SetItemByIndex(index: Integer; value: TFhirDeviceAssociation);
begin
  assert(value is TFhirDeviceAssociation);
  FhirDeviceAssociations[index] := value;
end;

procedure TFhirDeviceAssociationList.SetItemN(index: Integer; value: TFhirDeviceAssociation);
begin
  assert(value is TFhirDeviceAssociation);
  ObjectByIndex[index] := value;
end;

{ TFhirDevice }

constructor TFhirDevice.Create;
begin
  inherited;
end;

destructor TFhirDevice.Destroy;
begin
  FIdentifierList.Free;
  FDisplayName.free;
  FDefinition.free;
  FUdiCarrierList.Free;
  FStatus.free;
  FAvailabilityStatus.free;
  FBiologicalSourceEvent.free;
  FManufacturer.free;
  FManufactureDate.free;
  FExpirationDate.free;
  FLotNumber.free;
  FSerialNumber.free;
  FDeviceNameList.Free;
  FModelNumber.free;
  FPartNumber.free;
  FCategoryList.Free;
  FType_List.Free;
  FVersionList.Free;
  FSpecializationList.Free;
  FProperty_List.Free;
  FOperationList.Free;
  FAssociationList.Free;
  FOwner.free;
  FContactList.Free;
  FLocation.free;
  FUrl.free;
  FEndpointList.Free;
  FGatewayList.Free;
  FNoteList.Free;
  FSafetyList.Free;
  FParent.free;
  inherited;
end;

procedure TFhirDevice.Assign(oSource : TFslObject);
begin
  inherited;
  if (TFhirDevice(oSource).FIdentifierList = nil) then
  begin
    FIdentifierList.free;
    FIdentifierList := nil;
  end
  else
  begin
    if FIdentifierList = nil then
      FIdentifierList := TFhirIdentifierList.Create;
    FIdentifierList.Assign(TFhirDevice(oSource).FIdentifierList);
  end;
  displayNameElement := TFhirDevice(oSource).displayNameElement.Clone;
  definition := TFhirDevice(oSource).definition.Clone;
  if (TFhirDevice(oSource).FUdiCarrierList = nil) then
  begin
    FUdiCarrierList.free;
    FUdiCarrierList := nil;
  end
  else
  begin
    if FUdiCarrierList = nil then
      FUdiCarrierList := TFhirDeviceUdiCarrierList.Create;
    FUdiCarrierList.Assign(TFhirDevice(oSource).FUdiCarrierList);
  end;
  statusElement := TFhirDevice(oSource).statusElement.Clone;
  availabilityStatus := TFhirDevice(oSource).availabilityStatus.Clone;
  biologicalSourceEvent := TFhirDevice(oSource).biologicalSourceEvent.Clone;
  manufacturerElement := TFhirDevice(oSource).manufacturerElement.Clone;
  manufactureDateElement := TFhirDevice(oSource).manufactureDateElement.Clone;
  expirationDateElement := TFhirDevice(oSource).expirationDateElement.Clone;
  lotNumberElement := TFhirDevice(oSource).lotNumberElement.Clone;
  serialNumberElement := TFhirDevice(oSource).serialNumberElement.Clone;
  if (TFhirDevice(oSource).FDeviceNameList = nil) then
  begin
    FDeviceNameList.free;
    FDeviceNameList := nil;
  end
  else
  begin
    if FDeviceNameList = nil then
      FDeviceNameList := TFhirDeviceDeviceNameList.Create;
    FDeviceNameList.Assign(TFhirDevice(oSource).FDeviceNameList);
  end;
  modelNumberElement := TFhirDevice(oSource).modelNumberElement.Clone;
  partNumberElement := TFhirDevice(oSource).partNumberElement.Clone;
  if (TFhirDevice(oSource).FCategoryList = nil) then
  begin
    FCategoryList.free;
    FCategoryList := nil;
  end
  else
  begin
    if FCategoryList = nil then
      FCategoryList := TFhirCodeableConceptList.Create;
    FCategoryList.Assign(TFhirDevice(oSource).FCategoryList);
  end;
  if (TFhirDevice(oSource).FType_List = nil) then
  begin
    FType_List.free;
    FType_List := nil;
  end
  else
  begin
    if FType_List = nil then
      FType_List := TFhirCodeableConceptList.Create;
    FType_List.Assign(TFhirDevice(oSource).FType_List);
  end;
  if (TFhirDevice(oSource).FVersionList = nil) then
  begin
    FVersionList.free;
    FVersionList := nil;
  end
  else
  begin
    if FVersionList = nil then
      FVersionList := TFhirDeviceVersionList.Create;
    FVersionList.Assign(TFhirDevice(oSource).FVersionList);
  end;
  if (TFhirDevice(oSource).FSpecializationList = nil) then
  begin
    FSpecializationList.free;
    FSpecializationList := nil;
  end
  else
  begin
    if FSpecializationList = nil then
      FSpecializationList := TFhirDeviceSpecializationList.Create;
    FSpecializationList.Assign(TFhirDevice(oSource).FSpecializationList);
  end;
  if (TFhirDevice(oSource).FProperty_List = nil) then
  begin
    FProperty_List.free;
    FProperty_List := nil;
  end
  else
  begin
    if FProperty_List = nil then
      FProperty_List := TFhirDevicePropertyList.Create;
    FProperty_List.Assign(TFhirDevice(oSource).FProperty_List);
  end;
  if (TFhirDevice(oSource).FOperationList = nil) then
  begin
    FOperationList.free;
    FOperationList := nil;
  end
  else
  begin
    if FOperationList = nil then
      FOperationList := TFhirDeviceOperationList.Create;
    FOperationList.Assign(TFhirDevice(oSource).FOperationList);
  end;
  if (TFhirDevice(oSource).FAssociationList = nil) then
  begin
    FAssociationList.free;
    FAssociationList := nil;
  end
  else
  begin
    if FAssociationList = nil then
      FAssociationList := TFhirDeviceAssociationList.Create;
    FAssociationList.Assign(TFhirDevice(oSource).FAssociationList);
  end;
  owner := TFhirDevice(oSource).owner.Clone;
  if (TFhirDevice(oSource).FContactList = nil) then
  begin
    FContactList.free;
    FContactList := nil;
  end
  else
  begin
    if FContactList = nil then
      FContactList := TFhirContactPointList.Create;
    FContactList.Assign(TFhirDevice(oSource).FContactList);
  end;
  location := TFhirDevice(oSource).location.Clone;
  urlElement := TFhirDevice(oSource).urlElement.Clone;
  if (TFhirDevice(oSource).FEndpointList = nil) then
  begin
    FEndpointList.free;
    FEndpointList := nil;
  end
  else
  begin
    if FEndpointList = nil then
      FEndpointList := TFhirReferenceList.Create;
    FEndpointList.Assign(TFhirDevice(oSource).FEndpointList);
  end;
  if (TFhirDevice(oSource).FGatewayList = nil) then
  begin
    FGatewayList.free;
    FGatewayList := nil;
  end
  else
  begin
    if FGatewayList = nil then
      FGatewayList := TFhirCodeableReferenceList.Create;
    FGatewayList.Assign(TFhirDevice(oSource).FGatewayList);
  end;
  if (TFhirDevice(oSource).FNoteList = nil) then
  begin
    FNoteList.free;
    FNoteList := nil;
  end
  else
  begin
    if FNoteList = nil then
      FNoteList := TFhirAnnotationList.Create;
    FNoteList.Assign(TFhirDevice(oSource).FNoteList);
  end;
  if (TFhirDevice(oSource).FSafetyList = nil) then
  begin
    FSafetyList.free;
    FSafetyList := nil;
  end
  else
  begin
    if FSafetyList = nil then
      FSafetyList := TFhirCodeableConceptList.Create;
    FSafetyList.Assign(TFhirDevice(oSource).FSafetyList);
  end;
  parent := TFhirDevice(oSource).parent.Clone;
end;

function TFhirDevice.GetResourceType : TFhirResourceType;
begin
  result := frtDevice;
end;

procedure TFhirDevice.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'identifier') Then
    list.addAll(self, 'identifier', FIdentifierList);
  if (child_name = 'displayName') Then
     list.add(self.link, 'displayName', FDisplayName.Link);
  if (child_name = 'definition') Then
     list.add(self.link, 'definition', FDefinition.Link);
  if (child_name = 'udiCarrier') Then
    list.addAll(self, 'udiCarrier', FUdiCarrierList);
  if (child_name = 'status') Then
     list.add(self.link, 'status', FStatus.Link);
  if (child_name = 'availabilityStatus') Then
     list.add(self.link, 'availabilityStatus', FAvailabilityStatus.Link);
  if (child_name = 'biologicalSourceEvent') Then
     list.add(self.link, 'biologicalSourceEvent', FBiologicalSourceEvent.Link);
  if (child_name = 'manufacturer') Then
     list.add(self.link, 'manufacturer', FManufacturer.Link);
  if (child_name = 'manufactureDate') Then
     list.add(self.link, 'manufactureDate', FManufactureDate.Link);
  if (child_name = 'expirationDate') Then
     list.add(self.link, 'expirationDate', FExpirationDate.Link);
  if (child_name = 'lotNumber') Then
     list.add(self.link, 'lotNumber', FLotNumber.Link);
  if (child_name = 'serialNumber') Then
     list.add(self.link, 'serialNumber', FSerialNumber.Link);
  if (child_name = 'deviceName') Then
    list.addAll(self, 'deviceName', FDeviceNameList);
  if (child_name = 'modelNumber') Then
     list.add(self.link, 'modelNumber', FModelNumber.Link);
  if (child_name = 'partNumber') Then
     list.add(self.link, 'partNumber', FPartNumber.Link);
  if (child_name = 'category') Then
    list.addAll(self, 'category', FCategoryList);
  if (child_name = 'type') Then
    list.addAll(self, 'type', FType_List);
  if (child_name = 'version') Then
    list.addAll(self, 'version', FVersionList);
  if (child_name = 'specialization') Then
    list.addAll(self, 'specialization', FSpecializationList);
  if (child_name = 'property') Then
    list.addAll(self, 'property', FProperty_List);
  if (child_name = 'operation') Then
    list.addAll(self, 'operation', FOperationList);
  if (child_name = 'association') Then
    list.addAll(self, 'association', FAssociationList);
  if (child_name = 'owner') Then
     list.add(self.link, 'owner', FOwner.Link);
  if (child_name = 'contact') Then
    list.addAll(self, 'contact', FContactList);
  if (child_name = 'location') Then
     list.add(self.link, 'location', FLocation.Link);
  if (child_name = 'url') Then
     list.add(self.link, 'url', FUrl.Link);
  if (child_name = 'endpoint') Then
    list.addAll(self, 'endpoint', FEndpointList);
  if (child_name = 'gateway') Then
    list.addAll(self, 'gateway', FGatewayList);
  if (child_name = 'note') Then
    list.addAll(self, 'note', FNoteList);
  if (child_name = 'safety') Then
    list.addAll(self, 'safety', FSafetyList);
  if (child_name = 'parent') Then
     list.add(self.link, 'parent', FParent.Link);
end;

procedure TFhirDevice.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'identifier', 'Identifier', true, TFhirIdentifier, FIdentifierList.Link));
  oList.add(TFHIRProperty.create(self, 'displayName', 'string', false, TFhirString, FDisplayName.Link));
  oList.add(TFHIRProperty.create(self, 'definition', 'CodeableReference', false, TFhirCodeableReference, FDefinition.Link));
  oList.add(TFHIRProperty.create(self, 'udiCarrier', 'BackboneElement', true, TFhirDeviceUdiCarrier, FUdiCarrierList.Link));
  oList.add(TFHIRProperty.create(self, 'status', 'code', false, TFhirEnum, FStatus.Link));
  oList.add(TFHIRProperty.create(self, 'availabilityStatus', 'CodeableConcept', false, TFhirCodeableConcept, FAvailabilityStatus.Link));
  oList.add(TFHIRProperty.create(self, 'biologicalSourceEvent', 'Identifier', false, TFhirIdentifier, FBiologicalSourceEvent.Link));
  oList.add(TFHIRProperty.create(self, 'manufacturer', 'string', false, TFhirString, FManufacturer.Link));
  oList.add(TFHIRProperty.create(self, 'manufactureDate', 'dateTime', false, TFhirDateTime, FManufactureDate.Link));
  oList.add(TFHIRProperty.create(self, 'expirationDate', 'dateTime', false, TFhirDateTime, FExpirationDate.Link));
  oList.add(TFHIRProperty.create(self, 'lotNumber', 'string', false, TFhirString, FLotNumber.Link));
  oList.add(TFHIRProperty.create(self, 'serialNumber', 'string', false, TFhirString, FSerialNumber.Link));
  oList.add(TFHIRProperty.create(self, 'deviceName', 'BackboneElement', true, TFhirDeviceDeviceName, FDeviceNameList.Link));
  oList.add(TFHIRProperty.create(self, 'modelNumber', 'string', false, TFhirString, FModelNumber.Link));
  oList.add(TFHIRProperty.create(self, 'partNumber', 'string', false, TFhirString, FPartNumber.Link));
  oList.add(TFHIRProperty.create(self, 'category', 'CodeableConcept', true, TFhirCodeableConcept, FCategoryList.Link));
  oList.add(TFHIRProperty.create(self, 'type', 'CodeableConcept', true, TFhirCodeableConcept, FType_List.Link));
  oList.add(TFHIRProperty.create(self, 'version', 'BackboneElement', true, TFhirDeviceVersion, FVersionList.Link));
  oList.add(TFHIRProperty.create(self, 'specialization', 'BackboneElement', true, TFhirDeviceSpecialization, FSpecializationList.Link));
  oList.add(TFHIRProperty.create(self, 'property', 'BackboneElement', true, TFhirDeviceProperty, FProperty_List.Link));
  oList.add(TFHIRProperty.create(self, 'operation', 'BackboneElement', true, TFhirDeviceOperation, FOperationList.Link));
  oList.add(TFHIRProperty.create(self, 'association', 'BackboneElement', true, TFhirDeviceAssociation, FAssociationList.Link));
  oList.add(TFHIRProperty.create(self, 'owner', 'Reference', false, TFhirReference, FOwner.Link));
  oList.add(TFHIRProperty.create(self, 'contact', 'ContactPoint', true, TFhirContactPoint, FContactList.Link));
  oList.add(TFHIRProperty.create(self, 'location', 'Reference', false, TFhirReference, FLocation.Link));
  oList.add(TFHIRProperty.create(self, 'url', 'uri', false, TFhirUri, FUrl.Link));
  oList.add(TFHIRProperty.create(self, 'endpoint', 'Reference', true, TFhirReference, FEndpointList.Link));
  oList.add(TFHIRProperty.create(self, 'gateway', 'CodeableReference', true, TFhirCodeableReference, FGatewayList.Link));
  oList.add(TFHIRProperty.create(self, 'note', 'Annotation', true, TFhirAnnotation, FNoteList.Link));
  oList.add(TFHIRProperty.create(self, 'safety', 'CodeableConcept', true, TFhirCodeableConcept, FSafetyList.Link));
  oList.add(TFHIRProperty.create(self, 'parent', 'Reference', false, TFhirReference, FParent.Link));
end;

function TFhirDevice.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'identifier') then
  begin
    IdentifierList.add(propValue as TFhirIdentifier);
    result := propValue;
  end
  else if (propName = 'displayName') then
  begin
    DisplayNameElement := asString(propValue);
    result := propValue;
  end
  else if (propName = 'definition') then
  begin
    Definition := propValue as TFhirCodeableReference;
    result := propValue;
  end
  else if (propName = 'udiCarrier') then
  begin
    UdiCarrierList.add(propValue as TFhirDeviceUdiCarrier);
    result := propValue;
  end
  else if (propName = 'status') then
  begin
    StatusElement := asEnum(SYSTEMS_TFhirFHIRDeviceStatusEnum, CODES_TFhirFHIRDeviceStatusEnum, propValue);
    result := propValue;
  end
  else if (propName = 'availabilityStatus') then
  begin
    AvailabilityStatus := propValue as TFhirCodeableConcept;
    result := propValue;
  end
  else if (propName = 'biologicalSourceEvent') then
  begin
    BiologicalSourceEvent := propValue as TFhirIdentifier;
    result := propValue;
  end
  else if (propName = 'manufacturer') then
  begin
    ManufacturerElement := asString(propValue);
    result := propValue;
  end
  else if (propName = 'manufactureDate') then
  begin
    ManufactureDateElement := asDateTime(propValue);
    result := propValue;
  end
  else if (propName = 'expirationDate') then
  begin
    ExpirationDateElement := asDateTime(propValue);
    result := propValue;
  end
  else if (propName = 'lotNumber') then
  begin
    LotNumberElement := asString(propValue);
    result := propValue;
  end
  else if (propName = 'serialNumber') then
  begin
    SerialNumberElement := asString(propValue);
    result := propValue;
  end
  else if (propName = 'deviceName') then
  begin
    DeviceNameList.add(propValue as TFhirDeviceDeviceName);
    result := propValue;
  end
  else if (propName = 'modelNumber') then
  begin
    ModelNumberElement := asString(propValue);
    result := propValue;
  end
  else if (propName = 'partNumber') then
  begin
    PartNumberElement := asString(propValue);
    result := propValue;
  end
  else if (propName = 'category') then
  begin
    CategoryList.add(propValue as TFhirCodeableConcept);
    result := propValue;
  end
  else if (propName = 'type') then
  begin
    Type_List.add(propValue as TFhirCodeableConcept);
    result := propValue;
  end
  else if (propName = 'version') then
  begin
    VersionList.add(propValue as TFhirDeviceVersion);
    result := propValue;
  end
  else if (propName = 'specialization') then
  begin
    SpecializationList.add(propValue as TFhirDeviceSpecialization);
    result := propValue;
  end
  else if (propName = 'property') then
  begin
    Property_List.add(propValue as TFhirDeviceProperty);
    result := propValue;
  end
  else if (propName = 'operation') then
  begin
    OperationList.add(propValue as TFhirDeviceOperation);
    result := propValue;
  end
  else if (propName = 'association') then
  begin
    AssociationList.add(propValue as TFhirDeviceAssociation);
    result := propValue;
  end
  else if (propName = 'owner') then
  begin
    Owner := propValue as TFhirReference;
    result := propValue;
  end
  else if (propName = 'contact') then
  begin
    ContactList.add(propValue as TFhirContactPoint);
    result := propValue;
  end
  else if (propName = 'location') then
  begin
    Location := propValue as TFhirReference;
    result := propValue;
  end
  else if (propName = 'url') then
  begin
    UrlElement := asUri(propValue);
    result := propValue;
  end
  else if (propName = 'endpoint') then
  begin
    EndpointList.add(propValue as TFhirReference);
    result := propValue;
  end
  else if (propName = 'gateway') then
  begin
    GatewayList.add(propValue as TFhirCodeableReference);
    result := propValue;
  end
  else if (propName = 'note') then
  begin
    NoteList.add(propValue as TFhirAnnotation);
    result := propValue;
  end
  else if (propName = 'safety') then
  begin
    SafetyList.add(propValue as TFhirCodeableConcept);
    result := propValue;
  end
  else if (propName = 'parent') then
  begin
    Parent := propValue as TFhirReference;
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirDevice.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'identifier') then IdentifierList.insertItem(index, propValue as TFhirIdentifier)
  else if (propName = 'udiCarrier') then UdiCarrierList.insertItem(index, propValue as TFhirDeviceUdiCarrier)
  else if (propName = 'deviceName') then DeviceNameList.insertItem(index, propValue as TFhirDeviceDeviceName)
  else if (propName = 'category') then CategoryList.insertItem(index, propValue as TFhirCodeableConcept)
  else if (propName = 'type') then Type_List.insertItem(index, propValue as TFhirCodeableConcept)
  else if (propName = 'version') then VersionList.insertItem(index, propValue as TFhirDeviceVersion)
  else if (propName = 'specialization') then SpecializationList.insertItem(index, propValue as TFhirDeviceSpecialization)
  else if (propName = 'property') then Property_List.insertItem(index, propValue as TFhirDeviceProperty)
  else if (propName = 'operation') then OperationList.insertItem(index, propValue as TFhirDeviceOperation)
  else if (propName = 'association') then AssociationList.insertItem(index, propValue as TFhirDeviceAssociation)
  else if (propName = 'contact') then ContactList.insertItem(index, propValue as TFhirContactPoint)
  else if (propName = 'endpoint') then EndpointList.insertItem(index, propValue as TFhirReference)
  else if (propName = 'gateway') then GatewayList.insertItem(index, propValue as TFhirCodeableReference)
  else if (propName = 'note') then NoteList.insertItem(index, propValue as TFhirAnnotation)
  else if (propName = 'safety') then SafetyList.insertItem(index, propValue as TFhirCodeableConcept)
  else inherited;
end;

function TFhirDevice.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'identifier') then result := IdentifierList.new()
  else if (propName = 'displayName') then result := TFhirString.create()
  else if (propName = 'definition') then result := TFhirCodeableReference.create()
  else if (propName = 'udiCarrier') then result := UdiCarrierList.new()
  else if (propName = 'status') then result := TFhirEnum.create(SYSTEMS_TFhirFHIRDeviceStatusEnum[FHIRDeviceStatusNull], CODES_TFhirFHIRDeviceStatusEnum[FHIRDeviceStatusNull]) 
  else if (propName = 'availabilityStatus') then result := TFhirCodeableConcept.create()
  else if (propName = 'biologicalSourceEvent') then result := TFhirIdentifier.create()
  else if (propName = 'manufacturer') then result := TFhirString.create()
  else if (propName = 'manufactureDate') then result := TFhirDateTime.create()
  else if (propName = 'expirationDate') then result := TFhirDateTime.create()
  else if (propName = 'lotNumber') then result := TFhirString.create()
  else if (propName = 'serialNumber') then result := TFhirString.create()
  else if (propName = 'deviceName') then result := DeviceNameList.new()
  else if (propName = 'modelNumber') then result := TFhirString.create()
  else if (propName = 'partNumber') then result := TFhirString.create()
  else if (propName = 'category') then result := CategoryList.new()
  else if (propName = 'type') then result := Type_List.new()
  else if (propName = 'version') then result := VersionList.new()
  else if (propName = 'specialization') then result := SpecializationList.new()
  else if (propName = 'property') then result := Property_List.new()
  else if (propName = 'operation') then result := OperationList.new()
  else if (propName = 'association') then result := AssociationList.new()
  else if (propName = 'owner') then result := TFhirReference.create()
  else if (propName = 'contact') then result := ContactList.new()
  else if (propName = 'location') then result := TFhirReference.create()
  else if (propName = 'url') then result := TFhirUri.create()
  else if (propName = 'endpoint') then result := EndpointList.new()
  else if (propName = 'gateway') then result := GatewayList.new()
  else if (propName = 'note') then result := NoteList.new()
  else if (propName = 'safety') then result := SafetyList.new()
  else if (propName = 'parent') then result := TFhirReference.create()
  else result := inherited createPropertyValue(propName);
end;

function TFhirDevice.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'identifier') then result := 'Identifier'
  else if (propName = 'displayName') then result := 'string'
  else if (propName = 'definition') then result := 'CodeableReference'
  else if (propName = 'udiCarrier') then result := 'BackboneElement'
  else if (propName = 'status') then result := 'code'
  else if (propName = 'availabilityStatus') then result := 'CodeableConcept'
  else if (propName = 'biologicalSourceEvent') then result := 'Identifier'
  else if (propName = 'manufacturer') then result := 'string'
  else if (propName = 'manufactureDate') then result := 'dateTime'
  else if (propName = 'expirationDate') then result := 'dateTime'
  else if (propName = 'lotNumber') then result := 'string'
  else if (propName = 'serialNumber') then result := 'string'
  else if (propName = 'deviceName') then result := 'BackboneElement'
  else if (propName = 'modelNumber') then result := 'string'
  else if (propName = 'partNumber') then result := 'string'
  else if (propName = 'category') then result := 'CodeableConcept'
  else if (propName = 'type') then result := 'CodeableConcept'
  else if (propName = 'version') then result := 'BackboneElement'
  else if (propName = 'specialization') then result := 'BackboneElement'
  else if (propName = 'property') then result := 'BackboneElement'
  else if (propName = 'operation') then result := 'BackboneElement'
  else if (propName = 'association') then result := 'BackboneElement'
  else if (propName = 'owner') then result := 'Reference'
  else if (propName = 'contact') then result := 'ContactPoint'
  else if (propName = 'location') then result := 'Reference'
  else if (propName = 'url') then result := 'uri'
  else if (propName = 'endpoint') then result := 'Reference'
  else if (propName = 'gateway') then result := 'CodeableReference'
  else if (propName = 'note') then result := 'Annotation'
  else if (propName = 'safety') then result := 'CodeableConcept'
  else if (propName = 'parent') then result := 'Reference'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirDevice.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'identifier') then deletePropertyValue('identifier', IdentifierList, value)
  else if (propName = 'displayName') then DisplayNameElement := nil
  else if (propName = 'definition') then DefinitionElement := nil
  else if (propName = 'udiCarrier') then deletePropertyValue('udiCarrier', UdiCarrierList, value)
  else if (propName = 'status') then StatusElement := nil
  else if (propName = 'availabilityStatus') then AvailabilityStatusElement := nil
  else if (propName = 'biologicalSourceEvent') then BiologicalSourceEventElement := nil
  else if (propName = 'manufacturer') then ManufacturerElement := nil
  else if (propName = 'manufactureDate') then ManufactureDateElement := nil
  else if (propName = 'expirationDate') then ExpirationDateElement := nil
  else if (propName = 'lotNumber') then LotNumberElement := nil
  else if (propName = 'serialNumber') then SerialNumberElement := nil
  else if (propName = 'deviceName') then deletePropertyValue('deviceName', DeviceNameList, value)
  else if (propName = 'modelNumber') then ModelNumberElement := nil
  else if (propName = 'partNumber') then PartNumberElement := nil
  else if (propName = 'category') then deletePropertyValue('category', CategoryList, value)
  else if (propName = 'type') then deletePropertyValue('type', Type_List, value)
  else if (propName = 'version') then deletePropertyValue('version', VersionList, value)
  else if (propName = 'specialization') then deletePropertyValue('specialization', SpecializationList, value)
  else if (propName = 'property') then deletePropertyValue('property', Property_List, value)
  else if (propName = 'operation') then deletePropertyValue('operation', OperationList, value)
  else if (propName = 'association') then deletePropertyValue('association', AssociationList, value)
  else if (propName = 'owner') then OwnerElement := nil
  else if (propName = 'contact') then deletePropertyValue('contact', ContactList, value)
  else if (propName = 'location') then LocationElement := nil
  else if (propName = 'url') then UrlElement := nil
  else if (propName = 'endpoint') then deletePropertyValue('endpoint', EndpointList, value)
  else if (propName = 'gateway') then deletePropertyValue('gateway', GatewayList, value)
  else if (propName = 'note') then deletePropertyValue('note', NoteList, value)
  else if (propName = 'safety') then deletePropertyValue('safety', SafetyList, value)
  else if (propName = 'parent') then ParentElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirDevice.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'identifier') then replacePropertyValue('identifier', IdentifierList, existing, new)
  else if (propName = 'displayName') then DisplayNameElement := asString(new)
  else if (propName = 'definition') then DefinitionElement := new as TFhirCodeableReference
  else if (propName = 'udiCarrier') then replacePropertyValue('udiCarrier', UdiCarrierList, existing, new)
  else if (propName = 'status') then StatusElement := asEnum(SYSTEMS_TFhirFHIRDeviceStatusEnum, CODES_TFhirFHIRDeviceStatusEnum, new)
  else if (propName = 'availabilityStatus') then AvailabilityStatusElement := new as TFhirCodeableConcept
  else if (propName = 'biologicalSourceEvent') then BiologicalSourceEventElement := new as TFhirIdentifier
  else if (propName = 'manufacturer') then ManufacturerElement := asString(new)
  else if (propName = 'manufactureDate') then ManufactureDateElement := asDateTime(new)
  else if (propName = 'expirationDate') then ExpirationDateElement := asDateTime(new)
  else if (propName = 'lotNumber') then LotNumberElement := asString(new)
  else if (propName = 'serialNumber') then SerialNumberElement := asString(new)
  else if (propName = 'deviceName') then replacePropertyValue('deviceName', DeviceNameList, existing, new)
  else if (propName = 'modelNumber') then ModelNumberElement := asString(new)
  else if (propName = 'partNumber') then PartNumberElement := asString(new)
  else if (propName = 'category') then replacePropertyValue('category', CategoryList, existing, new)
  else if (propName = 'type') then replacePropertyValue('type', Type_List, existing, new)
  else if (propName = 'version') then replacePropertyValue('version', VersionList, existing, new)
  else if (propName = 'specialization') then replacePropertyValue('specialization', SpecializationList, existing, new)
  else if (propName = 'property') then replacePropertyValue('property', Property_List, existing, new)
  else if (propName = 'operation') then replacePropertyValue('operation', OperationList, existing, new)
  else if (propName = 'association') then replacePropertyValue('association', AssociationList, existing, new)
  else if (propName = 'owner') then OwnerElement := new as TFhirReference
  else if (propName = 'contact') then replacePropertyValue('contact', ContactList, existing, new)
  else if (propName = 'location') then LocationElement := new as TFhirReference
  else if (propName = 'url') then UrlElement := asUri(new)
  else if (propName = 'endpoint') then replacePropertyValue('endpoint', EndpointList, existing, new)
  else if (propName = 'gateway') then replacePropertyValue('gateway', GatewayList, existing, new)
  else if (propName = 'note') then replacePropertyValue('note', NoteList, existing, new)
  else if (propName = 'safety') then replacePropertyValue('safety', SafetyList, existing, new)
  else if (propName = 'parent') then ParentElement := new as TFhirReference
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirDevice.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'identifier') then IdentifierList.move(source, destination)
  else if (propName = 'udiCarrier') then UdiCarrierList.move(source, destination)
  else if (propName = 'deviceName') then DeviceNameList.move(source, destination)
  else if (propName = 'category') then CategoryList.move(source, destination)
  else if (propName = 'type') then Type_List.move(source, destination)
  else if (propName = 'version') then VersionList.move(source, destination)
  else if (propName = 'specialization') then SpecializationList.move(source, destination)
  else if (propName = 'property') then Property_List.move(source, destination)
  else if (propName = 'operation') then OperationList.move(source, destination)
  else if (propName = 'association') then AssociationList.move(source, destination)
  else if (propName = 'contact') then ContactList.move(source, destination)
  else if (propName = 'endpoint') then EndpointList.move(source, destination)
  else if (propName = 'gateway') then GatewayList.move(source, destination)
  else if (propName = 'note') then NoteList.move(source, destination)
  else if (propName = 'safety') then SafetyList.move(source, destination)
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirDevice.fhirType : string;
begin
  result := 'Device';
end;

function TFhirDevice.Link : TFhirDevice;
begin
  result := TFhirDevice(inherited Link);
end;

function TFhirDevice.Clone : TFhirDevice;
begin
  result := TFhirDevice(inherited Clone);
end;

function TFhirDevice.equals(other : TObject) : boolean; 
var
  o : TFhirDevice;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirDevice)) then
    result := false
  else
  begin
    o := TFhirDevice(other);
    result := compareDeep(identifierList, o.identifierList, true) and compareDeep(displayNameElement, o.displayNameElement, true) and 
      compareDeep(definitionElement, o.definitionElement, true) and compareDeep(udiCarrierList, o.udiCarrierList, true) and 
      compareDeep(statusElement, o.statusElement, true) and compareDeep(availabilityStatusElement, o.availabilityStatusElement, true) and 
      compareDeep(biologicalSourceEventElement, o.biologicalSourceEventElement, true) and 
      compareDeep(manufacturerElement, o.manufacturerElement, true) and compareDeep(manufactureDateElement, o.manufactureDateElement, true) and 
      compareDeep(expirationDateElement, o.expirationDateElement, true) and compareDeep(lotNumberElement, o.lotNumberElement, true) and 
      compareDeep(serialNumberElement, o.serialNumberElement, true) and compareDeep(deviceNameList, o.deviceNameList, true) and 
      compareDeep(modelNumberElement, o.modelNumberElement, true) and compareDeep(partNumberElement, o.partNumberElement, true) and 
      compareDeep(categoryList, o.categoryList, true) and compareDeep(type_List, o.type_List, true) and 
      compareDeep(versionList, o.versionList, true) and compareDeep(specializationList, o.specializationList, true) and 
      compareDeep(property_List, o.property_List, true) and compareDeep(operationList, o.operationList, true) and 
      compareDeep(associationList, o.associationList, true) and compareDeep(ownerElement, o.ownerElement, true) and 
      compareDeep(contactList, o.contactList, true) and compareDeep(locationElement, o.locationElement, true) and 
      compareDeep(urlElement, o.urlElement, true) and compareDeep(endpointList, o.endpointList, true) and 
      compareDeep(gatewayList, o.gatewayList, true) and compareDeep(noteList, o.noteList, true) and 
      compareDeep(safetyList, o.safetyList, true) and compareDeep(parentElement, o.parentElement, true);
  end;
end;

function TFhirDevice.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FidentifierList) and isEmptyProp(FDisplayName) and isEmptyProp(FDefinition) and isEmptyProp(FudiCarrierList) and isEmptyProp(FStatus) and isEmptyProp(FAvailabilityStatus) and isEmptyProp(FBiologicalSourceEvent) and isEmptyProp(FManufacturer) and isEmptyProp(FManufactureDate) and isEmptyProp(FExpirationDate) and isEmptyProp(FLotNumber) and isEmptyProp(FSerialNumber) and isEmptyProp(FdeviceNameList) and isEmptyProp(FModelNumber) and isEmptyProp(FPartNumber) and isEmptyProp(FcategoryList) and isEmptyProp(Ftype_List) and isEmptyProp(FversionList) and isEmptyProp(FspecializationList) and isEmptyProp(Fproperty_List) and isEmptyProp(FoperationList) and isEmptyProp(FassociationList) and isEmptyProp(FOwner) and isEmptyProp(FcontactList) and isEmptyProp(FLocation) and isEmptyProp(FUrl) and isEmptyProp(FendpointList) and isEmptyProp(FgatewayList) and isEmptyProp(FnoteList) and isEmptyProp(FsafetyList) and isEmptyProp(FParent);
end;

procedure TFhirDevice.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('identifier');
  fields.add('displayName');
  fields.add('definition');
  fields.add('udiCarrier');
  fields.add('status');
  fields.add('availabilityStatus');
  fields.add('biologicalSourceEvent');
  fields.add('manufacturer');
  fields.add('manufactureDate');
  fields.add('expirationDate');
  fields.add('lotNumber');
  fields.add('serialNumber');
  fields.add('deviceName');
  fields.add('modelNumber');
  fields.add('partNumber');
  fields.add('category');
  fields.add('type');
  fields.add('version');
  fields.add('specialization');
  fields.add('property');
  fields.add('operation');
  fields.add('association');
  fields.add('owner');
  fields.add('contact');
  fields.add('location');
  fields.add('url');
  fields.add('endpoint');
  fields.add('gateway');
  fields.add('note');
  fields.add('safety');
  fields.add('parent');
end;

function TFhirDevice.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
  inc(result, FIdentifierList.sizeInBytes(magic));
  inc(result, FUdiCarrierList.sizeInBytes(magic));
  inc(result, FDeviceNameList.sizeInBytes(magic));
  inc(result, FCategoryList.sizeInBytes(magic));
  inc(result, FType_List.sizeInBytes(magic));
  inc(result, FVersionList.sizeInBytes(magic));
  inc(result, FSpecializationList.sizeInBytes(magic));
  inc(result, FProperty_List.sizeInBytes(magic));
  inc(result, FOperationList.sizeInBytes(magic));
  inc(result, FAssociationList.sizeInBytes(magic));
  inc(result, FContactList.sizeInBytes(magic));
  inc(result, FEndpointList.sizeInBytes(magic));
  inc(result, FGatewayList.sizeInBytes(magic));
  inc(result, FNoteList.sizeInBytes(magic));
  inc(result, FSafetyList.sizeInBytes(magic));
end;

function TFhirDevice.GetIdentifierList : TFhirIdentifierList;
begin
  if FIdentifierList = nil then
    FIdentifierList := TFhirIdentifierList.Create;
  result := FIdentifierList;
end;

function TFhirDevice.GetHasIdentifierList : boolean;
begin
  result := (FIdentifierList <> nil) and (FIdentifierList.count > 0);
end;

procedure TFhirDevice.SetDisplayName(value : TFhirString);
begin
  FDisplayName.free;
  FDisplayName := value;
end;

function TFhirDevice.GetDisplayNameST : String;
begin
  if FDisplayName = nil then
    result := ''
  else
    result := FDisplayName.value;
end;

procedure TFhirDevice.SetDisplayNameST(value : String);
begin
  if value <> '' then
  begin
    if FDisplayName = nil then
      FDisplayName := TFhirString.create;
    FDisplayName.value := value
  end
  else if FDisplayName <> nil then
    FDisplayName.value := '';
end;

procedure TFhirDevice.SetDefinition(value : TFhirCodeableReference);
begin
  FDefinition.free;
  FDefinition := value;
end;

function TFhirDevice.GetUdiCarrierList : TFhirDeviceUdiCarrierList;
begin
  if FUdiCarrierList = nil then
    FUdiCarrierList := TFhirDeviceUdiCarrierList.Create;
  result := FUdiCarrierList;
end;

function TFhirDevice.GetHasUdiCarrierList : boolean;
begin
  result := (FUdiCarrierList <> nil) and (FUdiCarrierList.count > 0);
end;

procedure TFhirDevice.SetStatus(value : TFhirEnum);
begin
  FStatus.free;
  FStatus := value;
end;

function TFhirDevice.GetStatusST : TFhirFHIRDeviceStatusEnum;
begin
  if FStatus = nil then
    result := TFhirFHIRDeviceStatusEnum(0)
  else
    result := TFhirFHIRDeviceStatusEnum(StringArrayIndexOfSensitive(CODES_TFhirFHIRDeviceStatusEnum, FStatus.value));
end;

procedure TFhirDevice.SetStatusST(value : TFhirFHIRDeviceStatusEnum);
begin
  if ord(value) = 0 then
    StatusElement := nil
  else
    StatusElement := TFhirEnum.create(SYSTEMS_TFhirFHIRDeviceStatusEnum[value], CODES_TFhirFHIRDeviceStatusEnum[value]);
end;

procedure TFhirDevice.SetAvailabilityStatus(value : TFhirCodeableConcept);
begin
  FAvailabilityStatus.free;
  FAvailabilityStatus := value;
end;

procedure TFhirDevice.SetBiologicalSourceEvent(value : TFhirIdentifier);
begin
  FBiologicalSourceEvent.free;
  FBiologicalSourceEvent := value;
end;

procedure TFhirDevice.SetManufacturer(value : TFhirString);
begin
  FManufacturer.free;
  FManufacturer := value;
end;

function TFhirDevice.GetManufacturerST : String;
begin
  if FManufacturer = nil then
    result := ''
  else
    result := FManufacturer.value;
end;

procedure TFhirDevice.SetManufacturerST(value : String);
begin
  if value <> '' then
  begin
    if FManufacturer = nil then
      FManufacturer := TFhirString.create;
    FManufacturer.value := value
  end
  else if FManufacturer <> nil then
    FManufacturer.value := '';
end;

procedure TFhirDevice.SetManufactureDate(value : TFhirDateTime);
begin
  FManufactureDate.free;
  FManufactureDate := value;
end;

function TFhirDevice.GetManufactureDateST : TFslDateTime;
begin
  if FManufactureDate = nil then
    result := TFslDateTime.makeNull
  else
    result := FManufactureDate.value;
end;

procedure TFhirDevice.SetManufactureDateST(value : TFslDateTime);
begin
  if FManufactureDate = nil then
    FManufactureDate := TFhirDateTime.create;
  FManufactureDate.value := value
end;

procedure TFhirDevice.SetExpirationDate(value : TFhirDateTime);
begin
  FExpirationDate.free;
  FExpirationDate := value;
end;

function TFhirDevice.GetExpirationDateST : TFslDateTime;
begin
  if FExpirationDate = nil then
    result := TFslDateTime.makeNull
  else
    result := FExpirationDate.value;
end;

procedure TFhirDevice.SetExpirationDateST(value : TFslDateTime);
begin
  if FExpirationDate = nil then
    FExpirationDate := TFhirDateTime.create;
  FExpirationDate.value := value
end;

procedure TFhirDevice.SetLotNumber(value : TFhirString);
begin
  FLotNumber.free;
  FLotNumber := value;
end;

function TFhirDevice.GetLotNumberST : String;
begin
  if FLotNumber = nil then
    result := ''
  else
    result := FLotNumber.value;
end;

procedure TFhirDevice.SetLotNumberST(value : String);
begin
  if value <> '' then
  begin
    if FLotNumber = nil then
      FLotNumber := TFhirString.create;
    FLotNumber.value := value
  end
  else if FLotNumber <> nil then
    FLotNumber.value := '';
end;

procedure TFhirDevice.SetSerialNumber(value : TFhirString);
begin
  FSerialNumber.free;
  FSerialNumber := value;
end;

function TFhirDevice.GetSerialNumberST : String;
begin
  if FSerialNumber = nil then
    result := ''
  else
    result := FSerialNumber.value;
end;

procedure TFhirDevice.SetSerialNumberST(value : String);
begin
  if value <> '' then
  begin
    if FSerialNumber = nil then
      FSerialNumber := TFhirString.create;
    FSerialNumber.value := value
  end
  else if FSerialNumber <> nil then
    FSerialNumber.value := '';
end;

function TFhirDevice.GetDeviceNameList : TFhirDeviceDeviceNameList;
begin
  if FDeviceNameList = nil then
    FDeviceNameList := TFhirDeviceDeviceNameList.Create;
  result := FDeviceNameList;
end;

function TFhirDevice.GetHasDeviceNameList : boolean;
begin
  result := (FDeviceNameList <> nil) and (FDeviceNameList.count > 0);
end;

procedure TFhirDevice.SetModelNumber(value : TFhirString);
begin
  FModelNumber.free;
  FModelNumber := value;
end;

function TFhirDevice.GetModelNumberST : String;
begin
  if FModelNumber = nil then
    result := ''
  else
    result := FModelNumber.value;
end;

procedure TFhirDevice.SetModelNumberST(value : String);
begin
  if value <> '' then
  begin
    if FModelNumber = nil then
      FModelNumber := TFhirString.create;
    FModelNumber.value := value
  end
  else if FModelNumber <> nil then
    FModelNumber.value := '';
end;

procedure TFhirDevice.SetPartNumber(value : TFhirString);
begin
  FPartNumber.free;
  FPartNumber := value;
end;

function TFhirDevice.GetPartNumberST : String;
begin
  if FPartNumber = nil then
    result := ''
  else
    result := FPartNumber.value;
end;

procedure TFhirDevice.SetPartNumberST(value : String);
begin
  if value <> '' then
  begin
    if FPartNumber = nil then
      FPartNumber := TFhirString.create;
    FPartNumber.value := value
  end
  else if FPartNumber <> nil then
    FPartNumber.value := '';
end;

function TFhirDevice.GetCategoryList : TFhirCodeableConceptList;
begin
  if FCategoryList = nil then
    FCategoryList := TFhirCodeableConceptList.Create;
  result := FCategoryList;
end;

function TFhirDevice.GetHasCategoryList : boolean;
begin
  result := (FCategoryList <> nil) and (FCategoryList.count > 0);
end;

function TFhirDevice.GetType_List : TFhirCodeableConceptList;
begin
  if FType_List = nil then
    FType_List := TFhirCodeableConceptList.Create;
  result := FType_List;
end;

function TFhirDevice.GetHasType_List : boolean;
begin
  result := (FType_List <> nil) and (FType_List.count > 0);
end;

function TFhirDevice.GetVersionList : TFhirDeviceVersionList;
begin
  if FVersionList = nil then
    FVersionList := TFhirDeviceVersionList.Create;
  result := FVersionList;
end;

function TFhirDevice.GetHasVersionList : boolean;
begin
  result := (FVersionList <> nil) and (FVersionList.count > 0);
end;

function TFhirDevice.GetSpecializationList : TFhirDeviceSpecializationList;
begin
  if FSpecializationList = nil then
    FSpecializationList := TFhirDeviceSpecializationList.Create;
  result := FSpecializationList;
end;

function TFhirDevice.GetHasSpecializationList : boolean;
begin
  result := (FSpecializationList <> nil) and (FSpecializationList.count > 0);
end;

function TFhirDevice.GetProperty_List : TFhirDevicePropertyList;
begin
  if FProperty_List = nil then
    FProperty_List := TFhirDevicePropertyList.Create;
  result := FProperty_List;
end;

function TFhirDevice.GetHasProperty_List : boolean;
begin
  result := (FProperty_List <> nil) and (FProperty_List.count > 0);
end;

function TFhirDevice.GetOperationList : TFhirDeviceOperationList;
begin
  if FOperationList = nil then
    FOperationList := TFhirDeviceOperationList.Create;
  result := FOperationList;
end;

function TFhirDevice.GetHasOperationList : boolean;
begin
  result := (FOperationList <> nil) and (FOperationList.count > 0);
end;

function TFhirDevice.GetAssociationList : TFhirDeviceAssociationList;
begin
  if FAssociationList = nil then
    FAssociationList := TFhirDeviceAssociationList.Create;
  result := FAssociationList;
end;

function TFhirDevice.GetHasAssociationList : boolean;
begin
  result := (FAssociationList <> nil) and (FAssociationList.count > 0);
end;

procedure TFhirDevice.SetOwner(value : TFhirReference);
begin
  FOwner.free;
  FOwner := value;
end;

function TFhirDevice.GetContactList : TFhirContactPointList;
begin
  if FContactList = nil then
    FContactList := TFhirContactPointList.Create;
  result := FContactList;
end;

function TFhirDevice.GetHasContactList : boolean;
begin
  result := (FContactList <> nil) and (FContactList.count > 0);
end;

procedure TFhirDevice.SetLocation(value : TFhirReference);
begin
  FLocation.free;
  FLocation := value;
end;

procedure TFhirDevice.SetUrl(value : TFhirUri);
begin
  FUrl.free;
  FUrl := value;
end;

function TFhirDevice.GetUrlST : String;
begin
  if FUrl = nil then
    result := ''
  else
    result := FUrl.value;
end;

procedure TFhirDevice.SetUrlST(value : String);
begin
  if value <> '' then
  begin
    if FUrl = nil then
      FUrl := TFhirUri.create;
    FUrl.value := value
  end
  else if FUrl <> nil then
    FUrl.value := '';
end;

function TFhirDevice.GetEndpointList : TFhirReferenceList;
begin
  if FEndpointList = nil then
    FEndpointList := TFhirReferenceList.Create;
  result := FEndpointList;
end;

function TFhirDevice.GetHasEndpointList : boolean;
begin
  result := (FEndpointList <> nil) and (FEndpointList.count > 0);
end;

function TFhirDevice.GetGatewayList : TFhirCodeableReferenceList;
begin
  if FGatewayList = nil then
    FGatewayList := TFhirCodeableReferenceList.Create;
  result := FGatewayList;
end;

function TFhirDevice.GetHasGatewayList : boolean;
begin
  result := (FGatewayList <> nil) and (FGatewayList.count > 0);
end;

function TFhirDevice.GetNoteList : TFhirAnnotationList;
begin
  if FNoteList = nil then
    FNoteList := TFhirAnnotationList.Create;
  result := FNoteList;
end;

function TFhirDevice.GetHasNoteList : boolean;
begin
  result := (FNoteList <> nil) and (FNoteList.count > 0);
end;

function TFhirDevice.GetSafetyList : TFhirCodeableConceptList;
begin
  if FSafetyList = nil then
    FSafetyList := TFhirCodeableConceptList.Create;
  result := FSafetyList;
end;

function TFhirDevice.GetHasSafetyList : boolean;
begin
  result := (FSafetyList <> nil) and (FSafetyList.count > 0);
end;

procedure TFhirDevice.SetParent(value : TFhirReference);
begin
  FParent.free;
  FParent := value;
end;

{ TFhirDeviceListEnumerator }

constructor TFhirDeviceListEnumerator.Create(list : TFhirDeviceList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirDeviceListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirDeviceListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirDeviceListEnumerator.GetCurrent : TFhirDevice;
begin
  Result := FList[FIndex];
end;

function TFhirDeviceListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirDeviceList }

function TFhirDeviceList.AddItem(value: TFhirDevice): TFhirDevice;
begin
  assert(value.ClassName = 'TFhirDevice', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirDevice');
  add(value);
  result := value;
end;

function TFhirDeviceList.Append: TFhirDevice;
begin
  result := TFhirDevice.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirDeviceList.ClearItems;
begin
  Clear;
end;

function TFhirDeviceList.GetEnumerator : TFhirDeviceListEnumerator;
begin
  result := TFhirDeviceListEnumerator.Create(self.link);
end;

function TFhirDeviceList.Clone: TFhirDeviceList;
begin
  result := TFhirDeviceList(inherited Clone);
end;

function TFhirDeviceList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirDeviceList.GetItemN(index: Integer): TFhirDevice;
begin
  result := TFhirDevice(ObjectByIndex[index]);
end;

function TFhirDeviceList.ItemClass: TFslObjectClass;
begin
  result := TFhirDevice;
end;
function TFhirDeviceList.IndexOf(value: TFhirDevice): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirDeviceList.Insert(index: Integer): TFhirDevice;
begin
  result := TFhirDevice.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirDeviceList.InsertItem(index: Integer; value: TFhirDevice);
begin
  assert(value is TFhirDevice);
  Inherited Insert(index, value);
end;

function TFhirDeviceList.Item(index: Integer): TFhirDevice;
begin
  result := TFhirDevice(ObjectByIndex[index]);
end;

function TFhirDeviceList.Link: TFhirDeviceList;
begin
  result := TFhirDeviceList(inherited Link);
end;

procedure TFhirDeviceList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirDeviceList.SetItemByIndex(index: Integer; value: TFhirDevice);
begin
  assert(value is TFhirDevice);
  FhirDevices[index] := value;
end;

procedure TFhirDeviceList.SetItemN(index: Integer; value: TFhirDevice);
begin
  assert(value is TFhirDevice);
  ObjectByIndex[index] := value;
end;

{$ENDIF FHIR_DEVICE}
{$IFDEF FHIR_DEVICEDEFINITION}
{ TFhirDeviceDefinitionUdiDeviceIdentifier }

constructor TFhirDeviceDefinitionUdiDeviceIdentifier.Create;
begin
  inherited;
end;

destructor TFhirDeviceDefinitionUdiDeviceIdentifier.Destroy;
begin
  FDeviceIdentifier.free;
  FIssuer.free;
  FJurisdiction.free;
  FMarketDistributionList.Free;
  inherited;
end;

procedure TFhirDeviceDefinitionUdiDeviceIdentifier.Assign(oSource : TFslObject);
begin
  inherited;
  deviceIdentifierElement := TFhirDeviceDefinitionUdiDeviceIdentifier(oSource).deviceIdentifierElement.Clone;
  issuerElement := TFhirDeviceDefinitionUdiDeviceIdentifier(oSource).issuerElement.Clone;
  jurisdictionElement := TFhirDeviceDefinitionUdiDeviceIdentifier(oSource).jurisdictionElement.Clone;
  if (TFhirDeviceDefinitionUdiDeviceIdentifier(oSource).FMarketDistributionList = nil) then
  begin
    FMarketDistributionList.free;
    FMarketDistributionList := nil;
  end
  else
  begin
    if FMarketDistributionList = nil then
      FMarketDistributionList := TFhirDeviceDefinitionUdiDeviceIdentifierMarketDistributionList.Create;
    FMarketDistributionList.Assign(TFhirDeviceDefinitionUdiDeviceIdentifier(oSource).FMarketDistributionList);
  end;
end;

procedure TFhirDeviceDefinitionUdiDeviceIdentifier.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'deviceIdentifier') Then
     list.add(self.link, 'deviceIdentifier', FDeviceIdentifier.Link);
  if (child_name = 'issuer') Then
     list.add(self.link, 'issuer', FIssuer.Link);
  if (child_name = 'jurisdiction') Then
     list.add(self.link, 'jurisdiction', FJurisdiction.Link);
  if (child_name = 'marketDistribution') Then
    list.addAll(self, 'marketDistribution', FMarketDistributionList);
end;

procedure TFhirDeviceDefinitionUdiDeviceIdentifier.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'deviceIdentifier', 'string', false, TFhirString, FDeviceIdentifier.Link));
  oList.add(TFHIRProperty.create(self, 'issuer', 'uri', false, TFhirUri, FIssuer.Link));
  oList.add(TFHIRProperty.create(self, 'jurisdiction', 'uri', false, TFhirUri, FJurisdiction.Link));
  oList.add(TFHIRProperty.create(self, 'marketDistribution', 'BackboneElement', true, TFhirDeviceDefinitionUdiDeviceIdentifierMarketDistribution, FMarketDistributionList.Link));
end;

function TFhirDeviceDefinitionUdiDeviceIdentifier.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'deviceIdentifier') then
  begin
    DeviceIdentifierElement := asString(propValue);
    result := propValue;
  end
  else if (propName = 'issuer') then
  begin
    IssuerElement := asUri(propValue);
    result := propValue;
  end
  else if (propName = 'jurisdiction') then
  begin
    JurisdictionElement := asUri(propValue);
    result := propValue;
  end
  else if (propName = 'marketDistribution') then
  begin
    MarketDistributionList.add(propValue as TFhirDeviceDefinitionUdiDeviceIdentifierMarketDistribution);
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirDeviceDefinitionUdiDeviceIdentifier.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'marketDistribution') then MarketDistributionList.insertItem(index, propValue as TFhirDeviceDefinitionUdiDeviceIdentifierMarketDistribution)
  else inherited;
end;

function TFhirDeviceDefinitionUdiDeviceIdentifier.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'deviceIdentifier') then result := TFhirString.create()
  else if (propName = 'issuer') then result := TFhirUri.create()
  else if (propName = 'jurisdiction') then result := TFhirUri.create()
  else if (propName = 'marketDistribution') then result := MarketDistributionList.new()
  else result := inherited createPropertyValue(propName);
end;

function TFhirDeviceDefinitionUdiDeviceIdentifier.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'deviceIdentifier') then result := 'string'
  else if (propName = 'issuer') then result := 'uri'
  else if (propName = 'jurisdiction') then result := 'uri'
  else if (propName = 'marketDistribution') then result := 'BackboneElement'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirDeviceDefinitionUdiDeviceIdentifier.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'deviceIdentifier') then DeviceIdentifierElement := nil
  else if (propName = 'issuer') then IssuerElement := nil
  else if (propName = 'jurisdiction') then JurisdictionElement := nil
  else if (propName = 'marketDistribution') then deletePropertyValue('marketDistribution', MarketDistributionList, value)
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirDeviceDefinitionUdiDeviceIdentifier.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'deviceIdentifier') then DeviceIdentifierElement := asString(new)
  else if (propName = 'issuer') then IssuerElement := asUri(new)
  else if (propName = 'jurisdiction') then JurisdictionElement := asUri(new)
  else if (propName = 'marketDistribution') then replacePropertyValue('marketDistribution', MarketDistributionList, existing, new)
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirDeviceDefinitionUdiDeviceIdentifier.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'marketDistribution') then MarketDistributionList.move(source, destination)
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirDeviceDefinitionUdiDeviceIdentifier.fhirType : string;
begin
  result := 'DeviceDefinition.udiDeviceIdentifier';
end;

function TFhirDeviceDefinitionUdiDeviceIdentifier.Link : TFhirDeviceDefinitionUdiDeviceIdentifier;
begin
  result := TFhirDeviceDefinitionUdiDeviceIdentifier(inherited Link);
end;

function TFhirDeviceDefinitionUdiDeviceIdentifier.Clone : TFhirDeviceDefinitionUdiDeviceIdentifier;
begin
  result := TFhirDeviceDefinitionUdiDeviceIdentifier(inherited Clone);
end;

function TFhirDeviceDefinitionUdiDeviceIdentifier.equals(other : TObject) : boolean; 
var
  o : TFhirDeviceDefinitionUdiDeviceIdentifier;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirDeviceDefinitionUdiDeviceIdentifier)) then
    result := false
  else
  begin
    o := TFhirDeviceDefinitionUdiDeviceIdentifier(other);
    result := compareDeep(deviceIdentifierElement, o.deviceIdentifierElement, true) and 
      compareDeep(issuerElement, o.issuerElement, true) and compareDeep(jurisdictionElement, o.jurisdictionElement, true) and 
      compareDeep(marketDistributionList, o.marketDistributionList, true);
  end;
end;

function TFhirDeviceDefinitionUdiDeviceIdentifier.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FDeviceIdentifier) and isEmptyProp(FIssuer) and isEmptyProp(FJurisdiction) and isEmptyProp(FmarketDistributionList);
end;

procedure TFhirDeviceDefinitionUdiDeviceIdentifier.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('deviceIdentifier');
  fields.add('issuer');
  fields.add('jurisdiction');
  fields.add('marketDistribution');
end;

function TFhirDeviceDefinitionUdiDeviceIdentifier.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
  inc(result, FMarketDistributionList.sizeInBytes(magic));
end;

procedure TFhirDeviceDefinitionUdiDeviceIdentifier.SetDeviceIdentifier(value : TFhirString);
begin
  FDeviceIdentifier.free;
  FDeviceIdentifier := value;
end;

function TFhirDeviceDefinitionUdiDeviceIdentifier.GetDeviceIdentifierST : String;
begin
  if FDeviceIdentifier = nil then
    result := ''
  else
    result := FDeviceIdentifier.value;
end;

procedure TFhirDeviceDefinitionUdiDeviceIdentifier.SetDeviceIdentifierST(value : String);
begin
  if value <> '' then
  begin
    if FDeviceIdentifier = nil then
      FDeviceIdentifier := TFhirString.create;
    FDeviceIdentifier.value := value
  end
  else if FDeviceIdentifier <> nil then
    FDeviceIdentifier.value := '';
end;

procedure TFhirDeviceDefinitionUdiDeviceIdentifier.SetIssuer(value : TFhirUri);
begin
  FIssuer.free;
  FIssuer := value;
end;

function TFhirDeviceDefinitionUdiDeviceIdentifier.GetIssuerST : String;
begin
  if FIssuer = nil then
    result := ''
  else
    result := FIssuer.value;
end;

procedure TFhirDeviceDefinitionUdiDeviceIdentifier.SetIssuerST(value : String);
begin
  if value <> '' then
  begin
    if FIssuer = nil then
      FIssuer := TFhirUri.create;
    FIssuer.value := value
  end
  else if FIssuer <> nil then
    FIssuer.value := '';
end;

procedure TFhirDeviceDefinitionUdiDeviceIdentifier.SetJurisdiction(value : TFhirUri);
begin
  FJurisdiction.free;
  FJurisdiction := value;
end;

function TFhirDeviceDefinitionUdiDeviceIdentifier.GetJurisdictionST : String;
begin
  if FJurisdiction = nil then
    result := ''
  else
    result := FJurisdiction.value;
end;

procedure TFhirDeviceDefinitionUdiDeviceIdentifier.SetJurisdictionST(value : String);
begin
  if value <> '' then
  begin
    if FJurisdiction = nil then
      FJurisdiction := TFhirUri.create;
    FJurisdiction.value := value
  end
  else if FJurisdiction <> nil then
    FJurisdiction.value := '';
end;

function TFhirDeviceDefinitionUdiDeviceIdentifier.GetMarketDistributionList : TFhirDeviceDefinitionUdiDeviceIdentifierMarketDistributionList;
begin
  if FMarketDistributionList = nil then
    FMarketDistributionList := TFhirDeviceDefinitionUdiDeviceIdentifierMarketDistributionList.Create;
  result := FMarketDistributionList;
end;

function TFhirDeviceDefinitionUdiDeviceIdentifier.GetHasMarketDistributionList : boolean;
begin
  result := (FMarketDistributionList <> nil) and (FMarketDistributionList.count > 0);
end;

{ TFhirDeviceDefinitionUdiDeviceIdentifierListEnumerator }

constructor TFhirDeviceDefinitionUdiDeviceIdentifierListEnumerator.Create(list : TFhirDeviceDefinitionUdiDeviceIdentifierList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirDeviceDefinitionUdiDeviceIdentifierListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirDeviceDefinitionUdiDeviceIdentifierListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirDeviceDefinitionUdiDeviceIdentifierListEnumerator.GetCurrent : TFhirDeviceDefinitionUdiDeviceIdentifier;
begin
  Result := FList[FIndex];
end;

function TFhirDeviceDefinitionUdiDeviceIdentifierListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirDeviceDefinitionUdiDeviceIdentifierList }

function TFhirDeviceDefinitionUdiDeviceIdentifierList.AddItem(value: TFhirDeviceDefinitionUdiDeviceIdentifier): TFhirDeviceDefinitionUdiDeviceIdentifier;
begin
  assert(value.ClassName = 'TFhirDeviceDefinitionUdiDeviceIdentifier', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirDeviceDefinitionUdiDeviceIdentifier');
  add(value);
  result := value;
end;

function TFhirDeviceDefinitionUdiDeviceIdentifierList.Append: TFhirDeviceDefinitionUdiDeviceIdentifier;
begin
  result := TFhirDeviceDefinitionUdiDeviceIdentifier.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirDeviceDefinitionUdiDeviceIdentifierList.ClearItems;
begin
  Clear;
end;

function TFhirDeviceDefinitionUdiDeviceIdentifierList.GetEnumerator : TFhirDeviceDefinitionUdiDeviceIdentifierListEnumerator;
begin
  result := TFhirDeviceDefinitionUdiDeviceIdentifierListEnumerator.Create(self.link);
end;

function TFhirDeviceDefinitionUdiDeviceIdentifierList.Clone: TFhirDeviceDefinitionUdiDeviceIdentifierList;
begin
  result := TFhirDeviceDefinitionUdiDeviceIdentifierList(inherited Clone);
end;

function TFhirDeviceDefinitionUdiDeviceIdentifierList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirDeviceDefinitionUdiDeviceIdentifierList.GetItemN(index: Integer): TFhirDeviceDefinitionUdiDeviceIdentifier;
begin
  result := TFhirDeviceDefinitionUdiDeviceIdentifier(ObjectByIndex[index]);
end;

function TFhirDeviceDefinitionUdiDeviceIdentifierList.ItemClass: TFslObjectClass;
begin
  result := TFhirDeviceDefinitionUdiDeviceIdentifier;
end;
function TFhirDeviceDefinitionUdiDeviceIdentifierList.IndexOf(value: TFhirDeviceDefinitionUdiDeviceIdentifier): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirDeviceDefinitionUdiDeviceIdentifierList.Insert(index: Integer): TFhirDeviceDefinitionUdiDeviceIdentifier;
begin
  result := TFhirDeviceDefinitionUdiDeviceIdentifier.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirDeviceDefinitionUdiDeviceIdentifierList.InsertItem(index: Integer; value: TFhirDeviceDefinitionUdiDeviceIdentifier);
begin
  assert(value is TFhirDeviceDefinitionUdiDeviceIdentifier);
  Inherited Insert(index, value);
end;

function TFhirDeviceDefinitionUdiDeviceIdentifierList.Item(index: Integer): TFhirDeviceDefinitionUdiDeviceIdentifier;
begin
  result := TFhirDeviceDefinitionUdiDeviceIdentifier(ObjectByIndex[index]);
end;

function TFhirDeviceDefinitionUdiDeviceIdentifierList.Link: TFhirDeviceDefinitionUdiDeviceIdentifierList;
begin
  result := TFhirDeviceDefinitionUdiDeviceIdentifierList(inherited Link);
end;

procedure TFhirDeviceDefinitionUdiDeviceIdentifierList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirDeviceDefinitionUdiDeviceIdentifierList.SetItemByIndex(index: Integer; value: TFhirDeviceDefinitionUdiDeviceIdentifier);
begin
  assert(value is TFhirDeviceDefinitionUdiDeviceIdentifier);
  FhirDeviceDefinitionUdiDeviceIdentifiers[index] := value;
end;

procedure TFhirDeviceDefinitionUdiDeviceIdentifierList.SetItemN(index: Integer; value: TFhirDeviceDefinitionUdiDeviceIdentifier);
begin
  assert(value is TFhirDeviceDefinitionUdiDeviceIdentifier);
  ObjectByIndex[index] := value;
end;

{ TFhirDeviceDefinitionUdiDeviceIdentifierMarketDistribution }

constructor TFhirDeviceDefinitionUdiDeviceIdentifierMarketDistribution.Create;
begin
  inherited;
end;

destructor TFhirDeviceDefinitionUdiDeviceIdentifierMarketDistribution.Destroy;
begin
  FMarketPeriod.free;
  FSubJurisdiction.free;
  inherited;
end;

procedure TFhirDeviceDefinitionUdiDeviceIdentifierMarketDistribution.Assign(oSource : TFslObject);
begin
  inherited;
  marketPeriod := TFhirDeviceDefinitionUdiDeviceIdentifierMarketDistribution(oSource).marketPeriod.Clone;
  subJurisdictionElement := TFhirDeviceDefinitionUdiDeviceIdentifierMarketDistribution(oSource).subJurisdictionElement.Clone;
end;

procedure TFhirDeviceDefinitionUdiDeviceIdentifierMarketDistribution.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'marketPeriod') Then
     list.add(self.link, 'marketPeriod', FMarketPeriod.Link);
  if (child_name = 'subJurisdiction') Then
     list.add(self.link, 'subJurisdiction', FSubJurisdiction.Link);
end;

procedure TFhirDeviceDefinitionUdiDeviceIdentifierMarketDistribution.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'marketPeriod', 'Period', false, TFhirPeriod, FMarketPeriod.Link));
  oList.add(TFHIRProperty.create(self, 'subJurisdiction', 'uri', false, TFhirUri, FSubJurisdiction.Link));
end;

function TFhirDeviceDefinitionUdiDeviceIdentifierMarketDistribution.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'marketPeriod') then
  begin
    MarketPeriod := propValue as TFhirPeriod;
    result := propValue;
  end
  else if (propName = 'subJurisdiction') then
  begin
    SubJurisdictionElement := asUri(propValue);
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirDeviceDefinitionUdiDeviceIdentifierMarketDistribution.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirDeviceDefinitionUdiDeviceIdentifierMarketDistribution.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'marketPeriod') then result := TFhirPeriod.create()
  else if (propName = 'subJurisdiction') then result := TFhirUri.create()
  else result := inherited createPropertyValue(propName);
end;

function TFhirDeviceDefinitionUdiDeviceIdentifierMarketDistribution.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'marketPeriod') then result := 'Period'
  else if (propName = 'subJurisdiction') then result := 'uri'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirDeviceDefinitionUdiDeviceIdentifierMarketDistribution.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'marketPeriod') then MarketPeriodElement := nil
  else if (propName = 'subJurisdiction') then SubJurisdictionElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirDeviceDefinitionUdiDeviceIdentifierMarketDistribution.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'marketPeriod') then MarketPeriodElement := new as TFhirPeriod
  else if (propName = 'subJurisdiction') then SubJurisdictionElement := asUri(new)
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirDeviceDefinitionUdiDeviceIdentifierMarketDistribution.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirDeviceDefinitionUdiDeviceIdentifierMarketDistribution.fhirType : string;
begin
  result := 'DeviceDefinition.udiDeviceIdentifier.marketDistribution';
end;

function TFhirDeviceDefinitionUdiDeviceIdentifierMarketDistribution.Link : TFhirDeviceDefinitionUdiDeviceIdentifierMarketDistribution;
begin
  result := TFhirDeviceDefinitionUdiDeviceIdentifierMarketDistribution(inherited Link);
end;

function TFhirDeviceDefinitionUdiDeviceIdentifierMarketDistribution.Clone : TFhirDeviceDefinitionUdiDeviceIdentifierMarketDistribution;
begin
  result := TFhirDeviceDefinitionUdiDeviceIdentifierMarketDistribution(inherited Clone);
end;

function TFhirDeviceDefinitionUdiDeviceIdentifierMarketDistribution.equals(other : TObject) : boolean; 
var
  o : TFhirDeviceDefinitionUdiDeviceIdentifierMarketDistribution;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirDeviceDefinitionUdiDeviceIdentifierMarketDistribution)) then
    result := false
  else
  begin
    o := TFhirDeviceDefinitionUdiDeviceIdentifierMarketDistribution(other);
    result := compareDeep(marketPeriodElement, o.marketPeriodElement, true) and 
      compareDeep(subJurisdictionElement, o.subJurisdictionElement, true);
  end;
end;

function TFhirDeviceDefinitionUdiDeviceIdentifierMarketDistribution.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FMarketPeriod) and isEmptyProp(FSubJurisdiction);
end;

procedure TFhirDeviceDefinitionUdiDeviceIdentifierMarketDistribution.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('marketPeriod');
  fields.add('subJurisdiction');
end;

function TFhirDeviceDefinitionUdiDeviceIdentifierMarketDistribution.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
end;

procedure TFhirDeviceDefinitionUdiDeviceIdentifierMarketDistribution.SetMarketPeriod(value : TFhirPeriod);
begin
  FMarketPeriod.free;
  FMarketPeriod := value;
end;

procedure TFhirDeviceDefinitionUdiDeviceIdentifierMarketDistribution.SetSubJurisdiction(value : TFhirUri);
begin
  FSubJurisdiction.free;
  FSubJurisdiction := value;
end;

function TFhirDeviceDefinitionUdiDeviceIdentifierMarketDistribution.GetSubJurisdictionST : String;
begin
  if FSubJurisdiction = nil then
    result := ''
  else
    result := FSubJurisdiction.value;
end;

procedure TFhirDeviceDefinitionUdiDeviceIdentifierMarketDistribution.SetSubJurisdictionST(value : String);
begin
  if value <> '' then
  begin
    if FSubJurisdiction = nil then
      FSubJurisdiction := TFhirUri.create;
    FSubJurisdiction.value := value
  end
  else if FSubJurisdiction <> nil then
    FSubJurisdiction.value := '';
end;

{ TFhirDeviceDefinitionUdiDeviceIdentifierMarketDistributionListEnumerator }

constructor TFhirDeviceDefinitionUdiDeviceIdentifierMarketDistributionListEnumerator.Create(list : TFhirDeviceDefinitionUdiDeviceIdentifierMarketDistributionList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirDeviceDefinitionUdiDeviceIdentifierMarketDistributionListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirDeviceDefinitionUdiDeviceIdentifierMarketDistributionListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirDeviceDefinitionUdiDeviceIdentifierMarketDistributionListEnumerator.GetCurrent : TFhirDeviceDefinitionUdiDeviceIdentifierMarketDistribution;
begin
  Result := FList[FIndex];
end;

function TFhirDeviceDefinitionUdiDeviceIdentifierMarketDistributionListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirDeviceDefinitionUdiDeviceIdentifierMarketDistributionList }

function TFhirDeviceDefinitionUdiDeviceIdentifierMarketDistributionList.AddItem(value: TFhirDeviceDefinitionUdiDeviceIdentifierMarketDistribution): TFhirDeviceDefinitionUdiDeviceIdentifierMarketDistribution;
begin
  assert(value.ClassName = 'TFhirDeviceDefinitionUdiDeviceIdentifierMarketDistribution', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirDeviceDefinitionUdiDeviceIdentifierMarketDistribution');
  add(value);
  result := value;
end;

function TFhirDeviceDefinitionUdiDeviceIdentifierMarketDistributionList.Append: TFhirDeviceDefinitionUdiDeviceIdentifierMarketDistribution;
begin
  result := TFhirDeviceDefinitionUdiDeviceIdentifierMarketDistribution.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirDeviceDefinitionUdiDeviceIdentifierMarketDistributionList.ClearItems;
begin
  Clear;
end;

function TFhirDeviceDefinitionUdiDeviceIdentifierMarketDistributionList.GetEnumerator : TFhirDeviceDefinitionUdiDeviceIdentifierMarketDistributionListEnumerator;
begin
  result := TFhirDeviceDefinitionUdiDeviceIdentifierMarketDistributionListEnumerator.Create(self.link);
end;

function TFhirDeviceDefinitionUdiDeviceIdentifierMarketDistributionList.Clone: TFhirDeviceDefinitionUdiDeviceIdentifierMarketDistributionList;
begin
  result := TFhirDeviceDefinitionUdiDeviceIdentifierMarketDistributionList(inherited Clone);
end;

function TFhirDeviceDefinitionUdiDeviceIdentifierMarketDistributionList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirDeviceDefinitionUdiDeviceIdentifierMarketDistributionList.GetItemN(index: Integer): TFhirDeviceDefinitionUdiDeviceIdentifierMarketDistribution;
begin
  result := TFhirDeviceDefinitionUdiDeviceIdentifierMarketDistribution(ObjectByIndex[index]);
end;

function TFhirDeviceDefinitionUdiDeviceIdentifierMarketDistributionList.ItemClass: TFslObjectClass;
begin
  result := TFhirDeviceDefinitionUdiDeviceIdentifierMarketDistribution;
end;
function TFhirDeviceDefinitionUdiDeviceIdentifierMarketDistributionList.IndexOf(value: TFhirDeviceDefinitionUdiDeviceIdentifierMarketDistribution): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirDeviceDefinitionUdiDeviceIdentifierMarketDistributionList.Insert(index: Integer): TFhirDeviceDefinitionUdiDeviceIdentifierMarketDistribution;
begin
  result := TFhirDeviceDefinitionUdiDeviceIdentifierMarketDistribution.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirDeviceDefinitionUdiDeviceIdentifierMarketDistributionList.InsertItem(index: Integer; value: TFhirDeviceDefinitionUdiDeviceIdentifierMarketDistribution);
begin
  assert(value is TFhirDeviceDefinitionUdiDeviceIdentifierMarketDistribution);
  Inherited Insert(index, value);
end;

function TFhirDeviceDefinitionUdiDeviceIdentifierMarketDistributionList.Item(index: Integer): TFhirDeviceDefinitionUdiDeviceIdentifierMarketDistribution;
begin
  result := TFhirDeviceDefinitionUdiDeviceIdentifierMarketDistribution(ObjectByIndex[index]);
end;

function TFhirDeviceDefinitionUdiDeviceIdentifierMarketDistributionList.Link: TFhirDeviceDefinitionUdiDeviceIdentifierMarketDistributionList;
begin
  result := TFhirDeviceDefinitionUdiDeviceIdentifierMarketDistributionList(inherited Link);
end;

procedure TFhirDeviceDefinitionUdiDeviceIdentifierMarketDistributionList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirDeviceDefinitionUdiDeviceIdentifierMarketDistributionList.SetItemByIndex(index: Integer; value: TFhirDeviceDefinitionUdiDeviceIdentifierMarketDistribution);
begin
  assert(value is TFhirDeviceDefinitionUdiDeviceIdentifierMarketDistribution);
  FhirDeviceDefinitionUdiDeviceIdentifierMarketDistributions[index] := value;
end;

procedure TFhirDeviceDefinitionUdiDeviceIdentifierMarketDistributionList.SetItemN(index: Integer; value: TFhirDeviceDefinitionUdiDeviceIdentifierMarketDistribution);
begin
  assert(value is TFhirDeviceDefinitionUdiDeviceIdentifierMarketDistribution);
  ObjectByIndex[index] := value;
end;

{ TFhirDeviceDefinitionRegulatoryIdentifier }

constructor TFhirDeviceDefinitionRegulatoryIdentifier.Create;
begin
  inherited;
end;

destructor TFhirDeviceDefinitionRegulatoryIdentifier.Destroy;
begin
  FType_.free;
  FDeviceIdentifier.free;
  FIssuer.free;
  FJurisdiction.free;
  inherited;
end;

procedure TFhirDeviceDefinitionRegulatoryIdentifier.Assign(oSource : TFslObject);
begin
  inherited;
  type_Element := TFhirDeviceDefinitionRegulatoryIdentifier(oSource).type_Element.Clone;
  deviceIdentifierElement := TFhirDeviceDefinitionRegulatoryIdentifier(oSource).deviceIdentifierElement.Clone;
  issuerElement := TFhirDeviceDefinitionRegulatoryIdentifier(oSource).issuerElement.Clone;
  jurisdictionElement := TFhirDeviceDefinitionRegulatoryIdentifier(oSource).jurisdictionElement.Clone;
end;

procedure TFhirDeviceDefinitionRegulatoryIdentifier.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'type') Then
     list.add(self.link, 'type', FType_.Link);
  if (child_name = 'deviceIdentifier') Then
     list.add(self.link, 'deviceIdentifier', FDeviceIdentifier.Link);
  if (child_name = 'issuer') Then
     list.add(self.link, 'issuer', FIssuer.Link);
  if (child_name = 'jurisdiction') Then
     list.add(self.link, 'jurisdiction', FJurisdiction.Link);
end;

procedure TFhirDeviceDefinitionRegulatoryIdentifier.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'type', 'code', false, TFhirEnum, FType_.Link));
  oList.add(TFHIRProperty.create(self, 'deviceIdentifier', 'string', false, TFhirString, FDeviceIdentifier.Link));
  oList.add(TFHIRProperty.create(self, 'issuer', 'uri', false, TFhirUri, FIssuer.Link));
  oList.add(TFHIRProperty.create(self, 'jurisdiction', 'uri', false, TFhirUri, FJurisdiction.Link));
end;

function TFhirDeviceDefinitionRegulatoryIdentifier.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'type') then
  begin
    Type_Element := asEnum(SYSTEMS_TFhirDeviceDefinitionRegulatoryIdentifierTypeEnum, CODES_TFhirDeviceDefinitionRegulatoryIdentifierTypeEnum, propValue);
    result := propValue;
  end
  else if (propName = 'deviceIdentifier') then
  begin
    DeviceIdentifierElement := asString(propValue);
    result := propValue;
  end
  else if (propName = 'issuer') then
  begin
    IssuerElement := asUri(propValue);
    result := propValue;
  end
  else if (propName = 'jurisdiction') then
  begin
    JurisdictionElement := asUri(propValue);
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirDeviceDefinitionRegulatoryIdentifier.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirDeviceDefinitionRegulatoryIdentifier.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'type') then result := TFhirEnum.create(SYSTEMS_TFhirDeviceDefinitionRegulatoryIdentifierTypeEnum[DeviceDefinitionRegulatoryIdentifierTypeNull], CODES_TFhirDeviceDefinitionRegulatoryIdentifierTypeEnum[DeviceDefinitionRegulatoryIdentifierTypeNull]) 
  else if (propName = 'deviceIdentifier') then result := TFhirString.create()
  else if (propName = 'issuer') then result := TFhirUri.create()
  else if (propName = 'jurisdiction') then result := TFhirUri.create()
  else result := inherited createPropertyValue(propName);
end;

function TFhirDeviceDefinitionRegulatoryIdentifier.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'type') then result := 'code'
  else if (propName = 'deviceIdentifier') then result := 'string'
  else if (propName = 'issuer') then result := 'uri'
  else if (propName = 'jurisdiction') then result := 'uri'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirDeviceDefinitionRegulatoryIdentifier.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'type') then Type_Element := nil
  else if (propName = 'deviceIdentifier') then DeviceIdentifierElement := nil
  else if (propName = 'issuer') then IssuerElement := nil
  else if (propName = 'jurisdiction') then JurisdictionElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirDeviceDefinitionRegulatoryIdentifier.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'type') then Type_Element := asEnum(SYSTEMS_TFhirDeviceDefinitionRegulatoryIdentifierTypeEnum, CODES_TFhirDeviceDefinitionRegulatoryIdentifierTypeEnum, new)
  else if (propName = 'deviceIdentifier') then DeviceIdentifierElement := asString(new)
  else if (propName = 'issuer') then IssuerElement := asUri(new)
  else if (propName = 'jurisdiction') then JurisdictionElement := asUri(new)
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirDeviceDefinitionRegulatoryIdentifier.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirDeviceDefinitionRegulatoryIdentifier.fhirType : string;
begin
  result := 'DeviceDefinition.regulatoryIdentifier';
end;

function TFhirDeviceDefinitionRegulatoryIdentifier.Link : TFhirDeviceDefinitionRegulatoryIdentifier;
begin
  result := TFhirDeviceDefinitionRegulatoryIdentifier(inherited Link);
end;

function TFhirDeviceDefinitionRegulatoryIdentifier.Clone : TFhirDeviceDefinitionRegulatoryIdentifier;
begin
  result := TFhirDeviceDefinitionRegulatoryIdentifier(inherited Clone);
end;

function TFhirDeviceDefinitionRegulatoryIdentifier.equals(other : TObject) : boolean; 
var
  o : TFhirDeviceDefinitionRegulatoryIdentifier;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirDeviceDefinitionRegulatoryIdentifier)) then
    result := false
  else
  begin
    o := TFhirDeviceDefinitionRegulatoryIdentifier(other);
    result := compareDeep(type_Element, o.type_Element, true) and compareDeep(deviceIdentifierElement, o.deviceIdentifierElement, true) and 
      compareDeep(issuerElement, o.issuerElement, true) and compareDeep(jurisdictionElement, o.jurisdictionElement, true);
  end;
end;

function TFhirDeviceDefinitionRegulatoryIdentifier.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FType_) and isEmptyProp(FDeviceIdentifier) and isEmptyProp(FIssuer) and isEmptyProp(FJurisdiction);
end;

procedure TFhirDeviceDefinitionRegulatoryIdentifier.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('type');
  fields.add('deviceIdentifier');
  fields.add('issuer');
  fields.add('jurisdiction');
end;

function TFhirDeviceDefinitionRegulatoryIdentifier.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
end;

procedure TFhirDeviceDefinitionRegulatoryIdentifier.SetType_(value : TFhirEnum);
begin
  FType_.free;
  FType_ := value;
end;

function TFhirDeviceDefinitionRegulatoryIdentifier.GetType_ST : TFhirDeviceDefinitionRegulatoryIdentifierTypeEnum;
begin
  if FType_ = nil then
    result := TFhirDeviceDefinitionRegulatoryIdentifierTypeEnum(0)
  else
    result := TFhirDeviceDefinitionRegulatoryIdentifierTypeEnum(StringArrayIndexOfSensitive(CODES_TFhirDeviceDefinitionRegulatoryIdentifierTypeEnum, FType_.value));
end;

procedure TFhirDeviceDefinitionRegulatoryIdentifier.SetType_ST(value : TFhirDeviceDefinitionRegulatoryIdentifierTypeEnum);
begin
  if ord(value) = 0 then
    Type_Element := nil
  else
    Type_Element := TFhirEnum.create(SYSTEMS_TFhirDeviceDefinitionRegulatoryIdentifierTypeEnum[value], CODES_TFhirDeviceDefinitionRegulatoryIdentifierTypeEnum[value]);
end;

procedure TFhirDeviceDefinitionRegulatoryIdentifier.SetDeviceIdentifier(value : TFhirString);
begin
  FDeviceIdentifier.free;
  FDeviceIdentifier := value;
end;

function TFhirDeviceDefinitionRegulatoryIdentifier.GetDeviceIdentifierST : String;
begin
  if FDeviceIdentifier = nil then
    result := ''
  else
    result := FDeviceIdentifier.value;
end;

procedure TFhirDeviceDefinitionRegulatoryIdentifier.SetDeviceIdentifierST(value : String);
begin
  if value <> '' then
  begin
    if FDeviceIdentifier = nil then
      FDeviceIdentifier := TFhirString.create;
    FDeviceIdentifier.value := value
  end
  else if FDeviceIdentifier <> nil then
    FDeviceIdentifier.value := '';
end;

procedure TFhirDeviceDefinitionRegulatoryIdentifier.SetIssuer(value : TFhirUri);
begin
  FIssuer.free;
  FIssuer := value;
end;

function TFhirDeviceDefinitionRegulatoryIdentifier.GetIssuerST : String;
begin
  if FIssuer = nil then
    result := ''
  else
    result := FIssuer.value;
end;

procedure TFhirDeviceDefinitionRegulatoryIdentifier.SetIssuerST(value : String);
begin
  if value <> '' then
  begin
    if FIssuer = nil then
      FIssuer := TFhirUri.create;
    FIssuer.value := value
  end
  else if FIssuer <> nil then
    FIssuer.value := '';
end;

procedure TFhirDeviceDefinitionRegulatoryIdentifier.SetJurisdiction(value : TFhirUri);
begin
  FJurisdiction.free;
  FJurisdiction := value;
end;

function TFhirDeviceDefinitionRegulatoryIdentifier.GetJurisdictionST : String;
begin
  if FJurisdiction = nil then
    result := ''
  else
    result := FJurisdiction.value;
end;

procedure TFhirDeviceDefinitionRegulatoryIdentifier.SetJurisdictionST(value : String);
begin
  if value <> '' then
  begin
    if FJurisdiction = nil then
      FJurisdiction := TFhirUri.create;
    FJurisdiction.value := value
  end
  else if FJurisdiction <> nil then
    FJurisdiction.value := '';
end;

{ TFhirDeviceDefinitionRegulatoryIdentifierListEnumerator }

constructor TFhirDeviceDefinitionRegulatoryIdentifierListEnumerator.Create(list : TFhirDeviceDefinitionRegulatoryIdentifierList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirDeviceDefinitionRegulatoryIdentifierListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirDeviceDefinitionRegulatoryIdentifierListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirDeviceDefinitionRegulatoryIdentifierListEnumerator.GetCurrent : TFhirDeviceDefinitionRegulatoryIdentifier;
begin
  Result := FList[FIndex];
end;

function TFhirDeviceDefinitionRegulatoryIdentifierListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirDeviceDefinitionRegulatoryIdentifierList }

function TFhirDeviceDefinitionRegulatoryIdentifierList.AddItem(value: TFhirDeviceDefinitionRegulatoryIdentifier): TFhirDeviceDefinitionRegulatoryIdentifier;
begin
  assert(value.ClassName = 'TFhirDeviceDefinitionRegulatoryIdentifier', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirDeviceDefinitionRegulatoryIdentifier');
  add(value);
  result := value;
end;

function TFhirDeviceDefinitionRegulatoryIdentifierList.Append: TFhirDeviceDefinitionRegulatoryIdentifier;
begin
  result := TFhirDeviceDefinitionRegulatoryIdentifier.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirDeviceDefinitionRegulatoryIdentifierList.ClearItems;
begin
  Clear;
end;

function TFhirDeviceDefinitionRegulatoryIdentifierList.GetEnumerator : TFhirDeviceDefinitionRegulatoryIdentifierListEnumerator;
begin
  result := TFhirDeviceDefinitionRegulatoryIdentifierListEnumerator.Create(self.link);
end;

function TFhirDeviceDefinitionRegulatoryIdentifierList.Clone: TFhirDeviceDefinitionRegulatoryIdentifierList;
begin
  result := TFhirDeviceDefinitionRegulatoryIdentifierList(inherited Clone);
end;

function TFhirDeviceDefinitionRegulatoryIdentifierList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirDeviceDefinitionRegulatoryIdentifierList.GetItemN(index: Integer): TFhirDeviceDefinitionRegulatoryIdentifier;
begin
  result := TFhirDeviceDefinitionRegulatoryIdentifier(ObjectByIndex[index]);
end;

function TFhirDeviceDefinitionRegulatoryIdentifierList.ItemClass: TFslObjectClass;
begin
  result := TFhirDeviceDefinitionRegulatoryIdentifier;
end;
function TFhirDeviceDefinitionRegulatoryIdentifierList.IndexOf(value: TFhirDeviceDefinitionRegulatoryIdentifier): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirDeviceDefinitionRegulatoryIdentifierList.Insert(index: Integer): TFhirDeviceDefinitionRegulatoryIdentifier;
begin
  result := TFhirDeviceDefinitionRegulatoryIdentifier.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirDeviceDefinitionRegulatoryIdentifierList.InsertItem(index: Integer; value: TFhirDeviceDefinitionRegulatoryIdentifier);
begin
  assert(value is TFhirDeviceDefinitionRegulatoryIdentifier);
  Inherited Insert(index, value);
end;

function TFhirDeviceDefinitionRegulatoryIdentifierList.Item(index: Integer): TFhirDeviceDefinitionRegulatoryIdentifier;
begin
  result := TFhirDeviceDefinitionRegulatoryIdentifier(ObjectByIndex[index]);
end;

function TFhirDeviceDefinitionRegulatoryIdentifierList.Link: TFhirDeviceDefinitionRegulatoryIdentifierList;
begin
  result := TFhirDeviceDefinitionRegulatoryIdentifierList(inherited Link);
end;

procedure TFhirDeviceDefinitionRegulatoryIdentifierList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirDeviceDefinitionRegulatoryIdentifierList.SetItemByIndex(index: Integer; value: TFhirDeviceDefinitionRegulatoryIdentifier);
begin
  assert(value is TFhirDeviceDefinitionRegulatoryIdentifier);
  FhirDeviceDefinitionRegulatoryIdentifiers[index] := value;
end;

procedure TFhirDeviceDefinitionRegulatoryIdentifierList.SetItemN(index: Integer; value: TFhirDeviceDefinitionRegulatoryIdentifier);
begin
  assert(value is TFhirDeviceDefinitionRegulatoryIdentifier);
  ObjectByIndex[index] := value;
end;

{ TFhirDeviceDefinitionDeviceName }

constructor TFhirDeviceDefinitionDeviceName.Create;
begin
  inherited;
end;

destructor TFhirDeviceDefinitionDeviceName.Destroy;
begin
  FName.free;
  FType_.free;
  inherited;
end;

procedure TFhirDeviceDefinitionDeviceName.Assign(oSource : TFslObject);
begin
  inherited;
  nameElement := TFhirDeviceDefinitionDeviceName(oSource).nameElement.Clone;
  type_Element := TFhirDeviceDefinitionDeviceName(oSource).type_Element.Clone;
end;

procedure TFhirDeviceDefinitionDeviceName.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'name') Then
     list.add(self.link, 'name', FName.Link);
  if (child_name = 'type') Then
     list.add(self.link, 'type', FType_.Link);
end;

procedure TFhirDeviceDefinitionDeviceName.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'name', 'string', false, TFhirString, FName.Link));
  oList.add(TFHIRProperty.create(self, 'type', 'code', false, TFhirEnum, FType_.Link));
end;

function TFhirDeviceDefinitionDeviceName.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'name') then
  begin
    NameElement := asString(propValue);
    result := propValue;
  end
  else if (propName = 'type') then
  begin
    Type_Element := asEnum(SYSTEMS_TFhirDeviceNameTypeEnum, CODES_TFhirDeviceNameTypeEnum, propValue);
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirDeviceDefinitionDeviceName.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirDeviceDefinitionDeviceName.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'name') then result := TFhirString.create()
  else if (propName = 'type') then result := TFhirEnum.create(SYSTEMS_TFhirDeviceNameTypeEnum[DeviceNameTypeNull], CODES_TFhirDeviceNameTypeEnum[DeviceNameTypeNull]) 
  else result := inherited createPropertyValue(propName);
end;

function TFhirDeviceDefinitionDeviceName.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'name') then result := 'string'
  else if (propName = 'type') then result := 'code'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirDeviceDefinitionDeviceName.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'name') then NameElement := nil
  else if (propName = 'type') then Type_Element := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirDeviceDefinitionDeviceName.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'name') then NameElement := asString(new)
  else if (propName = 'type') then Type_Element := asEnum(SYSTEMS_TFhirDeviceNameTypeEnum, CODES_TFhirDeviceNameTypeEnum, new)
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirDeviceDefinitionDeviceName.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirDeviceDefinitionDeviceName.fhirType : string;
begin
  result := 'DeviceDefinition.deviceName';
end;

function TFhirDeviceDefinitionDeviceName.Link : TFhirDeviceDefinitionDeviceName;
begin
  result := TFhirDeviceDefinitionDeviceName(inherited Link);
end;

function TFhirDeviceDefinitionDeviceName.Clone : TFhirDeviceDefinitionDeviceName;
begin
  result := TFhirDeviceDefinitionDeviceName(inherited Clone);
end;

function TFhirDeviceDefinitionDeviceName.equals(other : TObject) : boolean; 
var
  o : TFhirDeviceDefinitionDeviceName;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirDeviceDefinitionDeviceName)) then
    result := false
  else
  begin
    o := TFhirDeviceDefinitionDeviceName(other);
    result := compareDeep(nameElement, o.nameElement, true) and compareDeep(type_Element, o.type_Element, true);
  end;
end;

function TFhirDeviceDefinitionDeviceName.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FName) and isEmptyProp(FType_);
end;

procedure TFhirDeviceDefinitionDeviceName.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('name');
  fields.add('type');
end;

function TFhirDeviceDefinitionDeviceName.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
end;

procedure TFhirDeviceDefinitionDeviceName.SetName(value : TFhirString);
begin
  FName.free;
  FName := value;
end;

function TFhirDeviceDefinitionDeviceName.GetNameST : String;
begin
  if FName = nil then
    result := ''
  else
    result := FName.value;
end;

procedure TFhirDeviceDefinitionDeviceName.SetNameST(value : String);
begin
  if value <> '' then
  begin
    if FName = nil then
      FName := TFhirString.create;
    FName.value := value
  end
  else if FName <> nil then
    FName.value := '';
end;

procedure TFhirDeviceDefinitionDeviceName.SetType_(value : TFhirEnum);
begin
  FType_.free;
  FType_ := value;
end;

function TFhirDeviceDefinitionDeviceName.GetType_ST : TFhirDeviceNameTypeEnum;
begin
  if FType_ = nil then
    result := TFhirDeviceNameTypeEnum(0)
  else
    result := TFhirDeviceNameTypeEnum(StringArrayIndexOfSensitive(CODES_TFhirDeviceNameTypeEnum, FType_.value));
end;

procedure TFhirDeviceDefinitionDeviceName.SetType_ST(value : TFhirDeviceNameTypeEnum);
begin
  if ord(value) = 0 then
    Type_Element := nil
  else
    Type_Element := TFhirEnum.create(SYSTEMS_TFhirDeviceNameTypeEnum[value], CODES_TFhirDeviceNameTypeEnum[value]);
end;

{ TFhirDeviceDefinitionDeviceNameListEnumerator }

constructor TFhirDeviceDefinitionDeviceNameListEnumerator.Create(list : TFhirDeviceDefinitionDeviceNameList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirDeviceDefinitionDeviceNameListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirDeviceDefinitionDeviceNameListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirDeviceDefinitionDeviceNameListEnumerator.GetCurrent : TFhirDeviceDefinitionDeviceName;
begin
  Result := FList[FIndex];
end;

function TFhirDeviceDefinitionDeviceNameListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirDeviceDefinitionDeviceNameList }

function TFhirDeviceDefinitionDeviceNameList.AddItem(value: TFhirDeviceDefinitionDeviceName): TFhirDeviceDefinitionDeviceName;
begin
  assert(value.ClassName = 'TFhirDeviceDefinitionDeviceName', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirDeviceDefinitionDeviceName');
  add(value);
  result := value;
end;

function TFhirDeviceDefinitionDeviceNameList.Append: TFhirDeviceDefinitionDeviceName;
begin
  result := TFhirDeviceDefinitionDeviceName.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirDeviceDefinitionDeviceNameList.ClearItems;
begin
  Clear;
end;

function TFhirDeviceDefinitionDeviceNameList.GetEnumerator : TFhirDeviceDefinitionDeviceNameListEnumerator;
begin
  result := TFhirDeviceDefinitionDeviceNameListEnumerator.Create(self.link);
end;

function TFhirDeviceDefinitionDeviceNameList.Clone: TFhirDeviceDefinitionDeviceNameList;
begin
  result := TFhirDeviceDefinitionDeviceNameList(inherited Clone);
end;

function TFhirDeviceDefinitionDeviceNameList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirDeviceDefinitionDeviceNameList.GetItemN(index: Integer): TFhirDeviceDefinitionDeviceName;
begin
  result := TFhirDeviceDefinitionDeviceName(ObjectByIndex[index]);
end;

function TFhirDeviceDefinitionDeviceNameList.ItemClass: TFslObjectClass;
begin
  result := TFhirDeviceDefinitionDeviceName;
end;
function TFhirDeviceDefinitionDeviceNameList.IndexOf(value: TFhirDeviceDefinitionDeviceName): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirDeviceDefinitionDeviceNameList.Insert(index: Integer): TFhirDeviceDefinitionDeviceName;
begin
  result := TFhirDeviceDefinitionDeviceName.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirDeviceDefinitionDeviceNameList.InsertItem(index: Integer; value: TFhirDeviceDefinitionDeviceName);
begin
  assert(value is TFhirDeviceDefinitionDeviceName);
  Inherited Insert(index, value);
end;

function TFhirDeviceDefinitionDeviceNameList.Item(index: Integer): TFhirDeviceDefinitionDeviceName;
begin
  result := TFhirDeviceDefinitionDeviceName(ObjectByIndex[index]);
end;

function TFhirDeviceDefinitionDeviceNameList.Link: TFhirDeviceDefinitionDeviceNameList;
begin
  result := TFhirDeviceDefinitionDeviceNameList(inherited Link);
end;

procedure TFhirDeviceDefinitionDeviceNameList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirDeviceDefinitionDeviceNameList.SetItemByIndex(index: Integer; value: TFhirDeviceDefinitionDeviceName);
begin
  assert(value is TFhirDeviceDefinitionDeviceName);
  FhirDeviceDefinitionDeviceNames[index] := value;
end;

procedure TFhirDeviceDefinitionDeviceNameList.SetItemN(index: Integer; value: TFhirDeviceDefinitionDeviceName);
begin
  assert(value is TFhirDeviceDefinitionDeviceName);
  ObjectByIndex[index] := value;
end;

{ TFhirDeviceDefinitionClassification }

constructor TFhirDeviceDefinitionClassification.Create;
begin
  inherited;
end;

destructor TFhirDeviceDefinitionClassification.Destroy;
begin
  FType_.free;
  FJustificationList.Free;
  inherited;
end;

procedure TFhirDeviceDefinitionClassification.Assign(oSource : TFslObject);
begin
  inherited;
  type_ := TFhirDeviceDefinitionClassification(oSource).type_.Clone;
  if (TFhirDeviceDefinitionClassification(oSource).FJustificationList = nil) then
  begin
    FJustificationList.free;
    FJustificationList := nil;
  end
  else
  begin
    if FJustificationList = nil then
      FJustificationList := TFhirRelatedArtifactList.Create;
    FJustificationList.Assign(TFhirDeviceDefinitionClassification(oSource).FJustificationList);
  end;
end;

procedure TFhirDeviceDefinitionClassification.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'type') Then
     list.add(self.link, 'type', FType_.Link);
  if (child_name = 'justification') Then
    list.addAll(self, 'justification', FJustificationList);
end;

procedure TFhirDeviceDefinitionClassification.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'type', 'CodeableConcept', false, TFhirCodeableConcept, FType_.Link));
  oList.add(TFHIRProperty.create(self, 'justification', 'RelatedArtifact', true, TFhirRelatedArtifact, FJustificationList.Link));
end;

function TFhirDeviceDefinitionClassification.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'type') then
  begin
    Type_ := propValue as TFhirCodeableConcept;
    result := propValue;
  end
  else if (propName = 'justification') then
  begin
    JustificationList.add(propValue as TFhirRelatedArtifact);
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirDeviceDefinitionClassification.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'justification') then JustificationList.insertItem(index, propValue as TFhirRelatedArtifact)
  else inherited;
end;

function TFhirDeviceDefinitionClassification.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'type') then result := TFhirCodeableConcept.create()
  else if (propName = 'justification') then result := JustificationList.new()
  else result := inherited createPropertyValue(propName);
end;

function TFhirDeviceDefinitionClassification.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'type') then result := 'CodeableConcept'
  else if (propName = 'justification') then result := 'RelatedArtifact'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirDeviceDefinitionClassification.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'type') then Type_Element := nil
  else if (propName = 'justification') then deletePropertyValue('justification', JustificationList, value)
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirDeviceDefinitionClassification.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'type') then Type_Element := new as TFhirCodeableConcept
  else if (propName = 'justification') then replacePropertyValue('justification', JustificationList, existing, new)
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirDeviceDefinitionClassification.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'justification') then JustificationList.move(source, destination)
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirDeviceDefinitionClassification.fhirType : string;
begin
  result := 'DeviceDefinition.classification';
end;

function TFhirDeviceDefinitionClassification.Link : TFhirDeviceDefinitionClassification;
begin
  result := TFhirDeviceDefinitionClassification(inherited Link);
end;

function TFhirDeviceDefinitionClassification.Clone : TFhirDeviceDefinitionClassification;
begin
  result := TFhirDeviceDefinitionClassification(inherited Clone);
end;

function TFhirDeviceDefinitionClassification.equals(other : TObject) : boolean; 
var
  o : TFhirDeviceDefinitionClassification;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirDeviceDefinitionClassification)) then
    result := false
  else
  begin
    o := TFhirDeviceDefinitionClassification(other);
    result := compareDeep(type_Element, o.type_Element, true) and compareDeep(justificationList, o.justificationList, true);
  end;
end;

function TFhirDeviceDefinitionClassification.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FType_) and isEmptyProp(FjustificationList);
end;

procedure TFhirDeviceDefinitionClassification.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('type');
  fields.add('justification');
end;

function TFhirDeviceDefinitionClassification.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
  inc(result, FJustificationList.sizeInBytes(magic));
end;

procedure TFhirDeviceDefinitionClassification.SetType_(value : TFhirCodeableConcept);
begin
  FType_.free;
  FType_ := value;
end;

function TFhirDeviceDefinitionClassification.GetJustificationList : TFhirRelatedArtifactList;
begin
  if FJustificationList = nil then
    FJustificationList := TFhirRelatedArtifactList.Create;
  result := FJustificationList;
end;

function TFhirDeviceDefinitionClassification.GetHasJustificationList : boolean;
begin
  result := (FJustificationList <> nil) and (FJustificationList.count > 0);
end;

{ TFhirDeviceDefinitionClassificationListEnumerator }

constructor TFhirDeviceDefinitionClassificationListEnumerator.Create(list : TFhirDeviceDefinitionClassificationList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirDeviceDefinitionClassificationListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirDeviceDefinitionClassificationListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirDeviceDefinitionClassificationListEnumerator.GetCurrent : TFhirDeviceDefinitionClassification;
begin
  Result := FList[FIndex];
end;

function TFhirDeviceDefinitionClassificationListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirDeviceDefinitionClassificationList }

function TFhirDeviceDefinitionClassificationList.AddItem(value: TFhirDeviceDefinitionClassification): TFhirDeviceDefinitionClassification;
begin
  assert(value.ClassName = 'TFhirDeviceDefinitionClassification', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirDeviceDefinitionClassification');
  add(value);
  result := value;
end;

function TFhirDeviceDefinitionClassificationList.Append: TFhirDeviceDefinitionClassification;
begin
  result := TFhirDeviceDefinitionClassification.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirDeviceDefinitionClassificationList.ClearItems;
begin
  Clear;
end;

function TFhirDeviceDefinitionClassificationList.GetEnumerator : TFhirDeviceDefinitionClassificationListEnumerator;
begin
  result := TFhirDeviceDefinitionClassificationListEnumerator.Create(self.link);
end;

function TFhirDeviceDefinitionClassificationList.Clone: TFhirDeviceDefinitionClassificationList;
begin
  result := TFhirDeviceDefinitionClassificationList(inherited Clone);
end;

function TFhirDeviceDefinitionClassificationList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirDeviceDefinitionClassificationList.GetItemN(index: Integer): TFhirDeviceDefinitionClassification;
begin
  result := TFhirDeviceDefinitionClassification(ObjectByIndex[index]);
end;

function TFhirDeviceDefinitionClassificationList.ItemClass: TFslObjectClass;
begin
  result := TFhirDeviceDefinitionClassification;
end;
function TFhirDeviceDefinitionClassificationList.IndexOf(value: TFhirDeviceDefinitionClassification): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirDeviceDefinitionClassificationList.Insert(index: Integer): TFhirDeviceDefinitionClassification;
begin
  result := TFhirDeviceDefinitionClassification.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirDeviceDefinitionClassificationList.InsertItem(index: Integer; value: TFhirDeviceDefinitionClassification);
begin
  assert(value is TFhirDeviceDefinitionClassification);
  Inherited Insert(index, value);
end;

function TFhirDeviceDefinitionClassificationList.Item(index: Integer): TFhirDeviceDefinitionClassification;
begin
  result := TFhirDeviceDefinitionClassification(ObjectByIndex[index]);
end;

function TFhirDeviceDefinitionClassificationList.Link: TFhirDeviceDefinitionClassificationList;
begin
  result := TFhirDeviceDefinitionClassificationList(inherited Link);
end;

procedure TFhirDeviceDefinitionClassificationList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirDeviceDefinitionClassificationList.SetItemByIndex(index: Integer; value: TFhirDeviceDefinitionClassification);
begin
  assert(value is TFhirDeviceDefinitionClassification);
  FhirDeviceDefinitionClassifications[index] := value;
end;

procedure TFhirDeviceDefinitionClassificationList.SetItemN(index: Integer; value: TFhirDeviceDefinitionClassification);
begin
  assert(value is TFhirDeviceDefinitionClassification);
  ObjectByIndex[index] := value;
end;

{ TFhirDeviceDefinitionHasPart }

constructor TFhirDeviceDefinitionHasPart.Create;
begin
  inherited;
end;

destructor TFhirDeviceDefinitionHasPart.Destroy;
begin
  FReference.free;
  FCount.free;
  inherited;
end;

procedure TFhirDeviceDefinitionHasPart.Assign(oSource : TFslObject);
begin
  inherited;
  reference := TFhirDeviceDefinitionHasPart(oSource).reference.Clone;
  countElement := TFhirDeviceDefinitionHasPart(oSource).countElement.Clone;
end;

procedure TFhirDeviceDefinitionHasPart.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'reference') Then
     list.add(self.link, 'reference', FReference.Link);
  if (child_name = 'count') Then
     list.add(self.link, 'count', FCount.Link);
end;

procedure TFhirDeviceDefinitionHasPart.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'reference', 'Reference', false, TFhirReference, FReference.Link));
  oList.add(TFHIRProperty.create(self, 'count', 'integer', false, TFhirInteger, FCount.Link));
end;

function TFhirDeviceDefinitionHasPart.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'reference') then
  begin
    Reference := propValue as TFhirReference;
    result := propValue;
  end
  else if (propName = 'count') then
  begin
    CountElement := asInteger(propValue);
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirDeviceDefinitionHasPart.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirDeviceDefinitionHasPart.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'reference') then result := TFhirReference.create()
  else if (propName = 'count') then result := TFhirInteger.create()
  else result := inherited createPropertyValue(propName);
end;

function TFhirDeviceDefinitionHasPart.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'reference') then result := 'Reference'
  else if (propName = 'count') then result := 'integer'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirDeviceDefinitionHasPart.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'reference') then ReferenceElement := nil
  else if (propName = 'count') then CountElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirDeviceDefinitionHasPart.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'reference') then ReferenceElement := new as TFhirReference
  else if (propName = 'count') then CountElement := asInteger(new)
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirDeviceDefinitionHasPart.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirDeviceDefinitionHasPart.fhirType : string;
begin
  result := 'DeviceDefinition.hasPart';
end;

function TFhirDeviceDefinitionHasPart.Link : TFhirDeviceDefinitionHasPart;
begin
  result := TFhirDeviceDefinitionHasPart(inherited Link);
end;

function TFhirDeviceDefinitionHasPart.Clone : TFhirDeviceDefinitionHasPart;
begin
  result := TFhirDeviceDefinitionHasPart(inherited Clone);
end;

function TFhirDeviceDefinitionHasPart.equals(other : TObject) : boolean; 
var
  o : TFhirDeviceDefinitionHasPart;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirDeviceDefinitionHasPart)) then
    result := false
  else
  begin
    o := TFhirDeviceDefinitionHasPart(other);
    result := compareDeep(referenceElement, o.referenceElement, true) and compareDeep(countElement, o.countElement, true);
  end;
end;

function TFhirDeviceDefinitionHasPart.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FReference) and isEmptyProp(FCount);
end;

procedure TFhirDeviceDefinitionHasPart.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('reference');
  fields.add('count');
end;

function TFhirDeviceDefinitionHasPart.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
end;

procedure TFhirDeviceDefinitionHasPart.SetReference(value : TFhirReference);
begin
  FReference.free;
  FReference := value;
end;

procedure TFhirDeviceDefinitionHasPart.SetCount(value : TFhirInteger);
begin
  FCount.free;
  FCount := value;
end;

function TFhirDeviceDefinitionHasPart.GetCountST : String;
begin
  if FCount = nil then
    result := ''
  else
    result := FCount.value;
end;

procedure TFhirDeviceDefinitionHasPart.SetCountST(value : String);
begin
  if value <> '' then
  begin
    if FCount = nil then
      FCount := TFhirInteger.create;
    FCount.value := value
  end
  else if FCount <> nil then
    FCount.value := '';
end;

{ TFhirDeviceDefinitionHasPartListEnumerator }

constructor TFhirDeviceDefinitionHasPartListEnumerator.Create(list : TFhirDeviceDefinitionHasPartList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirDeviceDefinitionHasPartListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirDeviceDefinitionHasPartListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirDeviceDefinitionHasPartListEnumerator.GetCurrent : TFhirDeviceDefinitionHasPart;
begin
  Result := FList[FIndex];
end;

function TFhirDeviceDefinitionHasPartListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirDeviceDefinitionHasPartList }

function TFhirDeviceDefinitionHasPartList.AddItem(value: TFhirDeviceDefinitionHasPart): TFhirDeviceDefinitionHasPart;
begin
  assert(value.ClassName = 'TFhirDeviceDefinitionHasPart', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirDeviceDefinitionHasPart');
  add(value);
  result := value;
end;

function TFhirDeviceDefinitionHasPartList.Append: TFhirDeviceDefinitionHasPart;
begin
  result := TFhirDeviceDefinitionHasPart.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirDeviceDefinitionHasPartList.ClearItems;
begin
  Clear;
end;

function TFhirDeviceDefinitionHasPartList.GetEnumerator : TFhirDeviceDefinitionHasPartListEnumerator;
begin
  result := TFhirDeviceDefinitionHasPartListEnumerator.Create(self.link);
end;

function TFhirDeviceDefinitionHasPartList.Clone: TFhirDeviceDefinitionHasPartList;
begin
  result := TFhirDeviceDefinitionHasPartList(inherited Clone);
end;

function TFhirDeviceDefinitionHasPartList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirDeviceDefinitionHasPartList.GetItemN(index: Integer): TFhirDeviceDefinitionHasPart;
begin
  result := TFhirDeviceDefinitionHasPart(ObjectByIndex[index]);
end;

function TFhirDeviceDefinitionHasPartList.ItemClass: TFslObjectClass;
begin
  result := TFhirDeviceDefinitionHasPart;
end;
function TFhirDeviceDefinitionHasPartList.IndexOf(value: TFhirDeviceDefinitionHasPart): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirDeviceDefinitionHasPartList.Insert(index: Integer): TFhirDeviceDefinitionHasPart;
begin
  result := TFhirDeviceDefinitionHasPart.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirDeviceDefinitionHasPartList.InsertItem(index: Integer; value: TFhirDeviceDefinitionHasPart);
begin
  assert(value is TFhirDeviceDefinitionHasPart);
  Inherited Insert(index, value);
end;

function TFhirDeviceDefinitionHasPartList.Item(index: Integer): TFhirDeviceDefinitionHasPart;
begin
  result := TFhirDeviceDefinitionHasPart(ObjectByIndex[index]);
end;

function TFhirDeviceDefinitionHasPartList.Link: TFhirDeviceDefinitionHasPartList;
begin
  result := TFhirDeviceDefinitionHasPartList(inherited Link);
end;

procedure TFhirDeviceDefinitionHasPartList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirDeviceDefinitionHasPartList.SetItemByIndex(index: Integer; value: TFhirDeviceDefinitionHasPart);
begin
  assert(value is TFhirDeviceDefinitionHasPart);
  FhirDeviceDefinitionHasParts[index] := value;
end;

procedure TFhirDeviceDefinitionHasPartList.SetItemN(index: Integer; value: TFhirDeviceDefinitionHasPart);
begin
  assert(value is TFhirDeviceDefinitionHasPart);
  ObjectByIndex[index] := value;
end;

{ TFhirDeviceDefinitionPackaging }

constructor TFhirDeviceDefinitionPackaging.Create;
begin
  inherited;
end;

destructor TFhirDeviceDefinitionPackaging.Destroy;
begin
  FIdentifier.free;
  FType_.free;
  FCount.free;
  FDistributorList.Free;
  FUdiDeviceIdentifierList.Free;
  FPackagingList.Free;
  inherited;
end;

procedure TFhirDeviceDefinitionPackaging.Assign(oSource : TFslObject);
begin
  inherited;
  identifier := TFhirDeviceDefinitionPackaging(oSource).identifier.Clone;
  type_ := TFhirDeviceDefinitionPackaging(oSource).type_.Clone;
  countElement := TFhirDeviceDefinitionPackaging(oSource).countElement.Clone;
  if (TFhirDeviceDefinitionPackaging(oSource).FDistributorList = nil) then
  begin
    FDistributorList.free;
    FDistributorList := nil;
  end
  else
  begin
    if FDistributorList = nil then
      FDistributorList := TFhirDeviceDefinitionPackagingDistributorList.Create;
    FDistributorList.Assign(TFhirDeviceDefinitionPackaging(oSource).FDistributorList);
  end;
  if (TFhirDeviceDefinitionPackaging(oSource).FUdiDeviceIdentifierList = nil) then
  begin
    FUdiDeviceIdentifierList.free;
    FUdiDeviceIdentifierList := nil;
  end
  else
  begin
    if FUdiDeviceIdentifierList = nil then
      FUdiDeviceIdentifierList := TFhirDeviceDefinitionUdiDeviceIdentifierList.Create;
    FUdiDeviceIdentifierList.Assign(TFhirDeviceDefinitionPackaging(oSource).FUdiDeviceIdentifierList);
  end;
  if (TFhirDeviceDefinitionPackaging(oSource).FPackagingList = nil) then
  begin
    FPackagingList.free;
    FPackagingList := nil;
  end
  else
  begin
    if FPackagingList = nil then
      FPackagingList := TFhirDeviceDefinitionPackagingList.Create;
    FPackagingList.Assign(TFhirDeviceDefinitionPackaging(oSource).FPackagingList);
  end;
end;

procedure TFhirDeviceDefinitionPackaging.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'identifier') Then
     list.add(self.link, 'identifier', FIdentifier.Link);
  if (child_name = 'type') Then
     list.add(self.link, 'type', FType_.Link);
  if (child_name = 'count') Then
     list.add(self.link, 'count', FCount.Link);
  if (child_name = 'distributor') Then
    list.addAll(self, 'distributor', FDistributorList);
  if (child_name = 'udiDeviceIdentifier') Then
    list.addAll(self, 'udiDeviceIdentifier', FUdiDeviceIdentifierList);
  if (child_name = 'packaging') Then
    list.addAll(self, 'packaging', FPackagingList);
end;

procedure TFhirDeviceDefinitionPackaging.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'identifier', 'Identifier', false, TFhirIdentifier, FIdentifier.Link));
  oList.add(TFHIRProperty.create(self, 'type', 'CodeableConcept', false, TFhirCodeableConcept, FType_.Link));
  oList.add(TFHIRProperty.create(self, 'count', 'integer', false, TFhirInteger, FCount.Link));
  oList.add(TFHIRProperty.create(self, 'distributor', 'BackboneElement', true, TFhirDeviceDefinitionPackagingDistributor, FDistributorList.Link));
  oList.add(TFHIRProperty.create(self, 'udiDeviceIdentifier', '', true, TFhirDeviceDefinitionUdiDeviceIdentifier, FUdiDeviceIdentifierList.Link));
  oList.add(TFHIRProperty.create(self, 'packaging', '', true, TFhirDeviceDefinitionPackaging, FPackagingList.Link));
end;

function TFhirDeviceDefinitionPackaging.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'identifier') then
  begin
    Identifier := propValue as TFhirIdentifier;
    result := propValue;
  end
  else if (propName = 'type') then
  begin
    Type_ := propValue as TFhirCodeableConcept;
    result := propValue;
  end
  else if (propName = 'count') then
  begin
    CountElement := asInteger(propValue);
    result := propValue;
  end
  else if (propName = 'distributor') then
  begin
    DistributorList.add(propValue as TFhirDeviceDefinitionPackagingDistributor);
    result := propValue;
  end
  else if (propName = 'udiDeviceIdentifier') then
  begin
    UdiDeviceIdentifierList.add(propValue as TFhirDeviceDefinitionUdiDeviceIdentifier);
    result := propValue;
  end
  else if (propName = 'packaging') then
  begin
    PackagingList.add(propValue as TFhirDeviceDefinitionPackaging);
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirDeviceDefinitionPackaging.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'distributor') then DistributorList.insertItem(index, propValue as TFhirDeviceDefinitionPackagingDistributor)
  else if (propName = 'udiDeviceIdentifier') then UdiDeviceIdentifierList.insertItem(index, propValue as TFhirDeviceDefinitionUdiDeviceIdentifier)
  else if (propName = 'packaging') then PackagingList.insertItem(index, propValue as TFhirDeviceDefinitionPackaging)
  else inherited;
end;

function TFhirDeviceDefinitionPackaging.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'identifier') then result := TFhirIdentifier.create()
  else if (propName = 'type') then result := TFhirCodeableConcept.create()
  else if (propName = 'count') then result := TFhirInteger.create()
  else if (propName = 'distributor') then result := DistributorList.new()
  else if (propName = 'udiDeviceIdentifier') then result := UdiDeviceIdentifierList.new()
  else if (propName = 'packaging') then result := PackagingList.new()
  else result := inherited createPropertyValue(propName);
end;

function TFhirDeviceDefinitionPackaging.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'identifier') then result := 'Identifier'
  else if (propName = 'type') then result := 'CodeableConcept'
  else if (propName = 'count') then result := 'integer'
  else if (propName = 'distributor') then result := 'BackboneElement'
  else if (propName = 'udiDeviceIdentifier') then result := ''
  else if (propName = 'packaging') then result := ''
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirDeviceDefinitionPackaging.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'identifier') then IdentifierElement := nil
  else if (propName = 'type') then Type_Element := nil
  else if (propName = 'count') then CountElement := nil
  else if (propName = 'distributor') then deletePropertyValue('distributor', DistributorList, value)
  else if (propName = 'udiDeviceIdentifier') then deletePropertyValue('udiDeviceIdentifier', UdiDeviceIdentifierList, value)
  else if (propName = 'packaging') then deletePropertyValue('packaging', PackagingList, value)
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirDeviceDefinitionPackaging.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'identifier') then IdentifierElement := new as TFhirIdentifier
  else if (propName = 'type') then Type_Element := new as TFhirCodeableConcept
  else if (propName = 'count') then CountElement := asInteger(new)
  else if (propName = 'distributor') then replacePropertyValue('distributor', DistributorList, existing, new)
  else if (propName = 'udiDeviceIdentifier') then replacePropertyValue('udiDeviceIdentifier', UdiDeviceIdentifierList, existing, new)
  else if (propName = 'packaging') then replacePropertyValue('packaging', PackagingList, existing, new)
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirDeviceDefinitionPackaging.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'distributor') then DistributorList.move(source, destination)
  else if (propName = 'udiDeviceIdentifier') then UdiDeviceIdentifierList.move(source, destination)
  else if (propName = 'packaging') then PackagingList.move(source, destination)
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirDeviceDefinitionPackaging.fhirType : string;
begin
  result := 'DeviceDefinition.packaging';
end;

function TFhirDeviceDefinitionPackaging.Link : TFhirDeviceDefinitionPackaging;
begin
  result := TFhirDeviceDefinitionPackaging(inherited Link);
end;

function TFhirDeviceDefinitionPackaging.Clone : TFhirDeviceDefinitionPackaging;
begin
  result := TFhirDeviceDefinitionPackaging(inherited Clone);
end;

function TFhirDeviceDefinitionPackaging.equals(other : TObject) : boolean; 
var
  o : TFhirDeviceDefinitionPackaging;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirDeviceDefinitionPackaging)) then
    result := false
  else
  begin
    o := TFhirDeviceDefinitionPackaging(other);
    result := compareDeep(identifierElement, o.identifierElement, true) and compareDeep(type_Element, o.type_Element, true) and 
      compareDeep(countElement, o.countElement, true) and compareDeep(distributorList, o.distributorList, true) and 
      compareDeep(udiDeviceIdentifierList, o.udiDeviceIdentifierList, true) and compareDeep(packagingList, o.packagingList, true);
  end;
end;

function TFhirDeviceDefinitionPackaging.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FIdentifier) and isEmptyProp(FType_) and isEmptyProp(FCount) and isEmptyProp(FdistributorList) and isEmptyProp(FudiDeviceIdentifierList) and isEmptyProp(FpackagingList);
end;

procedure TFhirDeviceDefinitionPackaging.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('identifier');
  fields.add('type');
  fields.add('count');
  fields.add('distributor');
  fields.add('udiDeviceIdentifier');
  fields.add('packaging');
end;

function TFhirDeviceDefinitionPackaging.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
  inc(result, FDistributorList.sizeInBytes(magic));
  inc(result, FUdiDeviceIdentifierList.sizeInBytes(magic));
  inc(result, FPackagingList.sizeInBytes(magic));
end;

procedure TFhirDeviceDefinitionPackaging.SetIdentifier(value : TFhirIdentifier);
begin
  FIdentifier.free;
  FIdentifier := value;
end;

procedure TFhirDeviceDefinitionPackaging.SetType_(value : TFhirCodeableConcept);
begin
  FType_.free;
  FType_ := value;
end;

procedure TFhirDeviceDefinitionPackaging.SetCount(value : TFhirInteger);
begin
  FCount.free;
  FCount := value;
end;

function TFhirDeviceDefinitionPackaging.GetCountST : String;
begin
  if FCount = nil then
    result := ''
  else
    result := FCount.value;
end;

procedure TFhirDeviceDefinitionPackaging.SetCountST(value : String);
begin
  if value <> '' then
  begin
    if FCount = nil then
      FCount := TFhirInteger.create;
    FCount.value := value
  end
  else if FCount <> nil then
    FCount.value := '';
end;

function TFhirDeviceDefinitionPackaging.GetDistributorList : TFhirDeviceDefinitionPackagingDistributorList;
begin
  if FDistributorList = nil then
    FDistributorList := TFhirDeviceDefinitionPackagingDistributorList.Create;
  result := FDistributorList;
end;

function TFhirDeviceDefinitionPackaging.GetHasDistributorList : boolean;
begin
  result := (FDistributorList <> nil) and (FDistributorList.count > 0);
end;

function TFhirDeviceDefinitionPackaging.GetUdiDeviceIdentifierList : TFhirDeviceDefinitionUdiDeviceIdentifierList;
begin
  if FUdiDeviceIdentifierList = nil then
    FUdiDeviceIdentifierList := TFhirDeviceDefinitionUdiDeviceIdentifierList.Create;
  result := FUdiDeviceIdentifierList;
end;

function TFhirDeviceDefinitionPackaging.GetHasUdiDeviceIdentifierList : boolean;
begin
  result := (FUdiDeviceIdentifierList <> nil) and (FUdiDeviceIdentifierList.count > 0);
end;

function TFhirDeviceDefinitionPackaging.GetPackagingList : TFhirDeviceDefinitionPackagingList;
begin
  if FPackagingList = nil then
    FPackagingList := TFhirDeviceDefinitionPackagingList.Create;
  result := FPackagingList;
end;

function TFhirDeviceDefinitionPackaging.GetHasPackagingList : boolean;
begin
  result := (FPackagingList <> nil) and (FPackagingList.count > 0);
end;

{ TFhirDeviceDefinitionPackagingListEnumerator }

constructor TFhirDeviceDefinitionPackagingListEnumerator.Create(list : TFhirDeviceDefinitionPackagingList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirDeviceDefinitionPackagingListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirDeviceDefinitionPackagingListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirDeviceDefinitionPackagingListEnumerator.GetCurrent : TFhirDeviceDefinitionPackaging;
begin
  Result := FList[FIndex];
end;

function TFhirDeviceDefinitionPackagingListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirDeviceDefinitionPackagingList }

function TFhirDeviceDefinitionPackagingList.AddItem(value: TFhirDeviceDefinitionPackaging): TFhirDeviceDefinitionPackaging;
begin
  assert(value.ClassName = 'TFhirDeviceDefinitionPackaging', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirDeviceDefinitionPackaging');
  add(value);
  result := value;
end;

function TFhirDeviceDefinitionPackagingList.Append: TFhirDeviceDefinitionPackaging;
begin
  result := TFhirDeviceDefinitionPackaging.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirDeviceDefinitionPackagingList.ClearItems;
begin
  Clear;
end;

function TFhirDeviceDefinitionPackagingList.GetEnumerator : TFhirDeviceDefinitionPackagingListEnumerator;
begin
  result := TFhirDeviceDefinitionPackagingListEnumerator.Create(self.link);
end;

function TFhirDeviceDefinitionPackagingList.Clone: TFhirDeviceDefinitionPackagingList;
begin
  result := TFhirDeviceDefinitionPackagingList(inherited Clone);
end;

function TFhirDeviceDefinitionPackagingList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirDeviceDefinitionPackagingList.GetItemN(index: Integer): TFhirDeviceDefinitionPackaging;
begin
  result := TFhirDeviceDefinitionPackaging(ObjectByIndex[index]);
end;

function TFhirDeviceDefinitionPackagingList.ItemClass: TFslObjectClass;
begin
  result := TFhirDeviceDefinitionPackaging;
end;
function TFhirDeviceDefinitionPackagingList.IndexOf(value: TFhirDeviceDefinitionPackaging): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirDeviceDefinitionPackagingList.Insert(index: Integer): TFhirDeviceDefinitionPackaging;
begin
  result := TFhirDeviceDefinitionPackaging.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirDeviceDefinitionPackagingList.InsertItem(index: Integer; value: TFhirDeviceDefinitionPackaging);
begin
  assert(value is TFhirDeviceDefinitionPackaging);
  Inherited Insert(index, value);
end;

function TFhirDeviceDefinitionPackagingList.Item(index: Integer): TFhirDeviceDefinitionPackaging;
begin
  result := TFhirDeviceDefinitionPackaging(ObjectByIndex[index]);
end;

function TFhirDeviceDefinitionPackagingList.Link: TFhirDeviceDefinitionPackagingList;
begin
  result := TFhirDeviceDefinitionPackagingList(inherited Link);
end;

procedure TFhirDeviceDefinitionPackagingList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirDeviceDefinitionPackagingList.SetItemByIndex(index: Integer; value: TFhirDeviceDefinitionPackaging);
begin
  assert(value is TFhirDeviceDefinitionPackaging);
  FhirDeviceDefinitionPackagings[index] := value;
end;

procedure TFhirDeviceDefinitionPackagingList.SetItemN(index: Integer; value: TFhirDeviceDefinitionPackaging);
begin
  assert(value is TFhirDeviceDefinitionPackaging);
  ObjectByIndex[index] := value;
end;

{ TFhirDeviceDefinitionPackagingDistributor }

constructor TFhirDeviceDefinitionPackagingDistributor.Create;
begin
  inherited;
end;

destructor TFhirDeviceDefinitionPackagingDistributor.Destroy;
begin
  FName.free;
  FOrganizationReferenceList.Free;
  inherited;
end;

procedure TFhirDeviceDefinitionPackagingDistributor.Assign(oSource : TFslObject);
begin
  inherited;
  nameElement := TFhirDeviceDefinitionPackagingDistributor(oSource).nameElement.Clone;
  if (TFhirDeviceDefinitionPackagingDistributor(oSource).FOrganizationReferenceList = nil) then
  begin
    FOrganizationReferenceList.free;
    FOrganizationReferenceList := nil;
  end
  else
  begin
    if FOrganizationReferenceList = nil then
      FOrganizationReferenceList := TFhirReferenceList.Create;
    FOrganizationReferenceList.Assign(TFhirDeviceDefinitionPackagingDistributor(oSource).FOrganizationReferenceList);
  end;
end;

procedure TFhirDeviceDefinitionPackagingDistributor.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'name') Then
     list.add(self.link, 'name', FName.Link);
  if (child_name = 'organizationReference') Then
    list.addAll(self, 'organizationReference', FOrganizationReferenceList);
end;

procedure TFhirDeviceDefinitionPackagingDistributor.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'name', 'string', false, TFhirString, FName.Link));
  oList.add(TFHIRProperty.create(self, 'organizationReference', 'Reference', true, TFhirReference, FOrganizationReferenceList.Link));
end;

function TFhirDeviceDefinitionPackagingDistributor.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'name') then
  begin
    NameElement := asString(propValue);
    result := propValue;
  end
  else if (propName = 'organizationReference') then
  begin
    OrganizationReferenceList.add(propValue as TFhirReference);
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirDeviceDefinitionPackagingDistributor.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'organizationReference') then OrganizationReferenceList.insertItem(index, propValue as TFhirReference)
  else inherited;
end;

function TFhirDeviceDefinitionPackagingDistributor.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'name') then result := TFhirString.create()
  else if (propName = 'organizationReference') then result := OrganizationReferenceList.new()
  else result := inherited createPropertyValue(propName);
end;

function TFhirDeviceDefinitionPackagingDistributor.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'name') then result := 'string'
  else if (propName = 'organizationReference') then result := 'Reference'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirDeviceDefinitionPackagingDistributor.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'name') then NameElement := nil
  else if (propName = 'organizationReference') then deletePropertyValue('organizationReference', OrganizationReferenceList, value)
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirDeviceDefinitionPackagingDistributor.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'name') then NameElement := asString(new)
  else if (propName = 'organizationReference') then replacePropertyValue('organizationReference', OrganizationReferenceList, existing, new)
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirDeviceDefinitionPackagingDistributor.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'organizationReference') then OrganizationReferenceList.move(source, destination)
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirDeviceDefinitionPackagingDistributor.fhirType : string;
begin
  result := 'DeviceDefinition.packaging.distributor';
end;

function TFhirDeviceDefinitionPackagingDistributor.Link : TFhirDeviceDefinitionPackagingDistributor;
begin
  result := TFhirDeviceDefinitionPackagingDistributor(inherited Link);
end;

function TFhirDeviceDefinitionPackagingDistributor.Clone : TFhirDeviceDefinitionPackagingDistributor;
begin
  result := TFhirDeviceDefinitionPackagingDistributor(inherited Clone);
end;

function TFhirDeviceDefinitionPackagingDistributor.equals(other : TObject) : boolean; 
var
  o : TFhirDeviceDefinitionPackagingDistributor;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirDeviceDefinitionPackagingDistributor)) then
    result := false
  else
  begin
    o := TFhirDeviceDefinitionPackagingDistributor(other);
    result := compareDeep(nameElement, o.nameElement, true) and compareDeep(organizationReferenceList, o.organizationReferenceList, true);
  end;
end;

function TFhirDeviceDefinitionPackagingDistributor.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FName) and isEmptyProp(ForganizationReferenceList);
end;

procedure TFhirDeviceDefinitionPackagingDistributor.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('name');
  fields.add('organizationReference');
end;

function TFhirDeviceDefinitionPackagingDistributor.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
  inc(result, FOrganizationReferenceList.sizeInBytes(magic));
end;

procedure TFhirDeviceDefinitionPackagingDistributor.SetName(value : TFhirString);
begin
  FName.free;
  FName := value;
end;

function TFhirDeviceDefinitionPackagingDistributor.GetNameST : String;
begin
  if FName = nil then
    result := ''
  else
    result := FName.value;
end;

procedure TFhirDeviceDefinitionPackagingDistributor.SetNameST(value : String);
begin
  if value <> '' then
  begin
    if FName = nil then
      FName := TFhirString.create;
    FName.value := value
  end
  else if FName <> nil then
    FName.value := '';
end;

function TFhirDeviceDefinitionPackagingDistributor.GetOrganizationReferenceList : TFhirReferenceList;
begin
  if FOrganizationReferenceList = nil then
    FOrganizationReferenceList := TFhirReferenceList.Create;
  result := FOrganizationReferenceList;
end;

function TFhirDeviceDefinitionPackagingDistributor.GetHasOrganizationReferenceList : boolean;
begin
  result := (FOrganizationReferenceList <> nil) and (FOrganizationReferenceList.count > 0);
end;

{ TFhirDeviceDefinitionPackagingDistributorListEnumerator }

constructor TFhirDeviceDefinitionPackagingDistributorListEnumerator.Create(list : TFhirDeviceDefinitionPackagingDistributorList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirDeviceDefinitionPackagingDistributorListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirDeviceDefinitionPackagingDistributorListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirDeviceDefinitionPackagingDistributorListEnumerator.GetCurrent : TFhirDeviceDefinitionPackagingDistributor;
begin
  Result := FList[FIndex];
end;

function TFhirDeviceDefinitionPackagingDistributorListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirDeviceDefinitionPackagingDistributorList }

function TFhirDeviceDefinitionPackagingDistributorList.AddItem(value: TFhirDeviceDefinitionPackagingDistributor): TFhirDeviceDefinitionPackagingDistributor;
begin
  assert(value.ClassName = 'TFhirDeviceDefinitionPackagingDistributor', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirDeviceDefinitionPackagingDistributor');
  add(value);
  result := value;
end;

function TFhirDeviceDefinitionPackagingDistributorList.Append: TFhirDeviceDefinitionPackagingDistributor;
begin
  result := TFhirDeviceDefinitionPackagingDistributor.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirDeviceDefinitionPackagingDistributorList.ClearItems;
begin
  Clear;
end;

function TFhirDeviceDefinitionPackagingDistributorList.GetEnumerator : TFhirDeviceDefinitionPackagingDistributorListEnumerator;
begin
  result := TFhirDeviceDefinitionPackagingDistributorListEnumerator.Create(self.link);
end;

function TFhirDeviceDefinitionPackagingDistributorList.Clone: TFhirDeviceDefinitionPackagingDistributorList;
begin
  result := TFhirDeviceDefinitionPackagingDistributorList(inherited Clone);
end;

function TFhirDeviceDefinitionPackagingDistributorList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirDeviceDefinitionPackagingDistributorList.GetItemN(index: Integer): TFhirDeviceDefinitionPackagingDistributor;
begin
  result := TFhirDeviceDefinitionPackagingDistributor(ObjectByIndex[index]);
end;

function TFhirDeviceDefinitionPackagingDistributorList.ItemClass: TFslObjectClass;
begin
  result := TFhirDeviceDefinitionPackagingDistributor;
end;
function TFhirDeviceDefinitionPackagingDistributorList.IndexOf(value: TFhirDeviceDefinitionPackagingDistributor): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirDeviceDefinitionPackagingDistributorList.Insert(index: Integer): TFhirDeviceDefinitionPackagingDistributor;
begin
  result := TFhirDeviceDefinitionPackagingDistributor.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirDeviceDefinitionPackagingDistributorList.InsertItem(index: Integer; value: TFhirDeviceDefinitionPackagingDistributor);
begin
  assert(value is TFhirDeviceDefinitionPackagingDistributor);
  Inherited Insert(index, value);
end;

function TFhirDeviceDefinitionPackagingDistributorList.Item(index: Integer): TFhirDeviceDefinitionPackagingDistributor;
begin
  result := TFhirDeviceDefinitionPackagingDistributor(ObjectByIndex[index]);
end;

function TFhirDeviceDefinitionPackagingDistributorList.Link: TFhirDeviceDefinitionPackagingDistributorList;
begin
  result := TFhirDeviceDefinitionPackagingDistributorList(inherited Link);
end;

procedure TFhirDeviceDefinitionPackagingDistributorList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirDeviceDefinitionPackagingDistributorList.SetItemByIndex(index: Integer; value: TFhirDeviceDefinitionPackagingDistributor);
begin
  assert(value is TFhirDeviceDefinitionPackagingDistributor);
  FhirDeviceDefinitionPackagingDistributors[index] := value;
end;

procedure TFhirDeviceDefinitionPackagingDistributorList.SetItemN(index: Integer; value: TFhirDeviceDefinitionPackagingDistributor);
begin
  assert(value is TFhirDeviceDefinitionPackagingDistributor);
  ObjectByIndex[index] := value;
end;

{ TFhirDeviceDefinitionVersion }

constructor TFhirDeviceDefinitionVersion.Create;
begin
  inherited;
end;

destructor TFhirDeviceDefinitionVersion.Destroy;
begin
  FType_.free;
  FComponent.free;
  FValue.free;
  inherited;
end;

procedure TFhirDeviceDefinitionVersion.Assign(oSource : TFslObject);
begin
  inherited;
  type_ := TFhirDeviceDefinitionVersion(oSource).type_.Clone;
  component := TFhirDeviceDefinitionVersion(oSource).component.Clone;
  valueElement := TFhirDeviceDefinitionVersion(oSource).valueElement.Clone;
end;

procedure TFhirDeviceDefinitionVersion.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'type') Then
     list.add(self.link, 'type', FType_.Link);
  if (child_name = 'component') Then
     list.add(self.link, 'component', FComponent.Link);
  if (child_name = 'value') Then
     list.add(self.link, 'value', FValue.Link);
end;

procedure TFhirDeviceDefinitionVersion.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'type', 'CodeableConcept', false, TFhirCodeableConcept, FType_.Link));
  oList.add(TFHIRProperty.create(self, 'component', 'Identifier', false, TFhirIdentifier, FComponent.Link));
  oList.add(TFHIRProperty.create(self, 'value', 'string', false, TFhirString, FValue.Link));
end;

function TFhirDeviceDefinitionVersion.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'type') then
  begin
    Type_ := propValue as TFhirCodeableConcept;
    result := propValue;
  end
  else if (propName = 'component') then
  begin
    Component := propValue as TFhirIdentifier;
    result := propValue;
  end
  else if (propName = 'value') then
  begin
    ValueElement := asString(propValue);
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirDeviceDefinitionVersion.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirDeviceDefinitionVersion.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'type') then result := TFhirCodeableConcept.create()
  else if (propName = 'component') then result := TFhirIdentifier.create()
  else if (propName = 'value') then result := TFhirString.create()
  else result := inherited createPropertyValue(propName);
end;

function TFhirDeviceDefinitionVersion.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'type') then result := 'CodeableConcept'
  else if (propName = 'component') then result := 'Identifier'
  else if (propName = 'value') then result := 'string'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirDeviceDefinitionVersion.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'type') then Type_Element := nil
  else if (propName = 'component') then ComponentElement := nil
  else if (propName = 'value') then ValueElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirDeviceDefinitionVersion.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'type') then Type_Element := new as TFhirCodeableConcept
  else if (propName = 'component') then ComponentElement := new as TFhirIdentifier
  else if (propName = 'value') then ValueElement := asString(new)
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirDeviceDefinitionVersion.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirDeviceDefinitionVersion.fhirType : string;
begin
  result := 'DeviceDefinition.version';
end;

function TFhirDeviceDefinitionVersion.Link : TFhirDeviceDefinitionVersion;
begin
  result := TFhirDeviceDefinitionVersion(inherited Link);
end;

function TFhirDeviceDefinitionVersion.Clone : TFhirDeviceDefinitionVersion;
begin
  result := TFhirDeviceDefinitionVersion(inherited Clone);
end;

function TFhirDeviceDefinitionVersion.equals(other : TObject) : boolean; 
var
  o : TFhirDeviceDefinitionVersion;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirDeviceDefinitionVersion)) then
    result := false
  else
  begin
    o := TFhirDeviceDefinitionVersion(other);
    result := compareDeep(type_Element, o.type_Element, true) and compareDeep(componentElement, o.componentElement, true) and 
      compareDeep(valueElement, o.valueElement, true);
  end;
end;

function TFhirDeviceDefinitionVersion.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FType_) and isEmptyProp(FComponent) and isEmptyProp(FValue);
end;

procedure TFhirDeviceDefinitionVersion.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('type');
  fields.add('component');
  fields.add('value');
end;

function TFhirDeviceDefinitionVersion.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
end;

procedure TFhirDeviceDefinitionVersion.SetType_(value : TFhirCodeableConcept);
begin
  FType_.free;
  FType_ := value;
end;

procedure TFhirDeviceDefinitionVersion.SetComponent(value : TFhirIdentifier);
begin
  FComponent.free;
  FComponent := value;
end;

procedure TFhirDeviceDefinitionVersion.SetValue(value : TFhirString);
begin
  FValue.free;
  FValue := value;
end;

function TFhirDeviceDefinitionVersion.GetValueST : String;
begin
  if FValue = nil then
    result := ''
  else
    result := FValue.value;
end;

procedure TFhirDeviceDefinitionVersion.SetValueST(value : String);
begin
  if value <> '' then
  begin
    if FValue = nil then
      FValue := TFhirString.create;
    FValue.value := value
  end
  else if FValue <> nil then
    FValue.value := '';
end;

{ TFhirDeviceDefinitionVersionListEnumerator }

constructor TFhirDeviceDefinitionVersionListEnumerator.Create(list : TFhirDeviceDefinitionVersionList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirDeviceDefinitionVersionListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirDeviceDefinitionVersionListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirDeviceDefinitionVersionListEnumerator.GetCurrent : TFhirDeviceDefinitionVersion;
begin
  Result := FList[FIndex];
end;

function TFhirDeviceDefinitionVersionListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirDeviceDefinitionVersionList }

function TFhirDeviceDefinitionVersionList.AddItem(value: TFhirDeviceDefinitionVersion): TFhirDeviceDefinitionVersion;
begin
  assert(value.ClassName = 'TFhirDeviceDefinitionVersion', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirDeviceDefinitionVersion');
  add(value);
  result := value;
end;

function TFhirDeviceDefinitionVersionList.Append: TFhirDeviceDefinitionVersion;
begin
  result := TFhirDeviceDefinitionVersion.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirDeviceDefinitionVersionList.ClearItems;
begin
  Clear;
end;

function TFhirDeviceDefinitionVersionList.GetEnumerator : TFhirDeviceDefinitionVersionListEnumerator;
begin
  result := TFhirDeviceDefinitionVersionListEnumerator.Create(self.link);
end;

function TFhirDeviceDefinitionVersionList.Clone: TFhirDeviceDefinitionVersionList;
begin
  result := TFhirDeviceDefinitionVersionList(inherited Clone);
end;

function TFhirDeviceDefinitionVersionList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirDeviceDefinitionVersionList.GetItemN(index: Integer): TFhirDeviceDefinitionVersion;
begin
  result := TFhirDeviceDefinitionVersion(ObjectByIndex[index]);
end;

function TFhirDeviceDefinitionVersionList.ItemClass: TFslObjectClass;
begin
  result := TFhirDeviceDefinitionVersion;
end;
function TFhirDeviceDefinitionVersionList.IndexOf(value: TFhirDeviceDefinitionVersion): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirDeviceDefinitionVersionList.Insert(index: Integer): TFhirDeviceDefinitionVersion;
begin
  result := TFhirDeviceDefinitionVersion.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirDeviceDefinitionVersionList.InsertItem(index: Integer; value: TFhirDeviceDefinitionVersion);
begin
  assert(value is TFhirDeviceDefinitionVersion);
  Inherited Insert(index, value);
end;

function TFhirDeviceDefinitionVersionList.Item(index: Integer): TFhirDeviceDefinitionVersion;
begin
  result := TFhirDeviceDefinitionVersion(ObjectByIndex[index]);
end;

function TFhirDeviceDefinitionVersionList.Link: TFhirDeviceDefinitionVersionList;
begin
  result := TFhirDeviceDefinitionVersionList(inherited Link);
end;

procedure TFhirDeviceDefinitionVersionList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirDeviceDefinitionVersionList.SetItemByIndex(index: Integer; value: TFhirDeviceDefinitionVersion);
begin
  assert(value is TFhirDeviceDefinitionVersion);
  FhirDeviceDefinitionVersions[index] := value;
end;

procedure TFhirDeviceDefinitionVersionList.SetItemN(index: Integer; value: TFhirDeviceDefinitionVersion);
begin
  assert(value is TFhirDeviceDefinitionVersion);
  ObjectByIndex[index] := value;
end;

{ TFhirDeviceDefinitionProperty }

constructor TFhirDeviceDefinitionProperty.Create;
begin
  inherited;
end;

destructor TFhirDeviceDefinitionProperty.Destroy;
begin
  FType_.free;
  FValue.free;
  inherited;
end;

procedure TFhirDeviceDefinitionProperty.Assign(oSource : TFslObject);
begin
  inherited;
  type_ := TFhirDeviceDefinitionProperty(oSource).type_.Clone;
  value := TFhirDeviceDefinitionProperty(oSource).value.Clone;
end;

procedure TFhirDeviceDefinitionProperty.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'type') Then
     list.add(self.link, 'type', FType_.Link);
  if (child_name = 'value[x]') or (child_name = 'value') Then
     list.add(self.link, 'value[x]', FValue.Link);
end;

procedure TFhirDeviceDefinitionProperty.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'type', 'CodeableConcept', false, TFhirCodeableConcept, FType_.Link));
  oList.add(TFHIRProperty.create(self, 'value[x]', 'Quantity|CodeableConcept|string|boolean|integer|Range|Attachment', false, TFhirDataType, FValue.Link));
end;

function TFhirDeviceDefinitionProperty.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'type') then
  begin
    Type_ := propValue as TFhirCodeableConcept;
    result := propValue;
  end
  else if (isMatchingName(propName, 'value', ['Quantity', 'CodeableConcept', 'String', 'Boolean', 'Integer', 'Range', 'Attachment'])) then
  begin
    Value := propValue as TFhirDataType;
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirDeviceDefinitionProperty.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirDeviceDefinitionProperty.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'type') then result := TFhirCodeableConcept.create()
  else if (isMatchingName(propName, 'value', ['Quantity', 'CodeableConcept', 'String', 'Boolean', 'Integer', 'Range', 'Attachment'])) then raise EFHIRException.create('Cannot make property Value')
  else result := inherited createPropertyValue(propName);
end;

function TFhirDeviceDefinitionProperty.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'type') then result := 'CodeableConcept'
  else if (propName = 'value[x]') then result := 'Quantity|CodeableConcept|string|boolean|integer|Range|Attachment'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirDeviceDefinitionProperty.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'type') then Type_Element := nil
  else if (isMatchingName(propName, 'value', ['Quantity', 'CodeableConcept', 'String', 'Boolean', 'Integer', 'Range', 'Attachment'])) then ValueElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirDeviceDefinitionProperty.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'type') then Type_Element := new as TFhirCodeableConcept
  else if (isMatchingName(propName, 'value', ['Quantity', 'CodeableConcept', 'String', 'Boolean', 'Integer', 'Range', 'Attachment'])) then ValueElement := new as TFhirDataType
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirDeviceDefinitionProperty.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirDeviceDefinitionProperty.fhirType : string;
begin
  result := 'DeviceDefinition.property';
end;

function TFhirDeviceDefinitionProperty.Link : TFhirDeviceDefinitionProperty;
begin
  result := TFhirDeviceDefinitionProperty(inherited Link);
end;

function TFhirDeviceDefinitionProperty.Clone : TFhirDeviceDefinitionProperty;
begin
  result := TFhirDeviceDefinitionProperty(inherited Clone);
end;

function TFhirDeviceDefinitionProperty.equals(other : TObject) : boolean; 
var
  o : TFhirDeviceDefinitionProperty;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirDeviceDefinitionProperty)) then
    result := false
  else
  begin
    o := TFhirDeviceDefinitionProperty(other);
    result := compareDeep(type_Element, o.type_Element, true) and compareDeep(valueElement, o.valueElement, true);
  end;
end;

function TFhirDeviceDefinitionProperty.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FType_) and isEmptyProp(FValue);
end;

procedure TFhirDeviceDefinitionProperty.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('type');
  fields.add('value[x]');
end;

function TFhirDeviceDefinitionProperty.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
end;

procedure TFhirDeviceDefinitionProperty.SetType_(value : TFhirCodeableConcept);
begin
  FType_.free;
  FType_ := value;
end;

procedure TFhirDeviceDefinitionProperty.SetValue(value : TFhirDataType);
begin
  FValue.free;
  FValue := value;
end;

{ TFhirDeviceDefinitionPropertyListEnumerator }

constructor TFhirDeviceDefinitionPropertyListEnumerator.Create(list : TFhirDeviceDefinitionPropertyList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirDeviceDefinitionPropertyListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirDeviceDefinitionPropertyListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirDeviceDefinitionPropertyListEnumerator.GetCurrent : TFhirDeviceDefinitionProperty;
begin
  Result := FList[FIndex];
end;

function TFhirDeviceDefinitionPropertyListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirDeviceDefinitionPropertyList }

function TFhirDeviceDefinitionPropertyList.AddItem(value: TFhirDeviceDefinitionProperty): TFhirDeviceDefinitionProperty;
begin
  assert(value.ClassName = 'TFhirDeviceDefinitionProperty', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirDeviceDefinitionProperty');
  add(value);
  result := value;
end;

function TFhirDeviceDefinitionPropertyList.Append: TFhirDeviceDefinitionProperty;
begin
  result := TFhirDeviceDefinitionProperty.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirDeviceDefinitionPropertyList.ClearItems;
begin
  Clear;
end;

function TFhirDeviceDefinitionPropertyList.GetEnumerator : TFhirDeviceDefinitionPropertyListEnumerator;
begin
  result := TFhirDeviceDefinitionPropertyListEnumerator.Create(self.link);
end;

function TFhirDeviceDefinitionPropertyList.Clone: TFhirDeviceDefinitionPropertyList;
begin
  result := TFhirDeviceDefinitionPropertyList(inherited Clone);
end;

function TFhirDeviceDefinitionPropertyList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirDeviceDefinitionPropertyList.GetItemN(index: Integer): TFhirDeviceDefinitionProperty;
begin
  result := TFhirDeviceDefinitionProperty(ObjectByIndex[index]);
end;

function TFhirDeviceDefinitionPropertyList.ItemClass: TFslObjectClass;
begin
  result := TFhirDeviceDefinitionProperty;
end;
function TFhirDeviceDefinitionPropertyList.IndexOf(value: TFhirDeviceDefinitionProperty): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirDeviceDefinitionPropertyList.Insert(index: Integer): TFhirDeviceDefinitionProperty;
begin
  result := TFhirDeviceDefinitionProperty.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirDeviceDefinitionPropertyList.InsertItem(index: Integer; value: TFhirDeviceDefinitionProperty);
begin
  assert(value is TFhirDeviceDefinitionProperty);
  Inherited Insert(index, value);
end;

function TFhirDeviceDefinitionPropertyList.Item(index: Integer): TFhirDeviceDefinitionProperty;
begin
  result := TFhirDeviceDefinitionProperty(ObjectByIndex[index]);
end;

function TFhirDeviceDefinitionPropertyList.Link: TFhirDeviceDefinitionPropertyList;
begin
  result := TFhirDeviceDefinitionPropertyList(inherited Link);
end;

procedure TFhirDeviceDefinitionPropertyList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirDeviceDefinitionPropertyList.SetItemByIndex(index: Integer; value: TFhirDeviceDefinitionProperty);
begin
  assert(value is TFhirDeviceDefinitionProperty);
  FhirDeviceDefinitionProperties[index] := value;
end;

procedure TFhirDeviceDefinitionPropertyList.SetItemN(index: Integer; value: TFhirDeviceDefinitionProperty);
begin
  assert(value is TFhirDeviceDefinitionProperty);
  ObjectByIndex[index] := value;
end;

{ TFhirDeviceDefinitionLink }

constructor TFhirDeviceDefinitionLink.Create;
begin
  inherited;
end;

destructor TFhirDeviceDefinitionLink.Destroy;
begin
  FRelation.free;
  FRelatedDevice.free;
  inherited;
end;

procedure TFhirDeviceDefinitionLink.Assign(oSource : TFslObject);
begin
  inherited;
  relation := TFhirDeviceDefinitionLink(oSource).relation.Clone;
  relatedDevice := TFhirDeviceDefinitionLink(oSource).relatedDevice.Clone;
end;

procedure TFhirDeviceDefinitionLink.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'relation') Then
     list.add(self.link, 'relation', FRelation.Link);
  if (child_name = 'relatedDevice') Then
     list.add(self.link, 'relatedDevice', FRelatedDevice.Link);
end;

procedure TFhirDeviceDefinitionLink.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'relation', 'Coding', false, TFhirCoding, FRelation.Link));
  oList.add(TFHIRProperty.create(self, 'relatedDevice', 'CodeableReference', false, TFhirCodeableReference, FRelatedDevice.Link));
end;

function TFhirDeviceDefinitionLink.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'relation') then
  begin
    Relation := propValue as TFhirCoding;
    result := propValue;
  end
  else if (propName = 'relatedDevice') then
  begin
    RelatedDevice := propValue as TFhirCodeableReference;
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirDeviceDefinitionLink.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirDeviceDefinitionLink.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'relation') then result := TFhirCoding.create()
  else if (propName = 'relatedDevice') then result := TFhirCodeableReference.create()
  else result := inherited createPropertyValue(propName);
end;

function TFhirDeviceDefinitionLink.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'relation') then result := 'Coding'
  else if (propName = 'relatedDevice') then result := 'CodeableReference'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirDeviceDefinitionLink.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'relation') then RelationElement := nil
  else if (propName = 'relatedDevice') then RelatedDeviceElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirDeviceDefinitionLink.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'relation') then RelationElement := new as TFhirCoding
  else if (propName = 'relatedDevice') then RelatedDeviceElement := new as TFhirCodeableReference
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirDeviceDefinitionLink.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirDeviceDefinitionLink.fhirType : string;
begin
  result := 'DeviceDefinition.link';
end;

function TFhirDeviceDefinitionLink.Link : TFhirDeviceDefinitionLink;
begin
  result := TFhirDeviceDefinitionLink(inherited Link);
end;

function TFhirDeviceDefinitionLink.Clone : TFhirDeviceDefinitionLink;
begin
  result := TFhirDeviceDefinitionLink(inherited Clone);
end;

function TFhirDeviceDefinitionLink.equals(other : TObject) : boolean; 
var
  o : TFhirDeviceDefinitionLink;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirDeviceDefinitionLink)) then
    result := false
  else
  begin
    o := TFhirDeviceDefinitionLink(other);
    result := compareDeep(relationElement, o.relationElement, true) and compareDeep(relatedDeviceElement, o.relatedDeviceElement, true);
  end;
end;

function TFhirDeviceDefinitionLink.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FRelation) and isEmptyProp(FRelatedDevice);
end;

procedure TFhirDeviceDefinitionLink.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('relation');
  fields.add('relatedDevice');
end;

function TFhirDeviceDefinitionLink.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
end;

procedure TFhirDeviceDefinitionLink.SetRelation(value : TFhirCoding);
begin
  FRelation.free;
  FRelation := value;
end;

procedure TFhirDeviceDefinitionLink.SetRelatedDevice(value : TFhirCodeableReference);
begin
  FRelatedDevice.free;
  FRelatedDevice := value;
end;

{ TFhirDeviceDefinitionLinkListEnumerator }

constructor TFhirDeviceDefinitionLinkListEnumerator.Create(list : TFhirDeviceDefinitionLinkList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirDeviceDefinitionLinkListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirDeviceDefinitionLinkListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirDeviceDefinitionLinkListEnumerator.GetCurrent : TFhirDeviceDefinitionLink;
begin
  Result := FList[FIndex];
end;

function TFhirDeviceDefinitionLinkListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirDeviceDefinitionLinkList }

function TFhirDeviceDefinitionLinkList.AddItem(value: TFhirDeviceDefinitionLink): TFhirDeviceDefinitionLink;
begin
  assert(value.ClassName = 'TFhirDeviceDefinitionLink', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirDeviceDefinitionLink');
  add(value);
  result := value;
end;

function TFhirDeviceDefinitionLinkList.Append: TFhirDeviceDefinitionLink;
begin
  result := TFhirDeviceDefinitionLink.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirDeviceDefinitionLinkList.ClearItems;
begin
  Clear;
end;

function TFhirDeviceDefinitionLinkList.GetEnumerator : TFhirDeviceDefinitionLinkListEnumerator;
begin
  result := TFhirDeviceDefinitionLinkListEnumerator.Create(self.link);
end;

function TFhirDeviceDefinitionLinkList.Clone: TFhirDeviceDefinitionLinkList;
begin
  result := TFhirDeviceDefinitionLinkList(inherited Clone);
end;

function TFhirDeviceDefinitionLinkList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirDeviceDefinitionLinkList.GetItemN(index: Integer): TFhirDeviceDefinitionLink;
begin
  result := TFhirDeviceDefinitionLink(ObjectByIndex[index]);
end;

function TFhirDeviceDefinitionLinkList.ItemClass: TFslObjectClass;
begin
  result := TFhirDeviceDefinitionLink;
end;
function TFhirDeviceDefinitionLinkList.IndexOf(value: TFhirDeviceDefinitionLink): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirDeviceDefinitionLinkList.Insert(index: Integer): TFhirDeviceDefinitionLink;
begin
  result := TFhirDeviceDefinitionLink.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirDeviceDefinitionLinkList.InsertItem(index: Integer; value: TFhirDeviceDefinitionLink);
begin
  assert(value is TFhirDeviceDefinitionLink);
  Inherited Insert(index, value);
end;

function TFhirDeviceDefinitionLinkList.Item(index: Integer): TFhirDeviceDefinitionLink;
begin
  result := TFhirDeviceDefinitionLink(ObjectByIndex[index]);
end;

function TFhirDeviceDefinitionLinkList.Link: TFhirDeviceDefinitionLinkList;
begin
  result := TFhirDeviceDefinitionLinkList(inherited Link);
end;

procedure TFhirDeviceDefinitionLinkList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirDeviceDefinitionLinkList.SetItemByIndex(index: Integer; value: TFhirDeviceDefinitionLink);
begin
  assert(value is TFhirDeviceDefinitionLink);
  FhirDeviceDefinitionLinks[index] := value;
end;

procedure TFhirDeviceDefinitionLinkList.SetItemN(index: Integer; value: TFhirDeviceDefinitionLink);
begin
  assert(value is TFhirDeviceDefinitionLink);
  ObjectByIndex[index] := value;
end;

{ TFhirDeviceDefinitionMaterial }

constructor TFhirDeviceDefinitionMaterial.Create;
begin
  inherited;
end;

destructor TFhirDeviceDefinitionMaterial.Destroy;
begin
  FSubstance.free;
  FAlternate.free;
  FAllergenicIndicator.free;
  inherited;
end;

procedure TFhirDeviceDefinitionMaterial.Assign(oSource : TFslObject);
begin
  inherited;
  substance := TFhirDeviceDefinitionMaterial(oSource).substance.Clone;
  alternateElement := TFhirDeviceDefinitionMaterial(oSource).alternateElement.Clone;
  allergenicIndicatorElement := TFhirDeviceDefinitionMaterial(oSource).allergenicIndicatorElement.Clone;
end;

procedure TFhirDeviceDefinitionMaterial.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'substance') Then
     list.add(self.link, 'substance', FSubstance.Link);
  if (child_name = 'alternate') Then
     list.add(self.link, 'alternate', FAlternate.Link);
  if (child_name = 'allergenicIndicator') Then
     list.add(self.link, 'allergenicIndicator', FAllergenicIndicator.Link);
end;

procedure TFhirDeviceDefinitionMaterial.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'substance', 'CodeableConcept', false, TFhirCodeableConcept, FSubstance.Link));
  oList.add(TFHIRProperty.create(self, 'alternate', 'boolean', false, TFhirBoolean, FAlternate.Link));
  oList.add(TFHIRProperty.create(self, 'allergenicIndicator', 'boolean', false, TFhirBoolean, FAllergenicIndicator.Link));
end;

function TFhirDeviceDefinitionMaterial.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'substance') then
  begin
    Substance := propValue as TFhirCodeableConcept;
    result := propValue;
  end
  else if (propName = 'alternate') then
  begin
    AlternateElement := asBoolean(propValue);
    result := propValue;
  end
  else if (propName = 'allergenicIndicator') then
  begin
    AllergenicIndicatorElement := asBoolean(propValue);
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirDeviceDefinitionMaterial.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirDeviceDefinitionMaterial.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'substance') then result := TFhirCodeableConcept.create()
  else if (propName = 'alternate') then result := TFhirBoolean.create()
  else if (propName = 'allergenicIndicator') then result := TFhirBoolean.create()
  else result := inherited createPropertyValue(propName);
end;

function TFhirDeviceDefinitionMaterial.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'substance') then result := 'CodeableConcept'
  else if (propName = 'alternate') then result := 'boolean'
  else if (propName = 'allergenicIndicator') then result := 'boolean'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirDeviceDefinitionMaterial.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'substance') then SubstanceElement := nil
  else if (propName = 'alternate') then AlternateElement := nil
  else if (propName = 'allergenicIndicator') then AllergenicIndicatorElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirDeviceDefinitionMaterial.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'substance') then SubstanceElement := new as TFhirCodeableConcept
  else if (propName = 'alternate') then AlternateElement := asBoolean(new)
  else if (propName = 'allergenicIndicator') then AllergenicIndicatorElement := asBoolean(new)
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirDeviceDefinitionMaterial.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirDeviceDefinitionMaterial.fhirType : string;
begin
  result := 'DeviceDefinition.material';
end;

function TFhirDeviceDefinitionMaterial.Link : TFhirDeviceDefinitionMaterial;
begin
  result := TFhirDeviceDefinitionMaterial(inherited Link);
end;

function TFhirDeviceDefinitionMaterial.Clone : TFhirDeviceDefinitionMaterial;
begin
  result := TFhirDeviceDefinitionMaterial(inherited Clone);
end;

function TFhirDeviceDefinitionMaterial.equals(other : TObject) : boolean; 
var
  o : TFhirDeviceDefinitionMaterial;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirDeviceDefinitionMaterial)) then
    result := false
  else
  begin
    o := TFhirDeviceDefinitionMaterial(other);
    result := compareDeep(substanceElement, o.substanceElement, true) and compareDeep(alternateElement, o.alternateElement, true) and 
      compareDeep(allergenicIndicatorElement, o.allergenicIndicatorElement, true);
  end;
end;

function TFhirDeviceDefinitionMaterial.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FSubstance) and isEmptyProp(FAlternate) and isEmptyProp(FAllergenicIndicator);
end;

procedure TFhirDeviceDefinitionMaterial.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('substance');
  fields.add('alternate');
  fields.add('allergenicIndicator');
end;

function TFhirDeviceDefinitionMaterial.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
end;

procedure TFhirDeviceDefinitionMaterial.SetSubstance(value : TFhirCodeableConcept);
begin
  FSubstance.free;
  FSubstance := value;
end;

procedure TFhirDeviceDefinitionMaterial.SetAlternate(value : TFhirBoolean);
begin
  FAlternate.free;
  FAlternate := value;
end;

function TFhirDeviceDefinitionMaterial.GetAlternateST : Boolean;
begin
  if FAlternate = nil then
    result := false
  else
    result := FAlternate.value;
end;

procedure TFhirDeviceDefinitionMaterial.SetAlternateST(value : Boolean);
begin
  if FAlternate = nil then
    FAlternate := TFhirBoolean.create;
  FAlternate.value := value
end;

procedure TFhirDeviceDefinitionMaterial.SetAllergenicIndicator(value : TFhirBoolean);
begin
  FAllergenicIndicator.free;
  FAllergenicIndicator := value;
end;

function TFhirDeviceDefinitionMaterial.GetAllergenicIndicatorST : Boolean;
begin
  if FAllergenicIndicator = nil then
    result := false
  else
    result := FAllergenicIndicator.value;
end;

procedure TFhirDeviceDefinitionMaterial.SetAllergenicIndicatorST(value : Boolean);
begin
  if FAllergenicIndicator = nil then
    FAllergenicIndicator := TFhirBoolean.create;
  FAllergenicIndicator.value := value
end;

{ TFhirDeviceDefinitionMaterialListEnumerator }

constructor TFhirDeviceDefinitionMaterialListEnumerator.Create(list : TFhirDeviceDefinitionMaterialList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirDeviceDefinitionMaterialListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirDeviceDefinitionMaterialListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirDeviceDefinitionMaterialListEnumerator.GetCurrent : TFhirDeviceDefinitionMaterial;
begin
  Result := FList[FIndex];
end;

function TFhirDeviceDefinitionMaterialListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirDeviceDefinitionMaterialList }

function TFhirDeviceDefinitionMaterialList.AddItem(value: TFhirDeviceDefinitionMaterial): TFhirDeviceDefinitionMaterial;
begin
  assert(value.ClassName = 'TFhirDeviceDefinitionMaterial', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirDeviceDefinitionMaterial');
  add(value);
  result := value;
end;

function TFhirDeviceDefinitionMaterialList.Append: TFhirDeviceDefinitionMaterial;
begin
  result := TFhirDeviceDefinitionMaterial.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirDeviceDefinitionMaterialList.ClearItems;
begin
  Clear;
end;

function TFhirDeviceDefinitionMaterialList.GetEnumerator : TFhirDeviceDefinitionMaterialListEnumerator;
begin
  result := TFhirDeviceDefinitionMaterialListEnumerator.Create(self.link);
end;

function TFhirDeviceDefinitionMaterialList.Clone: TFhirDeviceDefinitionMaterialList;
begin
  result := TFhirDeviceDefinitionMaterialList(inherited Clone);
end;

function TFhirDeviceDefinitionMaterialList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirDeviceDefinitionMaterialList.GetItemN(index: Integer): TFhirDeviceDefinitionMaterial;
begin
  result := TFhirDeviceDefinitionMaterial(ObjectByIndex[index]);
end;

function TFhirDeviceDefinitionMaterialList.ItemClass: TFslObjectClass;
begin
  result := TFhirDeviceDefinitionMaterial;
end;
function TFhirDeviceDefinitionMaterialList.IndexOf(value: TFhirDeviceDefinitionMaterial): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirDeviceDefinitionMaterialList.Insert(index: Integer): TFhirDeviceDefinitionMaterial;
begin
  result := TFhirDeviceDefinitionMaterial.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirDeviceDefinitionMaterialList.InsertItem(index: Integer; value: TFhirDeviceDefinitionMaterial);
begin
  assert(value is TFhirDeviceDefinitionMaterial);
  Inherited Insert(index, value);
end;

function TFhirDeviceDefinitionMaterialList.Item(index: Integer): TFhirDeviceDefinitionMaterial;
begin
  result := TFhirDeviceDefinitionMaterial(ObjectByIndex[index]);
end;

function TFhirDeviceDefinitionMaterialList.Link: TFhirDeviceDefinitionMaterialList;
begin
  result := TFhirDeviceDefinitionMaterialList(inherited Link);
end;

procedure TFhirDeviceDefinitionMaterialList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirDeviceDefinitionMaterialList.SetItemByIndex(index: Integer; value: TFhirDeviceDefinitionMaterial);
begin
  assert(value is TFhirDeviceDefinitionMaterial);
  FhirDeviceDefinitionMaterials[index] := value;
end;

procedure TFhirDeviceDefinitionMaterialList.SetItemN(index: Integer; value: TFhirDeviceDefinitionMaterial);
begin
  assert(value is TFhirDeviceDefinitionMaterial);
  ObjectByIndex[index] := value;
end;

{ TFhirDeviceDefinitionGuideline }

constructor TFhirDeviceDefinitionGuideline.Create;
begin
  inherited;
end;

destructor TFhirDeviceDefinitionGuideline.Destroy;
begin
  FUseContextList.Free;
  FUsageInstruction.free;
  FRelatedArtifactList.Free;
  FIndicationList.Free;
  FContraindicationList.Free;
  FWarningList.Free;
  FIntendedUse.free;
  inherited;
end;

procedure TFhirDeviceDefinitionGuideline.Assign(oSource : TFslObject);
begin
  inherited;
  if (TFhirDeviceDefinitionGuideline(oSource).FUseContextList = nil) then
  begin
    FUseContextList.free;
    FUseContextList := nil;
  end
  else
  begin
    if FUseContextList = nil then
      FUseContextList := TFhirUsageContextList.Create;
    FUseContextList.Assign(TFhirDeviceDefinitionGuideline(oSource).FUseContextList);
  end;
  usageInstructionElement := TFhirDeviceDefinitionGuideline(oSource).usageInstructionElement.Clone;
  if (TFhirDeviceDefinitionGuideline(oSource).FRelatedArtifactList = nil) then
  begin
    FRelatedArtifactList.free;
    FRelatedArtifactList := nil;
  end
  else
  begin
    if FRelatedArtifactList = nil then
      FRelatedArtifactList := TFhirRelatedArtifactList.Create;
    FRelatedArtifactList.Assign(TFhirDeviceDefinitionGuideline(oSource).FRelatedArtifactList);
  end;
  if (TFhirDeviceDefinitionGuideline(oSource).FIndicationList = nil) then
  begin
    FIndicationList.free;
    FIndicationList := nil;
  end
  else
  begin
    if FIndicationList = nil then
      FIndicationList := TFhirCodeableReferenceList.Create;
    FIndicationList.Assign(TFhirDeviceDefinitionGuideline(oSource).FIndicationList);
  end;
  if (TFhirDeviceDefinitionGuideline(oSource).FContraindicationList = nil) then
  begin
    FContraindicationList.free;
    FContraindicationList := nil;
  end
  else
  begin
    if FContraindicationList = nil then
      FContraindicationList := TFhirCodeableReferenceList.Create;
    FContraindicationList.Assign(TFhirDeviceDefinitionGuideline(oSource).FContraindicationList);
  end;
  if (TFhirDeviceDefinitionGuideline(oSource).FWarningList = nil) then
  begin
    FWarningList.free;
    FWarningList := nil;
  end
  else
  begin
    if FWarningList = nil then
      FWarningList := TFhirCodeableReferenceList.Create;
    FWarningList.Assign(TFhirDeviceDefinitionGuideline(oSource).FWarningList);
  end;
  intendedUseElement := TFhirDeviceDefinitionGuideline(oSource).intendedUseElement.Clone;
end;

procedure TFhirDeviceDefinitionGuideline.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'useContext') Then
    list.addAll(self, 'useContext', FUseContextList);
  if (child_name = 'usageInstruction') Then
     list.add(self.link, 'usageInstruction', FUsageInstruction.Link);
  if (child_name = 'relatedArtifact') Then
    list.addAll(self, 'relatedArtifact', FRelatedArtifactList);
  if (child_name = 'indication') Then
    list.addAll(self, 'indication', FIndicationList);
  if (child_name = 'contraindication') Then
    list.addAll(self, 'contraindication', FContraindicationList);
  if (child_name = 'warning') Then
    list.addAll(self, 'warning', FWarningList);
  if (child_name = 'intendedUse') Then
     list.add(self.link, 'intendedUse', FIntendedUse.Link);
end;

procedure TFhirDeviceDefinitionGuideline.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'useContext', 'UsageContext', true, TFhirUsageContext, FUseContextList.Link));
  oList.add(TFHIRProperty.create(self, 'usageInstruction', 'markdown', false, TFhirMarkdown, FUsageInstruction.Link));
  oList.add(TFHIRProperty.create(self, 'relatedArtifact', 'RelatedArtifact', true, TFhirRelatedArtifact, FRelatedArtifactList.Link));
  oList.add(TFHIRProperty.create(self, 'indication', 'CodeableReference', true, TFhirCodeableReference, FIndicationList.Link));
  oList.add(TFHIRProperty.create(self, 'contraindication', 'CodeableReference', true, TFhirCodeableReference, FContraindicationList.Link));
  oList.add(TFHIRProperty.create(self, 'warning', 'CodeableReference', true, TFhirCodeableReference, FWarningList.Link));
  oList.add(TFHIRProperty.create(self, 'intendedUse', 'string', false, TFhirString, FIntendedUse.Link));
end;

function TFhirDeviceDefinitionGuideline.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'useContext') then
  begin
    UseContextList.add(propValue as TFhirUsageContext);
    result := propValue;
  end
  else if (propName = 'usageInstruction') then
  begin
    UsageInstructionElement := asMarkdown(propValue);
    result := propValue;
  end
  else if (propName = 'relatedArtifact') then
  begin
    RelatedArtifactList.add(propValue as TFhirRelatedArtifact);
    result := propValue;
  end
  else if (propName = 'indication') then
  begin
    IndicationList.add(propValue as TFhirCodeableReference);
    result := propValue;
  end
  else if (propName = 'contraindication') then
  begin
    ContraindicationList.add(propValue as TFhirCodeableReference);
    result := propValue;
  end
  else if (propName = 'warning') then
  begin
    WarningList.add(propValue as TFhirCodeableReference);
    result := propValue;
  end
  else if (propName = 'intendedUse') then
  begin
    IntendedUseElement := asString(propValue);
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirDeviceDefinitionGuideline.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'useContext') then UseContextList.insertItem(index, propValue as TFhirUsageContext)
  else if (propName = 'relatedArtifact') then RelatedArtifactList.insertItem(index, propValue as TFhirRelatedArtifact)
  else if (propName = 'indication') then IndicationList.insertItem(index, propValue as TFhirCodeableReference)
  else if (propName = 'contraindication') then ContraindicationList.insertItem(index, propValue as TFhirCodeableReference)
  else if (propName = 'warning') then WarningList.insertItem(index, propValue as TFhirCodeableReference)
  else inherited;
end;

function TFhirDeviceDefinitionGuideline.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'useContext') then result := UseContextList.new()
  else if (propName = 'usageInstruction') then result := TFhirMarkdown.create()
  else if (propName = 'relatedArtifact') then result := RelatedArtifactList.new()
  else if (propName = 'indication') then result := IndicationList.new()
  else if (propName = 'contraindication') then result := ContraindicationList.new()
  else if (propName = 'warning') then result := WarningList.new()
  else if (propName = 'intendedUse') then result := TFhirString.create()
  else result := inherited createPropertyValue(propName);
end;

function TFhirDeviceDefinitionGuideline.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'useContext') then result := 'UsageContext'
  else if (propName = 'usageInstruction') then result := 'markdown'
  else if (propName = 'relatedArtifact') then result := 'RelatedArtifact'
  else if (propName = 'indication') then result := 'CodeableReference'
  else if (propName = 'contraindication') then result := 'CodeableReference'
  else if (propName = 'warning') then result := 'CodeableReference'
  else if (propName = 'intendedUse') then result := 'string'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirDeviceDefinitionGuideline.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'useContext') then deletePropertyValue('useContext', UseContextList, value)
  else if (propName = 'usageInstruction') then UsageInstructionElement := nil
  else if (propName = 'relatedArtifact') then deletePropertyValue('relatedArtifact', RelatedArtifactList, value)
  else if (propName = 'indication') then deletePropertyValue('indication', IndicationList, value)
  else if (propName = 'contraindication') then deletePropertyValue('contraindication', ContraindicationList, value)
  else if (propName = 'warning') then deletePropertyValue('warning', WarningList, value)
  else if (propName = 'intendedUse') then IntendedUseElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirDeviceDefinitionGuideline.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'useContext') then replacePropertyValue('useContext', UseContextList, existing, new)
  else if (propName = 'usageInstruction') then UsageInstructionElement := asMarkdown(new)
  else if (propName = 'relatedArtifact') then replacePropertyValue('relatedArtifact', RelatedArtifactList, existing, new)
  else if (propName = 'indication') then replacePropertyValue('indication', IndicationList, existing, new)
  else if (propName = 'contraindication') then replacePropertyValue('contraindication', ContraindicationList, existing, new)
  else if (propName = 'warning') then replacePropertyValue('warning', WarningList, existing, new)
  else if (propName = 'intendedUse') then IntendedUseElement := asString(new)
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirDeviceDefinitionGuideline.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'useContext') then UseContextList.move(source, destination)
  else if (propName = 'relatedArtifact') then RelatedArtifactList.move(source, destination)
  else if (propName = 'indication') then IndicationList.move(source, destination)
  else if (propName = 'contraindication') then ContraindicationList.move(source, destination)
  else if (propName = 'warning') then WarningList.move(source, destination)
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirDeviceDefinitionGuideline.fhirType : string;
begin
  result := 'DeviceDefinition.guideline';
end;

function TFhirDeviceDefinitionGuideline.Link : TFhirDeviceDefinitionGuideline;
begin
  result := TFhirDeviceDefinitionGuideline(inherited Link);
end;

function TFhirDeviceDefinitionGuideline.Clone : TFhirDeviceDefinitionGuideline;
begin
  result := TFhirDeviceDefinitionGuideline(inherited Clone);
end;

function TFhirDeviceDefinitionGuideline.equals(other : TObject) : boolean; 
var
  o : TFhirDeviceDefinitionGuideline;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirDeviceDefinitionGuideline)) then
    result := false
  else
  begin
    o := TFhirDeviceDefinitionGuideline(other);
    result := compareDeep(useContextList, o.useContextList, true) and compareDeep(usageInstructionElement, o.usageInstructionElement, true) and 
      compareDeep(relatedArtifactList, o.relatedArtifactList, true) and compareDeep(indicationList, o.indicationList, true) and 
      compareDeep(contraindicationList, o.contraindicationList, true) and compareDeep(warningList, o.warningList, true) and 
      compareDeep(intendedUseElement, o.intendedUseElement, true);
  end;
end;

function TFhirDeviceDefinitionGuideline.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FuseContextList) and isEmptyProp(FUsageInstruction) and isEmptyProp(FrelatedArtifactList) and isEmptyProp(FindicationList) and isEmptyProp(FcontraindicationList) and isEmptyProp(FwarningList) and isEmptyProp(FIntendedUse);
end;

procedure TFhirDeviceDefinitionGuideline.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('useContext');
  fields.add('usageInstruction');
  fields.add('relatedArtifact');
  fields.add('indication');
  fields.add('contraindication');
  fields.add('warning');
  fields.add('intendedUse');
end;

function TFhirDeviceDefinitionGuideline.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
  inc(result, FUseContextList.sizeInBytes(magic));
  inc(result, FRelatedArtifactList.sizeInBytes(magic));
  inc(result, FIndicationList.sizeInBytes(magic));
  inc(result, FContraindicationList.sizeInBytes(magic));
  inc(result, FWarningList.sizeInBytes(magic));
end;

function TFhirDeviceDefinitionGuideline.GetUseContextList : TFhirUsageContextList;
begin
  if FUseContextList = nil then
    FUseContextList := TFhirUsageContextList.Create;
  result := FUseContextList;
end;

function TFhirDeviceDefinitionGuideline.GetHasUseContextList : boolean;
begin
  result := (FUseContextList <> nil) and (FUseContextList.count > 0);
end;

procedure TFhirDeviceDefinitionGuideline.SetUsageInstruction(value : TFhirMarkdown);
begin
  FUsageInstruction.free;
  FUsageInstruction := value;
end;

function TFhirDeviceDefinitionGuideline.GetUsageInstructionST : String;
begin
  if FUsageInstruction = nil then
    result := ''
  else
    result := FUsageInstruction.value;
end;

procedure TFhirDeviceDefinitionGuideline.SetUsageInstructionST(value : String);
begin
  if value <> '' then
  begin
    if FUsageInstruction = nil then
      FUsageInstruction := TFhirMarkdown.create;
    FUsageInstruction.value := value
  end
  else if FUsageInstruction <> nil then
    FUsageInstruction.value := '';
end;

function TFhirDeviceDefinitionGuideline.GetRelatedArtifactList : TFhirRelatedArtifactList;
begin
  if FRelatedArtifactList = nil then
    FRelatedArtifactList := TFhirRelatedArtifactList.Create;
  result := FRelatedArtifactList;
end;

function TFhirDeviceDefinitionGuideline.GetHasRelatedArtifactList : boolean;
begin
  result := (FRelatedArtifactList <> nil) and (FRelatedArtifactList.count > 0);
end;

function TFhirDeviceDefinitionGuideline.GetIndicationList : TFhirCodeableReferenceList;
begin
  if FIndicationList = nil then
    FIndicationList := TFhirCodeableReferenceList.Create;
  result := FIndicationList;
end;

function TFhirDeviceDefinitionGuideline.GetHasIndicationList : boolean;
begin
  result := (FIndicationList <> nil) and (FIndicationList.count > 0);
end;

function TFhirDeviceDefinitionGuideline.GetContraindicationList : TFhirCodeableReferenceList;
begin
  if FContraindicationList = nil then
    FContraindicationList := TFhirCodeableReferenceList.Create;
  result := FContraindicationList;
end;

function TFhirDeviceDefinitionGuideline.GetHasContraindicationList : boolean;
begin
  result := (FContraindicationList <> nil) and (FContraindicationList.count > 0);
end;

function TFhirDeviceDefinitionGuideline.GetWarningList : TFhirCodeableReferenceList;
begin
  if FWarningList = nil then
    FWarningList := TFhirCodeableReferenceList.Create;
  result := FWarningList;
end;

function TFhirDeviceDefinitionGuideline.GetHasWarningList : boolean;
begin
  result := (FWarningList <> nil) and (FWarningList.count > 0);
end;

procedure TFhirDeviceDefinitionGuideline.SetIntendedUse(value : TFhirString);
begin
  FIntendedUse.free;
  FIntendedUse := value;
end;

function TFhirDeviceDefinitionGuideline.GetIntendedUseST : String;
begin
  if FIntendedUse = nil then
    result := ''
  else
    result := FIntendedUse.value;
end;

procedure TFhirDeviceDefinitionGuideline.SetIntendedUseST(value : String);
begin
  if value <> '' then
  begin
    if FIntendedUse = nil then
      FIntendedUse := TFhirString.create;
    FIntendedUse.value := value
  end
  else if FIntendedUse <> nil then
    FIntendedUse.value := '';
end;

{ TFhirDeviceDefinitionGuidelineListEnumerator }

constructor TFhirDeviceDefinitionGuidelineListEnumerator.Create(list : TFhirDeviceDefinitionGuidelineList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirDeviceDefinitionGuidelineListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirDeviceDefinitionGuidelineListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirDeviceDefinitionGuidelineListEnumerator.GetCurrent : TFhirDeviceDefinitionGuideline;
begin
  Result := FList[FIndex];
end;

function TFhirDeviceDefinitionGuidelineListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirDeviceDefinitionGuidelineList }

function TFhirDeviceDefinitionGuidelineList.AddItem(value: TFhirDeviceDefinitionGuideline): TFhirDeviceDefinitionGuideline;
begin
  assert(value.ClassName = 'TFhirDeviceDefinitionGuideline', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirDeviceDefinitionGuideline');
  add(value);
  result := value;
end;

function TFhirDeviceDefinitionGuidelineList.Append: TFhirDeviceDefinitionGuideline;
begin
  result := TFhirDeviceDefinitionGuideline.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirDeviceDefinitionGuidelineList.ClearItems;
begin
  Clear;
end;

function TFhirDeviceDefinitionGuidelineList.GetEnumerator : TFhirDeviceDefinitionGuidelineListEnumerator;
begin
  result := TFhirDeviceDefinitionGuidelineListEnumerator.Create(self.link);
end;

function TFhirDeviceDefinitionGuidelineList.Clone: TFhirDeviceDefinitionGuidelineList;
begin
  result := TFhirDeviceDefinitionGuidelineList(inherited Clone);
end;

function TFhirDeviceDefinitionGuidelineList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirDeviceDefinitionGuidelineList.GetItemN(index: Integer): TFhirDeviceDefinitionGuideline;
begin
  result := TFhirDeviceDefinitionGuideline(ObjectByIndex[index]);
end;

function TFhirDeviceDefinitionGuidelineList.ItemClass: TFslObjectClass;
begin
  result := TFhirDeviceDefinitionGuideline;
end;
function TFhirDeviceDefinitionGuidelineList.IndexOf(value: TFhirDeviceDefinitionGuideline): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirDeviceDefinitionGuidelineList.Insert(index: Integer): TFhirDeviceDefinitionGuideline;
begin
  result := TFhirDeviceDefinitionGuideline.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirDeviceDefinitionGuidelineList.InsertItem(index: Integer; value: TFhirDeviceDefinitionGuideline);
begin
  assert(value is TFhirDeviceDefinitionGuideline);
  Inherited Insert(index, value);
end;

function TFhirDeviceDefinitionGuidelineList.Item(index: Integer): TFhirDeviceDefinitionGuideline;
begin
  result := TFhirDeviceDefinitionGuideline(ObjectByIndex[index]);
end;

function TFhirDeviceDefinitionGuidelineList.Link: TFhirDeviceDefinitionGuidelineList;
begin
  result := TFhirDeviceDefinitionGuidelineList(inherited Link);
end;

procedure TFhirDeviceDefinitionGuidelineList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirDeviceDefinitionGuidelineList.SetItemByIndex(index: Integer; value: TFhirDeviceDefinitionGuideline);
begin
  assert(value is TFhirDeviceDefinitionGuideline);
  FhirDeviceDefinitionGuidelines[index] := value;
end;

procedure TFhirDeviceDefinitionGuidelineList.SetItemN(index: Integer; value: TFhirDeviceDefinitionGuideline);
begin
  assert(value is TFhirDeviceDefinitionGuideline);
  ObjectByIndex[index] := value;
end;

{ TFhirDeviceDefinitionCorrectiveAction }

constructor TFhirDeviceDefinitionCorrectiveAction.Create;
begin
  inherited;
end;

destructor TFhirDeviceDefinitionCorrectiveAction.Destroy;
begin
  FRecall.free;
  FScope.free;
  FPeriod.free;
  inherited;
end;

procedure TFhirDeviceDefinitionCorrectiveAction.Assign(oSource : TFslObject);
begin
  inherited;
  recallElement := TFhirDeviceDefinitionCorrectiveAction(oSource).recallElement.Clone;
  scopeElement := TFhirDeviceDefinitionCorrectiveAction(oSource).scopeElement.Clone;
  period := TFhirDeviceDefinitionCorrectiveAction(oSource).period.Clone;
end;

procedure TFhirDeviceDefinitionCorrectiveAction.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'recall') Then
     list.add(self.link, 'recall', FRecall.Link);
  if (child_name = 'scope') Then
     list.add(self.link, 'scope', FScope.Link);
  if (child_name = 'period') Then
     list.add(self.link, 'period', FPeriod.Link);
end;

procedure TFhirDeviceDefinitionCorrectiveAction.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'recall', 'boolean', false, TFhirBoolean, FRecall.Link));
  oList.add(TFHIRProperty.create(self, 'scope', 'code', false, TFhirEnum, FScope.Link));
  oList.add(TFHIRProperty.create(self, 'period', 'Period', false, TFhirPeriod, FPeriod.Link));
end;

function TFhirDeviceDefinitionCorrectiveAction.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'recall') then
  begin
    RecallElement := asBoolean(propValue);
    result := propValue;
  end
  else if (propName = 'scope') then
  begin
    ScopeElement := asEnum(SYSTEMS_TFhirDeviceCorrectiveActionScopeEnum, CODES_TFhirDeviceCorrectiveActionScopeEnum, propValue);
    result := propValue;
  end
  else if (propName = 'period') then
  begin
    Period := propValue as TFhirPeriod;
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirDeviceDefinitionCorrectiveAction.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirDeviceDefinitionCorrectiveAction.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'recall') then result := TFhirBoolean.create()
  else if (propName = 'scope') then result := TFhirEnum.create(SYSTEMS_TFhirDeviceCorrectiveActionScopeEnum[DeviceCorrectiveActionScopeNull], CODES_TFhirDeviceCorrectiveActionScopeEnum[DeviceCorrectiveActionScopeNull]) 
  else if (propName = 'period') then result := TFhirPeriod.create()
  else result := inherited createPropertyValue(propName);
end;

function TFhirDeviceDefinitionCorrectiveAction.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'recall') then result := 'boolean'
  else if (propName = 'scope') then result := 'code'
  else if (propName = 'period') then result := 'Period'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirDeviceDefinitionCorrectiveAction.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'recall') then RecallElement := nil
  else if (propName = 'scope') then ScopeElement := nil
  else if (propName = 'period') then PeriodElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirDeviceDefinitionCorrectiveAction.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'recall') then RecallElement := asBoolean(new)
  else if (propName = 'scope') then ScopeElement := asEnum(SYSTEMS_TFhirDeviceCorrectiveActionScopeEnum, CODES_TFhirDeviceCorrectiveActionScopeEnum, new)
  else if (propName = 'period') then PeriodElement := new as TFhirPeriod
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirDeviceDefinitionCorrectiveAction.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirDeviceDefinitionCorrectiveAction.fhirType : string;
begin
  result := 'DeviceDefinition.correctiveAction';
end;

function TFhirDeviceDefinitionCorrectiveAction.Link : TFhirDeviceDefinitionCorrectiveAction;
begin
  result := TFhirDeviceDefinitionCorrectiveAction(inherited Link);
end;

function TFhirDeviceDefinitionCorrectiveAction.Clone : TFhirDeviceDefinitionCorrectiveAction;
begin
  result := TFhirDeviceDefinitionCorrectiveAction(inherited Clone);
end;

function TFhirDeviceDefinitionCorrectiveAction.equals(other : TObject) : boolean; 
var
  o : TFhirDeviceDefinitionCorrectiveAction;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirDeviceDefinitionCorrectiveAction)) then
    result := false
  else
  begin
    o := TFhirDeviceDefinitionCorrectiveAction(other);
    result := compareDeep(recallElement, o.recallElement, true) and compareDeep(scopeElement, o.scopeElement, true) and 
      compareDeep(periodElement, o.periodElement, true);
  end;
end;

function TFhirDeviceDefinitionCorrectiveAction.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FRecall) and isEmptyProp(FScope) and isEmptyProp(FPeriod);
end;

procedure TFhirDeviceDefinitionCorrectiveAction.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('recall');
  fields.add('scope');
  fields.add('period');
end;

function TFhirDeviceDefinitionCorrectiveAction.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
end;

procedure TFhirDeviceDefinitionCorrectiveAction.SetRecall(value : TFhirBoolean);
begin
  FRecall.free;
  FRecall := value;
end;

function TFhirDeviceDefinitionCorrectiveAction.GetRecallST : Boolean;
begin
  if FRecall = nil then
    result := false
  else
    result := FRecall.value;
end;

procedure TFhirDeviceDefinitionCorrectiveAction.SetRecallST(value : Boolean);
begin
  if FRecall = nil then
    FRecall := TFhirBoolean.create;
  FRecall.value := value
end;

procedure TFhirDeviceDefinitionCorrectiveAction.SetScope(value : TFhirEnum);
begin
  FScope.free;
  FScope := value;
end;

function TFhirDeviceDefinitionCorrectiveAction.GetScopeST : TFhirDeviceCorrectiveActionScopeEnum;
begin
  if FScope = nil then
    result := TFhirDeviceCorrectiveActionScopeEnum(0)
  else
    result := TFhirDeviceCorrectiveActionScopeEnum(StringArrayIndexOfSensitive(CODES_TFhirDeviceCorrectiveActionScopeEnum, FScope.value));
end;

procedure TFhirDeviceDefinitionCorrectiveAction.SetScopeST(value : TFhirDeviceCorrectiveActionScopeEnum);
begin
  if ord(value) = 0 then
    ScopeElement := nil
  else
    ScopeElement := TFhirEnum.create(SYSTEMS_TFhirDeviceCorrectiveActionScopeEnum[value], CODES_TFhirDeviceCorrectiveActionScopeEnum[value]);
end;

procedure TFhirDeviceDefinitionCorrectiveAction.SetPeriod(value : TFhirPeriod);
begin
  FPeriod.free;
  FPeriod := value;
end;

{ TFhirDeviceDefinitionCorrectiveActionListEnumerator }

constructor TFhirDeviceDefinitionCorrectiveActionListEnumerator.Create(list : TFhirDeviceDefinitionCorrectiveActionList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirDeviceDefinitionCorrectiveActionListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirDeviceDefinitionCorrectiveActionListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirDeviceDefinitionCorrectiveActionListEnumerator.GetCurrent : TFhirDeviceDefinitionCorrectiveAction;
begin
  Result := FList[FIndex];
end;

function TFhirDeviceDefinitionCorrectiveActionListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirDeviceDefinitionCorrectiveActionList }

function TFhirDeviceDefinitionCorrectiveActionList.AddItem(value: TFhirDeviceDefinitionCorrectiveAction): TFhirDeviceDefinitionCorrectiveAction;
begin
  assert(value.ClassName = 'TFhirDeviceDefinitionCorrectiveAction', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirDeviceDefinitionCorrectiveAction');
  add(value);
  result := value;
end;

function TFhirDeviceDefinitionCorrectiveActionList.Append: TFhirDeviceDefinitionCorrectiveAction;
begin
  result := TFhirDeviceDefinitionCorrectiveAction.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirDeviceDefinitionCorrectiveActionList.ClearItems;
begin
  Clear;
end;

function TFhirDeviceDefinitionCorrectiveActionList.GetEnumerator : TFhirDeviceDefinitionCorrectiveActionListEnumerator;
begin
  result := TFhirDeviceDefinitionCorrectiveActionListEnumerator.Create(self.link);
end;

function TFhirDeviceDefinitionCorrectiveActionList.Clone: TFhirDeviceDefinitionCorrectiveActionList;
begin
  result := TFhirDeviceDefinitionCorrectiveActionList(inherited Clone);
end;

function TFhirDeviceDefinitionCorrectiveActionList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirDeviceDefinitionCorrectiveActionList.GetItemN(index: Integer): TFhirDeviceDefinitionCorrectiveAction;
begin
  result := TFhirDeviceDefinitionCorrectiveAction(ObjectByIndex[index]);
end;

function TFhirDeviceDefinitionCorrectiveActionList.ItemClass: TFslObjectClass;
begin
  result := TFhirDeviceDefinitionCorrectiveAction;
end;
function TFhirDeviceDefinitionCorrectiveActionList.IndexOf(value: TFhirDeviceDefinitionCorrectiveAction): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirDeviceDefinitionCorrectiveActionList.Insert(index: Integer): TFhirDeviceDefinitionCorrectiveAction;
begin
  result := TFhirDeviceDefinitionCorrectiveAction.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirDeviceDefinitionCorrectiveActionList.InsertItem(index: Integer; value: TFhirDeviceDefinitionCorrectiveAction);
begin
  assert(value is TFhirDeviceDefinitionCorrectiveAction);
  Inherited Insert(index, value);
end;

function TFhirDeviceDefinitionCorrectiveActionList.Item(index: Integer): TFhirDeviceDefinitionCorrectiveAction;
begin
  result := TFhirDeviceDefinitionCorrectiveAction(ObjectByIndex[index]);
end;

function TFhirDeviceDefinitionCorrectiveActionList.Link: TFhirDeviceDefinitionCorrectiveActionList;
begin
  result := TFhirDeviceDefinitionCorrectiveActionList(inherited Link);
end;

procedure TFhirDeviceDefinitionCorrectiveActionList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirDeviceDefinitionCorrectiveActionList.SetItemByIndex(index: Integer; value: TFhirDeviceDefinitionCorrectiveAction);
begin
  assert(value is TFhirDeviceDefinitionCorrectiveAction);
  FhirDeviceDefinitionCorrectiveActions[index] := value;
end;

procedure TFhirDeviceDefinitionCorrectiveActionList.SetItemN(index: Integer; value: TFhirDeviceDefinitionCorrectiveAction);
begin
  assert(value is TFhirDeviceDefinitionCorrectiveAction);
  ObjectByIndex[index] := value;
end;

{ TFhirDeviceDefinitionChargeItem }

constructor TFhirDeviceDefinitionChargeItem.Create;
begin
  inherited;
end;

destructor TFhirDeviceDefinitionChargeItem.Destroy;
begin
  FChargeItemCode.free;
  FCount.free;
  FEffectivePeriod.free;
  FUseContextList.Free;
  inherited;
end;

procedure TFhirDeviceDefinitionChargeItem.Assign(oSource : TFslObject);
begin
  inherited;
  chargeItemCode := TFhirDeviceDefinitionChargeItem(oSource).chargeItemCode.Clone;
  count := TFhirDeviceDefinitionChargeItem(oSource).count.Clone;
  effectivePeriod := TFhirDeviceDefinitionChargeItem(oSource).effectivePeriod.Clone;
  if (TFhirDeviceDefinitionChargeItem(oSource).FUseContextList = nil) then
  begin
    FUseContextList.free;
    FUseContextList := nil;
  end
  else
  begin
    if FUseContextList = nil then
      FUseContextList := TFhirUsageContextList.Create;
    FUseContextList.Assign(TFhirDeviceDefinitionChargeItem(oSource).FUseContextList);
  end;
end;

procedure TFhirDeviceDefinitionChargeItem.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'chargeItemCode') Then
     list.add(self.link, 'chargeItemCode', FChargeItemCode.Link);
  if (child_name = 'count') Then
     list.add(self.link, 'count', FCount.Link);
  if (child_name = 'effectivePeriod') Then
     list.add(self.link, 'effectivePeriod', FEffectivePeriod.Link);
  if (child_name = 'useContext') Then
    list.addAll(self, 'useContext', FUseContextList);
end;

procedure TFhirDeviceDefinitionChargeItem.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'chargeItemCode', 'CodeableReference', false, TFhirCodeableReference, FChargeItemCode.Link));
  oList.add(TFHIRProperty.create(self, 'count', 'Quantity', false, TFhirQuantity, FCount.Link));
  oList.add(TFHIRProperty.create(self, 'effectivePeriod', 'Period', false, TFhirPeriod, FEffectivePeriod.Link));
  oList.add(TFHIRProperty.create(self, 'useContext', 'UsageContext', true, TFhirUsageContext, FUseContextList.Link));
end;

function TFhirDeviceDefinitionChargeItem.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'chargeItemCode') then
  begin
    ChargeItemCode := propValue as TFhirCodeableReference;
    result := propValue;
  end
  else if (propName = 'count') then
  begin
    Count := propValue as TFhirQuantity;
    result := propValue;
  end
  else if (propName = 'effectivePeriod') then
  begin
    EffectivePeriod := propValue as TFhirPeriod;
    result := propValue;
  end
  else if (propName = 'useContext') then
  begin
    UseContextList.add(propValue as TFhirUsageContext);
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirDeviceDefinitionChargeItem.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'useContext') then UseContextList.insertItem(index, propValue as TFhirUsageContext)
  else inherited;
end;

function TFhirDeviceDefinitionChargeItem.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'chargeItemCode') then result := TFhirCodeableReference.create()
  else if (propName = 'count') then result := TFhirQuantity.create()
  else if (propName = 'effectivePeriod') then result := TFhirPeriod.create()
  else if (propName = 'useContext') then result := UseContextList.new()
  else result := inherited createPropertyValue(propName);
end;

function TFhirDeviceDefinitionChargeItem.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'chargeItemCode') then result := 'CodeableReference'
  else if (propName = 'count') then result := 'Quantity'
  else if (propName = 'effectivePeriod') then result := 'Period'
  else if (propName = 'useContext') then result := 'UsageContext'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirDeviceDefinitionChargeItem.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'chargeItemCode') then ChargeItemCodeElement := nil
  else if (propName = 'count') then CountElement := nil
  else if (propName = 'effectivePeriod') then EffectivePeriodElement := nil
  else if (propName = 'useContext') then deletePropertyValue('useContext', UseContextList, value)
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirDeviceDefinitionChargeItem.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'chargeItemCode') then ChargeItemCodeElement := new as TFhirCodeableReference
  else if (propName = 'count') then CountElement := new as TFhirQuantity
  else if (propName = 'effectivePeriod') then EffectivePeriodElement := new as TFhirPeriod
  else if (propName = 'useContext') then replacePropertyValue('useContext', UseContextList, existing, new)
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirDeviceDefinitionChargeItem.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'useContext') then UseContextList.move(source, destination)
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirDeviceDefinitionChargeItem.fhirType : string;
begin
  result := 'DeviceDefinition.chargeItem';
end;

function TFhirDeviceDefinitionChargeItem.Link : TFhirDeviceDefinitionChargeItem;
begin
  result := TFhirDeviceDefinitionChargeItem(inherited Link);
end;

function TFhirDeviceDefinitionChargeItem.Clone : TFhirDeviceDefinitionChargeItem;
begin
  result := TFhirDeviceDefinitionChargeItem(inherited Clone);
end;

function TFhirDeviceDefinitionChargeItem.equals(other : TObject) : boolean; 
var
  o : TFhirDeviceDefinitionChargeItem;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirDeviceDefinitionChargeItem)) then
    result := false
  else
  begin
    o := TFhirDeviceDefinitionChargeItem(other);
    result := compareDeep(chargeItemCodeElement, o.chargeItemCodeElement, true) and 
      compareDeep(countElement, o.countElement, true) and compareDeep(effectivePeriodElement, o.effectivePeriodElement, true) and 
      compareDeep(useContextList, o.useContextList, true);
  end;
end;

function TFhirDeviceDefinitionChargeItem.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FChargeItemCode) and isEmptyProp(FCount) and isEmptyProp(FEffectivePeriod) and isEmptyProp(FuseContextList);
end;

procedure TFhirDeviceDefinitionChargeItem.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('chargeItemCode');
  fields.add('count');
  fields.add('effectivePeriod');
  fields.add('useContext');
end;

function TFhirDeviceDefinitionChargeItem.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
  inc(result, FUseContextList.sizeInBytes(magic));
end;

procedure TFhirDeviceDefinitionChargeItem.SetChargeItemCode(value : TFhirCodeableReference);
begin
  FChargeItemCode.free;
  FChargeItemCode := value;
end;

procedure TFhirDeviceDefinitionChargeItem.SetCount(value : TFhirQuantity);
begin
  FCount.free;
  FCount := value;
end;

procedure TFhirDeviceDefinitionChargeItem.SetEffectivePeriod(value : TFhirPeriod);
begin
  FEffectivePeriod.free;
  FEffectivePeriod := value;
end;

function TFhirDeviceDefinitionChargeItem.GetUseContextList : TFhirUsageContextList;
begin
  if FUseContextList = nil then
    FUseContextList := TFhirUsageContextList.Create;
  result := FUseContextList;
end;

function TFhirDeviceDefinitionChargeItem.GetHasUseContextList : boolean;
begin
  result := (FUseContextList <> nil) and (FUseContextList.count > 0);
end;

{ TFhirDeviceDefinitionChargeItemListEnumerator }

constructor TFhirDeviceDefinitionChargeItemListEnumerator.Create(list : TFhirDeviceDefinitionChargeItemList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirDeviceDefinitionChargeItemListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirDeviceDefinitionChargeItemListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirDeviceDefinitionChargeItemListEnumerator.GetCurrent : TFhirDeviceDefinitionChargeItem;
begin
  Result := FList[FIndex];
end;

function TFhirDeviceDefinitionChargeItemListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirDeviceDefinitionChargeItemList }

function TFhirDeviceDefinitionChargeItemList.AddItem(value: TFhirDeviceDefinitionChargeItem): TFhirDeviceDefinitionChargeItem;
begin
  assert(value.ClassName = 'TFhirDeviceDefinitionChargeItem', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirDeviceDefinitionChargeItem');
  add(value);
  result := value;
end;

function TFhirDeviceDefinitionChargeItemList.Append: TFhirDeviceDefinitionChargeItem;
begin
  result := TFhirDeviceDefinitionChargeItem.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirDeviceDefinitionChargeItemList.ClearItems;
begin
  Clear;
end;

function TFhirDeviceDefinitionChargeItemList.GetEnumerator : TFhirDeviceDefinitionChargeItemListEnumerator;
begin
  result := TFhirDeviceDefinitionChargeItemListEnumerator.Create(self.link);
end;

function TFhirDeviceDefinitionChargeItemList.Clone: TFhirDeviceDefinitionChargeItemList;
begin
  result := TFhirDeviceDefinitionChargeItemList(inherited Clone);
end;

function TFhirDeviceDefinitionChargeItemList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirDeviceDefinitionChargeItemList.GetItemN(index: Integer): TFhirDeviceDefinitionChargeItem;
begin
  result := TFhirDeviceDefinitionChargeItem(ObjectByIndex[index]);
end;

function TFhirDeviceDefinitionChargeItemList.ItemClass: TFslObjectClass;
begin
  result := TFhirDeviceDefinitionChargeItem;
end;
function TFhirDeviceDefinitionChargeItemList.IndexOf(value: TFhirDeviceDefinitionChargeItem): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirDeviceDefinitionChargeItemList.Insert(index: Integer): TFhirDeviceDefinitionChargeItem;
begin
  result := TFhirDeviceDefinitionChargeItem.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirDeviceDefinitionChargeItemList.InsertItem(index: Integer; value: TFhirDeviceDefinitionChargeItem);
begin
  assert(value is TFhirDeviceDefinitionChargeItem);
  Inherited Insert(index, value);
end;

function TFhirDeviceDefinitionChargeItemList.Item(index: Integer): TFhirDeviceDefinitionChargeItem;
begin
  result := TFhirDeviceDefinitionChargeItem(ObjectByIndex[index]);
end;

function TFhirDeviceDefinitionChargeItemList.Link: TFhirDeviceDefinitionChargeItemList;
begin
  result := TFhirDeviceDefinitionChargeItemList(inherited Link);
end;

procedure TFhirDeviceDefinitionChargeItemList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirDeviceDefinitionChargeItemList.SetItemByIndex(index: Integer; value: TFhirDeviceDefinitionChargeItem);
begin
  assert(value is TFhirDeviceDefinitionChargeItem);
  FhirDeviceDefinitionChargeItems[index] := value;
end;

procedure TFhirDeviceDefinitionChargeItemList.SetItemN(index: Integer; value: TFhirDeviceDefinitionChargeItem);
begin
  assert(value is TFhirDeviceDefinitionChargeItem);
  ObjectByIndex[index] := value;
end;

{ TFhirDeviceDefinition }

constructor TFhirDeviceDefinition.Create;
begin
  inherited;
end;

destructor TFhirDeviceDefinition.Destroy;
begin
  FDescription.free;
  FIdentifierList.Free;
  FUdiDeviceIdentifierList.Free;
  FRegulatoryIdentifierList.Free;
  FPartNumber.free;
  FManufacturer.free;
  FDeviceNameList.Free;
  FModelNumber.free;
  FClassificationList.Free;
  FSpecializationList.Free;
  FHasPartList.Free;
  FPackagingList.Free;
  FVersionList.Free;
  FSafetyList.Free;
  FShelfLifeStorageList.Free;
  FLanguageCodeList.Free;
  FProperty_List.Free;
  FOwner.free;
  FContactList.Free;
  FLink_List.Free;
  FNoteList.Free;
  FParentDevice.free;
  FMaterialList.Free;
  FProductionIdentifierInUDI.Free;
  FGuideline.free;
  FCorrectiveAction.free;
  FChargeItemList.Free;
  inherited;
end;

procedure TFhirDeviceDefinition.Assign(oSource : TFslObject);
begin
  inherited;
  descriptionElement := TFhirDeviceDefinition(oSource).descriptionElement.Clone;
  if (TFhirDeviceDefinition(oSource).FIdentifierList = nil) then
  begin
    FIdentifierList.free;
    FIdentifierList := nil;
  end
  else
  begin
    if FIdentifierList = nil then
      FIdentifierList := TFhirIdentifierList.Create;
    FIdentifierList.Assign(TFhirDeviceDefinition(oSource).FIdentifierList);
  end;
  if (TFhirDeviceDefinition(oSource).FUdiDeviceIdentifierList = nil) then
  begin
    FUdiDeviceIdentifierList.free;
    FUdiDeviceIdentifierList := nil;
  end
  else
  begin
    if FUdiDeviceIdentifierList = nil then
      FUdiDeviceIdentifierList := TFhirDeviceDefinitionUdiDeviceIdentifierList.Create;
    FUdiDeviceIdentifierList.Assign(TFhirDeviceDefinition(oSource).FUdiDeviceIdentifierList);
  end;
  if (TFhirDeviceDefinition(oSource).FRegulatoryIdentifierList = nil) then
  begin
    FRegulatoryIdentifierList.free;
    FRegulatoryIdentifierList := nil;
  end
  else
  begin
    if FRegulatoryIdentifierList = nil then
      FRegulatoryIdentifierList := TFhirDeviceDefinitionRegulatoryIdentifierList.Create;
    FRegulatoryIdentifierList.Assign(TFhirDeviceDefinition(oSource).FRegulatoryIdentifierList);
  end;
  partNumberElement := TFhirDeviceDefinition(oSource).partNumberElement.Clone;
  manufacturer := TFhirDeviceDefinition(oSource).manufacturer.Clone;
  if (TFhirDeviceDefinition(oSource).FDeviceNameList = nil) then
  begin
    FDeviceNameList.free;
    FDeviceNameList := nil;
  end
  else
  begin
    if FDeviceNameList = nil then
      FDeviceNameList := TFhirDeviceDefinitionDeviceNameList.Create;
    FDeviceNameList.Assign(TFhirDeviceDefinition(oSource).FDeviceNameList);
  end;
  modelNumberElement := TFhirDeviceDefinition(oSource).modelNumberElement.Clone;
  if (TFhirDeviceDefinition(oSource).FClassificationList = nil) then
  begin
    FClassificationList.free;
    FClassificationList := nil;
  end
  else
  begin
    if FClassificationList = nil then
      FClassificationList := TFhirDeviceDefinitionClassificationList.Create;
    FClassificationList.Assign(TFhirDeviceDefinition(oSource).FClassificationList);
  end;
  if (TFhirDeviceDefinition(oSource).FSpecializationList = nil) then
  begin
    FSpecializationList.free;
    FSpecializationList := nil;
  end
  else
  begin
    if FSpecializationList = nil then
      FSpecializationList := TFhirRelatedArtifactList.Create;
    FSpecializationList.Assign(TFhirDeviceDefinition(oSource).FSpecializationList);
  end;
  if (TFhirDeviceDefinition(oSource).FHasPartList = nil) then
  begin
    FHasPartList.free;
    FHasPartList := nil;
  end
  else
  begin
    if FHasPartList = nil then
      FHasPartList := TFhirDeviceDefinitionHasPartList.Create;
    FHasPartList.Assign(TFhirDeviceDefinition(oSource).FHasPartList);
  end;
  if (TFhirDeviceDefinition(oSource).FPackagingList = nil) then
  begin
    FPackagingList.free;
    FPackagingList := nil;
  end
  else
  begin
    if FPackagingList = nil then
      FPackagingList := TFhirDeviceDefinitionPackagingList.Create;
    FPackagingList.Assign(TFhirDeviceDefinition(oSource).FPackagingList);
  end;
  if (TFhirDeviceDefinition(oSource).FVersionList = nil) then
  begin
    FVersionList.free;
    FVersionList := nil;
  end
  else
  begin
    if FVersionList = nil then
      FVersionList := TFhirDeviceDefinitionVersionList.Create;
    FVersionList.Assign(TFhirDeviceDefinition(oSource).FVersionList);
  end;
  if (TFhirDeviceDefinition(oSource).FSafetyList = nil) then
  begin
    FSafetyList.free;
    FSafetyList := nil;
  end
  else
  begin
    if FSafetyList = nil then
      FSafetyList := TFhirCodeableConceptList.Create;
    FSafetyList.Assign(TFhirDeviceDefinition(oSource).FSafetyList);
  end;
  if (TFhirDeviceDefinition(oSource).FShelfLifeStorageList = nil) then
  begin
    FShelfLifeStorageList.free;
    FShelfLifeStorageList := nil;
  end
  else
  begin
    if FShelfLifeStorageList = nil then
      FShelfLifeStorageList := TFhirProductShelfLifeList.Create;
    FShelfLifeStorageList.Assign(TFhirDeviceDefinition(oSource).FShelfLifeStorageList);
  end;
  if (TFhirDeviceDefinition(oSource).FLanguageCodeList = nil) then
  begin
    FLanguageCodeList.free;
    FLanguageCodeList := nil;
  end
  else
  begin
    if FLanguageCodeList = nil then
      FLanguageCodeList := TFhirCodeableConceptList.Create;
    FLanguageCodeList.Assign(TFhirDeviceDefinition(oSource).FLanguageCodeList);
  end;
  if (TFhirDeviceDefinition(oSource).FProperty_List = nil) then
  begin
    FProperty_List.free;
    FProperty_List := nil;
  end
  else
  begin
    if FProperty_List = nil then
      FProperty_List := TFhirDeviceDefinitionPropertyList.Create;
    FProperty_List.Assign(TFhirDeviceDefinition(oSource).FProperty_List);
  end;
  owner := TFhirDeviceDefinition(oSource).owner.Clone;
  if (TFhirDeviceDefinition(oSource).FContactList = nil) then
  begin
    FContactList.free;
    FContactList := nil;
  end
  else
  begin
    if FContactList = nil then
      FContactList := TFhirContactPointList.Create;
    FContactList.Assign(TFhirDeviceDefinition(oSource).FContactList);
  end;
  if (TFhirDeviceDefinition(oSource).FLink_List = nil) then
  begin
    FLink_List.free;
    FLink_List := nil;
  end
  else
  begin
    if FLink_List = nil then
      FLink_List := TFhirDeviceDefinitionLinkList.Create;
    FLink_List.Assign(TFhirDeviceDefinition(oSource).FLink_List);
  end;
  if (TFhirDeviceDefinition(oSource).FNoteList = nil) then
  begin
    FNoteList.free;
    FNoteList := nil;
  end
  else
  begin
    if FNoteList = nil then
      FNoteList := TFhirAnnotationList.Create;
    FNoteList.Assign(TFhirDeviceDefinition(oSource).FNoteList);
  end;
  parentDevice := TFhirDeviceDefinition(oSource).parentDevice.Clone;
  if (TFhirDeviceDefinition(oSource).FMaterialList = nil) then
  begin
    FMaterialList.free;
    FMaterialList := nil;
  end
  else
  begin
    if FMaterialList = nil then
      FMaterialList := TFhirDeviceDefinitionMaterialList.Create;
    FMaterialList.Assign(TFhirDeviceDefinition(oSource).FMaterialList);
  end;
  if (TFhirDeviceDefinition(oSource).FProductionIdentifierInUDI = nil) then
  begin
    FProductionIdentifierInUDI.free;
    FProductionIdentifierInUDI := nil;
  end
  else
  begin
    FProductionIdentifierInUDI := TFhirEnumList.Create(SYSTEMS_TFhirDeviceProductionIdentifierInUDIEnum, CODES_TFhirDeviceProductionIdentifierInUDIEnum);
    FProductionIdentifierInUDI.Assign(TFhirDeviceDefinition(oSource).FProductionIdentifierInUDI);
  end;
  guideline := TFhirDeviceDefinition(oSource).guideline.Clone;
  correctiveAction := TFhirDeviceDefinition(oSource).correctiveAction.Clone;
  if (TFhirDeviceDefinition(oSource).FChargeItemList = nil) then
  begin
    FChargeItemList.free;
    FChargeItemList := nil;
  end
  else
  begin
    if FChargeItemList = nil then
      FChargeItemList := TFhirDeviceDefinitionChargeItemList.Create;
    FChargeItemList.Assign(TFhirDeviceDefinition(oSource).FChargeItemList);
  end;
end;

function TFhirDeviceDefinition.GetResourceType : TFhirResourceType;
begin
  result := frtDeviceDefinition;
end;

procedure TFhirDeviceDefinition.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'description') Then
     list.add(self.link, 'description', FDescription.Link);
  if (child_name = 'identifier') Then
    list.addAll(self, 'identifier', FIdentifierList);
  if (child_name = 'udiDeviceIdentifier') Then
    list.addAll(self, 'udiDeviceIdentifier', FUdiDeviceIdentifierList);
  if (child_name = 'regulatoryIdentifier') Then
    list.addAll(self, 'regulatoryIdentifier', FRegulatoryIdentifierList);
  if (child_name = 'partNumber') Then
     list.add(self.link, 'partNumber', FPartNumber.Link);
  if (child_name = 'manufacturer') Then
     list.add(self.link, 'manufacturer', FManufacturer.Link);
  if (child_name = 'deviceName') Then
    list.addAll(self, 'deviceName', FDeviceNameList);
  if (child_name = 'modelNumber') Then
     list.add(self.link, 'modelNumber', FModelNumber.Link);
  if (child_name = 'classification') Then
    list.addAll(self, 'classification', FClassificationList);
  if (child_name = 'specialization') Then
    list.addAll(self, 'specialization', FSpecializationList);
  if (child_name = 'hasPart') Then
    list.addAll(self, 'hasPart', FHasPartList);
  if (child_name = 'packaging') Then
    list.addAll(self, 'packaging', FPackagingList);
  if (child_name = 'version') Then
    list.addAll(self, 'version', FVersionList);
  if (child_name = 'safety') Then
    list.addAll(self, 'safety', FSafetyList);
  if (child_name = 'shelfLifeStorage') Then
    list.addAll(self, 'shelfLifeStorage', FShelfLifeStorageList);
  if (child_name = 'languageCode') Then
    list.addAll(self, 'languageCode', FLanguageCodeList);
  if (child_name = 'property') Then
    list.addAll(self, 'property', FProperty_List);
  if (child_name = 'owner') Then
     list.add(self.link, 'owner', FOwner.Link);
  if (child_name = 'contact') Then
    list.addAll(self, 'contact', FContactList);
  if (child_name = 'link') Then
    list.addAll(self, 'link', FLink_List);
  if (child_name = 'note') Then
    list.addAll(self, 'note', FNoteList);
  if (child_name = 'parentDevice') Then
     list.add(self.link, 'parentDevice', FParentDevice.Link);
  if (child_name = 'material') Then
    list.addAll(self, 'material', FMaterialList);
  if (child_name = 'productionIdentifierInUDI') Then
     list.addAll(self, 'productionIdentifierInUDI', FProductionIdentifierInUDI);
  if (child_name = 'guideline') Then
     list.add(self.link, 'guideline', FGuideline.Link);
  if (child_name = 'correctiveAction') Then
     list.add(self.link, 'correctiveAction', FCorrectiveAction.Link);
  if (child_name = 'chargeItem') Then
    list.addAll(self, 'chargeItem', FChargeItemList);
end;

procedure TFhirDeviceDefinition.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'description', 'markdown', false, TFhirMarkdown, FDescription.Link));
  oList.add(TFHIRProperty.create(self, 'identifier', 'Identifier', true, TFhirIdentifier, FIdentifierList.Link));
  oList.add(TFHIRProperty.create(self, 'udiDeviceIdentifier', 'BackboneElement', true, TFhirDeviceDefinitionUdiDeviceIdentifier, FUdiDeviceIdentifierList.Link));
  oList.add(TFHIRProperty.create(self, 'regulatoryIdentifier', 'BackboneElement', true, TFhirDeviceDefinitionRegulatoryIdentifier, FRegulatoryIdentifierList.Link));
  oList.add(TFHIRProperty.create(self, 'partNumber', 'string', false, TFhirString, FPartNumber.Link));
  oList.add(TFHIRProperty.create(self, 'manufacturer', 'Reference', false, TFhirReference, FManufacturer.Link));
  oList.add(TFHIRProperty.create(self, 'deviceName', 'BackboneElement', true, TFhirDeviceDefinitionDeviceName, FDeviceNameList.Link));
  oList.add(TFHIRProperty.create(self, 'modelNumber', 'string', false, TFhirString, FModelNumber.Link));
  oList.add(TFHIRProperty.create(self, 'classification', 'BackboneElement', true, TFhirDeviceDefinitionClassification, FClassificationList.Link));
  oList.add(TFHIRProperty.create(self, 'specialization', 'RelatedArtifact', true, TFhirRelatedArtifact, FSpecializationList.Link));
  oList.add(TFHIRProperty.create(self, 'hasPart', 'BackboneElement', true, TFhirDeviceDefinitionHasPart, FHasPartList.Link));
  oList.add(TFHIRProperty.create(self, 'packaging', 'BackboneElement', true, TFhirDeviceDefinitionPackaging, FPackagingList.Link));
  oList.add(TFHIRProperty.create(self, 'version', 'BackboneElement', true, TFhirDeviceDefinitionVersion, FVersionList.Link));
  oList.add(TFHIRProperty.create(self, 'safety', 'CodeableConcept', true, TFhirCodeableConcept, FSafetyList.Link));
  oList.add(TFHIRProperty.create(self, 'shelfLifeStorage', 'ProductShelfLife', true, TFhirProductShelfLife, FShelfLifeStorageList.Link));
  oList.add(TFHIRProperty.create(self, 'languageCode', 'CodeableConcept', true, TFhirCodeableConcept, FLanguageCodeList.Link));
  oList.add(TFHIRProperty.create(self, 'property', 'BackboneElement', true, TFhirDeviceDefinitionProperty, FProperty_List.Link));
  oList.add(TFHIRProperty.create(self, 'owner', 'Reference', false, TFhirReference, FOwner.Link));
  oList.add(TFHIRProperty.create(self, 'contact', 'ContactPoint', true, TFhirContactPoint, FContactList.Link));
  oList.add(TFHIRProperty.create(self, 'link', 'BackboneElement', true, TFhirDeviceDefinitionLink, FLink_List.Link));
  oList.add(TFHIRProperty.create(self, 'note', 'Annotation', true, TFhirAnnotation, FNoteList.Link));
  oList.add(TFHIRProperty.create(self, 'parentDevice', 'Reference', false, TFhirReference, FParentDevice.Link));
  oList.add(TFHIRProperty.create(self, 'material', 'BackboneElement', true, TFhirDeviceDefinitionMaterial, FMaterialList.Link));
  oList.add(TFHIRProperty.create(self, 'productionIdentifierInUDI', 'code', true, TFhirEnum, FProductionIdentifierInUDI.Link));
  oList.add(TFHIRProperty.create(self, 'guideline', 'BackboneElement', false, TFhirDeviceDefinitionGuideline, FGuideline.Link));
  oList.add(TFHIRProperty.create(self, 'correctiveAction', 'BackboneElement', false, TFhirDeviceDefinitionCorrectiveAction, FCorrectiveAction.Link));
  oList.add(TFHIRProperty.create(self, 'chargeItem', 'BackboneElement', true, TFhirDeviceDefinitionChargeItem, FChargeItemList.Link));
end;

function TFhirDeviceDefinition.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'description') then
  begin
    DescriptionElement := asMarkdown(propValue);
    result := propValue;
  end
  else if (propName = 'identifier') then
  begin
    IdentifierList.add(propValue as TFhirIdentifier);
    result := propValue;
  end
  else if (propName = 'udiDeviceIdentifier') then
  begin
    UdiDeviceIdentifierList.add(propValue as TFhirDeviceDefinitionUdiDeviceIdentifier);
    result := propValue;
  end
  else if (propName = 'regulatoryIdentifier') then
  begin
    RegulatoryIdentifierList.add(propValue as TFhirDeviceDefinitionRegulatoryIdentifier);
    result := propValue;
  end
  else if (propName = 'partNumber') then
  begin
    PartNumberElement := asString(propValue);
    result := propValue;
  end
  else if (propName = 'manufacturer') then
  begin
    Manufacturer := propValue as TFhirReference;
    result := propValue;
  end
  else if (propName = 'deviceName') then
  begin
    DeviceNameList.add(propValue as TFhirDeviceDefinitionDeviceName);
    result := propValue;
  end
  else if (propName = 'modelNumber') then
  begin
    ModelNumberElement := asString(propValue);
    result := propValue;
  end
  else if (propName = 'classification') then
  begin
    ClassificationList.add(propValue as TFhirDeviceDefinitionClassification);
    result := propValue;
  end
  else if (propName = 'specialization') then
  begin
    SpecializationList.add(propValue as TFhirRelatedArtifact);
    result := propValue;
  end
  else if (propName = 'hasPart') then
  begin
    HasPartList.add(propValue as TFhirDeviceDefinitionHasPart);
    result := propValue;
  end
  else if (propName = 'packaging') then
  begin
    PackagingList.add(propValue as TFhirDeviceDefinitionPackaging);
    result := propValue;
  end
  else if (propName = 'version') then
  begin
    VersionList.add(propValue as TFhirDeviceDefinitionVersion);
    result := propValue;
  end
  else if (propName = 'safety') then
  begin
    SafetyList.add(propValue as TFhirCodeableConcept);
    result := propValue;
  end
  else if (propName = 'shelfLifeStorage') then
  begin
    ShelfLifeStorageList.add(propValue as TFhirProductShelfLife);
    result := propValue;
  end
  else if (propName = 'languageCode') then
  begin
    LanguageCodeList.add(propValue as TFhirCodeableConcept);
    result := propValue;
  end
  else if (propName = 'property') then
  begin
    Property_List.add(propValue as TFhirDeviceDefinitionProperty);
    result := propValue;
  end
  else if (propName = 'owner') then
  begin
    Owner := propValue as TFhirReference;
    result := propValue;
  end
  else if (propName = 'contact') then
  begin
    ContactList.add(propValue as TFhirContactPoint);
    result := propValue;
  end
  else if (propName = 'link') then
  begin
    Link_List.add(propValue as TFhirDeviceDefinitionLink);
    result := propValue;
  end
  else if (propName = 'note') then
  begin
    NoteList.add(propValue as TFhirAnnotation);
    result := propValue;
  end
  else if (propName = 'parentDevice') then
  begin
    ParentDevice := propValue as TFhirReference;
    result := propValue;
  end
  else if (propName = 'material') then
  begin
    MaterialList.add(propValue as TFhirDeviceDefinitionMaterial);
    result := propValue;
  end
  else if (propName = 'productionIdentifierInUDI') then
  begin
    ProductionIdentifierInUDIList.add(asEnum(SYSTEMS_TFhirDeviceProductionIdentifierInUDIEnum, CODES_TFhirDeviceProductionIdentifierInUDIEnum, propValue));
    result := propValue;
  end
  else if (propName = 'guideline') then
  begin
    Guideline := propValue as TFhirDeviceDefinitionGuideline;
    result := propValue;
  end
  else if (propName = 'correctiveAction') then
  begin
    CorrectiveAction := propValue as TFhirDeviceDefinitionCorrectiveAction;
    result := propValue;
  end
  else if (propName = 'chargeItem') then
  begin
    ChargeItemList.add(propValue as TFhirDeviceDefinitionChargeItem);
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirDeviceDefinition.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'identifier') then IdentifierList.insertItem(index, propValue as TFhirIdentifier)
  else if (propName = 'udiDeviceIdentifier') then UdiDeviceIdentifierList.insertItem(index, propValue as TFhirDeviceDefinitionUdiDeviceIdentifier)
  else if (propName = 'regulatoryIdentifier') then RegulatoryIdentifierList.insertItem(index, propValue as TFhirDeviceDefinitionRegulatoryIdentifier)
  else if (propName = 'deviceName') then DeviceNameList.insertItem(index, propValue as TFhirDeviceDefinitionDeviceName)
  else if (propName = 'classification') then ClassificationList.insertItem(index, propValue as TFhirDeviceDefinitionClassification)
  else if (propName = 'specialization') then SpecializationList.insertItem(index, propValue as TFhirRelatedArtifact)
  else if (propName = 'hasPart') then HasPartList.insertItem(index, propValue as TFhirDeviceDefinitionHasPart)
  else if (propName = 'packaging') then PackagingList.insertItem(index, propValue as TFhirDeviceDefinitionPackaging)
  else if (propName = 'version') then VersionList.insertItem(index, propValue as TFhirDeviceDefinitionVersion)
  else if (propName = 'safety') then SafetyList.insertItem(index, propValue as TFhirCodeableConcept)
  else if (propName = 'shelfLifeStorage') then ShelfLifeStorageList.insertItem(index, propValue as TFhirProductShelfLife)
  else if (propName = 'languageCode') then LanguageCodeList.insertItem(index, propValue as TFhirCodeableConcept)
  else if (propName = 'property') then Property_List.insertItem(index, propValue as TFhirDeviceDefinitionProperty)
  else if (propName = 'contact') then ContactList.insertItem(index, propValue as TFhirContactPoint)
  else if (propName = 'link') then Link_List.insertItem(index, propValue as TFhirDeviceDefinitionLink)
  else if (propName = 'note') then NoteList.insertItem(index, propValue as TFhirAnnotation)
  else if (propName = 'material') then MaterialList.insertItem(index, propValue as TFhirDeviceDefinitionMaterial)
  else if (propName = 'productionIdentifierInUDI') then FProductionIdentifierInUDI.insertItem(index, asEnum(SYSTEMS_TFhirDeviceProductionIdentifierInUDIEnum, CODES_TFhirDeviceProductionIdentifierInUDIEnum, propValue))
  else if (propName = 'chargeItem') then ChargeItemList.insertItem(index, propValue as TFhirDeviceDefinitionChargeItem)
  else inherited;
end;

function TFhirDeviceDefinition.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'description') then result := TFhirMarkdown.create()
  else if (propName = 'identifier') then result := IdentifierList.new()
  else if (propName = 'udiDeviceIdentifier') then result := UdiDeviceIdentifierList.new()
  else if (propName = 'regulatoryIdentifier') then result := RegulatoryIdentifierList.new()
  else if (propName = 'partNumber') then result := TFhirString.create()
  else if (propName = 'manufacturer') then result := TFhirReference.create()
  else if (propName = 'deviceName') then result := DeviceNameList.new()
  else if (propName = 'modelNumber') then result := TFhirString.create()
  else if (propName = 'classification') then result := ClassificationList.new()
  else if (propName = 'specialization') then result := SpecializationList.new()
  else if (propName = 'hasPart') then result := HasPartList.new()
  else if (propName = 'packaging') then result := PackagingList.new()
  else if (propName = 'version') then result := VersionList.new()
  else if (propName = 'safety') then result := SafetyList.new()
  else if (propName = 'shelfLifeStorage') then result := ShelfLifeStorageList.new()
  else if (propName = 'languageCode') then result := LanguageCodeList.new()
  else if (propName = 'property') then result := Property_List.new()
  else if (propName = 'owner') then result := TFhirReference.create()
  else if (propName = 'contact') then result := ContactList.new()
  else if (propName = 'link') then result := Link_List.new()
  else if (propName = 'note') then result := NoteList.new()
  else if (propName = 'parentDevice') then result := TFhirReference.create()
  else if (propName = 'material') then result := MaterialList.new()
  else if (propName = 'guideline') then result := TFhirDeviceDefinitionGuideline.create()
  else if (propName = 'correctiveAction') then result := TFhirDeviceDefinitionCorrectiveAction.create()
  else if (propName = 'chargeItem') then result := ChargeItemList.new()
  else result := inherited createPropertyValue(propName);
end;

function TFhirDeviceDefinition.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'description') then result := 'markdown'
  else if (propName = 'identifier') then result := 'Identifier'
  else if (propName = 'udiDeviceIdentifier') then result := 'BackboneElement'
  else if (propName = 'regulatoryIdentifier') then result := 'BackboneElement'
  else if (propName = 'partNumber') then result := 'string'
  else if (propName = 'manufacturer') then result := 'Reference'
  else if (propName = 'deviceName') then result := 'BackboneElement'
  else if (propName = 'modelNumber') then result := 'string'
  else if (propName = 'classification') then result := 'BackboneElement'
  else if (propName = 'specialization') then result := 'RelatedArtifact'
  else if (propName = 'hasPart') then result := 'BackboneElement'
  else if (propName = 'packaging') then result := 'BackboneElement'
  else if (propName = 'version') then result := 'BackboneElement'
  else if (propName = 'safety') then result := 'CodeableConcept'
  else if (propName = 'shelfLifeStorage') then result := 'ProductShelfLife'
  else if (propName = 'languageCode') then result := 'CodeableConcept'
  else if (propName = 'property') then result := 'BackboneElement'
  else if (propName = 'owner') then result := 'Reference'
  else if (propName = 'contact') then result := 'ContactPoint'
  else if (propName = 'link') then result := 'BackboneElement'
  else if (propName = 'note') then result := 'Annotation'
  else if (propName = 'parentDevice') then result := 'Reference'
  else if (propName = 'material') then result := 'BackboneElement'
  else if (propName = 'productionIdentifierInUDI') then result := 'code'
  else if (propName = 'guideline') then result := 'BackboneElement'
  else if (propName = 'correctiveAction') then result := 'BackboneElement'
  else if (propName = 'chargeItem') then result := 'BackboneElement'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirDeviceDefinition.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'description') then DescriptionElement := nil
  else if (propName = 'identifier') then deletePropertyValue('identifier', IdentifierList, value)
  else if (propName = 'udiDeviceIdentifier') then deletePropertyValue('udiDeviceIdentifier', UdiDeviceIdentifierList, value)
  else if (propName = 'regulatoryIdentifier') then deletePropertyValue('regulatoryIdentifier', RegulatoryIdentifierList, value)
  else if (propName = 'partNumber') then PartNumberElement := nil
  else if (propName = 'manufacturer') then ManufacturerElement := nil
  else if (propName = 'deviceName') then deletePropertyValue('deviceName', DeviceNameList, value)
  else if (propName = 'modelNumber') then ModelNumberElement := nil
  else if (propName = 'classification') then deletePropertyValue('classification', ClassificationList, value)
  else if (propName = 'specialization') then deletePropertyValue('specialization', SpecializationList, value)
  else if (propName = 'hasPart') then deletePropertyValue('hasPart', HasPartList, value)
  else if (propName = 'packaging') then deletePropertyValue('packaging', PackagingList, value)
  else if (propName = 'version') then deletePropertyValue('version', VersionList, value)
  else if (propName = 'safety') then deletePropertyValue('safety', SafetyList, value)
  else if (propName = 'shelfLifeStorage') then deletePropertyValue('shelfLifeStorage', ShelfLifeStorageList, value)
  else if (propName = 'languageCode') then deletePropertyValue('languageCode', LanguageCodeList, value)
  else if (propName = 'property') then deletePropertyValue('property', Property_List, value)
  else if (propName = 'owner') then OwnerElement := nil
  else if (propName = 'contact') then deletePropertyValue('contact', ContactList, value)
  else if (propName = 'link') then deletePropertyValue('link', Link_List, value)
  else if (propName = 'note') then deletePropertyValue('note', NoteList, value)
  else if (propName = 'parentDevice') then ParentDeviceElement := nil
  else if (propName = 'material') then deletePropertyValue('material', MaterialList, value)
  else if (propName = 'guideline') then GuidelineElement := nil
  else if (propName = 'correctiveAction') then CorrectiveActionElement := nil
  else if (propName = 'chargeItem') then deletePropertyValue('chargeItem', ChargeItemList, value)
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirDeviceDefinition.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'description') then DescriptionElement := asMarkdown(new)
  else if (propName = 'identifier') then replacePropertyValue('identifier', IdentifierList, existing, new)
  else if (propName = 'udiDeviceIdentifier') then replacePropertyValue('udiDeviceIdentifier', UdiDeviceIdentifierList, existing, new)
  else if (propName = 'regulatoryIdentifier') then replacePropertyValue('regulatoryIdentifier', RegulatoryIdentifierList, existing, new)
  else if (propName = 'partNumber') then PartNumberElement := asString(new)
  else if (propName = 'manufacturer') then ManufacturerElement := new as TFhirReference
  else if (propName = 'deviceName') then replacePropertyValue('deviceName', DeviceNameList, existing, new)
  else if (propName = 'modelNumber') then ModelNumberElement := asString(new)
  else if (propName = 'classification') then replacePropertyValue('classification', ClassificationList, existing, new)
  else if (propName = 'specialization') then replacePropertyValue('specialization', SpecializationList, existing, new)
  else if (propName = 'hasPart') then replacePropertyValue('hasPart', HasPartList, existing, new)
  else if (propName = 'packaging') then replacePropertyValue('packaging', PackagingList, existing, new)
  else if (propName = 'version') then replacePropertyValue('version', VersionList, existing, new)
  else if (propName = 'safety') then replacePropertyValue('safety', SafetyList, existing, new)
  else if (propName = 'shelfLifeStorage') then replacePropertyValue('shelfLifeStorage', ShelfLifeStorageList, existing, new)
  else if (propName = 'languageCode') then replacePropertyValue('languageCode', LanguageCodeList, existing, new)
  else if (propName = 'property') then replacePropertyValue('property', Property_List, existing, new)
  else if (propName = 'owner') then OwnerElement := new as TFhirReference
  else if (propName = 'contact') then replacePropertyValue('contact', ContactList, existing, new)
  else if (propName = 'link') then replacePropertyValue('link', Link_List, existing, new)
  else if (propName = 'note') then replacePropertyValue('note', NoteList, existing, new)
  else if (propName = 'parentDevice') then ParentDeviceElement := new as TFhirReference
  else if (propName = 'material') then replacePropertyValue('material', MaterialList, existing, new)
  else if (propName = 'guideline') then GuidelineElement := new as TFhirDeviceDefinitionGuideline
  else if (propName = 'correctiveAction') then CorrectiveActionElement := new as TFhirDeviceDefinitionCorrectiveAction
  else if (propName = 'chargeItem') then replacePropertyValue('chargeItem', ChargeItemList, existing, new)
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirDeviceDefinition.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'identifier') then IdentifierList.move(source, destination)
  else if (propName = 'udiDeviceIdentifier') then UdiDeviceIdentifierList.move(source, destination)
  else if (propName = 'regulatoryIdentifier') then RegulatoryIdentifierList.move(source, destination)
  else if (propName = 'deviceName') then DeviceNameList.move(source, destination)
  else if (propName = 'classification') then ClassificationList.move(source, destination)
  else if (propName = 'specialization') then SpecializationList.move(source, destination)
  else if (propName = 'hasPart') then HasPartList.move(source, destination)
  else if (propName = 'packaging') then PackagingList.move(source, destination)
  else if (propName = 'version') then VersionList.move(source, destination)
  else if (propName = 'safety') then SafetyList.move(source, destination)
  else if (propName = 'shelfLifeStorage') then ShelfLifeStorageList.move(source, destination)
  else if (propName = 'languageCode') then LanguageCodeList.move(source, destination)
  else if (propName = 'property') then Property_List.move(source, destination)
  else if (propName = 'contact') then ContactList.move(source, destination)
  else if (propName = 'link') then Link_List.move(source, destination)
  else if (propName = 'note') then NoteList.move(source, destination)
  else if (propName = 'material') then MaterialList.move(source, destination)
  else if (propName = 'productionIdentifierInUDI') then FProductionIdentifierInUDI.move(source, destination)
  else if (propName = 'chargeItem') then ChargeItemList.move(source, destination)
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirDeviceDefinition.fhirType : string;
begin
  result := 'DeviceDefinition';
end;

function TFhirDeviceDefinition.Link : TFhirDeviceDefinition;
begin
  result := TFhirDeviceDefinition(inherited Link);
end;

function TFhirDeviceDefinition.Clone : TFhirDeviceDefinition;
begin
  result := TFhirDeviceDefinition(inherited Clone);
end;

function TFhirDeviceDefinition.equals(other : TObject) : boolean; 
var
  o : TFhirDeviceDefinition;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirDeviceDefinition)) then
    result := false
  else
  begin
    o := TFhirDeviceDefinition(other);
    result := compareDeep(descriptionElement, o.descriptionElement, true) and compareDeep(identifierList, o.identifierList, true) and 
      compareDeep(udiDeviceIdentifierList, o.udiDeviceIdentifierList, true) and compareDeep(regulatoryIdentifierList, o.regulatoryIdentifierList, true) and 
      compareDeep(partNumberElement, o.partNumberElement, true) and compareDeep(manufacturerElement, o.manufacturerElement, true) and 
      compareDeep(deviceNameList, o.deviceNameList, true) and compareDeep(modelNumberElement, o.modelNumberElement, true) and 
      compareDeep(classificationList, o.classificationList, true) and compareDeep(specializationList, o.specializationList, true) and 
      compareDeep(hasPartList, o.hasPartList, true) and compareDeep(packagingList, o.packagingList, true) and 
      compareDeep(versionList, o.versionList, true) and compareDeep(safetyList, o.safetyList, true) and 
      compareDeep(shelfLifeStorageList, o.shelfLifeStorageList, true) and compareDeep(languageCodeList, o.languageCodeList, true) and 
      compareDeep(property_List, o.property_List, true) and compareDeep(ownerElement, o.ownerElement, true) and 
      compareDeep(contactList, o.contactList, true) and compareDeep(link_List, o.link_List, true) and 
      compareDeep(noteList, o.noteList, true) and compareDeep(parentDeviceElement, o.parentDeviceElement, true) and 
      compareDeep(materialList, o.materialList, true) and compareDeep(productionIdentifierInUDIList, o.productionIdentifierInUDIList, true) and 
      compareDeep(guidelineElement, o.guidelineElement, true) and compareDeep(correctiveActionElement, o.correctiveActionElement, true) and 
      compareDeep(chargeItemList, o.chargeItemList, true);
  end;
end;

function TFhirDeviceDefinition.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FDescription) and isEmptyProp(FidentifierList) and isEmptyProp(FudiDeviceIdentifierList) and isEmptyProp(FregulatoryIdentifierList) and isEmptyProp(FPartNumber) and isEmptyProp(FManufacturer) and isEmptyProp(FdeviceNameList) and isEmptyProp(FModelNumber) and isEmptyProp(FclassificationList) and isEmptyProp(FspecializationList) and isEmptyProp(FhasPartList) and isEmptyProp(FpackagingList) and isEmptyProp(FversionList) and isEmptyProp(FsafetyList) and isEmptyProp(FshelfLifeStorageList) and isEmptyProp(FlanguageCodeList) and isEmptyProp(Fproperty_List) and isEmptyProp(FOwner) and isEmptyProp(FcontactList) and isEmptyProp(Flink_List) and isEmptyProp(FnoteList) and isEmptyProp(FParentDevice) and isEmptyProp(FmaterialList) and isEmptyProp(FProductionIdentifierInUDI) and isEmptyProp(FGuideline) and isEmptyProp(FCorrectiveAction) and isEmptyProp(FchargeItemList);
end;

procedure TFhirDeviceDefinition.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('description');
  fields.add('identifier');
  fields.add('udiDeviceIdentifier');
  fields.add('regulatoryIdentifier');
  fields.add('partNumber');
  fields.add('manufacturer');
  fields.add('deviceName');
  fields.add('modelNumber');
  fields.add('classification');
  fields.add('specialization');
  fields.add('hasPart');
  fields.add('packaging');
  fields.add('version');
  fields.add('safety');
  fields.add('shelfLifeStorage');
  fields.add('languageCode');
  fields.add('property');
  fields.add('owner');
  fields.add('contact');
  fields.add('link');
  fields.add('note');
  fields.add('parentDevice');
  fields.add('material');
  fields.add('productionIdentifierInUDI');
  fields.add('guideline');
  fields.add('correctiveAction');
  fields.add('chargeItem');
end;

function TFhirDeviceDefinition.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
  inc(result, FIdentifierList.sizeInBytes(magic));
  inc(result, FUdiDeviceIdentifierList.sizeInBytes(magic));
  inc(result, FRegulatoryIdentifierList.sizeInBytes(magic));
  inc(result, FDeviceNameList.sizeInBytes(magic));
  inc(result, FClassificationList.sizeInBytes(magic));
  inc(result, FSpecializationList.sizeInBytes(magic));
  inc(result, FHasPartList.sizeInBytes(magic));
  inc(result, FPackagingList.sizeInBytes(magic));
  inc(result, FVersionList.sizeInBytes(magic));
  inc(result, FSafetyList.sizeInBytes(magic));
  inc(result, FShelfLifeStorageList.sizeInBytes(magic));
  inc(result, FLanguageCodeList.sizeInBytes(magic));
  inc(result, FProperty_List.sizeInBytes(magic));
  inc(result, FContactList.sizeInBytes(magic));
  inc(result, FLink_List.sizeInBytes(magic));
  inc(result, FNoteList.sizeInBytes(magic));
  inc(result, FMaterialList.sizeInBytes(magic));
  inc(result, FProductionIdentifierInUDI.sizeInBytes(magic));
  inc(result, FChargeItemList.sizeInBytes(magic));
end;

procedure TFhirDeviceDefinition.SetDescription(value : TFhirMarkdown);
begin
  FDescription.free;
  FDescription := value;
end;

function TFhirDeviceDefinition.GetDescriptionST : String;
begin
  if FDescription = nil then
    result := ''
  else
    result := FDescription.value;
end;

procedure TFhirDeviceDefinition.SetDescriptionST(value : String);
begin
  if value <> '' then
  begin
    if FDescription = nil then
      FDescription := TFhirMarkdown.create;
    FDescription.value := value
  end
  else if FDescription <> nil then
    FDescription.value := '';
end;

function TFhirDeviceDefinition.GetIdentifierList : TFhirIdentifierList;
begin
  if FIdentifierList = nil then
    FIdentifierList := TFhirIdentifierList.Create;
  result := FIdentifierList;
end;

function TFhirDeviceDefinition.GetHasIdentifierList : boolean;
begin
  result := (FIdentifierList <> nil) and (FIdentifierList.count > 0);
end;

function TFhirDeviceDefinition.GetUdiDeviceIdentifierList : TFhirDeviceDefinitionUdiDeviceIdentifierList;
begin
  if FUdiDeviceIdentifierList = nil then
    FUdiDeviceIdentifierList := TFhirDeviceDefinitionUdiDeviceIdentifierList.Create;
  result := FUdiDeviceIdentifierList;
end;

function TFhirDeviceDefinition.GetHasUdiDeviceIdentifierList : boolean;
begin
  result := (FUdiDeviceIdentifierList <> nil) and (FUdiDeviceIdentifierList.count > 0);
end;

function TFhirDeviceDefinition.GetRegulatoryIdentifierList : TFhirDeviceDefinitionRegulatoryIdentifierList;
begin
  if FRegulatoryIdentifierList = nil then
    FRegulatoryIdentifierList := TFhirDeviceDefinitionRegulatoryIdentifierList.Create;
  result := FRegulatoryIdentifierList;
end;

function TFhirDeviceDefinition.GetHasRegulatoryIdentifierList : boolean;
begin
  result := (FRegulatoryIdentifierList <> nil) and (FRegulatoryIdentifierList.count > 0);
end;

procedure TFhirDeviceDefinition.SetPartNumber(value : TFhirString);
begin
  FPartNumber.free;
  FPartNumber := value;
end;

function TFhirDeviceDefinition.GetPartNumberST : String;
begin
  if FPartNumber = nil then
    result := ''
  else
    result := FPartNumber.value;
end;

procedure TFhirDeviceDefinition.SetPartNumberST(value : String);
begin
  if value <> '' then
  begin
    if FPartNumber = nil then
      FPartNumber := TFhirString.create;
    FPartNumber.value := value
  end
  else if FPartNumber <> nil then
    FPartNumber.value := '';
end;

procedure TFhirDeviceDefinition.SetManufacturer(value : TFhirReference);
begin
  FManufacturer.free;
  FManufacturer := value;
end;

function TFhirDeviceDefinition.GetDeviceNameList : TFhirDeviceDefinitionDeviceNameList;
begin
  if FDeviceNameList = nil then
    FDeviceNameList := TFhirDeviceDefinitionDeviceNameList.Create;
  result := FDeviceNameList;
end;

function TFhirDeviceDefinition.GetHasDeviceNameList : boolean;
begin
  result := (FDeviceNameList <> nil) and (FDeviceNameList.count > 0);
end;

procedure TFhirDeviceDefinition.SetModelNumber(value : TFhirString);
begin
  FModelNumber.free;
  FModelNumber := value;
end;

function TFhirDeviceDefinition.GetModelNumberST : String;
begin
  if FModelNumber = nil then
    result := ''
  else
    result := FModelNumber.value;
end;

procedure TFhirDeviceDefinition.SetModelNumberST(value : String);
begin
  if value <> '' then
  begin
    if FModelNumber = nil then
      FModelNumber := TFhirString.create;
    FModelNumber.value := value
  end
  else if FModelNumber <> nil then
    FModelNumber.value := '';
end;

function TFhirDeviceDefinition.GetClassificationList : TFhirDeviceDefinitionClassificationList;
begin
  if FClassificationList = nil then
    FClassificationList := TFhirDeviceDefinitionClassificationList.Create;
  result := FClassificationList;
end;

function TFhirDeviceDefinition.GetHasClassificationList : boolean;
begin
  result := (FClassificationList <> nil) and (FClassificationList.count > 0);
end;

function TFhirDeviceDefinition.GetSpecializationList : TFhirRelatedArtifactList;
begin
  if FSpecializationList = nil then
    FSpecializationList := TFhirRelatedArtifactList.Create;
  result := FSpecializationList;
end;

function TFhirDeviceDefinition.GetHasSpecializationList : boolean;
begin
  result := (FSpecializationList <> nil) and (FSpecializationList.count > 0);
end;

function TFhirDeviceDefinition.GetHasPartList : TFhirDeviceDefinitionHasPartList;
begin
  if FHasPartList = nil then
    FHasPartList := TFhirDeviceDefinitionHasPartList.Create;
  result := FHasPartList;
end;

function TFhirDeviceDefinition.GetHasHasPartList : boolean;
begin
  result := (FHasPartList <> nil) and (FHasPartList.count > 0);
end;

function TFhirDeviceDefinition.GetPackagingList : TFhirDeviceDefinitionPackagingList;
begin
  if FPackagingList = nil then
    FPackagingList := TFhirDeviceDefinitionPackagingList.Create;
  result := FPackagingList;
end;

function TFhirDeviceDefinition.GetHasPackagingList : boolean;
begin
  result := (FPackagingList <> nil) and (FPackagingList.count > 0);
end;

function TFhirDeviceDefinition.GetVersionList : TFhirDeviceDefinitionVersionList;
begin
  if FVersionList = nil then
    FVersionList := TFhirDeviceDefinitionVersionList.Create;
  result := FVersionList;
end;

function TFhirDeviceDefinition.GetHasVersionList : boolean;
begin
  result := (FVersionList <> nil) and (FVersionList.count > 0);
end;

function TFhirDeviceDefinition.GetSafetyList : TFhirCodeableConceptList;
begin
  if FSafetyList = nil then
    FSafetyList := TFhirCodeableConceptList.Create;
  result := FSafetyList;
end;

function TFhirDeviceDefinition.GetHasSafetyList : boolean;
begin
  result := (FSafetyList <> nil) and (FSafetyList.count > 0);
end;

function TFhirDeviceDefinition.GetShelfLifeStorageList : TFhirProductShelfLifeList;
begin
  if FShelfLifeStorageList = nil then
    FShelfLifeStorageList := TFhirProductShelfLifeList.Create;
  result := FShelfLifeStorageList;
end;

function TFhirDeviceDefinition.GetHasShelfLifeStorageList : boolean;
begin
  result := (FShelfLifeStorageList <> nil) and (FShelfLifeStorageList.count > 0);
end;

function TFhirDeviceDefinition.GetLanguageCodeList : TFhirCodeableConceptList;
begin
  if FLanguageCodeList = nil then
    FLanguageCodeList := TFhirCodeableConceptList.Create;
  result := FLanguageCodeList;
end;

function TFhirDeviceDefinition.GetHasLanguageCodeList : boolean;
begin
  result := (FLanguageCodeList <> nil) and (FLanguageCodeList.count > 0);
end;

function TFhirDeviceDefinition.GetProperty_List : TFhirDeviceDefinitionPropertyList;
begin
  if FProperty_List = nil then
    FProperty_List := TFhirDeviceDefinitionPropertyList.Create;
  result := FProperty_List;
end;

function TFhirDeviceDefinition.GetHasProperty_List : boolean;
begin
  result := (FProperty_List <> nil) and (FProperty_List.count > 0);
end;

procedure TFhirDeviceDefinition.SetOwner(value : TFhirReference);
begin
  FOwner.free;
  FOwner := value;
end;

function TFhirDeviceDefinition.GetContactList : TFhirContactPointList;
begin
  if FContactList = nil then
    FContactList := TFhirContactPointList.Create;
  result := FContactList;
end;

function TFhirDeviceDefinition.GetHasContactList : boolean;
begin
  result := (FContactList <> nil) and (FContactList.count > 0);
end;

function TFhirDeviceDefinition.GetLink_List : TFhirDeviceDefinitionLinkList;
begin
  if FLink_List = nil then
    FLink_List := TFhirDeviceDefinitionLinkList.Create;
  result := FLink_List;
end;

function TFhirDeviceDefinition.GetHasLink_List : boolean;
begin
  result := (FLink_List <> nil) and (FLink_List.count > 0);
end;

function TFhirDeviceDefinition.GetNoteList : TFhirAnnotationList;
begin
  if FNoteList = nil then
    FNoteList := TFhirAnnotationList.Create;
  result := FNoteList;
end;

function TFhirDeviceDefinition.GetHasNoteList : boolean;
begin
  result := (FNoteList <> nil) and (FNoteList.count > 0);
end;

procedure TFhirDeviceDefinition.SetParentDevice(value : TFhirReference);
begin
  FParentDevice.free;
  FParentDevice := value;
end;

function TFhirDeviceDefinition.GetMaterialList : TFhirDeviceDefinitionMaterialList;
begin
  if FMaterialList = nil then
    FMaterialList := TFhirDeviceDefinitionMaterialList.Create;
  result := FMaterialList;
end;

function TFhirDeviceDefinition.GetHasMaterialList : boolean;
begin
  result := (FMaterialList <> nil) and (FMaterialList.count > 0);
end;

function TFhirDeviceDefinition.GetProductionIdentifierInUDI : TFhirEnumList;
begin
  if FProductionIdentifierInUDI = nil then
    FProductionIdentifierInUDI := TFhirEnumList.Create(SYSTEMS_TFhirDeviceProductionIdentifierInUDIEnum, CODES_TFhirDeviceProductionIdentifierInUDIEnum);
  result := FProductionIdentifierInUDI;
end;

function TFhirDeviceDefinition.GetHasProductionIdentifierInUDI : boolean;
begin
  result := (FProductionIdentifierInUDI <> nil) and (FProductionIdentifierInUDI.count > 0);
end;

function TFhirDeviceDefinition.GetProductionIdentifierInUDIST : TFhirDeviceProductionIdentifierInUDIEnumList;
  var i : integer;
begin
  result := [];
  if FproductionIdentifierInUDI <> nil then
    for i := 0 to FproductionIdentifierInUDI.count - 1 do
      result := result + [TFhirDeviceProductionIdentifierInUDIEnum(StringArrayIndexOfSensitive(CODES_TFhirDeviceProductionIdentifierInUDIEnum, FproductionIdentifierInUDI[i].value))];
end;

procedure TFhirDeviceDefinition.SetProductionIdentifierInUDIST(value : TFhirDeviceProductionIdentifierInUDIEnumList);
var a : TFhirDeviceProductionIdentifierInUDIEnum;
begin
  if FproductionIdentifierInUDI = nil then
    FproductionIdentifierInUDI := TFhirEnumList.create(SYSTEMS_TFhirDeviceProductionIdentifierInUDIEnum, CODES_TFhirDeviceProductionIdentifierInUDIEnum);
  FproductionIdentifierInUDI.clear;
  for a := low(TFhirDeviceProductionIdentifierInUDIEnum) to high(TFhirDeviceProductionIdentifierInUDIEnum) do
    if a in value then
      begin
         if FproductionIdentifierInUDI = nil then
           FproductionIdentifierInUDI := TFhirEnumList.create(SYSTEMS_TFhirDeviceProductionIdentifierInUDIEnum, CODES_TFhirDeviceProductionIdentifierInUDIEnum);
         FproductionIdentifierInUDI.add(TFhirEnum.create(SYSTEMS_TFhirDeviceProductionIdentifierInUDIEnum[a], CODES_TFhirDeviceProductionIdentifierInUDIEnum[a]));
      end;
end;

procedure TFhirDeviceDefinition.SetGuideline(value : TFhirDeviceDefinitionGuideline);
begin
  FGuideline.free;
  FGuideline := value;
end;

procedure TFhirDeviceDefinition.SetCorrectiveAction(value : TFhirDeviceDefinitionCorrectiveAction);
begin
  FCorrectiveAction.free;
  FCorrectiveAction := value;
end;

function TFhirDeviceDefinition.GetChargeItemList : TFhirDeviceDefinitionChargeItemList;
begin
  if FChargeItemList = nil then
    FChargeItemList := TFhirDeviceDefinitionChargeItemList.Create;
  result := FChargeItemList;
end;

function TFhirDeviceDefinition.GetHasChargeItemList : boolean;
begin
  result := (FChargeItemList <> nil) and (FChargeItemList.count > 0);
end;

{ TFhirDeviceDefinitionListEnumerator }

constructor TFhirDeviceDefinitionListEnumerator.Create(list : TFhirDeviceDefinitionList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirDeviceDefinitionListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirDeviceDefinitionListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirDeviceDefinitionListEnumerator.GetCurrent : TFhirDeviceDefinition;
begin
  Result := FList[FIndex];
end;

function TFhirDeviceDefinitionListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirDeviceDefinitionList }

function TFhirDeviceDefinitionList.AddItem(value: TFhirDeviceDefinition): TFhirDeviceDefinition;
begin
  assert(value.ClassName = 'TFhirDeviceDefinition', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirDeviceDefinition');
  add(value);
  result := value;
end;

function TFhirDeviceDefinitionList.Append: TFhirDeviceDefinition;
begin
  result := TFhirDeviceDefinition.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirDeviceDefinitionList.ClearItems;
begin
  Clear;
end;

function TFhirDeviceDefinitionList.GetEnumerator : TFhirDeviceDefinitionListEnumerator;
begin
  result := TFhirDeviceDefinitionListEnumerator.Create(self.link);
end;

function TFhirDeviceDefinitionList.Clone: TFhirDeviceDefinitionList;
begin
  result := TFhirDeviceDefinitionList(inherited Clone);
end;

function TFhirDeviceDefinitionList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirDeviceDefinitionList.GetItemN(index: Integer): TFhirDeviceDefinition;
begin
  result := TFhirDeviceDefinition(ObjectByIndex[index]);
end;

function TFhirDeviceDefinitionList.ItemClass: TFslObjectClass;
begin
  result := TFhirDeviceDefinition;
end;
function TFhirDeviceDefinitionList.IndexOf(value: TFhirDeviceDefinition): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirDeviceDefinitionList.Insert(index: Integer): TFhirDeviceDefinition;
begin
  result := TFhirDeviceDefinition.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirDeviceDefinitionList.InsertItem(index: Integer; value: TFhirDeviceDefinition);
begin
  assert(value is TFhirDeviceDefinition);
  Inherited Insert(index, value);
end;

function TFhirDeviceDefinitionList.Item(index: Integer): TFhirDeviceDefinition;
begin
  result := TFhirDeviceDefinition(ObjectByIndex[index]);
end;

function TFhirDeviceDefinitionList.Link: TFhirDeviceDefinitionList;
begin
  result := TFhirDeviceDefinitionList(inherited Link);
end;

procedure TFhirDeviceDefinitionList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirDeviceDefinitionList.SetItemByIndex(index: Integer; value: TFhirDeviceDefinition);
begin
  assert(value is TFhirDeviceDefinition);
  FhirDeviceDefinitions[index] := value;
end;

procedure TFhirDeviceDefinitionList.SetItemN(index: Integer; value: TFhirDeviceDefinition);
begin
  assert(value is TFhirDeviceDefinition);
  ObjectByIndex[index] := value;
end;

{$ENDIF FHIR_DEVICEDEFINITION}
{$IFDEF FHIR_DEVICEMETRIC}
{ TFhirDeviceMetricCalibration }

constructor TFhirDeviceMetricCalibration.Create;
begin
  inherited;
end;

destructor TFhirDeviceMetricCalibration.Destroy;
begin
  FType_.free;
  FState.free;
  FTime.free;
  inherited;
end;

procedure TFhirDeviceMetricCalibration.Assign(oSource : TFslObject);
begin
  inherited;
  type_Element := TFhirDeviceMetricCalibration(oSource).type_Element.Clone;
  stateElement := TFhirDeviceMetricCalibration(oSource).stateElement.Clone;
  timeElement := TFhirDeviceMetricCalibration(oSource).timeElement.Clone;
end;

procedure TFhirDeviceMetricCalibration.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'type') Then
     list.add(self.link, 'type', FType_.Link);
  if (child_name = 'state') Then
     list.add(self.link, 'state', FState.Link);
  if (child_name = 'time') Then
     list.add(self.link, 'time', FTime.Link);
end;

procedure TFhirDeviceMetricCalibration.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'type', 'code', false, TFhirEnum, FType_.Link));
  oList.add(TFHIRProperty.create(self, 'state', 'code', false, TFhirEnum, FState.Link));
  oList.add(TFHIRProperty.create(self, 'time', 'instant', false, TFhirInstant, FTime.Link));
end;

function TFhirDeviceMetricCalibration.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'type') then
  begin
    Type_Element := asEnum(SYSTEMS_TFhirDeviceMetricCalibrationTypeEnum, CODES_TFhirDeviceMetricCalibrationTypeEnum, propValue);
    result := propValue;
  end
  else if (propName = 'state') then
  begin
    StateElement := asEnum(SYSTEMS_TFhirDeviceMetricCalibrationStateEnum, CODES_TFhirDeviceMetricCalibrationStateEnum, propValue);
    result := propValue;
  end
  else if (propName = 'time') then
  begin
    TimeElement := asInstant(propValue);
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirDeviceMetricCalibration.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirDeviceMetricCalibration.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'type') then result := TFhirEnum.create(SYSTEMS_TFhirDeviceMetricCalibrationTypeEnum[DeviceMetricCalibrationTypeNull], CODES_TFhirDeviceMetricCalibrationTypeEnum[DeviceMetricCalibrationTypeNull]) 
  else if (propName = 'state') then result := TFhirEnum.create(SYSTEMS_TFhirDeviceMetricCalibrationStateEnum[DeviceMetricCalibrationStateNull], CODES_TFhirDeviceMetricCalibrationStateEnum[DeviceMetricCalibrationStateNull]) 
  else if (propName = 'time') then result := TFhirInstant.create()
  else result := inherited createPropertyValue(propName);
end;

function TFhirDeviceMetricCalibration.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'type') then result := 'code'
  else if (propName = 'state') then result := 'code'
  else if (propName = 'time') then result := 'instant'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirDeviceMetricCalibration.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'type') then Type_Element := nil
  else if (propName = 'state') then StateElement := nil
  else if (propName = 'time') then TimeElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirDeviceMetricCalibration.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'type') then Type_Element := asEnum(SYSTEMS_TFhirDeviceMetricCalibrationTypeEnum, CODES_TFhirDeviceMetricCalibrationTypeEnum, new)
  else if (propName = 'state') then StateElement := asEnum(SYSTEMS_TFhirDeviceMetricCalibrationStateEnum, CODES_TFhirDeviceMetricCalibrationStateEnum, new)
  else if (propName = 'time') then TimeElement := asInstant(new)
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirDeviceMetricCalibration.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirDeviceMetricCalibration.fhirType : string;
begin
  result := 'DeviceMetric.calibration';
end;

function TFhirDeviceMetricCalibration.Link : TFhirDeviceMetricCalibration;
begin
  result := TFhirDeviceMetricCalibration(inherited Link);
end;

function TFhirDeviceMetricCalibration.Clone : TFhirDeviceMetricCalibration;
begin
  result := TFhirDeviceMetricCalibration(inherited Clone);
end;

function TFhirDeviceMetricCalibration.equals(other : TObject) : boolean; 
var
  o : TFhirDeviceMetricCalibration;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirDeviceMetricCalibration)) then
    result := false
  else
  begin
    o := TFhirDeviceMetricCalibration(other);
    result := compareDeep(type_Element, o.type_Element, true) and compareDeep(stateElement, o.stateElement, true) and 
      compareDeep(timeElement, o.timeElement, true);
  end;
end;

function TFhirDeviceMetricCalibration.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FType_) and isEmptyProp(FState) and isEmptyProp(FTime);
end;

procedure TFhirDeviceMetricCalibration.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('type');
  fields.add('state');
  fields.add('time');
end;

function TFhirDeviceMetricCalibration.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
end;

procedure TFhirDeviceMetricCalibration.SetType_(value : TFhirEnum);
begin
  FType_.free;
  FType_ := value;
end;

function TFhirDeviceMetricCalibration.GetType_ST : TFhirDeviceMetricCalibrationTypeEnum;
begin
  if FType_ = nil then
    result := TFhirDeviceMetricCalibrationTypeEnum(0)
  else
    result := TFhirDeviceMetricCalibrationTypeEnum(StringArrayIndexOfSensitive(CODES_TFhirDeviceMetricCalibrationTypeEnum, FType_.value));
end;

procedure TFhirDeviceMetricCalibration.SetType_ST(value : TFhirDeviceMetricCalibrationTypeEnum);
begin
  if ord(value) = 0 then
    Type_Element := nil
  else
    Type_Element := TFhirEnum.create(SYSTEMS_TFhirDeviceMetricCalibrationTypeEnum[value], CODES_TFhirDeviceMetricCalibrationTypeEnum[value]);
end;

procedure TFhirDeviceMetricCalibration.SetState(value : TFhirEnum);
begin
  FState.free;
  FState := value;
end;

function TFhirDeviceMetricCalibration.GetStateST : TFhirDeviceMetricCalibrationStateEnum;
begin
  if FState = nil then
    result := TFhirDeviceMetricCalibrationStateEnum(0)
  else
    result := TFhirDeviceMetricCalibrationStateEnum(StringArrayIndexOfSensitive(CODES_TFhirDeviceMetricCalibrationStateEnum, FState.value));
end;

procedure TFhirDeviceMetricCalibration.SetStateST(value : TFhirDeviceMetricCalibrationStateEnum);
begin
  if ord(value) = 0 then
    StateElement := nil
  else
    StateElement := TFhirEnum.create(SYSTEMS_TFhirDeviceMetricCalibrationStateEnum[value], CODES_TFhirDeviceMetricCalibrationStateEnum[value]);
end;

procedure TFhirDeviceMetricCalibration.SetTime(value : TFhirInstant);
begin
  FTime.free;
  FTime := value;
end;

function TFhirDeviceMetricCalibration.GetTimeST : TFslDateTime;
begin
  if FTime = nil then
    result := TFslDateTime.makeNull
  else
    result := FTime.value;
end;

procedure TFhirDeviceMetricCalibration.SetTimeST(value : TFslDateTime);
begin
  if FTime = nil then
    FTime := TFhirInstant.create;
  FTime.value := value
end;

{ TFhirDeviceMetricCalibrationListEnumerator }

constructor TFhirDeviceMetricCalibrationListEnumerator.Create(list : TFhirDeviceMetricCalibrationList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirDeviceMetricCalibrationListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirDeviceMetricCalibrationListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirDeviceMetricCalibrationListEnumerator.GetCurrent : TFhirDeviceMetricCalibration;
begin
  Result := FList[FIndex];
end;

function TFhirDeviceMetricCalibrationListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirDeviceMetricCalibrationList }

function TFhirDeviceMetricCalibrationList.AddItem(value: TFhirDeviceMetricCalibration): TFhirDeviceMetricCalibration;
begin
  assert(value.ClassName = 'TFhirDeviceMetricCalibration', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirDeviceMetricCalibration');
  add(value);
  result := value;
end;

function TFhirDeviceMetricCalibrationList.Append: TFhirDeviceMetricCalibration;
begin
  result := TFhirDeviceMetricCalibration.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirDeviceMetricCalibrationList.ClearItems;
begin
  Clear;
end;

function TFhirDeviceMetricCalibrationList.GetEnumerator : TFhirDeviceMetricCalibrationListEnumerator;
begin
  result := TFhirDeviceMetricCalibrationListEnumerator.Create(self.link);
end;

function TFhirDeviceMetricCalibrationList.Clone: TFhirDeviceMetricCalibrationList;
begin
  result := TFhirDeviceMetricCalibrationList(inherited Clone);
end;

function TFhirDeviceMetricCalibrationList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirDeviceMetricCalibrationList.GetItemN(index: Integer): TFhirDeviceMetricCalibration;
begin
  result := TFhirDeviceMetricCalibration(ObjectByIndex[index]);
end;

function TFhirDeviceMetricCalibrationList.ItemClass: TFslObjectClass;
begin
  result := TFhirDeviceMetricCalibration;
end;
function TFhirDeviceMetricCalibrationList.IndexOf(value: TFhirDeviceMetricCalibration): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirDeviceMetricCalibrationList.Insert(index: Integer): TFhirDeviceMetricCalibration;
begin
  result := TFhirDeviceMetricCalibration.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirDeviceMetricCalibrationList.InsertItem(index: Integer; value: TFhirDeviceMetricCalibration);
begin
  assert(value is TFhirDeviceMetricCalibration);
  Inherited Insert(index, value);
end;

function TFhirDeviceMetricCalibrationList.Item(index: Integer): TFhirDeviceMetricCalibration;
begin
  result := TFhirDeviceMetricCalibration(ObjectByIndex[index]);
end;

function TFhirDeviceMetricCalibrationList.Link: TFhirDeviceMetricCalibrationList;
begin
  result := TFhirDeviceMetricCalibrationList(inherited Link);
end;

procedure TFhirDeviceMetricCalibrationList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirDeviceMetricCalibrationList.SetItemByIndex(index: Integer; value: TFhirDeviceMetricCalibration);
begin
  assert(value is TFhirDeviceMetricCalibration);
  FhirDeviceMetricCalibrations[index] := value;
end;

procedure TFhirDeviceMetricCalibrationList.SetItemN(index: Integer; value: TFhirDeviceMetricCalibration);
begin
  assert(value is TFhirDeviceMetricCalibration);
  ObjectByIndex[index] := value;
end;

{ TFhirDeviceMetric }

constructor TFhirDeviceMetric.Create;
begin
  inherited;
end;

destructor TFhirDeviceMetric.Destroy;
begin
  FIdentifierList.Free;
  FType_.free;
  FUnit_.free;
  FSource.free;
  FParent.free;
  FOperationalStatus.free;
  FColor.free;
  FCategory.free;
  FMeasurementPeriod.free;
  FCalibrationList.Free;
  inherited;
end;

procedure TFhirDeviceMetric.Assign(oSource : TFslObject);
begin
  inherited;
  if (TFhirDeviceMetric(oSource).FIdentifierList = nil) then
  begin
    FIdentifierList.free;
    FIdentifierList := nil;
  end
  else
  begin
    if FIdentifierList = nil then
      FIdentifierList := TFhirIdentifierList.Create;
    FIdentifierList.Assign(TFhirDeviceMetric(oSource).FIdentifierList);
  end;
  type_ := TFhirDeviceMetric(oSource).type_.Clone;
  unit_ := TFhirDeviceMetric(oSource).unit_.Clone;
  source := TFhirDeviceMetric(oSource).source.Clone;
  parent := TFhirDeviceMetric(oSource).parent.Clone;
  operationalStatusElement := TFhirDeviceMetric(oSource).operationalStatusElement.Clone;
  colorElement := TFhirDeviceMetric(oSource).colorElement.Clone;
  categoryElement := TFhirDeviceMetric(oSource).categoryElement.Clone;
  measurementPeriod := TFhirDeviceMetric(oSource).measurementPeriod.Clone;
  if (TFhirDeviceMetric(oSource).FCalibrationList = nil) then
  begin
    FCalibrationList.free;
    FCalibrationList := nil;
  end
  else
  begin
    if FCalibrationList = nil then
      FCalibrationList := TFhirDeviceMetricCalibrationList.Create;
    FCalibrationList.Assign(TFhirDeviceMetric(oSource).FCalibrationList);
  end;
end;

function TFhirDeviceMetric.GetResourceType : TFhirResourceType;
begin
  result := frtDeviceMetric;
end;

procedure TFhirDeviceMetric.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'identifier') Then
    list.addAll(self, 'identifier', FIdentifierList);
  if (child_name = 'type') Then
     list.add(self.link, 'type', FType_.Link);
  if (child_name = 'unit') Then
     list.add(self.link, 'unit', FUnit_.Link);
  if (child_name = 'source') Then
     list.add(self.link, 'source', FSource.Link);
  if (child_name = 'parent') Then
     list.add(self.link, 'parent', FParent.Link);
  if (child_name = 'operationalStatus') Then
     list.add(self.link, 'operationalStatus', FOperationalStatus.Link);
  if (child_name = 'color') Then
     list.add(self.link, 'color', FColor.Link);
  if (child_name = 'category') Then
     list.add(self.link, 'category', FCategory.Link);
  if (child_name = 'measurementPeriod') Then
     list.add(self.link, 'measurementPeriod', FMeasurementPeriod.Link);
  if (child_name = 'calibration') Then
    list.addAll(self, 'calibration', FCalibrationList);
end;

procedure TFhirDeviceMetric.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'identifier', 'Identifier', true, TFhirIdentifier, FIdentifierList.Link));
  oList.add(TFHIRProperty.create(self, 'type', 'CodeableConcept', false, TFhirCodeableConcept, FType_.Link));
  oList.add(TFHIRProperty.create(self, 'unit', 'CodeableConcept', false, TFhirCodeableConcept, FUnit_.Link));
  oList.add(TFHIRProperty.create(self, 'source', 'Reference', false, TFhirReference, FSource.Link));
  oList.add(TFHIRProperty.create(self, 'parent', 'Reference', false, TFhirReference, FParent.Link));
  oList.add(TFHIRProperty.create(self, 'operationalStatus', 'code', false, TFhirEnum, FOperationalStatus.Link));
  oList.add(TFHIRProperty.create(self, 'color', 'code', false, TFhirEnum, FColor.Link));
  oList.add(TFHIRProperty.create(self, 'category', 'code', false, TFhirEnum, FCategory.Link));
  oList.add(TFHIRProperty.create(self, 'measurementPeriod', 'Timing', false, TFhirTiming, FMeasurementPeriod.Link));
  oList.add(TFHIRProperty.create(self, 'calibration', 'BackboneElement', true, TFhirDeviceMetricCalibration, FCalibrationList.Link));
end;

function TFhirDeviceMetric.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'identifier') then
  begin
    IdentifierList.add(propValue as TFhirIdentifier);
    result := propValue;
  end
  else if (propName = 'type') then
  begin
    Type_ := propValue as TFhirCodeableConcept;
    result := propValue;
  end
  else if (propName = 'unit') then
  begin
    Unit_ := propValue as TFhirCodeableConcept;
    result := propValue;
  end
  else if (propName = 'source') then
  begin
    Source := propValue as TFhirReference;
    result := propValue;
  end
  else if (propName = 'parent') then
  begin
    Parent := propValue as TFhirReference;
    result := propValue;
  end
  else if (propName = 'operationalStatus') then
  begin
    OperationalStatusElement := asEnum(SYSTEMS_TFhirDeviceMetricOperationalStatusEnum, CODES_TFhirDeviceMetricOperationalStatusEnum, propValue);
    result := propValue;
  end
  else if (propName = 'color') then
  begin
    ColorElement := asEnum(SYSTEMS_TFhirDeviceMetricColorEnum, CODES_TFhirDeviceMetricColorEnum, propValue);
    result := propValue;
  end
  else if (propName = 'category') then
  begin
    CategoryElement := asEnum(SYSTEMS_TFhirDeviceMetricCategoryEnum, CODES_TFhirDeviceMetricCategoryEnum, propValue);
    result := propValue;
  end
  else if (propName = 'measurementPeriod') then
  begin
    MeasurementPeriod := propValue as TFhirTiming;
    result := propValue;
  end
  else if (propName = 'calibration') then
  begin
    CalibrationList.add(propValue as TFhirDeviceMetricCalibration);
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirDeviceMetric.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'identifier') then IdentifierList.insertItem(index, propValue as TFhirIdentifier)
  else if (propName = 'calibration') then CalibrationList.insertItem(index, propValue as TFhirDeviceMetricCalibration)
  else inherited;
end;

function TFhirDeviceMetric.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'identifier') then result := IdentifierList.new()
  else if (propName = 'type') then result := TFhirCodeableConcept.create()
  else if (propName = 'unit') then result := TFhirCodeableConcept.create()
  else if (propName = 'source') then result := TFhirReference.create()
  else if (propName = 'parent') then result := TFhirReference.create()
  else if (propName = 'operationalStatus') then result := TFhirEnum.create(SYSTEMS_TFhirDeviceMetricOperationalStatusEnum[DeviceMetricOperationalStatusNull], CODES_TFhirDeviceMetricOperationalStatusEnum[DeviceMetricOperationalStatusNull]) 
  else if (propName = 'color') then result := TFhirEnum.create(SYSTEMS_TFhirDeviceMetricColorEnum[DeviceMetricColorNull], CODES_TFhirDeviceMetricColorEnum[DeviceMetricColorNull]) 
  else if (propName = 'category') then result := TFhirEnum.create(SYSTEMS_TFhirDeviceMetricCategoryEnum[DeviceMetricCategoryNull], CODES_TFhirDeviceMetricCategoryEnum[DeviceMetricCategoryNull]) 
  else if (propName = 'measurementPeriod') then result := TFhirTiming.create()
  else if (propName = 'calibration') then result := CalibrationList.new()
  else result := inherited createPropertyValue(propName);
end;

function TFhirDeviceMetric.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'identifier') then result := 'Identifier'
  else if (propName = 'type') then result := 'CodeableConcept'
  else if (propName = 'unit') then result := 'CodeableConcept'
  else if (propName = 'source') then result := 'Reference'
  else if (propName = 'parent') then result := 'Reference'
  else if (propName = 'operationalStatus') then result := 'code'
  else if (propName = 'color') then result := 'code'
  else if (propName = 'category') then result := 'code'
  else if (propName = 'measurementPeriod') then result := 'Timing'
  else if (propName = 'calibration') then result := 'BackboneElement'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirDeviceMetric.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'identifier') then deletePropertyValue('identifier', IdentifierList, value)
  else if (propName = 'type') then Type_Element := nil
  else if (propName = 'unit') then Unit_Element := nil
  else if (propName = 'source') then SourceElement := nil
  else if (propName = 'parent') then ParentElement := nil
  else if (propName = 'operationalStatus') then OperationalStatusElement := nil
  else if (propName = 'color') then ColorElement := nil
  else if (propName = 'category') then CategoryElement := nil
  else if (propName = 'measurementPeriod') then MeasurementPeriodElement := nil
  else if (propName = 'calibration') then deletePropertyValue('calibration', CalibrationList, value)
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirDeviceMetric.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'identifier') then replacePropertyValue('identifier', IdentifierList, existing, new)
  else if (propName = 'type') then Type_Element := new as TFhirCodeableConcept
  else if (propName = 'unit') then Unit_Element := new as TFhirCodeableConcept
  else if (propName = 'source') then SourceElement := new as TFhirReference
  else if (propName = 'parent') then ParentElement := new as TFhirReference
  else if (propName = 'operationalStatus') then OperationalStatusElement := asEnum(SYSTEMS_TFhirDeviceMetricOperationalStatusEnum, CODES_TFhirDeviceMetricOperationalStatusEnum, new)
  else if (propName = 'color') then ColorElement := asEnum(SYSTEMS_TFhirDeviceMetricColorEnum, CODES_TFhirDeviceMetricColorEnum, new)
  else if (propName = 'category') then CategoryElement := asEnum(SYSTEMS_TFhirDeviceMetricCategoryEnum, CODES_TFhirDeviceMetricCategoryEnum, new)
  else if (propName = 'measurementPeriod') then MeasurementPeriodElement := new as TFhirTiming
  else if (propName = 'calibration') then replacePropertyValue('calibration', CalibrationList, existing, new)
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirDeviceMetric.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'identifier') then IdentifierList.move(source, destination)
  else if (propName = 'calibration') then CalibrationList.move(source, destination)
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirDeviceMetric.fhirType : string;
begin
  result := 'DeviceMetric';
end;

function TFhirDeviceMetric.Link : TFhirDeviceMetric;
begin
  result := TFhirDeviceMetric(inherited Link);
end;

function TFhirDeviceMetric.Clone : TFhirDeviceMetric;
begin
  result := TFhirDeviceMetric(inherited Clone);
end;

function TFhirDeviceMetric.equals(other : TObject) : boolean; 
var
  o : TFhirDeviceMetric;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirDeviceMetric)) then
    result := false
  else
  begin
    o := TFhirDeviceMetric(other);
    result := compareDeep(identifierList, o.identifierList, true) and compareDeep(type_Element, o.type_Element, true) and 
      compareDeep(unit_Element, o.unit_Element, true) and compareDeep(sourceElement, o.sourceElement, true) and 
      compareDeep(parentElement, o.parentElement, true) and compareDeep(operationalStatusElement, o.operationalStatusElement, true) and 
      compareDeep(colorElement, o.colorElement, true) and compareDeep(categoryElement, o.categoryElement, true) and 
      compareDeep(measurementPeriodElement, o.measurementPeriodElement, true) and compareDeep(calibrationList, o.calibrationList, true);
  end;
end;

function TFhirDeviceMetric.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FidentifierList) and isEmptyProp(FType_) and isEmptyProp(FUnit_) and isEmptyProp(FSource) and isEmptyProp(FParent) and isEmptyProp(FOperationalStatus) and isEmptyProp(FColor) and isEmptyProp(FCategory) and isEmptyProp(FMeasurementPeriod) and isEmptyProp(FcalibrationList);
end;

procedure TFhirDeviceMetric.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('identifier');
  fields.add('type');
  fields.add('unit');
  fields.add('source');
  fields.add('parent');
  fields.add('operationalStatus');
  fields.add('color');
  fields.add('category');
  fields.add('measurementPeriod');
  fields.add('calibration');
end;

function TFhirDeviceMetric.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
  inc(result, FIdentifierList.sizeInBytes(magic));
  inc(result, FCalibrationList.sizeInBytes(magic));
end;

function TFhirDeviceMetric.GetIdentifierList : TFhirIdentifierList;
begin
  if FIdentifierList = nil then
    FIdentifierList := TFhirIdentifierList.Create;
  result := FIdentifierList;
end;

function TFhirDeviceMetric.GetHasIdentifierList : boolean;
begin
  result := (FIdentifierList <> nil) and (FIdentifierList.count > 0);
end;

procedure TFhirDeviceMetric.SetType_(value : TFhirCodeableConcept);
begin
  FType_.free;
  FType_ := value;
end;

procedure TFhirDeviceMetric.SetUnit_(value : TFhirCodeableConcept);
begin
  FUnit_.free;
  FUnit_ := value;
end;

procedure TFhirDeviceMetric.SetSource(value : TFhirReference);
begin
  FSource.free;
  FSource := value;
end;

procedure TFhirDeviceMetric.SetParent(value : TFhirReference);
begin
  FParent.free;
  FParent := value;
end;

procedure TFhirDeviceMetric.SetOperationalStatus(value : TFhirEnum);
begin
  FOperationalStatus.free;
  FOperationalStatus := value;
end;

function TFhirDeviceMetric.GetOperationalStatusST : TFhirDeviceMetricOperationalStatusEnum;
begin
  if FOperationalStatus = nil then
    result := TFhirDeviceMetricOperationalStatusEnum(0)
  else
    result := TFhirDeviceMetricOperationalStatusEnum(StringArrayIndexOfSensitive(CODES_TFhirDeviceMetricOperationalStatusEnum, FOperationalStatus.value));
end;

procedure TFhirDeviceMetric.SetOperationalStatusST(value : TFhirDeviceMetricOperationalStatusEnum);
begin
  if ord(value) = 0 then
    OperationalStatusElement := nil
  else
    OperationalStatusElement := TFhirEnum.create(SYSTEMS_TFhirDeviceMetricOperationalStatusEnum[value], CODES_TFhirDeviceMetricOperationalStatusEnum[value]);
end;

procedure TFhirDeviceMetric.SetColor(value : TFhirEnum);
begin
  FColor.free;
  FColor := value;
end;

function TFhirDeviceMetric.GetColorST : TFhirDeviceMetricColorEnum;
begin
  if FColor = nil then
    result := TFhirDeviceMetricColorEnum(0)
  else
    result := TFhirDeviceMetricColorEnum(StringArrayIndexOfSensitive(CODES_TFhirDeviceMetricColorEnum, FColor.value));
end;

procedure TFhirDeviceMetric.SetColorST(value : TFhirDeviceMetricColorEnum);
begin
  if ord(value) = 0 then
    ColorElement := nil
  else
    ColorElement := TFhirEnum.create(SYSTEMS_TFhirDeviceMetricColorEnum[value], CODES_TFhirDeviceMetricColorEnum[value]);
end;

procedure TFhirDeviceMetric.SetCategory(value : TFhirEnum);
begin
  FCategory.free;
  FCategory := value;
end;

function TFhirDeviceMetric.GetCategoryST : TFhirDeviceMetricCategoryEnum;
begin
  if FCategory = nil then
    result := TFhirDeviceMetricCategoryEnum(0)
  else
    result := TFhirDeviceMetricCategoryEnum(StringArrayIndexOfSensitive(CODES_TFhirDeviceMetricCategoryEnum, FCategory.value));
end;

procedure TFhirDeviceMetric.SetCategoryST(value : TFhirDeviceMetricCategoryEnum);
begin
  if ord(value) = 0 then
    CategoryElement := nil
  else
    CategoryElement := TFhirEnum.create(SYSTEMS_TFhirDeviceMetricCategoryEnum[value], CODES_TFhirDeviceMetricCategoryEnum[value]);
end;

procedure TFhirDeviceMetric.SetMeasurementPeriod(value : TFhirTiming);
begin
  FMeasurementPeriod.free;
  FMeasurementPeriod := value;
end;

function TFhirDeviceMetric.GetCalibrationList : TFhirDeviceMetricCalibrationList;
begin
  if FCalibrationList = nil then
    FCalibrationList := TFhirDeviceMetricCalibrationList.Create;
  result := FCalibrationList;
end;

function TFhirDeviceMetric.GetHasCalibrationList : boolean;
begin
  result := (FCalibrationList <> nil) and (FCalibrationList.count > 0);
end;

{ TFhirDeviceMetricListEnumerator }

constructor TFhirDeviceMetricListEnumerator.Create(list : TFhirDeviceMetricList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirDeviceMetricListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirDeviceMetricListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirDeviceMetricListEnumerator.GetCurrent : TFhirDeviceMetric;
begin
  Result := FList[FIndex];
end;

function TFhirDeviceMetricListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirDeviceMetricList }

function TFhirDeviceMetricList.AddItem(value: TFhirDeviceMetric): TFhirDeviceMetric;
begin
  assert(value.ClassName = 'TFhirDeviceMetric', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirDeviceMetric');
  add(value);
  result := value;
end;

function TFhirDeviceMetricList.Append: TFhirDeviceMetric;
begin
  result := TFhirDeviceMetric.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirDeviceMetricList.ClearItems;
begin
  Clear;
end;

function TFhirDeviceMetricList.GetEnumerator : TFhirDeviceMetricListEnumerator;
begin
  result := TFhirDeviceMetricListEnumerator.Create(self.link);
end;

function TFhirDeviceMetricList.Clone: TFhirDeviceMetricList;
begin
  result := TFhirDeviceMetricList(inherited Clone);
end;

function TFhirDeviceMetricList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirDeviceMetricList.GetItemN(index: Integer): TFhirDeviceMetric;
begin
  result := TFhirDeviceMetric(ObjectByIndex[index]);
end;

function TFhirDeviceMetricList.ItemClass: TFslObjectClass;
begin
  result := TFhirDeviceMetric;
end;
function TFhirDeviceMetricList.IndexOf(value: TFhirDeviceMetric): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirDeviceMetricList.Insert(index: Integer): TFhirDeviceMetric;
begin
  result := TFhirDeviceMetric.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirDeviceMetricList.InsertItem(index: Integer; value: TFhirDeviceMetric);
begin
  assert(value is TFhirDeviceMetric);
  Inherited Insert(index, value);
end;

function TFhirDeviceMetricList.Item(index: Integer): TFhirDeviceMetric;
begin
  result := TFhirDeviceMetric(ObjectByIndex[index]);
end;

function TFhirDeviceMetricList.Link: TFhirDeviceMetricList;
begin
  result := TFhirDeviceMetricList(inherited Link);
end;

procedure TFhirDeviceMetricList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirDeviceMetricList.SetItemByIndex(index: Integer; value: TFhirDeviceMetric);
begin
  assert(value is TFhirDeviceMetric);
  FhirDeviceMetrics[index] := value;
end;

procedure TFhirDeviceMetricList.SetItemN(index: Integer; value: TFhirDeviceMetric);
begin
  assert(value is TFhirDeviceMetric);
  ObjectByIndex[index] := value;
end;

{$ENDIF FHIR_DEVICEMETRIC}
{$IFDEF FHIR_ENCOUNTER}
{ TFhirEncounterStatusHistory }

constructor TFhirEncounterStatusHistory.Create;
begin
  inherited;
end;

destructor TFhirEncounterStatusHistory.Destroy;
begin
  FStatus.free;
  FPeriod.free;
  inherited;
end;

procedure TFhirEncounterStatusHistory.Assign(oSource : TFslObject);
begin
  inherited;
  statusElement := TFhirEncounterStatusHistory(oSource).statusElement.Clone;
  period := TFhirEncounterStatusHistory(oSource).period.Clone;
end;

procedure TFhirEncounterStatusHistory.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'status') Then
     list.add(self.link, 'status', FStatus.Link);
  if (child_name = 'period') Then
     list.add(self.link, 'period', FPeriod.Link);
end;

procedure TFhirEncounterStatusHistory.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'status', 'code', false, TFhirEnum, FStatus.Link));
  oList.add(TFHIRProperty.create(self, 'period', 'Period', false, TFhirPeriod, FPeriod.Link));
end;

function TFhirEncounterStatusHistory.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'status') then
  begin
    StatusElement := asEnum(SYSTEMS_TFhirEncounterStatusEnum, CODES_TFhirEncounterStatusEnum, propValue);
    result := propValue;
  end
  else if (propName = 'period') then
  begin
    Period := propValue as TFhirPeriod;
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirEncounterStatusHistory.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirEncounterStatusHistory.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'status') then result := TFhirEnum.create(SYSTEMS_TFhirEncounterStatusEnum[EncounterStatusNull], CODES_TFhirEncounterStatusEnum[EncounterStatusNull]) 
  else if (propName = 'period') then result := TFhirPeriod.create()
  else result := inherited createPropertyValue(propName);
end;

function TFhirEncounterStatusHistory.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'status') then result := 'code'
  else if (propName = 'period') then result := 'Period'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirEncounterStatusHistory.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'status') then StatusElement := nil
  else if (propName = 'period') then PeriodElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirEncounterStatusHistory.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'status') then StatusElement := asEnum(SYSTEMS_TFhirEncounterStatusEnum, CODES_TFhirEncounterStatusEnum, new)
  else if (propName = 'period') then PeriodElement := new as TFhirPeriod
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirEncounterStatusHistory.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirEncounterStatusHistory.fhirType : string;
begin
  result := 'Encounter.statusHistory';
end;

function TFhirEncounterStatusHistory.Link : TFhirEncounterStatusHistory;
begin
  result := TFhirEncounterStatusHistory(inherited Link);
end;

function TFhirEncounterStatusHistory.Clone : TFhirEncounterStatusHistory;
begin
  result := TFhirEncounterStatusHistory(inherited Clone);
end;

function TFhirEncounterStatusHistory.equals(other : TObject) : boolean; 
var
  o : TFhirEncounterStatusHistory;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirEncounterStatusHistory)) then
    result := false
  else
  begin
    o := TFhirEncounterStatusHistory(other);
    result := compareDeep(statusElement, o.statusElement, true) and compareDeep(periodElement, o.periodElement, true);
  end;
end;

function TFhirEncounterStatusHistory.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FStatus) and isEmptyProp(FPeriod);
end;

procedure TFhirEncounterStatusHistory.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('status');
  fields.add('period');
end;

function TFhirEncounterStatusHistory.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
end;

procedure TFhirEncounterStatusHistory.SetStatus(value : TFhirEnum);
begin
  FStatus.free;
  FStatus := value;
end;

function TFhirEncounterStatusHistory.GetStatusST : TFhirEncounterStatusEnum;
begin
  if FStatus = nil then
    result := TFhirEncounterStatusEnum(0)
  else
    result := TFhirEncounterStatusEnum(StringArrayIndexOfSensitive(CODES_TFhirEncounterStatusEnum, FStatus.value));
end;

procedure TFhirEncounterStatusHistory.SetStatusST(value : TFhirEncounterStatusEnum);
begin
  if ord(value) = 0 then
    StatusElement := nil
  else
    StatusElement := TFhirEnum.create(SYSTEMS_TFhirEncounterStatusEnum[value], CODES_TFhirEncounterStatusEnum[value]);
end;

procedure TFhirEncounterStatusHistory.SetPeriod(value : TFhirPeriod);
begin
  FPeriod.free;
  FPeriod := value;
end;

{ TFhirEncounterStatusHistoryListEnumerator }

constructor TFhirEncounterStatusHistoryListEnumerator.Create(list : TFhirEncounterStatusHistoryList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirEncounterStatusHistoryListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirEncounterStatusHistoryListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirEncounterStatusHistoryListEnumerator.GetCurrent : TFhirEncounterStatusHistory;
begin
  Result := FList[FIndex];
end;

function TFhirEncounterStatusHistoryListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirEncounterStatusHistoryList }

function TFhirEncounterStatusHistoryList.AddItem(value: TFhirEncounterStatusHistory): TFhirEncounterStatusHistory;
begin
  assert(value.ClassName = 'TFhirEncounterStatusHistory', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirEncounterStatusHistory');
  add(value);
  result := value;
end;

function TFhirEncounterStatusHistoryList.Append: TFhirEncounterStatusHistory;
begin
  result := TFhirEncounterStatusHistory.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirEncounterStatusHistoryList.ClearItems;
begin
  Clear;
end;

function TFhirEncounterStatusHistoryList.GetEnumerator : TFhirEncounterStatusHistoryListEnumerator;
begin
  result := TFhirEncounterStatusHistoryListEnumerator.Create(self.link);
end;

function TFhirEncounterStatusHistoryList.Clone: TFhirEncounterStatusHistoryList;
begin
  result := TFhirEncounterStatusHistoryList(inherited Clone);
end;

function TFhirEncounterStatusHistoryList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirEncounterStatusHistoryList.GetItemN(index: Integer): TFhirEncounterStatusHistory;
begin
  result := TFhirEncounterStatusHistory(ObjectByIndex[index]);
end;

function TFhirEncounterStatusHistoryList.ItemClass: TFslObjectClass;
begin
  result := TFhirEncounterStatusHistory;
end;
function TFhirEncounterStatusHistoryList.IndexOf(value: TFhirEncounterStatusHistory): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirEncounterStatusHistoryList.Insert(index: Integer): TFhirEncounterStatusHistory;
begin
  result := TFhirEncounterStatusHistory.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirEncounterStatusHistoryList.InsertItem(index: Integer; value: TFhirEncounterStatusHistory);
begin
  assert(value is TFhirEncounterStatusHistory);
  Inherited Insert(index, value);
end;

function TFhirEncounterStatusHistoryList.Item(index: Integer): TFhirEncounterStatusHistory;
begin
  result := TFhirEncounterStatusHistory(ObjectByIndex[index]);
end;

function TFhirEncounterStatusHistoryList.Link: TFhirEncounterStatusHistoryList;
begin
  result := TFhirEncounterStatusHistoryList(inherited Link);
end;

procedure TFhirEncounterStatusHistoryList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirEncounterStatusHistoryList.SetItemByIndex(index: Integer; value: TFhirEncounterStatusHistory);
begin
  assert(value is TFhirEncounterStatusHistory);
  FhirEncounterStatusHistories[index] := value;
end;

procedure TFhirEncounterStatusHistoryList.SetItemN(index: Integer; value: TFhirEncounterStatusHistory);
begin
  assert(value is TFhirEncounterStatusHistory);
  ObjectByIndex[index] := value;
end;

{ TFhirEncounterClassHistory }

constructor TFhirEncounterClassHistory.Create;
begin
  inherited;
end;

destructor TFhirEncounterClassHistory.Destroy;
begin
  FClass_.free;
  FPeriod.free;
  inherited;
end;

procedure TFhirEncounterClassHistory.Assign(oSource : TFslObject);
begin
  inherited;
  class_ := TFhirEncounterClassHistory(oSource).class_.Clone;
  period := TFhirEncounterClassHistory(oSource).period.Clone;
end;

procedure TFhirEncounterClassHistory.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'class') Then
     list.add(self.link, 'class', FClass_.Link);
  if (child_name = 'period') Then
     list.add(self.link, 'period', FPeriod.Link);
end;

procedure TFhirEncounterClassHistory.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'class', 'Coding', false, TFhirCoding, FClass_.Link));
  oList.add(TFHIRProperty.create(self, 'period', 'Period', false, TFhirPeriod, FPeriod.Link));
end;

function TFhirEncounterClassHistory.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'class') then
  begin
    Class_ := propValue as TFhirCoding;
    result := propValue;
  end
  else if (propName = 'period') then
  begin
    Period := propValue as TFhirPeriod;
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirEncounterClassHistory.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirEncounterClassHistory.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'class') then result := TFhirCoding.create()
  else if (propName = 'period') then result := TFhirPeriod.create()
  else result := inherited createPropertyValue(propName);
end;

function TFhirEncounterClassHistory.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'class') then result := 'Coding'
  else if (propName = 'period') then result := 'Period'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirEncounterClassHistory.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'class') then Class_Element := nil
  else if (propName = 'period') then PeriodElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirEncounterClassHistory.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'class') then Class_Element := new as TFhirCoding
  else if (propName = 'period') then PeriodElement := new as TFhirPeriod
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirEncounterClassHistory.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirEncounterClassHistory.fhirType : string;
begin
  result := 'Encounter.classHistory';
end;

function TFhirEncounterClassHistory.Link : TFhirEncounterClassHistory;
begin
  result := TFhirEncounterClassHistory(inherited Link);
end;

function TFhirEncounterClassHistory.Clone : TFhirEncounterClassHistory;
begin
  result := TFhirEncounterClassHistory(inherited Clone);
end;

function TFhirEncounterClassHistory.equals(other : TObject) : boolean; 
var
  o : TFhirEncounterClassHistory;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirEncounterClassHistory)) then
    result := false
  else
  begin
    o := TFhirEncounterClassHistory(other);
    result := compareDeep(class_Element, o.class_Element, true) and compareDeep(periodElement, o.periodElement, true);
  end;
end;

function TFhirEncounterClassHistory.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FClass_) and isEmptyProp(FPeriod);
end;

procedure TFhirEncounterClassHistory.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('class');
  fields.add('period');
end;

function TFhirEncounterClassHistory.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
end;

procedure TFhirEncounterClassHistory.SetClass_(value : TFhirCoding);
begin
  FClass_.free;
  FClass_ := value;
end;

procedure TFhirEncounterClassHistory.SetPeriod(value : TFhirPeriod);
begin
  FPeriod.free;
  FPeriod := value;
end;

{ TFhirEncounterClassHistoryListEnumerator }

constructor TFhirEncounterClassHistoryListEnumerator.Create(list : TFhirEncounterClassHistoryList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirEncounterClassHistoryListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirEncounterClassHistoryListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirEncounterClassHistoryListEnumerator.GetCurrent : TFhirEncounterClassHistory;
begin
  Result := FList[FIndex];
end;

function TFhirEncounterClassHistoryListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirEncounterClassHistoryList }

function TFhirEncounterClassHistoryList.AddItem(value: TFhirEncounterClassHistory): TFhirEncounterClassHistory;
begin
  assert(value.ClassName = 'TFhirEncounterClassHistory', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirEncounterClassHistory');
  add(value);
  result := value;
end;

function TFhirEncounterClassHistoryList.Append: TFhirEncounterClassHistory;
begin
  result := TFhirEncounterClassHistory.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirEncounterClassHistoryList.ClearItems;
begin
  Clear;
end;

function TFhirEncounterClassHistoryList.GetEnumerator : TFhirEncounterClassHistoryListEnumerator;
begin
  result := TFhirEncounterClassHistoryListEnumerator.Create(self.link);
end;

function TFhirEncounterClassHistoryList.Clone: TFhirEncounterClassHistoryList;
begin
  result := TFhirEncounterClassHistoryList(inherited Clone);
end;

function TFhirEncounterClassHistoryList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirEncounterClassHistoryList.GetItemN(index: Integer): TFhirEncounterClassHistory;
begin
  result := TFhirEncounterClassHistory(ObjectByIndex[index]);
end;

function TFhirEncounterClassHistoryList.ItemClass: TFslObjectClass;
begin
  result := TFhirEncounterClassHistory;
end;
function TFhirEncounterClassHistoryList.IndexOf(value: TFhirEncounterClassHistory): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirEncounterClassHistoryList.Insert(index: Integer): TFhirEncounterClassHistory;
begin
  result := TFhirEncounterClassHistory.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirEncounterClassHistoryList.InsertItem(index: Integer; value: TFhirEncounterClassHistory);
begin
  assert(value is TFhirEncounterClassHistory);
  Inherited Insert(index, value);
end;

function TFhirEncounterClassHistoryList.Item(index: Integer): TFhirEncounterClassHistory;
begin
  result := TFhirEncounterClassHistory(ObjectByIndex[index]);
end;

function TFhirEncounterClassHistoryList.Link: TFhirEncounterClassHistoryList;
begin
  result := TFhirEncounterClassHistoryList(inherited Link);
end;

procedure TFhirEncounterClassHistoryList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirEncounterClassHistoryList.SetItemByIndex(index: Integer; value: TFhirEncounterClassHistory);
begin
  assert(value is TFhirEncounterClassHistory);
  FhirEncounterClassHistories[index] := value;
end;

procedure TFhirEncounterClassHistoryList.SetItemN(index: Integer; value: TFhirEncounterClassHistory);
begin
  assert(value is TFhirEncounterClassHistory);
  ObjectByIndex[index] := value;
end;

{ TFhirEncounterParticipant }

constructor TFhirEncounterParticipant.Create;
begin
  inherited;
end;

destructor TFhirEncounterParticipant.Destroy;
begin
  FType_List.Free;
  FPeriod.free;
  FActor.free;
  inherited;
end;

procedure TFhirEncounterParticipant.Assign(oSource : TFslObject);
begin
  inherited;
  if (TFhirEncounterParticipant(oSource).FType_List = nil) then
  begin
    FType_List.free;
    FType_List := nil;
  end
  else
  begin
    if FType_List = nil then
      FType_List := TFhirCodeableConceptList.Create;
    FType_List.Assign(TFhirEncounterParticipant(oSource).FType_List);
  end;
  period := TFhirEncounterParticipant(oSource).period.Clone;
  actor := TFhirEncounterParticipant(oSource).actor.Clone;
end;

procedure TFhirEncounterParticipant.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'type') Then
    list.addAll(self, 'type', FType_List);
  if (child_name = 'period') Then
     list.add(self.link, 'period', FPeriod.Link);
  if (child_name = 'actor') Then
     list.add(self.link, 'actor', FActor.Link);
end;

procedure TFhirEncounterParticipant.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'type', 'CodeableConcept', true, TFhirCodeableConcept, FType_List.Link));
  oList.add(TFHIRProperty.create(self, 'period', 'Period', false, TFhirPeriod, FPeriod.Link));
  oList.add(TFHIRProperty.create(self, 'actor', 'Reference', false, TFhirReference, FActor.Link));
end;

function TFhirEncounterParticipant.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'type') then
  begin
    Type_List.add(propValue as TFhirCodeableConcept);
    result := propValue;
  end
  else if (propName = 'period') then
  begin
    Period := propValue as TFhirPeriod;
    result := propValue;
  end
  else if (propName = 'actor') then
  begin
    Actor := propValue as TFhirReference;
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirEncounterParticipant.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'type') then Type_List.insertItem(index, propValue as TFhirCodeableConcept)
  else inherited;
end;

function TFhirEncounterParticipant.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'type') then result := Type_List.new()
  else if (propName = 'period') then result := TFhirPeriod.create()
  else if (propName = 'actor') then result := TFhirReference.create()
  else result := inherited createPropertyValue(propName);
end;

function TFhirEncounterParticipant.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'type') then result := 'CodeableConcept'
  else if (propName = 'period') then result := 'Period'
  else if (propName = 'actor') then result := 'Reference'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirEncounterParticipant.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'type') then deletePropertyValue('type', Type_List, value)
  else if (propName = 'period') then PeriodElement := nil
  else if (propName = 'actor') then ActorElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirEncounterParticipant.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'type') then replacePropertyValue('type', Type_List, existing, new)
  else if (propName = 'period') then PeriodElement := new as TFhirPeriod
  else if (propName = 'actor') then ActorElement := new as TFhirReference
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirEncounterParticipant.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'type') then Type_List.move(source, destination)
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirEncounterParticipant.fhirType : string;
begin
  result := 'Encounter.participant';
end;

function TFhirEncounterParticipant.Link : TFhirEncounterParticipant;
begin
  result := TFhirEncounterParticipant(inherited Link);
end;

function TFhirEncounterParticipant.Clone : TFhirEncounterParticipant;
begin
  result := TFhirEncounterParticipant(inherited Clone);
end;

function TFhirEncounterParticipant.equals(other : TObject) : boolean; 
var
  o : TFhirEncounterParticipant;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirEncounterParticipant)) then
    result := false
  else
  begin
    o := TFhirEncounterParticipant(other);
    result := compareDeep(type_List, o.type_List, true) and compareDeep(periodElement, o.periodElement, true) and 
      compareDeep(actorElement, o.actorElement, true);
  end;
end;

function TFhirEncounterParticipant.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(Ftype_List) and isEmptyProp(FPeriod) and isEmptyProp(FActor);
end;

procedure TFhirEncounterParticipant.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('type');
  fields.add('period');
  fields.add('actor');
end;

function TFhirEncounterParticipant.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
  inc(result, FType_List.sizeInBytes(magic));
end;

function TFhirEncounterParticipant.GetType_List : TFhirCodeableConceptList;
begin
  if FType_List = nil then
    FType_List := TFhirCodeableConceptList.Create;
  result := FType_List;
end;

function TFhirEncounterParticipant.GetHasType_List : boolean;
begin
  result := (FType_List <> nil) and (FType_List.count > 0);
end;

procedure TFhirEncounterParticipant.SetPeriod(value : TFhirPeriod);
begin
  FPeriod.free;
  FPeriod := value;
end;

procedure TFhirEncounterParticipant.SetActor(value : TFhirReference);
begin
  FActor.free;
  FActor := value;
end;

{ TFhirEncounterParticipantListEnumerator }

constructor TFhirEncounterParticipantListEnumerator.Create(list : TFhirEncounterParticipantList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirEncounterParticipantListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirEncounterParticipantListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirEncounterParticipantListEnumerator.GetCurrent : TFhirEncounterParticipant;
begin
  Result := FList[FIndex];
end;

function TFhirEncounterParticipantListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirEncounterParticipantList }

function TFhirEncounterParticipantList.AddItem(value: TFhirEncounterParticipant): TFhirEncounterParticipant;
begin
  assert(value.ClassName = 'TFhirEncounterParticipant', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirEncounterParticipant');
  add(value);
  result := value;
end;

function TFhirEncounterParticipantList.Append: TFhirEncounterParticipant;
begin
  result := TFhirEncounterParticipant.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirEncounterParticipantList.ClearItems;
begin
  Clear;
end;

function TFhirEncounterParticipantList.GetEnumerator : TFhirEncounterParticipantListEnumerator;
begin
  result := TFhirEncounterParticipantListEnumerator.Create(self.link);
end;

function TFhirEncounterParticipantList.Clone: TFhirEncounterParticipantList;
begin
  result := TFhirEncounterParticipantList(inherited Clone);
end;

function TFhirEncounterParticipantList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirEncounterParticipantList.GetItemN(index: Integer): TFhirEncounterParticipant;
begin
  result := TFhirEncounterParticipant(ObjectByIndex[index]);
end;

function TFhirEncounterParticipantList.ItemClass: TFslObjectClass;
begin
  result := TFhirEncounterParticipant;
end;
function TFhirEncounterParticipantList.IndexOf(value: TFhirEncounterParticipant): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirEncounterParticipantList.Insert(index: Integer): TFhirEncounterParticipant;
begin
  result := TFhirEncounterParticipant.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirEncounterParticipantList.InsertItem(index: Integer; value: TFhirEncounterParticipant);
begin
  assert(value is TFhirEncounterParticipant);
  Inherited Insert(index, value);
end;

function TFhirEncounterParticipantList.Item(index: Integer): TFhirEncounterParticipant;
begin
  result := TFhirEncounterParticipant(ObjectByIndex[index]);
end;

function TFhirEncounterParticipantList.Link: TFhirEncounterParticipantList;
begin
  result := TFhirEncounterParticipantList(inherited Link);
end;

procedure TFhirEncounterParticipantList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirEncounterParticipantList.SetItemByIndex(index: Integer; value: TFhirEncounterParticipant);
begin
  assert(value is TFhirEncounterParticipant);
  FhirEncounterParticipants[index] := value;
end;

procedure TFhirEncounterParticipantList.SetItemN(index: Integer; value: TFhirEncounterParticipant);
begin
  assert(value is TFhirEncounterParticipant);
  ObjectByIndex[index] := value;
end;

{ TFhirEncounterDiagnosis }

constructor TFhirEncounterDiagnosis.Create;
begin
  inherited;
end;

destructor TFhirEncounterDiagnosis.Destroy;
begin
  FCondition.free;
  FUse.free;
  FRank.free;
  inherited;
end;

procedure TFhirEncounterDiagnosis.Assign(oSource : TFslObject);
begin
  inherited;
  condition := TFhirEncounterDiagnosis(oSource).condition.Clone;
  use := TFhirEncounterDiagnosis(oSource).use.Clone;
  rankElement := TFhirEncounterDiagnosis(oSource).rankElement.Clone;
end;

procedure TFhirEncounterDiagnosis.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'condition') Then
     list.add(self.link, 'condition', FCondition.Link);
  if (child_name = 'use') Then
     list.add(self.link, 'use', FUse.Link);
  if (child_name = 'rank') Then
     list.add(self.link, 'rank', FRank.Link);
end;

procedure TFhirEncounterDiagnosis.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'condition', 'Reference', false, TFhirReference, FCondition.Link));
  oList.add(TFHIRProperty.create(self, 'use', 'CodeableConcept', false, TFhirCodeableConcept, FUse.Link));
  oList.add(TFHIRProperty.create(self, 'rank', 'positiveInt', false, TFhirPositiveInt, FRank.Link));
end;

function TFhirEncounterDiagnosis.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'condition') then
  begin
    Condition := propValue as TFhirReference;
    result := propValue;
  end
  else if (propName = 'use') then
  begin
    Use := propValue as TFhirCodeableConcept;
    result := propValue;
  end
  else if (propName = 'rank') then
  begin
    RankElement := asPositiveInt(propValue);
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirEncounterDiagnosis.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirEncounterDiagnosis.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'condition') then result := TFhirReference.create()
  else if (propName = 'use') then result := TFhirCodeableConcept.create()
  else if (propName = 'rank') then result := TFhirPositiveInt.create()
  else result := inherited createPropertyValue(propName);
end;

function TFhirEncounterDiagnosis.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'condition') then result := 'Reference'
  else if (propName = 'use') then result := 'CodeableConcept'
  else if (propName = 'rank') then result := 'positiveInt'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirEncounterDiagnosis.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'condition') then ConditionElement := nil
  else if (propName = 'use') then UseElement := nil
  else if (propName = 'rank') then RankElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirEncounterDiagnosis.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'condition') then ConditionElement := new as TFhirReference
  else if (propName = 'use') then UseElement := new as TFhirCodeableConcept
  else if (propName = 'rank') then RankElement := asPositiveInt(new)
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirEncounterDiagnosis.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirEncounterDiagnosis.fhirType : string;
begin
  result := 'Encounter.diagnosis';
end;

function TFhirEncounterDiagnosis.Link : TFhirEncounterDiagnosis;
begin
  result := TFhirEncounterDiagnosis(inherited Link);
end;

function TFhirEncounterDiagnosis.Clone : TFhirEncounterDiagnosis;
begin
  result := TFhirEncounterDiagnosis(inherited Clone);
end;

function TFhirEncounterDiagnosis.equals(other : TObject) : boolean; 
var
  o : TFhirEncounterDiagnosis;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirEncounterDiagnosis)) then
    result := false
  else
  begin
    o := TFhirEncounterDiagnosis(other);
    result := compareDeep(conditionElement, o.conditionElement, true) and compareDeep(useElement, o.useElement, true) and 
      compareDeep(rankElement, o.rankElement, true);
  end;
end;

function TFhirEncounterDiagnosis.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FCondition) and isEmptyProp(FUse) and isEmptyProp(FRank);
end;

procedure TFhirEncounterDiagnosis.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('condition');
  fields.add('use');
  fields.add('rank');
end;

function TFhirEncounterDiagnosis.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
end;

procedure TFhirEncounterDiagnosis.SetCondition(value : TFhirReference);
begin
  FCondition.free;
  FCondition := value;
end;

procedure TFhirEncounterDiagnosis.SetUse(value : TFhirCodeableConcept);
begin
  FUse.free;
  FUse := value;
end;

procedure TFhirEncounterDiagnosis.SetRank(value : TFhirPositiveInt);
begin
  FRank.free;
  FRank := value;
end;

function TFhirEncounterDiagnosis.GetRankST : String;
begin
  if FRank = nil then
    result := ''
  else
    result := FRank.value;
end;

procedure TFhirEncounterDiagnosis.SetRankST(value : String);
begin
  if value <> '' then
  begin
    if FRank = nil then
      FRank := TFhirPositiveInt.create;
    FRank.value := value
  end
  else if FRank <> nil then
    FRank.value := '';
end;

{ TFhirEncounterDiagnosisListEnumerator }

constructor TFhirEncounterDiagnosisListEnumerator.Create(list : TFhirEncounterDiagnosisList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirEncounterDiagnosisListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirEncounterDiagnosisListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirEncounterDiagnosisListEnumerator.GetCurrent : TFhirEncounterDiagnosis;
begin
  Result := FList[FIndex];
end;

function TFhirEncounterDiagnosisListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirEncounterDiagnosisList }

function TFhirEncounterDiagnosisList.AddItem(value: TFhirEncounterDiagnosis): TFhirEncounterDiagnosis;
begin
  assert(value.ClassName = 'TFhirEncounterDiagnosis', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirEncounterDiagnosis');
  add(value);
  result := value;
end;

function TFhirEncounterDiagnosisList.Append: TFhirEncounterDiagnosis;
begin
  result := TFhirEncounterDiagnosis.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirEncounterDiagnosisList.ClearItems;
begin
  Clear;
end;

function TFhirEncounterDiagnosisList.GetEnumerator : TFhirEncounterDiagnosisListEnumerator;
begin
  result := TFhirEncounterDiagnosisListEnumerator.Create(self.link);
end;

function TFhirEncounterDiagnosisList.Clone: TFhirEncounterDiagnosisList;
begin
  result := TFhirEncounterDiagnosisList(inherited Clone);
end;

function TFhirEncounterDiagnosisList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirEncounterDiagnosisList.GetItemN(index: Integer): TFhirEncounterDiagnosis;
begin
  result := TFhirEncounterDiagnosis(ObjectByIndex[index]);
end;

function TFhirEncounterDiagnosisList.ItemClass: TFslObjectClass;
begin
  result := TFhirEncounterDiagnosis;
end;
function TFhirEncounterDiagnosisList.IndexOf(value: TFhirEncounterDiagnosis): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirEncounterDiagnosisList.Insert(index: Integer): TFhirEncounterDiagnosis;
begin
  result := TFhirEncounterDiagnosis.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirEncounterDiagnosisList.InsertItem(index: Integer; value: TFhirEncounterDiagnosis);
begin
  assert(value is TFhirEncounterDiagnosis);
  Inherited Insert(index, value);
end;

function TFhirEncounterDiagnosisList.Item(index: Integer): TFhirEncounterDiagnosis;
begin
  result := TFhirEncounterDiagnosis(ObjectByIndex[index]);
end;

function TFhirEncounterDiagnosisList.Link: TFhirEncounterDiagnosisList;
begin
  result := TFhirEncounterDiagnosisList(inherited Link);
end;

procedure TFhirEncounterDiagnosisList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirEncounterDiagnosisList.SetItemByIndex(index: Integer; value: TFhirEncounterDiagnosis);
begin
  assert(value is TFhirEncounterDiagnosis);
  FhirEncounterDiagnoses[index] := value;
end;

procedure TFhirEncounterDiagnosisList.SetItemN(index: Integer; value: TFhirEncounterDiagnosis);
begin
  assert(value is TFhirEncounterDiagnosis);
  ObjectByIndex[index] := value;
end;

{ TFhirEncounterAdmission }

constructor TFhirEncounterAdmission.Create;
begin
  inherited;
end;

destructor TFhirEncounterAdmission.Destroy;
begin
  FPreAdmissionIdentifier.free;
  FOrigin.free;
  FAdmitSource.free;
  FReAdmission.free;
  FDietPreferenceList.Free;
  FSpecialCourtesyList.Free;
  FSpecialArrangementList.Free;
  FDestination.free;
  FDischargeDisposition.free;
  inherited;
end;

procedure TFhirEncounterAdmission.Assign(oSource : TFslObject);
begin
  inherited;
  preAdmissionIdentifier := TFhirEncounterAdmission(oSource).preAdmissionIdentifier.Clone;
  origin := TFhirEncounterAdmission(oSource).origin.Clone;
  admitSource := TFhirEncounterAdmission(oSource).admitSource.Clone;
  reAdmission := TFhirEncounterAdmission(oSource).reAdmission.Clone;
  if (TFhirEncounterAdmission(oSource).FDietPreferenceList = nil) then
  begin
    FDietPreferenceList.free;
    FDietPreferenceList := nil;
  end
  else
  begin
    if FDietPreferenceList = nil then
      FDietPreferenceList := TFhirCodeableConceptList.Create;
    FDietPreferenceList.Assign(TFhirEncounterAdmission(oSource).FDietPreferenceList);
  end;
  if (TFhirEncounterAdmission(oSource).FSpecialCourtesyList = nil) then
  begin
    FSpecialCourtesyList.free;
    FSpecialCourtesyList := nil;
  end
  else
  begin
    if FSpecialCourtesyList = nil then
      FSpecialCourtesyList := TFhirCodeableConceptList.Create;
    FSpecialCourtesyList.Assign(TFhirEncounterAdmission(oSource).FSpecialCourtesyList);
  end;
  if (TFhirEncounterAdmission(oSource).FSpecialArrangementList = nil) then
  begin
    FSpecialArrangementList.free;
    FSpecialArrangementList := nil;
  end
  else
  begin
    if FSpecialArrangementList = nil then
      FSpecialArrangementList := TFhirCodeableConceptList.Create;
    FSpecialArrangementList.Assign(TFhirEncounterAdmission(oSource).FSpecialArrangementList);
  end;
  destination := TFhirEncounterAdmission(oSource).destination.Clone;
  dischargeDisposition := TFhirEncounterAdmission(oSource).dischargeDisposition.Clone;
end;

procedure TFhirEncounterAdmission.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'preAdmissionIdentifier') Then
     list.add(self.link, 'preAdmissionIdentifier', FPreAdmissionIdentifier.Link);
  if (child_name = 'origin') Then
     list.add(self.link, 'origin', FOrigin.Link);
  if (child_name = 'admitSource') Then
     list.add(self.link, 'admitSource', FAdmitSource.Link);
  if (child_name = 'reAdmission') Then
     list.add(self.link, 'reAdmission', FReAdmission.Link);
  if (child_name = 'dietPreference') Then
    list.addAll(self, 'dietPreference', FDietPreferenceList);
  if (child_name = 'specialCourtesy') Then
    list.addAll(self, 'specialCourtesy', FSpecialCourtesyList);
  if (child_name = 'specialArrangement') Then
    list.addAll(self, 'specialArrangement', FSpecialArrangementList);
  if (child_name = 'destination') Then
     list.add(self.link, 'destination', FDestination.Link);
  if (child_name = 'dischargeDisposition') Then
     list.add(self.link, 'dischargeDisposition', FDischargeDisposition.Link);
end;

procedure TFhirEncounterAdmission.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'preAdmissionIdentifier', 'Identifier', false, TFhirIdentifier, FPreAdmissionIdentifier.Link));
  oList.add(TFHIRProperty.create(self, 'origin', 'Reference', false, TFhirReference, FOrigin.Link));
  oList.add(TFHIRProperty.create(self, 'admitSource', 'CodeableConcept', false, TFhirCodeableConcept, FAdmitSource.Link));
  oList.add(TFHIRProperty.create(self, 'reAdmission', 'CodeableConcept', false, TFhirCodeableConcept, FReAdmission.Link));
  oList.add(TFHIRProperty.create(self, 'dietPreference', 'CodeableConcept', true, TFhirCodeableConcept, FDietPreferenceList.Link));
  oList.add(TFHIRProperty.create(self, 'specialCourtesy', 'CodeableConcept', true, TFhirCodeableConcept, FSpecialCourtesyList.Link));
  oList.add(TFHIRProperty.create(self, 'specialArrangement', 'CodeableConcept', true, TFhirCodeableConcept, FSpecialArrangementList.Link));
  oList.add(TFHIRProperty.create(self, 'destination', 'Reference', false, TFhirReference, FDestination.Link));
  oList.add(TFHIRProperty.create(self, 'dischargeDisposition', 'CodeableConcept', false, TFhirCodeableConcept, FDischargeDisposition.Link));
end;

function TFhirEncounterAdmission.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'preAdmissionIdentifier') then
  begin
    PreAdmissionIdentifier := propValue as TFhirIdentifier;
    result := propValue;
  end
  else if (propName = 'origin') then
  begin
    Origin := propValue as TFhirReference;
    result := propValue;
  end
  else if (propName = 'admitSource') then
  begin
    AdmitSource := propValue as TFhirCodeableConcept;
    result := propValue;
  end
  else if (propName = 'reAdmission') then
  begin
    ReAdmission := propValue as TFhirCodeableConcept;
    result := propValue;
  end
  else if (propName = 'dietPreference') then
  begin
    DietPreferenceList.add(propValue as TFhirCodeableConcept);
    result := propValue;
  end
  else if (propName = 'specialCourtesy') then
  begin
    SpecialCourtesyList.add(propValue as TFhirCodeableConcept);
    result := propValue;
  end
  else if (propName = 'specialArrangement') then
  begin
    SpecialArrangementList.add(propValue as TFhirCodeableConcept);
    result := propValue;
  end
  else if (propName = 'destination') then
  begin
    Destination := propValue as TFhirReference;
    result := propValue;
  end
  else if (propName = 'dischargeDisposition') then
  begin
    DischargeDisposition := propValue as TFhirCodeableConcept;
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirEncounterAdmission.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'dietPreference') then DietPreferenceList.insertItem(index, propValue as TFhirCodeableConcept)
  else if (propName = 'specialCourtesy') then SpecialCourtesyList.insertItem(index, propValue as TFhirCodeableConcept)
  else if (propName = 'specialArrangement') then SpecialArrangementList.insertItem(index, propValue as TFhirCodeableConcept)
  else inherited;
end;

function TFhirEncounterAdmission.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'preAdmissionIdentifier') then result := TFhirIdentifier.create()
  else if (propName = 'origin') then result := TFhirReference.create()
  else if (propName = 'admitSource') then result := TFhirCodeableConcept.create()
  else if (propName = 'reAdmission') then result := TFhirCodeableConcept.create()
  else if (propName = 'dietPreference') then result := DietPreferenceList.new()
  else if (propName = 'specialCourtesy') then result := SpecialCourtesyList.new()
  else if (propName = 'specialArrangement') then result := SpecialArrangementList.new()
  else if (propName = 'destination') then result := TFhirReference.create()
  else if (propName = 'dischargeDisposition') then result := TFhirCodeableConcept.create()
  else result := inherited createPropertyValue(propName);
end;

function TFhirEncounterAdmission.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'preAdmissionIdentifier') then result := 'Identifier'
  else if (propName = 'origin') then result := 'Reference'
  else if (propName = 'admitSource') then result := 'CodeableConcept'
  else if (propName = 'reAdmission') then result := 'CodeableConcept'
  else if (propName = 'dietPreference') then result := 'CodeableConcept'
  else if (propName = 'specialCourtesy') then result := 'CodeableConcept'
  else if (propName = 'specialArrangement') then result := 'CodeableConcept'
  else if (propName = 'destination') then result := 'Reference'
  else if (propName = 'dischargeDisposition') then result := 'CodeableConcept'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirEncounterAdmission.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'preAdmissionIdentifier') then PreAdmissionIdentifierElement := nil
  else if (propName = 'origin') then OriginElement := nil
  else if (propName = 'admitSource') then AdmitSourceElement := nil
  else if (propName = 'reAdmission') then ReAdmissionElement := nil
  else if (propName = 'dietPreference') then deletePropertyValue('dietPreference', DietPreferenceList, value)
  else if (propName = 'specialCourtesy') then deletePropertyValue('specialCourtesy', SpecialCourtesyList, value)
  else if (propName = 'specialArrangement') then deletePropertyValue('specialArrangement', SpecialArrangementList, value)
  else if (propName = 'destination') then DestinationElement := nil
  else if (propName = 'dischargeDisposition') then DischargeDispositionElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirEncounterAdmission.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'preAdmissionIdentifier') then PreAdmissionIdentifierElement := new as TFhirIdentifier
  else if (propName = 'origin') then OriginElement := new as TFhirReference
  else if (propName = 'admitSource') then AdmitSourceElement := new as TFhirCodeableConcept
  else if (propName = 'reAdmission') then ReAdmissionElement := new as TFhirCodeableConcept
  else if (propName = 'dietPreference') then replacePropertyValue('dietPreference', DietPreferenceList, existing, new)
  else if (propName = 'specialCourtesy') then replacePropertyValue('specialCourtesy', SpecialCourtesyList, existing, new)
  else if (propName = 'specialArrangement') then replacePropertyValue('specialArrangement', SpecialArrangementList, existing, new)
  else if (propName = 'destination') then DestinationElement := new as TFhirReference
  else if (propName = 'dischargeDisposition') then DischargeDispositionElement := new as TFhirCodeableConcept
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirEncounterAdmission.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'dietPreference') then DietPreferenceList.move(source, destination)
  else if (propName = 'specialCourtesy') then SpecialCourtesyList.move(source, destination)
  else if (propName = 'specialArrangement') then SpecialArrangementList.move(source, destination)
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirEncounterAdmission.fhirType : string;
begin
  result := 'Encounter.admission';
end;

function TFhirEncounterAdmission.Link : TFhirEncounterAdmission;
begin
  result := TFhirEncounterAdmission(inherited Link);
end;

function TFhirEncounterAdmission.Clone : TFhirEncounterAdmission;
begin
  result := TFhirEncounterAdmission(inherited Clone);
end;

function TFhirEncounterAdmission.equals(other : TObject) : boolean; 
var
  o : TFhirEncounterAdmission;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirEncounterAdmission)) then
    result := false
  else
  begin
    o := TFhirEncounterAdmission(other);
    result := compareDeep(preAdmissionIdentifierElement, o.preAdmissionIdentifierElement, true) and 
      compareDeep(originElement, o.originElement, true) and compareDeep(admitSourceElement, o.admitSourceElement, true) and 
      compareDeep(reAdmissionElement, o.reAdmissionElement, true) and compareDeep(dietPreferenceList, o.dietPreferenceList, true) and 
      compareDeep(specialCourtesyList, o.specialCourtesyList, true) and compareDeep(specialArrangementList, o.specialArrangementList, true) and 
      compareDeep(destinationElement, o.destinationElement, true) and compareDeep(dischargeDispositionElement, o.dischargeDispositionElement, true);
  end;
end;

function TFhirEncounterAdmission.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FPreAdmissionIdentifier) and isEmptyProp(FOrigin) and isEmptyProp(FAdmitSource) and isEmptyProp(FReAdmission) and isEmptyProp(FdietPreferenceList) and isEmptyProp(FspecialCourtesyList) and isEmptyProp(FspecialArrangementList) and isEmptyProp(FDestination) and isEmptyProp(FDischargeDisposition);
end;

procedure TFhirEncounterAdmission.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('preAdmissionIdentifier');
  fields.add('origin');
  fields.add('admitSource');
  fields.add('reAdmission');
  fields.add('dietPreference');
  fields.add('specialCourtesy');
  fields.add('specialArrangement');
  fields.add('destination');
  fields.add('dischargeDisposition');
end;

function TFhirEncounterAdmission.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
  inc(result, FDietPreferenceList.sizeInBytes(magic));
  inc(result, FSpecialCourtesyList.sizeInBytes(magic));
  inc(result, FSpecialArrangementList.sizeInBytes(magic));
end;

procedure TFhirEncounterAdmission.SetPreAdmissionIdentifier(value : TFhirIdentifier);
begin
  FPreAdmissionIdentifier.free;
  FPreAdmissionIdentifier := value;
end;

procedure TFhirEncounterAdmission.SetOrigin(value : TFhirReference);
begin
  FOrigin.free;
  FOrigin := value;
end;

procedure TFhirEncounterAdmission.SetAdmitSource(value : TFhirCodeableConcept);
begin
  FAdmitSource.free;
  FAdmitSource := value;
end;

procedure TFhirEncounterAdmission.SetReAdmission(value : TFhirCodeableConcept);
begin
  FReAdmission.free;
  FReAdmission := value;
end;

function TFhirEncounterAdmission.GetDietPreferenceList : TFhirCodeableConceptList;
begin
  if FDietPreferenceList = nil then
    FDietPreferenceList := TFhirCodeableConceptList.Create;
  result := FDietPreferenceList;
end;

function TFhirEncounterAdmission.GetHasDietPreferenceList : boolean;
begin
  result := (FDietPreferenceList <> nil) and (FDietPreferenceList.count > 0);
end;

function TFhirEncounterAdmission.GetSpecialCourtesyList : TFhirCodeableConceptList;
begin
  if FSpecialCourtesyList = nil then
    FSpecialCourtesyList := TFhirCodeableConceptList.Create;
  result := FSpecialCourtesyList;
end;

function TFhirEncounterAdmission.GetHasSpecialCourtesyList : boolean;
begin
  result := (FSpecialCourtesyList <> nil) and (FSpecialCourtesyList.count > 0);
end;

function TFhirEncounterAdmission.GetSpecialArrangementList : TFhirCodeableConceptList;
begin
  if FSpecialArrangementList = nil then
    FSpecialArrangementList := TFhirCodeableConceptList.Create;
  result := FSpecialArrangementList;
end;

function TFhirEncounterAdmission.GetHasSpecialArrangementList : boolean;
begin
  result := (FSpecialArrangementList <> nil) and (FSpecialArrangementList.count > 0);
end;

procedure TFhirEncounterAdmission.SetDestination(value : TFhirReference);
begin
  FDestination.free;
  FDestination := value;
end;

procedure TFhirEncounterAdmission.SetDischargeDisposition(value : TFhirCodeableConcept);
begin
  FDischargeDisposition.free;
  FDischargeDisposition := value;
end;

{ TFhirEncounterAdmissionListEnumerator }

constructor TFhirEncounterAdmissionListEnumerator.Create(list : TFhirEncounterAdmissionList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirEncounterAdmissionListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirEncounterAdmissionListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirEncounterAdmissionListEnumerator.GetCurrent : TFhirEncounterAdmission;
begin
  Result := FList[FIndex];
end;

function TFhirEncounterAdmissionListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirEncounterAdmissionList }

function TFhirEncounterAdmissionList.AddItem(value: TFhirEncounterAdmission): TFhirEncounterAdmission;
begin
  assert(value.ClassName = 'TFhirEncounterAdmission', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirEncounterAdmission');
  add(value);
  result := value;
end;

function TFhirEncounterAdmissionList.Append: TFhirEncounterAdmission;
begin
  result := TFhirEncounterAdmission.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirEncounterAdmissionList.ClearItems;
begin
  Clear;
end;

function TFhirEncounterAdmissionList.GetEnumerator : TFhirEncounterAdmissionListEnumerator;
begin
  result := TFhirEncounterAdmissionListEnumerator.Create(self.link);
end;

function TFhirEncounterAdmissionList.Clone: TFhirEncounterAdmissionList;
begin
  result := TFhirEncounterAdmissionList(inherited Clone);
end;

function TFhirEncounterAdmissionList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirEncounterAdmissionList.GetItemN(index: Integer): TFhirEncounterAdmission;
begin
  result := TFhirEncounterAdmission(ObjectByIndex[index]);
end;

function TFhirEncounterAdmissionList.ItemClass: TFslObjectClass;
begin
  result := TFhirEncounterAdmission;
end;
function TFhirEncounterAdmissionList.IndexOf(value: TFhirEncounterAdmission): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirEncounterAdmissionList.Insert(index: Integer): TFhirEncounterAdmission;
begin
  result := TFhirEncounterAdmission.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirEncounterAdmissionList.InsertItem(index: Integer; value: TFhirEncounterAdmission);
begin
  assert(value is TFhirEncounterAdmission);
  Inherited Insert(index, value);
end;

function TFhirEncounterAdmissionList.Item(index: Integer): TFhirEncounterAdmission;
begin
  result := TFhirEncounterAdmission(ObjectByIndex[index]);
end;

function TFhirEncounterAdmissionList.Link: TFhirEncounterAdmissionList;
begin
  result := TFhirEncounterAdmissionList(inherited Link);
end;

procedure TFhirEncounterAdmissionList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirEncounterAdmissionList.SetItemByIndex(index: Integer; value: TFhirEncounterAdmission);
begin
  assert(value is TFhirEncounterAdmission);
  FhirEncounterAdmissions[index] := value;
end;

procedure TFhirEncounterAdmissionList.SetItemN(index: Integer; value: TFhirEncounterAdmission);
begin
  assert(value is TFhirEncounterAdmission);
  ObjectByIndex[index] := value;
end;

{ TFhirEncounterLocation }

constructor TFhirEncounterLocation.Create;
begin
  inherited;
end;

destructor TFhirEncounterLocation.Destroy;
begin
  FLocation.free;
  FStatus.free;
  FForm.free;
  FPeriod.free;
  inherited;
end;

procedure TFhirEncounterLocation.Assign(oSource : TFslObject);
begin
  inherited;
  location := TFhirEncounterLocation(oSource).location.Clone;
  statusElement := TFhirEncounterLocation(oSource).statusElement.Clone;
  form := TFhirEncounterLocation(oSource).form.Clone;
  period := TFhirEncounterLocation(oSource).period.Clone;
end;

procedure TFhirEncounterLocation.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'location') Then
     list.add(self.link, 'location', FLocation.Link);
  if (child_name = 'status') Then
     list.add(self.link, 'status', FStatus.Link);
  if (child_name = 'form') Then
     list.add(self.link, 'form', FForm.Link);
  if (child_name = 'period') Then
     list.add(self.link, 'period', FPeriod.Link);
end;

procedure TFhirEncounterLocation.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'location', 'Reference', false, TFhirReference, FLocation.Link));
  oList.add(TFHIRProperty.create(self, 'status', 'code', false, TFhirEnum, FStatus.Link));
  oList.add(TFHIRProperty.create(self, 'form', 'CodeableConcept', false, TFhirCodeableConcept, FForm.Link));
  oList.add(TFHIRProperty.create(self, 'period', 'Period', false, TFhirPeriod, FPeriod.Link));
end;

function TFhirEncounterLocation.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'location') then
  begin
    Location := propValue as TFhirReference;
    result := propValue;
  end
  else if (propName = 'status') then
  begin
    StatusElement := asEnum(SYSTEMS_TFhirEncounterLocationStatusEnum, CODES_TFhirEncounterLocationStatusEnum, propValue);
    result := propValue;
  end
  else if (propName = 'form') then
  begin
    Form := propValue as TFhirCodeableConcept;
    result := propValue;
  end
  else if (propName = 'period') then
  begin
    Period := propValue as TFhirPeriod;
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirEncounterLocation.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirEncounterLocation.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'location') then result := TFhirReference.create()
  else if (propName = 'status') then result := TFhirEnum.create(SYSTEMS_TFhirEncounterLocationStatusEnum[EncounterLocationStatusNull], CODES_TFhirEncounterLocationStatusEnum[EncounterLocationStatusNull]) 
  else if (propName = 'form') then result := TFhirCodeableConcept.create()
  else if (propName = 'period') then result := TFhirPeriod.create()
  else result := inherited createPropertyValue(propName);
end;

function TFhirEncounterLocation.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'location') then result := 'Reference'
  else if (propName = 'status') then result := 'code'
  else if (propName = 'form') then result := 'CodeableConcept'
  else if (propName = 'period') then result := 'Period'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirEncounterLocation.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'location') then LocationElement := nil
  else if (propName = 'status') then StatusElement := nil
  else if (propName = 'form') then FormElement := nil
  else if (propName = 'period') then PeriodElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirEncounterLocation.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'location') then LocationElement := new as TFhirReference
  else if (propName = 'status') then StatusElement := asEnum(SYSTEMS_TFhirEncounterLocationStatusEnum, CODES_TFhirEncounterLocationStatusEnum, new)
  else if (propName = 'form') then FormElement := new as TFhirCodeableConcept
  else if (propName = 'period') then PeriodElement := new as TFhirPeriod
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirEncounterLocation.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirEncounterLocation.fhirType : string;
begin
  result := 'Encounter.location';
end;

function TFhirEncounterLocation.Link : TFhirEncounterLocation;
begin
  result := TFhirEncounterLocation(inherited Link);
end;

function TFhirEncounterLocation.Clone : TFhirEncounterLocation;
begin
  result := TFhirEncounterLocation(inherited Clone);
end;

function TFhirEncounterLocation.equals(other : TObject) : boolean; 
var
  o : TFhirEncounterLocation;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirEncounterLocation)) then
    result := false
  else
  begin
    o := TFhirEncounterLocation(other);
    result := compareDeep(locationElement, o.locationElement, true) and compareDeep(statusElement, o.statusElement, true) and 
      compareDeep(formElement, o.formElement, true) and compareDeep(periodElement, o.periodElement, true);
  end;
end;

function TFhirEncounterLocation.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FLocation) and isEmptyProp(FStatus) and isEmptyProp(FForm) and isEmptyProp(FPeriod);
end;

procedure TFhirEncounterLocation.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('location');
  fields.add('status');
  fields.add('form');
  fields.add('period');
end;

function TFhirEncounterLocation.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
end;

procedure TFhirEncounterLocation.SetLocation(value : TFhirReference);
begin
  FLocation.free;
  FLocation := value;
end;

procedure TFhirEncounterLocation.SetStatus(value : TFhirEnum);
begin
  FStatus.free;
  FStatus := value;
end;

function TFhirEncounterLocation.GetStatusST : TFhirEncounterLocationStatusEnum;
begin
  if FStatus = nil then
    result := TFhirEncounterLocationStatusEnum(0)
  else
    result := TFhirEncounterLocationStatusEnum(StringArrayIndexOfSensitive(CODES_TFhirEncounterLocationStatusEnum, FStatus.value));
end;

procedure TFhirEncounterLocation.SetStatusST(value : TFhirEncounterLocationStatusEnum);
begin
  if ord(value) = 0 then
    StatusElement := nil
  else
    StatusElement := TFhirEnum.create(SYSTEMS_TFhirEncounterLocationStatusEnum[value], CODES_TFhirEncounterLocationStatusEnum[value]);
end;

procedure TFhirEncounterLocation.SetForm(value : TFhirCodeableConcept);
begin
  FForm.free;
  FForm := value;
end;

procedure TFhirEncounterLocation.SetPeriod(value : TFhirPeriod);
begin
  FPeriod.free;
  FPeriod := value;
end;

{ TFhirEncounterLocationListEnumerator }

constructor TFhirEncounterLocationListEnumerator.Create(list : TFhirEncounterLocationList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirEncounterLocationListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirEncounterLocationListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirEncounterLocationListEnumerator.GetCurrent : TFhirEncounterLocation;
begin
  Result := FList[FIndex];
end;

function TFhirEncounterLocationListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirEncounterLocationList }

function TFhirEncounterLocationList.AddItem(value: TFhirEncounterLocation): TFhirEncounterLocation;
begin
  assert(value.ClassName = 'TFhirEncounterLocation', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirEncounterLocation');
  add(value);
  result := value;
end;

function TFhirEncounterLocationList.Append: TFhirEncounterLocation;
begin
  result := TFhirEncounterLocation.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirEncounterLocationList.ClearItems;
begin
  Clear;
end;

function TFhirEncounterLocationList.GetEnumerator : TFhirEncounterLocationListEnumerator;
begin
  result := TFhirEncounterLocationListEnumerator.Create(self.link);
end;

function TFhirEncounterLocationList.Clone: TFhirEncounterLocationList;
begin
  result := TFhirEncounterLocationList(inherited Clone);
end;

function TFhirEncounterLocationList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirEncounterLocationList.GetItemN(index: Integer): TFhirEncounterLocation;
begin
  result := TFhirEncounterLocation(ObjectByIndex[index]);
end;

function TFhirEncounterLocationList.ItemClass: TFslObjectClass;
begin
  result := TFhirEncounterLocation;
end;
function TFhirEncounterLocationList.IndexOf(value: TFhirEncounterLocation): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirEncounterLocationList.Insert(index: Integer): TFhirEncounterLocation;
begin
  result := TFhirEncounterLocation.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirEncounterLocationList.InsertItem(index: Integer; value: TFhirEncounterLocation);
begin
  assert(value is TFhirEncounterLocation);
  Inherited Insert(index, value);
end;

function TFhirEncounterLocationList.Item(index: Integer): TFhirEncounterLocation;
begin
  result := TFhirEncounterLocation(ObjectByIndex[index]);
end;

function TFhirEncounterLocationList.Link: TFhirEncounterLocationList;
begin
  result := TFhirEncounterLocationList(inherited Link);
end;

procedure TFhirEncounterLocationList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirEncounterLocationList.SetItemByIndex(index: Integer; value: TFhirEncounterLocation);
begin
  assert(value is TFhirEncounterLocation);
  FhirEncounterLocations[index] := value;
end;

procedure TFhirEncounterLocationList.SetItemN(index: Integer; value: TFhirEncounterLocation);
begin
  assert(value is TFhirEncounterLocation);
  ObjectByIndex[index] := value;
end;

{ TFhirEncounter }

constructor TFhirEncounter.Create;
begin
  inherited;
end;

destructor TFhirEncounter.Destroy;
begin
  FIdentifierList.Free;
  FStatus.free;
  FStatusHistoryList.Free;
  FClass_List.Free;
  FClassHistoryList.Free;
  FPriority.free;
  FType_List.Free;
  FServiceTypeList.Free;
  FSubject.free;
  FSubjectStatus.free;
  FEpisodeOfCareList.Free;
  FBasedOnList.Free;
  FCareTeamList.Free;
  FPartOf.free;
  FServiceProvider.free;
  FParticipantList.Free;
  FAppointmentList.Free;
  FVirtualServiceList.Free;
  FActualPeriod.free;
  FPlannedStartDate.free;
  FPlannedEndDate.free;
  FLength.free;
  FReasonList.Free;
  FDiagnosisList.Free;
  FAccountList.Free;
  FAdmission.free;
  FLocationList.Free;
  inherited;
end;

procedure TFhirEncounter.Assign(oSource : TFslObject);
begin
  inherited;
  if (TFhirEncounter(oSource).FIdentifierList = nil) then
  begin
    FIdentifierList.free;
    FIdentifierList := nil;
  end
  else
  begin
    if FIdentifierList = nil then
      FIdentifierList := TFhirIdentifierList.Create;
    FIdentifierList.Assign(TFhirEncounter(oSource).FIdentifierList);
  end;
  statusElement := TFhirEncounter(oSource).statusElement.Clone;
  if (TFhirEncounter(oSource).FStatusHistoryList = nil) then
  begin
    FStatusHistoryList.free;
    FStatusHistoryList := nil;
  end
  else
  begin
    if FStatusHistoryList = nil then
      FStatusHistoryList := TFhirEncounterStatusHistoryList.Create;
    FStatusHistoryList.Assign(TFhirEncounter(oSource).FStatusHistoryList);
  end;
  if (TFhirEncounter(oSource).FClass_List = nil) then
  begin
    FClass_List.free;
    FClass_List := nil;
  end
  else
  begin
    if FClass_List = nil then
      FClass_List := TFhirCodeableConceptList.Create;
    FClass_List.Assign(TFhirEncounter(oSource).FClass_List);
  end;
  if (TFhirEncounter(oSource).FClassHistoryList = nil) then
  begin
    FClassHistoryList.free;
    FClassHistoryList := nil;
  end
  else
  begin
    if FClassHistoryList = nil then
      FClassHistoryList := TFhirEncounterClassHistoryList.Create;
    FClassHistoryList.Assign(TFhirEncounter(oSource).FClassHistoryList);
  end;
  priority := TFhirEncounter(oSource).priority.Clone;
  if (TFhirEncounter(oSource).FType_List = nil) then
  begin
    FType_List.free;
    FType_List := nil;
  end
  else
  begin
    if FType_List = nil then
      FType_List := TFhirCodeableConceptList.Create;
    FType_List.Assign(TFhirEncounter(oSource).FType_List);
  end;
  if (TFhirEncounter(oSource).FServiceTypeList = nil) then
  begin
    FServiceTypeList.free;
    FServiceTypeList := nil;
  end
  else
  begin
    if FServiceTypeList = nil then
      FServiceTypeList := TFhirCodeableReferenceList.Create;
    FServiceTypeList.Assign(TFhirEncounter(oSource).FServiceTypeList);
  end;
  subject := TFhirEncounter(oSource).subject.Clone;
  subjectStatus := TFhirEncounter(oSource).subjectStatus.Clone;
  if (TFhirEncounter(oSource).FEpisodeOfCareList = nil) then
  begin
    FEpisodeOfCareList.free;
    FEpisodeOfCareList := nil;
  end
  else
  begin
    if FEpisodeOfCareList = nil then
      FEpisodeOfCareList := TFhirReferenceList.Create;
    FEpisodeOfCareList.Assign(TFhirEncounter(oSource).FEpisodeOfCareList);
  end;
  if (TFhirEncounter(oSource).FBasedOnList = nil) then
  begin
    FBasedOnList.free;
    FBasedOnList := nil;
  end
  else
  begin
    if FBasedOnList = nil then
      FBasedOnList := TFhirReferenceList.Create;
    FBasedOnList.Assign(TFhirEncounter(oSource).FBasedOnList);
  end;
  if (TFhirEncounter(oSource).FCareTeamList = nil) then
  begin
    FCareTeamList.free;
    FCareTeamList := nil;
  end
  else
  begin
    if FCareTeamList = nil then
      FCareTeamList := TFhirReferenceList.Create;
    FCareTeamList.Assign(TFhirEncounter(oSource).FCareTeamList);
  end;
  partOf := TFhirEncounter(oSource).partOf.Clone;
  serviceProvider := TFhirEncounter(oSource).serviceProvider.Clone;
  if (TFhirEncounter(oSource).FParticipantList = nil) then
  begin
    FParticipantList.free;
    FParticipantList := nil;
  end
  else
  begin
    if FParticipantList = nil then
      FParticipantList := TFhirEncounterParticipantList.Create;
    FParticipantList.Assign(TFhirEncounter(oSource).FParticipantList);
  end;
  if (TFhirEncounter(oSource).FAppointmentList = nil) then
  begin
    FAppointmentList.free;
    FAppointmentList := nil;
  end
  else
  begin
    if FAppointmentList = nil then
      FAppointmentList := TFhirReferenceList.Create;
    FAppointmentList.Assign(TFhirEncounter(oSource).FAppointmentList);
  end;
  if (TFhirEncounter(oSource).FVirtualServiceList = nil) then
  begin
    FVirtualServiceList.free;
    FVirtualServiceList := nil;
  end
  else
  begin
    if FVirtualServiceList = nil then
      FVirtualServiceList := TFhirVirtualServiceDetailList.Create;
    FVirtualServiceList.Assign(TFhirEncounter(oSource).FVirtualServiceList);
  end;
  actualPeriod := TFhirEncounter(oSource).actualPeriod.Clone;
  plannedStartDateElement := TFhirEncounter(oSource).plannedStartDateElement.Clone;
  plannedEndDateElement := TFhirEncounter(oSource).plannedEndDateElement.Clone;
  length := TFhirEncounter(oSource).length.Clone;
  if (TFhirEncounter(oSource).FReasonList = nil) then
  begin
    FReasonList.free;
    FReasonList := nil;
  end
  else
  begin
    if FReasonList = nil then
      FReasonList := TFhirCodeableReferenceList.Create;
    FReasonList.Assign(TFhirEncounter(oSource).FReasonList);
  end;
  if (TFhirEncounter(oSource).FDiagnosisList = nil) then
  begin
    FDiagnosisList.free;
    FDiagnosisList := nil;
  end
  else
  begin
    if FDiagnosisList = nil then
      FDiagnosisList := TFhirEncounterDiagnosisList.Create;
    FDiagnosisList.Assign(TFhirEncounter(oSource).FDiagnosisList);
  end;
  if (TFhirEncounter(oSource).FAccountList = nil) then
  begin
    FAccountList.free;
    FAccountList := nil;
  end
  else
  begin
    if FAccountList = nil then
      FAccountList := TFhirReferenceList.Create;
    FAccountList.Assign(TFhirEncounter(oSource).FAccountList);
  end;
  admission := TFhirEncounter(oSource).admission.Clone;
  if (TFhirEncounter(oSource).FLocationList = nil) then
  begin
    FLocationList.free;
    FLocationList := nil;
  end
  else
  begin
    if FLocationList = nil then
      FLocationList := TFhirEncounterLocationList.Create;
    FLocationList.Assign(TFhirEncounter(oSource).FLocationList);
  end;
end;

function TFhirEncounter.GetResourceType : TFhirResourceType;
begin
  result := frtEncounter;
end;

procedure TFhirEncounter.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'identifier') Then
    list.addAll(self, 'identifier', FIdentifierList);
  if (child_name = 'status') Then
     list.add(self.link, 'status', FStatus.Link);
  if (child_name = 'statusHistory') Then
    list.addAll(self, 'statusHistory', FStatusHistoryList);
  if (child_name = 'class') Then
    list.addAll(self, 'class', FClass_List);
  if (child_name = 'classHistory') Then
    list.addAll(self, 'classHistory', FClassHistoryList);
  if (child_name = 'priority') Then
     list.add(self.link, 'priority', FPriority.Link);
  if (child_name = 'type') Then
    list.addAll(self, 'type', FType_List);
  if (child_name = 'serviceType') Then
    list.addAll(self, 'serviceType', FServiceTypeList);
  if (child_name = 'subject') Then
     list.add(self.link, 'subject', FSubject.Link);
  if (child_name = 'subjectStatus') Then
     list.add(self.link, 'subjectStatus', FSubjectStatus.Link);
  if (child_name = 'episodeOfCare') Then
    list.addAll(self, 'episodeOfCare', FEpisodeOfCareList);
  if (child_name = 'basedOn') Then
    list.addAll(self, 'basedOn', FBasedOnList);
  if (child_name = 'careTeam') Then
    list.addAll(self, 'careTeam', FCareTeamList);
  if (child_name = 'partOf') Then
     list.add(self.link, 'partOf', FPartOf.Link);
  if (child_name = 'serviceProvider') Then
     list.add(self.link, 'serviceProvider', FServiceProvider.Link);
  if (child_name = 'participant') Then
    list.addAll(self, 'participant', FParticipantList);
  if (child_name = 'appointment') Then
    list.addAll(self, 'appointment', FAppointmentList);
  if (child_name = 'virtualService') Then
    list.addAll(self, 'virtualService', FVirtualServiceList);
  if (child_name = 'actualPeriod') Then
     list.add(self.link, 'actualPeriod', FActualPeriod.Link);
  if (child_name = 'plannedStartDate') Then
     list.add(self.link, 'plannedStartDate', FPlannedStartDate.Link);
  if (child_name = 'plannedEndDate') Then
     list.add(self.link, 'plannedEndDate', FPlannedEndDate.Link);
  if (child_name = 'length') Then
     list.add(self.link, 'length', FLength.Link);
  if (child_name = 'reason') Then
    list.addAll(self, 'reason', FReasonList);
  if (child_name = 'diagnosis') Then
    list.addAll(self, 'diagnosis', FDiagnosisList);
  if (child_name = 'account') Then
    list.addAll(self, 'account', FAccountList);
  if (child_name = 'admission') Then
     list.add(self.link, 'admission', FAdmission.Link);
  if (child_name = 'location') Then
    list.addAll(self, 'location', FLocationList);
end;

procedure TFhirEncounter.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'identifier', 'Identifier', true, TFhirIdentifier, FIdentifierList.Link));
  oList.add(TFHIRProperty.create(self, 'status', 'code', false, TFhirEnum, FStatus.Link));
  oList.add(TFHIRProperty.create(self, 'statusHistory', 'BackboneElement', true, TFhirEncounterStatusHistory, FStatusHistoryList.Link));
  oList.add(TFHIRProperty.create(self, 'class', 'CodeableConcept', true, TFhirCodeableConcept, FClass_List.Link));
  oList.add(TFHIRProperty.create(self, 'classHistory', 'BackboneElement', true, TFhirEncounterClassHistory, FClassHistoryList.Link));
  oList.add(TFHIRProperty.create(self, 'priority', 'CodeableConcept', false, TFhirCodeableConcept, FPriority.Link));
  oList.add(TFHIRProperty.create(self, 'type', 'CodeableConcept', true, TFhirCodeableConcept, FType_List.Link));
  oList.add(TFHIRProperty.create(self, 'serviceType', 'CodeableReference', true, TFhirCodeableReference, FServiceTypeList.Link));
  oList.add(TFHIRProperty.create(self, 'subject', 'Reference', false, TFhirReference, FSubject.Link));
  oList.add(TFHIRProperty.create(self, 'subjectStatus', 'CodeableConcept', false, TFhirCodeableConcept, FSubjectStatus.Link));
  oList.add(TFHIRProperty.create(self, 'episodeOfCare', 'Reference', true, TFhirReference, FEpisodeOfCareList.Link));
  oList.add(TFHIRProperty.create(self, 'basedOn', 'Reference', true, TFhirReference, FBasedOnList.Link));
  oList.add(TFHIRProperty.create(self, 'careTeam', 'Reference', true, TFhirReference, FCareTeamList.Link));
  oList.add(TFHIRProperty.create(self, 'partOf', 'Reference', false, TFhirReference, FPartOf.Link));
  oList.add(TFHIRProperty.create(self, 'serviceProvider', 'Reference', false, TFhirReference, FServiceProvider.Link));
  oList.add(TFHIRProperty.create(self, 'participant', 'BackboneElement', true, TFhirEncounterParticipant, FParticipantList.Link));
  oList.add(TFHIRProperty.create(self, 'appointment', 'Reference', true, TFhirReference, FAppointmentList.Link));
  oList.add(TFHIRProperty.create(self, 'virtualService', 'VirtualServiceDetail', true, TFhirVirtualServiceDetail, FVirtualServiceList.Link));
  oList.add(TFHIRProperty.create(self, 'actualPeriod', 'Period', false, TFhirPeriod, FActualPeriod.Link));
  oList.add(TFHIRProperty.create(self, 'plannedStartDate', 'dateTime', false, TFhirDateTime, FPlannedStartDate.Link));
  oList.add(TFHIRProperty.create(self, 'plannedEndDate', 'dateTime', false, TFhirDateTime, FPlannedEndDate.Link));
  oList.add(TFHIRProperty.create(self, 'length', 'Duration', false, TFhirDuration, FLength.Link));
  oList.add(TFHIRProperty.create(self, 'reason', 'CodeableReference', true, TFhirCodeableReference, FReasonList.Link));
  oList.add(TFHIRProperty.create(self, 'diagnosis', 'BackboneElement', true, TFhirEncounterDiagnosis, FDiagnosisList.Link));
  oList.add(TFHIRProperty.create(self, 'account', 'Reference', true, TFhirReference, FAccountList.Link));
  oList.add(TFHIRProperty.create(self, 'admission', 'BackboneElement', false, TFhirEncounterAdmission, FAdmission.Link));
  oList.add(TFHIRProperty.create(self, 'location', 'BackboneElement', true, TFhirEncounterLocation, FLocationList.Link));
end;

function TFhirEncounter.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'identifier') then
  begin
    IdentifierList.add(propValue as TFhirIdentifier);
    result := propValue;
  end
  else if (propName = 'status') then
  begin
    StatusElement := asEnum(SYSTEMS_TFhirEncounterStatusEnum, CODES_TFhirEncounterStatusEnum, propValue);
    result := propValue;
  end
  else if (propName = 'statusHistory') then
  begin
    StatusHistoryList.add(propValue as TFhirEncounterStatusHistory);
    result := propValue;
  end
  else if (propName = 'class') then
  begin
    Class_List.add(propValue as TFhirCodeableConcept);
    result := propValue;
  end
  else if (propName = 'classHistory') then
  begin
    ClassHistoryList.add(propValue as TFhirEncounterClassHistory);
    result := propValue;
  end
  else if (propName = 'priority') then
  begin
    Priority := propValue as TFhirCodeableConcept;
    result := propValue;
  end
  else if (propName = 'type') then
  begin
    Type_List.add(propValue as TFhirCodeableConcept);
    result := propValue;
  end
  else if (propName = 'serviceType') then
  begin
    ServiceTypeList.add(propValue as TFhirCodeableReference);
    result := propValue;
  end
  else if (propName = 'subject') then
  begin
    Subject := propValue as TFhirReference;
    result := propValue;
  end
  else if (propName = 'subjectStatus') then
  begin
    SubjectStatus := propValue as TFhirCodeableConcept;
    result := propValue;
  end
  else if (propName = 'episodeOfCare') then
  begin
    EpisodeOfCareList.add(propValue as TFhirReference);
    result := propValue;
  end
  else if (propName = 'basedOn') then
  begin
    BasedOnList.add(propValue as TFhirReference);
    result := propValue;
  end
  else if (propName = 'careTeam') then
  begin
    CareTeamList.add(propValue as TFhirReference);
    result := propValue;
  end
  else if (propName = 'partOf') then
  begin
    PartOf := propValue as TFhirReference;
    result := propValue;
  end
  else if (propName = 'serviceProvider') then
  begin
    ServiceProvider := propValue as TFhirReference;
    result := propValue;
  end
  else if (propName = 'participant') then
  begin
    ParticipantList.add(propValue as TFhirEncounterParticipant);
    result := propValue;
  end
  else if (propName = 'appointment') then
  begin
    AppointmentList.add(propValue as TFhirReference);
    result := propValue;
  end
  else if (propName = 'virtualService') then
  begin
    VirtualServiceList.add(propValue as TFhirVirtualServiceDetail);
    result := propValue;
  end
  else if (propName = 'actualPeriod') then
  begin
    ActualPeriod := propValue as TFhirPeriod;
    result := propValue;
  end
  else if (propName = 'plannedStartDate') then
  begin
    PlannedStartDateElement := asDateTime(propValue);
    result := propValue;
  end
  else if (propName = 'plannedEndDate') then
  begin
    PlannedEndDateElement := asDateTime(propValue);
    result := propValue;
  end
  else if (propName = 'length') then
  begin
    Length := propValue as TFhirDuration;
    result := propValue;
  end
  else if (propName = 'reason') then
  begin
    ReasonList.add(propValue as TFhirCodeableReference);
    result := propValue;
  end
  else if (propName = 'diagnosis') then
  begin
    DiagnosisList.add(propValue as TFhirEncounterDiagnosis);
    result := propValue;
  end
  else if (propName = 'account') then
  begin
    AccountList.add(propValue as TFhirReference);
    result := propValue;
  end
  else if (propName = 'admission') then
  begin
    Admission := propValue as TFhirEncounterAdmission;
    result := propValue;
  end
  else if (propName = 'location') then
  begin
    LocationList.add(propValue as TFhirEncounterLocation);
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirEncounter.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'identifier') then IdentifierList.insertItem(index, propValue as TFhirIdentifier)
  else if (propName = 'statusHistory') then StatusHistoryList.insertItem(index, propValue as TFhirEncounterStatusHistory)
  else if (propName = 'class') then Class_List.insertItem(index, propValue as TFhirCodeableConcept)
  else if (propName = 'classHistory') then ClassHistoryList.insertItem(index, propValue as TFhirEncounterClassHistory)
  else if (propName = 'type') then Type_List.insertItem(index, propValue as TFhirCodeableConcept)
  else if (propName = 'serviceType') then ServiceTypeList.insertItem(index, propValue as TFhirCodeableReference)
  else if (propName = 'episodeOfCare') then EpisodeOfCareList.insertItem(index, propValue as TFhirReference)
  else if (propName = 'basedOn') then BasedOnList.insertItem(index, propValue as TFhirReference)
  else if (propName = 'careTeam') then CareTeamList.insertItem(index, propValue as TFhirReference)
  else if (propName = 'participant') then ParticipantList.insertItem(index, propValue as TFhirEncounterParticipant)
  else if (propName = 'appointment') then AppointmentList.insertItem(index, propValue as TFhirReference)
  else if (propName = 'virtualService') then VirtualServiceList.insertItem(index, propValue as TFhirVirtualServiceDetail)
  else if (propName = 'reason') then ReasonList.insertItem(index, propValue as TFhirCodeableReference)
  else if (propName = 'diagnosis') then DiagnosisList.insertItem(index, propValue as TFhirEncounterDiagnosis)
  else if (propName = 'account') then AccountList.insertItem(index, propValue as TFhirReference)
  else if (propName = 'location') then LocationList.insertItem(index, propValue as TFhirEncounterLocation)
  else inherited;
end;

function TFhirEncounter.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'identifier') then result := IdentifierList.new()
  else if (propName = 'status') then result := TFhirEnum.create(SYSTEMS_TFhirEncounterStatusEnum[EncounterStatusNull], CODES_TFhirEncounterStatusEnum[EncounterStatusNull]) 
  else if (propName = 'statusHistory') then result := StatusHistoryList.new()
  else if (propName = 'class') then result := Class_List.new()
  else if (propName = 'classHistory') then result := ClassHistoryList.new()
  else if (propName = 'priority') then result := TFhirCodeableConcept.create()
  else if (propName = 'type') then result := Type_List.new()
  else if (propName = 'serviceType') then result := ServiceTypeList.new()
  else if (propName = 'subject') then result := TFhirReference.create()
  else if (propName = 'subjectStatus') then result := TFhirCodeableConcept.create()
  else if (propName = 'episodeOfCare') then result := EpisodeOfCareList.new()
  else if (propName = 'basedOn') then result := BasedOnList.new()
  else if (propName = 'careTeam') then result := CareTeamList.new()
  else if (propName = 'partOf') then result := TFhirReference.create()
  else if (propName = 'serviceProvider') then result := TFhirReference.create()
  else if (propName = 'participant') then result := ParticipantList.new()
  else if (propName = 'appointment') then result := AppointmentList.new()
  else if (propName = 'virtualService') then result := VirtualServiceList.new()
  else if (propName = 'actualPeriod') then result := TFhirPeriod.create()
  else if (propName = 'plannedStartDate') then result := TFhirDateTime.create()
  else if (propName = 'plannedEndDate') then result := TFhirDateTime.create()
  else if (propName = 'length') then result := TFhirDuration.create()
  else if (propName = 'reason') then result := ReasonList.new()
  else if (propName = 'diagnosis') then result := DiagnosisList.new()
  else if (propName = 'account') then result := AccountList.new()
  else if (propName = 'admission') then result := TFhirEncounterAdmission.create()
  else if (propName = 'location') then result := LocationList.new()
  else result := inherited createPropertyValue(propName);
end;

function TFhirEncounter.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'identifier') then result := 'Identifier'
  else if (propName = 'status') then result := 'code'
  else if (propName = 'statusHistory') then result := 'BackboneElement'
  else if (propName = 'class') then result := 'CodeableConcept'
  else if (propName = 'classHistory') then result := 'BackboneElement'
  else if (propName = 'priority') then result := 'CodeableConcept'
  else if (propName = 'type') then result := 'CodeableConcept'
  else if (propName = 'serviceType') then result := 'CodeableReference'
  else if (propName = 'subject') then result := 'Reference'
  else if (propName = 'subjectStatus') then result := 'CodeableConcept'
  else if (propName = 'episodeOfCare') then result := 'Reference'
  else if (propName = 'basedOn') then result := 'Reference'
  else if (propName = 'careTeam') then result := 'Reference'
  else if (propName = 'partOf') then result := 'Reference'
  else if (propName = 'serviceProvider') then result := 'Reference'
  else if (propName = 'participant') then result := 'BackboneElement'
  else if (propName = 'appointment') then result := 'Reference'
  else if (propName = 'virtualService') then result := 'VirtualServiceDetail'
  else if (propName = 'actualPeriod') then result := 'Period'
  else if (propName = 'plannedStartDate') then result := 'dateTime'
  else if (propName = 'plannedEndDate') then result := 'dateTime'
  else if (propName = 'length') then result := 'Duration'
  else if (propName = 'reason') then result := 'CodeableReference'
  else if (propName = 'diagnosis') then result := 'BackboneElement'
  else if (propName = 'account') then result := 'Reference'
  else if (propName = 'admission') then result := 'BackboneElement'
  else if (propName = 'location') then result := 'BackboneElement'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirEncounter.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'identifier') then deletePropertyValue('identifier', IdentifierList, value)
  else if (propName = 'status') then StatusElement := nil
  else if (propName = 'statusHistory') then deletePropertyValue('statusHistory', StatusHistoryList, value)
  else if (propName = 'class') then deletePropertyValue('class', Class_List, value)
  else if (propName = 'classHistory') then deletePropertyValue('classHistory', ClassHistoryList, value)
  else if (propName = 'priority') then PriorityElement := nil
  else if (propName = 'type') then deletePropertyValue('type', Type_List, value)
  else if (propName = 'serviceType') then deletePropertyValue('serviceType', ServiceTypeList, value)
  else if (propName = 'subject') then SubjectElement := nil
  else if (propName = 'subjectStatus') then SubjectStatusElement := nil
  else if (propName = 'episodeOfCare') then deletePropertyValue('episodeOfCare', EpisodeOfCareList, value)
  else if (propName = 'basedOn') then deletePropertyValue('basedOn', BasedOnList, value)
  else if (propName = 'careTeam') then deletePropertyValue('careTeam', CareTeamList, value)
  else if (propName = 'partOf') then PartOfElement := nil
  else if (propName = 'serviceProvider') then ServiceProviderElement := nil
  else if (propName = 'participant') then deletePropertyValue('participant', ParticipantList, value)
  else if (propName = 'appointment') then deletePropertyValue('appointment', AppointmentList, value)
  else if (propName = 'virtualService') then deletePropertyValue('virtualService', VirtualServiceList, value)
  else if (propName = 'actualPeriod') then ActualPeriodElement := nil
  else if (propName = 'plannedStartDate') then PlannedStartDateElement := nil
  else if (propName = 'plannedEndDate') then PlannedEndDateElement := nil
  else if (propName = 'length') then LengthElement := nil
  else if (propName = 'reason') then deletePropertyValue('reason', ReasonList, value)
  else if (propName = 'diagnosis') then deletePropertyValue('diagnosis', DiagnosisList, value)
  else if (propName = 'account') then deletePropertyValue('account', AccountList, value)
  else if (propName = 'admission') then AdmissionElement := nil
  else if (propName = 'location') then deletePropertyValue('location', LocationList, value)
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirEncounter.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'identifier') then replacePropertyValue('identifier', IdentifierList, existing, new)
  else if (propName = 'status') then StatusElement := asEnum(SYSTEMS_TFhirEncounterStatusEnum, CODES_TFhirEncounterStatusEnum, new)
  else if (propName = 'statusHistory') then replacePropertyValue('statusHistory', StatusHistoryList, existing, new)
  else if (propName = 'class') then replacePropertyValue('class', Class_List, existing, new)
  else if (propName = 'classHistory') then replacePropertyValue('classHistory', ClassHistoryList, existing, new)
  else if (propName = 'priority') then PriorityElement := new as TFhirCodeableConcept
  else if (propName = 'type') then replacePropertyValue('type', Type_List, existing, new)
  else if (propName = 'serviceType') then replacePropertyValue('serviceType', ServiceTypeList, existing, new)
  else if (propName = 'subject') then SubjectElement := new as TFhirReference
  else if (propName = 'subjectStatus') then SubjectStatusElement := new as TFhirCodeableConcept
  else if (propName = 'episodeOfCare') then replacePropertyValue('episodeOfCare', EpisodeOfCareList, existing, new)
  else if (propName = 'basedOn') then replacePropertyValue('basedOn', BasedOnList, existing, new)
  else if (propName = 'careTeam') then replacePropertyValue('careTeam', CareTeamList, existing, new)
  else if (propName = 'partOf') then PartOfElement := new as TFhirReference
  else if (propName = 'serviceProvider') then ServiceProviderElement := new as TFhirReference
  else if (propName = 'participant') then replacePropertyValue('participant', ParticipantList, existing, new)
  else if (propName = 'appointment') then replacePropertyValue('appointment', AppointmentList, existing, new)
  else if (propName = 'virtualService') then replacePropertyValue('virtualService', VirtualServiceList, existing, new)
  else if (propName = 'actualPeriod') then ActualPeriodElement := new as TFhirPeriod
  else if (propName = 'plannedStartDate') then PlannedStartDateElement := asDateTime(new)
  else if (propName = 'plannedEndDate') then PlannedEndDateElement := asDateTime(new)
  else if (propName = 'length') then LengthElement := new as TFhirDuration
  else if (propName = 'reason') then replacePropertyValue('reason', ReasonList, existing, new)
  else if (propName = 'diagnosis') then replacePropertyValue('diagnosis', DiagnosisList, existing, new)
  else if (propName = 'account') then replacePropertyValue('account', AccountList, existing, new)
  else if (propName = 'admission') then AdmissionElement := new as TFhirEncounterAdmission
  else if (propName = 'location') then replacePropertyValue('location', LocationList, existing, new)
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirEncounter.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'identifier') then IdentifierList.move(source, destination)
  else if (propName = 'statusHistory') then StatusHistoryList.move(source, destination)
  else if (propName = 'class') then Class_List.move(source, destination)
  else if (propName = 'classHistory') then ClassHistoryList.move(source, destination)
  else if (propName = 'type') then Type_List.move(source, destination)
  else if (propName = 'serviceType') then ServiceTypeList.move(source, destination)
  else if (propName = 'episodeOfCare') then EpisodeOfCareList.move(source, destination)
  else if (propName = 'basedOn') then BasedOnList.move(source, destination)
  else if (propName = 'careTeam') then CareTeamList.move(source, destination)
  else if (propName = 'participant') then ParticipantList.move(source, destination)
  else if (propName = 'appointment') then AppointmentList.move(source, destination)
  else if (propName = 'virtualService') then VirtualServiceList.move(source, destination)
  else if (propName = 'reason') then ReasonList.move(source, destination)
  else if (propName = 'diagnosis') then DiagnosisList.move(source, destination)
  else if (propName = 'account') then AccountList.move(source, destination)
  else if (propName = 'location') then LocationList.move(source, destination)
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirEncounter.fhirType : string;
begin
  result := 'Encounter';
end;

function TFhirEncounter.Link : TFhirEncounter;
begin
  result := TFhirEncounter(inherited Link);
end;

function TFhirEncounter.Clone : TFhirEncounter;
begin
  result := TFhirEncounter(inherited Clone);
end;

function TFhirEncounter.equals(other : TObject) : boolean; 
var
  o : TFhirEncounter;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirEncounter)) then
    result := false
  else
  begin
    o := TFhirEncounter(other);
    result := compareDeep(identifierList, o.identifierList, true) and compareDeep(statusElement, o.statusElement, true) and 
      compareDeep(statusHistoryList, o.statusHistoryList, true) and compareDeep(class_List, o.class_List, true) and 
      compareDeep(classHistoryList, o.classHistoryList, true) and compareDeep(priorityElement, o.priorityElement, true) and 
      compareDeep(type_List, o.type_List, true) and compareDeep(serviceTypeList, o.serviceTypeList, true) and 
      compareDeep(subjectElement, o.subjectElement, true) and compareDeep(subjectStatusElement, o.subjectStatusElement, true) and 
      compareDeep(episodeOfCareList, o.episodeOfCareList, true) and compareDeep(basedOnList, o.basedOnList, true) and 
      compareDeep(careTeamList, o.careTeamList, true) and compareDeep(partOfElement, o.partOfElement, true) and 
      compareDeep(serviceProviderElement, o.serviceProviderElement, true) and compareDeep(participantList, o.participantList, true) and 
      compareDeep(appointmentList, o.appointmentList, true) and compareDeep(virtualServiceList, o.virtualServiceList, true) and 
      compareDeep(actualPeriodElement, o.actualPeriodElement, true) and compareDeep(plannedStartDateElement, o.plannedStartDateElement, true) and 
      compareDeep(plannedEndDateElement, o.plannedEndDateElement, true) and compareDeep(lengthElement, o.lengthElement, true) and 
      compareDeep(reasonList, o.reasonList, true) and compareDeep(diagnosisList, o.diagnosisList, true) and 
      compareDeep(accountList, o.accountList, true) and compareDeep(admissionElement, o.admissionElement, true) and 
      compareDeep(locationList, o.locationList, true);
  end;
end;

function TFhirEncounter.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FidentifierList) and isEmptyProp(FStatus) and isEmptyProp(FstatusHistoryList) and isEmptyProp(Fclass_List) and isEmptyProp(FclassHistoryList) and isEmptyProp(FPriority) and isEmptyProp(Ftype_List) and isEmptyProp(FserviceTypeList) and isEmptyProp(FSubject) and isEmptyProp(FSubjectStatus) and isEmptyProp(FepisodeOfCareList) and isEmptyProp(FbasedOnList) and isEmptyProp(FcareTeamList) and isEmptyProp(FPartOf) and isEmptyProp(FServiceProvider) and isEmptyProp(FparticipantList) and isEmptyProp(FappointmentList) and isEmptyProp(FvirtualServiceList) and isEmptyProp(FActualPeriod) and isEmptyProp(FPlannedStartDate) and isEmptyProp(FPlannedEndDate) and isEmptyProp(FLength) and isEmptyProp(FreasonList) and isEmptyProp(FdiagnosisList) and isEmptyProp(FaccountList) and isEmptyProp(FAdmission) and isEmptyProp(FlocationList);
end;

procedure TFhirEncounter.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('identifier');
  fields.add('status');
  fields.add('statusHistory');
  fields.add('class');
  fields.add('classHistory');
  fields.add('priority');
  fields.add('type');
  fields.add('serviceType');
  fields.add('subject');
  fields.add('subjectStatus');
  fields.add('episodeOfCare');
  fields.add('basedOn');
  fields.add('careTeam');
  fields.add('partOf');
  fields.add('serviceProvider');
  fields.add('participant');
  fields.add('appointment');
  fields.add('virtualService');
  fields.add('actualPeriod');
  fields.add('plannedStartDate');
  fields.add('plannedEndDate');
  fields.add('length');
  fields.add('reason');
  fields.add('diagnosis');
  fields.add('account');
  fields.add('admission');
  fields.add('location');
end;

function TFhirEncounter.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
  inc(result, FIdentifierList.sizeInBytes(magic));
  inc(result, FStatusHistoryList.sizeInBytes(magic));
  inc(result, FClass_List.sizeInBytes(magic));
  inc(result, FClassHistoryList.sizeInBytes(magic));
  inc(result, FType_List.sizeInBytes(magic));
  inc(result, FServiceTypeList.sizeInBytes(magic));
  inc(result, FEpisodeOfCareList.sizeInBytes(magic));
  inc(result, FBasedOnList.sizeInBytes(magic));
  inc(result, FCareTeamList.sizeInBytes(magic));
  inc(result, FParticipantList.sizeInBytes(magic));
  inc(result, FAppointmentList.sizeInBytes(magic));
  inc(result, FVirtualServiceList.sizeInBytes(magic));
  inc(result, FReasonList.sizeInBytes(magic));
  inc(result, FDiagnosisList.sizeInBytes(magic));
  inc(result, FAccountList.sizeInBytes(magic));
  inc(result, FLocationList.sizeInBytes(magic));
end;

function TFhirEncounter.GetIdentifierList : TFhirIdentifierList;
begin
  if FIdentifierList = nil then
    FIdentifierList := TFhirIdentifierList.Create;
  result := FIdentifierList;
end;

function TFhirEncounter.GetHasIdentifierList : boolean;
begin
  result := (FIdentifierList <> nil) and (FIdentifierList.count > 0);
end;

procedure TFhirEncounter.SetStatus(value : TFhirEnum);
begin
  FStatus.free;
  FStatus := value;
end;

function TFhirEncounter.GetStatusST : TFhirEncounterStatusEnum;
begin
  if FStatus = nil then
    result := TFhirEncounterStatusEnum(0)
  else
    result := TFhirEncounterStatusEnum(StringArrayIndexOfSensitive(CODES_TFhirEncounterStatusEnum, FStatus.value));
end;

procedure TFhirEncounter.SetStatusST(value : TFhirEncounterStatusEnum);
begin
  if ord(value) = 0 then
    StatusElement := nil
  else
    StatusElement := TFhirEnum.create(SYSTEMS_TFhirEncounterStatusEnum[value], CODES_TFhirEncounterStatusEnum[value]);
end;

function TFhirEncounter.GetStatusHistoryList : TFhirEncounterStatusHistoryList;
begin
  if FStatusHistoryList = nil then
    FStatusHistoryList := TFhirEncounterStatusHistoryList.Create;
  result := FStatusHistoryList;
end;

function TFhirEncounter.GetHasStatusHistoryList : boolean;
begin
  result := (FStatusHistoryList <> nil) and (FStatusHistoryList.count > 0);
end;

function TFhirEncounter.GetClass_List : TFhirCodeableConceptList;
begin
  if FClass_List = nil then
    FClass_List := TFhirCodeableConceptList.Create;
  result := FClass_List;
end;

function TFhirEncounter.GetHasClass_List : boolean;
begin
  result := (FClass_List <> nil) and (FClass_List.count > 0);
end;

function TFhirEncounter.GetClassHistoryList : TFhirEncounterClassHistoryList;
begin
  if FClassHistoryList = nil then
    FClassHistoryList := TFhirEncounterClassHistoryList.Create;
  result := FClassHistoryList;
end;

function TFhirEncounter.GetHasClassHistoryList : boolean;
begin
  result := (FClassHistoryList <> nil) and (FClassHistoryList.count > 0);
end;

procedure TFhirEncounter.SetPriority(value : TFhirCodeableConcept);
begin
  FPriority.free;
  FPriority := value;
end;

function TFhirEncounter.GetType_List : TFhirCodeableConceptList;
begin
  if FType_List = nil then
    FType_List := TFhirCodeableConceptList.Create;
  result := FType_List;
end;

function TFhirEncounter.GetHasType_List : boolean;
begin
  result := (FType_List <> nil) and (FType_List.count > 0);
end;

function TFhirEncounter.GetServiceTypeList : TFhirCodeableReferenceList;
begin
  if FServiceTypeList = nil then
    FServiceTypeList := TFhirCodeableReferenceList.Create;
  result := FServiceTypeList;
end;

function TFhirEncounter.GetHasServiceTypeList : boolean;
begin
  result := (FServiceTypeList <> nil) and (FServiceTypeList.count > 0);
end;

procedure TFhirEncounter.SetSubject(value : TFhirReference);
begin
  FSubject.free;
  FSubject := value;
end;

procedure TFhirEncounter.SetSubjectStatus(value : TFhirCodeableConcept);
begin
  FSubjectStatus.free;
  FSubjectStatus := value;
end;

function TFhirEncounter.GetEpisodeOfCareList : TFhirReferenceList;
begin
  if FEpisodeOfCareList = nil then
    FEpisodeOfCareList := TFhirReferenceList.Create;
  result := FEpisodeOfCareList;
end;

function TFhirEncounter.GetHasEpisodeOfCareList : boolean;
begin
  result := (FEpisodeOfCareList <> nil) and (FEpisodeOfCareList.count > 0);
end;

function TFhirEncounter.GetBasedOnList : TFhirReferenceList;
begin
  if FBasedOnList = nil then
    FBasedOnList := TFhirReferenceList.Create;
  result := FBasedOnList;
end;

function TFhirEncounter.GetHasBasedOnList : boolean;
begin
  result := (FBasedOnList <> nil) and (FBasedOnList.count > 0);
end;

function TFhirEncounter.GetCareTeamList : TFhirReferenceList;
begin
  if FCareTeamList = nil then
    FCareTeamList := TFhirReferenceList.Create;
  result := FCareTeamList;
end;

function TFhirEncounter.GetHasCareTeamList : boolean;
begin
  result := (FCareTeamList <> nil) and (FCareTeamList.count > 0);
end;

procedure TFhirEncounter.SetPartOf(value : TFhirReference);
begin
  FPartOf.free;
  FPartOf := value;
end;

procedure TFhirEncounter.SetServiceProvider(value : TFhirReference);
begin
  FServiceProvider.free;
  FServiceProvider := value;
end;

function TFhirEncounter.GetParticipantList : TFhirEncounterParticipantList;
begin
  if FParticipantList = nil then
    FParticipantList := TFhirEncounterParticipantList.Create;
  result := FParticipantList;
end;

function TFhirEncounter.GetHasParticipantList : boolean;
begin
  result := (FParticipantList <> nil) and (FParticipantList.count > 0);
end;

function TFhirEncounter.GetAppointmentList : TFhirReferenceList;
begin
  if FAppointmentList = nil then
    FAppointmentList := TFhirReferenceList.Create;
  result := FAppointmentList;
end;

function TFhirEncounter.GetHasAppointmentList : boolean;
begin
  result := (FAppointmentList <> nil) and (FAppointmentList.count > 0);
end;

function TFhirEncounter.GetVirtualServiceList : TFhirVirtualServiceDetailList;
begin
  if FVirtualServiceList = nil then
    FVirtualServiceList := TFhirVirtualServiceDetailList.Create;
  result := FVirtualServiceList;
end;

function TFhirEncounter.GetHasVirtualServiceList : boolean;
begin
  result := (FVirtualServiceList <> nil) and (FVirtualServiceList.count > 0);
end;

procedure TFhirEncounter.SetActualPeriod(value : TFhirPeriod);
begin
  FActualPeriod.free;
  FActualPeriod := value;
end;

procedure TFhirEncounter.SetPlannedStartDate(value : TFhirDateTime);
begin
  FPlannedStartDate.free;
  FPlannedStartDate := value;
end;

function TFhirEncounter.GetPlannedStartDateST : TFslDateTime;
begin
  if FPlannedStartDate = nil then
    result := TFslDateTime.makeNull
  else
    result := FPlannedStartDate.value;
end;

procedure TFhirEncounter.SetPlannedStartDateST(value : TFslDateTime);
begin
  if FPlannedStartDate = nil then
    FPlannedStartDate := TFhirDateTime.create;
  FPlannedStartDate.value := value
end;

procedure TFhirEncounter.SetPlannedEndDate(value : TFhirDateTime);
begin
  FPlannedEndDate.free;
  FPlannedEndDate := value;
end;

function TFhirEncounter.GetPlannedEndDateST : TFslDateTime;
begin
  if FPlannedEndDate = nil then
    result := TFslDateTime.makeNull
  else
    result := FPlannedEndDate.value;
end;

procedure TFhirEncounter.SetPlannedEndDateST(value : TFslDateTime);
begin
  if FPlannedEndDate = nil then
    FPlannedEndDate := TFhirDateTime.create;
  FPlannedEndDate.value := value
end;

procedure TFhirEncounter.SetLength(value : TFhirDuration);
begin
  FLength.free;
  FLength := value;
end;

function TFhirEncounter.GetReasonList : TFhirCodeableReferenceList;
begin
  if FReasonList = nil then
    FReasonList := TFhirCodeableReferenceList.Create;
  result := FReasonList;
end;

function TFhirEncounter.GetHasReasonList : boolean;
begin
  result := (FReasonList <> nil) and (FReasonList.count > 0);
end;

function TFhirEncounter.GetDiagnosisList : TFhirEncounterDiagnosisList;
begin
  if FDiagnosisList = nil then
    FDiagnosisList := TFhirEncounterDiagnosisList.Create;
  result := FDiagnosisList;
end;

function TFhirEncounter.GetHasDiagnosisList : boolean;
begin
  result := (FDiagnosisList <> nil) and (FDiagnosisList.count > 0);
end;

function TFhirEncounter.GetAccountList : TFhirReferenceList;
begin
  if FAccountList = nil then
    FAccountList := TFhirReferenceList.Create;
  result := FAccountList;
end;

function TFhirEncounter.GetHasAccountList : boolean;
begin
  result := (FAccountList <> nil) and (FAccountList.count > 0);
end;

procedure TFhirEncounter.SetAdmission(value : TFhirEncounterAdmission);
begin
  FAdmission.free;
  FAdmission := value;
end;

function TFhirEncounter.GetLocationList : TFhirEncounterLocationList;
begin
  if FLocationList = nil then
    FLocationList := TFhirEncounterLocationList.Create;
  result := FLocationList;
end;

function TFhirEncounter.GetHasLocationList : boolean;
begin
  result := (FLocationList <> nil) and (FLocationList.count > 0);
end;

{ TFhirEncounterListEnumerator }

constructor TFhirEncounterListEnumerator.Create(list : TFhirEncounterList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirEncounterListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirEncounterListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirEncounterListEnumerator.GetCurrent : TFhirEncounter;
begin
  Result := FList[FIndex];
end;

function TFhirEncounterListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirEncounterList }

function TFhirEncounterList.AddItem(value: TFhirEncounter): TFhirEncounter;
begin
  assert(value.ClassName = 'TFhirEncounter', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirEncounter');
  add(value);
  result := value;
end;

function TFhirEncounterList.Append: TFhirEncounter;
begin
  result := TFhirEncounter.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirEncounterList.ClearItems;
begin
  Clear;
end;

function TFhirEncounterList.GetEnumerator : TFhirEncounterListEnumerator;
begin
  result := TFhirEncounterListEnumerator.Create(self.link);
end;

function TFhirEncounterList.Clone: TFhirEncounterList;
begin
  result := TFhirEncounterList(inherited Clone);
end;

function TFhirEncounterList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirEncounterList.GetItemN(index: Integer): TFhirEncounter;
begin
  result := TFhirEncounter(ObjectByIndex[index]);
end;

function TFhirEncounterList.ItemClass: TFslObjectClass;
begin
  result := TFhirEncounter;
end;
function TFhirEncounterList.IndexOf(value: TFhirEncounter): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirEncounterList.Insert(index: Integer): TFhirEncounter;
begin
  result := TFhirEncounter.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirEncounterList.InsertItem(index: Integer; value: TFhirEncounter);
begin
  assert(value is TFhirEncounter);
  Inherited Insert(index, value);
end;

function TFhirEncounterList.Item(index: Integer): TFhirEncounter;
begin
  result := TFhirEncounter(ObjectByIndex[index]);
end;

function TFhirEncounterList.Link: TFhirEncounterList;
begin
  result := TFhirEncounterList(inherited Link);
end;

procedure TFhirEncounterList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirEncounterList.SetItemByIndex(index: Integer; value: TFhirEncounter);
begin
  assert(value is TFhirEncounter);
  FhirEncounters[index] := value;
end;

procedure TFhirEncounterList.SetItemN(index: Integer; value: TFhirEncounter);
begin
  assert(value is TFhirEncounter);
  ObjectByIndex[index] := value;
end;

{$ENDIF FHIR_ENCOUNTER}
{$IFDEF FHIR_ENDPOINT}
{ TFhirEndpoint }

constructor TFhirEndpoint.Create;
begin
  inherited;
end;

destructor TFhirEndpoint.Destroy;
begin
  FIdentifierList.Free;
  FStatus.free;
  FConnectionTypeList.Free;
  FName.free;
  FDescription.free;
  FEnvironmentTypeList.Free;
  FManagingOrganization.free;
  FContactList.Free;
  FPeriod.free;
  FPayloadTypeList.Free;
  FPayloadMimeTypeList.Free;
  FAddress.free;
  FHeaderList.Free;
  inherited;
end;

procedure TFhirEndpoint.Assign(oSource : TFslObject);
begin
  inherited;
  if (TFhirEndpoint(oSource).FIdentifierList = nil) then
  begin
    FIdentifierList.free;
    FIdentifierList := nil;
  end
  else
  begin
    if FIdentifierList = nil then
      FIdentifierList := TFhirIdentifierList.Create;
    FIdentifierList.Assign(TFhirEndpoint(oSource).FIdentifierList);
  end;
  statusElement := TFhirEndpoint(oSource).statusElement.Clone;
  if (TFhirEndpoint(oSource).FConnectionTypeList = nil) then
  begin
    FConnectionTypeList.free;
    FConnectionTypeList := nil;
  end
  else
  begin
    if FConnectionTypeList = nil then
      FConnectionTypeList := TFhirCodeableConceptList.Create;
    FConnectionTypeList.Assign(TFhirEndpoint(oSource).FConnectionTypeList);
  end;
  nameElement := TFhirEndpoint(oSource).nameElement.Clone;
  descriptionElement := TFhirEndpoint(oSource).descriptionElement.Clone;
  if (TFhirEndpoint(oSource).FEnvironmentTypeList = nil) then
  begin
    FEnvironmentTypeList.free;
    FEnvironmentTypeList := nil;
  end
  else
  begin
    if FEnvironmentTypeList = nil then
      FEnvironmentTypeList := TFhirCodeableConceptList.Create;
    FEnvironmentTypeList.Assign(TFhirEndpoint(oSource).FEnvironmentTypeList);
  end;
  managingOrganization := TFhirEndpoint(oSource).managingOrganization.Clone;
  if (TFhirEndpoint(oSource).FContactList = nil) then
  begin
    FContactList.free;
    FContactList := nil;
  end
  else
  begin
    if FContactList = nil then
      FContactList := TFhirContactPointList.Create;
    FContactList.Assign(TFhirEndpoint(oSource).FContactList);
  end;
  period := TFhirEndpoint(oSource).period.Clone;
  if (TFhirEndpoint(oSource).FPayloadTypeList = nil) then
  begin
    FPayloadTypeList.free;
    FPayloadTypeList := nil;
  end
  else
  begin
    if FPayloadTypeList = nil then
      FPayloadTypeList := TFhirCodeableConceptList.Create;
    FPayloadTypeList.Assign(TFhirEndpoint(oSource).FPayloadTypeList);
  end;
  if (TFhirEndpoint(oSource).FPayloadMimeTypeList = nil) then
  begin
    FPayloadMimeTypeList.free;
    FPayloadMimeTypeList := nil;
  end
  else
  begin
    if FPayloadMimeTypeList = nil then
      FPayloadMimeTypeList := TFhirCodeList.Create;
    FPayloadMimeTypeList.Assign(TFhirEndpoint(oSource).FPayloadMimeTypeList);
  end;
  addressElement := TFhirEndpoint(oSource).addressElement.Clone;
  if (TFhirEndpoint(oSource).FHeaderList = nil) then
  begin
    FHeaderList.free;
    FHeaderList := nil;
  end
  else
  begin
    if FHeaderList = nil then
      FHeaderList := TFhirStringList.Create;
    FHeaderList.Assign(TFhirEndpoint(oSource).FHeaderList);
  end;
end;

function TFhirEndpoint.GetResourceType : TFhirResourceType;
begin
  result := frtEndpoint;
end;

procedure TFhirEndpoint.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'identifier') Then
    list.addAll(self, 'identifier', FIdentifierList);
  if (child_name = 'status') Then
     list.add(self.link, 'status', FStatus.Link);
  if (child_name = 'connectionType') Then
    list.addAll(self, 'connectionType', FConnectionTypeList);
  if (child_name = 'name') Then
     list.add(self.link, 'name', FName.Link);
  if (child_name = 'description') Then
     list.add(self.link, 'description', FDescription.Link);
  if (child_name = 'environmentType') Then
    list.addAll(self, 'environmentType', FEnvironmentTypeList);
  if (child_name = 'managingOrganization') Then
     list.add(self.link, 'managingOrganization', FManagingOrganization.Link);
  if (child_name = 'contact') Then
    list.addAll(self, 'contact', FContactList);
  if (child_name = 'period') Then
     list.add(self.link, 'period', FPeriod.Link);
  if (child_name = 'payloadType') Then
    list.addAll(self, 'payloadType', FPayloadTypeList);
  if (child_name = 'payloadMimeType') Then
    list.addAll(self, 'payloadMimeType', FPayloadMimeTypeList);
  if (child_name = 'address') Then
     list.add(self.link, 'address', FAddress.Link);
  if (child_name = 'header') Then
    list.addAll(self, 'header', FHeaderList);
end;

procedure TFhirEndpoint.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'identifier', 'Identifier', true, TFhirIdentifier, FIdentifierList.Link));
  oList.add(TFHIRProperty.create(self, 'status', 'code', false, TFhirEnum, FStatus.Link));
  oList.add(TFHIRProperty.create(self, 'connectionType', 'CodeableConcept', true, TFhirCodeableConcept, FConnectionTypeList.Link));
  oList.add(TFHIRProperty.create(self, 'name', 'string', false, TFhirString, FName.Link));
  oList.add(TFHIRProperty.create(self, 'description', 'string', false, TFhirString, FDescription.Link));
  oList.add(TFHIRProperty.create(self, 'environmentType', 'CodeableConcept', true, TFhirCodeableConcept, FEnvironmentTypeList.Link));
  oList.add(TFHIRProperty.create(self, 'managingOrganization', 'Reference', false, TFhirReference, FManagingOrganization.Link));
  oList.add(TFHIRProperty.create(self, 'contact', 'ContactPoint', true, TFhirContactPoint, FContactList.Link));
  oList.add(TFHIRProperty.create(self, 'period', 'Period', false, TFhirPeriod, FPeriod.Link));
  oList.add(TFHIRProperty.create(self, 'payloadType', 'CodeableConcept', true, TFhirCodeableConcept, FPayloadTypeList.Link));
  oList.add(TFHIRProperty.create(self, 'payloadMimeType', 'code', true, TFhirCode, FPayloadMimeTypeList.Link));
  oList.add(TFHIRProperty.create(self, 'address', 'url', false, TFhirUrl, FAddress.Link));
  oList.add(TFHIRProperty.create(self, 'header', 'string', true, TFhirString, FHeaderList.Link));
end;

function TFhirEndpoint.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'identifier') then
  begin
    IdentifierList.add(propValue as TFhirIdentifier);
    result := propValue;
  end
  else if (propName = 'status') then
  begin
    StatusElement := asEnum(SYSTEMS_TFhirEndpointStatusEnum, CODES_TFhirEndpointStatusEnum, propValue);
    result := propValue;
  end
  else if (propName = 'connectionType') then
  begin
    ConnectionTypeList.add(propValue as TFhirCodeableConcept);
    result := propValue;
  end
  else if (propName = 'name') then
  begin
    NameElement := asString(propValue);
    result := propValue;
  end
  else if (propName = 'description') then
  begin
    DescriptionElement := asString(propValue);
    result := propValue;
  end
  else if (propName = 'environmentType') then
  begin
    EnvironmentTypeList.add(propValue as TFhirCodeableConcept);
    result := propValue;
  end
  else if (propName = 'managingOrganization') then
  begin
    ManagingOrganization := propValue as TFhirReference;
    result := propValue;
  end
  else if (propName = 'contact') then
  begin
    ContactList.add(propValue as TFhirContactPoint);
    result := propValue;
  end
  else if (propName = 'period') then
  begin
    Period := propValue as TFhirPeriod;
    result := propValue;
  end
  else if (propName = 'payloadType') then
  begin
    PayloadTypeList.add(propValue as TFhirCodeableConcept);
    result := propValue;
  end
  else if (propName = 'payloadMimeType') then
  begin
    PayloadMimeTypeList.add(asCode(propValue)){2};     result := propValue;

  end
  else if (propName = 'address') then
  begin
    AddressElement := asUrl(propValue);
    result := propValue;
  end
  else if (propName = 'header') then
  begin
    HeaderList.add(asString(propValue)){2};     result := propValue;

  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirEndpoint.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'identifier') then IdentifierList.insertItem(index, propValue as TFhirIdentifier)
  else if (propName = 'connectionType') then ConnectionTypeList.insertItem(index, propValue as TFhirCodeableConcept)
  else if (propName = 'environmentType') then EnvironmentTypeList.insertItem(index, propValue as TFhirCodeableConcept)
  else if (propName = 'contact') then ContactList.insertItem(index, propValue as TFhirContactPoint)
  else if (propName = 'payloadType') then PayloadTypeList.insertItem(index, propValue as TFhirCodeableConcept)
  else if (propName = 'payloadMimeType') then PayloadMimeTypeList.insertItem(index, asCode(propValue))
  else if (propName = 'header') then HeaderList.insertItem(index, asString(propValue))
  else inherited;
end;

function TFhirEndpoint.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'identifier') then result := IdentifierList.new()
  else if (propName = 'status') then result := TFhirEnum.create(SYSTEMS_TFhirEndpointStatusEnum[EndpointStatusNull], CODES_TFhirEndpointStatusEnum[EndpointStatusNull]) 
  else if (propName = 'connectionType') then result := ConnectionTypeList.new()
  else if (propName = 'name') then result := TFhirString.create()
  else if (propName = 'description') then result := TFhirString.create()
  else if (propName = 'environmentType') then result := EnvironmentTypeList.new()
  else if (propName = 'managingOrganization') then result := TFhirReference.create()
  else if (propName = 'contact') then result := ContactList.new()
  else if (propName = 'period') then result := TFhirPeriod.create()
  else if (propName = 'payloadType') then result := PayloadTypeList.new()
  else if (propName = 'payloadMimeType') then result := PayloadMimeTypeList.new()
  else if (propName = 'address') then result := TFhirUrl.create()
  else if (propName = 'header') then result := HeaderList.new()
  else result := inherited createPropertyValue(propName);
end;

function TFhirEndpoint.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'identifier') then result := 'Identifier'
  else if (propName = 'status') then result := 'code'
  else if (propName = 'connectionType') then result := 'CodeableConcept'
  else if (propName = 'name') then result := 'string'
  else if (propName = 'description') then result := 'string'
  else if (propName = 'environmentType') then result := 'CodeableConcept'
  else if (propName = 'managingOrganization') then result := 'Reference'
  else if (propName = 'contact') then result := 'ContactPoint'
  else if (propName = 'period') then result := 'Period'
  else if (propName = 'payloadType') then result := 'CodeableConcept'
  else if (propName = 'payloadMimeType') then result := 'code'
  else if (propName = 'address') then result := 'url'
  else if (propName = 'header') then result := 'string'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirEndpoint.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'identifier') then deletePropertyValue('identifier', IdentifierList, value)
  else if (propName = 'status') then StatusElement := nil
  else if (propName = 'connectionType') then deletePropertyValue('connectionType', ConnectionTypeList, value)
  else if (propName = 'name') then NameElement := nil
  else if (propName = 'description') then DescriptionElement := nil
  else if (propName = 'environmentType') then deletePropertyValue('environmentType', EnvironmentTypeList, value)
  else if (propName = 'managingOrganization') then ManagingOrganizationElement := nil
  else if (propName = 'contact') then deletePropertyValue('contact', ContactList, value)
  else if (propName = 'period') then PeriodElement := nil
  else if (propName = 'payloadType') then deletePropertyValue('payloadType', PayloadTypeList, value)
  else if (propName = 'payloadMimeType') then deletePropertyValue('payloadMimeType', PayloadMimeTypeList, value)
  else if (propName = 'address') then AddressElement := nil
  else if (propName = 'header') then deletePropertyValue('header', HeaderList, value)
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirEndpoint.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'identifier') then replacePropertyValue('identifier', IdentifierList, existing, new)
  else if (propName = 'status') then StatusElement := asEnum(SYSTEMS_TFhirEndpointStatusEnum, CODES_TFhirEndpointStatusEnum, new)
  else if (propName = 'connectionType') then replacePropertyValue('connectionType', ConnectionTypeList, existing, new)
  else if (propName = 'name') then NameElement := asString(new)
  else if (propName = 'description') then DescriptionElement := asString(new)
  else if (propName = 'environmentType') then replacePropertyValue('environmentType', EnvironmentTypeList, existing, new)
  else if (propName = 'managingOrganization') then ManagingOrganizationElement := new as TFhirReference
  else if (propName = 'contact') then replacePropertyValue('contact', ContactList, existing, new)
  else if (propName = 'period') then PeriodElement := new as TFhirPeriod
  else if (propName = 'payloadType') then replacePropertyValue('payloadType', PayloadTypeList, existing, new)
  else if (propName = 'payloadMimeType') then replacePropertyValue('payloadMimeType', PayloadMimeTypeList, existing, new)
  else if (propName = 'address') then AddressElement := asUrl(new)
  else if (propName = 'header') then replacePropertyValue('header', HeaderList, existing, new)
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirEndpoint.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'identifier') then IdentifierList.move(source, destination)
  else if (propName = 'connectionType') then ConnectionTypeList.move(source, destination)
  else if (propName = 'environmentType') then EnvironmentTypeList.move(source, destination)
  else if (propName = 'contact') then ContactList.move(source, destination)
  else if (propName = 'payloadType') then PayloadTypeList.move(source, destination)
  else if (propName = 'payloadMimeType') then PayloadMimeTypeList.move(source, destination)
  else if (propName = 'header') then HeaderList.move(source, destination)
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirEndpoint.fhirType : string;
begin
  result := 'Endpoint';
end;

function TFhirEndpoint.Link : TFhirEndpoint;
begin
  result := TFhirEndpoint(inherited Link);
end;

function TFhirEndpoint.Clone : TFhirEndpoint;
begin
  result := TFhirEndpoint(inherited Clone);
end;

function TFhirEndpoint.equals(other : TObject) : boolean; 
var
  o : TFhirEndpoint;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirEndpoint)) then
    result := false
  else
  begin
    o := TFhirEndpoint(other);
    result := compareDeep(identifierList, o.identifierList, true) and compareDeep(statusElement, o.statusElement, true) and 
      compareDeep(connectionTypeList, o.connectionTypeList, true) and compareDeep(nameElement, o.nameElement, true) and 
      compareDeep(descriptionElement, o.descriptionElement, true) and compareDeep(environmentTypeList, o.environmentTypeList, true) and 
      compareDeep(managingOrganizationElement, o.managingOrganizationElement, true) and 
      compareDeep(contactList, o.contactList, true) and compareDeep(periodElement, o.periodElement, true) and 
      compareDeep(payloadTypeList, o.payloadTypeList, true) and compareDeep(payloadMimeTypeList, o.payloadMimeTypeList, true) and 
      compareDeep(addressElement, o.addressElement, true) and compareDeep(headerList, o.headerList, true);
  end;
end;

function TFhirEndpoint.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FidentifierList) and isEmptyProp(FStatus) and isEmptyProp(FconnectionTypeList) and isEmptyProp(FName) and isEmptyProp(FDescription) and isEmptyProp(FenvironmentTypeList) and isEmptyProp(FManagingOrganization) and isEmptyProp(FcontactList) and isEmptyProp(FPeriod) and isEmptyProp(FpayloadTypeList) and isEmptyProp(FpayloadMimeTypeList) and isEmptyProp(FAddress) and isEmptyProp(FheaderList);
end;

procedure TFhirEndpoint.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('identifier');
  fields.add('status');
  fields.add('connectionType');
  fields.add('name');
  fields.add('description');
  fields.add('environmentType');
  fields.add('managingOrganization');
  fields.add('contact');
  fields.add('period');
  fields.add('payloadType');
  fields.add('payloadMimeType');
  fields.add('address');
  fields.add('header');
end;

function TFhirEndpoint.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
  inc(result, FIdentifierList.sizeInBytes(magic));
  inc(result, FConnectionTypeList.sizeInBytes(magic));
  inc(result, FEnvironmentTypeList.sizeInBytes(magic));
  inc(result, FContactList.sizeInBytes(magic));
  inc(result, FPayloadTypeList.sizeInBytes(magic));
  inc(result, FPayloadMimeTypeList.sizeInBytes(magic));
  inc(result, FHeaderList.sizeInBytes(magic));
end;

function TFhirEndpoint.GetIdentifierList : TFhirIdentifierList;
begin
  if FIdentifierList = nil then
    FIdentifierList := TFhirIdentifierList.Create;
  result := FIdentifierList;
end;

function TFhirEndpoint.GetHasIdentifierList : boolean;
begin
  result := (FIdentifierList <> nil) and (FIdentifierList.count > 0);
end;

procedure TFhirEndpoint.SetStatus(value : TFhirEnum);
begin
  FStatus.free;
  FStatus := value;
end;

function TFhirEndpoint.GetStatusST : TFhirEndpointStatusEnum;
begin
  if FStatus = nil then
    result := TFhirEndpointStatusEnum(0)
  else
    result := TFhirEndpointStatusEnum(StringArrayIndexOfSensitive(CODES_TFhirEndpointStatusEnum, FStatus.value));
end;

procedure TFhirEndpoint.SetStatusST(value : TFhirEndpointStatusEnum);
begin
  if ord(value) = 0 then
    StatusElement := nil
  else
    StatusElement := TFhirEnum.create(SYSTEMS_TFhirEndpointStatusEnum[value], CODES_TFhirEndpointStatusEnum[value]);
end;

function TFhirEndpoint.GetConnectionTypeList : TFhirCodeableConceptList;
begin
  if FConnectionTypeList = nil then
    FConnectionTypeList := TFhirCodeableConceptList.Create;
  result := FConnectionTypeList;
end;

function TFhirEndpoint.GetHasConnectionTypeList : boolean;
begin
  result := (FConnectionTypeList <> nil) and (FConnectionTypeList.count > 0);
end;

procedure TFhirEndpoint.SetName(value : TFhirString);
begin
  FName.free;
  FName := value;
end;

function TFhirEndpoint.GetNameST : String;
begin
  if FName = nil then
    result := ''
  else
    result := FName.value;
end;

procedure TFhirEndpoint.SetNameST(value : String);
begin
  if value <> '' then
  begin
    if FName = nil then
      FName := TFhirString.create;
    FName.value := value
  end
  else if FName <> nil then
    FName.value := '';
end;

procedure TFhirEndpoint.SetDescription(value : TFhirString);
begin
  FDescription.free;
  FDescription := value;
end;

function TFhirEndpoint.GetDescriptionST : String;
begin
  if FDescription = nil then
    result := ''
  else
    result := FDescription.value;
end;

procedure TFhirEndpoint.SetDescriptionST(value : String);
begin
  if value <> '' then
  begin
    if FDescription = nil then
      FDescription := TFhirString.create;
    FDescription.value := value
  end
  else if FDescription <> nil then
    FDescription.value := '';
end;

function TFhirEndpoint.GetEnvironmentTypeList : TFhirCodeableConceptList;
begin
  if FEnvironmentTypeList = nil then
    FEnvironmentTypeList := TFhirCodeableConceptList.Create;
  result := FEnvironmentTypeList;
end;

function TFhirEndpoint.GetHasEnvironmentTypeList : boolean;
begin
  result := (FEnvironmentTypeList <> nil) and (FEnvironmentTypeList.count > 0);
end;

procedure TFhirEndpoint.SetManagingOrganization(value : TFhirReference);
begin
  FManagingOrganization.free;
  FManagingOrganization := value;
end;

function TFhirEndpoint.GetContactList : TFhirContactPointList;
begin
  if FContactList = nil then
    FContactList := TFhirContactPointList.Create;
  result := FContactList;
end;

function TFhirEndpoint.GetHasContactList : boolean;
begin
  result := (FContactList <> nil) and (FContactList.count > 0);
end;

procedure TFhirEndpoint.SetPeriod(value : TFhirPeriod);
begin
  FPeriod.free;
  FPeriod := value;
end;

function TFhirEndpoint.GetPayloadTypeList : TFhirCodeableConceptList;
begin
  if FPayloadTypeList = nil then
    FPayloadTypeList := TFhirCodeableConceptList.Create;
  result := FPayloadTypeList;
end;

function TFhirEndpoint.GetHasPayloadTypeList : boolean;
begin
  result := (FPayloadTypeList <> nil) and (FPayloadTypeList.count > 0);
end;

function TFhirEndpoint.GetPayloadMimeTypeList : TFhirCodeList;
begin
  if FPayloadMimeTypeList = nil then
    FPayloadMimeTypeList := TFhirCodeList.Create;
  result := FPayloadMimeTypeList;
end;

function TFhirEndpoint.GetHasPayloadMimeTypeList : boolean;
begin
  result := (FPayloadMimeTypeList <> nil) and (FPayloadMimeTypeList.count > 0);
end;

procedure TFhirEndpoint.SetAddress(value : TFhirUrl);
begin
  FAddress.free;
  FAddress := value;
end;

function TFhirEndpoint.GetAddressST : String;
begin
  if FAddress = nil then
    result := ''
  else
    result := FAddress.value;
end;

procedure TFhirEndpoint.SetAddressST(value : String);
begin
  if value <> '' then
  begin
    if FAddress = nil then
      FAddress := TFhirUrl.create;
    FAddress.value := value
  end
  else if FAddress <> nil then
    FAddress.value := '';
end;

function TFhirEndpoint.GetHeaderList : TFhirStringList;
begin
  if FHeaderList = nil then
    FHeaderList := TFhirStringList.Create;
  result := FHeaderList;
end;

function TFhirEndpoint.GetHasHeaderList : boolean;
begin
  result := (FHeaderList <> nil) and (FHeaderList.count > 0);
end;

{ TFhirEndpointListEnumerator }

constructor TFhirEndpointListEnumerator.Create(list : TFhirEndpointList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirEndpointListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirEndpointListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirEndpointListEnumerator.GetCurrent : TFhirEndpoint;
begin
  Result := FList[FIndex];
end;

function TFhirEndpointListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirEndpointList }

function TFhirEndpointList.AddItem(value: TFhirEndpoint): TFhirEndpoint;
begin
  assert(value.ClassName = 'TFhirEndpoint', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirEndpoint');
  add(value);
  result := value;
end;

function TFhirEndpointList.Append: TFhirEndpoint;
begin
  result := TFhirEndpoint.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirEndpointList.ClearItems;
begin
  Clear;
end;

function TFhirEndpointList.GetEnumerator : TFhirEndpointListEnumerator;
begin
  result := TFhirEndpointListEnumerator.Create(self.link);
end;

function TFhirEndpointList.Clone: TFhirEndpointList;
begin
  result := TFhirEndpointList(inherited Clone);
end;

function TFhirEndpointList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirEndpointList.GetItemN(index: Integer): TFhirEndpoint;
begin
  result := TFhirEndpoint(ObjectByIndex[index]);
end;

function TFhirEndpointList.ItemClass: TFslObjectClass;
begin
  result := TFhirEndpoint;
end;
function TFhirEndpointList.IndexOf(value: TFhirEndpoint): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirEndpointList.Insert(index: Integer): TFhirEndpoint;
begin
  result := TFhirEndpoint.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirEndpointList.InsertItem(index: Integer; value: TFhirEndpoint);
begin
  assert(value is TFhirEndpoint);
  Inherited Insert(index, value);
end;

function TFhirEndpointList.Item(index: Integer): TFhirEndpoint;
begin
  result := TFhirEndpoint(ObjectByIndex[index]);
end;

function TFhirEndpointList.Link: TFhirEndpointList;
begin
  result := TFhirEndpointList(inherited Link);
end;

procedure TFhirEndpointList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirEndpointList.SetItemByIndex(index: Integer; value: TFhirEndpoint);
begin
  assert(value is TFhirEndpoint);
  FhirEndpoints[index] := value;
end;

procedure TFhirEndpointList.SetItemN(index: Integer; value: TFhirEndpoint);
begin
  assert(value is TFhirEndpoint);
  ObjectByIndex[index] := value;
end;

{$ENDIF FHIR_ENDPOINT}
{$IFDEF FHIR_GROUP}
{ TFhirGroupCharacteristic }

constructor TFhirGroupCharacteristic.Create;
begin
  inherited;
end;

destructor TFhirGroupCharacteristic.Destroy;
begin
  FCode.free;
  FValue.free;
  FExclude.free;
  FPeriod.free;
  inherited;
end;

procedure TFhirGroupCharacteristic.Assign(oSource : TFslObject);
begin
  inherited;
  code := TFhirGroupCharacteristic(oSource).code.Clone;
  value := TFhirGroupCharacteristic(oSource).value.Clone;
  excludeElement := TFhirGroupCharacteristic(oSource).excludeElement.Clone;
  period := TFhirGroupCharacteristic(oSource).period.Clone;
end;

procedure TFhirGroupCharacteristic.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'code') Then
     list.add(self.link, 'code', FCode.Link);
  if (child_name = 'value[x]') or (child_name = 'value') Then
     list.add(self.link, 'value[x]', FValue.Link);
  if (child_name = 'exclude') Then
     list.add(self.link, 'exclude', FExclude.Link);
  if (child_name = 'period') Then
     list.add(self.link, 'period', FPeriod.Link);
end;

procedure TFhirGroupCharacteristic.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'code', 'CodeableConcept', false, TFhirCodeableConcept, FCode.Link));
  oList.add(TFHIRProperty.create(self, 'value[x]', 'CodeableConcept|boolean|Quantity|Range|Reference', false, TFhirDataType, FValue.Link));
  oList.add(TFHIRProperty.create(self, 'exclude', 'boolean', false, TFhirBoolean, FExclude.Link));
  oList.add(TFHIRProperty.create(self, 'period', 'Period', false, TFhirPeriod, FPeriod.Link));
end;

function TFhirGroupCharacteristic.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'code') then
  begin
    Code := propValue as TFhirCodeableConcept;
    result := propValue;
  end
  else if (isMatchingName(propName, 'value', ['CodeableConcept', 'Boolean', 'Quantity', 'Range', 'Reference'])) then
  begin
    Value := propValue as TFhirDataType;
    result := propValue;
  end
  else if (propName = 'exclude') then
  begin
    ExcludeElement := asBoolean(propValue);
    result := propValue;
  end
  else if (propName = 'period') then
  begin
    Period := propValue as TFhirPeriod;
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirGroupCharacteristic.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirGroupCharacteristic.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'code') then result := TFhirCodeableConcept.create()
  else if (isMatchingName(propName, 'value', ['CodeableConcept', 'Boolean', 'Quantity', 'Range', 'Reference'])) then raise EFHIRException.create('Cannot make property Value')
  else if (propName = 'exclude') then result := TFhirBoolean.create()
  else if (propName = 'period') then result := TFhirPeriod.create()
  else result := inherited createPropertyValue(propName);
end;

function TFhirGroupCharacteristic.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'code') then result := 'CodeableConcept'
  else if (propName = 'value[x]') then result := 'CodeableConcept|boolean|Quantity|Range|Reference'
  else if (propName = 'exclude') then result := 'boolean'
  else if (propName = 'period') then result := 'Period'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirGroupCharacteristic.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'code') then CodeElement := nil
  else if (isMatchingName(propName, 'value', ['CodeableConcept', 'Boolean', 'Quantity', 'Range', 'Reference'])) then ValueElement := nil
  else if (propName = 'exclude') then ExcludeElement := nil
  else if (propName = 'period') then PeriodElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirGroupCharacteristic.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'code') then CodeElement := new as TFhirCodeableConcept
  else if (isMatchingName(propName, 'value', ['CodeableConcept', 'Boolean', 'Quantity', 'Range', 'Reference'])) then ValueElement := new as TFhirDataType
  else if (propName = 'exclude') then ExcludeElement := asBoolean(new)
  else if (propName = 'period') then PeriodElement := new as TFhirPeriod
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirGroupCharacteristic.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirGroupCharacteristic.fhirType : string;
begin
  result := 'Group.characteristic';
end;

function TFhirGroupCharacteristic.Link : TFhirGroupCharacteristic;
begin
  result := TFhirGroupCharacteristic(inherited Link);
end;

function TFhirGroupCharacteristic.Clone : TFhirGroupCharacteristic;
begin
  result := TFhirGroupCharacteristic(inherited Clone);
end;

function TFhirGroupCharacteristic.equals(other : TObject) : boolean; 
var
  o : TFhirGroupCharacteristic;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirGroupCharacteristic)) then
    result := false
  else
  begin
    o := TFhirGroupCharacteristic(other);
    result := compareDeep(codeElement, o.codeElement, true) and compareDeep(valueElement, o.valueElement, true) and 
      compareDeep(excludeElement, o.excludeElement, true) and compareDeep(periodElement, o.periodElement, true);
  end;
end;

function TFhirGroupCharacteristic.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FCode) and isEmptyProp(FValue) and isEmptyProp(FExclude) and isEmptyProp(FPeriod);
end;

procedure TFhirGroupCharacteristic.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('code');
  fields.add('value[x]');
  fields.add('exclude');
  fields.add('period');
end;

function TFhirGroupCharacteristic.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
end;

procedure TFhirGroupCharacteristic.SetCode(value : TFhirCodeableConcept);
begin
  FCode.free;
  FCode := value;
end;

procedure TFhirGroupCharacteristic.SetValue(value : TFhirDataType);
begin
  FValue.free;
  FValue := value;
end;

procedure TFhirGroupCharacteristic.SetExclude(value : TFhirBoolean);
begin
  FExclude.free;
  FExclude := value;
end;

function TFhirGroupCharacteristic.GetExcludeST : Boolean;
begin
  if FExclude = nil then
    result := false
  else
    result := FExclude.value;
end;

procedure TFhirGroupCharacteristic.SetExcludeST(value : Boolean);
begin
  if FExclude = nil then
    FExclude := TFhirBoolean.create;
  FExclude.value := value
end;

procedure TFhirGroupCharacteristic.SetPeriod(value : TFhirPeriod);
begin
  FPeriod.free;
  FPeriod := value;
end;

{ TFhirGroupCharacteristicListEnumerator }

constructor TFhirGroupCharacteristicListEnumerator.Create(list : TFhirGroupCharacteristicList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirGroupCharacteristicListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirGroupCharacteristicListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirGroupCharacteristicListEnumerator.GetCurrent : TFhirGroupCharacteristic;
begin
  Result := FList[FIndex];
end;

function TFhirGroupCharacteristicListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirGroupCharacteristicList }

function TFhirGroupCharacteristicList.AddItem(value: TFhirGroupCharacteristic): TFhirGroupCharacteristic;
begin
  assert(value.ClassName = 'TFhirGroupCharacteristic', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirGroupCharacteristic');
  add(value);
  result := value;
end;

function TFhirGroupCharacteristicList.Append: TFhirGroupCharacteristic;
begin
  result := TFhirGroupCharacteristic.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirGroupCharacteristicList.ClearItems;
begin
  Clear;
end;

function TFhirGroupCharacteristicList.GetEnumerator : TFhirGroupCharacteristicListEnumerator;
begin
  result := TFhirGroupCharacteristicListEnumerator.Create(self.link);
end;

function TFhirGroupCharacteristicList.Clone: TFhirGroupCharacteristicList;
begin
  result := TFhirGroupCharacteristicList(inherited Clone);
end;

function TFhirGroupCharacteristicList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirGroupCharacteristicList.GetItemN(index: Integer): TFhirGroupCharacteristic;
begin
  result := TFhirGroupCharacteristic(ObjectByIndex[index]);
end;

function TFhirGroupCharacteristicList.ItemClass: TFslObjectClass;
begin
  result := TFhirGroupCharacteristic;
end;
function TFhirGroupCharacteristicList.IndexOf(value: TFhirGroupCharacteristic): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirGroupCharacteristicList.Insert(index: Integer): TFhirGroupCharacteristic;
begin
  result := TFhirGroupCharacteristic.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirGroupCharacteristicList.InsertItem(index: Integer; value: TFhirGroupCharacteristic);
begin
  assert(value is TFhirGroupCharacteristic);
  Inherited Insert(index, value);
end;

function TFhirGroupCharacteristicList.Item(index: Integer): TFhirGroupCharacteristic;
begin
  result := TFhirGroupCharacteristic(ObjectByIndex[index]);
end;

function TFhirGroupCharacteristicList.Link: TFhirGroupCharacteristicList;
begin
  result := TFhirGroupCharacteristicList(inherited Link);
end;

procedure TFhirGroupCharacteristicList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirGroupCharacteristicList.SetItemByIndex(index: Integer; value: TFhirGroupCharacteristic);
begin
  assert(value is TFhirGroupCharacteristic);
  FhirGroupCharacteristics[index] := value;
end;

procedure TFhirGroupCharacteristicList.SetItemN(index: Integer; value: TFhirGroupCharacteristic);
begin
  assert(value is TFhirGroupCharacteristic);
  ObjectByIndex[index] := value;
end;

{ TFhirGroupMember }

constructor TFhirGroupMember.Create;
begin
  inherited;
end;

destructor TFhirGroupMember.Destroy;
begin
  FEntity.free;
  FPeriod.free;
  FInactive.free;
  inherited;
end;

procedure TFhirGroupMember.Assign(oSource : TFslObject);
begin
  inherited;
  entity := TFhirGroupMember(oSource).entity.Clone;
  period := TFhirGroupMember(oSource).period.Clone;
  inactiveElement := TFhirGroupMember(oSource).inactiveElement.Clone;
end;

procedure TFhirGroupMember.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'entity') Then
     list.add(self.link, 'entity', FEntity.Link);
  if (child_name = 'period') Then
     list.add(self.link, 'period', FPeriod.Link);
  if (child_name = 'inactive') Then
     list.add(self.link, 'inactive', FInactive.Link);
end;

procedure TFhirGroupMember.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'entity', 'Reference', false, TFhirReference, FEntity.Link));
  oList.add(TFHIRProperty.create(self, 'period', 'Period', false, TFhirPeriod, FPeriod.Link));
  oList.add(TFHIRProperty.create(self, 'inactive', 'boolean', false, TFhirBoolean, FInactive.Link));
end;

function TFhirGroupMember.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'entity') then
  begin
    Entity := propValue as TFhirReference;
    result := propValue;
  end
  else if (propName = 'period') then
  begin
    Period := propValue as TFhirPeriod;
    result := propValue;
  end
  else if (propName = 'inactive') then
  begin
    InactiveElement := asBoolean(propValue);
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirGroupMember.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirGroupMember.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'entity') then result := TFhirReference.create()
  else if (propName = 'period') then result := TFhirPeriod.create()
  else if (propName = 'inactive') then result := TFhirBoolean.create()
  else result := inherited createPropertyValue(propName);
end;

function TFhirGroupMember.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'entity') then result := 'Reference'
  else if (propName = 'period') then result := 'Period'
  else if (propName = 'inactive') then result := 'boolean'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirGroupMember.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'entity') then EntityElement := nil
  else if (propName = 'period') then PeriodElement := nil
  else if (propName = 'inactive') then InactiveElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirGroupMember.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'entity') then EntityElement := new as TFhirReference
  else if (propName = 'period') then PeriodElement := new as TFhirPeriod
  else if (propName = 'inactive') then InactiveElement := asBoolean(new)
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirGroupMember.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirGroupMember.fhirType : string;
begin
  result := 'Group.member';
end;

function TFhirGroupMember.Link : TFhirGroupMember;
begin
  result := TFhirGroupMember(inherited Link);
end;

function TFhirGroupMember.Clone : TFhirGroupMember;
begin
  result := TFhirGroupMember(inherited Clone);
end;

function TFhirGroupMember.equals(other : TObject) : boolean; 
var
  o : TFhirGroupMember;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirGroupMember)) then
    result := false
  else
  begin
    o := TFhirGroupMember(other);
    result := compareDeep(entityElement, o.entityElement, true) and compareDeep(periodElement, o.periodElement, true) and 
      compareDeep(inactiveElement, o.inactiveElement, true);
  end;
end;

function TFhirGroupMember.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FEntity) and isEmptyProp(FPeriod) and isEmptyProp(FInactive);
end;

procedure TFhirGroupMember.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('entity');
  fields.add('period');
  fields.add('inactive');
end;

function TFhirGroupMember.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
end;

procedure TFhirGroupMember.SetEntity(value : TFhirReference);
begin
  FEntity.free;
  FEntity := value;
end;

procedure TFhirGroupMember.SetPeriod(value : TFhirPeriod);
begin
  FPeriod.free;
  FPeriod := value;
end;

procedure TFhirGroupMember.SetInactive(value : TFhirBoolean);
begin
  FInactive.free;
  FInactive := value;
end;

function TFhirGroupMember.GetInactiveST : Boolean;
begin
  if FInactive = nil then
    result := false
  else
    result := FInactive.value;
end;

procedure TFhirGroupMember.SetInactiveST(value : Boolean);
begin
  if FInactive = nil then
    FInactive := TFhirBoolean.create;
  FInactive.value := value
end;

{ TFhirGroupMemberListEnumerator }

constructor TFhirGroupMemberListEnumerator.Create(list : TFhirGroupMemberList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirGroupMemberListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirGroupMemberListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirGroupMemberListEnumerator.GetCurrent : TFhirGroupMember;
begin
  Result := FList[FIndex];
end;

function TFhirGroupMemberListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirGroupMemberList }

function TFhirGroupMemberList.AddItem(value: TFhirGroupMember): TFhirGroupMember;
begin
  assert(value.ClassName = 'TFhirGroupMember', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirGroupMember');
  add(value);
  result := value;
end;

function TFhirGroupMemberList.Append: TFhirGroupMember;
begin
  result := TFhirGroupMember.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirGroupMemberList.ClearItems;
begin
  Clear;
end;

function TFhirGroupMemberList.GetEnumerator : TFhirGroupMemberListEnumerator;
begin
  result := TFhirGroupMemberListEnumerator.Create(self.link);
end;

function TFhirGroupMemberList.Clone: TFhirGroupMemberList;
begin
  result := TFhirGroupMemberList(inherited Clone);
end;

function TFhirGroupMemberList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirGroupMemberList.GetItemN(index: Integer): TFhirGroupMember;
begin
  result := TFhirGroupMember(ObjectByIndex[index]);
end;

function TFhirGroupMemberList.ItemClass: TFslObjectClass;
begin
  result := TFhirGroupMember;
end;
function TFhirGroupMemberList.IndexOf(value: TFhirGroupMember): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirGroupMemberList.Insert(index: Integer): TFhirGroupMember;
begin
  result := TFhirGroupMember.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirGroupMemberList.InsertItem(index: Integer; value: TFhirGroupMember);
begin
  assert(value is TFhirGroupMember);
  Inherited Insert(index, value);
end;

function TFhirGroupMemberList.Item(index: Integer): TFhirGroupMember;
begin
  result := TFhirGroupMember(ObjectByIndex[index]);
end;

function TFhirGroupMemberList.Link: TFhirGroupMemberList;
begin
  result := TFhirGroupMemberList(inherited Link);
end;

procedure TFhirGroupMemberList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirGroupMemberList.SetItemByIndex(index: Integer; value: TFhirGroupMember);
begin
  assert(value is TFhirGroupMember);
  FhirGroupMembers[index] := value;
end;

procedure TFhirGroupMemberList.SetItemN(index: Integer; value: TFhirGroupMember);
begin
  assert(value is TFhirGroupMember);
  ObjectByIndex[index] := value;
end;

{ TFhirGroup }

constructor TFhirGroup.Create;
begin
  inherited;
end;

destructor TFhirGroup.Destroy;
begin
  FIdentifierList.Free;
  FActive.free;
  FType_.free;
  FMembership.free;
  FCode.free;
  FName.free;
  FDescription.free;
  FQuantity.free;
  FManagingEntity.free;
  FCharacteristicList.Free;
  FMemberList.Free;
  inherited;
end;

procedure TFhirGroup.Assign(oSource : TFslObject);
begin
  inherited;
  if (TFhirGroup(oSource).FIdentifierList = nil) then
  begin
    FIdentifierList.free;
    FIdentifierList := nil;
  end
  else
  begin
    if FIdentifierList = nil then
      FIdentifierList := TFhirIdentifierList.Create;
    FIdentifierList.Assign(TFhirGroup(oSource).FIdentifierList);
  end;
  activeElement := TFhirGroup(oSource).activeElement.Clone;
  type_Element := TFhirGroup(oSource).type_Element.Clone;
  membershipElement := TFhirGroup(oSource).membershipElement.Clone;
  code := TFhirGroup(oSource).code.Clone;
  nameElement := TFhirGroup(oSource).nameElement.Clone;
  descriptionElement := TFhirGroup(oSource).descriptionElement.Clone;
  quantityElement := TFhirGroup(oSource).quantityElement.Clone;
  managingEntity := TFhirGroup(oSource).managingEntity.Clone;
  if (TFhirGroup(oSource).FCharacteristicList = nil) then
  begin
    FCharacteristicList.free;
    FCharacteristicList := nil;
  end
  else
  begin
    if FCharacteristicList = nil then
      FCharacteristicList := TFhirGroupCharacteristicList.Create;
    FCharacteristicList.Assign(TFhirGroup(oSource).FCharacteristicList);
  end;
  if (TFhirGroup(oSource).FMemberList = nil) then
  begin
    FMemberList.free;
    FMemberList := nil;
  end
  else
  begin
    if FMemberList = nil then
      FMemberList := TFhirGroupMemberList.Create;
    FMemberList.Assign(TFhirGroup(oSource).FMemberList);
  end;
end;

function TFhirGroup.GetResourceType : TFhirResourceType;
begin
  result := frtGroup;
end;

procedure TFhirGroup.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'identifier') Then
    list.addAll(self, 'identifier', FIdentifierList);
  if (child_name = 'active') Then
     list.add(self.link, 'active', FActive.Link);
  if (child_name = 'type') Then
     list.add(self.link, 'type', FType_.Link);
  if (child_name = 'membership') Then
     list.add(self.link, 'membership', FMembership.Link);
  if (child_name = 'code') Then
     list.add(self.link, 'code', FCode.Link);
  if (child_name = 'name') Then
     list.add(self.link, 'name', FName.Link);
  if (child_name = 'description') Then
     list.add(self.link, 'description', FDescription.Link);
  if (child_name = 'quantity') Then
     list.add(self.link, 'quantity', FQuantity.Link);
  if (child_name = 'managingEntity') Then
     list.add(self.link, 'managingEntity', FManagingEntity.Link);
  if (child_name = 'characteristic') Then
    list.addAll(self, 'characteristic', FCharacteristicList);
  if (child_name = 'member') Then
    list.addAll(self, 'member', FMemberList);
end;

procedure TFhirGroup.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'identifier', 'Identifier', true, TFhirIdentifier, FIdentifierList.Link));
  oList.add(TFHIRProperty.create(self, 'active', 'boolean', false, TFhirBoolean, FActive.Link));
  oList.add(TFHIRProperty.create(self, 'type', 'code', false, TFhirEnum, FType_.Link));
  oList.add(TFHIRProperty.create(self, 'membership', 'code', false, TFhirEnum, FMembership.Link));
  oList.add(TFHIRProperty.create(self, 'code', 'CodeableConcept', false, TFhirCodeableConcept, FCode.Link));
  oList.add(TFHIRProperty.create(self, 'name', 'string', false, TFhirString, FName.Link));
  oList.add(TFHIRProperty.create(self, 'description', 'markdown', false, TFhirMarkdown, FDescription.Link));
  oList.add(TFHIRProperty.create(self, 'quantity', 'unsignedInt', false, TFhirUnsignedInt, FQuantity.Link));
  oList.add(TFHIRProperty.create(self, 'managingEntity', 'Reference', false, TFhirReference, FManagingEntity.Link));
  oList.add(TFHIRProperty.create(self, 'characteristic', 'BackboneElement', true, TFhirGroupCharacteristic, FCharacteristicList.Link));
  oList.add(TFHIRProperty.create(self, 'member', 'BackboneElement', true, TFhirGroupMember, FMemberList.Link));
end;

function TFhirGroup.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'identifier') then
  begin
    IdentifierList.add(propValue as TFhirIdentifier);
    result := propValue;
  end
  else if (propName = 'active') then
  begin
    ActiveElement := asBoolean(propValue);
    result := propValue;
  end
  else if (propName = 'type') then
  begin
    Type_Element := asEnum(SYSTEMS_TFhirGroupTypeEnum, CODES_TFhirGroupTypeEnum, propValue);
    result := propValue;
  end
  else if (propName = 'membership') then
  begin
    MembershipElement := asEnum(SYSTEMS_TFhirGroupMembershipBasisEnum, CODES_TFhirGroupMembershipBasisEnum, propValue);
    result := propValue;
  end
  else if (propName = 'code') then
  begin
    Code := propValue as TFhirCodeableConcept;
    result := propValue;
  end
  else if (propName = 'name') then
  begin
    NameElement := asString(propValue);
    result := propValue;
  end
  else if (propName = 'description') then
  begin
    DescriptionElement := asMarkdown(propValue);
    result := propValue;
  end
  else if (propName = 'quantity') then
  begin
    QuantityElement := asUnsignedInt(propValue);
    result := propValue;
  end
  else if (propName = 'managingEntity') then
  begin
    ManagingEntity := propValue as TFhirReference;
    result := propValue;
  end
  else if (propName = 'characteristic') then
  begin
    CharacteristicList.add(propValue as TFhirGroupCharacteristic);
    result := propValue;
  end
  else if (propName = 'member') then
  begin
    MemberList.add(propValue as TFhirGroupMember);
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirGroup.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'identifier') then IdentifierList.insertItem(index, propValue as TFhirIdentifier)
  else if (propName = 'characteristic') then CharacteristicList.insertItem(index, propValue as TFhirGroupCharacteristic)
  else if (propName = 'member') then MemberList.insertItem(index, propValue as TFhirGroupMember)
  else inherited;
end;

function TFhirGroup.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'identifier') then result := IdentifierList.new()
  else if (propName = 'active') then result := TFhirBoolean.create()
  else if (propName = 'type') then result := TFhirEnum.create(SYSTEMS_TFhirGroupTypeEnum[GroupTypeNull], CODES_TFhirGroupTypeEnum[GroupTypeNull]) 
  else if (propName = 'membership') then result := TFhirEnum.create(SYSTEMS_TFhirGroupMembershipBasisEnum[GroupMembershipBasisNull], CODES_TFhirGroupMembershipBasisEnum[GroupMembershipBasisNull]) 
  else if (propName = 'code') then result := TFhirCodeableConcept.create()
  else if (propName = 'name') then result := TFhirString.create()
  else if (propName = 'description') then result := TFhirMarkdown.create()
  else if (propName = 'quantity') then result := TFhirUnsignedInt.create()
  else if (propName = 'managingEntity') then result := TFhirReference.create()
  else if (propName = 'characteristic') then result := CharacteristicList.new()
  else if (propName = 'member') then result := MemberList.new()
  else result := inherited createPropertyValue(propName);
end;

function TFhirGroup.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'identifier') then result := 'Identifier'
  else if (propName = 'active') then result := 'boolean'
  else if (propName = 'type') then result := 'code'
  else if (propName = 'membership') then result := 'code'
  else if (propName = 'code') then result := 'CodeableConcept'
  else if (propName = 'name') then result := 'string'
  else if (propName = 'description') then result := 'markdown'
  else if (propName = 'quantity') then result := 'unsignedInt'
  else if (propName = 'managingEntity') then result := 'Reference'
  else if (propName = 'characteristic') then result := 'BackboneElement'
  else if (propName = 'member') then result := 'BackboneElement'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirGroup.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'identifier') then deletePropertyValue('identifier', IdentifierList, value)
  else if (propName = 'active') then ActiveElement := nil
  else if (propName = 'type') then Type_Element := nil
  else if (propName = 'membership') then MembershipElement := nil
  else if (propName = 'code') then CodeElement := nil
  else if (propName = 'name') then NameElement := nil
  else if (propName = 'description') then DescriptionElement := nil
  else if (propName = 'quantity') then QuantityElement := nil
  else if (propName = 'managingEntity') then ManagingEntityElement := nil
  else if (propName = 'characteristic') then deletePropertyValue('characteristic', CharacteristicList, value)
  else if (propName = 'member') then deletePropertyValue('member', MemberList, value)
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirGroup.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'identifier') then replacePropertyValue('identifier', IdentifierList, existing, new)
  else if (propName = 'active') then ActiveElement := asBoolean(new)
  else if (propName = 'type') then Type_Element := asEnum(SYSTEMS_TFhirGroupTypeEnum, CODES_TFhirGroupTypeEnum, new)
  else if (propName = 'membership') then MembershipElement := asEnum(SYSTEMS_TFhirGroupMembershipBasisEnum, CODES_TFhirGroupMembershipBasisEnum, new)
  else if (propName = 'code') then CodeElement := new as TFhirCodeableConcept
  else if (propName = 'name') then NameElement := asString(new)
  else if (propName = 'description') then DescriptionElement := asMarkdown(new)
  else if (propName = 'quantity') then QuantityElement := asUnsignedInt(new)
  else if (propName = 'managingEntity') then ManagingEntityElement := new as TFhirReference
  else if (propName = 'characteristic') then replacePropertyValue('characteristic', CharacteristicList, existing, new)
  else if (propName = 'member') then replacePropertyValue('member', MemberList, existing, new)
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirGroup.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'identifier') then IdentifierList.move(source, destination)
  else if (propName = 'characteristic') then CharacteristicList.move(source, destination)
  else if (propName = 'member') then MemberList.move(source, destination)
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirGroup.fhirType : string;
begin
  result := 'Group';
end;

function TFhirGroup.Link : TFhirGroup;
begin
  result := TFhirGroup(inherited Link);
end;

function TFhirGroup.Clone : TFhirGroup;
begin
  result := TFhirGroup(inherited Clone);
end;

function TFhirGroup.equals(other : TObject) : boolean; 
var
  o : TFhirGroup;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirGroup)) then
    result := false
  else
  begin
    o := TFhirGroup(other);
    result := compareDeep(identifierList, o.identifierList, true) and compareDeep(activeElement, o.activeElement, true) and 
      compareDeep(type_Element, o.type_Element, true) and compareDeep(membershipElement, o.membershipElement, true) and 
      compareDeep(codeElement, o.codeElement, true) and compareDeep(nameElement, o.nameElement, true) and 
      compareDeep(descriptionElement, o.descriptionElement, true) and compareDeep(quantityElement, o.quantityElement, true) and 
      compareDeep(managingEntityElement, o.managingEntityElement, true) and compareDeep(characteristicList, o.characteristicList, true) and 
      compareDeep(memberList, o.memberList, true);
  end;
end;

function TFhirGroup.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FidentifierList) and isEmptyProp(FActive) and isEmptyProp(FType_) and isEmptyProp(FMembership) and isEmptyProp(FCode) and isEmptyProp(FName) and isEmptyProp(FDescription) and isEmptyProp(FQuantity) and isEmptyProp(FManagingEntity) and isEmptyProp(FcharacteristicList) and isEmptyProp(FmemberList);
end;

procedure TFhirGroup.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('identifier');
  fields.add('active');
  fields.add('type');
  fields.add('membership');
  fields.add('code');
  fields.add('name');
  fields.add('description');
  fields.add('quantity');
  fields.add('managingEntity');
  fields.add('characteristic');
  fields.add('member');
end;

function TFhirGroup.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
  inc(result, FIdentifierList.sizeInBytes(magic));
  inc(result, FCharacteristicList.sizeInBytes(magic));
  inc(result, FMemberList.sizeInBytes(magic));
end;

function TFhirGroup.GetIdentifierList : TFhirIdentifierList;
begin
  if FIdentifierList = nil then
    FIdentifierList := TFhirIdentifierList.Create;
  result := FIdentifierList;
end;

function TFhirGroup.GetHasIdentifierList : boolean;
begin
  result := (FIdentifierList <> nil) and (FIdentifierList.count > 0);
end;

procedure TFhirGroup.SetActive(value : TFhirBoolean);
begin
  FActive.free;
  FActive := value;
end;

function TFhirGroup.GetActiveST : Boolean;
begin
  if FActive = nil then
    result := false
  else
    result := FActive.value;
end;

procedure TFhirGroup.SetActiveST(value : Boolean);
begin
  if FActive = nil then
    FActive := TFhirBoolean.create;
  FActive.value := value
end;

procedure TFhirGroup.SetType_(value : TFhirEnum);
begin
  FType_.free;
  FType_ := value;
end;

function TFhirGroup.GetType_ST : TFhirGroupTypeEnum;
begin
  if FType_ = nil then
    result := TFhirGroupTypeEnum(0)
  else
    result := TFhirGroupTypeEnum(StringArrayIndexOfSensitive(CODES_TFhirGroupTypeEnum, FType_.value));
end;

procedure TFhirGroup.SetType_ST(value : TFhirGroupTypeEnum);
begin
  if ord(value) = 0 then
    Type_Element := nil
  else
    Type_Element := TFhirEnum.create(SYSTEMS_TFhirGroupTypeEnum[value], CODES_TFhirGroupTypeEnum[value]);
end;

procedure TFhirGroup.SetMembership(value : TFhirEnum);
begin
  FMembership.free;
  FMembership := value;
end;

function TFhirGroup.GetMembershipST : TFhirGroupMembershipBasisEnum;
begin
  if FMembership = nil then
    result := TFhirGroupMembershipBasisEnum(0)
  else
    result := TFhirGroupMembershipBasisEnum(StringArrayIndexOfSensitive(CODES_TFhirGroupMembershipBasisEnum, FMembership.value));
end;

procedure TFhirGroup.SetMembershipST(value : TFhirGroupMembershipBasisEnum);
begin
  if ord(value) = 0 then
    MembershipElement := nil
  else
    MembershipElement := TFhirEnum.create(SYSTEMS_TFhirGroupMembershipBasisEnum[value], CODES_TFhirGroupMembershipBasisEnum[value]);
end;

procedure TFhirGroup.SetCode(value : TFhirCodeableConcept);
begin
  FCode.free;
  FCode := value;
end;

procedure TFhirGroup.SetName(value : TFhirString);
begin
  FName.free;
  FName := value;
end;

function TFhirGroup.GetNameST : String;
begin
  if FName = nil then
    result := ''
  else
    result := FName.value;
end;

procedure TFhirGroup.SetNameST(value : String);
begin
  if value <> '' then
  begin
    if FName = nil then
      FName := TFhirString.create;
    FName.value := value
  end
  else if FName <> nil then
    FName.value := '';
end;

procedure TFhirGroup.SetDescription(value : TFhirMarkdown);
begin
  FDescription.free;
  FDescription := value;
end;

function TFhirGroup.GetDescriptionST : String;
begin
  if FDescription = nil then
    result := ''
  else
    result := FDescription.value;
end;

procedure TFhirGroup.SetDescriptionST(value : String);
begin
  if value <> '' then
  begin
    if FDescription = nil then
      FDescription := TFhirMarkdown.create;
    FDescription.value := value
  end
  else if FDescription <> nil then
    FDescription.value := '';
end;

procedure TFhirGroup.SetQuantity(value : TFhirUnsignedInt);
begin
  FQuantity.free;
  FQuantity := value;
end;

function TFhirGroup.GetQuantityST : String;
begin
  if FQuantity = nil then
    result := ''
  else
    result := FQuantity.value;
end;

procedure TFhirGroup.SetQuantityST(value : String);
begin
  if value <> '' then
  begin
    if FQuantity = nil then
      FQuantity := TFhirUnsignedInt.create;
    FQuantity.value := value
  end
  else if FQuantity <> nil then
    FQuantity.value := '';
end;

procedure TFhirGroup.SetManagingEntity(value : TFhirReference);
begin
  FManagingEntity.free;
  FManagingEntity := value;
end;

function TFhirGroup.GetCharacteristicList : TFhirGroupCharacteristicList;
begin
  if FCharacteristicList = nil then
    FCharacteristicList := TFhirGroupCharacteristicList.Create;
  result := FCharacteristicList;
end;

function TFhirGroup.GetHasCharacteristicList : boolean;
begin
  result := (FCharacteristicList <> nil) and (FCharacteristicList.count > 0);
end;

function TFhirGroup.GetMemberList : TFhirGroupMemberList;
begin
  if FMemberList = nil then
    FMemberList := TFhirGroupMemberList.Create;
  result := FMemberList;
end;

function TFhirGroup.GetHasMemberList : boolean;
begin
  result := (FMemberList <> nil) and (FMemberList.count > 0);
end;

{ TFhirGroupListEnumerator }

constructor TFhirGroupListEnumerator.Create(list : TFhirGroupList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirGroupListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirGroupListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirGroupListEnumerator.GetCurrent : TFhirGroup;
begin
  Result := FList[FIndex];
end;

function TFhirGroupListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirGroupList }

function TFhirGroupList.AddItem(value: TFhirGroup): TFhirGroup;
begin
  assert(value.ClassName = 'TFhirGroup', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirGroup');
  add(value);
  result := value;
end;

function TFhirGroupList.Append: TFhirGroup;
begin
  result := TFhirGroup.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirGroupList.ClearItems;
begin
  Clear;
end;

function TFhirGroupList.GetEnumerator : TFhirGroupListEnumerator;
begin
  result := TFhirGroupListEnumerator.Create(self.link);
end;

function TFhirGroupList.Clone: TFhirGroupList;
begin
  result := TFhirGroupList(inherited Clone);
end;

function TFhirGroupList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirGroupList.GetItemN(index: Integer): TFhirGroup;
begin
  result := TFhirGroup(ObjectByIndex[index]);
end;

function TFhirGroupList.ItemClass: TFslObjectClass;
begin
  result := TFhirGroup;
end;
function TFhirGroupList.IndexOf(value: TFhirGroup): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirGroupList.Insert(index: Integer): TFhirGroup;
begin
  result := TFhirGroup.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirGroupList.InsertItem(index: Integer; value: TFhirGroup);
begin
  assert(value is TFhirGroup);
  Inherited Insert(index, value);
end;

function TFhirGroupList.Item(index: Integer): TFhirGroup;
begin
  result := TFhirGroup(ObjectByIndex[index]);
end;

function TFhirGroupList.Link: TFhirGroupList;
begin
  result := TFhirGroupList(inherited Link);
end;

procedure TFhirGroupList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirGroupList.SetItemByIndex(index: Integer; value: TFhirGroup);
begin
  assert(value is TFhirGroup);
  FhirGroups[index] := value;
end;

procedure TFhirGroupList.SetItemN(index: Integer; value: TFhirGroup);
begin
  assert(value is TFhirGroup);
  ObjectByIndex[index] := value;
end;

{$ENDIF FHIR_GROUP}
{$IFDEF FHIR_HEALTHCARESERVICE}
{ TFhirHealthcareServiceEligibility }

constructor TFhirHealthcareServiceEligibility.Create;
begin
  inherited;
end;

destructor TFhirHealthcareServiceEligibility.Destroy;
begin
  FCode.free;
  FComment.free;
  inherited;
end;

procedure TFhirHealthcareServiceEligibility.Assign(oSource : TFslObject);
begin
  inherited;
  code := TFhirHealthcareServiceEligibility(oSource).code.Clone;
  commentElement := TFhirHealthcareServiceEligibility(oSource).commentElement.Clone;
end;

procedure TFhirHealthcareServiceEligibility.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'code') Then
     list.add(self.link, 'code', FCode.Link);
  if (child_name = 'comment') Then
     list.add(self.link, 'comment', FComment.Link);
end;

procedure TFhirHealthcareServiceEligibility.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'code', 'CodeableConcept', false, TFhirCodeableConcept, FCode.Link));
  oList.add(TFHIRProperty.create(self, 'comment', 'markdown', false, TFhirMarkdown, FComment.Link));
end;

function TFhirHealthcareServiceEligibility.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'code') then
  begin
    Code := propValue as TFhirCodeableConcept;
    result := propValue;
  end
  else if (propName = 'comment') then
  begin
    CommentElement := asMarkdown(propValue);
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirHealthcareServiceEligibility.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirHealthcareServiceEligibility.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'code') then result := TFhirCodeableConcept.create()
  else if (propName = 'comment') then result := TFhirMarkdown.create()
  else result := inherited createPropertyValue(propName);
end;

function TFhirHealthcareServiceEligibility.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'code') then result := 'CodeableConcept'
  else if (propName = 'comment') then result := 'markdown'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirHealthcareServiceEligibility.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'code') then CodeElement := nil
  else if (propName = 'comment') then CommentElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirHealthcareServiceEligibility.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'code') then CodeElement := new as TFhirCodeableConcept
  else if (propName = 'comment') then CommentElement := asMarkdown(new)
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirHealthcareServiceEligibility.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirHealthcareServiceEligibility.fhirType : string;
begin
  result := 'HealthcareService.eligibility';
end;

function TFhirHealthcareServiceEligibility.Link : TFhirHealthcareServiceEligibility;
begin
  result := TFhirHealthcareServiceEligibility(inherited Link);
end;

function TFhirHealthcareServiceEligibility.Clone : TFhirHealthcareServiceEligibility;
begin
  result := TFhirHealthcareServiceEligibility(inherited Clone);
end;

function TFhirHealthcareServiceEligibility.equals(other : TObject) : boolean; 
var
  o : TFhirHealthcareServiceEligibility;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirHealthcareServiceEligibility)) then
    result := false
  else
  begin
    o := TFhirHealthcareServiceEligibility(other);
    result := compareDeep(codeElement, o.codeElement, true) and compareDeep(commentElement, o.commentElement, true);
  end;
end;

function TFhirHealthcareServiceEligibility.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FCode) and isEmptyProp(FComment);
end;

procedure TFhirHealthcareServiceEligibility.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('code');
  fields.add('comment');
end;

function TFhirHealthcareServiceEligibility.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
end;

procedure TFhirHealthcareServiceEligibility.SetCode(value : TFhirCodeableConcept);
begin
  FCode.free;
  FCode := value;
end;

procedure TFhirHealthcareServiceEligibility.SetComment(value : TFhirMarkdown);
begin
  FComment.free;
  FComment := value;
end;

function TFhirHealthcareServiceEligibility.GetCommentST : String;
begin
  if FComment = nil then
    result := ''
  else
    result := FComment.value;
end;

procedure TFhirHealthcareServiceEligibility.SetCommentST(value : String);
begin
  if value <> '' then
  begin
    if FComment = nil then
      FComment := TFhirMarkdown.create;
    FComment.value := value
  end
  else if FComment <> nil then
    FComment.value := '';
end;

{ TFhirHealthcareServiceEligibilityListEnumerator }

constructor TFhirHealthcareServiceEligibilityListEnumerator.Create(list : TFhirHealthcareServiceEligibilityList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirHealthcareServiceEligibilityListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirHealthcareServiceEligibilityListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirHealthcareServiceEligibilityListEnumerator.GetCurrent : TFhirHealthcareServiceEligibility;
begin
  Result := FList[FIndex];
end;

function TFhirHealthcareServiceEligibilityListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirHealthcareServiceEligibilityList }

function TFhirHealthcareServiceEligibilityList.AddItem(value: TFhirHealthcareServiceEligibility): TFhirHealthcareServiceEligibility;
begin
  assert(value.ClassName = 'TFhirHealthcareServiceEligibility', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirHealthcareServiceEligibility');
  add(value);
  result := value;
end;

function TFhirHealthcareServiceEligibilityList.Append: TFhirHealthcareServiceEligibility;
begin
  result := TFhirHealthcareServiceEligibility.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirHealthcareServiceEligibilityList.ClearItems;
begin
  Clear;
end;

function TFhirHealthcareServiceEligibilityList.GetEnumerator : TFhirHealthcareServiceEligibilityListEnumerator;
begin
  result := TFhirHealthcareServiceEligibilityListEnumerator.Create(self.link);
end;

function TFhirHealthcareServiceEligibilityList.Clone: TFhirHealthcareServiceEligibilityList;
begin
  result := TFhirHealthcareServiceEligibilityList(inherited Clone);
end;

function TFhirHealthcareServiceEligibilityList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirHealthcareServiceEligibilityList.GetItemN(index: Integer): TFhirHealthcareServiceEligibility;
begin
  result := TFhirHealthcareServiceEligibility(ObjectByIndex[index]);
end;

function TFhirHealthcareServiceEligibilityList.ItemClass: TFslObjectClass;
begin
  result := TFhirHealthcareServiceEligibility;
end;
function TFhirHealthcareServiceEligibilityList.IndexOf(value: TFhirHealthcareServiceEligibility): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirHealthcareServiceEligibilityList.Insert(index: Integer): TFhirHealthcareServiceEligibility;
begin
  result := TFhirHealthcareServiceEligibility.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirHealthcareServiceEligibilityList.InsertItem(index: Integer; value: TFhirHealthcareServiceEligibility);
begin
  assert(value is TFhirHealthcareServiceEligibility);
  Inherited Insert(index, value);
end;

function TFhirHealthcareServiceEligibilityList.Item(index: Integer): TFhirHealthcareServiceEligibility;
begin
  result := TFhirHealthcareServiceEligibility(ObjectByIndex[index]);
end;

function TFhirHealthcareServiceEligibilityList.Link: TFhirHealthcareServiceEligibilityList;
begin
  result := TFhirHealthcareServiceEligibilityList(inherited Link);
end;

procedure TFhirHealthcareServiceEligibilityList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirHealthcareServiceEligibilityList.SetItemByIndex(index: Integer; value: TFhirHealthcareServiceEligibility);
begin
  assert(value is TFhirHealthcareServiceEligibility);
  FhirHealthcareServiceEligibilities[index] := value;
end;

procedure TFhirHealthcareServiceEligibilityList.SetItemN(index: Integer; value: TFhirHealthcareServiceEligibility);
begin
  assert(value is TFhirHealthcareServiceEligibility);
  ObjectByIndex[index] := value;
end;

{ TFhirHealthcareService }

constructor TFhirHealthcareService.Create;
begin
  inherited;
end;

destructor TFhirHealthcareService.Destroy;
begin
  FIdentifierList.Free;
  FActive.free;
  FProvidedBy.free;
  FOfferedInList.Free;
  FCategoryList.Free;
  FType_List.Free;
  FSpecialtyList.Free;
  FLocationList.Free;
  FName.free;
  FComment.free;
  FExtraDetails.free;
  FPhoto.free;
  FContactList.Free;
  FCoverageAreaList.Free;
  FServiceProvisionCodeList.Free;
  FEligibilityList.Free;
  FProgram_List.Free;
  FCharacteristicList.Free;
  FCommunicationList.Free;
  FReferralMethodList.Free;
  FAppointmentRequired.free;
  FAvailabilityList.Free;
  FEndpointList.Free;
  inherited;
end;

procedure TFhirHealthcareService.Assign(oSource : TFslObject);
begin
  inherited;
  if (TFhirHealthcareService(oSource).FIdentifierList = nil) then
  begin
    FIdentifierList.free;
    FIdentifierList := nil;
  end
  else
  begin
    if FIdentifierList = nil then
      FIdentifierList := TFhirIdentifierList.Create;
    FIdentifierList.Assign(TFhirHealthcareService(oSource).FIdentifierList);
  end;
  activeElement := TFhirHealthcareService(oSource).activeElement.Clone;
  providedBy := TFhirHealthcareService(oSource).providedBy.Clone;
  if (TFhirHealthcareService(oSource).FOfferedInList = nil) then
  begin
    FOfferedInList.free;
    FOfferedInList := nil;
  end
  else
  begin
    if FOfferedInList = nil then
      FOfferedInList := TFhirReferenceList.Create;
    FOfferedInList.Assign(TFhirHealthcareService(oSource).FOfferedInList);
  end;
  if (TFhirHealthcareService(oSource).FCategoryList = nil) then
  begin
    FCategoryList.free;
    FCategoryList := nil;
  end
  else
  begin
    if FCategoryList = nil then
      FCategoryList := TFhirCodeableConceptList.Create;
    FCategoryList.Assign(TFhirHealthcareService(oSource).FCategoryList);
  end;
  if (TFhirHealthcareService(oSource).FType_List = nil) then
  begin
    FType_List.free;
    FType_List := nil;
  end
  else
  begin
    if FType_List = nil then
      FType_List := TFhirCodeableConceptList.Create;
    FType_List.Assign(TFhirHealthcareService(oSource).FType_List);
  end;
  if (TFhirHealthcareService(oSource).FSpecialtyList = nil) then
  begin
    FSpecialtyList.free;
    FSpecialtyList := nil;
  end
  else
  begin
    if FSpecialtyList = nil then
      FSpecialtyList := TFhirCodeableConceptList.Create;
    FSpecialtyList.Assign(TFhirHealthcareService(oSource).FSpecialtyList);
  end;
  if (TFhirHealthcareService(oSource).FLocationList = nil) then
  begin
    FLocationList.free;
    FLocationList := nil;
  end
  else
  begin
    if FLocationList = nil then
      FLocationList := TFhirReferenceList.Create;
    FLocationList.Assign(TFhirHealthcareService(oSource).FLocationList);
  end;
  nameElement := TFhirHealthcareService(oSource).nameElement.Clone;
  commentElement := TFhirHealthcareService(oSource).commentElement.Clone;
  extraDetailsElement := TFhirHealthcareService(oSource).extraDetailsElement.Clone;
  photo := TFhirHealthcareService(oSource).photo.Clone;
  if (TFhirHealthcareService(oSource).FContactList = nil) then
  begin
    FContactList.free;
    FContactList := nil;
  end
  else
  begin
    if FContactList = nil then
      FContactList := TFhirExtendedContactDetailList.Create;
    FContactList.Assign(TFhirHealthcareService(oSource).FContactList);
  end;
  if (TFhirHealthcareService(oSource).FCoverageAreaList = nil) then
  begin
    FCoverageAreaList.free;
    FCoverageAreaList := nil;
  end
  else
  begin
    if FCoverageAreaList = nil then
      FCoverageAreaList := TFhirReferenceList.Create;
    FCoverageAreaList.Assign(TFhirHealthcareService(oSource).FCoverageAreaList);
  end;
  if (TFhirHealthcareService(oSource).FServiceProvisionCodeList = nil) then
  begin
    FServiceProvisionCodeList.free;
    FServiceProvisionCodeList := nil;
  end
  else
  begin
    if FServiceProvisionCodeList = nil then
      FServiceProvisionCodeList := TFhirCodeableConceptList.Create;
    FServiceProvisionCodeList.Assign(TFhirHealthcareService(oSource).FServiceProvisionCodeList);
  end;
  if (TFhirHealthcareService(oSource).FEligibilityList = nil) then
  begin
    FEligibilityList.free;
    FEligibilityList := nil;
  end
  else
  begin
    if FEligibilityList = nil then
      FEligibilityList := TFhirHealthcareServiceEligibilityList.Create;
    FEligibilityList.Assign(TFhirHealthcareService(oSource).FEligibilityList);
  end;
  if (TFhirHealthcareService(oSource).FProgram_List = nil) then
  begin
    FProgram_List.free;
    FProgram_List := nil;
  end
  else
  begin
    if FProgram_List = nil then
      FProgram_List := TFhirCodeableConceptList.Create;
    FProgram_List.Assign(TFhirHealthcareService(oSource).FProgram_List);
  end;
  if (TFhirHealthcareService(oSource).FCharacteristicList = nil) then
  begin
    FCharacteristicList.free;
    FCharacteristicList := nil;
  end
  else
  begin
    if FCharacteristicList = nil then
      FCharacteristicList := TFhirCodeableConceptList.Create;
    FCharacteristicList.Assign(TFhirHealthcareService(oSource).FCharacteristicList);
  end;
  if (TFhirHealthcareService(oSource).FCommunicationList = nil) then
  begin
    FCommunicationList.free;
    FCommunicationList := nil;
  end
  else
  begin
    if FCommunicationList = nil then
      FCommunicationList := TFhirCodeableConceptList.Create;
    FCommunicationList.Assign(TFhirHealthcareService(oSource).FCommunicationList);
  end;
  if (TFhirHealthcareService(oSource).FReferralMethodList = nil) then
  begin
    FReferralMethodList.free;
    FReferralMethodList := nil;
  end
  else
  begin
    if FReferralMethodList = nil then
      FReferralMethodList := TFhirCodeableConceptList.Create;
    FReferralMethodList.Assign(TFhirHealthcareService(oSource).FReferralMethodList);
  end;
  appointmentRequiredElement := TFhirHealthcareService(oSource).appointmentRequiredElement.Clone;
  if (TFhirHealthcareService(oSource).FAvailabilityList = nil) then
  begin
    FAvailabilityList.free;
    FAvailabilityList := nil;
  end
  else
  begin
    if FAvailabilityList = nil then
      FAvailabilityList := TFhirAvailabilityList.Create;
    FAvailabilityList.Assign(TFhirHealthcareService(oSource).FAvailabilityList);
  end;
  if (TFhirHealthcareService(oSource).FEndpointList = nil) then
  begin
    FEndpointList.free;
    FEndpointList := nil;
  end
  else
  begin
    if FEndpointList = nil then
      FEndpointList := TFhirReferenceList.Create;
    FEndpointList.Assign(TFhirHealthcareService(oSource).FEndpointList);
  end;
end;

function TFhirHealthcareService.GetResourceType : TFhirResourceType;
begin
  result := frtHealthcareService;
end;

procedure TFhirHealthcareService.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'identifier') Then
    list.addAll(self, 'identifier', FIdentifierList);
  if (child_name = 'active') Then
     list.add(self.link, 'active', FActive.Link);
  if (child_name = 'providedBy') Then
     list.add(self.link, 'providedBy', FProvidedBy.Link);
  if (child_name = 'offeredIn') Then
    list.addAll(self, 'offeredIn', FOfferedInList);
  if (child_name = 'category') Then
    list.addAll(self, 'category', FCategoryList);
  if (child_name = 'type') Then
    list.addAll(self, 'type', FType_List);
  if (child_name = 'specialty') Then
    list.addAll(self, 'specialty', FSpecialtyList);
  if (child_name = 'location') Then
    list.addAll(self, 'location', FLocationList);
  if (child_name = 'name') Then
     list.add(self.link, 'name', FName.Link);
  if (child_name = 'comment') Then
     list.add(self.link, 'comment', FComment.Link);
  if (child_name = 'extraDetails') Then
     list.add(self.link, 'extraDetails', FExtraDetails.Link);
  if (child_name = 'photo') Then
     list.add(self.link, 'photo', FPhoto.Link);
  if (child_name = 'contact') Then
    list.addAll(self, 'contact', FContactList);
  if (child_name = 'coverageArea') Then
    list.addAll(self, 'coverageArea', FCoverageAreaList);
  if (child_name = 'serviceProvisionCode') Then
    list.addAll(self, 'serviceProvisionCode', FServiceProvisionCodeList);
  if (child_name = 'eligibility') Then
    list.addAll(self, 'eligibility', FEligibilityList);
  if (child_name = 'program') Then
    list.addAll(self, 'program', FProgram_List);
  if (child_name = 'characteristic') Then
    list.addAll(self, 'characteristic', FCharacteristicList);
  if (child_name = 'communication') Then
    list.addAll(self, 'communication', FCommunicationList);
  if (child_name = 'referralMethod') Then
    list.addAll(self, 'referralMethod', FReferralMethodList);
  if (child_name = 'appointmentRequired') Then
     list.add(self.link, 'appointmentRequired', FAppointmentRequired.Link);
  if (child_name = 'availability') Then
    list.addAll(self, 'availability', FAvailabilityList);
  if (child_name = 'endpoint') Then
    list.addAll(self, 'endpoint', FEndpointList);
end;

procedure TFhirHealthcareService.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'identifier', 'Identifier', true, TFhirIdentifier, FIdentifierList.Link));
  oList.add(TFHIRProperty.create(self, 'active', 'boolean', false, TFhirBoolean, FActive.Link));
  oList.add(TFHIRProperty.create(self, 'providedBy', 'Reference', false, TFhirReference, FProvidedBy.Link));
  oList.add(TFHIRProperty.create(self, 'offeredIn', 'Reference', true, TFhirReference, FOfferedInList.Link));
  oList.add(TFHIRProperty.create(self, 'category', 'CodeableConcept', true, TFhirCodeableConcept, FCategoryList.Link));
  oList.add(TFHIRProperty.create(self, 'type', 'CodeableConcept', true, TFhirCodeableConcept, FType_List.Link));
  oList.add(TFHIRProperty.create(self, 'specialty', 'CodeableConcept', true, TFhirCodeableConcept, FSpecialtyList.Link));
  oList.add(TFHIRProperty.create(self, 'location', 'Reference', true, TFhirReference, FLocationList.Link));
  oList.add(TFHIRProperty.create(self, 'name', 'string', false, TFhirString, FName.Link));
  oList.add(TFHIRProperty.create(self, 'comment', 'string', false, TFhirString, FComment.Link));
  oList.add(TFHIRProperty.create(self, 'extraDetails', 'markdown', false, TFhirMarkdown, FExtraDetails.Link));
  oList.add(TFHIRProperty.create(self, 'photo', 'Attachment', false, TFhirAttachment, FPhoto.Link));
  oList.add(TFHIRProperty.create(self, 'contact', 'ExtendedContactDetail', true, TFhirExtendedContactDetail, FContactList.Link));
  oList.add(TFHIRProperty.create(self, 'coverageArea', 'Reference', true, TFhirReference, FCoverageAreaList.Link));
  oList.add(TFHIRProperty.create(self, 'serviceProvisionCode', 'CodeableConcept', true, TFhirCodeableConcept, FServiceProvisionCodeList.Link));
  oList.add(TFHIRProperty.create(self, 'eligibility', 'BackboneElement', true, TFhirHealthcareServiceEligibility, FEligibilityList.Link));
  oList.add(TFHIRProperty.create(self, 'program', 'CodeableConcept', true, TFhirCodeableConcept, FProgram_List.Link));
  oList.add(TFHIRProperty.create(self, 'characteristic', 'CodeableConcept', true, TFhirCodeableConcept, FCharacteristicList.Link));
  oList.add(TFHIRProperty.create(self, 'communication', 'CodeableConcept', true, TFhirCodeableConcept, FCommunicationList.Link));
  oList.add(TFHIRProperty.create(self, 'referralMethod', 'CodeableConcept', true, TFhirCodeableConcept, FReferralMethodList.Link));
  oList.add(TFHIRProperty.create(self, 'appointmentRequired', 'boolean', false, TFhirBoolean, FAppointmentRequired.Link));
  oList.add(TFHIRProperty.create(self, 'availability', 'Availability', true, TFhirAvailability, FAvailabilityList.Link));
  oList.add(TFHIRProperty.create(self, 'endpoint', 'Reference', true, TFhirReference, FEndpointList.Link));
end;

function TFhirHealthcareService.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'identifier') then
  begin
    IdentifierList.add(propValue as TFhirIdentifier);
    result := propValue;
  end
  else if (propName = 'active') then
  begin
    ActiveElement := asBoolean(propValue);
    result := propValue;
  end
  else if (propName = 'providedBy') then
  begin
    ProvidedBy := propValue as TFhirReference;
    result := propValue;
  end
  else if (propName = 'offeredIn') then
  begin
    OfferedInList.add(propValue as TFhirReference);
    result := propValue;
  end
  else if (propName = 'category') then
  begin
    CategoryList.add(propValue as TFhirCodeableConcept);
    result := propValue;
  end
  else if (propName = 'type') then
  begin
    Type_List.add(propValue as TFhirCodeableConcept);
    result := propValue;
  end
  else if (propName = 'specialty') then
  begin
    SpecialtyList.add(propValue as TFhirCodeableConcept);
    result := propValue;
  end
  else if (propName = 'location') then
  begin
    LocationList.add(propValue as TFhirReference);
    result := propValue;
  end
  else if (propName = 'name') then
  begin
    NameElement := asString(propValue);
    result := propValue;
  end
  else if (propName = 'comment') then
  begin
    CommentElement := asString(propValue);
    result := propValue;
  end
  else if (propName = 'extraDetails') then
  begin
    ExtraDetailsElement := asMarkdown(propValue);
    result := propValue;
  end
  else if (propName = 'photo') then
  begin
    Photo := propValue as TFhirAttachment;
    result := propValue;
  end
  else if (propName = 'contact') then
  begin
    ContactList.add(propValue as TFhirExtendedContactDetail);
    result := propValue;
  end
  else if (propName = 'coverageArea') then
  begin
    CoverageAreaList.add(propValue as TFhirReference);
    result := propValue;
  end
  else if (propName = 'serviceProvisionCode') then
  begin
    ServiceProvisionCodeList.add(propValue as TFhirCodeableConcept);
    result := propValue;
  end
  else if (propName = 'eligibility') then
  begin
    EligibilityList.add(propValue as TFhirHealthcareServiceEligibility);
    result := propValue;
  end
  else if (propName = 'program') then
  begin
    Program_List.add(propValue as TFhirCodeableConcept);
    result := propValue;
  end
  else if (propName = 'characteristic') then
  begin
    CharacteristicList.add(propValue as TFhirCodeableConcept);
    result := propValue;
  end
  else if (propName = 'communication') then
  begin
    CommunicationList.add(propValue as TFhirCodeableConcept);
    result := propValue;
  end
  else if (propName = 'referralMethod') then
  begin
    ReferralMethodList.add(propValue as TFhirCodeableConcept);
    result := propValue;
  end
  else if (propName = 'appointmentRequired') then
  begin
    AppointmentRequiredElement := asBoolean(propValue);
    result := propValue;
  end
  else if (propName = 'availability') then
  begin
    AvailabilityList.add(propValue as TFhirAvailability);
    result := propValue;
  end
  else if (propName = 'endpoint') then
  begin
    EndpointList.add(propValue as TFhirReference);
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirHealthcareService.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'identifier') then IdentifierList.insertItem(index, propValue as TFhirIdentifier)
  else if (propName = 'offeredIn') then OfferedInList.insertItem(index, propValue as TFhirReference)
  else if (propName = 'category') then CategoryList.insertItem(index, propValue as TFhirCodeableConcept)
  else if (propName = 'type') then Type_List.insertItem(index, propValue as TFhirCodeableConcept)
  else if (propName = 'specialty') then SpecialtyList.insertItem(index, propValue as TFhirCodeableConcept)
  else if (propName = 'location') then LocationList.insertItem(index, propValue as TFhirReference)
  else if (propName = 'contact') then ContactList.insertItem(index, propValue as TFhirExtendedContactDetail)
  else if (propName = 'coverageArea') then CoverageAreaList.insertItem(index, propValue as TFhirReference)
  else if (propName = 'serviceProvisionCode') then ServiceProvisionCodeList.insertItem(index, propValue as TFhirCodeableConcept)
  else if (propName = 'eligibility') then EligibilityList.insertItem(index, propValue as TFhirHealthcareServiceEligibility)
  else if (propName = 'program') then Program_List.insertItem(index, propValue as TFhirCodeableConcept)
  else if (propName = 'characteristic') then CharacteristicList.insertItem(index, propValue as TFhirCodeableConcept)
  else if (propName = 'communication') then CommunicationList.insertItem(index, propValue as TFhirCodeableConcept)
  else if (propName = 'referralMethod') then ReferralMethodList.insertItem(index, propValue as TFhirCodeableConcept)
  else if (propName = 'availability') then AvailabilityList.insertItem(index, propValue as TFhirAvailability)
  else if (propName = 'endpoint') then EndpointList.insertItem(index, propValue as TFhirReference)
  else inherited;
end;

function TFhirHealthcareService.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'identifier') then result := IdentifierList.new()
  else if (propName = 'active') then result := TFhirBoolean.create()
  else if (propName = 'providedBy') then result := TFhirReference.create()
  else if (propName = 'offeredIn') then result := OfferedInList.new()
  else if (propName = 'category') then result := CategoryList.new()
  else if (propName = 'type') then result := Type_List.new()
  else if (propName = 'specialty') then result := SpecialtyList.new()
  else if (propName = 'location') then result := LocationList.new()
  else if (propName = 'name') then result := TFhirString.create()
  else if (propName = 'comment') then result := TFhirString.create()
  else if (propName = 'extraDetails') then result := TFhirMarkdown.create()
  else if (propName = 'photo') then result := TFhirAttachment.create()
  else if (propName = 'contact') then result := ContactList.new()
  else if (propName = 'coverageArea') then result := CoverageAreaList.new()
  else if (propName = 'serviceProvisionCode') then result := ServiceProvisionCodeList.new()
  else if (propName = 'eligibility') then result := EligibilityList.new()
  else if (propName = 'program') then result := Program_List.new()
  else if (propName = 'characteristic') then result := CharacteristicList.new()
  else if (propName = 'communication') then result := CommunicationList.new()
  else if (propName = 'referralMethod') then result := ReferralMethodList.new()
  else if (propName = 'appointmentRequired') then result := TFhirBoolean.create()
  else if (propName = 'availability') then result := AvailabilityList.new()
  else if (propName = 'endpoint') then result := EndpointList.new()
  else result := inherited createPropertyValue(propName);
end;

function TFhirHealthcareService.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'identifier') then result := 'Identifier'
  else if (propName = 'active') then result := 'boolean'
  else if (propName = 'providedBy') then result := 'Reference'
  else if (propName = 'offeredIn') then result := 'Reference'
  else if (propName = 'category') then result := 'CodeableConcept'
  else if (propName = 'type') then result := 'CodeableConcept'
  else if (propName = 'specialty') then result := 'CodeableConcept'
  else if (propName = 'location') then result := 'Reference'
  else if (propName = 'name') then result := 'string'
  else if (propName = 'comment') then result := 'string'
  else if (propName = 'extraDetails') then result := 'markdown'
  else if (propName = 'photo') then result := 'Attachment'
  else if (propName = 'contact') then result := 'ExtendedContactDetail'
  else if (propName = 'coverageArea') then result := 'Reference'
  else if (propName = 'serviceProvisionCode') then result := 'CodeableConcept'
  else if (propName = 'eligibility') then result := 'BackboneElement'
  else if (propName = 'program') then result := 'CodeableConcept'
  else if (propName = 'characteristic') then result := 'CodeableConcept'
  else if (propName = 'communication') then result := 'CodeableConcept'
  else if (propName = 'referralMethod') then result := 'CodeableConcept'
  else if (propName = 'appointmentRequired') then result := 'boolean'
  else if (propName = 'availability') then result := 'Availability'
  else if (propName = 'endpoint') then result := 'Reference'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirHealthcareService.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'identifier') then deletePropertyValue('identifier', IdentifierList, value)
  else if (propName = 'active') then ActiveElement := nil
  else if (propName = 'providedBy') then ProvidedByElement := nil
  else if (propName = 'offeredIn') then deletePropertyValue('offeredIn', OfferedInList, value)
  else if (propName = 'category') then deletePropertyValue('category', CategoryList, value)
  else if (propName = 'type') then deletePropertyValue('type', Type_List, value)
  else if (propName = 'specialty') then deletePropertyValue('specialty', SpecialtyList, value)
  else if (propName = 'location') then deletePropertyValue('location', LocationList, value)
  else if (propName = 'name') then NameElement := nil
  else if (propName = 'comment') then CommentElement := nil
  else if (propName = 'extraDetails') then ExtraDetailsElement := nil
  else if (propName = 'photo') then PhotoElement := nil
  else if (propName = 'contact') then deletePropertyValue('contact', ContactList, value)
  else if (propName = 'coverageArea') then deletePropertyValue('coverageArea', CoverageAreaList, value)
  else if (propName = 'serviceProvisionCode') then deletePropertyValue('serviceProvisionCode', ServiceProvisionCodeList, value)
  else if (propName = 'eligibility') then deletePropertyValue('eligibility', EligibilityList, value)
  else if (propName = 'program') then deletePropertyValue('program', Program_List, value)
  else if (propName = 'characteristic') then deletePropertyValue('characteristic', CharacteristicList, value)
  else if (propName = 'communication') then deletePropertyValue('communication', CommunicationList, value)
  else if (propName = 'referralMethod') then deletePropertyValue('referralMethod', ReferralMethodList, value)
  else if (propName = 'appointmentRequired') then AppointmentRequiredElement := nil
  else if (propName = 'availability') then deletePropertyValue('availability', AvailabilityList, value)
  else if (propName = 'endpoint') then deletePropertyValue('endpoint', EndpointList, value)
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirHealthcareService.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'identifier') then replacePropertyValue('identifier', IdentifierList, existing, new)
  else if (propName = 'active') then ActiveElement := asBoolean(new)
  else if (propName = 'providedBy') then ProvidedByElement := new as TFhirReference
  else if (propName = 'offeredIn') then replacePropertyValue('offeredIn', OfferedInList, existing, new)
  else if (propName = 'category') then replacePropertyValue('category', CategoryList, existing, new)
  else if (propName = 'type') then replacePropertyValue('type', Type_List, existing, new)
  else if (propName = 'specialty') then replacePropertyValue('specialty', SpecialtyList, existing, new)
  else if (propName = 'location') then replacePropertyValue('location', LocationList, existing, new)
  else if (propName = 'name') then NameElement := asString(new)
  else if (propName = 'comment') then CommentElement := asString(new)
  else if (propName = 'extraDetails') then ExtraDetailsElement := asMarkdown(new)
  else if (propName = 'photo') then PhotoElement := new as TFhirAttachment
  else if (propName = 'contact') then replacePropertyValue('contact', ContactList, existing, new)
  else if (propName = 'coverageArea') then replacePropertyValue('coverageArea', CoverageAreaList, existing, new)
  else if (propName = 'serviceProvisionCode') then replacePropertyValue('serviceProvisionCode', ServiceProvisionCodeList, existing, new)
  else if (propName = 'eligibility') then replacePropertyValue('eligibility', EligibilityList, existing, new)
  else if (propName = 'program') then replacePropertyValue('program', Program_List, existing, new)
  else if (propName = 'characteristic') then replacePropertyValue('characteristic', CharacteristicList, existing, new)
  else if (propName = 'communication') then replacePropertyValue('communication', CommunicationList, existing, new)
  else if (propName = 'referralMethod') then replacePropertyValue('referralMethod', ReferralMethodList, existing, new)
  else if (propName = 'appointmentRequired') then AppointmentRequiredElement := asBoolean(new)
  else if (propName = 'availability') then replacePropertyValue('availability', AvailabilityList, existing, new)
  else if (propName = 'endpoint') then replacePropertyValue('endpoint', EndpointList, existing, new)
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirHealthcareService.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'identifier') then IdentifierList.move(source, destination)
  else if (propName = 'offeredIn') then OfferedInList.move(source, destination)
  else if (propName = 'category') then CategoryList.move(source, destination)
  else if (propName = 'type') then Type_List.move(source, destination)
  else if (propName = 'specialty') then SpecialtyList.move(source, destination)
  else if (propName = 'location') then LocationList.move(source, destination)
  else if (propName = 'contact') then ContactList.move(source, destination)
  else if (propName = 'coverageArea') then CoverageAreaList.move(source, destination)
  else if (propName = 'serviceProvisionCode') then ServiceProvisionCodeList.move(source, destination)
  else if (propName = 'eligibility') then EligibilityList.move(source, destination)
  else if (propName = 'program') then Program_List.move(source, destination)
  else if (propName = 'characteristic') then CharacteristicList.move(source, destination)
  else if (propName = 'communication') then CommunicationList.move(source, destination)
  else if (propName = 'referralMethod') then ReferralMethodList.move(source, destination)
  else if (propName = 'availability') then AvailabilityList.move(source, destination)
  else if (propName = 'endpoint') then EndpointList.move(source, destination)
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirHealthcareService.fhirType : string;
begin
  result := 'HealthcareService';
end;

function TFhirHealthcareService.Link : TFhirHealthcareService;
begin
  result := TFhirHealthcareService(inherited Link);
end;

function TFhirHealthcareService.Clone : TFhirHealthcareService;
begin
  result := TFhirHealthcareService(inherited Clone);
end;

function TFhirHealthcareService.equals(other : TObject) : boolean; 
var
  o : TFhirHealthcareService;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirHealthcareService)) then
    result := false
  else
  begin
    o := TFhirHealthcareService(other);
    result := compareDeep(identifierList, o.identifierList, true) and compareDeep(activeElement, o.activeElement, true) and 
      compareDeep(providedByElement, o.providedByElement, true) and compareDeep(offeredInList, o.offeredInList, true) and 
      compareDeep(categoryList, o.categoryList, true) and compareDeep(type_List, o.type_List, true) and 
      compareDeep(specialtyList, o.specialtyList, true) and compareDeep(locationList, o.locationList, true) and 
      compareDeep(nameElement, o.nameElement, true) and compareDeep(commentElement, o.commentElement, true) and 
      compareDeep(extraDetailsElement, o.extraDetailsElement, true) and compareDeep(photoElement, o.photoElement, true) and 
      compareDeep(contactList, o.contactList, true) and compareDeep(coverageAreaList, o.coverageAreaList, true) and 
      compareDeep(serviceProvisionCodeList, o.serviceProvisionCodeList, true) and compareDeep(eligibilityList, o.eligibilityList, true) and 
      compareDeep(program_List, o.program_List, true) and compareDeep(characteristicList, o.characteristicList, true) and 
      compareDeep(communicationList, o.communicationList, true) and compareDeep(referralMethodList, o.referralMethodList, true) and 
      compareDeep(appointmentRequiredElement, o.appointmentRequiredElement, true) and 
      compareDeep(availabilityList, o.availabilityList, true) and compareDeep(endpointList, o.endpointList, true);
  end;
end;

function TFhirHealthcareService.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FidentifierList) and isEmptyProp(FActive) and isEmptyProp(FProvidedBy) and isEmptyProp(FofferedInList) and isEmptyProp(FcategoryList) and isEmptyProp(Ftype_List) and isEmptyProp(FspecialtyList) and isEmptyProp(FlocationList) and isEmptyProp(FName) and isEmptyProp(FComment) and isEmptyProp(FExtraDetails) and isEmptyProp(FPhoto) and isEmptyProp(FcontactList) and isEmptyProp(FcoverageAreaList) and isEmptyProp(FserviceProvisionCodeList) and isEmptyProp(FeligibilityList) and isEmptyProp(Fprogram_List) and isEmptyProp(FcharacteristicList) and isEmptyProp(FcommunicationList) and isEmptyProp(FreferralMethodList) and isEmptyProp(FAppointmentRequired) and isEmptyProp(FavailabilityList) and isEmptyProp(FendpointList);
end;

procedure TFhirHealthcareService.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('identifier');
  fields.add('active');
  fields.add('providedBy');
  fields.add('offeredIn');
  fields.add('category');
  fields.add('type');
  fields.add('specialty');
  fields.add('location');
  fields.add('name');
  fields.add('comment');
  fields.add('extraDetails');
  fields.add('photo');
  fields.add('contact');
  fields.add('coverageArea');
  fields.add('serviceProvisionCode');
  fields.add('eligibility');
  fields.add('program');
  fields.add('characteristic');
  fields.add('communication');
  fields.add('referralMethod');
  fields.add('appointmentRequired');
  fields.add('availability');
  fields.add('endpoint');
end;

function TFhirHealthcareService.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
  inc(result, FIdentifierList.sizeInBytes(magic));
  inc(result, FOfferedInList.sizeInBytes(magic));
  inc(result, FCategoryList.sizeInBytes(magic));
  inc(result, FType_List.sizeInBytes(magic));
  inc(result, FSpecialtyList.sizeInBytes(magic));
  inc(result, FLocationList.sizeInBytes(magic));
  inc(result, FContactList.sizeInBytes(magic));
  inc(result, FCoverageAreaList.sizeInBytes(magic));
  inc(result, FServiceProvisionCodeList.sizeInBytes(magic));
  inc(result, FEligibilityList.sizeInBytes(magic));
  inc(result, FProgram_List.sizeInBytes(magic));
  inc(result, FCharacteristicList.sizeInBytes(magic));
  inc(result, FCommunicationList.sizeInBytes(magic));
  inc(result, FReferralMethodList.sizeInBytes(magic));
  inc(result, FAvailabilityList.sizeInBytes(magic));
  inc(result, FEndpointList.sizeInBytes(magic));
end;

function TFhirHealthcareService.GetIdentifierList : TFhirIdentifierList;
begin
  if FIdentifierList = nil then
    FIdentifierList := TFhirIdentifierList.Create;
  result := FIdentifierList;
end;

function TFhirHealthcareService.GetHasIdentifierList : boolean;
begin
  result := (FIdentifierList <> nil) and (FIdentifierList.count > 0);
end;

procedure TFhirHealthcareService.SetActive(value : TFhirBoolean);
begin
  FActive.free;
  FActive := value;
end;

function TFhirHealthcareService.GetActiveST : Boolean;
begin
  if FActive = nil then
    result := false
  else
    result := FActive.value;
end;

procedure TFhirHealthcareService.SetActiveST(value : Boolean);
begin
  if FActive = nil then
    FActive := TFhirBoolean.create;
  FActive.value := value
end;

procedure TFhirHealthcareService.SetProvidedBy(value : TFhirReference);
begin
  FProvidedBy.free;
  FProvidedBy := value;
end;

function TFhirHealthcareService.GetOfferedInList : TFhirReferenceList;
begin
  if FOfferedInList = nil then
    FOfferedInList := TFhirReferenceList.Create;
  result := FOfferedInList;
end;

function TFhirHealthcareService.GetHasOfferedInList : boolean;
begin
  result := (FOfferedInList <> nil) and (FOfferedInList.count > 0);
end;

function TFhirHealthcareService.GetCategoryList : TFhirCodeableConceptList;
begin
  if FCategoryList = nil then
    FCategoryList := TFhirCodeableConceptList.Create;
  result := FCategoryList;
end;

function TFhirHealthcareService.GetHasCategoryList : boolean;
begin
  result := (FCategoryList <> nil) and (FCategoryList.count > 0);
end;

function TFhirHealthcareService.GetType_List : TFhirCodeableConceptList;
begin
  if FType_List = nil then
    FType_List := TFhirCodeableConceptList.Create;
  result := FType_List;
end;

function TFhirHealthcareService.GetHasType_List : boolean;
begin
  result := (FType_List <> nil) and (FType_List.count > 0);
end;

function TFhirHealthcareService.GetSpecialtyList : TFhirCodeableConceptList;
begin
  if FSpecialtyList = nil then
    FSpecialtyList := TFhirCodeableConceptList.Create;
  result := FSpecialtyList;
end;

function TFhirHealthcareService.GetHasSpecialtyList : boolean;
begin
  result := (FSpecialtyList <> nil) and (FSpecialtyList.count > 0);
end;

function TFhirHealthcareService.GetLocationList : TFhirReferenceList;
begin
  if FLocationList = nil then
    FLocationList := TFhirReferenceList.Create;
  result := FLocationList;
end;

function TFhirHealthcareService.GetHasLocationList : boolean;
begin
  result := (FLocationList <> nil) and (FLocationList.count > 0);
end;

procedure TFhirHealthcareService.SetName(value : TFhirString);
begin
  FName.free;
  FName := value;
end;

function TFhirHealthcareService.GetNameST : String;
begin
  if FName = nil then
    result := ''
  else
    result := FName.value;
end;

procedure TFhirHealthcareService.SetNameST(value : String);
begin
  if value <> '' then
  begin
    if FName = nil then
      FName := TFhirString.create;
    FName.value := value
  end
  else if FName <> nil then
    FName.value := '';
end;

procedure TFhirHealthcareService.SetComment(value : TFhirString);
begin
  FComment.free;
  FComment := value;
end;

function TFhirHealthcareService.GetCommentST : String;
begin
  if FComment = nil then
    result := ''
  else
    result := FComment.value;
end;

procedure TFhirHealthcareService.SetCommentST(value : String);
begin
  if value <> '' then
  begin
    if FComment = nil then
      FComment := TFhirString.create;
    FComment.value := value
  end
  else if FComment <> nil then
    FComment.value := '';
end;

procedure TFhirHealthcareService.SetExtraDetails(value : TFhirMarkdown);
begin
  FExtraDetails.free;
  FExtraDetails := value;
end;

function TFhirHealthcareService.GetExtraDetailsST : String;
begin
  if FExtraDetails = nil then
    result := ''
  else
    result := FExtraDetails.value;
end;

procedure TFhirHealthcareService.SetExtraDetailsST(value : String);
begin
  if value <> '' then
  begin
    if FExtraDetails = nil then
      FExtraDetails := TFhirMarkdown.create;
    FExtraDetails.value := value
  end
  else if FExtraDetails <> nil then
    FExtraDetails.value := '';
end;

procedure TFhirHealthcareService.SetPhoto(value : TFhirAttachment);
begin
  FPhoto.free;
  FPhoto := value;
end;

function TFhirHealthcareService.GetContactList : TFhirExtendedContactDetailList;
begin
  if FContactList = nil then
    FContactList := TFhirExtendedContactDetailList.Create;
  result := FContactList;
end;

function TFhirHealthcareService.GetHasContactList : boolean;
begin
  result := (FContactList <> nil) and (FContactList.count > 0);
end;

function TFhirHealthcareService.GetCoverageAreaList : TFhirReferenceList;
begin
  if FCoverageAreaList = nil then
    FCoverageAreaList := TFhirReferenceList.Create;
  result := FCoverageAreaList;
end;

function TFhirHealthcareService.GetHasCoverageAreaList : boolean;
begin
  result := (FCoverageAreaList <> nil) and (FCoverageAreaList.count > 0);
end;

function TFhirHealthcareService.GetServiceProvisionCodeList : TFhirCodeableConceptList;
begin
  if FServiceProvisionCodeList = nil then
    FServiceProvisionCodeList := TFhirCodeableConceptList.Create;
  result := FServiceProvisionCodeList;
end;

function TFhirHealthcareService.GetHasServiceProvisionCodeList : boolean;
begin
  result := (FServiceProvisionCodeList <> nil) and (FServiceProvisionCodeList.count > 0);
end;

function TFhirHealthcareService.GetEligibilityList : TFhirHealthcareServiceEligibilityList;
begin
  if FEligibilityList = nil then
    FEligibilityList := TFhirHealthcareServiceEligibilityList.Create;
  result := FEligibilityList;
end;

function TFhirHealthcareService.GetHasEligibilityList : boolean;
begin
  result := (FEligibilityList <> nil) and (FEligibilityList.count > 0);
end;

function TFhirHealthcareService.GetProgram_List : TFhirCodeableConceptList;
begin
  if FProgram_List = nil then
    FProgram_List := TFhirCodeableConceptList.Create;
  result := FProgram_List;
end;

function TFhirHealthcareService.GetHasProgram_List : boolean;
begin
  result := (FProgram_List <> nil) and (FProgram_List.count > 0);
end;

function TFhirHealthcareService.GetCharacteristicList : TFhirCodeableConceptList;
begin
  if FCharacteristicList = nil then
    FCharacteristicList := TFhirCodeableConceptList.Create;
  result := FCharacteristicList;
end;

function TFhirHealthcareService.GetHasCharacteristicList : boolean;
begin
  result := (FCharacteristicList <> nil) and (FCharacteristicList.count > 0);
end;

function TFhirHealthcareService.GetCommunicationList : TFhirCodeableConceptList;
begin
  if FCommunicationList = nil then
    FCommunicationList := TFhirCodeableConceptList.Create;
  result := FCommunicationList;
end;

function TFhirHealthcareService.GetHasCommunicationList : boolean;
begin
  result := (FCommunicationList <> nil) and (FCommunicationList.count > 0);
end;

function TFhirHealthcareService.GetReferralMethodList : TFhirCodeableConceptList;
begin
  if FReferralMethodList = nil then
    FReferralMethodList := TFhirCodeableConceptList.Create;
  result := FReferralMethodList;
end;

function TFhirHealthcareService.GetHasReferralMethodList : boolean;
begin
  result := (FReferralMethodList <> nil) and (FReferralMethodList.count > 0);
end;

procedure TFhirHealthcareService.SetAppointmentRequired(value : TFhirBoolean);
begin
  FAppointmentRequired.free;
  FAppointmentRequired := value;
end;

function TFhirHealthcareService.GetAppointmentRequiredST : Boolean;
begin
  if FAppointmentRequired = nil then
    result := false
  else
    result := FAppointmentRequired.value;
end;

procedure TFhirHealthcareService.SetAppointmentRequiredST(value : Boolean);
begin
  if FAppointmentRequired = nil then
    FAppointmentRequired := TFhirBoolean.create;
  FAppointmentRequired.value := value
end;

function TFhirHealthcareService.GetAvailabilityList : TFhirAvailabilityList;
begin
  if FAvailabilityList = nil then
    FAvailabilityList := TFhirAvailabilityList.Create;
  result := FAvailabilityList;
end;

function TFhirHealthcareService.GetHasAvailabilityList : boolean;
begin
  result := (FAvailabilityList <> nil) and (FAvailabilityList.count > 0);
end;

function TFhirHealthcareService.GetEndpointList : TFhirReferenceList;
begin
  if FEndpointList = nil then
    FEndpointList := TFhirReferenceList.Create;
  result := FEndpointList;
end;

function TFhirHealthcareService.GetHasEndpointList : boolean;
begin
  result := (FEndpointList <> nil) and (FEndpointList.count > 0);
end;

{ TFhirHealthcareServiceListEnumerator }

constructor TFhirHealthcareServiceListEnumerator.Create(list : TFhirHealthcareServiceList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirHealthcareServiceListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirHealthcareServiceListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirHealthcareServiceListEnumerator.GetCurrent : TFhirHealthcareService;
begin
  Result := FList[FIndex];
end;

function TFhirHealthcareServiceListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirHealthcareServiceList }

function TFhirHealthcareServiceList.AddItem(value: TFhirHealthcareService): TFhirHealthcareService;
begin
  assert(value.ClassName = 'TFhirHealthcareService', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirHealthcareService');
  add(value);
  result := value;
end;

function TFhirHealthcareServiceList.Append: TFhirHealthcareService;
begin
  result := TFhirHealthcareService.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirHealthcareServiceList.ClearItems;
begin
  Clear;
end;

function TFhirHealthcareServiceList.GetEnumerator : TFhirHealthcareServiceListEnumerator;
begin
  result := TFhirHealthcareServiceListEnumerator.Create(self.link);
end;

function TFhirHealthcareServiceList.Clone: TFhirHealthcareServiceList;
begin
  result := TFhirHealthcareServiceList(inherited Clone);
end;

function TFhirHealthcareServiceList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirHealthcareServiceList.GetItemN(index: Integer): TFhirHealthcareService;
begin
  result := TFhirHealthcareService(ObjectByIndex[index]);
end;

function TFhirHealthcareServiceList.ItemClass: TFslObjectClass;
begin
  result := TFhirHealthcareService;
end;
function TFhirHealthcareServiceList.IndexOf(value: TFhirHealthcareService): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirHealthcareServiceList.Insert(index: Integer): TFhirHealthcareService;
begin
  result := TFhirHealthcareService.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirHealthcareServiceList.InsertItem(index: Integer; value: TFhirHealthcareService);
begin
  assert(value is TFhirHealthcareService);
  Inherited Insert(index, value);
end;

function TFhirHealthcareServiceList.Item(index: Integer): TFhirHealthcareService;
begin
  result := TFhirHealthcareService(ObjectByIndex[index]);
end;

function TFhirHealthcareServiceList.Link: TFhirHealthcareServiceList;
begin
  result := TFhirHealthcareServiceList(inherited Link);
end;

procedure TFhirHealthcareServiceList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirHealthcareServiceList.SetItemByIndex(index: Integer; value: TFhirHealthcareService);
begin
  assert(value is TFhirHealthcareService);
  FhirHealthcareServices[index] := value;
end;

procedure TFhirHealthcareServiceList.SetItemN(index: Integer; value: TFhirHealthcareService);
begin
  assert(value is TFhirHealthcareService);
  ObjectByIndex[index] := value;
end;

{$ENDIF FHIR_HEALTHCARESERVICE}
{$IFDEF FHIR_LOCATION}
{ TFhirLocationPosition }

constructor TFhirLocationPosition.Create;
begin
  inherited;
end;

destructor TFhirLocationPosition.Destroy;
begin
  FLongitude.free;
  FLatitude.free;
  FAltitude.free;
  inherited;
end;

procedure TFhirLocationPosition.Assign(oSource : TFslObject);
begin
  inherited;
  longitudeElement := TFhirLocationPosition(oSource).longitudeElement.Clone;
  latitudeElement := TFhirLocationPosition(oSource).latitudeElement.Clone;
  altitudeElement := TFhirLocationPosition(oSource).altitudeElement.Clone;
end;

procedure TFhirLocationPosition.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'longitude') Then
     list.add(self.link, 'longitude', FLongitude.Link);
  if (child_name = 'latitude') Then
     list.add(self.link, 'latitude', FLatitude.Link);
  if (child_name = 'altitude') Then
     list.add(self.link, 'altitude', FAltitude.Link);
end;

procedure TFhirLocationPosition.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'longitude', 'decimal', false, TFhirDecimal, FLongitude.Link));
  oList.add(TFHIRProperty.create(self, 'latitude', 'decimal', false, TFhirDecimal, FLatitude.Link));
  oList.add(TFHIRProperty.create(self, 'altitude', 'decimal', false, TFhirDecimal, FAltitude.Link));
end;

function TFhirLocationPosition.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'longitude') then
  begin
    LongitudeElement := asDecimal(propValue);
    result := propValue;
  end
  else if (propName = 'latitude') then
  begin
    LatitudeElement := asDecimal(propValue);
    result := propValue;
  end
  else if (propName = 'altitude') then
  begin
    AltitudeElement := asDecimal(propValue);
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirLocationPosition.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirLocationPosition.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'longitude') then result := TFhirDecimal.create()
  else if (propName = 'latitude') then result := TFhirDecimal.create()
  else if (propName = 'altitude') then result := TFhirDecimal.create()
  else result := inherited createPropertyValue(propName);
end;

function TFhirLocationPosition.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'longitude') then result := 'decimal'
  else if (propName = 'latitude') then result := 'decimal'
  else if (propName = 'altitude') then result := 'decimal'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirLocationPosition.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'longitude') then LongitudeElement := nil
  else if (propName = 'latitude') then LatitudeElement := nil
  else if (propName = 'altitude') then AltitudeElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirLocationPosition.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'longitude') then LongitudeElement := asDecimal(new)
  else if (propName = 'latitude') then LatitudeElement := asDecimal(new)
  else if (propName = 'altitude') then AltitudeElement := asDecimal(new)
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirLocationPosition.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirLocationPosition.fhirType : string;
begin
  result := 'Location.position';
end;

function TFhirLocationPosition.Link : TFhirLocationPosition;
begin
  result := TFhirLocationPosition(inherited Link);
end;

function TFhirLocationPosition.Clone : TFhirLocationPosition;
begin
  result := TFhirLocationPosition(inherited Clone);
end;

function TFhirLocationPosition.equals(other : TObject) : boolean; 
var
  o : TFhirLocationPosition;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirLocationPosition)) then
    result := false
  else
  begin
    o := TFhirLocationPosition(other);
    result := compareDeep(longitudeElement, o.longitudeElement, true) and compareDeep(latitudeElement, o.latitudeElement, true) and 
      compareDeep(altitudeElement, o.altitudeElement, true);
  end;
end;

function TFhirLocationPosition.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FLongitude) and isEmptyProp(FLatitude) and isEmptyProp(FAltitude);
end;

procedure TFhirLocationPosition.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('longitude');
  fields.add('latitude');
  fields.add('altitude');
end;

function TFhirLocationPosition.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
end;

procedure TFhirLocationPosition.SetLongitude(value : TFhirDecimal);
begin
  FLongitude.free;
  FLongitude := value;
end;

function TFhirLocationPosition.GetLongitudeST : String;
begin
  if FLongitude = nil then
    result := ''
  else
    result := FLongitude.value;
end;

procedure TFhirLocationPosition.SetLongitudeST(value : String);
begin
  if value <> '' then
  begin
    if FLongitude = nil then
      FLongitude := TFhirDecimal.create;
    FLongitude.value := value
  end
  else if FLongitude <> nil then
    FLongitude.value := '';
end;

procedure TFhirLocationPosition.SetLatitude(value : TFhirDecimal);
begin
  FLatitude.free;
  FLatitude := value;
end;

function TFhirLocationPosition.GetLatitudeST : String;
begin
  if FLatitude = nil then
    result := ''
  else
    result := FLatitude.value;
end;

procedure TFhirLocationPosition.SetLatitudeST(value : String);
begin
  if value <> '' then
  begin
    if FLatitude = nil then
      FLatitude := TFhirDecimal.create;
    FLatitude.value := value
  end
  else if FLatitude <> nil then
    FLatitude.value := '';
end;

procedure TFhirLocationPosition.SetAltitude(value : TFhirDecimal);
begin
  FAltitude.free;
  FAltitude := value;
end;

function TFhirLocationPosition.GetAltitudeST : String;
begin
  if FAltitude = nil then
    result := ''
  else
    result := FAltitude.value;
end;

procedure TFhirLocationPosition.SetAltitudeST(value : String);
begin
  if value <> '' then
  begin
    if FAltitude = nil then
      FAltitude := TFhirDecimal.create;
    FAltitude.value := value
  end
  else if FAltitude <> nil then
    FAltitude.value := '';
end;

{ TFhirLocationPositionListEnumerator }

constructor TFhirLocationPositionListEnumerator.Create(list : TFhirLocationPositionList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirLocationPositionListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirLocationPositionListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirLocationPositionListEnumerator.GetCurrent : TFhirLocationPosition;
begin
  Result := FList[FIndex];
end;

function TFhirLocationPositionListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirLocationPositionList }

function TFhirLocationPositionList.AddItem(value: TFhirLocationPosition): TFhirLocationPosition;
begin
  assert(value.ClassName = 'TFhirLocationPosition', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirLocationPosition');
  add(value);
  result := value;
end;

function TFhirLocationPositionList.Append: TFhirLocationPosition;
begin
  result := TFhirLocationPosition.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirLocationPositionList.ClearItems;
begin
  Clear;
end;

function TFhirLocationPositionList.GetEnumerator : TFhirLocationPositionListEnumerator;
begin
  result := TFhirLocationPositionListEnumerator.Create(self.link);
end;

function TFhirLocationPositionList.Clone: TFhirLocationPositionList;
begin
  result := TFhirLocationPositionList(inherited Clone);
end;

function TFhirLocationPositionList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirLocationPositionList.GetItemN(index: Integer): TFhirLocationPosition;
begin
  result := TFhirLocationPosition(ObjectByIndex[index]);
end;

function TFhirLocationPositionList.ItemClass: TFslObjectClass;
begin
  result := TFhirLocationPosition;
end;
function TFhirLocationPositionList.IndexOf(value: TFhirLocationPosition): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirLocationPositionList.Insert(index: Integer): TFhirLocationPosition;
begin
  result := TFhirLocationPosition.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirLocationPositionList.InsertItem(index: Integer; value: TFhirLocationPosition);
begin
  assert(value is TFhirLocationPosition);
  Inherited Insert(index, value);
end;

function TFhirLocationPositionList.Item(index: Integer): TFhirLocationPosition;
begin
  result := TFhirLocationPosition(ObjectByIndex[index]);
end;

function TFhirLocationPositionList.Link: TFhirLocationPositionList;
begin
  result := TFhirLocationPositionList(inherited Link);
end;

procedure TFhirLocationPositionList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirLocationPositionList.SetItemByIndex(index: Integer; value: TFhirLocationPosition);
begin
  assert(value is TFhirLocationPosition);
  FhirLocationPositions[index] := value;
end;

procedure TFhirLocationPositionList.SetItemN(index: Integer; value: TFhirLocationPosition);
begin
  assert(value is TFhirLocationPosition);
  ObjectByIndex[index] := value;
end;

{ TFhirLocation }

constructor TFhirLocation.Create;
begin
  inherited;
end;

destructor TFhirLocation.Destroy;
begin
  FIdentifierList.Free;
  FStatus.free;
  FOperationalStatus.free;
  FName.free;
  FAliasList.Free;
  FDescription.free;
  FMode.free;
  FType_List.Free;
  FContactList.Free;
  FAddress.free;
  FForm.free;
  FPosition.free;
  FManagingOrganization.free;
  FPartOf.free;
  FCharacteristicList.Free;
  FHoursOfOperationList.Free;
  FVirtualServiceList.Free;
  FEndpointList.Free;
  inherited;
end;

procedure TFhirLocation.Assign(oSource : TFslObject);
begin
  inherited;
  if (TFhirLocation(oSource).FIdentifierList = nil) then
  begin
    FIdentifierList.free;
    FIdentifierList := nil;
  end
  else
  begin
    if FIdentifierList = nil then
      FIdentifierList := TFhirIdentifierList.Create;
    FIdentifierList.Assign(TFhirLocation(oSource).FIdentifierList);
  end;
  statusElement := TFhirLocation(oSource).statusElement.Clone;
  operationalStatus := TFhirLocation(oSource).operationalStatus.Clone;
  nameElement := TFhirLocation(oSource).nameElement.Clone;
  if (TFhirLocation(oSource).FAliasList = nil) then
  begin
    FAliasList.free;
    FAliasList := nil;
  end
  else
  begin
    if FAliasList = nil then
      FAliasList := TFhirStringList.Create;
    FAliasList.Assign(TFhirLocation(oSource).FAliasList);
  end;
  descriptionElement := TFhirLocation(oSource).descriptionElement.Clone;
  modeElement := TFhirLocation(oSource).modeElement.Clone;
  if (TFhirLocation(oSource).FType_List = nil) then
  begin
    FType_List.free;
    FType_List := nil;
  end
  else
  begin
    if FType_List = nil then
      FType_List := TFhirCodeableConceptList.Create;
    FType_List.Assign(TFhirLocation(oSource).FType_List);
  end;
  if (TFhirLocation(oSource).FContactList = nil) then
  begin
    FContactList.free;
    FContactList := nil;
  end
  else
  begin
    if FContactList = nil then
      FContactList := TFhirExtendedContactDetailList.Create;
    FContactList.Assign(TFhirLocation(oSource).FContactList);
  end;
  address := TFhirLocation(oSource).address.Clone;
  form := TFhirLocation(oSource).form.Clone;
  position := TFhirLocation(oSource).position.Clone;
  managingOrganization := TFhirLocation(oSource).managingOrganization.Clone;
  partOf := TFhirLocation(oSource).partOf.Clone;
  if (TFhirLocation(oSource).FCharacteristicList = nil) then
  begin
    FCharacteristicList.free;
    FCharacteristicList := nil;
  end
  else
  begin
    if FCharacteristicList = nil then
      FCharacteristicList := TFhirCodeableConceptList.Create;
    FCharacteristicList.Assign(TFhirLocation(oSource).FCharacteristicList);
  end;
  if (TFhirLocation(oSource).FHoursOfOperationList = nil) then
  begin
    FHoursOfOperationList.free;
    FHoursOfOperationList := nil;
  end
  else
  begin
    if FHoursOfOperationList = nil then
      FHoursOfOperationList := TFhirAvailabilityList.Create;
    FHoursOfOperationList.Assign(TFhirLocation(oSource).FHoursOfOperationList);
  end;
  if (TFhirLocation(oSource).FVirtualServiceList = nil) then
  begin
    FVirtualServiceList.free;
    FVirtualServiceList := nil;
  end
  else
  begin
    if FVirtualServiceList = nil then
      FVirtualServiceList := TFhirVirtualServiceDetailList.Create;
    FVirtualServiceList.Assign(TFhirLocation(oSource).FVirtualServiceList);
  end;
  if (TFhirLocation(oSource).FEndpointList = nil) then
  begin
    FEndpointList.free;
    FEndpointList := nil;
  end
  else
  begin
    if FEndpointList = nil then
      FEndpointList := TFhirReferenceList.Create;
    FEndpointList.Assign(TFhirLocation(oSource).FEndpointList);
  end;
end;

function TFhirLocation.GetResourceType : TFhirResourceType;
begin
  result := frtLocation;
end;

procedure TFhirLocation.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'identifier') Then
    list.addAll(self, 'identifier', FIdentifierList);
  if (child_name = 'status') Then
     list.add(self.link, 'status', FStatus.Link);
  if (child_name = 'operationalStatus') Then
     list.add(self.link, 'operationalStatus', FOperationalStatus.Link);
  if (child_name = 'name') Then
     list.add(self.link, 'name', FName.Link);
  if (child_name = 'alias') Then
    list.addAll(self, 'alias', FAliasList);
  if (child_name = 'description') Then
     list.add(self.link, 'description', FDescription.Link);
  if (child_name = 'mode') Then
     list.add(self.link, 'mode', FMode.Link);
  if (child_name = 'type') Then
    list.addAll(self, 'type', FType_List);
  if (child_name = 'contact') Then
    list.addAll(self, 'contact', FContactList);
  if (child_name = 'address') Then
     list.add(self.link, 'address', FAddress.Link);
  if (child_name = 'form') Then
     list.add(self.link, 'form', FForm.Link);
  if (child_name = 'position') Then
     list.add(self.link, 'position', FPosition.Link);
  if (child_name = 'managingOrganization') Then
     list.add(self.link, 'managingOrganization', FManagingOrganization.Link);
  if (child_name = 'partOf') Then
     list.add(self.link, 'partOf', FPartOf.Link);
  if (child_name = 'characteristic') Then
    list.addAll(self, 'characteristic', FCharacteristicList);
  if (child_name = 'hoursOfOperation') Then
    list.addAll(self, 'hoursOfOperation', FHoursOfOperationList);
  if (child_name = 'virtualService') Then
    list.addAll(self, 'virtualService', FVirtualServiceList);
  if (child_name = 'endpoint') Then
    list.addAll(self, 'endpoint', FEndpointList);
end;

procedure TFhirLocation.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'identifier', 'Identifier', true, TFhirIdentifier, FIdentifierList.Link));
  oList.add(TFHIRProperty.create(self, 'status', 'code', false, TFhirEnum, FStatus.Link));
  oList.add(TFHIRProperty.create(self, 'operationalStatus', 'Coding', false, TFhirCoding, FOperationalStatus.Link));
  oList.add(TFHIRProperty.create(self, 'name', 'string', false, TFhirString, FName.Link));
  oList.add(TFHIRProperty.create(self, 'alias', 'string', true, TFhirString, FAliasList.Link));
  oList.add(TFHIRProperty.create(self, 'description', 'string', false, TFhirString, FDescription.Link));
  oList.add(TFHIRProperty.create(self, 'mode', 'code', false, TFhirEnum, FMode.Link));
  oList.add(TFHIRProperty.create(self, 'type', 'CodeableConcept', true, TFhirCodeableConcept, FType_List.Link));
  oList.add(TFHIRProperty.create(self, 'contact', 'ExtendedContactDetail', true, TFhirExtendedContactDetail, FContactList.Link));
  oList.add(TFHIRProperty.create(self, 'address', 'Address', false, TFhirAddress, FAddress.Link));
  oList.add(TFHIRProperty.create(self, 'form', 'CodeableConcept', false, TFhirCodeableConcept, FForm.Link));
  oList.add(TFHIRProperty.create(self, 'position', 'BackboneElement', false, TFhirLocationPosition, FPosition.Link));
  oList.add(TFHIRProperty.create(self, 'managingOrganization', 'Reference', false, TFhirReference, FManagingOrganization.Link));
  oList.add(TFHIRProperty.create(self, 'partOf', 'Reference', false, TFhirReference, FPartOf.Link));
  oList.add(TFHIRProperty.create(self, 'characteristic', 'CodeableConcept', true, TFhirCodeableConcept, FCharacteristicList.Link));
  oList.add(TFHIRProperty.create(self, 'hoursOfOperation', 'Availability', true, TFhirAvailability, FHoursOfOperationList.Link));
  oList.add(TFHIRProperty.create(self, 'virtualService', 'VirtualServiceDetail', true, TFhirVirtualServiceDetail, FVirtualServiceList.Link));
  oList.add(TFHIRProperty.create(self, 'endpoint', 'Reference', true, TFhirReference, FEndpointList.Link));
end;

function TFhirLocation.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'identifier') then
  begin
    IdentifierList.add(propValue as TFhirIdentifier);
    result := propValue;
  end
  else if (propName = 'status') then
  begin
    StatusElement := asEnum(SYSTEMS_TFhirLocationStatusEnum, CODES_TFhirLocationStatusEnum, propValue);
    result := propValue;
  end
  else if (propName = 'operationalStatus') then
  begin
    OperationalStatus := propValue as TFhirCoding;
    result := propValue;
  end
  else if (propName = 'name') then
  begin
    NameElement := asString(propValue);
    result := propValue;
  end
  else if (propName = 'alias') then
  begin
    AliasList.add(asString(propValue)){2};     result := propValue;

  end
  else if (propName = 'description') then
  begin
    DescriptionElement := asString(propValue);
    result := propValue;
  end
  else if (propName = 'mode') then
  begin
    ModeElement := asEnum(SYSTEMS_TFhirLocationModeEnum, CODES_TFhirLocationModeEnum, propValue);
    result := propValue;
  end
  else if (propName = 'type') then
  begin
    Type_List.add(propValue as TFhirCodeableConcept);
    result := propValue;
  end
  else if (propName = 'contact') then
  begin
    ContactList.add(propValue as TFhirExtendedContactDetail);
    result := propValue;
  end
  else if (propName = 'address') then
  begin
    Address := propValue as TFhirAddress;
    result := propValue;
  end
  else if (propName = 'form') then
  begin
    Form := propValue as TFhirCodeableConcept;
    result := propValue;
  end
  else if (propName = 'position') then
  begin
    Position := propValue as TFhirLocationPosition;
    result := propValue;
  end
  else if (propName = 'managingOrganization') then
  begin
    ManagingOrganization := propValue as TFhirReference;
    result := propValue;
  end
  else if (propName = 'partOf') then
  begin
    PartOf := propValue as TFhirReference;
    result := propValue;
  end
  else if (propName = 'characteristic') then
  begin
    CharacteristicList.add(propValue as TFhirCodeableConcept);
    result := propValue;
  end
  else if (propName = 'hoursOfOperation') then
  begin
    HoursOfOperationList.add(propValue as TFhirAvailability);
    result := propValue;
  end
  else if (propName = 'virtualService') then
  begin
    VirtualServiceList.add(propValue as TFhirVirtualServiceDetail);
    result := propValue;
  end
  else if (propName = 'endpoint') then
  begin
    EndpointList.add(propValue as TFhirReference);
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirLocation.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'identifier') then IdentifierList.insertItem(index, propValue as TFhirIdentifier)
  else if (propName = 'alias') then AliasList.insertItem(index, asString(propValue))
  else if (propName = 'type') then Type_List.insertItem(index, propValue as TFhirCodeableConcept)
  else if (propName = 'contact') then ContactList.insertItem(index, propValue as TFhirExtendedContactDetail)
  else if (propName = 'characteristic') then CharacteristicList.insertItem(index, propValue as TFhirCodeableConcept)
  else if (propName = 'hoursOfOperation') then HoursOfOperationList.insertItem(index, propValue as TFhirAvailability)
  else if (propName = 'virtualService') then VirtualServiceList.insertItem(index, propValue as TFhirVirtualServiceDetail)
  else if (propName = 'endpoint') then EndpointList.insertItem(index, propValue as TFhirReference)
  else inherited;
end;

function TFhirLocation.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'identifier') then result := IdentifierList.new()
  else if (propName = 'status') then result := TFhirEnum.create(SYSTEMS_TFhirLocationStatusEnum[LocationStatusNull], CODES_TFhirLocationStatusEnum[LocationStatusNull]) 
  else if (propName = 'operationalStatus') then result := TFhirCoding.create()
  else if (propName = 'name') then result := TFhirString.create()
  else if (propName = 'alias') then result := AliasList.new()
  else if (propName = 'description') then result := TFhirString.create()
  else if (propName = 'mode') then result := TFhirEnum.create(SYSTEMS_TFhirLocationModeEnum[LocationModeNull], CODES_TFhirLocationModeEnum[LocationModeNull]) 
  else if (propName = 'type') then result := Type_List.new()
  else if (propName = 'contact') then result := ContactList.new()
  else if (propName = 'address') then result := TFhirAddress.create()
  else if (propName = 'form') then result := TFhirCodeableConcept.create()
  else if (propName = 'position') then result := TFhirLocationPosition.create()
  else if (propName = 'managingOrganization') then result := TFhirReference.create()
  else if (propName = 'partOf') then result := TFhirReference.create()
  else if (propName = 'characteristic') then result := CharacteristicList.new()
  else if (propName = 'hoursOfOperation') then result := HoursOfOperationList.new()
  else if (propName = 'virtualService') then result := VirtualServiceList.new()
  else if (propName = 'endpoint') then result := EndpointList.new()
  else result := inherited createPropertyValue(propName);
end;

function TFhirLocation.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'identifier') then result := 'Identifier'
  else if (propName = 'status') then result := 'code'
  else if (propName = 'operationalStatus') then result := 'Coding'
  else if (propName = 'name') then result := 'string'
  else if (propName = 'alias') then result := 'string'
  else if (propName = 'description') then result := 'string'
  else if (propName = 'mode') then result := 'code'
  else if (propName = 'type') then result := 'CodeableConcept'
  else if (propName = 'contact') then result := 'ExtendedContactDetail'
  else if (propName = 'address') then result := 'Address'
  else if (propName = 'form') then result := 'CodeableConcept'
  else if (propName = 'position') then result := 'BackboneElement'
  else if (propName = 'managingOrganization') then result := 'Reference'
  else if (propName = 'partOf') then result := 'Reference'
  else if (propName = 'characteristic') then result := 'CodeableConcept'
  else if (propName = 'hoursOfOperation') then result := 'Availability'
  else if (propName = 'virtualService') then result := 'VirtualServiceDetail'
  else if (propName = 'endpoint') then result := 'Reference'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirLocation.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'identifier') then deletePropertyValue('identifier', IdentifierList, value)
  else if (propName = 'status') then StatusElement := nil
  else if (propName = 'operationalStatus') then OperationalStatusElement := nil
  else if (propName = 'name') then NameElement := nil
  else if (propName = 'alias') then deletePropertyValue('alias', AliasList, value)
  else if (propName = 'description') then DescriptionElement := nil
  else if (propName = 'mode') then ModeElement := nil
  else if (propName = 'type') then deletePropertyValue('type', Type_List, value)
  else if (propName = 'contact') then deletePropertyValue('contact', ContactList, value)
  else if (propName = 'address') then AddressElement := nil
  else if (propName = 'form') then FormElement := nil
  else if (propName = 'position') then PositionElement := nil
  else if (propName = 'managingOrganization') then ManagingOrganizationElement := nil
  else if (propName = 'partOf') then PartOfElement := nil
  else if (propName = 'characteristic') then deletePropertyValue('characteristic', CharacteristicList, value)
  else if (propName = 'hoursOfOperation') then deletePropertyValue('hoursOfOperation', HoursOfOperationList, value)
  else if (propName = 'virtualService') then deletePropertyValue('virtualService', VirtualServiceList, value)
  else if (propName = 'endpoint') then deletePropertyValue('endpoint', EndpointList, value)
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirLocation.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'identifier') then replacePropertyValue('identifier', IdentifierList, existing, new)
  else if (propName = 'status') then StatusElement := asEnum(SYSTEMS_TFhirLocationStatusEnum, CODES_TFhirLocationStatusEnum, new)
  else if (propName = 'operationalStatus') then OperationalStatusElement := new as TFhirCoding
  else if (propName = 'name') then NameElement := asString(new)
  else if (propName = 'alias') then replacePropertyValue('alias', AliasList, existing, new)
  else if (propName = 'description') then DescriptionElement := asString(new)
  else if (propName = 'mode') then ModeElement := asEnum(SYSTEMS_TFhirLocationModeEnum, CODES_TFhirLocationModeEnum, new)
  else if (propName = 'type') then replacePropertyValue('type', Type_List, existing, new)
  else if (propName = 'contact') then replacePropertyValue('contact', ContactList, existing, new)
  else if (propName = 'address') then AddressElement := new as TFhirAddress
  else if (propName = 'form') then FormElement := new as TFhirCodeableConcept
  else if (propName = 'position') then PositionElement := new as TFhirLocationPosition
  else if (propName = 'managingOrganization') then ManagingOrganizationElement := new as TFhirReference
  else if (propName = 'partOf') then PartOfElement := new as TFhirReference
  else if (propName = 'characteristic') then replacePropertyValue('characteristic', CharacteristicList, existing, new)
  else if (propName = 'hoursOfOperation') then replacePropertyValue('hoursOfOperation', HoursOfOperationList, existing, new)
  else if (propName = 'virtualService') then replacePropertyValue('virtualService', VirtualServiceList, existing, new)
  else if (propName = 'endpoint') then replacePropertyValue('endpoint', EndpointList, existing, new)
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirLocation.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'identifier') then IdentifierList.move(source, destination)
  else if (propName = 'alias') then AliasList.move(source, destination)
  else if (propName = 'type') then Type_List.move(source, destination)
  else if (propName = 'contact') then ContactList.move(source, destination)
  else if (propName = 'characteristic') then CharacteristicList.move(source, destination)
  else if (propName = 'hoursOfOperation') then HoursOfOperationList.move(source, destination)
  else if (propName = 'virtualService') then VirtualServiceList.move(source, destination)
  else if (propName = 'endpoint') then EndpointList.move(source, destination)
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirLocation.fhirType : string;
begin
  result := 'Location';
end;

function TFhirLocation.Link : TFhirLocation;
begin
  result := TFhirLocation(inherited Link);
end;

function TFhirLocation.Clone : TFhirLocation;
begin
  result := TFhirLocation(inherited Clone);
end;

function TFhirLocation.equals(other : TObject) : boolean; 
var
  o : TFhirLocation;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirLocation)) then
    result := false
  else
  begin
    o := TFhirLocation(other);
    result := compareDeep(identifierList, o.identifierList, true) and compareDeep(statusElement, o.statusElement, true) and 
      compareDeep(operationalStatusElement, o.operationalStatusElement, true) and compareDeep(nameElement, o.nameElement, true) and 
      compareDeep(aliasList, o.aliasList, true) and compareDeep(descriptionElement, o.descriptionElement, true) and 
      compareDeep(modeElement, o.modeElement, true) and compareDeep(type_List, o.type_List, true) and 
      compareDeep(contactList, o.contactList, true) and compareDeep(addressElement, o.addressElement, true) and 
      compareDeep(formElement, o.formElement, true) and compareDeep(positionElement, o.positionElement, true) and 
      compareDeep(managingOrganizationElement, o.managingOrganizationElement, true) and 
      compareDeep(partOfElement, o.partOfElement, true) and compareDeep(characteristicList, o.characteristicList, true) and 
      compareDeep(hoursOfOperationList, o.hoursOfOperationList, true) and compareDeep(virtualServiceList, o.virtualServiceList, true) and 
      compareDeep(endpointList, o.endpointList, true);
  end;
end;

function TFhirLocation.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FidentifierList) and isEmptyProp(FStatus) and isEmptyProp(FOperationalStatus) and isEmptyProp(FName) and isEmptyProp(FaliasList) and isEmptyProp(FDescription) and isEmptyProp(FMode) and isEmptyProp(Ftype_List) and isEmptyProp(FcontactList) and isEmptyProp(FAddress) and isEmptyProp(FForm) and isEmptyProp(FPosition) and isEmptyProp(FManagingOrganization) and isEmptyProp(FPartOf) and isEmptyProp(FcharacteristicList) and isEmptyProp(FhoursOfOperationList) and isEmptyProp(FvirtualServiceList) and isEmptyProp(FendpointList);
end;

procedure TFhirLocation.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('identifier');
  fields.add('status');
  fields.add('operationalStatus');
  fields.add('name');
  fields.add('alias');
  fields.add('description');
  fields.add('mode');
  fields.add('type');
  fields.add('contact');
  fields.add('address');
  fields.add('form');
  fields.add('position');
  fields.add('managingOrganization');
  fields.add('partOf');
  fields.add('characteristic');
  fields.add('hoursOfOperation');
  fields.add('virtualService');
  fields.add('endpoint');
end;

function TFhirLocation.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
  inc(result, FIdentifierList.sizeInBytes(magic));
  inc(result, FAliasList.sizeInBytes(magic));
  inc(result, FType_List.sizeInBytes(magic));
  inc(result, FContactList.sizeInBytes(magic));
  inc(result, FCharacteristicList.sizeInBytes(magic));
  inc(result, FHoursOfOperationList.sizeInBytes(magic));
  inc(result, FVirtualServiceList.sizeInBytes(magic));
  inc(result, FEndpointList.sizeInBytes(magic));
end;

function TFhirLocation.GetIdentifierList : TFhirIdentifierList;
begin
  if FIdentifierList = nil then
    FIdentifierList := TFhirIdentifierList.Create;
  result := FIdentifierList;
end;

function TFhirLocation.GetHasIdentifierList : boolean;
begin
  result := (FIdentifierList <> nil) and (FIdentifierList.count > 0);
end;

procedure TFhirLocation.SetStatus(value : TFhirEnum);
begin
  FStatus.free;
  FStatus := value;
end;

function TFhirLocation.GetStatusST : TFhirLocationStatusEnum;
begin
  if FStatus = nil then
    result := TFhirLocationStatusEnum(0)
  else
    result := TFhirLocationStatusEnum(StringArrayIndexOfSensitive(CODES_TFhirLocationStatusEnum, FStatus.value));
end;

procedure TFhirLocation.SetStatusST(value : TFhirLocationStatusEnum);
begin
  if ord(value) = 0 then
    StatusElement := nil
  else
    StatusElement := TFhirEnum.create(SYSTEMS_TFhirLocationStatusEnum[value], CODES_TFhirLocationStatusEnum[value]);
end;

procedure TFhirLocation.SetOperationalStatus(value : TFhirCoding);
begin
  FOperationalStatus.free;
  FOperationalStatus := value;
end;

procedure TFhirLocation.SetName(value : TFhirString);
begin
  FName.free;
  FName := value;
end;

function TFhirLocation.GetNameST : String;
begin
  if FName = nil then
    result := ''
  else
    result := FName.value;
end;

procedure TFhirLocation.SetNameST(value : String);
begin
  if value <> '' then
  begin
    if FName = nil then
      FName := TFhirString.create;
    FName.value := value
  end
  else if FName <> nil then
    FName.value := '';
end;

function TFhirLocation.GetAliasList : TFhirStringList;
begin
  if FAliasList = nil then
    FAliasList := TFhirStringList.Create;
  result := FAliasList;
end;

function TFhirLocation.GetHasAliasList : boolean;
begin
  result := (FAliasList <> nil) and (FAliasList.count > 0);
end;

procedure TFhirLocation.SetDescription(value : TFhirString);
begin
  FDescription.free;
  FDescription := value;
end;

function TFhirLocation.GetDescriptionST : String;
begin
  if FDescription = nil then
    result := ''
  else
    result := FDescription.value;
end;

procedure TFhirLocation.SetDescriptionST(value : String);
begin
  if value <> '' then
  begin
    if FDescription = nil then
      FDescription := TFhirString.create;
    FDescription.value := value
  end
  else if FDescription <> nil then
    FDescription.value := '';
end;

procedure TFhirLocation.SetMode(value : TFhirEnum);
begin
  FMode.free;
  FMode := value;
end;

function TFhirLocation.GetModeST : TFhirLocationModeEnum;
begin
  if FMode = nil then
    result := TFhirLocationModeEnum(0)
  else
    result := TFhirLocationModeEnum(StringArrayIndexOfSensitive(CODES_TFhirLocationModeEnum, FMode.value));
end;

procedure TFhirLocation.SetModeST(value : TFhirLocationModeEnum);
begin
  if ord(value) = 0 then
    ModeElement := nil
  else
    ModeElement := TFhirEnum.create(SYSTEMS_TFhirLocationModeEnum[value], CODES_TFhirLocationModeEnum[value]);
end;

function TFhirLocation.GetType_List : TFhirCodeableConceptList;
begin
  if FType_List = nil then
    FType_List := TFhirCodeableConceptList.Create;
  result := FType_List;
end;

function TFhirLocation.GetHasType_List : boolean;
begin
  result := (FType_List <> nil) and (FType_List.count > 0);
end;

function TFhirLocation.GetContactList : TFhirExtendedContactDetailList;
begin
  if FContactList = nil then
    FContactList := TFhirExtendedContactDetailList.Create;
  result := FContactList;
end;

function TFhirLocation.GetHasContactList : boolean;
begin
  result := (FContactList <> nil) and (FContactList.count > 0);
end;

procedure TFhirLocation.SetAddress(value : TFhirAddress);
begin
  FAddress.free;
  FAddress := value;
end;

procedure TFhirLocation.SetForm(value : TFhirCodeableConcept);
begin
  FForm.free;
  FForm := value;
end;

procedure TFhirLocation.SetPosition(value : TFhirLocationPosition);
begin
  FPosition.free;
  FPosition := value;
end;

procedure TFhirLocation.SetManagingOrganization(value : TFhirReference);
begin
  FManagingOrganization.free;
  FManagingOrganization := value;
end;

procedure TFhirLocation.SetPartOf(value : TFhirReference);
begin
  FPartOf.free;
  FPartOf := value;
end;

function TFhirLocation.GetCharacteristicList : TFhirCodeableConceptList;
begin
  if FCharacteristicList = nil then
    FCharacteristicList := TFhirCodeableConceptList.Create;
  result := FCharacteristicList;
end;

function TFhirLocation.GetHasCharacteristicList : boolean;
begin
  result := (FCharacteristicList <> nil) and (FCharacteristicList.count > 0);
end;

function TFhirLocation.GetHoursOfOperationList : TFhirAvailabilityList;
begin
  if FHoursOfOperationList = nil then
    FHoursOfOperationList := TFhirAvailabilityList.Create;
  result := FHoursOfOperationList;
end;

function TFhirLocation.GetHasHoursOfOperationList : boolean;
begin
  result := (FHoursOfOperationList <> nil) and (FHoursOfOperationList.count > 0);
end;

function TFhirLocation.GetVirtualServiceList : TFhirVirtualServiceDetailList;
begin
  if FVirtualServiceList = nil then
    FVirtualServiceList := TFhirVirtualServiceDetailList.Create;
  result := FVirtualServiceList;
end;

function TFhirLocation.GetHasVirtualServiceList : boolean;
begin
  result := (FVirtualServiceList <> nil) and (FVirtualServiceList.count > 0);
end;

function TFhirLocation.GetEndpointList : TFhirReferenceList;
begin
  if FEndpointList = nil then
    FEndpointList := TFhirReferenceList.Create;
  result := FEndpointList;
end;

function TFhirLocation.GetHasEndpointList : boolean;
begin
  result := (FEndpointList <> nil) and (FEndpointList.count > 0);
end;

{ TFhirLocationListEnumerator }

constructor TFhirLocationListEnumerator.Create(list : TFhirLocationList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirLocationListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirLocationListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirLocationListEnumerator.GetCurrent : TFhirLocation;
begin
  Result := FList[FIndex];
end;

function TFhirLocationListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirLocationList }

function TFhirLocationList.AddItem(value: TFhirLocation): TFhirLocation;
begin
  assert(value.ClassName = 'TFhirLocation', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirLocation');
  add(value);
  result := value;
end;

function TFhirLocationList.Append: TFhirLocation;
begin
  result := TFhirLocation.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirLocationList.ClearItems;
begin
  Clear;
end;

function TFhirLocationList.GetEnumerator : TFhirLocationListEnumerator;
begin
  result := TFhirLocationListEnumerator.Create(self.link);
end;

function TFhirLocationList.Clone: TFhirLocationList;
begin
  result := TFhirLocationList(inherited Clone);
end;

function TFhirLocationList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirLocationList.GetItemN(index: Integer): TFhirLocation;
begin
  result := TFhirLocation(ObjectByIndex[index]);
end;

function TFhirLocationList.ItemClass: TFslObjectClass;
begin
  result := TFhirLocation;
end;
function TFhirLocationList.IndexOf(value: TFhirLocation): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirLocationList.Insert(index: Integer): TFhirLocation;
begin
  result := TFhirLocation.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirLocationList.InsertItem(index: Integer; value: TFhirLocation);
begin
  assert(value is TFhirLocation);
  Inherited Insert(index, value);
end;

function TFhirLocationList.Item(index: Integer): TFhirLocation;
begin
  result := TFhirLocation(ObjectByIndex[index]);
end;

function TFhirLocationList.Link: TFhirLocationList;
begin
  result := TFhirLocationList(inherited Link);
end;

procedure TFhirLocationList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirLocationList.SetItemByIndex(index: Integer; value: TFhirLocation);
begin
  assert(value is TFhirLocation);
  FhirLocations[index] := value;
end;

procedure TFhirLocationList.SetItemN(index: Integer; value: TFhirLocation);
begin
  assert(value is TFhirLocation);
  ObjectByIndex[index] := value;
end;

{$ENDIF FHIR_LOCATION}
{$IFDEF FHIR_ORGANIZATION}
{ TFhirOrganizationQualification }

constructor TFhirOrganizationQualification.Create;
begin
  inherited;
end;

destructor TFhirOrganizationQualification.Destroy;
begin
  FIdentifierList.Free;
  FCode.free;
  FPeriod.free;
  FIssuer.free;
  inherited;
end;

procedure TFhirOrganizationQualification.Assign(oSource : TFslObject);
begin
  inherited;
  if (TFhirOrganizationQualification(oSource).FIdentifierList = nil) then
  begin
    FIdentifierList.free;
    FIdentifierList := nil;
  end
  else
  begin
    if FIdentifierList = nil then
      FIdentifierList := TFhirIdentifierList.Create;
    FIdentifierList.Assign(TFhirOrganizationQualification(oSource).FIdentifierList);
  end;
  code := TFhirOrganizationQualification(oSource).code.Clone;
  period := TFhirOrganizationQualification(oSource).period.Clone;
  issuer := TFhirOrganizationQualification(oSource).issuer.Clone;
end;

procedure TFhirOrganizationQualification.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'identifier') Then
    list.addAll(self, 'identifier', FIdentifierList);
  if (child_name = 'code') Then
     list.add(self.link, 'code', FCode.Link);
  if (child_name = 'period') Then
     list.add(self.link, 'period', FPeriod.Link);
  if (child_name = 'issuer') Then
     list.add(self.link, 'issuer', FIssuer.Link);
end;

procedure TFhirOrganizationQualification.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'identifier', 'Identifier', true, TFhirIdentifier, FIdentifierList.Link));
  oList.add(TFHIRProperty.create(self, 'code', 'CodeableConcept', false, TFhirCodeableConcept, FCode.Link));
  oList.add(TFHIRProperty.create(self, 'period', 'Period', false, TFhirPeriod, FPeriod.Link));
  oList.add(TFHIRProperty.create(self, 'issuer', 'Reference', false, TFhirReference, FIssuer.Link));
end;

function TFhirOrganizationQualification.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'identifier') then
  begin
    IdentifierList.add(propValue as TFhirIdentifier);
    result := propValue;
  end
  else if (propName = 'code') then
  begin
    Code := propValue as TFhirCodeableConcept;
    result := propValue;
  end
  else if (propName = 'period') then
  begin
    Period := propValue as TFhirPeriod;
    result := propValue;
  end
  else if (propName = 'issuer') then
  begin
    Issuer := propValue as TFhirReference;
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirOrganizationQualification.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'identifier') then IdentifierList.insertItem(index, propValue as TFhirIdentifier)
  else inherited;
end;

function TFhirOrganizationQualification.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'identifier') then result := IdentifierList.new()
  else if (propName = 'code') then result := TFhirCodeableConcept.create()
  else if (propName = 'period') then result := TFhirPeriod.create()
  else if (propName = 'issuer') then result := TFhirReference.create()
  else result := inherited createPropertyValue(propName);
end;

function TFhirOrganizationQualification.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'identifier') then result := 'Identifier'
  else if (propName = 'code') then result := 'CodeableConcept'
  else if (propName = 'period') then result := 'Period'
  else if (propName = 'issuer') then result := 'Reference'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirOrganizationQualification.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'identifier') then deletePropertyValue('identifier', IdentifierList, value)
  else if (propName = 'code') then CodeElement := nil
  else if (propName = 'period') then PeriodElement := nil
  else if (propName = 'issuer') then IssuerElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirOrganizationQualification.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'identifier') then replacePropertyValue('identifier', IdentifierList, existing, new)
  else if (propName = 'code') then CodeElement := new as TFhirCodeableConcept
  else if (propName = 'period') then PeriodElement := new as TFhirPeriod
  else if (propName = 'issuer') then IssuerElement := new as TFhirReference
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirOrganizationQualification.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'identifier') then IdentifierList.move(source, destination)
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirOrganizationQualification.fhirType : string;
begin
  result := 'Organization.qualification';
end;

function TFhirOrganizationQualification.Link : TFhirOrganizationQualification;
begin
  result := TFhirOrganizationQualification(inherited Link);
end;

function TFhirOrganizationQualification.Clone : TFhirOrganizationQualification;
begin
  result := TFhirOrganizationQualification(inherited Clone);
end;

function TFhirOrganizationQualification.equals(other : TObject) : boolean; 
var
  o : TFhirOrganizationQualification;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirOrganizationQualification)) then
    result := false
  else
  begin
    o := TFhirOrganizationQualification(other);
    result := compareDeep(identifierList, o.identifierList, true) and compareDeep(codeElement, o.codeElement, true) and 
      compareDeep(periodElement, o.periodElement, true) and compareDeep(issuerElement, o.issuerElement, true);
  end;
end;

function TFhirOrganizationQualification.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FidentifierList) and isEmptyProp(FCode) and isEmptyProp(FPeriod) and isEmptyProp(FIssuer);
end;

procedure TFhirOrganizationQualification.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('identifier');
  fields.add('code');
  fields.add('period');
  fields.add('issuer');
end;

function TFhirOrganizationQualification.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
  inc(result, FIdentifierList.sizeInBytes(magic));
end;

function TFhirOrganizationQualification.GetIdentifierList : TFhirIdentifierList;
begin
  if FIdentifierList = nil then
    FIdentifierList := TFhirIdentifierList.Create;
  result := FIdentifierList;
end;

function TFhirOrganizationQualification.GetHasIdentifierList : boolean;
begin
  result := (FIdentifierList <> nil) and (FIdentifierList.count > 0);
end;

procedure TFhirOrganizationQualification.SetCode(value : TFhirCodeableConcept);
begin
  FCode.free;
  FCode := value;
end;

procedure TFhirOrganizationQualification.SetPeriod(value : TFhirPeriod);
begin
  FPeriod.free;
  FPeriod := value;
end;

procedure TFhirOrganizationQualification.SetIssuer(value : TFhirReference);
begin
  FIssuer.free;
  FIssuer := value;
end;

{ TFhirOrganizationQualificationListEnumerator }

constructor TFhirOrganizationQualificationListEnumerator.Create(list : TFhirOrganizationQualificationList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirOrganizationQualificationListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirOrganizationQualificationListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirOrganizationQualificationListEnumerator.GetCurrent : TFhirOrganizationQualification;
begin
  Result := FList[FIndex];
end;

function TFhirOrganizationQualificationListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirOrganizationQualificationList }

function TFhirOrganizationQualificationList.AddItem(value: TFhirOrganizationQualification): TFhirOrganizationQualification;
begin
  assert(value.ClassName = 'TFhirOrganizationQualification', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirOrganizationQualification');
  add(value);
  result := value;
end;

function TFhirOrganizationQualificationList.Append: TFhirOrganizationQualification;
begin
  result := TFhirOrganizationQualification.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirOrganizationQualificationList.ClearItems;
begin
  Clear;
end;

function TFhirOrganizationQualificationList.GetEnumerator : TFhirOrganizationQualificationListEnumerator;
begin
  result := TFhirOrganizationQualificationListEnumerator.Create(self.link);
end;

function TFhirOrganizationQualificationList.Clone: TFhirOrganizationQualificationList;
begin
  result := TFhirOrganizationQualificationList(inherited Clone);
end;

function TFhirOrganizationQualificationList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirOrganizationQualificationList.GetItemN(index: Integer): TFhirOrganizationQualification;
begin
  result := TFhirOrganizationQualification(ObjectByIndex[index]);
end;

function TFhirOrganizationQualificationList.ItemClass: TFslObjectClass;
begin
  result := TFhirOrganizationQualification;
end;
function TFhirOrganizationQualificationList.IndexOf(value: TFhirOrganizationQualification): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirOrganizationQualificationList.Insert(index: Integer): TFhirOrganizationQualification;
begin
  result := TFhirOrganizationQualification.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirOrganizationQualificationList.InsertItem(index: Integer; value: TFhirOrganizationQualification);
begin
  assert(value is TFhirOrganizationQualification);
  Inherited Insert(index, value);
end;

function TFhirOrganizationQualificationList.Item(index: Integer): TFhirOrganizationQualification;
begin
  result := TFhirOrganizationQualification(ObjectByIndex[index]);
end;

function TFhirOrganizationQualificationList.Link: TFhirOrganizationQualificationList;
begin
  result := TFhirOrganizationQualificationList(inherited Link);
end;

procedure TFhirOrganizationQualificationList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirOrganizationQualificationList.SetItemByIndex(index: Integer; value: TFhirOrganizationQualification);
begin
  assert(value is TFhirOrganizationQualification);
  FhirOrganizationQualifications[index] := value;
end;

procedure TFhirOrganizationQualificationList.SetItemN(index: Integer; value: TFhirOrganizationQualification);
begin
  assert(value is TFhirOrganizationQualification);
  ObjectByIndex[index] := value;
end;

{ TFhirOrganization }

constructor TFhirOrganization.Create;
begin
  inherited;
end;

destructor TFhirOrganization.Destroy;
begin
  FIdentifierList.Free;
  FActive.free;
  FType_List.Free;
  FName.free;
  FAliasList.Free;
  FDescription.free;
  FContactList.Free;
  FPartOf.free;
  FEndpointList.Free;
  FQualificationList.Free;
  inherited;
end;

procedure TFhirOrganization.Assign(oSource : TFslObject);
begin
  inherited;
  if (TFhirOrganization(oSource).FIdentifierList = nil) then
  begin
    FIdentifierList.free;
    FIdentifierList := nil;
  end
  else
  begin
    if FIdentifierList = nil then
      FIdentifierList := TFhirIdentifierList.Create;
    FIdentifierList.Assign(TFhirOrganization(oSource).FIdentifierList);
  end;
  activeElement := TFhirOrganization(oSource).activeElement.Clone;
  if (TFhirOrganization(oSource).FType_List = nil) then
  begin
    FType_List.free;
    FType_List := nil;
  end
  else
  begin
    if FType_List = nil then
      FType_List := TFhirCodeableConceptList.Create;
    FType_List.Assign(TFhirOrganization(oSource).FType_List);
  end;
  nameElement := TFhirOrganization(oSource).nameElement.Clone;
  if (TFhirOrganization(oSource).FAliasList = nil) then
  begin
    FAliasList.free;
    FAliasList := nil;
  end
  else
  begin
    if FAliasList = nil then
      FAliasList := TFhirStringList.Create;
    FAliasList.Assign(TFhirOrganization(oSource).FAliasList);
  end;
  descriptionElement := TFhirOrganization(oSource).descriptionElement.Clone;
  if (TFhirOrganization(oSource).FContactList = nil) then
  begin
    FContactList.free;
    FContactList := nil;
  end
  else
  begin
    if FContactList = nil then
      FContactList := TFhirExtendedContactDetailList.Create;
    FContactList.Assign(TFhirOrganization(oSource).FContactList);
  end;
  partOf := TFhirOrganization(oSource).partOf.Clone;
  if (TFhirOrganization(oSource).FEndpointList = nil) then
  begin
    FEndpointList.free;
    FEndpointList := nil;
  end
  else
  begin
    if FEndpointList = nil then
      FEndpointList := TFhirReferenceList.Create;
    FEndpointList.Assign(TFhirOrganization(oSource).FEndpointList);
  end;
  if (TFhirOrganization(oSource).FQualificationList = nil) then
  begin
    FQualificationList.free;
    FQualificationList := nil;
  end
  else
  begin
    if FQualificationList = nil then
      FQualificationList := TFhirOrganizationQualificationList.Create;
    FQualificationList.Assign(TFhirOrganization(oSource).FQualificationList);
  end;
end;

function TFhirOrganization.GetResourceType : TFhirResourceType;
begin
  result := frtOrganization;
end;

procedure TFhirOrganization.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'identifier') Then
    list.addAll(self, 'identifier', FIdentifierList);
  if (child_name = 'active') Then
     list.add(self.link, 'active', FActive.Link);
  if (child_name = 'type') Then
    list.addAll(self, 'type', FType_List);
  if (child_name = 'name') Then
     list.add(self.link, 'name', FName.Link);
  if (child_name = 'alias') Then
    list.addAll(self, 'alias', FAliasList);
  if (child_name = 'description') Then
     list.add(self.link, 'description', FDescription.Link);
  if (child_name = 'contact') Then
    list.addAll(self, 'contact', FContactList);
  if (child_name = 'partOf') Then
     list.add(self.link, 'partOf', FPartOf.Link);
  if (child_name = 'endpoint') Then
    list.addAll(self, 'endpoint', FEndpointList);
  if (child_name = 'qualification') Then
    list.addAll(self, 'qualification', FQualificationList);
end;

procedure TFhirOrganization.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'identifier', 'Identifier', true, TFhirIdentifier, FIdentifierList.Link));
  oList.add(TFHIRProperty.create(self, 'active', 'boolean', false, TFhirBoolean, FActive.Link));
  oList.add(TFHIRProperty.create(self, 'type', 'CodeableConcept', true, TFhirCodeableConcept, FType_List.Link));
  oList.add(TFHIRProperty.create(self, 'name', 'string', false, TFhirString, FName.Link));
  oList.add(TFHIRProperty.create(self, 'alias', 'string', true, TFhirString, FAliasList.Link));
  oList.add(TFHIRProperty.create(self, 'description', 'string', false, TFhirString, FDescription.Link));
  oList.add(TFHIRProperty.create(self, 'contact', 'ExtendedContactDetail', true, TFhirExtendedContactDetail, FContactList.Link));
  oList.add(TFHIRProperty.create(self, 'partOf', 'Reference', false, TFhirReference, FPartOf.Link));
  oList.add(TFHIRProperty.create(self, 'endpoint', 'Reference', true, TFhirReference, FEndpointList.Link));
  oList.add(TFHIRProperty.create(self, 'qualification', 'BackboneElement', true, TFhirOrganizationQualification, FQualificationList.Link));
end;

function TFhirOrganization.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'identifier') then
  begin
    IdentifierList.add(propValue as TFhirIdentifier);
    result := propValue;
  end
  else if (propName = 'active') then
  begin
    ActiveElement := asBoolean(propValue);
    result := propValue;
  end
  else if (propName = 'type') then
  begin
    Type_List.add(propValue as TFhirCodeableConcept);
    result := propValue;
  end
  else if (propName = 'name') then
  begin
    NameElement := asString(propValue);
    result := propValue;
  end
  else if (propName = 'alias') then
  begin
    AliasList.add(asString(propValue)){2};     result := propValue;

  end
  else if (propName = 'description') then
  begin
    DescriptionElement := asString(propValue);
    result := propValue;
  end
  else if (propName = 'contact') then
  begin
    ContactList.add(propValue as TFhirExtendedContactDetail);
    result := propValue;
  end
  else if (propName = 'partOf') then
  begin
    PartOf := propValue as TFhirReference;
    result := propValue;
  end
  else if (propName = 'endpoint') then
  begin
    EndpointList.add(propValue as TFhirReference);
    result := propValue;
  end
  else if (propName = 'qualification') then
  begin
    QualificationList.add(propValue as TFhirOrganizationQualification);
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirOrganization.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'identifier') then IdentifierList.insertItem(index, propValue as TFhirIdentifier)
  else if (propName = 'type') then Type_List.insertItem(index, propValue as TFhirCodeableConcept)
  else if (propName = 'alias') then AliasList.insertItem(index, asString(propValue))
  else if (propName = 'contact') then ContactList.insertItem(index, propValue as TFhirExtendedContactDetail)
  else if (propName = 'endpoint') then EndpointList.insertItem(index, propValue as TFhirReference)
  else if (propName = 'qualification') then QualificationList.insertItem(index, propValue as TFhirOrganizationQualification)
  else inherited;
end;

function TFhirOrganization.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'identifier') then result := IdentifierList.new()
  else if (propName = 'active') then result := TFhirBoolean.create()
  else if (propName = 'type') then result := Type_List.new()
  else if (propName = 'name') then result := TFhirString.create()
  else if (propName = 'alias') then result := AliasList.new()
  else if (propName = 'description') then result := TFhirString.create()
  else if (propName = 'contact') then result := ContactList.new()
  else if (propName = 'partOf') then result := TFhirReference.create()
  else if (propName = 'endpoint') then result := EndpointList.new()
  else if (propName = 'qualification') then result := QualificationList.new()
  else result := inherited createPropertyValue(propName);
end;

function TFhirOrganization.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'identifier') then result := 'Identifier'
  else if (propName = 'active') then result := 'boolean'
  else if (propName = 'type') then result := 'CodeableConcept'
  else if (propName = 'name') then result := 'string'
  else if (propName = 'alias') then result := 'string'
  else if (propName = 'description') then result := 'string'
  else if (propName = 'contact') then result := 'ExtendedContactDetail'
  else if (propName = 'partOf') then result := 'Reference'
  else if (propName = 'endpoint') then result := 'Reference'
  else if (propName = 'qualification') then result := 'BackboneElement'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirOrganization.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'identifier') then deletePropertyValue('identifier', IdentifierList, value)
  else if (propName = 'active') then ActiveElement := nil
  else if (propName = 'type') then deletePropertyValue('type', Type_List, value)
  else if (propName = 'name') then NameElement := nil
  else if (propName = 'alias') then deletePropertyValue('alias', AliasList, value)
  else if (propName = 'description') then DescriptionElement := nil
  else if (propName = 'contact') then deletePropertyValue('contact', ContactList, value)
  else if (propName = 'partOf') then PartOfElement := nil
  else if (propName = 'endpoint') then deletePropertyValue('endpoint', EndpointList, value)
  else if (propName = 'qualification') then deletePropertyValue('qualification', QualificationList, value)
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirOrganization.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'identifier') then replacePropertyValue('identifier', IdentifierList, existing, new)
  else if (propName = 'active') then ActiveElement := asBoolean(new)
  else if (propName = 'type') then replacePropertyValue('type', Type_List, existing, new)
  else if (propName = 'name') then NameElement := asString(new)
  else if (propName = 'alias') then replacePropertyValue('alias', AliasList, existing, new)
  else if (propName = 'description') then DescriptionElement := asString(new)
  else if (propName = 'contact') then replacePropertyValue('contact', ContactList, existing, new)
  else if (propName = 'partOf') then PartOfElement := new as TFhirReference
  else if (propName = 'endpoint') then replacePropertyValue('endpoint', EndpointList, existing, new)
  else if (propName = 'qualification') then replacePropertyValue('qualification', QualificationList, existing, new)
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirOrganization.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'identifier') then IdentifierList.move(source, destination)
  else if (propName = 'type') then Type_List.move(source, destination)
  else if (propName = 'alias') then AliasList.move(source, destination)
  else if (propName = 'contact') then ContactList.move(source, destination)
  else if (propName = 'endpoint') then EndpointList.move(source, destination)
  else if (propName = 'qualification') then QualificationList.move(source, destination)
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirOrganization.fhirType : string;
begin
  result := 'Organization';
end;

function TFhirOrganization.Link : TFhirOrganization;
begin
  result := TFhirOrganization(inherited Link);
end;

function TFhirOrganization.Clone : TFhirOrganization;
begin
  result := TFhirOrganization(inherited Clone);
end;

function TFhirOrganization.equals(other : TObject) : boolean; 
var
  o : TFhirOrganization;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirOrganization)) then
    result := false
  else
  begin
    o := TFhirOrganization(other);
    result := compareDeep(identifierList, o.identifierList, true) and compareDeep(activeElement, o.activeElement, true) and 
      compareDeep(type_List, o.type_List, true) and compareDeep(nameElement, o.nameElement, true) and 
      compareDeep(aliasList, o.aliasList, true) and compareDeep(descriptionElement, o.descriptionElement, true) and 
      compareDeep(contactList, o.contactList, true) and compareDeep(partOfElement, o.partOfElement, true) and 
      compareDeep(endpointList, o.endpointList, true) and compareDeep(qualificationList, o.qualificationList, true);
  end;
end;

function TFhirOrganization.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FidentifierList) and isEmptyProp(FActive) and isEmptyProp(Ftype_List) and isEmptyProp(FName) and isEmptyProp(FaliasList) and isEmptyProp(FDescription) and isEmptyProp(FcontactList) and isEmptyProp(FPartOf) and isEmptyProp(FendpointList) and isEmptyProp(FqualificationList);
end;

procedure TFhirOrganization.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('identifier');
  fields.add('active');
  fields.add('type');
  fields.add('name');
  fields.add('alias');
  fields.add('description');
  fields.add('contact');
  fields.add('partOf');
  fields.add('endpoint');
  fields.add('qualification');
end;

function TFhirOrganization.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
  inc(result, FIdentifierList.sizeInBytes(magic));
  inc(result, FType_List.sizeInBytes(magic));
  inc(result, FAliasList.sizeInBytes(magic));
  inc(result, FContactList.sizeInBytes(magic));
  inc(result, FEndpointList.sizeInBytes(magic));
  inc(result, FQualificationList.sizeInBytes(magic));
end;

function TFhirOrganization.GetIdentifierList : TFhirIdentifierList;
begin
  if FIdentifierList = nil then
    FIdentifierList := TFhirIdentifierList.Create;
  result := FIdentifierList;
end;

function TFhirOrganization.GetHasIdentifierList : boolean;
begin
  result := (FIdentifierList <> nil) and (FIdentifierList.count > 0);
end;

procedure TFhirOrganization.SetActive(value : TFhirBoolean);
begin
  FActive.free;
  FActive := value;
end;

function TFhirOrganization.GetActiveST : Boolean;
begin
  if FActive = nil then
    result := false
  else
    result := FActive.value;
end;

procedure TFhirOrganization.SetActiveST(value : Boolean);
begin
  if FActive = nil then
    FActive := TFhirBoolean.create;
  FActive.value := value
end;

function TFhirOrganization.GetType_List : TFhirCodeableConceptList;
begin
  if FType_List = nil then
    FType_List := TFhirCodeableConceptList.Create;
  result := FType_List;
end;

function TFhirOrganization.GetHasType_List : boolean;
begin
  result := (FType_List <> nil) and (FType_List.count > 0);
end;

procedure TFhirOrganization.SetName(value : TFhirString);
begin
  FName.free;
  FName := value;
end;

function TFhirOrganization.GetNameST : String;
begin
  if FName = nil then
    result := ''
  else
    result := FName.value;
end;

procedure TFhirOrganization.SetNameST(value : String);
begin
  if value <> '' then
  begin
    if FName = nil then
      FName := TFhirString.create;
    FName.value := value
  end
  else if FName <> nil then
    FName.value := '';
end;

function TFhirOrganization.GetAliasList : TFhirStringList;
begin
  if FAliasList = nil then
    FAliasList := TFhirStringList.Create;
  result := FAliasList;
end;

function TFhirOrganization.GetHasAliasList : boolean;
begin
  result := (FAliasList <> nil) and (FAliasList.count > 0);
end;

procedure TFhirOrganization.SetDescription(value : TFhirString);
begin
  FDescription.free;
  FDescription := value;
end;

function TFhirOrganization.GetDescriptionST : String;
begin
  if FDescription = nil then
    result := ''
  else
    result := FDescription.value;
end;

procedure TFhirOrganization.SetDescriptionST(value : String);
begin
  if value <> '' then
  begin
    if FDescription = nil then
      FDescription := TFhirString.create;
    FDescription.value := value
  end
  else if FDescription <> nil then
    FDescription.value := '';
end;

function TFhirOrganization.GetContactList : TFhirExtendedContactDetailList;
begin
  if FContactList = nil then
    FContactList := TFhirExtendedContactDetailList.Create;
  result := FContactList;
end;

function TFhirOrganization.GetHasContactList : boolean;
begin
  result := (FContactList <> nil) and (FContactList.count > 0);
end;

procedure TFhirOrganization.SetPartOf(value : TFhirReference);
begin
  FPartOf.free;
  FPartOf := value;
end;

function TFhirOrganization.GetEndpointList : TFhirReferenceList;
begin
  if FEndpointList = nil then
    FEndpointList := TFhirReferenceList.Create;
  result := FEndpointList;
end;

function TFhirOrganization.GetHasEndpointList : boolean;
begin
  result := (FEndpointList <> nil) and (FEndpointList.count > 0);
end;

function TFhirOrganization.GetQualificationList : TFhirOrganizationQualificationList;
begin
  if FQualificationList = nil then
    FQualificationList := TFhirOrganizationQualificationList.Create;
  result := FQualificationList;
end;

function TFhirOrganization.GetHasQualificationList : boolean;
begin
  result := (FQualificationList <> nil) and (FQualificationList.count > 0);
end;

{ TFhirOrganizationListEnumerator }

constructor TFhirOrganizationListEnumerator.Create(list : TFhirOrganizationList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirOrganizationListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirOrganizationListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirOrganizationListEnumerator.GetCurrent : TFhirOrganization;
begin
  Result := FList[FIndex];
end;

function TFhirOrganizationListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirOrganizationList }

function TFhirOrganizationList.AddItem(value: TFhirOrganization): TFhirOrganization;
begin
  assert(value.ClassName = 'TFhirOrganization', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirOrganization');
  add(value);
  result := value;
end;

function TFhirOrganizationList.Append: TFhirOrganization;
begin
  result := TFhirOrganization.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirOrganizationList.ClearItems;
begin
  Clear;
end;

function TFhirOrganizationList.GetEnumerator : TFhirOrganizationListEnumerator;
begin
  result := TFhirOrganizationListEnumerator.Create(self.link);
end;

function TFhirOrganizationList.Clone: TFhirOrganizationList;
begin
  result := TFhirOrganizationList(inherited Clone);
end;

function TFhirOrganizationList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirOrganizationList.GetItemN(index: Integer): TFhirOrganization;
begin
  result := TFhirOrganization(ObjectByIndex[index]);
end;

function TFhirOrganizationList.ItemClass: TFslObjectClass;
begin
  result := TFhirOrganization;
end;
function TFhirOrganizationList.IndexOf(value: TFhirOrganization): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirOrganizationList.Insert(index: Integer): TFhirOrganization;
begin
  result := TFhirOrganization.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirOrganizationList.InsertItem(index: Integer; value: TFhirOrganization);
begin
  assert(value is TFhirOrganization);
  Inherited Insert(index, value);
end;

function TFhirOrganizationList.Item(index: Integer): TFhirOrganization;
begin
  result := TFhirOrganization(ObjectByIndex[index]);
end;

function TFhirOrganizationList.Link: TFhirOrganizationList;
begin
  result := TFhirOrganizationList(inherited Link);
end;

procedure TFhirOrganizationList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirOrganizationList.SetItemByIndex(index: Integer; value: TFhirOrganization);
begin
  assert(value is TFhirOrganization);
  FhirOrganizations[index] := value;
end;

procedure TFhirOrganizationList.SetItemN(index: Integer; value: TFhirOrganization);
begin
  assert(value is TFhirOrganization);
  ObjectByIndex[index] := value;
end;

{$ENDIF FHIR_ORGANIZATION}
{$IFDEF FHIR_ORGANIZATIONAFFILIATION}
{ TFhirOrganizationAffiliation }

constructor TFhirOrganizationAffiliation.Create;
begin
  inherited;
end;

destructor TFhirOrganizationAffiliation.Destroy;
begin
  FIdentifierList.Free;
  FActive.free;
  FPeriod.free;
  FOrganization.free;
  FParticipatingOrganization.free;
  FNetworkList.Free;
  FCodeList.Free;
  FSpecialtyList.Free;
  FLocationList.Free;
  FHealthcareServiceList.Free;
  FContactList.Free;
  FEndpointList.Free;
  inherited;
end;

procedure TFhirOrganizationAffiliation.Assign(oSource : TFslObject);
begin
  inherited;
  if (TFhirOrganizationAffiliation(oSource).FIdentifierList = nil) then
  begin
    FIdentifierList.free;
    FIdentifierList := nil;
  end
  else
  begin
    if FIdentifierList = nil then
      FIdentifierList := TFhirIdentifierList.Create;
    FIdentifierList.Assign(TFhirOrganizationAffiliation(oSource).FIdentifierList);
  end;
  activeElement := TFhirOrganizationAffiliation(oSource).activeElement.Clone;
  period := TFhirOrganizationAffiliation(oSource).period.Clone;
  organization := TFhirOrganizationAffiliation(oSource).organization.Clone;
  participatingOrganization := TFhirOrganizationAffiliation(oSource).participatingOrganization.Clone;
  if (TFhirOrganizationAffiliation(oSource).FNetworkList = nil) then
  begin
    FNetworkList.free;
    FNetworkList := nil;
  end
  else
  begin
    if FNetworkList = nil then
      FNetworkList := TFhirReferenceList.Create;
    FNetworkList.Assign(TFhirOrganizationAffiliation(oSource).FNetworkList);
  end;
  if (TFhirOrganizationAffiliation(oSource).FCodeList = nil) then
  begin
    FCodeList.free;
    FCodeList := nil;
  end
  else
  begin
    if FCodeList = nil then
      FCodeList := TFhirCodeableConceptList.Create;
    FCodeList.Assign(TFhirOrganizationAffiliation(oSource).FCodeList);
  end;
  if (TFhirOrganizationAffiliation(oSource).FSpecialtyList = nil) then
  begin
    FSpecialtyList.free;
    FSpecialtyList := nil;
  end
  else
  begin
    if FSpecialtyList = nil then
      FSpecialtyList := TFhirCodeableConceptList.Create;
    FSpecialtyList.Assign(TFhirOrganizationAffiliation(oSource).FSpecialtyList);
  end;
  if (TFhirOrganizationAffiliation(oSource).FLocationList = nil) then
  begin
    FLocationList.free;
    FLocationList := nil;
  end
  else
  begin
    if FLocationList = nil then
      FLocationList := TFhirReferenceList.Create;
    FLocationList.Assign(TFhirOrganizationAffiliation(oSource).FLocationList);
  end;
  if (TFhirOrganizationAffiliation(oSource).FHealthcareServiceList = nil) then
  begin
    FHealthcareServiceList.free;
    FHealthcareServiceList := nil;
  end
  else
  begin
    if FHealthcareServiceList = nil then
      FHealthcareServiceList := TFhirReferenceList.Create;
    FHealthcareServiceList.Assign(TFhirOrganizationAffiliation(oSource).FHealthcareServiceList);
  end;
  if (TFhirOrganizationAffiliation(oSource).FContactList = nil) then
  begin
    FContactList.free;
    FContactList := nil;
  end
  else
  begin
    if FContactList = nil then
      FContactList := TFhirExtendedContactDetailList.Create;
    FContactList.Assign(TFhirOrganizationAffiliation(oSource).FContactList);
  end;
  if (TFhirOrganizationAffiliation(oSource).FEndpointList = nil) then
  begin
    FEndpointList.free;
    FEndpointList := nil;
  end
  else
  begin
    if FEndpointList = nil then
      FEndpointList := TFhirReferenceList.Create;
    FEndpointList.Assign(TFhirOrganizationAffiliation(oSource).FEndpointList);
  end;
end;

function TFhirOrganizationAffiliation.GetResourceType : TFhirResourceType;
begin
  result := frtOrganizationAffiliation;
end;

procedure TFhirOrganizationAffiliation.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'identifier') Then
    list.addAll(self, 'identifier', FIdentifierList);
  if (child_name = 'active') Then
     list.add(self.link, 'active', FActive.Link);
  if (child_name = 'period') Then
     list.add(self.link, 'period', FPeriod.Link);
  if (child_name = 'organization') Then
     list.add(self.link, 'organization', FOrganization.Link);
  if (child_name = 'participatingOrganization') Then
     list.add(self.link, 'participatingOrganization', FParticipatingOrganization.Link);
  if (child_name = 'network') Then
    list.addAll(self, 'network', FNetworkList);
  if (child_name = 'code') Then
    list.addAll(self, 'code', FCodeList);
  if (child_name = 'specialty') Then
    list.addAll(self, 'specialty', FSpecialtyList);
  if (child_name = 'location') Then
    list.addAll(self, 'location', FLocationList);
  if (child_name = 'healthcareService') Then
    list.addAll(self, 'healthcareService', FHealthcareServiceList);
  if (child_name = 'contact') Then
    list.addAll(self, 'contact', FContactList);
  if (child_name = 'endpoint') Then
    list.addAll(self, 'endpoint', FEndpointList);
end;

procedure TFhirOrganizationAffiliation.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'identifier', 'Identifier', true, TFhirIdentifier, FIdentifierList.Link));
  oList.add(TFHIRProperty.create(self, 'active', 'boolean', false, TFhirBoolean, FActive.Link));
  oList.add(TFHIRProperty.create(self, 'period', 'Period', false, TFhirPeriod, FPeriod.Link));
  oList.add(TFHIRProperty.create(self, 'organization', 'Reference', false, TFhirReference, FOrganization.Link));
  oList.add(TFHIRProperty.create(self, 'participatingOrganization', 'Reference', false, TFhirReference, FParticipatingOrganization.Link));
  oList.add(TFHIRProperty.create(self, 'network', 'Reference', true, TFhirReference, FNetworkList.Link));
  oList.add(TFHIRProperty.create(self, 'code', 'CodeableConcept', true, TFhirCodeableConcept, FCodeList.Link));
  oList.add(TFHIRProperty.create(self, 'specialty', 'CodeableConcept', true, TFhirCodeableConcept, FSpecialtyList.Link));
  oList.add(TFHIRProperty.create(self, 'location', 'Reference', true, TFhirReference, FLocationList.Link));
  oList.add(TFHIRProperty.create(self, 'healthcareService', 'Reference', true, TFhirReference, FHealthcareServiceList.Link));
  oList.add(TFHIRProperty.create(self, 'contact', 'ExtendedContactDetail', true, TFhirExtendedContactDetail, FContactList.Link));
  oList.add(TFHIRProperty.create(self, 'endpoint', 'Reference', true, TFhirReference, FEndpointList.Link));
end;

function TFhirOrganizationAffiliation.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'identifier') then
  begin
    IdentifierList.add(propValue as TFhirIdentifier);
    result := propValue;
  end
  else if (propName = 'active') then
  begin
    ActiveElement := asBoolean(propValue);
    result := propValue;
  end
  else if (propName = 'period') then
  begin
    Period := propValue as TFhirPeriod;
    result := propValue;
  end
  else if (propName = 'organization') then
  begin
    Organization := propValue as TFhirReference;
    result := propValue;
  end
  else if (propName = 'participatingOrganization') then
  begin
    ParticipatingOrganization := propValue as TFhirReference;
    result := propValue;
  end
  else if (propName = 'network') then
  begin
    NetworkList.add(propValue as TFhirReference);
    result := propValue;
  end
  else if (propName = 'code') then
  begin
    CodeList.add(propValue as TFhirCodeableConcept);
    result := propValue;
  end
  else if (propName = 'specialty') then
  begin
    SpecialtyList.add(propValue as TFhirCodeableConcept);
    result := propValue;
  end
  else if (propName = 'location') then
  begin
    LocationList.add(propValue as TFhirReference);
    result := propValue;
  end
  else if (propName = 'healthcareService') then
  begin
    HealthcareServiceList.add(propValue as TFhirReference);
    result := propValue;
  end
  else if (propName = 'contact') then
  begin
    ContactList.add(propValue as TFhirExtendedContactDetail);
    result := propValue;
  end
  else if (propName = 'endpoint') then
  begin
    EndpointList.add(propValue as TFhirReference);
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirOrganizationAffiliation.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'identifier') then IdentifierList.insertItem(index, propValue as TFhirIdentifier)
  else if (propName = 'network') then NetworkList.insertItem(index, propValue as TFhirReference)
  else if (propName = 'code') then CodeList.insertItem(index, propValue as TFhirCodeableConcept)
  else if (propName = 'specialty') then SpecialtyList.insertItem(index, propValue as TFhirCodeableConcept)
  else if (propName = 'location') then LocationList.insertItem(index, propValue as TFhirReference)
  else if (propName = 'healthcareService') then HealthcareServiceList.insertItem(index, propValue as TFhirReference)
  else if (propName = 'contact') then ContactList.insertItem(index, propValue as TFhirExtendedContactDetail)
  else if (propName = 'endpoint') then EndpointList.insertItem(index, propValue as TFhirReference)
  else inherited;
end;

function TFhirOrganizationAffiliation.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'identifier') then result := IdentifierList.new()
  else if (propName = 'active') then result := TFhirBoolean.create()
  else if (propName = 'period') then result := TFhirPeriod.create()
  else if (propName = 'organization') then result := TFhirReference.create()
  else if (propName = 'participatingOrganization') then result := TFhirReference.create()
  else if (propName = 'network') then result := NetworkList.new()
  else if (propName = 'code') then result := CodeList.new()
  else if (propName = 'specialty') then result := SpecialtyList.new()
  else if (propName = 'location') then result := LocationList.new()
  else if (propName = 'healthcareService') then result := HealthcareServiceList.new()
  else if (propName = 'contact') then result := ContactList.new()
  else if (propName = 'endpoint') then result := EndpointList.new()
  else result := inherited createPropertyValue(propName);
end;

function TFhirOrganizationAffiliation.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'identifier') then result := 'Identifier'
  else if (propName = 'active') then result := 'boolean'
  else if (propName = 'period') then result := 'Period'
  else if (propName = 'organization') then result := 'Reference'
  else if (propName = 'participatingOrganization') then result := 'Reference'
  else if (propName = 'network') then result := 'Reference'
  else if (propName = 'code') then result := 'CodeableConcept'
  else if (propName = 'specialty') then result := 'CodeableConcept'
  else if (propName = 'location') then result := 'Reference'
  else if (propName = 'healthcareService') then result := 'Reference'
  else if (propName = 'contact') then result := 'ExtendedContactDetail'
  else if (propName = 'endpoint') then result := 'Reference'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirOrganizationAffiliation.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'identifier') then deletePropertyValue('identifier', IdentifierList, value)
  else if (propName = 'active') then ActiveElement := nil
  else if (propName = 'period') then PeriodElement := nil
  else if (propName = 'organization') then OrganizationElement := nil
  else if (propName = 'participatingOrganization') then ParticipatingOrganizationElement := nil
  else if (propName = 'network') then deletePropertyValue('network', NetworkList, value)
  else if (propName = 'code') then deletePropertyValue('code', CodeList, value)
  else if (propName = 'specialty') then deletePropertyValue('specialty', SpecialtyList, value)
  else if (propName = 'location') then deletePropertyValue('location', LocationList, value)
  else if (propName = 'healthcareService') then deletePropertyValue('healthcareService', HealthcareServiceList, value)
  else if (propName = 'contact') then deletePropertyValue('contact', ContactList, value)
  else if (propName = 'endpoint') then deletePropertyValue('endpoint', EndpointList, value)
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirOrganizationAffiliation.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'identifier') then replacePropertyValue('identifier', IdentifierList, existing, new)
  else if (propName = 'active') then ActiveElement := asBoolean(new)
  else if (propName = 'period') then PeriodElement := new as TFhirPeriod
  else if (propName = 'organization') then OrganizationElement := new as TFhirReference
  else if (propName = 'participatingOrganization') then ParticipatingOrganizationElement := new as TFhirReference
  else if (propName = 'network') then replacePropertyValue('network', NetworkList, existing, new)
  else if (propName = 'code') then replacePropertyValue('code', CodeList, existing, new)
  else if (propName = 'specialty') then replacePropertyValue('specialty', SpecialtyList, existing, new)
  else if (propName = 'location') then replacePropertyValue('location', LocationList, existing, new)
  else if (propName = 'healthcareService') then replacePropertyValue('healthcareService', HealthcareServiceList, existing, new)
  else if (propName = 'contact') then replacePropertyValue('contact', ContactList, existing, new)
  else if (propName = 'endpoint') then replacePropertyValue('endpoint', EndpointList, existing, new)
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirOrganizationAffiliation.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'identifier') then IdentifierList.move(source, destination)
  else if (propName = 'network') then NetworkList.move(source, destination)
  else if (propName = 'code') then CodeList.move(source, destination)
  else if (propName = 'specialty') then SpecialtyList.move(source, destination)
  else if (propName = 'location') then LocationList.move(source, destination)
  else if (propName = 'healthcareService') then HealthcareServiceList.move(source, destination)
  else if (propName = 'contact') then ContactList.move(source, destination)
  else if (propName = 'endpoint') then EndpointList.move(source, destination)
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirOrganizationAffiliation.fhirType : string;
begin
  result := 'OrganizationAffiliation';
end;

function TFhirOrganizationAffiliation.Link : TFhirOrganizationAffiliation;
begin
  result := TFhirOrganizationAffiliation(inherited Link);
end;

function TFhirOrganizationAffiliation.Clone : TFhirOrganizationAffiliation;
begin
  result := TFhirOrganizationAffiliation(inherited Clone);
end;

function TFhirOrganizationAffiliation.equals(other : TObject) : boolean; 
var
  o : TFhirOrganizationAffiliation;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirOrganizationAffiliation)) then
    result := false
  else
  begin
    o := TFhirOrganizationAffiliation(other);
    result := compareDeep(identifierList, o.identifierList, true) and compareDeep(activeElement, o.activeElement, true) and 
      compareDeep(periodElement, o.periodElement, true) and compareDeep(organizationElement, o.organizationElement, true) and 
      compareDeep(participatingOrganizationElement, o.participatingOrganizationElement, true) and 
      compareDeep(networkList, o.networkList, true) and compareDeep(codeList, o.codeList, true) and 
      compareDeep(specialtyList, o.specialtyList, true) and compareDeep(locationList, o.locationList, true) and 
      compareDeep(healthcareServiceList, o.healthcareServiceList, true) and compareDeep(contactList, o.contactList, true) and 
      compareDeep(endpointList, o.endpointList, true);
  end;
end;

function TFhirOrganizationAffiliation.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FidentifierList) and isEmptyProp(FActive) and isEmptyProp(FPeriod) and isEmptyProp(FOrganization) and isEmptyProp(FParticipatingOrganization) and isEmptyProp(FnetworkList) and isEmptyProp(FcodeList) and isEmptyProp(FspecialtyList) and isEmptyProp(FlocationList) and isEmptyProp(FhealthcareServiceList) and isEmptyProp(FcontactList) and isEmptyProp(FendpointList);
end;

procedure TFhirOrganizationAffiliation.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('identifier');
  fields.add('active');
  fields.add('period');
  fields.add('organization');
  fields.add('participatingOrganization');
  fields.add('network');
  fields.add('code');
  fields.add('specialty');
  fields.add('location');
  fields.add('healthcareService');
  fields.add('contact');
  fields.add('endpoint');
end;

function TFhirOrganizationAffiliation.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
  inc(result, FIdentifierList.sizeInBytes(magic));
  inc(result, FNetworkList.sizeInBytes(magic));
  inc(result, FCodeList.sizeInBytes(magic));
  inc(result, FSpecialtyList.sizeInBytes(magic));
  inc(result, FLocationList.sizeInBytes(magic));
  inc(result, FHealthcareServiceList.sizeInBytes(magic));
  inc(result, FContactList.sizeInBytes(magic));
  inc(result, FEndpointList.sizeInBytes(magic));
end;

function TFhirOrganizationAffiliation.GetIdentifierList : TFhirIdentifierList;
begin
  if FIdentifierList = nil then
    FIdentifierList := TFhirIdentifierList.Create;
  result := FIdentifierList;
end;

function TFhirOrganizationAffiliation.GetHasIdentifierList : boolean;
begin
  result := (FIdentifierList <> nil) and (FIdentifierList.count > 0);
end;

procedure TFhirOrganizationAffiliation.SetActive(value : TFhirBoolean);
begin
  FActive.free;
  FActive := value;
end;

function TFhirOrganizationAffiliation.GetActiveST : Boolean;
begin
  if FActive = nil then
    result := false
  else
    result := FActive.value;
end;

procedure TFhirOrganizationAffiliation.SetActiveST(value : Boolean);
begin
  if FActive = nil then
    FActive := TFhirBoolean.create;
  FActive.value := value
end;

procedure TFhirOrganizationAffiliation.SetPeriod(value : TFhirPeriod);
begin
  FPeriod.free;
  FPeriod := value;
end;

procedure TFhirOrganizationAffiliation.SetOrganization(value : TFhirReference);
begin
  FOrganization.free;
  FOrganization := value;
end;

procedure TFhirOrganizationAffiliation.SetParticipatingOrganization(value : TFhirReference);
begin
  FParticipatingOrganization.free;
  FParticipatingOrganization := value;
end;

function TFhirOrganizationAffiliation.GetNetworkList : TFhirReferenceList;
begin
  if FNetworkList = nil then
    FNetworkList := TFhirReferenceList.Create;
  result := FNetworkList;
end;

function TFhirOrganizationAffiliation.GetHasNetworkList : boolean;
begin
  result := (FNetworkList <> nil) and (FNetworkList.count > 0);
end;

function TFhirOrganizationAffiliation.GetCodeList : TFhirCodeableConceptList;
begin
  if FCodeList = nil then
    FCodeList := TFhirCodeableConceptList.Create;
  result := FCodeList;
end;

function TFhirOrganizationAffiliation.GetHasCodeList : boolean;
begin
  result := (FCodeList <> nil) and (FCodeList.count > 0);
end;

function TFhirOrganizationAffiliation.GetSpecialtyList : TFhirCodeableConceptList;
begin
  if FSpecialtyList = nil then
    FSpecialtyList := TFhirCodeableConceptList.Create;
  result := FSpecialtyList;
end;

function TFhirOrganizationAffiliation.GetHasSpecialtyList : boolean;
begin
  result := (FSpecialtyList <> nil) and (FSpecialtyList.count > 0);
end;

function TFhirOrganizationAffiliation.GetLocationList : TFhirReferenceList;
begin
  if FLocationList = nil then
    FLocationList := TFhirReferenceList.Create;
  result := FLocationList;
end;

function TFhirOrganizationAffiliation.GetHasLocationList : boolean;
begin
  result := (FLocationList <> nil) and (FLocationList.count > 0);
end;

function TFhirOrganizationAffiliation.GetHealthcareServiceList : TFhirReferenceList;
begin
  if FHealthcareServiceList = nil then
    FHealthcareServiceList := TFhirReferenceList.Create;
  result := FHealthcareServiceList;
end;

function TFhirOrganizationAffiliation.GetHasHealthcareServiceList : boolean;
begin
  result := (FHealthcareServiceList <> nil) and (FHealthcareServiceList.count > 0);
end;

function TFhirOrganizationAffiliation.GetContactList : TFhirExtendedContactDetailList;
begin
  if FContactList = nil then
    FContactList := TFhirExtendedContactDetailList.Create;
  result := FContactList;
end;

function TFhirOrganizationAffiliation.GetHasContactList : boolean;
begin
  result := (FContactList <> nil) and (FContactList.count > 0);
end;

function TFhirOrganizationAffiliation.GetEndpointList : TFhirReferenceList;
begin
  if FEndpointList = nil then
    FEndpointList := TFhirReferenceList.Create;
  result := FEndpointList;
end;

function TFhirOrganizationAffiliation.GetHasEndpointList : boolean;
begin
  result := (FEndpointList <> nil) and (FEndpointList.count > 0);
end;

{ TFhirOrganizationAffiliationListEnumerator }

constructor TFhirOrganizationAffiliationListEnumerator.Create(list : TFhirOrganizationAffiliationList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirOrganizationAffiliationListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirOrganizationAffiliationListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirOrganizationAffiliationListEnumerator.GetCurrent : TFhirOrganizationAffiliation;
begin
  Result := FList[FIndex];
end;

function TFhirOrganizationAffiliationListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirOrganizationAffiliationList }

function TFhirOrganizationAffiliationList.AddItem(value: TFhirOrganizationAffiliation): TFhirOrganizationAffiliation;
begin
  assert(value.ClassName = 'TFhirOrganizationAffiliation', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirOrganizationAffiliation');
  add(value);
  result := value;
end;

function TFhirOrganizationAffiliationList.Append: TFhirOrganizationAffiliation;
begin
  result := TFhirOrganizationAffiliation.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirOrganizationAffiliationList.ClearItems;
begin
  Clear;
end;

function TFhirOrganizationAffiliationList.GetEnumerator : TFhirOrganizationAffiliationListEnumerator;
begin
  result := TFhirOrganizationAffiliationListEnumerator.Create(self.link);
end;

function TFhirOrganizationAffiliationList.Clone: TFhirOrganizationAffiliationList;
begin
  result := TFhirOrganizationAffiliationList(inherited Clone);
end;

function TFhirOrganizationAffiliationList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirOrganizationAffiliationList.GetItemN(index: Integer): TFhirOrganizationAffiliation;
begin
  result := TFhirOrganizationAffiliation(ObjectByIndex[index]);
end;

function TFhirOrganizationAffiliationList.ItemClass: TFslObjectClass;
begin
  result := TFhirOrganizationAffiliation;
end;
function TFhirOrganizationAffiliationList.IndexOf(value: TFhirOrganizationAffiliation): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirOrganizationAffiliationList.Insert(index: Integer): TFhirOrganizationAffiliation;
begin
  result := TFhirOrganizationAffiliation.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirOrganizationAffiliationList.InsertItem(index: Integer; value: TFhirOrganizationAffiliation);
begin
  assert(value is TFhirOrganizationAffiliation);
  Inherited Insert(index, value);
end;

function TFhirOrganizationAffiliationList.Item(index: Integer): TFhirOrganizationAffiliation;
begin
  result := TFhirOrganizationAffiliation(ObjectByIndex[index]);
end;

function TFhirOrganizationAffiliationList.Link: TFhirOrganizationAffiliationList;
begin
  result := TFhirOrganizationAffiliationList(inherited Link);
end;

procedure TFhirOrganizationAffiliationList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirOrganizationAffiliationList.SetItemByIndex(index: Integer; value: TFhirOrganizationAffiliation);
begin
  assert(value is TFhirOrganizationAffiliation);
  FhirOrganizationAffiliations[index] := value;
end;

procedure TFhirOrganizationAffiliationList.SetItemN(index: Integer; value: TFhirOrganizationAffiliation);
begin
  assert(value is TFhirOrganizationAffiliation);
  ObjectByIndex[index] := value;
end;

{$ENDIF FHIR_ORGANIZATIONAFFILIATION}
{$IFDEF FHIR_PATIENT}
{ TFhirPatientContact }

constructor TFhirPatientContact.Create;
begin
  inherited;
end;

destructor TFhirPatientContact.Destroy;
begin
  FRelationshipList.Free;
  FName.free;
  FTelecomList.Free;
  FAddress.free;
  FGender.free;
  FOrganization.free;
  FPeriod.free;
  inherited;
end;

procedure TFhirPatientContact.Assign(oSource : TFslObject);
begin
  inherited;
  if (TFhirPatientContact(oSource).FRelationshipList = nil) then
  begin
    FRelationshipList.free;
    FRelationshipList := nil;
  end
  else
  begin
    if FRelationshipList = nil then
      FRelationshipList := TFhirCodeableConceptList.Create;
    FRelationshipList.Assign(TFhirPatientContact(oSource).FRelationshipList);
  end;
  name := TFhirPatientContact(oSource).name.Clone;
  if (TFhirPatientContact(oSource).FTelecomList = nil) then
  begin
    FTelecomList.free;
    FTelecomList := nil;
  end
  else
  begin
    if FTelecomList = nil then
      FTelecomList := TFhirContactPointList.Create;
    FTelecomList.Assign(TFhirPatientContact(oSource).FTelecomList);
  end;
  address := TFhirPatientContact(oSource).address.Clone;
  genderElement := TFhirPatientContact(oSource).genderElement.Clone;
  organization := TFhirPatientContact(oSource).organization.Clone;
  period := TFhirPatientContact(oSource).period.Clone;
end;

procedure TFhirPatientContact.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'relationship') Then
    list.addAll(self, 'relationship', FRelationshipList);
  if (child_name = 'name') Then
     list.add(self.link, 'name', FName.Link);
  if (child_name = 'telecom') Then
    list.addAll(self, 'telecom', FTelecomList);
  if (child_name = 'address') Then
     list.add(self.link, 'address', FAddress.Link);
  if (child_name = 'gender') Then
     list.add(self.link, 'gender', FGender.Link);
  if (child_name = 'organization') Then
     list.add(self.link, 'organization', FOrganization.Link);
  if (child_name = 'period') Then
     list.add(self.link, 'period', FPeriod.Link);
end;

procedure TFhirPatientContact.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'relationship', 'CodeableConcept', true, TFhirCodeableConcept, FRelationshipList.Link));
  oList.add(TFHIRProperty.create(self, 'name', 'HumanName', false, TFhirHumanName, FName.Link));
  oList.add(TFHIRProperty.create(self, 'telecom', 'ContactPoint', true, TFhirContactPoint, FTelecomList.Link));
  oList.add(TFHIRProperty.create(self, 'address', 'Address', false, TFhirAddress, FAddress.Link));
  oList.add(TFHIRProperty.create(self, 'gender', 'code', false, TFhirEnum, FGender.Link));
  oList.add(TFHIRProperty.create(self, 'organization', 'Reference', false, TFhirReference, FOrganization.Link));
  oList.add(TFHIRProperty.create(self, 'period', 'Period', false, TFhirPeriod, FPeriod.Link));
end;

function TFhirPatientContact.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'relationship') then
  begin
    RelationshipList.add(propValue as TFhirCodeableConcept);
    result := propValue;
  end
  else if (propName = 'name') then
  begin
    Name := propValue as TFhirHumanName;
    result := propValue;
  end
  else if (propName = 'telecom') then
  begin
    TelecomList.add(propValue as TFhirContactPoint);
    result := propValue;
  end
  else if (propName = 'address') then
  begin
    Address := propValue as TFhirAddress;
    result := propValue;
  end
  else if (propName = 'gender') then
  begin
    GenderElement := asEnum(SYSTEMS_TFhirAdministrativeGenderEnum, CODES_TFhirAdministrativeGenderEnum, propValue);
    result := propValue;
  end
  else if (propName = 'organization') then
  begin
    Organization := propValue as TFhirReference;
    result := propValue;
  end
  else if (propName = 'period') then
  begin
    Period := propValue as TFhirPeriod;
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirPatientContact.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'relationship') then RelationshipList.insertItem(index, propValue as TFhirCodeableConcept)
  else if (propName = 'telecom') then TelecomList.insertItem(index, propValue as TFhirContactPoint)
  else inherited;
end;

function TFhirPatientContact.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'relationship') then result := RelationshipList.new()
  else if (propName = 'name') then result := TFhirHumanName.create()
  else if (propName = 'telecom') then result := TelecomList.new()
  else if (propName = 'address') then result := TFhirAddress.create()
  else if (propName = 'gender') then result := TFhirEnum.create(SYSTEMS_TFhirAdministrativeGenderEnum[AdministrativeGenderNull], CODES_TFhirAdministrativeGenderEnum[AdministrativeGenderNull]) 
  else if (propName = 'organization') then result := TFhirReference.create()
  else if (propName = 'period') then result := TFhirPeriod.create()
  else result := inherited createPropertyValue(propName);
end;

function TFhirPatientContact.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'relationship') then result := 'CodeableConcept'
  else if (propName = 'name') then result := 'HumanName'
  else if (propName = 'telecom') then result := 'ContactPoint'
  else if (propName = 'address') then result := 'Address'
  else if (propName = 'gender') then result := 'code'
  else if (propName = 'organization') then result := 'Reference'
  else if (propName = 'period') then result := 'Period'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirPatientContact.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'relationship') then deletePropertyValue('relationship', RelationshipList, value)
  else if (propName = 'name') then NameElement := nil
  else if (propName = 'telecom') then deletePropertyValue('telecom', TelecomList, value)
  else if (propName = 'address') then AddressElement := nil
  else if (propName = 'gender') then GenderElement := nil
  else if (propName = 'organization') then OrganizationElement := nil
  else if (propName = 'period') then PeriodElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirPatientContact.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'relationship') then replacePropertyValue('relationship', RelationshipList, existing, new)
  else if (propName = 'name') then NameElement := new as TFhirHumanName
  else if (propName = 'telecom') then replacePropertyValue('telecom', TelecomList, existing, new)
  else if (propName = 'address') then AddressElement := new as TFhirAddress
  else if (propName = 'gender') then GenderElement := asEnum(SYSTEMS_TFhirAdministrativeGenderEnum, CODES_TFhirAdministrativeGenderEnum, new)
  else if (propName = 'organization') then OrganizationElement := new as TFhirReference
  else if (propName = 'period') then PeriodElement := new as TFhirPeriod
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirPatientContact.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'relationship') then RelationshipList.move(source, destination)
  else if (propName = 'telecom') then TelecomList.move(source, destination)
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirPatientContact.fhirType : string;
begin
  result := 'Patient.contact';
end;

function TFhirPatientContact.Link : TFhirPatientContact;
begin
  result := TFhirPatientContact(inherited Link);
end;

function TFhirPatientContact.Clone : TFhirPatientContact;
begin
  result := TFhirPatientContact(inherited Clone);
end;

function TFhirPatientContact.equals(other : TObject) : boolean; 
var
  o : TFhirPatientContact;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirPatientContact)) then
    result := false
  else
  begin
    o := TFhirPatientContact(other);
    result := compareDeep(relationshipList, o.relationshipList, true) and compareDeep(nameElement, o.nameElement, true) and 
      compareDeep(telecomList, o.telecomList, true) and compareDeep(addressElement, o.addressElement, true) and 
      compareDeep(genderElement, o.genderElement, true) and compareDeep(organizationElement, o.organizationElement, true) and 
      compareDeep(periodElement, o.periodElement, true);
  end;
end;

function TFhirPatientContact.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FrelationshipList) and isEmptyProp(FName) and isEmptyProp(FtelecomList) and isEmptyProp(FAddress) and isEmptyProp(FGender) and isEmptyProp(FOrganization) and isEmptyProp(FPeriod);
end;

procedure TFhirPatientContact.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('relationship');
  fields.add('name');
  fields.add('telecom');
  fields.add('address');
  fields.add('gender');
  fields.add('organization');
  fields.add('period');
end;

function TFhirPatientContact.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
  inc(result, FRelationshipList.sizeInBytes(magic));
  inc(result, FTelecomList.sizeInBytes(magic));
end;

function TFhirPatientContact.GetRelationshipList : TFhirCodeableConceptList;
begin
  if FRelationshipList = nil then
    FRelationshipList := TFhirCodeableConceptList.Create;
  result := FRelationshipList;
end;

function TFhirPatientContact.GetHasRelationshipList : boolean;
begin
  result := (FRelationshipList <> nil) and (FRelationshipList.count > 0);
end;

procedure TFhirPatientContact.SetName(value : TFhirHumanName);
begin
  FName.free;
  FName := value;
end;

function TFhirPatientContact.GetTelecomList : TFhirContactPointList;
begin
  if FTelecomList = nil then
    FTelecomList := TFhirContactPointList.Create;
  result := FTelecomList;
end;

function TFhirPatientContact.GetHasTelecomList : boolean;
begin
  result := (FTelecomList <> nil) and (FTelecomList.count > 0);
end;

procedure TFhirPatientContact.SetAddress(value : TFhirAddress);
begin
  FAddress.free;
  FAddress := value;
end;

procedure TFhirPatientContact.SetGender(value : TFhirEnum);
begin
  FGender.free;
  FGender := value;
end;

function TFhirPatientContact.GetGenderST : TFhirAdministrativeGenderEnum;
begin
  if FGender = nil then
    result := TFhirAdministrativeGenderEnum(0)
  else
    result := TFhirAdministrativeGenderEnum(StringArrayIndexOfSensitive(CODES_TFhirAdministrativeGenderEnum, FGender.value));
end;

procedure TFhirPatientContact.SetGenderST(value : TFhirAdministrativeGenderEnum);
begin
  if ord(value) = 0 then
    GenderElement := nil
  else
    GenderElement := TFhirEnum.create(SYSTEMS_TFhirAdministrativeGenderEnum[value], CODES_TFhirAdministrativeGenderEnum[value]);
end;

procedure TFhirPatientContact.SetOrganization(value : TFhirReference);
begin
  FOrganization.free;
  FOrganization := value;
end;

procedure TFhirPatientContact.SetPeriod(value : TFhirPeriod);
begin
  FPeriod.free;
  FPeriod := value;
end;

{ TFhirPatientContactListEnumerator }

constructor TFhirPatientContactListEnumerator.Create(list : TFhirPatientContactList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirPatientContactListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirPatientContactListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirPatientContactListEnumerator.GetCurrent : TFhirPatientContact;
begin
  Result := FList[FIndex];
end;

function TFhirPatientContactListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirPatientContactList }

function TFhirPatientContactList.AddItem(value: TFhirPatientContact): TFhirPatientContact;
begin
  assert(value.ClassName = 'TFhirPatientContact', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirPatientContact');
  add(value);
  result := value;
end;

function TFhirPatientContactList.Append: TFhirPatientContact;
begin
  result := TFhirPatientContact.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirPatientContactList.ClearItems;
begin
  Clear;
end;

function TFhirPatientContactList.GetEnumerator : TFhirPatientContactListEnumerator;
begin
  result := TFhirPatientContactListEnumerator.Create(self.link);
end;

function TFhirPatientContactList.Clone: TFhirPatientContactList;
begin
  result := TFhirPatientContactList(inherited Clone);
end;

function TFhirPatientContactList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirPatientContactList.GetItemN(index: Integer): TFhirPatientContact;
begin
  result := TFhirPatientContact(ObjectByIndex[index]);
end;

function TFhirPatientContactList.ItemClass: TFslObjectClass;
begin
  result := TFhirPatientContact;
end;
function TFhirPatientContactList.IndexOf(value: TFhirPatientContact): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirPatientContactList.Insert(index: Integer): TFhirPatientContact;
begin
  result := TFhirPatientContact.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirPatientContactList.InsertItem(index: Integer; value: TFhirPatientContact);
begin
  assert(value is TFhirPatientContact);
  Inherited Insert(index, value);
end;

function TFhirPatientContactList.Item(index: Integer): TFhirPatientContact;
begin
  result := TFhirPatientContact(ObjectByIndex[index]);
end;

function TFhirPatientContactList.Link: TFhirPatientContactList;
begin
  result := TFhirPatientContactList(inherited Link);
end;

procedure TFhirPatientContactList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirPatientContactList.SetItemByIndex(index: Integer; value: TFhirPatientContact);
begin
  assert(value is TFhirPatientContact);
  FhirPatientContacts[index] := value;
end;

procedure TFhirPatientContactList.SetItemN(index: Integer; value: TFhirPatientContact);
begin
  assert(value is TFhirPatientContact);
  ObjectByIndex[index] := value;
end;

{ TFhirPatientCommunication }

constructor TFhirPatientCommunication.Create;
begin
  inherited;
end;

destructor TFhirPatientCommunication.Destroy;
begin
  FLanguage.free;
  FPreferred.free;
  inherited;
end;

procedure TFhirPatientCommunication.Assign(oSource : TFslObject);
begin
  inherited;
  language := TFhirPatientCommunication(oSource).language.Clone;
  preferredElement := TFhirPatientCommunication(oSource).preferredElement.Clone;
end;

procedure TFhirPatientCommunication.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'language') Then
     list.add(self.link, 'language', FLanguage.Link);
  if (child_name = 'preferred') Then
     list.add(self.link, 'preferred', FPreferred.Link);
end;

procedure TFhirPatientCommunication.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'language', 'CodeableConcept', false, TFhirCodeableConcept, FLanguage.Link));
  oList.add(TFHIRProperty.create(self, 'preferred', 'boolean', false, TFhirBoolean, FPreferred.Link));
end;

function TFhirPatientCommunication.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'language') then
  begin
    Language := propValue as TFhirCodeableConcept;
    result := propValue;
  end
  else if (propName = 'preferred') then
  begin
    PreferredElement := asBoolean(propValue);
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirPatientCommunication.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirPatientCommunication.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'language') then result := TFhirCodeableConcept.create()
  else if (propName = 'preferred') then result := TFhirBoolean.create()
  else result := inherited createPropertyValue(propName);
end;

function TFhirPatientCommunication.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'language') then result := 'CodeableConcept'
  else if (propName = 'preferred') then result := 'boolean'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirPatientCommunication.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'language') then LanguageElement := nil
  else if (propName = 'preferred') then PreferredElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirPatientCommunication.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'language') then LanguageElement := new as TFhirCodeableConcept
  else if (propName = 'preferred') then PreferredElement := asBoolean(new)
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirPatientCommunication.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirPatientCommunication.fhirType : string;
begin
  result := 'Patient.communication';
end;

function TFhirPatientCommunication.Link : TFhirPatientCommunication;
begin
  result := TFhirPatientCommunication(inherited Link);
end;

function TFhirPatientCommunication.Clone : TFhirPatientCommunication;
begin
  result := TFhirPatientCommunication(inherited Clone);
end;

function TFhirPatientCommunication.equals(other : TObject) : boolean; 
var
  o : TFhirPatientCommunication;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirPatientCommunication)) then
    result := false
  else
  begin
    o := TFhirPatientCommunication(other);
    result := compareDeep(languageElement, o.languageElement, true) and compareDeep(preferredElement, o.preferredElement, true);
  end;
end;

function TFhirPatientCommunication.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FLanguage) and isEmptyProp(FPreferred);
end;

procedure TFhirPatientCommunication.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('language');
  fields.add('preferred');
end;

function TFhirPatientCommunication.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
end;

procedure TFhirPatientCommunication.SetLanguage(value : TFhirCodeableConcept);
begin
  FLanguage.free;
  FLanguage := value;
end;

procedure TFhirPatientCommunication.SetPreferred(value : TFhirBoolean);
begin
  FPreferred.free;
  FPreferred := value;
end;

function TFhirPatientCommunication.GetPreferredST : Boolean;
begin
  if FPreferred = nil then
    result := false
  else
    result := FPreferred.value;
end;

procedure TFhirPatientCommunication.SetPreferredST(value : Boolean);
begin
  if FPreferred = nil then
    FPreferred := TFhirBoolean.create;
  FPreferred.value := value
end;

{ TFhirPatientCommunicationListEnumerator }

constructor TFhirPatientCommunicationListEnumerator.Create(list : TFhirPatientCommunicationList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirPatientCommunicationListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirPatientCommunicationListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirPatientCommunicationListEnumerator.GetCurrent : TFhirPatientCommunication;
begin
  Result := FList[FIndex];
end;

function TFhirPatientCommunicationListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirPatientCommunicationList }

function TFhirPatientCommunicationList.AddItem(value: TFhirPatientCommunication): TFhirPatientCommunication;
begin
  assert(value.ClassName = 'TFhirPatientCommunication', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirPatientCommunication');
  add(value);
  result := value;
end;

function TFhirPatientCommunicationList.Append: TFhirPatientCommunication;
begin
  result := TFhirPatientCommunication.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirPatientCommunicationList.ClearItems;
begin
  Clear;
end;

function TFhirPatientCommunicationList.GetEnumerator : TFhirPatientCommunicationListEnumerator;
begin
  result := TFhirPatientCommunicationListEnumerator.Create(self.link);
end;

function TFhirPatientCommunicationList.Clone: TFhirPatientCommunicationList;
begin
  result := TFhirPatientCommunicationList(inherited Clone);
end;

function TFhirPatientCommunicationList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirPatientCommunicationList.GetItemN(index: Integer): TFhirPatientCommunication;
begin
  result := TFhirPatientCommunication(ObjectByIndex[index]);
end;

function TFhirPatientCommunicationList.ItemClass: TFslObjectClass;
begin
  result := TFhirPatientCommunication;
end;
function TFhirPatientCommunicationList.IndexOf(value: TFhirPatientCommunication): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirPatientCommunicationList.Insert(index: Integer): TFhirPatientCommunication;
begin
  result := TFhirPatientCommunication.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirPatientCommunicationList.InsertItem(index: Integer; value: TFhirPatientCommunication);
begin
  assert(value is TFhirPatientCommunication);
  Inherited Insert(index, value);
end;

function TFhirPatientCommunicationList.Item(index: Integer): TFhirPatientCommunication;
begin
  result := TFhirPatientCommunication(ObjectByIndex[index]);
end;

function TFhirPatientCommunicationList.Link: TFhirPatientCommunicationList;
begin
  result := TFhirPatientCommunicationList(inherited Link);
end;

procedure TFhirPatientCommunicationList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirPatientCommunicationList.SetItemByIndex(index: Integer; value: TFhirPatientCommunication);
begin
  assert(value is TFhirPatientCommunication);
  FhirPatientCommunications[index] := value;
end;

procedure TFhirPatientCommunicationList.SetItemN(index: Integer; value: TFhirPatientCommunication);
begin
  assert(value is TFhirPatientCommunication);
  ObjectByIndex[index] := value;
end;

{ TFhirPatientLink }

constructor TFhirPatientLink.Create;
begin
  inherited;
end;

destructor TFhirPatientLink.Destroy;
begin
  FOther.free;
  FType_.free;
  inherited;
end;

procedure TFhirPatientLink.Assign(oSource : TFslObject);
begin
  inherited;
  other := TFhirPatientLink(oSource).other.Clone;
  type_Element := TFhirPatientLink(oSource).type_Element.Clone;
end;

procedure TFhirPatientLink.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'other') Then
     list.add(self.link, 'other', FOther.Link);
  if (child_name = 'type') Then
     list.add(self.link, 'type', FType_.Link);
end;

procedure TFhirPatientLink.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'other', 'Reference', false, TFhirReference, FOther.Link));
  oList.add(TFHIRProperty.create(self, 'type', 'code', false, TFhirEnum, FType_.Link));
end;

function TFhirPatientLink.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'other') then
  begin
    Other := propValue as TFhirReference;
    result := propValue;
  end
  else if (propName = 'type') then
  begin
    Type_Element := asEnum(SYSTEMS_TFhirLinkTypeEnum, CODES_TFhirLinkTypeEnum, propValue);
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirPatientLink.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirPatientLink.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'other') then result := TFhirReference.create()
  else if (propName = 'type') then result := TFhirEnum.create(SYSTEMS_TFhirLinkTypeEnum[LinkTypeNull], CODES_TFhirLinkTypeEnum[LinkTypeNull]) 
  else result := inherited createPropertyValue(propName);
end;

function TFhirPatientLink.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'other') then result := 'Reference'
  else if (propName = 'type') then result := 'code'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirPatientLink.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'other') then OtherElement := nil
  else if (propName = 'type') then Type_Element := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirPatientLink.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'other') then OtherElement := new as TFhirReference
  else if (propName = 'type') then Type_Element := asEnum(SYSTEMS_TFhirLinkTypeEnum, CODES_TFhirLinkTypeEnum, new)
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirPatientLink.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirPatientLink.fhirType : string;
begin
  result := 'Patient.link';
end;

function TFhirPatientLink.Link : TFhirPatientLink;
begin
  result := TFhirPatientLink(inherited Link);
end;

function TFhirPatientLink.Clone : TFhirPatientLink;
begin
  result := TFhirPatientLink(inherited Clone);
end;

function TFhirPatientLink.equals(other : TObject) : boolean; 
var
  o : TFhirPatientLink;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirPatientLink)) then
    result := false
  else
  begin
    o := TFhirPatientLink(other);
    result := compareDeep(otherElement, o.otherElement, true) and compareDeep(type_Element, o.type_Element, true);
  end;
end;

function TFhirPatientLink.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FOther) and isEmptyProp(FType_);
end;

procedure TFhirPatientLink.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('other');
  fields.add('type');
end;

function TFhirPatientLink.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
end;

procedure TFhirPatientLink.SetOther(value : TFhirReference);
begin
  FOther.free;
  FOther := value;
end;

procedure TFhirPatientLink.SetType_(value : TFhirEnum);
begin
  FType_.free;
  FType_ := value;
end;

function TFhirPatientLink.GetType_ST : TFhirLinkTypeEnum;
begin
  if FType_ = nil then
    result := TFhirLinkTypeEnum(0)
  else
    result := TFhirLinkTypeEnum(StringArrayIndexOfSensitive(CODES_TFhirLinkTypeEnum, FType_.value));
end;

procedure TFhirPatientLink.SetType_ST(value : TFhirLinkTypeEnum);
begin
  if ord(value) = 0 then
    Type_Element := nil
  else
    Type_Element := TFhirEnum.create(SYSTEMS_TFhirLinkTypeEnum[value], CODES_TFhirLinkTypeEnum[value]);
end;

{ TFhirPatientLinkListEnumerator }

constructor TFhirPatientLinkListEnumerator.Create(list : TFhirPatientLinkList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirPatientLinkListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirPatientLinkListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirPatientLinkListEnumerator.GetCurrent : TFhirPatientLink;
begin
  Result := FList[FIndex];
end;

function TFhirPatientLinkListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirPatientLinkList }

function TFhirPatientLinkList.AddItem(value: TFhirPatientLink): TFhirPatientLink;
begin
  assert(value.ClassName = 'TFhirPatientLink', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirPatientLink');
  add(value);
  result := value;
end;

function TFhirPatientLinkList.Append: TFhirPatientLink;
begin
  result := TFhirPatientLink.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirPatientLinkList.ClearItems;
begin
  Clear;
end;

function TFhirPatientLinkList.GetEnumerator : TFhirPatientLinkListEnumerator;
begin
  result := TFhirPatientLinkListEnumerator.Create(self.link);
end;

function TFhirPatientLinkList.Clone: TFhirPatientLinkList;
begin
  result := TFhirPatientLinkList(inherited Clone);
end;

function TFhirPatientLinkList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirPatientLinkList.GetItemN(index: Integer): TFhirPatientLink;
begin
  result := TFhirPatientLink(ObjectByIndex[index]);
end;

function TFhirPatientLinkList.ItemClass: TFslObjectClass;
begin
  result := TFhirPatientLink;
end;
function TFhirPatientLinkList.IndexOf(value: TFhirPatientLink): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirPatientLinkList.Insert(index: Integer): TFhirPatientLink;
begin
  result := TFhirPatientLink.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirPatientLinkList.InsertItem(index: Integer; value: TFhirPatientLink);
begin
  assert(value is TFhirPatientLink);
  Inherited Insert(index, value);
end;

function TFhirPatientLinkList.Item(index: Integer): TFhirPatientLink;
begin
  result := TFhirPatientLink(ObjectByIndex[index]);
end;

function TFhirPatientLinkList.Link: TFhirPatientLinkList;
begin
  result := TFhirPatientLinkList(inherited Link);
end;

procedure TFhirPatientLinkList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirPatientLinkList.SetItemByIndex(index: Integer; value: TFhirPatientLink);
begin
  assert(value is TFhirPatientLink);
  FhirPatientLinks[index] := value;
end;

procedure TFhirPatientLinkList.SetItemN(index: Integer; value: TFhirPatientLink);
begin
  assert(value is TFhirPatientLink);
  ObjectByIndex[index] := value;
end;

{ TFhirPatient }

constructor TFhirPatient.Create;
begin
  inherited;
end;

destructor TFhirPatient.Destroy;
begin
  FIdentifierList.Free;
  FActive.free;
  FNameList.Free;
  FTelecomList.Free;
  FGender.free;
  FBirthDate.free;
  FDeceased.free;
  FAddressList.Free;
  FMaritalStatus.free;
  FMultipleBirth.free;
  FPhotoList.Free;
  FContactList.Free;
  FCommunicationList.Free;
  FGeneralPractitionerList.Free;
  FManagingOrganization.free;
  FLink_List.Free;
  inherited;
end;

procedure TFhirPatient.Assign(oSource : TFslObject);
begin
  inherited;
  if (TFhirPatient(oSource).FIdentifierList = nil) then
  begin
    FIdentifierList.free;
    FIdentifierList := nil;
  end
  else
  begin
    if FIdentifierList = nil then
      FIdentifierList := TFhirIdentifierList.Create;
    FIdentifierList.Assign(TFhirPatient(oSource).FIdentifierList);
  end;
  activeElement := TFhirPatient(oSource).activeElement.Clone;
  if (TFhirPatient(oSource).FNameList = nil) then
  begin
    FNameList.free;
    FNameList := nil;
  end
  else
  begin
    if FNameList = nil then
      FNameList := TFhirHumanNameList.Create;
    FNameList.Assign(TFhirPatient(oSource).FNameList);
  end;
  if (TFhirPatient(oSource).FTelecomList = nil) then
  begin
    FTelecomList.free;
    FTelecomList := nil;
  end
  else
  begin
    if FTelecomList = nil then
      FTelecomList := TFhirContactPointList.Create;
    FTelecomList.Assign(TFhirPatient(oSource).FTelecomList);
  end;
  genderElement := TFhirPatient(oSource).genderElement.Clone;
  birthDateElement := TFhirPatient(oSource).birthDateElement.Clone;
  deceased := TFhirPatient(oSource).deceased.Clone;
  if (TFhirPatient(oSource).FAddressList = nil) then
  begin
    FAddressList.free;
    FAddressList := nil;
  end
  else
  begin
    if FAddressList = nil then
      FAddressList := TFhirAddressList.Create;
    FAddressList.Assign(TFhirPatient(oSource).FAddressList);
  end;
  maritalStatus := TFhirPatient(oSource).maritalStatus.Clone;
  multipleBirth := TFhirPatient(oSource).multipleBirth.Clone;
  if (TFhirPatient(oSource).FPhotoList = nil) then
  begin
    FPhotoList.free;
    FPhotoList := nil;
  end
  else
  begin
    if FPhotoList = nil then
      FPhotoList := TFhirAttachmentList.Create;
    FPhotoList.Assign(TFhirPatient(oSource).FPhotoList);
  end;
  if (TFhirPatient(oSource).FContactList = nil) then
  begin
    FContactList.free;
    FContactList := nil;
  end
  else
  begin
    if FContactList = nil then
      FContactList := TFhirPatientContactList.Create;
    FContactList.Assign(TFhirPatient(oSource).FContactList);
  end;
  if (TFhirPatient(oSource).FCommunicationList = nil) then
  begin
    FCommunicationList.free;
    FCommunicationList := nil;
  end
  else
  begin
    if FCommunicationList = nil then
      FCommunicationList := TFhirPatientCommunicationList.Create;
    FCommunicationList.Assign(TFhirPatient(oSource).FCommunicationList);
  end;
  if (TFhirPatient(oSource).FGeneralPractitionerList = nil) then
  begin
    FGeneralPractitionerList.free;
    FGeneralPractitionerList := nil;
  end
  else
  begin
    if FGeneralPractitionerList = nil then
      FGeneralPractitionerList := TFhirReferenceList.Create;
    FGeneralPractitionerList.Assign(TFhirPatient(oSource).FGeneralPractitionerList);
  end;
  managingOrganization := TFhirPatient(oSource).managingOrganization.Clone;
  if (TFhirPatient(oSource).FLink_List = nil) then
  begin
    FLink_List.free;
    FLink_List := nil;
  end
  else
  begin
    if FLink_List = nil then
      FLink_List := TFhirPatientLinkList.Create;
    FLink_List.Assign(TFhirPatient(oSource).FLink_List);
  end;
end;

function TFhirPatient.GetResourceType : TFhirResourceType;
begin
  result := frtPatient;
end;

procedure TFhirPatient.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'identifier') Then
    list.addAll(self, 'identifier', FIdentifierList);
  if (child_name = 'active') Then
     list.add(self.link, 'active', FActive.Link);
  if (child_name = 'name') Then
    list.addAll(self, 'name', FNameList);
  if (child_name = 'telecom') Then
    list.addAll(self, 'telecom', FTelecomList);
  if (child_name = 'gender') Then
     list.add(self.link, 'gender', FGender.Link);
  if (child_name = 'birthDate') Then
     list.add(self.link, 'birthDate', FBirthDate.Link);
  if (child_name = 'deceased[x]') or (child_name = 'deceased') Then
     list.add(self.link, 'deceased[x]', FDeceased.Link);
  if (child_name = 'address') Then
    list.addAll(self, 'address', FAddressList);
  if (child_name = 'maritalStatus') Then
     list.add(self.link, 'maritalStatus', FMaritalStatus.Link);
  if (child_name = 'multipleBirth[x]') or (child_name = 'multipleBirth') Then
     list.add(self.link, 'multipleBirth[x]', FMultipleBirth.Link);
  if (child_name = 'photo') Then
    list.addAll(self, 'photo', FPhotoList);
  if (child_name = 'contact') Then
    list.addAll(self, 'contact', FContactList);
  if (child_name = 'communication') Then
    list.addAll(self, 'communication', FCommunicationList);
  if (child_name = 'generalPractitioner') Then
    list.addAll(self, 'generalPractitioner', FGeneralPractitionerList);
  if (child_name = 'managingOrganization') Then
     list.add(self.link, 'managingOrganization', FManagingOrganization.Link);
  if (child_name = 'link') Then
    list.addAll(self, 'link', FLink_List);
end;

procedure TFhirPatient.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'identifier', 'Identifier', true, TFhirIdentifier, FIdentifierList.Link));
  oList.add(TFHIRProperty.create(self, 'active', 'boolean', false, TFhirBoolean, FActive.Link));
  oList.add(TFHIRProperty.create(self, 'name', 'HumanName', true, TFhirHumanName, FNameList.Link));
  oList.add(TFHIRProperty.create(self, 'telecom', 'ContactPoint', true, TFhirContactPoint, FTelecomList.Link));
  oList.add(TFHIRProperty.create(self, 'gender', 'code', false, TFhirEnum, FGender.Link));
  oList.add(TFHIRProperty.create(self, 'birthDate', 'date', false, TFhirDate, FBirthDate.Link));
  oList.add(TFHIRProperty.create(self, 'deceased[x]', 'boolean|dateTime', false, TFhirDataType, FDeceased.Link));
  oList.add(TFHIRProperty.create(self, 'address', 'Address', true, TFhirAddress, FAddressList.Link));
  oList.add(TFHIRProperty.create(self, 'maritalStatus', 'CodeableConcept', false, TFhirCodeableConcept, FMaritalStatus.Link));
  oList.add(TFHIRProperty.create(self, 'multipleBirth[x]', 'boolean|integer', false, TFhirDataType, FMultipleBirth.Link));
  oList.add(TFHIRProperty.create(self, 'photo', 'Attachment', true, TFhirAttachment, FPhotoList.Link));
  oList.add(TFHIRProperty.create(self, 'contact', 'BackboneElement', true, TFhirPatientContact, FContactList.Link));
  oList.add(TFHIRProperty.create(self, 'communication', 'BackboneElement', true, TFhirPatientCommunication, FCommunicationList.Link));
  oList.add(TFHIRProperty.create(self, 'generalPractitioner', 'Reference', true, TFhirReference, FGeneralPractitionerList.Link));
  oList.add(TFHIRProperty.create(self, 'managingOrganization', 'Reference', false, TFhirReference, FManagingOrganization.Link));
  oList.add(TFHIRProperty.create(self, 'link', 'BackboneElement', true, TFhirPatientLink, FLink_List.Link));
end;

function TFhirPatient.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'identifier') then
  begin
    IdentifierList.add(propValue as TFhirIdentifier);
    result := propValue;
  end
  else if (propName = 'active') then
  begin
    ActiveElement := asBoolean(propValue);
    result := propValue;
  end
  else if (propName = 'name') then
  begin
    NameList.add(propValue as TFhirHumanName);
    result := propValue;
  end
  else if (propName = 'telecom') then
  begin
    TelecomList.add(propValue as TFhirContactPoint);
    result := propValue;
  end
  else if (propName = 'gender') then
  begin
    GenderElement := asEnum(SYSTEMS_TFhirAdministrativeGenderEnum, CODES_TFhirAdministrativeGenderEnum, propValue);
    result := propValue;
  end
  else if (propName = 'birthDate') then
  begin
    BirthDateElement := asDate(propValue);
    result := propValue;
  end
  else if (isMatchingName(propName, 'deceased', ['Boolean', 'DateTime'])) then
  begin
    Deceased := propValue as TFhirDataType;
    result := propValue;
  end
  else if (propName = 'address') then
  begin
    AddressList.add(propValue as TFhirAddress);
    result := propValue;
  end
  else if (propName = 'maritalStatus') then
  begin
    MaritalStatus := propValue as TFhirCodeableConcept;
    result := propValue;
  end
  else if (isMatchingName(propName, 'multipleBirth', ['Boolean', 'Integer'])) then
  begin
    MultipleBirth := propValue as TFhirDataType;
    result := propValue;
  end
  else if (propName = 'photo') then
  begin
    PhotoList.add(propValue as TFhirAttachment);
    result := propValue;
  end
  else if (propName = 'contact') then
  begin
    ContactList.add(propValue as TFhirPatientContact);
    result := propValue;
  end
  else if (propName = 'communication') then
  begin
    CommunicationList.add(propValue as TFhirPatientCommunication);
    result := propValue;
  end
  else if (propName = 'generalPractitioner') then
  begin
    GeneralPractitionerList.add(propValue as TFhirReference);
    result := propValue;
  end
  else if (propName = 'managingOrganization') then
  begin
    ManagingOrganization := propValue as TFhirReference;
    result := propValue;
  end
  else if (propName = 'link') then
  begin
    Link_List.add(propValue as TFhirPatientLink);
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirPatient.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'identifier') then IdentifierList.insertItem(index, propValue as TFhirIdentifier)
  else if (propName = 'name') then NameList.insertItem(index, propValue as TFhirHumanName)
  else if (propName = 'telecom') then TelecomList.insertItem(index, propValue as TFhirContactPoint)
  else if (propName = 'address') then AddressList.insertItem(index, propValue as TFhirAddress)
  else if (propName = 'photo') then PhotoList.insertItem(index, propValue as TFhirAttachment)
  else if (propName = 'contact') then ContactList.insertItem(index, propValue as TFhirPatientContact)
  else if (propName = 'communication') then CommunicationList.insertItem(index, propValue as TFhirPatientCommunication)
  else if (propName = 'generalPractitioner') then GeneralPractitionerList.insertItem(index, propValue as TFhirReference)
  else if (propName = 'link') then Link_List.insertItem(index, propValue as TFhirPatientLink)
  else inherited;
end;

function TFhirPatient.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'identifier') then result := IdentifierList.new()
  else if (propName = 'active') then result := TFhirBoolean.create()
  else if (propName = 'name') then result := NameList.new()
  else if (propName = 'telecom') then result := TelecomList.new()
  else if (propName = 'gender') then result := TFhirEnum.create(SYSTEMS_TFhirAdministrativeGenderEnum[AdministrativeGenderNull], CODES_TFhirAdministrativeGenderEnum[AdministrativeGenderNull]) 
  else if (propName = 'birthDate') then result := TFhirDate.create()
  else if (isMatchingName(propName, 'deceased', ['Boolean', 'DateTime'])) then raise EFHIRException.create('Cannot make property Deceased')
  else if (propName = 'address') then result := AddressList.new()
  else if (propName = 'maritalStatus') then result := TFhirCodeableConcept.create()
  else if (isMatchingName(propName, 'multipleBirth', ['Boolean', 'Integer'])) then raise EFHIRException.create('Cannot make property MultipleBirth')
  else if (propName = 'photo') then result := PhotoList.new()
  else if (propName = 'contact') then result := ContactList.new()
  else if (propName = 'communication') then result := CommunicationList.new()
  else if (propName = 'generalPractitioner') then result := GeneralPractitionerList.new()
  else if (propName = 'managingOrganization') then result := TFhirReference.create()
  else if (propName = 'link') then result := Link_List.new()
  else result := inherited createPropertyValue(propName);
end;

function TFhirPatient.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'identifier') then result := 'Identifier'
  else if (propName = 'active') then result := 'boolean'
  else if (propName = 'name') then result := 'HumanName'
  else if (propName = 'telecom') then result := 'ContactPoint'
  else if (propName = 'gender') then result := 'code'
  else if (propName = 'birthDate') then result := 'date'
  else if (propName = 'deceased[x]') then result := 'boolean|dateTime'
  else if (propName = 'address') then result := 'Address'
  else if (propName = 'maritalStatus') then result := 'CodeableConcept'
  else if (propName = 'multipleBirth[x]') then result := 'boolean|integer'
  else if (propName = 'photo') then result := 'Attachment'
  else if (propName = 'contact') then result := 'BackboneElement'
  else if (propName = 'communication') then result := 'BackboneElement'
  else if (propName = 'generalPractitioner') then result := 'Reference'
  else if (propName = 'managingOrganization') then result := 'Reference'
  else if (propName = 'link') then result := 'BackboneElement'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirPatient.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'identifier') then deletePropertyValue('identifier', IdentifierList, value)
  else if (propName = 'active') then ActiveElement := nil
  else if (propName = 'name') then deletePropertyValue('name', NameList, value)
  else if (propName = 'telecom') then deletePropertyValue('telecom', TelecomList, value)
  else if (propName = 'gender') then GenderElement := nil
  else if (propName = 'birthDate') then BirthDateElement := nil
  else if (isMatchingName(propName, 'deceased', ['Boolean', 'DateTime'])) then DeceasedElement := nil
  else if (propName = 'address') then deletePropertyValue('address', AddressList, value)
  else if (propName = 'maritalStatus') then MaritalStatusElement := nil
  else if (isMatchingName(propName, 'multipleBirth', ['Boolean', 'Integer'])) then MultipleBirthElement := nil
  else if (propName = 'photo') then deletePropertyValue('photo', PhotoList, value)
  else if (propName = 'contact') then deletePropertyValue('contact', ContactList, value)
  else if (propName = 'communication') then deletePropertyValue('communication', CommunicationList, value)
  else if (propName = 'generalPractitioner') then deletePropertyValue('generalPractitioner', GeneralPractitionerList, value)
  else if (propName = 'managingOrganization') then ManagingOrganizationElement := nil
  else if (propName = 'link') then deletePropertyValue('link', Link_List, value)
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirPatient.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'identifier') then replacePropertyValue('identifier', IdentifierList, existing, new)
  else if (propName = 'active') then ActiveElement := asBoolean(new)
  else if (propName = 'name') then replacePropertyValue('name', NameList, existing, new)
  else if (propName = 'telecom') then replacePropertyValue('telecom', TelecomList, existing, new)
  else if (propName = 'gender') then GenderElement := asEnum(SYSTEMS_TFhirAdministrativeGenderEnum, CODES_TFhirAdministrativeGenderEnum, new)
  else if (propName = 'birthDate') then BirthDateElement := asDate(new)
  else if (isMatchingName(propName, 'deceased', ['Boolean', 'DateTime'])) then DeceasedElement := new as TFhirDataType
  else if (propName = 'address') then replacePropertyValue('address', AddressList, existing, new)
  else if (propName = 'maritalStatus') then MaritalStatusElement := new as TFhirCodeableConcept
  else if (isMatchingName(propName, 'multipleBirth', ['Boolean', 'Integer'])) then MultipleBirthElement := new as TFhirDataType
  else if (propName = 'photo') then replacePropertyValue('photo', PhotoList, existing, new)
  else if (propName = 'contact') then replacePropertyValue('contact', ContactList, existing, new)
  else if (propName = 'communication') then replacePropertyValue('communication', CommunicationList, existing, new)
  else if (propName = 'generalPractitioner') then replacePropertyValue('generalPractitioner', GeneralPractitionerList, existing, new)
  else if (propName = 'managingOrganization') then ManagingOrganizationElement := new as TFhirReference
  else if (propName = 'link') then replacePropertyValue('link', Link_List, existing, new)
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirPatient.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'identifier') then IdentifierList.move(source, destination)
  else if (propName = 'name') then NameList.move(source, destination)
  else if (propName = 'telecom') then TelecomList.move(source, destination)
  else if (propName = 'address') then AddressList.move(source, destination)
  else if (propName = 'photo') then PhotoList.move(source, destination)
  else if (propName = 'contact') then ContactList.move(source, destination)
  else if (propName = 'communication') then CommunicationList.move(source, destination)
  else if (propName = 'generalPractitioner') then GeneralPractitionerList.move(source, destination)
  else if (propName = 'link') then Link_List.move(source, destination)
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirPatient.fhirType : string;
begin
  result := 'Patient';
end;

function TFhirPatient.Link : TFhirPatient;
begin
  result := TFhirPatient(inherited Link);
end;

function TFhirPatient.Clone : TFhirPatient;
begin
  result := TFhirPatient(inherited Clone);
end;

function TFhirPatient.equals(other : TObject) : boolean; 
var
  o : TFhirPatient;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirPatient)) then
    result := false
  else
  begin
    o := TFhirPatient(other);
    result := compareDeep(identifierList, o.identifierList, true) and compareDeep(activeElement, o.activeElement, true) and 
      compareDeep(nameList, o.nameList, true) and compareDeep(telecomList, o.telecomList, true) and 
      compareDeep(genderElement, o.genderElement, true) and compareDeep(birthDateElement, o.birthDateElement, true) and 
      compareDeep(deceasedElement, o.deceasedElement, true) and compareDeep(addressList, o.addressList, true) and 
      compareDeep(maritalStatusElement, o.maritalStatusElement, true) and compareDeep(multipleBirthElement, o.multipleBirthElement, true) and 
      compareDeep(photoList, o.photoList, true) and compareDeep(contactList, o.contactList, true) and 
      compareDeep(communicationList, o.communicationList, true) and compareDeep(generalPractitionerList, o.generalPractitionerList, true) and 
      compareDeep(managingOrganizationElement, o.managingOrganizationElement, true) and 
      compareDeep(link_List, o.link_List, true);
  end;
end;

function TFhirPatient.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FidentifierList) and isEmptyProp(FActive) and isEmptyProp(FnameList) and isEmptyProp(FtelecomList) and isEmptyProp(FGender) and isEmptyProp(FBirthDate) and isEmptyProp(FDeceased) and isEmptyProp(FaddressList) and isEmptyProp(FMaritalStatus) and isEmptyProp(FMultipleBirth) and isEmptyProp(FphotoList) and isEmptyProp(FcontactList) and isEmptyProp(FcommunicationList) and isEmptyProp(FgeneralPractitionerList) and isEmptyProp(FManagingOrganization) and isEmptyProp(Flink_List);
end;

procedure TFhirPatient.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('identifier');
  fields.add('active');
  fields.add('name');
  fields.add('telecom');
  fields.add('gender');
  fields.add('birthDate');
  fields.add('deceased[x]');
  fields.add('address');
  fields.add('maritalStatus');
  fields.add('multipleBirth[x]');
  fields.add('photo');
  fields.add('contact');
  fields.add('communication');
  fields.add('generalPractitioner');
  fields.add('managingOrganization');
  fields.add('link');
end;

function TFhirPatient.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
  inc(result, FIdentifierList.sizeInBytes(magic));
  inc(result, FNameList.sizeInBytes(magic));
  inc(result, FTelecomList.sizeInBytes(magic));
  inc(result, FAddressList.sizeInBytes(magic));
  inc(result, FPhotoList.sizeInBytes(magic));
  inc(result, FContactList.sizeInBytes(magic));
  inc(result, FCommunicationList.sizeInBytes(magic));
  inc(result, FGeneralPractitionerList.sizeInBytes(magic));
  inc(result, FLink_List.sizeInBytes(magic));
end;

function TFhirPatient.GetIdentifierList : TFhirIdentifierList;
begin
  if FIdentifierList = nil then
    FIdentifierList := TFhirIdentifierList.Create;
  result := FIdentifierList;
end;

function TFhirPatient.GetHasIdentifierList : boolean;
begin
  result := (FIdentifierList <> nil) and (FIdentifierList.count > 0);
end;

procedure TFhirPatient.SetActive(value : TFhirBoolean);
begin
  FActive.free;
  FActive := value;
end;

function TFhirPatient.GetActiveST : Boolean;
begin
  if FActive = nil then
    result := false
  else
    result := FActive.value;
end;

procedure TFhirPatient.SetActiveST(value : Boolean);
begin
  if FActive = nil then
    FActive := TFhirBoolean.create;
  FActive.value := value
end;

function TFhirPatient.GetNameList : TFhirHumanNameList;
begin
  if FNameList = nil then
    FNameList := TFhirHumanNameList.Create;
  result := FNameList;
end;

function TFhirPatient.GetHasNameList : boolean;
begin
  result := (FNameList <> nil) and (FNameList.count > 0);
end;

function TFhirPatient.GetTelecomList : TFhirContactPointList;
begin
  if FTelecomList = nil then
    FTelecomList := TFhirContactPointList.Create;
  result := FTelecomList;
end;

function TFhirPatient.GetHasTelecomList : boolean;
begin
  result := (FTelecomList <> nil) and (FTelecomList.count > 0);
end;

procedure TFhirPatient.SetGender(value : TFhirEnum);
begin
  FGender.free;
  FGender := value;
end;

function TFhirPatient.GetGenderST : TFhirAdministrativeGenderEnum;
begin
  if FGender = nil then
    result := TFhirAdministrativeGenderEnum(0)
  else
    result := TFhirAdministrativeGenderEnum(StringArrayIndexOfSensitive(CODES_TFhirAdministrativeGenderEnum, FGender.value));
end;

procedure TFhirPatient.SetGenderST(value : TFhirAdministrativeGenderEnum);
begin
  if ord(value) = 0 then
    GenderElement := nil
  else
    GenderElement := TFhirEnum.create(SYSTEMS_TFhirAdministrativeGenderEnum[value], CODES_TFhirAdministrativeGenderEnum[value]);
end;

procedure TFhirPatient.SetBirthDate(value : TFhirDate);
begin
  FBirthDate.free;
  FBirthDate := value;
end;

function TFhirPatient.GetBirthDateST : TFslDateTime;
begin
  if FBirthDate = nil then
    result := TFslDateTime.makeNull
  else
    result := FBirthDate.value;
end;

procedure TFhirPatient.SetBirthDateST(value : TFslDateTime);
begin
  if FBirthDate = nil then
    FBirthDate := TFhirDate.create;
  FBirthDate.value := value
end;

procedure TFhirPatient.SetDeceased(value : TFhirDataType);
begin
  FDeceased.free;
  FDeceased := value;
end;

function TFhirPatient.GetAddressList : TFhirAddressList;
begin
  if FAddressList = nil then
    FAddressList := TFhirAddressList.Create;
  result := FAddressList;
end;

function TFhirPatient.GetHasAddressList : boolean;
begin
  result := (FAddressList <> nil) and (FAddressList.count > 0);
end;

procedure TFhirPatient.SetMaritalStatus(value : TFhirCodeableConcept);
begin
  FMaritalStatus.free;
  FMaritalStatus := value;
end;

procedure TFhirPatient.SetMultipleBirth(value : TFhirDataType);
begin
  FMultipleBirth.free;
  FMultipleBirth := value;
end;

function TFhirPatient.GetPhotoList : TFhirAttachmentList;
begin
  if FPhotoList = nil then
    FPhotoList := TFhirAttachmentList.Create;
  result := FPhotoList;
end;

function TFhirPatient.GetHasPhotoList : boolean;
begin
  result := (FPhotoList <> nil) and (FPhotoList.count > 0);
end;

function TFhirPatient.GetContactList : TFhirPatientContactList;
begin
  if FContactList = nil then
    FContactList := TFhirPatientContactList.Create;
  result := FContactList;
end;

function TFhirPatient.GetHasContactList : boolean;
begin
  result := (FContactList <> nil) and (FContactList.count > 0);
end;

function TFhirPatient.GetCommunicationList : TFhirPatientCommunicationList;
begin
  if FCommunicationList = nil then
    FCommunicationList := TFhirPatientCommunicationList.Create;
  result := FCommunicationList;
end;

function TFhirPatient.GetHasCommunicationList : boolean;
begin
  result := (FCommunicationList <> nil) and (FCommunicationList.count > 0);
end;

function TFhirPatient.GetGeneralPractitionerList : TFhirReferenceList;
begin
  if FGeneralPractitionerList = nil then
    FGeneralPractitionerList := TFhirReferenceList.Create;
  result := FGeneralPractitionerList;
end;

function TFhirPatient.GetHasGeneralPractitionerList : boolean;
begin
  result := (FGeneralPractitionerList <> nil) and (FGeneralPractitionerList.count > 0);
end;

procedure TFhirPatient.SetManagingOrganization(value : TFhirReference);
begin
  FManagingOrganization.free;
  FManagingOrganization := value;
end;

function TFhirPatient.GetLink_List : TFhirPatientLinkList;
begin
  if FLink_List = nil then
    FLink_List := TFhirPatientLinkList.Create;
  result := FLink_List;
end;

function TFhirPatient.GetHasLink_List : boolean;
begin
  result := (FLink_List <> nil) and (FLink_List.count > 0);
end;

{ TFhirPatientListEnumerator }

constructor TFhirPatientListEnumerator.Create(list : TFhirPatientList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirPatientListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirPatientListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirPatientListEnumerator.GetCurrent : TFhirPatient;
begin
  Result := FList[FIndex];
end;

function TFhirPatientListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirPatientList }

function TFhirPatientList.AddItem(value: TFhirPatient): TFhirPatient;
begin
  assert(value.ClassName = 'TFhirPatient', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirPatient');
  add(value);
  result := value;
end;

function TFhirPatientList.Append: TFhirPatient;
begin
  result := TFhirPatient.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirPatientList.ClearItems;
begin
  Clear;
end;

function TFhirPatientList.GetEnumerator : TFhirPatientListEnumerator;
begin
  result := TFhirPatientListEnumerator.Create(self.link);
end;

function TFhirPatientList.Clone: TFhirPatientList;
begin
  result := TFhirPatientList(inherited Clone);
end;

function TFhirPatientList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirPatientList.GetItemN(index: Integer): TFhirPatient;
begin
  result := TFhirPatient(ObjectByIndex[index]);
end;

function TFhirPatientList.ItemClass: TFslObjectClass;
begin
  result := TFhirPatient;
end;
function TFhirPatientList.IndexOf(value: TFhirPatient): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirPatientList.Insert(index: Integer): TFhirPatient;
begin
  result := TFhirPatient.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirPatientList.InsertItem(index: Integer; value: TFhirPatient);
begin
  assert(value is TFhirPatient);
  Inherited Insert(index, value);
end;

function TFhirPatientList.Item(index: Integer): TFhirPatient;
begin
  result := TFhirPatient(ObjectByIndex[index]);
end;

function TFhirPatientList.Link: TFhirPatientList;
begin
  result := TFhirPatientList(inherited Link);
end;

procedure TFhirPatientList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirPatientList.SetItemByIndex(index: Integer; value: TFhirPatient);
begin
  assert(value is TFhirPatient);
  FhirPatients[index] := value;
end;

procedure TFhirPatientList.SetItemN(index: Integer; value: TFhirPatient);
begin
  assert(value is TFhirPatient);
  ObjectByIndex[index] := value;
end;

{$ENDIF FHIR_PATIENT}
{$IFDEF FHIR_PERSON}
{ TFhirPersonCommunication }

constructor TFhirPersonCommunication.Create;
begin
  inherited;
end;

destructor TFhirPersonCommunication.Destroy;
begin
  FLanguage.free;
  FPreferred.free;
  inherited;
end;

procedure TFhirPersonCommunication.Assign(oSource : TFslObject);
begin
  inherited;
  language := TFhirPersonCommunication(oSource).language.Clone;
  preferredElement := TFhirPersonCommunication(oSource).preferredElement.Clone;
end;

procedure TFhirPersonCommunication.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'language') Then
     list.add(self.link, 'language', FLanguage.Link);
  if (child_name = 'preferred') Then
     list.add(self.link, 'preferred', FPreferred.Link);
end;

procedure TFhirPersonCommunication.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'language', 'CodeableConcept', false, TFhirCodeableConcept, FLanguage.Link));
  oList.add(TFHIRProperty.create(self, 'preferred', 'boolean', false, TFhirBoolean, FPreferred.Link));
end;

function TFhirPersonCommunication.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'language') then
  begin
    Language := propValue as TFhirCodeableConcept;
    result := propValue;
  end
  else if (propName = 'preferred') then
  begin
    PreferredElement := asBoolean(propValue);
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirPersonCommunication.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirPersonCommunication.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'language') then result := TFhirCodeableConcept.create()
  else if (propName = 'preferred') then result := TFhirBoolean.create()
  else result := inherited createPropertyValue(propName);
end;

function TFhirPersonCommunication.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'language') then result := 'CodeableConcept'
  else if (propName = 'preferred') then result := 'boolean'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirPersonCommunication.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'language') then LanguageElement := nil
  else if (propName = 'preferred') then PreferredElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirPersonCommunication.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'language') then LanguageElement := new as TFhirCodeableConcept
  else if (propName = 'preferred') then PreferredElement := asBoolean(new)
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirPersonCommunication.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirPersonCommunication.fhirType : string;
begin
  result := 'Person.communication';
end;

function TFhirPersonCommunication.Link : TFhirPersonCommunication;
begin
  result := TFhirPersonCommunication(inherited Link);
end;

function TFhirPersonCommunication.Clone : TFhirPersonCommunication;
begin
  result := TFhirPersonCommunication(inherited Clone);
end;

function TFhirPersonCommunication.equals(other : TObject) : boolean; 
var
  o : TFhirPersonCommunication;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirPersonCommunication)) then
    result := false
  else
  begin
    o := TFhirPersonCommunication(other);
    result := compareDeep(languageElement, o.languageElement, true) and compareDeep(preferredElement, o.preferredElement, true);
  end;
end;

function TFhirPersonCommunication.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FLanguage) and isEmptyProp(FPreferred);
end;

procedure TFhirPersonCommunication.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('language');
  fields.add('preferred');
end;

function TFhirPersonCommunication.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
end;

procedure TFhirPersonCommunication.SetLanguage(value : TFhirCodeableConcept);
begin
  FLanguage.free;
  FLanguage := value;
end;

procedure TFhirPersonCommunication.SetPreferred(value : TFhirBoolean);
begin
  FPreferred.free;
  FPreferred := value;
end;

function TFhirPersonCommunication.GetPreferredST : Boolean;
begin
  if FPreferred = nil then
    result := false
  else
    result := FPreferred.value;
end;

procedure TFhirPersonCommunication.SetPreferredST(value : Boolean);
begin
  if FPreferred = nil then
    FPreferred := TFhirBoolean.create;
  FPreferred.value := value
end;

{ TFhirPersonCommunicationListEnumerator }

constructor TFhirPersonCommunicationListEnumerator.Create(list : TFhirPersonCommunicationList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirPersonCommunicationListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirPersonCommunicationListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirPersonCommunicationListEnumerator.GetCurrent : TFhirPersonCommunication;
begin
  Result := FList[FIndex];
end;

function TFhirPersonCommunicationListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirPersonCommunicationList }

function TFhirPersonCommunicationList.AddItem(value: TFhirPersonCommunication): TFhirPersonCommunication;
begin
  assert(value.ClassName = 'TFhirPersonCommunication', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirPersonCommunication');
  add(value);
  result := value;
end;

function TFhirPersonCommunicationList.Append: TFhirPersonCommunication;
begin
  result := TFhirPersonCommunication.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirPersonCommunicationList.ClearItems;
begin
  Clear;
end;

function TFhirPersonCommunicationList.GetEnumerator : TFhirPersonCommunicationListEnumerator;
begin
  result := TFhirPersonCommunicationListEnumerator.Create(self.link);
end;

function TFhirPersonCommunicationList.Clone: TFhirPersonCommunicationList;
begin
  result := TFhirPersonCommunicationList(inherited Clone);
end;

function TFhirPersonCommunicationList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirPersonCommunicationList.GetItemN(index: Integer): TFhirPersonCommunication;
begin
  result := TFhirPersonCommunication(ObjectByIndex[index]);
end;

function TFhirPersonCommunicationList.ItemClass: TFslObjectClass;
begin
  result := TFhirPersonCommunication;
end;
function TFhirPersonCommunicationList.IndexOf(value: TFhirPersonCommunication): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirPersonCommunicationList.Insert(index: Integer): TFhirPersonCommunication;
begin
  result := TFhirPersonCommunication.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirPersonCommunicationList.InsertItem(index: Integer; value: TFhirPersonCommunication);
begin
  assert(value is TFhirPersonCommunication);
  Inherited Insert(index, value);
end;

function TFhirPersonCommunicationList.Item(index: Integer): TFhirPersonCommunication;
begin
  result := TFhirPersonCommunication(ObjectByIndex[index]);
end;

function TFhirPersonCommunicationList.Link: TFhirPersonCommunicationList;
begin
  result := TFhirPersonCommunicationList(inherited Link);
end;

procedure TFhirPersonCommunicationList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirPersonCommunicationList.SetItemByIndex(index: Integer; value: TFhirPersonCommunication);
begin
  assert(value is TFhirPersonCommunication);
  FhirPersonCommunications[index] := value;
end;

procedure TFhirPersonCommunicationList.SetItemN(index: Integer; value: TFhirPersonCommunication);
begin
  assert(value is TFhirPersonCommunication);
  ObjectByIndex[index] := value;
end;

{ TFhirPersonLink }

constructor TFhirPersonLink.Create;
begin
  inherited;
end;

destructor TFhirPersonLink.Destroy;
begin
  FTarget.free;
  FAssurance.free;
  inherited;
end;

procedure TFhirPersonLink.Assign(oSource : TFslObject);
begin
  inherited;
  target := TFhirPersonLink(oSource).target.Clone;
  assuranceElement := TFhirPersonLink(oSource).assuranceElement.Clone;
end;

procedure TFhirPersonLink.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'target') Then
     list.add(self.link, 'target', FTarget.Link);
  if (child_name = 'assurance') Then
     list.add(self.link, 'assurance', FAssurance.Link);
end;

procedure TFhirPersonLink.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'target', 'Reference', false, TFhirReference, FTarget.Link));
  oList.add(TFHIRProperty.create(self, 'assurance', 'code', false, TFhirEnum, FAssurance.Link));
end;

function TFhirPersonLink.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'target') then
  begin
    Target := propValue as TFhirReference;
    result := propValue;
  end
  else if (propName = 'assurance') then
  begin
    AssuranceElement := asEnum(SYSTEMS_TFhirIdentityAssuranceLevelEnum, CODES_TFhirIdentityAssuranceLevelEnum, propValue);
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirPersonLink.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirPersonLink.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'target') then result := TFhirReference.create()
  else if (propName = 'assurance') then result := TFhirEnum.create(SYSTEMS_TFhirIdentityAssuranceLevelEnum[IdentityAssuranceLevelNull], CODES_TFhirIdentityAssuranceLevelEnum[IdentityAssuranceLevelNull]) 
  else result := inherited createPropertyValue(propName);
end;

function TFhirPersonLink.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'target') then result := 'Reference'
  else if (propName = 'assurance') then result := 'code'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirPersonLink.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'target') then TargetElement := nil
  else if (propName = 'assurance') then AssuranceElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirPersonLink.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'target') then TargetElement := new as TFhirReference
  else if (propName = 'assurance') then AssuranceElement := asEnum(SYSTEMS_TFhirIdentityAssuranceLevelEnum, CODES_TFhirIdentityAssuranceLevelEnum, new)
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirPersonLink.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirPersonLink.fhirType : string;
begin
  result := 'Person.link';
end;

function TFhirPersonLink.Link : TFhirPersonLink;
begin
  result := TFhirPersonLink(inherited Link);
end;

function TFhirPersonLink.Clone : TFhirPersonLink;
begin
  result := TFhirPersonLink(inherited Clone);
end;

function TFhirPersonLink.equals(other : TObject) : boolean; 
var
  o : TFhirPersonLink;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirPersonLink)) then
    result := false
  else
  begin
    o := TFhirPersonLink(other);
    result := compareDeep(targetElement, o.targetElement, true) and compareDeep(assuranceElement, o.assuranceElement, true);
  end;
end;

function TFhirPersonLink.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FTarget) and isEmptyProp(FAssurance);
end;

procedure TFhirPersonLink.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('target');
  fields.add('assurance');
end;

function TFhirPersonLink.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
end;

procedure TFhirPersonLink.SetTarget(value : TFhirReference);
begin
  FTarget.free;
  FTarget := value;
end;

procedure TFhirPersonLink.SetAssurance(value : TFhirEnum);
begin
  FAssurance.free;
  FAssurance := value;
end;

function TFhirPersonLink.GetAssuranceST : TFhirIdentityAssuranceLevelEnum;
begin
  if FAssurance = nil then
    result := TFhirIdentityAssuranceLevelEnum(0)
  else
    result := TFhirIdentityAssuranceLevelEnum(StringArrayIndexOfSensitive(CODES_TFhirIdentityAssuranceLevelEnum, FAssurance.value));
end;

procedure TFhirPersonLink.SetAssuranceST(value : TFhirIdentityAssuranceLevelEnum);
begin
  if ord(value) = 0 then
    AssuranceElement := nil
  else
    AssuranceElement := TFhirEnum.create(SYSTEMS_TFhirIdentityAssuranceLevelEnum[value], CODES_TFhirIdentityAssuranceLevelEnum[value]);
end;

{ TFhirPersonLinkListEnumerator }

constructor TFhirPersonLinkListEnumerator.Create(list : TFhirPersonLinkList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirPersonLinkListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirPersonLinkListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirPersonLinkListEnumerator.GetCurrent : TFhirPersonLink;
begin
  Result := FList[FIndex];
end;

function TFhirPersonLinkListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirPersonLinkList }

function TFhirPersonLinkList.AddItem(value: TFhirPersonLink): TFhirPersonLink;
begin
  assert(value.ClassName = 'TFhirPersonLink', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirPersonLink');
  add(value);
  result := value;
end;

function TFhirPersonLinkList.Append: TFhirPersonLink;
begin
  result := TFhirPersonLink.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirPersonLinkList.ClearItems;
begin
  Clear;
end;

function TFhirPersonLinkList.GetEnumerator : TFhirPersonLinkListEnumerator;
begin
  result := TFhirPersonLinkListEnumerator.Create(self.link);
end;

function TFhirPersonLinkList.Clone: TFhirPersonLinkList;
begin
  result := TFhirPersonLinkList(inherited Clone);
end;

function TFhirPersonLinkList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirPersonLinkList.GetItemN(index: Integer): TFhirPersonLink;
begin
  result := TFhirPersonLink(ObjectByIndex[index]);
end;

function TFhirPersonLinkList.ItemClass: TFslObjectClass;
begin
  result := TFhirPersonLink;
end;
function TFhirPersonLinkList.IndexOf(value: TFhirPersonLink): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirPersonLinkList.Insert(index: Integer): TFhirPersonLink;
begin
  result := TFhirPersonLink.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirPersonLinkList.InsertItem(index: Integer; value: TFhirPersonLink);
begin
  assert(value is TFhirPersonLink);
  Inherited Insert(index, value);
end;

function TFhirPersonLinkList.Item(index: Integer): TFhirPersonLink;
begin
  result := TFhirPersonLink(ObjectByIndex[index]);
end;

function TFhirPersonLinkList.Link: TFhirPersonLinkList;
begin
  result := TFhirPersonLinkList(inherited Link);
end;

procedure TFhirPersonLinkList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirPersonLinkList.SetItemByIndex(index: Integer; value: TFhirPersonLink);
begin
  assert(value is TFhirPersonLink);
  FhirPersonLinks[index] := value;
end;

procedure TFhirPersonLinkList.SetItemN(index: Integer; value: TFhirPersonLink);
begin
  assert(value is TFhirPersonLink);
  ObjectByIndex[index] := value;
end;

{ TFhirPerson }

constructor TFhirPerson.Create;
begin
  inherited;
end;

destructor TFhirPerson.Destroy;
begin
  FIdentifierList.Free;
  FActive.free;
  FNameList.Free;
  FTelecomList.Free;
  FGender.free;
  FBirthDate.free;
  FDeceased.free;
  FAddressList.Free;
  FMaritalStatus.free;
  FPhotoList.Free;
  FCommunicationList.Free;
  FManagingOrganization.free;
  FLink_List.Free;
  inherited;
end;

procedure TFhirPerson.Assign(oSource : TFslObject);
begin
  inherited;
  if (TFhirPerson(oSource).FIdentifierList = nil) then
  begin
    FIdentifierList.free;
    FIdentifierList := nil;
  end
  else
  begin
    if FIdentifierList = nil then
      FIdentifierList := TFhirIdentifierList.Create;
    FIdentifierList.Assign(TFhirPerson(oSource).FIdentifierList);
  end;
  activeElement := TFhirPerson(oSource).activeElement.Clone;
  if (TFhirPerson(oSource).FNameList = nil) then
  begin
    FNameList.free;
    FNameList := nil;
  end
  else
  begin
    if FNameList = nil then
      FNameList := TFhirHumanNameList.Create;
    FNameList.Assign(TFhirPerson(oSource).FNameList);
  end;
  if (TFhirPerson(oSource).FTelecomList = nil) then
  begin
    FTelecomList.free;
    FTelecomList := nil;
  end
  else
  begin
    if FTelecomList = nil then
      FTelecomList := TFhirContactPointList.Create;
    FTelecomList.Assign(TFhirPerson(oSource).FTelecomList);
  end;
  genderElement := TFhirPerson(oSource).genderElement.Clone;
  birthDateElement := TFhirPerson(oSource).birthDateElement.Clone;
  deceased := TFhirPerson(oSource).deceased.Clone;
  if (TFhirPerson(oSource).FAddressList = nil) then
  begin
    FAddressList.free;
    FAddressList := nil;
  end
  else
  begin
    if FAddressList = nil then
      FAddressList := TFhirAddressList.Create;
    FAddressList.Assign(TFhirPerson(oSource).FAddressList);
  end;
  maritalStatus := TFhirPerson(oSource).maritalStatus.Clone;
  if (TFhirPerson(oSource).FPhotoList = nil) then
  begin
    FPhotoList.free;
    FPhotoList := nil;
  end
  else
  begin
    if FPhotoList = nil then
      FPhotoList := TFhirAttachmentList.Create;
    FPhotoList.Assign(TFhirPerson(oSource).FPhotoList);
  end;
  if (TFhirPerson(oSource).FCommunicationList = nil) then
  begin
    FCommunicationList.free;
    FCommunicationList := nil;
  end
  else
  begin
    if FCommunicationList = nil then
      FCommunicationList := TFhirPersonCommunicationList.Create;
    FCommunicationList.Assign(TFhirPerson(oSource).FCommunicationList);
  end;
  managingOrganization := TFhirPerson(oSource).managingOrganization.Clone;
  if (TFhirPerson(oSource).FLink_List = nil) then
  begin
    FLink_List.free;
    FLink_List := nil;
  end
  else
  begin
    if FLink_List = nil then
      FLink_List := TFhirPersonLinkList.Create;
    FLink_List.Assign(TFhirPerson(oSource).FLink_List);
  end;
end;

function TFhirPerson.GetResourceType : TFhirResourceType;
begin
  result := frtPerson;
end;

procedure TFhirPerson.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'identifier') Then
    list.addAll(self, 'identifier', FIdentifierList);
  if (child_name = 'active') Then
     list.add(self.link, 'active', FActive.Link);
  if (child_name = 'name') Then
    list.addAll(self, 'name', FNameList);
  if (child_name = 'telecom') Then
    list.addAll(self, 'telecom', FTelecomList);
  if (child_name = 'gender') Then
     list.add(self.link, 'gender', FGender.Link);
  if (child_name = 'birthDate') Then
     list.add(self.link, 'birthDate', FBirthDate.Link);
  if (child_name = 'deceased[x]') or (child_name = 'deceased') Then
     list.add(self.link, 'deceased[x]', FDeceased.Link);
  if (child_name = 'address') Then
    list.addAll(self, 'address', FAddressList);
  if (child_name = 'maritalStatus') Then
     list.add(self.link, 'maritalStatus', FMaritalStatus.Link);
  if (child_name = 'photo') Then
    list.addAll(self, 'photo', FPhotoList);
  if (child_name = 'communication') Then
    list.addAll(self, 'communication', FCommunicationList);
  if (child_name = 'managingOrganization') Then
     list.add(self.link, 'managingOrganization', FManagingOrganization.Link);
  if (child_name = 'link') Then
    list.addAll(self, 'link', FLink_List);
end;

procedure TFhirPerson.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'identifier', 'Identifier', true, TFhirIdentifier, FIdentifierList.Link));
  oList.add(TFHIRProperty.create(self, 'active', 'boolean', false, TFhirBoolean, FActive.Link));
  oList.add(TFHIRProperty.create(self, 'name', 'HumanName', true, TFhirHumanName, FNameList.Link));
  oList.add(TFHIRProperty.create(self, 'telecom', 'ContactPoint', true, TFhirContactPoint, FTelecomList.Link));
  oList.add(TFHIRProperty.create(self, 'gender', 'code', false, TFhirEnum, FGender.Link));
  oList.add(TFHIRProperty.create(self, 'birthDate', 'date', false, TFhirDate, FBirthDate.Link));
  oList.add(TFHIRProperty.create(self, 'deceased[x]', 'boolean|dateTime', false, TFhirDataType, FDeceased.Link));
  oList.add(TFHIRProperty.create(self, 'address', 'Address', true, TFhirAddress, FAddressList.Link));
  oList.add(TFHIRProperty.create(self, 'maritalStatus', 'CodeableConcept', false, TFhirCodeableConcept, FMaritalStatus.Link));
  oList.add(TFHIRProperty.create(self, 'photo', 'Attachment', true, TFhirAttachment, FPhotoList.Link));
  oList.add(TFHIRProperty.create(self, 'communication', 'BackboneElement', true, TFhirPersonCommunication, FCommunicationList.Link));
  oList.add(TFHIRProperty.create(self, 'managingOrganization', 'Reference', false, TFhirReference, FManagingOrganization.Link));
  oList.add(TFHIRProperty.create(self, 'link', 'BackboneElement', true, TFhirPersonLink, FLink_List.Link));
end;

function TFhirPerson.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'identifier') then
  begin
    IdentifierList.add(propValue as TFhirIdentifier);
    result := propValue;
  end
  else if (propName = 'active') then
  begin
    ActiveElement := asBoolean(propValue);
    result := propValue;
  end
  else if (propName = 'name') then
  begin
    NameList.add(propValue as TFhirHumanName);
    result := propValue;
  end
  else if (propName = 'telecom') then
  begin
    TelecomList.add(propValue as TFhirContactPoint);
    result := propValue;
  end
  else if (propName = 'gender') then
  begin
    GenderElement := asEnum(SYSTEMS_TFhirAdministrativeGenderEnum, CODES_TFhirAdministrativeGenderEnum, propValue);
    result := propValue;
  end
  else if (propName = 'birthDate') then
  begin
    BirthDateElement := asDate(propValue);
    result := propValue;
  end
  else if (isMatchingName(propName, 'deceased', ['Boolean', 'DateTime'])) then
  begin
    Deceased := propValue as TFhirDataType;
    result := propValue;
  end
  else if (propName = 'address') then
  begin
    AddressList.add(propValue as TFhirAddress);
    result := propValue;
  end
  else if (propName = 'maritalStatus') then
  begin
    MaritalStatus := propValue as TFhirCodeableConcept;
    result := propValue;
  end
  else if (propName = 'photo') then
  begin
    PhotoList.add(propValue as TFhirAttachment);
    result := propValue;
  end
  else if (propName = 'communication') then
  begin
    CommunicationList.add(propValue as TFhirPersonCommunication);
    result := propValue;
  end
  else if (propName = 'managingOrganization') then
  begin
    ManagingOrganization := propValue as TFhirReference;
    result := propValue;
  end
  else if (propName = 'link') then
  begin
    Link_List.add(propValue as TFhirPersonLink);
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirPerson.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'identifier') then IdentifierList.insertItem(index, propValue as TFhirIdentifier)
  else if (propName = 'name') then NameList.insertItem(index, propValue as TFhirHumanName)
  else if (propName = 'telecom') then TelecomList.insertItem(index, propValue as TFhirContactPoint)
  else if (propName = 'address') then AddressList.insertItem(index, propValue as TFhirAddress)
  else if (propName = 'photo') then PhotoList.insertItem(index, propValue as TFhirAttachment)
  else if (propName = 'communication') then CommunicationList.insertItem(index, propValue as TFhirPersonCommunication)
  else if (propName = 'link') then Link_List.insertItem(index, propValue as TFhirPersonLink)
  else inherited;
end;

function TFhirPerson.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'identifier') then result := IdentifierList.new()
  else if (propName = 'active') then result := TFhirBoolean.create()
  else if (propName = 'name') then result := NameList.new()
  else if (propName = 'telecom') then result := TelecomList.new()
  else if (propName = 'gender') then result := TFhirEnum.create(SYSTEMS_TFhirAdministrativeGenderEnum[AdministrativeGenderNull], CODES_TFhirAdministrativeGenderEnum[AdministrativeGenderNull]) 
  else if (propName = 'birthDate') then result := TFhirDate.create()
  else if (isMatchingName(propName, 'deceased', ['Boolean', 'DateTime'])) then raise EFHIRException.create('Cannot make property Deceased')
  else if (propName = 'address') then result := AddressList.new()
  else if (propName = 'maritalStatus') then result := TFhirCodeableConcept.create()
  else if (propName = 'photo') then result := PhotoList.new()
  else if (propName = 'communication') then result := CommunicationList.new()
  else if (propName = 'managingOrganization') then result := TFhirReference.create()
  else if (propName = 'link') then result := Link_List.new()
  else result := inherited createPropertyValue(propName);
end;

function TFhirPerson.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'identifier') then result := 'Identifier'
  else if (propName = 'active') then result := 'boolean'
  else if (propName = 'name') then result := 'HumanName'
  else if (propName = 'telecom') then result := 'ContactPoint'
  else if (propName = 'gender') then result := 'code'
  else if (propName = 'birthDate') then result := 'date'
  else if (propName = 'deceased[x]') then result := 'boolean|dateTime'
  else if (propName = 'address') then result := 'Address'
  else if (propName = 'maritalStatus') then result := 'CodeableConcept'
  else if (propName = 'photo') then result := 'Attachment'
  else if (propName = 'communication') then result := 'BackboneElement'
  else if (propName = 'managingOrganization') then result := 'Reference'
  else if (propName = 'link') then result := 'BackboneElement'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirPerson.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'identifier') then deletePropertyValue('identifier', IdentifierList, value)
  else if (propName = 'active') then ActiveElement := nil
  else if (propName = 'name') then deletePropertyValue('name', NameList, value)
  else if (propName = 'telecom') then deletePropertyValue('telecom', TelecomList, value)
  else if (propName = 'gender') then GenderElement := nil
  else if (propName = 'birthDate') then BirthDateElement := nil
  else if (isMatchingName(propName, 'deceased', ['Boolean', 'DateTime'])) then DeceasedElement := nil
  else if (propName = 'address') then deletePropertyValue('address', AddressList, value)
  else if (propName = 'maritalStatus') then MaritalStatusElement := nil
  else if (propName = 'photo') then deletePropertyValue('photo', PhotoList, value)
  else if (propName = 'communication') then deletePropertyValue('communication', CommunicationList, value)
  else if (propName = 'managingOrganization') then ManagingOrganizationElement := nil
  else if (propName = 'link') then deletePropertyValue('link', Link_List, value)
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirPerson.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'identifier') then replacePropertyValue('identifier', IdentifierList, existing, new)
  else if (propName = 'active') then ActiveElement := asBoolean(new)
  else if (propName = 'name') then replacePropertyValue('name', NameList, existing, new)
  else if (propName = 'telecom') then replacePropertyValue('telecom', TelecomList, existing, new)
  else if (propName = 'gender') then GenderElement := asEnum(SYSTEMS_TFhirAdministrativeGenderEnum, CODES_TFhirAdministrativeGenderEnum, new)
  else if (propName = 'birthDate') then BirthDateElement := asDate(new)
  else if (isMatchingName(propName, 'deceased', ['Boolean', 'DateTime'])) then DeceasedElement := new as TFhirDataType
  else if (propName = 'address') then replacePropertyValue('address', AddressList, existing, new)
  else if (propName = 'maritalStatus') then MaritalStatusElement := new as TFhirCodeableConcept
  else if (propName = 'photo') then replacePropertyValue('photo', PhotoList, existing, new)
  else if (propName = 'communication') then replacePropertyValue('communication', CommunicationList, existing, new)
  else if (propName = 'managingOrganization') then ManagingOrganizationElement := new as TFhirReference
  else if (propName = 'link') then replacePropertyValue('link', Link_List, existing, new)
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirPerson.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'identifier') then IdentifierList.move(source, destination)
  else if (propName = 'name') then NameList.move(source, destination)
  else if (propName = 'telecom') then TelecomList.move(source, destination)
  else if (propName = 'address') then AddressList.move(source, destination)
  else if (propName = 'photo') then PhotoList.move(source, destination)
  else if (propName = 'communication') then CommunicationList.move(source, destination)
  else if (propName = 'link') then Link_List.move(source, destination)
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirPerson.fhirType : string;
begin
  result := 'Person';
end;

function TFhirPerson.Link : TFhirPerson;
begin
  result := TFhirPerson(inherited Link);
end;

function TFhirPerson.Clone : TFhirPerson;
begin
  result := TFhirPerson(inherited Clone);
end;

function TFhirPerson.equals(other : TObject) : boolean; 
var
  o : TFhirPerson;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirPerson)) then
    result := false
  else
  begin
    o := TFhirPerson(other);
    result := compareDeep(identifierList, o.identifierList, true) and compareDeep(activeElement, o.activeElement, true) and 
      compareDeep(nameList, o.nameList, true) and compareDeep(telecomList, o.telecomList, true) and 
      compareDeep(genderElement, o.genderElement, true) and compareDeep(birthDateElement, o.birthDateElement, true) and 
      compareDeep(deceasedElement, o.deceasedElement, true) and compareDeep(addressList, o.addressList, true) and 
      compareDeep(maritalStatusElement, o.maritalStatusElement, true) and compareDeep(photoList, o.photoList, true) and 
      compareDeep(communicationList, o.communicationList, true) and compareDeep(managingOrganizationElement, o.managingOrganizationElement, true) and 
      compareDeep(link_List, o.link_List, true);
  end;
end;

function TFhirPerson.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FidentifierList) and isEmptyProp(FActive) and isEmptyProp(FnameList) and isEmptyProp(FtelecomList) and isEmptyProp(FGender) and isEmptyProp(FBirthDate) and isEmptyProp(FDeceased) and isEmptyProp(FaddressList) and isEmptyProp(FMaritalStatus) and isEmptyProp(FphotoList) and isEmptyProp(FcommunicationList) and isEmptyProp(FManagingOrganization) and isEmptyProp(Flink_List);
end;

procedure TFhirPerson.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('identifier');
  fields.add('active');
  fields.add('name');
  fields.add('telecom');
  fields.add('gender');
  fields.add('birthDate');
  fields.add('deceased[x]');
  fields.add('address');
  fields.add('maritalStatus');
  fields.add('photo');
  fields.add('communication');
  fields.add('managingOrganization');
  fields.add('link');
end;

function TFhirPerson.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
  inc(result, FIdentifierList.sizeInBytes(magic));
  inc(result, FNameList.sizeInBytes(magic));
  inc(result, FTelecomList.sizeInBytes(magic));
  inc(result, FAddressList.sizeInBytes(magic));
  inc(result, FPhotoList.sizeInBytes(magic));
  inc(result, FCommunicationList.sizeInBytes(magic));
  inc(result, FLink_List.sizeInBytes(magic));
end;

function TFhirPerson.GetIdentifierList : TFhirIdentifierList;
begin
  if FIdentifierList = nil then
    FIdentifierList := TFhirIdentifierList.Create;
  result := FIdentifierList;
end;

function TFhirPerson.GetHasIdentifierList : boolean;
begin
  result := (FIdentifierList <> nil) and (FIdentifierList.count > 0);
end;

procedure TFhirPerson.SetActive(value : TFhirBoolean);
begin
  FActive.free;
  FActive := value;
end;

function TFhirPerson.GetActiveST : Boolean;
begin
  if FActive = nil then
    result := false
  else
    result := FActive.value;
end;

procedure TFhirPerson.SetActiveST(value : Boolean);
begin
  if FActive = nil then
    FActive := TFhirBoolean.create;
  FActive.value := value
end;

function TFhirPerson.GetNameList : TFhirHumanNameList;
begin
  if FNameList = nil then
    FNameList := TFhirHumanNameList.Create;
  result := FNameList;
end;

function TFhirPerson.GetHasNameList : boolean;
begin
  result := (FNameList <> nil) and (FNameList.count > 0);
end;

function TFhirPerson.GetTelecomList : TFhirContactPointList;
begin
  if FTelecomList = nil then
    FTelecomList := TFhirContactPointList.Create;
  result := FTelecomList;
end;

function TFhirPerson.GetHasTelecomList : boolean;
begin
  result := (FTelecomList <> nil) and (FTelecomList.count > 0);
end;

procedure TFhirPerson.SetGender(value : TFhirEnum);
begin
  FGender.free;
  FGender := value;
end;

function TFhirPerson.GetGenderST : TFhirAdministrativeGenderEnum;
begin
  if FGender = nil then
    result := TFhirAdministrativeGenderEnum(0)
  else
    result := TFhirAdministrativeGenderEnum(StringArrayIndexOfSensitive(CODES_TFhirAdministrativeGenderEnum, FGender.value));
end;

procedure TFhirPerson.SetGenderST(value : TFhirAdministrativeGenderEnum);
begin
  if ord(value) = 0 then
    GenderElement := nil
  else
    GenderElement := TFhirEnum.create(SYSTEMS_TFhirAdministrativeGenderEnum[value], CODES_TFhirAdministrativeGenderEnum[value]);
end;

procedure TFhirPerson.SetBirthDate(value : TFhirDate);
begin
  FBirthDate.free;
  FBirthDate := value;
end;

function TFhirPerson.GetBirthDateST : TFslDateTime;
begin
  if FBirthDate = nil then
    result := TFslDateTime.makeNull
  else
    result := FBirthDate.value;
end;

procedure TFhirPerson.SetBirthDateST(value : TFslDateTime);
begin
  if FBirthDate = nil then
    FBirthDate := TFhirDate.create;
  FBirthDate.value := value
end;

procedure TFhirPerson.SetDeceased(value : TFhirDataType);
begin
  FDeceased.free;
  FDeceased := value;
end;

function TFhirPerson.GetAddressList : TFhirAddressList;
begin
  if FAddressList = nil then
    FAddressList := TFhirAddressList.Create;
  result := FAddressList;
end;

function TFhirPerson.GetHasAddressList : boolean;
begin
  result := (FAddressList <> nil) and (FAddressList.count > 0);
end;

procedure TFhirPerson.SetMaritalStatus(value : TFhirCodeableConcept);
begin
  FMaritalStatus.free;
  FMaritalStatus := value;
end;

function TFhirPerson.GetPhotoList : TFhirAttachmentList;
begin
  if FPhotoList = nil then
    FPhotoList := TFhirAttachmentList.Create;
  result := FPhotoList;
end;

function TFhirPerson.GetHasPhotoList : boolean;
begin
  result := (FPhotoList <> nil) and (FPhotoList.count > 0);
end;

function TFhirPerson.GetCommunicationList : TFhirPersonCommunicationList;
begin
  if FCommunicationList = nil then
    FCommunicationList := TFhirPersonCommunicationList.Create;
  result := FCommunicationList;
end;

function TFhirPerson.GetHasCommunicationList : boolean;
begin
  result := (FCommunicationList <> nil) and (FCommunicationList.count > 0);
end;

procedure TFhirPerson.SetManagingOrganization(value : TFhirReference);
begin
  FManagingOrganization.free;
  FManagingOrganization := value;
end;

function TFhirPerson.GetLink_List : TFhirPersonLinkList;
begin
  if FLink_List = nil then
    FLink_List := TFhirPersonLinkList.Create;
  result := FLink_List;
end;

function TFhirPerson.GetHasLink_List : boolean;
begin
  result := (FLink_List <> nil) and (FLink_List.count > 0);
end;

{ TFhirPersonListEnumerator }

constructor TFhirPersonListEnumerator.Create(list : TFhirPersonList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirPersonListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirPersonListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirPersonListEnumerator.GetCurrent : TFhirPerson;
begin
  Result := FList[FIndex];
end;

function TFhirPersonListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirPersonList }

function TFhirPersonList.AddItem(value: TFhirPerson): TFhirPerson;
begin
  assert(value.ClassName = 'TFhirPerson', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirPerson');
  add(value);
  result := value;
end;

function TFhirPersonList.Append: TFhirPerson;
begin
  result := TFhirPerson.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirPersonList.ClearItems;
begin
  Clear;
end;

function TFhirPersonList.GetEnumerator : TFhirPersonListEnumerator;
begin
  result := TFhirPersonListEnumerator.Create(self.link);
end;

function TFhirPersonList.Clone: TFhirPersonList;
begin
  result := TFhirPersonList(inherited Clone);
end;

function TFhirPersonList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirPersonList.GetItemN(index: Integer): TFhirPerson;
begin
  result := TFhirPerson(ObjectByIndex[index]);
end;

function TFhirPersonList.ItemClass: TFslObjectClass;
begin
  result := TFhirPerson;
end;
function TFhirPersonList.IndexOf(value: TFhirPerson): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirPersonList.Insert(index: Integer): TFhirPerson;
begin
  result := TFhirPerson.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirPersonList.InsertItem(index: Integer; value: TFhirPerson);
begin
  assert(value is TFhirPerson);
  Inherited Insert(index, value);
end;

function TFhirPersonList.Item(index: Integer): TFhirPerson;
begin
  result := TFhirPerson(ObjectByIndex[index]);
end;

function TFhirPersonList.Link: TFhirPersonList;
begin
  result := TFhirPersonList(inherited Link);
end;

procedure TFhirPersonList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirPersonList.SetItemByIndex(index: Integer; value: TFhirPerson);
begin
  assert(value is TFhirPerson);
  FhirPeople[index] := value;
end;

procedure TFhirPersonList.SetItemN(index: Integer; value: TFhirPerson);
begin
  assert(value is TFhirPerson);
  ObjectByIndex[index] := value;
end;

{$ENDIF FHIR_PERSON}
{$IFDEF FHIR_PRACTITIONER}
{ TFhirPractitionerQualification }

constructor TFhirPractitionerQualification.Create;
begin
  inherited;
end;

destructor TFhirPractitionerQualification.Destroy;
begin
  FIdentifierList.Free;
  FCode.free;
  FPeriod.free;
  FIssuer.free;
  inherited;
end;

procedure TFhirPractitionerQualification.Assign(oSource : TFslObject);
begin
  inherited;
  if (TFhirPractitionerQualification(oSource).FIdentifierList = nil) then
  begin
    FIdentifierList.free;
    FIdentifierList := nil;
  end
  else
  begin
    if FIdentifierList = nil then
      FIdentifierList := TFhirIdentifierList.Create;
    FIdentifierList.Assign(TFhirPractitionerQualification(oSource).FIdentifierList);
  end;
  code := TFhirPractitionerQualification(oSource).code.Clone;
  period := TFhirPractitionerQualification(oSource).period.Clone;
  issuer := TFhirPractitionerQualification(oSource).issuer.Clone;
end;

procedure TFhirPractitionerQualification.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'identifier') Then
    list.addAll(self, 'identifier', FIdentifierList);
  if (child_name = 'code') Then
     list.add(self.link, 'code', FCode.Link);
  if (child_name = 'period') Then
     list.add(self.link, 'period', FPeriod.Link);
  if (child_name = 'issuer') Then
     list.add(self.link, 'issuer', FIssuer.Link);
end;

procedure TFhirPractitionerQualification.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'identifier', 'Identifier', true, TFhirIdentifier, FIdentifierList.Link));
  oList.add(TFHIRProperty.create(self, 'code', 'CodeableConcept', false, TFhirCodeableConcept, FCode.Link));
  oList.add(TFHIRProperty.create(self, 'period', 'Period', false, TFhirPeriod, FPeriod.Link));
  oList.add(TFHIRProperty.create(self, 'issuer', 'Reference', false, TFhirReference, FIssuer.Link));
end;

function TFhirPractitionerQualification.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'identifier') then
  begin
    IdentifierList.add(propValue as TFhirIdentifier);
    result := propValue;
  end
  else if (propName = 'code') then
  begin
    Code := propValue as TFhirCodeableConcept;
    result := propValue;
  end
  else if (propName = 'period') then
  begin
    Period := propValue as TFhirPeriod;
    result := propValue;
  end
  else if (propName = 'issuer') then
  begin
    Issuer := propValue as TFhirReference;
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirPractitionerQualification.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'identifier') then IdentifierList.insertItem(index, propValue as TFhirIdentifier)
  else inherited;
end;

function TFhirPractitionerQualification.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'identifier') then result := IdentifierList.new()
  else if (propName = 'code') then result := TFhirCodeableConcept.create()
  else if (propName = 'period') then result := TFhirPeriod.create()
  else if (propName = 'issuer') then result := TFhirReference.create()
  else result := inherited createPropertyValue(propName);
end;

function TFhirPractitionerQualification.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'identifier') then result := 'Identifier'
  else if (propName = 'code') then result := 'CodeableConcept'
  else if (propName = 'period') then result := 'Period'
  else if (propName = 'issuer') then result := 'Reference'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirPractitionerQualification.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'identifier') then deletePropertyValue('identifier', IdentifierList, value)
  else if (propName = 'code') then CodeElement := nil
  else if (propName = 'period') then PeriodElement := nil
  else if (propName = 'issuer') then IssuerElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirPractitionerQualification.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'identifier') then replacePropertyValue('identifier', IdentifierList, existing, new)
  else if (propName = 'code') then CodeElement := new as TFhirCodeableConcept
  else if (propName = 'period') then PeriodElement := new as TFhirPeriod
  else if (propName = 'issuer') then IssuerElement := new as TFhirReference
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirPractitionerQualification.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'identifier') then IdentifierList.move(source, destination)
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirPractitionerQualification.fhirType : string;
begin
  result := 'Practitioner.qualification';
end;

function TFhirPractitionerQualification.Link : TFhirPractitionerQualification;
begin
  result := TFhirPractitionerQualification(inherited Link);
end;

function TFhirPractitionerQualification.Clone : TFhirPractitionerQualification;
begin
  result := TFhirPractitionerQualification(inherited Clone);
end;

function TFhirPractitionerQualification.equals(other : TObject) : boolean; 
var
  o : TFhirPractitionerQualification;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirPractitionerQualification)) then
    result := false
  else
  begin
    o := TFhirPractitionerQualification(other);
    result := compareDeep(identifierList, o.identifierList, true) and compareDeep(codeElement, o.codeElement, true) and 
      compareDeep(periodElement, o.periodElement, true) and compareDeep(issuerElement, o.issuerElement, true);
  end;
end;

function TFhirPractitionerQualification.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FidentifierList) and isEmptyProp(FCode) and isEmptyProp(FPeriod) and isEmptyProp(FIssuer);
end;

procedure TFhirPractitionerQualification.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('identifier');
  fields.add('code');
  fields.add('period');
  fields.add('issuer');
end;

function TFhirPractitionerQualification.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
  inc(result, FIdentifierList.sizeInBytes(magic));
end;

function TFhirPractitionerQualification.GetIdentifierList : TFhirIdentifierList;
begin
  if FIdentifierList = nil then
    FIdentifierList := TFhirIdentifierList.Create;
  result := FIdentifierList;
end;

function TFhirPractitionerQualification.GetHasIdentifierList : boolean;
begin
  result := (FIdentifierList <> nil) and (FIdentifierList.count > 0);
end;

procedure TFhirPractitionerQualification.SetCode(value : TFhirCodeableConcept);
begin
  FCode.free;
  FCode := value;
end;

procedure TFhirPractitionerQualification.SetPeriod(value : TFhirPeriod);
begin
  FPeriod.free;
  FPeriod := value;
end;

procedure TFhirPractitionerQualification.SetIssuer(value : TFhirReference);
begin
  FIssuer.free;
  FIssuer := value;
end;

{ TFhirPractitionerQualificationListEnumerator }

constructor TFhirPractitionerQualificationListEnumerator.Create(list : TFhirPractitionerQualificationList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirPractitionerQualificationListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirPractitionerQualificationListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirPractitionerQualificationListEnumerator.GetCurrent : TFhirPractitionerQualification;
begin
  Result := FList[FIndex];
end;

function TFhirPractitionerQualificationListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirPractitionerQualificationList }

function TFhirPractitionerQualificationList.AddItem(value: TFhirPractitionerQualification): TFhirPractitionerQualification;
begin
  assert(value.ClassName = 'TFhirPractitionerQualification', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirPractitionerQualification');
  add(value);
  result := value;
end;

function TFhirPractitionerQualificationList.Append: TFhirPractitionerQualification;
begin
  result := TFhirPractitionerQualification.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirPractitionerQualificationList.ClearItems;
begin
  Clear;
end;

function TFhirPractitionerQualificationList.GetEnumerator : TFhirPractitionerQualificationListEnumerator;
begin
  result := TFhirPractitionerQualificationListEnumerator.Create(self.link);
end;

function TFhirPractitionerQualificationList.Clone: TFhirPractitionerQualificationList;
begin
  result := TFhirPractitionerQualificationList(inherited Clone);
end;

function TFhirPractitionerQualificationList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirPractitionerQualificationList.GetItemN(index: Integer): TFhirPractitionerQualification;
begin
  result := TFhirPractitionerQualification(ObjectByIndex[index]);
end;

function TFhirPractitionerQualificationList.ItemClass: TFslObjectClass;
begin
  result := TFhirPractitionerQualification;
end;
function TFhirPractitionerQualificationList.IndexOf(value: TFhirPractitionerQualification): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirPractitionerQualificationList.Insert(index: Integer): TFhirPractitionerQualification;
begin
  result := TFhirPractitionerQualification.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirPractitionerQualificationList.InsertItem(index: Integer; value: TFhirPractitionerQualification);
begin
  assert(value is TFhirPractitionerQualification);
  Inherited Insert(index, value);
end;

function TFhirPractitionerQualificationList.Item(index: Integer): TFhirPractitionerQualification;
begin
  result := TFhirPractitionerQualification(ObjectByIndex[index]);
end;

function TFhirPractitionerQualificationList.Link: TFhirPractitionerQualificationList;
begin
  result := TFhirPractitionerQualificationList(inherited Link);
end;

procedure TFhirPractitionerQualificationList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirPractitionerQualificationList.SetItemByIndex(index: Integer; value: TFhirPractitionerQualification);
begin
  assert(value is TFhirPractitionerQualification);
  FhirPractitionerQualifications[index] := value;
end;

procedure TFhirPractitionerQualificationList.SetItemN(index: Integer; value: TFhirPractitionerQualification);
begin
  assert(value is TFhirPractitionerQualification);
  ObjectByIndex[index] := value;
end;

{ TFhirPractitioner }

constructor TFhirPractitioner.Create;
begin
  inherited;
end;

destructor TFhirPractitioner.Destroy;
begin
  FIdentifierList.Free;
  FActive.free;
  FNameList.Free;
  FTelecomList.Free;
  FGender.free;
  FBirthDate.free;
  FDeceased.free;
  FAddressList.Free;
  FPhotoList.Free;
  FQualificationList.Free;
  FCommunicationList.Free;
  inherited;
end;

procedure TFhirPractitioner.Assign(oSource : TFslObject);
begin
  inherited;
  if (TFhirPractitioner(oSource).FIdentifierList = nil) then
  begin
    FIdentifierList.free;
    FIdentifierList := nil;
  end
  else
  begin
    if FIdentifierList = nil then
      FIdentifierList := TFhirIdentifierList.Create;
    FIdentifierList.Assign(TFhirPractitioner(oSource).FIdentifierList);
  end;
  activeElement := TFhirPractitioner(oSource).activeElement.Clone;
  if (TFhirPractitioner(oSource).FNameList = nil) then
  begin
    FNameList.free;
    FNameList := nil;
  end
  else
  begin
    if FNameList = nil then
      FNameList := TFhirHumanNameList.Create;
    FNameList.Assign(TFhirPractitioner(oSource).FNameList);
  end;
  if (TFhirPractitioner(oSource).FTelecomList = nil) then
  begin
    FTelecomList.free;
    FTelecomList := nil;
  end
  else
  begin
    if FTelecomList = nil then
      FTelecomList := TFhirContactPointList.Create;
    FTelecomList.Assign(TFhirPractitioner(oSource).FTelecomList);
  end;
  genderElement := TFhirPractitioner(oSource).genderElement.Clone;
  birthDateElement := TFhirPractitioner(oSource).birthDateElement.Clone;
  deceased := TFhirPractitioner(oSource).deceased.Clone;
  if (TFhirPractitioner(oSource).FAddressList = nil) then
  begin
    FAddressList.free;
    FAddressList := nil;
  end
  else
  begin
    if FAddressList = nil then
      FAddressList := TFhirAddressList.Create;
    FAddressList.Assign(TFhirPractitioner(oSource).FAddressList);
  end;
  if (TFhirPractitioner(oSource).FPhotoList = nil) then
  begin
    FPhotoList.free;
    FPhotoList := nil;
  end
  else
  begin
    if FPhotoList = nil then
      FPhotoList := TFhirAttachmentList.Create;
    FPhotoList.Assign(TFhirPractitioner(oSource).FPhotoList);
  end;
  if (TFhirPractitioner(oSource).FQualificationList = nil) then
  begin
    FQualificationList.free;
    FQualificationList := nil;
  end
  else
  begin
    if FQualificationList = nil then
      FQualificationList := TFhirPractitionerQualificationList.Create;
    FQualificationList.Assign(TFhirPractitioner(oSource).FQualificationList);
  end;
  if (TFhirPractitioner(oSource).FCommunicationList = nil) then
  begin
    FCommunicationList.free;
    FCommunicationList := nil;
  end
  else
  begin
    if FCommunicationList = nil then
      FCommunicationList := TFhirCodeableConceptList.Create;
    FCommunicationList.Assign(TFhirPractitioner(oSource).FCommunicationList);
  end;
end;

function TFhirPractitioner.GetResourceType : TFhirResourceType;
begin
  result := frtPractitioner;
end;

procedure TFhirPractitioner.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'identifier') Then
    list.addAll(self, 'identifier', FIdentifierList);
  if (child_name = 'active') Then
     list.add(self.link, 'active', FActive.Link);
  if (child_name = 'name') Then
    list.addAll(self, 'name', FNameList);
  if (child_name = 'telecom') Then
    list.addAll(self, 'telecom', FTelecomList);
  if (child_name = 'gender') Then
     list.add(self.link, 'gender', FGender.Link);
  if (child_name = 'birthDate') Then
     list.add(self.link, 'birthDate', FBirthDate.Link);
  if (child_name = 'deceased[x]') or (child_name = 'deceased') Then
     list.add(self.link, 'deceased[x]', FDeceased.Link);
  if (child_name = 'address') Then
    list.addAll(self, 'address', FAddressList);
  if (child_name = 'photo') Then
    list.addAll(self, 'photo', FPhotoList);
  if (child_name = 'qualification') Then
    list.addAll(self, 'qualification', FQualificationList);
  if (child_name = 'communication') Then
    list.addAll(self, 'communication', FCommunicationList);
end;

procedure TFhirPractitioner.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'identifier', 'Identifier', true, TFhirIdentifier, FIdentifierList.Link));
  oList.add(TFHIRProperty.create(self, 'active', 'boolean', false, TFhirBoolean, FActive.Link));
  oList.add(TFHIRProperty.create(self, 'name', 'HumanName', true, TFhirHumanName, FNameList.Link));
  oList.add(TFHIRProperty.create(self, 'telecom', 'ContactPoint', true, TFhirContactPoint, FTelecomList.Link));
  oList.add(TFHIRProperty.create(self, 'gender', 'code', false, TFhirEnum, FGender.Link));
  oList.add(TFHIRProperty.create(self, 'birthDate', 'date', false, TFhirDate, FBirthDate.Link));
  oList.add(TFHIRProperty.create(self, 'deceased[x]', 'boolean|dateTime', false, TFhirDataType, FDeceased.Link));
  oList.add(TFHIRProperty.create(self, 'address', 'Address', true, TFhirAddress, FAddressList.Link));
  oList.add(TFHIRProperty.create(self, 'photo', 'Attachment', true, TFhirAttachment, FPhotoList.Link));
  oList.add(TFHIRProperty.create(self, 'qualification', 'BackboneElement', true, TFhirPractitionerQualification, FQualificationList.Link));
  oList.add(TFHIRProperty.create(self, 'communication', 'CodeableConcept', true, TFhirCodeableConcept, FCommunicationList.Link));
end;

function TFhirPractitioner.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'identifier') then
  begin
    IdentifierList.add(propValue as TFhirIdentifier);
    result := propValue;
  end
  else if (propName = 'active') then
  begin
    ActiveElement := asBoolean(propValue);
    result := propValue;
  end
  else if (propName = 'name') then
  begin
    NameList.add(propValue as TFhirHumanName);
    result := propValue;
  end
  else if (propName = 'telecom') then
  begin
    TelecomList.add(propValue as TFhirContactPoint);
    result := propValue;
  end
  else if (propName = 'gender') then
  begin
    GenderElement := asEnum(SYSTEMS_TFhirAdministrativeGenderEnum, CODES_TFhirAdministrativeGenderEnum, propValue);
    result := propValue;
  end
  else if (propName = 'birthDate') then
  begin
    BirthDateElement := asDate(propValue);
    result := propValue;
  end
  else if (isMatchingName(propName, 'deceased', ['Boolean', 'DateTime'])) then
  begin
    Deceased := propValue as TFhirDataType;
    result := propValue;
  end
  else if (propName = 'address') then
  begin
    AddressList.add(propValue as TFhirAddress);
    result := propValue;
  end
  else if (propName = 'photo') then
  begin
    PhotoList.add(propValue as TFhirAttachment);
    result := propValue;
  end
  else if (propName = 'qualification') then
  begin
    QualificationList.add(propValue as TFhirPractitionerQualification);
    result := propValue;
  end
  else if (propName = 'communication') then
  begin
    CommunicationList.add(propValue as TFhirCodeableConcept);
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirPractitioner.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'identifier') then IdentifierList.insertItem(index, propValue as TFhirIdentifier)
  else if (propName = 'name') then NameList.insertItem(index, propValue as TFhirHumanName)
  else if (propName = 'telecom') then TelecomList.insertItem(index, propValue as TFhirContactPoint)
  else if (propName = 'address') then AddressList.insertItem(index, propValue as TFhirAddress)
  else if (propName = 'photo') then PhotoList.insertItem(index, propValue as TFhirAttachment)
  else if (propName = 'qualification') then QualificationList.insertItem(index, propValue as TFhirPractitionerQualification)
  else if (propName = 'communication') then CommunicationList.insertItem(index, propValue as TFhirCodeableConcept)
  else inherited;
end;

function TFhirPractitioner.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'identifier') then result := IdentifierList.new()
  else if (propName = 'active') then result := TFhirBoolean.create()
  else if (propName = 'name') then result := NameList.new()
  else if (propName = 'telecom') then result := TelecomList.new()
  else if (propName = 'gender') then result := TFhirEnum.create(SYSTEMS_TFhirAdministrativeGenderEnum[AdministrativeGenderNull], CODES_TFhirAdministrativeGenderEnum[AdministrativeGenderNull]) 
  else if (propName = 'birthDate') then result := TFhirDate.create()
  else if (isMatchingName(propName, 'deceased', ['Boolean', 'DateTime'])) then raise EFHIRException.create('Cannot make property Deceased')
  else if (propName = 'address') then result := AddressList.new()
  else if (propName = 'photo') then result := PhotoList.new()
  else if (propName = 'qualification') then result := QualificationList.new()
  else if (propName = 'communication') then result := CommunicationList.new()
  else result := inherited createPropertyValue(propName);
end;

function TFhirPractitioner.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'identifier') then result := 'Identifier'
  else if (propName = 'active') then result := 'boolean'
  else if (propName = 'name') then result := 'HumanName'
  else if (propName = 'telecom') then result := 'ContactPoint'
  else if (propName = 'gender') then result := 'code'
  else if (propName = 'birthDate') then result := 'date'
  else if (propName = 'deceased[x]') then result := 'boolean|dateTime'
  else if (propName = 'address') then result := 'Address'
  else if (propName = 'photo') then result := 'Attachment'
  else if (propName = 'qualification') then result := 'BackboneElement'
  else if (propName = 'communication') then result := 'CodeableConcept'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirPractitioner.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'identifier') then deletePropertyValue('identifier', IdentifierList, value)
  else if (propName = 'active') then ActiveElement := nil
  else if (propName = 'name') then deletePropertyValue('name', NameList, value)
  else if (propName = 'telecom') then deletePropertyValue('telecom', TelecomList, value)
  else if (propName = 'gender') then GenderElement := nil
  else if (propName = 'birthDate') then BirthDateElement := nil
  else if (isMatchingName(propName, 'deceased', ['Boolean', 'DateTime'])) then DeceasedElement := nil
  else if (propName = 'address') then deletePropertyValue('address', AddressList, value)
  else if (propName = 'photo') then deletePropertyValue('photo', PhotoList, value)
  else if (propName = 'qualification') then deletePropertyValue('qualification', QualificationList, value)
  else if (propName = 'communication') then deletePropertyValue('communication', CommunicationList, value)
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirPractitioner.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'identifier') then replacePropertyValue('identifier', IdentifierList, existing, new)
  else if (propName = 'active') then ActiveElement := asBoolean(new)
  else if (propName = 'name') then replacePropertyValue('name', NameList, existing, new)
  else if (propName = 'telecom') then replacePropertyValue('telecom', TelecomList, existing, new)
  else if (propName = 'gender') then GenderElement := asEnum(SYSTEMS_TFhirAdministrativeGenderEnum, CODES_TFhirAdministrativeGenderEnum, new)
  else if (propName = 'birthDate') then BirthDateElement := asDate(new)
  else if (isMatchingName(propName, 'deceased', ['Boolean', 'DateTime'])) then DeceasedElement := new as TFhirDataType
  else if (propName = 'address') then replacePropertyValue('address', AddressList, existing, new)
  else if (propName = 'photo') then replacePropertyValue('photo', PhotoList, existing, new)
  else if (propName = 'qualification') then replacePropertyValue('qualification', QualificationList, existing, new)
  else if (propName = 'communication') then replacePropertyValue('communication', CommunicationList, existing, new)
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirPractitioner.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'identifier') then IdentifierList.move(source, destination)
  else if (propName = 'name') then NameList.move(source, destination)
  else if (propName = 'telecom') then TelecomList.move(source, destination)
  else if (propName = 'address') then AddressList.move(source, destination)
  else if (propName = 'photo') then PhotoList.move(source, destination)
  else if (propName = 'qualification') then QualificationList.move(source, destination)
  else if (propName = 'communication') then CommunicationList.move(source, destination)
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirPractitioner.fhirType : string;
begin
  result := 'Practitioner';
end;

function TFhirPractitioner.Link : TFhirPractitioner;
begin
  result := TFhirPractitioner(inherited Link);
end;

function TFhirPractitioner.Clone : TFhirPractitioner;
begin
  result := TFhirPractitioner(inherited Clone);
end;

function TFhirPractitioner.equals(other : TObject) : boolean; 
var
  o : TFhirPractitioner;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirPractitioner)) then
    result := false
  else
  begin
    o := TFhirPractitioner(other);
    result := compareDeep(identifierList, o.identifierList, true) and compareDeep(activeElement, o.activeElement, true) and 
      compareDeep(nameList, o.nameList, true) and compareDeep(telecomList, o.telecomList, true) and 
      compareDeep(genderElement, o.genderElement, true) and compareDeep(birthDateElement, o.birthDateElement, true) and 
      compareDeep(deceasedElement, o.deceasedElement, true) and compareDeep(addressList, o.addressList, true) and 
      compareDeep(photoList, o.photoList, true) and compareDeep(qualificationList, o.qualificationList, true) and 
      compareDeep(communicationList, o.communicationList, true);
  end;
end;

function TFhirPractitioner.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FidentifierList) and isEmptyProp(FActive) and isEmptyProp(FnameList) and isEmptyProp(FtelecomList) and isEmptyProp(FGender) and isEmptyProp(FBirthDate) and isEmptyProp(FDeceased) and isEmptyProp(FaddressList) and isEmptyProp(FphotoList) and isEmptyProp(FqualificationList) and isEmptyProp(FcommunicationList);
end;

procedure TFhirPractitioner.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('identifier');
  fields.add('active');
  fields.add('name');
  fields.add('telecom');
  fields.add('gender');
  fields.add('birthDate');
  fields.add('deceased[x]');
  fields.add('address');
  fields.add('photo');
  fields.add('qualification');
  fields.add('communication');
end;

function TFhirPractitioner.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
  inc(result, FIdentifierList.sizeInBytes(magic));
  inc(result, FNameList.sizeInBytes(magic));
  inc(result, FTelecomList.sizeInBytes(magic));
  inc(result, FAddressList.sizeInBytes(magic));
  inc(result, FPhotoList.sizeInBytes(magic));
  inc(result, FQualificationList.sizeInBytes(magic));
  inc(result, FCommunicationList.sizeInBytes(magic));
end;

function TFhirPractitioner.GetIdentifierList : TFhirIdentifierList;
begin
  if FIdentifierList = nil then
    FIdentifierList := TFhirIdentifierList.Create;
  result := FIdentifierList;
end;

function TFhirPractitioner.GetHasIdentifierList : boolean;
begin
  result := (FIdentifierList <> nil) and (FIdentifierList.count > 0);
end;

procedure TFhirPractitioner.SetActive(value : TFhirBoolean);
begin
  FActive.free;
  FActive := value;
end;

function TFhirPractitioner.GetActiveST : Boolean;
begin
  if FActive = nil then
    result := false
  else
    result := FActive.value;
end;

procedure TFhirPractitioner.SetActiveST(value : Boolean);
begin
  if FActive = nil then
    FActive := TFhirBoolean.create;
  FActive.value := value
end;

function TFhirPractitioner.GetNameList : TFhirHumanNameList;
begin
  if FNameList = nil then
    FNameList := TFhirHumanNameList.Create;
  result := FNameList;
end;

function TFhirPractitioner.GetHasNameList : boolean;
begin
  result := (FNameList <> nil) and (FNameList.count > 0);
end;

function TFhirPractitioner.GetTelecomList : TFhirContactPointList;
begin
  if FTelecomList = nil then
    FTelecomList := TFhirContactPointList.Create;
  result := FTelecomList;
end;

function TFhirPractitioner.GetHasTelecomList : boolean;
begin
  result := (FTelecomList <> nil) and (FTelecomList.count > 0);
end;

procedure TFhirPractitioner.SetGender(value : TFhirEnum);
begin
  FGender.free;
  FGender := value;
end;

function TFhirPractitioner.GetGenderST : TFhirAdministrativeGenderEnum;
begin
  if FGender = nil then
    result := TFhirAdministrativeGenderEnum(0)
  else
    result := TFhirAdministrativeGenderEnum(StringArrayIndexOfSensitive(CODES_TFhirAdministrativeGenderEnum, FGender.value));
end;

procedure TFhirPractitioner.SetGenderST(value : TFhirAdministrativeGenderEnum);
begin
  if ord(value) = 0 then
    GenderElement := nil
  else
    GenderElement := TFhirEnum.create(SYSTEMS_TFhirAdministrativeGenderEnum[value], CODES_TFhirAdministrativeGenderEnum[value]);
end;

procedure TFhirPractitioner.SetBirthDate(value : TFhirDate);
begin
  FBirthDate.free;
  FBirthDate := value;
end;

function TFhirPractitioner.GetBirthDateST : TFslDateTime;
begin
  if FBirthDate = nil then
    result := TFslDateTime.makeNull
  else
    result := FBirthDate.value;
end;

procedure TFhirPractitioner.SetBirthDateST(value : TFslDateTime);
begin
  if FBirthDate = nil then
    FBirthDate := TFhirDate.create;
  FBirthDate.value := value
end;

procedure TFhirPractitioner.SetDeceased(value : TFhirDataType);
begin
  FDeceased.free;
  FDeceased := value;
end;

function TFhirPractitioner.GetAddressList : TFhirAddressList;
begin
  if FAddressList = nil then
    FAddressList := TFhirAddressList.Create;
  result := FAddressList;
end;

function TFhirPractitioner.GetHasAddressList : boolean;
begin
  result := (FAddressList <> nil) and (FAddressList.count > 0);
end;

function TFhirPractitioner.GetPhotoList : TFhirAttachmentList;
begin
  if FPhotoList = nil then
    FPhotoList := TFhirAttachmentList.Create;
  result := FPhotoList;
end;

function TFhirPractitioner.GetHasPhotoList : boolean;
begin
  result := (FPhotoList <> nil) and (FPhotoList.count > 0);
end;

function TFhirPractitioner.GetQualificationList : TFhirPractitionerQualificationList;
begin
  if FQualificationList = nil then
    FQualificationList := TFhirPractitionerQualificationList.Create;
  result := FQualificationList;
end;

function TFhirPractitioner.GetHasQualificationList : boolean;
begin
  result := (FQualificationList <> nil) and (FQualificationList.count > 0);
end;

function TFhirPractitioner.GetCommunicationList : TFhirCodeableConceptList;
begin
  if FCommunicationList = nil then
    FCommunicationList := TFhirCodeableConceptList.Create;
  result := FCommunicationList;
end;

function TFhirPractitioner.GetHasCommunicationList : boolean;
begin
  result := (FCommunicationList <> nil) and (FCommunicationList.count > 0);
end;

{ TFhirPractitionerListEnumerator }

constructor TFhirPractitionerListEnumerator.Create(list : TFhirPractitionerList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirPractitionerListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirPractitionerListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirPractitionerListEnumerator.GetCurrent : TFhirPractitioner;
begin
  Result := FList[FIndex];
end;

function TFhirPractitionerListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirPractitionerList }

function TFhirPractitionerList.AddItem(value: TFhirPractitioner): TFhirPractitioner;
begin
  assert(value.ClassName = 'TFhirPractitioner', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirPractitioner');
  add(value);
  result := value;
end;

function TFhirPractitionerList.Append: TFhirPractitioner;
begin
  result := TFhirPractitioner.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirPractitionerList.ClearItems;
begin
  Clear;
end;

function TFhirPractitionerList.GetEnumerator : TFhirPractitionerListEnumerator;
begin
  result := TFhirPractitionerListEnumerator.Create(self.link);
end;

function TFhirPractitionerList.Clone: TFhirPractitionerList;
begin
  result := TFhirPractitionerList(inherited Clone);
end;

function TFhirPractitionerList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirPractitionerList.GetItemN(index: Integer): TFhirPractitioner;
begin
  result := TFhirPractitioner(ObjectByIndex[index]);
end;

function TFhirPractitionerList.ItemClass: TFslObjectClass;
begin
  result := TFhirPractitioner;
end;
function TFhirPractitionerList.IndexOf(value: TFhirPractitioner): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirPractitionerList.Insert(index: Integer): TFhirPractitioner;
begin
  result := TFhirPractitioner.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirPractitionerList.InsertItem(index: Integer; value: TFhirPractitioner);
begin
  assert(value is TFhirPractitioner);
  Inherited Insert(index, value);
end;

function TFhirPractitionerList.Item(index: Integer): TFhirPractitioner;
begin
  result := TFhirPractitioner(ObjectByIndex[index]);
end;

function TFhirPractitionerList.Link: TFhirPractitionerList;
begin
  result := TFhirPractitionerList(inherited Link);
end;

procedure TFhirPractitionerList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirPractitionerList.SetItemByIndex(index: Integer; value: TFhirPractitioner);
begin
  assert(value is TFhirPractitioner);
  FhirPractitioners[index] := value;
end;

procedure TFhirPractitionerList.SetItemN(index: Integer; value: TFhirPractitioner);
begin
  assert(value is TFhirPractitioner);
  ObjectByIndex[index] := value;
end;

{$ENDIF FHIR_PRACTITIONER}
{$IFDEF FHIR_PRACTITIONERROLE}
{ TFhirPractitionerRole }

constructor TFhirPractitionerRole.Create;
begin
  inherited;
end;

destructor TFhirPractitionerRole.Destroy;
begin
  FIdentifierList.Free;
  FActive.free;
  FPeriod.free;
  FPractitioner.free;
  FOrganization.free;
  FCodeList.Free;
  FSpecialtyList.Free;
  FLocationList.Free;
  FHealthcareServiceList.Free;
  FContactList.Free;
  FAvailabilityList.Free;
  FEndpointList.Free;
  inherited;
end;

procedure TFhirPractitionerRole.Assign(oSource : TFslObject);
begin
  inherited;
  if (TFhirPractitionerRole(oSource).FIdentifierList = nil) then
  begin
    FIdentifierList.free;
    FIdentifierList := nil;
  end
  else
  begin
    if FIdentifierList = nil then
      FIdentifierList := TFhirIdentifierList.Create;
    FIdentifierList.Assign(TFhirPractitionerRole(oSource).FIdentifierList);
  end;
  activeElement := TFhirPractitionerRole(oSource).activeElement.Clone;
  period := TFhirPractitionerRole(oSource).period.Clone;
  practitioner := TFhirPractitionerRole(oSource).practitioner.Clone;
  organization := TFhirPractitionerRole(oSource).organization.Clone;
  if (TFhirPractitionerRole(oSource).FCodeList = nil) then
  begin
    FCodeList.free;
    FCodeList := nil;
  end
  else
  begin
    if FCodeList = nil then
      FCodeList := TFhirCodeableConceptList.Create;
    FCodeList.Assign(TFhirPractitionerRole(oSource).FCodeList);
  end;
  if (TFhirPractitionerRole(oSource).FSpecialtyList = nil) then
  begin
    FSpecialtyList.free;
    FSpecialtyList := nil;
  end
  else
  begin
    if FSpecialtyList = nil then
      FSpecialtyList := TFhirCodeableConceptList.Create;
    FSpecialtyList.Assign(TFhirPractitionerRole(oSource).FSpecialtyList);
  end;
  if (TFhirPractitionerRole(oSource).FLocationList = nil) then
  begin
    FLocationList.free;
    FLocationList := nil;
  end
  else
  begin
    if FLocationList = nil then
      FLocationList := TFhirReferenceList.Create;
    FLocationList.Assign(TFhirPractitionerRole(oSource).FLocationList);
  end;
  if (TFhirPractitionerRole(oSource).FHealthcareServiceList = nil) then
  begin
    FHealthcareServiceList.free;
    FHealthcareServiceList := nil;
  end
  else
  begin
    if FHealthcareServiceList = nil then
      FHealthcareServiceList := TFhirReferenceList.Create;
    FHealthcareServiceList.Assign(TFhirPractitionerRole(oSource).FHealthcareServiceList);
  end;
  if (TFhirPractitionerRole(oSource).FContactList = nil) then
  begin
    FContactList.free;
    FContactList := nil;
  end
  else
  begin
    if FContactList = nil then
      FContactList := TFhirExtendedContactDetailList.Create;
    FContactList.Assign(TFhirPractitionerRole(oSource).FContactList);
  end;
  if (TFhirPractitionerRole(oSource).FAvailabilityList = nil) then
  begin
    FAvailabilityList.free;
    FAvailabilityList := nil;
  end
  else
  begin
    if FAvailabilityList = nil then
      FAvailabilityList := TFhirAvailabilityList.Create;
    FAvailabilityList.Assign(TFhirPractitionerRole(oSource).FAvailabilityList);
  end;
  if (TFhirPractitionerRole(oSource).FEndpointList = nil) then
  begin
    FEndpointList.free;
    FEndpointList := nil;
  end
  else
  begin
    if FEndpointList = nil then
      FEndpointList := TFhirReferenceList.Create;
    FEndpointList.Assign(TFhirPractitionerRole(oSource).FEndpointList);
  end;
end;

function TFhirPractitionerRole.GetResourceType : TFhirResourceType;
begin
  result := frtPractitionerRole;
end;

procedure TFhirPractitionerRole.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'identifier') Then
    list.addAll(self, 'identifier', FIdentifierList);
  if (child_name = 'active') Then
     list.add(self.link, 'active', FActive.Link);
  if (child_name = 'period') Then
     list.add(self.link, 'period', FPeriod.Link);
  if (child_name = 'practitioner') Then
     list.add(self.link, 'practitioner', FPractitioner.Link);
  if (child_name = 'organization') Then
     list.add(self.link, 'organization', FOrganization.Link);
  if (child_name = 'code') Then
    list.addAll(self, 'code', FCodeList);
  if (child_name = 'specialty') Then
    list.addAll(self, 'specialty', FSpecialtyList);
  if (child_name = 'location') Then
    list.addAll(self, 'location', FLocationList);
  if (child_name = 'healthcareService') Then
    list.addAll(self, 'healthcareService', FHealthcareServiceList);
  if (child_name = 'contact') Then
    list.addAll(self, 'contact', FContactList);
  if (child_name = 'availability') Then
    list.addAll(self, 'availability', FAvailabilityList);
  if (child_name = 'endpoint') Then
    list.addAll(self, 'endpoint', FEndpointList);
end;

procedure TFhirPractitionerRole.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'identifier', 'Identifier', true, TFhirIdentifier, FIdentifierList.Link));
  oList.add(TFHIRProperty.create(self, 'active', 'boolean', false, TFhirBoolean, FActive.Link));
  oList.add(TFHIRProperty.create(self, 'period', 'Period', false, TFhirPeriod, FPeriod.Link));
  oList.add(TFHIRProperty.create(self, 'practitioner', 'Reference', false, TFhirReference, FPractitioner.Link));
  oList.add(TFHIRProperty.create(self, 'organization', 'Reference', false, TFhirReference, FOrganization.Link));
  oList.add(TFHIRProperty.create(self, 'code', 'CodeableConcept', true, TFhirCodeableConcept, FCodeList.Link));
  oList.add(TFHIRProperty.create(self, 'specialty', 'CodeableConcept', true, TFhirCodeableConcept, FSpecialtyList.Link));
  oList.add(TFHIRProperty.create(self, 'location', 'Reference', true, TFhirReference, FLocationList.Link));
  oList.add(TFHIRProperty.create(self, 'healthcareService', 'Reference', true, TFhirReference, FHealthcareServiceList.Link));
  oList.add(TFHIRProperty.create(self, 'contact', 'ExtendedContactDetail', true, TFhirExtendedContactDetail, FContactList.Link));
  oList.add(TFHIRProperty.create(self, 'availability', 'Availability', true, TFhirAvailability, FAvailabilityList.Link));
  oList.add(TFHIRProperty.create(self, 'endpoint', 'Reference', true, TFhirReference, FEndpointList.Link));
end;

function TFhirPractitionerRole.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'identifier') then
  begin
    IdentifierList.add(propValue as TFhirIdentifier);
    result := propValue;
  end
  else if (propName = 'active') then
  begin
    ActiveElement := asBoolean(propValue);
    result := propValue;
  end
  else if (propName = 'period') then
  begin
    Period := propValue as TFhirPeriod;
    result := propValue;
  end
  else if (propName = 'practitioner') then
  begin
    Practitioner := propValue as TFhirReference;
    result := propValue;
  end
  else if (propName = 'organization') then
  begin
    Organization := propValue as TFhirReference;
    result := propValue;
  end
  else if (propName = 'code') then
  begin
    CodeList.add(propValue as TFhirCodeableConcept);
    result := propValue;
  end
  else if (propName = 'specialty') then
  begin
    SpecialtyList.add(propValue as TFhirCodeableConcept);
    result := propValue;
  end
  else if (propName = 'location') then
  begin
    LocationList.add(propValue as TFhirReference);
    result := propValue;
  end
  else if (propName = 'healthcareService') then
  begin
    HealthcareServiceList.add(propValue as TFhirReference);
    result := propValue;
  end
  else if (propName = 'contact') then
  begin
    ContactList.add(propValue as TFhirExtendedContactDetail);
    result := propValue;
  end
  else if (propName = 'availability') then
  begin
    AvailabilityList.add(propValue as TFhirAvailability);
    result := propValue;
  end
  else if (propName = 'endpoint') then
  begin
    EndpointList.add(propValue as TFhirReference);
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirPractitionerRole.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'identifier') then IdentifierList.insertItem(index, propValue as TFhirIdentifier)
  else if (propName = 'code') then CodeList.insertItem(index, propValue as TFhirCodeableConcept)
  else if (propName = 'specialty') then SpecialtyList.insertItem(index, propValue as TFhirCodeableConcept)
  else if (propName = 'location') then LocationList.insertItem(index, propValue as TFhirReference)
  else if (propName = 'healthcareService') then HealthcareServiceList.insertItem(index, propValue as TFhirReference)
  else if (propName = 'contact') then ContactList.insertItem(index, propValue as TFhirExtendedContactDetail)
  else if (propName = 'availability') then AvailabilityList.insertItem(index, propValue as TFhirAvailability)
  else if (propName = 'endpoint') then EndpointList.insertItem(index, propValue as TFhirReference)
  else inherited;
end;

function TFhirPractitionerRole.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'identifier') then result := IdentifierList.new()
  else if (propName = 'active') then result := TFhirBoolean.create()
  else if (propName = 'period') then result := TFhirPeriod.create()
  else if (propName = 'practitioner') then result := TFhirReference.create()
  else if (propName = 'organization') then result := TFhirReference.create()
  else if (propName = 'code') then result := CodeList.new()
  else if (propName = 'specialty') then result := SpecialtyList.new()
  else if (propName = 'location') then result := LocationList.new()
  else if (propName = 'healthcareService') then result := HealthcareServiceList.new()
  else if (propName = 'contact') then result := ContactList.new()
  else if (propName = 'availability') then result := AvailabilityList.new()
  else if (propName = 'endpoint') then result := EndpointList.new()
  else result := inherited createPropertyValue(propName);
end;

function TFhirPractitionerRole.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'identifier') then result := 'Identifier'
  else if (propName = 'active') then result := 'boolean'
  else if (propName = 'period') then result := 'Period'
  else if (propName = 'practitioner') then result := 'Reference'
  else if (propName = 'organization') then result := 'Reference'
  else if (propName = 'code') then result := 'CodeableConcept'
  else if (propName = 'specialty') then result := 'CodeableConcept'
  else if (propName = 'location') then result := 'Reference'
  else if (propName = 'healthcareService') then result := 'Reference'
  else if (propName = 'contact') then result := 'ExtendedContactDetail'
  else if (propName = 'availability') then result := 'Availability'
  else if (propName = 'endpoint') then result := 'Reference'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirPractitionerRole.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'identifier') then deletePropertyValue('identifier', IdentifierList, value)
  else if (propName = 'active') then ActiveElement := nil
  else if (propName = 'period') then PeriodElement := nil
  else if (propName = 'practitioner') then PractitionerElement := nil
  else if (propName = 'organization') then OrganizationElement := nil
  else if (propName = 'code') then deletePropertyValue('code', CodeList, value)
  else if (propName = 'specialty') then deletePropertyValue('specialty', SpecialtyList, value)
  else if (propName = 'location') then deletePropertyValue('location', LocationList, value)
  else if (propName = 'healthcareService') then deletePropertyValue('healthcareService', HealthcareServiceList, value)
  else if (propName = 'contact') then deletePropertyValue('contact', ContactList, value)
  else if (propName = 'availability') then deletePropertyValue('availability', AvailabilityList, value)
  else if (propName = 'endpoint') then deletePropertyValue('endpoint', EndpointList, value)
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirPractitionerRole.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'identifier') then replacePropertyValue('identifier', IdentifierList, existing, new)
  else if (propName = 'active') then ActiveElement := asBoolean(new)
  else if (propName = 'period') then PeriodElement := new as TFhirPeriod
  else if (propName = 'practitioner') then PractitionerElement := new as TFhirReference
  else if (propName = 'organization') then OrganizationElement := new as TFhirReference
  else if (propName = 'code') then replacePropertyValue('code', CodeList, existing, new)
  else if (propName = 'specialty') then replacePropertyValue('specialty', SpecialtyList, existing, new)
  else if (propName = 'location') then replacePropertyValue('location', LocationList, existing, new)
  else if (propName = 'healthcareService') then replacePropertyValue('healthcareService', HealthcareServiceList, existing, new)
  else if (propName = 'contact') then replacePropertyValue('contact', ContactList, existing, new)
  else if (propName = 'availability') then replacePropertyValue('availability', AvailabilityList, existing, new)
  else if (propName = 'endpoint') then replacePropertyValue('endpoint', EndpointList, existing, new)
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirPractitionerRole.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'identifier') then IdentifierList.move(source, destination)
  else if (propName = 'code') then CodeList.move(source, destination)
  else if (propName = 'specialty') then SpecialtyList.move(source, destination)
  else if (propName = 'location') then LocationList.move(source, destination)
  else if (propName = 'healthcareService') then HealthcareServiceList.move(source, destination)
  else if (propName = 'contact') then ContactList.move(source, destination)
  else if (propName = 'availability') then AvailabilityList.move(source, destination)
  else if (propName = 'endpoint') then EndpointList.move(source, destination)
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirPractitionerRole.fhirType : string;
begin
  result := 'PractitionerRole';
end;

function TFhirPractitionerRole.Link : TFhirPractitionerRole;
begin
  result := TFhirPractitionerRole(inherited Link);
end;

function TFhirPractitionerRole.Clone : TFhirPractitionerRole;
begin
  result := TFhirPractitionerRole(inherited Clone);
end;

function TFhirPractitionerRole.equals(other : TObject) : boolean; 
var
  o : TFhirPractitionerRole;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirPractitionerRole)) then
    result := false
  else
  begin
    o := TFhirPractitionerRole(other);
    result := compareDeep(identifierList, o.identifierList, true) and compareDeep(activeElement, o.activeElement, true) and 
      compareDeep(periodElement, o.periodElement, true) and compareDeep(practitionerElement, o.practitionerElement, true) and 
      compareDeep(organizationElement, o.organizationElement, true) and compareDeep(codeList, o.codeList, true) and 
      compareDeep(specialtyList, o.specialtyList, true) and compareDeep(locationList, o.locationList, true) and 
      compareDeep(healthcareServiceList, o.healthcareServiceList, true) and compareDeep(contactList, o.contactList, true) and 
      compareDeep(availabilityList, o.availabilityList, true) and compareDeep(endpointList, o.endpointList, true);
  end;
end;

function TFhirPractitionerRole.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FidentifierList) and isEmptyProp(FActive) and isEmptyProp(FPeriod) and isEmptyProp(FPractitioner) and isEmptyProp(FOrganization) and isEmptyProp(FcodeList) and isEmptyProp(FspecialtyList) and isEmptyProp(FlocationList) and isEmptyProp(FhealthcareServiceList) and isEmptyProp(FcontactList) and isEmptyProp(FavailabilityList) and isEmptyProp(FendpointList);
end;

procedure TFhirPractitionerRole.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('identifier');
  fields.add('active');
  fields.add('period');
  fields.add('practitioner');
  fields.add('organization');
  fields.add('code');
  fields.add('specialty');
  fields.add('location');
  fields.add('healthcareService');
  fields.add('contact');
  fields.add('availability');
  fields.add('endpoint');
end;

function TFhirPractitionerRole.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
  inc(result, FIdentifierList.sizeInBytes(magic));
  inc(result, FCodeList.sizeInBytes(magic));
  inc(result, FSpecialtyList.sizeInBytes(magic));
  inc(result, FLocationList.sizeInBytes(magic));
  inc(result, FHealthcareServiceList.sizeInBytes(magic));
  inc(result, FContactList.sizeInBytes(magic));
  inc(result, FAvailabilityList.sizeInBytes(magic));
  inc(result, FEndpointList.sizeInBytes(magic));
end;

function TFhirPractitionerRole.GetIdentifierList : TFhirIdentifierList;
begin
  if FIdentifierList = nil then
    FIdentifierList := TFhirIdentifierList.Create;
  result := FIdentifierList;
end;

function TFhirPractitionerRole.GetHasIdentifierList : boolean;
begin
  result := (FIdentifierList <> nil) and (FIdentifierList.count > 0);
end;

procedure TFhirPractitionerRole.SetActive(value : TFhirBoolean);
begin
  FActive.free;
  FActive := value;
end;

function TFhirPractitionerRole.GetActiveST : Boolean;
begin
  if FActive = nil then
    result := false
  else
    result := FActive.value;
end;

procedure TFhirPractitionerRole.SetActiveST(value : Boolean);
begin
  if FActive = nil then
    FActive := TFhirBoolean.create;
  FActive.value := value
end;

procedure TFhirPractitionerRole.SetPeriod(value : TFhirPeriod);
begin
  FPeriod.free;
  FPeriod := value;
end;

procedure TFhirPractitionerRole.SetPractitioner(value : TFhirReference);
begin
  FPractitioner.free;
  FPractitioner := value;
end;

procedure TFhirPractitionerRole.SetOrganization(value : TFhirReference);
begin
  FOrganization.free;
  FOrganization := value;
end;

function TFhirPractitionerRole.GetCodeList : TFhirCodeableConceptList;
begin
  if FCodeList = nil then
    FCodeList := TFhirCodeableConceptList.Create;
  result := FCodeList;
end;

function TFhirPractitionerRole.GetHasCodeList : boolean;
begin
  result := (FCodeList <> nil) and (FCodeList.count > 0);
end;

function TFhirPractitionerRole.GetSpecialtyList : TFhirCodeableConceptList;
begin
  if FSpecialtyList = nil then
    FSpecialtyList := TFhirCodeableConceptList.Create;
  result := FSpecialtyList;
end;

function TFhirPractitionerRole.GetHasSpecialtyList : boolean;
begin
  result := (FSpecialtyList <> nil) and (FSpecialtyList.count > 0);
end;

function TFhirPractitionerRole.GetLocationList : TFhirReferenceList;
begin
  if FLocationList = nil then
    FLocationList := TFhirReferenceList.Create;
  result := FLocationList;
end;

function TFhirPractitionerRole.GetHasLocationList : boolean;
begin
  result := (FLocationList <> nil) and (FLocationList.count > 0);
end;

function TFhirPractitionerRole.GetHealthcareServiceList : TFhirReferenceList;
begin
  if FHealthcareServiceList = nil then
    FHealthcareServiceList := TFhirReferenceList.Create;
  result := FHealthcareServiceList;
end;

function TFhirPractitionerRole.GetHasHealthcareServiceList : boolean;
begin
  result := (FHealthcareServiceList <> nil) and (FHealthcareServiceList.count > 0);
end;

function TFhirPractitionerRole.GetContactList : TFhirExtendedContactDetailList;
begin
  if FContactList = nil then
    FContactList := TFhirExtendedContactDetailList.Create;
  result := FContactList;
end;

function TFhirPractitionerRole.GetHasContactList : boolean;
begin
  result := (FContactList <> nil) and (FContactList.count > 0);
end;

function TFhirPractitionerRole.GetAvailabilityList : TFhirAvailabilityList;
begin
  if FAvailabilityList = nil then
    FAvailabilityList := TFhirAvailabilityList.Create;
  result := FAvailabilityList;
end;

function TFhirPractitionerRole.GetHasAvailabilityList : boolean;
begin
  result := (FAvailabilityList <> nil) and (FAvailabilityList.count > 0);
end;

function TFhirPractitionerRole.GetEndpointList : TFhirReferenceList;
begin
  if FEndpointList = nil then
    FEndpointList := TFhirReferenceList.Create;
  result := FEndpointList;
end;

function TFhirPractitionerRole.GetHasEndpointList : boolean;
begin
  result := (FEndpointList <> nil) and (FEndpointList.count > 0);
end;

{ TFhirPractitionerRoleListEnumerator }

constructor TFhirPractitionerRoleListEnumerator.Create(list : TFhirPractitionerRoleList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirPractitionerRoleListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirPractitionerRoleListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirPractitionerRoleListEnumerator.GetCurrent : TFhirPractitionerRole;
begin
  Result := FList[FIndex];
end;

function TFhirPractitionerRoleListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirPractitionerRoleList }

function TFhirPractitionerRoleList.AddItem(value: TFhirPractitionerRole): TFhirPractitionerRole;
begin
  assert(value.ClassName = 'TFhirPractitionerRole', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirPractitionerRole');
  add(value);
  result := value;
end;

function TFhirPractitionerRoleList.Append: TFhirPractitionerRole;
begin
  result := TFhirPractitionerRole.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirPractitionerRoleList.ClearItems;
begin
  Clear;
end;

function TFhirPractitionerRoleList.GetEnumerator : TFhirPractitionerRoleListEnumerator;
begin
  result := TFhirPractitionerRoleListEnumerator.Create(self.link);
end;

function TFhirPractitionerRoleList.Clone: TFhirPractitionerRoleList;
begin
  result := TFhirPractitionerRoleList(inherited Clone);
end;

function TFhirPractitionerRoleList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirPractitionerRoleList.GetItemN(index: Integer): TFhirPractitionerRole;
begin
  result := TFhirPractitionerRole(ObjectByIndex[index]);
end;

function TFhirPractitionerRoleList.ItemClass: TFslObjectClass;
begin
  result := TFhirPractitionerRole;
end;
function TFhirPractitionerRoleList.IndexOf(value: TFhirPractitionerRole): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirPractitionerRoleList.Insert(index: Integer): TFhirPractitionerRole;
begin
  result := TFhirPractitionerRole.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirPractitionerRoleList.InsertItem(index: Integer; value: TFhirPractitionerRole);
begin
  assert(value is TFhirPractitionerRole);
  Inherited Insert(index, value);
end;

function TFhirPractitionerRoleList.Item(index: Integer): TFhirPractitionerRole;
begin
  result := TFhirPractitionerRole(ObjectByIndex[index]);
end;

function TFhirPractitionerRoleList.Link: TFhirPractitionerRoleList;
begin
  result := TFhirPractitionerRoleList(inherited Link);
end;

procedure TFhirPractitionerRoleList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirPractitionerRoleList.SetItemByIndex(index: Integer; value: TFhirPractitionerRole);
begin
  assert(value is TFhirPractitionerRole);
  FhirPractitionerRoles[index] := value;
end;

procedure TFhirPractitionerRoleList.SetItemN(index: Integer; value: TFhirPractitionerRole);
begin
  assert(value is TFhirPractitionerRole);
  ObjectByIndex[index] := value;
end;

{$ENDIF FHIR_PRACTITIONERROLE}
{$IFDEF FHIR_RELATEDPERSON}
{ TFhirRelatedPersonCommunication }

constructor TFhirRelatedPersonCommunication.Create;
begin
  inherited;
end;

destructor TFhirRelatedPersonCommunication.Destroy;
begin
  FLanguage.free;
  FPreferred.free;
  inherited;
end;

procedure TFhirRelatedPersonCommunication.Assign(oSource : TFslObject);
begin
  inherited;
  language := TFhirRelatedPersonCommunication(oSource).language.Clone;
  preferredElement := TFhirRelatedPersonCommunication(oSource).preferredElement.Clone;
end;

procedure TFhirRelatedPersonCommunication.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'language') Then
     list.add(self.link, 'language', FLanguage.Link);
  if (child_name = 'preferred') Then
     list.add(self.link, 'preferred', FPreferred.Link);
end;

procedure TFhirRelatedPersonCommunication.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'language', 'CodeableConcept', false, TFhirCodeableConcept, FLanguage.Link));
  oList.add(TFHIRProperty.create(self, 'preferred', 'boolean', false, TFhirBoolean, FPreferred.Link));
end;

function TFhirRelatedPersonCommunication.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'language') then
  begin
    Language := propValue as TFhirCodeableConcept;
    result := propValue;
  end
  else if (propName = 'preferred') then
  begin
    PreferredElement := asBoolean(propValue);
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirRelatedPersonCommunication.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirRelatedPersonCommunication.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'language') then result := TFhirCodeableConcept.create()
  else if (propName = 'preferred') then result := TFhirBoolean.create()
  else result := inherited createPropertyValue(propName);
end;

function TFhirRelatedPersonCommunication.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'language') then result := 'CodeableConcept'
  else if (propName = 'preferred') then result := 'boolean'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirRelatedPersonCommunication.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'language') then LanguageElement := nil
  else if (propName = 'preferred') then PreferredElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirRelatedPersonCommunication.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'language') then LanguageElement := new as TFhirCodeableConcept
  else if (propName = 'preferred') then PreferredElement := asBoolean(new)
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirRelatedPersonCommunication.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirRelatedPersonCommunication.fhirType : string;
begin
  result := 'RelatedPerson.communication';
end;

function TFhirRelatedPersonCommunication.Link : TFhirRelatedPersonCommunication;
begin
  result := TFhirRelatedPersonCommunication(inherited Link);
end;

function TFhirRelatedPersonCommunication.Clone : TFhirRelatedPersonCommunication;
begin
  result := TFhirRelatedPersonCommunication(inherited Clone);
end;

function TFhirRelatedPersonCommunication.equals(other : TObject) : boolean; 
var
  o : TFhirRelatedPersonCommunication;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirRelatedPersonCommunication)) then
    result := false
  else
  begin
    o := TFhirRelatedPersonCommunication(other);
    result := compareDeep(languageElement, o.languageElement, true) and compareDeep(preferredElement, o.preferredElement, true);
  end;
end;

function TFhirRelatedPersonCommunication.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FLanguage) and isEmptyProp(FPreferred);
end;

procedure TFhirRelatedPersonCommunication.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('language');
  fields.add('preferred');
end;

function TFhirRelatedPersonCommunication.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
end;

procedure TFhirRelatedPersonCommunication.SetLanguage(value : TFhirCodeableConcept);
begin
  FLanguage.free;
  FLanguage := value;
end;

procedure TFhirRelatedPersonCommunication.SetPreferred(value : TFhirBoolean);
begin
  FPreferred.free;
  FPreferred := value;
end;

function TFhirRelatedPersonCommunication.GetPreferredST : Boolean;
begin
  if FPreferred = nil then
    result := false
  else
    result := FPreferred.value;
end;

procedure TFhirRelatedPersonCommunication.SetPreferredST(value : Boolean);
begin
  if FPreferred = nil then
    FPreferred := TFhirBoolean.create;
  FPreferred.value := value
end;

{ TFhirRelatedPersonCommunicationListEnumerator }

constructor TFhirRelatedPersonCommunicationListEnumerator.Create(list : TFhirRelatedPersonCommunicationList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirRelatedPersonCommunicationListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirRelatedPersonCommunicationListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirRelatedPersonCommunicationListEnumerator.GetCurrent : TFhirRelatedPersonCommunication;
begin
  Result := FList[FIndex];
end;

function TFhirRelatedPersonCommunicationListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirRelatedPersonCommunicationList }

function TFhirRelatedPersonCommunicationList.AddItem(value: TFhirRelatedPersonCommunication): TFhirRelatedPersonCommunication;
begin
  assert(value.ClassName = 'TFhirRelatedPersonCommunication', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirRelatedPersonCommunication');
  add(value);
  result := value;
end;

function TFhirRelatedPersonCommunicationList.Append: TFhirRelatedPersonCommunication;
begin
  result := TFhirRelatedPersonCommunication.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirRelatedPersonCommunicationList.ClearItems;
begin
  Clear;
end;

function TFhirRelatedPersonCommunicationList.GetEnumerator : TFhirRelatedPersonCommunicationListEnumerator;
begin
  result := TFhirRelatedPersonCommunicationListEnumerator.Create(self.link);
end;

function TFhirRelatedPersonCommunicationList.Clone: TFhirRelatedPersonCommunicationList;
begin
  result := TFhirRelatedPersonCommunicationList(inherited Clone);
end;

function TFhirRelatedPersonCommunicationList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirRelatedPersonCommunicationList.GetItemN(index: Integer): TFhirRelatedPersonCommunication;
begin
  result := TFhirRelatedPersonCommunication(ObjectByIndex[index]);
end;

function TFhirRelatedPersonCommunicationList.ItemClass: TFslObjectClass;
begin
  result := TFhirRelatedPersonCommunication;
end;
function TFhirRelatedPersonCommunicationList.IndexOf(value: TFhirRelatedPersonCommunication): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirRelatedPersonCommunicationList.Insert(index: Integer): TFhirRelatedPersonCommunication;
begin
  result := TFhirRelatedPersonCommunication.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirRelatedPersonCommunicationList.InsertItem(index: Integer; value: TFhirRelatedPersonCommunication);
begin
  assert(value is TFhirRelatedPersonCommunication);
  Inherited Insert(index, value);
end;

function TFhirRelatedPersonCommunicationList.Item(index: Integer): TFhirRelatedPersonCommunication;
begin
  result := TFhirRelatedPersonCommunication(ObjectByIndex[index]);
end;

function TFhirRelatedPersonCommunicationList.Link: TFhirRelatedPersonCommunicationList;
begin
  result := TFhirRelatedPersonCommunicationList(inherited Link);
end;

procedure TFhirRelatedPersonCommunicationList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirRelatedPersonCommunicationList.SetItemByIndex(index: Integer; value: TFhirRelatedPersonCommunication);
begin
  assert(value is TFhirRelatedPersonCommunication);
  FhirRelatedPersonCommunications[index] := value;
end;

procedure TFhirRelatedPersonCommunicationList.SetItemN(index: Integer; value: TFhirRelatedPersonCommunication);
begin
  assert(value is TFhirRelatedPersonCommunication);
  ObjectByIndex[index] := value;
end;

{ TFhirRelatedPerson }

constructor TFhirRelatedPerson.Create;
begin
  inherited;
end;

destructor TFhirRelatedPerson.Destroy;
begin
  FIdentifierList.Free;
  FActive.free;
  FPatient.free;
  FRelationshipList.Free;
  FNameList.Free;
  FTelecomList.Free;
  FGender.free;
  FBirthDate.free;
  FAddressList.Free;
  FPhotoList.Free;
  FPeriod.free;
  FCommunicationList.Free;
  inherited;
end;

procedure TFhirRelatedPerson.Assign(oSource : TFslObject);
begin
  inherited;
  if (TFhirRelatedPerson(oSource).FIdentifierList = nil) then
  begin
    FIdentifierList.free;
    FIdentifierList := nil;
  end
  else
  begin
    if FIdentifierList = nil then
      FIdentifierList := TFhirIdentifierList.Create;
    FIdentifierList.Assign(TFhirRelatedPerson(oSource).FIdentifierList);
  end;
  activeElement := TFhirRelatedPerson(oSource).activeElement.Clone;
  patient := TFhirRelatedPerson(oSource).patient.Clone;
  if (TFhirRelatedPerson(oSource).FRelationshipList = nil) then
  begin
    FRelationshipList.free;
    FRelationshipList := nil;
  end
  else
  begin
    if FRelationshipList = nil then
      FRelationshipList := TFhirCodeableConceptList.Create;
    FRelationshipList.Assign(TFhirRelatedPerson(oSource).FRelationshipList);
  end;
  if (TFhirRelatedPerson(oSource).FNameList = nil) then
  begin
    FNameList.free;
    FNameList := nil;
  end
  else
  begin
    if FNameList = nil then
      FNameList := TFhirHumanNameList.Create;
    FNameList.Assign(TFhirRelatedPerson(oSource).FNameList);
  end;
  if (TFhirRelatedPerson(oSource).FTelecomList = nil) then
  begin
    FTelecomList.free;
    FTelecomList := nil;
  end
  else
  begin
    if FTelecomList = nil then
      FTelecomList := TFhirContactPointList.Create;
    FTelecomList.Assign(TFhirRelatedPerson(oSource).FTelecomList);
  end;
  genderElement := TFhirRelatedPerson(oSource).genderElement.Clone;
  birthDateElement := TFhirRelatedPerson(oSource).birthDateElement.Clone;
  if (TFhirRelatedPerson(oSource).FAddressList = nil) then
  begin
    FAddressList.free;
    FAddressList := nil;
  end
  else
  begin
    if FAddressList = nil then
      FAddressList := TFhirAddressList.Create;
    FAddressList.Assign(TFhirRelatedPerson(oSource).FAddressList);
  end;
  if (TFhirRelatedPerson(oSource).FPhotoList = nil) then
  begin
    FPhotoList.free;
    FPhotoList := nil;
  end
  else
  begin
    if FPhotoList = nil then
      FPhotoList := TFhirAttachmentList.Create;
    FPhotoList.Assign(TFhirRelatedPerson(oSource).FPhotoList);
  end;
  period := TFhirRelatedPerson(oSource).period.Clone;
  if (TFhirRelatedPerson(oSource).FCommunicationList = nil) then
  begin
    FCommunicationList.free;
    FCommunicationList := nil;
  end
  else
  begin
    if FCommunicationList = nil then
      FCommunicationList := TFhirRelatedPersonCommunicationList.Create;
    FCommunicationList.Assign(TFhirRelatedPerson(oSource).FCommunicationList);
  end;
end;

function TFhirRelatedPerson.GetResourceType : TFhirResourceType;
begin
  result := frtRelatedPerson;
end;

procedure TFhirRelatedPerson.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'identifier') Then
    list.addAll(self, 'identifier', FIdentifierList);
  if (child_name = 'active') Then
     list.add(self.link, 'active', FActive.Link);
  if (child_name = 'patient') Then
     list.add(self.link, 'patient', FPatient.Link);
  if (child_name = 'relationship') Then
    list.addAll(self, 'relationship', FRelationshipList);
  if (child_name = 'name') Then
    list.addAll(self, 'name', FNameList);
  if (child_name = 'telecom') Then
    list.addAll(self, 'telecom', FTelecomList);
  if (child_name = 'gender') Then
     list.add(self.link, 'gender', FGender.Link);
  if (child_name = 'birthDate') Then
     list.add(self.link, 'birthDate', FBirthDate.Link);
  if (child_name = 'address') Then
    list.addAll(self, 'address', FAddressList);
  if (child_name = 'photo') Then
    list.addAll(self, 'photo', FPhotoList);
  if (child_name = 'period') Then
     list.add(self.link, 'period', FPeriod.Link);
  if (child_name = 'communication') Then
    list.addAll(self, 'communication', FCommunicationList);
end;

procedure TFhirRelatedPerson.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'identifier', 'Identifier', true, TFhirIdentifier, FIdentifierList.Link));
  oList.add(TFHIRProperty.create(self, 'active', 'boolean', false, TFhirBoolean, FActive.Link));
  oList.add(TFHIRProperty.create(self, 'patient', 'Reference', false, TFhirReference, FPatient.Link));
  oList.add(TFHIRProperty.create(self, 'relationship', 'CodeableConcept', true, TFhirCodeableConcept, FRelationshipList.Link));
  oList.add(TFHIRProperty.create(self, 'name', 'HumanName', true, TFhirHumanName, FNameList.Link));
  oList.add(TFHIRProperty.create(self, 'telecom', 'ContactPoint', true, TFhirContactPoint, FTelecomList.Link));
  oList.add(TFHIRProperty.create(self, 'gender', 'code', false, TFhirEnum, FGender.Link));
  oList.add(TFHIRProperty.create(self, 'birthDate', 'date', false, TFhirDate, FBirthDate.Link));
  oList.add(TFHIRProperty.create(self, 'address', 'Address', true, TFhirAddress, FAddressList.Link));
  oList.add(TFHIRProperty.create(self, 'photo', 'Attachment', true, TFhirAttachment, FPhotoList.Link));
  oList.add(TFHIRProperty.create(self, 'period', 'Period', false, TFhirPeriod, FPeriod.Link));
  oList.add(TFHIRProperty.create(self, 'communication', 'BackboneElement', true, TFhirRelatedPersonCommunication, FCommunicationList.Link));
end;

function TFhirRelatedPerson.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'identifier') then
  begin
    IdentifierList.add(propValue as TFhirIdentifier);
    result := propValue;
  end
  else if (propName = 'active') then
  begin
    ActiveElement := asBoolean(propValue);
    result := propValue;
  end
  else if (propName = 'patient') then
  begin
    Patient := propValue as TFhirReference;
    result := propValue;
  end
  else if (propName = 'relationship') then
  begin
    RelationshipList.add(propValue as TFhirCodeableConcept);
    result := propValue;
  end
  else if (propName = 'name') then
  begin
    NameList.add(propValue as TFhirHumanName);
    result := propValue;
  end
  else if (propName = 'telecom') then
  begin
    TelecomList.add(propValue as TFhirContactPoint);
    result := propValue;
  end
  else if (propName = 'gender') then
  begin
    GenderElement := asEnum(SYSTEMS_TFhirAdministrativeGenderEnum, CODES_TFhirAdministrativeGenderEnum, propValue);
    result := propValue;
  end
  else if (propName = 'birthDate') then
  begin
    BirthDateElement := asDate(propValue);
    result := propValue;
  end
  else if (propName = 'address') then
  begin
    AddressList.add(propValue as TFhirAddress);
    result := propValue;
  end
  else if (propName = 'photo') then
  begin
    PhotoList.add(propValue as TFhirAttachment);
    result := propValue;
  end
  else if (propName = 'period') then
  begin
    Period := propValue as TFhirPeriod;
    result := propValue;
  end
  else if (propName = 'communication') then
  begin
    CommunicationList.add(propValue as TFhirRelatedPersonCommunication);
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirRelatedPerson.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'identifier') then IdentifierList.insertItem(index, propValue as TFhirIdentifier)
  else if (propName = 'relationship') then RelationshipList.insertItem(index, propValue as TFhirCodeableConcept)
  else if (propName = 'name') then NameList.insertItem(index, propValue as TFhirHumanName)
  else if (propName = 'telecom') then TelecomList.insertItem(index, propValue as TFhirContactPoint)
  else if (propName = 'address') then AddressList.insertItem(index, propValue as TFhirAddress)
  else if (propName = 'photo') then PhotoList.insertItem(index, propValue as TFhirAttachment)
  else if (propName = 'communication') then CommunicationList.insertItem(index, propValue as TFhirRelatedPersonCommunication)
  else inherited;
end;

function TFhirRelatedPerson.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'identifier') then result := IdentifierList.new()
  else if (propName = 'active') then result := TFhirBoolean.create()
  else if (propName = 'patient') then result := TFhirReference.create()
  else if (propName = 'relationship') then result := RelationshipList.new()
  else if (propName = 'name') then result := NameList.new()
  else if (propName = 'telecom') then result := TelecomList.new()
  else if (propName = 'gender') then result := TFhirEnum.create(SYSTEMS_TFhirAdministrativeGenderEnum[AdministrativeGenderNull], CODES_TFhirAdministrativeGenderEnum[AdministrativeGenderNull]) 
  else if (propName = 'birthDate') then result := TFhirDate.create()
  else if (propName = 'address') then result := AddressList.new()
  else if (propName = 'photo') then result := PhotoList.new()
  else if (propName = 'period') then result := TFhirPeriod.create()
  else if (propName = 'communication') then result := CommunicationList.new()
  else result := inherited createPropertyValue(propName);
end;

function TFhirRelatedPerson.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'identifier') then result := 'Identifier'
  else if (propName = 'active') then result := 'boolean'
  else if (propName = 'patient') then result := 'Reference'
  else if (propName = 'relationship') then result := 'CodeableConcept'
  else if (propName = 'name') then result := 'HumanName'
  else if (propName = 'telecom') then result := 'ContactPoint'
  else if (propName = 'gender') then result := 'code'
  else if (propName = 'birthDate') then result := 'date'
  else if (propName = 'address') then result := 'Address'
  else if (propName = 'photo') then result := 'Attachment'
  else if (propName = 'period') then result := 'Period'
  else if (propName = 'communication') then result := 'BackboneElement'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirRelatedPerson.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'identifier') then deletePropertyValue('identifier', IdentifierList, value)
  else if (propName = 'active') then ActiveElement := nil
  else if (propName = 'patient') then PatientElement := nil
  else if (propName = 'relationship') then deletePropertyValue('relationship', RelationshipList, value)
  else if (propName = 'name') then deletePropertyValue('name', NameList, value)
  else if (propName = 'telecom') then deletePropertyValue('telecom', TelecomList, value)
  else if (propName = 'gender') then GenderElement := nil
  else if (propName = 'birthDate') then BirthDateElement := nil
  else if (propName = 'address') then deletePropertyValue('address', AddressList, value)
  else if (propName = 'photo') then deletePropertyValue('photo', PhotoList, value)
  else if (propName = 'period') then PeriodElement := nil
  else if (propName = 'communication') then deletePropertyValue('communication', CommunicationList, value)
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirRelatedPerson.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'identifier') then replacePropertyValue('identifier', IdentifierList, existing, new)
  else if (propName = 'active') then ActiveElement := asBoolean(new)
  else if (propName = 'patient') then PatientElement := new as TFhirReference
  else if (propName = 'relationship') then replacePropertyValue('relationship', RelationshipList, existing, new)
  else if (propName = 'name') then replacePropertyValue('name', NameList, existing, new)
  else if (propName = 'telecom') then replacePropertyValue('telecom', TelecomList, existing, new)
  else if (propName = 'gender') then GenderElement := asEnum(SYSTEMS_TFhirAdministrativeGenderEnum, CODES_TFhirAdministrativeGenderEnum, new)
  else if (propName = 'birthDate') then BirthDateElement := asDate(new)
  else if (propName = 'address') then replacePropertyValue('address', AddressList, existing, new)
  else if (propName = 'photo') then replacePropertyValue('photo', PhotoList, existing, new)
  else if (propName = 'period') then PeriodElement := new as TFhirPeriod
  else if (propName = 'communication') then replacePropertyValue('communication', CommunicationList, existing, new)
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirRelatedPerson.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'identifier') then IdentifierList.move(source, destination)
  else if (propName = 'relationship') then RelationshipList.move(source, destination)
  else if (propName = 'name') then NameList.move(source, destination)
  else if (propName = 'telecom') then TelecomList.move(source, destination)
  else if (propName = 'address') then AddressList.move(source, destination)
  else if (propName = 'photo') then PhotoList.move(source, destination)
  else if (propName = 'communication') then CommunicationList.move(source, destination)
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirRelatedPerson.fhirType : string;
begin
  result := 'RelatedPerson';
end;

function TFhirRelatedPerson.Link : TFhirRelatedPerson;
begin
  result := TFhirRelatedPerson(inherited Link);
end;

function TFhirRelatedPerson.Clone : TFhirRelatedPerson;
begin
  result := TFhirRelatedPerson(inherited Clone);
end;

function TFhirRelatedPerson.equals(other : TObject) : boolean; 
var
  o : TFhirRelatedPerson;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirRelatedPerson)) then
    result := false
  else
  begin
    o := TFhirRelatedPerson(other);
    result := compareDeep(identifierList, o.identifierList, true) and compareDeep(activeElement, o.activeElement, true) and 
      compareDeep(patientElement, o.patientElement, true) and compareDeep(relationshipList, o.relationshipList, true) and 
      compareDeep(nameList, o.nameList, true) and compareDeep(telecomList, o.telecomList, true) and 
      compareDeep(genderElement, o.genderElement, true) and compareDeep(birthDateElement, o.birthDateElement, true) and 
      compareDeep(addressList, o.addressList, true) and compareDeep(photoList, o.photoList, true) and 
      compareDeep(periodElement, o.periodElement, true) and compareDeep(communicationList, o.communicationList, true);
  end;
end;

function TFhirRelatedPerson.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FidentifierList) and isEmptyProp(FActive) and isEmptyProp(FPatient) and isEmptyProp(FrelationshipList) and isEmptyProp(FnameList) and isEmptyProp(FtelecomList) and isEmptyProp(FGender) and isEmptyProp(FBirthDate) and isEmptyProp(FaddressList) and isEmptyProp(FphotoList) and isEmptyProp(FPeriod) and isEmptyProp(FcommunicationList);
end;

procedure TFhirRelatedPerson.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('identifier');
  fields.add('active');
  fields.add('patient');
  fields.add('relationship');
  fields.add('name');
  fields.add('telecom');
  fields.add('gender');
  fields.add('birthDate');
  fields.add('address');
  fields.add('photo');
  fields.add('period');
  fields.add('communication');
end;

function TFhirRelatedPerson.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
  inc(result, FIdentifierList.sizeInBytes(magic));
  inc(result, FRelationshipList.sizeInBytes(magic));
  inc(result, FNameList.sizeInBytes(magic));
  inc(result, FTelecomList.sizeInBytes(magic));
  inc(result, FAddressList.sizeInBytes(magic));
  inc(result, FPhotoList.sizeInBytes(magic));
  inc(result, FCommunicationList.sizeInBytes(magic));
end;

function TFhirRelatedPerson.GetIdentifierList : TFhirIdentifierList;
begin
  if FIdentifierList = nil then
    FIdentifierList := TFhirIdentifierList.Create;
  result := FIdentifierList;
end;

function TFhirRelatedPerson.GetHasIdentifierList : boolean;
begin
  result := (FIdentifierList <> nil) and (FIdentifierList.count > 0);
end;

procedure TFhirRelatedPerson.SetActive(value : TFhirBoolean);
begin
  FActive.free;
  FActive := value;
end;

function TFhirRelatedPerson.GetActiveST : Boolean;
begin
  if FActive = nil then
    result := false
  else
    result := FActive.value;
end;

procedure TFhirRelatedPerson.SetActiveST(value : Boolean);
begin
  if FActive = nil then
    FActive := TFhirBoolean.create;
  FActive.value := value
end;

procedure TFhirRelatedPerson.SetPatient(value : TFhirReference);
begin
  FPatient.free;
  FPatient := value;
end;

function TFhirRelatedPerson.GetRelationshipList : TFhirCodeableConceptList;
begin
  if FRelationshipList = nil then
    FRelationshipList := TFhirCodeableConceptList.Create;
  result := FRelationshipList;
end;

function TFhirRelatedPerson.GetHasRelationshipList : boolean;
begin
  result := (FRelationshipList <> nil) and (FRelationshipList.count > 0);
end;

function TFhirRelatedPerson.GetNameList : TFhirHumanNameList;
begin
  if FNameList = nil then
    FNameList := TFhirHumanNameList.Create;
  result := FNameList;
end;

function TFhirRelatedPerson.GetHasNameList : boolean;
begin
  result := (FNameList <> nil) and (FNameList.count > 0);
end;

function TFhirRelatedPerson.GetTelecomList : TFhirContactPointList;
begin
  if FTelecomList = nil then
    FTelecomList := TFhirContactPointList.Create;
  result := FTelecomList;
end;

function TFhirRelatedPerson.GetHasTelecomList : boolean;
begin
  result := (FTelecomList <> nil) and (FTelecomList.count > 0);
end;

procedure TFhirRelatedPerson.SetGender(value : TFhirEnum);
begin
  FGender.free;
  FGender := value;
end;

function TFhirRelatedPerson.GetGenderST : TFhirAdministrativeGenderEnum;
begin
  if FGender = nil then
    result := TFhirAdministrativeGenderEnum(0)
  else
    result := TFhirAdministrativeGenderEnum(StringArrayIndexOfSensitive(CODES_TFhirAdministrativeGenderEnum, FGender.value));
end;

procedure TFhirRelatedPerson.SetGenderST(value : TFhirAdministrativeGenderEnum);
begin
  if ord(value) = 0 then
    GenderElement := nil
  else
    GenderElement := TFhirEnum.create(SYSTEMS_TFhirAdministrativeGenderEnum[value], CODES_TFhirAdministrativeGenderEnum[value]);
end;

procedure TFhirRelatedPerson.SetBirthDate(value : TFhirDate);
begin
  FBirthDate.free;
  FBirthDate := value;
end;

function TFhirRelatedPerson.GetBirthDateST : TFslDateTime;
begin
  if FBirthDate = nil then
    result := TFslDateTime.makeNull
  else
    result := FBirthDate.value;
end;

procedure TFhirRelatedPerson.SetBirthDateST(value : TFslDateTime);
begin
  if FBirthDate = nil then
    FBirthDate := TFhirDate.create;
  FBirthDate.value := value
end;

function TFhirRelatedPerson.GetAddressList : TFhirAddressList;
begin
  if FAddressList = nil then
    FAddressList := TFhirAddressList.Create;
  result := FAddressList;
end;

function TFhirRelatedPerson.GetHasAddressList : boolean;
begin
  result := (FAddressList <> nil) and (FAddressList.count > 0);
end;

function TFhirRelatedPerson.GetPhotoList : TFhirAttachmentList;
begin
  if FPhotoList = nil then
    FPhotoList := TFhirAttachmentList.Create;
  result := FPhotoList;
end;

function TFhirRelatedPerson.GetHasPhotoList : boolean;
begin
  result := (FPhotoList <> nil) and (FPhotoList.count > 0);
end;

procedure TFhirRelatedPerson.SetPeriod(value : TFhirPeriod);
begin
  FPeriod.free;
  FPeriod := value;
end;

function TFhirRelatedPerson.GetCommunicationList : TFhirRelatedPersonCommunicationList;
begin
  if FCommunicationList = nil then
    FCommunicationList := TFhirRelatedPersonCommunicationList.Create;
  result := FCommunicationList;
end;

function TFhirRelatedPerson.GetHasCommunicationList : boolean;
begin
  result := (FCommunicationList <> nil) and (FCommunicationList.count > 0);
end;

{ TFhirRelatedPersonListEnumerator }

constructor TFhirRelatedPersonListEnumerator.Create(list : TFhirRelatedPersonList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirRelatedPersonListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirRelatedPersonListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirRelatedPersonListEnumerator.GetCurrent : TFhirRelatedPerson;
begin
  Result := FList[FIndex];
end;

function TFhirRelatedPersonListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirRelatedPersonList }

function TFhirRelatedPersonList.AddItem(value: TFhirRelatedPerson): TFhirRelatedPerson;
begin
  assert(value.ClassName = 'TFhirRelatedPerson', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirRelatedPerson');
  add(value);
  result := value;
end;

function TFhirRelatedPersonList.Append: TFhirRelatedPerson;
begin
  result := TFhirRelatedPerson.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirRelatedPersonList.ClearItems;
begin
  Clear;
end;

function TFhirRelatedPersonList.GetEnumerator : TFhirRelatedPersonListEnumerator;
begin
  result := TFhirRelatedPersonListEnumerator.Create(self.link);
end;

function TFhirRelatedPersonList.Clone: TFhirRelatedPersonList;
begin
  result := TFhirRelatedPersonList(inherited Clone);
end;

function TFhirRelatedPersonList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirRelatedPersonList.GetItemN(index: Integer): TFhirRelatedPerson;
begin
  result := TFhirRelatedPerson(ObjectByIndex[index]);
end;

function TFhirRelatedPersonList.ItemClass: TFslObjectClass;
begin
  result := TFhirRelatedPerson;
end;
function TFhirRelatedPersonList.IndexOf(value: TFhirRelatedPerson): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirRelatedPersonList.Insert(index: Integer): TFhirRelatedPerson;
begin
  result := TFhirRelatedPerson.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirRelatedPersonList.InsertItem(index: Integer; value: TFhirRelatedPerson);
begin
  assert(value is TFhirRelatedPerson);
  Inherited Insert(index, value);
end;

function TFhirRelatedPersonList.Item(index: Integer): TFhirRelatedPerson;
begin
  result := TFhirRelatedPerson(ObjectByIndex[index]);
end;

function TFhirRelatedPersonList.Link: TFhirRelatedPersonList;
begin
  result := TFhirRelatedPersonList(inherited Link);
end;

procedure TFhirRelatedPersonList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirRelatedPersonList.SetItemByIndex(index: Integer; value: TFhirRelatedPerson);
begin
  assert(value is TFhirRelatedPerson);
  FhirRelatedPeople[index] := value;
end;

procedure TFhirRelatedPersonList.SetItemN(index: Integer; value: TFhirRelatedPerson);
begin
  assert(value is TFhirRelatedPerson);
  ObjectByIndex[index] := value;
end;

{$ENDIF FHIR_RELATEDPERSON}
{$IFDEF FHIR_SCHEDULE}
{ TFhirSchedule }

constructor TFhirSchedule.Create;
begin
  inherited;
end;

destructor TFhirSchedule.Destroy;
begin
  FIdentifierList.Free;
  FActive.free;
  FServiceCategoryList.Free;
  FServiceTypeList.Free;
  FSpecialtyList.Free;
  FName.free;
  FActorList.Free;
  FPlanningHorizon.free;
  FComment.free;
  inherited;
end;

procedure TFhirSchedule.Assign(oSource : TFslObject);
begin
  inherited;
  if (TFhirSchedule(oSource).FIdentifierList = nil) then
  begin
    FIdentifierList.free;
    FIdentifierList := nil;
  end
  else
  begin
    if FIdentifierList = nil then
      FIdentifierList := TFhirIdentifierList.Create;
    FIdentifierList.Assign(TFhirSchedule(oSource).FIdentifierList);
  end;
  activeElement := TFhirSchedule(oSource).activeElement.Clone;
  if (TFhirSchedule(oSource).FServiceCategoryList = nil) then
  begin
    FServiceCategoryList.free;
    FServiceCategoryList := nil;
  end
  else
  begin
    if FServiceCategoryList = nil then
      FServiceCategoryList := TFhirCodeableConceptList.Create;
    FServiceCategoryList.Assign(TFhirSchedule(oSource).FServiceCategoryList);
  end;
  if (TFhirSchedule(oSource).FServiceTypeList = nil) then
  begin
    FServiceTypeList.free;
    FServiceTypeList := nil;
  end
  else
  begin
    if FServiceTypeList = nil then
      FServiceTypeList := TFhirCodeableReferenceList.Create;
    FServiceTypeList.Assign(TFhirSchedule(oSource).FServiceTypeList);
  end;
  if (TFhirSchedule(oSource).FSpecialtyList = nil) then
  begin
    FSpecialtyList.free;
    FSpecialtyList := nil;
  end
  else
  begin
    if FSpecialtyList = nil then
      FSpecialtyList := TFhirCodeableConceptList.Create;
    FSpecialtyList.Assign(TFhirSchedule(oSource).FSpecialtyList);
  end;
  nameElement := TFhirSchedule(oSource).nameElement.Clone;
  if (TFhirSchedule(oSource).FActorList = nil) then
  begin
    FActorList.free;
    FActorList := nil;
  end
  else
  begin
    if FActorList = nil then
      FActorList := TFhirReferenceList.Create;
    FActorList.Assign(TFhirSchedule(oSource).FActorList);
  end;
  planningHorizon := TFhirSchedule(oSource).planningHorizon.Clone;
  commentElement := TFhirSchedule(oSource).commentElement.Clone;
end;

function TFhirSchedule.GetResourceType : TFhirResourceType;
begin
  result := frtSchedule;
end;

procedure TFhirSchedule.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'identifier') Then
    list.addAll(self, 'identifier', FIdentifierList);
  if (child_name = 'active') Then
     list.add(self.link, 'active', FActive.Link);
  if (child_name = 'serviceCategory') Then
    list.addAll(self, 'serviceCategory', FServiceCategoryList);
  if (child_name = 'serviceType') Then
    list.addAll(self, 'serviceType', FServiceTypeList);
  if (child_name = 'specialty') Then
    list.addAll(self, 'specialty', FSpecialtyList);
  if (child_name = 'name') Then
     list.add(self.link, 'name', FName.Link);
  if (child_name = 'actor') Then
    list.addAll(self, 'actor', FActorList);
  if (child_name = 'planningHorizon') Then
     list.add(self.link, 'planningHorizon', FPlanningHorizon.Link);
  if (child_name = 'comment') Then
     list.add(self.link, 'comment', FComment.Link);
end;

procedure TFhirSchedule.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'identifier', 'Identifier', true, TFhirIdentifier, FIdentifierList.Link));
  oList.add(TFHIRProperty.create(self, 'active', 'boolean', false, TFhirBoolean, FActive.Link));
  oList.add(TFHIRProperty.create(self, 'serviceCategory', 'CodeableConcept', true, TFhirCodeableConcept, FServiceCategoryList.Link));
  oList.add(TFHIRProperty.create(self, 'serviceType', 'CodeableReference', true, TFhirCodeableReference, FServiceTypeList.Link));
  oList.add(TFHIRProperty.create(self, 'specialty', 'CodeableConcept', true, TFhirCodeableConcept, FSpecialtyList.Link));
  oList.add(TFHIRProperty.create(self, 'name', 'string', false, TFhirString, FName.Link));
  oList.add(TFHIRProperty.create(self, 'actor', 'Reference', true, TFhirReference, FActorList.Link));
  oList.add(TFHIRProperty.create(self, 'planningHorizon', 'Period', false, TFhirPeriod, FPlanningHorizon.Link));
  oList.add(TFHIRProperty.create(self, 'comment', 'string', false, TFhirString, FComment.Link));
end;

function TFhirSchedule.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'identifier') then
  begin
    IdentifierList.add(propValue as TFhirIdentifier);
    result := propValue;
  end
  else if (propName = 'active') then
  begin
    ActiveElement := asBoolean(propValue);
    result := propValue;
  end
  else if (propName = 'serviceCategory') then
  begin
    ServiceCategoryList.add(propValue as TFhirCodeableConcept);
    result := propValue;
  end
  else if (propName = 'serviceType') then
  begin
    ServiceTypeList.add(propValue as TFhirCodeableReference);
    result := propValue;
  end
  else if (propName = 'specialty') then
  begin
    SpecialtyList.add(propValue as TFhirCodeableConcept);
    result := propValue;
  end
  else if (propName = 'name') then
  begin
    NameElement := asString(propValue);
    result := propValue;
  end
  else if (propName = 'actor') then
  begin
    ActorList.add(propValue as TFhirReference);
    result := propValue;
  end
  else if (propName = 'planningHorizon') then
  begin
    PlanningHorizon := propValue as TFhirPeriod;
    result := propValue;
  end
  else if (propName = 'comment') then
  begin
    CommentElement := asString(propValue);
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirSchedule.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'identifier') then IdentifierList.insertItem(index, propValue as TFhirIdentifier)
  else if (propName = 'serviceCategory') then ServiceCategoryList.insertItem(index, propValue as TFhirCodeableConcept)
  else if (propName = 'serviceType') then ServiceTypeList.insertItem(index, propValue as TFhirCodeableReference)
  else if (propName = 'specialty') then SpecialtyList.insertItem(index, propValue as TFhirCodeableConcept)
  else if (propName = 'actor') then ActorList.insertItem(index, propValue as TFhirReference)
  else inherited;
end;

function TFhirSchedule.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'identifier') then result := IdentifierList.new()
  else if (propName = 'active') then result := TFhirBoolean.create()
  else if (propName = 'serviceCategory') then result := ServiceCategoryList.new()
  else if (propName = 'serviceType') then result := ServiceTypeList.new()
  else if (propName = 'specialty') then result := SpecialtyList.new()
  else if (propName = 'name') then result := TFhirString.create()
  else if (propName = 'actor') then result := ActorList.new()
  else if (propName = 'planningHorizon') then result := TFhirPeriod.create()
  else if (propName = 'comment') then result := TFhirString.create()
  else result := inherited createPropertyValue(propName);
end;

function TFhirSchedule.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'identifier') then result := 'Identifier'
  else if (propName = 'active') then result := 'boolean'
  else if (propName = 'serviceCategory') then result := 'CodeableConcept'
  else if (propName = 'serviceType') then result := 'CodeableReference'
  else if (propName = 'specialty') then result := 'CodeableConcept'
  else if (propName = 'name') then result := 'string'
  else if (propName = 'actor') then result := 'Reference'
  else if (propName = 'planningHorizon') then result := 'Period'
  else if (propName = 'comment') then result := 'string'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirSchedule.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'identifier') then deletePropertyValue('identifier', IdentifierList, value)
  else if (propName = 'active') then ActiveElement := nil
  else if (propName = 'serviceCategory') then deletePropertyValue('serviceCategory', ServiceCategoryList, value)
  else if (propName = 'serviceType') then deletePropertyValue('serviceType', ServiceTypeList, value)
  else if (propName = 'specialty') then deletePropertyValue('specialty', SpecialtyList, value)
  else if (propName = 'name') then NameElement := nil
  else if (propName = 'actor') then deletePropertyValue('actor', ActorList, value)
  else if (propName = 'planningHorizon') then PlanningHorizonElement := nil
  else if (propName = 'comment') then CommentElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirSchedule.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'identifier') then replacePropertyValue('identifier', IdentifierList, existing, new)
  else if (propName = 'active') then ActiveElement := asBoolean(new)
  else if (propName = 'serviceCategory') then replacePropertyValue('serviceCategory', ServiceCategoryList, existing, new)
  else if (propName = 'serviceType') then replacePropertyValue('serviceType', ServiceTypeList, existing, new)
  else if (propName = 'specialty') then replacePropertyValue('specialty', SpecialtyList, existing, new)
  else if (propName = 'name') then NameElement := asString(new)
  else if (propName = 'actor') then replacePropertyValue('actor', ActorList, existing, new)
  else if (propName = 'planningHorizon') then PlanningHorizonElement := new as TFhirPeriod
  else if (propName = 'comment') then CommentElement := asString(new)
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirSchedule.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'identifier') then IdentifierList.move(source, destination)
  else if (propName = 'serviceCategory') then ServiceCategoryList.move(source, destination)
  else if (propName = 'serviceType') then ServiceTypeList.move(source, destination)
  else if (propName = 'specialty') then SpecialtyList.move(source, destination)
  else if (propName = 'actor') then ActorList.move(source, destination)
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirSchedule.fhirType : string;
begin
  result := 'Schedule';
end;

function TFhirSchedule.Link : TFhirSchedule;
begin
  result := TFhirSchedule(inherited Link);
end;

function TFhirSchedule.Clone : TFhirSchedule;
begin
  result := TFhirSchedule(inherited Clone);
end;

function TFhirSchedule.equals(other : TObject) : boolean; 
var
  o : TFhirSchedule;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirSchedule)) then
    result := false
  else
  begin
    o := TFhirSchedule(other);
    result := compareDeep(identifierList, o.identifierList, true) and compareDeep(activeElement, o.activeElement, true) and 
      compareDeep(serviceCategoryList, o.serviceCategoryList, true) and compareDeep(serviceTypeList, o.serviceTypeList, true) and 
      compareDeep(specialtyList, o.specialtyList, true) and compareDeep(nameElement, o.nameElement, true) and 
      compareDeep(actorList, o.actorList, true) and compareDeep(planningHorizonElement, o.planningHorizonElement, true) and 
      compareDeep(commentElement, o.commentElement, true);
  end;
end;

function TFhirSchedule.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FidentifierList) and isEmptyProp(FActive) and isEmptyProp(FserviceCategoryList) and isEmptyProp(FserviceTypeList) and isEmptyProp(FspecialtyList) and isEmptyProp(FName) and isEmptyProp(FactorList) and isEmptyProp(FPlanningHorizon) and isEmptyProp(FComment);
end;

procedure TFhirSchedule.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('identifier');
  fields.add('active');
  fields.add('serviceCategory');
  fields.add('serviceType');
  fields.add('specialty');
  fields.add('name');
  fields.add('actor');
  fields.add('planningHorizon');
  fields.add('comment');
end;

function TFhirSchedule.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
  inc(result, FIdentifierList.sizeInBytes(magic));
  inc(result, FServiceCategoryList.sizeInBytes(magic));
  inc(result, FServiceTypeList.sizeInBytes(magic));
  inc(result, FSpecialtyList.sizeInBytes(magic));
  inc(result, FActorList.sizeInBytes(magic));
end;

function TFhirSchedule.GetIdentifierList : TFhirIdentifierList;
begin
  if FIdentifierList = nil then
    FIdentifierList := TFhirIdentifierList.Create;
  result := FIdentifierList;
end;

function TFhirSchedule.GetHasIdentifierList : boolean;
begin
  result := (FIdentifierList <> nil) and (FIdentifierList.count > 0);
end;

procedure TFhirSchedule.SetActive(value : TFhirBoolean);
begin
  FActive.free;
  FActive := value;
end;

function TFhirSchedule.GetActiveST : Boolean;
begin
  if FActive = nil then
    result := false
  else
    result := FActive.value;
end;

procedure TFhirSchedule.SetActiveST(value : Boolean);
begin
  if FActive = nil then
    FActive := TFhirBoolean.create;
  FActive.value := value
end;

function TFhirSchedule.GetServiceCategoryList : TFhirCodeableConceptList;
begin
  if FServiceCategoryList = nil then
    FServiceCategoryList := TFhirCodeableConceptList.Create;
  result := FServiceCategoryList;
end;

function TFhirSchedule.GetHasServiceCategoryList : boolean;
begin
  result := (FServiceCategoryList <> nil) and (FServiceCategoryList.count > 0);
end;

function TFhirSchedule.GetServiceTypeList : TFhirCodeableReferenceList;
begin
  if FServiceTypeList = nil then
    FServiceTypeList := TFhirCodeableReferenceList.Create;
  result := FServiceTypeList;
end;

function TFhirSchedule.GetHasServiceTypeList : boolean;
begin
  result := (FServiceTypeList <> nil) and (FServiceTypeList.count > 0);
end;

function TFhirSchedule.GetSpecialtyList : TFhirCodeableConceptList;
begin
  if FSpecialtyList = nil then
    FSpecialtyList := TFhirCodeableConceptList.Create;
  result := FSpecialtyList;
end;

function TFhirSchedule.GetHasSpecialtyList : boolean;
begin
  result := (FSpecialtyList <> nil) and (FSpecialtyList.count > 0);
end;

procedure TFhirSchedule.SetName(value : TFhirString);
begin
  FName.free;
  FName := value;
end;

function TFhirSchedule.GetNameST : String;
begin
  if FName = nil then
    result := ''
  else
    result := FName.value;
end;

procedure TFhirSchedule.SetNameST(value : String);
begin
  if value <> '' then
  begin
    if FName = nil then
      FName := TFhirString.create;
    FName.value := value
  end
  else if FName <> nil then
    FName.value := '';
end;

function TFhirSchedule.GetActorList : TFhirReferenceList;
begin
  if FActorList = nil then
    FActorList := TFhirReferenceList.Create;
  result := FActorList;
end;

function TFhirSchedule.GetHasActorList : boolean;
begin
  result := (FActorList <> nil) and (FActorList.count > 0);
end;

procedure TFhirSchedule.SetPlanningHorizon(value : TFhirPeriod);
begin
  FPlanningHorizon.free;
  FPlanningHorizon := value;
end;

procedure TFhirSchedule.SetComment(value : TFhirString);
begin
  FComment.free;
  FComment := value;
end;

function TFhirSchedule.GetCommentST : String;
begin
  if FComment = nil then
    result := ''
  else
    result := FComment.value;
end;

procedure TFhirSchedule.SetCommentST(value : String);
begin
  if value <> '' then
  begin
    if FComment = nil then
      FComment := TFhirString.create;
    FComment.value := value
  end
  else if FComment <> nil then
    FComment.value := '';
end;

{ TFhirScheduleListEnumerator }

constructor TFhirScheduleListEnumerator.Create(list : TFhirScheduleList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirScheduleListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirScheduleListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirScheduleListEnumerator.GetCurrent : TFhirSchedule;
begin
  Result := FList[FIndex];
end;

function TFhirScheduleListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirScheduleList }

function TFhirScheduleList.AddItem(value: TFhirSchedule): TFhirSchedule;
begin
  assert(value.ClassName = 'TFhirSchedule', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirSchedule');
  add(value);
  result := value;
end;

function TFhirScheduleList.Append: TFhirSchedule;
begin
  result := TFhirSchedule.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirScheduleList.ClearItems;
begin
  Clear;
end;

function TFhirScheduleList.GetEnumerator : TFhirScheduleListEnumerator;
begin
  result := TFhirScheduleListEnumerator.Create(self.link);
end;

function TFhirScheduleList.Clone: TFhirScheduleList;
begin
  result := TFhirScheduleList(inherited Clone);
end;

function TFhirScheduleList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirScheduleList.GetItemN(index: Integer): TFhirSchedule;
begin
  result := TFhirSchedule(ObjectByIndex[index]);
end;

function TFhirScheduleList.ItemClass: TFslObjectClass;
begin
  result := TFhirSchedule;
end;
function TFhirScheduleList.IndexOf(value: TFhirSchedule): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirScheduleList.Insert(index: Integer): TFhirSchedule;
begin
  result := TFhirSchedule.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirScheduleList.InsertItem(index: Integer; value: TFhirSchedule);
begin
  assert(value is TFhirSchedule);
  Inherited Insert(index, value);
end;

function TFhirScheduleList.Item(index: Integer): TFhirSchedule;
begin
  result := TFhirSchedule(ObjectByIndex[index]);
end;

function TFhirScheduleList.Link: TFhirScheduleList;
begin
  result := TFhirScheduleList(inherited Link);
end;

procedure TFhirScheduleList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirScheduleList.SetItemByIndex(index: Integer; value: TFhirSchedule);
begin
  assert(value is TFhirSchedule);
  FhirSchedules[index] := value;
end;

procedure TFhirScheduleList.SetItemN(index: Integer; value: TFhirSchedule);
begin
  assert(value is TFhirSchedule);
  ObjectByIndex[index] := value;
end;

{$ENDIF FHIR_SCHEDULE}
{$IFDEF FHIR_SLOT}
{ TFhirSlot }

constructor TFhirSlot.Create;
begin
  inherited;
end;

destructor TFhirSlot.Destroy;
begin
  FIdentifierList.Free;
  FServiceCategoryList.Free;
  FServiceTypeList.Free;
  FSpecialtyList.Free;
  FAppointmentTypeList.Free;
  FSchedule.free;
  FStatus.free;
  FStart.free;
  FEnd_.free;
  FOverbooked.free;
  FComment.free;
  inherited;
end;

procedure TFhirSlot.Assign(oSource : TFslObject);
begin
  inherited;
  if (TFhirSlot(oSource).FIdentifierList = nil) then
  begin
    FIdentifierList.free;
    FIdentifierList := nil;
  end
  else
  begin
    if FIdentifierList = nil then
      FIdentifierList := TFhirIdentifierList.Create;
    FIdentifierList.Assign(TFhirSlot(oSource).FIdentifierList);
  end;
  if (TFhirSlot(oSource).FServiceCategoryList = nil) then
  begin
    FServiceCategoryList.free;
    FServiceCategoryList := nil;
  end
  else
  begin
    if FServiceCategoryList = nil then
      FServiceCategoryList := TFhirCodeableConceptList.Create;
    FServiceCategoryList.Assign(TFhirSlot(oSource).FServiceCategoryList);
  end;
  if (TFhirSlot(oSource).FServiceTypeList = nil) then
  begin
    FServiceTypeList.free;
    FServiceTypeList := nil;
  end
  else
  begin
    if FServiceTypeList = nil then
      FServiceTypeList := TFhirCodeableReferenceList.Create;
    FServiceTypeList.Assign(TFhirSlot(oSource).FServiceTypeList);
  end;
  if (TFhirSlot(oSource).FSpecialtyList = nil) then
  begin
    FSpecialtyList.free;
    FSpecialtyList := nil;
  end
  else
  begin
    if FSpecialtyList = nil then
      FSpecialtyList := TFhirCodeableConceptList.Create;
    FSpecialtyList.Assign(TFhirSlot(oSource).FSpecialtyList);
  end;
  if (TFhirSlot(oSource).FAppointmentTypeList = nil) then
  begin
    FAppointmentTypeList.free;
    FAppointmentTypeList := nil;
  end
  else
  begin
    if FAppointmentTypeList = nil then
      FAppointmentTypeList := TFhirCodeableConceptList.Create;
    FAppointmentTypeList.Assign(TFhirSlot(oSource).FAppointmentTypeList);
  end;
  schedule := TFhirSlot(oSource).schedule.Clone;
  statusElement := TFhirSlot(oSource).statusElement.Clone;
  startElement := TFhirSlot(oSource).startElement.Clone;
  end_Element := TFhirSlot(oSource).end_Element.Clone;
  overbookedElement := TFhirSlot(oSource).overbookedElement.Clone;
  commentElement := TFhirSlot(oSource).commentElement.Clone;
end;

function TFhirSlot.GetResourceType : TFhirResourceType;
begin
  result := frtSlot;
end;

procedure TFhirSlot.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'identifier') Then
    list.addAll(self, 'identifier', FIdentifierList);
  if (child_name = 'serviceCategory') Then
    list.addAll(self, 'serviceCategory', FServiceCategoryList);
  if (child_name = 'serviceType') Then
    list.addAll(self, 'serviceType', FServiceTypeList);
  if (child_name = 'specialty') Then
    list.addAll(self, 'specialty', FSpecialtyList);
  if (child_name = 'appointmentType') Then
    list.addAll(self, 'appointmentType', FAppointmentTypeList);
  if (child_name = 'schedule') Then
     list.add(self.link, 'schedule', FSchedule.Link);
  if (child_name = 'status') Then
     list.add(self.link, 'status', FStatus.Link);
  if (child_name = 'start') Then
     list.add(self.link, 'start', FStart.Link);
  if (child_name = 'end') Then
     list.add(self.link, 'end', FEnd_.Link);
  if (child_name = 'overbooked') Then
     list.add(self.link, 'overbooked', FOverbooked.Link);
  if (child_name = 'comment') Then
     list.add(self.link, 'comment', FComment.Link);
end;

procedure TFhirSlot.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'identifier', 'Identifier', true, TFhirIdentifier, FIdentifierList.Link));
  oList.add(TFHIRProperty.create(self, 'serviceCategory', 'CodeableConcept', true, TFhirCodeableConcept, FServiceCategoryList.Link));
  oList.add(TFHIRProperty.create(self, 'serviceType', 'CodeableReference', true, TFhirCodeableReference, FServiceTypeList.Link));
  oList.add(TFHIRProperty.create(self, 'specialty', 'CodeableConcept', true, TFhirCodeableConcept, FSpecialtyList.Link));
  oList.add(TFHIRProperty.create(self, 'appointmentType', 'CodeableConcept', true, TFhirCodeableConcept, FAppointmentTypeList.Link));
  oList.add(TFHIRProperty.create(self, 'schedule', 'Reference', false, TFhirReference, FSchedule.Link));
  oList.add(TFHIRProperty.create(self, 'status', 'code', false, TFhirEnum, FStatus.Link));
  oList.add(TFHIRProperty.create(self, 'start', 'instant', false, TFhirInstant, FStart.Link));
  oList.add(TFHIRProperty.create(self, 'end', 'instant', false, TFhirInstant, FEnd_.Link));
  oList.add(TFHIRProperty.create(self, 'overbooked', 'boolean', false, TFhirBoolean, FOverbooked.Link));
  oList.add(TFHIRProperty.create(self, 'comment', 'string', false, TFhirString, FComment.Link));
end;

function TFhirSlot.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'identifier') then
  begin
    IdentifierList.add(propValue as TFhirIdentifier);
    result := propValue;
  end
  else if (propName = 'serviceCategory') then
  begin
    ServiceCategoryList.add(propValue as TFhirCodeableConcept);
    result := propValue;
  end
  else if (propName = 'serviceType') then
  begin
    ServiceTypeList.add(propValue as TFhirCodeableReference);
    result := propValue;
  end
  else if (propName = 'specialty') then
  begin
    SpecialtyList.add(propValue as TFhirCodeableConcept);
    result := propValue;
  end
  else if (propName = 'appointmentType') then
  begin
    AppointmentTypeList.add(propValue as TFhirCodeableConcept);
    result := propValue;
  end
  else if (propName = 'schedule') then
  begin
    Schedule := propValue as TFhirReference;
    result := propValue;
  end
  else if (propName = 'status') then
  begin
    StatusElement := asEnum(SYSTEMS_TFhirSlotStatusEnum, CODES_TFhirSlotStatusEnum, propValue);
    result := propValue;
  end
  else if (propName = 'start') then
  begin
    StartElement := asInstant(propValue);
    result := propValue;
  end
  else if (propName = 'end') then
  begin
    End_Element := asInstant(propValue);
    result := propValue;
  end
  else if (propName = 'overbooked') then
  begin
    OverbookedElement := asBoolean(propValue);
    result := propValue;
  end
  else if (propName = 'comment') then
  begin
    CommentElement := asString(propValue);
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirSlot.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'identifier') then IdentifierList.insertItem(index, propValue as TFhirIdentifier)
  else if (propName = 'serviceCategory') then ServiceCategoryList.insertItem(index, propValue as TFhirCodeableConcept)
  else if (propName = 'serviceType') then ServiceTypeList.insertItem(index, propValue as TFhirCodeableReference)
  else if (propName = 'specialty') then SpecialtyList.insertItem(index, propValue as TFhirCodeableConcept)
  else if (propName = 'appointmentType') then AppointmentTypeList.insertItem(index, propValue as TFhirCodeableConcept)
  else inherited;
end;

function TFhirSlot.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'identifier') then result := IdentifierList.new()
  else if (propName = 'serviceCategory') then result := ServiceCategoryList.new()
  else if (propName = 'serviceType') then result := ServiceTypeList.new()
  else if (propName = 'specialty') then result := SpecialtyList.new()
  else if (propName = 'appointmentType') then result := AppointmentTypeList.new()
  else if (propName = 'schedule') then result := TFhirReference.create()
  else if (propName = 'status') then result := TFhirEnum.create(SYSTEMS_TFhirSlotStatusEnum[SlotStatusNull], CODES_TFhirSlotStatusEnum[SlotStatusNull]) 
  else if (propName = 'start') then result := TFhirInstant.create()
  else if (propName = 'end') then result := TFhirInstant.create()
  else if (propName = 'overbooked') then result := TFhirBoolean.create()
  else if (propName = 'comment') then result := TFhirString.create()
  else result := inherited createPropertyValue(propName);
end;

function TFhirSlot.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'identifier') then result := 'Identifier'
  else if (propName = 'serviceCategory') then result := 'CodeableConcept'
  else if (propName = 'serviceType') then result := 'CodeableReference'
  else if (propName = 'specialty') then result := 'CodeableConcept'
  else if (propName = 'appointmentType') then result := 'CodeableConcept'
  else if (propName = 'schedule') then result := 'Reference'
  else if (propName = 'status') then result := 'code'
  else if (propName = 'start') then result := 'instant'
  else if (propName = 'end') then result := 'instant'
  else if (propName = 'overbooked') then result := 'boolean'
  else if (propName = 'comment') then result := 'string'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirSlot.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'identifier') then deletePropertyValue('identifier', IdentifierList, value)
  else if (propName = 'serviceCategory') then deletePropertyValue('serviceCategory', ServiceCategoryList, value)
  else if (propName = 'serviceType') then deletePropertyValue('serviceType', ServiceTypeList, value)
  else if (propName = 'specialty') then deletePropertyValue('specialty', SpecialtyList, value)
  else if (propName = 'appointmentType') then deletePropertyValue('appointmentType', AppointmentTypeList, value)
  else if (propName = 'schedule') then ScheduleElement := nil
  else if (propName = 'status') then StatusElement := nil
  else if (propName = 'start') then StartElement := nil
  else if (propName = 'end') then End_Element := nil
  else if (propName = 'overbooked') then OverbookedElement := nil
  else if (propName = 'comment') then CommentElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirSlot.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'identifier') then replacePropertyValue('identifier', IdentifierList, existing, new)
  else if (propName = 'serviceCategory') then replacePropertyValue('serviceCategory', ServiceCategoryList, existing, new)
  else if (propName = 'serviceType') then replacePropertyValue('serviceType', ServiceTypeList, existing, new)
  else if (propName = 'specialty') then replacePropertyValue('specialty', SpecialtyList, existing, new)
  else if (propName = 'appointmentType') then replacePropertyValue('appointmentType', AppointmentTypeList, existing, new)
  else if (propName = 'schedule') then ScheduleElement := new as TFhirReference
  else if (propName = 'status') then StatusElement := asEnum(SYSTEMS_TFhirSlotStatusEnum, CODES_TFhirSlotStatusEnum, new)
  else if (propName = 'start') then StartElement := asInstant(new)
  else if (propName = 'end') then End_Element := asInstant(new)
  else if (propName = 'overbooked') then OverbookedElement := asBoolean(new)
  else if (propName = 'comment') then CommentElement := asString(new)
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirSlot.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'identifier') then IdentifierList.move(source, destination)
  else if (propName = 'serviceCategory') then ServiceCategoryList.move(source, destination)
  else if (propName = 'serviceType') then ServiceTypeList.move(source, destination)
  else if (propName = 'specialty') then SpecialtyList.move(source, destination)
  else if (propName = 'appointmentType') then AppointmentTypeList.move(source, destination)
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirSlot.fhirType : string;
begin
  result := 'Slot';
end;

function TFhirSlot.Link : TFhirSlot;
begin
  result := TFhirSlot(inherited Link);
end;

function TFhirSlot.Clone : TFhirSlot;
begin
  result := TFhirSlot(inherited Clone);
end;

function TFhirSlot.equals(other : TObject) : boolean; 
var
  o : TFhirSlot;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirSlot)) then
    result := false
  else
  begin
    o := TFhirSlot(other);
    result := compareDeep(identifierList, o.identifierList, true) and compareDeep(serviceCategoryList, o.serviceCategoryList, true) and 
      compareDeep(serviceTypeList, o.serviceTypeList, true) and compareDeep(specialtyList, o.specialtyList, true) and 
      compareDeep(appointmentTypeList, o.appointmentTypeList, true) and compareDeep(scheduleElement, o.scheduleElement, true) and 
      compareDeep(statusElement, o.statusElement, true) and compareDeep(startElement, o.startElement, true) and 
      compareDeep(end_Element, o.end_Element, true) and compareDeep(overbookedElement, o.overbookedElement, true) and 
      compareDeep(commentElement, o.commentElement, true);
  end;
end;

function TFhirSlot.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FidentifierList) and isEmptyProp(FserviceCategoryList) and isEmptyProp(FserviceTypeList) and isEmptyProp(FspecialtyList) and isEmptyProp(FappointmentTypeList) and isEmptyProp(FSchedule) and isEmptyProp(FStatus) and isEmptyProp(FStart) and isEmptyProp(FEnd_) and isEmptyProp(FOverbooked) and isEmptyProp(FComment);
end;

procedure TFhirSlot.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('identifier');
  fields.add('serviceCategory');
  fields.add('serviceType');
  fields.add('specialty');
  fields.add('appointmentType');
  fields.add('schedule');
  fields.add('status');
  fields.add('start');
  fields.add('end');
  fields.add('overbooked');
  fields.add('comment');
end;

function TFhirSlot.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
  inc(result, FIdentifierList.sizeInBytes(magic));
  inc(result, FServiceCategoryList.sizeInBytes(magic));
  inc(result, FServiceTypeList.sizeInBytes(magic));
  inc(result, FSpecialtyList.sizeInBytes(magic));
  inc(result, FAppointmentTypeList.sizeInBytes(magic));
end;

function TFhirSlot.GetIdentifierList : TFhirIdentifierList;
begin
  if FIdentifierList = nil then
    FIdentifierList := TFhirIdentifierList.Create;
  result := FIdentifierList;
end;

function TFhirSlot.GetHasIdentifierList : boolean;
begin
  result := (FIdentifierList <> nil) and (FIdentifierList.count > 0);
end;

function TFhirSlot.GetServiceCategoryList : TFhirCodeableConceptList;
begin
  if FServiceCategoryList = nil then
    FServiceCategoryList := TFhirCodeableConceptList.Create;
  result := FServiceCategoryList;
end;

function TFhirSlot.GetHasServiceCategoryList : boolean;
begin
  result := (FServiceCategoryList <> nil) and (FServiceCategoryList.count > 0);
end;

function TFhirSlot.GetServiceTypeList : TFhirCodeableReferenceList;
begin
  if FServiceTypeList = nil then
    FServiceTypeList := TFhirCodeableReferenceList.Create;
  result := FServiceTypeList;
end;

function TFhirSlot.GetHasServiceTypeList : boolean;
begin
  result := (FServiceTypeList <> nil) and (FServiceTypeList.count > 0);
end;

function TFhirSlot.GetSpecialtyList : TFhirCodeableConceptList;
begin
  if FSpecialtyList = nil then
    FSpecialtyList := TFhirCodeableConceptList.Create;
  result := FSpecialtyList;
end;

function TFhirSlot.GetHasSpecialtyList : boolean;
begin
  result := (FSpecialtyList <> nil) and (FSpecialtyList.count > 0);
end;

function TFhirSlot.GetAppointmentTypeList : TFhirCodeableConceptList;
begin
  if FAppointmentTypeList = nil then
    FAppointmentTypeList := TFhirCodeableConceptList.Create;
  result := FAppointmentTypeList;
end;

function TFhirSlot.GetHasAppointmentTypeList : boolean;
begin
  result := (FAppointmentTypeList <> nil) and (FAppointmentTypeList.count > 0);
end;

procedure TFhirSlot.SetSchedule(value : TFhirReference);
begin
  FSchedule.free;
  FSchedule := value;
end;

procedure TFhirSlot.SetStatus(value : TFhirEnum);
begin
  FStatus.free;
  FStatus := value;
end;

function TFhirSlot.GetStatusST : TFhirSlotStatusEnum;
begin
  if FStatus = nil then
    result := TFhirSlotStatusEnum(0)
  else
    result := TFhirSlotStatusEnum(StringArrayIndexOfSensitive(CODES_TFhirSlotStatusEnum, FStatus.value));
end;

procedure TFhirSlot.SetStatusST(value : TFhirSlotStatusEnum);
begin
  if ord(value) = 0 then
    StatusElement := nil
  else
    StatusElement := TFhirEnum.create(SYSTEMS_TFhirSlotStatusEnum[value], CODES_TFhirSlotStatusEnum[value]);
end;

procedure TFhirSlot.SetStart(value : TFhirInstant);
begin
  FStart.free;
  FStart := value;
end;

function TFhirSlot.GetStartST : TFslDateTime;
begin
  if FStart = nil then
    result := TFslDateTime.makeNull
  else
    result := FStart.value;
end;

procedure TFhirSlot.SetStartST(value : TFslDateTime);
begin
  if FStart = nil then
    FStart := TFhirInstant.create;
  FStart.value := value
end;

procedure TFhirSlot.SetEnd_(value : TFhirInstant);
begin
  FEnd_.free;
  FEnd_ := value;
end;

function TFhirSlot.GetEnd_ST : TFslDateTime;
begin
  if FEnd_ = nil then
    result := TFslDateTime.makeNull
  else
    result := FEnd_.value;
end;

procedure TFhirSlot.SetEnd_ST(value : TFslDateTime);
begin
  if FEnd_ = nil then
    FEnd_ := TFhirInstant.create;
  FEnd_.value := value
end;

procedure TFhirSlot.SetOverbooked(value : TFhirBoolean);
begin
  FOverbooked.free;
  FOverbooked := value;
end;

function TFhirSlot.GetOverbookedST : Boolean;
begin
  if FOverbooked = nil then
    result := false
  else
    result := FOverbooked.value;
end;

procedure TFhirSlot.SetOverbookedST(value : Boolean);
begin
  if FOverbooked = nil then
    FOverbooked := TFhirBoolean.create;
  FOverbooked.value := value
end;

procedure TFhirSlot.SetComment(value : TFhirString);
begin
  FComment.free;
  FComment := value;
end;

function TFhirSlot.GetCommentST : String;
begin
  if FComment = nil then
    result := ''
  else
    result := FComment.value;
end;

procedure TFhirSlot.SetCommentST(value : String);
begin
  if value <> '' then
  begin
    if FComment = nil then
      FComment := TFhirString.create;
    FComment.value := value
  end
  else if FComment <> nil then
    FComment.value := '';
end;

{ TFhirSlotListEnumerator }

constructor TFhirSlotListEnumerator.Create(list : TFhirSlotList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirSlotListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirSlotListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirSlotListEnumerator.GetCurrent : TFhirSlot;
begin
  Result := FList[FIndex];
end;

function TFhirSlotListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirSlotList }

function TFhirSlotList.AddItem(value: TFhirSlot): TFhirSlot;
begin
  assert(value.ClassName = 'TFhirSlot', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirSlot');
  add(value);
  result := value;
end;

function TFhirSlotList.Append: TFhirSlot;
begin
  result := TFhirSlot.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirSlotList.ClearItems;
begin
  Clear;
end;

function TFhirSlotList.GetEnumerator : TFhirSlotListEnumerator;
begin
  result := TFhirSlotListEnumerator.Create(self.link);
end;

function TFhirSlotList.Clone: TFhirSlotList;
begin
  result := TFhirSlotList(inherited Clone);
end;

function TFhirSlotList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirSlotList.GetItemN(index: Integer): TFhirSlot;
begin
  result := TFhirSlot(ObjectByIndex[index]);
end;

function TFhirSlotList.ItemClass: TFslObjectClass;
begin
  result := TFhirSlot;
end;
function TFhirSlotList.IndexOf(value: TFhirSlot): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirSlotList.Insert(index: Integer): TFhirSlot;
begin
  result := TFhirSlot.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirSlotList.InsertItem(index: Integer; value: TFhirSlot);
begin
  assert(value is TFhirSlot);
  Inherited Insert(index, value);
end;

function TFhirSlotList.Item(index: Integer): TFhirSlot;
begin
  result := TFhirSlot(ObjectByIndex[index]);
end;

function TFhirSlotList.Link: TFhirSlotList;
begin
  result := TFhirSlotList(inherited Link);
end;

procedure TFhirSlotList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirSlotList.SetItemByIndex(index: Integer; value: TFhirSlot);
begin
  assert(value is TFhirSlot);
  FhirSlots[index] := value;
end;

procedure TFhirSlotList.SetItemN(index: Integer; value: TFhirSlot);
begin
  assert(value is TFhirSlot);
  ObjectByIndex[index] := value;
end;

{$ENDIF FHIR_SLOT}


end.

